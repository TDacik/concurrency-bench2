// #anon_enum_CONNECTION_OK=0_CONNECTION_BAD=1_CONNECTION_STARTED=2_CONNECTION_MADE=3_CONNECTION_AWAITING_RESPONSE=4_CONNECTION_AUTH_OK=5_CONNECTION_SETENV=6_CONNECTION_SSL_STARTUP=7_CONNECTION_NEEDED=8
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 47
enum anonymous_24 { CONNECTION_OK=0, CONNECTION_BAD=1, CONNECTION_STARTED=2, CONNECTION_MADE=3, CONNECTION_AWAITING_RESPONSE=4, CONNECTION_AUTH_OK=5, CONNECTION_SETENV=6, CONNECTION_SSL_STARTUP=7, CONNECTION_NEEDED=8 };

// #anon_enum_PGASYNC_IDLE=0_PGASYNC_BUSY=1_PGASYNC_READY=2_PGASYNC_COPY_IN=3_PGASYNC_COPY_OUT=4_PGASYNC_COPY_BOTH=5
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 215
enum anonymous_9 { PGASYNC_IDLE=0, PGASYNC_BUSY=1, PGASYNC_READY=2, PGASYNC_COPY_IN=3, PGASYNC_COPY_OUT=4, PGASYNC_COPY_BOTH=5 };

// #anon_enum_PGEVT_REGISTER=0_PGEVT_CONNRESET=1_PGEVT_CONNDESTROY=2_PGEVT_RESULTCREATE=3_PGEVT_RESULTCOPY=4_PGEVT_RESULTDESTROY=5
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.h line 27
enum anonymous_13 { PGEVT_REGISTER=0, PGEVT_CONNRESET=1, PGEVT_CONNDESTROY=2, PGEVT_RESULTCREATE=3, PGEVT_RESULTCOPY=4, PGEVT_RESULTDESTROY=5 };

// #anon_enum_PGQUERY_SIMPLE=0_PGQUERY_EXTENDED=1_PGQUERY_PREPARE=2_PGQUERY_DESCRIBE=3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 226
enum anonymous_10 { PGQUERY_SIMPLE=0, PGQUERY_EXTENDED=1, PGQUERY_PREPARE=2, PGQUERY_DESCRIBE=3 };

// #anon_enum_PGRES_EMPTY_QUERY=0_PGRES_COMMAND_OK=1_PGRES_TUPLES_OK=2_PGRES_COPY_OUT=3_PGRES_COPY_IN=4_PGRES_BAD_RESPONSE=5_PGRES_NONFATAL_ERROR=6_PGRES_FATAL_ERROR=7_PGRES_COPY_BOTH=8_PGRES_SINGLE_TUPLE=9
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 78
enum anonymous_20 { PGRES_EMPTY_QUERY=0, PGRES_COMMAND_OK=1, PGRES_TUPLES_OK=2, PGRES_COPY_OUT=3, PGRES_COPY_IN=4, PGRES_BAD_RESPONSE=5, PGRES_NONFATAL_ERROR=6, PGRES_FATAL_ERROR=7, PGRES_COPY_BOTH=8, PGRES_SINGLE_TUPLE=9 };

// #anon_enum_PGRES_POLLING_FAILED=0_PGRES_POLLING_READING=1_PGRES_POLLING_WRITING=2_PGRES_POLLING_OK=3_PGRES_POLLING_ACTIVE=4
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 68
enum anonymous_4 { PGRES_POLLING_FAILED=0, PGRES_POLLING_READING=1, PGRES_POLLING_WRITING=2, PGRES_POLLING_OK=3, PGRES_POLLING_ACTIVE=4 };

// #anon_enum_PQERRORS_TERSE=0_PQERRORS_DEFAULT=1_PQERRORS_VERBOSE=2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 106
enum anonymous_5 { PQERRORS_TERSE=0, PQERRORS_DEFAULT=1, PQERRORS_VERBOSE=2 };

// #anon_enum_PQPING_OK=0_PQPING_REJECT=1_PQPING_NO_RESPONSE=2_PQPING_NO_ATTEMPT=3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 118
enum anonymous_25 { PQPING_OK=0, PQPING_REJECT=1, PQPING_NO_RESPONSE=2, PQPING_NO_ATTEMPT=3 };

// #anon_enum_PQTRANS_IDLE=0_PQTRANS_ACTIVE=1_PQTRANS_INTRANS=2_PQTRANS_INERROR=3_PQTRANS_UNKNOWN=4
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 97
enum anonymous_3 { PQTRANS_IDLE=0, PQTRANS_ACTIVE=1, PQTRANS_INTRANS=2, PQTRANS_INERROR=3, PQTRANS_UNKNOWN=4 };

// #anon_enum_SETENV_STATE_CLIENT_ENCODING_SEND=0_SETENV_STATE_CLIENT_ENCODING_WAIT=1_SETENV_STATE_OPTION_SEND=2_SETENV_STATE_OPTION_WAIT=3_SETENV_STATE_QUERY1_SEND=4_SETENV_STATE_QUERY1_WAIT=5_SETENV_STATE_QUERY2_SEND=6_SETENV_STATE_QUERY2_WAIT=7_SETENV_STATE_IDLE=8
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 236
enum anonymous_11 { SETENV_STATE_CLIENT_ENCODING_SEND=0, SETENV_STATE_CLIENT_ENCODING_WAIT=1, SETENV_STATE_OPTION_SEND=2, SETENV_STATE_OPTION_WAIT=3, SETENV_STATE_QUERY1_SEND=4, SETENV_STATE_QUERY1_WAIT=5, SETENV_STATE_QUERY2_SEND=6, SETENV_STATE_QUERY2_WAIT=7, SETENV_STATE_IDLE=8 };

// tag-#anon#ST[*{S32(*{cU8}_cU8_|*{U32}_U32_|S32)->S32}_S32(*{cU8}_cU8_|*{U32}_U32_|S32)->S32_'mb2wchar_with_len'||*{S32(*{cU32}_cU32_|*{U8}_U8_|S32)->S32}_S32(*{cU32}_cU32_|*{U8}_U8_|S32)->S32_'wchar2mb_with_len'||*{S32(*{cU8}_cU8_)->S32}_S32(*{cU8}_cU8_)->S32_'mblen'||*{S32(*{cU8}_cU8_)->S32}_S32(*{cU8}_cU8_)->S32_'dsplen'||*{S32(*{cU8}_cU8_|S32)->S32}_S32(*{cU8}_cU8_|S32)->S32_'mbverify'||S32'maxmblen'||U32'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/mb/pg_wchar.h line 354
struct anonymous_27;

// tag-#anon#ST[*{S8}_S8_'line'||S32'command_num'||S32'type'||S32'argc'||U32'_pad0'||ARR10{*{S8}_S8_}_*{S8}_S8__'argv'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 267
struct anonymous_22;

// tag-#anon#ST[*{S8}_S8_'name'||*{S8}_S8_'value'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 183
struct anonymous_21;

// tag-#anon#ST[*{SYM#tag-pg_conn#}_SYM#tag-pg_conn#_'con'||S32'id'||S32'state'||S32'cnt'||S32'ecnt'||S32'listen'||S32'sleeping'||S8'throttling'||U56'_pad0'||*{SYM#tag-#anon#ST[*{S8}_S8_'name'||*{S8}_S8_'value'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'name'||*{S8}_S8_'value'|]#_'variables'||S32'nvariables'||U32'_pad1'||S64'txn_scheduled'||SYM#tag-timeval#'txn_begin'||SYM#tag-timeval#'stmt_begin'||S64'txn_latencies'||S64'txn_sqlats'||S8'is_throttled'||U24'_pad2'||S32'use_file'||ARR128{S8}_S8_'prepared'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 196
struct anonymous_18;

// tag-#anon#ST[*{SYM#tag-pg_conn#}_SYM#tag-pg_conn#_'conn'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.h line 37
struct anonymous_14;

// tag-#anon#ST[*{SYM#tag-pg_conn#}_SYM#tag-pg_conn#_'conn'||*{SYM#tag-pg_result#}_SYM#tag-pg_result#_'result'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.h line 52
struct anonymous_15;

// tag-#anon#ST[*{SYM#tag-pg_result#}_SYM#tag-pg_result#_'result'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.h line 64
struct anonymous_37;

// tag-#anon#ST[*{V(*{V}_V_|*{cSYM#tag-pg_result#}_cSYM#tag-pg_result#_)->V}_V(*{V}_V_|*{cSYM#tag-pg_result#}_cSYM#tag-pg_result#_)->V_'noticeRec'||*{V}_V_'noticeRecArg'||*{V(*{V}_V_|*{cS8}_cS8_)->V}_V(*{V}_V_|*{cS8}_cS8_)->V_'noticeProc'||*{V}_V_'noticeProcArg'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 152
struct anonymous_8;

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_47;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_45;

// tag-#anon#ST[*{cSYM#tag-pg_result#}_cSYM#tag-pg_result#_'src'||*{SYM#tag-pg_result#}_SYM#tag-pg_result#_'dest'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.h line 58
struct anonymous_36;

// tag-#anon#ST[ARR128{U8}_U8_'cert_verify_md'||ARR128{U8}_U8_'finish_md'||S32'finish_md_len'||ARR128{U8}_U8_'peer_finish_md'||S32'peer_finish_md_len'||U64'message_size'||S32'message_type'||U32'_pad0'||*{cSYM#tag-ssl_cipher_st#}_cSYM#tag-ssl_cipher_st#_'new_cipher'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ecdh'||S32'next_state'||S32'reuse_message'||S32'cert_req'||S32'ctype_num'||ARR9{S8}_S8_'ctype'||U56'_pad1'||*{SYM#tag-stack_st_X509_NAME#}_SYM#tag-stack_st_X509_NAME#_'ca_names'||S32'use_rsa_tmp'||S32'key_block_length'||*{U8}_U8_'key_block'||*{cSYM#tag-evp_cipher_st#}_cSYM#tag-evp_cipher_st#_'new_sym_enc'||*{cSYM#tag-env_md_st#}_cSYM#tag-env_md_st#_'new_hash'||S32'new_mac_pkey_type'||S32'new_mac_secret_size'||*{cSYM#tag-ssl_comp_st#}_cSYM#tag-ssl_comp_st#_'new_compression'||S32'cert_request'||U32'_pad2'|]
// file /usr/include/openssl/ssl3.h line 553
struct anonymous_1;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_28;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_6;

// tag-#anon#ST[S32'len'||S32'isint'||SYM#tag-#anon#UN[*{S32}_S32_'ptr'||S32'integer'|]#'u'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 209
struct anonymous_33;

// tag-#anon#ST[S32'sess_connect'||S32'sess_connect_renegotiate'||S32'sess_connect_good'||S32'sess_accept'||S32'sess_accept_renegotiate'||S32'sess_accept_good'||S32'sess_miss'||S32'sess_timeout'||S32'sess_cache_full'||S32'sess_hit'||S32'sess_cb_hit'|]
// file /usr/include/openssl/ssl.h line 964
struct anonymous_49;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_41;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_44;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_43;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_40;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_42;

// tag-#anon#ST[S32'tid'||U32'_pad0'||U64'thread'||*{SYM#tag-#anon#ST[*{SYM#tag-pg_conn#}_SYM#tag-pg_conn#_'con'||S32'id'||S32'state'||S32'cnt'||S32'ecnt'||S32'listen'||S32'sleeping'||S8'throttling'||U56'_pad0'||*{SYM#tag-#anon#ST[*{S8}_S8_'name'||*{S8}_S8_'value'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'name'||*{S8}_S8_'value'|]#_'variables'||S32'nvariables'||U32'_pad1'||S64'txn_scheduled'||SYM#tag-timeval#'txn_begin'||SYM#tag-timeval#'stmt_begin'||S64'txn_latencies'||S64'txn_sqlats'||S8'is_throttled'||U24'_pad2'||S32'use_file'||ARR128{S8}_S8_'prepared'|]#}_SYM#tag-#anon#ST[*{SYM#tag-pg_conn#}_SYM#tag-pg_conn#_'con'||S32'id'||S32'state'||S32'cnt'||S32'ecnt'||S32'listen'||S32'sleeping'||S8'throttling'||U56'_pad0'||*{SYM#tag-#anon#ST[*{S8}_S8_'name'||*{S8}_S8_'value'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'name'||*{S8}_S8_'value'|]#_'variables'||S32'nvariables'||U32'_pad1'||S64'txn_scheduled'||SYM#tag-timeval#'txn_begin'||SYM#tag-timeval#'stmt_begin'||S64'txn_latencies'||S64'txn_sqlats'||S8'is_throttled'||U24'_pad2'||S32'use_file'||ARR128{S8}_S8_'prepared'|]#_'state'||S32'nstate'||U32'_pad1'||SYM#tag-timeval#'start_time'||*{SYM#tag-timeval#}_SYM#tag-timeval#_'exec_elapsed'||*{S32}_S32_'exec_count'||ARR3{U16}_U16_'random_state'||U16'_pad2'||S64'throttle_trigger'||S64'throttle_lag'||S64'throttle_lag_max'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 222
struct anonymous_17;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_46;

// tag-#anon#ST[S64'start_time'||S32'cnt'||U32'_pad0'||F64'min_latency'||F64'max_latency'||F64'sum_latency'||F64'sum2_latency'||F64'min_lag'||F64'max_lag'||F64'sum_lag'||F64'sum2_lag'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 276
struct anonymous_19;

// tag-#anon#ST[SYM#tag-sockaddr_storage#'addr'||U32'salen'||U32'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/libpq/pqcomm.h line 62
struct anonymous_7;

// tag-#anon#ST[SYM#tag-timeval#'conn_time'||S64'xacts'||S64'latencies'||S64'sqlats'||S64'throttle_lag'||S64'throttle_lag_max'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 239
struct anonymous_30;

// tag-#anon#ST[U32'conn_id_length'||U32'cert_type'||U32'cert_length'||U32'csl'||U32'clear'||U32'enc'||ARR32{U8}_U8_'ccl'||U32'cipher_spec_length'||U32'session_id_length'||U32'clen'||U32'rlen'|]
// file /usr/include/openssl/ssl2.h line 203
struct anonymous;

// tag-#anon#UN[*{S32}_S32_'ptr'||S32'integer'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 213
union anonymous_35;

// tag-#anon#UN[*{S8}_S8_'ptr'||*{SYM#tag-rsa_st#}_SYM#tag-rsa_st#_'rsa'||*{SYM#tag-dsa_st#}_SYM#tag-dsa_st#_'dsa'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ec'|]
// file /usr/include/openssl/evp.h line 135
union anonymous_50;

// tag-#anon#UN[*{S8}_S8_'ptr'||S32'boolean'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'asn1_string'||*{SYM#tag-asn1_object_st#}_SYM#tag-asn1_object_st#_'object'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'integer'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'enumerated'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bit_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'octet_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'printablestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'t61string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'ia5string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bmpstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'universalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utctime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalizedtime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'visiblestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utf8string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'set'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'sequence'||*{SYM#tag-ASN1_VALUE_st#}_SYM#tag-ASN1_VALUE_st#_'asn1_value'|]
// file /usr/include/openssl/asn1.h line 526
union anonymous_12;

// tag-#anon#UN[*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'ifu_broadaddr'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'ifu_dstaddr'|]
// file /usr/include/ifaddrs.h line 38
union anonymous_23;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_39;

// tag-#anon#UN[*{V(S32|S32|*{V}_V_)->V}_V(S32|S32|*{V}_V_)->V_'cb_1'||*{S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32}_S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32_'cb_2'|]
// file /usr/include/openssl/bn.h line 351
union anonymous_51;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_32;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_48;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_0;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_2;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_31;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_29;

// tag-ASIdentifiers_st
// file /usr/include/openssl/x509.h line 293
struct ASIdentifiers_st;

// tag-ASN1_ENCODING_st
// file /usr/include/openssl/asn1.h line 257
struct ASN1_ENCODING_st;

// tag-ASN1_VALUE_st
// file /usr/include/openssl/asn1.h line 299
struct ASN1_VALUE_st;

// tag-AUTHORITY_KEYID_st
// file /usr/include/openssl/ossl_typ.h line 186
struct AUTHORITY_KEYID_st;

// tag-CancelRequestPacket
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/libpq/pqcomm.h line 189
struct CancelRequestPacket;

// tag-DSA_SIG_st
// file /usr/include/openssl/dsa.h line 124
struct DSA_SIG_st;

// tag-ForkNumber
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/relpath.h line 24
enum ForkNumber { InvalidForkNumber=-1, MAIN_FORKNUM=0, FSM_FORKNUM=1, VISIBILITYMAP_FORKNUM=2, INIT_FORKNUM=3 };

// tag-ISSUING_DIST_POINT_st
// file /usr/include/openssl/ossl_typ.h line 188
struct ISSUING_DIST_POINT_st;

// tag-NAME_CONSTRAINTS_st
// file /usr/include/openssl/ossl_typ.h line 189
struct NAME_CONSTRAINTS_st;

// tag-PGEvent
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 160
struct PGEvent;

// tag-PQEnvironmentOption
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 250
struct PQEnvironmentOption;

// tag-PQExpBufferData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 44
struct PQExpBufferData;

// tag-QueryMode
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 256
enum QueryMode { QUERY_SIMPLE=0, QUERY_EXTENDED=1, QUERY_PREPARED=2, NUM_QUERYMODE=3 };

// tag-StartupPacket
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/libpq/pqcomm.h line 141
struct StartupPacket;

// tag-X509_POLICY_CACHE_st
// file /usr/include/openssl/ossl_typ.h line 184
struct X509_POLICY_CACHE_st;

// tag-X509_POLICY_TREE_st
// file /usr/include/openssl/ossl_typ.h line 183
struct X509_POLICY_TREE_st;

// tag-X509_VERIFY_PARAM_ID_st
// file /usr/include/openssl/x509_vfy.h line 159
struct X509_VERIFY_PARAM_ID_st;

// tag-X509_VERIFY_PARAM_st
// file /usr/include/openssl/x509_vfy.h line 167
struct X509_VERIFY_PARAM_st;

// tag-X509_algor_st
// file /usr/include/openssl/ossl_typ.h line 155
struct X509_algor_st;

// tag-X509_crl_info_st
// file /usr/include/openssl/x509.h line 441
struct X509_crl_info_st;

// tag-X509_crl_st
// file /usr/include/openssl/ossl_typ.h line 156
struct X509_crl_st;

// tag-X509_name_st
// file /usr/include/openssl/ossl_typ.h line 159
struct X509_name_st;

// tag-X509_pubkey_st
// file /usr/include/openssl/ossl_typ.h line 160
struct X509_pubkey_st;

// tag-X509_val_st
// file /usr/include/openssl/x509.h line 152
struct X509_val_st;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_PQconninfoOption
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 190
struct _PQconninfoOption;

// tag-_PQprintOpt
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 166
struct _PQprintOpt;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__rlimit_resource
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 31
enum __rlimit_resource { RLIMIT_CPU=0, RLIMIT_FSIZE=1, RLIMIT_DATA=2, RLIMIT_STACK=3, RLIMIT_CORE=4, __RLIMIT_RSS=5, RLIMIT_NOFILE=7, __RLIMIT_OFILE=7, RLIMIT_AS=9, __RLIMIT_NPROC=6, __RLIMIT_MEMLOCK=8, __RLIMIT_LOCKS=10, __RLIMIT_SIGPENDING=11, __RLIMIT_MSGQUEUE=12, __RLIMIT_NICE=13, __RLIMIT_RTPRIO=14, __RLIMIT_RTTIME=15, __RLIMIT_NLIMITS=16, __RLIM_NLIMITS=16 };

// tag-_internalPQconninfoOption
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 145
struct _internalPQconninfoOption;

// tag-_pqueue
// file /usr/include/openssl/pqueue.h line 70
struct _pqueue;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-asn1_object_st
// file /usr/include/openssl/ossl_typ.h line 103
struct asn1_object_st;

// tag-asn1_string_st
// file /usr/include/openssl/ossl_typ.h line 83
struct asn1_string_st;

// tag-asn1_type_st
// file /usr/include/openssl/asn1.h line 524
struct asn1_type_st;

// tag-berval
// file /usr/include/lber.h line 212
struct berval;

// tag-bignum_ctx
// file /usr/include/openssl/ossl_typ.h line 121
struct bignum_ctx;

// tag-bignum_st
// file /usr/include/openssl/ossl_typ.h line 120
struct bignum_st;

// tag-bio_method_st
// file /usr/include/openssl/bio.h line 312
struct bio_method_st;

// tag-bio_st
// file /usr/include/openssl/crypto.h line 290
struct bio_st;

// tag-bn_blinding_st
// file /usr/include/openssl/ossl_typ.h line 122
struct bn_blinding_st;

// tag-bn_gencb_st
// file /usr/include/openssl/ossl_typ.h line 125
struct bn_gencb_st;

// tag-bn_mont_ctx_st
// file /usr/include/openssl/ossl_typ.h line 123
struct bn_mont_ctx_st;

// tag-buf_mem_st
// file /usr/include/openssl/ossl_typ.h line 127
struct buf_mem_st;

// tag-cert_st
// file /usr/include/openssl/ssl.h line 1035
struct cert_st;

// tag-comp_ctx_st
// file /usr/include/openssl/comp.h line 11
struct comp_ctx_st;

// tag-comp_method_st
// file /usr/include/openssl/comp.h line 13
struct comp_method_st;

// tag-crypto_ex_data_st
// file /usr/include/openssl/ossl_typ.h line 195
struct crypto_ex_data_st;

// tag-dh_method
// file /usr/include/openssl/ossl_typ.h line 141
struct dh_method;

// tag-dh_st
// file /usr/include/openssl/ossl_typ.h line 140
struct dh_st;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-dsa_method
// file /usr/include/openssl/ossl_typ.h line 144
struct dsa_method;

// tag-dsa_st
// file /usr/include/openssl/ossl_typ.h line 143
struct dsa_st;

// tag-dtls1_bitmap_st
// file /usr/include/openssl/dtls1.h line 128
struct dtls1_bitmap_st;

// tag-dtls1_retransmit_state
// file /usr/include/openssl/dtls1.h line 135
struct dtls1_retransmit_state;

// tag-dtls1_state_st
// file /usr/include/openssl/ssl.h line 1493
struct dtls1_state_st;

// tag-dtls1_timeout_st
// file /usr/include/openssl/dtls1.h line 162
struct dtls1_timeout_st;

// tag-ec_key_st
// file /usr/include/openssl/evp.h line 147
struct ec_key_st;

// tag-encoding_match
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/chklocale.c line 40
struct encoding_match;

// tag-engine_st
// file /usr/include/openssl/ossl_typ.h line 177
struct engine_st;

// tag-env_md_ctx_st
// file /usr/include/openssl/ossl_typ.h line 132
struct env_md_ctx_st;

// tag-env_md_st
// file /usr/include/openssl/ossl_typ.h line 131
struct env_md_st;

// tag-evp_cipher_ctx_st
// file /usr/include/openssl/ossl_typ.h line 130
struct evp_cipher_ctx_st;

// tag-evp_cipher_st
// file /usr/include/openssl/ossl_typ.h line 129
struct evp_cipher_st;

// tag-evp_pkey_asn1_method_st
// file /usr/include/openssl/ossl_typ.h line 135
struct evp_pkey_asn1_method_st;

// tag-evp_pkey_ctx_st
// file /usr/include/openssl/ossl_typ.h line 138
struct evp_pkey_ctx_st;

// tag-evp_pkey_st
// file /usr/include/openssl/ossl_typ.h line 133
struct evp_pkey_st;

// tag-gss_OID_desc_struct
// file /usr/include/mit-krb5/gssapi/gssapi.h line 106
struct gss_OID_desc_struct;

// tag-gss_buffer_desc_struct
// file /usr/include/mit-krb5/gssapi/gssapi.h line 117
struct gss_buffer_desc_struct;

// tag-gss_channel_bindings_struct
// file /usr/include/mit-krb5/gssapi/gssapi.h line 122
struct gss_channel_bindings_struct;

// tag-gss_cred_id_struct
// file /usr/include/mit-krb5/gssapi/gssapi.h line 81
struct gss_cred_id_struct;

// tag-gss_ctx_id_struct
// file /usr/include/mit-krb5/gssapi/gssapi.h line 84
struct gss_ctx_id_struct;

// tag-gss_name_struct
// file /usr/include/mit-krb5/gssapi/gssapi.h line 78
struct gss_name_struct;

// tag-hm_header_st
// file /usr/include/openssl/dtls1.h line 147
struct hm_header_st;

// tag-hmac_ctx_st
// file /usr/include/openssl/hmac.h line 75
struct hmac_ctx_st;

// tag-ifaddrs
// file /usr/include/ifaddrs.h line 29
struct ifaddrs;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-ldap
// file /usr/include/ldap.h line 752
struct ldap;

// tag-ldapmsg
// file /usr/include/ldap.h line 721
struct ldapmsg;

// tag-lhash_st_SSL_SESSION
// file /usr/include/openssl/ssl.h line 923
struct lhash_st_SSL_SESSION;

// tag-mbinterval
// file wchar.c line 576
struct mbinterval;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pgDataValue
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 288
struct pgDataValue;

// tag-pgLobjfuncs
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 266
struct pgLobjfuncs;

// tag-pgMessageField
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 144
struct pgMessageField;

// tag-pgNotify
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 150
struct pgNotify;

// tag-pgParameterStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 257
struct pgParameterStatus;

// tag-pg_cancel
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 142
struct pg_cancel;

// tag-pg_conn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 129
struct pg_conn;

// tag-pg_enc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/mb/pg_wchar.h line 236
enum pg_enc { PG_SQL_ASCII=0, PG_EUC_JP=1, PG_EUC_CN=2, PG_EUC_KR=3, PG_EUC_TW=4, PG_EUC_JIS_2004=5, PG_UTF8=6, PG_MULE_INTERNAL=7, PG_LATIN1=8, PG_LATIN2=9, PG_LATIN3=10, PG_LATIN4=11, PG_LATIN5=12, PG_LATIN6=13, PG_LATIN7=14, PG_LATIN8=15, PG_LATIN9=16, PG_LATIN10=17, PG_WIN1256=18, PG_WIN1258=19, PG_WIN866=20, PG_WIN874=21, PG_KOI8R=22, PG_WIN1251=23, PG_WIN1252=24, PG_ISO_8859_5=25, PG_ISO_8859_6=26, PG_ISO_8859_7=27, PG_ISO_8859_8=28, PG_WIN1250=29, PG_WIN1253=30, PG_WIN1254=31, PG_WIN1255=32, PG_WIN1257=33, PG_KOI8U=34, PG_SJIS=35, PG_BIG5=36, PG_GBK=37, PG_UHC=38, PG_GB18030=39, PG_JOHAB=40, PG_SHIFT_JIS_2004=41, _PG_LAST_ENCODING_=42 };

// tag-pg_enc2gettext
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/mb/pg_wchar.h line 327
struct pg_enc2gettext;

// tag-pg_enc2name
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/mb/pg_wchar.h line 313
struct pg_enc2name;

// tag-pg_encname
// file encnames.c line 32
struct pg_encname;

// tag-pg_result
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 136
struct pg_result;

// tag-pgresAttDesc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 224
struct pgresAttDesc;

// tag-pgresAttValue
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 137
struct pgresAttValue;

// tag-pgresParamDesc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 112
struct pgresParamDesc;

// tag-pgresult_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 103
union pgresult_data;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-record_pqueue_st
// file /usr/include/openssl/dtls1.h line 171
struct record_pqueue_st;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-rsa_meth_st
// file /usr/include/openssl/ossl_typ.h line 147
struct rsa_meth_st;

// tag-rsa_st
// file /usr/include/openssl/ossl_typ.h line 146
struct rsa_st;

// tag-sess_cert_st
// file /usr/include/openssl/ssl.h line 531
struct sess_cert_st;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigpipe_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 127
struct sigpipe_info;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-srp_ctx_st
// file /usr/include/openssl/ssl.h line 849
struct srp_ctx_st;

// tag-srtp_protection_profile_st
// file /usr/include/openssl/ssl.h line 383
struct srtp_protection_profile_st;

// tag-ssl2_state_st
// file /usr/include/openssl/ssl.h line 1491
struct ssl2_state_st;

// tag-ssl3_buf_freelist_st
// file /usr/include/openssl/ssl.h line 1114
struct ssl3_buf_freelist_st;

// tag-ssl3_buffer_st
// file /usr/include/openssl/ssl3.h line 438
struct ssl3_buffer_st;

// tag-ssl3_enc_method
// file /usr/include/openssl/ssl.h line 466
struct ssl3_enc_method;

// tag-ssl3_record_st
// file /usr/include/openssl/ssl3.h line 403
struct ssl3_record_st;

// tag-ssl3_state_st
// file /usr/include/openssl/ssl.h line 1492
struct ssl3_state_st;

// tag-ssl_cipher_st
// file /usr/include/openssl/ssl.h line 375
struct ssl_cipher_st;

// tag-ssl_comp_st
// file /usr/include/openssl/ssl.h line 908
struct ssl_comp_st;

// tag-ssl_ctx_st
// file /usr/include/openssl/ossl_typ.h line 179
struct ssl_ctx_st;

// tag-ssl_method_st
// file /usr/include/openssl/ssl.h line 374
struct ssl_method_st;

// tag-ssl_session_st
// file /usr/include/openssl/ssl.h line 376
struct ssl_session_st;

// tag-ssl_st
// file /usr/include/openssl/ossl_typ.h line 178
struct ssl_st;

// tag-stack_st
// file /usr/include/openssl/stack.h line 66
struct stack_st;

// tag-stack_st_ASN1_OBJECT
// file /usr/include/openssl/asn1.h line 793
struct stack_st_ASN1_OBJECT;

// tag-stack_st_DIST_POINT
// file /usr/include/openssl/x509.h line 288
struct stack_st_DIST_POINT;

// tag-stack_st_GENERAL_NAME
// file /usr/include/openssl/x509.h line 289
struct stack_st_GENERAL_NAME;

// tag-stack_st_GENERAL_NAMES
// file /usr/include/openssl/x509.h line 471
struct stack_st_GENERAL_NAMES;

// tag-stack_st_IPAddressFamily
// file /usr/include/openssl/x509.h line 292
struct stack_st_IPAddressFamily;

// tag-stack_st_OCSP_RESPID
// file /usr/include/openssl/ssl.h line 1610
struct stack_st_OCSP_RESPID;

// tag-stack_st_SRTP_PROTECTION_PROFILE
// file /usr/include/openssl/ssl.h line 388
struct stack_st_SRTP_PROTECTION_PROFILE;

// tag-stack_st_SSL_CIPHER
// file /usr/include/openssl/ssl.h line 380
struct stack_st_SSL_CIPHER;

// tag-stack_st_SSL_COMP
// file /usr/include/openssl/ssl.h line 922
struct stack_st_SSL_COMP;

// tag-stack_st_X509
// file /usr/include/openssl/x509.h line 301
struct stack_st_X509;

// tag-stack_st_X509_ALGOR
// file /usr/include/openssl/asn1.h line 162
struct stack_st_X509_ALGOR;

// tag-stack_st_X509_ATTRIBUTE
// file /usr/include/openssl/evp.h line 151
struct stack_st_X509_ATTRIBUTE;

// tag-stack_st_X509_CRL
// file /usr/include/openssl/x509.h line 476
struct stack_st_X509_CRL;

// tag-stack_st_X509_EXTENSION
// file /usr/include/openssl/x509.h line 202
struct stack_st_X509_EXTENSION;

// tag-stack_st_X509_LOOKUP
// file /usr/include/openssl/x509_vfy.h line 136
struct stack_st_X509_LOOKUP;

// tag-stack_st_X509_NAME
// file /usr/include/openssl/x509.h line 192
struct stack_st_X509_NAME;

// tag-stack_st_X509_NAME_ENTRY
// file /usr/include/openssl/x509.h line 175
struct stack_st_X509_NAME_ENTRY;

// tag-stack_st_X509_OBJECT
// file /usr/include/openssl/x509_vfy.h line 137
struct stack_st_X509_OBJECT;

// tag-stack_st_X509_REVOKED
// file /usr/include/openssl/x509.h line 438
struct stack_st_X509_REVOKED;

// tag-stack_st_void
// file /usr/include/openssl/crypto.h line 293
struct stack_st_void;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tls_session_ticket_ext_st
// file /usr/include/openssl/ssl.h line 373
struct tls_session_ticket_ext_st;

// tag-ucred
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 311
struct ucred;

// tag-ui_method_st
// file /usr/include/openssl/ossl_typ.h line 173
struct ui_method_st;

// tag-winsize
// file /usr/include/x86_64-linux-gnu/bits/ioctl-types.h line 27
struct winsize;

// tag-x509_cert_aux_st
// file /usr/include/openssl/x509.h line 262
struct x509_cert_aux_st;

// tag-x509_cinf_st
// file /usr/include/openssl/x509.h line 242
struct x509_cinf_st;

// tag-x509_crl_method_st
// file /usr/include/openssl/ossl_typ.h line 157
struct x509_crl_method_st;

// tag-x509_st
// file /usr/include/openssl/ossl_typ.h line 154
struct x509_st;

// tag-x509_store_ctx_st
// file /usr/include/openssl/ossl_typ.h line 162
struct x509_store_ctx_st;

// tag-x509_store_st
// file /usr/include/openssl/ossl_typ.h line 161
struct x509_store_st;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// CRYPTO_num_locks
// file /usr/include/openssl/crypto.h line 435
signed int CRYPTO_num_locks(void);
// CRYPTO_set_id_callback
// file /usr/include/openssl/crypto.h line 462
void CRYPTO_set_id_callback(unsigned long int (*)(void));
// CRYPTO_set_locking_callback
// file /usr/include/openssl/crypto.h line 437
void CRYPTO_set_locking_callback(void (*)(signed int, signed int, const char *, signed int));
// ENGINE_by_id
// file /usr/include/openssl/engine.h line 393
struct engine_st * ENGINE_by_id(const char *);
// ENGINE_finish
// file /usr/include/openssl/engine.h line 657
signed int ENGINE_finish(struct engine_st *);
// ENGINE_free
// file /usr/include/openssl/engine.h line 551
signed int ENGINE_free(struct engine_st *);
// ENGINE_init
// file /usr/include/openssl/engine.h line 651
signed int ENGINE_init(struct engine_st *);
// ENGINE_load_private_key
// file /usr/include/openssl/engine.h line 664
struct evp_pkey_st * ENGINE_load_private_key(struct engine_st *, const char *, struct ui_method_st *, void *);
// ERR_get_error
// file /usr/include/openssl/err.h line 321
unsigned long int ERR_get_error(void);
// ERR_reason_error_string
// file /usr/include/openssl/err.h line 338
const char * ERR_reason_error_string(unsigned long int);
// GetDatabasePath
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/relpath.c line 108
extern char * GetDatabasePath(unsigned int dbNode, unsigned int spcNode);
// GetRelationPath
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/relpath.c line 139
extern char * GetRelationPath(unsigned int dbNode, unsigned int spcNode, unsigned int relNode, signed int backendId, enum ForkNumber forkNumber);
// OPENSSL_config
// file /usr/include/openssl/conf.h line 139
void OPENSSL_config(const char *);
// PQbackendPID
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5461
extern signed int PQbackendPID(const struct pg_conn *conn);
// PQbinaryTuples
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2629
extern signed int PQbinaryTuples(const struct pg_result *res);
// PQcancel
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3320
extern signed int PQcancel(struct pg_cancel *cancel, char *errbuf, signed int errbufsize);
// PQclear
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 478
extern void PQclear(struct pg_result *res);
// PQclientEncoding
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5492
extern signed int PQclientEncoding(const struct pg_conn *conn);
// PQcmdStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2884
extern char * PQcmdStatus(struct pg_result *res);
// PQcmdTuples
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2954
extern char * PQcmdTuples(struct pg_result *res);
// PQconndefaults
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 919
extern struct _PQconninfoOption * PQconndefaults(void);
// PQconnectPoll
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1628
extern enum anonymous_4 PQconnectPoll(struct pg_conn *conn);
// PQconnectStart
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 637
extern struct pg_conn * PQconnectStart(const char *conninfo);
// PQconnectStartParams
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 558
extern struct pg_conn * PQconnectStartParams(const char * const *keywords, const char * const *values, signed int expand_dbname);
// PQconnectdb
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 511
extern struct pg_conn * PQconnectdb(const char *conninfo);
// PQconnectdbParams
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 251
extern struct pg_conn * PQconnectdbParams(const char * const *keywords, const char * const *values, signed int expand_dbname);
// PQconnectionNeedsPassword
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 316
extern signed int PQconnectionNeedsPassword(const struct pg_conn *conn);
// PQconnectionUsedPassword
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5481
extern signed int PQconnectionUsedPassword(const struct pg_conn *conn);
// PQconninfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5258
extern struct _PQconninfoOption * PQconninfo(struct pg_conn *conn);
// PQconninfoFree
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5299
extern void PQconninfoFree(struct _PQconninfoOption *connOptions);
// PQconninfoParse
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4121
extern struct _PQconninfoOption * PQconninfoParse(const char *conninfo, char **errmsg);
// PQconsumeInput
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 405
extern signed int PQconsumeInput(struct pg_conn *conn);
// PQcopyResult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 290
extern struct pg_result * PQcopyResult(const struct pg_result *src, signed int flags);
// PQdb
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5317
extern char * PQdb(const struct pg_conn *conn);
// PQdescribePortal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2060
extern struct pg_result * PQdescribePortal(struct pg_conn *conn, const char *portal);
// PQdescribePrepared
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2041
extern struct pg_result * PQdescribePrepared(struct pg_conn *conn, const char *stmt);
// PQdisplayTuples
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-print.c line 570
extern void PQdisplayTuples(const struct pg_result *res, struct _IO_FILE *fp, signed int fillAlign, const char *fieldSep, signed int printHeader, signed int quiet);
// PQdsplen
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 1195
extern signed int PQdsplen(const char *s, signed int encoding);
// PQencryptPassword
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 806
extern char * PQencryptPassword(const char *passwd, const char *user);
// PQendcopy
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 420
extern signed int PQendcopy(struct pg_conn *conn);
// PQenv2encoding
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 1204
extern signed int PQenv2encoding(void);
// PQerrorMessage
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 313
extern char * PQerrorMessage(const struct pg_conn *conn);
// PQescapeBytea
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3570
extern unsigned char * PQescapeBytea(const unsigned char *from, unsigned long int from_length, unsigned long int *to_length);
// PQescapeByteaConn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3558
extern unsigned char * PQescapeByteaConn(struct pg_conn *conn, const unsigned char *from, unsigned long int from_length, unsigned long int *to_length);
// PQescapeByteaInternal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3461
static unsigned char * PQescapeByteaInternal(struct pg_conn *conn, const unsigned char *from, unsigned long int from_length, unsigned long int *to_length, char std_strings, char use_hex);
// PQescapeIdentifier
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 502
extern char * PQescapeIdentifier(struct pg_conn *conn, const char *str, unsigned long int len);
// PQescapeInternal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3287
static char * PQescapeInternal(struct pg_conn *conn, const char *str, unsigned long int len, char as_ident);
// PQescapeLiteral
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3408
extern char * PQescapeLiteral(struct pg_conn *conn, const char *str, unsigned long int len);
// PQescapeString
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3272
extern unsigned long int PQescapeString(char *to, const char *from, unsigned long int length);
// PQescapeStringConn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3254
extern unsigned long int PQescapeStringConn(struct pg_conn *conn, char *to, const char *from, unsigned long int length, signed int *error);
// PQescapeStringInternal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3179
static unsigned long int PQescapeStringInternal(struct pg_conn *conn, char *to, const char *from, unsigned long int length, signed int *error, signed int encoding, char std_strings);
// PQexec
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 360
extern struct pg_result * PQexec(struct pg_conn *conn, const char *query);
// PQexecFinish
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1980
static struct pg_result * PQexecFinish(struct pg_conn *conn);
// PQexecParams
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1838
extern struct pg_result * PQexecParams(struct pg_conn *conn, const char *command, signed int nParams, const unsigned int *paramTypes, const char * const *paramValues, const signed int *paramLengths, const signed int *paramFormats, signed int resultFormat);
// PQexecPrepared
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1885
extern struct pg_result * PQexecPrepared(struct pg_conn *conn, const char *stmtName, signed int nParams, const char * const *paramValues, const signed int *paramLengths, const signed int *paramFormats, signed int resultFormat);
// PQexecStart
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1906
static char PQexecStart(struct pg_conn *conn);
// PQfformat
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2840
extern signed int PQfformat(const struct pg_result *res, signed int field_num);
// PQfinish
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 262
extern void PQfinish(struct pg_conn *conn);
// PQfireResultCreateEvents
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.c line 185
extern signed int PQfireResultCreateEvents(struct pg_conn *conn, struct pg_result *res);
// PQflush
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3127
extern signed int PQflush(struct pg_conn *conn);
// PQfmod
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2873
extern signed int PQfmod(const struct pg_result *res, signed int field_num);
// PQfn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2534
extern struct pg_result * PQfn(struct pg_conn *conn, signed int fnid, signed int *result_buf, signed int *result_len, signed int result_is_int, const struct anonymous_33 *args, signed int nargs);
// PQfname
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2699
extern char * PQfname(const struct pg_result *res, signed int field_num);
// PQfnumber
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2721
extern signed int PQfnumber(const struct pg_result *res, const char *field_name);
// PQfreeCancel
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3188
extern void PQfreeCancel(struct pg_cancel *cancel);
// PQfreeNotify
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3157
void PQfreeNotify(struct pgNotify *notify);
// PQfreemem
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 481
extern void PQfreemem(void *ptr);
// PQfsize
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2862
extern signed int PQfsize(const struct pg_result *res, signed int field_num);
// PQftable
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2818
extern unsigned int PQftable(const struct pg_result *res, signed int field_num);
// PQftablecol
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2829
extern signed int PQftablecol(const struct pg_result *res, signed int field_num);
// PQftype
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2851
extern unsigned int PQftype(const struct pg_result *res, signed int field_num);
// PQgetCancel
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3165
extern struct pg_cancel * PQgetCancel(struct pg_conn *conn);
// PQgetCopyData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2355
extern signed int PQgetCopyData(struct pg_conn *conn, char **buffer, signed int async);
// PQgetResult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 401
extern struct pg_result * PQgetResult(struct pg_conn *conn);
// PQgetisnull
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3032
extern signed int PQgetisnull(const struct pg_result *res, signed int tup_num, signed int field_num);
// PQgetlength
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3018
extern signed int PQgetlength(const struct pg_result *res, signed int tup_num, signed int field_num);
// PQgetline
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2397
extern signed int PQgetline(struct pg_conn *conn, char *s, signed int maxlen);
// PQgetlineAsync
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2447
extern signed int PQgetlineAsync(struct pg_conn *conn, char *buffer, signed int bufsize);
// PQgetssl
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1648
extern void * PQgetssl(struct pg_conn *conn);
// PQgetvalue
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 465
extern char * PQgetvalue(const struct pg_result *res, signed int tup_num, signed int field_num);
// PQhost
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5341
extern char * PQhost(const struct pg_conn *conn);
// PQinitOpenSSL
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 205
extern void PQinitOpenSSL(signed int do_ssl, signed int do_crypto);
// PQinitSSL
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 195
extern void PQinitSSL(signed int do_init);
// PQinstanceData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.c line 121
extern void * PQinstanceData(const struct pg_conn *conn, signed int (*proc)(enum anonymous_13, void *, void *));

//

// PQisBusy
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 404
extern signed int PQisBusy(struct pg_conn *conn);
// PQisnonblocking
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3108
extern signed int PQisnonblocking(const struct pg_conn *conn);
// PQisthreadsafe
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3115
extern signed int PQisthreadsafe(void);
// PQlibVersion
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 72
extern signed int PQlibVersion(void);
// PQmakeEmptyPGresult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 140
extern struct pg_result * PQmakeEmptyPGresult(struct pg_conn *conn, enum anonymous_20 status);
// PQmblen
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 1185
extern signed int PQmblen(const char *s, signed int encoding);
// PQnfields
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2621
extern signed int PQnfields(const struct pg_result *res);
// PQnotifies
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2171
extern struct pgNotify * PQnotifies(struct pg_conn *conn);
// PQnparams
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3046
extern signed int PQnparams(const struct pg_result *res);
// PQntuples
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2613
extern signed int PQntuples(const struct pg_result *res);
// PQoidStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2897
extern char * PQoidStatus(const struct pg_result *res);
// PQoidValue
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2925
extern unsigned int PQoidValue(const struct pg_result *res);
// PQoptions
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5374
extern char * PQoptions(const struct pg_conn *conn);
// PQparameterStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5400
extern const char * PQparameterStatus(const struct pg_conn *conn, const char *paramName);
// PQparamtype
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3057
extern unsigned int PQparamtype(const struct pg_result *res, signed int param_num);
// PQpass
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5333
extern char * PQpass(const struct pg_conn *conn);
// PQping
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 527
extern enum anonymous_25 PQping(const char *conninfo);
// PQpingParams
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 474
extern enum anonymous_25 PQpingParams(const char * const *keywords, const char * const *values, signed int expand_dbname);
// PQport
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5358
extern char * PQport(const struct pg_conn *conn);
// PQprepare
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 369
extern struct pg_result * PQprepare(struct pg_conn *conn, const char *stmtName, const char *query, signed int nParams, const unsigned int *paramTypes);
// PQprint
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-print.c line 68
extern void PQprint(struct _IO_FILE *fout, const struct pg_result *res, const struct _PQprintOpt *po);
// PQprintTuples
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-print.c line 668
extern void PQprintTuples(const struct pg_result *res, struct _IO_FILE *fout, signed int PrintAttNames, signed int TerseOutput, signed int colWidth);
// PQprotocolVersion
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5415
extern signed int PQprotocolVersion(const struct pg_conn *conn);
// PQputCopyData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2199
extern signed int PQputCopyData(struct pg_conn *conn, const char *buffer, signed int nbytes);
// PQputCopyEnd
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2266
extern signed int PQputCopyEnd(struct pg_conn *conn, const char *errormsg);
// PQputline
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 417
extern signed int PQputline(struct pg_conn *conn, const char *s);
// PQputnbytes
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2477
extern signed int PQputnbytes(struct pg_conn *conn, const char *buffer, signed int nbytes);
// PQregisterEventProc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.c line 40
extern signed int PQregisterEventProc(struct pg_conn *conn, signed int (*proc)(enum anonymous_13, void *, void *), const char *name, void *passThrough);

//

// PQregisterThreadLock
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5920
extern void (*PQregisterThreadLock(void (*newhandler)(signed int)))(signed int);
// PQregisterThreadLock::1::prev_object
//
void prev_object(signed int);

//

// PQrequestCancel
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3345
extern signed int PQrequestCancel(struct pg_conn *conn);
// PQresStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2582
extern char * PQresStatus(enum anonymous_20 status);
// PQreset
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3058
extern void PQreset(struct pg_conn *conn);
// PQresetPoll
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3118
extern enum anonymous_4 PQresetPoll(struct pg_conn *conn);
// PQresetStart
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3099
extern signed int PQresetStart(struct pg_conn *conn);
// PQresultAlloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 489
extern void * PQresultAlloc(struct pg_result *res, unsigned long int nBytes);
// PQresultErrorField
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 449
extern char * PQresultErrorField(const struct pg_result *res, signed int fieldcode);
// PQresultErrorMessage
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 448
extern char * PQresultErrorMessage(const struct pg_result *res);
// PQresultInstanceData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.c line 165
extern void * PQresultInstanceData(const struct pg_result *result, signed int (*proc)(enum anonymous_13, void *, void *));

//

// PQresultSetInstanceData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.c line 142
extern signed int PQresultSetInstanceData(struct pg_result *result, signed int (*proc)(enum anonymous_13, void *, void *), void *data);

//

// PQresultStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 446
extern enum anonymous_20 PQresultStatus(const struct pg_result *res);
// PQsendDescribe
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2105
static signed int PQsendDescribe(struct pg_conn *conn, char desc_type, const char *desc_target);
// PQsendDescribePortal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2090
extern signed int PQsendDescribePortal(struct pg_conn *conn, const char *portal);
// PQsendDescribePrepared
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2077
extern signed int PQsendDescribePrepared(struct pg_conn *conn, const char *stmt);
// PQsendPrepare
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1208
extern signed int PQsendPrepare(struct pg_conn *conn, const char *stmtName, const char *query, signed int nParams, const unsigned int *paramTypes);
// PQsendQuery
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 381
extern signed int PQsendQuery(struct pg_conn *conn, const char *query);
// PQsendQueryGuts
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1387
static signed int PQsendQueryGuts(struct pg_conn *conn, const char *command, const char *stmtName, signed int nParams, const unsigned int *paramTypes, const char * const *paramValues, const signed int *paramLengths, const signed int *paramFormats, signed int resultFormat);
// PQsendQueryParams
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 382
extern signed int PQsendQueryParams(struct pg_conn *conn, const char *command, signed int nParams, const unsigned int *paramTypes, const char * const *paramValues, const signed int *paramLengths, const signed int *paramFormats, signed int resultFormat);
// PQsendQueryPrepared
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 393
extern signed int PQsendQueryPrepared(struct pg_conn *conn, const char *stmtName, signed int nParams, const char * const *paramValues, const signed int *paramLengths, const signed int *paramFormats, signed int resultFormat);
// PQsendQueryStart
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1345
static char PQsendQueryStart(struct pg_conn *conn);
// PQserverVersion
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5425
extern signed int PQserverVersion(const struct pg_conn *conn);
// PQsetClientEncoding
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5500
extern signed int PQsetClientEncoding(struct pg_conn *conn, const char *encoding);
// PQsetErrorVerbosity
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5546
extern enum anonymous_5 PQsetErrorVerbosity(struct pg_conn *conn, enum anonymous_5 verbosity);
// PQsetInstanceData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.c line 98
extern signed int PQsetInstanceData(struct pg_conn *conn, signed int (*proc)(enum anonymous_13, void *, void *), void *data);

//

// PQsetNoticeProcessor
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5596
extern void (*PQsetNoticeProcessor(struct pg_conn *conn, void (*proc)(void *, const char *), void *arg))(void *, const char *);
// PQsetNoticeProcessor::1::old_object
//
void old_object(void *, const char *);

//

// PQsetNoticeReceiver
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5579
extern void (*PQsetNoticeReceiver(struct pg_conn *conn, void (*proc)(void *, const struct pg_result *), void *arg))(void *, const struct pg_result *);
// PQsetNoticeReceiver::1::old_object
//
void old_object(void *, const struct pg_result *);

//

// PQsetResultAttrs
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 225
extern signed int PQsetResultAttrs(struct pg_result *res, signed int numAttributes, struct pgresAttDesc *attDescs);
// PQsetSingleRowMode
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1582
extern signed int PQsetSingleRowMode(struct pg_conn *conn);
// PQsetdbLogin
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 957
extern struct pg_conn * PQsetdbLogin(const char *pghost, const char *pgport, const char *pgoptions, const char *pgtty, const char *dbName, const char *login, const char *pwd);
// PQsetnonblocking
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3075
extern signed int PQsetnonblocking(struct pg_conn *conn, signed int arg);
// PQsetvalue
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 420
extern signed int PQsetvalue(struct pg_result *res, signed int tup_num, signed int field_num, char *value, signed int len);
// PQsocket
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 314
extern signed int PQsocket(const struct pg_conn *conn);
// PQstatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 307
extern enum anonymous_24 PQstatus(const struct pg_conn *conn);
// PQtrace
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5558
extern void PQtrace(struct pg_conn *conn, struct _IO_FILE *debug_port);
// PQtransactionStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5390
extern enum anonymous_3 PQtransactionStatus(const struct pg_conn *conn);
// PQtty
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5366
extern char * PQtty(const struct pg_conn *conn);
// PQunescapeBytea
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3595
extern unsigned char * PQunescapeBytea(const unsigned char *strtext, unsigned long int *retbuflen);
// PQuntrace
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5567
extern void PQuntrace(struct pg_conn *conn);
// PQuser
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5325
extern char * PQuser(const struct pg_conn *conn);
// PasswordFromFile
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5683
static char * PasswordFromFile(char *hostname, char *port, char *dbname, char *username);
// SSL_CTX_ctrl
// file /usr/include/openssl/ssl.h line 2339
signed long int SSL_CTX_ctrl(struct ssl_ctx_st *, signed int, signed long int, void *);
// SSL_CTX_get_cert_store
// file /usr/include/openssl/ssl.h line 2135
struct x509_store_st * SSL_CTX_get_cert_store(const struct ssl_ctx_st *);
// SSL_CTX_load_verify_locations
// file /usr/include/openssl/ssl.h line 2442
signed int SSL_CTX_load_verify_locations(struct ssl_ctx_st *, const char *, const char *);
// SSL_CTX_new
// file /usr/include/openssl/ssl.h line 2131
struct ssl_ctx_st * SSL_CTX_new(const struct ssl_method_st *);
// SSL_CTX_use_certificate_chain_file
// file /usr/include/openssl/ssl.h line 2202
signed int SSL_CTX_use_certificate_chain_file(struct ssl_ctx_st *, const char *);
// SSL_check_private_key
// file /usr/include/openssl/ssl.h line 2286
signed int SSL_check_private_key(const struct ssl_st *);
// SSL_connect
// file /usr/include/openssl/ssl.h line 2333
signed int SSL_connect(struct ssl_st *);
// SSL_ctrl
// file /usr/include/openssl/ssl.h line 2337
signed long int SSL_ctrl(struct ssl_st *, signed int, signed long int, void *);
// SSL_free
// file /usr/include/openssl/ssl.h line 2331
void SSL_free(struct ssl_st *);
// SSL_get_error
// file /usr/include/openssl/ssl.h line 2342
signed int SSL_get_error(const struct ssl_st *, signed int);
// SSL_get_peer_certificate
// file /usr/include/openssl/ssl.h line 2253
struct x509_st * SSL_get_peer_certificate(const struct ssl_st *);
// SSL_library_init
// file /usr/include/openssl/ssl.h line 2419
signed int SSL_library_init(void);
// SSL_load_error_strings
// file /usr/include/openssl/ssl.h line 2216
void SSL_load_error_strings(void);
// SSL_new
// file /usr/include/openssl/ssl.h line 2291
struct ssl_st * SSL_new(struct ssl_ctx_st *);
// SSL_pending
// file /usr/include/openssl/ssl.h line 2154
signed int SSL_pending(const struct ssl_st *);
// SSL_read
// file /usr/include/openssl/ssl.h line 2334
signed int SSL_read(struct ssl_st *, void *, signed int);
// SSL_set_ex_data
// file /usr/include/openssl/ssl.h line 2459
signed int SSL_set_ex_data(struct ssl_st *, signed int, void *);
// SSL_set_fd
// file /usr/include/openssl/ssl.h line 2156
signed int SSL_set_fd(struct ssl_st *, signed int);
// SSL_set_verify
// file /usr/include/openssl/ssl.h line 2170
void SSL_set_verify(struct ssl_st *, signed int, signed int (*)(signed int, struct x509_store_ctx_st *));
// SSL_shutdown
// file /usr/include/openssl/ssl.h line 2397
signed int SSL_shutdown(struct ssl_st *);
// SSL_use_PrivateKey
// file /usr/include/openssl/ssl.h line 2178
signed int SSL_use_PrivateKey(struct ssl_st *, struct evp_pkey_st *);
// SSL_use_PrivateKey_file
// file /usr/include/openssl/ssl.h line 2196
signed int SSL_use_PrivateKey_file(struct ssl_st *, const char *, signed int);
// SSL_use_certificate_file
// file /usr/include/openssl/ssl.h line 2197
signed int SSL_use_certificate_file(struct ssl_st *, const char *, signed int);
// SSL_write
// file /usr/include/openssl/ssl.h line 2336
signed int SSL_write(struct ssl_st *, const void *, signed int);
// SSLerrfree
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1638
static void SSLerrfree(char *buf);
// SSLerrmessage
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1612
static char * SSLerrmessage(void);
// SSLv23_method
// file /usr/include/openssl/ssl.h line 2360
const struct ssl_method_st * SSLv23_method(void);
// X509_NAME_get_text_by_NID
// file /usr/include/openssl/x509.h line 1011
signed int X509_NAME_get_text_by_NID(struct X509_name_st *, signed int, char *, signed int);
// X509_STORE_load_locations
// file /usr/include/openssl/x509_vfy.h line 527
signed int X509_STORE_load_locations(struct x509_store_st *, const char *, const char *);
// X509_STORE_set_flags
// file /usr/include/openssl/x509_vfy.h line 467
signed int X509_STORE_set_flags(struct x509_store_st *, unsigned long int);
// X509_free
// file /usr/include/openssl/x509.h line 823
void X509_free(struct x509_st *);
// X509_get_subject_name
// file /usr/include/openssl/x509.h line 907
struct X509_name_st * X509_get_subject_name(struct x509_st *);
// _IO_putc
// file /usr/include/libio.h line 435
extern signed int _IO_putc(signed int, struct _IO_FILE *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _dorand48
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/erand48.c line 58
static void _dorand48(unsigned short int *xseed);
// _dorand48_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/erand48.c line 58
static void _dorand48_link1(unsigned short int *xseed_link1);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// agg_vals_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 915
static void agg_vals_init(struct anonymous_19 *aggs, struct timeval start);
// alarm
// file /usr/include/unistd.h line 432
extern unsigned int alarm(unsigned int);
// appendBinaryPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 185
extern void appendBinaryPQExpBuffer(struct PQExpBufferData *str, const char *data, unsigned long int datalen);
// appendPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 162
extern void appendPQExpBuffer(struct PQExpBufferData *str, const char *fmt, ...);
// appendPQExpBufferChar
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 178
extern void appendPQExpBufferChar(struct PQExpBufferData *str, char ch);
// appendPQExpBufferStr
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 171
extern void appendPQExpBufferStr(struct PQExpBufferData *str, const char *data);
// appendPQExpBufferVA
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.c line 288
static char appendPQExpBufferVA(struct PQExpBufferData *str, const char *fmt, void **args);
// assignVariables
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 743
static char * assignVariables(struct anonymous_18 *st, char *sql);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// bsearch
// file /usr/include/stdlib.h line 754
extern void * bsearch(const void *, const void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// build_startup_packet
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 2034
static signed int build_startup_packet(const struct pg_conn *conn, char *packet, const struct PQEnvironmentOption *options);
// bytesToHex
// file md5.c line 245
static void bytesToHex(unsigned char *b, char *s);
// calculateDigestFromBuffer
// file md5.c line 185
static signed int calculateDigestFromBuffer(const unsigned char *b, unsigned int len, unsigned char *sum);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// canonicalize_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 43
extern void canonicalize_path(char *path);
// ceil
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 178
extern double ceil(double);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// checkXactStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol2.c line 1086
static void checkXactStatus(struct pg_conn *conn, const char *cmdTag);
// check_field_number
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2642
static signed int check_field_number(const struct pg_result *res, signed int field_num);
// check_param_number
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2680
static signed int check_param_number(const struct pg_result *res, signed int param_num);
// check_tuple_field_number
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2657
static signed int check_tuple_field_number(const struct pg_result *res, signed int tup_num, signed int field_num);
// clean_encoding_name
// file encnames.c line 449
static char * clean_encoding_name(const char *key, char *newkey);
// clientDone
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 902
static char clientDone(struct anonymous_18 *st, char ok);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closePGconn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 2941
static void closePGconn(struct pg_conn *conn);
// close_SSL
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1549
static void close_SSL(struct pg_conn *conn);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// compareVariables
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 595
static signed int compareVariables(const void *v1, const void *v2);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// connectDBComplete
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1527
static signed int connectDBComplete(struct pg_conn *conn);
// connectDBStart
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1385
static signed int connectDBStart(struct pg_conn *conn);
// connectFailureMessage
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1114
static void connectFailureMessage(struct pg_conn *conn, signed int errorno);
// connectNoDelay
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1086
static signed int connectNoDelay(struct pg_conn *conn);
// connectOptions1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 723
static char connectOptions1(struct pg_conn *conn, const char *conninfo);
// connectOptions2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 765
static char connectOptions2(struct pg_conn *conn);
// conninfo_add_defaults
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4570
static char conninfo_add_defaults(struct _PQconninfoOption *options, struct PQExpBufferData *errorMessage);
// conninfo_array_parse
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4407
static struct _PQconninfoOption * conninfo_array_parse(const char * const *keywords, const char * const *values, struct PQExpBufferData *errorMessage, char use_defaults, signed int expand_dbname);
// conninfo_find
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5240
static struct _PQconninfoOption * conninfo_find(struct _PQconninfoOption *connOptions, const char *keyword);
// conninfo_getval
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5149
static const char * conninfo_getval(struct _PQconninfoOption *connOptions, const char *keyword);
// conninfo_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4143
static struct _PQconninfoOption * conninfo_init(struct PQExpBufferData *errorMessage);
// conninfo_parse
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4233
static struct _PQconninfoOption * conninfo_parse(const char *conninfo, struct PQExpBufferData *errorMessage, char use_defaults);
// conninfo_storeval
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5175
static struct _PQconninfoOption * conninfo_storeval(struct _PQconninfoOption *connOptions, const char *keyword, const char *value, struct PQExpBufferData *errorMessage, char ignoreMissing, char uri_decode);
// conninfo_uri_decode
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5060
static char * conninfo_uri_decode(const char *str, struct PQExpBufferData *errorMessage);
// conninfo_uri_parse
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4651
static struct _PQconninfoOption * conninfo_uri_parse(const char *uri, struct PQExpBufferData *errorMessage, char use_defaults);
// conninfo_uri_parse_options
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4701
static char conninfo_uri_parse_options(struct _PQconninfoOption *options, const char *uri, struct PQExpBufferData *errorMessage);
// conninfo_uri_parse_params
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4912
static char conninfo_uri_parse_params(char *params, struct _PQconninfoOption *connOptions, struct PQExpBufferData *errorMessage);
// createPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.c line 73
extern struct PQExpBufferData * createPQExpBuffer(void);
// createPaddedCopyWithLength
// file md5.c line 36
static unsigned char * createPaddedCopyWithLength(const unsigned char *b, unsigned int *l);
// decoct
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/inet_net_ntop.c line 157
static signed int decoct(const unsigned char *src, signed int bytes, char *dst, unsigned long int size);
// decoct_link1
// file inet_net_ntop.c line 157
static signed int decoct_link1(const unsigned char *src_link1, signed int bytes_link1, char *dst_link1, unsigned long int size_link1);
// decoct_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/inet_net_ntop.c line 157
static signed int decoct_link2(const unsigned char *src_link2, signed int bytes_link2, char *dst_link2, unsigned long int size_link2);
// defaultNoticeProcessor
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5634
static void defaultNoticeProcessor(void *arg, const char *message);
// defaultNoticeReceiver
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5619
static void defaultNoticeReceiver(void *arg, const struct pg_result *res);
// default_threadlock
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5885
static void default_threadlock(signed int acquire);
// destroyPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.c line 115
extern void destroyPQExpBuffer(struct PQExpBufferData *str);
// destroySSL
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1455
static void destroySSL(void);
// destroy_ssl_system
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1019
static void destroy_ssl_system(void);
// dgettext
// file /usr/include/libintl.h line 44
extern char * dgettext(const char *, const char *);
// dir_strcmp
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 457
static signed int dir_strcmp(const char *s1, const char *s2);
// dir_strcmp_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 457
static signed int dir_strcmp_link1(const char *s1_link1, const char *s2_link1);
// discard_response
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 582
static void discard_response(struct anonymous_18 *state);
// disconnect_all
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 1608
static void disconnect_all(struct anonymous_18 *state, signed int length);
// doConnect
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 515
static struct pg_conn * doConnect(void);
// doCustom
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 938
static char doCustom(struct anonymous_17 *thread, struct anonymous_18 *st, struct timeval *conn_time, struct _IO_FILE *logfile, struct anonymous_19 *agg);
// doTheRounds
// file md5.c line 94
static void doTheRounds(unsigned int *X, unsigned int *state);
// do_field
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-print.c line 325
static void do_field(const struct _PQprintOpt *po, const struct pg_result *res, const signed int i, const signed int j, const signed int fs_len, char **fields, const signed int nFields, const char **fieldNames, unsigned char *fieldNotNum, signed int *fieldMax, const signed int fieldMaxLen, struct _IO_FILE *fout);
// do_header
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-print.c line 439
static char * do_header(struct _IO_FILE *fout, const struct _PQprintOpt *po, const signed int nFields, signed int *fieldMax, const char **fieldNames, unsigned char *fieldNotNum, const signed int fs_len, const struct pg_result *res);
// dot_pg_pass_warning
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5826
static void dot_pg_pass_warning(struct pg_conn *conn);
// dupEvents
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 381
static struct PGEvent * dupEvents(struct PGEvent *events, signed int count);
// enlargePQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.c line 173
extern signed int enlargePQExpBuffer(struct PQExpBufferData *str, unsigned long int needed);
// escape_single_quotes_ascii
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/quotes.c line 33
extern char * escape_single_quotes_ascii(const char *src);
// executeStatement
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 500
static void executeStatement(struct pg_conn *con, const char *sql);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// fill
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-print.c line 753
static void fill(signed int length, signed int max, char filler, struct _IO_FILE *fp);
// fillPGconn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 681
static char fillPGconn(struct pg_conn *conn, struct _PQconninfoOption *connOptions);
// find_my_exec
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 119
extern signed int find_my_exec(const char *argv0, char *retpath);
// find_other_exec
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 307
extern signed int find_other_exec(const char *argv0, const char *target, const char *versionstr, char *retpath);
// first_dir_separator
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 38
extern char * first_dir_separator(const char *filename);
// first_path_var_separator
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 40
extern char * first_path_var_separator(const char *pathlist);
// fls
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/fls.c line 55
extern signed int fls(signed int mask);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// forkname_chars
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/relpath.c line 79
extern signed int forkname_chars(const char *str, enum ForkNumber *fork);
// forkname_to_number
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/relpath.c line 48
extern enum ForkNumber forkname_to_number(const char *forkName);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fputnbytes
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 84
static void fputnbytes(struct _IO_FILE *f, const char *str, unsigned long int n);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freePGconn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 2838
static void freePGconn(struct pg_conn *conn);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// freeifaddrs
// file /usr/include/ifaddrs.h line 69
extern void freeifaddrs(struct ifaddrs *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// getAnotherTuple
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol2.c line 790
static signed int getAnotherTuple(struct pg_conn *conn, char binary);
// getAnotherTuple_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 693
static signed int getAnotherTuple_link1(struct pg_conn *conn_link1, signed int msgLength);
// getCopyDataMessage
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 1429
static signed int getCopyDataMessage(struct pg_conn *conn);
// getCopyResult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1786
static struct pg_result * getCopyResult(struct pg_conn *conn, enum anonymous_20 copytype);
// getCopyStart
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 1341
static signed int getCopyStart(struct pg_conn *conn, enum anonymous_20 copytype);
// getNotify
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol2.c line 1114
static signed int getNotify(struct pg_conn *conn);
// getNotify_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 1285
static signed int getNotify_link1(struct pg_conn *conn_link1);
// getParamDescriptions
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 640
static signed int getParamDescriptions(struct pg_conn *conn);
// getParameterStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 1256
static signed int getParameterStatus(struct pg_conn *conn);
// getPgPassFilename
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5802
static char getPgPassFilename(char *pgpassfile);
// getPoissonRand
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 484
static signed long int getPoissonRand(struct anonymous_17 *thread, signed long int center);
// getQueryParams
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 779
static void getQueryParams(struct anonymous_18 *st, const struct anonymous_22 *command, const char **params);
// getReadyForQuery
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 1397
static signed int getReadyForQuery(struct pg_conn *conn);
// getRowDescriptions
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol2.c line 659
static signed int getRowDescriptions(struct pg_conn *conn);
// getRowDescriptions_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 463
static signed int getRowDescriptions_link1(struct pg_conn *conn_link1, signed int msgLength);
// getVariable
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 602
static char * getVariable(struct anonymous_18 *st, char *name);
// get_doc_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 742
extern void get_doc_path(const char *my_exec_path, char *ret_path);
// get_etc_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 51
extern void get_etc_path(const char *my_exec_path, char *ret_path);
// get_hex
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3434
static inline char get_hex(char c);
// get_hexdigit
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5128
static char get_hexdigit(char digit, signed int *value);
// get_home_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 773
extern char get_home_path(char *ret_path);
// get_html_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 751
extern void get_html_path(const char *my_exec_path, char *ret_path);
// get_include_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 688
extern void get_include_path(const char *my_exec_path, char *ret_path);
// get_includeserver_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 706
extern void get_includeserver_path(const char *my_exec_path, char *ret_path);
// get_lib_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 715
extern void get_lib_path(const char *my_exec_path, char *ret_path);
// get_locale_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 57
extern void get_locale_path(const char *my_exec_path, char *ret_path);
// get_man_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 760
extern void get_man_path(const char *my_exec_path, char *ret_path);
// get_parent_directory
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 820
extern void get_parent_directory(char *path);
// get_pkginclude_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 697
extern void get_pkginclude_path(const char *my_exec_path, char *ret_path);
// get_pkglib_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 724
extern void get_pkglib_path(const char *my_exec_path, char *ret_path);
// get_progname
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 49
extern const char * get_progname(const char *argv0);
// get_share_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 670
extern void get_share_path(const char *my_exec_path, char *ret_path);
// get_user_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/username.c line 33
extern const char * get_user_name(char **errstr);
// get_user_name_or_exit
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/username.c line 76
extern const char * get_user_name_or_exit(const char *progname);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getaddrinfo_unix
// file ip.c line 172
static signed int getaddrinfo_unix(const char *path, struct addrinfo *hintsp, struct addrinfo **result);
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getifaddrs
// file /usr/include/ifaddrs.h line 66
extern signed int getifaddrs(struct ifaddrs **);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getnameinfo_unix
// file ip.c line 238
static signed int getnameinfo_unix(struct sockaddr_un *sa, signed int salen, char *node, signed int nodelen, char *service, signed int servicelen, signed int flags);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpeereid
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/getpeereid.c line 35
extern signed int getpeereid(signed int sock, unsigned int *uid, unsigned int *gid);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getpwuid_r
// file /usr/include/pwd.h line 144
extern signed int getpwuid_r(unsigned int, struct passwd *, char *, unsigned long int, struct passwd ** restrict );
// getrand
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 465
static signed long int getrand(struct anonymous_17 *thread, signed long int min, signed long int max);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(enum __rlimit_resource, struct rlimit *);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettext
// file /usr/include/libintl.h line 39
extern char * gettext(const char *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// gss_delete_sec_context
// file /usr/include/mit-krb5/gssapi/gssapi.h line 474
unsigned int gss_delete_sec_context(unsigned int *, struct gss_ctx_id_struct **, struct gss_buffer_desc_struct *);
// gss_display_status
// file /usr/include/mit-krb5/gssapi/gssapi.h line 530
unsigned int gss_display_status(unsigned int *, unsigned int, signed int, struct gss_OID_desc_struct *, unsigned int *, struct gss_buffer_desc_struct *);
// gss_import_name
// file /usr/include/mit-krb5/gssapi/gssapi.h line 562
unsigned int gss_import_name(unsigned int *, struct gss_buffer_desc_struct *, struct gss_OID_desc_struct *, struct gss_name_struct **);
// gss_init_sec_context
// file /usr/include/mit-krb5/gssapi/gssapi.h line 437
unsigned int gss_init_sec_context(unsigned int *, struct gss_cred_id_struct *, struct gss_ctx_id_struct **, struct gss_name_struct *, struct gss_OID_desc_struct *, unsigned int, unsigned int, struct gss_channel_bindings_struct *, struct gss_buffer_desc_struct *, struct gss_OID_desc_struct **, struct gss_buffer_desc_struct *, unsigned int *, unsigned int *);
// gss_release_buffer
// file /usr/include/mit-krb5/gssapi/gssapi.h line 574
unsigned int gss_release_buffer(unsigned int *, struct gss_buffer_desc_struct *);
// gss_release_name
// file /usr/include/mit-krb5/gssapi/gssapi.h line 569
unsigned int gss_release_name(unsigned int *, struct gss_name_struct **);
// handleSyncLoss
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 440
static void handleSyncLoss(struct pg_conn *conn, char id, signed int msgLength);
// handle_sig_alarm
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 3454
static void handle_sig_alarm(signed int postgres_signal_arg);
// has_drive_prefix
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 87
extern char has_drive_prefix(const char *path);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inet_net_ntop
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/inet_net_ntop.c line 78
extern char * inet_net_ntop(signed int af, const void *src, signed int bits, char *dst, unsigned long int size);
// inet_net_ntop_ipv4
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/inet_net_ntop.c line 116
static char * inet_net_ntop_ipv4(const unsigned char *src, signed int bits, char *dst, unsigned long int size);
// inet_net_ntop_ipv4_link1
// file inet_net_ntop.c line 116
static char * inet_net_ntop_ipv4_link1(const unsigned char *src_link1, signed int bits_link1, char *dst_link1, unsigned long int size_link1);
// inet_net_ntop_ipv4_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/inet_net_ntop.c line 116
static char * inet_net_ntop_ipv4_link2(const unsigned char *src_link2, signed int bits_link2, char *dst_link2, unsigned long int size_link2);
// inet_net_ntop_ipv6
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/inet_net_ntop.c line 180
static char * inet_net_ntop_ipv6(const unsigned char *src, signed int bits, char *dst, unsigned long int size);
// inet_net_ntop_ipv6_link1
// file inet_net_ntop.c line 180
static char * inet_net_ntop_ipv6_link1(const unsigned char *src_link1, signed int bits_link1, char *dst_link1, unsigned long int size_link1);
// inet_net_ntop_ipv6_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/inet_net_ntop.c line 180
static char * inet_net_ntop_ipv6_link2(const unsigned char *src_link2, signed int bits_link2, char *dst_link2, unsigned long int size_link2);
// init
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 1624
static void init(char is_no_vacuum);
// initPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 103
extern void initPQExpBuffer(struct PQExpBufferData *str);
// init_ssl_system
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 902
static signed int init_ssl_system(struct pg_conn *conn);
// initialize_SSL
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1062
static signed int initialize_SSL(struct pg_conn *conn);
// internal_cancel
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3216
static signed int internal_cancel(struct anonymous_7 *raddr, signed int be_pid, signed int be_key, char *errbuf, signed int errbufsize);
// internal_ping
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 2679
static enum anonymous_25 internal_ping(struct pg_conn *conn);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// isLegalVariableName
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 625
static char isLegalVariableName(const char *name);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// join_path_components
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 41
extern void join_path_components(char *ret_path, const char *head, const char *tail);
// last_dir_separator
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 39
extern char * last_dir_separator(const char *filename);
// ldapServiceLookup
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3441
static signed int ldapServiceLookup(const char *purl, struct _PQconninfoOption *options, struct PQExpBufferData *errorMessage);
// ldap_count_entries
// file /usr/include/ldap.h line 1613
extern signed int ldap_count_entries(struct ldap *, struct ldapmsg *);
// ldap_err2string
// file /usr/include/ldap.h line 1364
extern char * ldap_err2string(signed int);
// ldap_first_entry
// file /usr/include/ldap.h line 1603
extern struct ldapmsg * ldap_first_entry(struct ldap *, struct ldapmsg *);
// ldap_get_values_len
// file /usr/include/ldap.h line 1800
extern struct berval ** ldap_get_values_len(struct ldap *, struct ldapmsg *, const char *);
// ldap_init
// file /usr/include/ldap.h line 1506
extern struct ldap * ldap_init(const char *, signed int);
// ldap_msgfree
// file /usr/include/ldap.h line 1849
extern signed int ldap_msgfree(struct ldapmsg *);
// ldap_result
// file /usr/include/ldap.h line 1833
extern signed int ldap_result(struct ldap *, signed int, signed int, struct timeval *, struct ldapmsg **);
// ldap_search_st
// file /usr/include/ldap.h line 1915
extern signed int ldap_search_st(struct ldap *, const char *, signed int, const char *, char **, signed int, struct timeval *, struct ldapmsg **);
// ldap_set_option
// file /usr/include/ldap.h line 964
extern signed int ldap_set_option(struct ldap *, signed int, const void *);
// ldap_simple_bind
// file /usr/include/ldap.h line 1265
extern signed int ldap_simple_bind(struct ldap *, const char *, const char *);
// ldap_unbind
// file /usr/include/ldap.h line 1947
extern signed int ldap_unbind(struct ldap *);
// ldap_value_free_len
// file /usr/include/ldap.h line 1810
extern void ldap_value_free_len(struct berval **);
// ldexp
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 106
extern double ldexp(double, signed int);
// libpq_gettext
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 621
extern char * libpq_gettext(const char *msgid);
// lo_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 100
extern signed int lo_close(struct pg_conn *conn, signed int fd);
// lo_creat
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 466
extern unsigned int lo_creat(struct pg_conn *conn, signed int mode);
// lo_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 505
extern unsigned int lo_create(struct pg_conn *conn, unsigned int lobjId);
// lo_export
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 785
extern signed int lo_export(struct pg_conn *conn, unsigned int lobjId, const char *filename);
// lo_hton64
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 1062
static signed long int lo_hton64(signed long int host64);
// lo_import
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 669
extern unsigned int lo_import(struct pg_conn *conn, const char *filename);
// lo_import_internal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 690
static unsigned int lo_import_internal(struct pg_conn *conn, const char *filename, unsigned int oid);
// lo_import_with_oid
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 684
extern unsigned int lo_import_with_oid(struct pg_conn *conn, const char *filename, unsigned int lobjId);
// lo_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 877
static signed int lo_initialize(struct pg_conn *conn);
// lo_lseek
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 366
extern signed int lo_lseek(struct pg_conn *conn, signed int fd, signed int offset, signed int whence);
// lo_lseek64
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 410
extern signed long int lo_lseek64(struct pg_conn *conn, signed int fd, signed long int offset, signed int whence);
// lo_ntoh64
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 1087
static signed long int lo_ntoh64(signed long int net64);
// lo_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 58
extern signed int lo_open(struct pg_conn *conn, unsigned int lobjId, signed int mode);
// lo_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 259
extern signed int lo_read(struct pg_conn *conn, signed int fd, char *buf, unsigned long int len);
// lo_tell
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 549
extern signed int lo_tell(struct pg_conn *conn, signed int fd);
// lo_tell64
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 585
extern signed long int lo_tell64(struct pg_conn *conn, signed int fd);
// lo_truncate
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 138
extern signed int lo_truncate(struct pg_conn *conn, signed int fd, unsigned long int len);
// lo_truncate64
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 206
extern signed int lo_truncate64(struct pg_conn *conn, signed int fd, signed long int len);
// lo_unlink
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 629
extern signed int lo_unlink(struct pg_conn *conn, unsigned int lobjId);
// lo_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 313
extern signed int lo_write(struct pg_conn *conn, signed int fd, const char *buf, unsigned long int len);
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 262
extern signed int lstat(const char *, struct stat *);
// makeEmptyPGconn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 2744
static struct pg_conn * makeEmptyPGconn(void);
// make_absolute_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 574
extern char * make_absolute_path(const char *path);
// make_native_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 162
extern void make_native_path(char *filename);
// make_relative_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 505
static void make_relative_path(char *ret_path, const char *target_path, const char *bin_path, const char *my_exec_path);
// make_relative_path_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 505
static void make_relative_path_link1(char *ret_path_link1, const char *target_path_link1, const char *bin_path_link1, const char *my_exec_path_link1);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// markPQExpBufferBroken
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.c line 51
static void markPQExpBufferBroken(struct PQExpBufferData *str);
// mbbisearch
// file wchar.c line 584
static signed int mbbisearch(unsigned int ucs, struct mbinterval *table, signed int max);
// med3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort.c line 105
static char * med3(char *a, char *b, char *c, signed int (*cmp)(const void *, const void *));
// med3_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort_arg.c line 105
static char * med3_link1(char *a_link1, char *b_link1, char *c_link1, signed int (*cmp_link1)(const void *, const void *, void *), void *arg);
// med3_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort.c line 105
static char * med3_link2(char *a_link2, char *b_link2, char *c_link2, signed int (*cmp_link2)(const void *, const void *));
// med3_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort_arg.c line 105
static char * med3_link3(char *a_link3, char *b_link3, char *c_link3, signed int (*cmp_link3)(const void *, const void *, void *), void *arg_link1);
// med3::cmp_link1_object
//
signed int cmp_link1_object(const void *, const void *, void *);
// med3::cmp_link2_object
//
signed int cmp_link2_object(const void *, const void *);
// med3::cmp_link3_object
//
signed int cmp_link3_object(const void *, const void *, void *);
// med3::cmp_object
//
signed int cmp_object(const void *, const void *);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// nl_langinfo
// file /usr/include/langinfo.h line 583
extern char * nl_langinfo(signed int);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// open_client_SSL
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1464
static enum anonymous_4 open_client_SSL(struct pg_conn *conn);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// output_row
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-print.c line 525
static void output_row(struct _IO_FILE *fout, const struct _PQprintOpt *po, const signed int nFields, char **fields, unsigned char *fieldNotNum, signed int *fieldMax, char *border, const signed int row_index);
// palloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 21
extern void * palloc(unsigned long int size);
// palloc0
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/fe_memutils.c line 107
extern void * palloc0(unsigned long int size);
// parseInput
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1645
static void parseInput(struct pg_conn *conn);
// parseQuery
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 1903
static char parseQuery(struct anonymous_22 *cmd, const char *raw_sql);
// parseServiceFile
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3956
static signed int parseServiceFile(const char *serviceFile, const char *service, struct _PQconninfoOption *options, struct PQExpBufferData *errorMessage, char *group_found);
// parseServiceInfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3887
static signed int parseServiceInfo(struct _PQconninfoOption *options, struct PQExpBufferData *errorMessage);
// parseVariable
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 702
static char * parseVariable(const char *sql, signed int *eaten);
// parse_connection_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4183
static struct _PQconninfoOption * parse_connection_string(const char *connstr, struct PQExpBufferData *errorMessage, char use_defaults);
// path_contains_parent_reference
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 342
extern char path_contains_parent_reference(const char *path);
// path_is_prefix_of_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 404
extern char path_is_prefix_of_path(const char *path1, const char *path2);
// path_is_relative_and_below_cwd
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 371
extern char path_is_relative_and_below_cwd(const char *path);
// pclose
// file /usr/include/stdio.h line 878
extern signed int pclose(struct _IO_FILE *);
// pclose_check
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 510
extern signed int pclose_check(struct _IO_FILE *stream);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pfree
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 24
extern void pfree(void *pointer);
// pg_GSS_continue
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 102
static signed int pg_GSS_continue(struct pg_conn *conn);
// pg_GSS_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 86
static void pg_GSS_error(const char *mprefix, struct pg_conn *conn, unsigned int maj_stat, unsigned int min_stat);
// pg_GSS_error_int
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 66
static void pg_GSS_error_int(struct PQExpBufferData *str, const char *mprefix, unsigned int stat, signed int type);
// pg_GSS_startup
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 167
static signed int pg_GSS_startup(struct pg_conn *conn);
// pg_ascii2wchar_with_len
// file wchar.c line 40
static signed int pg_ascii2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len);
// pg_ascii_dsplen
// file wchar.c line 61
static signed int pg_ascii_dsplen(const unsigned char *s);
// pg_ascii_mblen
// file wchar.c line 55
static signed int pg_ascii_mblen(const unsigned char *s);
// pg_ascii_tolower
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgstrcasecmp.c line 146
extern unsigned char pg_ascii_tolower(unsigned char ch);
// pg_ascii_toupper
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgstrcasecmp.c line 135
extern unsigned char pg_ascii_toupper(unsigned char ch);
// pg_ascii_verifier
// file wchar.c line 1125
static signed int pg_ascii_verifier(const unsigned char *s, signed int len);
// pg_big5_dsplen
// file wchar.c line 1007
static signed int pg_big5_dsplen(const unsigned char *s);
// pg_big5_mblen
// file wchar.c line 995
static signed int pg_big5_mblen(const unsigned char *s);
// pg_big5_verifier
// file wchar.c line 1344
static signed int pg_big5_verifier(const unsigned char *s, signed int len);
// pg_char_to_encoding
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 579
extern signed int pg_char_to_encoding(const char *name);
// pg_check_dir
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgcheckdir.c line 31
extern signed int pg_check_dir(const char *dir);
// pg_encoding_dsplen
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/mb/pg_wchar.h line 449
extern signed int pg_encoding_dsplen(signed int encoding, const char *mbstr);
// pg_encoding_max_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/mb/pg_wchar.h line 459
extern signed int pg_encoding_max_length(signed int encoding);
// pg_encoding_mblen
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/mb/pg_wchar.h line 448
extern signed int pg_encoding_mblen(signed int encoding, const char *mbstr);
// pg_encoding_to_char
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 580
extern const char * pg_encoding_to_char(signed int encoding);
// pg_encoding_verifymb
// file wchar.c line 1803
extern signed int pg_encoding_verifymb(signed int encoding, const char *mbstr, signed int len);
// pg_erand48
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 372
extern double pg_erand48(unsigned short int *xseed);
// pg_euc2wchar_with_len
// file wchar.c line 75
static signed int pg_euc2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len);
// pg_euc_dsplen
// file wchar.c line 130
static inline signed int pg_euc_dsplen(const unsigned char *s);
// pg_euc_mblen
// file wchar.c line 114
static inline signed int pg_euc_mblen(const unsigned char *s);
// pg_euccn2wchar_with_len
// file wchar.c line 202
static signed int pg_euccn2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len);
// pg_euccn_dsplen
// file wchar.c line 253
static signed int pg_euccn_dsplen(const unsigned char *s);
// pg_euccn_mblen
// file wchar.c line 241
static signed int pg_euccn_mblen(const unsigned char *s);
// pg_eucjp2wchar_with_len
// file wchar.c line 149
static signed int pg_eucjp2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len);
// pg_eucjp_dsplen
// file wchar.c line 161
static signed int pg_eucjp_dsplen(const unsigned char *s);
// pg_eucjp_mblen
// file wchar.c line 155
static signed int pg_eucjp_mblen(const unsigned char *s);
// pg_eucjp_verifier
// file wchar.c line 1133
static signed int pg_eucjp_verifier(const unsigned char *s, signed int len);
// pg_euckr2wchar_with_len
// file wchar.c line 180
static signed int pg_euckr2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len);
// pg_euckr_dsplen
// file wchar.c line 192
static signed int pg_euckr_dsplen(const unsigned char *s);
// pg_euckr_mblen
// file wchar.c line 186
static signed int pg_euckr_mblen(const unsigned char *s);
// pg_euckr_verifier
// file wchar.c line 1188
static signed int pg_euckr_verifier(const unsigned char *s, signed int len);
// pg_euctw2wchar_with_len
// file wchar.c line 269
static signed int pg_euctw2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len);
// pg_euctw_dsplen
// file wchar.c line 325
static signed int pg_euctw_dsplen(const unsigned char *s);
// pg_euctw_mblen
// file wchar.c line 309
static signed int pg_euctw_mblen(const unsigned char *s);
// pg_euctw_verifier
// file wchar.c line 1220
static signed int pg_euctw_verifier(const unsigned char *s, signed int len);
// pg_fe_getauthname
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 722
extern char * pg_fe_getauthname(struct PQExpBufferData *errorMessage);
// pg_fe_sendauth
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 554
extern signed int pg_fe_sendauth(unsigned int areq, struct pg_conn *conn);
// pg_foreach_ifaddr
// file ip.c line 531
extern signed int pg_foreach_ifaddr(void (*callback)(struct sockaddr *, struct sockaddr *, void *), void *cb_data);

//

// pg_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 17
extern void pg_free(void *ptr);
// pg_freeaddrinfo_all
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/libpq/ip.h line 35
extern void pg_freeaddrinfo_all(signed int hint_ai_family, struct addrinfo *ai);
// pg_g_threadlock_object
//
void pg_g_threadlock_object(signed int);
// pg_gb18030_dsplen
// file wchar.c line 1096
static signed int pg_gb18030_dsplen(const unsigned char *s);
// pg_gb18030_mblen
// file wchar.c line 1077
static signed int pg_gb18030_mblen(const unsigned char *s);
// pg_gb18030_verifier
// file wchar.c line 1404
static signed int pg_gb18030_verifier(const unsigned char *s, signed int len);
// pg_gbk_dsplen
// file wchar.c line 1034
static signed int pg_gbk_dsplen(const unsigned char *s);
// pg_gbk_mblen
// file wchar.c line 1022
static signed int pg_gbk_mblen(const unsigned char *s);
// pg_gbk_verifier
// file wchar.c line 1364
static signed int pg_gbk_verifier(const unsigned char *s, signed int len);
// pg_get_encoding_from_locale
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/chklocale.c line 283
extern signed int pg_get_encoding_from_locale(const char *ctype, char write_message);
// pg_getaddrinfo_all
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/libpq/ip.h line 32
extern signed int pg_getaddrinfo_all(const char *hostname, const char *servname, struct addrinfo *hintp, struct addrinfo **result);
// pg_getnameinfo_all
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/libpq/ip.h line 37
extern signed int pg_getnameinfo_all(struct sockaddr_storage *addr, signed int salen, char *node, signed int nodelen, char *service, signed int servicelen, signed int flags);
// pg_johab_dsplen
// file wchar.c line 399
static signed int pg_johab_dsplen(const unsigned char *s);
// pg_johab_mblen
// file wchar.c line 393
static signed int pg_johab_mblen(const unsigned char *s);
// pg_johab_verifier
// file wchar.c line 1270
static signed int pg_johab_verifier(const unsigned char *s, signed int len);
// pg_latin12wchar_with_len
// file wchar.c line 912
static signed int pg_latin12wchar_with_len(const unsigned char *from, unsigned int *to, signed int len);
// pg_latin1_dsplen
// file wchar.c line 955
static signed int pg_latin1_dsplen(const unsigned char *s);
// pg_latin1_mblen
// file wchar.c line 949
static signed int pg_latin1_mblen(const unsigned char *s);
// pg_latin1_verifier
// file wchar.c line 1315
static signed int pg_latin1_verifier(const unsigned char *s, signed int len);
// pg_local_sendauth
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 441
static signed int pg_local_sendauth(struct pg_conn *conn);
// pg_lrand48
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/erand48.c line 88
extern signed long int pg_lrand48(void);
// pg_malloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 14
extern void * pg_malloc(unsigned long int size);
// pg_malloc0
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/fe_memutils.c line 40
extern void * pg_malloc0(unsigned long int size);
// pg_md5_binary
// file md5.c line 302
extern char pg_md5_binary(const void *buff, unsigned long int len, void *outbuf);
// pg_md5_encrypt
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/libpq/md5.h line 27
extern char pg_md5_encrypt(const char *passwd, const char *salt, unsigned long int salt_len, char *buf);
// pg_md5_hash
// file md5.c line 290
extern char pg_md5_hash(const void *buff, unsigned long int len, char *hexsum);
// pg_mic_mblen
// file wchar.c line 1770
extern signed int pg_mic_mblen(const unsigned char *mbstr);
// pg_mkdir_p
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgmkdirp.c line 57
extern signed int pg_mkdir_p(char *path, signed int omode);
// pg_mule2wchar_with_len
// file wchar.c line 748
static signed int pg_mule2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len);
// pg_mule_dsplen
// file wchar.c line 884
static signed int pg_mule_dsplen(const unsigned char *s);
// pg_mule_mblen
// file wchar.c line 866
extern signed int pg_mule_mblen(const unsigned char *s);
// pg_mule_verifier
// file wchar.c line 1294
static signed int pg_mule_verifier(const unsigned char *s, signed int len);
// pg_password_sendauth
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 493
static signed int pg_password_sendauth(struct pg_conn *conn, const char *password, unsigned int areq);
// pg_qsort
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 445
extern void pg_qsort(void *a, unsigned long int n, unsigned long int es, signed int (*cmp)(const void *, const void *));
// pg_qsort::cmp_link1_object
//
signed int cmp_link1_object(const void *, const void *);
// pg_qsort::cmp_object
//
signed int cmp_object(const void *, const void *);
// pg_qsort_strcmp
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort.c line 232
extern signed int pg_qsort_strcmp(const void *a, const void *b);
// pg_range_sockaddr
// file ip.c line 276
extern signed int pg_range_sockaddr(struct sockaddr_storage *addr, struct sockaddr_storage *netaddr, struct sockaddr_storage *netmask);
// pg_realloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 16
extern void * pg_realloc(void *ptr, unsigned long int size);
// pg_set_block
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/noblock.c line 35
extern char pg_set_block(signed int sock);
// pg_set_noblock
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/noblock.c line 21
extern char pg_set_noblock(signed int sock);
// pg_sjis_dsplen
// file wchar.c line 978
static signed int pg_sjis_dsplen(const unsigned char *s);
// pg_sjis_mblen
// file wchar.c line 964
static signed int pg_sjis_mblen(const unsigned char *s);
// pg_sjis_verifier
// file wchar.c line 1321
static signed int pg_sjis_verifier(const unsigned char *s, signed int len);
// pg_sockaddr_cidr_mask
// file ip.c line 338
extern signed int pg_sockaddr_cidr_mask(struct sockaddr_storage *mask, char *numbits, signed int family);
// pg_srand48
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/erand48.c line 95
extern void pg_srand48(signed long int seed);
// pg_str_endswith
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/string.c line 31
extern char pg_str_endswith(const char *str, const char *end);
// pg_strcasecmp
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 122
extern signed int pg_strcasecmp(const char *s1, const char *s2);
// pg_strdup
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 13
extern char * pg_strdup(const char *in);
// pg_strncasecmp
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgstrcasecmp.c line 69
extern signed int pg_strncasecmp(const char *s1, const char *s2, unsigned long int n);
// pg_tolower
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgstrcasecmp.c line 122
extern unsigned char pg_tolower(unsigned char ch);
// pg_toupper
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgstrcasecmp.c line 105
extern unsigned char pg_toupper(unsigned char ch);
// pg_uhc_dsplen
// file wchar.c line 1061
static signed int pg_uhc_dsplen(const unsigned char *s);
// pg_uhc_mblen
// file wchar.c line 1049
static signed int pg_uhc_mblen(const unsigned char *s);
// pg_uhc_verifier
// file wchar.c line 1384
static signed int pg_uhc_verifier(const unsigned char *s, signed int len);
// pg_usleep
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgsleep.c line 44
extern void pg_usleep(signed long int microsec);
// pg_utf2wchar_with_len
// file wchar.c line 411
static signed int pg_utf2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len);
// pg_utf8_islegal
// file wchar.c line 1452
extern char pg_utf8_islegal(const unsigned char *source, signed int length);
// pg_utf8_verifier
// file wchar.c line 1424
static signed int pg_utf8_verifier(const unsigned char *s, signed int len);
// pg_utf_dsplen
// file wchar.c line 736
static signed int pg_utf_dsplen(const unsigned char *s);
// pg_utf_mblen
// file wchar.c line 541
extern signed int pg_utf_mblen(const unsigned char *s);
// pg_valid_client_encoding
// file encnames.c line 411
extern signed int pg_valid_client_encoding(const char *name);
// pg_valid_server_encoding
// file encnames.c line 425
extern signed int pg_valid_server_encoding(const char *name);
// pg_valid_server_encoding_id
// file encnames.c line 439
extern signed int pg_valid_server_encoding_id(signed int encoding);
// pg_wchar2euc_with_len
// file wchar.c line 347
static signed int pg_wchar2euc_with_len(const unsigned int *from, unsigned char *to, signed int len);
// pg_wchar2mule_with_len
// file wchar.c line 801
static signed int pg_wchar2mule_with_len(const unsigned int *from, unsigned char *to, signed int len);
// pg_wchar2single_with_len
// file wchar.c line 934
static signed int pg_wchar2single_with_len(const unsigned int *from, unsigned char *to, signed int len);
// pg_wchar2utf_with_len
// file wchar.c line 510
static signed int pg_wchar2utf_with_len(const unsigned int *from, unsigned char *to, signed int len);
// pgfnames
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/pgfnames.c line 31
extern char ** pgfnames(const char *path);
// pgfnames_cleanup
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/pgfnames.c line 99
extern void pgfnames_cleanup(char **filenames);
// pipe_read_line
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 348
static char * pipe_read_line(char *cmd, char *line, signed int maxsize);
// pipe_read_line_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 348
static char * pipe_read_line_link1(char *cmd_link1, char *line_link1, signed int maxsize_link1);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// popen
// file /usr/include/stdio.h line 872
extern struct _IO_FILE * popen(const char *, const char *);
// pqAddTuple
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 851
static char pqAddTuple(struct pg_result *res, struct pgresAttValue *tup);
// pqBuildStartupPacket2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 542
extern char * pqBuildStartupPacket2(struct pg_conn *conn, signed int *packetlen, const struct PQEnvironmentOption *options);
// pqBuildStartupPacket3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 556
extern char * pqBuildStartupPacket3(struct pg_conn *conn, signed int *packetlen, const struct PQEnvironmentOption *options);
// pqCatenateResultError
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 630
extern void pqCatenateResultError(struct pg_result *res, const char *msg);
// pqCheckInBufferSpace
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 577
extern signed int pqCheckInBufferSpace(unsigned long int bytes_needed, struct pg_conn *conn);
// pqCheckOutBufferSpace
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 576
extern signed int pqCheckOutBufferSpace(unsigned long int bytes_needed, struct pg_conn *conn);
// pqClearAsyncResult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 524
extern void pqClearAsyncResult(struct pg_conn *conn);
// pqDropConnection
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 396
extern void pqDropConnection(struct pg_conn *conn);
// pqEndcopy2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 548
extern signed int pqEndcopy2(struct pg_conn *conn);
// pqEndcopy3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 563
extern signed int pqEndcopy3(struct pg_conn *conn);
// pqFlush
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 591
extern signed int pqFlush(struct pg_conn *conn);
// pqFunctionCall2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 549
extern struct pg_result * pqFunctionCall2(struct pg_conn *conn, unsigned int fnid, signed int *result_buf, signed int *actual_result_len, signed int result_is_int, const struct anonymous_33 *args, signed int nargs);
// pqFunctionCall3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 564
extern struct pg_result * pqFunctionCall3(struct pg_conn *conn, unsigned int fnid, signed int *result_buf, signed int *actual_result_len, signed int result_is_int, const struct anonymous_33 *args, signed int nargs);
// pqGetCopyData2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 545
extern signed int pqGetCopyData2(struct pg_conn *conn, char **buffer, signed int async);
// pqGetCopyData3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 560
extern signed int pqGetCopyData3(struct pg_conn *conn, char **buffer, signed int async);
// pqGetErrorNotice2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol2.c line 963
static signed int pqGetErrorNotice2(struct pg_conn *conn, char isError);
// pqGetErrorNotice3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 559
extern signed int pqGetErrorNotice3(struct pg_conn *conn, char isError);
// pqGetHomeDirectory
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5856
extern char pqGetHomeDirectory(char *buf, signed int bufsize);
// pqGetInt
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 586
extern signed int pqGetInt(signed int *result, unsigned long int bytes, struct pg_conn *conn);
// pqGetc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 578
extern signed int pqGetc(char *result, struct pg_conn *conn);
// pqGetline2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 546
extern signed int pqGetline2(struct pg_conn *conn, char *s, signed int maxlen);
// pqGetline3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 561
extern signed int pqGetline3(struct pg_conn *conn, char *s, signed int maxlen);
// pqGetlineAsync2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 547
extern signed int pqGetlineAsync2(struct pg_conn *conn, char *buffer, signed int bufsize);
// pqGetlineAsync3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 562
extern signed int pqGetlineAsync3(struct pg_conn *conn, char *buffer, signed int bufsize);
// pqGetnchar
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 583
extern signed int pqGetnchar(char *s, unsigned long int len, struct pg_conn *conn);
// pqGetpwuid
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 435
extern signed int pqGetpwuid(unsigned int uid, struct passwd *resultbuf, char *buffer, unsigned long int buflen, struct passwd **result);
// pqGets
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 168
extern signed int pqGets(struct PQExpBufferData *buf, struct pg_conn *conn);
// pqGets_append
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 581
extern signed int pqGets_append(struct PQExpBufferData *buf, struct pg_conn *conn);
// pqGets_internal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 137
static signed int pqGets_internal(struct PQExpBufferData *buf, struct pg_conn *conn, char resetbuffer);
// pqHandleSendFailure
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1561
extern void pqHandleSendFailure(struct pg_conn *conn);
// pqInternalNotice
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 800
extern void pqInternalNotice(const struct anonymous_8 *hooks, const char *fmt, ...);
// pqPacketSend
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 497
extern signed int pqPacketSend(struct pg_conn *conn, char pack_type, const void *buf, unsigned long int buf_len);
// pqParseInput2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 544
extern void pqParseInput2(struct pg_conn *conn);
// pqParseInput3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 558
extern void pqParseInput3(struct pg_conn *conn);
// pqPrepareAsyncResult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 755
extern struct pg_result * pqPrepareAsyncResult(struct pg_conn *conn);
// pqPutInt
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 587
extern signed int pqPutInt(signed int value, unsigned long int bytes, struct pg_conn *conn);
// pqPutMsgBytes
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 569
static signed int pqPutMsgBytes(const void *buf, unsigned long int len, struct pg_conn *conn);
// pqPutMsgEnd
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 589
extern signed int pqPutMsgEnd(struct pg_conn *conn);
// pqPutMsgStart
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 588
extern signed int pqPutMsgStart(char msg_type, char force_len, struct pg_conn *conn);
// pqPutc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 579
extern signed int pqPutc(char c, struct pg_conn *conn);
// pqPutnchar
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 585
extern signed int pqPutnchar(const char *s, unsigned long int len, struct pg_conn *conn);
// pqPuts
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 582
extern signed int pqPuts(const char *s, struct pg_conn *conn);
// pqReadData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 590
extern signed int pqReadData(struct pg_conn *conn);
// pqReadReady
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 1026
extern signed int pqReadReady(struct pg_conn *conn);
// pqResultAlloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 505
extern void * pqResultAlloc(struct pg_result *res, unsigned long int nBytes, char isBinary);
// pqResultStrdup
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 601
extern char * pqResultStrdup(struct pg_result *res, const char *str);
// pqRowProcessor
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1010
extern signed int pqRowProcessor(struct pg_conn *conn, const char **errmsgp);
// pqSaveErrorResult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 727
extern void pqSaveErrorResult(struct pg_conn *conn);
// pqSaveMessageField
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 889
extern void pqSaveMessageField(struct pg_result *res, char code, const char *value);
// pqSaveParameterStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 533
extern void pqSaveParameterStatus(struct pg_conn *conn, const char *name, const char *value);
// pqSendSome
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 832
static signed int pqSendSome(struct pg_conn *conn, signed int len);
// pqSetResultError
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 615
extern void pqSetResultError(struct pg_result *res, const char *msg);
// pqSetenvPoll
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 540
extern enum anonymous_4 pqSetenvPoll(struct pg_conn *conn);
// pqSkipnchar
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 229
extern signed int pqSkipnchar(unsigned long int len, struct pg_conn *conn);
// pqSocketCheck
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 1050
static signed int pqSocketCheck(struct pg_conn *conn, signed int forRead, signed int forWrite, signed long int end_time);
// pqSocketPoll
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 1100
static signed int pqSocketPoll(signed int sock, signed int forRead, signed int forWrite, signed long int end_time);
// pqStrerror
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/thread.c line 61
extern char * pqStrerror(signed int errnum, char *strerrbuf, unsigned long int buflen);
// pqWait
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 592
extern signed int pqWait(signed int forRead, signed int forWrite, struct pg_conn *conn);
// pqWaitTimed
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 593
extern signed int pqWaitTimed(signed int forRead, signed int forWrite, struct pg_conn *conn, signed long int finish_time);
// pqWriteReady
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 1036
extern signed int pqWriteReady(struct pg_conn *conn);
// pq_block_sigpipe
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 608
extern signed int pq_block_sigpipe(struct anonymous_6 *osigset, char *sigpipe_pending);
// pq_lockingcallback
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 870
static void pq_lockingcallback(signed int mode, signed int n, const char *file, signed int line);
// pq_reset_sigpipe
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 609
extern void pq_reset_sigpipe(struct anonymous_6 *osigset, char sigpipe_pending, char got_epipe);
// pq_threadidcallback
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 857
static unsigned long int pq_threadidcallback(void);
// pqsecure_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 603
extern void pqsecure_close(struct pg_conn *conn);
// pqsecure_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 242
extern void pqsecure_destroy(void);
// pqsecure_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 600
extern signed int pqsecure_initialize(struct pg_conn *conn);
// pqsecure_open_client
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 602
extern enum anonymous_4 pqsecure_open_client(struct pg_conn *conn);
// pqsecure_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 604
extern signed long int pqsecure_read(struct pg_conn *conn, void *ptr, unsigned long int len);
// pqsecure_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 605
extern signed long int pqsecure_write(struct pg_conn *conn, const void *ptr, unsigned long int len);
// pqsignal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 475
extern void (*pqsignal(signed int signo, void (*func)(signed int)))(signed int);

//


//


//

// preparedStatementName
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 896
static void preparedStatementName(char *buffer, signed int file, signed int state);
// printResults
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 2260
static void printResults(signed int ttype, signed long int normal_xacts, signed int nclients, struct anonymous_17 *threads, signed int nthreads, struct timeval total_time, struct timeval conn_total_time, signed long int total_latencies, signed long int total_sqlats, signed long int throttle_lag, signed long int throttle_lag_max);
// print_val
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/tar.c line 10
static void print_val(char *s, unsigned long int val, unsigned int base, unsigned long int len);
// print_val_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/tar.c line 10
static void print_val_link1(char *s_link1, unsigned long int val_link1, unsigned int base_link1, unsigned long int len_link1);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// printfPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 150
extern void printfPQExpBuffer(struct PQExpBufferData *str, const char *fmt, ...);
// process_builtin
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 2208
static struct anonymous_22 ** process_builtin(char *tb);
// process_commands
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 1948
static struct anonymous_22 * process_commands(char *buf);
// process_file
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 2148
static signed int process_file(char *filename);
// psprintf
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/psprintf.c line 46
extern char * psprintf(const char *fmt, ...);
// pstrdup
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 20
extern char * pstrdup(const char *in);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_2 *, const union anonymous_0 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_2 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_2 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_6 *, struct anonymous_6 *);
// putVariable
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 639
static signed int putVariable(struct anonymous_18 *st, const char *context, char *name, char *value);
// putenv
// file /usr/include/stdlib.h line 578
extern signed int putenv(char *);
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// pvsnprintf
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/psprintf.c line 104
extern unsigned long int pvsnprintf(char *buf, unsigned long int len, const char *fmt, void **args);
// pwdfMatchesString
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5646
static char * pwdfMatchesString(char *buf, char *token);
// qsort_arg
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort_arg.c line 113
extern void qsort_arg(void *a, unsigned long int n, unsigned long int es, signed int (*cmp)(const void *, const void *, void *), void *arg);
// qsort_arg::cmp_link1_object
//
signed int cmp_link1_object(const void *, const void *, void *);
// qsort_arg::cmp_object
//
signed int cmp_object(const void *, const void *, void *);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// range_sockaddr_AF_INET
// file ip.c line 295
static signed int range_sockaddr_AF_INET(struct sockaddr_in *addr, struct sockaddr_in *netaddr, struct sockaddr_in *netmask);
// range_sockaddr_AF_INET6
// file ip.c line 310
static signed int range_sockaddr_AF_INET6(struct sockaddr_in6 *addr, struct sockaddr_in6 *netaddr, struct sockaddr_in6 *netmask);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_line_from_file
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 2112
static char * read_line_from_file(struct _IO_FILE *fd);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// readlink
// file /usr/include/unistd.h line 809
extern signed long int readlink(const char *, char *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recognized_connection_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4222
static char recognized_connection_string(const char *connstr);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// repalloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 23
extern void * repalloc(void *pointer, unsigned long int size);
// replaceVariable
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 723
static char * replaceVariable(char **sql, char *param, signed int len, char *value);
// reportErrorPosition
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 1028
static void reportErrorPosition(struct PQExpBufferData *msg, const char *query, signed int loc, signed int encoding);
// resetPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 130
extern void resetPQExpBuffer(struct PQExpBufferData *str);
// resolve_symlinks
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 219
static signed int resolve_symlinks(char *path);
// resolve_symlinks_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 219
static signed int resolve_symlinks_link1(char *path_link1);
// rmdir
// file /usr/include/unistd.h line 835
extern signed int rmdir(const char *);
// rmtree
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/rmtree.c line 36
extern char rmtree(const char *path, char rmtopdir);
// runShellCommand
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 792
static char runShellCommand(struct anonymous_18 *st, char *variable, char **argv, signed int argc);
// run_ifaddr_callback
// file ip.c line 415
static void run_ifaddr_callback(void (*callback)(struct sockaddr *, struct sockaddr *, void *), void *cb_data, struct sockaddr *addr, struct sockaddr *mask);

//

// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_28 *, struct anonymous_28 *, struct anonymous_28 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// setKeepalivesCount
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1302
static signed int setKeepalivesCount(struct pg_conn *conn);
// setKeepalivesIdle
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1225
static signed int setKeepalivesIdle(struct pg_conn *conn);
// setKeepalivesInterval
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1270
static signed int setKeepalivesInterval(struct pg_conn *conn);
// set_pglocale_pgservice
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 550
extern void set_pglocale_pgservice(const char *argv0, const char *app);
// setalarm
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 3460
static void setalarm(signed int seconds);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_6 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_6 *);
// sigismember
// file /usr/include/signal.h line 227
extern signed int sigismember(const struct anonymous_6 *, signed int);
// sigpending
// file /usr/include/signal.h line 263
extern signed int sigpending(struct anonymous_6 *);
// sigwait
// file /usr/include/signal.h line 270
extern signed int sigwait(const struct anonymous_6 *, signed int *);
// simple_prompt
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 217
extern char * simple_prompt(const char *prompt, signed int maxlen, char echo);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strerror_r
// file /usr/include/string.h line 437
extern char * strerror_r(signed int, char *, unsigned long int);
// strlcat
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/strlcat.c line 33
extern unsigned long int strlcat(char *dst, const char *src, unsigned long int siz);
// strlcpy
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 412
extern unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtoint64
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 402
static signed long int strtoint64(const char *str);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// swapfunc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort.c line 86
static void swapfunc(char *a, char *b, unsigned long int n, signed int swaptype);
// swapfunc_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort_arg.c line 86
static void swapfunc_link1(char *a_link1, char *b_link1, unsigned long int n_link1, signed int swaptype_link1);
// swapfunc_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort.c line 86
static void swapfunc_link2(char *a_link2, char *b_link2, unsigned long int n_link2, signed int swaptype_link2);
// swapfunc_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort_arg.c line 86
static void swapfunc_link3(char *a_link3, char *b_link3, unsigned long int n_link3, signed int swaptype_link3);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// tarChecksum
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/tar.c line 29
extern signed int tarChecksum(char *header);
// tarCreateHeader
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/tar.c line 53
extern void tarCreateHeader(char *h, const char *filename, const char *linktarget, unsigned long int size, unsigned int mode, unsigned int uid, unsigned int gid, signed long int mtime);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// termPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 122
extern void termPQExpBuffer(struct PQExpBufferData *str);
// textdomain
// file /usr/include/libintl.h line 82
extern char * textdomain(const char *);
// threadRun
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 3055
static void * threadRun(void *arg);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// trim_directory
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 834
static void trim_directory(char *path);
// trim_directory_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 834
static void trim_directory_link1(char *path_link1);
// trim_trailing_separator
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 865
static void trim_trailing_separator(char *path);
// trim_trailing_separator_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 865
static void trim_trailing_separator_link1(char *path_link1);
// ucs_wcwidth
// file wchar.c line 637
static signed int ucs_wcwidth(unsigned int ucs);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// unicode_to_utf8
// file wchar.c line 475
extern unsigned char * unicode_to_utf8(unsigned int c, unsigned char *utf8string);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// uri_prefix_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4201
static signed int uri_prefix_length(const char *connstr);
// usage
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 345
static void usage(void);
// useKeepalives
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1207
static signed int useKeepalives(struct pg_conn *conn);
// utf8_to_unicode
// file wchar.c line 714
extern unsigned int utf8_to_unicode(const unsigned char *c);
// validate_exec
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 58
static signed int validate_exec(const char *path);
// validate_exec_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 58
static signed int validate_exec_link1(const char *path_link1);
// verify_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 698
static signed int verify_cb(signed int ok, struct x509_store_ctx_st *ctx);
// verify_peer_name_matches_certificate
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 760
static char verify_peer_name_matches_certificate(struct pg_conn *conn);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// wait_result_to_str
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 481
extern char * wait_result_to_str(signed int exitstatus);
// wildcard_certificate_match
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 720
static signed int wildcard_certificate_match(const char *pattern, const char *string);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_27
{
  // mb2wchar_with_len
  signed int (*mb2wchar_with_len)(const unsigned char *, unsigned int *, signed int);
  // wchar2mb_with_len
  signed int (*wchar2mb_with_len)(const unsigned int *, unsigned char *, signed int);
  // mblen
  signed int (*mblen)(const unsigned char *);
  // dsplen
  signed int (*dsplen)(const unsigned char *);
  // mbverify
  signed int (*mbverify)(const unsigned char *, signed int);
  // maxmblen
  signed int maxmblen;
};

struct anonymous_22
{
  // line
  char *line;
  // command_num
  signed int command_num;
  // type
  signed int type;
  // argc
  signed int argc;
  // argv
  char *argv[10l];
};

struct anonymous_21
{
  // name
  char *name;
  // value
  char *value;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct anonymous_18
{
  // con
  struct pg_conn *con;
  // id
  signed int id;
  // state
  signed int state;
  // cnt
  signed int cnt;
  // ecnt
  signed int ecnt;
  // listen
  signed int listen;
  // sleeping
  signed int sleeping;
  // throttling
  char throttling;
  // variables
  struct anonymous_21 *variables;
  // nvariables
  signed int nvariables;
  // txn_scheduled
  signed long int txn_scheduled;
  // txn_begin
  struct timeval txn_begin;
  // stmt_begin
  struct timeval stmt_begin;
  // txn_latencies
  signed long int txn_latencies;
  // txn_sqlats
  signed long int txn_sqlats;
  // is_throttled
  char is_throttled;
  // use_file
  signed int use_file;
  // prepared
  char prepared[128l];
};

struct anonymous_14
{
  // conn
  struct pg_conn *conn;
};

struct anonymous_15
{
  // conn
  struct pg_conn *conn;
  // result
  struct pg_result *result;
};

struct anonymous_37
{
  // result
  struct pg_result *result;
};

struct anonymous_8
{
  // noticeRec
  void (*noticeRec)(void *, const struct pg_result *);
  // noticeRecArg
  void *noticeRecArg;
  // noticeProc
  void (*noticeProc)(void *, const char *);
  // noticeProcArg
  void *noticeProcArg;
};

struct anonymous_47
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_45
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_36
{
  // src
  const struct pg_result *src;
  // dest
  struct pg_result *dest;
};

struct anonymous_1
{
  // cert_verify_md
  unsigned char cert_verify_md[128l];
  // finish_md
  unsigned char finish_md[128l];
  // finish_md_len
  signed int finish_md_len;
  // peer_finish_md
  unsigned char peer_finish_md[128l];
  // peer_finish_md_len
  signed int peer_finish_md_len;
  // message_size
  unsigned long int message_size;
  // message_type
  signed int message_type;
  // new_cipher
  const struct ssl_cipher_st *new_cipher;
  // dh
  struct dh_st *dh;
  // ecdh
  struct ec_key_st *ecdh;
  // next_state
  signed int next_state;
  // reuse_message
  signed int reuse_message;
  // cert_req
  signed int cert_req;
  // ctype_num
  signed int ctype_num;
  // ctype
  char ctype[9l];
  // ca_names
  struct stack_st_X509_NAME *ca_names;
  // use_rsa_tmp
  signed int use_rsa_tmp;
  // key_block_length
  signed int key_block_length;
  // key_block
  unsigned char *key_block;
  // new_sym_enc
  const struct evp_cipher_st *new_sym_enc;
  // new_hash
  const struct env_md_st *new_hash;
  // new_mac_pkey_type
  signed int new_mac_pkey_type;
  // new_mac_secret_size
  signed int new_mac_secret_size;
  // new_compression
  const struct ssl_comp_st *new_compression;
  // cert_request
  signed int cert_request;
};

struct anonymous_28
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_6
{
  // __val
  unsigned long int __val[16l];
};

union anonymous_35
{
  // ptr
  signed int *ptr;
  // integer
  signed int integer;
};

struct anonymous_33
{
  // len
  signed int len;
  // isint
  signed int isint;
  // u
  union anonymous_35 u;
};

struct anonymous_49
{
  // sess_connect
  signed int sess_connect;
  // sess_connect_renegotiate
  signed int sess_connect_renegotiate;
  // sess_connect_good
  signed int sess_connect_good;
  // sess_accept
  signed int sess_accept;
  // sess_accept_renegotiate
  signed int sess_accept_renegotiate;
  // sess_accept_good
  signed int sess_accept_good;
  // sess_miss
  signed int sess_miss;
  // sess_timeout
  signed int sess_timeout;
  // sess_cache_full
  signed int sess_cache_full;
  // sess_hit
  signed int sess_hit;
  // sess_cb_hit
  signed int sess_cb_hit;
};

struct anonymous_41
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_44
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_43
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_42
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_46
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_48
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_41 _kill;
  // _timer
  struct anonymous_42 _timer;
  // _rt
  struct anonymous_43 _rt;
  // _sigchld
  struct anonymous_44 _sigchld;
  // _sigfault
  struct anonymous_45 _sigfault;
  // _sigpoll
  struct anonymous_46 _sigpoll;
  // _sigsys
  struct anonymous_47 _sigsys;
};

struct anonymous_40
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_48 _sifields;
};

struct anonymous_17
{
  // tid
  signed int tid;
  // thread
  unsigned long int thread;
  // state
  struct anonymous_18 *state;
  // nstate
  signed int nstate;
  // start_time
  struct timeval start_time;
  // exec_elapsed
  struct timeval *exec_elapsed;
  // exec_count
  signed int *exec_count;
  // random_state
  unsigned short int random_state[3l];
  // throttle_trigger
  signed long int throttle_trigger;
  // throttle_lag
  signed long int throttle_lag;
  // throttle_lag_max
  signed long int throttle_lag_max;
};

struct anonymous_19
{
  // start_time
  signed long int start_time;
  // cnt
  signed int cnt;
  // min_latency
  double min_latency;
  // max_latency
  double max_latency;
  // sum_latency
  double sum_latency;
  // sum2_latency
  double sum2_latency;
  // min_lag
  double min_lag;
  // max_lag
  double max_lag;
  // sum_lag
  double sum_lag;
  // sum2_lag
  double sum2_lag;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct anonymous_7
{
  // addr
  struct sockaddr_storage addr;
  // salen
  unsigned int salen;
};

struct anonymous_30
{
  // conn_time
  struct timeval conn_time;
  // xacts
  signed long int xacts;
  // latencies
  signed long int latencies;
  // sqlats
  signed long int sqlats;
  // throttle_lag
  signed long int throttle_lag;
  // throttle_lag_max
  signed long int throttle_lag_max;
};

struct anonymous
{
  // conn_id_length
  unsigned int conn_id_length;
  // cert_type
  unsigned int cert_type;
  // cert_length
  unsigned int cert_length;
  // csl
  unsigned int csl;
  // clear
  unsigned int clear;
  // enc
  unsigned int enc;
  // ccl
  unsigned char ccl[32l];
  // cipher_spec_length
  unsigned int cipher_spec_length;
  // session_id_length
  unsigned int session_id_length;
  // clen
  unsigned int clen;
  // rlen
  unsigned int rlen;
};

union anonymous_50
{
  // ptr
  char *ptr;
  // rsa
  struct rsa_st *rsa;
  // dsa
  struct dsa_st *dsa;
  // dh
  struct dh_st *dh;
  // ec
  struct ec_key_st *ec;
};

union anonymous_12
{
  // ptr
  char *ptr;
  // boolean
  signed int boolean;
  // asn1_string
  struct asn1_string_st *asn1_string;
  // object
  struct asn1_object_st *object;
  // integer
  struct asn1_string_st *integer;
  // enumerated
  struct asn1_string_st *enumerated;
  // bit_string
  struct asn1_string_st *bit_string;
  // octet_string
  struct asn1_string_st *octet_string;
  // printablestring
  struct asn1_string_st *printablestring;
  // t61string
  struct asn1_string_st *t61string;
  // ia5string
  struct asn1_string_st *ia5string;
  // generalstring
  struct asn1_string_st *generalstring;
  // bmpstring
  struct asn1_string_st *bmpstring;
  // universalstring
  struct asn1_string_st *universalstring;
  // utctime
  struct asn1_string_st *utctime;
  // generalizedtime
  struct asn1_string_st *generalizedtime;
  // visiblestring
  struct asn1_string_st *visiblestring;
  // utf8string
  struct asn1_string_st *utf8string;
  // set
  struct asn1_string_st *set;
  // sequence
  struct asn1_string_st *sequence;
  // asn1_value
  struct ASN1_VALUE_st *asn1_value;
};

union anonymous_23
{
  // ifu_broadaddr
  struct sockaddr *ifu_broadaddr;
  // ifu_dstaddr
  struct sockaddr *ifu_dstaddr;
};

union anonymous_39
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_40 *, void *);
};

union anonymous_51
{
  // cb_1
  void (*cb_1)(signed int, signed int, void *);
  // cb_2
  signed int (*cb_2)(signed int, signed int, struct bn_gencb_st *);
};

union anonymous_32
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_0
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_2
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous_31
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_29
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct ASN1_ENCODING_st
{
  // enc
  unsigned char *enc;
  // len
  signed long int len;
  // modified
  signed int modified;
};

struct CancelRequestPacket
{
  // cancelRequestCode
  unsigned int cancelRequestCode;
  // backendPID
  unsigned int backendPID;
  // cancelAuthCode
  unsigned int cancelAuthCode;
};

struct DSA_SIG_st
{
  // r
  struct bignum_st *r;
  // s
  struct bignum_st *s;
};

struct PGEvent
{
  // proc
  signed int (*proc)(enum anonymous_13, void *, void *);
  // name
  char *name;
  // passThrough
  void *passThrough;
  // data
  void *data;
  // resultInitialized
  char resultInitialized;
};

struct PQEnvironmentOption
{
  // envName
  const char *envName;
  // pgName
  const char *pgName;
};

struct PQExpBufferData
{
  // data
  char *data;
  // len
  unsigned long int len;
  // maxlen
  unsigned long int maxlen;
};

struct StartupPacket
{
  // protoVersion
  unsigned int protoVersion;
  // database
  char database[64l];
  // user
  char user[32l];
  // options
  char options[64l];
  // unused
  char unused[64l];
  // tty
  char tty[64l];
};

struct X509_VERIFY_PARAM_st
{
  // name
  char *name;
  // check_time
  signed long int check_time;
  // inh_flags
  unsigned long int inh_flags;
  // flags
  unsigned long int flags;
  // purpose
  signed int purpose;
  // trust
  signed int trust;
  // depth
  signed int depth;
  // policies
  struct stack_st_ASN1_OBJECT *policies;
  // id
  struct X509_VERIFY_PARAM_ID_st *id;
};

struct X509_algor_st
{
  // algorithm
  struct asn1_object_st *algorithm;
  // parameter
  struct asn1_type_st *parameter;
};

struct X509_crl_info_st
{
  // version
  struct asn1_string_st *version;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // issuer
  struct X509_name_st *issuer;
  // lastUpdate
  struct asn1_string_st *lastUpdate;
  // nextUpdate
  struct asn1_string_st *nextUpdate;
  // revoked
  struct stack_st_X509_REVOKED *revoked;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct X509_crl_st
{
  // crl
  struct X509_crl_info_st *crl;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
  // flags
  signed int flags;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // idp
  struct ISSUING_DIST_POINT_st *idp;
  // idp_flags
  signed int idp_flags;
  // idp_reasons
  signed int idp_reasons;
  // crl_number
  struct asn1_string_st *crl_number;
  // base_crl_number
  struct asn1_string_st *base_crl_number;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // issuers
  struct stack_st_GENERAL_NAMES *issuers;
  // meth
  const struct x509_crl_method_st *meth;
  // meth_data
  void *meth_data;
};

struct X509_name_st
{
  // entries
  struct stack_st_X509_NAME_ENTRY *entries;
  // modified
  signed int modified;
  // bytes
  struct buf_mem_st *bytes;
  // canon_enc
  unsigned char *canon_enc;
  // canon_enclen
  signed int canon_enclen;
};

struct X509_pubkey_st
{
  // algor
  struct X509_algor_st *algor;
  // public_key
  struct asn1_string_st *public_key;
  // pkey
  struct evp_pkey_st *pkey;
};

struct X509_val_st
{
  // notBefore
  struct asn1_string_st *notBefore;
  // notAfter
  struct asn1_string_st *notAfter;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _PQconninfoOption
{
  // keyword
  char *keyword;
  // envvar
  char *envvar;
  // compiled
  char *compiled;
  // val
  char *val;
  // label
  char *label;
  // dispchar
  char *dispchar;
  // dispsize
  signed int dispsize;
};

struct _PQprintOpt
{
  // header
  char header;
  // align
  char align;
  // standard
  char standard;
  // html3
  char html3;
  // expanded
  char expanded;
  // pager
  char pager;
  // fieldSep
  char *fieldSep;
  // tableOpt
  char *tableOpt;
  // caption
  char *caption;
  // fieldName
  char **fieldName;
};

struct _internalPQconninfoOption
{
  // keyword
  char *keyword;
  // envvar
  char *envvar;
  // compiled
  char *compiled;
  // val
  char *val;
  // label
  char *label;
  // dispchar
  char *dispchar;
  // dispsize
  signed int dispsize;
  // connofs
  signed long int connofs;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct asn1_object_st
{
  // sn
  const char *sn;
  // ln
  const char *ln;
  // nid
  signed int nid;
  // length
  signed int length;
  // data
  const unsigned char *data;
  // flags
  signed int flags;
};

struct asn1_string_st
{
  // length
  signed int length;
  // type
  signed int type;
  // data
  unsigned char *data;
  // flags
  signed long int flags;
};

struct asn1_type_st
{
  // type
  signed int type;
  // value
  union anonymous_12 value;
};

struct berval
{
  // bv_len
  unsigned long int bv_len;
  // bv_val
  char *bv_val;
};

struct bignum_st
{
  // d
  unsigned long int *d;
  // top
  signed int top;
  // dmax
  signed int dmax;
  // neg
  signed int neg;
  // flags
  signed int flags;
};

struct bio_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // bwrite
  signed int (*bwrite)(struct bio_st *, const char *, signed int);
  // bread
  signed int (*bread)(struct bio_st *, char *, signed int);
  // bputs
  signed int (*bputs)(struct bio_st *, const char *);
  // bgets
  signed int (*bgets)(struct bio_st *, char *, signed int);
  // ctrl
  signed long int (*ctrl)(struct bio_st *, signed int, signed long int, void *);
  // create
  signed int (*create)(struct bio_st *);
  // destroy
  signed int (*destroy)(struct bio_st *);
  // callback_ctrl
  signed long int (*callback_ctrl)(struct bio_st *, signed int, void (*)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int));
};

struct crypto_ex_data_st
{
  // sk
  struct stack_st_void *sk;
  // dummy
  signed int dummy;
};

struct bio_st
{
  // method
  struct bio_method_st *method;
  // callback
  signed long int (*callback)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int);
  // cb_arg
  char *cb_arg;
  // init
  signed int init;
  // shutdown
  signed int shutdown;
  // flags
  signed int flags;
  // retry_reason
  signed int retry_reason;
  // num
  signed int num;
  // ptr
  void *ptr;
  // next_bio
  struct bio_st *next_bio;
  // prev_bio
  struct bio_st *prev_bio;
  // references
  signed int references;
  // num_read
  unsigned long int num_read;
  // num_write
  unsigned long int num_write;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct bn_gencb_st
{
  // ver
  unsigned int ver;
  // arg
  void *arg;
  // cb
  union anonymous_51 cb;
};

struct bn_mont_ctx_st
{
  // ri
  signed int ri;
  // RR
  struct bignum_st RR;
  // N
  struct bignum_st N;
  // Ni
  struct bignum_st Ni;
  // n0
  unsigned long int n0[2l];
  // flags
  signed int flags;
};

struct buf_mem_st
{
  // length
  unsigned long int length;
  // data
  char *data;
  // max
  unsigned long int max;
};

struct comp_ctx_st
{
  // meth
  struct comp_method_st *meth;
  // compress_in
  unsigned long int compress_in;
  // compress_out
  unsigned long int compress_out;
  // expand_in
  unsigned long int expand_in;
  // expand_out
  unsigned long int expand_out;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct comp_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // init
  signed int (*init)(struct comp_ctx_st *);
  // finish
  void (*finish)(struct comp_ctx_st *);
  // compress
  signed int (*compress)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // expand
  signed int (*expand)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // ctrl
  signed long int (*ctrl)(void);
  // callback_ctrl
  signed long int (*callback_ctrl)(void);
};

struct dh_method
{
  // name
  const char *name;
  // generate_key
  signed int (*generate_key)(struct dh_st *);
  // compute_key
  signed int (*compute_key)(unsigned char *, const struct bignum_st *, struct dh_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(const struct dh_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dh_st *);
  // finish
  signed int (*finish)(struct dh_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // generate_params
  signed int (*generate_params)(struct dh_st *, signed int, signed int, struct bn_gencb_st *);
};

struct dh_st
{
  // pad
  signed int pad;
  // version
  signed int version;
  // p
  struct bignum_st *p;
  // g
  struct bignum_st *g;
  // length
  signed long int length;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // q
  struct bignum_st *q;
  // j
  struct bignum_st *j;
  // seed
  unsigned char *seed;
  // seedlen
  signed int seedlen;
  // counter
  struct bignum_st *counter;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dh_method *meth;
  // engine
  struct engine_st *engine;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct dsa_method
{
  // name
  const char *name;
  // dsa_do_sign
  struct DSA_SIG_st * (*dsa_do_sign)(const unsigned char *, signed int, struct dsa_st *);
  // dsa_sign_setup
  signed int (*dsa_sign_setup)(struct dsa_st *, struct bignum_ctx *, struct bignum_st **, struct bignum_st **);
  // dsa_do_verify
  signed int (*dsa_do_verify)(const unsigned char *, signed int, struct DSA_SIG_st *, struct dsa_st *);
  // dsa_mod_exp
  signed int (*dsa_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dsa_st *);
  // finish
  signed int (*finish)(struct dsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // dsa_paramgen
  signed int (*dsa_paramgen)(struct dsa_st *, signed int, const unsigned char *, signed int, signed int *, unsigned long int *, struct bn_gencb_st *);
  // dsa_keygen
  signed int (*dsa_keygen)(struct dsa_st *);
};

struct dsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // write_params
  signed int write_params;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // g
  struct bignum_st *g;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // kinv
  struct bignum_st *kinv;
  // r
  struct bignum_st *r;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dsa_method *meth;
  // engine
  struct engine_st *engine;
};

struct dtls1_bitmap_st
{
  // map
  unsigned long int map;
  // max_seq_num
  unsigned char max_seq_num[8l];
};

struct dtls1_retransmit_state
{
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // session
  struct ssl_session_st *session;
  // epoch
  unsigned short int epoch;
};

struct record_pqueue_st
{
  // epoch
  unsigned short int epoch;
  // q
  struct _pqueue *q;
};

struct hm_header_st
{
  // type
  unsigned char type;
  // msg_len
  unsigned long int msg_len;
  // seq
  unsigned short int seq;
  // frag_off
  unsigned long int frag_off;
  // frag_len
  unsigned long int frag_len;
  // is_ccs
  unsigned int is_ccs;
  // saved_retransmit_state
  struct dtls1_retransmit_state saved_retransmit_state;
};

struct dtls1_timeout_st
{
  // read_timeouts
  unsigned int read_timeouts;
  // write_timeouts
  unsigned int write_timeouts;
  // num_alerts
  unsigned int num_alerts;
};

struct dtls1_state_st
{
  // send_cookie
  unsigned int send_cookie;
  // cookie
  unsigned char cookie[256l];
  // rcvd_cookie
  unsigned char rcvd_cookie[256l];
  // cookie_len
  unsigned int cookie_len;
  // r_epoch
  unsigned short int r_epoch;
  // w_epoch
  unsigned short int w_epoch;
  // bitmap
  struct dtls1_bitmap_st bitmap;
  // next_bitmap
  struct dtls1_bitmap_st next_bitmap;
  // handshake_write_seq
  unsigned short int handshake_write_seq;
  // next_handshake_write_seq
  unsigned short int next_handshake_write_seq;
  // handshake_read_seq
  unsigned short int handshake_read_seq;
  // last_write_sequence
  unsigned char last_write_sequence[8l];
  // unprocessed_rcds
  struct record_pqueue_st unprocessed_rcds;
  // processed_rcds
  struct record_pqueue_st processed_rcds;
  // buffered_messages
  struct _pqueue *buffered_messages;
  // sent_messages
  struct _pqueue *sent_messages;
  // buffered_app_data
  struct record_pqueue_st buffered_app_data;
  // listen
  unsigned int listen;
  // link_mtu
  unsigned int link_mtu;
  // mtu
  unsigned int mtu;
  // w_msg_hdr
  struct hm_header_st w_msg_hdr;
  // r_msg_hdr
  struct hm_header_st r_msg_hdr;
  // timeout
  struct dtls1_timeout_st timeout;
  // next_timeout
  struct timeval next_timeout;
  // timeout_duration
  unsigned short int timeout_duration;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[12l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // retransmitting
  unsigned int retransmitting;
  // change_cipher_spec_ok
  unsigned int change_cipher_spec_ok;
};

struct encoding_match
{
  // pg_enc_code
  enum pg_enc pg_enc_code;
  // system_enc_name
  const char *system_enc_name;
};

struct env_md_ctx_st
{
  // digest
  const struct env_md_st *digest;
  // engine
  struct engine_st *engine;
  // flags
  unsigned long int flags;
  // md_data
  void *md_data;
  // pctx
  struct evp_pkey_ctx_st *pctx;
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
};

struct env_md_st
{
  // type
  signed int type;
  // pkey_type
  signed int pkey_type;
  // md_size
  signed int md_size;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct env_md_ctx_st *);
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
  // final
  signed int (*final)(struct env_md_ctx_st *, unsigned char *);
  // copy
  signed int (*copy)(struct env_md_ctx_st *, const struct env_md_ctx_st *);
  // cleanup
  signed int (*cleanup)(struct env_md_ctx_st *);
  // sign
  signed int (*sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, void *);
  // verify
  signed int (*verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, void *);
  // required_pkey_type
  signed int required_pkey_type[5l];
  // block_size
  signed int block_size;
  // ctx_size
  signed int ctx_size;
  // md_ctrl
  signed int (*md_ctrl)(struct env_md_ctx_st *, signed int, signed int, void *);
};

struct evp_cipher_ctx_st
{
  // cipher
  const struct evp_cipher_st *cipher;
  // engine
  struct engine_st *engine;
  // encrypt
  signed int encrypt;
  // buf_len
  signed int buf_len;
  // oiv
  unsigned char oiv[16l];
  // iv
  unsigned char iv[16l];
  // buf
  unsigned char buf[32l];
  // num
  signed int num;
  // app_data
  void *app_data;
  // key_len
  signed int key_len;
  // flags
  unsigned long int flags;
  // cipher_data
  void *cipher_data;
  // final_used
  signed int final_used;
  // block_mask
  signed int block_mask;
  // final
  unsigned char final[32l];
};

struct evp_cipher_st
{
  // nid
  signed int nid;
  // block_size
  signed int block_size;
  // key_len
  signed int key_len;
  // iv_len
  signed int iv_len;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct evp_cipher_ctx_st *, const unsigned char *, const unsigned char *, signed int);
  // do_cipher
  signed int (*do_cipher)(struct evp_cipher_ctx_st *, unsigned char *, const unsigned char *, unsigned long int);
  // cleanup
  signed int (*cleanup)(struct evp_cipher_ctx_st *);
  // ctx_size
  signed int ctx_size;
  // set_asn1_parameters
  signed int (*set_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // get_asn1_parameters
  signed int (*get_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // ctrl
  signed int (*ctrl)(struct evp_cipher_ctx_st *, signed int, signed int, void *);
  // app_data
  void *app_data;
};

struct evp_pkey_st
{
  // type
  signed int type;
  // save_type
  signed int save_type;
  // references
  signed int references;
  // ameth
  const struct evp_pkey_asn1_method_st *ameth;
  // engine
  struct engine_st *engine;
  // pkey
  union anonymous_50 pkey;
  // save_parameters
  signed int save_parameters;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct gss_OID_desc_struct
{
  // length
  unsigned int length;
  // elements
  void *elements;
};

struct gss_buffer_desc_struct
{
  // length
  unsigned long int length;
  // value
  void *value;
};

struct gss_channel_bindings_struct
{
  // initiator_addrtype
  unsigned int initiator_addrtype;
  // initiator_address
  struct gss_buffer_desc_struct initiator_address;
  // acceptor_addrtype
  unsigned int acceptor_addrtype;
  // acceptor_address
  struct gss_buffer_desc_struct acceptor_address;
  // application_data
  struct gss_buffer_desc_struct application_data;
};

struct hmac_ctx_st
{
  // md
  const struct env_md_st *md;
  // md_ctx
  struct env_md_ctx_st md_ctx;
  // i_ctx
  struct env_md_ctx_st i_ctx;
  // o_ctx
  struct env_md_ctx_st o_ctx;
  // key_length
  unsigned int key_length;
  // key
  unsigned char key[128l];
};

struct ifaddrs
{
  // ifa_next
  struct ifaddrs *ifa_next;
  // ifa_name
  char *ifa_name;
  // ifa_flags
  unsigned int ifa_flags;
  // ifa_addr
  struct sockaddr *ifa_addr;
  // ifa_netmask
  struct sockaddr *ifa_netmask;
  // ifa_ifu
  union anonymous_23 ifa_ifu;
  // ifa_data
  void *ifa_data;
};

struct in6_addr
{
  // __in6_u
  union anonymous_32 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct lhash_st_SSL_SESSION
{
  // dummy
  signed int dummy;
};

struct mbinterval
{
  // first
  unsigned short int first;
  // last
  unsigned short int last;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pgDataValue
{
  // len
  signed int len;
  // value
  const char *value;
};

struct pgLobjfuncs
{
  // fn_lo_open
  unsigned int fn_lo_open;
  // fn_lo_close
  unsigned int fn_lo_close;
  // fn_lo_creat
  unsigned int fn_lo_creat;
  // fn_lo_create
  unsigned int fn_lo_create;
  // fn_lo_unlink
  unsigned int fn_lo_unlink;
  // fn_lo_lseek
  unsigned int fn_lo_lseek;
  // fn_lo_lseek64
  unsigned int fn_lo_lseek64;
  // fn_lo_tell
  unsigned int fn_lo_tell;
  // fn_lo_tell64
  unsigned int fn_lo_tell64;
  // fn_lo_truncate
  unsigned int fn_lo_truncate;
  // fn_lo_truncate64
  unsigned int fn_lo_truncate64;
  // fn_lo_read
  unsigned int fn_lo_read;
  // fn_lo_write
  unsigned int fn_lo_write;
};

struct pgMessageField
{
  // next
  struct pgMessageField *next;
  // code
  char code;
  // contents
  char contents[1l];
};

struct pgNotify
{
  // relname
  char *relname;
  // be_pid
  signed int be_pid;
  // extra
  char *extra;
  // next
  struct pgNotify *next;
};

struct pgParameterStatus
{
  // next
  struct pgParameterStatus *next;
  // name
  char *name;
  // value
  char *value;
};

struct pg_cancel
{
  // raddr
  struct anonymous_7 raddr;
  // be_pid
  signed int be_pid;
  // be_key
  signed int be_key;
};

struct pg_conn
{
  // pghost
  char *pghost;
  // pghostaddr
  char *pghostaddr;
  // pgport
  char *pgport;
  // pgunixsocket
  char *pgunixsocket;
  // pgtty
  char *pgtty;
  // connect_timeout
  char *connect_timeout;
  // client_encoding_initial
  char *client_encoding_initial;
  // pgoptions
  char *pgoptions;
  // appname
  char *appname;
  // fbappname
  char *fbappname;
  // dbName
  char *dbName;
  // replication
  char *replication;
  // pguser
  char *pguser;
  // pgpass
  char *pgpass;
  // keepalives
  char *keepalives;
  // keepalives_idle
  char *keepalives_idle;
  // keepalives_interval
  char *keepalives_interval;
  // keepalives_count
  char *keepalives_count;
  // sslmode
  char *sslmode;
  // sslcompression
  char *sslcompression;
  // sslkey
  char *sslkey;
  // sslcert
  char *sslcert;
  // sslrootcert
  char *sslrootcert;
  // sslcrl
  char *sslcrl;
  // requirepeer
  char *requirepeer;
  // krbsrvname
  char *krbsrvname;
  // Pfdebug
  struct _IO_FILE *Pfdebug;
  // noticeHooks
  struct anonymous_8 noticeHooks;
  // events
  struct PGEvent *events;
  // nEvents
  signed int nEvents;
  // eventArraySize
  signed int eventArraySize;
  // status
  enum anonymous_24 status;
  // asyncStatus
  enum anonymous_9 asyncStatus;
  // xactStatus
  enum anonymous_3 xactStatus;
  // queryclass
  enum anonymous_10 queryclass;
  // last_query
  char *last_query;
  // last_sqlstate
  char last_sqlstate[6l];
  // options_valid
  char options_valid;
  // nonblocking
  char nonblocking;
  // singleRowMode
  char singleRowMode;
  // copy_is_binary
  char copy_is_binary;
  // copy_already_done
  signed int copy_already_done;
  // notifyHead
  struct pgNotify *notifyHead;
  // notifyTail
  struct pgNotify *notifyTail;
  // sock
  signed int sock;
  // laddr
  struct anonymous_7 laddr;
  // raddr
  struct anonymous_7 raddr;
  // pversion
  unsigned int pversion;
  // sversion
  signed int sversion;
  // auth_req_received
  char auth_req_received;
  // password_needed
  char password_needed;
  // dot_pgpass_used
  char dot_pgpass_used;
  // sigpipe_so
  char sigpipe_so;
  // sigpipe_flag
  char sigpipe_flag;
  // addrlist
  struct addrinfo *addrlist;
  // addr_cur
  struct addrinfo *addr_cur;
  // addrlist_family
  signed int addrlist_family;
  // setenv_state
  enum anonymous_11 setenv_state;
  // next_eo
  const struct PQEnvironmentOption *next_eo;
  // send_appname
  char send_appname;
  // be_pid
  signed int be_pid;
  // be_key
  signed int be_key;
  // md5Salt
  char md5Salt[4l];
  // pstatus
  struct pgParameterStatus *pstatus;
  // client_encoding
  signed int client_encoding;
  // std_strings
  char std_strings;
  // verbosity
  enum anonymous_5 verbosity;
  // lobjfuncs
  struct pgLobjfuncs *lobjfuncs;
  // inBuffer
  char *inBuffer;
  // inBufSize
  signed int inBufSize;
  // inStart
  signed int inStart;
  // inCursor
  signed int inCursor;
  // inEnd
  signed int inEnd;
  // outBuffer
  char *outBuffer;
  // outBufSize
  signed int outBufSize;
  // outCount
  signed int outCount;
  // outMsgStart
  signed int outMsgStart;
  // outMsgEnd
  signed int outMsgEnd;
  // rowBuf
  struct pgDataValue *rowBuf;
  // rowBufLen
  signed int rowBufLen;
  // result
  struct pg_result *result;
  // next_result
  struct pg_result *next_result;
  // allow_ssl_try
  char allow_ssl_try;
  // wait_ssl_try
  char wait_ssl_try;
  // ssl
  struct ssl_st *ssl;
  // peer
  struct x509_st *peer;
  // engine
  struct engine_st *engine;
  // gctx
  struct gss_ctx_id_struct *gctx;
  // gtarg_nam
  struct gss_name_struct *gtarg_nam;
  // ginbuf
  struct gss_buffer_desc_struct ginbuf;
  // goutbuf
  struct gss_buffer_desc_struct goutbuf;
  // errorMessage
  struct PQExpBufferData errorMessage;
  // workBuffer
  struct PQExpBufferData workBuffer;
};

struct pg_enc2gettext
{
  // encoding
  enum pg_enc encoding;
  // name
  const char *name;
};

struct pg_enc2name
{
  // name
  const char *name;
  // encoding
  enum pg_enc encoding;
};

struct pg_encname
{
  // name
  const char *name;
  // encoding
  enum pg_enc encoding;
};

struct pg_result
{
  // ntups
  signed int ntups;
  // numAttributes
  signed int numAttributes;
  // attDescs
  struct pgresAttDesc *attDescs;
  // tuples
  struct pgresAttValue **tuples;
  // tupArrSize
  signed int tupArrSize;
  // numParameters
  signed int numParameters;
  // paramDescs
  struct pgresParamDesc *paramDescs;
  // resultStatus
  enum anonymous_20 resultStatus;
  // cmdStatus
  char cmdStatus[64l];
  // binary
  signed int binary;
  // noticeHooks
  struct anonymous_8 noticeHooks;
  // events
  struct PGEvent *events;
  // nEvents
  signed int nEvents;
  // client_encoding
  signed int client_encoding;
  // errMsg
  char *errMsg;
  // errFields
  struct pgMessageField *errFields;
  // null_field
  char null_field[1l];
  // curBlock
  union pgresult_data *curBlock;
  // curOffset
  signed int curOffset;
  // spaceLeft
  signed int spaceLeft;
};

struct pgresAttDesc
{
  // name
  char *name;
  // tableid
  unsigned int tableid;
  // columnid
  signed int columnid;
  // format
  signed int format;
  // typid
  unsigned int typid;
  // typlen
  signed int typlen;
  // atttypmod
  signed int atttypmod;
};

struct pgresAttValue
{
  // len
  signed int len;
  // value
  char *value;
};

struct pgresParamDesc
{
  // typid
  unsigned int typid;
};

union pgresult_data
{
  // next
  union pgresult_data *next;
  // space
  char space[1l];
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct rsa_meth_st
{
  // name
  const char *name;
  // rsa_pub_enc
  signed int (*rsa_pub_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_pub_dec
  signed int (*rsa_pub_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_enc
  signed int (*rsa_priv_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_dec
  signed int (*rsa_priv_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_mod_exp
  signed int (*rsa_mod_exp)(struct bignum_st *, const struct bignum_st *, struct rsa_st *, struct bignum_ctx *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct rsa_st *);
  // finish
  signed int (*finish)(struct rsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // rsa_sign
  signed int (*rsa_sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, const struct rsa_st *);
  // rsa_verify
  signed int (*rsa_verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, const struct rsa_st *);
  // rsa_keygen
  signed int (*rsa_keygen)(struct rsa_st *, signed int, struct bignum_st *, struct bn_gencb_st *);
};

struct rsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // meth
  const struct rsa_meth_st *meth;
  // engine
  struct engine_st *engine;
  // n
  struct bignum_st *n;
  // e
  struct bignum_st *e;
  // d
  struct bignum_st *d;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // dmp1
  struct bignum_st *dmp1;
  // dmq1
  struct bignum_st *dmq1;
  // iqmp
  struct bignum_st *iqmp;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
  // flags
  signed int flags;
  // _method_mod_n
  struct bn_mont_ctx_st *_method_mod_n;
  // _method_mod_p
  struct bn_mont_ctx_st *_method_mod_p;
  // _method_mod_q
  struct bn_mont_ctx_st *_method_mod_q;
  // bignum_data
  char *bignum_data;
  // blinding
  struct bn_blinding_st *blinding;
  // mt_blinding
  struct bn_blinding_st *mt_blinding;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_39 __sigaction_handler;
  // sa_mask
  struct anonymous_6 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sigpipe_info
{
  // oldsigmask
  struct anonymous_6 oldsigmask;
  // sigpipe_pending
  char sigpipe_pending;
  // got_epipe
  char got_epipe;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct srp_ctx_st
{
  // SRP_cb_arg
  void *SRP_cb_arg;
  // TLS_ext_srp_username_callback
  signed int (*TLS_ext_srp_username_callback)(struct ssl_st *, signed int *, void *);
  // SRP_verify_param_callback
  signed int (*SRP_verify_param_callback)(struct ssl_st *, void *);
  // SRP_give_srp_client_pwd_callback
  char * (*SRP_give_srp_client_pwd_callback)(struct ssl_st *, void *);
  // login
  char *login;
  // N
  struct bignum_st *N;
  // g
  struct bignum_st *g;
  // s
  struct bignum_st *s;
  // B
  struct bignum_st *B;
  // A
  struct bignum_st *A;
  // a
  struct bignum_st *a;
  // b
  struct bignum_st *b;
  // v
  struct bignum_st *v;
  // info
  char *info;
  // strength
  signed int strength;
  // srp_Mask
  unsigned long int srp_Mask;
};

struct srtp_protection_profile_st
{
  // name
  const char *name;
  // id
  unsigned long int id;
};

struct ssl2_state_st
{
  // three_byte_header
  signed int three_byte_header;
  // clear_text
  signed int clear_text;
  // escape
  signed int escape;
  // ssl2_rollback
  signed int ssl2_rollback;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_buf
  const unsigned char *wpend_buf;
  // wpend_off
  signed int wpend_off;
  // wpend_len
  signed int wpend_len;
  // wpend_ret
  signed int wpend_ret;
  // rbuf_left
  signed int rbuf_left;
  // rbuf_offs
  signed int rbuf_offs;
  // rbuf
  unsigned char *rbuf;
  // wbuf
  unsigned char *wbuf;
  // write_ptr
  unsigned char *write_ptr;
  // padding
  unsigned int padding;
  // rlength
  unsigned int rlength;
  // ract_data_length
  signed int ract_data_length;
  // wlength
  unsigned int wlength;
  // wact_data_length
  signed int wact_data_length;
  // ract_data
  unsigned char *ract_data;
  // wact_data
  unsigned char *wact_data;
  // mac_data
  unsigned char *mac_data;
  // read_key
  unsigned char *read_key;
  // write_key
  unsigned char *write_key;
  // challenge_length
  unsigned int challenge_length;
  // challenge
  unsigned char challenge[32l];
  // conn_id_length
  unsigned int conn_id_length;
  // conn_id
  unsigned char conn_id[16l];
  // key_material_length
  unsigned int key_material_length;
  // key_material
  unsigned char key_material[48l];
  // read_sequence
  unsigned long int read_sequence;
  // write_sequence
  unsigned long int write_sequence;
  // tmp
  struct anonymous tmp;
};

struct ssl3_buffer_st
{
  // buf
  unsigned char *buf;
  // len
  unsigned long int len;
  // offset
  signed int offset;
  // left
  signed int left;
};

struct ssl3_record_st
{
  // type
  signed int type;
  // length
  unsigned int length;
  // off
  unsigned int off;
  // data
  unsigned char *data;
  // input
  unsigned char *input;
  // comp
  unsigned char *comp;
  // epoch
  unsigned long int epoch;
  // seq_num
  unsigned char seq_num[8l];
};

struct ssl3_state_st
{
  // flags
  signed long int flags;
  // delay_buf_pop_ret
  signed int delay_buf_pop_ret;
  // read_sequence
  unsigned char read_sequence[8l];
  // read_mac_secret_size
  signed int read_mac_secret_size;
  // read_mac_secret
  unsigned char read_mac_secret[64l];
  // write_sequence
  unsigned char write_sequence[8l];
  // write_mac_secret_size
  signed int write_mac_secret_size;
  // write_mac_secret
  unsigned char write_mac_secret[64l];
  // server_random
  unsigned char server_random[32l];
  // client_random
  unsigned char client_random[32l];
  // need_empty_fragments
  signed int need_empty_fragments;
  // empty_fragment_done
  signed int empty_fragment_done;
  // init_extra
  signed int init_extra;
  // rbuf
  struct ssl3_buffer_st rbuf;
  // wbuf
  struct ssl3_buffer_st wbuf;
  // rrec
  struct ssl3_record_st rrec;
  // wrec
  struct ssl3_record_st wrec;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[4l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_type
  signed int wpend_type;
  // wpend_ret
  signed int wpend_ret;
  // wpend_buf
  const unsigned char *wpend_buf;
  // handshake_buffer
  struct bio_st *handshake_buffer;
  // handshake_dgst
  struct env_md_ctx_st **handshake_dgst;
  // change_cipher_spec
  signed int change_cipher_spec;
  // warn_alert
  signed int warn_alert;
  // fatal_alert
  signed int fatal_alert;
  // alert_dispatch
  signed int alert_dispatch;
  // send_alert
  unsigned char send_alert[2l];
  // renegotiate
  signed int renegotiate;
  // total_renegotiations
  signed int total_renegotiations;
  // num_renegotiations
  signed int num_renegotiations;
  // in_read_app_data
  signed int in_read_app_data;
  // client_opaque_prf_input
  void *client_opaque_prf_input;
  // client_opaque_prf_input_len
  unsigned long int client_opaque_prf_input_len;
  // server_opaque_prf_input
  void *server_opaque_prf_input;
  // server_opaque_prf_input_len
  unsigned long int server_opaque_prf_input_len;
  // tmp
  struct anonymous_1 tmp;
  // previous_client_finished
  unsigned char previous_client_finished[64l];
  // previous_client_finished_len
  unsigned char previous_client_finished_len;
  // previous_server_finished
  unsigned char previous_server_finished[64l];
  // previous_server_finished_len
  unsigned char previous_server_finished_len;
  // send_connection_binding
  signed int send_connection_binding;
  // next_proto_neg_seen
  signed int next_proto_neg_seen;
  // is_probably_safari
  char is_probably_safari;
  // alpn_selected
  unsigned char *alpn_selected;
  // alpn_selected_len
  unsigned int alpn_selected_len;
};

struct ssl_cipher_st
{
  // valid
  signed int valid;
  // name
  const char *name;
  // id
  unsigned long int id;
  // algorithm_mkey
  unsigned long int algorithm_mkey;
  // algorithm_auth
  unsigned long int algorithm_auth;
  // algorithm_enc
  unsigned long int algorithm_enc;
  // algorithm_mac
  unsigned long int algorithm_mac;
  // algorithm_ssl
  unsigned long int algorithm_ssl;
  // algo_strength
  unsigned long int algo_strength;
  // algorithm2
  unsigned long int algorithm2;
  // strength_bits
  signed int strength_bits;
  // alg_bits
  signed int alg_bits;
};

struct ssl_comp_st
{
  // id
  signed int id;
  // name
  const char *name;
  // method
  struct comp_method_st *method;
};

struct ssl_ctx_st
{
  // method
  const struct ssl_method_st *method;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // cert_store
  struct x509_store_st *cert_store;
  // sessions
  struct lhash_st_SSL_SESSION *sessions;
  // session_cache_size
  unsigned long int session_cache_size;
  // session_cache_head
  struct ssl_session_st *session_cache_head;
  // session_cache_tail
  struct ssl_session_st *session_cache_tail;
  // session_cache_mode
  signed int session_cache_mode;
  // session_timeout
  signed long int session_timeout;
  // new_session_cb
  signed int (*new_session_cb)(struct ssl_st *, struct ssl_session_st *);
  // remove_session_cb
  void (*remove_session_cb)(struct ssl_ctx_st *, struct ssl_session_st *);
  // get_session_cb
  struct ssl_session_st * (*get_session_cb)(struct ssl_st *, unsigned char *, signed int, signed int *);
  // stats
  struct anonymous_49 stats;
  // references
  signed int references;
  // app_verify_callback
  signed int (*app_verify_callback)(struct x509_store_ctx_st *, void *);
  // app_verify_arg
  void *app_verify_arg;
  // default_passwd_callback
  signed int (*default_passwd_callback)(char *, signed int, signed int, void *);
  // default_passwd_callback_userdata
  void *default_passwd_callback_userdata;
  // client_cert_cb
  signed int (*client_cert_cb)(struct ssl_st *, struct x509_st **, struct evp_pkey_st **);
  // app_gen_cookie_cb
  signed int (*app_gen_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int *);
  // app_verify_cookie_cb
  signed int (*app_verify_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // rsa_md5
  const struct env_md_st *rsa_md5;
  // md5
  const struct env_md_st *md5;
  // sha1
  const struct env_md_st *sha1;
  // extra_certs
  struct stack_st_X509 *extra_certs;
  // comp_methods
  struct stack_st_SSL_COMP *comp_methods;
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // cert
  struct cert_st *cert;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // verify_mode
  signed int verify_mode;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // default_verify_callback
  signed int (*default_verify_callback)(signed int, struct x509_store_ctx_st *);
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // param
  struct X509_VERIFY_PARAM_st *param;
  // quiet_shutdown
  signed int quiet_shutdown;
  // max_send_fragment
  unsigned int max_send_fragment;
  // client_cert_engine
  struct engine_st *client_cert_engine;
  // tlsext_servername_callback
  signed int (*tlsext_servername_callback)(struct ssl_st *, signed int *, void *);
  // tlsext_servername_arg
  void *tlsext_servername_arg;
  // tlsext_tick_key_name
  unsigned char tlsext_tick_key_name[16l];
  // tlsext_tick_hmac_key
  unsigned char tlsext_tick_hmac_key[16l];
  // tlsext_tick_aes_key
  unsigned char tlsext_tick_aes_key[16l];
  // tlsext_ticket_key_cb
  signed int (*tlsext_ticket_key_cb)(struct ssl_st *, unsigned char *, unsigned char *, struct evp_cipher_ctx_st *, struct hmac_ctx_st *, signed int);
  // tlsext_status_cb
  signed int (*tlsext_status_cb)(struct ssl_st *, void *);
  // tlsext_status_arg
  void *tlsext_status_arg;
  // tlsext_opaque_prf_input_callback
  signed int (*tlsext_opaque_prf_input_callback)(struct ssl_st *, void *, unsigned long int, void *);
  // tlsext_opaque_prf_input_callback_arg
  void *tlsext_opaque_prf_input_callback_arg;
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // freelist_max_len
  unsigned int freelist_max_len;
  // wbuf_freelist
  struct ssl3_buf_freelist_st *wbuf_freelist;
  // rbuf_freelist
  struct ssl3_buf_freelist_st *rbuf_freelist;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // next_protos_advertised_cb
  signed int (*next_protos_advertised_cb)(struct ssl_st *, const unsigned char **, unsigned int *, void *);
  // next_protos_advertised_cb_arg
  void *next_protos_advertised_cb_arg;
  // next_proto_select_cb
  signed int (*next_proto_select_cb)(struct ssl_st *, unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // next_proto_select_cb_arg
  void *next_proto_select_cb_arg;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // alpn_select_cb
  signed int (*alpn_select_cb)(struct ssl_st *, const unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // alpn_select_cb_arg
  void *alpn_select_cb_arg;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
};

struct ssl_method_st
{
  // version
  signed int version;
  // ssl_new
  signed int (*ssl_new)(struct ssl_st *);
  // ssl_clear
  void (*ssl_clear)(struct ssl_st *);
  // ssl_free
  void (*ssl_free)(struct ssl_st *);
  // ssl_accept
  signed int (*ssl_accept)(struct ssl_st *);
  // ssl_connect
  signed int (*ssl_connect)(struct ssl_st *);
  // ssl_read
  signed int (*ssl_read)(struct ssl_st *, void *, signed int);
  // ssl_peek
  signed int (*ssl_peek)(struct ssl_st *, void *, signed int);
  // ssl_write
  signed int (*ssl_write)(struct ssl_st *, const void *, signed int);
  // ssl_shutdown
  signed int (*ssl_shutdown)(struct ssl_st *);
  // ssl_renegotiate
  signed int (*ssl_renegotiate)(struct ssl_st *);
  // ssl_renegotiate_check
  signed int (*ssl_renegotiate_check)(struct ssl_st *);
  // ssl_get_message
  signed long int (*ssl_get_message)(struct ssl_st *, signed int, signed int, signed int, signed long int, signed int *);
  // ssl_read_bytes
  signed int (*ssl_read_bytes)(struct ssl_st *, signed int, unsigned char *, signed int, signed int);
  // ssl_write_bytes
  signed int (*ssl_write_bytes)(struct ssl_st *, signed int, const void *, signed int);
  // ssl_dispatch_alert
  signed int (*ssl_dispatch_alert)(struct ssl_st *);
  // ssl_ctrl
  signed long int (*ssl_ctrl)(struct ssl_st *, signed int, signed long int, void *);
  // ssl_ctx_ctrl
  signed long int (*ssl_ctx_ctrl)(struct ssl_ctx_st *, signed int, signed long int, void *);
  // get_cipher_by_char
  const struct ssl_cipher_st * (*get_cipher_by_char)(const unsigned char *);
  // put_cipher_by_char
  signed int (*put_cipher_by_char)(const struct ssl_cipher_st *, unsigned char *);
  // ssl_pending
  signed int (*ssl_pending)(const struct ssl_st *);
  // num_ciphers
  signed int (*num_ciphers)(void);
  // get_cipher
  const struct ssl_cipher_st * (*get_cipher)(unsigned int);
  // get_ssl_method
  struct ssl_method_st * (*get_ssl_method)(signed int);
  // get_timeout
  signed long int (*get_timeout)(void);
  // ssl3_enc
  struct ssl3_enc_method *ssl3_enc;
  // ssl_version
  signed int (*ssl_version)(void);
  // ssl_callback_ctrl
  signed long int (*ssl_callback_ctrl)(struct ssl_st *, signed int, void (*)(void));
  // ssl_ctx_callback_ctrl
  signed long int (*ssl_ctx_callback_ctrl)(struct ssl_ctx_st *, signed int, void (*)(void));
};

struct ssl_session_st
{
  // ssl_version
  signed int ssl_version;
  // key_arg_length
  unsigned int key_arg_length;
  // key_arg
  unsigned char key_arg[8l];
  // master_key_length
  signed int master_key_length;
  // master_key
  unsigned char master_key[48l];
  // session_id_length
  unsigned int session_id_length;
  // session_id
  unsigned char session_id[32l];
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_identity
  char *psk_identity;
  // not_resumable
  signed int not_resumable;
  // sess_cert
  struct sess_cert_st *sess_cert;
  // peer
  struct x509_st *peer;
  // verify_result
  signed long int verify_result;
  // references
  signed int references;
  // timeout
  signed long int timeout;
  // time
  signed long int time;
  // compress_meth
  unsigned int compress_meth;
  // cipher
  const struct ssl_cipher_st *cipher;
  // cipher_id
  unsigned long int cipher_id;
  // ciphers
  struct stack_st_SSL_CIPHER *ciphers;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // prev
  struct ssl_session_st *prev;
  // next
  struct ssl_session_st *next;
  // tlsext_hostname
  char *tlsext_hostname;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_tick
  unsigned char *tlsext_tick;
  // tlsext_ticklen
  unsigned long int tlsext_ticklen;
  // tlsext_tick_lifetime_hint
  signed long int tlsext_tick_lifetime_hint;
  // srp_username
  char *srp_username;
};

struct ssl_st
{
  // version
  signed int version;
  // type
  signed int type;
  // method
  const struct ssl_method_st *method;
  // rbio
  struct bio_st *rbio;
  // wbio
  struct bio_st *wbio;
  // bbio
  struct bio_st *bbio;
  // rwstate
  signed int rwstate;
  // in_handshake
  signed int in_handshake;
  // handshake_func
  signed int (*handshake_func)(struct ssl_st *);
  // server
  signed int server;
  // new_session
  signed int new_session;
  // quiet_shutdown
  signed int quiet_shutdown;
  // shutdown
  signed int shutdown;
  // state
  signed int state;
  // rstate
  signed int rstate;
  // init_buf
  struct buf_mem_st *init_buf;
  // init_msg
  void *init_msg;
  // init_num
  signed int init_num;
  // init_off
  signed int init_off;
  // packet
  unsigned char *packet;
  // packet_length
  unsigned int packet_length;
  // s2
  struct ssl2_state_st *s2;
  // s3
  struct ssl3_state_st *s3;
  // d1
  struct dtls1_state_st *d1;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // hit
  signed int hit;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // mac_flags
  signed int mac_flags;
  // enc_read_ctx
  struct evp_cipher_ctx_st *enc_read_ctx;
  // read_hash
  struct env_md_ctx_st *read_hash;
  // expand
  struct comp_ctx_st *expand;
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // cert
  struct cert_st *cert;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // session
  struct ssl_session_st *session;
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // verify_mode
  signed int verify_mode;
  // verify_callback
  signed int (*verify_callback)(signed int, struct x509_store_ctx_st *);
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // error
  signed int error;
  // error_code
  signed int error_code;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // ctx
  struct ssl_ctx_st *ctx;
  // debug
  signed int debug;
  // verify_result
  signed long int verify_result;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // references
  signed int references;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // first_packet
  signed int first_packet;
  // client_version
  signed int client_version;
  // max_send_fragment
  unsigned int max_send_fragment;
  // tlsext_debug_cb
  void (*tlsext_debug_cb)(struct ssl_st *, signed int, signed int, unsigned char *, signed int, void *);
  // tlsext_debug_arg
  void *tlsext_debug_arg;
  // tlsext_hostname
  char *tlsext_hostname;
  // servername_done
  signed int servername_done;
  // tlsext_status_type
  signed int tlsext_status_type;
  // tlsext_status_expected
  signed int tlsext_status_expected;
  // tlsext_ocsp_ids
  struct stack_st_OCSP_RESPID *tlsext_ocsp_ids;
  // tlsext_ocsp_exts
  struct stack_st_X509_EXTENSION *tlsext_ocsp_exts;
  // tlsext_ocsp_resp
  unsigned char *tlsext_ocsp_resp;
  // tlsext_ocsp_resplen
  signed int tlsext_ocsp_resplen;
  // tlsext_ticket_expected
  signed int tlsext_ticket_expected;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_opaque_prf_input
  void *tlsext_opaque_prf_input;
  // tlsext_opaque_prf_input_len
  unsigned long int tlsext_opaque_prf_input_len;
  // tlsext_session_ticket
  struct tls_session_ticket_ext_st *tlsext_session_ticket;
  // tls_session_ticket_ext_cb
  signed int (*tls_session_ticket_ext_cb)(struct ssl_st *, const unsigned char *, signed int, void *);
  // tls_session_ticket_ext_cb_arg
  void *tls_session_ticket_ext_cb_arg;
  // tls_session_secret_cb
  signed int (*tls_session_secret_cb)(struct ssl_st *, void *, signed int *, struct stack_st_SSL_CIPHER *, struct ssl_cipher_st **, void *);
  // tls_session_secret_cb_arg
  void *tls_session_secret_cb_arg;
  // initial_ctx
  struct ssl_ctx_st *initial_ctx;
  // next_proto_negotiated
  unsigned char *next_proto_negotiated;
  // next_proto_negotiated_len
  unsigned char next_proto_negotiated_len;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // srtp_profile
  struct srtp_protection_profile_st *srtp_profile;
  // tlsext_heartbeat
  unsigned int tlsext_heartbeat;
  // tlsext_hb_pending
  unsigned int tlsext_hb_pending;
  // tlsext_hb_seq
  unsigned int tlsext_hb_seq;
  // renegotiate
  signed int renegotiate;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
};

struct stack_st
{
  // num
  signed int num;
  // data
  char **data;
  // sorted
  signed int sorted;
  // num_alloc
  signed int num_alloc;
  // comp
  signed int (*comp)(const void *, const void *);
};

struct stack_st_ASN1_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_SRTP_PROTECTION_PROFILE
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_CIPHER
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_COMP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ALGOR
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ATTRIBUTE
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_CRL
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_EXTENSION
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_LOOKUP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME_ENTRY
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_REVOKED
{
  // stack
  struct stack_st stack;
};

struct stack_st_void
{
  // stack
  struct stack_st stack;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tls_session_ticket_ext_st
{
  // length
  unsigned short int length;
  // data
  void *data;
};

struct ucred
{
  // pid
  signed int pid;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
};

struct winsize
{
  // ws_row
  unsigned short int ws_row;
  // ws_col
  unsigned short int ws_col;
  // ws_xpixel
  unsigned short int ws_xpixel;
  // ws_ypixel
  unsigned short int ws_ypixel;
};

struct x509_cert_aux_st
{
  // trust
  struct stack_st_ASN1_OBJECT *trust;
  // reject
  struct stack_st_ASN1_OBJECT *reject;
  // alias
  struct asn1_string_st *alias;
  // keyid
  struct asn1_string_st *keyid;
  // other
  struct stack_st_X509_ALGOR *other;
};

struct x509_cinf_st
{
  // version
  struct asn1_string_st *version;
  // serialNumber
  struct asn1_string_st *serialNumber;
  // signature
  struct X509_algor_st *signature;
  // issuer
  struct X509_name_st *issuer;
  // validity
  struct X509_val_st *validity;
  // subject
  struct X509_name_st *subject;
  // key
  struct X509_pubkey_st *key;
  // issuerUID
  struct asn1_string_st *issuerUID;
  // subjectUID
  struct asn1_string_st *subjectUID;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct x509_st
{
  // cert_info
  struct x509_cinf_st *cert_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // valid
  signed int valid;
  // references
  signed int references;
  // name
  char *name;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // ex_pathlen
  signed long int ex_pathlen;
  // ex_pcpathlen
  signed long int ex_pcpathlen;
  // ex_flags
  unsigned long int ex_flags;
  // ex_kusage
  unsigned long int ex_kusage;
  // ex_xkusage
  unsigned long int ex_xkusage;
  // ex_nscert
  unsigned long int ex_nscert;
  // skid
  struct asn1_string_st *skid;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // policy_cache
  struct X509_POLICY_CACHE_st *policy_cache;
  // crldp
  struct stack_st_DIST_POINT *crldp;
  // altname
  struct stack_st_GENERAL_NAME *altname;
  // nc
  struct NAME_CONSTRAINTS_st *nc;
  // rfc3779_addr
  struct stack_st_IPAddressFamily *rfc3779_addr;
  // rfc3779_asid
  struct ASIdentifiers_st *rfc3779_asid;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // aux
  struct x509_cert_aux_st *aux;
};

struct x509_store_ctx_st
{
  // ctx
  struct x509_store_st *ctx;
  // current_method
  signed int current_method;
  // cert
  struct x509_st *cert;
  // untrusted
  struct stack_st_X509 *untrusted;
  // crls
  struct stack_st_X509_CRL *crls;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // other_ctx
  void *other_ctx;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // check_policy
  signed int (*check_policy)(struct x509_store_ctx_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // valid
  signed int valid;
  // last_untrusted
  signed int last_untrusted;
  // chain
  struct stack_st_X509 *chain;
  // tree
  struct X509_POLICY_TREE_st *tree;
  // explicit_policy
  signed int explicit_policy;
  // error_depth
  signed int error_depth;
  // error
  signed int error;
  // current_cert
  struct x509_st *current_cert;
  // current_issuer
  struct x509_st *current_issuer;
  // current_crl
  struct X509_crl_st *current_crl;
  // current_crl_score
  signed int current_crl_score;
  // current_reasons
  unsigned int current_reasons;
  // parent
  struct x509_store_ctx_st *parent;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct x509_store_st
{
  // cache
  signed int cache;
  // objs
  struct stack_st_X509_OBJECT *objs;
  // get_cert_methods
  struct stack_st_X509_LOOKUP *get_cert_methods;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
};


// EnvironmentOptions
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 308
static const struct PQEnvironmentOption EnvironmentOptions[4l] = { { .envName="PGDATESTYLE", .pgName="datestyle" },
    { .envName="PGTZ", .pgName="timezone" },
    { .envName="PGGEQO", .pgName="geqo" }, { .envName=(const char *)(void *)0, .pgName=(const char *)(void *)0 } };
// GSS_C_NT_HOSTBASED_SERVICE
// file /usr/include/mit-krb5/gssapi/gssapi.h line 391
extern struct gss_OID_desc_struct *GSS_C_NT_HOSTBASED_SERVICE;
// PQconninfoOptions
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 167
static const struct _internalPQconninfoOption PQconninfoOptions[28l] = { { .keyword="authtype", .envvar="PGAUTHTYPE", .compiled="",
    .val=(char *)(void *)0, .label="Database-Authtype",
    .dispchar="D", .dispsize=20,
    .connofs=(signed long int)-1 },
    { .keyword="service", .envvar="PGSERVICE", .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="Database-Service",
    .dispchar="", .dispsize=20,
    .connofs=(signed long int)-1 },
    { .keyword="user", .envvar="PGUSER", .compiled=(char *)(void *)0, .val=(char *)(void *)0,
    .label="Database-User", .dispchar="",
    .dispsize=20, .connofs=(signed long int)96ul },
    { .keyword="password", .envvar="PGPASSWORD", .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="Database-Password",
    .dispchar="*", .dispsize=20,
    .connofs=(signed long int)104ul },
    { .keyword="connect_timeout", .envvar="PGCONNECT_TIMEOUT", .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="Connect-timeout",
    .dispchar="", .dispsize=10,
    .connofs=(signed long int)40ul },
    { .keyword="dbname", .envvar="PGDATABASE", .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="Database-Name",
    .dispchar="", .dispsize=20,
    .connofs=(signed long int)80ul },
    { .keyword="host", .envvar="PGHOST", .compiled=(char *)(void *)0, .val=(char *)(void *)0,
    .label="Database-Host", .dispchar="",
    .dispsize=40, .connofs=(signed long int)0ul },
    { .keyword="hostaddr", .envvar="PGHOSTADDR", .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="Database-Host-IP-Address",
    .dispchar="", .dispsize=45,
    .connofs=(signed long int)8ul },
    { .keyword="port", .envvar="PGPORT", .compiled="5432", .val=(char *)(void *)0,
    .label="Database-Port", .dispchar="",
    .dispsize=6, .connofs=(signed long int)16ul },
    { .keyword="client_encoding", .envvar="PGCLIENTENCODING", .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="Client-Encoding",
    .dispchar="", .dispsize=10,
    .connofs=(signed long int)48ul },
    { .keyword="tty", .envvar="PGTTY", .compiled="", .val=(char *)(void *)0,
    .label="Backend-Debug-TTY", .dispchar="D",
    .dispsize=40, .connofs=(signed long int)32ul },
    { .keyword="options", .envvar="PGOPTIONS", .compiled="",
    .val=(char *)(void *)0, .label="Backend-Debug-Options",
    .dispchar="D", .dispsize=40,
    .connofs=(signed long int)56ul },
    { .keyword="application_name", .envvar="PGAPPNAME", .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="Application-Name",
    .dispchar="", .dispsize=64,
    .connofs=(signed long int)64ul },
    { .keyword="fallback_application_name", .envvar=(char *)(void *)0, .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="Fallback-Application-Name",
    .dispchar="", .dispsize=64,
    .connofs=(signed long int)72ul },
    { .keyword="keepalives", .envvar=(char *)(void *)0, .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="TCP-Keepalives",
    .dispchar="", .dispsize=1,
    .connofs=(signed long int)112ul },
    { .keyword="keepalives_idle", .envvar=(char *)(void *)0, .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="TCP-Keepalives-Idle",
    .dispchar="", .dispsize=10,
    .connofs=(signed long int)120ul },
    { .keyword="keepalives_interval", .envvar=(char *)(void *)0, .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="TCP-Keepalives-Interval",
    .dispchar="", .dispsize=10,
    .connofs=(signed long int)128ul },
    { .keyword="keepalives_count", .envvar=(char *)(void *)0, .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="TCP-Keepalives-Count",
    .dispchar="", .dispsize=10,
    .connofs=(signed long int)136ul },
    { .keyword="sslmode", .envvar="PGSSLMODE", .compiled="prefer",
    .val=(char *)(void *)0, .label="SSL-Mode",
    .dispchar="", .dispsize=12, .connofs=(signed long int)144ul },
    { .keyword="sslcompression", .envvar="PGSSLCOMPRESSION", .compiled="1",
    .val=(char *)(void *)0, .label="SSL-Compression",
    .dispchar="", .dispsize=1,
    .connofs=(signed long int)152ul },
    { .keyword="sslcert", .envvar="PGSSLCERT", .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="SSL-Client-Cert",
    .dispchar="", .dispsize=64,
    .connofs=(signed long int)168ul },
    { .keyword="sslkey", .envvar="PGSSLKEY", .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="SSL-Client-Key",
    .dispchar="", .dispsize=64,
    .connofs=(signed long int)160ul },
    { .keyword="sslrootcert", .envvar="PGSSLROOTCERT", .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="SSL-Root-Certificate",
    .dispchar="", .dispsize=64,
    .connofs=(signed long int)176ul },
    { .keyword="sslcrl", .envvar="PGSSLCRL", .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="SSL-Revocation-List",
    .dispchar="", .dispsize=64,
    .connofs=(signed long int)184ul },
    { .keyword="requirepeer", .envvar="PGREQUIREPEER", .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="Require-Peer",
    .dispchar="", .dispsize=10,
    .connofs=(signed long int)192ul },
    { .keyword="krbsrvname", .envvar="PGKRBSRVNAME", .compiled="postgres",
    .val=(char *)(void *)0, .label="Kerberos-service-name",
    .dispchar="", .dispsize=20,
    .connofs=(signed long int)200ul },
    { .keyword="replication", .envvar=(char *)(void *)0, .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label="Replication",
    .dispchar="D", .dispsize=5,
    .connofs=(signed long int)88ul },
    { .keyword=(char *)(void *)0, .envvar=(char *)(void *)0, .compiled=(char *)(void *)0,
    .val=(char *)(void *)0, .label=(char *)(void *)0,
    .dispchar=(char *)(void *)0, .dispsize=0,
    .connofs=0l } };
// QUERYMODE
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 265
static const char *QUERYMODE[3l] = { "simple", "extended", "prepared" };
// SSL_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 101
static struct ssl_ctx_st *SSL_context = (struct ssl_ctx_st *)(void *)0;
// _rand48_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/erand48.c line 54
static unsigned short int _rand48_add = (unsigned short int)0x000b;
// _rand48_add_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/erand48.c line 54
static unsigned short int _rand48_add_link1 = (unsigned short int)0x000b;
// _rand48_mult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/erand48.c line 49
static unsigned short int _rand48_mult[3l] = { (unsigned short int)0xe66d, (unsigned short int)0xdeec, (unsigned short int)0x0005 };
// _rand48_mult_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/erand48.c line 49
static unsigned short int _rand48_mult_link1[3l] = { (unsigned short int)0xe66d, (unsigned short int)0xdeec, (unsigned short int)0x0005 };
// _rand48_seed
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/erand48.c line 44
static unsigned short int _rand48_seed[3l] = { (unsigned short int)0x330e, (unsigned short int)0xabcd, (unsigned short int)0x1234 };
// _rand48_seed_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/erand48.c line 44
static unsigned short int _rand48_seed_link1[3l] = { (unsigned short int)0x330e, (unsigned short int)0xabcd, (unsigned short int)0x1234 };
// agg_interval
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 163
signed int agg_interval;
// dbName
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 177
char *dbName;
// debug
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 297
static signed int debug = 0;
// duration
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 102
signed int duration = 0;
// encoding_match_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/chklocale.c line 46
static struct encoding_match encoding_match_list[111l] = { { .pg_enc_code=(enum pg_enc)1, .system_enc_name="EUC-JP" },
    { .pg_enc_code=(enum pg_enc)1, .system_enc_name="eucJP" },
    { .pg_enc_code=(enum pg_enc)1, .system_enc_name="IBM-eucJP" },
    { .pg_enc_code=(enum pg_enc)1, .system_enc_name="sdeckanji" },
    { .pg_enc_code=(enum pg_enc)1, .system_enc_name="CP20932" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="EUC-CN" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="eucCN" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="IBM-eucCN" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="GB2312" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="dechanzi" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="CP20936" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="EUC-KR" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="eucKR" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="IBM-eucKR" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="deckorean" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="5601" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="CP51949" },
    { .pg_enc_code=(enum pg_enc)4, .system_enc_name="EUC-TW" },
    { .pg_enc_code=(enum pg_enc)4, .system_enc_name="eucTW" },
    { .pg_enc_code=(enum pg_enc)4, .system_enc_name="IBM-eucTW" },
    { .pg_enc_code=(enum pg_enc)4, .system_enc_name="cns11643" },
    { .pg_enc_code=(enum pg_enc)6, .system_enc_name="UTF-8" },
    { .pg_enc_code=(enum pg_enc)6, .system_enc_name="utf8" },
    { .pg_enc_code=(enum pg_enc)6, .system_enc_name="CP65001" },
    { .pg_enc_code=(enum pg_enc)8, .system_enc_name="ISO-8859-1" },
    { .pg_enc_code=(enum pg_enc)8, .system_enc_name="ISO8859-1" },
    { .pg_enc_code=(enum pg_enc)8, .system_enc_name="iso88591" },
    { .pg_enc_code=(enum pg_enc)8, .system_enc_name="CP28591" },
    { .pg_enc_code=(enum pg_enc)9, .system_enc_name="ISO-8859-2" },
    { .pg_enc_code=(enum pg_enc)9, .system_enc_name="ISO8859-2" },
    { .pg_enc_code=(enum pg_enc)9, .system_enc_name="iso88592" },
    { .pg_enc_code=(enum pg_enc)9, .system_enc_name="CP28592" },
    { .pg_enc_code=(enum pg_enc)10, .system_enc_name="ISO-8859-3" },
    { .pg_enc_code=(enum pg_enc)10, .system_enc_name="ISO8859-3" },
    { .pg_enc_code=(enum pg_enc)10, .system_enc_name="iso88593" },
    { .pg_enc_code=(enum pg_enc)10, .system_enc_name="CP28593" },
    { .pg_enc_code=(enum pg_enc)11, .system_enc_name="ISO-8859-4" },
    { .pg_enc_code=(enum pg_enc)11, .system_enc_name="ISO8859-4" },
    { .pg_enc_code=(enum pg_enc)11, .system_enc_name="iso88594" },
    { .pg_enc_code=(enum pg_enc)11, .system_enc_name="CP28594" },
    { .pg_enc_code=(enum pg_enc)12, .system_enc_name="ISO-8859-9" },
    { .pg_enc_code=(enum pg_enc)12, .system_enc_name="ISO8859-9" },
    { .pg_enc_code=(enum pg_enc)12, .system_enc_name="iso88599" },
    { .pg_enc_code=(enum pg_enc)12, .system_enc_name="CP28599" },
    { .pg_enc_code=(enum pg_enc)13, .system_enc_name="ISO-8859-10" },
    { .pg_enc_code=(enum pg_enc)13, .system_enc_name="ISO8859-10" },
    { .pg_enc_code=(enum pg_enc)13, .system_enc_name="iso885910" },
    { .pg_enc_code=(enum pg_enc)14, .system_enc_name="ISO-8859-13" },
    { .pg_enc_code=(enum pg_enc)14, .system_enc_name="ISO8859-13" },
    { .pg_enc_code=(enum pg_enc)14, .system_enc_name="iso885913" },
    { .pg_enc_code=(enum pg_enc)15, .system_enc_name="ISO-8859-14" },
    { .pg_enc_code=(enum pg_enc)15, .system_enc_name="ISO8859-14" },
    { .pg_enc_code=(enum pg_enc)15, .system_enc_name="iso885914" },
    { .pg_enc_code=(enum pg_enc)16, .system_enc_name="ISO-8859-15" },
    { .pg_enc_code=(enum pg_enc)16, .system_enc_name="ISO8859-15" },
    { .pg_enc_code=(enum pg_enc)16, .system_enc_name="iso885915" },
    { .pg_enc_code=(enum pg_enc)16, .system_enc_name="CP28605" },
    { .pg_enc_code=(enum pg_enc)17, .system_enc_name="ISO-8859-16" },
    { .pg_enc_code=(enum pg_enc)17, .system_enc_name="ISO8859-16" },
    { .pg_enc_code=(enum pg_enc)17, .system_enc_name="iso885916" },
    { .pg_enc_code=(enum pg_enc)22, .system_enc_name="KOI8-R" },
    { .pg_enc_code=(enum pg_enc)22, .system_enc_name="CP20866" },
    { .pg_enc_code=(enum pg_enc)34, .system_enc_name="KOI8-U" },
    { .pg_enc_code=(enum pg_enc)34, .system_enc_name="CP21866" },
    { .pg_enc_code=(enum pg_enc)20, .system_enc_name="CP866" },
    { .pg_enc_code=(enum pg_enc)21, .system_enc_name="CP874" },
    { .pg_enc_code=(enum pg_enc)29, .system_enc_name="CP1250" },
    { .pg_enc_code=(enum pg_enc)23, .system_enc_name="CP1251" },
    { .pg_enc_code=(enum pg_enc)23, .system_enc_name="ansi-1251" },
    { .pg_enc_code=(enum pg_enc)24, .system_enc_name="CP1252" },
    { .pg_enc_code=(enum pg_enc)30, .system_enc_name="CP1253" },
    { .pg_enc_code=(enum pg_enc)31, .system_enc_name="CP1254" },
    { .pg_enc_code=(enum pg_enc)32, .system_enc_name="CP1255" },
    { .pg_enc_code=(enum pg_enc)18, .system_enc_name="CP1256" },
    { .pg_enc_code=(enum pg_enc)33, .system_enc_name="CP1257" },
    { .pg_enc_code=(enum pg_enc)19, .system_enc_name="CP1258" },
    { .pg_enc_code=(enum pg_enc)25, .system_enc_name="ISO-8859-5" },
    { .pg_enc_code=(enum pg_enc)25, .system_enc_name="ISO8859-5" },
    { .pg_enc_code=(enum pg_enc)25, .system_enc_name="iso88595" },
    { .pg_enc_code=(enum pg_enc)25, .system_enc_name="CP28595" },
    { .pg_enc_code=(enum pg_enc)26, .system_enc_name="ISO-8859-6" },
    { .pg_enc_code=(enum pg_enc)26, .system_enc_name="ISO8859-6" },
    { .pg_enc_code=(enum pg_enc)26, .system_enc_name="iso88596" },
    { .pg_enc_code=(enum pg_enc)26, .system_enc_name="CP28596" },
    { .pg_enc_code=(enum pg_enc)27, .system_enc_name="ISO-8859-7" },
    { .pg_enc_code=(enum pg_enc)27, .system_enc_name="ISO8859-7" },
    { .pg_enc_code=(enum pg_enc)27, .system_enc_name="iso88597" },
    { .pg_enc_code=(enum pg_enc)27, .system_enc_name="CP28597" },
    { .pg_enc_code=(enum pg_enc)28, .system_enc_name="ISO-8859-8" },
    { .pg_enc_code=(enum pg_enc)28, .system_enc_name="ISO8859-8" },
    { .pg_enc_code=(enum pg_enc)28, .system_enc_name="iso88598" },
    { .pg_enc_code=(enum pg_enc)28, .system_enc_name="CP28598" },
    { .pg_enc_code=(enum pg_enc)35, .system_enc_name="SJIS" },
    { .pg_enc_code=(enum pg_enc)35, .system_enc_name="PCK" },
    { .pg_enc_code=(enum pg_enc)35, .system_enc_name="CP932" },
    { .pg_enc_code=(enum pg_enc)35, .system_enc_name="SHIFT_JIS" },
    { .pg_enc_code=(enum pg_enc)36, .system_enc_name="BIG5" },
    { .pg_enc_code=(enum pg_enc)36, .system_enc_name="BIG5HKSCS" },
    { .pg_enc_code=(enum pg_enc)36, .system_enc_name="Big5-HKSCS" },
    { .pg_enc_code=(enum pg_enc)36, .system_enc_name="CP950" },
    { .pg_enc_code=(enum pg_enc)37, .system_enc_name="GBK" },
    { .pg_enc_code=(enum pg_enc)37, .system_enc_name="CP936" },
    { .pg_enc_code=(enum pg_enc)38, .system_enc_name="UHC" },
    { .pg_enc_code=(enum pg_enc)38, .system_enc_name="CP949" },
    { .pg_enc_code=(enum pg_enc)40, .system_enc_name="JOHAB" },
    { .pg_enc_code=(enum pg_enc)40, .system_enc_name="CP1361" },
    { .pg_enc_code=(enum pg_enc)39, .system_enc_name="GB18030" },
    { .pg_enc_code=(enum pg_enc)39, .system_enc_name="CP54936" },
    { .pg_enc_code=(enum pg_enc)41, .system_enc_name="SJIS_2004" },
    { .pg_enc_code=(enum pg_enc)0, .system_enc_name="US-ASCII" },
    { .pg_enc_code=(enum pg_enc)0, .system_enc_name=(const char *)(void *)0 } };
// encoding_match_list_link1
// file chklocale.c line 46
static struct encoding_match encoding_match_list_link1[111l] = { { .pg_enc_code=(enum pg_enc)1, .system_enc_name="EUC-JP" },
    { .pg_enc_code=(enum pg_enc)1, .system_enc_name="eucJP" },
    { .pg_enc_code=(enum pg_enc)1, .system_enc_name="IBM-eucJP" },
    { .pg_enc_code=(enum pg_enc)1, .system_enc_name="sdeckanji" },
    { .pg_enc_code=(enum pg_enc)1, .system_enc_name="CP20932" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="EUC-CN" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="eucCN" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="IBM-eucCN" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="GB2312" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="dechanzi" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="CP20936" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="EUC-KR" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="eucKR" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="IBM-eucKR" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="deckorean" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="5601" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="CP51949" },
    { .pg_enc_code=(enum pg_enc)4, .system_enc_name="EUC-TW" },
    { .pg_enc_code=(enum pg_enc)4, .system_enc_name="eucTW" },
    { .pg_enc_code=(enum pg_enc)4, .system_enc_name="IBM-eucTW" },
    { .pg_enc_code=(enum pg_enc)4, .system_enc_name="cns11643" },
    { .pg_enc_code=(enum pg_enc)6, .system_enc_name="UTF-8" },
    { .pg_enc_code=(enum pg_enc)6, .system_enc_name="utf8" },
    { .pg_enc_code=(enum pg_enc)6, .system_enc_name="CP65001" },
    { .pg_enc_code=(enum pg_enc)8, .system_enc_name="ISO-8859-1" },
    { .pg_enc_code=(enum pg_enc)8, .system_enc_name="ISO8859-1" },
    { .pg_enc_code=(enum pg_enc)8, .system_enc_name="iso88591" },
    { .pg_enc_code=(enum pg_enc)8, .system_enc_name="CP28591" },
    { .pg_enc_code=(enum pg_enc)9, .system_enc_name="ISO-8859-2" },
    { .pg_enc_code=(enum pg_enc)9, .system_enc_name="ISO8859-2" },
    { .pg_enc_code=(enum pg_enc)9, .system_enc_name="iso88592" },
    { .pg_enc_code=(enum pg_enc)9, .system_enc_name="CP28592" },
    { .pg_enc_code=(enum pg_enc)10, .system_enc_name="ISO-8859-3" },
    { .pg_enc_code=(enum pg_enc)10, .system_enc_name="ISO8859-3" },
    { .pg_enc_code=(enum pg_enc)10, .system_enc_name="iso88593" },
    { .pg_enc_code=(enum pg_enc)10, .system_enc_name="CP28593" },
    { .pg_enc_code=(enum pg_enc)11, .system_enc_name="ISO-8859-4" },
    { .pg_enc_code=(enum pg_enc)11, .system_enc_name="ISO8859-4" },
    { .pg_enc_code=(enum pg_enc)11, .system_enc_name="iso88594" },
    { .pg_enc_code=(enum pg_enc)11, .system_enc_name="CP28594" },
    { .pg_enc_code=(enum pg_enc)12, .system_enc_name="ISO-8859-9" },
    { .pg_enc_code=(enum pg_enc)12, .system_enc_name="ISO8859-9" },
    { .pg_enc_code=(enum pg_enc)12, .system_enc_name="iso88599" },
    { .pg_enc_code=(enum pg_enc)12, .system_enc_name="CP28599" },
    { .pg_enc_code=(enum pg_enc)13, .system_enc_name="ISO-8859-10" },
    { .pg_enc_code=(enum pg_enc)13, .system_enc_name="ISO8859-10" },
    { .pg_enc_code=(enum pg_enc)13, .system_enc_name="iso885910" },
    { .pg_enc_code=(enum pg_enc)14, .system_enc_name="ISO-8859-13" },
    { .pg_enc_code=(enum pg_enc)14, .system_enc_name="ISO8859-13" },
    { .pg_enc_code=(enum pg_enc)14, .system_enc_name="iso885913" },
    { .pg_enc_code=(enum pg_enc)15, .system_enc_name="ISO-8859-14" },
    { .pg_enc_code=(enum pg_enc)15, .system_enc_name="ISO8859-14" },
    { .pg_enc_code=(enum pg_enc)15, .system_enc_name="iso885914" },
    { .pg_enc_code=(enum pg_enc)16, .system_enc_name="ISO-8859-15" },
    { .pg_enc_code=(enum pg_enc)16, .system_enc_name="ISO8859-15" },
    { .pg_enc_code=(enum pg_enc)16, .system_enc_name="iso885915" },
    { .pg_enc_code=(enum pg_enc)16, .system_enc_name="CP28605" },
    { .pg_enc_code=(enum pg_enc)17, .system_enc_name="ISO-8859-16" },
    { .pg_enc_code=(enum pg_enc)17, .system_enc_name="ISO8859-16" },
    { .pg_enc_code=(enum pg_enc)17, .system_enc_name="iso885916" },
    { .pg_enc_code=(enum pg_enc)22, .system_enc_name="KOI8-R" },
    { .pg_enc_code=(enum pg_enc)22, .system_enc_name="CP20866" },
    { .pg_enc_code=(enum pg_enc)34, .system_enc_name="KOI8-U" },
    { .pg_enc_code=(enum pg_enc)34, .system_enc_name="CP21866" },
    { .pg_enc_code=(enum pg_enc)20, .system_enc_name="CP866" },
    { .pg_enc_code=(enum pg_enc)21, .system_enc_name="CP874" },
    { .pg_enc_code=(enum pg_enc)29, .system_enc_name="CP1250" },
    { .pg_enc_code=(enum pg_enc)23, .system_enc_name="CP1251" },
    { .pg_enc_code=(enum pg_enc)23, .system_enc_name="ansi-1251" },
    { .pg_enc_code=(enum pg_enc)24, .system_enc_name="CP1252" },
    { .pg_enc_code=(enum pg_enc)30, .system_enc_name="CP1253" },
    { .pg_enc_code=(enum pg_enc)31, .system_enc_name="CP1254" },
    { .pg_enc_code=(enum pg_enc)32, .system_enc_name="CP1255" },
    { .pg_enc_code=(enum pg_enc)18, .system_enc_name="CP1256" },
    { .pg_enc_code=(enum pg_enc)33, .system_enc_name="CP1257" },
    { .pg_enc_code=(enum pg_enc)19, .system_enc_name="CP1258" },
    { .pg_enc_code=(enum pg_enc)25, .system_enc_name="ISO-8859-5" },
    { .pg_enc_code=(enum pg_enc)25, .system_enc_name="ISO8859-5" },
    { .pg_enc_code=(enum pg_enc)25, .system_enc_name="iso88595" },
    { .pg_enc_code=(enum pg_enc)25, .system_enc_name="CP28595" },
    { .pg_enc_code=(enum pg_enc)26, .system_enc_name="ISO-8859-6" },
    { .pg_enc_code=(enum pg_enc)26, .system_enc_name="ISO8859-6" },
    { .pg_enc_code=(enum pg_enc)26, .system_enc_name="iso88596" },
    { .pg_enc_code=(enum pg_enc)26, .system_enc_name="CP28596" },
    { .pg_enc_code=(enum pg_enc)27, .system_enc_name="ISO-8859-7" },
    { .pg_enc_code=(enum pg_enc)27, .system_enc_name="ISO8859-7" },
    { .pg_enc_code=(enum pg_enc)27, .system_enc_name="iso88597" },
    { .pg_enc_code=(enum pg_enc)27, .system_enc_name="CP28597" },
    { .pg_enc_code=(enum pg_enc)28, .system_enc_name="ISO-8859-8" },
    { .pg_enc_code=(enum pg_enc)28, .system_enc_name="ISO8859-8" },
    { .pg_enc_code=(enum pg_enc)28, .system_enc_name="iso88598" },
    { .pg_enc_code=(enum pg_enc)28, .system_enc_name="CP28598" },
    { .pg_enc_code=(enum pg_enc)35, .system_enc_name="SJIS" },
    { .pg_enc_code=(enum pg_enc)35, .system_enc_name="PCK" },
    { .pg_enc_code=(enum pg_enc)35, .system_enc_name="CP932" },
    { .pg_enc_code=(enum pg_enc)35, .system_enc_name="SHIFT_JIS" },
    { .pg_enc_code=(enum pg_enc)36, .system_enc_name="BIG5" },
    { .pg_enc_code=(enum pg_enc)36, .system_enc_name="BIG5HKSCS" },
    { .pg_enc_code=(enum pg_enc)36, .system_enc_name="Big5-HKSCS" },
    { .pg_enc_code=(enum pg_enc)36, .system_enc_name="CP950" },
    { .pg_enc_code=(enum pg_enc)37, .system_enc_name="GBK" },
    { .pg_enc_code=(enum pg_enc)37, .system_enc_name="CP936" },
    { .pg_enc_code=(enum pg_enc)38, .system_enc_name="UHC" },
    { .pg_enc_code=(enum pg_enc)38, .system_enc_name="CP949" },
    { .pg_enc_code=(enum pg_enc)40, .system_enc_name="JOHAB" },
    { .pg_enc_code=(enum pg_enc)40, .system_enc_name="CP1361" },
    { .pg_enc_code=(enum pg_enc)39, .system_enc_name="GB18030" },
    { .pg_enc_code=(enum pg_enc)39, .system_enc_name="CP54936" },
    { .pg_enc_code=(enum pg_enc)41, .system_enc_name="SJIS_2004" },
    { .pg_enc_code=(enum pg_enc)0, .system_enc_name="US-ASCII" },
    { .pg_enc_code=(enum pg_enc)0, .system_enc_name=(const char *)(void *)0 } };
// encoding_match_list_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/chklocale.c line 46
static struct encoding_match encoding_match_list_link2[111l] = { { .pg_enc_code=(enum pg_enc)1, .system_enc_name="EUC-JP" },
    { .pg_enc_code=(enum pg_enc)1, .system_enc_name="eucJP" },
    { .pg_enc_code=(enum pg_enc)1, .system_enc_name="IBM-eucJP" },
    { .pg_enc_code=(enum pg_enc)1, .system_enc_name="sdeckanji" },
    { .pg_enc_code=(enum pg_enc)1, .system_enc_name="CP20932" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="EUC-CN" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="eucCN" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="IBM-eucCN" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="GB2312" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="dechanzi" },
    { .pg_enc_code=(enum pg_enc)2, .system_enc_name="CP20936" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="EUC-KR" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="eucKR" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="IBM-eucKR" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="deckorean" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="5601" },
    { .pg_enc_code=(enum pg_enc)3, .system_enc_name="CP51949" },
    { .pg_enc_code=(enum pg_enc)4, .system_enc_name="EUC-TW" },
    { .pg_enc_code=(enum pg_enc)4, .system_enc_name="eucTW" },
    { .pg_enc_code=(enum pg_enc)4, .system_enc_name="IBM-eucTW" },
    { .pg_enc_code=(enum pg_enc)4, .system_enc_name="cns11643" },
    { .pg_enc_code=(enum pg_enc)6, .system_enc_name="UTF-8" },
    { .pg_enc_code=(enum pg_enc)6, .system_enc_name="utf8" },
    { .pg_enc_code=(enum pg_enc)6, .system_enc_name="CP65001" },
    { .pg_enc_code=(enum pg_enc)8, .system_enc_name="ISO-8859-1" },
    { .pg_enc_code=(enum pg_enc)8, .system_enc_name="ISO8859-1" },
    { .pg_enc_code=(enum pg_enc)8, .system_enc_name="iso88591" },
    { .pg_enc_code=(enum pg_enc)8, .system_enc_name="CP28591" },
    { .pg_enc_code=(enum pg_enc)9, .system_enc_name="ISO-8859-2" },
    { .pg_enc_code=(enum pg_enc)9, .system_enc_name="ISO8859-2" },
    { .pg_enc_code=(enum pg_enc)9, .system_enc_name="iso88592" },
    { .pg_enc_code=(enum pg_enc)9, .system_enc_name="CP28592" },
    { .pg_enc_code=(enum pg_enc)10, .system_enc_name="ISO-8859-3" },
    { .pg_enc_code=(enum pg_enc)10, .system_enc_name="ISO8859-3" },
    { .pg_enc_code=(enum pg_enc)10, .system_enc_name="iso88593" },
    { .pg_enc_code=(enum pg_enc)10, .system_enc_name="CP28593" },
    { .pg_enc_code=(enum pg_enc)11, .system_enc_name="ISO-8859-4" },
    { .pg_enc_code=(enum pg_enc)11, .system_enc_name="ISO8859-4" },
    { .pg_enc_code=(enum pg_enc)11, .system_enc_name="iso88594" },
    { .pg_enc_code=(enum pg_enc)11, .system_enc_name="CP28594" },
    { .pg_enc_code=(enum pg_enc)12, .system_enc_name="ISO-8859-9" },
    { .pg_enc_code=(enum pg_enc)12, .system_enc_name="ISO8859-9" },
    { .pg_enc_code=(enum pg_enc)12, .system_enc_name="iso88599" },
    { .pg_enc_code=(enum pg_enc)12, .system_enc_name="CP28599" },
    { .pg_enc_code=(enum pg_enc)13, .system_enc_name="ISO-8859-10" },
    { .pg_enc_code=(enum pg_enc)13, .system_enc_name="ISO8859-10" },
    { .pg_enc_code=(enum pg_enc)13, .system_enc_name="iso885910" },
    { .pg_enc_code=(enum pg_enc)14, .system_enc_name="ISO-8859-13" },
    { .pg_enc_code=(enum pg_enc)14, .system_enc_name="ISO8859-13" },
    { .pg_enc_code=(enum pg_enc)14, .system_enc_name="iso885913" },
    { .pg_enc_code=(enum pg_enc)15, .system_enc_name="ISO-8859-14" },
    { .pg_enc_code=(enum pg_enc)15, .system_enc_name="ISO8859-14" },
    { .pg_enc_code=(enum pg_enc)15, .system_enc_name="iso885914" },
    { .pg_enc_code=(enum pg_enc)16, .system_enc_name="ISO-8859-15" },
    { .pg_enc_code=(enum pg_enc)16, .system_enc_name="ISO8859-15" },
    { .pg_enc_code=(enum pg_enc)16, .system_enc_name="iso885915" },
    { .pg_enc_code=(enum pg_enc)16, .system_enc_name="CP28605" },
    { .pg_enc_code=(enum pg_enc)17, .system_enc_name="ISO-8859-16" },
    { .pg_enc_code=(enum pg_enc)17, .system_enc_name="ISO8859-16" },
    { .pg_enc_code=(enum pg_enc)17, .system_enc_name="iso885916" },
    { .pg_enc_code=(enum pg_enc)22, .system_enc_name="KOI8-R" },
    { .pg_enc_code=(enum pg_enc)22, .system_enc_name="CP20866" },
    { .pg_enc_code=(enum pg_enc)34, .system_enc_name="KOI8-U" },
    { .pg_enc_code=(enum pg_enc)34, .system_enc_name="CP21866" },
    { .pg_enc_code=(enum pg_enc)20, .system_enc_name="CP866" },
    { .pg_enc_code=(enum pg_enc)21, .system_enc_name="CP874" },
    { .pg_enc_code=(enum pg_enc)29, .system_enc_name="CP1250" },
    { .pg_enc_code=(enum pg_enc)23, .system_enc_name="CP1251" },
    { .pg_enc_code=(enum pg_enc)23, .system_enc_name="ansi-1251" },
    { .pg_enc_code=(enum pg_enc)24, .system_enc_name="CP1252" },
    { .pg_enc_code=(enum pg_enc)30, .system_enc_name="CP1253" },
    { .pg_enc_code=(enum pg_enc)31, .system_enc_name="CP1254" },
    { .pg_enc_code=(enum pg_enc)32, .system_enc_name="CP1255" },
    { .pg_enc_code=(enum pg_enc)18, .system_enc_name="CP1256" },
    { .pg_enc_code=(enum pg_enc)33, .system_enc_name="CP1257" },
    { .pg_enc_code=(enum pg_enc)19, .system_enc_name="CP1258" },
    { .pg_enc_code=(enum pg_enc)25, .system_enc_name="ISO-8859-5" },
    { .pg_enc_code=(enum pg_enc)25, .system_enc_name="ISO8859-5" },
    { .pg_enc_code=(enum pg_enc)25, .system_enc_name="iso88595" },
    { .pg_enc_code=(enum pg_enc)25, .system_enc_name="CP28595" },
    { .pg_enc_code=(enum pg_enc)26, .system_enc_name="ISO-8859-6" },
    { .pg_enc_code=(enum pg_enc)26, .system_enc_name="ISO8859-6" },
    { .pg_enc_code=(enum pg_enc)26, .system_enc_name="iso88596" },
    { .pg_enc_code=(enum pg_enc)26, .system_enc_name="CP28596" },
    { .pg_enc_code=(enum pg_enc)27, .system_enc_name="ISO-8859-7" },
    { .pg_enc_code=(enum pg_enc)27, .system_enc_name="ISO8859-7" },
    { .pg_enc_code=(enum pg_enc)27, .system_enc_name="iso88597" },
    { .pg_enc_code=(enum pg_enc)27, .system_enc_name="CP28597" },
    { .pg_enc_code=(enum pg_enc)28, .system_enc_name="ISO-8859-8" },
    { .pg_enc_code=(enum pg_enc)28, .system_enc_name="ISO8859-8" },
    { .pg_enc_code=(enum pg_enc)28, .system_enc_name="iso88598" },
    { .pg_enc_code=(enum pg_enc)28, .system_enc_name="CP28598" },
    { .pg_enc_code=(enum pg_enc)35, .system_enc_name="SJIS" },
    { .pg_enc_code=(enum pg_enc)35, .system_enc_name="PCK" },
    { .pg_enc_code=(enum pg_enc)35, .system_enc_name="CP932" },
    { .pg_enc_code=(enum pg_enc)35, .system_enc_name="SHIFT_JIS" },
    { .pg_enc_code=(enum pg_enc)36, .system_enc_name="BIG5" },
    { .pg_enc_code=(enum pg_enc)36, .system_enc_name="BIG5HKSCS" },
    { .pg_enc_code=(enum pg_enc)36, .system_enc_name="Big5-HKSCS" },
    { .pg_enc_code=(enum pg_enc)36, .system_enc_name="CP950" },
    { .pg_enc_code=(enum pg_enc)37, .system_enc_name="GBK" },
    { .pg_enc_code=(enum pg_enc)37, .system_enc_name="CP936" },
    { .pg_enc_code=(enum pg_enc)38, .system_enc_name="UHC" },
    { .pg_enc_code=(enum pg_enc)38, .system_enc_name="CP949" },
    { .pg_enc_code=(enum pg_enc)40, .system_enc_name="JOHAB" },
    { .pg_enc_code=(enum pg_enc)40, .system_enc_name="CP1361" },
    { .pg_enc_code=(enum pg_enc)39, .system_enc_name="GB18030" },
    { .pg_enc_code=(enum pg_enc)39, .system_enc_name="CP54936" },
    { .pg_enc_code=(enum pg_enc)41, .system_enc_name="SJIS_2004" },
    { .pg_enc_code=(enum pg_enc)0, .system_enc_name="US-ASCII" },
    { .pg_enc_code=(enum pg_enc)0, .system_enc_name=(const char *)(void *)0 } };
// fillfactor
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 114
signed int fillfactor = 100;
// foreign_keys
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 119
signed int foreign_keys = 0;
// forkNames
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/relpath.c line 34
const char * const forkNames[4l] = { "main", "fsm", "vm", "init" };
// hexlookup
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3422
static const signed char hexlookup[128l] = { (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)0, (const signed char)1, (const signed char)2, (const signed char)3, (const signed char)4, (const signed char)5, (const signed char)6, (const signed char)7, (const signed char)8, (const signed char)9, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)10, (const signed char)11, (const signed char)12, (const signed char)13, (const signed char)14, (const signed char)15, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)10, (const signed char)11, (const signed char)12, (const signed char)13, (const signed char)14, (const signed char)15, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)-1 };
// hextbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3420
static const char hextbl[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 0 };
// index_tablespace
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 141
char *index_tablespace = (char *)(void *)0;
// is_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 170
char is_connect;
// is_latencies
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 171
char is_latencies;
// login
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 176
char *login = (char *)(void *)0;
// unlogged_tables
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 124
signed int unlogged_tables = 0;
// main_pid
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 172
signed int main_pid;
// num_commands
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 296
static signed int num_commands = 0;
// num_files
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 295
static signed int num_files;
// nxacts
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 101
signed int nxacts = 0;
// oom_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.c line 38
static const char oom_buffer[1l] = { 0 };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// pg_crc32_table
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/utils/pg_crc_tables.h line 36
const unsigned int pg_crc32_table[256l] = { (const unsigned int)0x00000000, (const unsigned int)0x77073096, 0xEE0E612C, 0x990951BA, (const unsigned int)0x076DC419, (const unsigned int)0x706AF48F, 0xE963A535, 0x9E6495A3, (const unsigned int)0x0EDB8832, (const unsigned int)0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, (const unsigned int)0x09B64C2B, (const unsigned int)0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, (const unsigned int)0x1DB71064, (const unsigned int)0x6AB020F2, 0xF3B97148, 0x84BE41DE, (const unsigned int)0x1ADAD47D, (const unsigned int)0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, (const unsigned int)0x136C9856, (const unsigned int)0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, (const unsigned int)0x14015C4F, (const unsigned int)0x63066CD9, 0xFA0F3D63, 0x8D080DF5, (const unsigned int)0x3B6E20C8, (const unsigned int)0x4C69105E, 0xD56041E4, 0xA2677172, (const unsigned int)0x3C03E4D1, (const unsigned int)0x4B04D447, 0xD20D85FD, 0xA50AB56B, (const unsigned int)0x35B5A8FA, (const unsigned int)0x42B2986C, 0xDBBBC9D6, 0xACBCF940, (const unsigned int)0x32D86CE3, (const unsigned int)0x45DF5C75, 0xDCD60DCF, 0xABD13D59, (const unsigned int)0x26D930AC, (const unsigned int)0x51DE003A, 0xC8D75180, 0xBFD06116, (const unsigned int)0x21B4F4B5, (const unsigned int)0x56B3C423, 0xCFBA9599, 0xB8BDA50F, (const unsigned int)0x2802B89E, (const unsigned int)0x5F058808, 0xC60CD9B2, 0xB10BE924, (const unsigned int)0x2F6F7C87, (const unsigned int)0x58684C11, 0xC1611DAB, 0xB6662D3D, (const unsigned int)0x76DC4190, (const unsigned int)0x01DB7106, 0x98D220BC, 0xEFD5102A, (const unsigned int)0x71B18589, (const unsigned int)0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, (const unsigned int)0x7807C9A2, (const unsigned int)0x0F00F934, 0x9609A88E, 0xE10E9818, (const unsigned int)0x7F6A0DBB, (const unsigned int)0x086D3D2D, 0x91646C97, 0xE6635C01, (const unsigned int)0x6B6B51F4, (const unsigned int)0x1C6C6162, 0x856530D8, 0xF262004E, (const unsigned int)0x6C0695ED, (const unsigned int)0x1B01A57B, 0x8208F4C1, 0xF50FC457, (const unsigned int)0x65B0D9C6, (const unsigned int)0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, (const unsigned int)0x62DD1DDF, (const unsigned int)0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, (const unsigned int)0x4DB26158, (const unsigned int)0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, (const unsigned int)0x4ADFA541, (const unsigned int)0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, (const unsigned int)0x4369E96A, (const unsigned int)0x346ED9FC, 0xAD678846, 0xDA60B8D0, (const unsigned int)0x44042D73, (const unsigned int)0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, (const unsigned int)0x5005713C, (const unsigned int)0x270241AA, 0xBE0B1010, 0xC90C2086, (const unsigned int)0x5768B525, (const unsigned int)0x206F85B3, 0xB966D409, 0xCE61E49F, (const unsigned int)0x5EDEF90E, (const unsigned int)0x29D9C998, 0xB0D09822, 0xC7D7A8B4, (const unsigned int)0x59B33D17, (const unsigned int)0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, (const unsigned int)0x03B6E20C, (const unsigned int)0x74B1D29A, 0xEAD54739, 0x9DD277AF, (const unsigned int)0x04DB2615, (const unsigned int)0x73DC1683, 0xE3630B12, 0x94643B84, (const unsigned int)0x0D6D6A3E, (const unsigned int)0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, (const unsigned int)0x0A00AE27, (const unsigned int)0x7D079EB1, 0xF00F9344, 0x8708A3D2, (const unsigned int)0x1E01F268, (const unsigned int)0x6906C2FE, 0xF762575D, 0x806567CB, (const unsigned int)0x196C3671, (const unsigned int)0x6E6B06E7, 0xFED41B76, 0x89D32BE0, (const unsigned int)0x10DA7A5A, (const unsigned int)0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, (const unsigned int)0x17B7BE43, (const unsigned int)0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, (const unsigned int)0x38D8C2C4, (const unsigned int)0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, (const unsigned int)0x3FB506DD, (const unsigned int)0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, (const unsigned int)0x36034AF6, (const unsigned int)0x41047A60, 0xDF60EFC3, 0xA867DF55, (const unsigned int)0x316E8EEF, (const unsigned int)0x4669BE79, 0xCB61B38C, 0xBC66831A, (const unsigned int)0x256FD2A0, (const unsigned int)0x5268E236, 0xCC0C7795, 0xBB0B4703, (const unsigned int)0x220216B9, (const unsigned int)0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, (const unsigned int)0x2BB45A92, (const unsigned int)0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, (const unsigned int)0x2CD99E8B, (const unsigned int)0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, (const unsigned int)0x756AA39C, (const unsigned int)0x026D930A, 0x9C0906A9, 0xEB0E363F, (const unsigned int)0x72076785, (const unsigned int)0x05005713, 0x95BF4A82, 0xE2B87A14, (const unsigned int)0x7BB12BAE, (const unsigned int)0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, (const unsigned int)0x7CDCEFB7, (const unsigned int)0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, (const unsigned int)0x68DDB3F8, (const unsigned int)0x1FDA836E, 0x81BE16CD, 0xF6B9265B, (const unsigned int)0x6FB077E1, (const unsigned int)0x18B74777, 0x88085AE6, 0xFF0F6A70, (const unsigned int)0x66063BCA, (const unsigned int)0x11010B5C, 0x8F659EFF, 0xF862AE69, (const unsigned int)0x616BFFD3, (const unsigned int)0x166CCF45, 0xA00AE278, 0xD70DD2EE, (const unsigned int)0x4E048354, (const unsigned int)0x3903B3C2, 0xA7672661, 0xD06016F7, (const unsigned int)0x4969474D, (const unsigned int)0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, (const unsigned int)0x40DF0B66, (const unsigned int)0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, (const unsigned int)0x47B2CF7F, (const unsigned int)0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, (const unsigned int)0x53B39330, (const unsigned int)0x24B4A3A6, 0xBAD03605, 0xCDD70693, (const unsigned int)0x54DE5729, (const unsigned int)0x23D967BF, 0xB3667A2E, 0xC4614AB8, (const unsigned int)0x5D681B02, (const unsigned int)0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, (const unsigned int)0x5A05DF1B, (const unsigned int)0x2D02EF8D };
// pg_enc2gettext_tbl
// file encnames.c line 359
const struct pg_enc2gettext pg_enc2gettext_tbl[42l] = { { .encoding=(enum pg_enc)0, .name="US-ASCII" },
    { .encoding=(enum pg_enc)6, .name="UTF-8" },
    { .encoding=(enum pg_enc)8, .name="LATIN1" },
    { .encoding=(enum pg_enc)9, .name="LATIN2" },
    { .encoding=(enum pg_enc)10, .name="LATIN3" },
    { .encoding=(enum pg_enc)11, .name="LATIN4" },
    { .encoding=(enum pg_enc)25, .name="ISO-8859-5" },
    { .encoding=(enum pg_enc)26, .name="ISO_8859-6" },
    { .encoding=(enum pg_enc)27, .name="ISO-8859-7" },
    { .encoding=(enum pg_enc)28, .name="ISO-8859-8" },
    { .encoding=(enum pg_enc)12, .name="LATIN5" },
    { .encoding=(enum pg_enc)13, .name="LATIN6" },
    { .encoding=(enum pg_enc)14, .name="LATIN7" },
    { .encoding=(enum pg_enc)15, .name="LATIN8" },
    { .encoding=(enum pg_enc)16, .name="LATIN-9" },
    { .encoding=(enum pg_enc)17, .name="LATIN10" },
    { .encoding=(enum pg_enc)22, .name="KOI8-R" },
    { .encoding=(enum pg_enc)34, .name="KOI8-U" },
    { .encoding=(enum pg_enc)29, .name="CP1250" },
    { .encoding=(enum pg_enc)23, .name="CP1251" },
    { .encoding=(enum pg_enc)24, .name="CP1252" },
    { .encoding=(enum pg_enc)30, .name="CP1253" },
    { .encoding=(enum pg_enc)31, .name="CP1254" },
    { .encoding=(enum pg_enc)32, .name="CP1255" },
    { .encoding=(enum pg_enc)18, .name="CP1256" },
    { .encoding=(enum pg_enc)33, .name="CP1257" },
    { .encoding=(enum pg_enc)19, .name="CP1258" },
    { .encoding=(enum pg_enc)20, .name="CP866" },
    { .encoding=(enum pg_enc)21, .name="CP874" },
    { .encoding=(enum pg_enc)2, .name="EUC-CN" },
    { .encoding=(enum pg_enc)1, .name="EUC-JP" },
    { .encoding=(enum pg_enc)3, .name="EUC-KR" },
    { .encoding=(enum pg_enc)4, .name="EUC-TW" },
    { .encoding=(enum pg_enc)5, .name="EUC-JP" },
    { .encoding=(enum pg_enc)35, .name="SHIFT-JIS" },
    { .encoding=(enum pg_enc)36, .name="BIG5" },
    { .encoding=(enum pg_enc)37, .name="GBK" },
    { .encoding=(enum pg_enc)38, .name="UHC" },
    { .encoding=(enum pg_enc)39, .name="GB18030" },
    { .encoding=(enum pg_enc)40, .name="JOHAB" },
    { .encoding=(enum pg_enc)41, .name="SHIFT_JISX0213" },
    { .encoding=(enum pg_enc)0, .name=(const char *)(void *)0 } };
// pg_enc2name_tbl
// file encnames.c line 307
const struct pg_enc2name pg_enc2name_tbl[42l] = { { .name="SQL_ASCII", .encoding=(enum pg_enc)0 },
    { .name="EUC_JP", .encoding=(enum pg_enc)1 },
    { .name="EUC_CN", .encoding=(enum pg_enc)2 },
    { .name="EUC_KR", .encoding=(enum pg_enc)3 },
    { .name="EUC_TW", .encoding=(enum pg_enc)4 },
    { .name="EUC_JIS_2004", .encoding=(enum pg_enc)5 },
    { .name="UTF8", .encoding=(enum pg_enc)6 },
    { .name="MULE_INTERNAL", .encoding=(enum pg_enc)7 },
    { .name="LATIN1", .encoding=(enum pg_enc)8 },
    { .name="LATIN2", .encoding=(enum pg_enc)9 },
    { .name="LATIN3", .encoding=(enum pg_enc)10 },
    { .name="LATIN4", .encoding=(enum pg_enc)11 },
    { .name="LATIN5", .encoding=(enum pg_enc)12 },
    { .name="LATIN6", .encoding=(enum pg_enc)13 },
    { .name="LATIN7", .encoding=(enum pg_enc)14 },
    { .name="LATIN8", .encoding=(enum pg_enc)15 },
    { .name="LATIN9", .encoding=(enum pg_enc)16 },
    { .name="LATIN10", .encoding=(enum pg_enc)17 },
    { .name="WIN1256", .encoding=(enum pg_enc)18 },
    { .name="WIN1258", .encoding=(enum pg_enc)19 },
    { .name="WIN866", .encoding=(enum pg_enc)20 },
    { .name="WIN874", .encoding=(enum pg_enc)21 },
    { .name="KOI8R", .encoding=(enum pg_enc)22 },
    { .name="WIN1251", .encoding=(enum pg_enc)23 },
    { .name="WIN1252", .encoding=(enum pg_enc)24 },
    { .name="ISO_8859_5", .encoding=(enum pg_enc)25 },
    { .name="ISO_8859_6", .encoding=(enum pg_enc)26 },
    { .name="ISO_8859_7", .encoding=(enum pg_enc)27 },
    { .name="ISO_8859_8", .encoding=(enum pg_enc)28 },
    { .name="WIN1250", .encoding=(enum pg_enc)29 },
    { .name="WIN1253", .encoding=(enum pg_enc)30 },
    { .name="WIN1254", .encoding=(enum pg_enc)31 },
    { .name="WIN1255", .encoding=(enum pg_enc)32 },
    { .name="WIN1257", .encoding=(enum pg_enc)33 },
    { .name="KOI8U", .encoding=(enum pg_enc)34 },
    { .name="SJIS", .encoding=(enum pg_enc)35 },
    { .name="BIG5", .encoding=(enum pg_enc)36 },
    { .name="GBK", .encoding=(enum pg_enc)37 },
    { .name="UHC", .encoding=(enum pg_enc)38 },
    { .name="GB18030", .encoding=(enum pg_enc)39 },
    { .name="JOHAB", .encoding=(enum pg_enc)40 },
    { .name="SHIFT_JIS_2004", .encoding=(enum pg_enc)41 } };
// pg_encname_tbl
// file encnames.c line 38
static const struct pg_encname pg_encname_tbl[81l] = { { .name="abc", .encoding=(enum pg_enc)19 },
    { .name="alt", .encoding=(enum pg_enc)20 },
    { .name="big5", .encoding=(enum pg_enc)36 },
    { .name="euccn", .encoding=(enum pg_enc)2 },
    { .name="eucjis2004", .encoding=(enum pg_enc)5 },
    { .name="eucjp", .encoding=(enum pg_enc)1 },
    { .name="euckr", .encoding=(enum pg_enc)3 },
    { .name="euctw", .encoding=(enum pg_enc)4 },
    { .name="gb18030", .encoding=(enum pg_enc)39 },
    { .name="gbk", .encoding=(enum pg_enc)37 },
    { .name="iso88591", .encoding=(enum pg_enc)8 },
    { .name="iso885910", .encoding=(enum pg_enc)13 },
    { .name="iso885913", .encoding=(enum pg_enc)14 },
    { .name="iso885914", .encoding=(enum pg_enc)15 },
    { .name="iso885915", .encoding=(enum pg_enc)16 },
    { .name="iso885916", .encoding=(enum pg_enc)17 },
    { .name="iso88592", .encoding=(enum pg_enc)9 },
    { .name="iso88593", .encoding=(enum pg_enc)10 },
    { .name="iso88594", .encoding=(enum pg_enc)11 },
    { .name="iso88595", .encoding=(enum pg_enc)25 },
    { .name="iso88596", .encoding=(enum pg_enc)26 },
    { .name="iso88597", .encoding=(enum pg_enc)27 },
    { .name="iso88598", .encoding=(enum pg_enc)28 },
    { .name="iso88599", .encoding=(enum pg_enc)12 },
    { .name="johab", .encoding=(enum pg_enc)40 },
    { .name="koi8", .encoding=(enum pg_enc)22 },
    { .name="koi8r", .encoding=(enum pg_enc)22 },
    { .name="koi8u", .encoding=(enum pg_enc)34 },
    { .name="latin1", .encoding=(enum pg_enc)8 },
    { .name="latin10", .encoding=(enum pg_enc)17 },
    { .name="latin2", .encoding=(enum pg_enc)9 },
    { .name="latin3", .encoding=(enum pg_enc)10 },
    { .name="latin4", .encoding=(enum pg_enc)11 },
    { .name="latin5", .encoding=(enum pg_enc)12 },
    { .name="latin6", .encoding=(enum pg_enc)13 },
    { .name="latin7", .encoding=(enum pg_enc)14 },
    { .name="latin8", .encoding=(enum pg_enc)15 },
    { .name="latin9", .encoding=(enum pg_enc)16 },
    { .name="mskanji", .encoding=(enum pg_enc)35 },
    { .name="muleinternal", .encoding=(enum pg_enc)7 },
    { .name="shiftjis", .encoding=(enum pg_enc)35 },
    { .name="shiftjis2004", .encoding=(enum pg_enc)41 },
    { .name="sjis", .encoding=(enum pg_enc)35 },
    { .name="sqlascii", .encoding=(enum pg_enc)0 },
    { .name="tcvn", .encoding=(enum pg_enc)19 },
    { .name="tcvn5712", .encoding=(enum pg_enc)19 },
    { .name="uhc", .encoding=(enum pg_enc)38 },
    { .name="unicode", .encoding=(enum pg_enc)6 },
    { .name="utf8", .encoding=(enum pg_enc)6 },
    { .name="vscii", .encoding=(enum pg_enc)19 },
    { .name="win", .encoding=(enum pg_enc)23 },
    { .name="win1250", .encoding=(enum pg_enc)29 },
    { .name="win1251", .encoding=(enum pg_enc)23 },
    { .name="win1252", .encoding=(enum pg_enc)24 },
    { .name="win1253", .encoding=(enum pg_enc)30 },
    { .name="win1254", .encoding=(enum pg_enc)31 },
    { .name="win1255", .encoding=(enum pg_enc)32 },
    { .name="win1256", .encoding=(enum pg_enc)18 },
    { .name="win1257", .encoding=(enum pg_enc)33 },
    { .name="win1258", .encoding=(enum pg_enc)19 },
    { .name="win866", .encoding=(enum pg_enc)20 },
    { .name="win874", .encoding=(enum pg_enc)21 },
    { .name="win932", .encoding=(enum pg_enc)35 },
    { .name="win936", .encoding=(enum pg_enc)37 },
    { .name="win949", .encoding=(enum pg_enc)38 },
    { .name="win950", .encoding=(enum pg_enc)36 },
    { .name="windows1250", .encoding=(enum pg_enc)29 },
    { .name="windows1251", .encoding=(enum pg_enc)23 },
    { .name="windows1252", .encoding=(enum pg_enc)24 },
    { .name="windows1253", .encoding=(enum pg_enc)30 },
    { .name="windows1254", .encoding=(enum pg_enc)31 },
    { .name="windows1255", .encoding=(enum pg_enc)32 },
    { .name="windows1256", .encoding=(enum pg_enc)18 },
    { .name="windows1257", .encoding=(enum pg_enc)33 },
    { .name="windows1258", .encoding=(enum pg_enc)19 },
    { .name="windows866", .encoding=(enum pg_enc)20 },
    { .name="windows874", .encoding=(enum pg_enc)21 },
    { .name="windows932", .encoding=(enum pg_enc)35 },
    { .name="windows936", .encoding=(enum pg_enc)37 },
    { .name="windows949", .encoding=(enum pg_enc)38 },
    { .name="windows950", .encoding=(enum pg_enc)36 } };
// pg_g_threadlock
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 385
void (*pg_g_threadlock)(signed int);
// pg_g_threadlock
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 385
void (*pg_g_threadlock)(signed int) = default_threadlock;
// pg_wchar_table
// file wchar.c line 1723
const struct anonymous_27 pg_wchar_table[42l];
// pg_wchar_table
// file wchar.c line 1723
const struct anonymous_27 pg_wchar_table[42l] = { { .mb2wchar_with_len=pg_ascii2wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_ascii_mblen,
    .dsplen=pg_ascii_dsplen, .mbverify=pg_ascii_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_eucjp2wchar_with_len, .wchar2mb_with_len=pg_wchar2euc_with_len,
    .mblen=pg_eucjp_mblen,
    .dsplen=pg_eucjp_dsplen, .mbverify=pg_eucjp_verifier,
    .maxmblen=3 },
    { .mb2wchar_with_len=pg_euccn2wchar_with_len, .wchar2mb_with_len=pg_wchar2euc_with_len,
    .mblen=pg_euccn_mblen,
    .dsplen=pg_euccn_dsplen, .mbverify=pg_euckr_verifier,
    .maxmblen=2 },
    { .mb2wchar_with_len=pg_euckr2wchar_with_len, .wchar2mb_with_len=pg_wchar2euc_with_len,
    .mblen=pg_euckr_mblen,
    .dsplen=pg_euckr_dsplen, .mbverify=pg_euckr_verifier,
    .maxmblen=3 },
    { .mb2wchar_with_len=pg_euctw2wchar_with_len, .wchar2mb_with_len=pg_wchar2euc_with_len,
    .mblen=pg_euctw_mblen,
    .dsplen=pg_euctw_dsplen, .mbverify=pg_euctw_verifier,
    .maxmblen=4 },
    { .mb2wchar_with_len=pg_eucjp2wchar_with_len, .wchar2mb_with_len=pg_wchar2euc_with_len,
    .mblen=pg_eucjp_mblen,
    .dsplen=pg_eucjp_dsplen, .mbverify=pg_eucjp_verifier,
    .maxmblen=3 },
    { .mb2wchar_with_len=pg_utf2wchar_with_len, .wchar2mb_with_len=pg_wchar2utf_with_len,
    .mblen=pg_utf_mblen,
    .dsplen=pg_utf_dsplen, .mbverify=pg_utf8_verifier,
    .maxmblen=4 },
    { .mb2wchar_with_len=pg_mule2wchar_with_len, .wchar2mb_with_len=pg_wchar2mule_with_len,
    .mblen=pg_mule_mblen,
    .dsplen=pg_mule_dsplen, .mbverify=pg_mule_verifier,
    .maxmblen=4 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=pg_latin12wchar_with_len, .wchar2mb_with_len=pg_wchar2single_with_len,
    .mblen=pg_latin1_mblen,
    .dsplen=pg_latin1_dsplen, .mbverify=pg_latin1_verifier,
    .maxmblen=1 },
    { .mb2wchar_with_len=((signed int (*)(const unsigned char *, unsigned int *, signed int))NULL), .wchar2mb_with_len=((signed int (*)(const unsigned int *, unsigned char *, signed int))NULL),
    .mblen=pg_sjis_mblen,
    .dsplen=pg_sjis_dsplen, .mbverify=pg_sjis_verifier,
    .maxmblen=2 },
    { .mb2wchar_with_len=((signed int (*)(const unsigned char *, unsigned int *, signed int))NULL), .wchar2mb_with_len=((signed int (*)(const unsigned int *, unsigned char *, signed int))NULL),
    .mblen=pg_big5_mblen,
    .dsplen=pg_big5_dsplen, .mbverify=pg_big5_verifier,
    .maxmblen=2 },
    { .mb2wchar_with_len=((signed int (*)(const unsigned char *, unsigned int *, signed int))NULL), .wchar2mb_with_len=((signed int (*)(const unsigned int *, unsigned char *, signed int))NULL),
    .mblen=pg_gbk_mblen,
    .dsplen=pg_gbk_dsplen, .mbverify=pg_gbk_verifier,
    .maxmblen=2 },
    { .mb2wchar_with_len=((signed int (*)(const unsigned char *, unsigned int *, signed int))NULL), .wchar2mb_with_len=((signed int (*)(const unsigned int *, unsigned char *, signed int))NULL),
    .mblen=pg_uhc_mblen,
    .dsplen=pg_uhc_dsplen, .mbverify=pg_uhc_verifier,
    .maxmblen=2 },
    { .mb2wchar_with_len=((signed int (*)(const unsigned char *, unsigned int *, signed int))NULL), .wchar2mb_with_len=((signed int (*)(const unsigned int *, unsigned char *, signed int))NULL),
    .mblen=pg_gb18030_mblen,
    .dsplen=pg_gb18030_dsplen, .mbverify=pg_gb18030_verifier,
    .maxmblen=4 },
    { .mb2wchar_with_len=((signed int (*)(const unsigned char *, unsigned int *, signed int))NULL), .wchar2mb_with_len=((signed int (*)(const unsigned int *, unsigned char *, signed int))NULL),
    .mblen=pg_johab_mblen,
    .dsplen=pg_johab_dsplen, .mbverify=pg_johab_verifier,
    .maxmblen=3 },
    { .mb2wchar_with_len=((signed int (*)(const unsigned char *, unsigned int *, signed int))NULL), .wchar2mb_with_len=((signed int (*)(const unsigned int *, unsigned char *, signed int))NULL),
    .mblen=pg_sjis_mblen,
    .dsplen=pg_sjis_dsplen, .mbverify=pg_sjis_verifier,
    .maxmblen=2 } };
// pghost
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 174
char *pghost = "";
// pgport
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 175
char *pgport = "";
// pgresStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 32
char * const pgresStatus[10l] = { "PGRES_EMPTY_QUERY", "PGRES_COMMAND_OK", "PGRES_TUPLES_OK", "PGRES_COPY_OUT", "PGRES_COPY_IN", "PGRES_BAD_RESPONSE", "PGRES_NONFATAL_ERROR", "PGRES_FATAL_ERROR", "PGRES_COPY_BOTH", "PGRES_SINGLE_TUPLE" };
// pq_init_crypto_lib
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 94
static char pq_init_crypto_lib = (char)1;
// pq_init_ssl_lib
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 93
static char pq_init_ssl_lib = (char)1;
// pq_lockarray
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 867
static union anonymous_2 *pq_lockarray;
// progname
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 178
const char *progname;
// progress
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 165
signed int progress = 0;
// progress_nclients
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 166
signed int progress_nclients = 0;
// progress_nthreads
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 168
signed int progress_nthreads = 0;
// querymode
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 264
static enum QueryMode querymode = (enum QueryMode)0;
// sample_rate
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 129
double sample_rate = 0.0;
// scale
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 108
signed int scale = 1;
// select_only
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 334
static char *select_only = "\\set naccounts 100000 * :scale\n\\setrandom aid 1 :naccounts\nSELECT abalance FROM pgbench_accounts WHERE aid = :aid;\n";
// short_uri_designator
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 328
static const char short_uri_designator[12l] = { 'p', 'o', 's', 't', 'g', 'r', 'e', 's', ':', '/', '/', 0 };
// simple_update
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 318
static char *simple_update = "\\set nbranches 1 * :scale\n\\set ntellers 10 * :scale\n\\set naccounts 100000 * :scale\n\\setrandom aid 1 :naccounts\n\\setrandom bid 1 :nbranches\n\\setrandom tid 1 :ntellers\n\\setrandom delta -5000 5000\nBEGIN;\nUPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;\nSELECT abalance FROM pgbench_accounts WHERE aid = :aid;\nINSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);\nEND;\n";
// sql_files
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 294
static struct anonymous_22 **sql_files[128l];
// ssl_config_mutex
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 107
static union anonymous_2 ssl_config_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// ssl_nomem
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1607
static char ssl_nomem[43l] = { 'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ' ', 'a', 'l', 'l', 'o', 'c', 'a', 't', 'i', 'n', 'g', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'd', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n', 0 };
// ssl_open_connections
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 104
static signed long int ssl_open_connections = (signed long int)0;
// static_client_encoding
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 49
static signed int static_client_encoding = 0;
// static_std_strings
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 50
static char static_std_strings = (char)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// sys_siglist
// file /usr/include/signal.h line 304
extern const char * const sys_siglist[65l];
// tablespace
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 140
char *tablespace = (char *)(void *)0;
// throttle_delay
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 135
signed long int throttle_delay = (signed long int)0;
// timer_exceeded
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 180
volatile char timer_exceeded = (char)0;
// tpc_b
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 300
static char *tpc_b = "\\set nbranches 1 * :scale\n\\set ntellers 10 * :scale\n\\set naccounts 100000 * :scale\n\\setrandom aid 1 :naccounts\n\\setrandom bid 1 :nbranches\n\\setrandom tid 1 :ntellers\n\\setrandom delta -5000 5000\nBEGIN;\nUPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;\nSELECT abalance FROM pgbench_accounts WHERE aid = :aid;\nUPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;\nUPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;\nINSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);\nEND;\n";
// uri_designator
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 327
static const char uri_designator[14l] = { 'p', 'o', 's', 't', 'g', 'r', 'e', 's', 'q', 'l', ':', '/', '/', 0 };
// use_log
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 161
char use_log;
// use_quiet
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 162
char use_quiet;

// GetDatabasePath
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/relpath.c line 108
extern char * GetDatabasePath(unsigned int dbNode, unsigned int spcNode)
{
  if(spcNode == 1664u)
  {
    char *return_value_pstrdup_1;
    return_value_pstrdup_1=pstrdup("global");
    return return_value_pstrdup_1;
  }

  else
    if(spcNode == 1663u)
    {
      char *return_value_psprintf_2;
      return_value_psprintf_2=psprintf("base/%u", dbNode);
      return return_value_psprintf_2;
    }

    else
    {
      char *return_value_psprintf_3;
      return_value_psprintf_3=psprintf("pg_tblspc/%u/%s/%u", spcNode, (const void *)"PG_9.4_201409291", dbNode);
      return return_value_psprintf_3;
    }
}

// GetRelationPath
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/relpath.c line 139
extern char * GetRelationPath(unsigned int dbNode, unsigned int spcNode, unsigned int relNode, signed int backendId, enum ForkNumber forkNumber)
{
  char *path;
  if(spcNode == 1664u)
  {
    if(!((signed int)forkNumber == MAIN_FORKNUM))
      path=psprintf("global/%u_%s", relNode, forkNames[(signed long int)forkNumber]);

    else
      path=psprintf("global/%u", relNode);
  }

  else
    if(spcNode == 1663u)
    {
      if(backendId == -1)
      {
        if(!((signed int)forkNumber == MAIN_FORKNUM))
          path=psprintf("base/%u/%u_%s", dbNode, relNode, forkNames[(signed long int)forkNumber]);

        else
          path=psprintf("base/%u/%u", dbNode, relNode);
      }

      else
        if(!((signed int)forkNumber == MAIN_FORKNUM))
          path=psprintf("base/%u/t%d_%u_%s", dbNode, backendId, relNode, forkNames[(signed long int)forkNumber]);

        else
          path=psprintf("base/%u/t%d_%u", dbNode, backendId, relNode);
    }

    else
      if(backendId == -1)
      {
        if(!((signed int)forkNumber == MAIN_FORKNUM))
          path=psprintf("pg_tblspc/%u/%s/%u/%u_%s", spcNode, (const void *)"PG_9.4_201409291", dbNode, relNode, forkNames[(signed long int)forkNumber]);

        else
          path=psprintf("pg_tblspc/%u/%s/%u/%u", spcNode, (const void *)"PG_9.4_201409291", dbNode, relNode);
      }

      else
        if(!((signed int)forkNumber == MAIN_FORKNUM))
          path=psprintf("pg_tblspc/%u/%s/%u/t%d_%u_%s", spcNode, (const void *)"PG_9.4_201409291", dbNode, backendId, relNode, forkNames[(signed long int)forkNumber]);

        else
          path=psprintf("pg_tblspc/%u/%s/%u/t%d_%u", spcNode, (const void *)"PG_9.4_201409291", dbNode, backendId, relNode);
  return path;
}

// PQbackendPID
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5461
extern signed int PQbackendPID(const struct pg_conn *conn)
{
  _Bool tmp_if_expr_1;
  if(conn == ((const struct pg_conn *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)conn->status != CONNECTION_OK ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return 0;

  else
    return conn->be_pid;
}

// PQbinaryTuples
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2629
extern signed int PQbinaryTuples(const struct pg_result *res)
{
  if(res == ((const struct pg_result *)NULL))
    return 0;

  else
    return res->binary;
}

// PQcancel
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3320
extern signed int PQcancel(struct pg_cancel *cancel, char *errbuf, signed int errbufsize)
{
  if(cancel == ((struct pg_cancel *)NULL))
  {
    strlcpy(errbuf, "PQcancel() -- no cancel object supplied", (unsigned long int)errbufsize);
    return 0;
  }

  else
  {
    signed int return_value_internal_cancel_1;
    return_value_internal_cancel_1=internal_cancel(&cancel->raddr, cancel->be_pid, cancel->be_key, errbuf, errbufsize);
    return return_value_internal_cancel_1;
  }
}

// PQclear
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 478
extern void PQclear(struct pg_result *res)
{
  union pgresult_data *block;
  signed int i;
  if(!(res == ((struct pg_result *)NULL)))
  {
    i = 0;
    for( ; !(i >= res->nEvents); i = i + 1)
    {
      if(!((res->events + (signed long int)i)->resultInitialized == 0))
      {
        struct anonymous_37 evt;
        evt.result = res;
        (res->events + (signed long int)i)->proc((enum anonymous_13)PGEVT_RESULTDESTROY, (void *)&evt, (res->events + (signed long int)i)->passThrough);
      }

      free((void *)(res->events + (signed long int)i)->name);
    }
    if(!(res->events == ((struct PGEvent *)NULL)))
      free((void *)res->events);

    do
    {
      block = res->curBlock;
      if(block == ((union pgresult_data *)NULL))
        break;

      res->curBlock = block->next;
      free((void *)block);
    }
    while((_Bool)1);
    if(!(res->tuples == ((struct pgresAttValue **)NULL)))
      free((void *)res->tuples);

    res->attDescs = (struct pgresAttDesc *)(void *)0;
    res->tuples = (struct pgresAttValue **)(void *)0;
    res->paramDescs = (struct pgresParamDesc *)(void *)0;
    res->errFields = (struct pgMessageField *)(void *)0;
    res->events = (struct PGEvent *)(void *)0;
    res->nEvents = 0;
    free((void *)res);
  }

}

// PQclientEncoding
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5492
extern signed int PQclientEncoding(const struct pg_conn *conn)
{
  _Bool tmp_if_expr_1;
  if(conn == ((const struct pg_conn *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)conn->status != CONNECTION_OK ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return -1;

  else
    return conn->client_encoding;
}

// PQcmdStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2884
extern char * PQcmdStatus(struct pg_result *res)
{
  if(res == ((struct pg_result *)NULL))
    return (char *)(void *)0;

  else
    return res->cmdStatus;
}

// PQcmdTuples
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2954
extern char * PQcmdTuples(struct pg_result *res)
{
  char *p;
  char *c;
  signed int return_value_strncmp_5;
  _Bool tmp_if_expr_7;
  signed int return_value_strncmp_6;
  _Bool tmp_if_expr_9;
  signed int return_value_strncmp_8;
  signed int return_value_strncmp_4;
  signed int return_value_strncmp_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strncmp_2;
  if(res == ((struct pg_result *)NULL))
    return "";

  else
  {
    signed int return_value_strncmp_10;
    return_value_strncmp_10=strncmp(res->cmdStatus, "INSERT ", (unsigned long int)7);
    if(return_value_strncmp_10 == 0)
    {
      p = res->cmdStatus + (signed long int)7;
      for( ; !(*p == 0); p = p + 1l)
        if((signed int)*p == 32)
          break;

      if((signed int)*p == 0)
        goto interpret_error;

      p = p + 1l;
    }

    else
    {
      return_value_strncmp_5=strncmp(res->cmdStatus, "SELECT ", (unsigned long int)7);
      if(return_value_strncmp_5 == 0)
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_strncmp_6=strncmp(res->cmdStatus, "DELETE ", (unsigned long int)7);
        tmp_if_expr_7 = return_value_strncmp_6 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
        tmp_if_expr_9 = (_Bool)1;

      else
      {
        return_value_strncmp_8=strncmp(res->cmdStatus, "UPDATE ", (unsigned long int)7);
        tmp_if_expr_9 = return_value_strncmp_8 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_9)
        p = res->cmdStatus + (signed long int)7;

      else
      {
        return_value_strncmp_4=strncmp(res->cmdStatus, "FETCH ", (unsigned long int)6);
        if(return_value_strncmp_4 == 0)
          p = res->cmdStatus + (signed long int)6;

        else
        {
          return_value_strncmp_1=strncmp(res->cmdStatus, "MOVE ", (unsigned long int)5);
          if(return_value_strncmp_1 == 0)
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value_strncmp_2=strncmp(res->cmdStatus, "COPY ", (unsigned long int)5);
            tmp_if_expr_3 = return_value_strncmp_2 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_3)
            p = res->cmdStatus + (signed long int)5;

          else
            return "";
        }
      }
    }
    c = p;
    for( ; !(*c == 0); c = c + 1l)
    {
      const unsigned short int **return_value___ctype_b_loc_11;
      return_value___ctype_b_loc_11=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc_11)[(signed long int)(signed int)(unsigned char)*c]) == 0)
        goto interpret_error;

    }
    if(!(c == p))
      return p;

    else
    {

    interpret_error:
      ;
      pqInternalNotice(&res->noticeHooks, "could not interpret result from server: %s", (const void *)res->cmdStatus);
      return "";
    }
  }
}

// PQconndefaults
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 919
extern struct _PQconninfoOption * PQconndefaults(void)
{
  struct PQExpBufferData errorBuf;
  struct _PQconninfoOption *connOptions;
  initPQExpBuffer(&errorBuf);
  if(errorBuf.maxlen == 0ul)
    return (struct _PQconninfoOption *)(void *)0;

  else
  {
    connOptions=conninfo_init(&errorBuf);
    if(!(connOptions == ((struct _PQconninfoOption *)NULL)))
    {
      char return_value_conninfo_add_defaults_1;
      return_value_conninfo_add_defaults_1=conninfo_add_defaults(connOptions, (struct PQExpBufferData *)(void *)0);
      if(return_value_conninfo_add_defaults_1 == 0)
      {
        PQconninfoFree(connOptions);
        connOptions = (struct _PQconninfoOption *)(void *)0;
      }

    }

    termPQExpBuffer(&errorBuf);
    return connOptions;
  }
}

// PQconnectPoll
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1628
extern enum anonymous_4 PQconnectPoll(struct pg_conn *conn)
{
  struct pg_result *res;
  char sebuf[256l];
  signed int optval;
  signed int n;
  char *return_value_libpq_gettext_1;
  signed int return_value_setsockopt_23;
  signed int return_value_setKeepalivesIdle_18;
  _Bool tmp_if_expr_20;
  signed int return_value_setKeepalivesInterval_19;
  _Bool tmp_if_expr_22;
  signed int return_value_setKeepalivesCount_21;
  _Bool tmp_if_expr_26;
  signed int *return_value___errno_location_25;
  char *return_value_libpq_gettext_38;
  char *return_value_libpq_gettext_39;
  signed int *return_value___errno_location_40;
  char *return_value_pqStrerror_41;
  char *return_value_libpq_gettext_44;
  char *return_value_pqStrerror_45;
  char *return_value_libpq_gettext_46;
  _Bool tmp_if_expr_61;
  signed int return_value_PQisBusy_77;
  char *return_value_libpq_gettext_78;
  _Bool tmp_if_expr_80;
  const char *sqlstate;
  signed int return_value_strcmp_79;
  _Bool tmp_if_expr_81;
  if(conn == ((struct pg_conn *)NULL))
    return (enum anonymous_4)PGRES_POLLING_FAILED;

  else
  {
    switch((signed int)conn->status)
    {
      case CONNECTION_BAD:
        return (enum anonymous_4)PGRES_POLLING_FAILED;
      case CONNECTION_OK:
        return (enum anonymous_4)PGRES_POLLING_OK;
      case CONNECTION_AWAITING_RESPONSE:

      case CONNECTION_AUTH_OK:
      {
        n=pqReadData(conn);
        if(!(n >= 0))
          goto error_return;

        if(n == 0)
          return (enum anonymous_4)PGRES_POLLING_READING;

        break;
      }
      case CONNECTION_STARTED:

      case CONNECTION_MADE:
        break;
      case CONNECTION_SETENV:
        break;
      case CONNECTION_SSL_STARTUP:

      case CONNECTION_NEEDED:
        break;
      default:
      {
        return_value_libpq_gettext_1=libpq_gettext("invalid connection state, probably indicative of memory corruption\n");
        appendPQExpBufferStr(&conn->errorMessage, return_value_libpq_gettext_1);
        goto error_return;
      }
    }

  keep_going:
    ;
    for( ; (_Bool)1; conn->status = (enum anonymous_24)CONNECTION_NEEDED)
    {
      if(!((signed int)conn->status == CONNECTION_NEEDED))
      {
        if((signed int)conn->status == CONNECTION_STARTED)
          goto __CPROVER_DUMP_L34;

        if((signed int)conn->status == CONNECTION_MADE)
          goto __CPROVER_DUMP_L39;

        if((signed int)conn->status == CONNECTION_SSL_STARTUP)
          goto __CPROVER_DUMP_L55;

        if((signed int)conn->status == CONNECTION_AWAITING_RESPONSE)
          goto __CPROVER_DUMP_L68;

        if((signed int)conn->status == CONNECTION_AUTH_OK)
          goto __CPROVER_DUMP_L95;

        if((signed int)conn->status == CONNECTION_SETENV)
          goto __CPROVER_DUMP_L107;

        goto __CPROVER_DUMP_L113;
      }

      while(!(conn->addr_cur == ((struct addrinfo *)NULL)))
      {
        struct addrinfo *addr_cur = conn->addr_cur;
        memcpy((void *)&conn->raddr.addr, (const void *)addr_cur->ai_addr, (unsigned long int)addr_cur->ai_addrlen);
        conn->raddr.salen = addr_cur->ai_addrlen;
        conn->sock=socket(addr_cur->ai_family, 1, 0);
        if(conn->sock == -1)
        {
          if(!(addr_cur->ai_next == ((struct addrinfo *)NULL)))
          {
            conn->addr_cur = addr_cur->ai_next;
            continue;
          }

          char *return_value_libpq_gettext_2;
          return_value_libpq_gettext_2=libpq_gettext("could not create socket: %s\n");
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          char *return_value_pqStrerror_4;
          return_value_pqStrerror_4=pqStrerror(*return_value___errno_location_3, sebuf, sizeof(char [256l]) /*256ul*/ );
          appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2, return_value_pqStrerror_4);
          break;
        }

        if(!(addr_cur->ai_family == 1))
        {
          signed int return_value_connectNoDelay_5;
          return_value_connectNoDelay_5=connectNoDelay(conn);
          if(return_value_connectNoDelay_5 == 0)
          {
            pqDropConnection(conn);
            conn->addr_cur = addr_cur->ai_next;
            continue;
          }

        }

        char return_value_pg_set_noblock_9;
        return_value_pg_set_noblock_9=pg_set_noblock(conn->sock);
        if(return_value_pg_set_noblock_9 == 0)
        {
          char *return_value_libpq_gettext_6;
          return_value_libpq_gettext_6=libpq_gettext("could not set socket to nonblocking mode: %s\n");
          signed int *return_value___errno_location_7;
          return_value___errno_location_7=__errno_location();
          char *return_value_pqStrerror_8;
          return_value_pqStrerror_8=pqStrerror(*return_value___errno_location_7, sebuf, sizeof(char [256l]) /*256ul*/ );
          appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_6, return_value_pqStrerror_8);
          pqDropConnection(conn);
          conn->addr_cur = addr_cur->ai_next;
          continue;
        }

        signed int return_value_fcntl_13;
        return_value_fcntl_13=fcntl(conn->sock, 2, 1);
        if(return_value_fcntl_13 == -1)
        {
          char *return_value_libpq_gettext_10;
          return_value_libpq_gettext_10=libpq_gettext("could not set socket to close-on-exec mode: %s\n");
          signed int *return_value___errno_location_11;
          return_value___errno_location_11=__errno_location();
          char *return_value_pqStrerror_12;
          return_value_pqStrerror_12=pqStrerror(*return_value___errno_location_11, sebuf, sizeof(char [256l]) /*256ul*/ );
          appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_10, return_value_pqStrerror_12);
          pqDropConnection(conn);
          conn->addr_cur = addr_cur->ai_next;
          continue;
        }

        if(!(addr_cur->ai_family == 1))
        {
          signed int on = 1;
          signed int usekeepalives;
          usekeepalives=useKeepalives(conn);
          signed int err = 0;
          if(!(usekeepalives >= 0))
          {
            char *return_value_libpq_gettext_14;
            return_value_libpq_gettext_14=libpq_gettext("keepalives parameter must be an integer\n");
            appendPQExpBufferStr(&conn->errorMessage, return_value_libpq_gettext_14);
            err = 1;
          }

          else
            if(!(usekeepalives == 0))
            {
              return_value_setsockopt_23=setsockopt(conn->sock, 1, 9, (const void *)(char *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
              if(!(return_value_setsockopt_23 >= 0))
              {
                char *return_value_libpq_gettext_15;
                return_value_libpq_gettext_15=libpq_gettext("setsockopt(SO_KEEPALIVE) failed: %s\n");
                signed int *return_value___errno_location_16;
                return_value___errno_location_16=__errno_location();
                char *return_value_pqStrerror_17;
                return_value_pqStrerror_17=pqStrerror(*return_value___errno_location_16, sebuf, sizeof(char [256l]) /*256ul*/ );
                appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_15, return_value_pqStrerror_17);
                err = 1;
              }

              else
              {
                return_value_setKeepalivesIdle_18=setKeepalivesIdle(conn);
                if(return_value_setKeepalivesIdle_18 == 0)
                  tmp_if_expr_20 = (_Bool)1;

                else
                {
                  return_value_setKeepalivesInterval_19=setKeepalivesInterval(conn);
                  tmp_if_expr_20 = !(return_value_setKeepalivesInterval_19 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_20)
                  tmp_if_expr_22 = (_Bool)1;

                else
                {
                  return_value_setKeepalivesCount_21=setKeepalivesCount(conn);
                  tmp_if_expr_22 = !(return_value_setKeepalivesCount_21 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_22)
                  err = 1;

              }
            }

          if(!(err == 0))
          {
            pqDropConnection(conn);
            conn->addr_cur = addr_cur->ai_next;
            continue;
          }

        }

        conn->sigpipe_so = (char)0;
        conn->sigpipe_flag = (char)1;
        signed int return_value_connect_27;
        return_value_connect_27=connect(conn->sock, addr_cur->ai_addr, addr_cur->ai_addrlen);
        if(!(return_value_connect_27 >= 0))
        {
          signed int *return_value___errno_location_24;
          return_value___errno_location_24=__errno_location();
          if(*return_value___errno_location_24 == 115)
            tmp_if_expr_26 = (_Bool)1;

          else
          {
            return_value___errno_location_25=__errno_location();
            tmp_if_expr_26 = *return_value___errno_location_25 == 4 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_26)
          {
            conn->status = (enum anonymous_24)CONNECTION_STARTED;
            return (enum anonymous_4)PGRES_POLLING_WRITING;
          }

        }

        else
        {
          conn->status = (enum anonymous_24)CONNECTION_STARTED;
          goto keep_going;
        }
        signed int *return_value___errno_location_28;
        return_value___errno_location_28=__errno_location();
        connectFailureMessage(conn, *return_value___errno_location_28);
        pqDropConnection(conn);
        conn->addr_cur = addr_cur->ai_next;
      }
      goto error_return;

    __CPROVER_DUMP_L34:
      ;
      unsigned int optlen = (unsigned int)sizeof(signed int) /*4ul*/ ;
      signed int return_value_getsockopt_32;
      return_value_getsockopt_32=getsockopt(conn->sock, 1, 4, (void *)(char *)&optval, &optlen);
      if(return_value_getsockopt_32 == -1)
      {
        char *return_value_libpq_gettext_29;
        return_value_libpq_gettext_29=libpq_gettext("could not get socket error status: %s\n");
        signed int *return_value___errno_location_30;
        return_value___errno_location_30=__errno_location();
        char *return_value_pqStrerror_31;
        return_value_pqStrerror_31=pqStrerror(*return_value___errno_location_30, sebuf, sizeof(char [256l]) /*256ul*/ );
        appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_29, return_value_pqStrerror_31);
        goto error_return;
      }

      else
        if(!(optval == 0))
        {
          connectFailureMessage(conn, optval);
          pqDropConnection(conn);
          if(!(conn->addr_cur->ai_next == ((struct addrinfo *)NULL)))
          {
            conn->addr_cur = conn->addr_cur->ai_next;
            conn->status = (enum anonymous_24)CONNECTION_NEEDED;
            goto keep_going;
          }

          goto error_return;
        }

      conn->laddr.salen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
      signed int return_value_getsockname_36;
      return_value_getsockname_36=getsockname(conn->sock, (struct sockaddr *)&conn->laddr.addr, &conn->laddr.salen);
      if(!(return_value_getsockname_36 >= 0))
      {
        char *return_value_libpq_gettext_33;
        return_value_libpq_gettext_33=libpq_gettext("could not get client address from socket: %s\n");
        signed int *return_value___errno_location_34;
        return_value___errno_location_34=__errno_location();
        char *return_value_pqStrerror_35;
        return_value_pqStrerror_35=pqStrerror(*return_value___errno_location_34, sebuf, sizeof(char [256l]) /*256ul*/ );
        appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_33, return_value_pqStrerror_35);
        goto error_return;
      }

      conn->status = (enum anonymous_24)CONNECTION_MADE;
      return (enum anonymous_4)PGRES_POLLING_WRITING;

    __CPROVER_DUMP_L39:
      ;
      char *startpacket;
      signed int packetlen;
      if(!(conn->requirepeer == ((char *)NULL)))
      {
        if(!(*conn->requirepeer == 0))
        {
          if((signed int)conn->raddr.addr.ss_family == 1)
          {
            char pwdbuf[8192l];
            struct passwd pass_buf;
            struct passwd *pass;
            signed int passerr;
            unsigned int uid;
            unsigned int gid;
            signed int *return_value___errno_location_37;
            return_value___errno_location_37=__errno_location();
            *return_value___errno_location_37 = 0;
            signed int return_value_getpeereid_43;
            return_value_getpeereid_43=getpeereid(conn->sock, &uid, &gid);
            if(!(return_value_getpeereid_43 == 0))
            {
              signed int *return_value___errno_location_42;
              return_value___errno_location_42=__errno_location();
              if(*return_value___errno_location_42 == 38)
              {
                return_value_libpq_gettext_38=libpq_gettext("requirepeer parameter is not supported on this platform\n");
                appendPQExpBufferStr(&conn->errorMessage, return_value_libpq_gettext_38);
              }

              else
              {
                return_value_libpq_gettext_39=libpq_gettext("could not get peer credentials: %s\n");
                return_value___errno_location_40=__errno_location();
                return_value_pqStrerror_41=pqStrerror(*return_value___errno_location_40, sebuf, sizeof(char [256l]) /*256ul*/ );
                appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_39, return_value_pqStrerror_41);
              }
              goto error_return;
            }

            passerr=pqGetpwuid(uid, &pass_buf, pwdbuf, sizeof(char [8192l]) /*8192ul*/ , &pass);
            if(pass == ((struct passwd *)NULL))
            {
              if(!(passerr == 0))
              {
                return_value_libpq_gettext_44=libpq_gettext("could not look up local user ID %d: %s\n");
                return_value_pqStrerror_45=pqStrerror(passerr, sebuf, sizeof(char [256l]) /*256ul*/ );
                appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_44, (signed int)uid, return_value_pqStrerror_45);
              }

              else
              {
                return_value_libpq_gettext_46=libpq_gettext("local user with ID %d does not exist\n");
                appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_46, (signed int)uid);
              }
              goto error_return;
            }

            signed int return_value_strcmp_48;
            return_value_strcmp_48=strcmp(pass->pw_name, conn->requirepeer);
            if(!(return_value_strcmp_48 == 0))
            {
              char *return_value_libpq_gettext_47;
              return_value_libpq_gettext_47=libpq_gettext("requirepeer specifies \"%s\", but actual peer user name is \"%s\"\n");
              appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_47, conn->requirepeer, pass->pw_name);
              goto error_return;
            }

          }

        }

      }

      if((signed int)conn->raddr.addr.ss_family == 1)
        conn->allow_ssl_try = (char)0;

      if(!(conn->allow_ssl_try == 0))
      {
        if(conn->wait_ssl_try == 0)
        {
          if(conn->ssl == ((struct ssl_st *)NULL))
          {
            unsigned int pv;
            pv=htonl((unsigned int)(1234 << 16 | 5679));
            signed int return_value_pqPacketSend_52;
            return_value_pqPacketSend_52=pqPacketSend(conn, (char)0, (const void *)&pv, sizeof(unsigned int) /*4ul*/ );
            if(!(return_value_pqPacketSend_52 == 0))
            {
              char *return_value_libpq_gettext_49;
              return_value_libpq_gettext_49=libpq_gettext("could not send SSL negotiation packet: %s\n");
              signed int *return_value___errno_location_50;
              return_value___errno_location_50=__errno_location();
              char *return_value_pqStrerror_51;
              return_value_pqStrerror_51=pqStrerror(*return_value___errno_location_50, sebuf, sizeof(char [256l]) /*256ul*/ );
              appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_49, return_value_pqStrerror_51);
              goto error_return;
            }

            conn->status = (enum anonymous_24)CONNECTION_SSL_STARTUP;
            return (enum anonymous_4)PGRES_POLLING_READING;
          }

        }

      }

      if(conn->pversion >> 16 >= 3u)
        startpacket=pqBuildStartupPacket3(conn, &packetlen, EnvironmentOptions);

      else
        startpacket=pqBuildStartupPacket2(conn, &packetlen, EnvironmentOptions);
      if(startpacket == ((char *)NULL))
      {
        char *return_value_libpq_gettext_53;
        return_value_libpq_gettext_53=libpq_gettext("out of memory\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_53);
        goto error_return;
      }

      signed int return_value_pqPacketSend_57;
      return_value_pqPacketSend_57=pqPacketSend(conn, (char)0, (const void *)startpacket, (unsigned long int)packetlen);
      if(!(return_value_pqPacketSend_57 == 0))
      {
        char *return_value_libpq_gettext_54;
        return_value_libpq_gettext_54=libpq_gettext("could not send startup packet: %s\n");
        signed int *return_value___errno_location_55;
        return_value___errno_location_55=__errno_location();
        char *return_value_pqStrerror_56;
        return_value_pqStrerror_56=pqStrerror(*return_value___errno_location_55, sebuf, sizeof(char [256l]) /*256ul*/ );
        appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_54, return_value_pqStrerror_56);
        free((void *)startpacket);
        goto error_return;
      }

      free((void *)startpacket);
      conn->status = (enum anonymous_24)CONNECTION_AWAITING_RESPONSE;
      return (enum anonymous_4)PGRES_POLLING_READING;

    __CPROVER_DUMP_L55:
      ;
      enum anonymous_4 pollres;
      if(conn->ssl == ((struct ssl_st *)NULL))
      {
        char SSLok;
        signed int rdresult;
        rdresult=pqReadData(conn);
        if(!(rdresult >= 0))
          goto error_return;

        if(rdresult == 0)
          return (enum anonymous_4)PGRES_POLLING_READING;

        signed int return_value_pqGetc_58;
        return_value_pqGetc_58=pqGetc(&SSLok, conn);
        if(!(return_value_pqGetc_58 >= 0))
          return (enum anonymous_4)PGRES_POLLING_READING;

        if((signed int)SSLok == 83)
        {
          conn->inStart = conn->inCursor;
          signed int return_value_pqsecure_initialize_59;
          return_value_pqsecure_initialize_59=pqsecure_initialize(conn);
          if(!(return_value_pqsecure_initialize_59 == 0))
            goto error_return;

        }

        else
          if((signed int)SSLok == 78)
          {
            conn->inStart = conn->inCursor;
            if((signed int)*conn->sslmode == 114)
              tmp_if_expr_61 = (_Bool)1;

            else
              tmp_if_expr_61 = (signed int)conn->sslmode[(signed long int)0] == 118 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_61)
            {
              char *return_value_libpq_gettext_60;
              return_value_libpq_gettext_60=libpq_gettext("server does not support SSL, but SSL was required\n");
              appendPQExpBufferStr(&conn->errorMessage, return_value_libpq_gettext_60);
              goto error_return;
            }

            conn->allow_ssl_try = (char)0;
            conn->status = (enum anonymous_24)CONNECTION_MADE;
            return (enum anonymous_4)PGRES_POLLING_WRITING;
          }

          else
            if((signed int)SSLok == 69)
            {
              conn->status = (enum anonymous_24)CONNECTION_AWAITING_RESPONSE;
              goto keep_going;
            }

            else
            {
              char *return_value_libpq_gettext_62;
              return_value_libpq_gettext_62=libpq_gettext("received invalid response to SSL negotiation: %c\n");
              appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_62, SSLok);
              goto error_return;
            }
      }

      pollres=pqsecure_open_client(conn);
      if((signed int)pollres == PGRES_POLLING_OK)
      {
        conn->status = (enum anonymous_24)CONNECTION_MADE;
        return (enum anonymous_4)PGRES_POLLING_WRITING;
      }

      if((signed int)pollres == PGRES_POLLING_FAILED)
      {
        if((signed int)*conn->sslmode == 112)
        {
          if(!(conn->allow_ssl_try == 0))
          {
            if(conn->wait_ssl_try == 0)
            {
              conn->allow_ssl_try = (char)0;
              pqDropConnection(conn);
              conn->status = (enum anonymous_24)CONNECTION_NEEDED;
              goto keep_going;
            }

          }

        }

      }

      return pollres;

    __CPROVER_DUMP_L68:
      ;
      char beresp;
      signed int msgLength;
      signed int avail;
      unsigned int areq;
      conn->inCursor = conn->inStart;
      signed int return_value_pqGetc_63;
      return_value_pqGetc_63=pqGetc(&beresp, conn);
      if(!(return_value_pqGetc_63 == 0))
        return (enum anonymous_4)PGRES_POLLING_READING;

      if(!((signed int)beresp == 69) && !((signed int)beresp == 82))
      {
        char *return_value_libpq_gettext_64;
        return_value_libpq_gettext_64=libpq_gettext("expected authentication request from server, but received %c\n");
        appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_64, beresp);
        goto error_return;
      }

      if(conn->pversion >> 16 >= 3u)
      {
        signed int return_value_pqGetInt_65;
        return_value_pqGetInt_65=pqGetInt(&msgLength, (unsigned long int)4, conn);
        if(!(return_value_pqGetInt_65 == 0))
          return (enum anonymous_4)PGRES_POLLING_READING;

      }

      else
        msgLength = 8;
      if((signed int)beresp == 82 && (msgLength >= 2001 || !(msgLength >= 8)))
      {
        char *return_value_libpq_gettext_66;
        return_value_libpq_gettext_66=libpq_gettext("expected authentication request from server, but received %c\n");
        appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_66, beresp);
        goto error_return;
      }

      if((signed int)beresp == 69 && (msgLength >= 30001 || !(msgLength >= 8)))
      {
        conn->inCursor = conn->inStart + 1;
        signed int return_value_pqGets_append_67;
        return_value_pqGets_append_67=pqGets_append(&conn->errorMessage, conn);
        if(!(return_value_pqGets_append_67 == 0))
          return (enum anonymous_4)PGRES_POLLING_READING;

        conn->inStart = conn->inCursor;
        appendPQExpBufferChar(&conn->errorMessage, (char)10);
        if(conn->pversion >> 16 >= 3u)
        {
          conn->pversion = (unsigned int)(2 << 16 | 0);
          pqDropConnection(conn);
          conn->status = (enum anonymous_24)CONNECTION_NEEDED;
          goto keep_going;
        }

        goto error_return;
      }

      msgLength = msgLength - 4;
      avail = conn->inEnd - conn->inCursor;
      if(!(avail >= msgLength))
      {
        signed int return_value_pqCheckInBufferSpace_68;
        return_value_pqCheckInBufferSpace_68=pqCheckInBufferSpace((unsigned long int)conn->inCursor + (unsigned long int)msgLength, conn);
        if(!(return_value_pqCheckInBufferSpace_68 == 0))
          goto error_return;

        return (enum anonymous_4)PGRES_POLLING_READING;
      }

      if((signed int)beresp == 69)
      {
        if(conn->pversion >> 16 >= 3u)
        {
          signed int return_value_pqGetErrorNotice3_69;
          return_value_pqGetErrorNotice3_69=pqGetErrorNotice3(conn, (char)1);
          if(!(return_value_pqGetErrorNotice3_69 == 0))
            return (enum anonymous_4)PGRES_POLLING_READING;

        }

        else
        {
          signed int return_value_pqGets_append_70;
          return_value_pqGets_append_70=pqGets_append(&conn->errorMessage, conn);
          if(!(return_value_pqGets_append_70 == 0))
            return (enum anonymous_4)PGRES_POLLING_READING;

        }
        conn->inStart = conn->inCursor;
        if((signed int)*conn->sslmode == 97)
        {
          if(conn->ssl == ((struct ssl_st *)NULL))
          {
            if(!(conn->allow_ssl_try == 0))
            {
              if(!(conn->wait_ssl_try == 0))
              {
                conn->wait_ssl_try = (char)0;
                pqDropConnection(conn);
                conn->status = (enum anonymous_24)CONNECTION_NEEDED;
                goto keep_going;
              }

            }

          }

        }

        if((signed int)*conn->sslmode == 112)
        {
          if(!(conn->allow_ssl_try == 0))
          {
            if(conn->wait_ssl_try == 0)
            {
              conn->allow_ssl_try = (char)0;
              pqDropConnection(conn);
              conn->status = (enum anonymous_24)CONNECTION_NEEDED;
              goto keep_going;
            }

          }

        }

        goto error_return;
      }

      conn->auth_req_received = (char)1;
      signed int return_value_pqGetInt_71;
      return_value_pqGetInt_71=pqGetInt((signed int *)&areq, (unsigned long int)4, conn);
      if(!(return_value_pqGetInt_71 == 0))
        return (enum anonymous_4)PGRES_POLLING_READING;

      if(areq == 5u)
      {
        signed int return_value_pqGetnchar_72;
        return_value_pqGetnchar_72=pqGetnchar(conn->md5Salt, sizeof(char [4l]) /*4ul*/ , conn);
        if(!(return_value_pqGetnchar_72 == 0))
          return (enum anonymous_4)PGRES_POLLING_READING;

      }

      if(areq == 8u)
      {
        signed int llen = msgLength - 4;
        if(!((unsigned long int)llen == conn->ginbuf.length))
        {
          if(!(conn->ginbuf.value == NULL))
            free(conn->ginbuf.value);

          conn->ginbuf.length = (unsigned long int)llen;
          conn->ginbuf.value=malloc((unsigned long int)llen);
          if(conn->ginbuf.value == NULL)
          {
            char *return_value_libpq_gettext_73;
            return_value_libpq_gettext_73=libpq_gettext("out of memory allocating GSSAPI buffer (%d)");
            printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_73, llen);
            goto error_return;
          }

        }

        signed int return_value_pqGetnchar_74;
        return_value_pqGetnchar_74=pqGetnchar((char *)conn->ginbuf.value, (unsigned long int)llen, conn);
        if(!(return_value_pqGetnchar_74 == 0))
          return (enum anonymous_4)PGRES_POLLING_READING;

      }

      conn->inStart = conn->inCursor;
      signed int return_value_pg_fe_sendauth_75;
      return_value_pg_fe_sendauth_75=pg_fe_sendauth(areq, conn);
      if(!(return_value_pg_fe_sendauth_75 == 0))
      {
        conn->errorMessage.len=strlen(conn->errorMessage.data);
        goto error_return;
      }

      conn->errorMessage.len=strlen(conn->errorMessage.data);
      signed int return_value_pqFlush_76;
      return_value_pqFlush_76=pqFlush(conn);
      if(!(return_value_pqFlush_76 == 0))
        goto error_return;

      if(areq == 0u)
      {
        conn->status = (enum anonymous_24)CONNECTION_AUTH_OK;
        conn->asyncStatus = (enum anonymous_9)PGASYNC_BUSY;
      }

      goto keep_going;

    __CPROVER_DUMP_L95:
      ;
      return_value_PQisBusy_77=PQisBusy(conn);
      if(!(return_value_PQisBusy_77 == 0))
        return (enum anonymous_4)PGRES_POLLING_READING;

      res=PQgetResult(conn);
      if(res == ((struct pg_result *)NULL))
        goto __CPROVER_DUMP_L105;

      if(!((signed int)res->resultStatus == PGRES_FATAL_ERROR))
      {
        return_value_libpq_gettext_78=libpq_gettext("unexpected message from server during startup\n");
        appendPQExpBufferStr(&conn->errorMessage, return_value_libpq_gettext_78);
        goto __CPROVER_DUMP_L101;
      }

      if(conn->send_appname == 0)
        goto __CPROVER_DUMP_L101;

      if(!(conn->appname == ((char *)NULL)))
        tmp_if_expr_80 = (_Bool)1;

      else
        tmp_if_expr_80 = conn->fbappname != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_80)
        goto __CPROVER_DUMP_L101;

      sqlstate=PQresultErrorField(res, 67);
      if(sqlstate == ((const char *)NULL))
        break;

      return_value_strcmp_79=strcmp(sqlstate, "42704");
      if(!(return_value_strcmp_79 == 0))
        break;

      PQclear(res);
      conn->send_appname = (char)0;
      pqDropConnection(conn);
    }

  __CPROVER_DUMP_L101:
    ;
    if(!(conn->errorMessage.len >= 1ul))
      tmp_if_expr_81 = (_Bool)1;

    else
      tmp_if_expr_81 = (signed int)conn->errorMessage.data[(signed long int)(conn->errorMessage.len - (unsigned long int)1)] != 10 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_81)
      appendPQExpBufferChar(&conn->errorMessage, (char)10);

    PQclear(res);
    goto error_return;

  __CPROVER_DUMP_L105:
    ;
    pg_freeaddrinfo_all(conn->addrlist_family, conn->addrlist);
    conn->addrlist = (struct addrinfo *)(void *)0;
    conn->addr_cur = (struct addrinfo *)(void *)0;
    if(!(conn->pversion >> 16 >= 3u))
    {
      conn->status = (enum anonymous_24)CONNECTION_SETENV;
      conn->setenv_state = (enum anonymous_11)SETENV_STATE_CLIENT_ENCODING_SEND;
      conn->next_eo = EnvironmentOptions;
      return (enum anonymous_4)PGRES_POLLING_WRITING;
    }

    else
    {
      conn->status = (enum anonymous_24)CONNECTION_OK;
      return (enum anonymous_4)PGRES_POLLING_OK;

    __CPROVER_DUMP_L107:
      ;
      conn->status = (enum anonymous_24)CONNECTION_OK;
      enum anonymous_4 return_value_pqSetenvPoll_82;
      return_value_pqSetenvPoll_82=pqSetenvPoll(conn);
      switch((signed int)return_value_pqSetenvPoll_82)
      {
        case PGRES_POLLING_OK:
          break;
        case PGRES_POLLING_READING:
        {
          conn->status = (enum anonymous_24)CONNECTION_SETENV;
          return (enum anonymous_4)PGRES_POLLING_READING;
        }
        case PGRES_POLLING_WRITING:
        {
          conn->status = (enum anonymous_24)CONNECTION_SETENV;
          return (enum anonymous_4)PGRES_POLLING_WRITING;
        }
        default:
          goto error_return;
      }
      conn->status = (enum anonymous_24)CONNECTION_OK;
      return (enum anonymous_4)PGRES_POLLING_OK;

    __CPROVER_DUMP_L113:
      ;
      char *return_value_libpq_gettext_83;
      return_value_libpq_gettext_83=libpq_gettext("invalid connection state %d, probably indicative of memory corruption\n");
      appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_83, conn->status);
      goto error_return;

    error_return:
      ;
      dot_pg_pass_warning(conn);
      conn->status = (enum anonymous_24)CONNECTION_BAD;
      return (enum anonymous_4)PGRES_POLLING_FAILED;
    }
  }
}

// PQconnectStart
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 637
extern struct pg_conn * PQconnectStart(const char *conninfo)
{
  struct pg_conn *conn;
  conn=makeEmptyPGconn();
  if(conn == ((struct pg_conn *)NULL))
    return (struct pg_conn *)(void *)0;

  else
  {
    char return_value_connectOptions1_1;
    return_value_connectOptions1_1=connectOptions1(conn, conninfo);
    if(return_value_connectOptions1_1 == 0)
      return conn;

    else
    {
      char return_value_connectOptions2_2;
      return_value_connectOptions2_2=connectOptions2(conn);
      if(return_value_connectOptions2_2 == 0)
        return conn;

      else
      {
        signed int return_value_connectDBStart_3;
        return_value_connectDBStart_3=connectDBStart(conn);
        if(return_value_connectDBStart_3 == 0)
          conn->status = (enum anonymous_24)CONNECTION_BAD;

        return conn;
      }
    }
  }
}

// PQconnectStartParams
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 558
extern struct pg_conn * PQconnectStartParams(const char * const *keywords, const char * const *values, signed int expand_dbname)
{
  struct pg_conn *conn;
  struct _PQconninfoOption *connOptions;
  conn=makeEmptyPGconn();
  if(conn == ((struct pg_conn *)NULL))
    return (struct pg_conn *)(void *)0;

  else
  {
    connOptions=conninfo_array_parse(keywords, values, &conn->errorMessage, (char)1, expand_dbname);
    if(connOptions == ((struct _PQconninfoOption *)NULL))
    {
      conn->status = (enum anonymous_24)CONNECTION_BAD;
      return conn;
    }

    else
    {
      char return_value_fillPGconn_1;
      return_value_fillPGconn_1=fillPGconn(conn, connOptions);
      if(return_value_fillPGconn_1 == 0)
      {
        PQconninfoFree(connOptions);
        return conn;
      }

      else
      {
        PQconninfoFree(connOptions);
        char return_value_connectOptions2_2;
        return_value_connectOptions2_2=connectOptions2(conn);
        if(return_value_connectOptions2_2 == 0)
          return conn;

        else
        {
          signed int return_value_connectDBStart_3;
          return_value_connectDBStart_3=connectDBStart(conn);
          if(return_value_connectDBStart_3 == 0)
            conn->status = (enum anonymous_24)CONNECTION_BAD;

          return conn;
        }
      }
    }
  }
}

// PQconnectdb
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 511
extern struct pg_conn * PQconnectdb(const char *conninfo)
{
  struct pg_conn *conn;
  conn=PQconnectStart(conninfo);
  if(!(conn == ((struct pg_conn *)NULL)))
  {
    if(!((signed int)conn->status == CONNECTION_BAD))
      connectDBComplete(conn);

  }

  return conn;
}

// PQconnectdbParams
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 251
extern struct pg_conn * PQconnectdbParams(const char * const *keywords, const char * const *values, signed int expand_dbname)
{
  struct pg_conn *conn;
  conn=PQconnectStartParams(keywords, values, expand_dbname);
  if(!(conn == ((struct pg_conn *)NULL)))
  {
    if(!((signed int)conn->status == CONNECTION_BAD))
      connectDBComplete(conn);

  }

  return conn;
}

// PQconnectionNeedsPassword
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 316
extern signed int PQconnectionNeedsPassword(const struct pg_conn *conn)
{
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(conn == ((const struct pg_conn *)NULL))
    return (signed int)(char)0;

  else
  {
    if(!(conn->password_needed == 0))
    {
      if(conn->pgpass == ((char *)NULL))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (signed int)conn->pgpass[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      return (signed int)(char)1;

    else
      return (signed int)(char)0;
  }
}

// PQconnectionUsedPassword
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5481
extern signed int PQconnectionUsedPassword(const struct pg_conn *conn)
{
  if(conn == ((const struct pg_conn *)NULL))
    return (signed int)(char)0;

  else
    if(!(conn->password_needed == 0))
      return (signed int)(char)1;

    else
      return (signed int)(char)0;
}

// PQconninfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5258
extern struct _PQconninfoOption * PQconninfo(struct pg_conn *conn)
{
  struct PQExpBufferData errorBuf;
  struct _PQconninfoOption *connOptions;
  if(conn == ((struct pg_conn *)NULL))
    return (struct _PQconninfoOption *)(void *)0;

  else
  {
    initPQExpBuffer(&errorBuf);
    if(errorBuf.maxlen == 0ul)
      return (struct _PQconninfoOption *)(void *)0;

    else
    {
      connOptions=conninfo_init(&errorBuf);
      if(!(connOptions == ((struct _PQconninfoOption *)NULL)))
      {
        const struct _internalPQconninfoOption *option = PQconninfoOptions;
        for( ; !(option->keyword == ((char *)NULL)); option = option + 1l)
        {
          char **connmember;
          if(option->connofs >= 0l)
          {
            connmember = (char **)((char *)conn + option->connofs);
            if(!(*connmember == ((char *)NULL)))
              conninfo_storeval(connOptions, option->keyword, *connmember, &errorBuf, (char)1, (char)0);

          }

        }
      }

      termPQExpBuffer(&errorBuf);
      return connOptions;
    }
  }
}

// PQconninfoFree
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5299
extern void PQconninfoFree(struct _PQconninfoOption *connOptions)
{
  struct _PQconninfoOption *option;
  if(!(connOptions == ((struct _PQconninfoOption *)NULL)))
  {
    option = connOptions;
    for( ; !(option->keyword == ((char *)NULL)); option = option + 1l)
      if(!(option->val == ((char *)NULL)))
        free((void *)option->val);

    free((void *)connOptions);
  }

}

// PQconninfoParse
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4121
extern struct _PQconninfoOption * PQconninfoParse(const char *conninfo, char **errmsg)
{
  struct PQExpBufferData errorBuf;
  struct _PQconninfoOption *connOptions;
  if(!(errmsg == ((char **)NULL)))
    *errmsg = (char *)(void *)0;

  initPQExpBuffer(&errorBuf);
  if(errorBuf.maxlen == 0ul)
    return (struct _PQconninfoOption *)(void *)0;

  else
  {
    connOptions=parse_connection_string(conninfo, &errorBuf, (char)0);
    if(connOptions == ((struct _PQconninfoOption *)NULL) && !(errmsg == ((char **)NULL)))
      *errmsg = errorBuf.data;

    else
      termPQExpBuffer(&errorBuf);
    return connOptions;
  }
}

// PQconsumeInput
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 405
extern signed int PQconsumeInput(struct pg_conn *conn)
{
  if(conn == ((struct pg_conn *)NULL))
    return 0;

  else
  {
    if(!(conn->nonblocking == 0))
    {
      signed int return_value_pqFlush_1;
      return_value_pqFlush_1=pqFlush(conn);
      if(!(return_value_pqFlush_1 >= 0))
        return 0;

    }

    signed int return_value_pqReadData_2;
    return_value_pqReadData_2=pqReadData(conn);
    if(!(return_value_pqReadData_2 >= 0))
      return 0;

    else
      return 1;
  }
}

// PQcopyResult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 290
extern struct pg_result * PQcopyResult(const struct pg_result *src, signed int flags)
{
  struct pg_result *dest;
  signed int i;
  if(src == ((const struct pg_result *)NULL))
    return (struct pg_result *)(void *)0;

  else
  {
    dest=PQmakeEmptyPGresult((struct pg_conn *)(void *)0, (enum anonymous_20)PGRES_TUPLES_OK);
    if(dest == ((struct pg_result *)NULL))
      return (struct pg_result *)(void *)0;

    else
    {
      dest->client_encoding = src->client_encoding;
      strcpy(dest->cmdStatus, src->cmdStatus);
      if(!((3 & flags) == 0))
      {
        signed int return_value_PQsetResultAttrs_1;
        return_value_PQsetResultAttrs_1=PQsetResultAttrs(dest, src->numAttributes, src->attDescs);
        if(return_value_PQsetResultAttrs_1 == 0)
        {
          PQclear(dest);
          return (struct pg_result *)(void *)0;
        }

      }

      if(!((0x02 & flags) == 0))
      {
        signed int tup;
        signed int field;
        tup = 0;
        for( ; !(tup >= src->ntups); tup = tup + 1)
        {
          field = 0;
          for( ; !(field >= src->numAttributes); field = field + 1)
          {
            signed int return_value_PQsetvalue_2;
            return_value_PQsetvalue_2=PQsetvalue(dest, tup, field, (src->tuples[(signed long int)tup] + (signed long int)field)->value, (src->tuples[(signed long int)tup] + (signed long int)field)->len);
            if(return_value_PQsetvalue_2 == 0)
            {
              PQclear(dest);
              return (struct pg_result *)(void *)0;
            }

          }
        }
      }

      if(!((0x08 & flags) == 0))
        dest->noticeHooks = src->noticeHooks;

      if(!((0x04 & flags) == 0))
      {
        if(src->nEvents >= 1)
        {
          dest->events=dupEvents(src->events, src->nEvents);
          if(dest->events == ((struct PGEvent *)NULL))
          {
            PQclear(dest);
            return (struct pg_result *)(void *)0;
          }

          dest->nEvents = src->nEvents;
        }

      }

      i = 0;
      for( ; !(i >= dest->nEvents); i = i + 1)
        if(!((src->events + (signed long int)i)->resultInitialized == 0))
        {
          struct anonymous_36 evt;
          evt.src = src;
          evt.dest = dest;
          signed int return_value;
          return_value=(dest->events + (signed long int)i)->proc((enum anonymous_13)PGEVT_RESULTCOPY, (void *)&evt, (dest->events + (signed long int)i)->passThrough);
          if(return_value == 0)
          {
            PQclear(dest);
            return (struct pg_result *)(void *)0;
          }

          (dest->events + (signed long int)i)->resultInitialized = (char)1;
        }

      return dest;
    }
  }
}

// PQdb
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5317
extern char * PQdb(const struct pg_conn *conn)
{
  if(conn == ((const struct pg_conn *)NULL))
    return (char *)(void *)0;

  else
    return conn->dbName;
}

// PQdescribePortal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2060
extern struct pg_result * PQdescribePortal(struct pg_conn *conn, const char *portal)
{
  char return_value_PQexecStart_1;
  return_value_PQexecStart_1=PQexecStart(conn);
  if(return_value_PQexecStart_1 == 0)
    return (struct pg_result *)(void *)0;

  else
  {
    signed int return_value_PQsendDescribe_2;
    return_value_PQsendDescribe_2=PQsendDescribe(conn, (char)80, portal);
    if(return_value_PQsendDescribe_2 == 0)
      return (struct pg_result *)(void *)0;

    else
    {
      struct pg_result *return_value_PQexecFinish_3;
      return_value_PQexecFinish_3=PQexecFinish(conn);
      return return_value_PQexecFinish_3;
    }
  }
}

// PQdescribePrepared
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2041
extern struct pg_result * PQdescribePrepared(struct pg_conn *conn, const char *stmt)
{
  char return_value_PQexecStart_1;
  return_value_PQexecStart_1=PQexecStart(conn);
  if(return_value_PQexecStart_1 == 0)
    return (struct pg_result *)(void *)0;

  else
  {
    signed int return_value_PQsendDescribe_2;
    return_value_PQsendDescribe_2=PQsendDescribe(conn, (char)83, stmt);
    if(return_value_PQsendDescribe_2 == 0)
      return (struct pg_result *)(void *)0;

    else
    {
      struct pg_result *return_value_PQexecFinish_3;
      return_value_PQexecFinish_3=PQexecFinish(conn);
      return return_value_PQexecFinish_3;
    }
  }
}

// PQdisplayTuples
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-print.c line 570
extern void PQdisplayTuples(const struct pg_result *res, struct _IO_FILE *fp, signed int fillAlign, const char *fieldSep, signed int printHeader, signed int quiet)
{
  signed int i;
  signed int j;
  signed int nFields;
  signed int nTuples;
  signed int *fLength = (signed int *)(void *)0;
  if(fieldSep == ((const char *)NULL))
    fieldSep = " ";

  nFields=PQnfields(res);
  nTuples=PQntuples(res);
  if(fp == ((struct _IO_FILE *)NULL))
    fp = stdout;

  if(!(fillAlign == 0))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)nFields * sizeof(signed int) /*4ul*/ );
    fLength = (signed int *)return_value_malloc_1;
    if(fLength == ((signed int *)NULL))
    {
      char *return_value_libpq_gettext_2;
      return_value_libpq_gettext_2=libpq_gettext("out of memory\n");
      fprintf(stderr, return_value_libpq_gettext_2);
      abort();
    }

    j = 0;
    for( ; !(j >= nFields); j = j + 1)
    {
      char *return_value_PQfname_3;
      return_value_PQfname_3=PQfname(res, j);
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(return_value_PQfname_3);
      fLength[(signed long int)j] = (signed int)return_value_strlen_4;
      i = 0;
      for( ; !(i >= nTuples); i = i + 1)
      {
        signed int flen;
        flen=PQgetlength(res, i, j);
        if(!(fLength[(signed long int)j] >= flen))
          fLength[(signed long int)j] = flen;

      }
    }
  }

  char *return_value_PQfname_6;
  unsigned long int return_value_strlen_7;
  if(!(printHeader == 0))
  {
    i = 0;
    for( ; !(i >= nFields); i = i + 1)
    {
      char *return_value_PQfname_5;
      return_value_PQfname_5=PQfname(res, i);
      fputs(return_value_PQfname_5, fp);
      if(!(fillAlign == 0))
      {
        return_value_PQfname_6=PQfname(res, i);
        return_value_strlen_7=strlen(return_value_PQfname_6);
        fill((signed int)return_value_strlen_7, fLength[(signed long int)i], (char)32, fp);
      }

      fputs(fieldSep, fp);
    }
    fprintf(fp, "\n");
    i = 0;
    for( ; !(i >= nFields); i = i + 1)
    {
      if(!(fillAlign == 0))
        fill(0, fLength[(signed long int)i], (char)45, fp);

      fputs(fieldSep, fp);
    }
    fprintf(fp, "\n");
  }

  i = 0;
  char *return_value_PQgetvalue_9;
  unsigned long int return_value_strlen_10;
  for( ; !(i >= nTuples); i = i + 1)
  {
    j = 0;
    for( ; !(j >= nFields); j = j + 1)
    {
      char *return_value_PQgetvalue_8;
      return_value_PQgetvalue_8=PQgetvalue(res, i, j);
      fprintf(fp, "%s", return_value_PQgetvalue_8);
      if(!(fillAlign == 0))
      {
        return_value_PQgetvalue_9=PQgetvalue(res, i, j);
        return_value_strlen_10=strlen(return_value_PQgetvalue_9);
        fill((signed int)return_value_strlen_10, fLength[(signed long int)j], (char)32, fp);
      }

      fputs(fieldSep, fp);
    }
    fprintf(fp, "\n");
  }
  signed int return_value_PQntuples_11;
  signed int return_value_PQntuples_12;
  if(quiet == 0)
  {
    return_value_PQntuples_11=PQntuples(res);
    return_value_PQntuples_12=PQntuples(res);
    fprintf(fp, "\nQuery returned %d row%s.\n", return_value_PQntuples_11, return_value_PQntuples_12 == 1 ? "" : "s");
  }

  fflush(fp);
  if(!(fLength == ((signed int *)NULL)))
    free((void *)fLength);

}

// PQdsplen
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 1195
extern signed int PQdsplen(const char *s, signed int encoding)
{
  signed int return_value_pg_encoding_dsplen_1;
  return_value_pg_encoding_dsplen_1=pg_encoding_dsplen(encoding, s);
  return return_value_pg_encoding_dsplen_1;
}

// PQencryptPassword
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 806
extern char * PQencryptPassword(const char *passwd, const char *user)
{
  char *crypt_pwd;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(35 + 1));
  crypt_pwd = (char *)return_value_malloc_1;
  if(crypt_pwd == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(user);
    char return_value_pg_md5_encrypt_3;
    return_value_pg_md5_encrypt_3=pg_md5_encrypt(passwd, user, return_value_strlen_2, crypt_pwd);
    if(return_value_pg_md5_encrypt_3 == 0)
    {
      free((void *)crypt_pwd);
      return (char *)(void *)0;
    }

    else
      return crypt_pwd;
  }
}

// PQendcopy
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 420
extern signed int PQendcopy(struct pg_conn *conn)
{
  signed int return_value_pqEndcopy3_1;
  signed int return_value_pqEndcopy2_2;
  if(conn == ((struct pg_conn *)NULL))
    return 0;

  else
    if(conn->pversion >> 16 >= 3u)
    {
      return_value_pqEndcopy3_1=pqEndcopy3(conn);
      return return_value_pqEndcopy3_1;
    }

    else
    {
      return_value_pqEndcopy2_2=pqEndcopy2(conn);
      return return_value_pqEndcopy2_2;
    }
}

// PQenv2encoding
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 1204
extern signed int PQenv2encoding(void)
{
  char *str;
  signed int encoding = PG_SQL_ASCII;
  str=getenv("PGCLIENTENCODING");
  if(!(str == ((char *)NULL)))
  {
    if(!((signed int)*str == 0))
    {
      encoding=pg_char_to_encoding(str);
      if(!(encoding >= 0))
        encoding = PG_SQL_ASCII;

    }

  }

  return encoding;
}

// PQerrorMessage
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 313
extern char * PQerrorMessage(const struct pg_conn *conn)
{
  char *return_value_libpq_gettext_1;
  if(conn == ((const struct pg_conn *)NULL))
  {
    return_value_libpq_gettext_1=libpq_gettext("connection pointer is NULL\n");
    return return_value_libpq_gettext_1;
  }

  else
    return conn->errorMessage.data;
}

// PQescapeBytea
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3570
extern unsigned char * PQescapeBytea(const unsigned char *from, unsigned long int from_length, unsigned long int *to_length)
{
  unsigned char *return_value_PQescapeByteaInternal_1;
  return_value_PQescapeByteaInternal_1=PQescapeByteaInternal((struct pg_conn *)(void *)0, from, from_length, to_length, static_std_strings, (char)0);
  return return_value_PQescapeByteaInternal_1;
}

// PQescapeByteaConn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3558
extern unsigned char * PQescapeByteaConn(struct pg_conn *conn, const unsigned char *from, unsigned long int from_length, unsigned long int *to_length)
{
  if(conn == ((struct pg_conn *)NULL))
    return (unsigned char *)(void *)0;

  else
  {
    unsigned char *return_value_PQescapeByteaInternal_1;
    return_value_PQescapeByteaInternal_1=PQescapeByteaInternal(conn, from, from_length, to_length, conn->std_strings, (char)(conn->sversion >= 90000));
    return return_value_PQescapeByteaInternal_1;
  }
}

// PQescapeByteaInternal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3461
static unsigned char * PQescapeByteaInternal(struct pg_conn *conn, const unsigned char *from, unsigned long int from_length, unsigned long int *to_length, char std_strings, char use_hex)
{
  const unsigned char *vp;
  unsigned char *rp;
  unsigned char *result;
  unsigned long int i;
  unsigned long int len;
  unsigned long int bslash_len = (unsigned long int)(std_strings != 0 ? 1 : 2);
  len = (unsigned long int)1;
  _Bool tmp_if_expr_1;
  if(!(use_hex == 0))
    len = len + bslash_len + (unsigned long int)1 + (unsigned long int)2 * from_length;

  else
  {
    vp = from;
    i = from_length;
    for( ; i >= 1ul; vp = vp + 1l)
    {
      if(!((signed int)*vp >= 0x20))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (signed int)*vp > 0x7e ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        len = len + bslash_len + (unsigned long int)3;

      else
        if((signed int)*vp == 39)
          len = len + (unsigned long int)2;

        else
          if((signed int)*vp == 92)
            len = len + bslash_len + bslash_len;

          else
            len = len + 1ul;
      i = i - 1ul;
    }
  }
  *to_length = len;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(len);
  result = (unsigned char *)return_value_malloc_2;
  rp = result;
  char *return_value_libpq_gettext_3;
  if(rp == ((unsigned char *)NULL))
  {
    if(!(conn == ((struct pg_conn *)NULL)))
    {
      return_value_libpq_gettext_3=libpq_gettext("out of memory\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
    }

    return (unsigned char *)(void *)0;
  }

  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  if(!(use_hex == 0))
  {
    if(std_strings == 0)
    {
      tmp_post_4 = rp;
      rp = rp + 1l;
      *tmp_post_4 = (unsigned char)92;
    }

    tmp_post_5 = rp;
    rp = rp + 1l;
    *tmp_post_5 = (unsigned char)92;
    tmp_post_6 = rp;
    rp = rp + 1l;
    *tmp_post_6 = (unsigned char)120;
  }

  vp = from;
  i = from_length;
  unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  unsigned char *tmp_post_9;
  unsigned char *tmp_post_10;
  unsigned char *tmp_post_11;
  unsigned char *tmp_post_12;
  unsigned char *tmp_post_13;
  unsigned char *tmp_post_14;
  unsigned char *tmp_post_15;
  unsigned char *tmp_post_16;
  unsigned char *tmp_post_17;
  unsigned char *tmp_post_18;
  unsigned char *tmp_post_19;
  unsigned char *tmp_post_20;
  for( ; i >= 1ul; vp = vp + 1l)
  {
    unsigned char c = *vp;
    if(!(use_hex == 0))
    {
      tmp_post_7 = rp;
      rp = rp + 1l;
      *tmp_post_7 = (unsigned char)hextbl[(signed long int)((signed int)c >> 4 & 0xF)];
      tmp_post_8 = rp;
      rp = rp + 1l;
      *tmp_post_8 = (unsigned char)hextbl[(signed long int)((signed int)c & 0xF)];
    }

    else
      if((signed int)c >= 127 || !((signed int)c >= 0x20))
      {
        if(std_strings == 0)
        {
          tmp_post_9 = rp;
          rp = rp + 1l;
          *tmp_post_9 = (unsigned char)92;
        }

        tmp_post_10 = rp;
        rp = rp + 1l;
        *tmp_post_10 = (unsigned char)92;
        tmp_post_11 = rp;
        rp = rp + 1l;
        *tmp_post_11 = (unsigned char)(((signed int)c >> 6) + 48);
        tmp_post_12 = rp;
        rp = rp + 1l;
        *tmp_post_12 = (unsigned char)(((signed int)c >> 3 & 07) + 48);
        tmp_post_13 = rp;
        rp = rp + 1l;
        *tmp_post_13 = (unsigned char)(((signed int)c & 07) + 48);
      }

      else
        if((signed int)c == 39)
        {
          tmp_post_14 = rp;
          rp = rp + 1l;
          *tmp_post_14 = (unsigned char)39;
          tmp_post_15 = rp;
          rp = rp + 1l;
          *tmp_post_15 = (unsigned char)39;
        }

        else
          if((signed int)c == 92)
          {
            if(std_strings == 0)
            {
              tmp_post_16 = rp;
              rp = rp + 1l;
              *tmp_post_16 = (unsigned char)92;
              tmp_post_17 = rp;
              rp = rp + 1l;
              *tmp_post_17 = (unsigned char)92;
            }

            tmp_post_18 = rp;
            rp = rp + 1l;
            *tmp_post_18 = (unsigned char)92;
            tmp_post_19 = rp;
            rp = rp + 1l;
            *tmp_post_19 = (unsigned char)92;
          }

          else
          {
            tmp_post_20 = rp;
            rp = rp + 1l;
            *tmp_post_20 = c;
          }
    i = i - 1ul;
  }
  *rp = (unsigned char)0;
  return result;
}

// PQescapeIdentifier
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 502
extern char * PQescapeIdentifier(struct pg_conn *conn, const char *str, unsigned long int len)
{
  char *return_value_PQescapeInternal_1;
  return_value_PQescapeInternal_1=PQescapeInternal(conn, str, len, (char)1);
  return return_value_PQescapeInternal_1;
}

// PQescapeInternal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3287
static char * PQescapeInternal(struct pg_conn *conn, const char *str, unsigned long int len, char as_ident)
{
  const char *s;
  char *result;
  char *rp;
  signed int num_quotes = 0;
  signed int num_backslashes = 0;
  signed int input_len;
  signed int result_size;
  char quote_char = (char)(as_ident != 0 ? 34 : 39);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_4;
  void *return_value_memchr_3;
  char *tmp_post_7;
  char *tmp_post_8;
  char *tmp_post_9;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_14;
  char *tmp_post_10;
  char *tmp_post_11;
  char *tmp_post_12;
  char *tmp_post_13;
  char *tmp_post_16;
  if(conn == ((struct pg_conn *)NULL))
    return (char *)(void *)0;

  else
  {
    s = str;
    do
    {
      if(!((unsigned long int)(s - str) >= len))
        tmp_if_expr_1 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      if(*s == quote_char)
        num_quotes = num_quotes + 1;

      else
        if((signed int)*s == 92)
          num_backslashes = num_backslashes + 1;

        else
          if(!((0x80 & (signed int)(unsigned char)*s) == 0))
          {
            signed int charlen;
            charlen=pg_encoding_mblen(conn->client_encoding, s);
            if(!(len >= (unsigned long int)(s - str) + (unsigned long int)(signed long int)charlen))
              tmp_if_expr_4 = (_Bool)1;

            else
            {
              return_value_memchr_3=memchr((const void *)s, 0, (unsigned long int)charlen);
              tmp_if_expr_4 = return_value_memchr_3 != (void *)0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_4)
            {
              char *return_value_libpq_gettext_2;
              return_value_libpq_gettext_2=libpq_gettext("incomplete multibyte character\n");
              printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2);
              return (char *)(void *)0;
            }

            s = s + (signed long int)(charlen - 1);
          }

      s = s + 1l;
    }
    while((_Bool)1);
    input_len = (signed int)(s - str);
    result_size = input_len + num_quotes + 3;
    if(as_ident == 0 && num_backslashes >= 1)
      result_size = result_size + num_backslashes + 2;

    void *return_value_malloc_5;
    return_value_malloc_5=malloc((unsigned long int)result_size);
    rp = (char *)return_value_malloc_5;
    result = rp;
    if(rp == ((char *)NULL))
    {
      char *return_value_libpq_gettext_6;
      return_value_libpq_gettext_6=libpq_gettext("out of memory\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_6);
      return (char *)(void *)0;
    }

    if(as_ident == 0 && num_backslashes >= 1)
    {
      tmp_post_7 = rp;
      rp = rp + 1l;
      *tmp_post_7 = (char)32;
      tmp_post_8 = rp;
      rp = rp + 1l;
      *tmp_post_8 = (char)69;
    }

    tmp_post_9 = rp;
    rp = rp + 1l;
    *tmp_post_9 = quote_char;
    if(num_quotes == 0 && (num_backslashes == 0 || !(as_ident == 0)))
    {
      memcpy((void *)rp, (const void *)str, (unsigned long int)input_len);
      rp = rp + (signed long int)input_len;
    }

    else
    {
      s = str;
      for( ; !(s - str >= (signed long int)input_len); s = s + 1l)
      {
        if(*s == quote_char)
          tmp_if_expr_15 = (_Bool)1;

        else
        {
          if(as_ident == 0)
            tmp_if_expr_14 = (signed int)*s == 92 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_14 = (_Bool)0;
          tmp_if_expr_15 = tmp_if_expr_14 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_15)
        {
          tmp_post_10 = rp;
          rp = rp + 1l;
          *tmp_post_10 = *s;
          tmp_post_11 = rp;
          rp = rp + 1l;
          *tmp_post_11 = *s;
        }

        else
          if((0x80 & (signed int)(unsigned char)*s) == 0)
          {
            tmp_post_12 = rp;
            rp = rp + 1l;
            *tmp_post_12 = *s;
          }

          else
          {
            signed int i;
            i=pg_encoding_mblen(conn->client_encoding, s);
            for( ; (_Bool)1; s = s + 1l)
            {
              tmp_post_13 = rp;
              rp = rp + 1l;
              *tmp_post_13 = *s;
              i = i - 1;
              if(i == 0)
                break;

            }
          }
      }
    }
    tmp_post_16 = rp;
    rp = rp + 1l;
    *tmp_post_16 = quote_char;
    *rp = (char)0;
    return result;
  }
}

// PQescapeLiteral
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3408
extern char * PQescapeLiteral(struct pg_conn *conn, const char *str, unsigned long int len)
{
  char *return_value_PQescapeInternal_1;
  return_value_PQescapeInternal_1=PQescapeInternal(conn, str, len, (char)0);
  return return_value_PQescapeInternal_1;
}

// PQescapeString
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3272
extern unsigned long int PQescapeString(char *to, const char *from, unsigned long int length)
{
  unsigned long int return_value_PQescapeStringInternal_1;
  return_value_PQescapeStringInternal_1=PQescapeStringInternal((struct pg_conn *)(void *)0, to, from, length, (signed int *)(void *)0, static_client_encoding, static_std_strings);
  return return_value_PQescapeStringInternal_1;
}

// PQescapeStringConn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3254
extern unsigned long int PQescapeStringConn(struct pg_conn *conn, char *to, const char *from, unsigned long int length, signed int *error)
{
  if(conn == ((struct pg_conn *)NULL))
  {
    *to = (char)0;
    if(!(error == ((signed int *)NULL)))
      *error = 1;

    return (unsigned long int)0;
  }

  else
  {
    unsigned long int return_value_PQescapeStringInternal_1;
    return_value_PQescapeStringInternal_1=PQescapeStringInternal(conn, to, from, length, error, conn->client_encoding, conn->std_strings);
    return return_value_PQescapeStringInternal_1;
  }
}

// PQescapeStringInternal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3179
static unsigned long int PQescapeStringInternal(struct pg_conn *conn, char *to, const char *from, unsigned long int length, signed int *error, signed int encoding, char std_strings)
{
  const char *source = from;
  char *target = to;
  unsigned long int remaining = length;
  if(!(error == ((signed int *)NULL)))
    *error = 0;

  char *tmp_post_1;
  char *tmp_post_2;
  _Bool tmp_if_expr_3;
  char *tmp_post_4;
  const char *tmp_post_5;
  char *return_value_libpq_gettext_6;
  char *tmp_post_7;
  while(remaining >= 1ul)
  {
    if((signed int)*source == 0)
      break;

    char c = *source;
    signed int len;
    signed int i;
    if((0x80 & (signed int)(unsigned char)c) == 0)
    {
      if((signed int)c == 39 || std_strings == 0 && (signed int)c == 92)
      {
        tmp_post_1 = target;
        target = target + 1l;
        *tmp_post_1 = c;
      }

      tmp_post_2 = target;
      target = target + 1l;
      *tmp_post_2 = c;
      source = source + 1l;
      remaining = remaining - 1ul;
    }

    else
    {
      len=pg_encoding_mblen(encoding, source);
      i = 0;
      for( ; !(i >= len); i = i + 1)
      {
        if(remaining == 0ul)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (signed int)*source == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_3)
          break;

        tmp_post_4 = target;
        target = target + 1l;
        tmp_post_5 = source;
        source = source + 1l;
        *tmp_post_4 = *tmp_post_5;
        remaining = remaining - 1ul;
      }
      if(!(i >= len))
      {
        if(!(error == ((signed int *)NULL)))
          *error = 1;

        if(!(conn == ((struct pg_conn *)NULL)))
        {
          return_value_libpq_gettext_6=libpq_gettext("incomplete multibyte character\n");
          printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_6);
        }

        for( ; !(i >= len); i = i + 1)
        {
          if((unsigned long int)(target - to) / 2ul >= length)
            break;

          tmp_post_7 = target;
          target = target + 1l;
          *tmp_post_7 = (char)32;
        }
        break;
      }

    }
  }
  *target = (char)0;
  return (unsigned long int)(target - to);
}

// PQexec
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 360
extern struct pg_result * PQexec(struct pg_conn *conn, const char *query)
{
  char return_value_PQexecStart_1;
  return_value_PQexecStart_1=PQexecStart(conn);
  if(return_value_PQexecStart_1 == 0)
    return (struct pg_result *)(void *)0;

  else
  {
    signed int return_value_PQsendQuery_2;
    return_value_PQsendQuery_2=PQsendQuery(conn, query);
    if(return_value_PQsendQuery_2 == 0)
      return (struct pg_result *)(void *)0;

    else
    {
      struct pg_result *return_value_PQexecFinish_3;
      return_value_PQexecFinish_3=PQexecFinish(conn);
      return return_value_PQexecFinish_3;
    }
  }
}

// PQexecFinish
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1980
static struct pg_result * PQexecFinish(struct pg_conn *conn)
{
  struct pg_result *result;
  struct pg_result *lastResult = (struct pg_result *)(void *)0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  do
  {
    result=PQgetResult(conn);
    if(result == ((struct pg_result *)NULL))
      break;

    if(!(lastResult == ((struct pg_result *)NULL)))
    {
      if((signed int)lastResult->resultStatus == PGRES_FATAL_ERROR)
        tmp_if_expr_1 = (signed int)result->resultStatus == PGRES_FATAL_ERROR ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
      {
        pqCatenateResultError(lastResult, result->errMsg);
        PQclear(result);
        result = lastResult;
        resetPQExpBuffer(&conn->errorMessage);
        appendPQExpBufferStr(&conn->errorMessage, result->errMsg);
      }

      else
        PQclear(lastResult);
    }

    lastResult = result;
    if((signed int)result->resultStatus == PGRES_COPY_IN)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)result->resultStatus == PGRES_COPY_OUT ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)result->resultStatus == PGRES_COPY_BOTH ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)conn->status == CONNECTION_BAD ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      break;

  }
  while((_Bool)1);
  return lastResult;
}

// PQexecParams
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1838
extern struct pg_result * PQexecParams(struct pg_conn *conn, const char *command, signed int nParams, const unsigned int *paramTypes, const char * const *paramValues, const signed int *paramLengths, const signed int *paramFormats, signed int resultFormat)
{
  char return_value_PQexecStart_1;
  return_value_PQexecStart_1=PQexecStart(conn);
  if(return_value_PQexecStart_1 == 0)
    return (struct pg_result *)(void *)0;

  else
  {
    signed int return_value_PQsendQueryParams_2;
    return_value_PQsendQueryParams_2=PQsendQueryParams(conn, command, nParams, paramTypes, paramValues, paramLengths, paramFormats, resultFormat);
    if(return_value_PQsendQueryParams_2 == 0)
      return (struct pg_result *)(void *)0;

    else
    {
      struct pg_result *return_value_PQexecFinish_3;
      return_value_PQexecFinish_3=PQexecFinish(conn);
      return return_value_PQexecFinish_3;
    }
  }
}

// PQexecPrepared
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1885
extern struct pg_result * PQexecPrepared(struct pg_conn *conn, const char *stmtName, signed int nParams, const char * const *paramValues, const signed int *paramLengths, const signed int *paramFormats, signed int resultFormat)
{
  char return_value_PQexecStart_1;
  return_value_PQexecStart_1=PQexecStart(conn);
  if(return_value_PQexecStart_1 == 0)
    return (struct pg_result *)(void *)0;

  else
  {
    signed int return_value_PQsendQueryPrepared_2;
    return_value_PQsendQueryPrepared_2=PQsendQueryPrepared(conn, stmtName, nParams, paramValues, paramLengths, paramFormats, resultFormat);
    if(return_value_PQsendQueryPrepared_2 == 0)
      return (struct pg_result *)(void *)0;

    else
    {
      struct pg_result *return_value_PQexecFinish_3;
      return_value_PQexecFinish_3=PQexecFinish(conn);
      return return_value_PQexecFinish_3;
    }
  }
}

// PQexecStart
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1906
static char PQexecStart(struct pg_conn *conn)
{
  struct pg_result *result;
  if(conn == ((struct pg_conn *)NULL))
    return (char)0;

  else
  {
    do
    {
      result=PQgetResult(conn);
      if(result == ((struct pg_result *)NULL))
        break;

      enum anonymous_20 resultStatus = result->resultStatus;
      PQclear(result);
      if((signed int)resultStatus == PGRES_COPY_IN)
      {
        if(conn->pversion >> 16 >= 3u)
        {
          char *return_value_libpq_gettext_1;
          return_value_libpq_gettext_1=libpq_gettext("COPY terminated by new PQexec");
          signed int return_value_PQputCopyEnd_2;
          return_value_PQputCopyEnd_2=PQputCopyEnd(conn, return_value_libpq_gettext_1);
          if(!(return_value_PQputCopyEnd_2 >= 0))
            return (char)0;

        }

        else
        {
          char *return_value_libpq_gettext_3;
          return_value_libpq_gettext_3=libpq_gettext("COPY IN state must be terminated first\n");
          printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
          return (char)0;
        }
      }

      else
        if((signed int)resultStatus == PGRES_COPY_OUT)
        {
          if(conn->pversion >> 16 >= 3u)
            conn->asyncStatus = (enum anonymous_9)PGASYNC_BUSY;

          else
          {
            char *return_value_libpq_gettext_4;
            return_value_libpq_gettext_4=libpq_gettext("COPY OUT state must be terminated first\n");
            printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_4);
            return (char)0;
          }
        }

        else
          if((signed int)resultStatus == PGRES_COPY_BOTH)
          {
            char *return_value_libpq_gettext_5;
            return_value_libpq_gettext_5=libpq_gettext("PQexec not allowed during COPY BOTH\n");
            printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_5);
            return (char)0;
          }

      if((signed int)conn->status == CONNECTION_BAD)
        return (char)0;

    }
    while((_Bool)1);
    return (char)1;
  }
}

// PQfformat
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2840
extern signed int PQfformat(const struct pg_result *res, signed int field_num)
{
  signed int return_value_check_field_number_1;
  return_value_check_field_number_1=check_field_number(res, field_num);
  if(return_value_check_field_number_1 == 0)
    return 0;

  else
    if(!(res->attDescs == ((struct pgresAttDesc *)NULL)))
      return (res->attDescs + (signed long int)field_num)->format;

    else
      return 0;
}

// PQfinish
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 262
extern void PQfinish(struct pg_conn *conn)
{
  if(!(conn == ((struct pg_conn *)NULL)))
  {
    closePGconn(conn);
    freePGconn(conn);
  }

}

// PQfireResultCreateEvents
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.c line 185
extern signed int PQfireResultCreateEvents(struct pg_conn *conn, struct pg_result *res)
{
  signed int i;
  if(res == ((struct pg_result *)NULL))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= res->nEvents); i = i + 1)
      if((res->events + (signed long int)i)->resultInitialized == 0)
      {
        struct anonymous_15 evt;
        evt.conn = conn;
        evt.result = res;
        signed int return_value;
        return_value=(res->events + (signed long int)i)->proc((enum anonymous_13)PGEVT_RESULTCREATE, (void *)&evt, (res->events + (signed long int)i)->passThrough);
        if(return_value == 0)
          return 0;

        (res->events + (signed long int)i)->resultInitialized = (char)1;
      }

    return 1;
  }
}

// PQflush
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3127
extern signed int PQflush(struct pg_conn *conn)
{
  signed int return_value_pqFlush_1;
  return_value_pqFlush_1=pqFlush(conn);
  return return_value_pqFlush_1;
}

// PQfmod
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2873
extern signed int PQfmod(const struct pg_result *res, signed int field_num)
{
  signed int return_value_check_field_number_1;
  return_value_check_field_number_1=check_field_number(res, field_num);
  if(return_value_check_field_number_1 == 0)
    return 0;

  else
    if(!(res->attDescs == ((struct pgresAttDesc *)NULL)))
      return (res->attDescs + (signed long int)field_num)->atttypmod;

    else
      return 0;
}

// PQfn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2534
extern struct pg_result * PQfn(struct pg_conn *conn, signed int fnid, signed int *result_buf, signed int *result_len, signed int result_is_int, const struct anonymous_33 *args, signed int nargs)
{
  *result_len = 0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  struct pg_result *return_value_pqFunctionCall3_4;
  struct pg_result *return_value_pqFunctionCall2_5;
  if(conn == ((struct pg_conn *)NULL))
    return (struct pg_result *)(void *)0;

  else
  {
    resetPQExpBuffer(&conn->errorMessage);
    if(conn->sock == -1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)conn->asyncStatus != PGASYNC_IDLE ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = conn->result != (struct pg_result *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      char *return_value_libpq_gettext_1;
      return_value_libpq_gettext_1=libpq_gettext("connection in wrong state\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
      return (struct pg_result *)(void *)0;
    }

    if(conn->pversion >> 16 >= 3u)
    {
      return_value_pqFunctionCall3_4=pqFunctionCall3(conn, (unsigned int)fnid, result_buf, result_len, result_is_int, args, nargs);
      return return_value_pqFunctionCall3_4;
    }

    else
    {
      return_value_pqFunctionCall2_5=pqFunctionCall2(conn, (unsigned int)fnid, result_buf, result_len, result_is_int, args, nargs);
      return return_value_pqFunctionCall2_5;
    }
  }
}

// PQfname
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2699
extern char * PQfname(const struct pg_result *res, signed int field_num)
{
  signed int return_value_check_field_number_1;
  return_value_check_field_number_1=check_field_number(res, field_num);
  if(return_value_check_field_number_1 == 0)
    return (char *)(void *)0;

  else
    if(!(res->attDescs == ((struct pgresAttDesc *)NULL)))
      return (res->attDescs + (signed long int)field_num)->name;

    else
      return (char *)(void *)0;
}

// PQfnumber
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2721
extern signed int PQfnumber(const struct pg_result *res, const char *field_name)
{
  char *field_case;
  char in_quotes;
  char all_lower = (char)1;
  const char *iptr;
  char *optr;
  signed int i;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  unsigned char return_value_pg_tolower_3;
  signed int return_value_strcmp_5;
  char *tmp_post_6;
  char *tmp_post_7;
  char *tmp_post_9;
  if(res == ((const struct pg_result *)NULL))
    return -1;

  else
  {
    if(field_name == ((const char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)field_name[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = res->attDescs == (struct pgresAttDesc *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return -1;

    else
    {
      iptr = field_name;
      for( ; !(*iptr == 0); iptr = iptr + 1l)
      {
        char c = *iptr;
        if((signed int)c == 34)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_pg_tolower_3=pg_tolower((unsigned char)c);
          tmp_if_expr_4 = (signed int)c != (signed int)return_value_pg_tolower_3 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          all_lower = (char)0;
          break;
        }

      }
      if(!(all_lower == 0))
      {
        i = 0;
        for( ; !(i >= res->numAttributes); i = i + 1)
        {
          return_value_strcmp_5=strcmp(field_name, (res->attDescs + (signed long int)i)->name);
          if(return_value_strcmp_5 == 0)
            return i;

        }
      }

      field_case=strdup(field_name);
      if(field_case == ((char *)NULL))
        return -1;

      else
      {
        in_quotes = (char)0;
        optr = field_case;
        iptr = field_case;
        for( ; !(*iptr == 0); iptr = iptr + 1l)
        {
          char PQfnumber__1__3__1__c = *iptr;
          if(!(in_quotes == 0))
          {
            if((signed int)PQfnumber__1__3__1__c == 34)
            {
              if((signed int)iptr[1l] == 34)
              {
                tmp_post_6 = optr;
                optr = optr + 1l;
                *tmp_post_6 = (char)34;
                iptr = iptr + 1l;
              }

              else
                in_quotes = (char)0;
            }

            else
            {
              tmp_post_7 = optr;
              optr = optr + 1l;
              *tmp_post_7 = PQfnumber__1__3__1__c;
            }
          }

          else
            if((signed int)PQfnumber__1__3__1__c == 34)
              in_quotes = (char)1;

            else
            {
              unsigned char return_value_pg_tolower_8;
              return_value_pg_tolower_8=pg_tolower((unsigned char)PQfnumber__1__3__1__c);
              PQfnumber__1__3__1__c = (char)return_value_pg_tolower_8;
              tmp_post_9 = optr;
              optr = optr + 1l;
              *tmp_post_9 = PQfnumber__1__3__1__c;
            }
        }
        *optr = (char)0;
        i = 0;
        for( ; !(i >= res->numAttributes); i = i + 1)
        {
          signed int return_value_strcmp_10;
          return_value_strcmp_10=strcmp(field_case, (res->attDescs + (signed long int)i)->name);
          if(return_value_strcmp_10 == 0)
          {
            free((void *)field_case);
            return i;
          }

        }
        free((void *)field_case);
        return -1;
      }
    }
  }
}

// PQfreeCancel
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3188
extern void PQfreeCancel(struct pg_cancel *cancel)
{
  if(!(cancel == ((struct pg_cancel *)NULL)))
    free((void *)cancel);

}

// PQfreeNotify
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3157
void PQfreeNotify(struct pgNotify *notify)
{
  PQfreemem((void *)notify);
}

// PQfreemem
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 481
extern void PQfreemem(void *ptr)
{
  free(ptr);
}

// PQfsize
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2862
extern signed int PQfsize(const struct pg_result *res, signed int field_num)
{
  signed int return_value_check_field_number_1;
  return_value_check_field_number_1=check_field_number(res, field_num);
  if(return_value_check_field_number_1 == 0)
    return 0;

  else
    if(!(res->attDescs == ((struct pgresAttDesc *)NULL)))
      return (res->attDescs + (signed long int)field_num)->typlen;

    else
      return 0;
}

// PQftable
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2818
extern unsigned int PQftable(const struct pg_result *res, signed int field_num)
{
  signed int return_value_check_field_number_1;
  return_value_check_field_number_1=check_field_number(res, field_num);
  if(return_value_check_field_number_1 == 0)
    return (unsigned int)0;

  else
    if(!(res->attDescs == ((struct pgresAttDesc *)NULL)))
      return (res->attDescs + (signed long int)field_num)->tableid;

    else
      return (unsigned int)0;
}

// PQftablecol
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2829
extern signed int PQftablecol(const struct pg_result *res, signed int field_num)
{
  signed int return_value_check_field_number_1;
  return_value_check_field_number_1=check_field_number(res, field_num);
  if(return_value_check_field_number_1 == 0)
    return 0;

  else
    if(!(res->attDescs == ((struct pgresAttDesc *)NULL)))
      return (res->attDescs + (signed long int)field_num)->columnid;

    else
      return 0;
}

// PQftype
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2851
extern unsigned int PQftype(const struct pg_result *res, signed int field_num)
{
  signed int return_value_check_field_number_1;
  return_value_check_field_number_1=check_field_number(res, field_num);
  if(return_value_check_field_number_1 == 0)
    return (unsigned int)0;

  else
    if(!(res->attDescs == ((struct pgresAttDesc *)NULL)))
      return (res->attDescs + (signed long int)field_num)->typid;

    else
      return (unsigned int)0;
}

// PQgetCancel
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3165
extern struct pg_cancel * PQgetCancel(struct pg_conn *conn)
{
  struct pg_cancel *cancel;
  if(conn == ((struct pg_conn *)NULL))
    return (struct pg_cancel *)(void *)0;

  else
    if(conn->sock == -1)
      return (struct pg_cancel *)(void *)0;

    else
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(sizeof(struct pg_cancel) /*144ul*/ );
      cancel = (struct pg_cancel *)return_value_malloc_1;
      if(cancel == ((struct pg_cancel *)NULL))
        return (struct pg_cancel *)(void *)0;

      else
      {
        memcpy((void *)&cancel->raddr, (const void *)&conn->raddr, sizeof(struct anonymous_7) /*136ul*/ );
        cancel->be_pid = conn->be_pid;
        cancel->be_key = conn->be_key;
        return cancel;
      }
    }
}

// PQgetCopyData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2355
extern signed int PQgetCopyData(struct pg_conn *conn, char **buffer, signed int async)
{
  *buffer = (char *)(void *)0;
  signed int return_value_pqGetCopyData3_2;
  signed int return_value_pqGetCopyData2_3;
  if(conn == ((struct pg_conn *)NULL))
    return -2;

  else
  {
    if(!((signed int)conn->asyncStatus == PGASYNC_COPY_OUT))
    {
      if(!((signed int)conn->asyncStatus == PGASYNC_COPY_BOTH))
      {
        char *return_value_libpq_gettext_1;
        return_value_libpq_gettext_1=libpq_gettext("no COPY in progress\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
        return -2;
      }

    }

    if(conn->pversion >> 16 >= 3u)
    {
      return_value_pqGetCopyData3_2=pqGetCopyData3(conn, buffer, async);
      return return_value_pqGetCopyData3_2;
    }

    else
    {
      return_value_pqGetCopyData2_3=pqGetCopyData2(conn, buffer, async);
      return return_value_pqGetCopyData2_3;
    }
  }
}

// PQgetResult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 401
extern struct pg_result * PQgetResult(struct pg_conn *conn)
{
  struct pg_result *res;
  _Bool tmp_if_expr_4;
  signed int return_value_pqWait_3;
  _Bool tmp_if_expr_6;
  signed int return_value_pqReadData_5;
  char *return_value_libpq_gettext_7;
  if(conn == ((struct pg_conn *)NULL))
    return (struct pg_result *)(void *)0;

  else
  {
    parseInput(conn);
    while((signed int)conn->asyncStatus == PGASYNC_BUSY)
    {
      signed int flushResult;
      do
      {
        flushResult=pqFlush(conn);
        if(!(flushResult >= 1))
          break;

        signed int return_value_pqWait_1;
        return_value_pqWait_1=pqWait(0, 1, conn);
        if(!(return_value_pqWait_1 == 0))
        {
          flushResult = -1;
          break;
        }

      }
      while((_Bool)1);
      if(!(flushResult == 0))
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value_pqWait_3=pqWait(1, 0, conn);
        tmp_if_expr_4 = return_value_pqWait_3 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_pqReadData_5=pqReadData(conn);
        tmp_if_expr_6 = return_value_pqReadData_5 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
      {
        pqSaveErrorResult(conn);
        conn->asyncStatus = (enum anonymous_9)PGASYNC_IDLE;
        struct pg_result *return_value_pqPrepareAsyncResult_2;
        return_value_pqPrepareAsyncResult_2=pqPrepareAsyncResult(conn);
        return return_value_pqPrepareAsyncResult_2;
      }

      parseInput(conn);
    }
    switch((signed int)conn->asyncStatus)
    {
      case PGASYNC_IDLE:
      {
        res = (struct pg_result *)(void *)0;
        break;
      }
      case PGASYNC_READY:
      {
        res=pqPrepareAsyncResult(conn);
        conn->asyncStatus = (enum anonymous_9)PGASYNC_BUSY;
        break;
      }
      case PGASYNC_COPY_IN:
      {
        res=getCopyResult(conn, (enum anonymous_20)PGRES_COPY_IN);
        break;
      }
      case PGASYNC_COPY_OUT:
      {
        res=getCopyResult(conn, (enum anonymous_20)PGRES_COPY_OUT);
        break;
      }
      case PGASYNC_COPY_BOTH:
      {
        res=getCopyResult(conn, (enum anonymous_20)PGRES_COPY_BOTH);
        break;
      }
      default:
      {
        return_value_libpq_gettext_7=libpq_gettext("unexpected asyncStatus: %d\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_7, (signed int)conn->asyncStatus);
        res=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_FATAL_ERROR);
      }
    }
    if(!(res == ((struct pg_result *)NULL)))
    {
      signed int i = 0;
      if(!(i >= res->nEvents))
      {
        struct anonymous_15 evt;
        evt.conn = conn;
        evt.result = res;
        signed int return_value;
        return_value=(res->events + (signed long int)i)->proc((enum anonymous_13)PGEVT_RESULTCREATE, (void *)&evt, (res->events + (signed long int)i)->passThrough);
        if(return_value == 0)
        {
          char *return_value_libpq_gettext_8;
          return_value_libpq_gettext_8=libpq_gettext("PGEventProc \"%s\" failed during PGEVT_RESULTCREATE event\n");
          printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_8, (res->events + (signed long int)i)->name);
          pqSetResultError(res, conn->errorMessage.data);
          res->resultStatus = (enum anonymous_20)PGRES_FATAL_ERROR;
        }

        (res->events + (signed long int)i)->resultInitialized = (char)1;
        i = i + 1;
      }

    }

    return res;
  }
}

// PQgetisnull
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3032
extern signed int PQgetisnull(const struct pg_result *res, signed int tup_num, signed int field_num)
{
  signed int return_value_check_tuple_field_number_1;
  return_value_check_tuple_field_number_1=check_tuple_field_number(res, tup_num, field_num);
  if(return_value_check_tuple_field_number_1 == 0)
    return 1;

  else
    if((res->tuples[(signed long int)tup_num] + (signed long int)field_num)->len == -1)
      return 1;

    else
      return 0;
}

// PQgetlength
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3018
extern signed int PQgetlength(const struct pg_result *res, signed int tup_num, signed int field_num)
{
  signed int return_value_check_tuple_field_number_1;
  return_value_check_tuple_field_number_1=check_tuple_field_number(res, tup_num, field_num);
  if(return_value_check_tuple_field_number_1 == 0)
    return 0;

  else
    if(!((res->tuples[(signed long int)tup_num] + (signed long int)field_num)->len == -1))
      return (res->tuples[(signed long int)tup_num] + (signed long int)field_num)->len;

    else
      return 0;
}

// PQgetline
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2397
extern signed int PQgetline(struct pg_conn *conn, char *s, signed int maxlen)
{
  signed int return_value_pqGetline3_1;
  signed int return_value_pqGetline2_2;
  if(s == ((char *)NULL) || !(maxlen >= 1))
    return -1;

  else
  {
    *s = (char)0;
    if(!(maxlen >= 3))
      return -1;

    else
      if(conn == ((struct pg_conn *)NULL))
        return -1;

      else
        if(conn->pversion >> 16 >= 3u)
        {
          return_value_pqGetline3_1=pqGetline3(conn, s, maxlen);
          return return_value_pqGetline3_1;
        }

        else
        {
          return_value_pqGetline2_2=pqGetline2(conn, s, maxlen);
          return return_value_pqGetline2_2;
        }
  }
}

// PQgetlineAsync
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2447
extern signed int PQgetlineAsync(struct pg_conn *conn, char *buffer, signed int bufsize)
{
  signed int return_value_pqGetlineAsync3_1;
  signed int return_value_pqGetlineAsync2_2;
  if(conn == ((struct pg_conn *)NULL))
    return -1;

  else
    if(conn->pversion >> 16 >= 3u)
    {
      return_value_pqGetlineAsync3_1=pqGetlineAsync3(conn, buffer, bufsize);
      return return_value_pqGetlineAsync3_1;
    }

    else
    {
      return_value_pqGetlineAsync2_2=pqGetlineAsync2(conn, buffer, bufsize);
      return return_value_pqGetlineAsync2_2;
    }
}

// PQgetssl
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1648
extern void * PQgetssl(struct pg_conn *conn)
{
  if(conn == ((struct pg_conn *)NULL))
    return (void *)0;

  else
    return (void *)conn->ssl;
}

// PQgetvalue
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 465
extern char * PQgetvalue(const struct pg_result *res, signed int tup_num, signed int field_num)
{
  signed int return_value_check_tuple_field_number_1;
  return_value_check_tuple_field_number_1=check_tuple_field_number(res, tup_num, field_num);
  if(return_value_check_tuple_field_number_1 == 0)
    return (char *)(void *)0;

  else
    return (res->tuples[(signed long int)tup_num] + (signed long int)field_num)->value;
}

// PQhost
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5341
extern char * PQhost(const struct pg_conn *conn)
{
  _Bool tmp_if_expr_1;
  if(conn == ((const struct pg_conn *)NULL))
    return (char *)(void *)0;

  else
  {
    if(!(conn->pghost == ((char *)NULL)))
      tmp_if_expr_1 = (signed int)conn->pghost[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      return conn->pghost;

    else
      return conn->pgunixsocket;
  }
}

// PQinitOpenSSL
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 205
extern void PQinitOpenSSL(signed int do_ssl, signed int do_crypto)
{
  if(ssl_open_connections == 0l)
  {
    pq_init_ssl_lib = (char)do_ssl;
    pq_init_crypto_lib = (char)do_crypto;
  }

}

// PQinitSSL
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 195
extern void PQinitSSL(signed int do_init)
{
  PQinitOpenSSL(do_init, do_init);
}

// PQinstanceData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.c line 121
extern void * PQinstanceData(const struct pg_conn *conn, signed int (*proc)(enum anonymous_13, void *, void *))
{
  signed int i;
  if(proc == ((signed int (*)(enum anonymous_13, void *, void *))NULL) || conn == ((const struct pg_conn *)NULL))
    return (void *)0;

  else
  {
    i = 0;
    for( ; !(i >= conn->nEvents); i = i + 1)
      if((conn->events + (signed long int)i)->proc == proc)
        return (conn->events + (signed long int)i)->data;

    return (void *)0;
  }
}

// PQisBusy
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 404
extern signed int PQisBusy(struct pg_conn *conn)
{
  if(conn == ((struct pg_conn *)NULL))
    return 0;

  else
  {
    parseInput(conn);
    return (signed int)((signed int)conn->asyncStatus == PGASYNC_BUSY);
  }
}

// PQisnonblocking
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3108
extern signed int PQisnonblocking(const struct pg_conn *conn)
{
  return (signed int)conn->nonblocking;
}

// PQisthreadsafe
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3115
extern signed int PQisthreadsafe(void)
{
  return (signed int)(char)1;
}

// PQlibVersion
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 72
extern signed int PQlibVersion(void)
{
  return 90405;
}

// PQmakeEmptyPGresult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 140
extern struct pg_result * PQmakeEmptyPGresult(struct pg_conn *conn, enum anonymous_20 status)
{
  struct pg_result *result;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct pg_result) /*200ul*/ );
  result = (struct pg_result *)return_value_malloc_1;
  if(result == ((struct pg_result *)NULL))
    return (struct pg_result *)(void *)0;

  else
  {
    result->ntups = 0;
    result->numAttributes = 0;
    result->attDescs = (struct pgresAttDesc *)(void *)0;
    result->tuples = (struct pgresAttValue **)(void *)0;
    result->tupArrSize = 0;
    result->numParameters = 0;
    result->paramDescs = (struct pgresParamDesc *)(void *)0;
    result->resultStatus = status;
    result->cmdStatus[(signed long int)0] = (char)0;
    result->binary = 0;
    result->events = (struct PGEvent *)(void *)0;
    result->nEvents = 0;
    result->errMsg = (char *)(void *)0;
    result->errFields = (struct pgMessageField *)(void *)0;
    result->null_field[(signed long int)0] = (char)0;
    result->curBlock = (union pgresult_data *)(void *)0;
    result->curOffset = 0;
    result->spaceLeft = 0;
    if(!(conn == ((struct pg_conn *)NULL)))
    {
      result->noticeHooks = conn->noticeHooks;
      result->client_encoding = conn->client_encoding;
      if((signed int)status == PGRES_EMPTY_QUERY || (signed int)status == PGRES_COMMAND_OK || (signed int)status == PGRES_TUPLES_OK || (signed int)status == PGRES_COPY_OUT || (signed int)status == PGRES_COPY_IN || (signed int)status == PGRES_COPY_BOTH || (signed int)status == PGRES_SINGLE_TUPLE)
        goto __CPROVER_DUMP_L4;

      pqSetResultError(result, conn->errorMessage.data);

    __CPROVER_DUMP_L4:
      ;
      if(conn->nEvents >= 1)
      {
        result->events=dupEvents(conn->events, conn->nEvents);
        if(result->events == ((struct PGEvent *)NULL))
        {
          PQclear(result);
          return (struct pg_result *)(void *)0;
        }

        result->nEvents = conn->nEvents;
      }

    }

    else
    {
      result->noticeHooks.noticeRec = (void (*)(void *, const struct pg_result *))(void *)0;
      result->noticeHooks.noticeRecArg = (void *)0;
      result->noticeHooks.noticeProc = (void (*)(void *, const char *))(void *)0;
      result->noticeHooks.noticeProcArg = (void *)0;
      result->client_encoding = PG_SQL_ASCII;
    }
    return result;
  }
}

// PQmblen
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 1185
extern signed int PQmblen(const char *s, signed int encoding)
{
  signed int return_value_pg_encoding_mblen_1;
  return_value_pg_encoding_mblen_1=pg_encoding_mblen(encoding, s);
  return return_value_pg_encoding_mblen_1;
}

// PQnfields
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2621
extern signed int PQnfields(const struct pg_result *res)
{
  if(res == ((const struct pg_result *)NULL))
    return 0;

  else
    return res->numAttributes;
}

// PQnotifies
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2171
extern struct pgNotify * PQnotifies(struct pg_conn *conn)
{
  struct pgNotify *event;
  if(conn == ((struct pg_conn *)NULL))
    return (struct pgNotify *)(void *)0;

  else
  {
    parseInput(conn);
    event = conn->notifyHead;
    if(!(event == ((struct pgNotify *)NULL)))
    {
      conn->notifyHead = event->next;
      if(conn->notifyHead == ((struct pgNotify *)NULL))
        conn->notifyTail = (struct pgNotify *)(void *)0;

      event->next = (struct pgNotify *)(void *)0;
    }

    return event;
  }
}

// PQnparams
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3046
extern signed int PQnparams(const struct pg_result *res)
{
  if(res == ((const struct pg_result *)NULL))
    return 0;

  else
    return res->numParameters;
}

// PQntuples
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2613
extern signed int PQntuples(const struct pg_result *res)
{
  if(res == ((const struct pg_result *)NULL))
    return 0;

  else
    return res->ntups;
}

// PQoidStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2897
extern char * PQoidStatus(const struct pg_result *res)
{
  unsigned long int len;
  _Bool tmp_if_expr_2;
  signed int return_value_strncmp_1;
  if(res == ((const struct pg_result *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strncmp_1=strncmp(res->cmdStatus, "INSERT ", (unsigned long int)7);
    tmp_if_expr_2 = return_value_strncmp_1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return "";

  else
  {
    len=strspn(res->cmdStatus + (signed long int)7, "0123456789");
    if(len >= 24ul)
      len = (unsigned long int)23;

    static char buf[24l];
    strncpy(buf, res->cmdStatus + (signed long int)7, len);
    buf[(signed long int)len] = (char)0;
    return buf;
  }
}

// PQoidValue
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2925
extern unsigned int PQoidValue(const struct pg_result *res)
{
  char *endptr = (char *)(void *)0;
  unsigned long int result;
  _Bool tmp_if_expr_2;
  signed int return_value_strncmp_1;
  if(res == ((const struct pg_result *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strncmp_1=strncmp(res->cmdStatus, "INSERT ", (unsigned long int)7);
    tmp_if_expr_2 = return_value_strncmp_1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)res->cmdStatus[(signed long int)7] < 48 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = (signed int)res->cmdStatus[(signed long int)7] > 57 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_4)
    return (unsigned int)0;

  else
  {
    result=strtoul(res->cmdStatus + (signed long int)7, &endptr, 10);
    if(endptr == ((char *)NULL))
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      if(!((signed int)*endptr == 32))
        tmp_if_expr_5 = (signed int)*endptr != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      return (unsigned int)0;

    else
      return (unsigned int)result;
  }
}

// PQoptions
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5374
extern char * PQoptions(const struct pg_conn *conn)
{
  if(conn == ((const struct pg_conn *)NULL))
    return (char *)(void *)0;

  else
    return conn->pgoptions;
}

// PQparameterStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5400
extern const char * PQparameterStatus(const struct pg_conn *conn, const char *paramName)
{
  const struct pgParameterStatus *pstatus;
  if(paramName == ((const char *)NULL) || conn == ((const struct pg_conn *)NULL))
    return (const char *)(void *)0;

  else
  {
    pstatus = conn->pstatus;
    for( ; !(pstatus == ((const struct pgParameterStatus *)NULL)); pstatus = pstatus->next)
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(pstatus->name, paramName);
      if(return_value_strcmp_1 == 0)
        return pstatus->value;

    }
    return (const char *)(void *)0;
  }
}

// PQparamtype
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3057
extern unsigned int PQparamtype(const struct pg_result *res, signed int param_num)
{
  signed int return_value_check_param_number_1;
  return_value_check_param_number_1=check_param_number(res, param_num);
  if(return_value_check_param_number_1 == 0)
    return (unsigned int)0;

  else
    if(!(res->paramDescs == ((struct pgresParamDesc *)NULL)))
      return (res->paramDescs + (signed long int)param_num)->typid;

    else
      return (unsigned int)0;
}

// PQpass
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5333
extern char * PQpass(const struct pg_conn *conn)
{
  if(conn == ((const struct pg_conn *)NULL))
    return (char *)(void *)0;

  else
    return conn->pgpass;
}

// PQping
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 527
extern enum anonymous_25 PQping(const char *conninfo)
{
  struct pg_conn *conn;
  conn=PQconnectStart(conninfo);
  enum anonymous_25 ret;
  ret=internal_ping(conn);
  PQfinish(conn);
  return ret;
}

// PQpingParams
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 474
extern enum anonymous_25 PQpingParams(const char * const *keywords, const char * const *values, signed int expand_dbname)
{
  struct pg_conn *conn;
  conn=PQconnectStartParams(keywords, values, expand_dbname);
  enum anonymous_25 ret;
  ret=internal_ping(conn);
  PQfinish(conn);
  return ret;
}

// PQport
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5358
extern char * PQport(const struct pg_conn *conn)
{
  if(conn == ((const struct pg_conn *)NULL))
    return (char *)(void *)0;

  else
    return conn->pgport;
}

// PQprepare
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 369
extern struct pg_result * PQprepare(struct pg_conn *conn, const char *stmtName, const char *query, signed int nParams, const unsigned int *paramTypes)
{
  char return_value_PQexecStart_1;
  return_value_PQexecStart_1=PQexecStart(conn);
  if(return_value_PQexecStart_1 == 0)
    return (struct pg_result *)(void *)0;

  else
  {
    signed int return_value_PQsendPrepare_2;
    return_value_PQsendPrepare_2=PQsendPrepare(conn, stmtName, query, nParams, paramTypes);
    if(return_value_PQsendPrepare_2 == 0)
      return (struct pg_result *)(void *)0;

    else
    {
      struct pg_result *return_value_PQexecFinish_3;
      return_value_PQexecFinish_3=PQexecFinish(conn);
      return return_value_PQexecFinish_3;
    }
  }
}

// PQprint
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-print.c line 68
extern void PQprint(struct _IO_FILE *fout, const struct pg_result *res, const struct _PQprintOpt *po)
{
  signed int nFields;
  nFields=PQnfields(res);
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  char *tmp_if_expr_11;
  char *return_value_PQfname_10;
  unsigned long int tmp_if_expr_13;
  unsigned long int return_value_strlen_12;
  signed int return_value_fileno_22;
  signed int return_value_isatty_23;
  signed int return_value_fileno_20;
  signed int return_value_isatty_21;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_33;
  _Bool tmp_if_expr_32;
  char *return_value_libpq_gettext_26;
  char *return_value_libpq_gettext_27;
  char *return_value_libpq_gettext_28;
  char *return_value_libpq_gettext_29;
  signed int tmp_post_31;
  char *tmp_if_expr_34;
  char *return_value_libpq_gettext_35;
  _Bool tmp_if_expr_39;
  char *tmp_if_expr_36;
  char *tmp_if_expr_37;
  char *tmp_if_expr_38;
  signed int return_value_PQntuples_40;
  signed int return_value_PQntuples_41;
  if(nFields >= 1)
  {
    signed int i;
    signed int j;
    signed int nTups;
    signed int *fieldMax = (signed int *)(void *)0;
    unsigned char *fieldNotNum = (unsigned char *)(void *)0;
    char *border = (char *)(void *)0;
    char **fields = (char **)(void *)0;
    const char **fieldNames;
    signed int fieldMaxLen = 0;
    signed int numFieldName;
    signed int fs_len;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(po->fieldSep);
    fs_len = (signed int)return_value_strlen_1;
    signed int total_line_length = 0;
    signed int usePipe = 0;
    char *pagerenv;
    struct anonymous_6 osigset;
    char sigpipe_masked = (char)0;
    char sigpipe_pending;
    struct winsize screen_size;
    nTups=PQntuples(res);
    void *return_value_calloc_3;
    return_value_calloc_3=calloc((unsigned long int)nFields, sizeof(char *) /*8ul*/ );
    fieldNames = (const char **)return_value_calloc_3;
    if(fieldNames == ((const char **)NULL))
    {
      char *return_value_libpq_gettext_2;
      return_value_libpq_gettext_2=libpq_gettext("out of memory\n");
      fprintf(stderr, return_value_libpq_gettext_2);
      abort();
    }

    void *return_value_calloc_5;
    return_value_calloc_5=calloc((unsigned long int)nFields, (unsigned long int)1);
    fieldNotNum = (unsigned char *)return_value_calloc_5;
    if(fieldNotNum == ((unsigned char *)NULL))
    {
      char *return_value_libpq_gettext_4;
      return_value_libpq_gettext_4=libpq_gettext("out of memory\n");
      fprintf(stderr, return_value_libpq_gettext_4);
      abort();
    }

    void *return_value_calloc_7;
    return_value_calloc_7=calloc((unsigned long int)nFields, sizeof(signed int) /*4ul*/ );
    fieldMax = (signed int *)return_value_calloc_7;
    if(fieldMax == ((signed int *)NULL))
    {
      char *return_value_libpq_gettext_6;
      return_value_libpq_gettext_6=libpq_gettext("out of memory\n");
      fprintf(stderr, return_value_libpq_gettext_6);
      abort();
    }

    numFieldName = 0;
    do
    {
      if(!(po->fieldName == ((char **)NULL)))
        tmp_if_expr_8 = po->fieldName[(signed long int)numFieldName] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_8 = (_Bool)0;
      if(!tmp_if_expr_8)
        break;

      numFieldName = numFieldName + 1;
    }
    while((_Bool)1);
    j = 0;
    for( ; !(j >= nFields); j = j + 1)
    {
      signed int len;
      const char *s;
      if(!(j >= numFieldName))
        tmp_if_expr_9 = po->fieldName[(signed long int)j][(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_9 = (_Bool)0;
      if(tmp_if_expr_9)
        tmp_if_expr_11 = po->fieldName[(signed long int)j];

      else
      {
        return_value_PQfname_10=PQfname(res, j);
        tmp_if_expr_11 = return_value_PQfname_10;
      }
      s = tmp_if_expr_11;
      fieldNames[(signed long int)j] = s;
      if(!(s == ((const char *)NULL)))
      {
        return_value_strlen_12=strlen(s);
        tmp_if_expr_13 = return_value_strlen_12;
      }

      else
        tmp_if_expr_13 = (unsigned long int)0;
      len = (signed int)tmp_if_expr_13;
      fieldMax[(signed long int)j] = len;
      len = len + fs_len;
      if(!(fieldMaxLen >= len))
        fieldMaxLen = len;

      total_line_length = total_line_length + len;
    }
    unsigned long int return_value_strlen_14;
    return_value_strlen_14=strlen(po->fieldSep);
    total_line_length = total_line_length + (signed int)((unsigned long int)nFields * return_value_strlen_14 + (unsigned long int)1);
    if(fout == ((struct _IO_FILE *)NULL))
      fout = stdout;

    if(!(po->pager == 0))
    {
      if(fout == stdout)
      {
        return_value_fileno_22=fileno(stdin);
        return_value_isatty_23=isatty(return_value_fileno_22);
        if(!(return_value_isatty_23 == 0))
        {
          return_value_fileno_20=fileno(stdout);
          return_value_isatty_21=isatty(return_value_fileno_20);
          if(!(return_value_isatty_21 == 0))
          {
            signed int return_value_fileno_15;
            return_value_fileno_15=fileno(stdout);
            signed int return_value_ioctl_16;
            return_value_ioctl_16=ioctl(return_value_fileno_15, (unsigned long int)0x5413, &screen_size);
            if(return_value_ioctl_16 == -1 || (signed int)screen_size.ws_col == 0 || (signed int)screen_size.ws_row == 0)
            {
              screen_size.ws_row = (unsigned short int)24;
              screen_size.ws_col = (unsigned short int)80;
            }

            pagerenv=getenv("PAGER");
            if(!(pagerenv == ((char *)NULL)))
            {
              if(!((signed int)*pagerenv == 0))
              {
                if(po->html3 == 0)
                {
                  if((1 + nFields) * nTups >= (signed int)screen_size.ws_row && !(po->expanded == 0))
                    tmp_if_expr_19 = (_Bool)1;

                  else
                  {
                    if(po->expanded == 0)
                      tmp_if_expr_18 = nTups * (total_line_length / (signed int)screen_size.ws_col + 1) * (1 + (signed int)((signed int)po->standard != 0)) >= ((signed int)screen_size.ws_row - (signed int)((signed int)po->header != 0) * (total_line_length / (signed int)screen_size.ws_col + 1) * 2) - (signed int)((signed int)po->header != 0) * 2 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_18 = (_Bool)0;
                    tmp_if_expr_19 = tmp_if_expr_18 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_19)
                  {
                    fout=popen(pagerenv, "w");
                    if(!(fout == ((struct _IO_FILE *)NULL)))
                    {
                      usePipe = 1;
                      signed int return_value_pq_block_sigpipe_17;
                      return_value_pq_block_sigpipe_17=pq_block_sigpipe(&osigset, &sigpipe_pending);
                      if(return_value_pq_block_sigpipe_17 == 0)
                        sigpipe_masked = (char)1;

                    }

                    else
                      fout = stdout;
                  }

                }

              }

            }

          }

        }

      }

    }

    if(po->expanded == 0)
    {
      if(!(po->align == 0))
        tmp_if_expr_32 = (_Bool)1;

      else
        tmp_if_expr_32 = po->html3 != 0 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_33 = tmp_if_expr_32 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_33 = (_Bool)0;
    if(tmp_if_expr_33)
    {
      void *return_value_calloc_25;
      return_value_calloc_25=calloc((unsigned long int)(nFields * (nTups + 1)), sizeof(char *) /*8ul*/ );
      fields = (char **)return_value_calloc_25;
      if(fields == ((char **)NULL))
      {
        char *return_value_libpq_gettext_24;
        return_value_libpq_gettext_24=libpq_gettext("out of memory\n");
        fprintf(stderr, return_value_libpq_gettext_24);
        abort();
      }

    }

    else
      if(!(po->header == 0))
      {
        if(po->html3 == 0)
        {
          if(!(po->expanded == 0))
          {
            if(!(po->align == 0))
            {
              return_value_libpq_gettext_26=libpq_gettext("%-*s%s Value\n");
              return_value_libpq_gettext_27=libpq_gettext("Field");
              fprintf(fout, return_value_libpq_gettext_26, fieldMaxLen - fs_len, return_value_libpq_gettext_27, po->fieldSep);
            }

            else
            {
              return_value_libpq_gettext_28=libpq_gettext("%s%sValue\n");
              return_value_libpq_gettext_29=libpq_gettext("Field");
              fprintf(fout, return_value_libpq_gettext_28, return_value_libpq_gettext_29, po->fieldSep);
            }
          }

          else
          {
            signed int PQprint__1__1__8__2__len = 0;
            j = 0;
            for( ; !(j >= nFields); j = j + 1)
            {
              const char *PQprint__1__1__8__2__1__1__s = fieldNames[(signed long int)j];
              fputs(PQprint__1__1__8__2__1__1__s, fout);
              unsigned long int return_value_strlen_30;
              return_value_strlen_30=strlen(PQprint__1__1__8__2__1__1__s);
              PQprint__1__1__8__2__len = PQprint__1__1__8__2__len + (signed int)(return_value_strlen_30 + (unsigned long int)fs_len);
              if(!(1 + j >= nFields))
                fputs(po->fieldSep, fout);

            }
            fputc(10, fout);
            PQprint__1__1__8__2__len = PQprint__1__1__8__2__len - fs_len;
            do
            {
              tmp_post_31 = PQprint__1__1__8__2__len;
              PQprint__1__1__8__2__len = PQprint__1__1__8__2__len - 1;
              if(tmp_post_31 == 0)
                break;

              fputc(45, fout);
            }
            while((_Bool)1);
            fputc(10, fout);
          }
        }

      }

    if(!(po->expanded == 0))
    {
      if(!(po->html3 == 0))
      {
        if(!(po->caption == ((char *)NULL)))
          fprintf(fout, "<center><h2>%s</h2></center>\n", po->caption);

        else
          fprintf(fout, "<center><h2>Query retrieved %d rows * %d fields</h2></center>\n", nTups, nFields);
      }

    }

    i = 0;
    for( ; !(i >= nTups); i = i + 1)
    {
      if(!(po->expanded == 0))
      {
        if(!(po->html3 == 0))
        {
          if(!(po->tableOpt == ((char *)NULL)))
            tmp_if_expr_34 = po->tableOpt;

          else
            tmp_if_expr_34 = "";
          fprintf(fout, "<table %s><caption align=\"top\">%d</caption>\n", tmp_if_expr_34, i);
        }

        else
        {
          return_value_libpq_gettext_35=libpq_gettext("-- RECORD %d --\n");
          fprintf(fout, return_value_libpq_gettext_35, i);
        }
      }

      j = 0;
      for( ; !(j >= nFields); j = j + 1)
        do_field(po, res, i, j, fs_len, fields, nFields, fieldNames, fieldNotNum, fieldMax, fieldMaxLen, fout);
      if(!(po->html3 == 0))
      {
        if(!(po->expanded == 0))
          fputs("</table>\n", fout);

      }

    }
    if(po->expanded == 0)
    {
      if(!(po->align == 0))
        tmp_if_expr_39 = (_Bool)1;

      else
        tmp_if_expr_39 = po->html3 != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_39)
      {
        if(!(po->html3 == 0))
        {
          if(!(po->header == 0))
          {
            if(!(po->caption == ((char *)NULL)))
            {
              if(!(po->tableOpt == ((char *)NULL)))
                tmp_if_expr_36 = po->tableOpt;

              else
                tmp_if_expr_36 = "";
              fprintf(fout, "<table %s><caption align=\"top\">%s</caption>\n", tmp_if_expr_36, po->caption);
            }

            else
            {
              if(!(po->tableOpt == ((char *)NULL)))
                tmp_if_expr_37 = po->tableOpt;

              else
                tmp_if_expr_37 = "";
              fprintf(fout, "<table %s><caption align=\"top\">Retrieved %d rows * %d fields</caption>\n", tmp_if_expr_37, nTups, nFields);
            }
          }

          else
          {
            if(!(po->tableOpt == ((char *)NULL)))
              tmp_if_expr_38 = po->tableOpt;

            else
              tmp_if_expr_38 = "";
            fprintf(fout, "<table %s>", tmp_if_expr_38);
          }
        }

        if(!(po->header == 0))
          border=do_header(fout, po, nFields, fieldMax, fieldNames, fieldNotNum, fs_len, res);

        i = 0;
        for( ; !(i >= nTups); i = i + 1)
          output_row(fout, po, nFields, fields, fieldNotNum, fieldMax, border, i);
        free((void *)fields);
        if(!(border == ((char *)NULL)))
          free((void *)border);

      }

    }

    if(!(po->header == 0))
    {
      if(po->html3 == 0)
      {
        return_value_PQntuples_40=PQntuples(res);
        return_value_PQntuples_41=PQntuples(res);
        fprintf(fout, "(%d row%s)\n\n", return_value_PQntuples_40, return_value_PQntuples_41 == 1 ? "" : "s");
      }

    }

    free((void *)fieldMax);
    free((void *)fieldNotNum);
    free((void *)fieldNames);
    if(!(usePipe == 0))
    {
      pclose(fout);
      if(!(sigpipe_masked == 0))
        pq_reset_sigpipe(&osigset, sigpipe_pending, (char)1);

    }

    if(!(po->html3 == 0))
    {
      if(po->expanded == 0)
        fputs("</table>\n", fout);

    }

  }

}

// PQprintTuples
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-print.c line 668
extern void PQprintTuples(const struct pg_result *res, struct _IO_FILE *fout, signed int PrintAttNames, signed int TerseOutput, signed int colWidth)
{
  signed int nFields;
  signed int nTups;
  signed int i;
  signed int j;
  char formatString[80l];
  char *tborder = (char *)(void *)0;
  nFields=PQnfields(res);
  nTups=PQntuples(res);
  if(colWidth >= 1)
    sprintf(formatString, "%%s %%-%ds", colWidth);

  else
    sprintf(formatString, "%%s %%s");
  if(nFields >= 1)
  {
    if(TerseOutput == 0)
    {
      signed int width = nFields * 14;
      void *return_value_malloc_1;
      return_value_malloc_1=malloc((unsigned long int)(width + 1));
      tborder = (char *)return_value_malloc_1;
      if(tborder == ((char *)NULL))
      {
        char *return_value_libpq_gettext_2;
        return_value_libpq_gettext_2=libpq_gettext("out of memory\n");
        fprintf(stderr, return_value_libpq_gettext_2);
        abort();
      }

      i = 0;
      for( ; !(i >= width); i = i + 1)
        tborder[(signed long int)i] = (char)45;
      tborder[(signed long int)width] = (char)0;
      fprintf(fout, "%s\n", tborder);
    }

    i = 0;
    for( ; !(i >= nFields); i = i + 1)
      if(!(PrintAttNames == 0))
      {
        char *return_value_PQfname_3;
        return_value_PQfname_3=PQfname(res, i);
        fprintf(fout, formatString, TerseOutput != 0 ? "" : "|", return_value_PQfname_3);
      }

    if(!(PrintAttNames == 0))
    {
      if(!(TerseOutput == 0))
        fprintf(fout, "\n");

      else
        fprintf(fout, "|\n%s\n", tborder);
    }

    i = 0;
    for( ; !(i >= nTups); i = i + 1)
    {
      j = 0;
      for( ; !(j >= nFields); j = j + 1)
      {
        const char *pval;
        pval=PQgetvalue(res, i, j);
        fprintf(fout, formatString, TerseOutput != 0 ? "" : "|", pval != ((const char *)NULL) ? pval : "");
      }
      if(!(TerseOutput == 0))
        fprintf(fout, "\n");

      else
        fprintf(fout, "|\n%s\n", tborder);
    }
  }

  if(!(tborder == ((char *)NULL)))
    free((void *)tborder);

}

// PQprotocolVersion
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5415
extern signed int PQprotocolVersion(const struct pg_conn *conn)
{
  if(conn == ((const struct pg_conn *)NULL))
    return 0;

  else
    if((signed int)conn->status == CONNECTION_BAD)
      return 0;

    else
      return (signed int)(conn->pversion >> 16);
}

// PQputCopyData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2199
extern signed int PQputCopyData(struct pg_conn *conn, const char *buffer, signed int nbytes)
{
  _Bool tmp_if_expr_6;
  signed int return_value_pqPutnchar_5;
  _Bool tmp_if_expr_8;
  signed int return_value_pqPutMsgEnd_7;
  _Bool tmp_if_expr_11;
  signed int return_value_pqPutnchar_10;
  _Bool tmp_if_expr_13;
  signed int return_value_pqPutMsgEnd_12;
  if(conn == ((struct pg_conn *)NULL))
    return -1;

  else
  {
    if(!((signed int)conn->asyncStatus == PGASYNC_COPY_IN))
    {
      if(!((signed int)conn->asyncStatus == PGASYNC_COPY_BOTH))
      {
        char *return_value_libpq_gettext_1;
        return_value_libpq_gettext_1=libpq_gettext("no COPY in progress\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
        return -1;
      }

    }

    parseInput(conn);
    if(nbytes >= 1)
    {
      if(!(conn->outBufSize + -conn->outCount + -5 >= nbytes))
      {
        signed int return_value_pqFlush_2;
        return_value_pqFlush_2=pqFlush(conn);
        if(!(return_value_pqFlush_2 >= 0))
          return -1;

        signed int return_value_pqCheckOutBufferSpace_3;
        return_value_pqCheckOutBufferSpace_3=pqCheckOutBufferSpace((unsigned long int)(conn->outCount + 5) + (unsigned long int)nbytes, conn);
        if(!(return_value_pqCheckOutBufferSpace_3 == 0))
          return conn->nonblocking != 0 ? 0 : -1;

      }

      if(conn->pversion >> 16 >= 3u)
      {
        signed int return_value_pqPutMsgStart_4;
        return_value_pqPutMsgStart_4=pqPutMsgStart((char)100, (char)0, conn);
        if(!(return_value_pqPutMsgStart_4 >= 0))
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value_pqPutnchar_5=pqPutnchar(buffer, (unsigned long int)nbytes, conn);
          tmp_if_expr_6 = return_value_pqPutnchar_5 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_pqPutMsgEnd_7=pqPutMsgEnd(conn);
          tmp_if_expr_8 = return_value_pqPutMsgEnd_7 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
          return -1;

      }

      else
      {
        signed int return_value_pqPutMsgStart_9;
        return_value_pqPutMsgStart_9=pqPutMsgStart((char)0, (char)0, conn);
        if(!(return_value_pqPutMsgStart_9 >= 0))
          tmp_if_expr_11 = (_Bool)1;

        else
        {
          return_value_pqPutnchar_10=pqPutnchar(buffer, (unsigned long int)nbytes, conn);
          tmp_if_expr_11 = return_value_pqPutnchar_10 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_11)
          tmp_if_expr_13 = (_Bool)1;

        else
        {
          return_value_pqPutMsgEnd_12=pqPutMsgEnd(conn);
          tmp_if_expr_13 = return_value_pqPutMsgEnd_12 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_13)
          return -1;

      }
    }

    return 1;
  }
}

// PQputCopyEnd
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2266
extern signed int PQputCopyEnd(struct pg_conn *conn, const char *errormsg)
{
  _Bool tmp_if_expr_4;
  signed int return_value_pqPuts_3;
  _Bool tmp_if_expr_6;
  signed int return_value_pqPutMsgEnd_5;
  _Bool tmp_if_expr_9;
  signed int return_value_pqPutMsgEnd_8;
  _Bool tmp_if_expr_12;
  signed int return_value_pqPutMsgEnd_11;
  _Bool tmp_if_expr_16;
  signed int return_value_pqPutnchar_15;
  _Bool tmp_if_expr_18;
  signed int return_value_pqPutMsgEnd_17;
  if(conn == ((struct pg_conn *)NULL))
    return -1;

  else
  {
    if(!((signed int)conn->asyncStatus == PGASYNC_COPY_IN))
    {
      if(!((signed int)conn->asyncStatus == PGASYNC_COPY_BOTH))
      {
        char *return_value_libpq_gettext_1;
        return_value_libpq_gettext_1=libpq_gettext("no COPY in progress\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
        return -1;
      }

    }

    if(conn->pversion >> 16 >= 3u)
    {
      if(!(errormsg == ((const char *)NULL)))
      {
        signed int return_value_pqPutMsgStart_2;
        return_value_pqPutMsgStart_2=pqPutMsgStart((char)102, (char)0, conn);
        if(!(return_value_pqPutMsgStart_2 >= 0))
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_pqPuts_3=pqPuts(errormsg, conn);
          tmp_if_expr_4 = return_value_pqPuts_3 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value_pqPutMsgEnd_5=pqPutMsgEnd(conn);
          tmp_if_expr_6 = return_value_pqPutMsgEnd_5 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
          return -1;

      }

      else
      {
        signed int return_value_pqPutMsgStart_7;
        return_value_pqPutMsgStart_7=pqPutMsgStart((char)99, (char)0, conn);
        if(!(return_value_pqPutMsgStart_7 >= 0))
          tmp_if_expr_9 = (_Bool)1;

        else
        {
          return_value_pqPutMsgEnd_8=pqPutMsgEnd(conn);
          tmp_if_expr_9 = return_value_pqPutMsgEnd_8 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_9)
          return -1;

      }
      if(!((signed int)conn->queryclass == PGQUERY_SIMPLE))
      {
        signed int return_value_pqPutMsgStart_10;
        return_value_pqPutMsgStart_10=pqPutMsgStart((char)83, (char)0, conn);
        if(!(return_value_pqPutMsgStart_10 >= 0))
          tmp_if_expr_12 = (_Bool)1;

        else
        {
          return_value_pqPutMsgEnd_11=pqPutMsgEnd(conn);
          tmp_if_expr_12 = return_value_pqPutMsgEnd_11 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_12)
          return -1;

      }

    }

    else
      if(!(errormsg == ((const char *)NULL)))
      {
        char *return_value_libpq_gettext_13;
        return_value_libpq_gettext_13=libpq_gettext("function requires at least protocol version 3.0\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_13);
        return -1;
      }

      else
      {
        signed int return_value_pqPutMsgStart_14;
        return_value_pqPutMsgStart_14=pqPutMsgStart((char)0, (char)0, conn);
        if(!(return_value_pqPutMsgStart_14 >= 0))
          tmp_if_expr_16 = (_Bool)1;

        else
        {
          return_value_pqPutnchar_15=pqPutnchar("\\.\n", (unsigned long int)3, conn);
          tmp_if_expr_16 = return_value_pqPutnchar_15 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_16)
          tmp_if_expr_18 = (_Bool)1;

        else
        {
          return_value_pqPutMsgEnd_17=pqPutMsgEnd(conn);
          tmp_if_expr_18 = return_value_pqPutMsgEnd_17 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_18)
          return -1;

      }
    if((signed int)conn->asyncStatus == PGASYNC_COPY_BOTH)
      conn->asyncStatus = (enum anonymous_9)PGASYNC_COPY_OUT;

    else
      conn->asyncStatus = (enum anonymous_9)PGASYNC_BUSY;
    resetPQExpBuffer(&conn->errorMessage);
    signed int return_value_pqFlush_19;
    return_value_pqFlush_19=pqFlush(conn);
    if(!(return_value_pqFlush_19 >= 0))
      return -1;

    else
      return 1;
  }
}

// PQputline
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 417
extern signed int PQputline(struct pg_conn *conn, const char *s)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  signed int return_value_PQputnbytes_2;
  return_value_PQputnbytes_2=PQputnbytes(conn, s, (signed int)return_value_strlen_1);
  return return_value_PQputnbytes_2;
}

// PQputnbytes
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2477
extern signed int PQputnbytes(struct pg_conn *conn, const char *buffer, signed int nbytes)
{
  signed int return_value_PQputCopyData_1;
  return_value_PQputCopyData_1=PQputCopyData(conn, buffer, nbytes);
  if(return_value_PQputCopyData_1 >= 1)
    return 0;

  else
    return -1;
}

// PQregisterEventProc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.c line 40
extern signed int PQregisterEventProc(struct pg_conn *conn, signed int (*proc)(enum anonymous_13, void *, void *), const char *name, void *passThrough)
{
  signed int i;
  struct anonymous_14 regevt;
  _Bool tmp_if_expr_1;
  if(proc == ((signed int (*)(enum anonymous_13, void *, void *))NULL) || name == ((const char *)NULL) || conn == ((struct pg_conn *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*name != 0) ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr_2;
  void *return_value_realloc_3;
  void *return_value_malloc_4;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= conn->nEvents); i = i + 1)
      if((conn->events + (signed long int)i)->proc == proc)
        return 0;

    if(conn->nEvents >= conn->eventArraySize)
    {
      struct PGEvent *e;
      signed int newSize;
      if(!(conn->eventArraySize == 0))
        tmp_if_expr_2 = conn->eventArraySize * 2;

      else
        tmp_if_expr_2 = 8;
      newSize = tmp_if_expr_2;
      if(!(conn->events == ((struct PGEvent *)NULL)))
      {
        return_value_realloc_3=realloc((void *)conn->events, (unsigned long int)newSize * sizeof(struct PGEvent) /*40ul*/ );
        e = (struct PGEvent *)return_value_realloc_3;
      }

      else
      {
        return_value_malloc_4=malloc((unsigned long int)newSize * sizeof(struct PGEvent) /*40ul*/ );
        e = (struct PGEvent *)return_value_malloc_4;
      }
      if(e == ((struct PGEvent *)NULL))
        return 0;

      conn->eventArraySize = newSize;
      conn->events = e;
    }

    (conn->events + (signed long int)conn->nEvents)->proc = proc;
    (conn->events + (signed long int)conn->nEvents)->name=strdup(name);
    if((conn->events + (signed long int)conn->nEvents)->name == ((char *)NULL))
      return 0;

    else
    {
      (conn->events + (signed long int)conn->nEvents)->passThrough = passThrough;
      (conn->events + (signed long int)conn->nEvents)->data = (void *)0;
      (conn->events + (signed long int)conn->nEvents)->resultInitialized = (char)0;
      conn->nEvents = conn->nEvents + 1;
      regevt.conn = conn;
      signed int return_value;
      return_value=proc((enum anonymous_13)PGEVT_REGISTER, (void *)&regevt, passThrough);
      if(return_value == 0)
      {
        conn->nEvents = conn->nEvents - 1;
        free((void *)(conn->events + (signed long int)conn->nEvents)->name);
        return 0;
      }

      else
        return 1;
    }
  }
}

// PQregisterThreadLock
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5920
extern void (*PQregisterThreadLock(void (*newhandler)(signed int)))(signed int)
{
  void (*prev)(signed int) = pg_g_threadlock;
  if(!(newhandler == ((void (*)(signed int))NULL)))
    pg_g_threadlock = newhandler;

  else
    pg_g_threadlock = default_threadlock;
  return prev;
}

// PQrequestCancel
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3345
extern signed int PQrequestCancel(struct pg_conn *conn)
{
  signed int r;
  if(conn == ((struct pg_conn *)NULL))
    return 0;

  else
    if(conn->sock == -1)
    {
      strlcpy(conn->errorMessage.data, "PQrequestCancel() -- connection is not open\n", conn->errorMessage.maxlen);
      conn->errorMessage.len=strlen(conn->errorMessage.data);
      return 0;
    }

    else
    {
      r=internal_cancel(&conn->raddr, conn->be_pid, conn->be_key, conn->errorMessage.data, (signed int)conn->errorMessage.maxlen);
      if(r == 0)
        conn->errorMessage.len=strlen(conn->errorMessage.data);

      return r;
    }
}

// PQresStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2582
extern char * PQresStatus(enum anonymous_20 status)
{
  char *return_value_libpq_gettext_1;
  if((unsigned long int)(unsigned int)status >= 10ul)
  {
    return_value_libpq_gettext_1=libpq_gettext("invalid ExecStatusType code");
    return return_value_libpq_gettext_1;
  }

  else
    return pgresStatus[(signed long int)status];
}

// PQreset
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3058
extern void PQreset(struct pg_conn *conn)
{
  signed int return_value_connectDBComplete_2;
  if(!(conn == ((struct pg_conn *)NULL)))
  {
    closePGconn(conn);
    signed int return_value_connectDBStart_3;
    return_value_connectDBStart_3=connectDBStart(conn);
    if(!(return_value_connectDBStart_3 == 0))
    {
      return_value_connectDBComplete_2=connectDBComplete(conn);
      if(!(return_value_connectDBComplete_2 == 0))
      {
        signed int i = 0;
        if(!(i >= conn->nEvents))
        {
          struct anonymous_14 evt;
          evt.conn = conn;
          signed int return_value;
          return_value=(conn->events + (signed long int)i)->proc((enum anonymous_13)PGEVT_CONNRESET, (void *)&evt, (conn->events + (signed long int)i)->passThrough);
          if(return_value == 0)
          {
            conn->status = (enum anonymous_24)CONNECTION_BAD;
            char *return_value_libpq_gettext_1;
            return_value_libpq_gettext_1=libpq_gettext("PGEventProc \"%s\" failed during PGEVT_CONNRESET event\n");
            printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1, (conn->events + (signed long int)i)->name);
          }

          i = i + 1;
        }

      }

    }

  }

}

// PQresetPoll
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3118
extern enum anonymous_4 PQresetPoll(struct pg_conn *conn)
{
  if(!(conn == ((struct pg_conn *)NULL)))
  {
    enum anonymous_4 status;
    status=PQconnectPoll(conn);
    if((signed int)status == PGRES_POLLING_OK)
    {
      signed int i = 0;
      if(!(i >= conn->nEvents))
      {
        struct anonymous_14 evt;
        evt.conn = conn;
        signed int return_value;
        return_value=(conn->events + (signed long int)i)->proc((enum anonymous_13)PGEVT_CONNRESET, (void *)&evt, (conn->events + (signed long int)i)->passThrough);
        if(return_value == 0)
        {
          conn->status = (enum anonymous_24)CONNECTION_BAD;
          char *return_value_libpq_gettext_1;
          return_value_libpq_gettext_1=libpq_gettext("PGEventProc \"%s\" failed during PGEVT_CONNRESET event\n");
          printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1, (conn->events + (signed long int)i)->name);
          return (enum anonymous_4)PGRES_POLLING_FAILED;
        }

        i = i + 1;
      }

    }

    return status;
  }

  return (enum anonymous_4)PGRES_POLLING_FAILED;
}

// PQresetStart
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3099
extern signed int PQresetStart(struct pg_conn *conn)
{
  if(!(conn == ((struct pg_conn *)NULL)))
  {
    closePGconn(conn);
    signed int return_value_connectDBStart_1;
    return_value_connectDBStart_1=connectDBStart(conn);
    return return_value_connectDBStart_1;
  }

  return 0;
}

// PQresultAlloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 489
extern void * PQresultAlloc(struct pg_result *res, unsigned long int nBytes)
{
  void *return_value_pqResultAlloc_1;
  return_value_pqResultAlloc_1=pqResultAlloc(res, nBytes, (char)1);
  return return_value_pqResultAlloc_1;
}

// PQresultErrorField
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 449
extern char * PQresultErrorField(const struct pg_result *res, signed int fieldcode)
{
  struct pgMessageField *pfield;
  if(res == ((const struct pg_result *)NULL))
    return (char *)(void *)0;

  else
  {
    pfield = res->errFields;
    for( ; !(pfield == ((struct pgMessageField *)NULL)); pfield = pfield->next)
      if((signed int)pfield->code == fieldcode)
        return pfield->contents;

    return (char *)(void *)0;
  }
}

// PQresultErrorMessage
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 448
extern char * PQresultErrorMessage(const struct pg_result *res)
{
  _Bool tmp_if_expr_1;
  if(res == ((const struct pg_result *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(res->errMsg != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return "";

  else
    return res->errMsg;
}

// PQresultInstanceData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.c line 165
extern void * PQresultInstanceData(const struct pg_result *result, signed int (*proc)(enum anonymous_13, void *, void *))
{
  signed int i;
  if(proc == ((signed int (*)(enum anonymous_13, void *, void *))NULL) || result == ((const struct pg_result *)NULL))
    return (void *)0;

  else
  {
    i = 0;
    for( ; !(i >= result->nEvents); i = i + 1)
      if((result->events + (signed long int)i)->proc == proc)
        return (result->events + (signed long int)i)->data;

    return (void *)0;
  }
}

// PQresultSetInstanceData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.c line 142
extern signed int PQresultSetInstanceData(struct pg_result *result, signed int (*proc)(enum anonymous_13, void *, void *), void *data)
{
  signed int i;
  if(proc == ((signed int (*)(enum anonymous_13, void *, void *))NULL) || result == ((struct pg_result *)NULL))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= result->nEvents); i = i + 1)
      if((result->events + (signed long int)i)->proc == proc)
      {
        (result->events + (signed long int)i)->data = data;
        return 1;
      }

    return 0;
  }
}

// PQresultStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 446
extern enum anonymous_20 PQresultStatus(const struct pg_result *res)
{
  if(res == ((const struct pg_result *)NULL))
    return (enum anonymous_20)PGRES_FATAL_ERROR;

  else
    return res->resultStatus;
}

// PQsendDescribe
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2105
static signed int PQsendDescribe(struct pg_conn *conn, char desc_type, const char *desc_target)
{
  if(desc_target == ((const char *)NULL))
    desc_target = "";

  char return_value_PQsendQueryStart_1;
  return_value_PQsendQueryStart_1=PQsendQueryStart(conn);
  _Bool tmp_if_expr_5;
  signed int return_value_pqPutc_4;
  _Bool tmp_if_expr_7;
  signed int return_value_pqPuts_6;
  _Bool tmp_if_expr_9;
  signed int return_value_pqPutMsgEnd_8;
  signed int return_value_pqPutMsgStart_10;
  _Bool tmp_if_expr_12;
  signed int return_value_pqPutMsgEnd_11;
  signed int return_value_pqFlush_13;
  if(return_value_PQsendQueryStart_1 == 0)
    return 0;

  else
  {
    if(!(conn->pversion >> 16 >= 3u))
    {
      char *return_value_libpq_gettext_2;
      return_value_libpq_gettext_2=libpq_gettext("function requires at least protocol version 3.0\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2);
      return 0;
    }

    signed int return_value_pqPutMsgStart_3;
    return_value_pqPutMsgStart_3=pqPutMsgStart((char)68, (char)0, conn);
    if(!(return_value_pqPutMsgStart_3 >= 0))
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_pqPutc_4=pqPutc(desc_type, conn);
      tmp_if_expr_5 = return_value_pqPutc_4 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_pqPuts_6=pqPuts(desc_target, conn);
      tmp_if_expr_7 = return_value_pqPuts_6 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_pqPutMsgEnd_8=pqPutMsgEnd(conn);
      tmp_if_expr_9 = return_value_pqPutMsgEnd_8 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_9)
    {
      return_value_pqPutMsgStart_10=pqPutMsgStart((char)83, (char)0, conn);
      if(!(return_value_pqPutMsgStart_10 >= 0))
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        return_value_pqPutMsgEnd_11=pqPutMsgEnd(conn);
        tmp_if_expr_12 = return_value_pqPutMsgEnd_11 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
        goto sendFailed;

      conn->queryclass = (enum anonymous_10)PGQUERY_DESCRIBE;
      if(!(conn->last_query == ((char *)NULL)))
      {
        free((void *)conn->last_query);
        conn->last_query = (char *)(void *)0;
      }

      return_value_pqFlush_13=pqFlush(conn);
      if(!(return_value_pqFlush_13 >= 0))
        goto sendFailed;

      conn->asyncStatus = (enum anonymous_9)PGASYNC_BUSY;
      return 1;
    }

    else
    {

    sendFailed:
      ;
      pqHandleSendFailure(conn);
      return 0;
    }
  }
}

// PQsendDescribePortal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2090
extern signed int PQsendDescribePortal(struct pg_conn *conn, const char *portal)
{
  signed int return_value_PQsendDescribe_1;
  return_value_PQsendDescribe_1=PQsendDescribe(conn, (char)80, portal);
  return return_value_PQsendDescribe_1;
}

// PQsendDescribePrepared
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2077
extern signed int PQsendDescribePrepared(struct pg_conn *conn, const char *stmt)
{
  signed int return_value_PQsendDescribe_1;
  return_value_PQsendDescribe_1=PQsendDescribe(conn, (char)83, stmt);
  return return_value_PQsendDescribe_1;
}

// PQsendPrepare
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1208
extern signed int PQsendPrepare(struct pg_conn *conn, const char *stmtName, const char *query, signed int nParams, const unsigned int *paramTypes)
{
  char return_value_PQsendQueryStart_1;
  return_value_PQsendQueryStart_1=PQsendQueryStart(conn);
  _Bool tmp_if_expr_8;
  signed int return_value_pqPuts_7;
  _Bool tmp_if_expr_10;
  signed int return_value_pqPuts_9;
  signed int return_value_pqPutMsgEnd_14;
  signed int return_value_pqPutMsgStart_15;
  _Bool tmp_if_expr_17;
  signed int return_value_pqPutMsgEnd_16;
  signed int return_value_pqFlush_18;
  if(return_value_PQsendQueryStart_1 == 0)
    return 0;

  else
  {
    if(stmtName == ((const char *)NULL))
    {
      char *return_value_libpq_gettext_2;
      return_value_libpq_gettext_2=libpq_gettext("statement name is a null pointer\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2);
      return 0;
    }

    if(query == ((const char *)NULL))
    {
      char *return_value_libpq_gettext_3;
      return_value_libpq_gettext_3=libpq_gettext("command string is a null pointer\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
      return 0;
    }

    if(nParams >= 65536 || !(nParams >= 0))
    {
      char *return_value_libpq_gettext_4;
      return_value_libpq_gettext_4=libpq_gettext("number of parameters must be between 0 and 65535\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_4);
      return 0;
    }

    if(!(conn->pversion >> 16 >= 3u))
    {
      char *return_value_libpq_gettext_5;
      return_value_libpq_gettext_5=libpq_gettext("function requires at least protocol version 3.0\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_5);
      return 0;
    }

    signed int return_value_pqPutMsgStart_6;
    return_value_pqPutMsgStart_6=pqPutMsgStart((char)80, (char)0, conn);
    if(!(return_value_pqPutMsgStart_6 >= 0))
      tmp_if_expr_8 = (_Bool)1;

    else
    {
      return_value_pqPuts_7=pqPuts(stmtName, conn);
      tmp_if_expr_8 = return_value_pqPuts_7 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_8)
      tmp_if_expr_10 = (_Bool)1;

    else
    {
      return_value_pqPuts_9=pqPuts(query, conn);
      tmp_if_expr_10 = return_value_pqPuts_9 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_10)
    {
      if(nParams >= 1 && !(paramTypes == ((const unsigned int *)NULL)))
      {
        signed int i;
        signed int return_value_pqPutInt_11;
        return_value_pqPutInt_11=pqPutInt(nParams, (unsigned long int)2, conn);
        if(!(return_value_pqPutInt_11 >= 0))
          goto sendFailed;

        i = 0;
        for( ; !(i >= nParams); i = i + 1)
        {
          signed int return_value_pqPutInt_12;
          return_value_pqPutInt_12=pqPutInt((signed int)paramTypes[(signed long int)i], (unsigned long int)4, conn);
          if(!(return_value_pqPutInt_12 >= 0))
            goto sendFailed;

        }
      }

      else
      {
        signed int return_value_pqPutInt_13;
        return_value_pqPutInt_13=pqPutInt(0, (unsigned long int)2, conn);
        if(!(return_value_pqPutInt_13 >= 0))
          goto sendFailed;

      }
      return_value_pqPutMsgEnd_14=pqPutMsgEnd(conn);
      if(!(return_value_pqPutMsgEnd_14 >= 0))
        goto sendFailed;

      return_value_pqPutMsgStart_15=pqPutMsgStart((char)83, (char)0, conn);
      if(!(return_value_pqPutMsgStart_15 >= 0))
        tmp_if_expr_17 = (_Bool)1;

      else
      {
        return_value_pqPutMsgEnd_16=pqPutMsgEnd(conn);
        tmp_if_expr_17 = return_value_pqPutMsgEnd_16 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_17)
        goto sendFailed;

      conn->queryclass = (enum anonymous_10)PGQUERY_PREPARE;
      if(!(conn->last_query == ((char *)NULL)))
        free((void *)conn->last_query);

      conn->last_query=strdup(query);
      return_value_pqFlush_18=pqFlush(conn);
      if(!(return_value_pqFlush_18 >= 0))
        goto sendFailed;

      conn->asyncStatus = (enum anonymous_9)PGASYNC_BUSY;
      return 1;
    }

    else
    {

    sendFailed:
      ;
      pqHandleSendFailure(conn);
      return 0;
    }
  }
}

// PQsendQuery
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 381
extern signed int PQsendQuery(struct pg_conn *conn, const char *query)
{
  char return_value_PQsendQueryStart_1;
  return_value_PQsendQueryStart_1=PQsendQueryStart(conn);
  _Bool tmp_if_expr_5;
  signed int return_value_pqPuts_4;
  _Bool tmp_if_expr_7;
  signed int return_value_pqPutMsgEnd_6;
  if(return_value_PQsendQueryStart_1 == 0)
    return 0;

  else
  {
    if(query == ((const char *)NULL))
    {
      char *return_value_libpq_gettext_2;
      return_value_libpq_gettext_2=libpq_gettext("command string is a null pointer\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2);
      return 0;
    }

    signed int return_value_pqPutMsgStart_3;
    return_value_pqPutMsgStart_3=pqPutMsgStart((char)81, (char)0, conn);
    if(!(return_value_pqPutMsgStart_3 >= 0))
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_pqPuts_4=pqPuts(query, conn);
      tmp_if_expr_5 = return_value_pqPuts_4 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_pqPutMsgEnd_6=pqPutMsgEnd(conn);
      tmp_if_expr_7 = return_value_pqPutMsgEnd_6 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
    {
      pqHandleSendFailure(conn);
      return 0;
    }

    else
    {
      conn->queryclass = (enum anonymous_10)PGQUERY_SIMPLE;
      if(!(conn->last_query == ((char *)NULL)))
        free((void *)conn->last_query);

      conn->last_query=strdup(query);
      signed int return_value_pqFlush_8;
      return_value_pqFlush_8=pqFlush(conn);
      if(!(return_value_pqFlush_8 >= 0))
      {
        pqHandleSendFailure(conn);
        return 0;
      }

      else
      {
        conn->asyncStatus = (enum anonymous_9)PGASYNC_BUSY;
        return 1;
      }
    }
  }
}

// PQsendQueryGuts
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1387
static signed int PQsendQueryGuts(struct pg_conn *conn, const char *command, const char *stmtName, signed int nParams, const unsigned int *paramTypes, const char * const *paramValues, const signed int *paramLengths, const signed int *paramFormats, signed int resultFormat)
{
  signed int i;
  if(!(conn->pversion >> 16 >= 3u))
  {
    char *return_value_libpq_gettext_1;
    return_value_libpq_gettext_1=libpq_gettext("function requires at least protocol version 3.0\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
    return 0;
  }

  _Bool tmp_if_expr_4;
  signed int return_value_pqPuts_3;
  _Bool tmp_if_expr_6;
  signed int return_value_pqPuts_5;
  if(!(command == ((const char *)NULL)))
  {
    signed int return_value_pqPutMsgStart_2;
    return_value_pqPutMsgStart_2=pqPutMsgStart((char)80, (char)0, conn);
    if(!(return_value_pqPutMsgStart_2 >= 0))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_pqPuts_3=pqPuts(stmtName, conn);
      tmp_if_expr_4 = return_value_pqPuts_3 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_pqPuts_5=pqPuts(command, conn);
      tmp_if_expr_6 = return_value_pqPuts_5 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      goto sendFailed;

    if(nParams >= 1 && !(paramTypes == ((const unsigned int *)NULL)))
    {
      signed int return_value_pqPutInt_7;
      return_value_pqPutInt_7=pqPutInt(nParams, (unsigned long int)2, conn);
      if(!(return_value_pqPutInt_7 >= 0))
        goto sendFailed;

      i = 0;
      for( ; !(i >= nParams); i = i + 1)
      {
        signed int return_value_pqPutInt_8;
        return_value_pqPutInt_8=pqPutInt((signed int)paramTypes[(signed long int)i], (unsigned long int)4, conn);
        if(!(return_value_pqPutInt_8 >= 0))
          goto sendFailed;

      }
    }

    else
    {
      signed int return_value_pqPutInt_9;
      return_value_pqPutInt_9=pqPutInt(0, (unsigned long int)2, conn);
      if(!(return_value_pqPutInt_9 >= 0))
        goto sendFailed;

    }
    signed int return_value_pqPutMsgEnd_10;
    return_value_pqPutMsgEnd_10=pqPutMsgEnd(conn);
    if(!(return_value_pqPutMsgEnd_10 >= 0))
      goto sendFailed;

  }

  signed int return_value_pqPutMsgStart_11;
  return_value_pqPutMsgStart_11=pqPutMsgStart((char)66, (char)0, conn);
  _Bool tmp_if_expr_13;
  signed int return_value_pqPuts_12;
  if(!(return_value_pqPutMsgStart_11 >= 0))
    tmp_if_expr_13 = (_Bool)1;

  else
  {
    return_value_pqPuts_12=pqPuts("", conn);
    tmp_if_expr_13 = return_value_pqPuts_12 < 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_15;
  signed int return_value_pqPuts_14;
  if(tmp_if_expr_13)
    tmp_if_expr_15 = (_Bool)1;

  else
  {
    return_value_pqPuts_14=pqPuts(stmtName, conn);
    tmp_if_expr_15 = return_value_pqPuts_14 < 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_pqPutInt_19;
  _Bool tmp_if_expr_27;
  _Bool tmp_if_expr_22;
  _Bool tmp_if_expr_25;
  signed int return_value_pqPutnchar_24;
  signed int return_value_pqPutInt_28;
  _Bool tmp_if_expr_30;
  signed int return_value_pqPutInt_29;
  signed int return_value_pqPutMsgEnd_31;
  signed int return_value_pqPutMsgStart_32;
  _Bool tmp_if_expr_34;
  signed int return_value_pqPutc_33;
  _Bool tmp_if_expr_36;
  signed int return_value_pqPuts_35;
  _Bool tmp_if_expr_38;
  signed int return_value_pqPutMsgEnd_37;
  signed int return_value_pqPutMsgStart_39;
  _Bool tmp_if_expr_41;
  signed int return_value_pqPuts_40;
  _Bool tmp_if_expr_43;
  signed int return_value_pqPutInt_42;
  _Bool tmp_if_expr_45;
  signed int return_value_pqPutMsgEnd_44;
  signed int return_value_pqPutMsgStart_46;
  _Bool tmp_if_expr_48;
  signed int return_value_pqPutMsgEnd_47;
  signed int return_value_pqFlush_49;
  if(!tmp_if_expr_15)
  {
    if(nParams >= 1 && !(paramFormats == ((const signed int *)NULL)))
    {
      signed int return_value_pqPutInt_16;
      return_value_pqPutInt_16=pqPutInt(nParams, (unsigned long int)2, conn);
      if(!(return_value_pqPutInt_16 >= 0))
        goto sendFailed;

      i = 0;
      for( ; !(i >= nParams); i = i + 1)
      {
        signed int return_value_pqPutInt_17;
        return_value_pqPutInt_17=pqPutInt(paramFormats[(signed long int)i], (unsigned long int)2, conn);
        if(!(return_value_pqPutInt_17 >= 0))
          goto sendFailed;

      }
    }

    else
    {
      signed int return_value_pqPutInt_18;
      return_value_pqPutInt_18=pqPutInt(0, (unsigned long int)2, conn);
      if(!(return_value_pqPutInt_18 >= 0))
        goto sendFailed;

    }
    return_value_pqPutInt_19=pqPutInt(nParams, (unsigned long int)2, conn);
    if(!(return_value_pqPutInt_19 >= 0))
      goto sendFailed;

    i = 0;
    for( ; !(i >= nParams); i = i + 1)
    {
      if(!(paramValues == ((const char * const *)NULL)))
        tmp_if_expr_27 = paramValues[(signed long int)i] != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_27 = (_Bool)0;
      if(tmp_if_expr_27)
      {
        signed int nbytes;
        if(!(paramFormats == ((const signed int *)NULL)))
          tmp_if_expr_22 = paramFormats[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_22 = (_Bool)0;
        if(tmp_if_expr_22)
        {
          if(!(paramLengths == ((const signed int *)NULL)))
            nbytes = paramLengths[(signed long int)i];

          else
          {
            char *return_value_libpq_gettext_20;
            return_value_libpq_gettext_20=libpq_gettext("length must be given for binary parameter\n");
            printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_20);
            goto sendFailed;
          }
        }

        else
        {
          unsigned long int return_value_strlen_21;
          return_value_strlen_21=strlen(paramValues[(signed long int)i]);
          nbytes = (signed int)return_value_strlen_21;
        }
        signed int return_value_pqPutInt_23;
        return_value_pqPutInt_23=pqPutInt(nbytes, (unsigned long int)4, conn);
        if(!(return_value_pqPutInt_23 >= 0))
          tmp_if_expr_25 = (_Bool)1;

        else
        {
          return_value_pqPutnchar_24=pqPutnchar(paramValues[(signed long int)i], (unsigned long int)nbytes, conn);
          tmp_if_expr_25 = return_value_pqPutnchar_24 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_25)
          goto sendFailed;

      }

      else
      {
        signed int return_value_pqPutInt_26;
        return_value_pqPutInt_26=pqPutInt(-1, (unsigned long int)4, conn);
        if(!(return_value_pqPutInt_26 >= 0))
          goto sendFailed;

      }
    }
    return_value_pqPutInt_28=pqPutInt(1, (unsigned long int)2, conn);
    if(!(return_value_pqPutInt_28 >= 0))
      tmp_if_expr_30 = (_Bool)1;

    else
    {
      return_value_pqPutInt_29=pqPutInt(resultFormat, (unsigned long int)2, conn);
      tmp_if_expr_30 = return_value_pqPutInt_29 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_30)
      goto sendFailed;

    return_value_pqPutMsgEnd_31=pqPutMsgEnd(conn);
    if(!(return_value_pqPutMsgEnd_31 >= 0))
      goto sendFailed;

    return_value_pqPutMsgStart_32=pqPutMsgStart((char)68, (char)0, conn);
    if(!(return_value_pqPutMsgStart_32 >= 0))
      tmp_if_expr_34 = (_Bool)1;

    else
    {
      return_value_pqPutc_33=pqPutc((char)80, conn);
      tmp_if_expr_34 = return_value_pqPutc_33 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_34)
      tmp_if_expr_36 = (_Bool)1;

    else
    {
      return_value_pqPuts_35=pqPuts("", conn);
      tmp_if_expr_36 = return_value_pqPuts_35 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_36)
      tmp_if_expr_38 = (_Bool)1;

    else
    {
      return_value_pqPutMsgEnd_37=pqPutMsgEnd(conn);
      tmp_if_expr_38 = return_value_pqPutMsgEnd_37 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_38)
      goto sendFailed;

    return_value_pqPutMsgStart_39=pqPutMsgStart((char)69, (char)0, conn);
    if(!(return_value_pqPutMsgStart_39 >= 0))
      tmp_if_expr_41 = (_Bool)1;

    else
    {
      return_value_pqPuts_40=pqPuts("", conn);
      tmp_if_expr_41 = return_value_pqPuts_40 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_41)
      tmp_if_expr_43 = (_Bool)1;

    else
    {
      return_value_pqPutInt_42=pqPutInt(0, (unsigned long int)4, conn);
      tmp_if_expr_43 = return_value_pqPutInt_42 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_43)
      tmp_if_expr_45 = (_Bool)1;

    else
    {
      return_value_pqPutMsgEnd_44=pqPutMsgEnd(conn);
      tmp_if_expr_45 = return_value_pqPutMsgEnd_44 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_45)
      goto sendFailed;

    return_value_pqPutMsgStart_46=pqPutMsgStart((char)83, (char)0, conn);
    if(!(return_value_pqPutMsgStart_46 >= 0))
      tmp_if_expr_48 = (_Bool)1;

    else
    {
      return_value_pqPutMsgEnd_47=pqPutMsgEnd(conn);
      tmp_if_expr_48 = return_value_pqPutMsgEnd_47 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_48)
      goto sendFailed;

    conn->queryclass = (enum anonymous_10)PGQUERY_EXTENDED;
    if(!(conn->last_query == ((char *)NULL)))
      free((void *)conn->last_query);

    if(!(command == ((const char *)NULL)))
      conn->last_query=strdup(command);

    else
      conn->last_query = (char *)(void *)0;
    return_value_pqFlush_49=pqFlush(conn);
    if(!(return_value_pqFlush_49 >= 0))
      goto sendFailed;

    conn->asyncStatus = (enum anonymous_9)PGASYNC_BUSY;
    return 1;
  }

  else
  {

  sendFailed:
    ;
    pqHandleSendFailure(conn);
    return 0;
  }
}

// PQsendQueryParams
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 382
extern signed int PQsendQueryParams(struct pg_conn *conn, const char *command, signed int nParams, const unsigned int *paramTypes, const char * const *paramValues, const signed int *paramLengths, const signed int *paramFormats, signed int resultFormat)
{
  char return_value_PQsendQueryStart_1;
  return_value_PQsendQueryStart_1=PQsendQueryStart(conn);
  if(return_value_PQsendQueryStart_1 == 0)
    return 0;

  else
  {
    if(command == ((const char *)NULL))
    {
      char *return_value_libpq_gettext_2;
      return_value_libpq_gettext_2=libpq_gettext("command string is a null pointer\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2);
      return 0;
    }

    if(nParams >= 65536 || !(nParams >= 0))
    {
      char *return_value_libpq_gettext_3;
      return_value_libpq_gettext_3=libpq_gettext("number of parameters must be between 0 and 65535\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
      return 0;
    }

    signed int return_value_PQsendQueryGuts_4;
    return_value_PQsendQueryGuts_4=PQsendQueryGuts(conn, command, "", nParams, paramTypes, paramValues, paramLengths, paramFormats, resultFormat);
    return return_value_PQsendQueryGuts_4;
  }
}

// PQsendQueryPrepared
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 393
extern signed int PQsendQueryPrepared(struct pg_conn *conn, const char *stmtName, signed int nParams, const char * const *paramValues, const signed int *paramLengths, const signed int *paramFormats, signed int resultFormat)
{
  char return_value_PQsendQueryStart_1;
  return_value_PQsendQueryStart_1=PQsendQueryStart(conn);
  if(return_value_PQsendQueryStart_1 == 0)
    return 0;

  else
  {
    if(stmtName == ((const char *)NULL))
    {
      char *return_value_libpq_gettext_2;
      return_value_libpq_gettext_2=libpq_gettext("statement name is a null pointer\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2);
      return 0;
    }

    if(nParams >= 65536 || !(nParams >= 0))
    {
      char *return_value_libpq_gettext_3;
      return_value_libpq_gettext_3=libpq_gettext("number of parameters must be between 0 and 65535\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
      return 0;
    }

    signed int return_value_PQsendQueryGuts_4;
    return_value_PQsendQueryGuts_4=PQsendQueryGuts(conn, (const char *)(void *)0, stmtName, nParams, (const unsigned int *)(void *)0, paramValues, paramLengths, paramFormats, resultFormat);
    return return_value_PQsendQueryGuts_4;
  }
}

// PQsendQueryStart
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1345
static char PQsendQueryStart(struct pg_conn *conn)
{
  if(conn == ((struct pg_conn *)NULL))
    return (char)0;

  else
  {
    resetPQExpBuffer(&conn->errorMessage);
    if(!((signed int)conn->status == CONNECTION_OK))
    {
      char *return_value_libpq_gettext_1;
      return_value_libpq_gettext_1=libpq_gettext("no connection to the server\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
      return (char)0;
    }

    if(!((signed int)conn->asyncStatus == PGASYNC_IDLE))
    {
      char *return_value_libpq_gettext_2;
      return_value_libpq_gettext_2=libpq_gettext("another command is already in progress\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2);
      return (char)0;
    }

    conn->result = (struct pg_result *)(void *)0;
    conn->next_result = (struct pg_result *)(void *)0;
    conn->singleRowMode = (char)0;
    return (char)1;
  }
}

// PQserverVersion
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5425
extern signed int PQserverVersion(const struct pg_conn *conn)
{
  if(conn == ((const struct pg_conn *)NULL))
    return 0;

  else
    if((signed int)conn->status == CONNECTION_BAD)
      return 0;

    else
      return conn->sversion;
}

// PQsetClientEncoding
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5500
extern signed int PQsetClientEncoding(struct pg_conn *conn, const char *encoding)
{
  char qbuf[128l];
  struct pg_result *res;
  signed int status;
  _Bool tmp_if_expr_1;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)conn->status != CONNECTION_OK ? (_Bool)1 : (_Bool)0;
  signed int return_value_pg_get_encoding_from_locale_2;
  if(tmp_if_expr_1)
    return -1;

  else
    if(encoding == ((const char *)NULL))
      return -1;

    else
    {
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(encoding, "auto");
      if(return_value_strcmp_3 == 0)
      {
        return_value_pg_get_encoding_from_locale_2=pg_get_encoding_from_locale((const char *)(void *)0, (char)1);
        encoding=pg_encoding_to_char(return_value_pg_get_encoding_from_locale_2);
      }

      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(encoding);
      if(sizeof(const char [28l]) /*28ul*/  + return_value_strlen_4 >= 129ul)
        return -1;

      else
      {
        static const char query[28l] = { 's', 'e', 't', ' ', 'c', 'l', 'i', 'e', 'n', 't', '_', 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g', ' ', 't', 'o', ' ', '\'', '%', 's', '\'', 0 };
        sprintf(qbuf, query, encoding);
        res=PQexec(conn, qbuf);
        if(res == ((struct pg_result *)NULL))
          return -1;

        else
        {
          if(!((signed int)res->resultStatus == PGRES_COMMAND_OK))
            status = -1;

          else
          {
            if(!(conn->pversion >> 16 >= 3u))
              pqSaveParameterStatus(conn, "client_encoding", encoding);

            status = 0;
          }
          PQclear(res);
          return status;
        }
      }
    }
}

// PQsetErrorVerbosity
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5546
extern enum anonymous_5 PQsetErrorVerbosity(struct pg_conn *conn, enum anonymous_5 verbosity)
{
  enum anonymous_5 old;
  if(conn == ((struct pg_conn *)NULL))
    return (enum anonymous_5)PQERRORS_DEFAULT;

  else
  {
    old = conn->verbosity;
    conn->verbosity = verbosity;
    return old;
  }
}

// PQsetInstanceData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-events.c line 98
extern signed int PQsetInstanceData(struct pg_conn *conn, signed int (*proc)(enum anonymous_13, void *, void *), void *data)
{
  signed int i;
  if(proc == ((signed int (*)(enum anonymous_13, void *, void *))NULL) || conn == ((struct pg_conn *)NULL))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= conn->nEvents); i = i + 1)
      if((conn->events + (signed long int)i)->proc == proc)
      {
        (conn->events + (signed long int)i)->data = data;
        return 1;
      }

    return 0;
  }
}

// PQsetNoticeProcessor
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5596
extern void (*PQsetNoticeProcessor(struct pg_conn *conn, void (*proc)(void *, const char *), void *arg))(void *, const char *)
{
  void (*old)(void *, const char *);
  if(conn == ((struct pg_conn *)NULL))
    return (void (*)(void *, const char *))(void *)0;

  else
  {
    old = conn->noticeHooks.noticeProc;
    if(!(proc == ((void (*)(void *, const char *))NULL)))
    {
      conn->noticeHooks.noticeProc = proc;
      conn->noticeHooks.noticeProcArg = arg;
    }

    return old;
  }
}

// PQsetNoticeReceiver
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5579
extern void (*PQsetNoticeReceiver(struct pg_conn *conn, void (*proc)(void *, const struct pg_result *), void *arg))(void *, const struct pg_result *)
{
  void (*old)(void *, const struct pg_result *);
  if(conn == ((struct pg_conn *)NULL))
    return (void (*)(void *, const struct pg_result *))(void *)0;

  else
  {
    old = conn->noticeHooks.noticeRec;
    if(!(proc == ((void (*)(void *, const struct pg_result *))NULL)))
    {
      conn->noticeHooks.noticeRec = proc;
      conn->noticeHooks.noticeRecArg = arg;
    }

    return old;
  }
}

// PQsetResultAttrs
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 225
extern signed int PQsetResultAttrs(struct pg_result *res, signed int numAttributes, struct pgresAttDesc *attDescs)
{
  signed int i;
  _Bool tmp_if_expr_1;
  if(res == ((struct pg_result *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = res->numAttributes > 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return 0;

  else
    if(attDescs == ((struct pgresAttDesc *)NULL) || !(numAttributes >= 1))
      return 1;

    else
    {
      void *return_value_PQresultAlloc_2;
      return_value_PQresultAlloc_2=PQresultAlloc(res, (unsigned long int)numAttributes * sizeof(struct pgresAttDesc) /*32ul*/ );
      res->attDescs = (struct pgresAttDesc *)return_value_PQresultAlloc_2;
      if(res->attDescs == ((struct pgresAttDesc *)NULL))
        return 0;

      else
      {
        res->numAttributes = numAttributes;
        memcpy((void *)res->attDescs, (const void *)attDescs, (unsigned long int)numAttributes * sizeof(struct pgresAttDesc) /*32ul*/ );
        res->binary = 1;
        i = 0;
        for( ; !(i >= res->numAttributes); i = i + 1)
        {
          if(!((res->attDescs + (signed long int)i)->name == ((char *)NULL)))
            (res->attDescs + (signed long int)i)->name=pqResultStrdup(res, (res->attDescs + (signed long int)i)->name);

          else
            (res->attDescs + (signed long int)i)->name = res->null_field;
          if((res->attDescs + (signed long int)i)->name == ((char *)NULL))
            return 0;

          if((res->attDescs + (signed long int)i)->format == 0)
            res->binary = 0;

        }
        return 1;
      }
    }
}

// PQsetSingleRowMode
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1582
extern signed int PQsetSingleRowMode(struct pg_conn *conn)
{
  if(conn == ((struct pg_conn *)NULL))
    return 0;

  else
    if(!((signed int)conn->asyncStatus == PGASYNC_BUSY))
      return 0;

    else
      if(!((signed int)conn->queryclass == PGQUERY_SIMPLE))
      {
        if((signed int)conn->queryclass == PGQUERY_EXTENDED)
          goto __CPROVER_DUMP_L3;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        if(!(conn->result == ((struct pg_result *)NULL)))
          return 0;

        else
        {
          conn->singleRowMode = (char)1;
          return 1;
        }
      }
}

// PQsetdbLogin
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 957
extern struct pg_conn * PQsetdbLogin(const char *pghost, const char *pgport, const char *pgoptions, const char *pgtty, const char *dbName, const char *login, const char *pwd)
{
  struct pg_conn *conn;
  conn=makeEmptyPGconn();
  _Bool tmp_if_expr_4;
  char return_value_recognized_connection_string_3;
  if(conn == ((struct pg_conn *)NULL))
    return (struct pg_conn *)(void *)0;

  else
  {
    if(!(dbName == ((const char *)NULL)))
    {
      return_value_recognized_connection_string_3=recognized_connection_string(dbName);
      tmp_if_expr_4 = return_value_recognized_connection_string_3 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      char return_value_connectOptions1_1;
      return_value_connectOptions1_1=connectOptions1(conn, dbName);
      if(return_value_connectOptions1_1 == 0)
        return conn;

    }

    else
    {
      char return_value_connectOptions1_2;
      return_value_connectOptions1_2=connectOptions1(conn, "");
      if(return_value_connectOptions1_2 == 0)
        return conn;

      if(!(dbName == ((const char *)NULL)))
      {
        if(!((signed int)*dbName == 0))
        {
          if(!(conn->dbName == ((char *)NULL)))
            free((void *)conn->dbName);

          conn->dbName=strdup(dbName);
          if(conn->dbName == ((char *)NULL))
            goto oom_error;

        }

      }

    }
    if(!(pghost == ((const char *)NULL)))
    {
      if(!((signed int)*pghost == 0))
      {
        if(!(conn->pghost == ((char *)NULL)))
          free((void *)conn->pghost);

        conn->pghost=strdup(pghost);
        if(conn->pghost == ((char *)NULL))
          goto oom_error;

      }

    }

    if(!(pgport == ((const char *)NULL)))
    {
      if(!((signed int)*pgport == 0))
      {
        if(!(conn->pgport == ((char *)NULL)))
          free((void *)conn->pgport);

        conn->pgport=strdup(pgport);
        if(conn->pgport == ((char *)NULL))
          goto oom_error;

      }

    }

    if(!(pgoptions == ((const char *)NULL)))
    {
      if(!((signed int)*pgoptions == 0))
      {
        if(!(conn->pgoptions == ((char *)NULL)))
          free((void *)conn->pgoptions);

        conn->pgoptions=strdup(pgoptions);
        if(conn->pgoptions == ((char *)NULL))
          goto oom_error;

      }

    }

    if(!(pgtty == ((const char *)NULL)))
    {
      if(!((signed int)*pgtty == 0))
      {
        if(!(conn->pgtty == ((char *)NULL)))
          free((void *)conn->pgtty);

        conn->pgtty=strdup(pgtty);
        if(conn->pgtty == ((char *)NULL))
          goto oom_error;

      }

    }

    if(!(login == ((const char *)NULL)))
    {
      if(!((signed int)*login == 0))
      {
        if(!(conn->pguser == ((char *)NULL)))
          free((void *)conn->pguser);

        conn->pguser=strdup(login);
        if(conn->pguser == ((char *)NULL))
          goto oom_error;

      }

    }

    if(!(pwd == ((const char *)NULL)))
    {
      if(!((signed int)*pwd == 0))
      {
        if(!(conn->pgpass == ((char *)NULL)))
          free((void *)conn->pgpass);

        conn->pgpass=strdup(pwd);
        if(conn->pgpass == ((char *)NULL))
          goto oom_error;

      }

    }

    char return_value_connectOptions2_5;
    return_value_connectOptions2_5=connectOptions2(conn);
    if(return_value_connectOptions2_5 == 0)
      return conn;

    else
    {
      signed int return_value_connectDBStart_6;
      return_value_connectDBStart_6=connectDBStart(conn);
      if(!(return_value_connectDBStart_6 == 0))
        connectDBComplete(conn);

      return conn;

    oom_error:
      ;
      conn->status = (enum anonymous_24)CONNECTION_BAD;
      char *return_value_libpq_gettext_7;
      return_value_libpq_gettext_7=libpq_gettext("out of memory\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_7);
      return conn;
    }
  }
}

// PQsetnonblocking
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3075
extern signed int PQsetnonblocking(struct pg_conn *conn, signed int arg)
{
  char barg;
  _Bool tmp_if_expr_1;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)conn->status == CONNECTION_BAD ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return -1;

  else
  {
    barg = (char)(arg != 0 ? 1 : 0);
    if(barg == conn->nonblocking)
      return 0;

    else
    {
      signed int return_value_pqFlush_2;
      return_value_pqFlush_2=pqFlush(conn);
      if(!(return_value_pqFlush_2 == 0))
        return -1;

      else
      {
        conn->nonblocking = barg;
        return 0;
      }
    }
  }
}

// PQsetvalue
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 420
extern signed int PQsetvalue(struct pg_result *res, signed int tup_num, signed int field_num, char *value, signed int len)
{
  struct pgresAttValue *attval;
  signed int return_value_check_field_number_1;
  return_value_check_field_number_1=check_field_number(res, field_num);
  _Bool tmp_if_expr_2;
  if(return_value_check_field_number_1 == 0)
    return 0;

  else
  {
    if(!(tup_num >= 0))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = tup_num > res->ntups ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return 0;

    else
    {
      if(tup_num == res->ntups)
      {
        struct pgresAttValue *tup;
        signed int i;
        void *return_value_pqResultAlloc_3;
        return_value_pqResultAlloc_3=pqResultAlloc(res, (unsigned long int)res->numAttributes * sizeof(struct pgresAttValue) /*16ul*/ , (char)1);
        tup = (struct pgresAttValue *)return_value_pqResultAlloc_3;
        if(tup == ((struct pgresAttValue *)NULL))
          return 0;

        i = 0;
        for( ; !(i >= res->numAttributes); i = i + 1)
        {
          (tup + (signed long int)i)->len = -1;
          (tup + (signed long int)i)->value = res->null_field;
        }
        char return_value_pqAddTuple_4;
        return_value_pqAddTuple_4=pqAddTuple(res, tup);
        if(return_value_pqAddTuple_4 == 0)
          return 0;

      }

      attval = &res->tuples[(signed long int)tup_num][(signed long int)field_num];
      if(value == ((char *)NULL) || len == -1)
      {
        attval->len = -1;
        attval->value = res->null_field;
      }

      else
        if(!(len >= 1))
        {
          attval->len = 0;
          attval->value = res->null_field;
        }

        else
        {
          void *return_value_pqResultAlloc_5;
          return_value_pqResultAlloc_5=pqResultAlloc(res, (unsigned long int)(len + 1), (char)1);
          attval->value = (char *)return_value_pqResultAlloc_5;
          if(attval->value == ((char *)NULL))
            return 0;

          attval->len = len;
          memcpy((void *)attval->value, (const void *)value, (unsigned long int)len);
          attval->value[(signed long int)len] = (char)0;
        }
      return 1;
    }
  }
}

// PQsocket
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 314
extern signed int PQsocket(const struct pg_conn *conn)
{
  signed int tmp_if_expr_1;
  if(conn == ((const struct pg_conn *)NULL))
    return -1;

  else
  {
    if(!(conn->sock == -1))
      tmp_if_expr_1 = conn->sock;

    else
      tmp_if_expr_1 = -1;
    return tmp_if_expr_1;
  }
}

// PQstatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 307
extern enum anonymous_24 PQstatus(const struct pg_conn *conn)
{
  if(conn == ((const struct pg_conn *)NULL))
    return (enum anonymous_24)CONNECTION_BAD;

  else
    return conn->status;
}

// PQtrace
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5558
extern void PQtrace(struct pg_conn *conn, struct _IO_FILE *debug_port)
{
  if(!(conn == ((struct pg_conn *)NULL)))
  {
    PQuntrace(conn);
    conn->Pfdebug = debug_port;
  }

}

// PQtransactionStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5390
extern enum anonymous_3 PQtransactionStatus(const struct pg_conn *conn)
{
  _Bool tmp_if_expr_1;
  if(conn == ((const struct pg_conn *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)conn->status != CONNECTION_OK ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (enum anonymous_3)PQTRANS_UNKNOWN;

  else
    if(!((signed int)conn->asyncStatus == PGASYNC_IDLE))
      return (enum anonymous_3)PQTRANS_ACTIVE;

    else
      return conn->xactStatus;
}

// PQtty
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5366
extern char * PQtty(const struct pg_conn *conn)
{
  if(conn == ((const struct pg_conn *)NULL))
    return (char *)(void *)0;

  else
    return conn->pgtty;
}

// PQunescapeBytea
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3595
extern unsigned char * PQunescapeBytea(const unsigned char *strtext, unsigned long int *retbuflen)
{
  unsigned long int strtextlen;
  unsigned long int buflen;
  unsigned char *buffer;
  unsigned char *tmpbuf;
  unsigned long int i;
  unsigned long int j;
  _Bool tmp_if_expr_14;
  const unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned long int tmp_post_6;
  unsigned long int tmp_post_7;
  unsigned long int tmp_post_8;
  unsigned long int tmp_post_9;
  unsigned long int tmp_post_10;
  unsigned long int tmp_post_11;
  unsigned long int tmp_post_12;
  unsigned long int tmp_post_13;
  if(strtext == ((const unsigned char *)NULL))
    return (unsigned char *)(void *)0;

  else
  {
    strtextlen=strlen((const char *)strtext);
    if((signed int)*strtext == 92)
      tmp_if_expr_14 = (signed int)strtext[(signed long int)1] == 120 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_14 = (_Bool)0;
    if(tmp_if_expr_14)
    {
      const unsigned char *s;
      unsigned char *p;
      buflen = (strtextlen - (unsigned long int)2) / (unsigned long int)2;
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(buflen > (unsigned long int)0 ? buflen : (unsigned long int)1);
      buffer = (unsigned char *)return_value_malloc_1;
      if(buffer == ((unsigned char *)NULL))
        return (unsigned char *)(void *)0;

      s = strtext + (signed long int)2;
      p = buffer;
      while(!(*s == 0))
      {
        char v1;
        char v2;
        tmp_post_2 = s;
        s = s + 1l;
        v1=get_hex((char)*tmp_post_2);
        if(!(*s == 0) && !(v1 == -1))
        {
          tmp_post_3 = s;
          s = s + 1l;
          v2=get_hex((char)*tmp_post_3);
          if(!(v2 == -1))
          {
            tmp_post_4 = p;
            p = p + 1l;
            *tmp_post_4 = (unsigned char)((signed int)v1 << 4 | (signed int)v2);
          }

        }

      }
      buflen = (unsigned long int)(p - buffer);
    }

    else
    {
      void *return_value_malloc_5;
      return_value_malloc_5=malloc(strtextlen + (unsigned long int)1);
      buffer = (unsigned char *)return_value_malloc_5;
      if(buffer == ((unsigned char *)NULL))
        return (unsigned char *)(void *)0;

      j = (unsigned long int)0;
      i = j;
      while(!(i >= strtextlen))
      {
        if((signed int)strtext[(signed long int)i] == 92)
        {
          i = i + 1ul;
          if((signed int)strtext[(signed long int)i] == 92)
          {
            tmp_post_6 = j;
            j = j + 1ul;
            tmp_post_7 = i;
            i = i + 1ul;
            buffer[(signed long int)tmp_post_6] = strtext[(signed long int)tmp_post_7];
          }

          else
            if((signed int)strtext[(signed long int)i] >= 48)
            {
              if(!((signed int)strtext[(signed long int)i] >= 52))
              {
                if((signed int)strtext[1l + (signed long int)i] >= 48)
                {
                  if(!((signed int)strtext[1l + (signed long int)i] >= 56))
                  {
                    if((signed int)strtext[2l + (signed long int)i] >= 48)
                    {
                      if(!((signed int)strtext[2l + (signed long int)i] >= 56))
                      {
                        signed int byte;
                        tmp_post_8 = i;
                        i = i + 1ul;
                        byte = (signed int)strtext[(signed long int)tmp_post_8] - 48;
                        tmp_post_9 = i;
                        i = i + 1ul;
                        byte = (byte << 3) + ((signed int)strtext[(signed long int)tmp_post_9] - 48);
                        tmp_post_10 = i;
                        i = i + 1ul;
                        byte = (byte << 3) + ((signed int)strtext[(signed long int)tmp_post_10] - 48);
                        tmp_post_11 = j;
                        j = j + 1ul;
                        buffer[(signed long int)tmp_post_11] = (unsigned char)byte;
                      }

                    }

                  }

                }

              }

            }

          continue;
        }

        tmp_post_12 = j;
        j = j + 1ul;
        tmp_post_13 = i;
        i = i + 1ul;
        buffer[(signed long int)tmp_post_12] = strtext[(signed long int)tmp_post_13];
      }
      buflen = j;
    }
    void *return_value_realloc_15;
    return_value_realloc_15=realloc((void *)buffer, buflen + (unsigned long int)1);
    tmpbuf = (unsigned char *)return_value_realloc_15;
    if(tmpbuf == ((unsigned char *)NULL))
    {
      free((void *)buffer);
      return (unsigned char *)(void *)0;
    }

    else
    {
      *retbuflen = buflen;
      return tmpbuf;
    }
  }
}

// PQuntrace
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5567
extern void PQuntrace(struct pg_conn *conn)
{
  if(!(conn == ((struct pg_conn *)NULL)))
  {
    if(!(conn->Pfdebug == ((struct _IO_FILE *)NULL)))
    {
      fflush(conn->Pfdebug);
      conn->Pfdebug = (struct _IO_FILE *)(void *)0;
    }

  }

}

// PQuser
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5325
extern char * PQuser(const struct pg_conn *conn)
{
  if(conn == ((const struct pg_conn *)NULL))
    return (char *)(void *)0;

  else
    return conn->pguser;
}

// PasswordFromFile
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5683
static char * PasswordFromFile(char *hostname, char *port, char *dbname, char *username)
{
  struct _IO_FILE *fp;
  char pgpassfile[1024l];
  struct stat stat_buf;
  char buf[320l];
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(dbname == ((char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strlen_1=strlen(dbname);
    tmp_if_expr_2 = return_value_strlen_1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  unsigned long int return_value_strlen_3;
  signed int return_value_strcmp_5;
  signed int return_value_feof_10;
  signed int return_value_ferror_11;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_17;
  if(tmp_if_expr_2)
    return (char *)(void *)0;

  else
  {
    if(username == ((char *)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_strlen_3=strlen(username);
      tmp_if_expr_4 = return_value_strlen_3 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      return (char *)(void *)0;

    else
    {
      if(hostname == ((char *)NULL))
        hostname = "localhost";

      else
        if((signed int)*hostname == 47)
        {
          return_value_strcmp_5=strcmp(hostname, "/var/run/postgresql");
          if(return_value_strcmp_5 == 0)
            hostname = "localhost";

        }

      if(port == ((char *)NULL))
        port = "5432";

      char return_value_getPgPassFilename_6;
      return_value_getPgPassFilename_6=getPgPassFilename(pgpassfile);
      if(return_value_getPgPassFilename_6 == 0)
        return (char *)(void *)0;

      else
      {
        signed int return_value_stat_7;
        return_value_stat_7=stat(pgpassfile, &stat_buf);
        if(!(return_value_stat_7 == 0))
          return (char *)(void *)0;

        else
        {
          if(!((61440u & stat_buf.st_mode) == 32768u))
          {
            char *return_value_libpq_gettext_8;
            return_value_libpq_gettext_8=libpq_gettext("WARNING: password file \"%s\" is not a plain file\n");
            fprintf(stderr, return_value_libpq_gettext_8, (const void *)pgpassfile);
            return (char *)(void *)0;
          }

          if(!((63u & stat_buf.st_mode) == 0u))
          {
            char *return_value_libpq_gettext_9;
            return_value_libpq_gettext_9=libpq_gettext("WARNING: password file \"%s\" has group or world access; permissions should be u=rw (0600) or less\n");
            fprintf(stderr, return_value_libpq_gettext_9, (const void *)pgpassfile);
            return (char *)(void *)0;
          }

          fp=fopen(pgpassfile, "r");
          if(fp == ((struct _IO_FILE *)NULL))
            return (char *)(void *)0;

          else
          {
            do
            {
              return_value_feof_10=feof(fp);
              if(!(return_value_feof_10 == 0))
                break;

              return_value_ferror_11=ferror(fp);
              if(!(return_value_ferror_11 == 0))
                break;

              char *t = buf;
              char *ret;
              char *p1;
              char *p2;
              signed int len;
              char *return_value_fgets_12;
              return_value_fgets_12=fgets(buf, (signed int)sizeof(char [320l]) /*320ul*/ , fp);
              if(return_value_fgets_12 == ((char *)NULL))
                break;

              unsigned long int return_value_strlen_13;
              return_value_strlen_13=strlen(buf);
              len = (signed int)return_value_strlen_13;
              if(!(len == 0))
              {
                if((signed int)buf[(signed long int)(len + -1)] == 10)
                  buf[(signed long int)(len - 1)] = (char)0;

                t=pwdfMatchesString(t, hostname);
                if(t == ((char *)NULL))
                  tmp_if_expr_14 = (_Bool)1;

                else
                {
                  t=pwdfMatchesString(t, port);
                  tmp_if_expr_14 = t == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_14)
                  tmp_if_expr_15 = (_Bool)1;

                else
                {
                  t=pwdfMatchesString(t, dbname);
                  tmp_if_expr_15 = t == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_15)
                  tmp_if_expr_16 = (_Bool)1;

                else
                {
                  t=pwdfMatchesString(t, username);
                  tmp_if_expr_16 = t == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
                }
                if(!tmp_if_expr_16)
                {
                  ret=strdup(t);
                  fclose(fp);
                  if(ret == ((char *)NULL))
                    return (char *)(void *)0;

                  p2 = ret;
                  p1 = p2;
                  do
                  {
                    if(!((signed int)*p1 == 58))
                      tmp_if_expr_17 = (signed int)*p1 != 0 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_17 = (_Bool)0;
                    if(!tmp_if_expr_17)
                      break;

                    if((signed int)*p1 == 92)
                    {
                      if(!((signed int)p1[1l] == 0))
                        p1 = p1 + 1l;

                    }

                    *p2 = *p1;
                    p1 = p1 + 1l;
                    p2 = p2 + 1l;
                  }
                  while((_Bool)1);
                  *p2 = (char)0;
                  return ret;
                }

              }

            }
            while((_Bool)1);
            fclose(fp);
            return (char *)(void *)0;
          }
        }
      }
    }
  }
}

// SSLerrfree
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1638
static void SSLerrfree(char *buf)
{
  if(!(buf == ssl_nomem))
    free((void *)buf);

}

// SSLerrmessage
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1612
static char * SSLerrmessage(void)
{
  unsigned long int errcode;
  const char *errreason;
  char *errbuf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)128);
  errbuf = (char *)return_value_malloc_1;
  if(errbuf == ((char *)NULL))
    return ssl_nomem;

  else
  {
    errcode=ERR_get_error();
    if(errcode == 0ul)
    {
      char *return_value_libpq_gettext_2;
      return_value_libpq_gettext_2=libpq_gettext("no SSL error reported");
      snprintf(errbuf, (unsigned long int)128, return_value_libpq_gettext_2);
      return errbuf;
    }

    errreason=ERR_reason_error_string(errcode);
    if(!(errreason == ((const char *)NULL)))
    {
      strlcpy(errbuf, errreason, (unsigned long int)128);
      return errbuf;
    }

    else
    {
      char *return_value_libpq_gettext_3;
      return_value_libpq_gettext_3=libpq_gettext("SSL error code %lu");
      snprintf(errbuf, (unsigned long int)128, return_value_libpq_gettext_3, errcode);
      return errbuf;
    }
  }
}

// _dorand48
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/erand48.c line 58
static void _dorand48(unsigned short int *xseed)
{
  unsigned long int accu;
  unsigned short int temp[2l];
  accu = (unsigned long int)_rand48_mult[(signed long int)0] * (unsigned long int)xseed[(signed long int)0] + (unsigned long int)_rand48_add;
  temp[(signed long int)0] = (unsigned short int)accu;
  accu = accu >> sizeof(unsigned short int) /*2ul*/  * (unsigned long int)8;
  accu = accu + (unsigned long int)_rand48_mult[(signed long int)0] * (unsigned long int)xseed[(signed long int)1] + (unsigned long int)_rand48_mult[(signed long int)1] * (unsigned long int)xseed[(signed long int)0];
  temp[(signed long int)1] = (unsigned short int)accu;
  accu = accu >> sizeof(unsigned short int) /*2ul*/  * (unsigned long int)8;
  accu = accu + (unsigned long int)((signed int)_rand48_mult[(signed long int)0] * (signed int)xseed[(signed long int)2] + (signed int)_rand48_mult[(signed long int)1] * (signed int)xseed[(signed long int)1] + (signed int)_rand48_mult[(signed long int)2] * (signed int)xseed[(signed long int)0]);
  xseed[(signed long int)0] = temp[(signed long int)0];
  xseed[(signed long int)1] = temp[(signed long int)1];
  xseed[(signed long int)2] = (unsigned short int)accu;
}

// _dorand48_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/erand48.c line 58
static void _dorand48_link1(unsigned short int *xseed_link1)
{
  unsigned long int accu_link1;
  unsigned short int temp_link1[2l];
  accu_link1 = (unsigned long int)_rand48_mult_link1[(signed long int)0] * (unsigned long int)xseed_link1[(signed long int)0] + (unsigned long int)_rand48_add_link1;
  temp_link1[(signed long int)0] = (unsigned short int)accu_link1;
  accu_link1 = accu_link1 >> sizeof(unsigned short int) /*2ul*/  * (unsigned long int)8;
  accu_link1 = accu_link1 + (unsigned long int)_rand48_mult_link1[(signed long int)0] * (unsigned long int)xseed_link1[(signed long int)1] + (unsigned long int)_rand48_mult_link1[(signed long int)1] * (unsigned long int)xseed_link1[(signed long int)0];
  temp_link1[(signed long int)1] = (unsigned short int)accu_link1;
  accu_link1 = accu_link1 >> sizeof(unsigned short int) /*2ul*/  * (unsigned long int)8;
  accu_link1 = accu_link1 + (unsigned long int)((signed int)_rand48_mult_link1[(signed long int)0] * (signed int)xseed_link1[(signed long int)2] + (signed int)_rand48_mult_link1[(signed long int)1] * (signed int)xseed_link1[(signed long int)1] + (signed int)_rand48_mult_link1[(signed long int)2] * (signed int)xseed_link1[(signed long int)0]);
  xseed_link1[(signed long int)0] = temp_link1[(signed long int)0];
  xseed_link1[(signed long int)1] = temp_link1[(signed long int)1];
  xseed_link1[(signed long int)2] = (unsigned short int)accu_link1;
}

// agg_vals_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 915
static void agg_vals_init(struct anonymous_19 *aggs, struct timeval start)
{
  aggs->cnt = 0;
  aggs->sum_latency = (double)0;
  aggs->sum2_latency = (double)0;
  aggs->min_latency = (double)0;
  aggs->max_latency = (double)0;
  aggs->sum_lag = (double)0;
  aggs->sum2_lag = (double)0;
  aggs->min_lag = (double)0;
  aggs->max_lag = (double)0;
  aggs->start_time = (signed long int)((double)start.tv_sec + (double)start.tv_usec / 1000000.0);
}

// appendBinaryPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 185
extern void appendBinaryPQExpBuffer(struct PQExpBufferData *str, const char *data, unsigned long int datalen)
{
  signed int return_value_enlargePQExpBuffer_1;
  return_value_enlargePQExpBuffer_1=enlargePQExpBuffer(str, datalen);
  if(!(return_value_enlargePQExpBuffer_1 == 0))
  {
    memcpy((void *)(str->data + (signed long int)str->len), (const void *)data, datalen);
    str->len = str->len + datalen;
    str->data[(signed long int)str->len] = (char)0;
  }

}

// appendPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 162
extern void appendPQExpBuffer(struct PQExpBufferData *str, const char *fmt, ...)
{
  void **args;
  char done;
  _Bool tmp_if_expr_1;
  if(str == ((struct PQExpBufferData *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = str->maxlen == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
    do
    {
      args = (void **)&fmt;
      done=appendPQExpBufferVA(str, fmt, args);
      args = ((void **)NULL);
    }
    while(done == 0);

}

// appendPQExpBufferChar
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 178
extern void appendPQExpBufferChar(struct PQExpBufferData *str, char ch)
{
  signed int return_value_enlargePQExpBuffer_1;
  return_value_enlargePQExpBuffer_1=enlargePQExpBuffer(str, (unsigned long int)1);
  if(!(return_value_enlargePQExpBuffer_1 == 0))
  {
    str->data[(signed long int)str->len] = ch;
    str->len = str->len + 1ul;
    str->data[(signed long int)str->len] = (char)0;
  }

}

// appendPQExpBufferStr
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 171
extern void appendPQExpBufferStr(struct PQExpBufferData *str, const char *data)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(data);
  appendBinaryPQExpBuffer(str, data, return_value_strlen_1);
}

// appendPQExpBufferVA
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.c line 288
static char appendPQExpBufferVA(struct PQExpBufferData *str, const char *fmt, void **args)
{
  unsigned long int avail;
  unsigned long int needed;
  signed int nprinted;
  signed int *return_value___errno_location_3;
  signed int *return_value___errno_location_2;
  if(!(16ul + str->len >= str->maxlen))
  {
    avail = (str->maxlen - str->len) - (unsigned long int)1;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    nprinted=vsnprintf(str->data + (signed long int)str->len, avail, fmt, args);
    if(!(nprinted >= 0))
    {
      return_value___errno_location_3=__errno_location();
      if(!(*return_value___errno_location_3 == 0))
      {
        return_value___errno_location_2=__errno_location();
        if(!(*return_value___errno_location_2 == 12))
        {
          markPQExpBufferBroken(str);
          return (char)1;
        }

      }

    }

    if(nprinted >= 0 && !((unsigned long int)nprinted >= avail + 18446744073709551615ul))
    {
      str->len = str->len + (unsigned long int)nprinted;
      return (char)1;
    }

    if(nprinted >= 0 && !(avail >= (unsigned long int)nprinted))
    {
      if(nprinted >= 2147483646)
      {
        markPQExpBufferBroken(str);
        return (char)1;
      }

      needed = (unsigned long int)(nprinted + 2);
    }

    else
      if(avail >= 1073741823ul)
        needed = (unsigned long int)0x7fffffff;

      else
        needed = avail * (unsigned long int)2;
  }

  else
    needed = (unsigned long int)32;
  signed int return_value_enlargePQExpBuffer_4;
  return_value_enlargePQExpBuffer_4=enlargePQExpBuffer(str, needed);
  if(return_value_enlargePQExpBuffer_4 == 0)
    return (char)1;

  else
    return (char)0;
}

// assignVariables
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 743
static char * assignVariables(struct anonymous_18 *st, char *sql)
{
  char *p;
  char *name;
  char *val;
  p = sql;
  do
  {
    p=strchr(p, 58);
    if(p == ((char *)NULL))
      break;

    signed int eaten;
    name=parseVariable(p, &eaten);
    if(name == ((char *)NULL))
      for( ; (signed int)*p == 58; p = p + 1l)
        ;

    else
    {
      val=getVariable(st, name);
      free((void *)name);
      if(val == ((char *)NULL))
        p = p + 1l;

      else
        p=replaceVariable(&sql, p, eaten, val);
    }
  }
  while((_Bool)1);
  return sql;
}

// build_startup_packet
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 2034
static signed int build_startup_packet(const struct pg_conn *conn, char *packet, const struct PQEnvironmentOption *options)
{
  signed int packet_len = 0;
  const struct PQEnvironmentOption *next_eo;
  const char *val;
  if(!(packet == ((char *)NULL)))
  {
    unsigned int pv;
    pv=htonl(conn->pversion);
    memcpy((void *)(packet + (signed long int)packet_len), (const void *)&pv, sizeof(unsigned int) /*4ul*/ );
  }

  packet_len = packet_len + (signed int)sizeof(unsigned int) /*4ul*/ ;
  if(!(conn->pguser == ((char *)NULL)))
  {
    if(!(*conn->pguser == 0))
      do
      {
        if(!(packet == ((char *)NULL)))
          strcpy(packet + (signed long int)packet_len, "user");

        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen("user");
        packet_len = packet_len + (signed int)(return_value_strlen_1 + (unsigned long int)1);
        if(!(packet == ((char *)NULL)))
          strcpy(packet + (signed long int)packet_len, conn->pguser);

        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(conn->pguser);
        packet_len = packet_len + (signed int)(return_value_strlen_2 + (unsigned long int)1);
      }
      while((_Bool)0);

  }

  if(!(conn->dbName == ((char *)NULL)))
  {
    if(!(*conn->dbName == 0))
      do
      {
        if(!(packet == ((char *)NULL)))
          strcpy(packet + (signed long int)packet_len, "database");

        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen("database");
        packet_len = packet_len + (signed int)(return_value_strlen_3 + (unsigned long int)1);
        if(!(packet == ((char *)NULL)))
          strcpy(packet + (signed long int)packet_len, conn->dbName);

        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(conn->dbName);
        packet_len = packet_len + (signed int)(return_value_strlen_4 + (unsigned long int)1);
      }
      while((_Bool)0);

  }

  if(!(conn->replication == ((char *)NULL)))
  {
    if(!(*conn->replication == 0))
      do
      {
        if(!(packet == ((char *)NULL)))
          strcpy(packet + (signed long int)packet_len, "replication");

        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen("replication");
        packet_len = packet_len + (signed int)(return_value_strlen_5 + (unsigned long int)1);
        if(!(packet == ((char *)NULL)))
          strcpy(packet + (signed long int)packet_len, conn->replication);

        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen(conn->replication);
        packet_len = packet_len + (signed int)(return_value_strlen_6 + (unsigned long int)1);
      }
      while((_Bool)0);

  }

  if(!(conn->pgoptions == ((char *)NULL)))
  {
    if(!(*conn->pgoptions == 0))
      do
      {
        if(!(packet == ((char *)NULL)))
          strcpy(packet + (signed long int)packet_len, "options");

        unsigned long int return_value_strlen_7;
        return_value_strlen_7=strlen("options");
        packet_len = packet_len + (signed int)(return_value_strlen_7 + (unsigned long int)1);
        if(!(packet == ((char *)NULL)))
          strcpy(packet + (signed long int)packet_len, conn->pgoptions);

        unsigned long int return_value_strlen_8;
        return_value_strlen_8=strlen(conn->pgoptions);
        packet_len = packet_len + (signed int)(return_value_strlen_8 + (unsigned long int)1);
      }
      while((_Bool)0);

  }

  char *tmp_if_expr_9;
  if(!(conn->send_appname == 0))
  {
    if(!(conn->appname == ((char *)NULL)))
      tmp_if_expr_9 = conn->appname;

    else
      tmp_if_expr_9 = conn->fbappname;
    val = tmp_if_expr_9;
    if(!(val == ((const char *)NULL)))
    {
      if(!(*val == 0))
        do
        {
          if(!(packet == ((char *)NULL)))
            strcpy(packet + (signed long int)packet_len, "application_name");

          unsigned long int return_value_strlen_10;
          return_value_strlen_10=strlen("application_name");
          packet_len = packet_len + (signed int)(return_value_strlen_10 + (unsigned long int)1);
          if(!(packet == ((char *)NULL)))
            strcpy(packet + (signed long int)packet_len, val);

          unsigned long int return_value_strlen_11;
          return_value_strlen_11=strlen(val);
          packet_len = packet_len + (signed int)(return_value_strlen_11 + (unsigned long int)1);
        }
        while((_Bool)0);

    }

  }

  if(!(conn->client_encoding_initial == ((char *)NULL)))
  {
    if(!(*conn->client_encoding_initial == 0))
      do
      {
        if(!(packet == ((char *)NULL)))
          strcpy(packet + (signed long int)packet_len, "client_encoding");

        unsigned long int return_value_strlen_12;
        return_value_strlen_12=strlen("client_encoding");
        packet_len = packet_len + (signed int)(return_value_strlen_12 + (unsigned long int)1);
        if(!(packet == ((char *)NULL)))
          strcpy(packet + (signed long int)packet_len, conn->client_encoding_initial);

        unsigned long int return_value_strlen_13;
        return_value_strlen_13=strlen(conn->client_encoding_initial);
        packet_len = packet_len + (signed int)(return_value_strlen_13 + (unsigned long int)1);
      }
      while((_Bool)0);

  }

  next_eo = options;
  for( ; !(next_eo->envName == ((const char *)NULL)); next_eo = next_eo + 1l)
  {
    val=getenv(next_eo->envName);
    if(!(val == ((const char *)NULL)))
    {
      signed int return_value_pg_strcasecmp_16;
      return_value_pg_strcasecmp_16=pg_strcasecmp(val, "default");
      if(!(return_value_pg_strcasecmp_16 == 0))
        do
        {
          if(!(packet == ((char *)NULL)))
            strcpy(packet + (signed long int)packet_len, next_eo->pgName);

          unsigned long int return_value_strlen_14;
          return_value_strlen_14=strlen(next_eo->pgName);
          packet_len = packet_len + (signed int)(return_value_strlen_14 + (unsigned long int)1);
          if(!(packet == ((char *)NULL)))
            strcpy(packet + (signed long int)packet_len, val);

          unsigned long int return_value_strlen_15;
          return_value_strlen_15=strlen(val);
          packet_len = packet_len + (signed int)(return_value_strlen_15 + (unsigned long int)1);
        }
        while((_Bool)0);

    }

  }
  if(!(packet == ((char *)NULL)))
    packet[(signed long int)packet_len] = (char)0;

  packet_len = packet_len + 1;
  return packet_len;
}

// bytesToHex
// file md5.c line 245
static void bytesToHex(unsigned char *b, char *s)
{
  signed int q;
  signed int w;
  q = 0;
  w = 0;
  signed int tmp_post_1;
  signed int tmp_post_2;
  for( ; !(q >= 16); q = q + 1)
  {
    tmp_post_1 = w;
    w = w + 1;
    static const char *hex = "0123456789abcdef";
    s[(signed long int)tmp_post_1] = hex[(signed long int)((signed int)b[(signed long int)q] >> 4 & 0x0F)];
    tmp_post_2 = w;
    w = w + 1;
    s[(signed long int)tmp_post_2] = hex[(signed long int)((signed int)b[(signed long int)q] & 0x0F)];
  }
  s[(signed long int)w] = (char)0;
}

// calculateDigestFromBuffer
// file md5.c line 185
static signed int calculateDigestFromBuffer(const unsigned char *b, unsigned int len, unsigned char *sum)
{
  unsigned int i;
  unsigned int j;
  unsigned int k;
  unsigned int newI;
  unsigned int l;
  unsigned char *input;
  unsigned int *wbp;
  unsigned int workBuff[16l];
  unsigned int state[4l];
  l = len;
  state[(signed long int)0] = (unsigned int)0x67452301;
  state[(signed long int)1] = 0xEFCDAB89;
  state[(signed long int)2] = 0x98BADCFE;
  state[(signed long int)3] = (unsigned int)0x10325476;
  input=createPaddedCopyWithLength(b, &l);
  unsigned int tmp_post_1;
  unsigned int tmp_post_2;
  unsigned int tmp_post_3;
  unsigned int tmp_post_4;
  unsigned int tmp_post_5;
  unsigned int tmp_post_6;
  unsigned int tmp_post_7;
  if(input == ((unsigned char *)NULL))
    return 0;

  else
  {
    i = (unsigned int)0;
    do
    {
      newI = i + (unsigned int)(16 * 4);
      if(!(l >= newI))
        break;

      k = i + (unsigned int)3;
      j = (unsigned int)0;
      for( ; !(j >= 16u); j = j + 1u)
      {
        wbp = workBuff + (signed long int)j;
        tmp_post_1 = k;
        k = k - 1u;
        *wbp = (unsigned int)input[(signed long int)tmp_post_1];
        *wbp = *wbp << 8;
        tmp_post_2 = k;
        k = k - 1u;
        *wbp = *wbp | (unsigned int)input[(signed long int)tmp_post_2];
        *wbp = *wbp << 8;
        tmp_post_3 = k;
        k = k - 1u;
        *wbp = *wbp | (unsigned int)input[(signed long int)tmp_post_3];
        *wbp = *wbp << 8;
        *wbp = *wbp | (unsigned int)input[(signed long int)k];
        k = k + (unsigned int)7;
      }
      doTheRounds(workBuff, state);
      i = newI;
    }
    while((_Bool)1);
    free((void *)input);
    j = (unsigned int)0;
    i = (unsigned int)0;
    for( ; !(i >= 4u); i = i + 1u)
    {
      k = state[(signed long int)i];
      tmp_post_4 = j;
      j = j + 1u;
      sum[(signed long int)tmp_post_4] = (unsigned char)(k & (unsigned int)0xff);
      k = k >> 8;
      tmp_post_5 = j;
      j = j + 1u;
      sum[(signed long int)tmp_post_5] = (unsigned char)(k & (unsigned int)0xff);
      k = k >> 8;
      tmp_post_6 = j;
      j = j + 1u;
      sum[(signed long int)tmp_post_6] = (unsigned char)(k & (unsigned int)0xff);
      k = k >> 8;
      tmp_post_7 = j;
      j = j + 1u;
      sum[(signed long int)tmp_post_7] = (unsigned char)(k & (unsigned int)0xff);
    }
    return 1;
  }
}

// canonicalize_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 43
extern void canonicalize_path(char *path)
{
  char *p;
  char *to_p;
  char *spath;
  char was_sep = (char)0;
  signed int pending_strips;
  trim_trailing_separator(path);
  p = path;
  to_p = p;
  for( ; !(*p == 0); to_p = to_p + 1l)
  {
    for( ; (signed int)*p == 47; p = p + 1l)
      if(was_sep == 0)
        break;

    if(!(to_p == p))
      *to_p = *p;

    was_sep = (char)((signed int)*p == 47);
    p = p + 1l;
  }
  *to_p = (char)0;
  spath = path;
  pending_strips = 0;
  _Bool tmp_if_expr_9;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_7;
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_5;
  _Bool tmp_if_expr_2;
  do
  {
    signed int len;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(spath);
    len = (signed int)return_value_strlen_1;
    if(len >= 2)
    {
      return_value_strcmp_8=strcmp((spath + (signed long int)len) - (signed long int)2, "/.");
      tmp_if_expr_9 = return_value_strcmp_8 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_9 = (_Bool)0;
    if(tmp_if_expr_9)
      trim_directory(path);

    else
    {
      return_value_strcmp_7=strcmp(spath, ".");
      if(return_value_strcmp_7 == 0)
      {
        if(pending_strips >= 1)
          *spath = (char)0;

        break;
      }

      else
      {
        if(len >= 3)
        {
          return_value_strcmp_3=strcmp((spath + (signed long int)len) - (signed long int)3, "/..");
          tmp_if_expr_4 = return_value_strcmp_3 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value_strcmp_5=strcmp(spath, "..");
          tmp_if_expr_6 = return_value_strcmp_5 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
        {
          trim_directory(path);
          pending_strips = pending_strips + 1;
        }

        else
        {
          if(pending_strips >= 1)
            tmp_if_expr_2 = (signed int)*spath != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_2 = (_Bool)0;
          if(tmp_if_expr_2)
          {
            trim_directory(path);
            pending_strips = pending_strips - 1;
            if((signed int)*spath == 0)
              strcpy(spath, ".");

          }

          else
            break;
        }
      }
    }
  }
  while((_Bool)1);
  if(pending_strips >= 1)
  {
    do
    {
      pending_strips = pending_strips - 1;
      if(!(pending_strips >= 1))
        break;

      strcat(path, "../");
    }
    while((_Bool)1);
    strcat(path, "..");
  }

}

// checkXactStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol2.c line 1086
static void checkXactStatus(struct pg_conn *conn, const char *cmdTag)
{
  signed int return_value_strcmp_5;
  return_value_strcmp_5=strcmp(cmdTag, "BEGIN");
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(return_value_strcmp_5 == 0)
    conn->xactStatus = (enum anonymous_3)PQTRANS_INTRANS;

  else
  {
    return_value_strcmp_4=strcmp(cmdTag, "COMMIT");
    if(return_value_strcmp_4 == 0)
      conn->xactStatus = (enum anonymous_3)PQTRANS_IDLE;

    else
    {
      return_value_strcmp_3=strcmp(cmdTag, "ROLLBACK");
      if(return_value_strcmp_3 == 0)
        conn->xactStatus = (enum anonymous_3)PQTRANS_IDLE;

      else
      {
        return_value_strcmp_2=strcmp(cmdTag, "START TRANSACTION");
        if(return_value_strcmp_2 == 0)
          conn->xactStatus = (enum anonymous_3)PQTRANS_INTRANS;

        else
        {
          return_value_strcmp_1=strcmp(cmdTag, "*ABORT STATE*");
          if(return_value_strcmp_1 == 0)
            conn->xactStatus = (enum anonymous_3)PQTRANS_INERROR;

        }
      }
    }
  }
}

// check_field_number
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2642
static signed int check_field_number(const struct pg_result *res, signed int field_num)
{
  _Bool tmp_if_expr_1;
  if(res == ((const struct pg_result *)NULL))
    return 0;

  else
  {
    if(!(field_num >= 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = field_num >= res->numAttributes ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      pqInternalNotice(&res->noticeHooks, "column number %d is out of range 0..%d", field_num, res->numAttributes - 1);
      return 0;
    }

    else
      return 1;
  }
}

// check_param_number
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2680
static signed int check_param_number(const struct pg_result *res, signed int param_num)
{
  _Bool tmp_if_expr_1;
  if(res == ((const struct pg_result *)NULL))
    return 0;

  else
  {
    if(!(param_num >= 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = param_num >= res->numParameters ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      pqInternalNotice(&res->noticeHooks, "parameter number %d is out of range 0..%d", param_num, res->numParameters - 1);
      return 0;
    }

    else
      return 1;
  }
}

// check_tuple_field_number
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 2657
static signed int check_tuple_field_number(const struct pg_result *res, signed int tup_num, signed int field_num)
{
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(res == ((const struct pg_result *)NULL))
    return 0;

  else
  {
    if(!(tup_num >= 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = tup_num >= res->ntups ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      pqInternalNotice(&res->noticeHooks, "row number %d is out of range 0..%d", tup_num, res->ntups - 1);
      return 0;
    }

    else
    {
      if(!(field_num >= 0))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = field_num >= res->numAttributes ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        pqInternalNotice(&res->noticeHooks, "column number %d is out of range 0..%d", field_num, res->numAttributes - 1);
        return 0;
      }

      else
        return 1;
    }
  }
}

// clean_encoding_name
// file encnames.c line 449
static char * clean_encoding_name(const char *key, char *newkey)
{
  const char *p;
  char *np;
  p = key;
  np = newkey;
  _Bool tmp_if_expr_3;
  char *tmp_post_1;
  char *tmp_post_2;
  for( ; !((signed int)*p == 0); p = p + 1l)
  {
    const unsigned short int **return_value___ctype_b_loc_4;
    return_value___ctype_b_loc_4=__ctype_b_loc();
    if(!((8 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)*p]) == 0))
    {
      if((signed int)*p >= 65)
        tmp_if_expr_3 = (signed int)*p <= 90 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
      {
        tmp_post_1 = np;
        np = np + 1l;
        *tmp_post_1 = (char)(((signed int)*p + 97) - 65);
      }

      else
      {
        tmp_post_2 = np;
        np = np + 1l;
        *tmp_post_2 = *p;
      }
    }

  }
  *np = (char)0;
  return newkey;
}

// clientDone
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 902
static char clientDone(struct anonymous_18 *st, char ok)
{
  (void)ok;
  if(!(st->con == ((struct pg_conn *)NULL)))
  {
    PQfinish(st->con);
    st->con = (struct pg_conn *)(void *)0;
  }

  return (char)0;
}

// closePGconn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 2941
static void closePGconn(struct pg_conn *conn)
{
  struct pgNotify *notify;
  struct pgParameterStatus *pstatus;
  if(!(conn->sock == -1))
  {
    if((signed int)conn->status == CONNECTION_OK)
    {
      pqPutMsgStart((char)88, (char)0, conn);
      pqPutMsgEnd(conn);
      pqFlush(conn);
    }

  }

  conn->nonblocking = (char)0;
  pqDropConnection(conn);
  conn->status = (enum anonymous_24)CONNECTION_BAD;
  conn->asyncStatus = (enum anonymous_9)PGASYNC_IDLE;
  pqClearAsyncResult(conn);
  resetPQExpBuffer(&conn->errorMessage);
  pg_freeaddrinfo_all(conn->addrlist_family, conn->addrlist);
  conn->addrlist = (struct addrinfo *)(void *)0;
  conn->addr_cur = (struct addrinfo *)(void *)0;
  notify = conn->notifyHead;
  while(!(notify == ((struct pgNotify *)NULL)))
  {
    struct pgNotify *closePGconn__1__2__prev = notify;
    notify = notify->next;
    free((void *)closePGconn__1__2__prev);
  }
  conn->notifyTail = (struct pgNotify *)(void *)0;
  conn->notifyHead = conn->notifyTail;
  pstatus = conn->pstatus;
  while(!(pstatus == ((struct pgParameterStatus *)NULL)))
  {
    struct pgParameterStatus *prev = pstatus;
    pstatus = pstatus->next;
    free((void *)prev);
  }
  conn->pstatus = (struct pgParameterStatus *)(void *)0;
  if(!(conn->lobjfuncs == ((struct pgLobjfuncs *)NULL)))
    free((void *)conn->lobjfuncs);

  conn->lobjfuncs = (struct pgLobjfuncs *)(void *)0;
  unsigned int min_s;
  if(!(conn->gctx == ((struct gss_ctx_id_struct *)NULL)))
    gss_delete_sec_context(&min_s, &conn->gctx, (struct gss_buffer_desc_struct *)0);

  if(!(conn->gtarg_nam == ((struct gss_name_struct *)NULL)))
    gss_release_name(&min_s, &conn->gtarg_nam);

  if(!(conn->ginbuf.length == 0ul))
    gss_release_buffer(&min_s, &conn->ginbuf);

  if(!(conn->goutbuf.length == 0ul))
    gss_release_buffer(&min_s, &conn->goutbuf);

}

// close_SSL
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1549
static void close_SSL(struct pg_conn *conn)
{
  char destroy_needed = (char)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(!(conn->ssl == ((struct ssl_st *)NULL)))
  {
    struct sigpipe_info spinfo;
    destroy_needed = (char)1;
    do
    {
      spinfo.got_epipe = (char)0;
      if(!(conn->sigpipe_so == 0))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = conn->sigpipe_flag != 0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_2)
      {
        signed int return_value_pq_block_sigpipe_1;
        return_value_pq_block_sigpipe_1=pq_block_sigpipe(&spinfo.oldsigmask, &spinfo.sigpipe_pending);
      }

    }
    while((_Bool)0);
    SSL_shutdown(conn->ssl);
    SSL_free(conn->ssl);
    conn->ssl = (struct ssl_st *)(void *)0;
    do
      spinfo.got_epipe = (char)1;
    while((_Bool)0);
    do
    {
      if(!(conn->sigpipe_so == 0))
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = conn->sigpipe_flag != 0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_3)
        pq_reset_sigpipe(&spinfo.oldsigmask, spinfo.sigpipe_pending, spinfo.got_epipe);

    }
    while((_Bool)0);
  }

  if(!(conn->peer == ((struct x509_st *)NULL)))
  {
    X509_free(conn->peer);
    conn->peer = (struct x509_st *)(void *)0;
  }

  if(!(conn->engine == ((struct engine_st *)NULL)))
  {
    ENGINE_finish(conn->engine);
    ENGINE_free(conn->engine);
    conn->engine = (struct engine_st *)(void *)0;
  }

  if(!(destroy_needed == 0))
    pqsecure_destroy();

}

// compareVariables
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 595
static signed int compareVariables(const void *v1, const void *v2)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(((const struct anonymous_21 *)v1)->name, ((const struct anonymous_21 *)v2)->name);
  return return_value_strcmp_1;
}

// connectDBComplete
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1527
static signed int connectDBComplete(struct pg_conn *conn)
{
  enum anonymous_4 flag = (enum anonymous_4)PGRES_POLLING_WRITING;
  signed long int finish_time = (signed long int)-1;
  _Bool tmp_if_expr_1;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)conn->status == CONNECTION_BAD ? (_Bool)1 : (_Bool)0;
  signed int return_value_pqWaitTimed_3;
  signed int return_value_pqWaitTimed_4;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    if(!(conn->connect_timeout == ((char *)NULL)))
    {
      signed int timeout;
      timeout=atoi(conn->connect_timeout);
      if(timeout >= 1)
      {
        if(!(timeout >= 2))
          timeout = 2;

        signed long int return_value_time_2;
        return_value_time_2=time((signed long int *)(void *)0);
        finish_time = return_value_time_2 + (signed long int)timeout;
      }

    }

    while((_Bool)1)
    {
      switch((signed int)flag)
      {
        case PGRES_POLLING_OK:
        {
          resetPQExpBuffer(&conn->errorMessage);
          return 1;
        }
        case PGRES_POLLING_READING:
        {
          return_value_pqWaitTimed_3=pqWaitTimed(1, 0, conn, finish_time);
          if(!(return_value_pqWaitTimed_3 == 0))
          {
            conn->status = (enum anonymous_24)CONNECTION_BAD;
            return 0;
          }

          break;
        }
        case PGRES_POLLING_WRITING:
        {
          return_value_pqWaitTimed_4=pqWaitTimed(0, 1, conn, finish_time);
          if(!(return_value_pqWaitTimed_4 == 0))
          {
            conn->status = (enum anonymous_24)CONNECTION_BAD;
            return 0;
          }

          break;
        }
        default:
        {
          conn->status = (enum anonymous_24)CONNECTION_BAD;
          return 0;
        }
      }
      flag=PQconnectPoll(conn);
    }
  }
}

// connectDBStart
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1385
static signed int connectDBStart(struct pg_conn *conn)
{
  signed int portnum;
  char portstr[1024l];
  struct addrinfo *addrs = (struct addrinfo *)(void *)0;
  struct addrinfo hint;
  const char *node;
  signed int ret;
  signed long int *tmp_post_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_4;
  char *tmp_if_expr_5;
  char *return_value_libpq_gettext_10;
  const char *return_value_gai_strerror_11;
  char *return_value_libpq_gettext_12;
  const char *return_value_gai_strerror_13;
  enum anonymous_4 return_value_PQconnectPoll_14;
  if(conn == ((struct pg_conn *)NULL))
    return 0;

  else
    if(!(conn->options_valid == 0))
    {
      conn->inEnd = 0;
      conn->inCursor = conn->inEnd;
      conn->inStart = conn->inCursor;
      conn->outCount = 0;
      do
      {
        void *_vstart = (void *)&hint;
        signed int _val = 0;
        unsigned long int _len = sizeof(struct addrinfo) /*48ul*/ ;
        if((7ul & _len) == 0ul && (7ul & (unsigned long int)_vstart) == 0ul && _val == 0 && !(_len >= 1025ul))
        {
          signed long int *connectDBStart__1__1__1___start = (signed long int *)_vstart;
          signed long int *_stop = (signed long int *)((char *)connectDBStart__1__1__1___start + (signed long int)_len);
          for( ; !(connectDBStart__1__1__1___start >= _stop); *tmp_post_1 = (signed long int)0)
          {
            tmp_post_1 = connectDBStart__1__1__1___start;
            connectDBStart__1__1__1___start = connectDBStart__1__1__1___start + 1l;
          }
        }

        else
          memset(_vstart, _val, _len);
      }
      while((_Bool)0);
      hint.ai_socktype = 1;
      hint.ai_family = 0;
      if(!(conn->pgport == ((char *)NULL)))
        tmp_if_expr_3 = (signed int)conn->pgport[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
      {
        portnum=atoi(conn->pgport);
        if(portnum >= 65536 || !(portnum >= 1))
        {
          char *return_value_libpq_gettext_2;
          return_value_libpq_gettext_2=libpq_gettext("invalid port number: \"%s\"\n");
          appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2, conn->pgport);
          conn->options_valid = (char)0;
          goto connect_errReturn;
        }

      }

      else
        portnum = 5432;
      snprintf(portstr, sizeof(char [1024l]) /*1024ul*/ , "%d", portnum);
      if(!(conn->pghostaddr == ((char *)NULL)))
        tmp_if_expr_9 = (signed int)conn->pghostaddr[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_9 = (_Bool)0;
      if(tmp_if_expr_9)
      {
        node = conn->pghostaddr;
        hint.ai_family = 0;
        hint.ai_flags = 0x0004;
      }

      else
      {
        if(!(conn->pghost == ((char *)NULL)))
          tmp_if_expr_8 = (signed int)conn->pghost[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_8 = (_Bool)0;
        if(tmp_if_expr_8)
        {
          node = conn->pghost;
          hint.ai_family = 0;
        }

        else
        {
          node = (const char *)(void *)0;
          hint.ai_family = 1;
          if(!(conn->pgunixsocket == ((char *)NULL)))
            tmp_if_expr_4 = (signed int)*conn->pgunixsocket != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
            tmp_if_expr_5 = conn->pgunixsocket;

          else
            tmp_if_expr_5 = "/var/run/postgresql";
          snprintf(portstr, sizeof(char [1024l]) /*1024ul*/ , "%s/.s.PGSQL.%d", tmp_if_expr_5, portnum);
          unsigned long int return_value_strlen_7;
          return_value_strlen_7=strlen(portstr);
          if(return_value_strlen_7 >= sizeof(char [108l]) /*108ul*/ )
          {
            char *return_value_libpq_gettext_6;
            return_value_libpq_gettext_6=libpq_gettext("Unix-domain socket path \"%s\" is too long (maximum %d bytes)\n");
            appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_6, (const void *)portstr, (signed int)(sizeof(char [108l]) /*108ul*/  - (unsigned long int)1));
            conn->options_valid = (char)0;
            goto connect_errReturn;
          }

        }
      }
      ret=pg_getaddrinfo_all(node, portstr, &hint, &addrs);
      if(addrs == ((struct addrinfo *)NULL) || !(ret == 0))
      {
        if(!(node == ((const char *)NULL)))
        {
          return_value_libpq_gettext_10=libpq_gettext("could not translate host name \"%s\" to address: %s\n");
          return_value_gai_strerror_11=gai_strerror(ret);
          appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_10, node, return_value_gai_strerror_11);
        }

        else
        {
          return_value_libpq_gettext_12=libpq_gettext("could not translate Unix-domain socket path \"%s\" to address: %s\n");
          return_value_gai_strerror_13=gai_strerror(ret);
          appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_12, (const void *)portstr, return_value_gai_strerror_13);
        }
        if(!(addrs == ((struct addrinfo *)NULL)))
          pg_freeaddrinfo_all(hint.ai_family, addrs);

        conn->options_valid = (char)0;
        goto connect_errReturn;
      }

      if((signed int)*conn->sslmode == 100)
        conn->allow_ssl_try = (char)0;

      else
        if((signed int)*conn->sslmode == 97)
          conn->wait_ssl_try = (char)1;

      conn->addrlist = addrs;
      conn->addr_cur = addrs;
      conn->addrlist_family = hint.ai_family;
      conn->pversion = (unsigned int)(3 << 16 | 0);
      conn->send_appname = (char)1;
      conn->status = (enum anonymous_24)CONNECTION_NEEDED;
      return_value_PQconnectPoll_14=PQconnectPoll(conn);
      if(!((signed int)return_value_PQconnectPoll_14 == PGRES_POLLING_WRITING))
        goto connect_errReturn;

      return 1;
    }

    else
    {

    connect_errReturn:
      ;
      pqDropConnection(conn);
      conn->status = (enum anonymous_24)CONNECTION_BAD;
      return 0;
    }
}

// connectFailureMessage
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1114
static void connectFailureMessage(struct pg_conn *conn, signed int errorno)
{
  char sebuf[256l];
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_12;
  signed int return_value_strcmp_11;
  char *return_value_libpq_gettext_7;
  char *return_value_pqStrerror_8;
  char *return_value_libpq_gettext_9;
  char *return_value_pqStrerror_10;
  if((signed int)conn->raddr.addr.ss_family == 1)
  {
    char service[1025l];
    pg_getnameinfo_all(&conn->raddr.addr, (signed int)conn->raddr.salen, (char *)(void *)0, 0, service, (signed int)sizeof(char [1025l]) /*1025ul*/ , 2);
    char *return_value_libpq_gettext_1;
    return_value_libpq_gettext_1=libpq_gettext("could not connect to server: %s\n\tIs the server running locally and accepting\n\tconnections on Unix domain socket \"%s\"?\n");
    char *return_value_pqStrerror_2;
    return_value_pqStrerror_2=pqStrerror(errorno, sebuf, sizeof(char [256l]) /*256ul*/ );
    appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1, return_value_pqStrerror_2, (const void *)service);
  }

  else
  {
    char host_addr[1025l];
    const char *displayed_host;
    struct sockaddr_storage *addr = &conn->raddr.addr;
    if(!(conn->pghostaddr == ((char *)NULL)))
      strlcpy(host_addr, conn->pghostaddr, (unsigned long int)1025);

    else
      if((signed int)addr->ss_family == 2)
      {
        char *return_value_inet_net_ntop_3;
        return_value_inet_net_ntop_3=inet_net_ntop(2, (const void *)&((struct sockaddr_in *)addr)->sin_addr.s_addr, 32, host_addr, sizeof(char [1025l]) /*1025ul*/ );
        if(return_value_inet_net_ntop_3 == ((char *)NULL))
          strcpy(host_addr, "???");

      }

      else
        if((signed int)addr->ss_family == 10)
        {
          char *return_value_inet_net_ntop_4;
          return_value_inet_net_ntop_4=inet_net_ntop(10, (const void *)&((struct sockaddr_in6 *)addr)->sin6_addr.__in6_u.__u6_addr8, 128, host_addr, sizeof(char [1025l]) /*1025ul*/ );
          if(return_value_inet_net_ntop_4 == ((char *)NULL))
            strcpy(host_addr, "???");

        }

        else
          strcpy(host_addr, "???");
    if(!(conn->pghostaddr == ((char *)NULL)))
      tmp_if_expr_6 = (signed int)conn->pghostaddr[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_6 = (_Bool)0;
    if(tmp_if_expr_6)
      displayed_host = conn->pghostaddr;

    else
    {
      if(!(conn->pghost == ((char *)NULL)))
        tmp_if_expr_5 = (signed int)conn->pghost[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        displayed_host = conn->pghost;

      else
        displayed_host = "localhost";
    }
    if(conn->pghostaddr == ((char *)NULL))
    {
      if(conn->pghost == ((char *)NULL))
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        return_value_strcmp_11=strcmp(conn->pghost, host_addr);
        tmp_if_expr_12 = return_value_strcmp_11 != 0 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_13 = tmp_if_expr_12 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_13 = (_Bool)0;
    if(tmp_if_expr_13)
    {
      return_value_libpq_gettext_7=libpq_gettext("could not connect to server: %s\n\tIs the server running on host \"%s\" (%s) and accepting\n\tTCP/IP connections on port %s?\n");
      return_value_pqStrerror_8=pqStrerror(errorno, sebuf, sizeof(char [256l]) /*256ul*/ );
      appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_7, return_value_pqStrerror_8, displayed_host, (const void *)host_addr, conn->pgport);
    }

    else
    {
      return_value_libpq_gettext_9=libpq_gettext("could not connect to server: %s\n\tIs the server running on host \"%s\" and accepting\n\tTCP/IP connections on port %s?\n");
      return_value_pqStrerror_10=pqStrerror(errorno, sebuf, sizeof(char [256l]) /*256ul*/ );
      appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_9, return_value_pqStrerror_10, displayed_host, conn->pgport);
    }
  }
}

// connectNoDelay
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1086
static signed int connectNoDelay(struct pg_conn *conn)
{
  signed int on = 1;
  signed int return_value_setsockopt_4;
  return_value_setsockopt_4=setsockopt(conn->sock, 6, 1, (const void *)(char *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_setsockopt_4 >= 0))
  {
    char sebuf[256l];
    char *return_value_libpq_gettext_1;
    return_value_libpq_gettext_1=libpq_gettext("could not set socket to TCP no delay mode: %s\n");
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_pqStrerror_3;
    return_value_pqStrerror_3=pqStrerror(*return_value___errno_location_2, sebuf, sizeof(char [256l]) /*256ul*/ );
    appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1, return_value_pqStrerror_3);
    return 0;
  }

  return 1;
}

// connectOptions1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 723
static char connectOptions1(struct pg_conn *conn, const char *conninfo)
{
  struct _PQconninfoOption *connOptions;
  connOptions=parse_connection_string(conninfo, &conn->errorMessage, (char)1);
  if(connOptions == ((struct _PQconninfoOption *)NULL))
  {
    conn->status = (enum anonymous_24)CONNECTION_BAD;
    return (char)0;
  }

  else
  {
    char return_value_fillPGconn_1;
    return_value_fillPGconn_1=fillPGconn(conn, connOptions);
    if(return_value_fillPGconn_1 == 0)
    {
      conn->status = (enum anonymous_24)CONNECTION_BAD;
      PQconninfoFree(connOptions);
      return (char)0;
    }

    else
    {
      PQconninfoFree(connOptions);
      return (char)1;
    }
  }
}

// connectOptions2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 765
static char connectOptions2(struct pg_conn *conn)
{
  _Bool tmp_if_expr_1;
  if(conn->pguser == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)conn->pguser[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_13;
  if(tmp_if_expr_1)
  {
    if(!(conn->pguser == ((char *)NULL)))
      free((void *)conn->pguser);

    conn->pguser=pg_fe_getauthname(&conn->errorMessage);
    if(!(conn->pguser == ((char *)NULL)))
      goto __CPROVER_DUMP_L4;

    conn->status = (enum anonymous_24)CONNECTION_BAD;
    return (char)0;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    if(conn->dbName == ((char *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)conn->dbName[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      if(!(conn->dbName == ((char *)NULL)))
        free((void *)conn->dbName);

      conn->dbName=strdup(conn->pguser);
      if(conn->dbName == ((char *)NULL))
        goto oom_error;

    }

    if(conn->pgpass == ((char *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)conn->pgpass[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      if(!(conn->pgpass == ((char *)NULL)))
        free((void *)conn->pgpass);

      conn->pgpass=PasswordFromFile(conn->pghost, conn->pgport, conn->dbName, conn->pguser);
      if(conn->pgpass == ((char *)NULL))
      {
        conn->pgpass=strdup("");
        if(conn->pgpass == ((char *)NULL))
          goto oom_error;

      }

      else
        conn->dot_pgpass_used = (char)1;
    }

    if(!(conn->pghost == ((char *)NULL)))
    {
      if((signed int)*conn->pghost == 47)
      {
        if(!(conn->pgunixsocket == ((char *)NULL)))
          free((void *)conn->pgunixsocket);

        conn->pgunixsocket = conn->pghost;
        conn->pghost = (char *)(void *)0;
      }

    }

    if(!(conn->sslmode == ((char *)NULL)))
    {
      signed int return_value_strcmp_10;
      return_value_strcmp_10=strcmp(conn->sslmode, "disable");
      if(!(return_value_strcmp_10 == 0))
      {
        return_value_strcmp_9=strcmp(conn->sslmode, "allow");
        if(!(return_value_strcmp_9 == 0))
        {
          return_value_strcmp_8=strcmp(conn->sslmode, "prefer");
          if(!(return_value_strcmp_8 == 0))
          {
            return_value_strcmp_7=strcmp(conn->sslmode, "require");
            if(!(return_value_strcmp_7 == 0))
            {
              return_value_strcmp_6=strcmp(conn->sslmode, "verify-ca");
              if(!(return_value_strcmp_6 == 0))
              {
                return_value_strcmp_5=strcmp(conn->sslmode, "verify-full");
                if(!(return_value_strcmp_5 == 0))
                {
                  conn->status = (enum anonymous_24)CONNECTION_BAD;
                  char *return_value_libpq_gettext_4;
                  return_value_libpq_gettext_4=libpq_gettext("invalid sslmode value: \"%s\"\n");
                  printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_4, conn->sslmode);
                  return (char)0;
                }

              }

            }

          }

        }

      }

    }

    else
    {
      conn->sslmode=strdup("prefer");
      if(conn->sslmode == ((char *)NULL))
        goto oom_error;

    }
    if(!(conn->client_encoding_initial == ((char *)NULL)))
    {
      return_value_strcmp_13=strcmp(conn->client_encoding_initial, "auto");
      if(return_value_strcmp_13 == 0)
      {
        free((void *)conn->client_encoding_initial);
        signed int return_value_pg_get_encoding_from_locale_11;
        return_value_pg_get_encoding_from_locale_11=pg_get_encoding_from_locale((const char *)(void *)0, (char)1);
        const char *return_value_pg_encoding_to_char_12;
        return_value_pg_encoding_to_char_12=pg_encoding_to_char(return_value_pg_get_encoding_from_locale_11);
        conn->client_encoding_initial=strdup(return_value_pg_encoding_to_char_12);
        if(conn->client_encoding_initial == ((char *)NULL))
          goto oom_error;

      }

    }

    conn->options_valid = (char)1;
    return (char)1;

  oom_error:
    ;
    conn->status = (enum anonymous_24)CONNECTION_BAD;
    char *return_value_libpq_gettext_14;
    return_value_libpq_gettext_14=libpq_gettext("out of memory\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_14);
    return (char)0;
  }
}

// conninfo_add_defaults
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4570
static char conninfo_add_defaults(struct _PQconninfoOption *options, struct PQExpBufferData *errorMessage)
{
  struct _PQconninfoOption *option;
  char *tmp;
  signed int return_value_parseServiceInfo_1;
  return_value_parseServiceInfo_1=parseServiceInfo(options, errorMessage);
  char *return_value_libpq_gettext_2;
  char *return_value_libpq_gettext_3;
  if(!(return_value_parseServiceInfo_1 == 0))
  {
    if(errorMessage == ((struct PQExpBufferData *)NULL))
      goto __CPROVER_DUMP_L1;

    return (char)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    option = options;
    for( ; !(option->keyword == ((char *)NULL)); option = option + 1l)
      if(option->val == ((char *)NULL))
      {
        if(!(option->envvar == ((char *)NULL)))
        {
          tmp=getenv(option->envvar);
          if(tmp == ((char *)NULL))
            goto __CPROVER_DUMP_L5;

          option->val=strdup(tmp);
          if(option->val == ((char *)NULL))
          {
            if(!(errorMessage == ((struct PQExpBufferData *)NULL)))
            {
              return_value_libpq_gettext_2=libpq_gettext("out of memory\n");
              printfPQExpBuffer(errorMessage, return_value_libpq_gettext_2);
            }

            return (char)0;
          }

        }

        else
        {

        __CPROVER_DUMP_L5:
          ;
          if(!(option->compiled == ((char *)NULL)))
          {
            option->val=strdup(option->compiled);
            if(option->val == ((char *)NULL))
            {
              if(!(errorMessage == ((struct PQExpBufferData *)NULL)))
              {
                return_value_libpq_gettext_3=libpq_gettext("out of memory\n");
                printfPQExpBuffer(errorMessage, return_value_libpq_gettext_3);
              }

              return (char)0;
            }

          }

          else
          {
            signed int return_value_strcmp_4;
            return_value_strcmp_4=strcmp(option->keyword, "user");
            if(return_value_strcmp_4 == 0)
              option->val=pg_fe_getauthname((struct PQExpBufferData *)(void *)0);

          }
        }
      }

    return (char)1;
  }
}

// conninfo_array_parse
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4407
static struct _PQconninfoOption * conninfo_array_parse(const char * const *keywords, const char * const *values, struct PQExpBufferData *errorMessage, char use_defaults, signed int expand_dbname)
{
  struct _PQconninfoOption *options;
  struct _PQconninfoOption *dbname_options = (struct _PQconninfoOption *)(void *)0;
  struct _PQconninfoOption *option;
  signed int i = 0;
  while(!(expand_dbname == 0))
  {
    if(keywords[(signed long int)i] == ((const char *)NULL))
      break;

    const char *pname = keywords[(signed long int)i];
    const char *conninfo_array_parse__1__1__pvalue = values[(signed long int)i];
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(pname, "dbname");
    if(return_value_strcmp_2 == 0)
    {
      if(!(conninfo_array_parse__1__1__pvalue == ((const char *)NULL)))
      {
        char return_value_recognized_connection_string_1;
        return_value_recognized_connection_string_1=recognized_connection_string(conninfo_array_parse__1__1__pvalue);
        if(!(return_value_recognized_connection_string_1 == 0))
        {
          dbname_options=parse_connection_string(conninfo_array_parse__1__1__pvalue, errorMessage, (char)0);
          if(dbname_options == ((struct _PQconninfoOption *)NULL))
            return (struct _PQconninfoOption *)(void *)0;

        }

        break;
      }

    }

    i = i + 1;
  }
  options=conninfo_init(errorMessage);
  if(options == ((struct _PQconninfoOption *)NULL))
  {
    PQconninfoFree(dbname_options);
    return (struct _PQconninfoOption *)(void *)0;
  }

  else
  {
    i = 0;
    while(!(keywords[(signed long int)i] == ((const char *)NULL)))
    {
      const char *conninfo_array_parse__1__3__pname = keywords[(signed long int)i];
      const char *pvalue = values[(signed long int)i];
      if(!(pvalue == ((const char *)NULL)))
      {
        if(!((signed int)*pvalue == 0))
        {
          option = options;
          for( ; !(option->keyword == ((char *)NULL)); option = option + 1l)
          {
            signed int return_value_strcmp_3;
            return_value_strcmp_3=strcmp(option->keyword, conninfo_array_parse__1__3__pname);
            if(return_value_strcmp_3 == 0)
              break;

          }
          if(option->keyword == ((char *)NULL))
          {
            char *return_value_libpq_gettext_4;
            return_value_libpq_gettext_4=libpq_gettext("invalid connection option \"%s\"\n");
            printfPQExpBuffer(errorMessage, return_value_libpq_gettext_4, conninfo_array_parse__1__3__pname);
            PQconninfoFree(options);
            PQconninfoFree(dbname_options);
            return (struct _PQconninfoOption *)(void *)0;
          }

          signed int return_value_strcmp_8;
          return_value_strcmp_8=strcmp(conninfo_array_parse__1__3__pname, "dbname");
          if(return_value_strcmp_8 == 0 && !(dbname_options == ((struct _PQconninfoOption *)NULL)))
          {
            struct _PQconninfoOption *str_option = dbname_options;
            for( ; !(str_option->keyword == ((char *)NULL)); str_option = str_option + 1l)
              if(!(str_option->val == ((char *)NULL)))
              {
                signed int k = 0;
                for( ; !((options + (signed long int)k)->keyword == ((char *)NULL)); k = k + 1)
                {
                  signed int return_value_strcmp_6;
                  return_value_strcmp_6=strcmp((options + (signed long int)k)->keyword, str_option->keyword);
                  if(return_value_strcmp_6 == 0)
                  {
                    if(!((options + (signed long int)k)->val == ((char *)NULL)))
                      free((void *)(options + (signed long int)k)->val);

                    (options + (signed long int)k)->val=strdup(str_option->val);
                    if((options + (signed long int)k)->val == ((char *)NULL))
                    {
                      char *return_value_libpq_gettext_5;
                      return_value_libpq_gettext_5=libpq_gettext("out of memory\n");
                      printfPQExpBuffer(errorMessage, return_value_libpq_gettext_5);
                      PQconninfoFree(options);
                      PQconninfoFree(dbname_options);
                      return (struct _PQconninfoOption *)(void *)0;
                    }

                    break;
                  }

                }
              }

            PQconninfoFree(dbname_options);
            dbname_options = (struct _PQconninfoOption *)(void *)0;
          }

          else
          {
            if(!(option->val == ((char *)NULL)))
              free((void *)option->val);

            option->val=strdup(pvalue);
            if(option->val == ((char *)NULL))
            {
              char *return_value_libpq_gettext_7;
              return_value_libpq_gettext_7=libpq_gettext("out of memory\n");
              printfPQExpBuffer(errorMessage, return_value_libpq_gettext_7);
              PQconninfoFree(options);
              PQconninfoFree(dbname_options);
              return (struct _PQconninfoOption *)(void *)0;
            }

          }
        }

      }

      i = i + 1;
    }
    PQconninfoFree(dbname_options);
    if(!(use_defaults == 0))
    {
      char return_value_conninfo_add_defaults_9;
      return_value_conninfo_add_defaults_9=conninfo_add_defaults(options, errorMessage);
      if(return_value_conninfo_add_defaults_9 == 0)
      {
        PQconninfoFree(options);
        return (struct _PQconninfoOption *)(void *)0;
      }

    }

    return options;
  }
}

// conninfo_find
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5240
static struct _PQconninfoOption * conninfo_find(struct _PQconninfoOption *connOptions, const char *keyword)
{
  struct _PQconninfoOption *option = connOptions;
  for( ; !(option->keyword == ((char *)NULL)); option = option + 1l)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(option->keyword, keyword);
    if(return_value_strcmp_1 == 0)
      return option;

  }
  return (struct _PQconninfoOption *)(void *)0;
}

// conninfo_getval
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5149
static const char * conninfo_getval(struct _PQconninfoOption *connOptions, const char *keyword)
{
  struct _PQconninfoOption *option;
  option=conninfo_find(connOptions, keyword);
  char *tmp_if_expr_1;
  if(!(option == ((struct _PQconninfoOption *)NULL)))
    tmp_if_expr_1 = option->val;

  else
    tmp_if_expr_1 = (char *)(void *)0;
  return tmp_if_expr_1;
}

// conninfo_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4143
static struct _PQconninfoOption * conninfo_init(struct PQExpBufferData *errorMessage)
{
  struct _PQconninfoOption *options;
  struct _PQconninfoOption *opt_dest;
  const struct _internalPQconninfoOption *cur_opt;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((sizeof(struct _PQconninfoOption) /*56ul*/  * sizeof(const struct _internalPQconninfoOption [28l]) /*1792ul*/ ) / sizeof(const struct _internalPQconninfoOption) /*64ul*/ );
  options = (struct _PQconninfoOption *)return_value_malloc_1;
  if(options == ((struct _PQconninfoOption *)NULL))
  {
    char *return_value_libpq_gettext_2;
    return_value_libpq_gettext_2=libpq_gettext("out of memory\n");
    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_2);
    return (struct _PQconninfoOption *)(void *)0;
  }

  opt_dest = options;
  cur_opt = PQconninfoOptions;
  for( ; !(cur_opt->keyword == ((char *)NULL)); cur_opt = cur_opt + 1l)
  {
    memcpy((void *)opt_dest, (const void *)cur_opt, sizeof(struct _PQconninfoOption) /*56ul*/ );
    opt_dest = opt_dest + 1l;
  }
  signed long int *tmp_post_3;
  do
  {
    void *_vstart = (void *)opt_dest;
    signed int _val = 0;
    unsigned long int _len = sizeof(struct _PQconninfoOption) /*56ul*/ ;
    if((7ul & _len) == 0ul && (7ul & (unsigned long int)_vstart) == 0ul && _val == 0 && !(_len >= 1025ul))
    {
      signed long int *conninfo_init__1__3__1___start = (signed long int *)_vstart;
      signed long int *_stop = (signed long int *)((char *)conninfo_init__1__3__1___start + (signed long int)_len);
      for( ; !(conninfo_init__1__3__1___start >= _stop); *tmp_post_3 = (signed long int)0)
      {
        tmp_post_3 = conninfo_init__1__3__1___start;
        conninfo_init__1__3__1___start = conninfo_init__1__3__1___start + 1l;
      }
    }

    else
      memset(_vstart, _val, _len);
  }
  while((_Bool)0);
  return options;
}

// conninfo_parse
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4233
static struct _PQconninfoOption * conninfo_parse(const char *conninfo, struct PQExpBufferData *errorMessage, char use_defaults)
{
  char *pname;
  char *pval;
  char *buf;
  char *cp;
  char *cp2;
  struct _PQconninfoOption *options;
  options=conninfo_init(errorMessage);
  char *tmp_post_3;
  char *tmp_post_7;
  char *tmp_post_9;
  char *tmp_post_11;
  char *tmp_post_12;
  char *tmp_post_13;
  char *tmp_post_14;
  char *tmp_post_16;
  char *tmp_post_17;
  char *tmp_post_18;
  char *tmp_post_19;
  if(options == ((struct _PQconninfoOption *)NULL))
    return (struct _PQconninfoOption *)(void *)0;

  else
  {
    buf=strdup(conninfo);
    if(buf == ((char *)NULL))
    {
      char *return_value_libpq_gettext_1;
      return_value_libpq_gettext_1=libpq_gettext("out of memory\n");
      printfPQExpBuffer(errorMessage, return_value_libpq_gettext_1);
      PQconninfoFree(options);
      return (struct _PQconninfoOption *)(void *)0;
    }

    cp = buf;
    while(!(*cp == 0))
    {
      const unsigned short int **return_value___ctype_b_loc_2;
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)*cp]) == 0))
        cp = cp + 1l;

      else
      {
        pname = cp;
        while(!(*cp == 0))
        {
          if((signed int)*cp == 61)
            break;

          const unsigned short int **return_value___ctype_b_loc_5;
          return_value___ctype_b_loc_5=__ctype_b_loc();
          if(!((8192 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)(unsigned char)*cp]) == 0))
          {
            tmp_post_3 = cp;
            cp = cp + 1l;
            *tmp_post_3 = (char)0;
            while(!(*cp == 0))
            {
              const unsigned short int **return_value___ctype_b_loc_4;
              return_value___ctype_b_loc_4=__ctype_b_loc();
              if((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)*cp]) == 0)
                break;

              cp = cp + 1l;
            }
            break;
          }

          cp = cp + 1l;
        }
        if(!((signed int)*cp == 61))
        {
          char *return_value_libpq_gettext_6;
          return_value_libpq_gettext_6=libpq_gettext("missing \"=\" after \"%s\" in connection info string\n");
          printfPQExpBuffer(errorMessage, return_value_libpq_gettext_6, pname);
          PQconninfoFree(options);
          free((void *)buf);
          return (struct _PQconninfoOption *)(void *)0;
        }

        tmp_post_7 = cp;
        cp = cp + 1l;
        *tmp_post_7 = (char)0;
        while(!(*cp == 0))
        {
          const unsigned short int **return_value___ctype_b_loc_8;
          return_value___ctype_b_loc_8=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_8)[(signed long int)(signed int)(unsigned char)*cp]) == 0)
            break;

          cp = cp + 1l;
        }
        pval = cp;
        if(!((signed int)*cp == 39))
        {
          cp2 = pval;
          while(!(*cp == 0))
          {
            const unsigned short int **return_value___ctype_b_loc_10;
            return_value___ctype_b_loc_10=__ctype_b_loc();
            if(!((8192 & (signed int)(*return_value___ctype_b_loc_10)[(signed long int)(signed int)(unsigned char)*cp]) == 0))
            {
              tmp_post_9 = cp;
              cp = cp + 1l;
              *tmp_post_9 = (char)0;
              break;
            }

            if((signed int)*cp == 92)
            {
              cp = cp + 1l;
              if(!((signed int)*cp == 0))
              {
                tmp_post_11 = cp2;
                cp2 = cp2 + 1l;
                tmp_post_12 = cp;
                cp = cp + 1l;
                *tmp_post_11 = *tmp_post_12;
              }

            }

            else
            {
              tmp_post_13 = cp2;
              cp2 = cp2 + 1l;
              tmp_post_14 = cp;
              cp = cp + 1l;
              *tmp_post_13 = *tmp_post_14;
            }
          }
          *cp2 = (char)0;
        }

        else
        {
          cp2 = pval;
          cp = cp + 1l;
          while((_Bool)1)
          {
            if((signed int)*cp == 0)
            {
              char *return_value_libpq_gettext_15;
              return_value_libpq_gettext_15=libpq_gettext("unterminated quoted string in connection info string\n");
              printfPQExpBuffer(errorMessage, return_value_libpq_gettext_15);
              PQconninfoFree(options);
              free((void *)buf);
              return (struct _PQconninfoOption *)(void *)0;
            }

            if((signed int)*cp == 92)
            {
              cp = cp + 1l;
              if(!((signed int)*cp == 0))
              {
                tmp_post_16 = cp2;
                cp2 = cp2 + 1l;
                tmp_post_17 = cp;
                cp = cp + 1l;
                *tmp_post_16 = *tmp_post_17;
              }

            }

            else
            {
              if((signed int)*cp == 39)
              {
                *cp2 = (char)0;
                cp = cp + 1l;
                break;
              }

              tmp_post_18 = cp2;
              cp2 = cp2 + 1l;
              tmp_post_19 = cp;
              cp = cp + 1l;
              *tmp_post_18 = *tmp_post_19;
            }
          }
        }
        struct _PQconninfoOption *return_value_conninfo_storeval_20;
        return_value_conninfo_storeval_20=conninfo_storeval(options, pname, pval, errorMessage, (char)0, (char)0);
        if(return_value_conninfo_storeval_20 == ((struct _PQconninfoOption *)NULL))
        {
          PQconninfoFree(options);
          free((void *)buf);
          return (struct _PQconninfoOption *)(void *)0;
        }

      }
    }
    free((void *)buf);
    if(!(use_defaults == 0))
    {
      char return_value_conninfo_add_defaults_21;
      return_value_conninfo_add_defaults_21=conninfo_add_defaults(options, errorMessage);
      if(return_value_conninfo_add_defaults_21 == 0)
      {
        PQconninfoFree(options);
        return (struct _PQconninfoOption *)(void *)0;
      }

    }

    return options;
  }
}

// conninfo_storeval
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5175
static struct _PQconninfoOption * conninfo_storeval(struct _PQconninfoOption *connOptions, const char *keyword, const char *value, struct PQExpBufferData *errorMessage, char ignoreMissing, char uri_decode)
{
  struct _PQconninfoOption *option;
  char *value_copy;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(keyword, "requiressl");
  if(return_value_strcmp_1 == 0)
  {
    keyword = "sslmode";
    if((signed int)*value == 49)
      value = "require";

    else
      value = "prefer";
  }

  option=conninfo_find(connOptions, keyword);
  char *return_value_libpq_gettext_2;
  if(option == ((struct _PQconninfoOption *)NULL))
  {
    if(ignoreMissing == 0)
    {
      return_value_libpq_gettext_2=libpq_gettext("invalid connection option \"%s\"\n");
      printfPQExpBuffer(errorMessage, return_value_libpq_gettext_2, keyword);
    }

    return (struct _PQconninfoOption *)(void *)0;
  }

  if(!(uri_decode == 0))
  {
    value_copy=conninfo_uri_decode(value, errorMessage);
    if(value_copy == ((char *)NULL))
      return (struct _PQconninfoOption *)(void *)0;

  }

  else
  {
    value_copy=strdup(value);
    if(value_copy == ((char *)NULL))
    {
      char *return_value_libpq_gettext_3;
      return_value_libpq_gettext_3=libpq_gettext("out of memory\n");
      printfPQExpBuffer(errorMessage, return_value_libpq_gettext_3);
      return (struct _PQconninfoOption *)(void *)0;
    }

  }
  if(!(option->val == ((char *)NULL)))
    free((void *)option->val);

  option->val = value_copy;
  return option;
}

// conninfo_uri_decode
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5060
static char * conninfo_uri_decode(const char *str, struct PQExpBufferData *errorMessage)
{
  char *buf;
  char *p;
  const char *q = str;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(return_value_strlen_1 + (unsigned long int)1);
  buf = (char *)return_value_malloc_2;
  if(buf == ((char *)NULL))
  {
    char *return_value_libpq_gettext_3;
    return_value_libpq_gettext_3=libpq_gettext("out of memory\n");
    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_3);
    return (char *)(void *)0;
  }

  p = buf;
  char *tmp_post_4;
  const char *tmp_post_5;
  const char *tmp_post_7;
  _Bool tmp_if_expr_11;
  const char *tmp_post_9;
  char return_value_get_hexdigit_10;
  char *tmp_post_13;
  while((_Bool)1)
    if(!((signed int)*q == 37))
    {
      tmp_post_4 = p;
      p = p + 1l;
      tmp_post_5 = q;
      q = q + 1l;
      *tmp_post_4 = *tmp_post_5;
      if(*tmp_post_4 == 0)
        goto __CPROVER_DUMP_L9;

    }

    else
    {
      signed int hi;
      signed int lo;
      signed int c;
      q = q + 1l;
      tmp_post_7 = q;
      q = q + 1l;
      char return_value_get_hexdigit_8;
      return_value_get_hexdigit_8=get_hexdigit(*tmp_post_7, &hi);
      if(!(return_value_get_hexdigit_8 == 0))
      {
        tmp_post_9 = q;
        q = q + 1l;
        return_value_get_hexdigit_10=get_hexdigit(*tmp_post_9, &lo);
        tmp_if_expr_11 = return_value_get_hexdigit_10 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_11 = (_Bool)0;
      if(!tmp_if_expr_11)
      {
        char *return_value_libpq_gettext_6;
        return_value_libpq_gettext_6=libpq_gettext("invalid percent-encoded token: \"%s\"\n");
        printfPQExpBuffer(errorMessage, return_value_libpq_gettext_6, str);
        free((void *)buf);
        return (char *)(void *)0;
      }

      c = hi << 4 | lo;
      if(c == 0)
      {
        char *return_value_libpq_gettext_12;
        return_value_libpq_gettext_12=libpq_gettext("forbidden value %%00 in percent-encoded value: \"%s\"\n");
        printfPQExpBuffer(errorMessage, return_value_libpq_gettext_12, str);
        free((void *)buf);
        return (char *)(void *)0;
      }

      tmp_post_13 = p;
      p = p + 1l;
      *tmp_post_13 = (char)c;
    }

__CPROVER_DUMP_L9:
  ;
  return buf;
}

// conninfo_uri_parse
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4651
static struct _PQconninfoOption * conninfo_uri_parse(const char *uri, struct PQExpBufferData *errorMessage, char use_defaults)
{
  struct _PQconninfoOption *options;
  options=conninfo_init(errorMessage);
  if(options == ((struct _PQconninfoOption *)NULL))
    return (struct _PQconninfoOption *)(void *)0;

  else
  {
    char return_value_conninfo_uri_parse_options_1;
    return_value_conninfo_uri_parse_options_1=conninfo_uri_parse_options(options, uri, errorMessage);
    if(return_value_conninfo_uri_parse_options_1 == 0)
    {
      PQconninfoFree(options);
      return (struct _PQconninfoOption *)(void *)0;
    }

    else
    {
      if(!(use_defaults == 0))
      {
        char return_value_conninfo_add_defaults_2;
        return_value_conninfo_add_defaults_2=conninfo_add_defaults(options, errorMessage);
        if(return_value_conninfo_add_defaults_2 == 0)
        {
          PQconninfoFree(options);
          return (struct _PQconninfoOption *)(void *)0;
        }

      }

      return options;
    }
  }
}

// conninfo_uri_parse_options
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4701
static char conninfo_uri_parse_options(struct _PQconninfoOption *options, const char *uri, struct PQExpBufferData *errorMessage)
{
  signed int prefix_len;
  char *p;
  char *buf;
  char *start;
  char prevchar = (char)0;
  char *user = (char *)(void *)0;
  char *host = (char *)(void *)0;
  char retval = (char)0;
  buf=strdup(uri);
  if(buf == ((char *)NULL))
  {
    char *return_value_libpq_gettext_1;
    return_value_libpq_gettext_1=libpq_gettext("out of memory\n");
    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_1);
    return (char)0;
  }

  start = buf;
  prefix_len=uri_prefix_length(uri);
  if(prefix_len == 0)
  {
    char *return_value_libpq_gettext_2;
    return_value_libpq_gettext_2=libpq_gettext("invalid URI propagated to internal parser routine: \"%s\"\n");
    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_2, uri);
    goto cleanup;
  }

  start = start + (signed long int)prefix_len;
  p = start;
  for( ; !(*p == 0); p = p + 1l)
  {
    if((signed int)*p == 64)
      break;

    if((signed int)*p == 47)
      break;

  }
  struct _PQconninfoOption *return_value_conninfo_storeval_3;
  struct _PQconninfoOption *return_value_conninfo_storeval_4;
  if((signed int)*p == 64)
  {
    user = start;
    p = user;
    for( ; !((signed int)*p == 58); p = p + 1l)
      if((signed int)*p == 64)
        break;

    prevchar = *p;
    *p = (char)0;
    if(!(*user == 0))
    {
      return_value_conninfo_storeval_3=conninfo_storeval(options, "user", user, errorMessage, (char)0, (char)1);
      if(return_value_conninfo_storeval_3 == ((struct _PQconninfoOption *)NULL))
        goto cleanup;

    }

    if((signed int)prevchar == 58)
    {
      const char *password = p + (signed long int)1;
      for( ; !((signed int)*p == 64); p = p + 1l)
        ;
      *p = (char)0;
      if(!(*password == 0))
      {
        return_value_conninfo_storeval_4=conninfo_storeval(options, "password", password, errorMessage, (char)0, (char)1);
        if(return_value_conninfo_storeval_4 == ((struct _PQconninfoOption *)NULL))
          goto cleanup;

      }

    }

    p = p + 1l;
  }

  else
    p = start;
  char *tmp_post_7;
  if((signed int)*p == 91)
  {
    p = p + 1l;
    host = p;
    for( ; !(*p == 0); p = p + 1l)
      if((signed int)*p == 93)
        break;

    if(*p == 0)
    {
      char *return_value_libpq_gettext_5;
      return_value_libpq_gettext_5=libpq_gettext("end of string reached when looking for matching \"]\" in IPv6 host address in URI: \"%s\"\n");
      printfPQExpBuffer(errorMessage, return_value_libpq_gettext_5, uri);
      goto cleanup;
    }

    if(p == host)
    {
      char *return_value_libpq_gettext_6;
      return_value_libpq_gettext_6=libpq_gettext("IPv6 host address may not be empty in URI: \"%s\"\n");
      printfPQExpBuffer(errorMessage, return_value_libpq_gettext_6, uri);
      goto cleanup;
    }

    tmp_post_7 = p;
    p = p + 1l;
    *tmp_post_7 = (char)0;
    if(!(*p == 0))
    {
      if(!((signed int)*p == 58))
      {
        if(!((signed int)*p == 47))
        {
          if(!((signed int)*p == 63))
          {
            char *return_value_libpq_gettext_8;
            return_value_libpq_gettext_8=libpq_gettext("unexpected character \"%c\" at position %d in URI (expected \":\" or \"/\"): \"%s\"\n");
            printfPQExpBuffer(errorMessage, return_value_libpq_gettext_8, *p, (signed int)((p - buf) + (signed long int)1), uri);
            goto cleanup;
          }

        }

      }

    }

  }

  else
  {
    host = p;
    for( ; !(*p == 0); p = p + 1l)
    {
      if((signed int)*p == 58)
        break;

      if((signed int)*p == 47)
        break;

      if((signed int)*p == 63)
        break;

    }
  }
  prevchar = *p;
  *p = (char)0;
  struct _PQconninfoOption *return_value_conninfo_storeval_9;
  if(!(*host == 0))
  {
    return_value_conninfo_storeval_9=conninfo_storeval(options, "host", host, errorMessage, (char)0, (char)1);
    if(return_value_conninfo_storeval_9 == ((struct _PQconninfoOption *)NULL))
      goto cleanup;

  }

  struct _PQconninfoOption *return_value_conninfo_storeval_10;
  if((signed int)prevchar == 58)
  {
    const char *port;
    p = p + 1l;
    port = p;
    for( ; !(*p == 0); p = p + 1l)
    {
      if((signed int)*p == 47)
        break;

      if((signed int)*p == 63)
        break;

    }
    prevchar = *p;
    *p = (char)0;
    if(!(*port == 0))
    {
      return_value_conninfo_storeval_10=conninfo_storeval(options, "port", port, errorMessage, (char)0, (char)1);
      if(return_value_conninfo_storeval_10 == ((struct _PQconninfoOption *)NULL))
        goto cleanup;

    }

  }

  struct _PQconninfoOption *return_value_conninfo_storeval_11;
  if(!(prevchar == 0) && !((signed int)prevchar == 63))
  {
    const char *dbname;
    p = p + 1l;
    dbname = p;
    for( ; !(*p == 0); p = p + 1l)
      if((signed int)*p == 63)
        break;

    prevchar = *p;
    *p = (char)0;
    if(!(*dbname == 0))
    {
      return_value_conninfo_storeval_11=conninfo_storeval(options, "dbname", dbname, errorMessage, (char)0, (char)1);
      if(return_value_conninfo_storeval_11 == ((struct _PQconninfoOption *)NULL))
        goto cleanup;

    }

  }

  if(!(prevchar == 0))
  {
    p = p + 1l;
    char return_value_conninfo_uri_parse_params_12;
    return_value_conninfo_uri_parse_params_12=conninfo_uri_parse_params(p, options, errorMessage);
    if(return_value_conninfo_uri_parse_params_12 == 0)
      goto cleanup;

  }

  retval = (char)1;

cleanup:
  ;
  free((void *)buf);
  return retval;
}

// conninfo_uri_parse_params
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4912
static char conninfo_uri_parse_params(char *params, struct _PQconninfoOption *connOptions, struct PQExpBufferData *errorMessage)
{
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_4;
  while(!(*params == 0))
  {
    char *keyword = params;
    char *value = (char *)(void *)0;
    char *p = params;
    char malloced = (char)0;
    while((_Bool)1)
      if((signed int)*p == 61)
      {
        if(!(value == ((char *)NULL)))
        {
          char *return_value_libpq_gettext_1;
          return_value_libpq_gettext_1=libpq_gettext("extra key/value separator \"=\" in URI query parameter: \"%s\"\n");
          printfPQExpBuffer(errorMessage, return_value_libpq_gettext_1, params);
          return (char)0;
        }

        *p = (char)0;
        p = p + 1l;
        value = p;
      }

      else
      {
        if((signed int)*p == 38)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (signed int)*p == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_3)
        {
          char prevchar = *p;
          *p = (char)0;
          if(value == ((char *)NULL))
          {
            char *return_value_libpq_gettext_2;
            return_value_libpq_gettext_2=libpq_gettext("missing key/value separator \"=\" in URI query parameter: \"%s\"\n");
            printfPQExpBuffer(errorMessage, return_value_libpq_gettext_2, params);
            return (char)0;
          }

          if(!((signed int)prevchar == 0))
            p = p + 1l;

          goto __CPROVER_DUMP_L11;
        }

        else
          p = p + 1l;
      }

  __CPROVER_DUMP_L11:
    ;
    keyword=conninfo_uri_decode(keyword, errorMessage);
    if(keyword == ((char *)NULL))
      return (char)0;

    value=conninfo_uri_decode(value, errorMessage);
    if(value == ((char *)NULL))
    {
      free((void *)keyword);
      return (char)0;
    }

    malloced = (char)1;
    signed int return_value_strcmp_5;
    return_value_strcmp_5=strcmp(keyword, "ssl");
    if(return_value_strcmp_5 == 0)
    {
      return_value_strcmp_4=strcmp(value, "true");
      if(return_value_strcmp_4 == 0)
      {
        free((void *)keyword);
        free((void *)value);
        malloced = (char)0;
        keyword = "sslmode";
        value = "require";
      }

    }

    struct _PQconninfoOption *return_value_conninfo_storeval_7;
    return_value_conninfo_storeval_7=conninfo_storeval(connOptions, keyword, value, errorMessage, (char)1, (char)0);
    if(return_value_conninfo_storeval_7 == ((struct _PQconninfoOption *)NULL))
    {
      if(!(errorMessage->len == 0ul))
      {
        if(!(malloced == 0))
        {
          free((void *)keyword);
          free((void *)value);
        }

        return (char)0;
      }

      char *return_value_libpq_gettext_6;
      return_value_libpq_gettext_6=libpq_gettext("invalid URI query parameter: \"%s\"\n");
      printfPQExpBuffer(errorMessage, return_value_libpq_gettext_6, keyword);
      if(!(malloced == 0))
      {
        free((void *)keyword);
        free((void *)value);
      }

      return (char)0;
    }

    if(!(malloced == 0))
    {
      free((void *)keyword);
      free((void *)value);
    }

    params = p;
  }
  return (char)1;
}

// createPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.c line 73
extern struct PQExpBufferData * createPQExpBuffer(void)
{
  struct PQExpBufferData *res;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct PQExpBufferData) /*24ul*/ );
  res = (struct PQExpBufferData *)return_value_malloc_1;
  if(!(res == ((struct PQExpBufferData *)NULL)))
    initPQExpBuffer(res);

  return res;
}

// createPaddedCopyWithLength
// file md5.c line 36
static unsigned char * createPaddedCopyWithLength(const unsigned char *b, unsigned int *l)
{
  unsigned char *ret;
  unsigned int q;
  unsigned int len;
  unsigned int newLen448;
  unsigned int len_high;
  unsigned int len_low;
  unsigned int tmp_if_expr_1;
  if(b == ((const unsigned char *)NULL))
    tmp_if_expr_1 = (unsigned int)0;

  else
    tmp_if_expr_1 = *l;
  len = tmp_if_expr_1;
  newLen448 = ((len + (unsigned int)64) - len % (unsigned int)64) - (unsigned int)8;
  if(len >= newLen448)
    newLen448 = newLen448 + (unsigned int)64;

  *l = newLen448 + (unsigned int)8;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(unsigned char) /*1ul*/  * (unsigned long int)*l);
  ret = (unsigned char *)return_value_malloc_2;
  unsigned int tmp_post_3;
  unsigned int tmp_post_4;
  unsigned int tmp_post_5;
  unsigned int tmp_post_6;
  unsigned int tmp_post_7;
  unsigned int tmp_post_8;
  unsigned int tmp_post_9;
  if(ret == ((unsigned char *)NULL))
    return (unsigned char *)(void *)0;

  else
  {
    if(!(b == ((const unsigned char *)NULL)))
      memcpy((void *)ret, (const void *)b, sizeof(unsigned char) /*1ul*/  * (unsigned long int)len);

    ret[(signed long int)len] = (unsigned char)0x80;
    q = len + (unsigned int)1;
    for( ; !(q >= newLen448); q = q + 1u)
      ret[(signed long int)q] = (unsigned char)0x00;
    len_low = len;
    len_high = len >> 29;
    len_low = len_low << 3;
    q = newLen448;
    tmp_post_3 = q;
    q = q + 1u;
    ret[(signed long int)tmp_post_3] = (unsigned char)(len_low & (unsigned int)0xff);
    len_low = len_low >> 8;
    tmp_post_4 = q;
    q = q + 1u;
    ret[(signed long int)tmp_post_4] = (unsigned char)(len_low & (unsigned int)0xff);
    len_low = len_low >> 8;
    tmp_post_5 = q;
    q = q + 1u;
    ret[(signed long int)tmp_post_5] = (unsigned char)(len_low & (unsigned int)0xff);
    len_low = len_low >> 8;
    tmp_post_6 = q;
    q = q + 1u;
    ret[(signed long int)tmp_post_6] = (unsigned char)(len_low & (unsigned int)0xff);
    tmp_post_7 = q;
    q = q + 1u;
    ret[(signed long int)tmp_post_7] = (unsigned char)(len_high & (unsigned int)0xff);
    len_high = len_high >> 8;
    tmp_post_8 = q;
    q = q + 1u;
    ret[(signed long int)tmp_post_8] = (unsigned char)(len_high & (unsigned int)0xff);
    len_high = len_high >> 8;
    tmp_post_9 = q;
    q = q + 1u;
    ret[(signed long int)tmp_post_9] = (unsigned char)(len_high & (unsigned int)0xff);
    len_high = len_high >> 8;
    ret[(signed long int)q] = (unsigned char)(len_high & (unsigned int)0xff);
    return ret;
  }
}

// decoct
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/inet_net_ntop.c line 157
static signed int decoct(const unsigned char *src, signed int bytes, char *dst, unsigned long int size)
{
  char *odst = dst;
  char *t;
  signed int b = 1;
  const unsigned char *tmp_post_1;
  char *tmp_post_3;
  for( ; bytes >= b; b = b + 1)
  {
    if(!(size >= 6ul))
      return 0;

    t = dst;
    tmp_post_1 = src;
    src = src + 1l;
    signed int return_value_sprintf_2;
    return_value_sprintf_2=sprintf(dst, "%u", *tmp_post_1);
    dst = dst + (signed long int)(unsigned long int)return_value_sprintf_2;
    if(!(b == bytes))
    {
      tmp_post_3 = dst;
      dst = dst + 1l;
      *tmp_post_3 = (char)46;
      *dst = (char)0;
    }

    size = size - (unsigned long int)(dst - t);
  }
  return (signed int)(dst - odst);
}

// decoct_link1
// file inet_net_ntop.c line 157
static signed int decoct_link1(const unsigned char *src_link1, signed int bytes_link1, char *dst_link1, unsigned long int size_link1)
{
  char *odst_link1 = dst_link1;
  char *t_link1;
  signed int b_link1 = 1;
  const unsigned char *tmp_post_1_link1;
  char *tmp_post_3_link1;
  for( ; bytes_link1 >= b_link1; b_link1 = b_link1 + 1)
  {
    if(!(size_link1 >= 6ul))
      return 0;

    t_link1 = dst_link1;
    tmp_post_1_link1 = src_link1;
    src_link1 = src_link1 + 1l;
    signed int return_value_sprintf_2_link1;
    return_value_sprintf_2_link1=sprintf(dst_link1, "%u", *tmp_post_1_link1);
    dst_link1 = dst_link1 + (signed long int)(unsigned long int)return_value_sprintf_2_link1;
    if(!(b_link1 == bytes_link1))
    {
      tmp_post_3_link1 = dst_link1;
      dst_link1 = dst_link1 + 1l;
      *tmp_post_3_link1 = (char)46;
      *dst_link1 = (char)0;
    }

    size_link1 = size_link1 - (unsigned long int)(dst_link1 - t_link1);
  }
  return (signed int)(dst_link1 - odst_link1);
}

// decoct_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/inet_net_ntop.c line 157
static signed int decoct_link2(const unsigned char *src_link2, signed int bytes_link2, char *dst_link2, unsigned long int size_link2)
{
  char *odst_link2 = dst_link2;
  char *t_link2;
  signed int b_link2 = 1;
  const unsigned char *tmp_post_1_link2;
  char *tmp_post_3_link2;
  for( ; bytes_link2 >= b_link2; b_link2 = b_link2 + 1)
  {
    if(!(size_link2 >= 6ul))
      return 0;

    t_link2 = dst_link2;
    tmp_post_1_link2 = src_link2;
    src_link2 = src_link2 + 1l;
    signed int return_value_sprintf_2_link2;
    return_value_sprintf_2_link2=sprintf(dst_link2, "%u", *tmp_post_1_link2);
    dst_link2 = dst_link2 + (signed long int)(unsigned long int)return_value_sprintf_2_link2;
    if(!(b_link2 == bytes_link2))
    {
      tmp_post_3_link2 = dst_link2;
      dst_link2 = dst_link2 + 1l;
      *tmp_post_3_link2 = (char)46;
      *dst_link2 = (char)0;
    }

    size_link2 = size_link2 - (unsigned long int)(dst_link2 - t_link2);
  }
  return (signed int)(dst_link2 - odst_link2);
}

// defaultNoticeProcessor
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5634
static void defaultNoticeProcessor(void *arg, const char *message)
{
  (void)arg;
  fprintf(stderr, "%s", message);
}

// defaultNoticeReceiver
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5619
static void defaultNoticeReceiver(void *arg, const struct pg_result *res)
{
  (void)arg;
  char *return_value_PQresultErrorMessage_1;
  if(!(res->noticeHooks.noticeProc == ((void (*)(void *, const char *))NULL)))
  {
    return_value_PQresultErrorMessage_1=PQresultErrorMessage(res);
    res->noticeHooks.noticeProc(res->noticeHooks.noticeProcArg, return_value_PQresultErrorMessage_1);
  }

}

// default_threadlock
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5885
static void default_threadlock(signed int acquire)
{
  static union anonymous_2 singlethread_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
  if(!(acquire == 0))
  {
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&singlethread_lock);
    if(!(return_value_pthread_mutex_lock_1 == 0))
      do
      {
        fprintf(stderr, "%s\n", (const void *)"failed to lock mutex");
        abort();
      }
      while((_Bool)0);

  }

  else
  {
    signed int return_value_pthread_mutex_unlock_2;
    return_value_pthread_mutex_unlock_2=pthread_mutex_unlock(&singlethread_lock);
    if(!(return_value_pthread_mutex_unlock_2 == 0))
      do
      {
        fprintf(stderr, "%s\n", (const void *)"failed to unlock mutex");
        abort();
      }
      while((_Bool)0);

  }
}

// destroyPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.c line 115
extern void destroyPQExpBuffer(struct PQExpBufferData *str)
{
  if(!(str == ((struct PQExpBufferData *)NULL)))
  {
    termPQExpBuffer(str);
    free((void *)str);
  }

}

// destroySSL
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1455
static void destroySSL(void)
{
  destroy_ssl_system();
}

// destroy_ssl_system
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1019
static void destroy_ssl_system(void)
{
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&ssl_config_mutex);
  if(return_value_pthread_mutex_lock_1 == 0)
  {
    if(ssl_open_connections >= 1l && !(pq_init_crypto_lib == 0))
      ssl_open_connections = ssl_open_connections - 1l;

    if(ssl_open_connections == 0l && !(pq_init_crypto_lib == 0))
    {
      CRYPTO_set_locking_callback((void (*)(signed int, signed int, const char *, signed int))(void *)0);
      CRYPTO_set_id_callback((unsigned long int (*)(void))(void *)0);
    }

    pthread_mutex_unlock(&ssl_config_mutex);
  }

}

// dir_strcmp
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 457
static signed int dir_strcmp(const char *s1, const char *s2)
{
  _Bool tmp_if_expr_1;
  for( ; !(*s1 == 0); s2 = s2 + 1l)
  {
    if(*s2 == 0)
      break;

    if(!(*s1 == *s2))
    {
      if((signed int)*s1 == 47)
        tmp_if_expr_1 = (signed int)*s2 == 47 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        return (signed int)*s1 - (signed int)*s2;

    }

    s1 = s1 + 1l;
  }
  if(!(*s1 == 0))
    return 1;

  else
    if(!(*s2 == 0))
      return -1;

    else
      return 0;
}

// dir_strcmp_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 457
static signed int dir_strcmp_link1(const char *s1_link1, const char *s2_link1)
{
  _Bool tmp_if_expr_1_link1;
  for( ; !(*s1_link1 == 0); s2_link1 = s2_link1 + 1l)
  {
    if(*s2_link1 == 0)
      break;

    if(!(*s1_link1 == *s2_link1))
    {
      if((signed int)*s1_link1 == 47)
        tmp_if_expr_1_link1 = (signed int)*s2_link1 == 47 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1_link1 = (_Bool)0;
      if(!tmp_if_expr_1_link1)
        return (signed int)*s1_link1 - (signed int)*s2_link1;

    }

    s1_link1 = s1_link1 + 1l;
  }
  if(!(*s1_link1 == 0))
    return 1;

  else
    if(!(*s2_link1 == 0))
      return -1;

    else
      return 0;
}

// discard_response
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 582
static void discard_response(struct anonymous_18 *state)
{
  struct pg_result *res;
  do
  {
    res=PQgetResult(state->con);
    if(!(res == ((struct pg_result *)NULL)))
      PQclear(res);

  }
  while(!(res == ((struct pg_result *)NULL)));
}

// disconnect_all
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 1608
static void disconnect_all(struct anonymous_18 *state, signed int length)
{
  signed int i = 0;
  for( ; !(i >= length); i = i + 1)
    if(!((state + (signed long int)i)->con == ((struct pg_conn *)NULL)))
    {
      PQfinish((state + (signed long int)i)->con);
      (state + (signed long int)i)->con = (struct pg_conn *)(void *)0;
    }

}

// doConnect
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 515
static struct pg_conn * doConnect(void)
{
  struct pg_conn *conn;
  char new_pass;
  signed int return_value_PQconnectionNeedsPassword_1;
  do
  {
    const char *keywords[7l];
    const char *values[7l];
    keywords[(signed long int)0] = "host";
    values[(signed long int)0] = pghost;
    keywords[(signed long int)1] = "port";
    values[(signed long int)1] = pgport;
    keywords[(signed long int)2] = "user";
    values[(signed long int)2] = login;
    keywords[(signed long int)3] = "password";
    static char *password = (char *)(void *)0;
    values[(signed long int)3] = password;
    keywords[(signed long int)4] = "dbname";
    values[(signed long int)4] = dbName;
    keywords[(signed long int)5] = "fallback_application_name";
    values[(signed long int)5] = progname;
    keywords[(signed long int)6] = (const char *)(void *)0;
    values[(signed long int)6] = (const char *)(void *)0;
    new_pass = (char)0;
    conn=PQconnectdbParams(keywords, values, (signed int)(char)1);
    if(conn == ((struct pg_conn *)NULL))
    {
      fprintf(stderr, "Connection to database \"%s\" failed\n", dbName);
      return (struct pg_conn *)(void *)0;
    }

    enum anonymous_24 return_value_PQstatus_2;
    return_value_PQstatus_2=PQstatus(conn);
    if((signed int)return_value_PQstatus_2 == CONNECTION_BAD)
    {
      return_value_PQconnectionNeedsPassword_1=PQconnectionNeedsPassword(conn);
      if(!(return_value_PQconnectionNeedsPassword_1 == 0))
      {
        if(password == ((char *)NULL))
        {
          PQfinish(conn);
          password=simple_prompt("Password: ", 100, (char)0);
          new_pass = (char)1;
        }

      }

    }

  }
  while(!(new_pass == 0));
  enum anonymous_24 return_value_PQstatus_4;
  return_value_PQstatus_4=PQstatus(conn);
  if((signed int)return_value_PQstatus_4 == CONNECTION_BAD)
  {
    char *return_value_PQerrorMessage_3;
    return_value_PQerrorMessage_3=PQerrorMessage(conn);
    fprintf(stderr, "Connection to database \"%s\" failed:\n%s", dbName, return_value_PQerrorMessage_3);
    PQfinish(conn);
    return (struct pg_conn *)(void *)0;
  }

  return conn;
}

// doCustom
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 938
static char doCustom(struct anonymous_17 *thread, struct anonymous_18 *st, struct timeval *conn_time, struct _IO_FILE *logfile, struct anonymous_19 *agg)
{
  struct pg_result *doCustom__1__res;
  struct anonymous_22 **commands;
  char trans_needs_throttle = (char)0;
  _Bool tmp_if_expr_9;
  double return_value_pg_erand48_8;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  char return_value_clientDone_13;
  char *return_value_PQerrorMessage_16;
  signed int argc;
  signed int i;
  char **argv;
  signed int return_value_pg_strcasecmp_33;
  signed int return_value_pg_strcasecmp_32;
  signed int return_value_strcmp_22;
  signed int return_value_strcmp_21;
  signed int return_value_strcmp_20;
  signed int return_value_pg_strcasecmp_31;
  signed int return_value_pg_strcasecmp_25;
  signed int return_value_pg_strcasecmp_30;
  char return_value_clientDone_27;
  signed int return_value_pg_strcasecmp_29;
  char return_value_clientDone_28;
  do
  {

  top:
    ;
    commands = sql_files[(signed long int)st->use_file];
    if(!(throttle_delay == 0l))
    {
      if(st->is_throttled == 0)
      {
        signed long int wait;
        wait=getPoissonRand(thread, throttle_delay);
        thread->throttle_trigger = thread->throttle_trigger + wait;
        st->txn_scheduled = thread->throttle_trigger;
        st->sleeping = 1;
        st->throttling = (char)1;
        st->is_throttled = (char)1;
        if(!(debug == 0))
          fprintf(stderr, "client %d throttling %ld us\n", st->id, wait);

      }

    }

    if(!(st->sleeping == 0))
    {
      struct timeval now;
      signed long int now_us;
      gettimeofday(&now, (struct timezone *)(void *)0);
      now_us = (signed long int)((unsigned long int)now.tv_sec * (unsigned long int)1000000 + (unsigned long int)now.tv_usec);
      if(now_us >= st->txn_scheduled)
      {
        st->sleeping = 0;
        if(!(st->throttling == 0))
        {
          signed long int lag = now_us - st->txn_scheduled;
          thread->throttle_lag = thread->throttle_lag + lag;
          if(!(thread->throttle_lag_max >= lag))
            thread->throttle_lag_max = lag;

          st->throttling = (char)0;
        }

      }

      else
        return (char)1;
    }

    if(!(st->listen == 0))
    {
      struct timeval doCustom__1__3__now;
      char now_valid = (char)0;
      doCustom__1__3__now.tv_sec = (signed long int)0;
      doCustom__1__3__now.tv_usec = (signed long int)0;
      if(commands[(signed long int)st->state]->type == 1)
      {
        if(!(debug == 0))
          fprintf(stderr, "client %d receiving\n", st->id);

        signed int return_value_PQconsumeInput_2;
        return_value_PQconsumeInput_2=PQconsumeInput(st->con);
        if(return_value_PQconsumeInput_2 == 0)
        {
          fprintf(stderr, "Client %d aborted in state %d. Probably the backend died while processing.\n", st->id, st->state);
          char return_value_clientDone_1;
          return_value_clientDone_1=clientDone(st, (char)0);
          return return_value_clientDone_1;
        }

        signed int return_value_PQisBusy_3;
        return_value_PQisBusy_3=PQisBusy(st->con);
        if(!(return_value_PQisBusy_3 == 0))
          return (char)1;

      }

      if(!(is_latencies == 0))
      {
        signed int cnum = commands[(signed long int)st->state]->command_num;
        if(now_valid == 0)
        {
          gettimeofday(&doCustom__1__3__now, (struct timezone *)(void *)0);
          now_valid = (char)1;
        }

        do
        {
          (thread->exec_elapsed + (signed long int)cnum)->tv_sec = (thread->exec_elapsed + (signed long int)cnum)->tv_sec + (doCustom__1__3__now.tv_sec - st->stmt_begin.tv_sec);
          (thread->exec_elapsed + (signed long int)cnum)->tv_usec = (thread->exec_elapsed + (signed long int)cnum)->tv_usec + (doCustom__1__3__now.tv_usec - st->stmt_begin.tv_usec);
          for( ; !((thread->exec_elapsed + (signed long int)cnum)->tv_usec >= 0l); (thread->exec_elapsed + (signed long int)cnum)->tv_sec = (thread->exec_elapsed + (signed long int)cnum)->tv_sec - 1l)
            (thread->exec_elapsed + (signed long int)cnum)->tv_usec = (thread->exec_elapsed + (signed long int)cnum)->tv_usec + (signed long int)1000000;
          for( ; (thread->exec_elapsed + (signed long int)cnum)->tv_usec >= 1000000l; (thread->exec_elapsed + (signed long int)cnum)->tv_sec = (thread->exec_elapsed + (signed long int)cnum)->tv_sec + 1l)
            (thread->exec_elapsed + (signed long int)cnum)->tv_usec = (thread->exec_elapsed + (signed long int)cnum)->tv_usec - (signed long int)1000000;
        }
        while((_Bool)0);
        thread->exec_count[(signed long int)cnum] = thread->exec_count[(signed long int)cnum] + 1;
      }

      if(!(progress == 0) || !(throttle_delay == 0l))
      {
        if(commands[(signed long int)(1 + st->state)] == ((struct anonymous_22 *)NULL))
        {
          signed long int doCustom__1__3__3__latency;
          if(now_valid == 0)
          {
            gettimeofday(&doCustom__1__3__now, (struct timezone *)(void *)0);
            now_valid = (char)1;
          }

          doCustom__1__3__3__latency = (signed long int)(((unsigned long int)doCustom__1__3__now.tv_sec * (unsigned long int)1000000 + (unsigned long int)doCustom__1__3__now.tv_usec) - (unsigned long int)st->txn_scheduled);
          st->txn_latencies = st->txn_latencies + doCustom__1__3__3__latency;
          st->txn_sqlats = st->txn_sqlats + doCustom__1__3__3__latency * doCustom__1__3__3__latency;
        }

      }

      if(!(logfile == ((struct _IO_FILE *)NULL)))
      {
        if(commands[(signed long int)(1 + st->state)] == ((struct anonymous_22 *)NULL))
        {
          double doCustom__1__3__4__lag;
          double latency;
          if(IEEE_FLOAT_EQUAL(sample_rate, 0.0))
            tmp_if_expr_9 = (_Bool)1;

          else
          {
            return_value_pg_erand48_8=pg_erand48(thread->random_state);
            tmp_if_expr_9 = return_value_pg_erand48_8 <= sample_rate ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_9)
          {
            if(now_valid == 0)
            {
              gettimeofday(&doCustom__1__3__now, (struct timezone *)(void *)0);
              now_valid = (char)1;
            }

            latency = (double)(((unsigned long int)doCustom__1__3__now.tv_sec * (unsigned long int)1000000 + (unsigned long int)doCustom__1__3__now.tv_usec) - (unsigned long int)st->txn_scheduled);
            doCustom__1__3__4__lag = (double)(((unsigned long int)st->txn_begin.tv_sec * (unsigned long int)1000000 + (unsigned long int)st->txn_begin.tv_usec) - (unsigned long int)st->txn_scheduled);
            if(agg_interval >= 1)
            {
              if((double)(agg->start_time + (signed long int)agg_interval) >= (double)doCustom__1__3__now.tv_sec + (double)doCustom__1__3__now.tv_usec / 1000000.0)
              {
                agg->cnt = agg->cnt + 1;
                agg->sum_latency = agg->sum_latency + latency;
                agg->sum2_latency = agg->sum2_latency + latency * latency;
                if(agg->cnt == 1)
                  tmp_if_expr_4 = (_Bool)1;

                else
                  tmp_if_expr_4 = latency < agg->min_latency ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_4)
                  agg->min_latency = latency;

                if(agg->cnt == 1)
                  tmp_if_expr_5 = (_Bool)1;

                else
                  tmp_if_expr_5 = latency > agg->max_latency ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_5)
                  agg->max_latency = latency;

                if(!(throttle_delay == 0l))
                {
                  agg->sum_lag = agg->sum_lag + doCustom__1__3__4__lag;
                  agg->sum2_lag = agg->sum2_lag + doCustom__1__3__4__lag * doCustom__1__3__4__lag;
                  if(agg->cnt == 1)
                    tmp_if_expr_6 = (_Bool)1;

                  else
                    tmp_if_expr_6 = doCustom__1__3__4__lag < agg->min_lag ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_6)
                    agg->min_lag = doCustom__1__3__4__lag;

                  if(agg->cnt == 1)
                    tmp_if_expr_7 = (_Bool)1;

                  else
                    tmp_if_expr_7 = doCustom__1__3__4__lag > agg->max_lag ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_7)
                    agg->max_lag = doCustom__1__3__4__lag;

                }

              }

              else
              {
                for( ; (double)(agg->start_time + (signed long int)agg_interval) < (double)doCustom__1__3__now.tv_sec + (double)doCustom__1__3__now.tv_usec / 1000000.0; agg->sum2_lag = (double)0)
                {
                  fprintf(logfile, "%ld %d %.0f %.0f %.0f %.0f", agg->start_time, agg->cnt, agg->sum_latency, agg->sum2_latency, agg->min_latency, agg->max_latency);
                  if(!(throttle_delay == 0l))
                    fprintf(logfile, " %.0f %.0f %.0f %.0f", agg->sum_lag, agg->sum2_lag, agg->min_lag, agg->max_lag);

                  fputc(10, logfile);
                  agg->start_time = agg->start_time + (signed long int)agg_interval;
                  agg->cnt = 0;
                  agg->min_latency = (double)0;
                  agg->max_latency = (double)0;
                  agg->sum_latency = (double)0;
                  agg->sum2_latency = (double)0;
                  agg->min_lag = (double)0;
                  agg->max_lag = (double)0;
                  agg->sum_lag = (double)0;
                }
                agg->cnt = 1;
                agg->min_latency = latency;
                agg->max_latency = latency;
                agg->sum_latency = latency;
                agg->sum2_latency = latency * latency;
                agg->min_lag = doCustom__1__3__4__lag;
                agg->max_lag = doCustom__1__3__4__lag;
                agg->sum_lag = doCustom__1__3__4__lag;
                agg->sum2_lag = doCustom__1__3__4__lag * doCustom__1__3__4__lag;
              }
            }

            else
            {
              fprintf(logfile, "%d %d %.0f %d %ld %ld", st->id, st->cnt, latency, st->use_file, (signed long int)doCustom__1__3__now.tv_sec, (signed long int)doCustom__1__3__now.tv_usec);
              if(!(throttle_delay == 0l))
                fprintf(logfile, " %.0f", doCustom__1__3__4__lag);

              fputc(10, logfile);
            }
          }

        }

      }

      if(commands[(signed long int)st->state]->type == 1)
      {
        doCustom__1__res=PQgetResult(st->con);
        enum anonymous_20 return_value_PQresultStatus_10;
        return_value_PQresultStatus_10=PQresultStatus(doCustom__1__res);
        if((signed int)return_value_PQresultStatus_10 == PGRES_COMMAND_OK || (signed int)return_value_PQresultStatus_10 == PGRES_TUPLES_OK)
          goto __CPROVER_DUMP_L45;

        char *return_value_PQerrorMessage_11;
        return_value_PQerrorMessage_11=PQerrorMessage(st->con);
        fprintf(stderr, "Client %d aborted in state %d: %s", st->id, st->state, return_value_PQerrorMessage_11);
        PQclear(doCustom__1__res);
        char return_value_clientDone_12;
        return_value_clientDone_12=clientDone(st, (char)0);
        return return_value_clientDone_12;

      __CPROVER_DUMP_L45:
        ;
        PQclear(doCustom__1__res);
        discard_response(st);
      }

      if(commands[(signed long int)(1 + st->state)] == ((struct anonymous_22 *)NULL))
      {
        if(!(is_connect == 0))
        {
          PQfinish(st->con);
          st->con = (struct pg_conn *)(void *)0;
        }

        st->cnt = st->cnt + 1;
        if(st->cnt >= nxacts && !(duration >= 1) || !(timer_exceeded == 0))
        {
          return_value_clientDone_13=clientDone(st, (char)1);
          return return_value_clientDone_13;
        }

      }

      st->state = st->state + 1;
      if(commands[(signed long int)st->state] == ((struct anonymous_22 *)NULL))
      {
        st->state = 0;
        signed long int return_value_getrand_14;
        return_value_getrand_14=getrand(thread, (signed long int)0, (signed long int)(num_files - 1));
        st->use_file = (signed int)return_value_getrand_14;
        commands = sql_files[(signed long int)st->use_file];
        st->is_throttled = (char)0;
        st->listen = 0;
        trans_needs_throttle = (char)(throttle_delay > (signed long int)0);
      }

    }

    if(st->con == ((struct pg_conn *)NULL))
    {
      struct timeval start;
      struct timeval end;
      gettimeofday(&start, (struct timezone *)(void *)0);
      st->con=doConnect();
      if(st->con == ((struct pg_conn *)NULL))
      {
        fprintf(stderr, "Client %d aborted in establishing connection.\n", st->id);
        char return_value_clientDone_15;
        return_value_clientDone_15=clientDone(st, (char)0);
        return return_value_clientDone_15;
      }

      gettimeofday(&end, (struct timezone *)(void *)0);
      do
      {
        conn_time->tv_sec = conn_time->tv_sec + (end.tv_sec - start.tv_sec);
        conn_time->tv_usec = conn_time->tv_usec + (end.tv_usec - start.tv_usec);
        for( ; !(conn_time->tv_usec >= 0l); conn_time->tv_sec = conn_time->tv_sec - 1l)
          conn_time->tv_usec = conn_time->tv_usec + (signed long int)1000000;
        for( ; conn_time->tv_usec >= 1000000l; conn_time->tv_sec = conn_time->tv_sec + 1l)
          conn_time->tv_usec = conn_time->tv_usec - (signed long int)1000000;
      }
      while((_Bool)0);
    }

    if(!(trans_needs_throttle == 0))
    {
      trans_needs_throttle = (char)0;
      goto top;
    }

    if(!(logfile == ((struct _IO_FILE *)NULL)) || !(progress == 0) || !(throttle_delay == 0l))
    {
      if(st->state == 0)
      {
        gettimeofday(&st->txn_begin, (struct timezone *)(void *)0);
        if(throttle_delay == 0l)
          st->txn_scheduled = (signed long int)((unsigned long int)st->txn_begin.tv_sec * (unsigned long int)1000000 + (unsigned long int)st->txn_begin.tv_usec);

      }

    }

    if(!(is_latencies == 0))
      gettimeofday(&st->stmt_begin, (struct timezone *)(void *)0);

    if(commands[(signed long int)st->state]->type == 1)
    {
      const struct anonymous_22 *command = commands[(signed long int)st->state];
      signed int r;
      if((signed int)querymode == QUERY_SIMPLE)
      {
        char *sql;
        sql=pg_strdup(command->argv[(signed long int)0]);
        sql=assignVariables(st, sql);
        if(!(debug == 0))
          fprintf(stderr, "client %d sending %s\n", st->id, sql);

        r=PQsendQuery(st->con, sql);
        free((void *)sql);
      }

      else
        if((signed int)querymode == QUERY_EXTENDED)
        {
          const char *doCustom__1__7__2__sql = command->argv[(signed long int)0];
          const char *params[10l];
          getQueryParams(st, command, params);
          if(!(debug == 0))
            fprintf(stderr, "client %d sending %s\n", st->id, doCustom__1__7__2__sql);

          r=PQsendQueryParams(st->con, doCustom__1__7__2__sql, command->argc - 1, (const unsigned int *)(void *)0, params, (const signed int *)(void *)0, (const signed int *)(void *)0, 0);
        }

        else
          if((signed int)querymode == QUERY_PREPARED)
          {
            char name[32l];
            const char *doCustom__1__7__3__params[10l];
            if(st->prepared[(signed long int)st->use_file] == 0)
            {
              signed int j = 0;
              for( ; !(commands[(signed long int)j] == ((struct anonymous_22 *)NULL)); j = j + 1)
              {
                struct pg_result *doCustom__1__7__3__1__1__1__res;
                char doCustom__1__7__3__1__1__1__name[32l];
                if(commands[(signed long int)j]->type == 1)
                {
                  preparedStatementName(doCustom__1__7__3__1__1__1__name, st->use_file, j);
                  doCustom__1__7__3__1__1__1__res=PQprepare(st->con, doCustom__1__7__3__1__1__1__name, commands[(signed long int)j]->argv[(signed long int)0], commands[(signed long int)j]->argc - 1, (const unsigned int *)(void *)0);
                  enum anonymous_20 return_value_PQresultStatus_17;
                  return_value_PQresultStatus_17=PQresultStatus(doCustom__1__7__3__1__1__1__res);
                  if(!((signed int)return_value_PQresultStatus_17 == PGRES_COMMAND_OK))
                  {
                    return_value_PQerrorMessage_16=PQerrorMessage(st->con);
                    fprintf(stderr, "%s", return_value_PQerrorMessage_16);
                  }

                  PQclear(doCustom__1__7__3__1__1__1__res);
                }

              }
              st->prepared[(signed long int)st->use_file] = (char)1;
            }

            getQueryParams(st, command, doCustom__1__7__3__params);
            preparedStatementName(name, st->use_file, st->state);
            if(!(debug == 0))
              fprintf(stderr, "client %d sending %s\n", st->id, (const void *)name);

            r=PQsendQueryPrepared(st->con, name, command->argc - 1, doCustom__1__7__3__params, (const signed int *)(void *)0, (const signed int *)(void *)0, 0);
          }

          else
            r = 0;
      if(r == 0)
      {
        if(!(debug == 0))
          fprintf(stderr, "client %d cannot send %s\n", st->id, command->argv[(signed long int)0]);

        st->ecnt = st->ecnt + 1;
      }

      else
        st->listen = 1;
      break;
    }

    if(!(commands[(signed long int)st->state]->type == 2))
      break;

    argc = commands[(signed long int)st->state]->argc;
    argv = commands[(signed long int)st->state]->argv;
    if(!(debug == 0))
    {
      fprintf(stderr, "client %d executing \\%s", st->id, argv[(signed long int)0]);
      i = 1;
      for( ; !(i >= argc); i = i + 1)
        fprintf(stderr, " %s", argv[(signed long int)i]);
      fprintf(stderr, "\n");
    }

    return_value_pg_strcasecmp_33=pg_strcasecmp(argv[(signed long int)0], "setrandom");
    if(return_value_pg_strcasecmp_33 == 0)
    {
      char *doCustom__1__8__2__var;
      signed long int min;
      signed long int max;
      char res[64l];
      if((signed int)*argv[2l] == 58)
      {
        doCustom__1__8__2__var=getVariable(st, argv[(signed long int)2] + (signed long int)1);
        if(doCustom__1__8__2__var == ((char *)NULL))
        {
          fprintf(stderr, "%s: undefined variable %s\n", argv[(signed long int)0], argv[(signed long int)2]);
          st->ecnt = st->ecnt + 1;
          return (char)1;
        }

        min=strtoint64(doCustom__1__8__2__var);
      }

      else
        min=strtoint64(argv[(signed long int)2]);
      if((signed int)*argv[3l] == 58)
      {
        doCustom__1__8__2__var=getVariable(st, argv[(signed long int)3] + (signed long int)1);
        if(doCustom__1__8__2__var == ((char *)NULL))
        {
          fprintf(stderr, "%s: undefined variable %s\n", argv[(signed long int)0], argv[(signed long int)3]);
          st->ecnt = st->ecnt + 1;
          return (char)1;
        }

        max=strtoint64(doCustom__1__8__2__var);
      }

      else
        max=strtoint64(argv[(signed long int)3]);
      if(!(max >= min))
      {
        fprintf(stderr, "%s: maximum is less than minimum\n", argv[(signed long int)0]);
        st->ecnt = st->ecnt + 1;
        return (char)1;
      }

      if(!(max + -min >= 0l) || !(1l + max + -min >= 0l))
      {
        fprintf(stderr, "%s: range too large\n", argv[(signed long int)0]);
        st->ecnt = st->ecnt + 1;
        return (char)1;
      }

      signed long int return_value_getrand_18;
      return_value_getrand_18=getrand(thread, min, max);
      snprintf(res, sizeof(char [64l]) /*64ul*/ , "%ld", return_value_getrand_18);
      signed int return_value_putVariable_19;
      return_value_putVariable_19=putVariable(st, argv[(signed long int)0], argv[(signed long int)1], res);
      if(return_value_putVariable_19 == 0)
      {
        st->ecnt = st->ecnt + 1;
        return (char)1;
      }

      st->listen = 1;
    }

    else
    {
      return_value_pg_strcasecmp_32=pg_strcasecmp(argv[(signed long int)0], "set");
      if(return_value_pg_strcasecmp_32 == 0)
      {
        char *var;
        signed long int ope1;
        signed long int ope2;
        char doCustom__1__8__3__res[64l];
        if((signed int)*argv[2l] == 58)
        {
          var=getVariable(st, argv[(signed long int)2] + (signed long int)1);
          if(var == ((char *)NULL))
          {
            fprintf(stderr, "%s: undefined variable %s\n", argv[(signed long int)0], argv[(signed long int)2]);
            st->ecnt = st->ecnt + 1;
            return (char)1;
          }

          ope1=strtoint64(var);
        }

        else
          ope1=strtoint64(argv[(signed long int)2]);
        if(!(argc >= 5))
          snprintf(doCustom__1__8__3__res, sizeof(char [64l]) /*64ul*/ , "%ld", ope1);

        else
        {
          if((signed int)*argv[4l] == 58)
          {
            var=getVariable(st, argv[(signed long int)4] + (signed long int)1);
            if(var == ((char *)NULL))
            {
              fprintf(stderr, "%s: undefined variable %s\n", argv[(signed long int)0], argv[(signed long int)4]);
              st->ecnt = st->ecnt + 1;
              return (char)1;
            }

            ope2=strtoint64(var);
          }

          else
            ope2=strtoint64(argv[(signed long int)4]);
          signed int return_value_strcmp_23;
          return_value_strcmp_23=strcmp(argv[(signed long int)3], "+");
          if(return_value_strcmp_23 == 0)
            snprintf(doCustom__1__8__3__res, sizeof(char [64l]) /*64ul*/ , "%ld", ope1 + ope2);

          else
          {
            return_value_strcmp_22=strcmp(argv[(signed long int)3], "-");
            if(return_value_strcmp_22 == 0)
              snprintf(doCustom__1__8__3__res, sizeof(char [64l]) /*64ul*/ , "%ld", ope1 - ope2);

            else
            {
              return_value_strcmp_21=strcmp(argv[(signed long int)3], "*");
              if(return_value_strcmp_21 == 0)
                snprintf(doCustom__1__8__3__res, sizeof(char [64l]) /*64ul*/ , "%ld", ope1 * ope2);

              else
              {
                return_value_strcmp_20=strcmp(argv[(signed long int)3], "/");
                if(return_value_strcmp_20 == 0)
                {
                  if(ope2 == 0l)
                  {
                    fprintf(stderr, "%s: division by zero\n", argv[(signed long int)0]);
                    st->ecnt = st->ecnt + 1;
                    return (char)1;
                  }

                  snprintf(doCustom__1__8__3__res, sizeof(char [64l]) /*64ul*/ , "%ld", ope1 / ope2);
                }

                else
                {
                  fprintf(stderr, "%s: unsupported operator %s\n", argv[(signed long int)0], argv[(signed long int)3]);
                  st->ecnt = st->ecnt + 1;
                  return (char)1;
                }
              }
            }
          }
        }
        signed int return_value_putVariable_24;
        return_value_putVariable_24=putVariable(st, argv[(signed long int)0], argv[(signed long int)1], doCustom__1__8__3__res);
        if(return_value_putVariable_24 == 0)
        {
          st->ecnt = st->ecnt + 1;
          return (char)1;
        }

        st->listen = 1;
      }

      else
      {
        return_value_pg_strcasecmp_31=pg_strcasecmp(argv[(signed long int)0], "sleep");
        if(return_value_pg_strcasecmp_31 == 0)
        {
          char *doCustom__1__8__4__var;
          signed int usec;
          struct timeval doCustom__1__8__4__now;
          if((signed int)*argv[1l] == 58)
          {
            doCustom__1__8__4__var=getVariable(st, argv[(signed long int)1] + (signed long int)1);
            if(doCustom__1__8__4__var == ((char *)NULL))
            {
              fprintf(stderr, "%s: undefined variable %s\n", argv[(signed long int)0], argv[(signed long int)1]);
              st->ecnt = st->ecnt + 1;
              return (char)1;
            }

            usec=atoi(doCustom__1__8__4__var);
          }

          else
            usec=atoi(argv[(signed long int)1]);
          if(argc >= 3)
          {
            signed int return_value_pg_strcasecmp_26;
            return_value_pg_strcasecmp_26=pg_strcasecmp(argv[(signed long int)2], "ms");
            if(return_value_pg_strcasecmp_26 == 0)
              usec = usec * 1000;

            else
            {
              return_value_pg_strcasecmp_25=pg_strcasecmp(argv[(signed long int)2], "s");
              if(return_value_pg_strcasecmp_25 == 0)
                usec = usec * 1000000;

            }
          }

          else
            usec = usec * 1000000;
          gettimeofday(&doCustom__1__8__4__now, (struct timezone *)(void *)0);
          st->txn_scheduled = (signed long int)((unsigned long int)doCustom__1__8__4__now.tv_sec * (unsigned long int)1000000 + (unsigned long int)doCustom__1__8__4__now.tv_usec + (unsigned long int)usec);
          st->sleeping = 1;
          st->listen = 1;
        }

        else
        {
          return_value_pg_strcasecmp_30=pg_strcasecmp(argv[(signed long int)0], "setshell");
          if(return_value_pg_strcasecmp_30 == 0)
          {
            char ret;
            ret=runShellCommand(st, argv[(signed long int)1], argv + (signed long int)2, argc - 2);
            if(!(timer_exceeded == 0))
            {
              return_value_clientDone_27=clientDone(st, (char)1);
              return return_value_clientDone_27;
            }

            else
              if(ret == 0)
              {
                st->ecnt = st->ecnt + 1;
                return (char)1;
              }

              else
                st->listen = 1;
          }

          else
          {
            return_value_pg_strcasecmp_29=pg_strcasecmp(argv[(signed long int)0], "shell");
            if(return_value_pg_strcasecmp_29 == 0)
            {
              char doCustom__1__8__6__ret;
              doCustom__1__8__6__ret=runShellCommand(st, (char *)(void *)0, argv + (signed long int)1, argc - 1);
              if(!(timer_exceeded == 0))
              {
                return_value_clientDone_28=clientDone(st, (char)1);
                return return_value_clientDone_28;
              }

              else
                if(doCustom__1__8__6__ret == 0)
                {
                  st->ecnt = st->ecnt + 1;
                  return (char)1;
                }

                else
                  st->listen = 1;
            }

          }
        }
      }
    }
  }
  while((_Bool)1);
  return (char)1;
}

// doTheRounds
// file md5.c line 94
static void doTheRounds(unsigned int *X, unsigned int *state)
{
  unsigned int a;
  unsigned int b;
  unsigned int c;
  unsigned int d;
  a = state[(signed long int)0];
  b = state[(signed long int)1];
  c = state[(signed long int)2];
  d = state[(signed long int)3];
  a = b + (a + (b & c | ~b & d) + X[(signed long int)0] + 0xd76aa478 << 7 | a + (b & c | ~b & d) + X[(signed long int)0] + 0xd76aa478 >> 32 - 7);
  d = a + (d + (a & b | ~a & c) + X[(signed long int)1] + 0xe8c7b756 << 12 | d + (a & b | ~a & c) + X[(signed long int)1] + 0xe8c7b756 >> 32 - 12);
  c = d + (c + (d & a | ~d & b) + X[(signed long int)2] + (unsigned int)0x242070db << 17 | c + (d & a | ~d & b) + X[(signed long int)2] + (unsigned int)0x242070db >> 32 - 17);
  b = c + (b + (c & d | ~c & a) + X[(signed long int)3] + 0xc1bdceee << 22 | b + (c & d | ~c & a) + X[(signed long int)3] + 0xc1bdceee >> 32 - 22);
  a = b + (a + (b & c | ~b & d) + X[(signed long int)4] + 0xf57c0faf << 7 | a + (b & c | ~b & d) + X[(signed long int)4] + 0xf57c0faf >> 32 - 7);
  d = a + (d + (a & b | ~a & c) + X[(signed long int)5] + (unsigned int)0x4787c62a << 12 | d + (a & b | ~a & c) + X[(signed long int)5] + (unsigned int)0x4787c62a >> 32 - 12);
  c = d + (c + (d & a | ~d & b) + X[(signed long int)6] + 0xa8304613 << 17 | c + (d & a | ~d & b) + X[(signed long int)6] + 0xa8304613 >> 32 - 17);
  b = c + (b + (c & d | ~c & a) + X[(signed long int)7] + 0xfd469501 << 22 | b + (c & d | ~c & a) + X[(signed long int)7] + 0xfd469501 >> 32 - 22);
  a = b + (a + (b & c | ~b & d) + X[(signed long int)8] + (unsigned int)0x698098d8 << 7 | a + (b & c | ~b & d) + X[(signed long int)8] + (unsigned int)0x698098d8 >> 32 - 7);
  d = a + (d + (a & b | ~a & c) + X[(signed long int)9] + 0x8b44f7af << 12 | d + (a & b | ~a & c) + X[(signed long int)9] + 0x8b44f7af >> 32 - 12);
  c = d + (c + (d & a | ~d & b) + X[(signed long int)10] + 0xffff5bb1 << 17 | c + (d & a | ~d & b) + X[(signed long int)10] + 0xffff5bb1 >> 32 - 17);
  b = c + (b + (c & d | ~c & a) + X[(signed long int)11] + 0x895cd7be << 22 | b + (c & d | ~c & a) + X[(signed long int)11] + 0x895cd7be >> 32 - 22);
  a = b + (a + (b & c | ~b & d) + X[(signed long int)12] + (unsigned int)0x6b901122 << 7 | a + (b & c | ~b & d) + X[(signed long int)12] + (unsigned int)0x6b901122 >> 32 - 7);
  d = a + (d + (a & b | ~a & c) + X[(signed long int)13] + 0xfd987193 << 12 | d + (a & b | ~a & c) + X[(signed long int)13] + 0xfd987193 >> 32 - 12);
  c = d + (c + (d & a | ~d & b) + X[(signed long int)14] + 0xa679438e << 17 | c + (d & a | ~d & b) + X[(signed long int)14] + 0xa679438e >> 32 - 17);
  b = c + (b + (c & d | ~c & a) + X[(signed long int)15] + (unsigned int)0x49b40821 << 22 | b + (c & d | ~c & a) + X[(signed long int)15] + (unsigned int)0x49b40821 >> 32 - 22);
  a = b + (a + (b & d | c & ~d) + X[(signed long int)1] + 0xf61e2562 << 5 | a + (b & d | c & ~d) + X[(signed long int)1] + 0xf61e2562 >> 32 - 5);
  d = a + (d + (a & c | b & ~c) + X[(signed long int)6] + 0xc040b340 << 9 | d + (a & c | b & ~c) + X[(signed long int)6] + 0xc040b340 >> 32 - 9);
  c = d + (c + (d & b | a & ~b) + X[(signed long int)11] + (unsigned int)0x265e5a51 << 14 | c + (d & b | a & ~b) + X[(signed long int)11] + (unsigned int)0x265e5a51 >> 32 - 14);
  b = c + (b + (c & a | d & ~a) + X[(signed long int)0] + 0xe9b6c7aa << 20 | b + (c & a | d & ~a) + X[(signed long int)0] + 0xe9b6c7aa >> 32 - 20);
  a = b + (a + (b & d | c & ~d) + X[(signed long int)5] + 0xd62f105d << 5 | a + (b & d | c & ~d) + X[(signed long int)5] + 0xd62f105d >> 32 - 5);
  d = a + (d + (a & c | b & ~c) + X[(signed long int)10] + (unsigned int)0x02441453 << 9 | d + (a & c | b & ~c) + X[(signed long int)10] + (unsigned int)0x02441453 >> 32 - 9);
  c = d + (c + (d & b | a & ~b) + X[(signed long int)15] + 0xd8a1e681 << 14 | c + (d & b | a & ~b) + X[(signed long int)15] + 0xd8a1e681 >> 32 - 14);
  b = c + (b + (c & a | d & ~a) + X[(signed long int)4] + 0xe7d3fbc8 << 20 | b + (c & a | d & ~a) + X[(signed long int)4] + 0xe7d3fbc8 >> 32 - 20);
  a = b + (a + (b & d | c & ~d) + X[(signed long int)9] + (unsigned int)0x21e1cde6 << 5 | a + (b & d | c & ~d) + X[(signed long int)9] + (unsigned int)0x21e1cde6 >> 32 - 5);
  d = a + (d + (a & c | b & ~c) + X[(signed long int)14] + 0xc33707d6 << 9 | d + (a & c | b & ~c) + X[(signed long int)14] + 0xc33707d6 >> 32 - 9);
  c = d + (c + (d & b | a & ~b) + X[(signed long int)3] + 0xf4d50d87 << 14 | c + (d & b | a & ~b) + X[(signed long int)3] + 0xf4d50d87 >> 32 - 14);
  b = c + (b + (c & a | d & ~a) + X[(signed long int)8] + (unsigned int)0x455a14ed << 20 | b + (c & a | d & ~a) + X[(signed long int)8] + (unsigned int)0x455a14ed >> 32 - 20);
  a = b + (a + (b & d | c & ~d) + X[(signed long int)13] + 0xa9e3e905 << 5 | a + (b & d | c & ~d) + X[(signed long int)13] + 0xa9e3e905 >> 32 - 5);
  d = a + (d + (a & c | b & ~c) + X[(signed long int)2] + 0xfcefa3f8 << 9 | d + (a & c | b & ~c) + X[(signed long int)2] + 0xfcefa3f8 >> 32 - 9);
  c = d + (c + (d & b | a & ~b) + X[(signed long int)7] + (unsigned int)0x676f02d9 << 14 | c + (d & b | a & ~b) + X[(signed long int)7] + (unsigned int)0x676f02d9 >> 32 - 14);
  b = c + (b + (c & a | d & ~a) + X[(signed long int)12] + 0x8d2a4c8a << 20 | b + (c & a | d & ~a) + X[(signed long int)12] + 0x8d2a4c8a >> 32 - 20);
  a = b + (a + (b ^ c ^ d) + X[(signed long int)5] + 0xfffa3942 << 4 | a + (b ^ c ^ d) + X[(signed long int)5] + 0xfffa3942 >> 32 - 4);
  d = a + (d + (a ^ b ^ c) + X[(signed long int)8] + 0x8771f681 << 11 | d + (a ^ b ^ c) + X[(signed long int)8] + 0x8771f681 >> 32 - 11);
  c = d + (c + (d ^ a ^ b) + X[(signed long int)11] + (unsigned int)0x6d9d6122 << 16 | c + (d ^ a ^ b) + X[(signed long int)11] + (unsigned int)0x6d9d6122 >> 32 - 16);
  b = c + (b + (c ^ d ^ a) + X[(signed long int)14] + 0xfde5380c << 23 | b + (c ^ d ^ a) + X[(signed long int)14] + 0xfde5380c >> 32 - 23);
  a = b + (a + (b ^ c ^ d) + X[(signed long int)1] + 0xa4beea44 << 4 | a + (b ^ c ^ d) + X[(signed long int)1] + 0xa4beea44 >> 32 - 4);
  d = a + (d + (a ^ b ^ c) + X[(signed long int)4] + (unsigned int)0x4bdecfa9 << 11 | d + (a ^ b ^ c) + X[(signed long int)4] + (unsigned int)0x4bdecfa9 >> 32 - 11);
  c = d + (c + (d ^ a ^ b) + X[(signed long int)7] + 0xf6bb4b60 << 16 | c + (d ^ a ^ b) + X[(signed long int)7] + 0xf6bb4b60 >> 32 - 16);
  b = c + (b + (c ^ d ^ a) + X[(signed long int)10] + 0xbebfbc70 << 23 | b + (c ^ d ^ a) + X[(signed long int)10] + 0xbebfbc70 >> 32 - 23);
  a = b + (a + (b ^ c ^ d) + X[(signed long int)13] + (unsigned int)0x289b7ec6 << 4 | a + (b ^ c ^ d) + X[(signed long int)13] + (unsigned int)0x289b7ec6 >> 32 - 4);
  d = a + (d + (a ^ b ^ c) + X[(signed long int)0] + 0xeaa127fa << 11 | d + (a ^ b ^ c) + X[(signed long int)0] + 0xeaa127fa >> 32 - 11);
  c = d + (c + (d ^ a ^ b) + X[(signed long int)3] + 0xd4ef3085 << 16 | c + (d ^ a ^ b) + X[(signed long int)3] + 0xd4ef3085 >> 32 - 16);
  b = c + (b + (c ^ d ^ a) + X[(signed long int)6] + (unsigned int)0x04881d05 << 23 | b + (c ^ d ^ a) + X[(signed long int)6] + (unsigned int)0x04881d05 >> 32 - 23);
  a = b + (a + (b ^ c ^ d) + X[(signed long int)9] + 0xd9d4d039 << 4 | a + (b ^ c ^ d) + X[(signed long int)9] + 0xd9d4d039 >> 32 - 4);
  d = a + (d + (a ^ b ^ c) + X[(signed long int)12] + 0xe6db99e5 << 11 | d + (a ^ b ^ c) + X[(signed long int)12] + 0xe6db99e5 >> 32 - 11);
  c = d + (c + (d ^ a ^ b) + X[(signed long int)15] + (unsigned int)0x1fa27cf8 << 16 | c + (d ^ a ^ b) + X[(signed long int)15] + (unsigned int)0x1fa27cf8 >> 32 - 16);
  b = c + (b + (c ^ d ^ a) + X[(signed long int)2] + 0xc4ac5665 << 23 | b + (c ^ d ^ a) + X[(signed long int)2] + 0xc4ac5665 >> 32 - 23);
  a = b + (a + (c ^ (b | ~d)) + X[(signed long int)0] + 0xf4292244 << 6 | a + (c ^ (b | ~d)) + X[(signed long int)0] + 0xf4292244 >> 32 - 6);
  d = a + (d + (b ^ (a | ~c)) + X[(signed long int)7] + (unsigned int)0x432aff97 << 10 | d + (b ^ (a | ~c)) + X[(signed long int)7] + (unsigned int)0x432aff97 >> 32 - 10);
  c = d + (c + (a ^ (d | ~b)) + X[(signed long int)14] + 0xab9423a7 << 15 | c + (a ^ (d | ~b)) + X[(signed long int)14] + 0xab9423a7 >> 32 - 15);
  b = c + (b + (d ^ (c | ~a)) + X[(signed long int)5] + 0xfc93a039 << 21 | b + (d ^ (c | ~a)) + X[(signed long int)5] + 0xfc93a039 >> 32 - 21);
  a = b + (a + (c ^ (b | ~d)) + X[(signed long int)12] + (unsigned int)0x655b59c3 << 6 | a + (c ^ (b | ~d)) + X[(signed long int)12] + (unsigned int)0x655b59c3 >> 32 - 6);
  d = a + (d + (b ^ (a | ~c)) + X[(signed long int)3] + 0x8f0ccc92 << 10 | d + (b ^ (a | ~c)) + X[(signed long int)3] + 0x8f0ccc92 >> 32 - 10);
  c = d + (c + (a ^ (d | ~b)) + X[(signed long int)10] + 0xffeff47d << 15 | c + (a ^ (d | ~b)) + X[(signed long int)10] + 0xffeff47d >> 32 - 15);
  b = c + (b + (d ^ (c | ~a)) + X[(signed long int)1] + 0x85845dd1 << 21 | b + (d ^ (c | ~a)) + X[(signed long int)1] + 0x85845dd1 >> 32 - 21);
  a = b + (a + (c ^ (b | ~d)) + X[(signed long int)8] + (unsigned int)0x6fa87e4f << 6 | a + (c ^ (b | ~d)) + X[(signed long int)8] + (unsigned int)0x6fa87e4f >> 32 - 6);
  d = a + (d + (b ^ (a | ~c)) + X[(signed long int)15] + 0xfe2ce6e0 << 10 | d + (b ^ (a | ~c)) + X[(signed long int)15] + 0xfe2ce6e0 >> 32 - 10);
  c = d + (c + (a ^ (d | ~b)) + X[(signed long int)6] + 0xa3014314 << 15 | c + (a ^ (d | ~b)) + X[(signed long int)6] + 0xa3014314 >> 32 - 15);
  b = c + (b + (d ^ (c | ~a)) + X[(signed long int)13] + (unsigned int)0x4e0811a1 << 21 | b + (d ^ (c | ~a)) + X[(signed long int)13] + (unsigned int)0x4e0811a1 >> 32 - 21);
  a = b + (a + (c ^ (b | ~d)) + X[(signed long int)4] + 0xf7537e82 << 6 | a + (c ^ (b | ~d)) + X[(signed long int)4] + 0xf7537e82 >> 32 - 6);
  d = a + (d + (b ^ (a | ~c)) + X[(signed long int)11] + 0xbd3af235 << 10 | d + (b ^ (a | ~c)) + X[(signed long int)11] + 0xbd3af235 >> 32 - 10);
  c = d + (c + (a ^ (d | ~b)) + X[(signed long int)2] + (unsigned int)0x2ad7d2bb << 15 | c + (a ^ (d | ~b)) + X[(signed long int)2] + (unsigned int)0x2ad7d2bb >> 32 - 15);
  b = c + (b + (d ^ (c | ~a)) + X[(signed long int)9] + 0xeb86d391 << 21 | b + (d ^ (c | ~a)) + X[(signed long int)9] + 0xeb86d391 >> 32 - 21);
  state[(signed long int)0] = state[(signed long int)0] + a;
  state[(signed long int)1] = state[(signed long int)1] + b;
  state[(signed long int)2] = state[(signed long int)2] + c;
  state[(signed long int)3] = state[(signed long int)3] + d;
}

// do_field
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-print.c line 325
static void do_field(const struct _PQprintOpt *po, const struct pg_result *res, const signed int i, const signed int j, const signed int fs_len, char **fields, const signed int nFields, const char **fieldNames, unsigned char *fieldNotNum, signed int *fieldMax, const signed int fieldMaxLen, struct _IO_FILE *fout)
{
  const char *pval;
  const char *p;
  signed int plen;
  char skipit;
  plen=PQgetlength(res, i, j);
  pval=PQgetvalue(res, i, j);
  _Bool tmp_if_expr_2;
  if(pval == ((const char *)NULL) || !(plen >= 1))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(*pval != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_1;
  if(tmp_if_expr_2)
  {
    if(!(po->align == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = po->expanded != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      skipit = (char)1;

    else
    {
      skipit = (char)0;
      goto efield;
    }
  }

  else
    skipit = (char)0;
  signed int return_value_PQmblen_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  if(skipit == 0)
  {
    if(!(po->align == 0))
    {
      if(fieldNotNum[(signed long int)j] == 0)
      {
        char ch = (char)48;
        p = pval;
        for( ; !(*p == 0); p = p + (signed long int)return_value_PQmblen_3)
        {
          ch = *p;
          if(!((signed int)ch == 32) && !((signed int)ch == 45) && !((signed int)ch == 46) && !((signed int)ch == 69) && !((signed int)ch == 101) && (!((signed int)ch >= 48) || (signed int)ch >= 58))
          {
            fieldNotNum[(signed long int)j] = (unsigned char)1;
            break;
          }

          return_value_PQmblen_3=PQmblen(p, res->client_encoding);
        }
        if((signed int)*pval == 69)
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = (signed int)*pval == 101 ? (_Bool)1 : (_Bool)0;
        if((signed int)ch >= 58 || !((signed int)ch >= 48) || tmp_if_expr_4)
          fieldNotNum[(signed long int)j] = (unsigned char)1;

      }

    }

    if(po->expanded == 0)
    {
      if(!(po->align == 0))
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = po->html3 != 0 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    if(tmp_if_expr_8)
    {
      if(!(fieldMax[(signed long int)j] >= plen))
        fieldMax[(signed long int)j] = plen;

      void *return_value_malloc_6;
      return_value_malloc_6=malloc((unsigned long int)(plen + 1));
      fields[(signed long int)(i * nFields + j)] = (char *)return_value_malloc_6;
      if(fields[(signed long int)(i * nFields + j)] == ((char *)NULL))
      {
        char *return_value_libpq_gettext_5;
        return_value_libpq_gettext_5=libpq_gettext("out of memory\n");
        fprintf(stderr, return_value_libpq_gettext_5);
        abort();
      }

      strcpy(fields[(signed long int)(i * nFields + j)], pval);
    }

    else
      if(!(po->expanded == 0))
      {
        if(!(po->html3 == 0))
          fprintf(fout, "<tr><td align=\"left\"><b>%s</b></td><td align=\"%s\">%s</td></tr>\n", fieldNames[(signed long int)j], fieldNotNum[(signed long int)j] != 0 ? "left" : "right", pval);

        else
          if(!(po->align == 0))
            fprintf(fout, "%-*s%s %s\n", fieldMaxLen - fs_len, fieldNames[(signed long int)j], po->fieldSep, pval);

          else
            fprintf(fout, "%s%s%s\n", fieldNames[(signed long int)j], po->fieldSep, pval);
      }

      else
        if(po->html3 == 0)
        {
          fputs(pval, fout);

        efield:
          ;
          if(!(1 + j >= nFields))
            fputs(po->fieldSep, fout);

          else
            fputc(10, fout);
        }

  }

}

// do_header
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-print.c line 439
static char * do_header(struct _IO_FILE *fout, const struct _PQprintOpt *po, const signed int nFields, signed int *fieldMax, const char **fieldNames, unsigned char *fieldNotNum, const signed int fs_len, const struct pg_result *res)
{
  signed int j;
  char *border = (char *)(void *)0;
  char *tmp_post_3;
  char *tmp_post_4;
  signed int tmp_post_5;
  char *tmp_post_6;
  char *tmp_post_7;
  char *tmp_post_8;
  if(!(po->html3 == 0))
    fputs("<tr>", fout);

  else
  {
    signed int tot = 0;
    signed int do_header__1__1__n = 0;
    char *p = (char *)(void *)0;
    for( ; !(do_header__1__1__n >= nFields); do_header__1__1__n = do_header__1__1__n + 1)
      tot = tot + fieldMax[(signed long int)do_header__1__1__n] + fs_len + (po->standard != 0 ? 2 : 0);
    if(!(po->standard == 0))
      tot = tot + fs_len * 2 + 2;

    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(tot + 1));
    border = (char *)return_value_malloc_1;
    if(border == ((char *)NULL))
    {
      char *return_value_libpq_gettext_2;
      return_value_libpq_gettext_2=libpq_gettext("out of memory\n");
      fprintf(stderr, return_value_libpq_gettext_2);
      abort();
    }

    p = border;
    if(!(po->standard == 0))
    {
      char *fs = po->fieldSep;
      do
      {
        tmp_post_3 = fs;
        fs = fs + 1l;
        if(*tmp_post_3 == 0)
          break;

        tmp_post_4 = p;
        p = p + 1l;
        *tmp_post_4 = (char)43;
      }
      while((_Bool)1);
    }

    j = 0;
    for( ; !(j >= nFields); j = j + 1)
    {
      signed int len = fieldMax[(signed long int)j] + (po->standard != 0 ? 2 : 0);
      do
      {
        tmp_post_5 = len;
        len = len - 1;
        if(tmp_post_5 == 0)
          break;

        tmp_post_6 = p;
        p = p + 1l;
        *tmp_post_6 = (char)45;
      }
      while((_Bool)1);
      if(!(po->standard == 0) || !(1 + j >= nFields))
      {
        char *do_header__1__1__4__1__2__fs = po->fieldSep;
        do
        {
          tmp_post_7 = do_header__1__1__4__1__2__fs;
          do_header__1__1__4__1__2__fs = do_header__1__1__4__1__2__fs + 1l;
          if(*tmp_post_7 == 0)
            break;

          tmp_post_8 = p;
          p = p + 1l;
          *tmp_post_8 = (char)43;
        }
        while((_Bool)1);
      }

    }
    *p = (char)0;
    if(!(po->standard == 0))
      fprintf(fout, "%s\n", border);

  }
  if(!(po->standard == 0))
    fputs(po->fieldSep, fout);

  j = 0;
  for( ; !(j >= nFields); j = j + 1)
  {
    const char *s;
    s=PQfname(res, j);
    if(!(po->html3 == 0))
      fprintf(fout, "<th align=\"%s\">%s</th>", fieldNotNum[(signed long int)j] != 0 ? "left" : "right", fieldNames[(signed long int)j]);

    else
    {
      signed int n;
      unsigned long int return_value_strlen_9;
      return_value_strlen_9=strlen(s);
      n = (signed int)return_value_strlen_9;
      if(!(fieldMax[(signed long int)j] >= n))
        fieldMax[(signed long int)j] = n;

      if(!(po->standard == 0))
        fprintf(fout, fieldNotNum[(signed long int)j] != 0 ? " %-*s " : " %*s ", fieldMax[(signed long int)j], s);

      else
        fprintf(fout, fieldNotNum[(signed long int)j] != 0 ? "%-*s" : "%*s", fieldMax[(signed long int)j], s);
      if(!(po->standard == 0) || !(1 + j >= nFields))
        fputs(po->fieldSep, fout);

    }
  }
  if(!(po->html3 == 0))
    fputs("</tr>\n", fout);

  else
    fprintf(fout, "\n%s\n", border);
  return border;
}

// dot_pg_pass_warning
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5826
static void dot_pg_pass_warning(struct pg_conn *conn)
{
  char *return_value_PQresultErrorField_3;
  signed int return_value_strcmp_4;
  if(!(conn->dot_pgpass_used == 0))
  {
    if(!(conn->password_needed == 0))
    {
      if(!(conn->result == ((struct pg_result *)NULL)))
      {
        return_value_PQresultErrorField_3=PQresultErrorField(conn->result, 67);
        return_value_strcmp_4=strcmp(return_value_PQresultErrorField_3, "28P01");
        if(return_value_strcmp_4 == 0)
        {
          char pgpassfile[1024l];
          char return_value_getPgPassFilename_1;
          return_value_getPgPassFilename_1=getPgPassFilename(pgpassfile);
          if(return_value_getPgPassFilename_1 == 0)
            goto __CPROVER_DUMP_L3;

          char *return_value_libpq_gettext_2;
          return_value_libpq_gettext_2=libpq_gettext("password retrieved from file \"%s\"\n");
          appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2, (const void *)pgpassfile);
        }

      }

    }

  }


__CPROVER_DUMP_L3:
  ;
}

// dupEvents
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 381
static struct PGEvent * dupEvents(struct PGEvent *events, signed int count)
{
  struct PGEvent *newEvents;
  signed int i;
  if(events == ((struct PGEvent *)NULL) || !(count >= 1))
    return (struct PGEvent *)(void *)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)count * sizeof(struct PGEvent) /*40ul*/ );
    newEvents = (struct PGEvent *)return_value_malloc_1;
    if(newEvents == ((struct PGEvent *)NULL))
      return (struct PGEvent *)(void *)0;

    else
    {
      i = 0;
      for( ; !(i >= count); i = i + 1)
      {
        (newEvents + (signed long int)i)->proc = (events + (signed long int)i)->proc;
        (newEvents + (signed long int)i)->passThrough = (events + (signed long int)i)->passThrough;
        (newEvents + (signed long int)i)->data = (void *)0;
        (newEvents + (signed long int)i)->resultInitialized = (char)0;
        (newEvents + (signed long int)i)->name=strdup((events + (signed long int)i)->name);
        if((newEvents + (signed long int)i)->name == ((char *)NULL))
        {
          do
          {
            i = i - 1;
            if(!(i >= 0))
              break;

            free((void *)(newEvents + (signed long int)i)->name);
          }
          while((_Bool)1);
          free((void *)newEvents);
          return (struct PGEvent *)(void *)0;
        }

      }
      return newEvents;
    }
  }
}

// enlargePQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.c line 173
extern signed int enlargePQExpBuffer(struct PQExpBufferData *str, unsigned long int needed)
{
  unsigned long int newlen;
  char *newdata;
  _Bool tmp_if_expr_1;
  if(str == ((struct PQExpBufferData *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = str->maxlen == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  unsigned long int tmp_if_expr_2;
  if(tmp_if_expr_1)
    return 0;

  else
    if(needed >= 2147483647ul + -str->len)
    {
      markPQExpBufferBroken(str);
      return 0;
    }

    else
    {
      needed = needed + str->len + (unsigned long int)1;
      if(str->maxlen >= needed)
        return 1;

      else
      {
        if(str->maxlen >= 1ul)
          tmp_if_expr_2 = (unsigned long int)2 * str->maxlen;

        else
          tmp_if_expr_2 = (unsigned long int)64;
        newlen = tmp_if_expr_2;
        for( ; !(newlen >= needed); newlen = (unsigned long int)2 * newlen)
          ;
        if(newlen >= 2147483648ul)
          newlen = (unsigned long int)0x7fffffff;

        void *return_value_realloc_3;
        return_value_realloc_3=realloc((void *)str->data, newlen);
        newdata = (char *)return_value_realloc_3;
        if(!(newdata == ((char *)NULL)))
        {
          str->data = newdata;
          str->maxlen = newlen;
          return 1;
        }

        else
        {
          markPQExpBufferBroken(str);
          return 0;
        }
      }
    }
}

// escape_single_quotes_ascii
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/quotes.c line 33
extern char * escape_single_quotes_ascii(const char *src)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(src);
  len = (signed int)return_value_strlen_1;
  signed int i;
  signed int j;
  char *result;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(len * 2 + 1));
  result = (char *)return_value_malloc_2;
  _Bool tmp_if_expr_4;
  signed int tmp_post_3;
  signed int tmp_post_5;
  if(result == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    i = 0;
    j = 0;
    for( ; !(i >= len); i = i + 1)
    {
      if((signed int)src[(signed long int)i] == 39)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = ((signed int)src[(signed long int)i] == 92 ? ((char)1 != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
      {
        tmp_post_3 = j;
        j = j + 1;
        result[(signed long int)tmp_post_3] = src[(signed long int)i];
      }

      tmp_post_5 = j;
      j = j + 1;
      result[(signed long int)tmp_post_5] = src[(signed long int)i];
    }
    result[(signed long int)j] = (char)0;
    return result;
  }
}

// executeStatement
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 500
static void executeStatement(struct pg_conn *con, const char *sql)
{
  struct pg_result *res;
  res=PQexec(con, sql);
  enum anonymous_20 return_value_PQresultStatus_2;
  return_value_PQresultStatus_2=PQresultStatus(res);
  if(!((signed int)return_value_PQresultStatus_2 == PGRES_COMMAND_OK))
  {
    char *return_value_PQerrorMessage_1;
    return_value_PQerrorMessage_1=PQerrorMessage(con);
    fprintf(stderr, "%s", return_value_PQerrorMessage_1);
    exit(1);
  }

  PQclear(res);
}

// fill
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-print.c line 753
static void fill(signed int length, signed int max, char filler, struct _IO_FILE *fp)
{
  signed int count = max - length;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = count;
    count = count - 1;
    if(!(tmp_post_1 >= 0))
      break;

    _IO_putc((signed int)filler, fp);
  }
  while((_Bool)1);
}

// fillPGconn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 681
static char fillPGconn(struct pg_conn *conn, struct _PQconninfoOption *connOptions)
{
  const struct _internalPQconninfoOption *option = PQconninfoOptions;
  for( ; !(option->keyword == ((char *)NULL)); option = option + 1l)
    if(option->connofs >= 0l)
    {
      const char *tmp;
      tmp=conninfo_getval(connOptions, option->keyword);
      if(!(tmp == ((const char *)NULL)))
      {
        char **connmember = (char **)((char *)conn + option->connofs);
        if(!(*connmember == ((char *)NULL)))
          free((void *)*connmember);

        *connmember=strdup(tmp);
        if(*connmember == ((char *)NULL))
        {
          char *return_value_libpq_gettext_1;
          return_value_libpq_gettext_1=libpq_gettext("out of memory\n");
          printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
          return (char)0;
        }

      }

    }

  return (char)1;
}

// find_my_exec
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 119
extern signed int find_my_exec(const char *argv0, char *retpath)
{
  char cwd[1024l];
  char test_path[1024l];
  char *path;
  char *return_value_getcwd_4;
  return_value_getcwd_4=getcwd(cwd, (unsigned long int)1024);
  if(return_value_getcwd_4 == ((char *)NULL))
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("could not identify current directory: %s");
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    fprintf(stderr, return_value_gettext_1, return_value_strerror_3);
    fputc(10, stderr);
    return -1;
  }

  char *return_value_first_dir_separator_8;
  return_value_first_dir_separator_8=first_dir_separator(argv0);
  signed int return_value_resolve_symlinks_5;
  if(!(return_value_first_dir_separator_8 == ((char *)NULL)))
  {
    if((signed int)*argv0 == 47)
      do
      {
        char *find_my_exec__1__2__1___dst = retpath;
        unsigned long int _len = (unsigned long int)1024;
        if(_len >= 1ul)
        {
          strncpy(find_my_exec__1__2__1___dst, argv0, _len);
          find_my_exec__1__2__1___dst[(signed long int)(_len - (unsigned long int)1)] = (char)0;
        }

      }
      while((_Bool)0);

    else
      join_path_components(retpath, cwd, argv0);
    canonicalize_path(retpath);
    signed int return_value_validate_exec_6;
    return_value_validate_exec_6=validate_exec(retpath);
    if(return_value_validate_exec_6 == 0)
    {
      return_value_resolve_symlinks_5=resolve_symlinks(retpath);
      return return_value_resolve_symlinks_5;
    }

    char *return_value_gettext_7;
    return_value_gettext_7=gettext("invalid binary \"%s\"");
    fprintf(stderr, return_value_gettext_7, retpath);
    fputc(10, stderr);
    return -1;
  }

  path=getenv("PATH");
  unsigned long int return_value_strlen_9;
  if(!(path == ((char *)NULL)))
  {
    if(!(*path == 0))
    {
      char *startp = (char *)(void *)0;
      char *endp = (char *)(void *)0;
      while((_Bool)1)
      {
        if(startp == ((char *)NULL))
          startp = path;

        else
          startp = endp + (signed long int)1;
        endp=first_path_var_separator(startp);
        if(endp == ((char *)NULL))
        {
          return_value_strlen_9=strlen(startp);
          endp = startp + (signed long int)return_value_strlen_9;
        }

        do
        {
          char *_dst = test_path;
          unsigned long int find_my_exec__1__3__1__1___len = (unsigned long int)((endp - startp) + (signed long int)1 < (signed long int)1024 ? (endp - startp) + (signed long int)1 : (signed long int)1024);
          if(find_my_exec__1__3__1__1___len >= 1ul)
          {
            strncpy(_dst, startp, find_my_exec__1__3__1__1___len);
            _dst[(signed long int)(find_my_exec__1__3__1__1___len - (unsigned long int)1)] = (char)0;
          }

        }
        while((_Bool)0);
        if((signed int)test_path[0l] == 47)
          join_path_components(retpath, test_path, argv0);

        else
        {
          join_path_components(retpath, cwd, test_path);
          join_path_components(retpath, retpath, argv0);
        }
        canonicalize_path(retpath);
        signed int return_value_validate_exec_10;
        return_value_validate_exec_10=validate_exec(retpath);
        if(!(return_value_validate_exec_10 == 0))
        {
          if(return_value_validate_exec_10 == -1)
            goto __CPROVER_DUMP_L16;

          if(return_value_validate_exec_10 == -2)
            goto __CPROVER_DUMP_L17;

        }

        else
        {
          signed int return_value_resolve_symlinks_11;
          return_value_resolve_symlinks_11=resolve_symlinks(retpath);
          return return_value_resolve_symlinks_11;

        __CPROVER_DUMP_L16:
          ;
          goto __CPROVER_DUMP_L18;

        __CPROVER_DUMP_L17:
          ;
          char *return_value_gettext_12;
          return_value_gettext_12=gettext("could not read binary \"%s\"");
          fprintf(stderr, return_value_gettext_12, retpath);
          fputc(10, stderr);
        }

      __CPROVER_DUMP_L18:
        ;
        if(*endp == 0)
          break;

      }
    }

  }

  char *return_value_gettext_13;
  return_value_gettext_13=gettext("could not find a \"%s\" to execute");
  fprintf(stderr, return_value_gettext_13, argv0);
  fputc(10, stderr);
  return -1;
}

// find_other_exec
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 307
extern signed int find_other_exec(const char *argv0, const char *target, const char *versionstr, char *retpath)
{
  char cmd[1024l];
  char line[100l];
  signed int return_value_find_my_exec_1;
  return_value_find_my_exec_1=find_my_exec(argv0, retpath);
  if(!(return_value_find_my_exec_1 >= 0))
    return -1;

  else
  {
    char *return_value_last_dir_separator_2;
    return_value_last_dir_separator_2=last_dir_separator(retpath);
    *return_value_last_dir_separator_2 = (char)0;
    canonicalize_path(retpath);
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(retpath);
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(retpath);
    snprintf(retpath + (signed long int)return_value_strlen_3, (unsigned long int)1024 - return_value_strlen_4, "/%s%s", target, (const void *)"");
    signed int return_value_validate_exec_5;
    return_value_validate_exec_5=validate_exec(retpath);
    if(!(return_value_validate_exec_5 == 0))
      return -1;

    else
    {
      snprintf(cmd, sizeof(char [1024l]) /*1024ul*/ , "\"%s\" -V", retpath);
      char *return_value_pipe_read_line_6;
      return_value_pipe_read_line_6=pipe_read_line(cmd, line, (signed int)sizeof(char [100l]) /*100ul*/ );
      if(return_value_pipe_read_line_6 == ((char *)NULL))
        return -1;

      else
      {
        signed int return_value_strcmp_7;
        return_value_strcmp_7=strcmp(line, versionstr);
        if(!(return_value_strcmp_7 == 0))
          return -2;

        else
          return 0;
      }
    }
  }
}

// first_dir_separator
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 38
extern char * first_dir_separator(const char *filename)
{
  const char *p = filename;
  for( ; !(*p == 0); p = p + 1l)
    if((signed int)*p == 47)
      return (char *)p;

  return (char *)(void *)0;
}

// first_path_var_separator
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 40
extern char * first_path_var_separator(const char *pathlist)
{
  const char *p = pathlist;
  for( ; !(*p == 0); p = p + 1l)
    if((signed int)*p == 58)
      return (char *)p;

  return (char *)(void *)0;
}

// fls
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/fls.c line 55
extern signed int fls(signed int mask)
{
  signed int bit;
  if(mask == 0)
    return 0;

  else
  {
    bit = 1;
    for( ; !(mask == 1); bit = bit + 1)
      mask = (signed int)((unsigned int)mask >> 1);
    return bit;
  }
}

// forkname_chars
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/relpath.c line 79
extern signed int forkname_chars(const char *str, enum ForkNumber *fork)
{
  enum ForkNumber forkNum = (enum ForkNumber)1;
  for( ; !((signed int)forkNum >= 4); forkNum = (enum ForkNumber)((signed int)forkNum + 1))
  {
    signed int len;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(forkNames[(signed long int)forkNum]);
    len = (signed int)return_value_strlen_1;
    signed int return_value_strncmp_2;
    return_value_strncmp_2=strncmp(forkNames[(signed long int)forkNum], str, (unsigned long int)len);
    if(return_value_strncmp_2 == 0)
    {
      if(!(fork == ((enum ForkNumber *)NULL)))
        *fork = forkNum;

      return len;
    }

  }
  if(!(fork == ((enum ForkNumber *)NULL)))
    *fork = (enum ForkNumber)InvalidForkNumber;

  return 0;
}

// forkname_to_number
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/relpath.c line 48
extern enum ForkNumber forkname_to_number(const char *forkName)
{
  enum ForkNumber forkNum = (enum ForkNumber)0;
  signed int return_value_strcmp_1;
  for( ; !((signed int)forkNum >= 4); forkNum = (enum ForkNumber)((signed int)forkNum + 1))
  {
    return_value_strcmp_1=strcmp(forkNames[(signed long int)forkNum], forkName);
    if(return_value_strcmp_1 == 0)
      return forkNum;

  }
  return (enum ForkNumber)InvalidForkNumber;
}

// fputnbytes
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 84
static void fputnbytes(struct _IO_FILE *f, const char *str, unsigned long int n)
{
  unsigned long int tmp_post_1;
  const char *tmp_post_2;
  do
  {
    tmp_post_1 = n;
    n = n - 1ul;
    if(!(tmp_post_1 >= 1ul))
      break;

    tmp_post_2 = str;
    str = str + 1l;
    fputc((signed int)*tmp_post_2, f);
  }
  while((_Bool)1);
}

// freePGconn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 2838
static void freePGconn(struct pg_conn *conn)
{
  signed int i = 0;
  if(!(i >= conn->nEvents))
  {
    struct anonymous_14 evt;
    evt.conn = conn;
    (conn->events + (signed long int)i)->proc((enum anonymous_13)PGEVT_CONNDESTROY, (void *)&evt, (conn->events + (signed long int)i)->passThrough);
    free((void *)(conn->events + (signed long int)i)->name);
    i = i + 1;
  }

  if(!(conn->client_encoding_initial == ((char *)NULL)))
    free((void *)conn->client_encoding_initial);

  if(!(conn->events == ((struct PGEvent *)NULL)))
    free((void *)conn->events);

  if(!(conn->pghost == ((char *)NULL)))
    free((void *)conn->pghost);

  if(!(conn->pghostaddr == ((char *)NULL)))
    free((void *)conn->pghostaddr);

  if(!(conn->pgport == ((char *)NULL)))
    free((void *)conn->pgport);

  if(!(conn->pgunixsocket == ((char *)NULL)))
    free((void *)conn->pgunixsocket);

  if(!(conn->pgtty == ((char *)NULL)))
    free((void *)conn->pgtty);

  if(!(conn->connect_timeout == ((char *)NULL)))
    free((void *)conn->connect_timeout);

  if(!(conn->pgoptions == ((char *)NULL)))
    free((void *)conn->pgoptions);

  if(!(conn->appname == ((char *)NULL)))
    free((void *)conn->appname);

  if(!(conn->fbappname == ((char *)NULL)))
    free((void *)conn->fbappname);

  if(!(conn->dbName == ((char *)NULL)))
    free((void *)conn->dbName);

  if(!(conn->replication == ((char *)NULL)))
    free((void *)conn->replication);

  if(!(conn->pguser == ((char *)NULL)))
    free((void *)conn->pguser);

  if(!(conn->pgpass == ((char *)NULL)))
    free((void *)conn->pgpass);

  if(!(conn->keepalives == ((char *)NULL)))
    free((void *)conn->keepalives);

  if(!(conn->keepalives_idle == ((char *)NULL)))
    free((void *)conn->keepalives_idle);

  if(!(conn->keepalives_interval == ((char *)NULL)))
    free((void *)conn->keepalives_interval);

  if(!(conn->keepalives_count == ((char *)NULL)))
    free((void *)conn->keepalives_count);

  if(!(conn->sslmode == ((char *)NULL)))
    free((void *)conn->sslmode);

  if(!(conn->sslcert == ((char *)NULL)))
    free((void *)conn->sslcert);

  if(!(conn->sslkey == ((char *)NULL)))
    free((void *)conn->sslkey);

  if(!(conn->sslrootcert == ((char *)NULL)))
    free((void *)conn->sslrootcert);

  if(!(conn->sslcrl == ((char *)NULL)))
    free((void *)conn->sslcrl);

  if(!(conn->sslcompression == ((char *)NULL)))
    free((void *)conn->sslcompression);

  if(!(conn->requirepeer == ((char *)NULL)))
    free((void *)conn->requirepeer);

  if(!(conn->krbsrvname == ((char *)NULL)))
    free((void *)conn->krbsrvname);

  if(!(conn->last_query == ((char *)NULL)))
    free((void *)conn->last_query);

  if(!(conn->inBuffer == ((char *)NULL)))
    free((void *)conn->inBuffer);

  if(!(conn->outBuffer == ((char *)NULL)))
    free((void *)conn->outBuffer);

  if(!(conn->rowBuf == ((struct pgDataValue *)NULL)))
    free((void *)conn->rowBuf);

  termPQExpBuffer(&conn->errorMessage);
  termPQExpBuffer(&conn->workBuffer);
  free((void *)conn);
}

// getAnotherTuple
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol2.c line 790
static signed int getAnotherTuple(struct pg_conn *conn, char binary)
{
  struct pg_result *result = conn->result;
  signed int nfields = result->numAttributes;
  const char *errmsg;
  struct pgDataValue *rowbuf;
  char std_bitmap[64l];
  char *bitmap = std_bitmap;
  signed int i;
  unsigned long int nbytes;
  char bmap;
  signed int bitmap_index;
  signed int bitcnt;
  signed int vlen;
  rowbuf = conn->rowBuf;
  if(!(conn->rowBufLen >= nfields))
  {
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)rowbuf, (unsigned long int)nfields * sizeof(struct pgDataValue) /*16ul*/ );
    rowbuf = (struct pgDataValue *)return_value_realloc_1;
    if(rowbuf == ((struct pgDataValue *)NULL))
    {
      errmsg = (const char *)(void *)0;
      goto advance_and_error;
    }

    conn->rowBuf = rowbuf;
    conn->rowBufLen = nfields;
  }

  result->binary = (signed int)binary;
  if(!(binary == 0))
  {
    i = 0;
    for( ; !(i >= nfields); i = i + 1)
      (result->attDescs + (signed long int)i)->format = 1;
  }

  nbytes = (unsigned long int)(((nfields + 8) - 1) / 8);
  if(nbytes >= 65ul)
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(nbytes);
    bitmap = (char *)return_value_malloc_2;
    if(bitmap == ((char *)NULL))
    {
      errmsg = (const char *)(void *)0;
      goto advance_and_error;
    }

  }

  signed int return_value_pqGetnchar_3;
  return_value_pqGetnchar_3=pqGetnchar(bitmap, nbytes, conn);
  signed int return_value_pqGetInt_4;
  signed int return_value_pqRowProcessor_6;
  if(return_value_pqGetnchar_3 == 0)
  {
    bitmap_index = 0;
    bmap = bitmap[(signed long int)bitmap_index];
    bitcnt = 0;
    i = 0;
    for( ; !(i >= nfields); i = i + 1)
    {
      if((0200 & (signed int)bmap) == 0)
        vlen = -1;

      else
      {
        return_value_pqGetInt_4=pqGetInt(&vlen, (unsigned long int)4, conn);
        if(!(return_value_pqGetInt_4 == 0))
          goto EOFexit;

        else
        {
          if(binary == 0)
            vlen = vlen - 4;

          if(!(vlen >= 0))
            vlen = 0;

        }
      }
      (rowbuf + (signed long int)i)->len = vlen;
      (rowbuf + (signed long int)i)->value = conn->inBuffer + (signed long int)conn->inCursor;
      if(vlen >= 1)
      {
        signed int return_value_pqSkipnchar_5;
        return_value_pqSkipnchar_5=pqSkipnchar((unsigned long int)vlen, conn);
        if(!(return_value_pqSkipnchar_5 == 0))
          goto EOFexit;

      }

      bitcnt = bitcnt + 1;
      if(bitcnt == 8)
      {
        bitmap_index = bitmap_index + 1;
        bmap = bitmap[(signed long int)bitmap_index];
        bitcnt = 0;
      }

      else
        bmap = bmap << 1;
    }
    if(!(bitmap == std_bitmap))
      free((void *)bitmap);

    bitmap = (char *)(void *)0;
    conn->inStart = conn->inCursor;
    errmsg = (const char *)(void *)0;
    return_value_pqRowProcessor_6=pqRowProcessor(conn, &errmsg);
    if(!(return_value_pqRowProcessor_6 == 0))
      return 0;

    goto set_error_result;

  advance_and_error:
    ;
    conn->inStart = conn->inEnd;

  set_error_result:
    ;
    pqClearAsyncResult(conn);
    if(errmsg == ((const char *)NULL))
      errmsg=libpq_gettext("out of memory for query result");

    printfPQExpBuffer(&conn->errorMessage, "%s\n", errmsg);
    conn->result=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_FATAL_ERROR);
    conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
  }


EOFexit:
  ;
  if(!(bitmap == ((char *)NULL)))
  {
    if(!(bitmap == std_bitmap))
      free((void *)bitmap);

  }

  return -1;
}

// getAnotherTuple_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 693
static signed int getAnotherTuple_link1(struct pg_conn *conn_link1, signed int msgLength)
{
  struct pg_result *result_link1 = conn_link1->result;
  signed int nfields_link1 = result_link1->numAttributes;
  const char *errmsg_link1;
  struct pgDataValue *rowbuf_link1;
  signed int tupnfields;
  signed int vlen_link1;
  signed int i_link1;
  signed int return_value_pqGetInt_1;
  return_value_pqGetInt_1=pqGetInt(&tupnfields, (unsigned long int)2, conn_link1);
  signed int return_value_pqRowProcessor_5;
  if(!(return_value_pqGetInt_1 == 0))
    errmsg_link1=libpq_gettext("insufficient data in \"D\" message");

  else
    if(!(tupnfields == nfields_link1))
      errmsg_link1=libpq_gettext("unexpected field count in \"D\" message");

    else
    {
      rowbuf_link1 = conn_link1->rowBuf;
      if(!(conn_link1->rowBufLen >= nfields_link1))
      {
        void *return_value_realloc_2;
        return_value_realloc_2=realloc((void *)rowbuf_link1, (unsigned long int)nfields_link1 * sizeof(struct pgDataValue) /*16ul*/ );
        rowbuf_link1 = (struct pgDataValue *)return_value_realloc_2;
        if(rowbuf_link1 == ((struct pgDataValue *)NULL))
        {
          errmsg_link1 = (const char *)(void *)0;
          goto advance_and_error;
        }

        conn_link1->rowBuf = rowbuf_link1;
        conn_link1->rowBufLen = nfields_link1;
      }

      i_link1 = 0;
      for( ; !(i_link1 >= nfields_link1); i_link1 = i_link1 + 1)
      {
        signed int return_value_pqGetInt_3;
        return_value_pqGetInt_3=pqGetInt(&vlen_link1, (unsigned long int)4, conn_link1);
        if(!(return_value_pqGetInt_3 == 0))
        {
          errmsg_link1=libpq_gettext("insufficient data in \"D\" message");
          goto advance_and_error;
        }

        (rowbuf_link1 + (signed long int)i_link1)->len = vlen_link1;
        (rowbuf_link1 + (signed long int)i_link1)->value = conn_link1->inBuffer + (signed long int)conn_link1->inCursor;
        if(vlen_link1 >= 1)
        {
          signed int return_value_pqSkipnchar_4;
          return_value_pqSkipnchar_4=pqSkipnchar((unsigned long int)vlen_link1, conn_link1);
          if(!(return_value_pqSkipnchar_4 == 0))
          {
            errmsg_link1=libpq_gettext("insufficient data in \"D\" message");
            goto advance_and_error;
          }

        }

      }
      if(!(conn_link1->inCursor == 5 + conn_link1->inStart + msgLength))
        errmsg_link1=libpq_gettext("extraneous data in \"D\" message");

      else
      {
        conn_link1->inStart = conn_link1->inCursor;
        errmsg_link1 = (const char *)(void *)0;
        return_value_pqRowProcessor_5=pqRowProcessor(conn_link1, &errmsg_link1);
        if(!(return_value_pqRowProcessor_5 == 0))
          return 0;

        goto set_error_result;
      }
    }

advance_and_error:
  ;
  conn_link1->inStart = conn_link1->inStart + 5 + msgLength;

set_error_result:
  ;
  pqClearAsyncResult(conn_link1);
  if(errmsg_link1 == ((const char *)NULL))
    errmsg_link1=libpq_gettext("out of memory for query result");

  printfPQExpBuffer(&conn_link1->errorMessage, "%s\n", errmsg_link1);
  pqSaveErrorResult(conn_link1);
  return 0;
}

// getCopyDataMessage
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 1429
static signed int getCopyDataMessage(struct pg_conn *conn)
{
  char id;
  signed int msgLength;
  signed int avail;
  signed int return_value_getNotify_4;
  signed int return_value_pqGetErrorNotice3_5;
  signed int return_value_getParameterStatus_6;
  do
  {
    conn->inCursor = conn->inStart;
    signed int return_value_pqGetc_1;
    return_value_pqGetc_1=pqGetc(&id, conn);
    if(!(return_value_pqGetc_1 == 0))
      return 0;

    signed int return_value_pqGetInt_2;
    return_value_pqGetInt_2=pqGetInt(&msgLength, (unsigned long int)4, conn);
    if(!(return_value_pqGetInt_2 == 0))
      return 0;

    if(!(msgLength >= 4))
    {
      handleSyncLoss(conn, id, msgLength);
      return -2;
    }

    avail = conn->inEnd - conn->inCursor;
    if(!(avail >= msgLength + -4))
    {
      signed int return_value_pqCheckInBufferSpace_3;
      return_value_pqCheckInBufferSpace_3=pqCheckInBufferSpace(((unsigned long int)conn->inCursor + (unsigned long int)msgLength) - (unsigned long int)4, conn);
      if(!(return_value_pqCheckInBufferSpace_3 == 0))
      {
        handleSyncLoss(conn, id, msgLength);
        return -2;
      }

      return 0;
    }

    switch((signed int)id)
    {
      case 65:
      {
        return_value_getNotify_4=getNotify_link1(conn);
        if(!(return_value_getNotify_4 == 0))
          return 0;

        break;
      }
      case 78:
      {
        return_value_pqGetErrorNotice3_5=pqGetErrorNotice3(conn, (char)0);
        if(!(return_value_pqGetErrorNotice3_5 == 0))
          return 0;

        break;
      }
      case 83:
      {
        return_value_getParameterStatus_6=getParameterStatus(conn);
        if(!(return_value_getParameterStatus_6 == 0))
          return 0;

        break;
      }
      case 100:
        return msgLength;
      case 99:
      {
        if((signed int)conn->asyncStatus == PGASYNC_COPY_BOTH)
          conn->asyncStatus = (enum anonymous_9)PGASYNC_COPY_IN;

        else
          conn->asyncStatus = (enum anonymous_9)PGASYNC_BUSY;
        return -1;
      }
      default:
      {
        conn->asyncStatus = (enum anonymous_9)PGASYNC_BUSY;
        return -1;
      }
    }
    conn->inStart = conn->inCursor;
  }
  while((_Bool)1);
}

// getCopyResult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1786
static struct pg_result * getCopyResult(struct pg_conn *conn, enum anonymous_20 copytype)
{
  if(!((signed int)conn->status == CONNECTION_OK))
  {
    pqSaveErrorResult(conn);
    conn->asyncStatus = (enum anonymous_9)PGASYNC_IDLE;
    struct pg_result *return_value_pqPrepareAsyncResult_1;
    return_value_pqPrepareAsyncResult_1=pqPrepareAsyncResult(conn);
    return return_value_pqPrepareAsyncResult_1;
  }

  struct pg_result *return_value_pqPrepareAsyncResult_2;
  if(!(conn->result == ((struct pg_result *)NULL)))
  {
    if(!(conn->result->resultStatus == copytype))
      goto __CPROVER_DUMP_L2;

    return_value_pqPrepareAsyncResult_2=pqPrepareAsyncResult(conn);
    return return_value_pqPrepareAsyncResult_2;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    struct pg_result *return_value_PQmakeEmptyPGresult_3;
    return_value_PQmakeEmptyPGresult_3=PQmakeEmptyPGresult(conn, copytype);
    return return_value_PQmakeEmptyPGresult_3;
  }
}

// getCopyStart
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 1341
static signed int getCopyStart(struct pg_conn *conn, enum anonymous_20 copytype)
{
  struct pg_result *result;
  signed int nfields;
  signed int i;
  result=PQmakeEmptyPGresult(conn, copytype);
  signed int return_value_pqGetc_1;
  signed int return_value_pqGetInt_2;
  signed long int *tmp_post_4;
  if(!(result == ((struct pg_result *)NULL)))
  {
    return_value_pqGetc_1=pqGetc(&conn->copy_is_binary, conn);
    if(!(return_value_pqGetc_1 == 0))
      goto failure;

    result->binary = (signed int)conn->copy_is_binary;
    return_value_pqGetInt_2=pqGetInt(&result->numAttributes, (unsigned long int)2, conn);
    if(!(return_value_pqGetInt_2 == 0))
      goto failure;

    nfields = result->numAttributes;
    if(nfields >= 1)
    {
      void *return_value_pqResultAlloc_3;
      return_value_pqResultAlloc_3=pqResultAlloc(result, (unsigned long int)nfields * sizeof(struct pgresAttDesc) /*32ul*/ , (char)1);
      result->attDescs = (struct pgresAttDesc *)return_value_pqResultAlloc_3;
      if(result->attDescs == ((struct pgresAttDesc *)NULL))
        goto failure;

      do
      {
        void *_vstart = (void *)result->attDescs;
        signed int _val = 0;
        unsigned long int _len = (unsigned long int)nfields * sizeof(struct pgresAttDesc) /*32ul*/ ;
        if((7ul & _len) == 0ul && (7ul & (unsigned long int)_vstart) == 0ul && _val == 0 && !(_len >= 1025ul))
        {
          signed long int *getCopyStart__1__1__1__1___start = (signed long int *)_vstart;
          signed long int *_stop = (signed long int *)((char *)getCopyStart__1__1__1__1___start + (signed long int)_len);
          for( ; !(getCopyStart__1__1__1__1___start >= _stop); *tmp_post_4 = (signed long int)0)
          {
            tmp_post_4 = getCopyStart__1__1__1__1___start;
            getCopyStart__1__1__1__1___start = getCopyStart__1__1__1__1___start + 1l;
          }
        }

        else
          memset(_vstart, _val, _len);
      }
      while((_Bool)0);
    }

    i = 0;
    for( ; !(i >= nfields); i = i + 1)
    {
      signed int format;
      signed int return_value_pqGetInt_5;
      return_value_pqGetInt_5=pqGetInt(&format, (unsigned long int)2, conn);
      if(!(return_value_pqGetInt_5 == 0))
        goto failure;

      format = (signed int)(signed short int)format;
      (result->attDescs + (signed long int)i)->format = format;
    }
    conn->result = result;
    return 0;
  }

  else
  {

  failure:
    ;
    PQclear(result);
    return -1;
  }
}

// getNotify
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol2.c line 1114
static signed int getNotify(struct pg_conn *conn)
{
  signed int be_pid;
  signed int nmlen;
  struct pgNotify *newNotify;
  signed int return_value_pqGetInt_1;
  return_value_pqGetInt_1=pqGetInt(&be_pid, (unsigned long int)4, conn);
  if(!(return_value_pqGetInt_1 == 0))
    return -1;

  else
  {
    signed int return_value_pqGets_2;
    return_value_pqGets_2=pqGets(&conn->workBuffer, conn);
    if(!(return_value_pqGets_2 == 0))
      return -1;

    else
    {
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(conn->workBuffer.data);
      nmlen = (signed int)return_value_strlen_3;
      void *return_value_malloc_4;
      return_value_malloc_4=malloc(sizeof(struct pgNotify) /*32ul*/  + (unsigned long int)nmlen + (unsigned long int)1);
      newNotify = (struct pgNotify *)return_value_malloc_4;
      if(!(newNotify == ((struct pgNotify *)NULL)))
      {
        newNotify->relname = (char *)newNotify + (signed long int)sizeof(struct pgNotify) /*32ul*/ ;
        strcpy(newNotify->relname, conn->workBuffer.data);
        newNotify->extra = newNotify->relname + (signed long int)nmlen;
        newNotify->be_pid = be_pid;
        newNotify->next = (struct pgNotify *)(void *)0;
        if(!(conn->notifyTail == ((struct pgNotify *)NULL)))
          conn->notifyTail->next = newNotify;

        else
          conn->notifyHead = newNotify;
        conn->notifyTail = newNotify;
      }

      return 0;
    }
  }
}

// getNotify_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 1285
static signed int getNotify_link1(struct pg_conn *conn_link1)
{
  signed int be_pid_link1;
  char *svname;
  signed int nmlen_link1;
  signed int extralen;
  struct pgNotify *newNotify_link1;
  signed int return_value_pqGetInt_1_link1;
  return_value_pqGetInt_1_link1=pqGetInt(&be_pid_link1, (unsigned long int)4, conn_link1);
  if(!(return_value_pqGetInt_1_link1 == 0))
    return -1;

  else
  {
    signed int return_value_pqGets_2_link1;
    return_value_pqGets_2_link1=pqGets(&conn_link1->workBuffer, conn_link1);
    if(!(return_value_pqGets_2_link1 == 0))
      return -1;

    else
    {
      svname=strdup(conn_link1->workBuffer.data);
      if(svname == ((char *)NULL))
        return -1;

      else
      {
        signed int return_value_pqGets_3;
        return_value_pqGets_3=pqGets(&conn_link1->workBuffer, conn_link1);
        if(!(return_value_pqGets_3 == 0))
        {
          free((void *)svname);
          return -1;
        }

        else
        {
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(svname);
          nmlen_link1 = (signed int)return_value_strlen_4;
          unsigned long int return_value_strlen_5;
          return_value_strlen_5=strlen(conn_link1->workBuffer.data);
          extralen = (signed int)return_value_strlen_5;
          void *return_value_malloc_6;
          return_value_malloc_6=malloc(sizeof(struct pgNotify) /*32ul*/  + (unsigned long int)nmlen_link1 + (unsigned long int)extralen + (unsigned long int)2);
          newNotify_link1 = (struct pgNotify *)return_value_malloc_6;
          if(!(newNotify_link1 == ((struct pgNotify *)NULL)))
          {
            newNotify_link1->relname = (char *)newNotify_link1 + (signed long int)sizeof(struct pgNotify) /*32ul*/ ;
            strcpy(newNotify_link1->relname, svname);
            newNotify_link1->extra = newNotify_link1->relname + (signed long int)nmlen_link1 + (signed long int)1;
            strcpy(newNotify_link1->extra, conn_link1->workBuffer.data);
            newNotify_link1->be_pid = be_pid_link1;
            newNotify_link1->next = (struct pgNotify *)(void *)0;
            if(!(conn_link1->notifyTail == ((struct pgNotify *)NULL)))
              conn_link1->notifyTail->next = newNotify_link1;

            else
              conn_link1->notifyHead = newNotify_link1;
            conn_link1->notifyTail = newNotify_link1;
          }

          free((void *)svname);
          return 0;
        }
      }
    }
  }
}

// getParamDescriptions
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 640
static signed int getParamDescriptions(struct pg_conn *conn)
{
  struct pg_result *result;
  signed int nparams;
  signed int i;
  result=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_COMMAND_OK);
  signed int return_value_pqGetInt_1;
  signed long int *tmp_post_3;
  if(!(result == ((struct pg_result *)NULL)))
  {
    return_value_pqGetInt_1=pqGetInt(&result->numParameters, (unsigned long int)2, conn);
    if(!(return_value_pqGetInt_1 == 0))
      goto failure;

    nparams = result->numParameters;
    if(nparams >= 1)
    {
      void *return_value_pqResultAlloc_2;
      return_value_pqResultAlloc_2=pqResultAlloc(result, (unsigned long int)nparams * sizeof(struct pgresParamDesc) /*4ul*/ , (char)1);
      result->paramDescs = (struct pgresParamDesc *)return_value_pqResultAlloc_2;
      if(result->paramDescs == ((struct pgresParamDesc *)NULL))
        goto failure;

      do
      {
        void *_vstart = (void *)result->paramDescs;
        signed int _val = 0;
        unsigned long int _len = (unsigned long int)nparams * sizeof(struct pgresParamDesc) /*4ul*/ ;
        if((7ul & _len) == 0ul && (7ul & (unsigned long int)_vstart) == 0ul && _val == 0 && !(_len >= 1025ul))
        {
          signed long int *getParamDescriptions__1__1__1__1___start = (signed long int *)_vstart;
          signed long int *_stop = (signed long int *)((char *)getParamDescriptions__1__1__1__1___start + (signed long int)_len);
          for( ; !(getParamDescriptions__1__1__1__1___start >= _stop); *tmp_post_3 = (signed long int)0)
          {
            tmp_post_3 = getParamDescriptions__1__1__1__1___start;
            getParamDescriptions__1__1__1__1___start = getParamDescriptions__1__1__1__1___start + 1l;
          }
        }

        else
          memset(_vstart, _val, _len);
      }
      while((_Bool)0);
    }

    i = 0;
    for( ; !(i >= nparams); i = i + 1)
    {
      signed int typid;
      signed int return_value_pqGetInt_4;
      return_value_pqGetInt_4=pqGetInt(&typid, (unsigned long int)4, conn);
      if(!(return_value_pqGetInt_4 == 0))
        goto failure;

      (result->paramDescs + (signed long int)i)->typid = (unsigned int)typid;
    }
    conn->result = result;
    return 0;
  }

  else
  {

  failure:
    ;
    PQclear(result);
    return -1;
  }
}

// getParameterStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 1256
static signed int getParameterStatus(struct pg_conn *conn)
{
  struct PQExpBufferData valueBuf;
  signed int return_value_pqGets_1;
  return_value_pqGets_1=pqGets(&conn->workBuffer, conn);
  if(!(return_value_pqGets_1 == 0))
    return -1;

  else
  {
    initPQExpBuffer(&valueBuf);
    signed int return_value_pqGets_2;
    return_value_pqGets_2=pqGets(&valueBuf, conn);
    if(!(return_value_pqGets_2 == 0))
    {
      termPQExpBuffer(&valueBuf);
      return -1;
    }

    else
    {
      pqSaveParameterStatus(conn, conn->workBuffer.data, valueBuf.data);
      termPQExpBuffer(&valueBuf);
      return 0;
    }
  }
}

// getPgPassFilename
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5802
static char getPgPassFilename(char *pgpassfile)
{
  char *passfile_env;
  passfile_env=getenv("PGPASSFILE");
  if(!(passfile_env == ((char *)NULL)))
    strlcpy(pgpassfile, passfile_env, (unsigned long int)1024);

  else
  {
    char homedir[1024l];
    char return_value_pqGetHomeDirectory_1;
    return_value_pqGetHomeDirectory_1=pqGetHomeDirectory(homedir, (signed int)sizeof(char [1024l]) /*1024ul*/ );
    if(return_value_pqGetHomeDirectory_1 == 0)
      return (char)0;

    snprintf(pgpassfile, (unsigned long int)1024, "%s/%s", (const void *)homedir, (const void *)".pgpass");
  }
  return (char)1;
}

// getPoissonRand
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 484
static signed long int getPoissonRand(struct anonymous_17 *thread, signed long int center)
{
  double uniform;
  double return_value_pg_erand48_1;
  return_value_pg_erand48_1=pg_erand48(thread->random_state);
  uniform = 1.0 - return_value_pg_erand48_1;
  double return_value_log_2;
  return_value_log_2=log(uniform);
  return (signed long int)(-return_value_log_2 * (double)center + 0.5);
}

// getQueryParams
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 779
static void getQueryParams(struct anonymous_18 *st, const struct anonymous_22 *command, const char **params)
{
  signed int i = 0;
  for( ; !(i >= command->argc + -1); i = i + 1)
    params[(signed long int)i]=getVariable(st, command->argv[(signed long int)(i + 1)]);
}

// getReadyForQuery
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 1397
static signed int getReadyForQuery(struct pg_conn *conn)
{
  char xact_status;
  signed int return_value_pqGetc_1;
  return_value_pqGetc_1=pqGetc(&xact_status, conn);
  if(!(return_value_pqGetc_1 == 0))
    return -1;

  else
  {
    switch((signed int)xact_status)
    {
      case 73:
      {
        conn->xactStatus = (enum anonymous_3)PQTRANS_IDLE;
        break;
      }
      case 84:
      {
        conn->xactStatus = (enum anonymous_3)PQTRANS_INTRANS;
        break;
      }
      case 69:
      {
        conn->xactStatus = (enum anonymous_3)PQTRANS_INERROR;
        break;
      }
      default:
        conn->xactStatus = (enum anonymous_3)PQTRANS_UNKNOWN;
    }
    return 0;
  }
}

// getRowDescriptions
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol2.c line 659
static signed int getRowDescriptions(struct pg_conn *conn)
{
  struct pg_result *result;
  signed int nfields;
  const char *errmsg;
  signed int i;
  result=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_TUPLES_OK);
  signed int return_value_pqGetInt_1;
  signed long int *tmp_post_3;
  _Bool tmp_if_expr_6;
  signed int return_value_pqGetInt_5;
  _Bool tmp_if_expr_8;
  signed int return_value_pqGetInt_7;
  _Bool tmp_if_expr_10;
  signed int return_value_pqGetInt_9;
  if(result == ((struct pg_result *)NULL))
    errmsg = (const char *)(void *)0;

  else
  {
    return_value_pqGetInt_1=pqGetInt(&result->numAttributes, (unsigned long int)2, conn);
    if(!(return_value_pqGetInt_1 == 0))
      goto EOFexit;

    nfields = result->numAttributes;
    if(nfields >= 1)
    {
      void *return_value_pqResultAlloc_2;
      return_value_pqResultAlloc_2=pqResultAlloc(result, (unsigned long int)nfields * sizeof(struct pgresAttDesc) /*32ul*/ , (char)1);
      result->attDescs = (struct pgresAttDesc *)return_value_pqResultAlloc_2;
      if(result->attDescs == ((struct pgresAttDesc *)NULL))
      {
        errmsg = (const char *)(void *)0;
        goto advance_and_error;
      }

      do
      {
        void *_vstart = (void *)result->attDescs;
        signed int _val = 0;
        unsigned long int _len = (unsigned long int)nfields * sizeof(struct pgresAttDesc) /*32ul*/ ;
        if((7ul & _len) == 0ul && (7ul & (unsigned long int)_vstart) == 0ul && _val == 0 && !(_len >= 1025ul))
        {
          signed long int *getRowDescriptions__1__2__2__1___start = (signed long int *)_vstart;
          signed long int *_stop = (signed long int *)((char *)getRowDescriptions__1__2__2__1___start + (signed long int)_len);
          for( ; !(getRowDescriptions__1__2__2__1___start >= _stop); *tmp_post_3 = (signed long int)0)
          {
            tmp_post_3 = getRowDescriptions__1__2__2__1___start;
            getRowDescriptions__1__2__2__1___start = getRowDescriptions__1__2__2__1___start + 1l;
          }
        }

        else
          memset(_vstart, _val, _len);
      }
      while((_Bool)0);
    }

    i = 0;
    for( ; !(i >= nfields); i = i + 1)
    {
      signed int typid;
      signed int typlen;
      signed int atttypmod;
      signed int return_value_pqGets_4;
      return_value_pqGets_4=pqGets(&conn->workBuffer, conn);
      if(!(return_value_pqGets_4 == 0))
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_pqGetInt_5=pqGetInt(&typid, (unsigned long int)4, conn);
        tmp_if_expr_6 = return_value_pqGetInt_5 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        tmp_if_expr_8 = (_Bool)1;

      else
      {
        return_value_pqGetInt_7=pqGetInt(&typlen, (unsigned long int)2, conn);
        tmp_if_expr_8 = return_value_pqGetInt_7 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_8)
        tmp_if_expr_10 = (_Bool)1;

      else
      {
        return_value_pqGetInt_9=pqGetInt(&atttypmod, (unsigned long int)4, conn);
        tmp_if_expr_10 = return_value_pqGetInt_9 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_10)
        goto EOFexit;

      typlen = (signed int)(signed short int)typlen;
      (result->attDescs + (signed long int)i)->name=pqResultStrdup(result, conn->workBuffer.data);
      if((result->attDescs + (signed long int)i)->name == ((char *)NULL))
      {
        errmsg = (const char *)(void *)0;
        goto advance_and_error;
      }

      (result->attDescs + (signed long int)i)->tableid = (unsigned int)0;
      (result->attDescs + (signed long int)i)->columnid = 0;
      (result->attDescs + (signed long int)i)->format = 0;
      (result->attDescs + (signed long int)i)->typid = (unsigned int)typid;
      (result->attDescs + (signed long int)i)->typlen = typlen;
      (result->attDescs + (signed long int)i)->atttypmod = atttypmod;
    }
    conn->result = result;
    conn->inStart = conn->inCursor;
    return 0;
  }

advance_and_error:
  ;
  conn->inStart = conn->inEnd;
  pqClearAsyncResult(conn);
  if(errmsg == ((const char *)NULL))
    errmsg=libpq_gettext("out of memory for query result");

  printfPQExpBuffer(&conn->errorMessage, "%s\n", errmsg);
  conn->result=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_FATAL_ERROR);
  conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;

EOFexit:
  ;
  if(!(result == ((struct pg_result *)NULL)))
  {
    if(!(result == conn->result))
      PQclear(result);

  }

  return -1;
}

// getRowDescriptions_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 463
static signed int getRowDescriptions_link1(struct pg_conn *conn_link1, signed int msgLength)
{
  struct pg_result *result_link1;
  signed int nfields_link1;
  const char *errmsg_link1;
  signed int i_link1;
  if((signed int)conn_link1->queryclass == PGQUERY_DESCRIBE)
  {
    if(!(conn_link1->result == ((struct pg_result *)NULL)))
      result_link1 = conn_link1->result;

    else
      result_link1=PQmakeEmptyPGresult(conn_link1, (enum anonymous_20)PGRES_COMMAND_OK);
  }

  else
    result_link1=PQmakeEmptyPGresult(conn_link1, (enum anonymous_20)PGRES_TUPLES_OK);
  signed int return_value_pqGetInt_1_link1;
  signed long int *tmp_post_3_link1;
  _Bool tmp_if_expr_6_link1;
  signed int return_value_pqGetInt_5_link1;
  _Bool tmp_if_expr_8_link1;
  signed int return_value_pqGetInt_7_link1;
  _Bool tmp_if_expr_10_link1;
  signed int return_value_pqGetInt_9_link1;
  _Bool tmp_if_expr_12;
  signed int return_value_pqGetInt_11;
  _Bool tmp_if_expr_14;
  signed int return_value_pqGetInt_13;
  _Bool tmp_if_expr_16;
  signed int return_value_pqGetInt_15;
  if(result_link1 == ((struct pg_result *)NULL))
    errmsg_link1 = (const char *)(void *)0;

  else
  {
    return_value_pqGetInt_1_link1=pqGetInt(&result_link1->numAttributes, (unsigned long int)2, conn_link1);
    if(!(return_value_pqGetInt_1_link1 == 0))
      errmsg_link1=libpq_gettext("insufficient data in \"T\" message");

    else
    {
      nfields_link1 = result_link1->numAttributes;
      if(nfields_link1 >= 1)
      {
        void *return_value_pqResultAlloc_2_link1;
        return_value_pqResultAlloc_2_link1=pqResultAlloc(result_link1, (unsigned long int)nfields_link1 * sizeof(struct pgresAttDesc) /*32ul*/ , (char)1);
        result_link1->attDescs = (struct pgresAttDesc *)return_value_pqResultAlloc_2_link1;
        if(result_link1->attDescs == ((struct pgresAttDesc *)NULL))
        {
          errmsg_link1 = (const char *)(void *)0;
          goto advance_and_error;
        }

        do
        {
          void *_vstart = (void *)result_link1->attDescs;
          signed int _val = 0;
          unsigned long int _len = (unsigned long int)nfields_link1 * sizeof(struct pgresAttDesc) /*32ul*/ ;
          if((7ul & _len) == 0ul && (7ul & (unsigned long int)_vstart) == 0ul && _val == 0 && !(_len >= 1025ul))
          {
            signed long int *getRowDescriptions__1__4__2__1___start = (signed long int *)_vstart;
            signed long int *_stop = (signed long int *)((char *)getRowDescriptions__1__4__2__1___start + (signed long int)_len);
            for( ; !(getRowDescriptions__1__4__2__1___start >= _stop); *tmp_post_3_link1 = (signed long int)0)
            {
              tmp_post_3_link1 = getRowDescriptions__1__4__2__1___start;
              getRowDescriptions__1__4__2__1___start = getRowDescriptions__1__4__2__1___start + 1l;
            }
          }

          else
            memset(_vstart, _val, _len);
        }
        while((_Bool)0);
      }

      result_link1->binary = nfields_link1 > 0 ? 1 : 0;
      i_link1 = 0;
      for( ; !(i_link1 >= nfields_link1); i_link1 = i_link1 + 1)
      {
        signed int tableid;
        signed int columnid;
        signed int typid;
        signed int typlen;
        signed int atttypmod;
        signed int format;
        signed int return_value_pqGets_4_link1;
        return_value_pqGets_4_link1=pqGets(&conn_link1->workBuffer, conn_link1);
        if(!(return_value_pqGets_4_link1 == 0))
          tmp_if_expr_6_link1 = (_Bool)1;

        else
        {
          return_value_pqGetInt_5_link1=pqGetInt(&tableid, (unsigned long int)4, conn_link1);
          tmp_if_expr_6_link1 = return_value_pqGetInt_5_link1 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6_link1)
          tmp_if_expr_8_link1 = (_Bool)1;

        else
        {
          return_value_pqGetInt_7_link1=pqGetInt(&columnid, (unsigned long int)2, conn_link1);
          tmp_if_expr_8_link1 = return_value_pqGetInt_7_link1 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8_link1)
          tmp_if_expr_10_link1 = (_Bool)1;

        else
        {
          return_value_pqGetInt_9_link1=pqGetInt(&typid, (unsigned long int)4, conn_link1);
          tmp_if_expr_10_link1 = return_value_pqGetInt_9_link1 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_10_link1)
          tmp_if_expr_12 = (_Bool)1;

        else
        {
          return_value_pqGetInt_11=pqGetInt(&typlen, (unsigned long int)2, conn_link1);
          tmp_if_expr_12 = return_value_pqGetInt_11 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_12)
          tmp_if_expr_14 = (_Bool)1;

        else
        {
          return_value_pqGetInt_13=pqGetInt(&atttypmod, (unsigned long int)4, conn_link1);
          tmp_if_expr_14 = return_value_pqGetInt_13 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_14)
          tmp_if_expr_16 = (_Bool)1;

        else
        {
          return_value_pqGetInt_15=pqGetInt(&format, (unsigned long int)2, conn_link1);
          tmp_if_expr_16 = return_value_pqGetInt_15 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_16)
        {
          errmsg_link1=libpq_gettext("insufficient data in \"T\" message");
          goto advance_and_error;
        }

        columnid = (signed int)(signed short int)columnid;
        typlen = (signed int)(signed short int)typlen;
        format = (signed int)(signed short int)format;
        (result_link1->attDescs + (signed long int)i_link1)->name=pqResultStrdup(result_link1, conn_link1->workBuffer.data);
        if((result_link1->attDescs + (signed long int)i_link1)->name == ((char *)NULL))
        {
          errmsg_link1 = (const char *)(void *)0;
          goto advance_and_error;
        }

        (result_link1->attDescs + (signed long int)i_link1)->tableid = (unsigned int)tableid;
        (result_link1->attDescs + (signed long int)i_link1)->columnid = columnid;
        (result_link1->attDescs + (signed long int)i_link1)->format = format;
        (result_link1->attDescs + (signed long int)i_link1)->typid = (unsigned int)typid;
        (result_link1->attDescs + (signed long int)i_link1)->typlen = typlen;
        (result_link1->attDescs + (signed long int)i_link1)->atttypmod = atttypmod;
        if(!(format == 1))
          result_link1->binary = 0;

      }
      if(!(conn_link1->inCursor == 5 + conn_link1->inStart + msgLength))
        errmsg_link1=libpq_gettext("extraneous data in \"T\" message");

      else
      {
        conn_link1->result = result_link1;
        conn_link1->inStart = conn_link1->inCursor;
        if((signed int)conn_link1->queryclass == PGQUERY_DESCRIBE)
        {
          conn_link1->asyncStatus = (enum anonymous_9)PGASYNC_READY;
          return 0;
        }

        return 0;
      }
    }
  }

advance_and_error:
  ;
  if(!(result_link1 == ((struct pg_result *)NULL)))
  {
    if(!(result_link1 == conn_link1->result))
      PQclear(result_link1);

  }

  conn_link1->inStart = conn_link1->inStart + 5 + msgLength;
  pqClearAsyncResult(conn_link1);
  if(errmsg_link1 == ((const char *)NULL))
    errmsg_link1=libpq_gettext("out of memory for query result");

  printfPQExpBuffer(&conn_link1->errorMessage, "%s\n", errmsg_link1);
  pqSaveErrorResult(conn_link1);
  return 0;
}

// getVariable
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 602
static char * getVariable(struct anonymous_18 *st, char *name)
{
  struct anonymous_21 key;
  struct anonymous_21 *var;
  if(!(st->nvariables >= 1))
    return (char *)(void *)0;

  else
  {
    key.name = name;
    void *return_value_bsearch_1;
    return_value_bsearch_1=bsearch((void *)&key, (void *)st->variables, (unsigned long int)st->nvariables, sizeof(struct anonymous_21) /*16ul*/ , compareVariables);
    var = (struct anonymous_21 *)return_value_bsearch_1;
    if(!(var == ((struct anonymous_21 *)NULL)))
      return var->value;

    else
      return (char *)(void *)0;
  }
}

// get_doc_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 742
extern void get_doc_path(const char *my_exec_path, char *ret_path)
{
  make_relative_path(ret_path, "/usr/share/doc/postgresql-doc-9.4", "/usr/lib/postgresql/9.4/bin", my_exec_path);
}

// get_etc_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 51
extern void get_etc_path(const char *my_exec_path, char *ret_path)
{
  make_relative_path(ret_path, "/etc/postgresql-common", "/usr/lib/postgresql/9.4/bin", my_exec_path);
}

// get_hex
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 3434
static inline char get_hex(char c)
{
  signed int res = -1;
  if((signed int)c >= 1 && !((signed int)c >= 127))
    res = (signed int)hexlookup[(signed long int)(unsigned char)c];

  return (char)res;
}

// get_hexdigit
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5128
static char get_hexdigit(char digit, signed int *value)
{
  if((signed int)digit >= 48 && !((signed int)digit >= 58))
    *value = (signed int)digit - 48;

  else
    if((signed int)digit >= 65 && !((signed int)digit >= 71))
      *value = ((signed int)digit - 65) + 10;

    else
      if((signed int)digit >= 97 && !((signed int)digit >= 103))
        *value = ((signed int)digit - 97) + 10;

      else
        return (char)0;
  return (char)1;
}

// get_home_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 773
extern char get_home_path(char *ret_path)
{
  char pwdbuf[8192l];
  struct passwd pwdstr;
  struct passwd *pwd = (struct passwd *)(void *)0;
  unsigned int return_value_geteuid_1;
  return_value_geteuid_1=geteuid();
  pqGetpwuid(return_value_geteuid_1, &pwdstr, pwdbuf, sizeof(char [8192l]) /*8192ul*/ , &pwd);
  if(pwd == ((struct passwd *)NULL))
    return (char)0;

  else
  {
    strlcpy(ret_path, pwd->pw_dir, (unsigned long int)1024);
    return (char)1;
  }
}

// get_html_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 751
extern void get_html_path(const char *my_exec_path, char *ret_path)
{
  make_relative_path(ret_path, "/usr/share/doc/postgresql-doc-9.4", "/usr/lib/postgresql/9.4/bin", my_exec_path);
}

// get_include_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 688
extern void get_include_path(const char *my_exec_path, char *ret_path)
{
  make_relative_path(ret_path, "/usr/include/postgresql", "/usr/lib/postgresql/9.4/bin", my_exec_path);
}

// get_includeserver_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 706
extern void get_includeserver_path(const char *my_exec_path, char *ret_path)
{
  make_relative_path(ret_path, "/usr/include/postgresql/9.4/server", "/usr/lib/postgresql/9.4/bin", my_exec_path);
}

// get_lib_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 715
extern void get_lib_path(const char *my_exec_path, char *ret_path)
{
  make_relative_path(ret_path, "/usr/lib/x86_64-linux-gnu", "/usr/lib/postgresql/9.4/bin", my_exec_path);
}

// get_locale_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 57
extern void get_locale_path(const char *my_exec_path, char *ret_path)
{
  make_relative_path(ret_path, "/usr/share/locale", "/usr/lib/postgresql/9.4/bin", my_exec_path);
}

// get_man_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 760
extern void get_man_path(const char *my_exec_path, char *ret_path)
{
  make_relative_path(ret_path, "/usr/share/postgresql/9.4/man", "/usr/lib/postgresql/9.4/bin", my_exec_path);
}

// get_parent_directory
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 820
extern void get_parent_directory(char *path)
{
  trim_directory(path);
}

// get_pkginclude_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 697
extern void get_pkginclude_path(const char *my_exec_path, char *ret_path)
{
  make_relative_path(ret_path, "/usr/include/postgresql", "/usr/lib/postgresql/9.4/bin", my_exec_path);
}

// get_pkglib_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 724
extern void get_pkglib_path(const char *my_exec_path, char *ret_path)
{
  make_relative_path(ret_path, "/usr/lib/postgresql/9.4/lib", "/usr/lib/postgresql/9.4/bin", my_exec_path);
}

// get_progname
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 49
extern const char * get_progname(const char *argv0)
{
  const char *nodir_name;
  char *get_progname__1__progname;
  nodir_name=last_dir_separator(argv0);
  if(!(nodir_name == ((const char *)NULL)))
    nodir_name = nodir_name + 1l;

  else
    nodir_name = argv0;
  get_progname__1__progname=strdup(nodir_name);
  if(get_progname__1__progname == ((char *)NULL))
  {
    fprintf(stderr, "%s: out of memory\n", nodir_name);
    abort();
  }

  return get_progname__1__progname;
}

// get_share_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 670
extern void get_share_path(const char *my_exec_path, char *ret_path)
{
  make_relative_path(ret_path, "/usr/share/postgresql/9.4", "/usr/lib/postgresql/9.4/bin", my_exec_path);
}

// get_user_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/username.c line 33
extern const char * get_user_name(char **errstr)
{
  struct passwd *pw;
  unsigned int user_id;
  user_id=geteuid();
  *errstr = (char *)(void *)0;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  pw=getpwuid(user_id);
  char *tmp_if_expr_7;
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  char *return_value_gettext_6;
  if(pw == ((struct passwd *)NULL))
  {
    char *return_value_gettext_2;
    return_value_gettext_2=gettext("could not look up effective user ID %ld: %s");
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    if(!(*return_value___errno_location_3 == 0))
    {
      return_value___errno_location_4=__errno_location();
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      tmp_if_expr_7 = return_value_strerror_5;
    }

    else
    {
      return_value_gettext_6=gettext("user does not exist");
      tmp_if_expr_7 = return_value_gettext_6;
    }
    *errstr=psprintf(return_value_gettext_2, (signed long int)user_id, tmp_if_expr_7);
    return (const char *)(void *)0;
  }

  return pw->pw_name;
}

// get_user_name_or_exit
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/username.c line 76
extern const char * get_user_name_or_exit(const char *progname)
{
  const char *user_name;
  char *errstr;
  user_name=get_user_name(&errstr);
  if(user_name == ((const char *)NULL))
  {
    fprintf(stderr, "%s: %s\n", progname, errstr);
    exit(1);
  }

  return user_name;
}

// getaddrinfo_unix
// file ip.c line 172
static signed int getaddrinfo_unix(const char *path, struct addrinfo *hintsp, struct addrinfo **result)
{
  struct addrinfo hints;
  struct addrinfo *aip;
  struct sockaddr_un *unp;
  *result = (struct addrinfo *)(void *)0;
  signed long int *tmp_post_1;
  do
  {
    void *_vstart = (void *)&hints;
    signed int _val = 0;
    unsigned long int _len = sizeof(struct addrinfo) /*48ul*/ ;
    if((7ul & _len) == 0ul && (7ul & (unsigned long int)_vstart) == 0ul && _val == 0 && !(_len >= 1025ul))
    {
      signed long int *getaddrinfo_unix__1__1__1___start = (signed long int *)_vstart;
      signed long int *_stop = (signed long int *)((char *)getaddrinfo_unix__1__1__1___start + (signed long int)_len);
      for( ; !(getaddrinfo_unix__1__1__1___start >= _stop); *tmp_post_1 = (signed long int)0)
      {
        tmp_post_1 = getaddrinfo_unix__1__1__1___start;
        getaddrinfo_unix__1__1__1___start = getaddrinfo_unix__1__1__1___start + 1l;
      }
    }

    else
      memset(_vstart, _val, _len);
  }
  while((_Bool)0);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(path);
  if(return_value_strlen_2 >= sizeof(char [108l]) /*108ul*/ )
    return -4;

  else
  {
    if(hintsp == ((struct addrinfo *)NULL))
    {
      hints.ai_family = 1;
      hints.ai_socktype = 1;
    }

    else
      memcpy((void *)&hints, (const void *)hintsp, sizeof(struct addrinfo) /*48ul*/ );
    if(hints.ai_socktype == 0)
      hints.ai_socktype = 1;

    if(!(hints.ai_family == 1))
      return -4;

    else
    {
      void *return_value_calloc_3;
      return_value_calloc_3=calloc((unsigned long int)1, sizeof(struct addrinfo) /*48ul*/ );
      aip = (struct addrinfo *)return_value_calloc_3;
      if(aip == ((struct addrinfo *)NULL))
        return -10;

      else
      {
        void *return_value_calloc_4;
        return_value_calloc_4=calloc((unsigned long int)1, sizeof(struct sockaddr_un) /*110ul*/ );
        unp = (struct sockaddr_un *)return_value_calloc_4;
        if(unp == ((struct sockaddr_un *)NULL))
        {
          free((void *)aip);
          return -10;
        }

        else
        {
          aip->ai_family = 1;
          aip->ai_socktype = hints.ai_socktype;
          aip->ai_protocol = hints.ai_protocol;
          aip->ai_next = (struct addrinfo *)(void *)0;
          aip->ai_canonname = (char *)(void *)0;
          *result = aip;
          unp->sun_family = (unsigned short int)1;
          aip->ai_addr = (struct sockaddr *)unp;
          aip->ai_addrlen = (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ ;
          strcpy(unp->sun_path, path);
          return 0;
        }
      }
    }
  }
}

// getnameinfo_unix
// file ip.c line 238
static signed int getnameinfo_unix(struct sockaddr_un *sa, signed int salen, char *node, signed int nodelen, char *service, signed int servicelen, signed int flags)
{
  signed int ret = -1;
  _Bool tmp_if_expr_1;
  if(sa == ((struct sockaddr_un *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)sa->sun_family != 1 ? (_Bool)1 : (_Bool)0;
  if(node == ((char *)NULL) && service == ((char *)NULL) || tmp_if_expr_1)
    return -4;

  else
    if(!(node == ((char *)NULL)))
    {
      ret=snprintf(node, (unsigned long int)nodelen, "%s", (const void *)"[local]");
      if(!(ret == -1) && nodelen >= ret)
        goto __CPROVER_DUMP_L4;

      return -10;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      if(!(service == ((char *)NULL)))
      {
        ret=snprintf(service, (unsigned long int)servicelen, "%s", (const void *)sa->sun_path);
        if(!(ret == -1) && servicelen >= ret)
          goto __CPROVER_DUMP_L5;

        return -10;
      }

      else
      {

      __CPROVER_DUMP_L5:
        ;
        return 0;
      }
    }
}

// getpeereid
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/getpeereid.c line 35
extern signed int getpeereid(signed int sock, unsigned int *uid, unsigned int *gid)
{
  struct ucred peercred;
  unsigned int so_len = (unsigned int)sizeof(struct ucred) /*12ul*/ ;
  signed int return_value_getsockopt_1;
  return_value_getsockopt_1=getsockopt(sock, 1, 17, (void *)&peercred, &so_len);
  if(!(return_value_getsockopt_1 == 0) || !((unsigned long int)so_len == sizeof(struct ucred) /*12ul*/ ))
    return -1;

  else
  {
    *uid = peercred.uid;
    *gid = peercred.gid;
    return 0;
  }
}

// getrand
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 465
static signed long int getrand(struct anonymous_17 *thread, signed long int min, signed long int max)
{
  double return_value_pg_erand48_1;
  return_value_pg_erand48_1=pg_erand48(thread->random_state);
  return min + (signed long int)((double)((max - min) + (signed long int)1) * return_value_pg_erand48_1);
}

// handleSyncLoss
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 440
static void handleSyncLoss(struct pg_conn *conn, char id, signed int msgLength)
{
  char *return_value_libpq_gettext_1;
  return_value_libpq_gettext_1=libpq_gettext("lost synchronization with server: got message type \"%c\", length %d\n");
  printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1, id, msgLength);
  pqSaveErrorResult(conn);
  conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
  pqDropConnection(conn);
  conn->status = (enum anonymous_24)CONNECTION_BAD;
}

// handle_sig_alarm
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 3454
static void handle_sig_alarm(signed int postgres_signal_arg)
{
  timer_exceeded = (char)1;
}

// has_drive_prefix
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 87
extern char has_drive_prefix(const char *path)
{
  return (char)(path != path);
}

// inet_net_ntop
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/inet_net_ntop.c line 78
extern char * inet_net_ntop(signed int af, const void *src, signed int bits, char *dst, unsigned long int size)
{
  char *return_value_inet_net_ntop_ipv4_1;
  char *return_value_inet_net_ntop_ipv6_2;
  if(!(af == 0))
  {
    if(af == 1 || af == 10)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    return_value_inet_net_ntop_ipv4_1=inet_net_ntop_ipv4((const unsigned char *)src, bits, dst, size);
    return return_value_inet_net_ntop_ipv4_1;

  __CPROVER_DUMP_L2:
    ;
    return_value_inet_net_ntop_ipv6_2=inet_net_ntop_ipv6((const unsigned char *)src, bits, dst, size);
    return return_value_inet_net_ntop_ipv6_2;
  }
  signed int *return_value___errno_location_3;
  return_value___errno_location_3=__errno_location();
  *return_value___errno_location_3 = 97;
  return (char *)(void *)0;
}

// inet_net_ntop_ipv4
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/inet_net_ntop.c line 116
static char * inet_net_ntop_ipv4(const unsigned char *src, signed int bits, char *dst, unsigned long int size)
{
  char *odst = dst;
  char *t;
  signed int len = 4;
  signed int b;
  if(bits >= 33 || !(bits >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return (char *)(void *)0;
  }

  b = len;
  char *tmp_post_2;
  const unsigned char *tmp_post_3;
  for( ; b >= 1; b = b - 1)
  {
    if(!(size >= 6ul))
      goto emsgsize;

    t = dst;
    if(!(dst == odst))
    {
      tmp_post_2 = dst;
      dst = dst + 1l;
      *tmp_post_2 = (char)46;
    }

    tmp_post_3 = src;
    src = src + 1l;
    signed int return_value_sprintf_4;
    return_value_sprintf_4=sprintf(dst, "%u", *tmp_post_3);
    dst = dst + (signed long int)(unsigned long int)return_value_sprintf_4;
    size = size - (unsigned long int)(dst - t);
  }
  if(!(bits == 32))
  {
    if(!(size >= 5ul))
      goto emsgsize;

    signed int return_value_sprintf_5;
    return_value_sprintf_5=sprintf(dst, "/%u", bits);
    dst = dst + (signed long int)(unsigned long int)return_value_sprintf_5;
  }

  return odst;

emsgsize:
  ;
  signed int *return_value___errno_location_6;
  return_value___errno_location_6=__errno_location();
  *return_value___errno_location_6 = 90;
  return (char *)(void *)0;
}

// inet_net_ntop_ipv4_link1
// file inet_net_ntop.c line 116
static char * inet_net_ntop_ipv4_link1(const unsigned char *src_link1, signed int bits_link1, char *dst_link1, unsigned long int size_link1)
{
  char *odst_link1 = dst_link1;
  char *t_link1;
  signed int len_link1 = 4;
  signed int b_link1;
  if(bits_link1 >= 33 || !(bits_link1 >= 0))
  {
    signed int *return_value___errno_location_1_link1;
    return_value___errno_location_1_link1=__errno_location();
    *return_value___errno_location_1_link1 = 22;
    return (char *)(void *)0;
  }

  b_link1 = len_link1;
  char *tmp_post_2_link1;
  const unsigned char *tmp_post_3_link1;
  for( ; b_link1 >= 1; b_link1 = b_link1 - 1)
  {
    if(!(size_link1 >= 6ul))
      goto emsgsize;

    t_link1 = dst_link1;
    if(!(dst_link1 == odst_link1))
    {
      tmp_post_2_link1 = dst_link1;
      dst_link1 = dst_link1 + 1l;
      *tmp_post_2_link1 = (char)46;
    }

    tmp_post_3_link1 = src_link1;
    src_link1 = src_link1 + 1l;
    signed int return_value_sprintf_4_link1;
    return_value_sprintf_4_link1=sprintf(dst_link1, "%u", *tmp_post_3_link1);
    dst_link1 = dst_link1 + (signed long int)(unsigned long int)return_value_sprintf_4_link1;
    size_link1 = size_link1 - (unsigned long int)(dst_link1 - t_link1);
  }
  if(!(bits_link1 == 32))
  {
    if(!(size_link1 >= 5ul))
      goto emsgsize;

    signed int return_value_sprintf_5_link1;
    return_value_sprintf_5_link1=sprintf(dst_link1, "/%u", bits_link1);
    dst_link1 = dst_link1 + (signed long int)(unsigned long int)return_value_sprintf_5_link1;
  }

  return odst_link1;

emsgsize:
  ;
  signed int *return_value___errno_location_6_link1;
  return_value___errno_location_6_link1=__errno_location();
  *return_value___errno_location_6_link1 = 90;
  return (char *)(void *)0;
}

// inet_net_ntop_ipv4_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/inet_net_ntop.c line 116
static char * inet_net_ntop_ipv4_link2(const unsigned char *src_link2, signed int bits_link2, char *dst_link2, unsigned long int size_link2)
{
  char *odst_link2 = dst_link2;
  char *t_link2;
  signed int len_link2 = 4;
  signed int b_link2;
  if(bits_link2 >= 33 || !(bits_link2 >= 0))
  {
    signed int *return_value___errno_location_1_link2;
    return_value___errno_location_1_link2=__errno_location();
    *return_value___errno_location_1_link2 = 22;
    return (char *)(void *)0;
  }

  b_link2 = len_link2;
  char *tmp_post_2_link2;
  const unsigned char *tmp_post_3_link2;
  for( ; b_link2 >= 1; b_link2 = b_link2 - 1)
  {
    if(!(size_link2 >= 6ul))
      goto emsgsize;

    t_link2 = dst_link2;
    if(!(dst_link2 == odst_link2))
    {
      tmp_post_2_link2 = dst_link2;
      dst_link2 = dst_link2 + 1l;
      *tmp_post_2_link2 = (char)46;
    }

    tmp_post_3_link2 = src_link2;
    src_link2 = src_link2 + 1l;
    signed int return_value_sprintf_4_link2;
    return_value_sprintf_4_link2=sprintf(dst_link2, "%u", *tmp_post_3_link2);
    dst_link2 = dst_link2 + (signed long int)(unsigned long int)return_value_sprintf_4_link2;
    size_link2 = size_link2 - (unsigned long int)(dst_link2 - t_link2);
  }
  if(!(bits_link2 == 32))
  {
    if(!(size_link2 >= 5ul))
      goto emsgsize;

    signed int return_value_sprintf_5_link2;
    return_value_sprintf_5_link2=sprintf(dst_link2, "/%u", bits_link2);
    dst_link2 = dst_link2 + (signed long int)(unsigned long int)return_value_sprintf_5_link2;
  }

  return odst_link2;

emsgsize:
  ;
  signed int *return_value___errno_location_6_link2;
  return_value___errno_location_6_link2=__errno_location();
  *return_value___errno_location_6_link2 = 90;
  return (char *)(void *)0;
}

// inet_net_ntop_ipv6
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/inet_net_ntop.c line 180
static char * inet_net_ntop_ipv6(const unsigned char *src, signed int bits, char *dst, unsigned long int size)
{
  char tmp[(signed long int)sizeof(char [50l]) /*50l*/ ];
  char *tp;
  /* tag-#anon#lST[S32'base'||S32'len'|] */
struct anonymous_16
{
  // base
  signed int base;
  // len
  signed int len;
};

/* */
  ;
  struct anonymous_16 best;
  struct anonymous_16 cur;
  unsigned int words[8l];
  signed int i;
  if(bits >= 129 || !(bits >= -1))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return (char *)(void *)0;
  }

  memset((void *)words, 0, sizeof(unsigned int [8l]) /*32ul*/ );
  i = 0;
  for( ; !(i >= 16); i = i + 1)
    words[(signed long int)(i / 2)] = words[(signed long int)(i / 2)] | (unsigned int)((signed int)src[(signed long int)i] << (1 - i % 2 << 3));
  best.base = -1;
  cur.base = -1;
  best.len = 0;
  cur.len = 0;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    if(words[(signed long int)i] == 0u)
    {
      if(cur.base == -1)
      {
        cur.base = i;
        cur.len = 1;
      }

      else
        cur.len = cur.len + 1;
    }

    else
      if(!(cur.base == -1))
      {
        if(best.base == -1 || !(best.len >= cur.len))
          best = cur;

        cur.base = -1;
      }

  if(!(cur.base == -1))
  {
    if(best.base == -1 || !(best.len >= cur.len))
      best = cur;

  }

  if(!(best.base == -1) && !(best.len >= 2))
    best.base = -1;

  tp = tmp;
  i = 0;
  char *tmp_post_2;
  char *tmp_post_3;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  for( ; !(i >= 8); i = i + 1)
    if(i >= best.base && !(best.base == -1) && !(i >= best.base + best.len))
    {
      if(i == best.base)
      {
        tmp_post_2 = tp;
        tp = tp + 1l;
        *tmp_post_2 = (char)58;
      }

    }

    else
    {
      if(!(i == 0))
      {
        tmp_post_3 = tp;
        tp = tp + 1l;
        *tmp_post_3 = (char)58;
      }

      if(best.base == 0 && i == 6)
      {
        if(best.len == 6)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          if(best.len == 7)
            tmp_if_expr_6 = words[(signed long int)7] != (unsigned int)0x0001 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6 = (_Bool)0;
          tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
          tmp_if_expr_9 = (_Bool)1;

        else
        {
          if(best.len == 5)
            tmp_if_expr_8 = words[(signed long int)5] == (unsigned int)0xffff ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_8 = (_Bool)0;
          tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_9)
        {
          signed int n;
          n=decoct(src + (signed long int)12, 4, tp, sizeof(char [50l]) /*50ul*/  - (unsigned long int)(tp - tmp));
          if(n == 0)
          {
            signed int *return_value___errno_location_4;
            return_value___errno_location_4=__errno_location();
            *return_value___errno_location_4 = 90;
            return (char *)(void *)0;
          }

          unsigned long int return_value_strlen_5;
          return_value_strlen_5=strlen(tp);
          tp = tp + (signed long int)return_value_strlen_5;
          break;
        }

      }

      signed int return_value_sprintf_10;
      return_value_sprintf_10=sprintf(tp, "%x", words[(signed long int)i]);
      tp = tp + (signed long int)(unsigned long int)return_value_sprintf_10;
    }
  char *tmp_post_11;
  if(best.base + best.len == 8 && !(best.base == -1))
  {
    tmp_post_11 = tp;
    tp = tp + 1l;
    *tmp_post_11 = (char)58;
  }

  *tp = (char)0;
  signed int return_value_sprintf_12;
  if(!(bits == 128) && !(bits == -1))
  {
    return_value_sprintf_12=sprintf(tp, "/%u", bits);
    tp = tp + (signed long int)(unsigned long int)return_value_sprintf_12;
  }

  if(!(size >= (unsigned long int)(tp - tmp)))
  {
    signed int *return_value___errno_location_13;
    return_value___errno_location_13=__errno_location();
    *return_value___errno_location_13 = 90;
    return (char *)(void *)0;
  }

  strcpy(dst, tmp);
  return dst;
}

// inet_net_ntop_ipv6_link1
// file inet_net_ntop.c line 180
static char * inet_net_ntop_ipv6_link1(const unsigned char *src_link1, signed int bits_link1, char *dst_link1, unsigned long int size_link1)
{
  char tmp_link1[(signed long int)sizeof(char [50l]) /*50l*/ ];
  char *tp_link1;
  /* tag-#anon#lST[S32'base'||S32'len'|] */
struct anonymous_16
{
  // base
  signed int base;
  // len
  signed int len;
};

/* */
  ;
  struct anonymous_16 best_link1;
  struct anonymous_16 cur_link1;
  unsigned int words_link1[8l];
  signed int i_link1;
  if(bits_link1 >= 129 || !(bits_link1 >= -1))
  {
    signed int *return_value___errno_location_1_link1;
    return_value___errno_location_1_link1=__errno_location();
    *return_value___errno_location_1_link1 = 22;
    return (char *)(void *)0;
  }

  memset((void *)words_link1, 0, sizeof(unsigned int [8l]) /*32ul*/ );
  i_link1 = 0;
  for( ; !(i_link1 >= 16); i_link1 = i_link1 + 1)
    words_link1[(signed long int)(i_link1 / 2)] = words_link1[(signed long int)(i_link1 / 2)] | (unsigned int)((signed int)src_link1[(signed long int)i_link1] << (1 - i_link1 % 2 << 3));
  best_link1.base = -1;
  cur_link1.base = -1;
  best_link1.len = 0;
  cur_link1.len = 0;
  i_link1 = 0;
  for( ; !(i_link1 >= 8); i_link1 = i_link1 + 1)
    if(words_link1[(signed long int)i_link1] == 0u)
    {
      if(cur_link1.base == -1)
      {
        cur_link1.base = i_link1;
        cur_link1.len = 1;
      }

      else
        cur_link1.len = cur_link1.len + 1;
    }

    else
      if(!(cur_link1.base == -1))
      {
        if(best_link1.base == -1 || !(best_link1.len >= cur_link1.len))
          best_link1 = cur_link1;

        cur_link1.base = -1;
      }

  if(!(cur_link1.base == -1))
  {
    if(best_link1.base == -1 || !(best_link1.len >= cur_link1.len))
      best_link1 = cur_link1;

  }

  if(!(best_link1.base == -1) && !(best_link1.len >= 2))
    best_link1.base = -1;

  tp_link1 = tmp_link1;
  i_link1 = 0;
  char *tmp_post_2_link1;
  char *tmp_post_3_link1;
  _Bool tmp_if_expr_7_link1;
  _Bool tmp_if_expr_6_link1;
  _Bool tmp_if_expr_9_link1;
  _Bool tmp_if_expr_8_link1;
  for( ; !(i_link1 >= 8); i_link1 = i_link1 + 1)
    if(i_link1 >= best_link1.base && !(best_link1.base == -1) && !(i_link1 >= best_link1.base + best_link1.len))
    {
      if(i_link1 == best_link1.base)
      {
        tmp_post_2_link1 = tp_link1;
        tp_link1 = tp_link1 + 1l;
        *tmp_post_2_link1 = (char)58;
      }

    }

    else
    {
      if(!(i_link1 == 0))
      {
        tmp_post_3_link1 = tp_link1;
        tp_link1 = tp_link1 + 1l;
        *tmp_post_3_link1 = (char)58;
      }

      if(best_link1.base == 0 && i_link1 == 6)
      {
        if(best_link1.len == 6)
          tmp_if_expr_7_link1 = (_Bool)1;

        else
        {
          if(best_link1.len == 7)
            tmp_if_expr_6_link1 = words_link1[(signed long int)7] != (unsigned int)0x0001 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6_link1 = (_Bool)0;
          tmp_if_expr_7_link1 = tmp_if_expr_6_link1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7_link1)
          tmp_if_expr_9_link1 = (_Bool)1;

        else
        {
          if(best_link1.len == 5)
            tmp_if_expr_8_link1 = words_link1[(signed long int)5] == (unsigned int)0xffff ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_8_link1 = (_Bool)0;
          tmp_if_expr_9_link1 = tmp_if_expr_8_link1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_9_link1)
        {
          signed int n_link1;
          n_link1=decoct_link1(src_link1 + (signed long int)12, 4, tp_link1, sizeof(char [50l]) /*50ul*/  - (unsigned long int)(tp_link1 - tmp_link1));
          if(n_link1 == 0)
          {
            signed int *return_value___errno_location_4_link1;
            return_value___errno_location_4_link1=__errno_location();
            *return_value___errno_location_4_link1 = 90;
            return (char *)(void *)0;
          }

          unsigned long int return_value_strlen_5_link1;
          return_value_strlen_5_link1=strlen(tp_link1);
          tp_link1 = tp_link1 + (signed long int)return_value_strlen_5_link1;
          break;
        }

      }

      signed int return_value_sprintf_10_link1;
      return_value_sprintf_10_link1=sprintf(tp_link1, "%x", words_link1[(signed long int)i_link1]);
      tp_link1 = tp_link1 + (signed long int)(unsigned long int)return_value_sprintf_10_link1;
    }
  char *tmp_post_11_link1;
  if(best_link1.base + best_link1.len == 8 && !(best_link1.base == -1))
  {
    tmp_post_11_link1 = tp_link1;
    tp_link1 = tp_link1 + 1l;
    *tmp_post_11_link1 = (char)58;
  }

  *tp_link1 = (char)0;
  signed int return_value_sprintf_12_link1;
  if(!(bits_link1 == 128) && !(bits_link1 == -1))
  {
    return_value_sprintf_12_link1=sprintf(tp_link1, "/%u", bits_link1);
    tp_link1 = tp_link1 + (signed long int)(unsigned long int)return_value_sprintf_12_link1;
  }

  if(!(size_link1 >= (unsigned long int)(tp_link1 - tmp_link1)))
  {
    signed int *return_value___errno_location_13_link1;
    return_value___errno_location_13_link1=__errno_location();
    *return_value___errno_location_13_link1 = 90;
    return (char *)(void *)0;
  }

  strcpy(dst_link1, tmp_link1);
  return dst_link1;
}

// inet_net_ntop_ipv6_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/inet_net_ntop.c line 180
static char * inet_net_ntop_ipv6_link2(const unsigned char *src_link2, signed int bits_link2, char *dst_link2, unsigned long int size_link2)
{
  char tmp_link2[(signed long int)sizeof(char [50l]) /*50l*/ ];
  char *tp_link2;
  /* tag-#anon#lST[S32'base'||S32'len'|] */
struct anonymous_16
{
  // base
  signed int base;
  // len
  signed int len;
};

/* */
  ;
  struct anonymous_16 best_link2;
  struct anonymous_16 cur_link2;
  unsigned int words_link2[8l];
  signed int i_link2;
  if(bits_link2 >= 129 || !(bits_link2 >= -1))
  {
    signed int *return_value___errno_location_1_link2;
    return_value___errno_location_1_link2=__errno_location();
    *return_value___errno_location_1_link2 = 22;
    return (char *)(void *)0;
  }

  memset((void *)words_link2, 0, sizeof(unsigned int [8l]) /*32ul*/ );
  i_link2 = 0;
  for( ; !(i_link2 >= 16); i_link2 = i_link2 + 1)
    words_link2[(signed long int)(i_link2 / 2)] = words_link2[(signed long int)(i_link2 / 2)] | (unsigned int)((signed int)src_link2[(signed long int)i_link2] << (1 - i_link2 % 2 << 3));
  best_link2.base = -1;
  cur_link2.base = -1;
  best_link2.len = 0;
  cur_link2.len = 0;
  i_link2 = 0;
  for( ; !(i_link2 >= 8); i_link2 = i_link2 + 1)
    if(words_link2[(signed long int)i_link2] == 0u)
    {
      if(cur_link2.base == -1)
      {
        cur_link2.base = i_link2;
        cur_link2.len = 1;
      }

      else
        cur_link2.len = cur_link2.len + 1;
    }

    else
      if(!(cur_link2.base == -1))
      {
        if(best_link2.base == -1 || !(best_link2.len >= cur_link2.len))
          best_link2 = cur_link2;

        cur_link2.base = -1;
      }

  if(!(cur_link2.base == -1))
  {
    if(best_link2.base == -1 || !(best_link2.len >= cur_link2.len))
      best_link2 = cur_link2;

  }

  if(!(best_link2.base == -1) && !(best_link2.len >= 2))
    best_link2.base = -1;

  tp_link2 = tmp_link2;
  i_link2 = 0;
  char *tmp_post_2_link2;
  char *tmp_post_3_link2;
  _Bool tmp_if_expr_7_link2;
  _Bool tmp_if_expr_6_link2;
  _Bool tmp_if_expr_9_link2;
  _Bool tmp_if_expr_8_link2;
  for( ; !(i_link2 >= 8); i_link2 = i_link2 + 1)
    if(i_link2 >= best_link2.base && !(best_link2.base == -1) && !(i_link2 >= best_link2.base + best_link2.len))
    {
      if(i_link2 == best_link2.base)
      {
        tmp_post_2_link2 = tp_link2;
        tp_link2 = tp_link2 + 1l;
        *tmp_post_2_link2 = (char)58;
      }

    }

    else
    {
      if(!(i_link2 == 0))
      {
        tmp_post_3_link2 = tp_link2;
        tp_link2 = tp_link2 + 1l;
        *tmp_post_3_link2 = (char)58;
      }

      if(best_link2.base == 0 && i_link2 == 6)
      {
        if(best_link2.len == 6)
          tmp_if_expr_7_link2 = (_Bool)1;

        else
        {
          if(best_link2.len == 7)
            tmp_if_expr_6_link2 = words_link2[(signed long int)7] != (unsigned int)0x0001 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6_link2 = (_Bool)0;
          tmp_if_expr_7_link2 = tmp_if_expr_6_link2 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7_link2)
          tmp_if_expr_9_link2 = (_Bool)1;

        else
        {
          if(best_link2.len == 5)
            tmp_if_expr_8_link2 = words_link2[(signed long int)5] == (unsigned int)0xffff ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_8_link2 = (_Bool)0;
          tmp_if_expr_9_link2 = tmp_if_expr_8_link2 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_9_link2)
        {
          signed int n_link2;
          n_link2=decoct_link2(src_link2 + (signed long int)12, 4, tp_link2, sizeof(char [50l]) /*50ul*/  - (unsigned long int)(tp_link2 - tmp_link2));
          if(n_link2 == 0)
          {
            signed int *return_value___errno_location_4_link2;
            return_value___errno_location_4_link2=__errno_location();
            *return_value___errno_location_4_link2 = 90;
            return (char *)(void *)0;
          }

          unsigned long int return_value_strlen_5_link2;
          return_value_strlen_5_link2=strlen(tp_link2);
          tp_link2 = tp_link2 + (signed long int)return_value_strlen_5_link2;
          break;
        }

      }

      signed int return_value_sprintf_10_link2;
      return_value_sprintf_10_link2=sprintf(tp_link2, "%x", words_link2[(signed long int)i_link2]);
      tp_link2 = tp_link2 + (signed long int)(unsigned long int)return_value_sprintf_10_link2;
    }
  char *tmp_post_11_link2;
  if(best_link2.base + best_link2.len == 8 && !(best_link2.base == -1))
  {
    tmp_post_11_link2 = tp_link2;
    tp_link2 = tp_link2 + 1l;
    *tmp_post_11_link2 = (char)58;
  }

  *tp_link2 = (char)0;
  signed int return_value_sprintf_12_link2;
  if(!(bits_link2 == 128) && !(bits_link2 == -1))
  {
    return_value_sprintf_12_link2=sprintf(tp_link2, "/%u", bits_link2);
    tp_link2 = tp_link2 + (signed long int)(unsigned long int)return_value_sprintf_12_link2;
  }

  if(!(size_link2 >= (unsigned long int)(tp_link2 - tmp_link2)))
  {
    signed int *return_value___errno_location_13_link2;
    return_value___errno_location_13_link2=__errno_location();
    *return_value___errno_location_13_link2 = 90;
    return (char *)(void *)0;
  }

  strcpy(dst_link2, tmp_link2);
  return dst_link2;
}

// init
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 1624
static void init(char is_no_vacuum)
{
  struct pg_conn *con;
  struct pg_result *res;
  char sql[256l];
  signed int i;
  signed long int k;
  struct timeval start;
  struct timeval diff;
  double elapsed_sec;
  double remaining_sec;
  signed int log_interval = 1;
  con=doConnect();
  if(con == ((struct pg_conn *)NULL))
    exit(1);

  i = 0;
  unsigned long int return_value_strlen_1;
  unsigned long int return_value_strlen_2;
  const char *tmp_if_expr_6;
  for( ; !((unsigned long int)i >= 4ul); i = i + 1)
  {
    char opts[256l];
    char init__1__1__1__buffer[256l];
    /* init::1::tag-ddlinfo */
struct ddlinfo
{
  // table
  const char *table;
  // smcols
  const char *smcols;
  // bigcols
  const char *bigcols;
  // declare_fillfactor
  signed int declare_fillfactor;
};

/* */
    ;
    static struct ddlinfo DDLs[4l] = { { .table="pgbench_history", .smcols="tid int,bid int,aid    int,delta int,mtime timestamp,filler char(22)", .bigcols="tid int,bid int,aid bigint,delta int,mtime timestamp,filler char(22)",
    .declare_fillfactor=0 },
    { .table="pgbench_tellers", .smcols="tid int not null,bid int,tbalance int,filler char(84)", .bigcols="tid int not null,bid int,tbalance int,filler char(84)",
    .declare_fillfactor=1 },
    { .table="pgbench_accounts", .smcols="aid    int not null,bid int,abalance int,filler char(84)", .bigcols="aid bigint not null,bid int,abalance int,filler char(84)",
    .declare_fillfactor=1 },
    { .table="pgbench_branches", .smcols="bid int not null,bbalance int,filler char(88)", .bigcols="bid int not null,bbalance int,filler char(88)",
    .declare_fillfactor=1 } };
    struct ddlinfo *ddl = &DDLs[(signed long int)i];
    const char *cols;
    snprintf(init__1__1__1__buffer, sizeof(char [256l]) /*256ul*/ , "drop table if exists %s", ddl->table);
    executeStatement(con, init__1__1__1__buffer);
    opts[(signed long int)0] = (char)0;
    if(!(ddl->declare_fillfactor == 0))
    {
      return_value_strlen_1=strlen(opts);
      return_value_strlen_2=strlen(opts);
      snprintf(opts + (signed long int)return_value_strlen_1, sizeof(char [256l]) /*256ul*/  - return_value_strlen_2, " with (fillfactor=%d)", fillfactor);
    }

    if(!(tablespace == ((char *)NULL)))
    {
      char *escape_tablespace;
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(tablespace);
      escape_tablespace=PQescapeIdentifier(con, tablespace, return_value_strlen_3);
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(opts);
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(opts);
      snprintf(opts + (signed long int)return_value_strlen_4, sizeof(char [256l]) /*256ul*/  - return_value_strlen_5, " tablespace %s", escape_tablespace);
      PQfreemem((void *)escape_tablespace);
    }

    if(scale >= 20000)
      tmp_if_expr_6 = ddl->bigcols;

    else
      tmp_if_expr_6 = ddl->smcols;
    cols = tmp_if_expr_6;
    snprintf(init__1__1__1__buffer, sizeof(char [256l]) /*256ul*/ , "create%s table %s(%s)%s", unlogged_tables != 0 ? " unlogged" : "", ddl->table, cols, (const void *)opts);
    executeStatement(con, init__1__1__1__buffer);
  }
  executeStatement(con, "begin");
  i = 0;
  for( ; !(i >= scale); i = i + 1)
  {
    snprintf(sql, sizeof(char [256l]) /*256ul*/ , "insert into pgbench_branches(bid,bbalance) values(%d,0)", i + 1);
    executeStatement(con, sql);
  }
  i = 0;
  for( ; !(i >= 10 * scale); i = i + 1)
  {
    snprintf(sql, sizeof(char [256l]) /*256ul*/ , "insert into pgbench_tellers(tid,bid,tbalance) values (%d,%d,0)", i + 1, i / 10 + 1);
    executeStatement(con, sql);
  }
  executeStatement(con, "commit");
  fprintf(stderr, "creating tables...\n");
  executeStatement(con, "begin");
  executeStatement(con, "truncate pgbench_accounts");
  res=PQexec(con, "copy pgbench_accounts from stdin");
  enum anonymous_20 return_value_PQresultStatus_8;
  return_value_PQresultStatus_8=PQresultStatus(res);
  if(!((signed int)return_value_PQresultStatus_8 == PGRES_COPY_IN))
  {
    char *return_value_PQerrorMessage_7;
    return_value_PQerrorMessage_7=PQerrorMessage(con);
    fprintf(stderr, "%s", return_value_PQerrorMessage_7);
    exit(1);
  }

  PQclear(res);
  gettimeofday(&start, (struct timezone *)(void *)0);
  k = (signed long int)0;
  for( ; !(k >= 100000l * (signed long int)scale); k = k + 1l)
  {
    signed long int j = k + (signed long int)1;
    snprintf(sql, sizeof(char [256l]) /*256ul*/ , "%ld\t%ld\t%d\t\n", j, k / (signed long int)100000 + (signed long int)1, 0);
    signed int return_value_PQputline_9;
    return_value_PQputline_9=PQputline(con, sql);
    if(!(return_value_PQputline_9 == 0))
    {
      fprintf(stderr, "PQputline failed\n");
      exit(1);
    }

    if(j % 100000l == 0l && use_quiet == 0)
    {
      gettimeofday(&diff, (struct timezone *)(void *)0);
      do
      {
        diff.tv_sec = diff.tv_sec - start.tv_sec;
        diff.tv_usec = diff.tv_usec - start.tv_usec;
        for( ; !(diff.tv_usec >= 0l); diff.tv_sec = diff.tv_sec - 1l)
          diff.tv_usec = diff.tv_usec + (signed long int)1000000;
      }
      while((_Bool)0);
      elapsed_sec = (double)diff.tv_sec + (double)diff.tv_usec / 1000000.0;
      remaining_sec = (((double)scale * (double)100000 - (double)j) * elapsed_sec) / (double)j;
      fprintf(stderr, "%ld of %ld tuples (%d%%) done (elapsed %.2f s, remaining %.2f s).\n", j, (signed long int)100000 * (signed long int)scale, (signed int)(((signed long int)j * (signed long int)100) / ((signed long int)100000 * (signed long int)scale)), elapsed_sec, remaining_sec);
    }

    else
      if(j % 100l == 0l && !(use_quiet == 0))
      {
        gettimeofday(&diff, (struct timezone *)(void *)0);
        do
        {
          diff.tv_sec = diff.tv_sec - start.tv_sec;
          diff.tv_usec = diff.tv_usec - start.tv_usec;
          for( ; !(diff.tv_usec >= 0l); diff.tv_sec = diff.tv_sec - 1l)
            diff.tv_usec = diff.tv_usec + (signed long int)1000000;
        }
        while((_Bool)0);
        elapsed_sec = (double)diff.tv_sec + (double)diff.tv_usec / 1000000.0;
        remaining_sec = (((double)scale * (double)100000 - (double)j) * elapsed_sec) / (double)j;
        if(j == (signed long int)(100000 * scale) || elapsed_sec >= (double)(5 * log_interval))
        {
          fprintf(stderr, "%ld of %ld tuples (%d%%) done (elapsed %.2f s, remaining %.2f s).\n", j, (signed long int)100000 * (signed long int)scale, (signed int)(((signed long int)j * (signed long int)100) / ((signed long int)100000 * (signed long int)scale)), elapsed_sec, remaining_sec);
          double return_value_ceil_10;
          return_value_ceil_10=ceil(elapsed_sec / (double)5);
          log_interval = (signed int)return_value_ceil_10;
        }

      }

  }
  signed int return_value_PQputline_11;
  return_value_PQputline_11=PQputline(con, "\\.\n");
  if(!(return_value_PQputline_11 == 0))
  {
    fprintf(stderr, "very last PQputline failed\n");
    exit(1);
  }

  signed int return_value_PQendcopy_12;
  return_value_PQendcopy_12=PQendcopy(con);
  if(!(return_value_PQendcopy_12 == 0))
  {
    fprintf(stderr, "PQendcopy failed\n");
    exit(1);
  }

  executeStatement(con, "commit");
  if(is_no_vacuum == 0)
  {
    fprintf(stderr, "vacuum...\n");
    executeStatement(con, "vacuum analyze pgbench_branches");
    executeStatement(con, "vacuum analyze pgbench_tellers");
    executeStatement(con, "vacuum analyze pgbench_accounts");
    executeStatement(con, "vacuum analyze pgbench_history");
  }

  fprintf(stderr, "set primary keys...\n");
  i = 0;
  for( ; !((unsigned long int)i >= 3ul); i = i + 1)
  {
    char buffer[256l];
    static const char * const DDLINDEXes[3l] = { "alter table pgbench_branches add primary key (bid)",
    "alter table pgbench_tellers add primary key (tid)",
    "alter table pgbench_accounts add primary key (aid)" };
    strlcpy(buffer, DDLINDEXes[(signed long int)i], sizeof(char [256l]) /*256ul*/ );
    if(!(index_tablespace == ((char *)NULL)))
    {
      char *init__1__9__1__1__escape_tablespace;
      unsigned long int return_value_strlen_13;
      return_value_strlen_13=strlen(index_tablespace);
      init__1__9__1__1__escape_tablespace=PQescapeIdentifier(con, index_tablespace, return_value_strlen_13);
      unsigned long int return_value_strlen_14;
      return_value_strlen_14=strlen(buffer);
      unsigned long int return_value_strlen_15;
      return_value_strlen_15=strlen(buffer);
      snprintf(buffer + (signed long int)return_value_strlen_14, sizeof(char [256l]) /*256ul*/  - return_value_strlen_15, " using index tablespace %s", init__1__9__1__1__escape_tablespace);
      PQfreemem((void *)init__1__9__1__1__escape_tablespace);
    }

    executeStatement(con, buffer);
  }
  if(!(foreign_keys == 0))
  {
    fprintf(stderr, "set foreign keys...\n");
    i = 0;
    static const char * const DDLKEYs[5l] = { "alter table pgbench_tellers add foreign key (bid) references pgbench_branches",
    "alter table pgbench_accounts add foreign key (bid) references pgbench_branches",
    "alter table pgbench_history add foreign key (bid) references pgbench_branches",
    "alter table pgbench_history add foreign key (tid) references pgbench_tellers",
    "alter table pgbench_history add foreign key (aid) references pgbench_accounts" };
    for( ; !((unsigned long int)i >= 5ul); i = i + 1)
      executeStatement(con, DDLKEYs[(signed long int)i]);
  }

  fprintf(stderr, "done.\n");
  PQfinish(con);
}

// initPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 103
extern void initPQExpBuffer(struct PQExpBufferData *str)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)256);
  str->data = (char *)return_value_malloc_1;
  if(str->data == ((char *)NULL))
  {
    str->data = (char *)oom_buffer;
    str->maxlen = (unsigned long int)0;
    str->len = (unsigned long int)0;
  }

  else
  {
    str->maxlen = (unsigned long int)256;
    str->len = (unsigned long int)0;
    str->data[(signed long int)0] = (char)0;
  }
}

// init_ssl_system
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 902
static signed int init_ssl_system(struct pg_conn *conn)
{
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&ssl_config_mutex);
  signed int return_value_CRYPTO_num_locks_4;
  signed long int tmp_post_6;
  if(!(return_value_pthread_mutex_lock_1 == 0))
    return -1;

  else
  {
    if(!(pq_init_crypto_lib == 0))
    {
      if(pq_lockarray == ((union anonymous_2 *)NULL))
      {
        signed int i;
        signed int return_value_CRYPTO_num_locks_2;
        return_value_CRYPTO_num_locks_2=CRYPTO_num_locks();
        void *return_value_malloc_3;
        return_value_malloc_3=malloc(sizeof(union anonymous_2) /*40ul*/  * (unsigned long int)return_value_CRYPTO_num_locks_2);
        pq_lockarray = (union anonymous_2 *)return_value_malloc_3;
        if(pq_lockarray == ((union anonymous_2 *)NULL))
        {
          pthread_mutex_unlock(&ssl_config_mutex);
          return -1;
        }

        i = 0;
        do
        {
          return_value_CRYPTO_num_locks_4=CRYPTO_num_locks();
          if(i >= return_value_CRYPTO_num_locks_4)
            break;

          signed int return_value_pthread_mutex_init_5;
          return_value_pthread_mutex_init_5=pthread_mutex_init(&pq_lockarray[(signed long int)i], (const union anonymous_0 *)(void *)0);
          if(!(return_value_pthread_mutex_init_5 == 0))
          {
            free((void *)pq_lockarray);
            pq_lockarray = (union anonymous_2 *)(void *)0;
            pthread_mutex_unlock(&ssl_config_mutex);
            return -1;
          }

          i = i + 1;
        }
        while((_Bool)1);
      }

      tmp_post_6 = ssl_open_connections;
      ssl_open_connections = ssl_open_connections + 1l;
      if(tmp_post_6 == 0l)
      {
        CRYPTO_set_id_callback(pq_threadidcallback);
        CRYPTO_set_locking_callback(pq_lockingcallback);
      }

    }

    if(SSL_context == ((struct ssl_ctx_st *)NULL))
    {
      if(!(pq_init_ssl_lib == 0))
      {
        OPENSSL_config((const char *)(void *)0);
        SSL_library_init();
        SSL_load_error_strings();
      }

      const struct ssl_method_st *return_value_SSLv23_method_7;
      return_value_SSLv23_method_7=SSLv23_method();
      SSL_context=SSL_CTX_new(return_value_SSLv23_method_7);
      if(SSL_context == ((struct ssl_ctx_st *)NULL))
      {
        char *err;
        err=SSLerrmessage();
        char *return_value_libpq_gettext_8;
        return_value_libpq_gettext_8=libpq_gettext("could not create SSL context: %s\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_8, err);
        SSLerrfree(err);
        pthread_mutex_unlock(&ssl_config_mutex);
        return -1;
      }

      SSL_CTX_ctrl(SSL_context, 32, 0x01000000L | 0x02000000L, (void *)0);
      SSL_CTX_ctrl(SSL_context, 33, 0x00000002L, (void *)0);
    }

    pthread_mutex_unlock(&ssl_config_mutex);
    return 0;
  }
}

// initialize_SSL
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1062
static signed int initialize_SSL(struct pg_conn *conn)
{
  struct stat buf;
  char homedir[1024l];
  char fnbuf[1024l];
  char sebuf[256l];
  char have_homedir;
  char have_cert;
  struct evp_pkey_st *pkey = (struct evp_pkey_st *)(void *)0;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(!(conn->sslcert == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(conn->sslcert);
    tmp_if_expr_2 = return_value_strlen_1 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  unsigned long int return_value_strlen_3;
  if(!tmp_if_expr_2)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    if(!(conn->sslkey == ((char *)NULL)))
    {
      return_value_strlen_3=strlen(conn->sslkey);
      tmp_if_expr_4 = return_value_strlen_3 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    tmp_if_expr_5 = !tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  unsigned long int return_value_strlen_6;
  if(tmp_if_expr_5)
    tmp_if_expr_8 = (_Bool)1;

  else
  {
    if(!(conn->sslrootcert == ((char *)NULL)))
    {
      return_value_strlen_6=strlen(conn->sslrootcert);
      tmp_if_expr_7 = return_value_strlen_6 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_7 = (_Bool)0;
    tmp_if_expr_8 = !tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_10;
  unsigned long int return_value_strlen_9;
  if(tmp_if_expr_8)
    tmp_if_expr_11 = (_Bool)1;

  else
  {
    if(!(conn->sslcrl == ((char *)NULL)))
    {
      return_value_strlen_9=strlen(conn->sslcrl);
      tmp_if_expr_10 = return_value_strlen_9 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_10 = (_Bool)0;
    tmp_if_expr_11 = !tmp_if_expr_10 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_11)
    have_homedir=pqGetHomeDirectory(homedir, (signed int)sizeof(char [1024l]) /*1024ul*/ );

  else
    have_homedir = (char)0;
  _Bool tmp_if_expr_13;
  unsigned long int return_value_strlen_12;
  if(!(conn->sslcert == ((char *)NULL)))
  {
    return_value_strlen_12=strlen(conn->sslcert);
    tmp_if_expr_13 = return_value_strlen_12 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_13 = (_Bool)0;
  if(tmp_if_expr_13)
    strlcpy(fnbuf, conn->sslcert, sizeof(char [1024l]) /*1024ul*/ );

  else
    if(!(have_homedir == 0))
      snprintf(fnbuf, sizeof(char [1024l]) /*1024ul*/ , "%s/%s", (const void *)homedir, (const void *)".postgresql/postgresql.crt");

    else
      fnbuf[(signed long int)0] = (char)0;
  signed int return_value_stat_25;
  signed int *return_value___errno_location_17;
  if((signed int)fnbuf[0l] == 0)
    have_cert = (char)0;

  else
  {
    return_value_stat_25=stat(fnbuf, &buf);
    if(!(return_value_stat_25 == 0))
    {
      signed int *return_value___errno_location_18;
      return_value___errno_location_18=__errno_location();
      if(!(*return_value___errno_location_18 == 2))
      {
        return_value___errno_location_17=__errno_location();
        if(!(*return_value___errno_location_17 == 20))
        {
          char *return_value_libpq_gettext_14;
          return_value_libpq_gettext_14=libpq_gettext("could not open certificate file \"%s\": %s\n");
          signed int *return_value___errno_location_15;
          return_value___errno_location_15=__errno_location();
          char *return_value_pqStrerror_16;
          return_value_pqStrerror_16=pqStrerror(*return_value___errno_location_15, sebuf, sizeof(char [256l]) /*256ul*/ );
          printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_14, (const void *)fnbuf, return_value_pqStrerror_16);
          return -1;
        }

      }

      have_cert = (char)0;
    }

    else
    {
      signed int rc;
      rc=pthread_mutex_lock(&ssl_config_mutex);
      if(!(rc == 0))
      {
        char *return_value_libpq_gettext_19;
        return_value_libpq_gettext_19=libpq_gettext("could not acquire mutex: %s\n");
        char *return_value_strerror_20;
        return_value_strerror_20=strerror(rc);
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_19, return_value_strerror_20);
        return -1;
      }

      signed int return_value_SSL_CTX_use_certificate_chain_file_22;
      return_value_SSL_CTX_use_certificate_chain_file_22=SSL_CTX_use_certificate_chain_file(SSL_context, fnbuf);
      if(!(return_value_SSL_CTX_use_certificate_chain_file_22 == 1))
      {
        char *err;
        err=SSLerrmessage();
        char *return_value_libpq_gettext_21;
        return_value_libpq_gettext_21=libpq_gettext("could not read certificate file \"%s\": %s\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_21, (const void *)fnbuf, err);
        SSLerrfree(err);
        pthread_mutex_unlock(&ssl_config_mutex);
        return -1;
      }

      signed int return_value_SSL_use_certificate_file_24;
      return_value_SSL_use_certificate_file_24=SSL_use_certificate_file(conn->ssl, fnbuf, 1);
      if(!(return_value_SSL_use_certificate_file_24 == 1))
      {
        char *initialize_SSL__1__3__3__err;
        initialize_SSL__1__3__3__err=SSLerrmessage();
        char *return_value_libpq_gettext_23;
        return_value_libpq_gettext_23=libpq_gettext("could not read certificate file \"%s\": %s\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_23, (const void *)fnbuf, initialize_SSL__1__3__3__err);
        SSLerrfree(initialize_SSL__1__3__3__err);
        pthread_mutex_unlock(&ssl_config_mutex);
        return -1;
      }

      have_cert = (char)1;
      pthread_mutex_unlock(&ssl_config_mutex);
    }
  }
  _Bool tmp_if_expr_34;
  if(!(have_cert == 0))
    tmp_if_expr_34 = conn->sslkey != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_34 = (_Bool)0;
  _Bool tmp_if_expr_36;
  unsigned long int return_value_strlen_35;
  if(tmp_if_expr_34)
  {
    return_value_strlen_35=strlen(conn->sslkey);
    tmp_if_expr_36 = return_value_strlen_35 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_36 = (_Bool)0;
  if(tmp_if_expr_36)
  {
    char *return_value_strchr_33;
    return_value_strchr_33=strchr(conn->sslkey, 58);
    if(!(return_value_strchr_33 == ((char *)NULL)))
    {
      char *engine_str;
      engine_str=strdup(conn->sslkey);
      char *engine_colon;
      if(engine_str == ((char *)NULL))
      {
        char *return_value_libpq_gettext_26;
        return_value_libpq_gettext_26=libpq_gettext("out of memory\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_26);
        return -1;
      }

      engine_colon=strchr(engine_str, 58);
      *engine_colon = (char)0;
      engine_colon = engine_colon + 1l;
      conn->engine=ENGINE_by_id(engine_str);
      if(conn->engine == ((struct engine_st *)NULL))
      {
        char *initialize_SSL__1__4__1__2__err;
        initialize_SSL__1__4__1__2__err=SSLerrmessage();
        char *return_value_libpq_gettext_27;
        return_value_libpq_gettext_27=libpq_gettext("could not load SSL engine \"%s\": %s\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_27, engine_str, initialize_SSL__1__4__1__2__err);
        SSLerrfree(initialize_SSL__1__4__1__2__err);
        free((void *)engine_str);
        return -1;
      }

      signed int return_value_ENGINE_init_29;
      return_value_ENGINE_init_29=ENGINE_init(conn->engine);
      if(return_value_ENGINE_init_29 == 0)
      {
        char *initialize_SSL__1__4__1__3__err;
        initialize_SSL__1__4__1__3__err=SSLerrmessage();
        char *return_value_libpq_gettext_28;
        return_value_libpq_gettext_28=libpq_gettext("could not initialize SSL engine \"%s\": %s\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_28, engine_str, initialize_SSL__1__4__1__3__err);
        SSLerrfree(initialize_SSL__1__4__1__3__err);
        ENGINE_free(conn->engine);
        conn->engine = (struct engine_st *)(void *)0;
        free((void *)engine_str);
        return -1;
      }

      pkey=ENGINE_load_private_key(conn->engine, engine_colon, (struct ui_method_st *)(void *)0, (void *)0);
      if(pkey == ((struct evp_pkey_st *)NULL))
      {
        char *initialize_SSL__1__4__1__4__err;
        initialize_SSL__1__4__1__4__err=SSLerrmessage();
        char *return_value_libpq_gettext_30;
        return_value_libpq_gettext_30=libpq_gettext("could not read private SSL key \"%s\" from engine \"%s\": %s\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_30, engine_colon, engine_str, initialize_SSL__1__4__1__4__err);
        SSLerrfree(initialize_SSL__1__4__1__4__err);
        ENGINE_finish(conn->engine);
        ENGINE_free(conn->engine);
        conn->engine = (struct engine_st *)(void *)0;
        free((void *)engine_str);
        return -1;
      }

      signed int return_value_SSL_use_PrivateKey_32;
      return_value_SSL_use_PrivateKey_32=SSL_use_PrivateKey(conn->ssl, pkey);
      if(!(return_value_SSL_use_PrivateKey_32 == 1))
      {
        char *initialize_SSL__1__4__1__5__err;
        initialize_SSL__1__4__1__5__err=SSLerrmessage();
        char *return_value_libpq_gettext_31;
        return_value_libpq_gettext_31=libpq_gettext("could not load private SSL key \"%s\" from engine \"%s\": %s\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_31, engine_colon, engine_str, initialize_SSL__1__4__1__5__err);
        SSLerrfree(initialize_SSL__1__4__1__5__err);
        ENGINE_finish(conn->engine);
        ENGINE_free(conn->engine);
        conn->engine = (struct engine_st *)(void *)0;
        free((void *)engine_str);
        return -1;
      }

      free((void *)engine_str);
      fnbuf[(signed long int)0] = (char)0;
    }

    else
      strlcpy(fnbuf, conn->sslkey, sizeof(char [1024l]) /*1024ul*/ );
  }

  else
    if(!(have_homedir == 0))
      snprintf(fnbuf, sizeof(char [1024l]) /*1024ul*/ , "%s/%s", (const void *)homedir, (const void *)".postgresql/postgresql.key");

    else
      fnbuf[(signed long int)0] = (char)0;
  if(!(have_cert == 0))
  {
    if(!((signed int)fnbuf[0l] == 0))
    {
      signed int return_value_stat_38;
      return_value_stat_38=stat(fnbuf, &buf);
      if(!(return_value_stat_38 == 0))
      {
        char *return_value_libpq_gettext_37;
        return_value_libpq_gettext_37=libpq_gettext("certificate present, but not private key file \"%s\"\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_37, (const void *)fnbuf);
        return -1;
      }

      if(!((63u & buf.st_mode) == 0u) || !((61440u & buf.st_mode) == 32768u))
      {
        char *return_value_libpq_gettext_39;
        return_value_libpq_gettext_39=libpq_gettext("private key file \"%s\" has group or world access; permissions should be u=rw (0600) or less\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_39, (const void *)fnbuf);
        return -1;
      }

      signed int return_value_SSL_use_PrivateKey_file_41;
      return_value_SSL_use_PrivateKey_file_41=SSL_use_PrivateKey_file(conn->ssl, fnbuf, 1);
      if(!(return_value_SSL_use_PrivateKey_file_41 == 1))
      {
        char *initialize_SSL__1__6__3__err;
        initialize_SSL__1__6__3__err=SSLerrmessage();
        char *return_value_libpq_gettext_40;
        return_value_libpq_gettext_40=libpq_gettext("could not load private key file \"%s\": %s\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_40, (const void *)fnbuf, initialize_SSL__1__6__3__err);
        SSLerrfree(initialize_SSL__1__6__3__err);
        return -1;
      }

    }

  }

  signed int return_value_SSL_check_private_key_43;
  if(!(have_cert == 0))
  {
    return_value_SSL_check_private_key_43=SSL_check_private_key(conn->ssl);
    if(!(return_value_SSL_check_private_key_43 == 1))
    {
      char *initialize_SSL__1__7__err;
      initialize_SSL__1__7__err=SSLerrmessage();
      char *return_value_libpq_gettext_42;
      return_value_libpq_gettext_42=libpq_gettext("certificate does not match private key file \"%s\": %s\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_42, (const void *)fnbuf, initialize_SSL__1__7__err);
      SSLerrfree(initialize_SSL__1__7__err);
      return -1;
    }

  }

  _Bool tmp_if_expr_45;
  unsigned long int return_value_strlen_44;
  if(!(conn->sslrootcert == ((char *)NULL)))
  {
    return_value_strlen_44=strlen(conn->sslrootcert);
    tmp_if_expr_45 = return_value_strlen_44 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_45 = (_Bool)0;
  if(tmp_if_expr_45)
    strlcpy(fnbuf, conn->sslrootcert, sizeof(char [1024l]) /*1024ul*/ );

  else
    if(!(have_homedir == 0))
      snprintf(fnbuf, sizeof(char [1024l]) /*1024ul*/ , "%s/%s", (const void *)homedir, (const void *)".postgresql/root.crt");

    else
      fnbuf[(signed long int)0] = (char)0;
  _Bool tmp_if_expr_56;
  signed int return_value_stat_55;
  if(!((signed int)fnbuf[0l] == 0))
  {
    return_value_stat_55=stat(fnbuf, &buf);
    tmp_if_expr_56 = return_value_stat_55 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_56 = (_Bool)0;
  _Bool tmp_if_expr_51;
  unsigned long int return_value_strlen_50;
  signed int return_value_X509_STORE_load_locations_52;
  char *return_value_libpq_gettext_53;
  char *return_value_libpq_gettext_54;
  if(tmp_if_expr_56)
  {
    struct x509_store_st *cvstore;
    signed int initialize_SSL__1__8__rc;
    initialize_SSL__1__8__rc=pthread_mutex_lock(&ssl_config_mutex);
    if(!(initialize_SSL__1__8__rc == 0))
    {
      char *return_value_libpq_gettext_46;
      return_value_libpq_gettext_46=libpq_gettext("could not acquire mutex: %s\n");
      char *return_value_strerror_47;
      return_value_strerror_47=strerror(initialize_SSL__1__8__rc);
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_46, return_value_strerror_47);
      return -1;
    }

    signed int return_value_SSL_CTX_load_verify_locations_49;
    return_value_SSL_CTX_load_verify_locations_49=SSL_CTX_load_verify_locations(SSL_context, fnbuf, (const char *)(void *)0);
    if(!(return_value_SSL_CTX_load_verify_locations_49 == 1))
    {
      char *initialize_SSL__1__8__2__err;
      initialize_SSL__1__8__2__err=SSLerrmessage();
      char *return_value_libpq_gettext_48;
      return_value_libpq_gettext_48=libpq_gettext("could not read root certificate file \"%s\": %s\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_48, (const void *)fnbuf, initialize_SSL__1__8__2__err);
      SSLerrfree(initialize_SSL__1__8__2__err);
      pthread_mutex_unlock(&ssl_config_mutex);
      return -1;
    }

    cvstore=SSL_CTX_get_cert_store(SSL_context);
    if(!(cvstore == ((struct x509_store_st *)NULL)))
    {
      if(!(conn->sslcrl == ((char *)NULL)))
      {
        return_value_strlen_50=strlen(conn->sslcrl);
        tmp_if_expr_51 = return_value_strlen_50 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_51 = (_Bool)0;
      if(tmp_if_expr_51)
        strlcpy(fnbuf, conn->sslcrl, sizeof(char [1024l]) /*1024ul*/ );

      else
        if(!(have_homedir == 0))
          snprintf(fnbuf, sizeof(char [1024l]) /*1024ul*/ , "%s/%s", (const void *)homedir, (const void *)".postgresql/root.crl");

        else
          fnbuf[(signed long int)0] = (char)0;
      if(!((signed int)fnbuf[0l] == 0))
      {
        return_value_X509_STORE_load_locations_52=X509_STORE_load_locations(cvstore, fnbuf, (const char *)(void *)0);
        if(return_value_X509_STORE_load_locations_52 == 1)
          X509_STORE_set_flags(cvstore, (unsigned long int)(0x4 | 0x8));

      }

    }

    pthread_mutex_unlock(&ssl_config_mutex);
    SSL_set_verify(conn->ssl, 0x01, verify_cb);
  }

  else
    if((signed int)*conn->sslmode == 118)
    {
      if((signed int)fnbuf[0l] == 0)
      {
        return_value_libpq_gettext_53=libpq_gettext("could not get home directory to locate root certificate file\nEither provide the file or change sslmode to disable server certificate verification.\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_53);
      }

      else
      {
        return_value_libpq_gettext_54=libpq_gettext("root certificate file \"%s\" does not exist\nEither provide the file or change sslmode to disable server certificate verification.\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_54, (const void *)fnbuf);
      }
      return -1;
    }

  if(!(conn->sslcompression == ((char *)NULL)))
  {
    if((signed int)*conn->sslcompression == 48)
      SSL_ctrl(conn->ssl, 32, 0x00020000L, (void *)0);

  }

  return 0;
}

// internal_cancel
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3216
static signed int internal_cancel(struct anonymous_7 *raddr, signed int be_pid, signed int be_key, char *errbuf, signed int errbufsize)
{
  signed int save_errno;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  save_errno = *return_value___errno_location_1;
  signed int tmpsock = -1;
  char sebuf[256l];
  signed int maxlen;
  /* tag-#anon#lST[U32'packetlen'||SYM#tag-CancelRequestPacket#'cp'|] */
struct anonymous_26
{
  // packetlen
  unsigned int packetlen;
  // cp
  struct CancelRequestPacket cp;
};

/* */
  ;
  struct anonymous_26 crp;
  tmpsock=socket((signed int)raddr->addr.ss_family, 1, 0);
  signed int return_value_connect_3;
  signed int *return_value___errno_location_2;
  unsigned int return_value_htonl_4;
  signed long int return_value_send_6;
  signed int *return_value___errno_location_5;
  signed long int return_value_recv_8;
  signed int *return_value___errno_location_7;
  signed int *return_value___errno_location_9;
  if(tmpsock == -1)
    strlcpy(errbuf, "PQcancel() -- socket() failed: ", (unsigned long int)errbufsize);

  else
  {
    do
    {

    retry3:
      ;
      return_value_connect_3=connect(tmpsock, (struct sockaddr *)&raddr->addr, raddr->salen);
      if(return_value_connect_3 >= 0)
        goto __CPROVER_DUMP_L2;

      return_value___errno_location_2=__errno_location();
    }
    while(*return_value___errno_location_2 == 4);
    strlcpy(errbuf, "PQcancel() -- connect() failed: ", (unsigned long int)errbufsize);
    goto cancel_errReturn;

  __CPROVER_DUMP_L2:
    ;
    crp.packetlen=htonl((unsigned int)sizeof(struct anonymous_26) /*16ul*/ );
    return_value_htonl_4=htonl((unsigned int)(1234 << 16 | 5678));
    crp.cp.cancelRequestCode = (unsigned int)return_value_htonl_4;
    crp.cp.backendPID=htonl((unsigned int)be_pid);
    crp.cp.cancelAuthCode=htonl((unsigned int)be_key);
    do
    {

    retry4:
      ;
      return_value_send_6=send(tmpsock, (const void *)(char *)&crp, sizeof(struct anonymous_26) /*16ul*/ , 0);
      if(return_value_send_6 == (signed long int)sizeof(struct anonymous_26) /*16l*/ )
        goto retry5;

      return_value___errno_location_5=__errno_location();
    }
    while(*return_value___errno_location_5 == 4);
    strlcpy(errbuf, "PQcancel() -- send() failed: ", (unsigned long int)errbufsize);
    goto cancel_errReturn;
    do
    {

    retry5:
      ;
      return_value_recv_8=recv(tmpsock, (void *)(char *)&crp, (unsigned long int)1, 0);
      if(return_value_recv_8 >= 0l)
        goto __CPROVER_DUMP_L5;

      return_value___errno_location_7=__errno_location();
    }
    while(*return_value___errno_location_7 == 4);

  __CPROVER_DUMP_L5:
    ;
    close(tmpsock);
    return_value___errno_location_9=__errno_location();
    *return_value___errno_location_9 = save_errno;
    return 1;
  }

cancel_errReturn:
  ;
  unsigned long int return_value_strlen_10;
  return_value_strlen_10=strlen(errbuf);
  maxlen = (signed int)(((unsigned long int)errbufsize - return_value_strlen_10) - (unsigned long int)2);
  if(maxlen >= 0)
  {
    signed int *return_value___errno_location_11;
    return_value___errno_location_11=__errno_location();
    char *return_value_pqStrerror_12;
    return_value_pqStrerror_12=pqStrerror(*return_value___errno_location_11, sebuf, sizeof(char [256l]) /*256ul*/ );
    strncat(errbuf, return_value_pqStrerror_12, (unsigned long int)maxlen);
    strcat(errbuf, "\n");
  }

  if(!(tmpsock == -1))
    close(tmpsock);

  signed int *return_value___errno_location_13;
  return_value___errno_location_13=__errno_location();
  *return_value___errno_location_13 = save_errno;
  return 0;
}

// internal_ping
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 2679
static enum anonymous_25 internal_ping(struct pg_conn *conn)
{
  _Bool tmp_if_expr_1;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(conn->options_valid != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (enum anonymous_25)PQPING_NO_ATTEMPT;

  else
  {
    if(!((signed int)conn->status == CONNECTION_BAD))
      connectDBComplete(conn);

    if(!((signed int)conn->status == CONNECTION_BAD))
      return (enum anonymous_25)PQPING_OK;

    else
      if(!(conn->auth_req_received == 0))
        return (enum anonymous_25)PQPING_OK;

      else
      {
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(conn->last_sqlstate);
        if(!(return_value_strlen_2 == 5ul))
          return (enum anonymous_25)PQPING_NO_RESPONSE;

        else
        {
          signed int return_value_strcmp_3;
          return_value_strcmp_3=strcmp(conn->last_sqlstate, "57P03");
          if(return_value_strcmp_3 == 0)
            return (enum anonymous_25)PQPING_REJECT;

          else
            return (enum anonymous_25)PQPING_OK;
        }
      }
  }
}

// isLegalVariableName
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 625
static char isLegalVariableName(const char *name)
{
  signed int i = 0;
  for( ; !((signed int)name[(signed long int)i] == 0); i = i + 1)
  {
    const unsigned short int **return_value___ctype_b_loc_1;
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)name[(signed long int)i]]) == 0)
    {
      if(!((signed int)name[(signed long int)i] == 95))
        return (char)0;

    }

  }
  return (char)1;
}

// join_path_components
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 41
extern void join_path_components(char *ret_path, const char *head, const char *tail)
{
  if(!(ret_path == head))
    strlcpy(ret_path, head, (unsigned long int)1024);

  for( ; (signed int)*tail == 46; tail = tail + (signed long int)2)
    if(!((signed int)tail[1l] == 47))
      break;

  if(!(*tail == 0))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(ret_path);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(ret_path);
    snprintf(ret_path + (signed long int)return_value_strlen_1, (unsigned long int)1024 - return_value_strlen_2, "%s%s", (signed int)*head != 0 ? "/" : "", tail);
  }

}

// last_dir_separator
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 39
extern char * last_dir_separator(const char *filename)
{
  const char *p;
  const char *ret = (const char *)(void *)0;
  p = filename;
  for( ; !(*p == 0); p = p + 1l)
    if((signed int)*p == 47)
      ret = p;

  return (char *)ret;
}

// ldapServiceLookup
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3441
static signed int ldapServiceLookup(const char *purl, struct _PQconninfoOption *options, struct PQExpBufferData *errorMessage)
{
  signed int port = 389;
  signed int scope;
  signed int rc;
  signed int size;
  signed int state;
  signed int oldstate;
  signed int i;
  signed int msgid;
  char found_keyword;
  char *url;
  char *hostname;
  char *portstr;
  char *endptr;
  char *dn;
  char *scopestr;
  char *filter;
  char *result;
  char *p;
  char *p1 = (char *)(void *)0;
  char *optname = (char *)(void *)0;
  char *optval = (char *)(void *)0;
  char *attrs[2l] = { (char *)(void *)0, (char *)(void *)0 };
  struct ldap *ld = (struct ldap *)(void *)0;
  struct ldapmsg *res;
  struct ldapmsg *entry;
  struct berval **values;
  struct timeval ldapServiceLookup__1__time = { .tv_sec=(signed long int)2, .tv_usec=(signed long int)0 };
  url=strdup(purl);
  if(url == ((char *)NULL))
  {
    char *return_value_libpq_gettext_1;
    return_value_libpq_gettext_1=libpq_gettext("out of memory\n");
    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_1);
    return 3;
  }

  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen("ldap://");
  signed int return_value_pg_strncasecmp_4;
  return_value_pg_strncasecmp_4=pg_strncasecmp(url, "ldap://", return_value_strlen_3);
  if(!(return_value_pg_strncasecmp_4 == 0))
  {
    char *return_value_libpq_gettext_2;
    return_value_libpq_gettext_2=libpq_gettext("invalid LDAP URL \"%s\": scheme must be ldap://\n");
    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_2, purl);
    free((void *)url);
    return 3;
  }

  unsigned long int return_value_strlen_5;
  return_value_strlen_5=strlen("ldap://");
  hostname = url + (signed long int)return_value_strlen_5;
  if((signed int)*hostname == 47)
    hostname = "localhost";

  unsigned long int return_value_strlen_6;
  return_value_strlen_6=strlen("ldap://");
  p=strchr(url + (signed long int)return_value_strlen_6, 47);
  _Bool tmp_if_expr_8;
  if(p == ((char *)NULL))
    tmp_if_expr_8 = (_Bool)1;

  else
    tmp_if_expr_8 = (signed int)p[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_9;
  if(tmp_if_expr_8)
    tmp_if_expr_9 = (_Bool)1;

  else
    tmp_if_expr_9 = (signed int)p[(signed long int)1] == 63 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_9)
  {
    char *return_value_libpq_gettext_7;
    return_value_libpq_gettext_7=libpq_gettext("invalid LDAP URL \"%s\": missing distinguished name\n");
    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_7, purl);
    free((void *)url);
    return 3;
  }

  *p = (char)0;
  dn = p + (signed long int)1;
  p=strchr(dn, 63);
  _Bool tmp_if_expr_11;
  if(p == ((char *)NULL))
    tmp_if_expr_11 = (_Bool)1;

  else
    tmp_if_expr_11 = (signed int)p[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_12;
  if(tmp_if_expr_11)
    tmp_if_expr_12 = (_Bool)1;

  else
    tmp_if_expr_12 = (signed int)p[(signed long int)1] == 63 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_12)
  {
    char *return_value_libpq_gettext_10;
    return_value_libpq_gettext_10=libpq_gettext("invalid LDAP URL \"%s\": must have exactly one attribute\n");
    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_10, purl);
    free((void *)url);
    return 3;
  }

  *p = (char)0;
  attrs[(signed long int)0] = p + (signed long int)1;
  p=strchr(attrs[(signed long int)0], 63);
  _Bool tmp_if_expr_14;
  if(p == ((char *)NULL))
    tmp_if_expr_14 = (_Bool)1;

  else
    tmp_if_expr_14 = (signed int)p[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_15;
  if(tmp_if_expr_14)
    tmp_if_expr_15 = (_Bool)1;

  else
    tmp_if_expr_15 = (signed int)p[(signed long int)1] == 63 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_15)
  {
    char *return_value_libpq_gettext_13;
    return_value_libpq_gettext_13=libpq_gettext("invalid LDAP URL \"%s\": must have search scope (base/one/sub)\n");
    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_13, purl);
    free((void *)url);
    return 3;
  }

  *p = (char)0;
  scopestr = p + (signed long int)1;
  p=strchr(scopestr, 63);
  _Bool tmp_if_expr_17;
  if(p == ((char *)NULL))
    tmp_if_expr_17 = (_Bool)1;

  else
    tmp_if_expr_17 = (signed int)p[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_18;
  if(tmp_if_expr_17)
    tmp_if_expr_18 = (_Bool)1;

  else
    tmp_if_expr_18 = (signed int)p[(signed long int)1] == 63 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_18)
  {
    char *return_value_libpq_gettext_16;
    return_value_libpq_gettext_16=libpq_gettext("invalid LDAP URL \"%s\": no filter\n");
    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_16, purl);
    free((void *)url);
    return 3;
  }

  *p = (char)0;
  filter = p + (signed long int)1;
  p=strchr(filter, 63);
  if(!(p == ((char *)NULL)))
    *p = (char)0;

  p1=strchr(hostname, 58);
  _Bool tmp_if_expr_21;
  _Bool tmp_if_expr_23;
  signed int *return_value___errno_location_22;
  if(!(p1 == ((char *)NULL)))
  {
    signed long int lport;
    *p1 = (char)0;
    portstr = p1 + (signed long int)1;
    signed int *return_value___errno_location_19;
    return_value___errno_location_19=__errno_location();
    *return_value___errno_location_19 = 0;
    lport=strtol(portstr, &endptr, 10);
    if((signed int)*portstr == 0)
      tmp_if_expr_21 = (_Bool)1;

    else
      tmp_if_expr_21 = (signed int)*endptr != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_21)
      tmp_if_expr_23 = (_Bool)1;

    else
    {
      return_value___errno_location_22=__errno_location();
      tmp_if_expr_23 = *return_value___errno_location_22 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(lport >= 65536l || !(lport >= 0l) || tmp_if_expr_23)
    {
      char *return_value_libpq_gettext_20;
      return_value_libpq_gettext_20=libpq_gettext("invalid LDAP URL \"%s\": invalid port number\n");
      printfPQExpBuffer(errorMessage, return_value_libpq_gettext_20, purl);
      free((void *)url);
      return 3;
    }

    port = (signed int)lport;
  }

  char *return_value_strchr_25;
  return_value_strchr_25=strchr(attrs[(signed long int)0], 44);
  if(!(return_value_strchr_25 == ((char *)NULL)))
  {
    char *return_value_libpq_gettext_24;
    return_value_libpq_gettext_24=libpq_gettext("invalid LDAP URL \"%s\": must have exactly one attribute\n");
    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_24, purl);
    free((void *)url);
    return 3;
  }

  signed int return_value_pg_strcasecmp_29;
  return_value_pg_strcasecmp_29=pg_strcasecmp(scopestr, "base");
  signed int return_value_pg_strcasecmp_28;
  signed int return_value_pg_strcasecmp_27;
  if(return_value_pg_strcasecmp_29 == 0)
    scope = (signed int)0x0000;

  else
  {
    return_value_pg_strcasecmp_28=pg_strcasecmp(scopestr, "one");
    if(return_value_pg_strcasecmp_28 == 0)
      scope = (signed int)0x0001;

    else
    {
      return_value_pg_strcasecmp_27=pg_strcasecmp(scopestr, "sub");
      if(return_value_pg_strcasecmp_27 == 0)
        scope = (signed int)0x0002;

      else
      {
        char *return_value_libpq_gettext_26;
        return_value_libpq_gettext_26=libpq_gettext("invalid LDAP URL \"%s\": must have search scope (base/one/sub)\n");
        printfPQExpBuffer(errorMessage, return_value_libpq_gettext_26, purl);
        free((void *)url);
        return 3;
      }
    }
  }
  ld=ldap_init(hostname, port);
  if(ld == ((struct ldap *)NULL))
  {
    char *return_value_libpq_gettext_30;
    return_value_libpq_gettext_30=libpq_gettext("could not create LDAP structure\n");
    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_30);
    free((void *)url);
    return 3;
  }

  signed int return_value_ldap_set_option_31;
  return_value_ldap_set_option_31=ldap_set_option(ld, 0x5005, (const void *)&ldapServiceLookup__1__time);
  char *tmp_if_expr_37;
  char *return_value_libpq_gettext_35;
  char *return_value_libpq_gettext_36;
  char *tmp_post_43;
  _Bool tmp_if_expr_45;
  _Bool tmp_if_expr_44;
  _Bool tmp_if_expr_48;
  _Bool tmp_if_expr_47;
  _Bool tmp_if_expr_50;
  _Bool tmp_if_expr_53;
  _Bool tmp_if_expr_52;
  _Bool tmp_if_expr_54;
  _Bool tmp_if_expr_56;
  _Bool tmp_if_expr_55;
  char *tmp_post_57;
  char *tmp_post_58;
  if(!(return_value_ldap_set_option_31 == 0x00))
  {
    free((void *)url);
    ldap_unbind(ld);
    return 3;
  }

  else
  {
    msgid=ldap_simple_bind(ld, (const char *)(void *)0, (const char *)(void *)0);
    if(msgid == -1)
    {
      free((void *)url);
      ldap_unbind(ld);
      return 2;
    }

    else
    {
      res = (struct ldapmsg *)(void *)0;
      rc=ldap_result(ld, msgid, 0x01, &ldapServiceLookup__1__time, &res);
      if(res == ((struct ldapmsg *)NULL) || rc == -1)
      {
        if(!(res == ((struct ldapmsg *)NULL)))
          ldap_msgfree(res);

        free((void *)url);
        ldap_unbind(ld);
        return 2;
      }

      else
      {
        ldap_msgfree(res);
        ldapServiceLookup__1__time.tv_sec = (signed long int)-1;
        signed int return_value_ldap_set_option_32;
        return_value_ldap_set_option_32=ldap_set_option(ld, 0x5005, (const void *)&ldapServiceLookup__1__time);
        if(!(return_value_ldap_set_option_32 == 0x00))
        {
          free((void *)url);
          ldap_unbind(ld);
          return 3;
        }

        else
        {
          res = (struct ldapmsg *)(void *)0;
          rc=ldap_search_st(ld, dn, scope, filter, attrs, 0, &ldapServiceLookup__1__time, &res);
          if(!(rc == 0x00))
          {
            if(!(res == ((struct ldapmsg *)NULL)))
              ldap_msgfree(res);

            char *return_value_libpq_gettext_33;
            return_value_libpq_gettext_33=libpq_gettext("lookup on LDAP server failed: %s\n");
            char *return_value_ldap_err2string_34;
            return_value_ldap_err2string_34=ldap_err2string(rc);
            printfPQExpBuffer(errorMessage, return_value_libpq_gettext_33, return_value_ldap_err2string_34);
            ldap_unbind(ld);
            free((void *)url);
            return 1;
          }

          rc=ldap_count_entries(ld, res);
          if(!(rc == 1))
          {
            if(!(rc == 0))
            {
              return_value_libpq_gettext_35=libpq_gettext("more than one entry found on LDAP lookup\n");
              tmp_if_expr_37 = return_value_libpq_gettext_35;
            }

            else
            {
              return_value_libpq_gettext_36=libpq_gettext("no entry found on LDAP lookup\n");
              tmp_if_expr_37 = return_value_libpq_gettext_36;
            }
            printfPQExpBuffer(errorMessage, tmp_if_expr_37);
            ldap_msgfree(res);
            ldap_unbind(ld);
            free((void *)url);
            return 1;
          }

          entry=ldap_first_entry(ld, res);
          if(entry == ((struct ldapmsg *)NULL))
          {
            char *return_value_libpq_gettext_38;
            return_value_libpq_gettext_38=libpq_gettext("no entry found on LDAP lookup\n");
            printfPQExpBuffer(errorMessage, return_value_libpq_gettext_38);
            ldap_msgfree(res);
            ldap_unbind(ld);
            free((void *)url);
            return 1;
          }

          values=ldap_get_values_len(ld, entry, attrs[(signed long int)0]);
          if(values == ((struct berval **)NULL))
          {
            char *return_value_libpq_gettext_39;
            return_value_libpq_gettext_39=libpq_gettext("attribute has no values on LDAP lookup\n");
            printfPQExpBuffer(errorMessage, return_value_libpq_gettext_39);
            ldap_msgfree(res);
            ldap_unbind(ld);
            free((void *)url);
            return 1;
          }

          ldap_msgfree(res);
          free((void *)url);
          if(*values == ((struct berval *)NULL))
          {
            char *return_value_libpq_gettext_40;
            return_value_libpq_gettext_40=libpq_gettext("attribute has no values on LDAP lookup\n");
            printfPQExpBuffer(errorMessage, return_value_libpq_gettext_40);
            ldap_value_free_len(values);
            ldap_unbind(ld);
            return 1;
          }

          size = 1;
          i = 0;
          for( ; !(values[(signed long int)i] == ((struct berval *)NULL)); i = i + 1)
            size = size + (signed int)(values[(signed long int)i]->bv_len + (unsigned long int)1);
          void *return_value_malloc_42;
          return_value_malloc_42=malloc((unsigned long int)size);
          result = (char *)return_value_malloc_42;
          if(result == ((char *)NULL))
          {
            char *return_value_libpq_gettext_41;
            return_value_libpq_gettext_41=libpq_gettext("out of memory\n");
            printfPQExpBuffer(errorMessage, return_value_libpq_gettext_41);
            ldap_value_free_len(values);
            ldap_unbind(ld);
            return 3;
          }

          p = result;
          i = 0;
          for( ; !(values[(signed long int)i] == ((struct berval *)NULL)); i = i + 1)
          {
            memcpy((void *)p, (const void *)values[(signed long int)i]->bv_val, values[(signed long int)i]->bv_len);
            p = p + (signed long int)values[(signed long int)i]->bv_len;
            tmp_post_43 = p;
            p = p + 1l;
            *tmp_post_43 = (char)10;
          }
          *p = (char)0;
          ldap_value_free_len(values);
          ldap_unbind(ld);
          state = 0;
          oldstate = state;
          p = result;
          for( ; !((signed int)*p == 0); p = p + 1l)
          {
            switch(state)
            {
              case 0:
              {
                if((signed int)*p == 32)
                  tmp_if_expr_45 = (_Bool)1;

                else
                  tmp_if_expr_45 = (signed int)*p == 9 ? (_Bool)1 : (_Bool)0;
                if(!tmp_if_expr_45)
                {
                  if((signed int)*p == 13)
                    tmp_if_expr_44 = (_Bool)1;

                  else
                    tmp_if_expr_44 = (signed int)*p == 10 ? (_Bool)1 : (_Bool)0;
                  if(!tmp_if_expr_44)
                  {
                    optname = p;
                    state = 1;
                  }

                }

                break;
              }
              case 1:
              {
                if((signed int)*p == 32)
                  tmp_if_expr_48 = (_Bool)1;

                else
                  tmp_if_expr_48 = (signed int)*p == 9 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_48)
                {
                  *p = (char)0;
                  state = 2;
                }

                else
                {
                  if((signed int)*p == 13)
                    tmp_if_expr_47 = (_Bool)1;

                  else
                    tmp_if_expr_47 = (signed int)*p == 10 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_47)
                  {
                    char *return_value_libpq_gettext_46;
                    return_value_libpq_gettext_46=libpq_gettext("missing \"=\" after \"%s\" in connection info string\n");
                    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_46, optname);
                    free((void *)result);
                    return 3;
                  }

                  else
                    if((signed int)*p == 61)
                    {
                      *p = (char)0;
                      state = 3;
                    }

                }
                break;
              }
              case 2:
              {
                if((signed int)*p == 61)
                  state = 3;

                else
                {
                  if((signed int)*p == 32)
                    tmp_if_expr_50 = (_Bool)1;

                  else
                    tmp_if_expr_50 = (signed int)*p == 9 ? (_Bool)1 : (_Bool)0;
                  if(!tmp_if_expr_50)
                  {
                    char *return_value_libpq_gettext_49;
                    return_value_libpq_gettext_49=libpq_gettext("missing \"=\" after \"%s\" in connection info string\n");
                    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_49, optname);
                    free((void *)result);
                    return 3;
                  }

                }
                break;
              }
              case 3:
              {
                if((signed int)*p == 39)
                {
                  optval = p + (signed long int)1;
                  p1 = p + (signed long int)1;
                  state = 5;
                }

                else
                {
                  if((signed int)*p == 13)
                    tmp_if_expr_53 = (_Bool)1;

                  else
                    tmp_if_expr_53 = (signed int)*p == 10 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_53)
                  {
                    unsigned long int return_value_strlen_51;
                    return_value_strlen_51=strlen(optname);
                    optval = optname + (signed long int)return_value_strlen_51;
                    state = 0;
                  }

                  else
                  {
                    if((signed int)*p == 32)
                      tmp_if_expr_52 = (_Bool)1;

                    else
                      tmp_if_expr_52 = (signed int)*p == 9 ? (_Bool)1 : (_Bool)0;
                    if(!tmp_if_expr_52)
                    {
                      optval = p;
                      state = 4;
                    }

                  }
                }
                break;
              }
              case 4:
              {
                if((signed int)*p == 32)
                  tmp_if_expr_54 = (_Bool)1;

                else
                  tmp_if_expr_54 = (signed int)*p == 9 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_54)
                  tmp_if_expr_56 = (_Bool)1;

                else
                {
                  if((signed int)*p == 13)
                    tmp_if_expr_55 = (_Bool)1;

                  else
                    tmp_if_expr_55 = (signed int)*p == 10 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_56 = tmp_if_expr_55 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_56)
                {
                  *p = (char)0;
                  state = 0;
                }

                break;
              }
              case 5:
              {
                if((signed int)*p == 39)
                {
                  *p1 = (char)0;
                  state = 0;
                }

                else
                  if((signed int)*p == 92)
                    state = 6;

                  else
                  {
                    tmp_post_57 = p1;
                    p1 = p1 + 1l;
                    *tmp_post_57 = *p;
                  }
                break;
              }
              case 6:
              {
                tmp_post_58 = p1;
                p1 = p1 + 1l;
                *tmp_post_58 = *p;
                state = 5;
              }
            }
            if(state == 0 && !(oldstate == 0))
            {
              found_keyword = (char)0;
              i = 0;
              for( ; !((options + (signed long int)i)->keyword == ((char *)NULL)); i = i + 1)
              {
                signed int return_value_strcmp_60;
                return_value_strcmp_60=strcmp((options + (signed long int)i)->keyword, optname);
                if(return_value_strcmp_60 == 0)
                {
                  if((options + (signed long int)i)->val == ((char *)NULL))
                  {
                    (options + (signed long int)i)->val=strdup(optval);
                    if((options + (signed long int)i)->val == ((char *)NULL))
                    {
                      char *return_value_libpq_gettext_59;
                      return_value_libpq_gettext_59=libpq_gettext("out of memory\n");
                      printfPQExpBuffer(errorMessage, return_value_libpq_gettext_59);
                      free((void *)result);
                      return 3;
                    }

                  }

                  found_keyword = (char)1;
                  break;
                }

              }
              if(found_keyword == 0)
              {
                char *return_value_libpq_gettext_61;
                return_value_libpq_gettext_61=libpq_gettext("invalid connection option \"%s\"\n");
                printfPQExpBuffer(errorMessage, return_value_libpq_gettext_61, optname);
                free((void *)result);
                return 1;
              }

              optname = (char *)(void *)0;
              optval = (char *)(void *)0;
            }

            oldstate = state;
          }
          free((void *)result);
          if(state == 5 || state == 6)
          {
            char *return_value_libpq_gettext_62;
            return_value_libpq_gettext_62=libpq_gettext("unterminated quoted string in connection info string\n");
            printfPQExpBuffer(errorMessage, return_value_libpq_gettext_62);
            return 3;
          }

          return 0;
        }
      }
    }
  }
}

// libpq_gettext
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 621
extern char * libpq_gettext(const char *msgid)
{
  static char already_bound = (char)0;
  if(already_bound == 0)
  {
    signed int save_errno;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    save_errno = *return_value___errno_location_1;
    const char *ldir;
    already_bound = (char)1;
    ldir=getenv("PGLOCALEDIR");
    if(ldir == ((const char *)NULL))
      ldir = "/usr/share/locale";

    bindtextdomain("libpq5-9.4", ldir);
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = save_errno;
  }

  char *return_value_dgettext_3;
  return_value_dgettext_3=dgettext("libpq5-9.4", msgid);
  return return_value_dgettext_3;
}

// lo_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 100
extern signed int lo_close(struct pg_conn *conn, signed int fd)
{
  struct anonymous_33 argv[1l];
  struct pg_result *res;
  signed int retval;
  signed int result_len;
  _Bool tmp_if_expr_2;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = conn->lobjfuncs == (struct pgLobjfuncs *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_lo_initialize_1;
    return_value_lo_initialize_1=lo_initialize(conn);
    if(!(return_value_lo_initialize_1 >= 0))
      return -1;

  }

  argv[(signed long int)0].isint = 1;
  argv[(signed long int)0].len = 4;
  argv[(signed long int)0].u.integer = fd;
  res=PQfn(conn, (signed int)conn->lobjfuncs->fn_lo_close, &retval, &result_len, 1, argv, 1);
  enum anonymous_20 return_value_PQresultStatus_3;
  return_value_PQresultStatus_3=PQresultStatus(res);
  if((signed int)return_value_PQresultStatus_3 == PGRES_COMMAND_OK)
  {
    PQclear(res);
    return retval;
  }

  else
  {
    PQclear(res);
    return -1;
  }
}

// lo_creat
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 466
extern unsigned int lo_creat(struct pg_conn *conn, signed int mode)
{
  struct anonymous_33 argv[1l];
  struct pg_result *res;
  signed int retval;
  signed int result_len;
  _Bool tmp_if_expr_2;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = conn->lobjfuncs == (struct pgLobjfuncs *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_lo_initialize_1;
    return_value_lo_initialize_1=lo_initialize(conn);
    if(!(return_value_lo_initialize_1 >= 0))
      return (unsigned int)0;

  }

  argv[(signed long int)0].isint = 1;
  argv[(signed long int)0].len = 4;
  argv[(signed long int)0].u.integer = mode;
  res=PQfn(conn, (signed int)conn->lobjfuncs->fn_lo_creat, &retval, &result_len, 1, argv, 1);
  enum anonymous_20 return_value_PQresultStatus_3;
  return_value_PQresultStatus_3=PQresultStatus(res);
  if((signed int)return_value_PQresultStatus_3 == PGRES_COMMAND_OK)
  {
    PQclear(res);
    return (unsigned int)retval;
  }

  else
  {
    PQclear(res);
    return (unsigned int)0;
  }
}

// lo_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 505
extern unsigned int lo_create(struct pg_conn *conn, unsigned int lobjId)
{
  struct anonymous_33 argv[1l];
  struct pg_result *res;
  signed int retval;
  signed int result_len;
  _Bool tmp_if_expr_2;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = conn->lobjfuncs == (struct pgLobjfuncs *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_lo_initialize_1;
    return_value_lo_initialize_1=lo_initialize(conn);
    if(!(return_value_lo_initialize_1 >= 0))
      return (unsigned int)0;

  }

  if(conn->lobjfuncs->fn_lo_create == 0u)
  {
    char *return_value_libpq_gettext_3;
    return_value_libpq_gettext_3=libpq_gettext("cannot determine OID of function lo_create\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
    return (unsigned int)0;
  }

  argv[(signed long int)0].isint = 1;
  argv[(signed long int)0].len = 4;
  argv[(signed long int)0].u.integer = (signed int)lobjId;
  res=PQfn(conn, (signed int)conn->lobjfuncs->fn_lo_create, &retval, &result_len, 1, argv, 1);
  enum anonymous_20 return_value_PQresultStatus_4;
  return_value_PQresultStatus_4=PQresultStatus(res);
  if((signed int)return_value_PQresultStatus_4 == PGRES_COMMAND_OK)
  {
    PQclear(res);
    return (unsigned int)retval;
  }

  else
  {
    PQclear(res);
    return (unsigned int)0;
  }
}

// lo_export
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 785
extern signed int lo_export(struct pg_conn *conn, unsigned int lobjId, const char *filename)
{
  signed int result = 1;
  signed int fd;
  signed int nbytes;
  signed int tmp;
  char buf[8192l];
  signed int lobj;
  char sebuf[256l];
  lobj=lo_open(conn, lobjId, 0x00040000);
  _Bool tmp_if_expr_9;
  signed int return_value_lo_close_8;
  if(lobj == -1)
    return -1;

  else
  {
    fd=open(filename, 0100 | 01 | 01000 | 0, 0666);
    if(!(fd >= 0))
    {
      signed int save_errno;
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      save_errno = *return_value___errno_location_1;
      lo_close(conn, lobj);
      char *return_value_libpq_gettext_2;
      return_value_libpq_gettext_2=libpq_gettext("could not open file \"%s\": %s\n");
      char *return_value_pqStrerror_3;
      return_value_pqStrerror_3=pqStrerror(save_errno, sebuf, sizeof(char [256l]) /*256ul*/ );
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2, filename, return_value_pqStrerror_3);
      return -1;
    }

    do
    {
      nbytes=lo_read(conn, lobj, buf, (unsigned long int)8192);
      if(!(nbytes >= 1))
        break;

      signed long int return_value_write_4;
      return_value_write_4=write(fd, (const void *)buf, (unsigned long int)nbytes);
      tmp = (signed int)return_value_write_4;
      if(!(tmp == nbytes))
      {
        signed int lo_export__1__3__1__save_errno;
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        lo_export__1__3__1__save_errno = *return_value___errno_location_5;
        lo_close(conn, lobj);
        close(fd);
        char *return_value_libpq_gettext_6;
        return_value_libpq_gettext_6=libpq_gettext("could not write to file \"%s\": %s\n");
        char *return_value_pqStrerror_7;
        return_value_pqStrerror_7=pqStrerror(lo_export__1__3__1__save_errno, sebuf, sizeof(char [256l]) /*256ul*/ );
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_6, filename, return_value_pqStrerror_7);
        return -1;
      }

    }
    while((_Bool)1);
    if(!(nbytes >= 0))
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_lo_close_8=lo_close(conn, lobj);
      tmp_if_expr_9 = return_value_lo_close_8 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
      result = -1;

    signed int return_value_close_13;
    return_value_close_13=close(fd);
    if(!(return_value_close_13 == 0))
    {
      if(result >= 0)
      {
        char *return_value_libpq_gettext_10;
        return_value_libpq_gettext_10=libpq_gettext("could not write to file \"%s\": %s\n");
        signed int *return_value___errno_location_11;
        return_value___errno_location_11=__errno_location();
        char *return_value_pqStrerror_12;
        return_value_pqStrerror_12=pqStrerror(*return_value___errno_location_11, sebuf, sizeof(char [256l]) /*256ul*/ );
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_10, filename, return_value_pqStrerror_12);
        result = -1;
      }

    }

    return result;
  }
}

// lo_hton64
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 1062
static signed long int lo_hton64(signed long int host64)
{
  /* tag-#anon#lUN[S64'i64'||lARR2{U32}_U32_'i32'|] */
union anonymous_38
{
  // i64
  signed long int i64;
  // i32
  unsigned int i32[2l];
};

/* */
  ;
  union anonymous_38 swap;
  unsigned int t = (unsigned int)(host64 >> 32);
  swap.i32[(signed long int)0]=htonl(t);
  t = (unsigned int)host64;
  swap.i32[(signed long int)1]=htonl(t);
  return swap.i64;
}

// lo_import
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 669
extern unsigned int lo_import(struct pg_conn *conn, const char *filename)
{
  unsigned int return_value_lo_import_internal_1;
  return_value_lo_import_internal_1=lo_import_internal(conn, filename, (unsigned int)0);
  return return_value_lo_import_internal_1;
}

// lo_import_internal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 690
static unsigned int lo_import_internal(struct pg_conn *conn, const char *filename, unsigned int oid)
{
  signed int fd;
  signed int nbytes;
  signed int tmp;
  char buf[8192l];
  unsigned int lobjOid;
  signed int lobj;
  char sebuf[256l];
  fd=open(filename, 00 | 0, 0666);
  if(!(fd >= 0))
  {
    char *return_value_libpq_gettext_1;
    return_value_libpq_gettext_1=libpq_gettext("could not open file \"%s\": %s\n");
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_pqStrerror_3;
    return_value_pqStrerror_3=pqStrerror(*return_value___errno_location_2, sebuf, sizeof(char [256l]) /*256ul*/ );
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1, filename, return_value_pqStrerror_3);
    return (unsigned int)0;
  }

  if(oid == 0u)
    lobjOid=lo_creat(conn, 0x00040000 | 0x00020000);

  else
    lobjOid=lo_create(conn, oid);
  signed long int return_value_read_4;
  if(lobjOid == 0u)
  {
    close(fd);
    return (unsigned int)0;
  }

  else
  {
    lobj=lo_open(conn, lobjOid, 0x00020000);
    if(lobj == -1)
    {
      close(fd);
      return (unsigned int)0;
    }

    else
    {
      do
      {
        return_value_read_4=read(fd, (void *)buf, (unsigned long int)8192);
        nbytes = (signed int)return_value_read_4;
        if(!(nbytes >= 1))
          break;

        tmp=lo_write(conn, lobj, buf, (unsigned long int)nbytes);
        if(!(tmp == nbytes))
        {
          close(fd);
          return (unsigned int)0;
        }

      }
      while((_Bool)1);
      if(!(nbytes >= 0))
      {
        signed int save_errno;
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        save_errno = *return_value___errno_location_5;
        lo_close(conn, lobj);
        close(fd);
        char *return_value_libpq_gettext_6;
        return_value_libpq_gettext_6=libpq_gettext("could not read from file \"%s\": %s\n");
        char *return_value_pqStrerror_7;
        return_value_pqStrerror_7=pqStrerror(save_errno, sebuf, sizeof(char [256l]) /*256ul*/ );
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_6, filename, return_value_pqStrerror_7);
        return (unsigned int)0;
      }

      close(fd);
      signed int return_value_lo_close_8;
      return_value_lo_close_8=lo_close(conn, lobj);
      if(!(return_value_lo_close_8 == 0))
        return (unsigned int)0;

      else
        return lobjOid;
    }
  }
}

// lo_import_with_oid
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 684
extern unsigned int lo_import_with_oid(struct pg_conn *conn, const char *filename, unsigned int lobjId)
{
  unsigned int return_value_lo_import_internal_1;
  return_value_lo_import_internal_1=lo_import_internal(conn, filename, lobjId);
  return return_value_lo_import_internal_1;
}

// lo_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 877
static signed int lo_initialize(struct pg_conn *conn)
{
  struct pg_result *res;
  struct pgLobjfuncs *lobjfuncs;
  signed int n;
  const char *query;
  const char *fname;
  unsigned int foid;
  signed long int *tmp_post_3;
  signed int return_value_PQntuples_5;
  signed int return_value_strcmp_19;
  signed int return_value_strcmp_18;
  signed int return_value_strcmp_17;
  signed int return_value_strcmp_16;
  signed int return_value_strcmp_15;
  signed int return_value_strcmp_14;
  signed int return_value_strcmp_13;
  signed int return_value_strcmp_12;
  signed int return_value_strcmp_11;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  if(conn == ((struct pg_conn *)NULL))
    return -1;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct pgLobjfuncs) /*52ul*/ );
    lobjfuncs = (struct pgLobjfuncs *)return_value_malloc_1;
    if(lobjfuncs == ((struct pgLobjfuncs *)NULL))
    {
      char *return_value_libpq_gettext_2;
      return_value_libpq_gettext_2=libpq_gettext("out of memory\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2);
      return -1;
    }

    do
    {
      void *_vstart = (void *)(char *)lobjfuncs;
      signed int _val = 0;
      unsigned long int _len = sizeof(struct pgLobjfuncs) /*52ul*/ ;
      if((7ul & _len) == 0ul && (7ul & (unsigned long int)_vstart) == 0ul && _val == 0 && !(_len >= 1025ul))
      {
        signed long int *lo_initialize__1__2__1___start = (signed long int *)_vstart;
        signed long int *_stop = (signed long int *)((char *)lo_initialize__1__2__1___start + (signed long int)_len);
        for( ; !(lo_initialize__1__2__1___start >= _stop); *tmp_post_3 = (signed long int)0)
        {
          tmp_post_3 = lo_initialize__1__2__1___start;
          lo_initialize__1__2__1___start = lo_initialize__1__2__1___start + 1l;
        }
      }

      else
        memset(_vstart, _val, _len);
    }
    while((_Bool)0);
    if(conn->sversion >= 70300)
      query = "select proname, oid from pg_catalog.pg_proc where proname in ('lo_open', 'lo_close', 'lo_creat', 'lo_create', 'lo_unlink', 'lo_lseek', 'lo_lseek64', 'lo_tell', 'lo_tell64', 'lo_truncate', 'lo_truncate64', 'loread', 'lowrite') and pronamespace = (select oid from pg_catalog.pg_namespace where nspname = 'pg_catalog')";

    else
      query = "select proname, oid from pg_proc where proname = 'lo_open' or proname = 'lo_close' or proname = 'lo_creat' or proname = 'lo_unlink' or proname = 'lo_lseek' or proname = 'lo_tell' or proname = 'loread' or proname = 'lowrite'";
    res=PQexec(conn, query);
    if(res == ((struct pg_result *)NULL))
    {
      free((void *)lobjfuncs);
      return -1;
    }

    else
    {
      if(!((signed int)res->resultStatus == PGRES_TUPLES_OK))
      {
        free((void *)lobjfuncs);
        PQclear(res);
        char *return_value_libpq_gettext_4;
        return_value_libpq_gettext_4=libpq_gettext("query to initialize large object functions did not return data\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_4);
        return -1;
      }

      n = 0;
      do
      {
        return_value_PQntuples_5=PQntuples(res);
        if(n >= return_value_PQntuples_5)
          break;

        fname=PQgetvalue(res, n, 0);
        char *return_value_PQgetvalue_6;
        return_value_PQgetvalue_6=PQgetvalue(res, n, 1);
        signed int return_value_atoi_7;
        return_value_atoi_7=atoi(return_value_PQgetvalue_6);
        foid = (unsigned int)return_value_atoi_7;
        signed int return_value_strcmp_20;
        return_value_strcmp_20=strcmp(fname, "lo_open");
        if(return_value_strcmp_20 == 0)
          lobjfuncs->fn_lo_open = foid;

        else
        {
          return_value_strcmp_19=strcmp(fname, "lo_close");
          if(return_value_strcmp_19 == 0)
            lobjfuncs->fn_lo_close = foid;

          else
          {
            return_value_strcmp_18=strcmp(fname, "lo_creat");
            if(return_value_strcmp_18 == 0)
              lobjfuncs->fn_lo_creat = foid;

            else
            {
              return_value_strcmp_17=strcmp(fname, "lo_create");
              if(return_value_strcmp_17 == 0)
                lobjfuncs->fn_lo_create = foid;

              else
              {
                return_value_strcmp_16=strcmp(fname, "lo_unlink");
                if(return_value_strcmp_16 == 0)
                  lobjfuncs->fn_lo_unlink = foid;

                else
                {
                  return_value_strcmp_15=strcmp(fname, "lo_lseek");
                  if(return_value_strcmp_15 == 0)
                    lobjfuncs->fn_lo_lseek = foid;

                  else
                  {
                    return_value_strcmp_14=strcmp(fname, "lo_lseek64");
                    if(return_value_strcmp_14 == 0)
                      lobjfuncs->fn_lo_lseek64 = foid;

                    else
                    {
                      return_value_strcmp_13=strcmp(fname, "lo_tell");
                      if(return_value_strcmp_13 == 0)
                        lobjfuncs->fn_lo_tell = foid;

                      else
                      {
                        return_value_strcmp_12=strcmp(fname, "lo_tell64");
                        if(return_value_strcmp_12 == 0)
                          lobjfuncs->fn_lo_tell64 = foid;

                        else
                        {
                          return_value_strcmp_11=strcmp(fname, "lo_truncate");
                          if(return_value_strcmp_11 == 0)
                            lobjfuncs->fn_lo_truncate = foid;

                          else
                          {
                            return_value_strcmp_10=strcmp(fname, "lo_truncate64");
                            if(return_value_strcmp_10 == 0)
                              lobjfuncs->fn_lo_truncate64 = foid;

                            else
                            {
                              return_value_strcmp_9=strcmp(fname, "loread");
                              if(return_value_strcmp_9 == 0)
                                lobjfuncs->fn_lo_read = foid;

                              else
                              {
                                return_value_strcmp_8=strcmp(fname, "lowrite");
                                if(return_value_strcmp_8 == 0)
                                  lobjfuncs->fn_lo_write = foid;

                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        n = n + 1;
      }
      while((_Bool)1);
      PQclear(res);
      if(lobjfuncs->fn_lo_open == 0u)
      {
        char *return_value_libpq_gettext_21;
        return_value_libpq_gettext_21=libpq_gettext("cannot determine OID of function lo_open\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_21);
        free((void *)lobjfuncs);
        return -1;
      }

      if(lobjfuncs->fn_lo_close == 0u)
      {
        char *return_value_libpq_gettext_22;
        return_value_libpq_gettext_22=libpq_gettext("cannot determine OID of function lo_close\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_22);
        free((void *)lobjfuncs);
        return -1;
      }

      if(lobjfuncs->fn_lo_creat == 0u)
      {
        char *return_value_libpq_gettext_23;
        return_value_libpq_gettext_23=libpq_gettext("cannot determine OID of function lo_creat\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_23);
        free((void *)lobjfuncs);
        return -1;
      }

      if(lobjfuncs->fn_lo_unlink == 0u)
      {
        char *return_value_libpq_gettext_24;
        return_value_libpq_gettext_24=libpq_gettext("cannot determine OID of function lo_unlink\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_24);
        free((void *)lobjfuncs);
        return -1;
      }

      if(lobjfuncs->fn_lo_lseek == 0u)
      {
        char *return_value_libpq_gettext_25;
        return_value_libpq_gettext_25=libpq_gettext("cannot determine OID of function lo_lseek\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_25);
        free((void *)lobjfuncs);
        return -1;
      }

      if(lobjfuncs->fn_lo_tell == 0u)
      {
        char *return_value_libpq_gettext_26;
        return_value_libpq_gettext_26=libpq_gettext("cannot determine OID of function lo_tell\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_26);
        free((void *)lobjfuncs);
        return -1;
      }

      if(lobjfuncs->fn_lo_read == 0u)
      {
        char *return_value_libpq_gettext_27;
        return_value_libpq_gettext_27=libpq_gettext("cannot determine OID of function loread\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_27);
        free((void *)lobjfuncs);
        return -1;
      }

      if(lobjfuncs->fn_lo_write == 0u)
      {
        char *return_value_libpq_gettext_28;
        return_value_libpq_gettext_28=libpq_gettext("cannot determine OID of function lowrite\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_28);
        free((void *)lobjfuncs);
        return -1;
      }

      conn->lobjfuncs = lobjfuncs;
      return 0;
    }
  }
}

// lo_lseek
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 366
extern signed int lo_lseek(struct pg_conn *conn, signed int fd, signed int offset, signed int whence)
{
  struct anonymous_33 argv[3l];
  struct pg_result *res;
  signed int retval;
  signed int result_len;
  _Bool tmp_if_expr_2;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = conn->lobjfuncs == (struct pgLobjfuncs *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_lo_initialize_1;
    return_value_lo_initialize_1=lo_initialize(conn);
    if(!(return_value_lo_initialize_1 >= 0))
      return -1;

  }

  argv[(signed long int)0].isint = 1;
  argv[(signed long int)0].len = 4;
  argv[(signed long int)0].u.integer = fd;
  argv[(signed long int)1].isint = 1;
  argv[(signed long int)1].len = 4;
  argv[(signed long int)1].u.integer = offset;
  argv[(signed long int)2].isint = 1;
  argv[(signed long int)2].len = 4;
  argv[(signed long int)2].u.integer = whence;
  res=PQfn(conn, (signed int)conn->lobjfuncs->fn_lo_lseek, &retval, &result_len, 1, argv, 3);
  enum anonymous_20 return_value_PQresultStatus_3;
  return_value_PQresultStatus_3=PQresultStatus(res);
  if((signed int)return_value_PQresultStatus_3 == PGRES_COMMAND_OK)
  {
    PQclear(res);
    return retval;
  }

  else
  {
    PQclear(res);
    return -1;
  }
}

// lo_lseek64
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 410
extern signed long int lo_lseek64(struct pg_conn *conn, signed int fd, signed long int offset, signed int whence)
{
  struct anonymous_33 argv[3l];
  struct pg_result *res;
  signed long int retval;
  signed int result_len;
  _Bool tmp_if_expr_2;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = conn->lobjfuncs == (struct pgLobjfuncs *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_lo_initialize_1;
    return_value_lo_initialize_1=lo_initialize(conn);
    if(!(return_value_lo_initialize_1 >= 0))
      return (signed long int)-1;

  }

  if(conn->lobjfuncs->fn_lo_lseek64 == 0u)
  {
    char *return_value_libpq_gettext_3;
    return_value_libpq_gettext_3=libpq_gettext("cannot determine OID of function lo_lseek64\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
    return (signed long int)-1;
  }

  argv[(signed long int)0].isint = 1;
  argv[(signed long int)0].len = 4;
  argv[(signed long int)0].u.integer = fd;
  offset=lo_hton64(offset);
  argv[(signed long int)1].isint = 0;
  argv[(signed long int)1].len = 8;
  argv[(signed long int)1].u.ptr = (signed int *)&offset;
  argv[(signed long int)2].isint = 1;
  argv[(signed long int)2].len = 4;
  argv[(signed long int)2].u.integer = whence;
  res=PQfn(conn, (signed int)conn->lobjfuncs->fn_lo_lseek64, (signed int *)(void *)&retval, &result_len, 0, argv, 3);
  enum anonymous_20 return_value_PQresultStatus_5;
  return_value_PQresultStatus_5=PQresultStatus(res);
  if(result_len == 8 && (signed int)return_value_PQresultStatus_5 == PGRES_COMMAND_OK)
  {
    PQclear(res);
    signed long int return_value_lo_ntoh64_4;
    return_value_lo_ntoh64_4=lo_ntoh64(retval);
    return return_value_lo_ntoh64_4;
  }

  else
  {
    PQclear(res);
    return (signed long int)-1;
  }
}

// lo_ntoh64
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 1087
static signed long int lo_ntoh64(signed long int net64)
{
  /* tag-#anon#lUN[S64'i64'||lARR2{U32}_U32_'i32'|] */
union anonymous_38
{
  // i64
  signed long int i64;
  // i32
  unsigned int i32[2l];
};

/* */
  ;
  union anonymous_38 swap;
  signed long int result;
  swap.i64 = net64;
  unsigned int return_value_ntohl_1;
  return_value_ntohl_1=ntohl(swap.i32[(signed long int)0]);
  result = (signed long int)(unsigned int)return_value_ntohl_1;
  result = result << 32;
  unsigned int return_value_ntohl_2;
  return_value_ntohl_2=ntohl(swap.i32[(signed long int)1]);
  result = result | (signed long int)(unsigned int)return_value_ntohl_2;
  return result;
}

// lo_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 58
extern signed int lo_open(struct pg_conn *conn, unsigned int lobjId, signed int mode)
{
  signed int fd;
  signed int result_len;
  struct anonymous_33 argv[2l];
  struct pg_result *res;
  _Bool tmp_if_expr_2;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = conn->lobjfuncs == (struct pgLobjfuncs *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_lo_initialize_1;
    return_value_lo_initialize_1=lo_initialize(conn);
    if(!(return_value_lo_initialize_1 >= 0))
      return -1;

  }

  argv[(signed long int)0].isint = 1;
  argv[(signed long int)0].len = 4;
  argv[(signed long int)0].u.integer = (signed int)lobjId;
  argv[(signed long int)1].isint = 1;
  argv[(signed long int)1].len = 4;
  argv[(signed long int)1].u.integer = mode;
  res=PQfn(conn, (signed int)conn->lobjfuncs->fn_lo_open, &fd, &result_len, 1, argv, 2);
  enum anonymous_20 return_value_PQresultStatus_3;
  return_value_PQresultStatus_3=PQresultStatus(res);
  if((signed int)return_value_PQresultStatus_3 == PGRES_COMMAND_OK)
  {
    PQclear(res);
    return fd;
  }

  else
  {
    PQclear(res);
    return -1;
  }
}

// lo_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 259
extern signed int lo_read(struct pg_conn *conn, signed int fd, char *buf, unsigned long int len)
{
  struct anonymous_33 argv[2l];
  struct pg_result *res;
  signed int result_len;
  _Bool tmp_if_expr_2;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = conn->lobjfuncs == (struct pgLobjfuncs *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_lo_initialize_1;
    return_value_lo_initialize_1=lo_initialize(conn);
    if(!(return_value_lo_initialize_1 >= 0))
      return -1;

  }

  if(len >= 2147483648ul)
  {
    char *return_value_libpq_gettext_3;
    return_value_libpq_gettext_3=libpq_gettext("argument of lo_read exceeds integer range\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
    return -1;
  }

  argv[(signed long int)0].isint = 1;
  argv[(signed long int)0].len = 4;
  argv[(signed long int)0].u.integer = fd;
  argv[(signed long int)1].isint = 1;
  argv[(signed long int)1].len = 4;
  argv[(signed long int)1].u.integer = (signed int)len;
  res=PQfn(conn, (signed int)conn->lobjfuncs->fn_lo_read, (signed int *)(void *)buf, &result_len, 0, argv, 2);
  enum anonymous_20 return_value_PQresultStatus_4;
  return_value_PQresultStatus_4=PQresultStatus(res);
  if((signed int)return_value_PQresultStatus_4 == PGRES_COMMAND_OK)
  {
    PQclear(res);
    return result_len;
  }

  else
  {
    PQclear(res);
    return -1;
  }
}

// lo_tell
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 549
extern signed int lo_tell(struct pg_conn *conn, signed int fd)
{
  signed int retval;
  struct anonymous_33 argv[1l];
  struct pg_result *res;
  signed int result_len;
  _Bool tmp_if_expr_2;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = conn->lobjfuncs == (struct pgLobjfuncs *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_lo_initialize_1;
    return_value_lo_initialize_1=lo_initialize(conn);
    if(!(return_value_lo_initialize_1 >= 0))
      return -1;

  }

  argv[(signed long int)0].isint = 1;
  argv[(signed long int)0].len = 4;
  argv[(signed long int)0].u.integer = fd;
  res=PQfn(conn, (signed int)conn->lobjfuncs->fn_lo_tell, &retval, &result_len, 1, argv, 1);
  enum anonymous_20 return_value_PQresultStatus_3;
  return_value_PQresultStatus_3=PQresultStatus(res);
  if((signed int)return_value_PQresultStatus_3 == PGRES_COMMAND_OK)
  {
    PQclear(res);
    return retval;
  }

  else
  {
    PQclear(res);
    return -1;
  }
}

// lo_tell64
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 585
extern signed long int lo_tell64(struct pg_conn *conn, signed int fd)
{
  signed long int retval;
  struct anonymous_33 argv[1l];
  struct pg_result *res;
  signed int result_len;
  _Bool tmp_if_expr_2;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = conn->lobjfuncs == (struct pgLobjfuncs *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_lo_initialize_1;
    return_value_lo_initialize_1=lo_initialize(conn);
    if(!(return_value_lo_initialize_1 >= 0))
      return (signed long int)-1;

  }

  if(conn->lobjfuncs->fn_lo_tell64 == 0u)
  {
    char *return_value_libpq_gettext_3;
    return_value_libpq_gettext_3=libpq_gettext("cannot determine OID of function lo_tell64\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
    return (signed long int)-1;
  }

  argv[(signed long int)0].isint = 1;
  argv[(signed long int)0].len = 4;
  argv[(signed long int)0].u.integer = fd;
  res=PQfn(conn, (signed int)conn->lobjfuncs->fn_lo_tell64, (signed int *)(void *)&retval, &result_len, 0, argv, 1);
  enum anonymous_20 return_value_PQresultStatus_5;
  return_value_PQresultStatus_5=PQresultStatus(res);
  if(result_len == 8 && (signed int)return_value_PQresultStatus_5 == PGRES_COMMAND_OK)
  {
    PQclear(res);
    signed long int return_value_lo_ntoh64_4;
    return_value_lo_ntoh64_4=lo_ntoh64(retval);
    return return_value_lo_ntoh64_4;
  }

  else
  {
    PQclear(res);
    return (signed long int)-1;
  }
}

// lo_truncate
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 138
extern signed int lo_truncate(struct pg_conn *conn, signed int fd, unsigned long int len)
{
  struct anonymous_33 argv[2l];
  struct pg_result *res;
  signed int retval;
  signed int result_len;
  _Bool tmp_if_expr_2;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = conn->lobjfuncs == (struct pgLobjfuncs *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_lo_initialize_1;
    return_value_lo_initialize_1=lo_initialize(conn);
    if(!(return_value_lo_initialize_1 >= 0))
      return -1;

  }

  if(conn->lobjfuncs->fn_lo_truncate == 0u)
  {
    char *return_value_libpq_gettext_3;
    return_value_libpq_gettext_3=libpq_gettext("cannot determine OID of function lo_truncate\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
    return -1;
  }

  if(len >= 2147483648ul)
  {
    char *return_value_libpq_gettext_4;
    return_value_libpq_gettext_4=libpq_gettext("argument of lo_truncate exceeds integer range\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_4);
    return -1;
  }

  argv[(signed long int)0].isint = 1;
  argv[(signed long int)0].len = 4;
  argv[(signed long int)0].u.integer = fd;
  argv[(signed long int)1].isint = 1;
  argv[(signed long int)1].len = 4;
  argv[(signed long int)1].u.integer = (signed int)len;
  res=PQfn(conn, (signed int)conn->lobjfuncs->fn_lo_truncate, &retval, &result_len, 1, argv, 2);
  enum anonymous_20 return_value_PQresultStatus_5;
  return_value_PQresultStatus_5=PQresultStatus(res);
  if((signed int)return_value_PQresultStatus_5 == PGRES_COMMAND_OK)
  {
    PQclear(res);
    return retval;
  }

  else
  {
    PQclear(res);
    return -1;
  }
}

// lo_truncate64
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 206
extern signed int lo_truncate64(struct pg_conn *conn, signed int fd, signed long int len)
{
  struct anonymous_33 argv[2l];
  struct pg_result *res;
  signed int retval;
  signed int result_len;
  _Bool tmp_if_expr_2;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = conn->lobjfuncs == (struct pgLobjfuncs *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_lo_initialize_1;
    return_value_lo_initialize_1=lo_initialize(conn);
    if(!(return_value_lo_initialize_1 >= 0))
      return -1;

  }

  if(conn->lobjfuncs->fn_lo_truncate64 == 0u)
  {
    char *return_value_libpq_gettext_3;
    return_value_libpq_gettext_3=libpq_gettext("cannot determine OID of function lo_truncate64\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
    return -1;
  }

  argv[(signed long int)0].isint = 1;
  argv[(signed long int)0].len = 4;
  argv[(signed long int)0].u.integer = fd;
  len=lo_hton64(len);
  argv[(signed long int)1].isint = 0;
  argv[(signed long int)1].len = 8;
  argv[(signed long int)1].u.ptr = (signed int *)&len;
  res=PQfn(conn, (signed int)conn->lobjfuncs->fn_lo_truncate64, &retval, &result_len, 1, argv, 2);
  enum anonymous_20 return_value_PQresultStatus_4;
  return_value_PQresultStatus_4=PQresultStatus(res);
  if((signed int)return_value_PQresultStatus_4 == PGRES_COMMAND_OK)
  {
    PQclear(res);
    return retval;
  }

  else
  {
    PQclear(res);
    return -1;
  }
}

// lo_unlink
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 629
extern signed int lo_unlink(struct pg_conn *conn, unsigned int lobjId)
{
  struct anonymous_33 argv[1l];
  struct pg_result *res;
  signed int result_len;
  signed int retval;
  _Bool tmp_if_expr_2;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = conn->lobjfuncs == (struct pgLobjfuncs *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_lo_initialize_1;
    return_value_lo_initialize_1=lo_initialize(conn);
    if(!(return_value_lo_initialize_1 >= 0))
      return -1;

  }

  argv[(signed long int)0].isint = 1;
  argv[(signed long int)0].len = 4;
  argv[(signed long int)0].u.integer = (signed int)lobjId;
  res=PQfn(conn, (signed int)conn->lobjfuncs->fn_lo_unlink, &retval, &result_len, 1, argv, 1);
  enum anonymous_20 return_value_PQresultStatus_3;
  return_value_PQresultStatus_3=PQresultStatus(res);
  if((signed int)return_value_PQresultStatus_3 == PGRES_COMMAND_OK)
  {
    PQclear(res);
    return retval;
  }

  else
  {
    PQclear(res);
    return -1;
  }
}

// lo_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-lobj.c line 313
extern signed int lo_write(struct pg_conn *conn, signed int fd, const char *buf, unsigned long int len)
{
  struct anonymous_33 argv[2l];
  struct pg_result *res;
  signed int result_len;
  signed int retval;
  _Bool tmp_if_expr_2;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = conn->lobjfuncs == (struct pgLobjfuncs *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_lo_initialize_1;
    return_value_lo_initialize_1=lo_initialize(conn);
    if(!(return_value_lo_initialize_1 >= 0))
      return -1;

  }

  if(len >= 2147483648ul)
  {
    char *return_value_libpq_gettext_3;
    return_value_libpq_gettext_3=libpq_gettext("argument of lo_write exceeds integer range\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
    return -1;
  }

  argv[(signed long int)0].isint = 1;
  argv[(signed long int)0].len = 4;
  argv[(signed long int)0].u.integer = fd;
  argv[(signed long int)1].isint = 0;
  argv[(signed long int)1].len = (signed int)len;
  argv[(signed long int)1].u.ptr = (signed int *)buf;
  res=PQfn(conn, (signed int)conn->lobjfuncs->fn_lo_write, &retval, &result_len, 1, argv, 2);
  enum anonymous_20 return_value_PQresultStatus_4;
  return_value_PQresultStatus_4=PQresultStatus(res);
  if((signed int)return_value_PQresultStatus_4 == PGRES_COMMAND_OK)
  {
    PQclear(res);
    return retval;
  }

  else
  {
    PQclear(res);
    return -1;
  }
}

// main
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 2387
signed int main(signed int argc, char **argv)
{
  signed int c;
  signed int nclients = 1;
  signed int nthreads = 1;
  signed int is_init_mode = 0;
  signed int is_no_vacuum = 0;
  signed int do_vacuum_accounts = 0;
  signed int ttype = 0;
  signed int optindex;
  char *filename = (char *)(void *)0;
  char scale_given = (char)0;
  struct anonymous_18 *state;
  struct anonymous_17 *threads;
  struct timeval start_time;
  struct timeval total_time;
  struct timeval conn_total_time;
  signed long int total_xacts = (signed long int)0;
  signed long int total_latencies = (signed long int)0;
  signed long int total_sqlats = (signed long int)0;
  signed long int throttle_lag = (signed long int)0;
  signed long int throttle_lag_max = (signed long int)0;
  signed int i;
  struct rlimit rlim;
  struct pg_conn *con;
  struct pg_result *res;
  char *env;
  char val[64l];
  progname=get_progname(argv[(signed long int)0]);
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_5;
  if(argc >= 2)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(argv[(signed long int)1], "--help");
    if(return_value_strcmp_1 == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_strcmp_2=strcmp(argv[(signed long int)1], "-?");
      tmp_if_expr_3 = return_value_strcmp_2 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
    {
      usage();
      exit(0);
    }

    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(argv[(signed long int)1], "--version");
    if(return_value_strcmp_4 == 0)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_strcmp_5=strcmp(argv[(signed long int)1], "-V");
      tmp_if_expr_6 = return_value_strcmp_5 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      puts("pgbench (PostgreSQL) 9.4.5");
      exit(0);
    }

  }

  env=getenv("PGHOST");
  if(!(env == ((char *)NULL)))
  {
    if(!((signed int)*env == 0))
      pghost = env;

  }

  env=getenv("PGPORT");
  _Bool tmp_if_expr_7;
  if(!(env == ((char *)NULL)))
    tmp_if_expr_7 = (signed int)*env != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_7 = (_Bool)0;
  if(tmp_if_expr_7)
    pgport = env;

  else
  {
    env=getenv("PGUSER");
    if(!(env == ((char *)NULL)))
    {
      if(!((signed int)*env == 0))
        login = env;

    }

  }
  void *return_value_pg_malloc_8;
  return_value_pg_malloc_8=pg_malloc(sizeof(struct anonymous_18) /*248ul*/ );
  state = (struct anonymous_18 *)return_value_pg_malloc_8;
  memset((void *)state, 0, sizeof(struct anonymous_18) /*248ul*/ );
  signed int return_value_getrlimit_11;
  signed int return_value_process_file_12;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_14;
  char *tmp_post_15;
  signed int return_value_strcmp_17;
  char *return_value_gettext_18;
  do
  {
    static struct option long_options[31l] = { { .name="client", .has_arg=1, .flag=(signed int *)(void *)0, .val=99 },
    { .name="connect", .has_arg=0, .flag=(signed int *)(void *)0, .val=67 },
    { .name="debug", .has_arg=0, .flag=(signed int *)(void *)0, .val=100 },
    { .name="define", .has_arg=1, .flag=(signed int *)(void *)0, .val=68 },
    { .name="file", .has_arg=1, .flag=(signed int *)(void *)0, .val=102 },
    { .name="fillfactor", .has_arg=1, .flag=(signed int *)(void *)0, .val=70 },
    { .name="host", .has_arg=1, .flag=(signed int *)(void *)0, .val=104 },
    { .name="initialize", .has_arg=0, .flag=(signed int *)(void *)0, .val=105 },
    { .name="jobs", .has_arg=1, .flag=(signed int *)(void *)0, .val=106 },
    { .name="log", .has_arg=0, .flag=(signed int *)(void *)0, .val=108 },
    { .name="no-vacuum", .has_arg=0, .flag=(signed int *)(void *)0, .val=110 },
    { .name="port", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 },
    { .name="progress", .has_arg=1, .flag=(signed int *)(void *)0, .val=80 },
    { .name="protocol", .has_arg=1, .flag=(signed int *)(void *)0, .val=77 },
    { .name="quiet", .has_arg=0, .flag=(signed int *)(void *)0, .val=113 },
    { .name="report-latencies", .has_arg=0, .flag=(signed int *)(void *)0, .val=114 },
    { .name="scale", .has_arg=1, .flag=(signed int *)(void *)0, .val=115 },
    { .name="select-only", .has_arg=0, .flag=(signed int *)(void *)0, .val=83 },
    { .name="skip-some-updates", .has_arg=0, .flag=(signed int *)(void *)0,
    .val=78 },
    { .name="time", .has_arg=1, .flag=(signed int *)(void *)0, .val=84 },
    { .name="transactions", .has_arg=1, .flag=(signed int *)(void *)0, .val=116 },
    { .name="username", .has_arg=1, .flag=(signed int *)(void *)0, .val=85 },
    { .name="vacuum-all", .has_arg=0, .flag=(signed int *)(void *)0, .val=118 },
    { .name="foreign-keys", .has_arg=0, .flag=&foreign_keys, .val=1 },
    { .name="index-tablespace", .has_arg=1, .flag=(signed int *)(void *)0, .val=3 },
    { .name="tablespace", .has_arg=1, .flag=(signed int *)(void *)0, .val=2 },
    { .name="unlogged-tables", .has_arg=0, .flag=&unlogged_tables, .val=1 },
    { .name="sampling-rate", .has_arg=1, .flag=(signed int *)(void *)0, .val=4 },
    { .name="aggregate-interval", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=5 },
    { .name="rate", .has_arg=1, .flag=(signed int *)(void *)0, .val=82 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
    c=getopt_long(argc, argv, "ih:nvp:dqSNc:j:Crs:t:T:U:lf:D:F:M:P:R:", long_options, &optindex);
    if(c == -1)
      break;

    switch(c)
    {
      case 105:
      {
        is_init_mode = is_init_mode + 1;
        break;
      }
      case 104:
      {
        pghost=pg_strdup(optarg);
        break;
      }
      case 110:
      {
        is_no_vacuum = is_no_vacuum + 1;
        break;
      }
      case 118:
      {
        do_vacuum_accounts = do_vacuum_accounts + 1;
        break;
      }
      case 112:
      {
        pgport=pg_strdup(optarg);
        break;
      }
      case 100:
      {
        debug = debug + 1;
        break;
      }
      case 83:
      {
        ttype = 1;
        break;
      }
      case 78:
      {
        ttype = 2;
        break;
      }
      case 99:
      {
        nclients=atoi(optarg);
        if(nclients >= 1015 || !(nclients >= 1))
        {
          fprintf(stderr, "invalid number of clients: %d\n", nclients);
          exit(1);
        }

        return_value_getrlimit_11=getrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &rlim);
        if(return_value_getrlimit_11 == -1)
        {
          signed int *return_value___errno_location_9;
          return_value___errno_location_9=__errno_location();
          char *return_value_strerror_10;
          return_value_strerror_10=strerror(*return_value___errno_location_9);
          fprintf(stderr, "getrlimit failed: %s\n", return_value_strerror_10);
          exit(1);
        }

        if((unsigned long int)(2 + nclients) >= rlim.rlim_cur)
        {
          fprintf(stderr, "You need at least %d open files but you are only allowed to use %ld.\n", nclients + 2, (signed long int)rlim.rlim_cur);
          fprintf(stderr, "Use limit/ulimit to increase the limit before using pgbench.\n");
          exit(1);
        }

        break;
      }
      case 106:
      {
        nthreads=atoi(optarg);
        if(!(nthreads >= 1))
        {
          fprintf(stderr, "invalid number of threads: %d\n", nthreads);
          exit(1);
        }

        break;
      }
      case 67:
      {
        is_connect = (char)1;
        break;
      }
      case 114:
      {
        is_latencies = (char)1;
        break;
      }
      case 115:
      {
        scale_given = (char)1;
        scale=atoi(optarg);
        if(!(scale >= 1))
        {
          fprintf(stderr, "invalid scaling factor: %d\n", scale);
          exit(1);
        }

        break;
      }
      case 116:
      {
        if(duration >= 1)
        {
          fprintf(stderr, "specify either a number of transactions (-t) or a duration (-T), not both.\n");
          exit(1);
        }

        nxacts=atoi(optarg);
        if(!(nxacts >= 1))
        {
          fprintf(stderr, "invalid number of transactions: %d\n", nxacts);
          exit(1);
        }

        break;
      }
      case 84:
      {
        if(nxacts >= 1)
        {
          fprintf(stderr, "specify either a number of transactions (-t) or a duration (-T), not both.\n");
          exit(1);
        }

        duration=atoi(optarg);
        if(!(duration >= 1))
        {
          fprintf(stderr, "invalid duration: %d\n", duration);
          exit(1);
        }

        break;
      }
      case 85:
      {
        login=pg_strdup(optarg);
        break;
      }
      case 108:
      {
        use_log = (char)1;
        break;
      }
      case 113:
      {
        use_quiet = (char)1;
        break;
      }
      case 102:
      {
        ttype = 3;
        filename=pg_strdup(optarg);
        return_value_process_file_12=process_file(filename);
        if(return_value_process_file_12 == 0)
          tmp_if_expr_13 = (_Bool)1;

        else
          tmp_if_expr_13 = *sql_files[(signed long int)(num_files - 1)] == (struct anonymous_22 *)(void *)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_13)
          exit(1);

        break;
      }
      case 68:
      {
        char *p;
        p=strchr(optarg, 61);
        if(p == ((char *)NULL) || p == optarg)
          tmp_if_expr_14 = (_Bool)1;

        else
          tmp_if_expr_14 = (signed int)p[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_14)
        {
          fprintf(stderr, "invalid variable definition: %s\n", optarg);
          exit(1);
        }

        tmp_post_15 = p;
        p = p + 1l;
        *tmp_post_15 = (char)0;
        signed int return_value_putVariable_16;
        return_value_putVariable_16=putVariable(&state[(signed long int)0], "option", optarg, p);
        if(return_value_putVariable_16 == 0)
          exit(1);

        break;
      }
      case 70:
      {
        fillfactor=atoi(optarg);
        if(fillfactor >= 101 || !(fillfactor >= 10))
        {
          fprintf(stderr, "invalid fillfactor: %d\n", fillfactor);
          exit(1);
        }

        break;
      }
      case 77:
      {
        if(num_files >= 1)
        {
          fprintf(stderr, "query mode (-M) should be specified before transaction scripts (-f)\n");
          exit(1);
        }

        querymode = (enum QueryMode)0;
        for( ; !((signed int)querymode >= NUM_QUERYMODE); querymode = (enum QueryMode)((signed int)querymode + 1))
        {
          return_value_strcmp_17=strcmp(optarg, QUERYMODE[(signed long int)querymode]);
          if(return_value_strcmp_17 == 0)
            break;

        }
        if((signed int)querymode >= NUM_QUERYMODE)
        {
          fprintf(stderr, "invalid query mode (-M): %s\n", optarg);
          exit(1);
        }

        break;
      }
      case 80:
      {
        progress=atoi(optarg);
        if(!(progress >= 1))
        {
          fprintf(stderr, "thread progress delay (-P) must be positive (%s)\n", optarg);
          exit(1);
        }

        break;
      }
      case 82:
      {
        double throttle_value;
        throttle_value=atof(optarg);
        if(throttle_value <= 0.0)
        {
          fprintf(stderr, "invalid rate limit: %s\n", optarg);
          exit(1);
        }

        throttle_delay = (signed long int)(1000000.0 / throttle_value);
        break;
      }
      case 0:
        break;
      case 2:
      {
        tablespace=pg_strdup(optarg);
        break;
      }
      case 3:
      {
        index_tablespace=pg_strdup(optarg);
        break;
      }
      case 4:
      {
        sample_rate=atof(optarg);
        if(sample_rate <= 0.0 || sample_rate > 1.0)
        {
          fprintf(stderr, "invalid sampling rate: %f\n", sample_rate);
          exit(1);
        }

        break;
      }
      case 5:
      {
        agg_interval=atoi(optarg);
        if(!(agg_interval >= 1))
        {
          fprintf(stderr, "invalid number of seconds for aggregation: %d\n", agg_interval);
          exit(1);
        }

        break;
      }
      default:
      {
        return_value_gettext_18=gettext("Try \"%s --help\" for more information.\n");
        fprintf(stderr, return_value_gettext_18, progname);
        exit(1);
      }
    }
  }
  while((_Bool)1);
  throttle_delay = throttle_delay * (signed long int)nthreads;
  _Bool tmp_if_expr_20;
  _Bool tmp_if_expr_19;
  if(!(optind >= argc))
    dbName = argv[(signed long int)optind];

  else
  {
    env=getenv("PGDATABASE");
    if(!(env == ((char *)NULL)))
      tmp_if_expr_20 = (signed int)*env != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_20 = (_Bool)0;
    if(tmp_if_expr_20)
      dbName = env;

    else
    {
      if(!(login == ((char *)NULL)))
        tmp_if_expr_19 = (signed int)*login != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_19 = (_Bool)0;
      if(tmp_if_expr_19)
        dbName = login;

      else
        dbName = "";
    }
  }
  if(!(is_init_mode == 0))
  {
    init((char)is_no_vacuum);
    exit(0);
  }

  if(!(duration >= 1) && !(nxacts >= 1))
    nxacts = 10;

  if(!(nclients % nthreads == 0))
  {
    fprintf(stderr, "number of clients (%d) must be a multiple of number of threads (%d)\n", nclients, nthreads);
    exit(1);
  }

  if(use_log == 0 && sample_rate > 0.0)
  {
    fprintf(stderr, "log sampling rate is allowed only when logging transactions (-l) \n");
    exit(1);
  }

  if(is_init_mode == 0 && !(use_quiet == 0))
  {
    fprintf(stderr, "quiet-logging is allowed only in initialization mode (-i)\n");
    exit(1);
  }

  if(sample_rate > 0.0 && agg_interval >= 1)
  {
    fprintf(stderr, "log sampling (--sampling-rate) and aggregation (--aggregate-interval) can't be used at the same time\n");
    exit(1);
  }

  if(use_log == 0 && agg_interval >= 1)
  {
    fprintf(stderr, "log aggregation is allowed only when actually logging transactions\n");
    exit(1);
  }

  if(duration >= 1 && !(duration >= agg_interval))
  {
    fprintf(stderr, "number of seconds for aggregation (%d) must not be higher that test duration (%d)\n", agg_interval, duration);
    exit(1);
  }

  if(agg_interval >= 1 && duration >= 1 && !(duration % agg_interval == 0))
  {
    fprintf(stderr, "duration (%d) must be a multiple of aggregation interval (%d)\n", duration, agg_interval);
    exit(1);
  }

  signed int return_value_getpid_21;
  return_value_getpid_21=getpid();
  main_pid = (signed int)return_value_getpid_21;
  progress_nclients = nclients;
  progress_nthreads = nthreads;
  if(nclients >= 2)
  {
    void *return_value_pg_realloc_22;
    return_value_pg_realloc_22=pg_realloc((void *)state, sizeof(struct anonymous_18) /*248ul*/  * (unsigned long int)nclients);
    state = (struct anonymous_18 *)return_value_pg_realloc_22;
    memset((void *)(state + (signed long int)1), 0, sizeof(struct anonymous_18) /*248ul*/  * (unsigned long int)(nclients - 1));
    i = 1;
    for( ; !(i >= nclients); i = i + 1)
    {
      signed int j;
      (state + (signed long int)i)->id = i;
      j = 0;
      for( ; !(j >= state->nvariables); j = j + 1)
      {
        signed int return_value_putVariable_23;
        return_value_putVariable_23=putVariable(&state[(signed long int)i], "startup", ((state + (signed long int)0)->variables + (signed long int)j)->name, ((state + (signed long int)0)->variables + (signed long int)j)->value);
        if(return_value_putVariable_23 == 0)
          exit(1);

      }
    }
  }

  if(!(debug == 0))
  {
    if(!(duration >= 1))
      printf("pghost: %s pgport: %s nclients: %d nxacts: %d dbName: %s\n", pghost, pgport, nclients, nxacts, dbName);

    else
      printf("pghost: %s pgport: %s nclients: %d duration: %d dbName: %s\n", pghost, pgport, nclients, duration, dbName);
  }

  con=doConnect();
  if(con == ((struct pg_conn *)NULL))
    exit(1);

  enum anonymous_24 return_value_PQstatus_25;
  return_value_PQstatus_25=PQstatus(con);
  if((signed int)return_value_PQstatus_25 == CONNECTION_BAD)
  {
    fprintf(stderr, "Connection to database '%s' failed.\n", dbName);
    char *return_value_PQerrorMessage_24;
    return_value_PQerrorMessage_24=PQerrorMessage(con);
    fprintf(stderr, "%s", return_value_PQerrorMessage_24);
    exit(1);
  }

  if(!(ttype == 3))
  {
    res=PQexec(con, "select count(*) from pgbench_branches");
    enum anonymous_20 return_value_PQresultStatus_27;
    return_value_PQresultStatus_27=PQresultStatus(res);
    if(!((signed int)return_value_PQresultStatus_27 == PGRES_TUPLES_OK))
    {
      char *return_value_PQerrorMessage_26;
      return_value_PQerrorMessage_26=PQerrorMessage(con);
      fprintf(stderr, "%s", return_value_PQerrorMessage_26);
      exit(1);
    }

    char *return_value_PQgetvalue_28;
    return_value_PQgetvalue_28=PQgetvalue(res, 0, 0);
    scale=atoi(return_value_PQgetvalue_28);
    if(!(scale >= 0))
    {
      fprintf(stderr, "count(*) from pgbench_branches invalid (%d)\n", scale);
      exit(1);
    }

    PQclear(res);
    if(!(scale_given == 0))
      fprintf(stderr, "Scale option ignored, using pgbench_branches table count = %d\n", scale);

  }

  char *return_value_getVariable_30;
  return_value_getVariable_30=getVariable(&state[(signed long int)0], "scale");
  if(return_value_getVariable_30 == ((char *)NULL))
  {
    snprintf(val, sizeof(char [64l]) /*64ul*/ , "%d", scale);
    i = 0;
    for( ; !(i >= nclients); i = i + 1)
    {
      signed int return_value_putVariable_29;
      return_value_putVariable_29=putVariable(&state[(signed long int)i], "startup", "scale", val);
      if(return_value_putVariable_29 == 0)
        exit(1);

    }
  }

  char *return_value_getVariable_32;
  return_value_getVariable_32=getVariable(&state[(signed long int)0], "client_id");
  if(return_value_getVariable_32 == ((char *)NULL))
  {
    i = 0;
    for( ; !(i >= nclients); i = i + 1)
    {
      snprintf(val, sizeof(char [64l]) /*64ul*/ , "%d", i);
      signed int return_value_putVariable_31;
      return_value_putVariable_31=putVariable(&state[(signed long int)i], "startup", "client_id", val);
      if(return_value_putVariable_31 == 0)
        exit(1);

    }
  }

  if(is_no_vacuum == 0)
  {
    fprintf(stderr, "starting vacuum...");
    executeStatement(con, "vacuum pgbench_branches");
    executeStatement(con, "vacuum pgbench_tellers");
    executeStatement(con, "truncate pgbench_history");
    fprintf(stderr, "end.\n");
    if(!(do_vacuum_accounts == 0))
    {
      fprintf(stderr, "starting vacuum pgbench_accounts...");
      executeStatement(con, "vacuum analyze pgbench_accounts");
      fprintf(stderr, "end.\n");
    }

  }

  PQfinish(con);
  gettimeofday(&start_time, (struct timezone *)(void *)0);
  srandom((unsigned int)((unsigned long int)start_time.tv_sec * (unsigned long int)1000000 + (unsigned long int)start_time.tv_usec));
  switch(ttype)
  {
    case 0:
    {
      sql_files[(signed long int)0]=process_builtin(tpc_b);
      num_files = 1;
      break;
    }
    case 1:
    {
      sql_files[(signed long int)0]=process_builtin(select_only);
      num_files = 1;
      break;
    }
    case 2:
    {
      sql_files[(signed long int)0]=process_builtin(simple_update);
      num_files = 1;
    }
  }
  void *return_value_pg_malloc_33;
  return_value_pg_malloc_33=pg_malloc(sizeof(struct anonymous_17) /*96ul*/  * (unsigned long int)nthreads);
  threads = (struct anonymous_17 *)return_value_pg_malloc_33;
  i = 0;
  for( ; !(i >= nthreads); i = i + 1)
  {
    struct anonymous_17 *thread = &threads[(signed long int)i];
    thread->tid = i;
    thread->state = &state[(signed long int)((nclients / nthreads) * i)];
    thread->nstate = nclients / nthreads;
    signed long int return_value_random_34;
    return_value_random_34=random();
    thread->random_state[(signed long int)0] = (unsigned short int)return_value_random_34;
    signed long int return_value_random_35;
    return_value_random_35=random();
    thread->random_state[(signed long int)1] = (unsigned short int)return_value_random_35;
    signed long int return_value_random_36;
    return_value_random_36=random();
    thread->random_state[(signed long int)2] = (unsigned short int)return_value_random_36;
    if(!(is_latencies == 0))
    {
      signed int t;
      void *return_value_pg_malloc_37;
      return_value_pg_malloc_37=pg_malloc(sizeof(struct timeval) /*16ul*/  * (unsigned long int)num_commands);
      thread->exec_elapsed = (struct timeval *)return_value_pg_malloc_37;
      void *return_value_pg_malloc_38;
      return_value_pg_malloc_38=pg_malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)num_commands);
      thread->exec_count = (signed int *)return_value_pg_malloc_38;
      t = 0;
      for( ; !(t >= num_commands); t = t + 1)
      {
        (thread->exec_elapsed + (signed long int)t)->tv_sec = (signed long int)0;
        (thread->exec_elapsed + (signed long int)t)->tv_usec = (signed long int)0;
        thread->exec_count[(signed long int)t] = 0;
      }
    }

    else
    {
      thread->exec_elapsed = (struct timeval *)(void *)0;
      thread->exec_count = (signed int *)(void *)0;
    }
  }
  gettimeofday(&start_time, (struct timezone *)(void *)0);
  if(duration >= 1)
    setalarm(duration);

  i = 0;
  _Bool tmp_if_expr_40;
  for( ; !(i >= nthreads); i = i + 1)
  {
    struct anonymous_17 *main__1__21__1__thread = &threads[(signed long int)i];
    gettimeofday(&main__1__21__1__thread->start_time, (struct timezone *)(void *)0);
    if(i >= 1)
    {
      signed int err;
      err=pthread_create(&main__1__21__1__thread->thread, (const union pthread_attr_t *)(void *)0, threadRun, (void *)main__1__21__1__thread);
      if(!(err == 0))
        tmp_if_expr_40 = (_Bool)1;

      else
        tmp_if_expr_40 = main__1__21__1__thread->thread == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_40)
      {
        char *return_value_strerror_39;
        return_value_strerror_39=strerror(err);
        fprintf(stderr, "cannot create thread: %s\n", return_value_strerror_39);
        exit(1);
      }

    }

    else
      main__1__21__1__thread->thread = (unsigned long int)0;
  }
  conn_total_time.tv_sec = (signed long int)0;
  conn_total_time.tv_usec = (signed long int)0;
  i = 0;
  for( ; !(i >= nthreads); i = i + 1)
  {
    void *ret = (void *)0;
    if((threads + (signed long int)i)->thread == 0ul)
      ret=threadRun((void *)&threads[(signed long int)i]);

    else
      pthread_join((threads + (signed long int)i)->thread, &ret);
    if(!(ret == NULL))
    {
      struct anonymous_30 *r = (struct anonymous_30 *)ret;
      total_xacts = total_xacts + r->xacts;
      total_latencies = total_latencies + r->latencies;
      total_sqlats = total_sqlats + r->sqlats;
      throttle_lag = throttle_lag + r->throttle_lag;
      if(!(throttle_lag_max >= r->throttle_lag_max))
        throttle_lag_max = r->throttle_lag_max;

      do
      {
        conn_total_time.tv_sec = conn_total_time.tv_sec + r->conn_time.tv_sec;
        conn_total_time.tv_usec = conn_total_time.tv_usec + r->conn_time.tv_usec;
        for( ; conn_total_time.tv_usec >= 1000000l; conn_total_time.tv_sec = conn_total_time.tv_sec + 1l)
          conn_total_time.tv_usec = conn_total_time.tv_usec - (signed long int)1000000;
      }
      while((_Bool)0);
      free(ret);
    }

  }
  disconnect_all(state, nclients);
  gettimeofday(&total_time, (struct timezone *)(void *)0);
  do
  {
    total_time.tv_sec = total_time.tv_sec - start_time.tv_sec;
    total_time.tv_usec = total_time.tv_usec - start_time.tv_usec;
    for( ; !(total_time.tv_usec >= 0l); total_time.tv_sec = total_time.tv_sec - 1l)
      total_time.tv_usec = total_time.tv_usec + (signed long int)1000000;
  }
  while((_Bool)0);
  printResults(ttype, total_xacts, nclients, threads, nthreads, total_time, conn_total_time, total_latencies, total_sqlats, throttle_lag, throttle_lag_max);
  return 0;
}

// makeEmptyPGconn
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 2744
static struct pg_conn * makeEmptyPGconn(void)
{
  struct pg_conn *conn;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct pg_conn) /*904ul*/ );
  conn = (struct pg_conn *)return_value_malloc_1;
  signed long int *tmp_post_2;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  if(conn == ((struct pg_conn *)NULL))
    return conn;

  else
  {
    do
    {
      void *_vstart = (void *)conn;
      signed int _val = 0;
      unsigned long int _len = sizeof(struct pg_conn) /*904ul*/ ;
      if((7ul & _len) == 0ul && (7ul & (unsigned long int)_vstart) == 0ul && _val == 0 && !(_len >= 1025ul))
      {
        signed long int *makeEmptyPGconn__1__2__1___start = (signed long int *)_vstart;
        signed long int *_stop = (signed long int *)((char *)makeEmptyPGconn__1__2__1___start + (signed long int)_len);
        for( ; !(makeEmptyPGconn__1__2__1___start >= _stop); *tmp_post_2 = (signed long int)0)
        {
          tmp_post_2 = makeEmptyPGconn__1__2__1___start;
          makeEmptyPGconn__1__2__1___start = makeEmptyPGconn__1__2__1___start + 1l;
        }
      }

      else
        memset(_vstart, _val, _len);
    }
    while((_Bool)0);
    conn->noticeHooks.noticeRec = defaultNoticeReceiver;
    conn->noticeHooks.noticeProc = defaultNoticeProcessor;
    conn->status = (enum anonymous_24)CONNECTION_BAD;
    conn->asyncStatus = (enum anonymous_9)PGASYNC_IDLE;
    conn->xactStatus = (enum anonymous_3)PQTRANS_IDLE;
    conn->options_valid = (char)0;
    conn->nonblocking = (char)0;
    conn->setenv_state = (enum anonymous_11)SETENV_STATE_IDLE;
    conn->client_encoding = PG_SQL_ASCII;
    conn->std_strings = (char)0;
    conn->verbosity = (enum anonymous_5)PQERRORS_DEFAULT;
    conn->sock = -1;
    conn->auth_req_received = (char)0;
    conn->password_needed = (char)0;
    conn->dot_pgpass_used = (char)0;
    conn->allow_ssl_try = (char)1;
    conn->wait_ssl_try = (char)0;
    conn->inBufSize = 16 * 1024;
    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)conn->inBufSize);
    conn->inBuffer = (char *)return_value_malloc_3;
    conn->outBufSize = 16 * 1024;
    void *return_value_malloc_4;
    return_value_malloc_4=malloc((unsigned long int)conn->outBufSize);
    conn->outBuffer = (char *)return_value_malloc_4;
    conn->rowBufLen = 32;
    void *return_value_malloc_5;
    return_value_malloc_5=malloc((unsigned long int)conn->rowBufLen * sizeof(struct pgDataValue) /*16ul*/ );
    conn->rowBuf = (struct pgDataValue *)return_value_malloc_5;
    initPQExpBuffer(&conn->errorMessage);
    initPQExpBuffer(&conn->workBuffer);
    if(conn->inBuffer == ((char *)NULL))
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = conn->outBuffer == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = conn->rowBuf == (struct pgDataValue *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_7)
      tmp_if_expr_8 = (_Bool)1;

    else
      tmp_if_expr_8 = ((&conn->errorMessage)->maxlen == (unsigned long int)0 ? (_Bool)1 : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_8)
      tmp_if_expr_9 = (_Bool)1;

    else
      tmp_if_expr_9 = ((&conn->workBuffer)->maxlen == (unsigned long int)0 ? (_Bool)1 : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_9)
    {
      freePGconn(conn);
      conn = (struct pg_conn *)(void *)0;
    }

    return conn;
  }
}

// make_absolute_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 574
extern char * make_absolute_path(const char *path)
{
  char *new;
  signed int *return_value___errno_location_8;
  if(path == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    if(!((signed int)*path == 47))
    {
      char *buf;
      unsigned long int buflen = (unsigned long int)1024;
      do
      {
        void *return_value_malloc_1;
        return_value_malloc_1=malloc(buflen);
        buf = (char *)return_value_malloc_1;
        if(buf == ((char *)NULL))
        {
          char *return_value_gettext_2;
          return_value_gettext_2=gettext("out of memory\n");
          fprintf(stderr, return_value_gettext_2);
          return (char *)(void *)0;
        }

        char *return_value_getcwd_9;
        return_value_getcwd_9=getcwd(buf, buflen);
        if(!(return_value_getcwd_9 == ((char *)NULL)))
          break;

        else
        {
          return_value___errno_location_8=__errno_location();
          if(*return_value___errno_location_8 == 34)
          {
            free((void *)buf);
            buflen = buflen * (unsigned long int)2;
            continue;
          }

          else
          {
            signed int save_errno;
            signed int *return_value___errno_location_3;
            return_value___errno_location_3=__errno_location();
            save_errno = *return_value___errno_location_3;
            free((void *)buf);
            signed int *return_value___errno_location_4;
            return_value___errno_location_4=__errno_location();
            *return_value___errno_location_4 = save_errno;
            char *return_value_gettext_5;
            return_value_gettext_5=gettext("could not get current working directory: %s\n");
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            char *return_value_strerror_7;
            return_value_strerror_7=strerror(*return_value___errno_location_6);
            fprintf(stderr, return_value_gettext_5, return_value_strerror_7);
            return (char *)(void *)0;
          }
        }
      }
      while((_Bool)1);
      unsigned long int return_value_strlen_10;
      return_value_strlen_10=strlen(buf);
      unsigned long int return_value_strlen_11;
      return_value_strlen_11=strlen(path);
      void *return_value_malloc_12;
      return_value_malloc_12=malloc(return_value_strlen_10 + return_value_strlen_11 + (unsigned long int)2);
      new = (char *)return_value_malloc_12;
      if(new == ((char *)NULL))
      {
        free((void *)buf);
        char *return_value_gettext_13;
        return_value_gettext_13=gettext("out of memory\n");
        fprintf(stderr, return_value_gettext_13);
        return (char *)(void *)0;
      }

      sprintf(new, "%s/%s", buf, path);
      free((void *)buf);
    }

    else
    {
      new=strdup(path);
      if(new == ((char *)NULL))
      {
        char *return_value_gettext_14;
        return_value_gettext_14=gettext("out of memory\n");
        fprintf(stderr, return_value_gettext_14);
        return (char *)(void *)0;
      }

    }
    canonicalize_path(new);
    return new;
  }
}

// make_native_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 162
extern void make_native_path(char *filename)
{
  ;
}

// make_relative_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 505
static void make_relative_path(char *ret_path, const char *target_path, const char *bin_path, const char *my_exec_path)
{
  signed int prefix_len;
  signed int tail_start;
  signed int tail_len;
  signed int i;
  prefix_len = 0;
  i = 0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  do
  {
    if(!(target_path[(signed long int)i] == 0))
      tmp_if_expr_1 = bin_path[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    if((signed int)target_path[(signed long int)i] == 47)
      tmp_if_expr_2 = (signed int)bin_path[(signed long int)i] == 47 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      prefix_len = i + 1;

    else
      if(!(target_path[(signed long int)i] == bin_path[(signed long int)i]))
        break;

    i = i + 1;
  }
  while((_Bool)1);
  unsigned long int return_value_strlen_3;
  unsigned long int return_value_strlen_4;
  signed int return_value_dir_strcmp_5;
  if(!(prefix_len == 0))
  {
    return_value_strlen_3=strlen(bin_path);
    tail_len = (signed int)(return_value_strlen_3 - (unsigned long int)prefix_len);
    strlcpy(ret_path, my_exec_path, (unsigned long int)1024);
    trim_directory(ret_path);
    canonicalize_path(ret_path);
    return_value_strlen_4=strlen(ret_path);
    tail_start = (signed int)return_value_strlen_4 - tail_len;
    if(!(tail_start >= 1))
      goto no_match;

    if(!((signed int)ret_path[(signed long int)(tail_start + -1)] == 47))
      goto no_match;

    return_value_dir_strcmp_5=dir_strcmp(ret_path + (signed long int)tail_start, bin_path + (signed long int)prefix_len);
    if(!(return_value_dir_strcmp_5 == 0))
      goto no_match;

    ret_path[(signed long int)tail_start] = (char)0;
    trim_trailing_separator(ret_path);
    join_path_components(ret_path, ret_path, target_path + (signed long int)prefix_len);
    canonicalize_path(ret_path);
  }

  else
  {

  no_match:
    ;
    strlcpy(ret_path, target_path, (unsigned long int)1024);
    canonicalize_path(ret_path);
  }
}

// make_relative_path_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 505
static void make_relative_path_link1(char *ret_path_link1, const char *target_path_link1, const char *bin_path_link1, const char *my_exec_path_link1)
{
  signed int prefix_len_link1;
  signed int tail_start_link1;
  signed int tail_len_link1;
  signed int i_link1;
  prefix_len_link1 = 0;
  i_link1 = 0;
  _Bool tmp_if_expr_1_link1;
  _Bool tmp_if_expr_2_link1;
  do
  {
    if(!(target_path_link1[(signed long int)i_link1] == 0))
      tmp_if_expr_1_link1 = bin_path_link1[(signed long int)i_link1] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1_link1 = (_Bool)0;
    if(!tmp_if_expr_1_link1)
      break;

    if((signed int)target_path_link1[(signed long int)i_link1] == 47)
      tmp_if_expr_2_link1 = (signed int)bin_path_link1[(signed long int)i_link1] == 47 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2_link1 = (_Bool)0;
    if(tmp_if_expr_2_link1)
      prefix_len_link1 = i_link1 + 1;

    else
      if(!(target_path_link1[(signed long int)i_link1] == bin_path_link1[(signed long int)i_link1]))
        break;

    i_link1 = i_link1 + 1;
  }
  while((_Bool)1);
  unsigned long int return_value_strlen_3_link1;
  unsigned long int return_value_strlen_4_link1;
  signed int return_value_dir_strcmp_5_link1;
  if(!(prefix_len_link1 == 0))
  {
    return_value_strlen_3_link1=strlen(bin_path_link1);
    tail_len_link1 = (signed int)(return_value_strlen_3_link1 - (unsigned long int)prefix_len_link1);
    strlcpy(ret_path_link1, my_exec_path_link1, (unsigned long int)1024);
    trim_directory_link1(ret_path_link1);
    canonicalize_path(ret_path_link1);
    return_value_strlen_4_link1=strlen(ret_path_link1);
    tail_start_link1 = (signed int)return_value_strlen_4_link1 - tail_len_link1;
    if(!(tail_start_link1 >= 1))
      goto no_match;

    if(!((signed int)ret_path_link1[(signed long int)(tail_start_link1 + -1)] == 47))
      goto no_match;

    return_value_dir_strcmp_5_link1=dir_strcmp_link1(ret_path_link1 + (signed long int)tail_start_link1, bin_path_link1 + (signed long int)prefix_len_link1);
    if(!(return_value_dir_strcmp_5_link1 == 0))
      goto no_match;

    ret_path_link1[(signed long int)tail_start_link1] = (char)0;
    trim_trailing_separator_link1(ret_path_link1);
    join_path_components(ret_path_link1, ret_path_link1, target_path_link1 + (signed long int)prefix_len_link1);
    canonicalize_path(ret_path_link1);
  }

  else
  {

  no_match:
    ;
    strlcpy(ret_path_link1, target_path_link1, (unsigned long int)1024);
    canonicalize_path(ret_path_link1);
  }
}

// markPQExpBufferBroken
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.c line 51
static void markPQExpBufferBroken(struct PQExpBufferData *str)
{
  if(!(str->data == oom_buffer))
    free((void *)str->data);

  str->data = (char *)oom_buffer;
  str->len = (unsigned long int)0;
  str->maxlen = (unsigned long int)0;
}

// mbbisearch
// file wchar.c line 584
static signed int mbbisearch(unsigned int ucs, struct mbinterval *table, signed int max)
{
  signed int min = 0;
  signed int mid;
  _Bool tmp_if_expr_1;
  if(!(ucs >= (unsigned int)table->first))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ucs > (unsigned int)(table + (signed long int)max)->last ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    while(max >= min)
    {
      mid = (min + max) / 2;
      if(!((unsigned int)(table + (signed long int)mid)->last >= ucs))
        min = mid + 1;

      else
        if(!(ucs >= (unsigned int)(table + (signed long int)mid)->first))
          max = mid - 1;

        else
          return 1;
    }
    return 0;
  }
}

// med3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort.c line 105
static char * med3(char *a, char *b, char *c, signed int (*cmp)(const void *, const void *))
{
  signed int return_value;
  return_value=cmp((const void *)a, (const void *)b);
  char *tmp_if_expr_3;
  signed int return_value_1;
  char *tmp_if_expr_1;
  signed int return_value_2;
  signed int return_value_3;
  char *tmp_if_expr_2;
  signed int return_value_4;
  if(!(return_value >= 0))
  {
    return_value_1=cmp((const void *)b, (const void *)c);
    if(!(return_value_1 >= 0))
      tmp_if_expr_1 = b;

    else
    {
      return_value_2=cmp((const void *)a, (const void *)c);
      tmp_if_expr_1 = return_value_2 < 0 ? c : a;
    }
    tmp_if_expr_3 = tmp_if_expr_1;
  }

  else
  {
    return_value_3=cmp((const void *)b, (const void *)c);
    if(return_value_3 >= 1)
      tmp_if_expr_2 = b;

    else
    {
      return_value_4=cmp((const void *)a, (const void *)c);
      tmp_if_expr_2 = return_value_4 < 0 ? a : c;
    }
    tmp_if_expr_3 = tmp_if_expr_2;
  }
  return tmp_if_expr_3;
}

// med3_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort_arg.c line 105
static char * med3_link1(char *a_link1, char *b_link1, char *c_link1, signed int (*cmp_link1)(const void *, const void *, void *), void *arg)
{
  signed int return_value_link1;
  return_value_link1=cmp_link1((const void *)a_link1, (const void *)b_link1, arg);
  char *tmp_if_expr_3_link1;
  signed int return_value_1_link1;
  char *tmp_if_expr_1_link1;
  signed int return_value_2_link1;
  signed int return_value_3_link1;
  char *tmp_if_expr_2_link1;
  signed int return_value_4_link1;
  if(!(return_value_link1 >= 0))
  {
    return_value_1_link1=cmp_link1((const void *)b_link1, (const void *)c_link1, arg);
    if(!(return_value_1_link1 >= 0))
      tmp_if_expr_1_link1 = b_link1;

    else
    {
      return_value_2_link1=cmp_link1((const void *)a_link1, (const void *)c_link1, arg);
      tmp_if_expr_1_link1 = return_value_2_link1 < 0 ? c_link1 : a_link1;
    }
    tmp_if_expr_3_link1 = tmp_if_expr_1_link1;
  }

  else
  {
    return_value_3_link1=cmp_link1((const void *)b_link1, (const void *)c_link1, arg);
    if(return_value_3_link1 >= 1)
      tmp_if_expr_2_link1 = b_link1;

    else
    {
      return_value_4_link1=cmp_link1((const void *)a_link1, (const void *)c_link1, arg);
      tmp_if_expr_2_link1 = return_value_4_link1 < 0 ? a_link1 : c_link1;
    }
    tmp_if_expr_3_link1 = tmp_if_expr_2_link1;
  }
  return tmp_if_expr_3_link1;
}

// med3_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort.c line 105
static char * med3_link2(char *a_link2, char *b_link2, char *c_link2, signed int (*cmp_link2)(const void *, const void *))
{
  signed int return_value_link2;
  return_value_link2=cmp_link2((const void *)a_link2, (const void *)b_link2);
  char *tmp_if_expr_3_link2;
  signed int return_value_1_link2;
  char *tmp_if_expr_1_link2;
  signed int return_value_2_link2;
  signed int return_value_3_link2;
  char *tmp_if_expr_2_link2;
  signed int return_value_4_link2;
  if(!(return_value_link2 >= 0))
  {
    return_value_1_link2=cmp_link2((const void *)b_link2, (const void *)c_link2);
    if(!(return_value_1_link2 >= 0))
      tmp_if_expr_1_link2 = b_link2;

    else
    {
      return_value_2_link2=cmp_link2((const void *)a_link2, (const void *)c_link2);
      tmp_if_expr_1_link2 = return_value_2_link2 < 0 ? c_link2 : a_link2;
    }
    tmp_if_expr_3_link2 = tmp_if_expr_1_link2;
  }

  else
  {
    return_value_3_link2=cmp_link2((const void *)b_link2, (const void *)c_link2);
    if(return_value_3_link2 >= 1)
      tmp_if_expr_2_link2 = b_link2;

    else
    {
      return_value_4_link2=cmp_link2((const void *)a_link2, (const void *)c_link2);
      tmp_if_expr_2_link2 = return_value_4_link2 < 0 ? a_link2 : c_link2;
    }
    tmp_if_expr_3_link2 = tmp_if_expr_2_link2;
  }
  return tmp_if_expr_3_link2;
}

// med3_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort_arg.c line 105
static char * med3_link3(char *a_link3, char *b_link3, char *c_link3, signed int (*cmp_link3)(const void *, const void *, void *), void *arg_link1)
{
  signed int return_value_link3;
  return_value_link3=cmp_link3((const void *)a_link3, (const void *)b_link3, arg_link1);
  char *tmp_if_expr_3_link3;
  signed int return_value_1_link3;
  char *tmp_if_expr_1_link3;
  signed int return_value_2_link3;
  signed int return_value_3_link3;
  char *tmp_if_expr_2_link3;
  signed int return_value_4_link3;
  if(!(return_value_link3 >= 0))
  {
    return_value_1_link3=cmp_link3((const void *)b_link3, (const void *)c_link3, arg_link1);
    if(!(return_value_1_link3 >= 0))
      tmp_if_expr_1_link3 = b_link3;

    else
    {
      return_value_2_link3=cmp_link3((const void *)a_link3, (const void *)c_link3, arg_link1);
      tmp_if_expr_1_link3 = return_value_2_link3 < 0 ? c_link3 : a_link3;
    }
    tmp_if_expr_3_link3 = tmp_if_expr_1_link3;
  }

  else
  {
    return_value_3_link3=cmp_link3((const void *)b_link3, (const void *)c_link3, arg_link1);
    if(return_value_3_link3 >= 1)
      tmp_if_expr_2_link3 = b_link3;

    else
    {
      return_value_4_link3=cmp_link3((const void *)a_link3, (const void *)c_link3, arg_link1);
      tmp_if_expr_2_link3 = return_value_4_link3 < 0 ? a_link3 : c_link3;
    }
    tmp_if_expr_3_link3 = tmp_if_expr_2_link3;
  }
  return tmp_if_expr_3_link3;
}

// open_client_SSL
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 1464
static enum anonymous_4 open_client_SSL(struct pg_conn *conn)
{
  signed int r;
  r=SSL_connect(conn->ssl);
  char sebuf[256l];
  char *return_value_libpq_gettext_1;
  signed int *return_value___errno_location_2;
  char *return_value_pqStrerror_3;
  char *return_value_libpq_gettext_4;
  char *open_client_SSL__1__1__1__2__err;
  char *return_value_libpq_gettext_5;
  char *return_value_libpq_gettext_6;
  if(!(r >= 1))
  {
    signed int open_client_SSL__1__1__err;
    open_client_SSL__1__1__err=SSL_get_error(conn->ssl, r);
    switch(open_client_SSL__1__1__err)
    {
      case 2:
        return (enum anonymous_4)PGRES_POLLING_READING;
      case 3:
        return (enum anonymous_4)PGRES_POLLING_WRITING;
      case 5:
      {
        if(r == -1)
        {
          return_value_libpq_gettext_1=libpq_gettext("SSL SYSCALL error: %s\n");
          return_value___errno_location_2=__errno_location();
          return_value_pqStrerror_3=pqStrerror(*return_value___errno_location_2, sebuf, sizeof(char [256l]) /*256ul*/ );
          printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1, return_value_pqStrerror_3);
        }

        else
        {
          return_value_libpq_gettext_4=libpq_gettext("SSL SYSCALL error: EOF detected\n");
          printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_4);
        }
        close_SSL(conn);
        return (enum anonymous_4)PGRES_POLLING_FAILED;
      }
      case 1:
      {
        open_client_SSL__1__1__1__2__err=SSLerrmessage();
        return_value_libpq_gettext_5=libpq_gettext("SSL error: %s\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_5, open_client_SSL__1__1__1__2__err);
        SSLerrfree(open_client_SSL__1__1__1__2__err);
        close_SSL(conn);
        return (enum anonymous_4)PGRES_POLLING_FAILED;
      }
      default:
      {
        return_value_libpq_gettext_6=libpq_gettext("unrecognized SSL error code: %d\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_6, open_client_SSL__1__1__err);
        close_SSL(conn);
        return (enum anonymous_4)PGRES_POLLING_FAILED;
      }
    }
  }

  conn->peer=SSL_get_peer_certificate(conn->ssl);
  if(conn->peer == ((struct x509_st *)NULL))
  {
    char *err;
    err=SSLerrmessage();
    char *return_value_libpq_gettext_7;
    return_value_libpq_gettext_7=libpq_gettext("certificate could not be obtained: %s\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_7, err);
    SSLerrfree(err);
    close_SSL(conn);
    return (enum anonymous_4)PGRES_POLLING_FAILED;
  }

  char return_value_verify_peer_name_matches_certificate_8;
  return_value_verify_peer_name_matches_certificate_8=verify_peer_name_matches_certificate(conn);
  if(return_value_verify_peer_name_matches_certificate_8 == 0)
  {
    close_SSL(conn);
    return (enum anonymous_4)PGRES_POLLING_FAILED;
  }

  else
    return (enum anonymous_4)PGRES_POLLING_OK;
}

// output_row
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-print.c line 525
static void output_row(struct _IO_FILE *fout, const struct _PQprintOpt *po, const signed int nFields, char **fields, unsigned char *fieldNotNum, signed int *fieldMax, char *border, const signed int row_index)
{
  signed int field_index;
  if(!(po->html3 == 0))
    fputs("<tr>", fout);

  else
    if(!(po->standard == 0))
      fputs(po->fieldSep, fout);

  field_index = 0;
  char *tmp_if_expr_1;
  for( ; !(field_index >= nFields); field_index = field_index + 1)
  {
    char *p = fields[(signed long int)(row_index * nFields + field_index)];
    if(!(po->html3 == 0))
      fprintf(fout, "<td align=\"%s\">%s</td>", fieldNotNum[(signed long int)field_index] != 0 ? "left" : "right", p != ((char *)NULL) ? p : "");

    else
    {
      if(!(fieldNotNum[(signed long int)field_index] == 0))
        tmp_if_expr_1 = po->standard != 0 ? " %-*s " : "%-*s";

      else
        tmp_if_expr_1 = po->standard != 0 ? " %*s " : "%*s";
      fprintf(fout, tmp_if_expr_1, fieldMax[(signed long int)field_index], p != ((char *)NULL) ? p : "");
      if(!(po->standard == 0) || !(1 + field_index >= nFields))
        fputs(po->fieldSep, fout);

    }
    if(!(p == ((char *)NULL)))
      free((void *)p);

  }
  if(!(po->html3 == 0))
    fputs("</tr>", fout);

  else
    if(!(po->standard == 0))
      fprintf(fout, "\n%s", border);

  fputc(10, fout);
}

// palloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 21
extern void * palloc(unsigned long int size)
{
  void *return_value_pg_malloc_1;
  return_value_pg_malloc_1=pg_malloc(size);
  return return_value_pg_malloc_1;
}

// palloc0
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/fe_memutils.c line 107
extern void * palloc0(unsigned long int size)
{
  void *return_value_pg_malloc0_1;
  return_value_pg_malloc0_1=pg_malloc0(size);
  return return_value_pg_malloc0_1;
}

// parseInput
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1645
static void parseInput(struct pg_conn *conn)
{
  if(conn->pversion >> 16 >= 3u)
    pqParseInput3(conn);

  else
    pqParseInput2(conn);
}

// parseQuery
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 1903
static char parseQuery(struct anonymous_22 *cmd, const char *raw_sql)
{
  char *sql;
  char *p;
  sql=pg_strdup(raw_sql);
  cmd->argc = 1;
  p = sql;
  do
  {
    p=strchr(p, 58);
    if(p == ((char *)NULL))
      break;

    char var[12l];
    char *name;
    signed int eaten;
    name=parseVariable(p, &eaten);
    if(name == ((char *)NULL))
      for( ; (signed int)*p == 58; p = p + 1l)
        ;

    else
    {
      if(cmd->argc >= 10)
      {
        fprintf(stderr, "statement has too many arguments (maximum is %d): %s\n", 10 - 1, raw_sql);
        pg_free((void *)name);
        return (char)0;
      }

      sprintf(var, "_%d", cmd->argc);
      p=replaceVariable(&sql, p, eaten, var);
      cmd->argv[(signed long int)cmd->argc] = name;
      cmd->argc = cmd->argc + 1;
    }
  }
  while((_Bool)1);
  cmd->argv[(signed long int)0] = sql;
  return (char)1;
}

// parseServiceFile
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3956
static signed int parseServiceFile(const char *serviceFile, const char *service, struct _PQconninfoOption *options, struct PQExpBufferData *errorMessage, char *group_found)
{
  signed int linenr = 0;
  signed int i;
  struct _IO_FILE *f;
  char buf[256l];
  char *line;
  f=fopen(serviceFile, "r");
  if(f == ((struct _IO_FILE *)NULL))
  {
    char *return_value_libpq_gettext_1;
    return_value_libpq_gettext_1=libpq_gettext("service file \"%s\" not found\n");
    printfPQExpBuffer(errorMessage, return_value_libpq_gettext_1, serviceFile);
    return 1;
  }

  unsigned long int return_value_strlen_5;
  unsigned long int return_value_strlen_4;
  const unsigned short int **return_value___ctype_b_loc_7;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_13;
  unsigned long int return_value_strlen_12;
  char *tmp_post_16;
  do
  {
    line=fgets(buf, (signed int)sizeof(char [256l]) /*256ul*/ , f);
    if(line == ((char *)NULL))
      break;

    linenr = linenr + 1;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(line);
    if(return_value_strlen_3 >= 255ul)
    {
      fclose(f);
      char *return_value_libpq_gettext_2;
      return_value_libpq_gettext_2=libpq_gettext("line %d too long in service file \"%s\"\n");
      printfPQExpBuffer(errorMessage, return_value_libpq_gettext_2, linenr, serviceFile);
      return 2;
    }

    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(line);
    if(!(return_value_strlen_6 == 0ul))
    {
      return_value_strlen_5=strlen(line);
      if((signed int)line[-1l + (signed long int)return_value_strlen_5] == 10)
      {
        return_value_strlen_4=strlen(line);
        line[(signed long int)(return_value_strlen_4 - (unsigned long int)1)] = (char)0;
      }

    }

    for( ; !(*line == 0); line = line + 1l)
    {
      return_value___ctype_b_loc_7=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)(unsigned char)*line]) == 0)
        break;

    }
    unsigned long int return_value_strlen_8;
    return_value_strlen_8=strlen(line);
    if(return_value_strlen_8 == 0ul)
      tmp_if_expr_9 = (_Bool)1;

    else
      tmp_if_expr_9 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_9)
    {
      if((signed int)*line == 91)
      {
        if(!(*group_found == 0))
        {
          fclose(f);
          return 0;
        }

        unsigned long int return_value_strlen_10;
        return_value_strlen_10=strlen(service);
        signed int return_value_strncmp_11;
        return_value_strncmp_11=strncmp(line + (signed long int)1, service, return_value_strlen_10);
        if(return_value_strncmp_11 == 0)
        {
          return_value_strlen_12=strlen(service);
          tmp_if_expr_13 = (signed int)line[(signed long int)(return_value_strlen_12 + (unsigned long int)1)] == 93 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_13 = (_Bool)0;
        if(tmp_if_expr_13)
          *group_found = (char)1;

        else
          *group_found = (char)0;
      }

      else
        if(!(*group_found == 0))
        {
          char *key;
          char *val;
          char found_keyword;
          signed int return_value_strncmp_14;
          return_value_strncmp_14=strncmp(line, "ldap", (unsigned long int)4);
          if(return_value_strncmp_14 == 0)
          {
            signed int rc;
            rc=ldapServiceLookup(line, options, errorMessage);
            switch(rc)
            {
              case 0:
              {
                fclose(f);
                return 0;
              }
              case 1:

              case 3:
              {
                fclose(f);
                return 3;
              }
              case 2:
                goto __CPROVER_DUMP_L26;
              default:
                ;
            }
          }

          key = line;
          val=strchr(line, 61);
          if(val == ((char *)NULL))
          {
            char *return_value_libpq_gettext_15;
            return_value_libpq_gettext_15=libpq_gettext("syntax error in service file \"%s\", line %d\n");
            printfPQExpBuffer(errorMessage, return_value_libpq_gettext_15, serviceFile, linenr);
            fclose(f);
            return 3;
          }

          tmp_post_16 = val;
          val = val + 1l;
          *tmp_post_16 = (char)0;
          found_keyword = (char)0;
          i = 0;
          for( ; !((options + (signed long int)i)->keyword == ((char *)NULL)); i = i + 1)
          {
            signed int return_value_strcmp_18;
            return_value_strcmp_18=strcmp((options + (signed long int)i)->keyword, key);
            if(return_value_strcmp_18 == 0)
            {
              if((options + (signed long int)i)->val == ((char *)NULL))
                (options + (signed long int)i)->val=strdup(val);

              if((options + (signed long int)i)->val == ((char *)NULL))
              {
                char *return_value_libpq_gettext_17;
                return_value_libpq_gettext_17=libpq_gettext("out of memory\n");
                printfPQExpBuffer(errorMessage, return_value_libpq_gettext_17);
                fclose(f);
                return 3;
              }

              found_keyword = (char)1;
              break;
            }

          }
          if(found_keyword == 0)
          {
            char *return_value_libpq_gettext_19;
            return_value_libpq_gettext_19=libpq_gettext("syntax error in service file \"%s\", line %d\n");
            printfPQExpBuffer(errorMessage, return_value_libpq_gettext_19, serviceFile, linenr);
            fclose(f);
            return 3;
          }

        }

    }


  __CPROVER_DUMP_L26:
    ;
  }
  while((_Bool)1);
  fclose(f);
  return 0;
}

// parseServiceInfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 3887
static signed int parseServiceInfo(struct _PQconninfoOption *options, struct PQExpBufferData *errorMessage)
{
  const char *service;
  service=conninfo_getval(options, "service");
  char serviceFile[1024l];
  char *env;
  char group_found = (char)0;
  signed int status;
  struct stat stat_buf;
  if(service == ((const char *)NULL))
    service=getenv("PGSERVICE");

  signed int *return_value___errno_location_4;
  char *tmp_if_expr_8;
  char *return_value_getenv_7;
  signed int *return_value___errno_location_10;
  if(service == ((const char *)NULL))
    return 0;

  else
  {
    env=getenv("PGSERVICEFILE");
    if(!(env == ((char *)NULL)))
      strlcpy(serviceFile, env, sizeof(char [1024l]) /*1024ul*/ );

    else
    {
      char homedir[1024l];
      char return_value_pqGetHomeDirectory_2;
      return_value_pqGetHomeDirectory_2=pqGetHomeDirectory(homedir, (signed int)sizeof(char [1024l]) /*1024ul*/ );
      if(return_value_pqGetHomeDirectory_2 == 0)
      {
        char *return_value_libpq_gettext_1;
        return_value_libpq_gettext_1=libpq_gettext("could not get home directory to locate service definition file");
        printfPQExpBuffer(errorMessage, return_value_libpq_gettext_1);
        return 1;
      }

      snprintf(serviceFile, (unsigned long int)1024, "%s/%s", (const void *)homedir, (const void *)".pg_service.conf");
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 0;
      signed int return_value_stat_5;
      return_value_stat_5=stat(serviceFile, &stat_buf);
      if(!(return_value_stat_5 == 0))
      {
        return_value___errno_location_4=__errno_location();
        if(*return_value___errno_location_4 == 2)
          goto next_file;

      }

    }
    status=parseServiceFile(serviceFile, service, options, errorMessage, &group_found);
    if(!(status == 0) || !(group_found == 0))
      return status;

    else
    {

    next_file:
      ;
      char *return_value_getenv_6;
      return_value_getenv_6=getenv("PGSYSCONFDIR");
      if(!(return_value_getenv_6 == ((char *)NULL)))
      {
        return_value_getenv_7=getenv("PGSYSCONFDIR");
        tmp_if_expr_8 = return_value_getenv_7;
      }

      else
        tmp_if_expr_8 = "/etc/postgresql-common";
      snprintf(serviceFile, (unsigned long int)1024, "%s/pg_service.conf", tmp_if_expr_8);
      signed int *return_value___errno_location_9;
      return_value___errno_location_9=__errno_location();
      *return_value___errno_location_9 = 0;
      signed int return_value_stat_11;
      return_value_stat_11=stat(serviceFile, &stat_buf);
      if(!(return_value_stat_11 == 0))
      {
        return_value___errno_location_10=__errno_location();
        if(*return_value___errno_location_10 == 2)
          goto last_file;

      }

      status=parseServiceFile(serviceFile, service, options, errorMessage, &group_found);
      if(!(status == 0))
        return status;

      else
      {

      last_file:
        ;
        if(group_found == 0)
        {
          char *return_value_libpq_gettext_12;
          return_value_libpq_gettext_12=libpq_gettext("definition of service \"%s\" not found\n");
          printfPQExpBuffer(errorMessage, return_value_libpq_gettext_12, service);
          return 3;
        }

        return 0;
      }
    }
  }
}

// parseVariable
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 702
static char * parseVariable(const char *sql, signed int *eaten)
{
  signed int i = 0;
  char *name;
  const unsigned short int **return_value___ctype_b_loc_1;
  _Bool tmp_if_expr_2;
  do
  {
    i = i + 1;
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if(!((8 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)sql[(signed long int)i]]) == 0))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)sql[(signed long int)i] == 95 ? (_Bool)1 : (_Bool)0;
  }
  while(tmp_if_expr_2);
  if(i == 1)
    return (char *)(void *)0;

  else
  {
    void *return_value_pg_malloc_3;
    return_value_pg_malloc_3=pg_malloc((unsigned long int)i);
    name = (char *)return_value_pg_malloc_3;
    memcpy((void *)name, (const void *)&sql[(signed long int)1], (unsigned long int)(i - 1));
    name[(signed long int)(i - 1)] = (char)0;
    *eaten = i;
    return name;
  }
}

// parse_connection_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4183
static struct _PQconninfoOption * parse_connection_string(const char *connstr, struct PQExpBufferData *errorMessage, char use_defaults)
{
  signed int return_value_uri_prefix_length_2;
  return_value_uri_prefix_length_2=uri_prefix_length(connstr);
  struct _PQconninfoOption *return_value_conninfo_uri_parse_1;
  if(!(return_value_uri_prefix_length_2 == 0))
  {
    return_value_conninfo_uri_parse_1=conninfo_uri_parse(connstr, errorMessage, use_defaults);
    return return_value_conninfo_uri_parse_1;
  }

  else
  {
    struct _PQconninfoOption *return_value_conninfo_parse_3;
    return_value_conninfo_parse_3=conninfo_parse(connstr, errorMessage, use_defaults);
    return return_value_conninfo_parse_3;
  }
}

// path_contains_parent_reference
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 342
extern char path_contains_parent_reference(const char *path)
{
  signed int path_len;
  path = path;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(path);
  path_len = (signed int)return_value_strlen_1;
  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(path, "..");
  _Bool tmp_if_expr_4;
  signed int return_value_strncmp_3;
  if(return_value_strcmp_2 == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_strncmp_3=strncmp(path, "../", (unsigned long int)3);
    tmp_if_expr_4 = return_value_strncmp_3 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_6;
  char *return_value_strstr_5;
  if(tmp_if_expr_4)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_strstr_5=strstr(path, "/../");
    tmp_if_expr_6 = return_value_strstr_5 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  signed int return_value_strcmp_7;
  if(tmp_if_expr_6)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    if(path_len >= 3)
    {
      return_value_strcmp_7=strcmp((path + (signed long int)path_len) - (signed long int)3, "/..");
      tmp_if_expr_8 = return_value_strcmp_7 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_9)
    return (char)1;

  else
    return (char)0;
}

// path_is_prefix_of_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 404
extern char path_is_prefix_of_path(const char *path1, const char *path2)
{
  signed int path1_len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(path1);
  path1_len = (signed int)return_value_strlen_1;
  signed int return_value_strncmp_3;
  return_value_strncmp_3=strncmp(path1, path2, (unsigned long int)path1_len);
  _Bool tmp_if_expr_2;
  if(return_value_strncmp_3 == 0)
  {
    if((signed int)path2[(signed long int)path1_len] == 47)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)path2[(signed long int)path1_len] == 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
      goto __CPROVER_DUMP_L3;

    return (char)1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    return (char)0;
  }
}

// path_is_relative_and_below_cwd
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 371
extern char path_is_relative_and_below_cwd(const char *path)
{
  char return_value_path_contains_parent_reference_1;
  if((signed int)*path == 47)
    return (char)0;

  else
  {
    return_value_path_contains_parent_reference_1=path_contains_parent_reference(path);
    if(!(return_value_path_contains_parent_reference_1 == 0))
      return (char)0;

    else
      return (char)1;
  }
}

// pclose_check
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 510
extern signed int pclose_check(struct _IO_FILE *stream)
{
  signed int exitstatus;
  char *reason;
  exitstatus=pclose(stream);
  if(exitstatus == 0)
    return 0;

  else
  {
    if(exitstatus == -1)
    {
      char *return_value_gettext_1;
      return_value_gettext_1=gettext("pclose failed: %s");
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      fprintf(stderr, return_value_gettext_1, return_value_strerror_3);
      fputc(10, stderr);
    }

    else
    {
      reason=wait_result_to_str(exitstatus);
      fprintf(stderr, "%s", reason);
      fputc(10, stderr);
      free((void *)reason);
    }
    return exitstatus;
  }
}

// pfree
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 24
extern void pfree(void *pointer)
{
  pg_free(pointer);
}

// pg_GSS_continue
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 102
static signed int pg_GSS_continue(struct pg_conn *conn)
{
  unsigned int maj_stat;
  unsigned int min_stat;
  unsigned int lmin_s;
  struct gss_buffer_desc_struct *tmp_if_expr_1;
  if(conn->gctx == ((struct gss_ctx_id_struct *)NULL))
    tmp_if_expr_1 = (struct gss_buffer_desc_struct *)0;

  else
    tmp_if_expr_1 = &conn->ginbuf;
  maj_stat=gss_init_sec_context(&min_stat, (struct gss_cred_id_struct *)0, &conn->gctx, conn->gtarg_nam, (struct gss_OID_desc_struct *)0, (unsigned int)2, (unsigned int)0, (struct gss_channel_bindings_struct *)0, tmp_if_expr_1, (struct gss_OID_desc_struct **)(void *)0, &conn->goutbuf, (unsigned int *)(void *)0, (unsigned int *)(void *)0);
  if(!(conn->gctx == ((struct gss_ctx_id_struct *)NULL)))
  {
    free(conn->ginbuf.value);
    conn->ginbuf.value = (void *)0;
    conn->ginbuf.length = (unsigned long int)0;
  }

  if(!(conn->goutbuf.length == 0ul))
  {
    signed int return_value_pqPacketSend_2;
    return_value_pqPacketSend_2=pqPacketSend(conn, (char)112, conn->goutbuf.value, conn->goutbuf.length);
    if(!(return_value_pqPacketSend_2 == 0))
    {
      gss_release_buffer(&lmin_s, &conn->goutbuf);
      return -1;
    }

  }

  gss_release_buffer(&lmin_s, &conn->goutbuf);
  if(!(maj_stat == 0u) && !(maj_stat == 1u))
  {
    char *return_value_libpq_gettext_3;
    return_value_libpq_gettext_3=libpq_gettext("GSSAPI continuation error");
    pg_GSS_error(return_value_libpq_gettext_3, conn, maj_stat, min_stat);
    gss_release_name(&lmin_s, &conn->gtarg_nam);
    if(!(conn->gctx == ((struct gss_ctx_id_struct *)NULL)))
      gss_delete_sec_context(&lmin_s, &conn->gctx, (struct gss_buffer_desc_struct *)0);

    return -1;
  }

  if(maj_stat == 0u)
    gss_release_name(&lmin_s, &conn->gtarg_nam);

  return 0;
}

// pg_GSS_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 86
static void pg_GSS_error(const char *mprefix, struct pg_conn *conn, unsigned int maj_stat, unsigned int min_stat)
{
  resetPQExpBuffer(&conn->errorMessage);
  pg_GSS_error_int(&conn->errorMessage, mprefix, maj_stat, 1);
  pg_GSS_error_int(&conn->errorMessage, mprefix, min_stat, 2);
}

// pg_GSS_error_int
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 66
static void pg_GSS_error_int(struct PQExpBufferData *str, const char *mprefix, unsigned int stat, signed int type)
{
  unsigned int lmin_s;
  struct gss_buffer_desc_struct lmsg;
  unsigned int msg_ctx = (unsigned int)0;
  do
  {
    gss_display_status(&lmin_s, stat, type, (struct gss_OID_desc_struct *)0, &msg_ctx, &lmsg);
    appendPQExpBuffer(str, "%s: %s\n", mprefix, (char *)lmsg.value);
    gss_release_buffer(&lmin_s, &lmsg);
  }
  while(!(msg_ctx == 0u));
}

// pg_GSS_startup
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 167
static signed int pg_GSS_startup(struct pg_conn *conn)
{
  unsigned int maj_stat;
  unsigned int min_stat;
  signed int maxlen;
  struct gss_buffer_desc_struct temp_gbuf;
  _Bool tmp_if_expr_2;
  if(!(conn->pghost == ((char *)NULL)))
    tmp_if_expr_2 = (signed int)conn->pghost[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(!tmp_if_expr_2)
  {
    char *return_value_libpq_gettext_1;
    return_value_libpq_gettext_1=libpq_gettext("host name must be specified\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
    return -1;
  }

  if(!(conn->gctx == ((struct gss_ctx_id_struct *)NULL)))
  {
    char *return_value_libpq_gettext_3;
    return_value_libpq_gettext_3=libpq_gettext("duplicate GSS authentication request\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
    return -1;
  }

  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(conn->krbsrvname);
  maxlen = (signed int)((unsigned long int)1025 + return_value_strlen_4 + (unsigned long int)2);
  void *return_value_malloc_5;
  return_value_malloc_5=malloc((unsigned long int)maxlen);
  temp_gbuf.value = (void *)(char *)return_value_malloc_5;
  if(temp_gbuf.value == NULL)
  {
    char *return_value_libpq_gettext_6;
    return_value_libpq_gettext_6=libpq_gettext("out of memory\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_6);
    return -1;
  }

  snprintf((char *)temp_gbuf.value, (unsigned long int)maxlen, "%s@%s", conn->krbsrvname, conn->pghost);
  temp_gbuf.length=strlen((const char *)temp_gbuf.value);
  maj_stat=gss_import_name(&min_stat, &temp_gbuf, GSS_C_NT_HOSTBASED_SERVICE, &conn->gtarg_nam);
  free(temp_gbuf.value);
  if(!(maj_stat == 0u))
  {
    char *return_value_libpq_gettext_7;
    return_value_libpq_gettext_7=libpq_gettext("GSSAPI name import error");
    pg_GSS_error(return_value_libpq_gettext_7, conn, maj_stat, min_stat);
    return -1;
  }

  conn->gctx = (struct gss_ctx_id_struct *)0;
  signed int return_value_pg_GSS_continue_8;
  return_value_pg_GSS_continue_8=pg_GSS_continue(conn);
  return return_value_pg_GSS_continue_8;
}

// pg_ascii2wchar_with_len
// file wchar.c line 40
static signed int pg_ascii2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len)
{
  signed int cnt = 0;
  unsigned int *tmp_post_1;
  const unsigned char *tmp_post_2;
  for( ; len >= 1; cnt = cnt + 1)
  {
    if(*from == 0)
      break;

    tmp_post_1 = to;
    to = to + 1l;
    tmp_post_2 = from;
    from = from + 1l;
    *tmp_post_1 = (unsigned int)*tmp_post_2;
    len = len - 1;
  }
  *to = (unsigned int)0;
  return cnt;
}

// pg_ascii_dsplen
// file wchar.c line 61
static signed int pg_ascii_dsplen(const unsigned char *s)
{
  _Bool tmp_if_expr_1;
  if((signed int)*s == 0)
    return 0;

  else
  {
    if(!((signed int)*s >= 0x20))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)*s == 0x7f ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return -1;

    else
      return 1;
  }
}

// pg_ascii_mblen
// file wchar.c line 55
static signed int pg_ascii_mblen(const unsigned char *s)
{
  return 1;
}

// pg_ascii_tolower
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgstrcasecmp.c line 146
extern unsigned char pg_ascii_tolower(unsigned char ch)
{
  if((signed int)ch >= 65 && !((signed int)ch >= 91))
    ch = ch + (unsigned char)(97 - 65);

  return ch;
}

// pg_ascii_toupper
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgstrcasecmp.c line 135
extern unsigned char pg_ascii_toupper(unsigned char ch)
{
  if((signed int)ch >= 97 && !((signed int)ch >= 123))
    ch = ch + (unsigned char)(65 - 97);

  return ch;
}

// pg_ascii_verifier
// file wchar.c line 1125
static signed int pg_ascii_verifier(const unsigned char *s, signed int len)
{
  return 1;
}

// pg_big5_dsplen
// file wchar.c line 1007
static signed int pg_big5_dsplen(const unsigned char *s)
{
  signed int len;
  if(!((0x80 & (signed int)*s) == 0))
    len = 2;

  else
    len=pg_ascii_dsplen(s);
  return len;
}

// pg_big5_mblen
// file wchar.c line 995
static signed int pg_big5_mblen(const unsigned char *s)
{
  signed int len;
  if(!((0x80 & (signed int)*s) == 0))
    len = 2;

  else
    len = 1;
  return len;
}

// pg_big5_verifier
// file wchar.c line 1344
static signed int pg_big5_verifier(const unsigned char *s, signed int len)
{
  signed int l;
  signed int mbl;
  mbl=pg_big5_mblen(s);
  l = mbl;
  if(!(len >= l))
    return -1;

  else
  {
    do
    {
      l = l - 1;
      if(!(l >= 1))
        break;

      s = s + 1l;
      if((signed int)*s == 0)
        return -1;

    }
    while((_Bool)1);
    return mbl;
  }
}

// pg_char_to_encoding
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 579
extern signed int pg_char_to_encoding(const char *name)
{
  unsigned int nel = (unsigned int)(sizeof(const struct pg_encname [81l]) /*1296ul*/  / sizeof(const struct pg_encname) /*16ul*/ );
  const struct pg_encname *base = pg_encname_tbl;
  const struct pg_encname *last = (base + (signed long int)nel) - (signed long int)1;
  const struct pg_encname *position;
  signed int result;
  char buff[64l];
  char *key;
  _Bool tmp_if_expr_1;
  if(name == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*name == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return -1;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(name);
    if(return_value_strlen_2 >= 64ul)
    {
      fprintf(stderr, "encoding name too long\n");
      return -1;
    }

    else
    {
      key=clean_encoding_name(name, buff);
      while(last >= base)
      {
        position = base + (last - base >> 1);
        result = (signed int)key[(signed long int)0] - (signed int)position->name[(signed long int)0];
        if(result == 0)
        {
          result=strcmp(key, position->name);
          if(result == 0)
            return (signed int)position->encoding;

        }

        if(!(result >= 0))
          last = position - (signed long int)1;

        else
          base = position + (signed long int)1;
      }
      return -1;
    }
  }
}

// pg_check_dir
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgcheckdir.c line 31
extern signed int pg_check_dir(const char *dir)
{
  signed int result = 1;
  struct __dirstream *chkdir;
  struct dirent *file;
  char dot_found = (char)0;
  char mount_found = (char)0;
  signed int readdir_errno;
  chkdir=opendir(dir);
  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_2;
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_3;
  signed int *return_value___errno_location_9;
  if(chkdir == ((struct __dirstream *)NULL))
  {
    return_value___errno_location_1=__errno_location();
    return *return_value___errno_location_1 == 2 ? 0 : -1;
  }

  else
  {
    do
    {
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 0;
      file=readdir(chkdir);
      if(file == ((struct dirent *)NULL))
        break;

      signed int return_value_strcmp_4;
      return_value_strcmp_4=strcmp(".", file->d_name);
      if(return_value_strcmp_4 == 0)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_strcmp_5=strcmp("..", file->d_name);
        tmp_if_expr_6 = return_value_strcmp_5 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        continue;

      else
        if((signed int)file->d_name[0l] == 46)
          dot_found = (char)1;

        else
        {
          return_value_strcmp_3=strcmp("lost+found", file->d_name);
          if(return_value_strcmp_3 == 0)
            mount_found = (char)1;

          else
          {
            result = 4;
            break;
          }
        }
    }
    while((_Bool)1);
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    if(!(*return_value___errno_location_7 == 0))
      result = -1;

    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    readdir_errno = *return_value___errno_location_8;
    signed int return_value_closedir_10;
    return_value_closedir_10=closedir(chkdir);
    if(!(return_value_closedir_10 == 0))
      result = -1;

    else
    {
      return_value___errno_location_9=__errno_location();
      *return_value___errno_location_9 = readdir_errno;
    }
    if(result == 1 && !(mount_found == 0))
      result = 3;

    if(result == 1 && !(dot_found == 0))
      result = 2;

    return result;
  }
}

// pg_encoding_dsplen
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/mb/pg_wchar.h line 449
extern signed int pg_encoding_dsplen(signed int encoding, const char *mbstr)
{
  signed int tmp_if_expr_1;
  signed int return_value;
  signed int return_value_1;
  if(encoding >= 0 && !(encoding >= _PG_LAST_ENCODING_))
  {
    return_value=pg_wchar_table[(signed long int)encoding].dsplen((const unsigned char *)mbstr);
    tmp_if_expr_1 = return_value;
  }

  else
  {
    return_value_1=pg_wchar_table[(signed long int)PG_SQL_ASCII].dsplen((const unsigned char *)mbstr);
    tmp_if_expr_1 = return_value_1;
  }
  return tmp_if_expr_1;
}

// pg_encoding_max_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/mb/pg_wchar.h line 459
extern signed int pg_encoding_max_length(signed int encoding)
{
  return pg_wchar_table[(signed long int)encoding].maxmblen;
}

// pg_encoding_mblen
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/mb/pg_wchar.h line 448
extern signed int pg_encoding_mblen(signed int encoding, const char *mbstr)
{
  signed int tmp_if_expr_1;
  signed int return_value;
  signed int return_value_1;
  if(encoding >= 0 && !(encoding >= _PG_LAST_ENCODING_))
  {
    return_value=pg_wchar_table[(signed long int)encoding].mblen((const unsigned char *)mbstr);
    tmp_if_expr_1 = return_value;
  }

  else
  {
    return_value_1=pg_wchar_table[(signed long int)PG_SQL_ASCII].mblen((const unsigned char *)mbstr);
    tmp_if_expr_1 = return_value_1;
  }
  return tmp_if_expr_1;
}

// pg_encoding_to_char
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-fe.h line 580
extern const char * pg_encoding_to_char(signed int encoding)
{
  if(encoding >= 0 && !(encoding >= _PG_LAST_ENCODING_))
  {
    const struct pg_enc2name *p = &pg_enc2name_tbl[(signed long int)encoding];
    return p->name;
  }

  return "";
}

// pg_encoding_verifymb
// file wchar.c line 1803
extern signed int pg_encoding_verifymb(signed int encoding, const char *mbstr, signed int len)
{
  signed int tmp_if_expr_1;
  signed int return_value;
  signed int return_value_1;
  if(encoding >= 0 && !(encoding >= _PG_LAST_ENCODING_))
  {
    return_value=pg_wchar_table[(signed long int)encoding].mbverify((const unsigned char *)mbstr, len);
    tmp_if_expr_1 = return_value;
  }

  else
  {
    return_value_1=pg_wchar_table[(signed long int)PG_SQL_ASCII].mbverify((const unsigned char *)mbstr, len);
    tmp_if_expr_1 = return_value_1;
  }
  return tmp_if_expr_1;
}

// pg_erand48
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 372
extern double pg_erand48(unsigned short int *xseed)
{
  _dorand48(xseed);
  double return_value_ldexp_1;
  return_value_ldexp_1=ldexp((double)xseed[(signed long int)0], -48);
  double return_value_ldexp_2;
  return_value_ldexp_2=ldexp((double)xseed[(signed long int)1], -32);
  double return_value_ldexp_3;
  return_value_ldexp_3=ldexp((double)xseed[(signed long int)2], -16);
  return return_value_ldexp_1 + return_value_ldexp_2 + return_value_ldexp_3;
}

// pg_euc2wchar_with_len
// file wchar.c line 75
static signed int pg_euc2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len)
{
  signed int cnt = 0;
  const unsigned char *tmp_post_1;
  const unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  const unsigned char *tmp_post_4;
  const unsigned char *tmp_post_5;
  const unsigned char *tmp_post_6;
  for( ; len >= 1; cnt = cnt + 1)
  {
    if(*from == 0)
      break;

    if((signed int)*from == 0x8e && len >= 2)
    {
      from = from + 1l;
      tmp_post_1 = from;
      from = from + 1l;
      *to = (unsigned int)(0x8e << 8 | (signed int)*tmp_post_1);
      len = len - 2;
    }

    else
      if((signed int)*from == 0x8f && len >= 3)
      {
        from = from + 1l;
        tmp_post_2 = from;
        from = from + 1l;
        *to = (unsigned int)(0x8f << 16 | (signed int)*tmp_post_2 << 8);
        tmp_post_3 = from;
        from = from + 1l;
        *to = *to | (unsigned int)*tmp_post_3;
        len = len - 3;
      }

      else
        if(len >= 2 && !((0x80 & (signed int)*from) == 0))
        {
          tmp_post_4 = from;
          from = from + 1l;
          *to = (unsigned int)((signed int)*tmp_post_4 << 8);
          tmp_post_5 = from;
          from = from + 1l;
          *to = *to | (unsigned int)*tmp_post_5;
          len = len - 2;
        }

        else
        {
          tmp_post_6 = from;
          from = from + 1l;
          *to = (unsigned int)*tmp_post_6;
          len = len - 1;
        }
    to = to + 1l;
  }
  *to = (unsigned int)0;
  return cnt;
}

// pg_euc_dsplen
// file wchar.c line 130
static inline signed int pg_euc_dsplen(const unsigned char *s)
{
  signed int len;
  if((signed int)*s == 0x8e)
    len = 2;

  else
    if((signed int)*s == 0x8f)
      len = 2;

    else
      if(!((0x80 & (signed int)*s) == 0))
        len = 2;

      else
        len=pg_ascii_dsplen(s);
  return len;
}

// pg_euc_mblen
// file wchar.c line 114
static inline signed int pg_euc_mblen(const unsigned char *s)
{
  signed int len;
  if((signed int)*s == 0x8e)
    len = 2;

  else
    if((signed int)*s == 0x8f)
      len = 3;

    else
      if(!((0x80 & (signed int)*s) == 0))
        len = 2;

      else
        len = 1;
  return len;
}

// pg_euccn2wchar_with_len
// file wchar.c line 202
static signed int pg_euccn2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len)
{
  signed int cnt = 0;
  const unsigned char *tmp_post_1;
  const unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  const unsigned char *tmp_post_4;
  const unsigned char *tmp_post_5;
  const unsigned char *tmp_post_6;
  const unsigned char *tmp_post_7;
  for( ; len >= 1; cnt = cnt + 1)
  {
    if(*from == 0)
      break;

    if((signed int)*from == 0x8e && len >= 3)
    {
      from = from + 1l;
      tmp_post_1 = from;
      from = from + 1l;
      *to = (unsigned int)(0x8e << 16 | (signed int)*tmp_post_1 << 8);
      tmp_post_2 = from;
      from = from + 1l;
      *to = *to | (unsigned int)*tmp_post_2;
      len = len - 3;
    }

    else
      if((signed int)*from == 0x8f && len >= 3)
      {
        from = from + 1l;
        tmp_post_3 = from;
        from = from + 1l;
        *to = (unsigned int)(0x8f << 16 | (signed int)*tmp_post_3 << 8);
        tmp_post_4 = from;
        from = from + 1l;
        *to = *to | (unsigned int)*tmp_post_4;
        len = len - 3;
      }

      else
        if(len >= 2 && !((0x80 & (signed int)*from) == 0))
        {
          tmp_post_5 = from;
          from = from + 1l;
          *to = (unsigned int)((signed int)*tmp_post_5 << 8);
          tmp_post_6 = from;
          from = from + 1l;
          *to = *to | (unsigned int)*tmp_post_6;
          len = len - 2;
        }

        else
        {
          tmp_post_7 = from;
          from = from + 1l;
          *to = (unsigned int)*tmp_post_7;
          len = len - 1;
        }
    to = to + 1l;
  }
  *to = (unsigned int)0;
  return cnt;
}

// pg_euccn_dsplen
// file wchar.c line 253
static signed int pg_euccn_dsplen(const unsigned char *s)
{
  signed int len;
  if(!((0x80 & (signed int)*s) == 0))
    len = 2;

  else
    len=pg_ascii_dsplen(s);
  return len;
}

// pg_euccn_mblen
// file wchar.c line 241
static signed int pg_euccn_mblen(const unsigned char *s)
{
  signed int len;
  if(!((0x80 & (signed int)*s) == 0))
    len = 2;

  else
    len = 1;
  return len;
}

// pg_eucjp2wchar_with_len
// file wchar.c line 149
static signed int pg_eucjp2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len)
{
  signed int return_value_pg_euc2wchar_with_len_1;
  return_value_pg_euc2wchar_with_len_1=pg_euc2wchar_with_len(from, to, len);
  return return_value_pg_euc2wchar_with_len_1;
}

// pg_eucjp_dsplen
// file wchar.c line 161
static signed int pg_eucjp_dsplen(const unsigned char *s)
{
  signed int len;
  if((signed int)*s == 0x8e)
    len = 1;

  else
    if((signed int)*s == 0x8f)
      len = 2;

    else
      if(!((0x80 & (signed int)*s) == 0))
        len = 2;

      else
        len=pg_ascii_dsplen(s);
  return len;
}

// pg_eucjp_mblen
// file wchar.c line 155
static signed int pg_eucjp_mblen(const unsigned char *s)
{
  signed int return_value_pg_euc_mblen_1;
  return_value_pg_euc_mblen_1=pg_euc_mblen(s);
  return return_value_pg_euc_mblen_1;
}

// pg_eucjp_verifier
// file wchar.c line 1133
static signed int pg_eucjp_verifier(const unsigned char *s, signed int len)
{
  signed int l;
  unsigned char c1;
  unsigned char c2;
  const unsigned char *tmp_post_1 = s;
  s = s + 1l;
  c1 = *tmp_post_1;
  const unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  const unsigned char *tmp_post_4;
  const unsigned char *tmp_post_5;
  switch((signed int)c1)
  {
    case 0x8e:
    {
      l = 2;
      if(!(len >= l))
        return -1;

      tmp_post_2 = s;
      s = s + 1l;
      c2 = *tmp_post_2;
      if((signed int)c2 >= 224 || !((signed int)c2 >= 0xa1))
        return -1;

      break;
    }
    case 0x8f:
    {
      l = 3;
      if(!(len >= l))
        return -1;

      tmp_post_3 = s;
      s = s + 1l;
      c2 = *tmp_post_3;
      if(!((signed int)c2 >= 0xa1) || (signed int)c2 >= 255)
        return -1;

      tmp_post_4 = s;
      s = s + 1l;
      c2 = *tmp_post_4;
      if(!((signed int)c2 >= 0xa1) || (signed int)c2 >= 255)
        return -1;

      break;
    }
    default:
      if(!((0x80 & (signed int)c1) == 0))
      {
        l = 2;
        if(!(len >= l))
          return -1;

        if(!((signed int)c1 >= 0xa1) || (signed int)c1 >= 255)
          return -1;

        tmp_post_5 = s;
        s = s + 1l;
        c2 = *tmp_post_5;
        if(!((signed int)c2 >= 0xa1) || (signed int)c2 >= 255)
          return -1;

      }

      else
        l = 1;
  }
  return l;
}

// pg_euckr2wchar_with_len
// file wchar.c line 180
static signed int pg_euckr2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len)
{
  signed int return_value_pg_euc2wchar_with_len_1;
  return_value_pg_euc2wchar_with_len_1=pg_euc2wchar_with_len(from, to, len);
  return return_value_pg_euc2wchar_with_len_1;
}

// pg_euckr_dsplen
// file wchar.c line 192
static signed int pg_euckr_dsplen(const unsigned char *s)
{
  signed int return_value_pg_euc_dsplen_1;
  return_value_pg_euc_dsplen_1=pg_euc_dsplen(s);
  return return_value_pg_euc_dsplen_1;
}

// pg_euckr_mblen
// file wchar.c line 186
static signed int pg_euckr_mblen(const unsigned char *s)
{
  signed int return_value_pg_euc_mblen_1;
  return_value_pg_euc_mblen_1=pg_euc_mblen(s);
  return return_value_pg_euc_mblen_1;
}

// pg_euckr_verifier
// file wchar.c line 1188
static signed int pg_euckr_verifier(const unsigned char *s, signed int len)
{
  signed int l;
  unsigned char c1;
  unsigned char c2;
  const unsigned char *tmp_post_1 = s;
  s = s + 1l;
  c1 = *tmp_post_1;
  const unsigned char *tmp_post_2;
  if(!((0x80 & (signed int)c1) == 0))
  {
    l = 2;
    if(!(len >= l))
      return -1;

    if(!((signed int)c1 >= 0xa1) || (signed int)c1 >= 255)
      return -1;

    tmp_post_2 = s;
    s = s + 1l;
    c2 = *tmp_post_2;
    if(!((signed int)c2 >= 0xa1) || (signed int)c2 >= 255)
      return -1;

  }

  else
    l = 1;
  return l;
}

// pg_euctw2wchar_with_len
// file wchar.c line 269
static signed int pg_euctw2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len)
{
  signed int cnt = 0;
  const unsigned char *tmp_post_1;
  const unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  const unsigned char *tmp_post_4;
  const unsigned char *tmp_post_5;
  const unsigned char *tmp_post_6;
  const unsigned char *tmp_post_7;
  const unsigned char *tmp_post_8;
  for( ; len >= 1; cnt = cnt + 1)
  {
    if(*from == 0)
      break;

    if((signed int)*from == 0x8e && len >= 4)
    {
      from = from + 1l;
      tmp_post_1 = from;
      from = from + 1l;
      *to = (unsigned int)0x8e << 24 | (unsigned int)((signed int)*tmp_post_1 << 16);
      tmp_post_2 = from;
      from = from + 1l;
      *to = *to | (unsigned int)((signed int)*tmp_post_2 << 8);
      tmp_post_3 = from;
      from = from + 1l;
      *to = *to | (unsigned int)*tmp_post_3;
      len = len - 4;
    }

    else
      if((signed int)*from == 0x8f && len >= 3)
      {
        from = from + 1l;
        tmp_post_4 = from;
        from = from + 1l;
        *to = (unsigned int)(0x8f << 16 | (signed int)*tmp_post_4 << 8);
        tmp_post_5 = from;
        from = from + 1l;
        *to = *to | (unsigned int)*tmp_post_5;
        len = len - 3;
      }

      else
        if(len >= 2 && !((0x80 & (signed int)*from) == 0))
        {
          tmp_post_6 = from;
          from = from + 1l;
          *to = (unsigned int)((signed int)*tmp_post_6 << 8);
          tmp_post_7 = from;
          from = from + 1l;
          *to = *to | (unsigned int)*tmp_post_7;
          len = len - 2;
        }

        else
        {
          tmp_post_8 = from;
          from = from + 1l;
          *to = (unsigned int)*tmp_post_8;
          len = len - 1;
        }
    to = to + 1l;
  }
  *to = (unsigned int)0;
  return cnt;
}

// pg_euctw_dsplen
// file wchar.c line 325
static signed int pg_euctw_dsplen(const unsigned char *s)
{
  signed int len;
  if((signed int)*s == 0x8e)
    len = 2;

  else
    if((signed int)*s == 0x8f)
      len = 2;

    else
      if(!((0x80 & (signed int)*s) == 0))
        len = 2;

      else
        len=pg_ascii_dsplen(s);
  return len;
}

// pg_euctw_mblen
// file wchar.c line 309
static signed int pg_euctw_mblen(const unsigned char *s)
{
  signed int len;
  if((signed int)*s == 0x8e)
    len = 4;

  else
    if((signed int)*s == 0x8f)
      len = 3;

    else
      if(!((0x80 & (signed int)*s) == 0))
        len = 2;

      else
        len = 1;
  return len;
}

// pg_euctw_verifier
// file wchar.c line 1220
static signed int pg_euctw_verifier(const unsigned char *s, signed int len)
{
  signed int l;
  unsigned char c1;
  unsigned char c2;
  const unsigned char *tmp_post_1 = s;
  s = s + 1l;
  c1 = *tmp_post_1;
  const unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  const unsigned char *tmp_post_4;
  const unsigned char *tmp_post_5;
  switch((signed int)c1)
  {
    case 0x8e:
    {
      l = 4;
      if(!(len >= l))
        return -1;

      tmp_post_2 = s;
      s = s + 1l;
      c2 = *tmp_post_2;
      if((signed int)c2 >= 168 || !((signed int)c2 >= 0xa1))
        return -1;

      tmp_post_3 = s;
      s = s + 1l;
      c2 = *tmp_post_3;
      if(!((signed int)c2 >= 0xa1) || (signed int)c2 >= 255)
        return -1;

      tmp_post_4 = s;
      s = s + 1l;
      c2 = *tmp_post_4;
      if(!((signed int)c2 >= 0xa1) || (signed int)c2 >= 255)
        return -1;

      break;
    }
    case 0x8f:
      return -1;
    default:
      if(!((0x80 & (signed int)c1) == 0))
      {
        l = 2;
        if(!(len >= l))
          return -1;

        tmp_post_5 = s;
        s = s + 1l;
        c2 = *tmp_post_5;
        if(!((signed int)c2 >= 0xa1) || (signed int)c2 >= 255)
          return -1;

      }

      else
        l = 1;
  }
  return l;
}

// pg_fe_getauthname
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 722
extern char * pg_fe_getauthname(struct PQExpBufferData *errorMessage)
{
  char *result = (char *)(void *)0;
  const char *name = (const char *)(void *)0;
  unsigned int user_id;
  user_id=geteuid();
  char pwdbuf[8192l];
  struct passwd pwdstr;
  struct passwd *pw = (struct passwd *)(void *)0;
  signed int pwerr;
  pg_g_threadlock((signed int)(char)1);
  pwerr=pqGetpwuid(user_id, &pwdstr, pwdbuf, sizeof(char [8192l]) /*8192ul*/ , &pw);
  char *return_value_libpq_gettext_1;
  char *return_value_pqStrerror_2;
  char *return_value_libpq_gettext_3;
  if(!(pw == ((struct passwd *)NULL)))
    name = pw->pw_name;

  else
    if(!(errorMessage == ((struct PQExpBufferData *)NULL)))
    {
      if(!(pwerr == 0))
      {
        return_value_libpq_gettext_1=libpq_gettext("could not look up local user ID %d: %s\n");
        return_value_pqStrerror_2=pqStrerror(pwerr, pwdbuf, sizeof(char [8192l]) /*8192ul*/ );
        printfPQExpBuffer(errorMessage, return_value_libpq_gettext_1, (signed int)user_id, return_value_pqStrerror_2);
      }

      else
      {
        return_value_libpq_gettext_3=libpq_gettext("local user with ID %d does not exist\n");
        printfPQExpBuffer(errorMessage, return_value_libpq_gettext_3, (signed int)user_id);
      }
    }

  char *return_value_libpq_gettext_4;
  if(!(name == ((const char *)NULL)))
  {
    result=strdup(name);
    if(result == ((char *)NULL) && !(errorMessage == ((struct PQExpBufferData *)NULL)))
    {
      return_value_libpq_gettext_4=libpq_gettext("out of memory\n");
      printfPQExpBuffer(errorMessage, return_value_libpq_gettext_4);
    }

  }

  pg_g_threadlock((signed int)(char)0);
  return result;
}

// pg_fe_sendauth
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 554
extern signed int pg_fe_sendauth(unsigned int areq, struct pg_conn *conn)
{
  char *return_value_libpq_gettext_1;
  char *return_value_libpq_gettext_2;
  signed int r;
  signed int pg_fe_sendauth__1__1__2__r;
  char *return_value_libpq_gettext_3;
  _Bool tmp_if_expr_4;
  signed int return_value_pg_password_sendauth_5;
  signed int return_value_pg_local_sendauth_6;
  char *return_value_libpq_gettext_7;
  switch(areq)
  {
    case (unsigned int)0:
      break;
    case (unsigned int)1:
    {
      return_value_libpq_gettext_1=libpq_gettext("Kerberos 4 authentication not supported\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
      return -1;
    }
    case (unsigned int)2:
    {
      return_value_libpq_gettext_2=libpq_gettext("Kerberos 5 authentication not supported\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2);
      return -1;
    }
    case (unsigned int)7:

    case (unsigned int)9:
      pg_g_threadlock((signed int)(char)1);
    case (unsigned int)8:
      pg_g_threadlock((signed int)(char)1);
    case (unsigned int)4:
    {
      return_value_libpq_gettext_3=libpq_gettext("Crypt authentication not supported\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
      return -1;
    }
    case (unsigned int)5:

    case (unsigned int)3:
    {
      conn->password_needed = (char)1;
      if(conn->pgpass == ((char *)NULL))
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (signed int)conn->pgpass[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
      {
        printfPQExpBuffer(&conn->errorMessage, "fe_sendauth: no password supplied\n");
        return -1;
      }

      return_value_pg_password_sendauth_5=pg_password_sendauth(conn, conn->pgpass, areq);
      if(!(return_value_pg_password_sendauth_5 == 0))
      {
        printfPQExpBuffer(&conn->errorMessage, "fe_sendauth: error sending password authentication\n");
        return -1;
      }

      break;
    }
    case (unsigned int)6:
    {
      return_value_pg_local_sendauth_6=pg_local_sendauth(conn);
      if(!(return_value_pg_local_sendauth_6 == 0))
        return -1;

      break;
    }
    default:
    {
      return_value_libpq_gettext_7=libpq_gettext("authentication method %u not supported\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_7, areq);
      return -1;
    }
  }
  return 0;
}

// pg_foreach_ifaddr
// file ip.c line 531
extern signed int pg_foreach_ifaddr(void (*callback)(struct sockaddr *, struct sockaddr *, void *), void *cb_data)
{
  struct ifaddrs *ifa;
  struct ifaddrs *l;
  signed int return_value_getifaddrs_1;
  return_value_getifaddrs_1=getifaddrs(&ifa);
  if(!(return_value_getifaddrs_1 >= 0))
    return -1;

  else
  {
    l = ifa;
    for( ; !(l == ((struct ifaddrs *)NULL)); l = l->ifa_next)
      run_ifaddr_callback(callback, cb_data, l->ifa_addr, l->ifa_netmask);
    freeifaddrs(ifa);
    return 0;
  }
}

// pg_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 17
extern void pg_free(void *ptr)
{
  if(!(ptr == NULL))
    free(ptr);

}

// pg_freeaddrinfo_all
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/libpq/ip.h line 35
extern void pg_freeaddrinfo_all(signed int hint_ai_family, struct addrinfo *ai)
{
  if(hint_ai_family == 1)
    while(!(ai == ((struct addrinfo *)NULL)))
    {
      struct addrinfo *p = ai;
      ai = ai->ai_next;
      free((void *)p->ai_addr);
      free((void *)p);
    }

  else
    if(!(ai == ((struct addrinfo *)NULL)))
      freeaddrinfo(ai);

}

// pg_gb18030_dsplen
// file wchar.c line 1096
static signed int pg_gb18030_dsplen(const unsigned char *s)
{
  signed int len;
  if(!((0x80 & (signed int)*s) == 0))
    len = 2;

  else
    len=pg_ascii_dsplen(s);
  return len;
}

// pg_gb18030_mblen
// file wchar.c line 1077
static signed int pg_gb18030_mblen(const unsigned char *s)
{
  signed int len;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_1;
  if((0x80 & (signed int)*s) == 0)
    len = 1;

  else
  {
    if((signed int)s[1l] >= 0x40)
      tmp_if_expr_2 = (signed int)s[(signed long int)1] <= 0x7e ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      if((signed int)s[1l] >= 0x80)
        tmp_if_expr_3 = (signed int)s[(signed long int)1] <= 0xfe ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      len = 2;

    else
    {
      if((signed int)s[1l] >= 0x30)
        tmp_if_expr_1 = (signed int)s[(signed long int)1] <= 0x39 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        len = 4;

      else
        len = 2;
    }
  }
  return len;
}

// pg_gb18030_verifier
// file wchar.c line 1404
static signed int pg_gb18030_verifier(const unsigned char *s, signed int len)
{
  signed int l;
  signed int mbl;
  mbl=pg_gb18030_mblen(s);
  l = mbl;
  if(!(len >= l))
    return -1;

  else
  {
    do
    {
      l = l - 1;
      if(!(l >= 1))
        break;

      s = s + 1l;
      if((signed int)*s == 0)
        return -1;

    }
    while((_Bool)1);
    return mbl;
  }
}

// pg_gbk_dsplen
// file wchar.c line 1034
static signed int pg_gbk_dsplen(const unsigned char *s)
{
  signed int len;
  if(!((0x80 & (signed int)*s) == 0))
    len = 2;

  else
    len=pg_ascii_dsplen(s);
  return len;
}

// pg_gbk_mblen
// file wchar.c line 1022
static signed int pg_gbk_mblen(const unsigned char *s)
{
  signed int len;
  if(!((0x80 & (signed int)*s) == 0))
    len = 2;

  else
    len = 1;
  return len;
}

// pg_gbk_verifier
// file wchar.c line 1364
static signed int pg_gbk_verifier(const unsigned char *s, signed int len)
{
  signed int l;
  signed int mbl;
  mbl=pg_gbk_mblen(s);
  l = mbl;
  if(!(len >= l))
    return -1;

  else
  {
    do
    {
      l = l - 1;
      if(!(l >= 1))
        break;

      s = s + 1l;
      if((signed int)*s == 0)
        return -1;

    }
    while((_Bool)1);
    return mbl;
  }
}

// pg_get_encoding_from_locale
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/chklocale.c line 283
extern signed int pg_get_encoding_from_locale(const char *ctype, char write_message)
{
  char *sys;
  signed int i;
  _Bool tmp_if_expr_3;
  signed int return_value_pg_strcasecmp_2;
  _Bool tmp_if_expr_6;
  signed int return_value_pg_strcasecmp_5;
  if(!(ctype == ((const char *)NULL)))
  {
    char *save;
    char *name;
    signed int return_value_pg_strcasecmp_1;
    return_value_pg_strcasecmp_1=pg_strcasecmp(ctype, "C");
    if(return_value_pg_strcasecmp_1 == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_pg_strcasecmp_2=pg_strcasecmp(ctype, "POSIX");
      tmp_if_expr_3 = return_value_pg_strcasecmp_2 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return PG_SQL_ASCII;

    save=setlocale(0, (const char *)(void *)0);
    if(save == ((char *)NULL))
      return -1;

    save=strdup(save);
    if(save == ((char *)NULL))
      return -1;

    name=setlocale(0, ctype);
    if(name == ((char *)NULL))
    {
      free((void *)save);
      return -1;
    }

    sys=nl_langinfo(14);
    if(!(sys == ((char *)NULL)))
      sys=strdup(sys);

    setlocale(0, save);
    free((void *)save);
  }

  else
  {
    ctype=setlocale(0, (const char *)(void *)0);
    if(ctype == ((const char *)NULL))
      return -1;

    signed int return_value_pg_strcasecmp_4;
    return_value_pg_strcasecmp_4=pg_strcasecmp(ctype, "C");
    if(return_value_pg_strcasecmp_4 == 0)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_pg_strcasecmp_5=pg_strcasecmp(ctype, "POSIX");
      tmp_if_expr_6 = return_value_pg_strcasecmp_5 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      return PG_SQL_ASCII;

    sys=nl_langinfo(14);
    if(!(sys == ((char *)NULL)))
      sys=strdup(sys);

  }
  if(sys == ((char *)NULL))
    return -1;

  else
  {
    i = 0;
    for( ; !(encoding_match_list[(signed long int)i].system_enc_name == ((const char *)NULL)); i = i + 1)
    {
      signed int return_value_pg_strcasecmp_7;
      return_value_pg_strcasecmp_7=pg_strcasecmp(sys, encoding_match_list[(signed long int)i].system_enc_name);
      if(return_value_pg_strcasecmp_7 == 0)
      {
        free((void *)sys);
        return (signed int)encoding_match_list[(signed long int)i].pg_enc_code;
      }

    }
    if(!(write_message == 0))
    {
      char *return_value_gettext_8;
      return_value_gettext_8=gettext("could not determine encoding for locale \"%s\": codeset is \"%s\"");
      fprintf(stderr, return_value_gettext_8, ctype, sys);
      fputc(10, stderr);
    }

    free((void *)sys);
    return -1;
  }
}

// pg_getaddrinfo_all
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/libpq/ip.h line 32
extern signed int pg_getaddrinfo_all(const char *hostname, const char *servname, struct addrinfo *hintp, struct addrinfo **result)
{
  signed int rc;
  *result = (struct addrinfo *)(void *)0;
  signed int return_value_getaddrinfo_unix_1;
  _Bool tmp_if_expr_2;
  if(hintp->ai_family == 1)
  {
    return_value_getaddrinfo_unix_1=getaddrinfo_unix(servname, hintp, result);
    return return_value_getaddrinfo_unix_1;
  }

  else
  {
    if(hostname == ((const char *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)hostname[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    rc=getaddrinfo(tmp_if_expr_2 ? (const char *)(void *)0 : hostname, servname, hintp, result);
    return rc;
  }
}

// pg_getnameinfo_all
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/libpq/ip.h line 37
extern signed int pg_getnameinfo_all(struct sockaddr_storage *addr, signed int salen, char *node, signed int nodelen, char *service, signed int servicelen, signed int flags)
{
  signed int rc;
  _Bool tmp_if_expr_1;
  if(!(addr == ((struct sockaddr_storage *)NULL)))
    tmp_if_expr_1 = (signed int)addr->ss_family == 1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    rc=getnameinfo_unix((struct sockaddr_un *)addr, salen, node, nodelen, service, servicelen, flags);

  else
    rc=getnameinfo((struct sockaddr *)addr, (unsigned int)salen, node, (unsigned int)nodelen, service, (unsigned int)servicelen, flags);
  if(!(rc == 0))
  {
    if(!(node == ((char *)NULL)))
      strlcpy(node, "???", (unsigned long int)nodelen);

    if(!(service == ((char *)NULL)))
      strlcpy(service, "???", (unsigned long int)servicelen);

  }

  return rc;
}

// pg_johab_dsplen
// file wchar.c line 399
static signed int pg_johab_dsplen(const unsigned char *s)
{
  signed int return_value_pg_euc_dsplen_1;
  return_value_pg_euc_dsplen_1=pg_euc_dsplen(s);
  return return_value_pg_euc_dsplen_1;
}

// pg_johab_mblen
// file wchar.c line 393
static signed int pg_johab_mblen(const unsigned char *s)
{
  signed int return_value_pg_euc_mblen_1;
  return_value_pg_euc_mblen_1=pg_euc_mblen(s);
  return return_value_pg_euc_mblen_1;
}

// pg_johab_verifier
// file wchar.c line 1270
static signed int pg_johab_verifier(const unsigned char *s, signed int len)
{
  signed int l;
  signed int mbl;
  unsigned char c;
  mbl=pg_johab_mblen(s);
  l = mbl;
  if(!(len >= l))
    return -1;

  else
    if((0x80 & (signed int)*s) == 0)
      return mbl;

    else
    {
      do
      {
        l = l - 1;
        if(!(l >= 1))
          break;

        s = s + 1l;
        c = *s;
        if(!((signed int)c >= 0xa1) || (signed int)c >= 255)
          return -1;

      }
      while((_Bool)1);
      return mbl;
    }
}

// pg_latin12wchar_with_len
// file wchar.c line 912
static signed int pg_latin12wchar_with_len(const unsigned char *from, unsigned int *to, signed int len)
{
  signed int cnt = 0;
  unsigned int *tmp_post_1;
  const unsigned char *tmp_post_2;
  for( ; len >= 1; cnt = cnt + 1)
  {
    if(*from == 0)
      break;

    tmp_post_1 = to;
    to = to + 1l;
    tmp_post_2 = from;
    from = from + 1l;
    *tmp_post_1 = (unsigned int)*tmp_post_2;
    len = len - 1;
  }
  *to = (unsigned int)0;
  return cnt;
}

// pg_latin1_dsplen
// file wchar.c line 955
static signed int pg_latin1_dsplen(const unsigned char *s)
{
  signed int return_value_pg_ascii_dsplen_1;
  return_value_pg_ascii_dsplen_1=pg_ascii_dsplen(s);
  return return_value_pg_ascii_dsplen_1;
}

// pg_latin1_mblen
// file wchar.c line 949
static signed int pg_latin1_mblen(const unsigned char *s)
{
  return 1;
}

// pg_latin1_verifier
// file wchar.c line 1315
static signed int pg_latin1_verifier(const unsigned char *s, signed int len)
{
  return 1;
}

// pg_local_sendauth
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 441
static signed int pg_local_sendauth(struct pg_conn *conn)
{
  char *return_value_libpq_gettext_1;
  return_value_libpq_gettext_1=libpq_gettext("SCM_CRED authentication method not supported\n");
  printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
  return -1;
}

// pg_lrand48
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/erand48.c line 88
extern signed long int pg_lrand48(void)
{
  _dorand48(_rand48_seed);
  return ((signed long int)_rand48_seed[(signed long int)2] << 15) + ((signed long int)_rand48_seed[(signed long int)1] >> 1);
}

// pg_malloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 14
extern void * pg_malloc(unsigned long int size)
{
  void *tmp;
  if(size == 0ul)
    size = (unsigned long int)1;

  tmp=malloc(size);
  if(tmp == NULL)
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("out of memory\n");
    fprintf(stderr, return_value_gettext_1);
    exit(1);
  }

  return tmp;
}

// pg_malloc0
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/fe_memutils.c line 40
extern void * pg_malloc0(unsigned long int size)
{
  void *tmp;
  tmp=pg_malloc(size);
  signed long int *tmp_post_1;
  do
  {
    void *_vstart = (void *)tmp;
    signed int _val = 0;
    unsigned long int _len = size;
    if((7ul & _len) == 0ul && (7ul & (unsigned long int)_vstart) == 0ul && _val == 0 && !(_len >= 1025ul))
    {
      signed long int *pg_malloc0__1__1__1___start = (signed long int *)_vstart;
      signed long int *_stop = (signed long int *)((char *)pg_malloc0__1__1__1___start + (signed long int)_len);
      for( ; !(pg_malloc0__1__1__1___start >= _stop); *tmp_post_1 = (signed long int)0)
      {
        tmp_post_1 = pg_malloc0__1__1__1___start;
        pg_malloc0__1__1__1___start = pg_malloc0__1__1__1___start + 1l;
      }
    }

    else
      memset(_vstart, _val, _len);
  }
  while((_Bool)0);
  return tmp;
}

// pg_md5_binary
// file md5.c line 302
extern char pg_md5_binary(const void *buff, unsigned long int len, void *outbuf)
{
  signed int return_value_calculateDigestFromBuffer_1;
  return_value_calculateDigestFromBuffer_1=calculateDigestFromBuffer((const unsigned char *)buff, (unsigned int)len, (unsigned char *)outbuf);
  if(return_value_calculateDigestFromBuffer_1 == 0)
    return (char)0;

  else
    return (char)1;
}

// pg_md5_encrypt
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/libpq/md5.h line 27
extern char pg_md5_encrypt(const char *passwd, const char *salt, unsigned long int salt_len, char *buf)
{
  unsigned long int passwd_len;
  passwd_len=strlen(passwd);
  char *crypt_buf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(passwd_len + salt_len + (unsigned long int)1);
  crypt_buf = (char *)return_value_malloc_1;
  char ret;
  if(crypt_buf == ((char *)NULL))
    return (char)0;

  else
  {
    memcpy((void *)crypt_buf, (const void *)passwd, passwd_len);
    memcpy((void *)(crypt_buf + (signed long int)passwd_len), (const void *)salt, salt_len);
    strcpy(buf, "md5");
    ret=pg_md5_hash((const void *)crypt_buf, passwd_len + salt_len, buf + (signed long int)3);
    free((void *)crypt_buf);
    return ret;
  }
}

// pg_md5_hash
// file md5.c line 290
extern char pg_md5_hash(const void *buff, unsigned long int len, char *hexsum)
{
  unsigned char sum[16l];
  signed int return_value_calculateDigestFromBuffer_1;
  return_value_calculateDigestFromBuffer_1=calculateDigestFromBuffer((const unsigned char *)buff, (unsigned int)len, sum);
  if(return_value_calculateDigestFromBuffer_1 == 0)
    return (char)0;

  else
  {
    bytesToHex(sum, hexsum);
    return (char)1;
  }
}

// pg_mic_mblen
// file wchar.c line 1770
extern signed int pg_mic_mblen(const unsigned char *mbstr)
{
  signed int return_value_pg_mule_mblen_1;
  return_value_pg_mule_mblen_1=pg_mule_mblen(mbstr);
  return return_value_pg_mule_mblen_1;
}

// pg_mkdir_p
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgmkdirp.c line 57
extern signed int pg_mkdir_p(char *path, signed int omode)
{
  struct stat sb;
  unsigned int numask;
  unsigned int oumask;
  signed int last;
  signed int retval;
  char *p;
  retval = 0;
  p = path;
  oumask=umask((unsigned int)0);
  numask = oumask & (unsigned int)~(0200 | 0100);
  umask(numask);
  if((signed int)*p == 47)
    p = p + 1l;

  last = 0;
  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_2;
  signed int return_value_mkdir_3;
  for( ; last == 0; p = p + 1l)
  {
    if((signed int)*p == 0)
      last = 1;

    else
      if(!((signed int)*p == 47))
        goto __CPROVER_DUMP_L13;

    *p = (char)0;
    if(last == 0)
    {
      if((signed int)p[1l] == 0)
        last = 1;

    }

    if(!(last == 0))
      umask(oumask);

    signed int return_value_stat_4;
    return_value_stat_4=stat(path, &sb);
    if(return_value_stat_4 == 0)
    {
      if(!((61440u & sb.st_mode) == 16384u))
      {
        if(!(last == 0))
        {
          return_value___errno_location_1=__errno_location();
          *return_value___errno_location_1 = 17;
        }

        else
        {
          return_value___errno_location_2=__errno_location();
          *return_value___errno_location_2 = 20;
        }
        retval = -1;
        break;
      }

    }

    else
    {
      return_value_mkdir_3=mkdir(path, (unsigned int)(last != 0 ? omode : 0400 | 0200 | 0100 | (0400 | 0200 | 0100) >> 3 | ((0400 | 0200 | 0100) >> 3) >> 3));
      if(!(return_value_mkdir_3 >= 0))
      {
        retval = -1;
        break;
      }

    }
    if(last == 0)
      *p = (char)47;


  __CPROVER_DUMP_L13:
    ;
  }
  umask(oumask);
  return retval;
}

// pg_mule2wchar_with_len
// file wchar.c line 748
static signed int pg_mule2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len)
{
  signed int cnt = 0;
  _Bool tmp_if_expr_15;
  const unsigned char *tmp_post_1;
  const unsigned char *tmp_post_2;
  _Bool tmp_if_expr_14;
  const unsigned char *tmp_post_3;
  const unsigned char *tmp_post_4;
  _Bool tmp_if_expr_13;
  const unsigned char *tmp_post_5;
  const unsigned char *tmp_post_6;
  const unsigned char *tmp_post_7;
  _Bool tmp_if_expr_12;
  const unsigned char *tmp_post_8;
  const unsigned char *tmp_post_9;
  const unsigned char *tmp_post_10;
  const unsigned char *tmp_post_11;
  for( ; len >= 1; cnt = cnt + 1)
  {
    if(*from == 0)
      break;

    if((signed int)*from >= 0x81)
      tmp_if_expr_15 = (signed int)(unsigned char)*from <= 0x8d ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_15 = (_Bool)0;
    if(len >= 2 && tmp_if_expr_15)
    {
      tmp_post_1 = from;
      from = from + 1l;
      *to = (unsigned int)((signed int)*tmp_post_1 << 16);
      tmp_post_2 = from;
      from = from + 1l;
      *to = *to | (unsigned int)*tmp_post_2;
      len = len - 2;
    }

    else
    {
      if((signed int)*from == 0x9a)
        tmp_if_expr_14 = (_Bool)1;

      else
        tmp_if_expr_14 = (signed int)(unsigned char)*from == 0x9b ? (_Bool)1 : (_Bool)0;
      if(len >= 3 && tmp_if_expr_14)
      {
        from = from + 1l;
        tmp_post_3 = from;
        from = from + 1l;
        *to = (unsigned int)((signed int)*tmp_post_3 << 16);
        tmp_post_4 = from;
        from = from + 1l;
        *to = *to | (unsigned int)*tmp_post_4;
        len = len - 3;
      }

      else
      {
        if((signed int)*from >= 0x90)
          tmp_if_expr_13 = (signed int)(unsigned char)*from <= 0x99 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_13 = (_Bool)0;
        if(len >= 3 && tmp_if_expr_13)
        {
          tmp_post_5 = from;
          from = from + 1l;
          *to = (unsigned int)((signed int)*tmp_post_5 << 16);
          tmp_post_6 = from;
          from = from + 1l;
          *to = *to | (unsigned int)((signed int)*tmp_post_6 << 8);
          tmp_post_7 = from;
          from = from + 1l;
          *to = *to | (unsigned int)*tmp_post_7;
          len = len - 3;
        }

        else
        {
          if((signed int)*from == 0x9c)
            tmp_if_expr_12 = (_Bool)1;

          else
            tmp_if_expr_12 = (signed int)(unsigned char)*from == 0x9d ? (_Bool)1 : (_Bool)0;
          if(len >= 4 && tmp_if_expr_12)
          {
            from = from + 1l;
            tmp_post_8 = from;
            from = from + 1l;
            *to = (unsigned int)((signed int)*tmp_post_8 << 16);
            tmp_post_9 = from;
            from = from + 1l;
            *to = *to | (unsigned int)((signed int)*tmp_post_9 << 8);
            tmp_post_10 = from;
            from = from + 1l;
            *to = *to | (unsigned int)*tmp_post_10;
            len = len - 4;
          }

          else
          {
            tmp_post_11 = from;
            from = from + 1l;
            *to = (unsigned int)(unsigned char)*tmp_post_11;
            len = len - 1;
          }
        }
      }
    }
    to = to + 1l;
  }
  *to = (unsigned int)0;
  return cnt;
}

// pg_mule_dsplen
// file wchar.c line 884
static signed int pg_mule_dsplen(const unsigned char *s)
{
  signed int len;
  _Bool tmp_if_expr_4;
  if((signed int)*s >= 0x81)
    tmp_if_expr_4 = (signed int)(unsigned char)*s <= 0x8d ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(tmp_if_expr_4)
    len = 1;

  else
  {
    if((signed int)*s == 0x9a)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)(unsigned char)*s == 0x9b ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      len = 1;

    else
    {
      if((signed int)*s >= 0x90)
        tmp_if_expr_2 = (signed int)(unsigned char)*s <= 0x99 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        len = 2;

      else
      {
        if((signed int)*s == 0x9c)
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = (signed int)(unsigned char)*s == 0x9d ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
          len = 2;

        else
          len = 1;
      }
    }
  }
  return len;
}

// pg_mule_mblen
// file wchar.c line 866
extern signed int pg_mule_mblen(const unsigned char *s)
{
  signed int len;
  _Bool tmp_if_expr_4;
  if((signed int)*s >= 0x81)
    tmp_if_expr_4 = (signed int)(unsigned char)*s <= 0x8d ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(tmp_if_expr_4)
    len = 2;

  else
  {
    if((signed int)*s == 0x9a)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)(unsigned char)*s == 0x9b ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      len = 3;

    else
    {
      if((signed int)*s >= 0x90)
        tmp_if_expr_2 = (signed int)(unsigned char)*s <= 0x99 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        len = 3;

      else
      {
        if((signed int)*s == 0x9c)
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = (signed int)(unsigned char)*s == 0x9d ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
          len = 4;

        else
          len = 1;
      }
    }
  }
  return len;
}

// pg_mule_verifier
// file wchar.c line 1294
static signed int pg_mule_verifier(const unsigned char *s, signed int len)
{
  signed int l;
  signed int mbl;
  unsigned char c;
  mbl=pg_mule_mblen(s);
  l = mbl;
  if(!(len >= l))
    return -1;

  else
  {
    do
    {
      l = l - 1;
      if(!(l >= 1))
        break;

      s = s + 1l;
      c = *s;
      if((0x80 & (signed int)c) == 0)
        return -1;

    }
    while((_Bool)1);
    return mbl;
  }
}

// pg_password_sendauth
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-auth.c line 493
static signed int pg_password_sendauth(struct pg_conn *conn, const char *password, unsigned int areq)
{
  signed int ret;
  char *crypt_pwd = (char *)(void *)0;
  const char *pwd_to_send;
  char *crypt_pwd2;
  void *return_value_malloc_1;
  unsigned long int return_value_strlen_3;
  char return_value_pg_md5_encrypt_4;
  unsigned long int return_value_strlen_5;
  char return_value_pg_md5_encrypt_6;
  switch(areq)
  {
    case (unsigned int)5:
    {
      return_value_malloc_1=malloc((unsigned long int)(2 * (35 + 1)));
      crypt_pwd = (char *)return_value_malloc_1;
      if(crypt_pwd == ((char *)NULL))
      {
        char *return_value_libpq_gettext_2;
        return_value_libpq_gettext_2=libpq_gettext("out of memory\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2);
        return -1;
      }

      crypt_pwd2 = crypt_pwd + (signed long int)35 + (signed long int)1;
      return_value_strlen_3=strlen(conn->pguser);
      return_value_pg_md5_encrypt_4=pg_md5_encrypt(password, conn->pguser, return_value_strlen_3, crypt_pwd2);
      if(return_value_pg_md5_encrypt_4 == 0)
      {
        free((void *)crypt_pwd);
        return -1;
      }

      return_value_strlen_5=strlen("md5");
      return_value_pg_md5_encrypt_6=pg_md5_encrypt(crypt_pwd2 + (signed long int)return_value_strlen_5, conn->md5Salt, sizeof(char [4l]) /*4ul*/ , crypt_pwd);
      if(return_value_pg_md5_encrypt_6 == 0)
      {
        free((void *)crypt_pwd);
        return -1;
      }

      pwd_to_send = crypt_pwd;
      break;
    }
    case (unsigned int)3:
    {
      pwd_to_send = password;
      break;
    }
    default:
      return -1;
  }
  unsigned long int return_value_strlen_7;
  unsigned long int return_value_strlen_8;
  if(conn->pversion >> 16 >= 3u)
  {
    return_value_strlen_7=strlen(pwd_to_send);
    ret=pqPacketSend(conn, (char)112, (const void *)pwd_to_send, return_value_strlen_7 + (unsigned long int)1);
  }

  else
  {
    return_value_strlen_8=strlen(pwd_to_send);
    ret=pqPacketSend(conn, (char)0, (const void *)pwd_to_send, return_value_strlen_8 + (unsigned long int)1);
  }
  if(!(crypt_pwd == ((char *)NULL)))
    free((void *)crypt_pwd);

  return ret;
}

// pg_qsort
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 445
extern void pg_qsort(void *a, unsigned long int n, unsigned long int es, signed int (*cmp)(const void *, const void *))
{
  char *pa;
  char *pb;
  char *pc;
  char *pd;
  char *pl;
  char *pm;
  char *pn;
  unsigned long int d1;
  unsigned long int d2;
  signed int r;
  signed int swaptype;
  signed int presorted;
  _Bool tmp_if_expr_1;
  signed int return_value;
  do
  {

  loop:
    ;
    swaptype = (unsigned long int)((char *)a - (char *)0) % sizeof(signed long int) /*8ul*/  != 0ul || es % sizeof(signed long int) /*8ul*/  != 0ul ? 2 : (es == sizeof(signed long int) /*8ul*/  ? 0 : 1);
    if(!(n >= 7ul))
    {
      pm = (char *)a + (signed long int)es;
      for( ; !(pm >= (char *)a + (signed long int)es * (signed long int)n); pm = pm + (signed long int)es)
      {
        pl = pm;
        do
        {
          if(!((char *)a >= pl))
          {
            return_value=cmp((const void *)(pl - (signed long int)es), (const void *)pl);
            tmp_if_expr_1 = return_value > 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_1 = (_Bool)0;
          if(!tmp_if_expr_1)
            break;

          if(swaptype == 0)
          {
            signed long int t = *((signed long int *)(void *)pl);
            *((signed long int *)(void *)pl) = *((signed long int *)(void *)(pl - (signed long int)es));
            *((signed long int *)(void *)(pl - (signed long int)es)) = t;
          }

          else
            swapfunc(pl, pl - (signed long int)es, es, swaptype);
          pl = pl - (signed long int)es;
        }
        while((_Bool)1);
      }
      goto __CPROVER_DUMP_L38;
    }

    presorted = 1;
    pm = (char *)a + (signed long int)es;
    if(!(pm >= (char *)a + (signed long int)es * (signed long int)n))
    {
      signed int return_value_1;
      return_value_1=cmp((const void *)(pm - (signed long int)es), (const void *)pm);
      if(return_value_1 >= 1)
        presorted = 0;

      else
        pm = pm + (signed long int)es;
    }

    if(!(presorted == 0))
      goto __CPROVER_DUMP_L38;

    pm = (char *)a + (signed long int)((n / (unsigned long int)2) * es);
    if(n >= 8ul)
    {
      pl = (char *)a;
      pn = (char *)a + (signed long int)((n - (unsigned long int)1) * es);
      if(n >= 41ul)
      {
        unsigned long int d = (n / (unsigned long int)8) * es;
        pl=med3(pl, pl + (signed long int)d, pl + (signed long int)((unsigned long int)2 * d), cmp);
        pm=med3(pm - (signed long int)d, pm, pm + (signed long int)d, cmp);
        pn=med3(pn - (signed long int)((unsigned long int)2 * d), pn - (signed long int)d, pn, cmp);
      }

      pm=med3(pl, pm, pn, cmp);
    }

    if(swaptype == 0)
    {
      signed long int pg_qsort__1__4__t = *((signed long int *)(void *)a);
      *((signed long int *)(void *)a) = *((signed long int *)(void *)pm);
      *((signed long int *)(void *)pm) = pg_qsort__1__4__t;
    }

    else
      swapfunc((char *)a, pm, es, swaptype);
    pb = (char *)a + (signed long int)es;
    pa = pb;
    pd = (char *)a + (signed long int)((n - (unsigned long int)1) * es);
    pc = pd;
    for( ; (_Bool)1; pc = pc - (signed long int)es)
    {
      if(pc >= pb)
      {
        r=cmp((const void *)pb, a);
        if(!(r >= 1))
        {
          if(r == 0)
          {
            if(swaptype == 0)
            {
              signed long int pg_qsort__1__5__1__1__1__1__t = *((signed long int *)(void *)pa);
              *((signed long int *)(void *)pa) = *((signed long int *)(void *)pb);
              *((signed long int *)(void *)pb) = pg_qsort__1__5__1__1__1__1__t;
            }

            else
              swapfunc(pa, pb, es, swaptype);
            pa = pa + (signed long int)es;
          }

          pb = pb + (signed long int)es;
        }

      }

      if(pc >= pb)
      {
        r=cmp((const void *)pc, a);
        if(r >= 0)
        {
          if(r == 0)
          {
            if(swaptype == 0)
            {
              signed long int pg_qsort__1__5__1__2__1__1__t = *((signed long int *)(void *)pc);
              *((signed long int *)(void *)pc) = *((signed long int *)(void *)pd);
              *((signed long int *)(void *)pd) = pg_qsort__1__5__1__2__1__1__t;
            }

            else
              swapfunc(pc, pd, es, swaptype);
            pd = pd - (signed long int)es;
          }

          pc = pc - (signed long int)es;
        }

      }

      if(!(pc >= pb))
        break;

      if(swaptype == 0)
      {
        signed long int pg_qsort__1__5__1__3__t = *((signed long int *)(void *)pb);
        *((signed long int *)(void *)pb) = *((signed long int *)(void *)pc);
        *((signed long int *)(void *)pc) = pg_qsort__1__5__1__3__t;
      }

      else
        swapfunc(pb, pc, es, swaptype);
      pb = pb + (signed long int)es;
    }
    pn = (char *)a + (signed long int)(n * es);
    d1 = (unsigned long int)(pa - (char *)a < pb - pa ? pa - (char *)a : pb - pa);
    if(d1 >= 1ul)
      swapfunc((char *)a, pb - (signed long int)d1, d1, swaptype);

    d1 = (unsigned long int)(pd - pc) < (unsigned long int)(pn - pd) - es ? (unsigned long int)(pd - pc) : (unsigned long int)(pn - pd) - es;
    if(d1 >= 1ul)
      swapfunc(pb, pn - (signed long int)d1, d1, swaptype);

    d1 = (unsigned long int)(pb - pa);
    d2 = (unsigned long int)(pd - pc);
    if(d2 >= d1)
    {
      if(!(es >= d1))
        pg_qsort(a, d1 / es, es, cmp);

      if(!(es >= d2))
      {
        a = (void *)(pn - (signed long int)d2);
        n = d2 / es;
        goto loop;
      }

      break;
    }

    if(!(es >= d2))
      pg_qsort((void *)(pn - (signed long int)d2), d2 / es, es, cmp);

    if(es >= d1)
      break;

    n = d1 / es;
  }
  while((_Bool)1);

__CPROVER_DUMP_L38:
  ;
}

// pg_qsort_strcmp
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort.c line 232
extern signed int pg_qsort_strcmp(const void *a, const void *b)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(*((const char * const *)a), *((const char * const *)b));
  return return_value_strcmp_1;
}

// pg_range_sockaddr
// file ip.c line 276
extern signed int pg_range_sockaddr(struct sockaddr_storage *addr, struct sockaddr_storage *netaddr, struct sockaddr_storage *netmask)
{
  signed int return_value_range_sockaddr_AF_INET_1;
  signed int return_value_range_sockaddr_AF_INET6_2;
  if((signed int)addr->ss_family == 2)
  {
    return_value_range_sockaddr_AF_INET_1=range_sockaddr_AF_INET((struct sockaddr_in *)addr, (struct sockaddr_in *)netaddr, (struct sockaddr_in *)netmask);
    return return_value_range_sockaddr_AF_INET_1;
  }

  else
    if((signed int)addr->ss_family == 10)
    {
      return_value_range_sockaddr_AF_INET6_2=range_sockaddr_AF_INET6((struct sockaddr_in6 *)addr, (struct sockaddr_in6 *)netaddr, (struct sockaddr_in6 *)netmask);
      return return_value_range_sockaddr_AF_INET6_2;
    }

    else
      return 0;
}

// pg_realloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 16
extern void * pg_realloc(void *ptr, unsigned long int size)
{
  void *tmp;
  if(ptr == NULL && size == 0ul)
    size = (unsigned long int)1;

  tmp=realloc(ptr, size);
  if(tmp == NULL)
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("out of memory\n");
    fprintf(stderr, return_value_gettext_1);
    exit(1);
  }

  return tmp;
}

// pg_set_block
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/noblock.c line 35
extern char pg_set_block(signed int sock)
{
  signed int flags;
  flags=fcntl(sock, 3);
  _Bool tmp_if_expr_2;
  signed int return_value_fcntl_1;
  if(!(flags >= 0))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_fcntl_1=fcntl(sock, 4, (signed long int)(flags & ~04000));
    tmp_if_expr_2 = return_value_fcntl_1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return (char)0;

  else
    return (char)1;
}

// pg_set_noblock
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/noblock.c line 21
extern char pg_set_noblock(signed int sock)
{
  signed int return_value_fcntl_1;
  return_value_fcntl_1=fcntl(sock, 4, 04000);
  return (char)(return_value_fcntl_1 != -1);
}

// pg_sjis_dsplen
// file wchar.c line 978
static signed int pg_sjis_dsplen(const unsigned char *s)
{
  signed int len;
  _Bool tmp_if_expr_1;
  if((signed int)*s >= 0xa1)
    tmp_if_expr_1 = (signed int)*s <= 0xdf ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    len = 1;

  else
    if(!((0x80 & (signed int)*s) == 0))
      len = 2;

    else
      len=pg_ascii_dsplen(s);
  return len;
}

// pg_sjis_mblen
// file wchar.c line 964
static signed int pg_sjis_mblen(const unsigned char *s)
{
  signed int len;
  _Bool tmp_if_expr_1;
  if((signed int)*s >= 0xa1)
    tmp_if_expr_1 = (signed int)*s <= 0xdf ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    len = 1;

  else
    if(!((0x80 & (signed int)*s) == 0))
      len = 2;

    else
      len = 1;
  return len;
}

// pg_sjis_verifier
// file wchar.c line 1321
static signed int pg_sjis_verifier(const unsigned char *s, signed int len)
{
  signed int l;
  signed int mbl;
  unsigned char c1;
  unsigned char c2;
  mbl=pg_sjis_mblen(s);
  l = mbl;
  const unsigned char *tmp_post_1;
  if(!(len >= l))
    return -1;

  else
    if(l == 1)
      return mbl;

    else
    {
      tmp_post_1 = s;
      s = s + 1l;
      c1 = *tmp_post_1;
      c2 = *s;
      if((!((signed int)c1 >= 0x81) || (signed int)c1 >= 160) && (!((signed int)c1 >= 0xe0) || (signed int)c1 >= 253) || (!((signed int)c2 >= 0x40) || (signed int)c2 >= 127) && (!((signed int)c2 >= 0x80) || (signed int)c2 >= 253))
        return -1;

      else
        return mbl;
    }
}

// pg_sockaddr_cidr_mask
// file ip.c line 338
extern signed int pg_sockaddr_cidr_mask(struct sockaddr_storage *mask, char *numbits, signed int family)
{
  signed long int bits;
  char *endptr;
  _Bool tmp_if_expr_1;
  if(numbits == ((char *)NULL))
    bits = (signed long int)(family == 2 ? 32 : 128);

  else
  {
    bits=strtol(numbits, &endptr, 10);
    if((signed int)*numbits == 0)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)*endptr != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return -1;

  }
  struct sockaddr_in mask4;
  signed long int maskl;
  struct sockaddr_in6 mask6;
  signed int i;
  switch(family)
  {
    case 2:
    {
      if(bits >= 33l || !(bits >= 0l))
        return -1;

      memset((void *)&mask4, 0, sizeof(struct sockaddr_in) /*16ul*/ );
      if(bits >= 1l)
        maskl = (signed long int)(0xffffffffUL << 32 - (signed int)bits & 0xffffffffUL);

      else
        maskl = (signed long int)0;
      mask4.sin_addr.s_addr=htonl((unsigned int)maskl);
      memcpy((void *)mask, (const void *)&mask4, sizeof(struct sockaddr_in) /*16ul*/ );
      break;
    }
    case 10:
    {
      if(bits >= 129l || !(bits >= 0l))
        return -1;

      memset((void *)&mask6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
      i = 0;
      for( ; !(i >= 16); i = i + 1)
      {
        if(!(bits >= 1l))
          mask6.sin6_addr.__in6_u.__u6_addr8[(signed long int)i] = (unsigned char)0;

        else
          if(bits >= 8l)
            mask6.sin6_addr.__in6_u.__u6_addr8[(signed long int)i] = (unsigned char)0xff;

          else
            mask6.sin6_addr.__in6_u.__u6_addr8[(signed long int)i] = (unsigned char)(0xff << 8 - (signed int)bits & 0xff);
        bits = bits - (signed long int)8;
      }
      memcpy((void *)mask, (const void *)&mask6, sizeof(struct sockaddr_in6) /*28ul*/ );
      break;
    }
    default:
      return -1;
  }
  mask->ss_family = (unsigned short int)family;
  return 0;
}

// pg_srand48
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/erand48.c line 95
extern void pg_srand48(signed long int seed)
{
  _rand48_seed[(signed long int)0] = (unsigned short int)0x330e;
  _rand48_seed[(signed long int)1] = (unsigned short int)seed;
  _rand48_seed[(signed long int)2] = (unsigned short int)(seed >> 16);
  _rand48_mult[(signed long int)0] = (unsigned short int)0xe66d;
  _rand48_mult[(signed long int)1] = (unsigned short int)0xdeec;
  _rand48_mult[(signed long int)2] = (unsigned short int)0x0005;
  _rand48_add = (unsigned short int)0x000b;
}

// pg_str_endswith
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/string.c line 31
extern char pg_str_endswith(const char *str, const char *end)
{
  unsigned long int slen;
  slen=strlen(str);
  unsigned long int elen;
  elen=strlen(end);
  if(!(slen >= elen))
    return (char)0;

  else
  {
    str = str + (signed long int)(slen - elen);
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(str, end);
    return (char)(return_value_strcmp_1 == 0);
  }
}

// pg_strcasecmp
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 122
extern signed int pg_strcasecmp(const char *s1, const char *s2)
{
  const char *tmp_post_1;
  const char *tmp_post_2;
  const unsigned short int **return_value___ctype_b_loc_4;
  signed int return_value_tolower_3;
  const unsigned short int **return_value___ctype_b_loc_6;
  signed int return_value_tolower_5;
  do
  {
    unsigned char ch1;
    tmp_post_1 = s1;
    s1 = s1 + 1l;
    ch1 = (unsigned char)*tmp_post_1;
    unsigned char ch2;
    tmp_post_2 = s2;
    s2 = s2 + 1l;
    ch2 = (unsigned char)*tmp_post_2;
    if(!(ch1 == ch2))
    {
      if((signed int)ch1 >= 65 && !((signed int)ch1 >= 91))
        ch1 = ch1 + (unsigned char)(97 - 65);

      else
        if(!((0x80 & (signed int)ch1) == 0))
        {
          return_value___ctype_b_loc_4=__ctype_b_loc();
          if(!((256 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)ch1]) == 0))
          {
            return_value_tolower_3=tolower((signed int)ch1);
            ch1 = (unsigned char)return_value_tolower_3;
          }

        }

      if((signed int)ch2 >= 65 && !((signed int)ch2 >= 91))
        ch2 = ch2 + (unsigned char)(97 - 65);

      else
        if(!((0x80 & (signed int)ch2) == 0))
        {
          return_value___ctype_b_loc_6=__ctype_b_loc();
          if(!((256 & (signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)ch2]) == 0))
          {
            return_value_tolower_5=tolower((signed int)ch2);
            ch2 = (unsigned char)return_value_tolower_5;
          }

        }

      if(!(ch1 == ch2))
        return (signed int)ch1 - (signed int)ch2;

    }

    if((signed int)ch1 == 0)
      break;

  }
  while((_Bool)1);
  return 0;
}

// pg_strdup
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 13
extern char * pg_strdup(const char *in)
{
  char *tmp;
  if(in == ((const char *)NULL))
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("cannot duplicate null pointer (internal error)\n");
    fprintf(stderr, return_value_gettext_1);
    exit(1);
  }

  tmp=strdup(in);
  if(tmp == ((char *)NULL))
  {
    char *return_value_gettext_2;
    return_value_gettext_2=gettext("out of memory\n");
    fprintf(stderr, return_value_gettext_2);
    exit(1);
  }

  return tmp;
}

// pg_strncasecmp
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgstrcasecmp.c line 69
extern signed int pg_strncasecmp(const char *s1, const char *s2, unsigned long int n)
{
  unsigned long int tmp_post_1;
  const char *tmp_post_2;
  const char *tmp_post_3;
  const unsigned short int **return_value___ctype_b_loc_5;
  signed int return_value_tolower_4;
  const unsigned short int **return_value___ctype_b_loc_7;
  signed int return_value_tolower_6;
  do
  {
    tmp_post_1 = n;
    n = n - 1ul;
    if(!(tmp_post_1 >= 1ul))
      break;

    unsigned char ch1;
    tmp_post_2 = s1;
    s1 = s1 + 1l;
    ch1 = (unsigned char)*tmp_post_2;
    unsigned char ch2;
    tmp_post_3 = s2;
    s2 = s2 + 1l;
    ch2 = (unsigned char)*tmp_post_3;
    if(!(ch1 == ch2))
    {
      if((signed int)ch1 >= 65 && !((signed int)ch1 >= 91))
        ch1 = ch1 + (unsigned char)(97 - 65);

      else
        if(!((0x80 & (signed int)ch1) == 0))
        {
          return_value___ctype_b_loc_5=__ctype_b_loc();
          if(!((256 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)ch1]) == 0))
          {
            return_value_tolower_4=tolower((signed int)ch1);
            ch1 = (unsigned char)return_value_tolower_4;
          }

        }

      if((signed int)ch2 >= 65 && !((signed int)ch2 >= 91))
        ch2 = ch2 + (unsigned char)(97 - 65);

      else
        if(!((0x80 & (signed int)ch2) == 0))
        {
          return_value___ctype_b_loc_7=__ctype_b_loc();
          if(!((256 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)ch2]) == 0))
          {
            return_value_tolower_6=tolower((signed int)ch2);
            ch2 = (unsigned char)return_value_tolower_6;
          }

        }

      if(!(ch1 == ch2))
        return (signed int)ch1 - (signed int)ch2;

    }

    if((signed int)ch1 == 0)
      break;

  }
  while((_Bool)1);
  return 0;
}

// pg_tolower
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgstrcasecmp.c line 122
extern unsigned char pg_tolower(unsigned char ch)
{
  const unsigned short int **return_value___ctype_b_loc_2;
  signed int return_value_tolower_1;
  if((signed int)ch >= 65 && !((signed int)ch >= 91))
    ch = ch + (unsigned char)(97 - 65);

  else
    if(!((0x80 & (signed int)ch) == 0))
    {
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if(!((256 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)ch]) == 0))
      {
        return_value_tolower_1=tolower((signed int)ch);
        ch = (unsigned char)return_value_tolower_1;
      }

    }

  return ch;
}

// pg_toupper
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgstrcasecmp.c line 105
extern unsigned char pg_toupper(unsigned char ch)
{
  const unsigned short int **return_value___ctype_b_loc_2;
  signed int return_value_toupper_1;
  if((signed int)ch >= 97 && !((signed int)ch >= 123))
    ch = ch + (unsigned char)(65 - 97);

  else
    if(!((0x80 & (signed int)ch) == 0))
    {
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if(!((512 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)ch]) == 0))
      {
        return_value_toupper_1=toupper((signed int)ch);
        ch = (unsigned char)return_value_toupper_1;
      }

    }

  return ch;
}

// pg_uhc_dsplen
// file wchar.c line 1061
static signed int pg_uhc_dsplen(const unsigned char *s)
{
  signed int len;
  if(!((0x80 & (signed int)*s) == 0))
    len = 2;

  else
    len=pg_ascii_dsplen(s);
  return len;
}

// pg_uhc_mblen
// file wchar.c line 1049
static signed int pg_uhc_mblen(const unsigned char *s)
{
  signed int len;
  if(!((0x80 & (signed int)*s) == 0))
    len = 2;

  else
    len = 1;
  return len;
}

// pg_uhc_verifier
// file wchar.c line 1384
static signed int pg_uhc_verifier(const unsigned char *s, signed int len)
{
  signed int l;
  signed int mbl;
  mbl=pg_uhc_mblen(s);
  l = mbl;
  if(!(len >= l))
    return -1;

  else
  {
    do
    {
      l = l - 1;
      if(!(l >= 1))
        break;

      s = s + 1l;
      if((signed int)*s == 0)
        return -1;

    }
    while((_Bool)1);
    return mbl;
  }
}

// pg_usleep
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/pgsleep.c line 44
extern void pg_usleep(signed long int microsec)
{
  if(microsec >= 1l)
  {
    struct timeval delay;
    delay.tv_sec = microsec / 1000000L;
    delay.tv_usec = microsec % 1000000L;
    select(0, (struct anonymous_28 *)(void *)0, (struct anonymous_28 *)(void *)0, (struct anonymous_28 *)(void *)0, &delay);
  }

}

// pg_utf2wchar_with_len
// file wchar.c line 411
static signed int pg_utf2wchar_with_len(const unsigned char *from, unsigned int *to, signed int len)
{
  signed int cnt = 0;
  unsigned int c1;
  unsigned int c2;
  unsigned int c3;
  unsigned int c4;
  const unsigned char *tmp_post_1;
  const unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  const unsigned char *tmp_post_4;
  const unsigned char *tmp_post_5;
  const unsigned char *tmp_post_6;
  const unsigned char *tmp_post_7;
  const unsigned char *tmp_post_8;
  const unsigned char *tmp_post_9;
  const unsigned char *tmp_post_10;
  const unsigned char *tmp_post_11;
  for( ; len >= 1; cnt = cnt + 1)
  {
    if(*from == 0)
      break;

    if((0x80 & (signed int)*from) == 0)
    {
      tmp_post_1 = from;
      from = from + 1l;
      *to = (unsigned int)*tmp_post_1;
      len = len - 1;
    }

    else
      if((0xe0 & (signed int)*from) == 0xc0)
      {
        if(!(len >= 2))
          break;

        tmp_post_2 = from;
        from = from + 1l;
        c1 = (unsigned int)((signed int)*tmp_post_2 & 0x1f);
        tmp_post_3 = from;
        from = from + 1l;
        c2 = (unsigned int)((signed int)*tmp_post_3 & 0x3f);
        *to = c1 << 6 | c2;
        len = len - 2;
      }

      else
        if((0xf0 & (signed int)*from) == 0xe0)
        {
          if(!(len >= 3))
            break;

          tmp_post_4 = from;
          from = from + 1l;
          c1 = (unsigned int)((signed int)*tmp_post_4 & 0x0f);
          tmp_post_5 = from;
          from = from + 1l;
          c2 = (unsigned int)((signed int)*tmp_post_5 & 0x3f);
          tmp_post_6 = from;
          from = from + 1l;
          c3 = (unsigned int)((signed int)*tmp_post_6 & 0x3f);
          *to = c1 << 12 | c2 << 6 | c3;
          len = len - 3;
        }

        else
          if((0xf8 & (signed int)*from) == 0xf0)
          {
            if(!(len >= 4))
              break;

            tmp_post_7 = from;
            from = from + 1l;
            c1 = (unsigned int)((signed int)*tmp_post_7 & 0x07);
            tmp_post_8 = from;
            from = from + 1l;
            c2 = (unsigned int)((signed int)*tmp_post_8 & 0x3f);
            tmp_post_9 = from;
            from = from + 1l;
            c3 = (unsigned int)((signed int)*tmp_post_9 & 0x3f);
            tmp_post_10 = from;
            from = from + 1l;
            c4 = (unsigned int)((signed int)*tmp_post_10 & 0x3f);
            *to = c1 << 18 | c2 << 12 | c3 << 6 | c4;
            len = len - 4;
          }

          else
          {
            tmp_post_11 = from;
            from = from + 1l;
            *to = (unsigned int)*tmp_post_11;
            len = len - 1;
          }
    to = to + 1l;
  }
  *to = (unsigned int)0;
  return cnt;
}

// pg_utf8_islegal
// file wchar.c line 1452
extern char pg_utf8_islegal(const unsigned char *source, signed int length)
{
  unsigned char a;
  if(!(length == 4))
  {
    if(length == 3)
      goto __CPROVER_DUMP_L2;

    if(length == 2)
      goto __CPROVER_DUMP_L3;

    if(length == 1)
      goto __CPROVER_DUMP_L13;

    return (char)0;
  }

  else
  {
    a = source[(signed long int)3];
    if((signed int)a >= 192 || !((signed int)a >= 0x80))
      return (char)0;

    else
    {

    __CPROVER_DUMP_L2:
      ;
      a = source[(signed long int)2];
      if((signed int)a >= 192 || !((signed int)a >= 0x80))
        return (char)0;

      else
      {

      __CPROVER_DUMP_L3:
        ;
        a = source[(signed long int)1];
        switch((signed int)*source)
        {
          case 0xE0:
          {
            if((signed int)a >= 192 || !((signed int)a >= 0xA0))
              return (char)0;

            break;
          }
          case 0xED:
          {
            if((signed int)a >= 160 || !((signed int)a >= 0x80))
              return (char)0;

            break;
          }
          case 0xF0:
          {
            if((signed int)a >= 192 || !((signed int)a >= 0x90))
              return (char)0;

            break;
          }
          case 0xF4:
          {
            if((signed int)a >= 144 || !((signed int)a >= 0x80))
              return (char)0;

            break;
          }
          default:
            if((signed int)a >= 192 || !((signed int)a >= 0x80))
              return (char)0;

        }

      __CPROVER_DUMP_L13:
        ;
        a = *source;
        if((signed int)a >= 0x80 && !((signed int)a >= 0xC2))
          return (char)0;

        else
          if((signed int)a >= 245)
            return (char)0;

          else
            return (char)1;
      }
    }
  }
}

// pg_utf8_verifier
// file wchar.c line 1424
static signed int pg_utf8_verifier(const unsigned char *s, signed int len)
{
  signed int l;
  l=pg_utf_mblen(s);
  if(!(len >= l))
    return -1;

  else
  {
    char return_value_pg_utf8_islegal_1;
    return_value_pg_utf8_islegal_1=pg_utf8_islegal(s, l);
    if(return_value_pg_utf8_islegal_1 == 0)
      return -1;

    else
      return l;
  }
}

// pg_utf_dsplen
// file wchar.c line 736
static signed int pg_utf_dsplen(const unsigned char *s)
{
  unsigned int return_value_utf8_to_unicode_1;
  return_value_utf8_to_unicode_1=utf8_to_unicode(s);
  signed int return_value_ucs_wcwidth_2;
  return_value_ucs_wcwidth_2=ucs_wcwidth(return_value_utf8_to_unicode_1);
  return return_value_ucs_wcwidth_2;
}

// pg_utf_mblen
// file wchar.c line 541
extern signed int pg_utf_mblen(const unsigned char *s)
{
  signed int len;
  if((0x80 & (signed int)*s) == 0)
    len = 1;

  else
    if((0xe0 & (signed int)*s) == 0xc0)
      len = 2;

    else
      if((0xf0 & (signed int)*s) == 0xe0)
        len = 3;

      else
        if((0xf8 & (signed int)*s) == 0xf0)
          len = 4;

        else
          len = 1;
  return len;
}

// pg_valid_client_encoding
// file encnames.c line 411
extern signed int pg_valid_client_encoding(const char *name)
{
  signed int enc;
  enc=pg_char_to_encoding(name);
  if(!(enc >= 0))
    return -1;

  else
    if(!(enc >= 0) || enc >= _PG_LAST_ENCODING_)
      return -1;

    else
      return enc;
}

// pg_valid_server_encoding
// file encnames.c line 425
extern signed int pg_valid_server_encoding(const char *name)
{
  signed int enc;
  enc=pg_char_to_encoding(name);
  if(!(enc >= 0))
    return -1;

  else
    if(!(enc >= 0) || enc >= 35)
      return -1;

    else
      return enc;
}

// pg_valid_server_encoding_id
// file encnames.c line 439
extern signed int pg_valid_server_encoding_id(signed int encoding)
{
  return (signed int)(encoding >= 0 && encoding <= PG_KOI8U);
}

// pg_wchar2euc_with_len
// file wchar.c line 347
static signed int pg_wchar2euc_with_len(const unsigned int *from, unsigned char *to, signed int len)
{
  signed int cnt = 0;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  unsigned char *tmp_post_9;
  unsigned char *tmp_post_10;
  while(len >= 1)
  {
    if(*from == 0u)
      break;

    unsigned char c = (unsigned char)(*from >> 24);
    if(!(c == 0))
    {
      tmp_post_1 = to;
      to = to + 1l;
      *tmp_post_1 = c;
      tmp_post_2 = to;
      to = to + 1l;
      *tmp_post_2 = (unsigned char)(*from >> 16 & (unsigned int)0xff);
      tmp_post_3 = to;
      to = to + 1l;
      *tmp_post_3 = (unsigned char)(*from >> 8 & (unsigned int)0xff);
      tmp_post_4 = to;
      to = to + 1l;
      *tmp_post_4 = (unsigned char)(*from & (unsigned int)0xff);
      cnt = cnt + 4;
    }

    else
    {
      c = (unsigned char)(*from >> 16);
      if(!(c == 0))
      {
        tmp_post_5 = to;
        to = to + 1l;
        *tmp_post_5 = c;
        tmp_post_6 = to;
        to = to + 1l;
        *tmp_post_6 = (unsigned char)(*from >> 8 & (unsigned int)0xff);
        tmp_post_7 = to;
        to = to + 1l;
        *tmp_post_7 = (unsigned char)(*from & (unsigned int)0xff);
        cnt = cnt + 3;
      }

      else
      {
        c = (unsigned char)(*from >> 8);
        if(!(c == 0))
        {
          tmp_post_8 = to;
          to = to + 1l;
          *tmp_post_8 = c;
          tmp_post_9 = to;
          to = to + 1l;
          *tmp_post_9 = (unsigned char)(*from & (unsigned int)0xff);
          cnt = cnt + 2;
        }

        else
        {
          tmp_post_10 = to;
          to = to + 1l;
          *tmp_post_10 = (unsigned char)*from;
          cnt = cnt + 1;
        }
      }
    }
    from = from + 1l;
    len = len - 1;
  }
  *to = (unsigned char)0;
  return cnt;
}

// pg_wchar2mule_with_len
// file wchar.c line 801
static signed int pg_wchar2mule_with_len(const unsigned int *from, unsigned char *to, signed int len)
{
  signed int cnt = 0;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  unsigned char *tmp_post_9;
  unsigned char *tmp_post_10;
  unsigned char *tmp_post_11;
  unsigned char *tmp_post_12;
  unsigned char *tmp_post_13;
  unsigned char *tmp_post_14;
  unsigned char *tmp_post_15;
  unsigned char *tmp_post_16;
  unsigned char *tmp_post_17;
  unsigned char *tmp_post_18;
  unsigned char *tmp_post_19;
  unsigned char *tmp_post_20;
  while(len >= 1)
  {
    if(*from == 0u)
      break;

    unsigned char lb = (unsigned char)(*from >> 16 & (unsigned int)0xff);
    if((signed int)lb >= 0x81 && !((signed int)lb >= 142))
    {
      tmp_post_1 = to;
      to = to + 1l;
      *tmp_post_1 = lb;
      tmp_post_2 = to;
      to = to + 1l;
      *tmp_post_2 = (unsigned char)(*from & (unsigned int)0xff);
      cnt = cnt + 2;
    }

    else
      if((signed int)lb >= 0x90 && !((signed int)lb >= 154))
      {
        tmp_post_3 = to;
        to = to + 1l;
        *tmp_post_3 = lb;
        tmp_post_4 = to;
        to = to + 1l;
        *tmp_post_4 = (unsigned char)(*from >> 8 & (unsigned int)0xff);
        tmp_post_5 = to;
        to = to + 1l;
        *tmp_post_5 = (unsigned char)(*from & (unsigned int)0xff);
        cnt = cnt + 3;
      }

      else
        if((signed int)lb >= 0xa0 && !((signed int)lb >= 224))
        {
          tmp_post_6 = to;
          to = to + 1l;
          *tmp_post_6 = (unsigned char)0x9a;
          tmp_post_7 = to;
          to = to + 1l;
          *tmp_post_7 = lb;
          tmp_post_8 = to;
          to = to + 1l;
          *tmp_post_8 = (unsigned char)(*from & (unsigned int)0xff);
          cnt = cnt + 3;
        }

        else
          if((signed int)lb >= 0xe0 && !((signed int)lb >= 240))
          {
            tmp_post_9 = to;
            to = to + 1l;
            *tmp_post_9 = (unsigned char)0x9b;
            tmp_post_10 = to;
            to = to + 1l;
            *tmp_post_10 = lb;
            tmp_post_11 = to;
            to = to + 1l;
            *tmp_post_11 = (unsigned char)(*from & (unsigned int)0xff);
            cnt = cnt + 3;
          }

          else
            if((signed int)lb >= 0xf0 && !((signed int)lb >= 245))
            {
              tmp_post_12 = to;
              to = to + 1l;
              *tmp_post_12 = (unsigned char)0x9c;
              tmp_post_13 = to;
              to = to + 1l;
              *tmp_post_13 = lb;
              tmp_post_14 = to;
              to = to + 1l;
              *tmp_post_14 = (unsigned char)(*from >> 8 & (unsigned int)0xff);
              tmp_post_15 = to;
              to = to + 1l;
              *tmp_post_15 = (unsigned char)(*from & (unsigned int)0xff);
              cnt = cnt + 4;
            }

            else
              if((signed int)lb >= 0xf5 && !((signed int)lb >= 255))
              {
                tmp_post_16 = to;
                to = to + 1l;
                *tmp_post_16 = (unsigned char)0x9d;
                tmp_post_17 = to;
                to = to + 1l;
                *tmp_post_17 = lb;
                tmp_post_18 = to;
                to = to + 1l;
                *tmp_post_18 = (unsigned char)(*from >> 8 & (unsigned int)0xff);
                tmp_post_19 = to;
                to = to + 1l;
                *tmp_post_19 = (unsigned char)(*from & (unsigned int)0xff);
                cnt = cnt + 4;
              }

              else
              {
                tmp_post_20 = to;
                to = to + 1l;
                *tmp_post_20 = (unsigned char)(*from & (unsigned int)0xff);
                cnt = cnt + 1;
              }
    from = from + 1l;
    len = len - 1;
  }
  *to = (unsigned char)0;
  return cnt;
}

// pg_wchar2single_with_len
// file wchar.c line 934
static signed int pg_wchar2single_with_len(const unsigned int *from, unsigned char *to, signed int len)
{
  signed int cnt = 0;
  unsigned char *tmp_post_1;
  const unsigned int *tmp_post_2;
  for( ; len >= 1; cnt = cnt + 1)
  {
    if(*from == 0u)
      break;

    tmp_post_1 = to;
    to = to + 1l;
    tmp_post_2 = from;
    from = from + 1l;
    *tmp_post_1 = (unsigned char)*tmp_post_2;
    len = len - 1;
  }
  *to = (unsigned char)0;
  return cnt;
}

// pg_wchar2utf_with_len
// file wchar.c line 510
static signed int pg_wchar2utf_with_len(const unsigned int *from, unsigned char *to, signed int len)
{
  signed int cnt = 0;
  while(len >= 1)
  {
    if(*from == 0u)
      break;

    signed int char_len;
    unicode_to_utf8(*from, to);
    char_len=pg_utf_mblen(to);
    cnt = cnt + char_len;
    to = to + (signed long int)char_len;
    from = from + 1l;
    len = len - 1;
  }
  *to = (unsigned char)0;
  return cnt;
}

// pgfnames
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/pgfnames.c line 31
extern char ** pgfnames(const char *path)
{
  struct __dirstream *dir;
  struct dirent *file;
  char **filenames;
  signed int numnames = 0;
  signed int fnsize = 200;
  dir=opendir(path);
  if(dir == ((struct __dirstream *)NULL))
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("could not open directory \"%s\": %s\n");
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    fprintf(stderr, return_value_gettext_1, path, return_value_strerror_3);
    return (char **)(void *)0;
  }

  void *return_value_palloc_4;
  return_value_palloc_4=palloc((unsigned long int)fnsize * sizeof(char *) /*8ul*/ );
  filenames = (char **)return_value_palloc_4;
  signed int *return_value___errno_location_5;
  signed int return_value_strcmp_8;
  signed int tmp_post_7;
  do
  {
    return_value___errno_location_5=__errno_location();
    *return_value___errno_location_5 = 0;
    file=readdir(dir);
    if(file == ((struct dirent *)NULL))
      break;

    signed int return_value_strcmp_9;
    return_value_strcmp_9=strcmp(file->d_name, ".");
    if(!(return_value_strcmp_9 == 0))
    {
      return_value_strcmp_8=strcmp(file->d_name, "..");
      if(!(return_value_strcmp_8 == 0))
      {
        if(1 + numnames >= fnsize)
        {
          fnsize = fnsize * 2;
          void *return_value_repalloc_6;
          return_value_repalloc_6=repalloc((void *)filenames, (unsigned long int)fnsize * sizeof(char *) /*8ul*/ );
          filenames = (char **)return_value_repalloc_6;
        }

        tmp_post_7 = numnames;
        numnames = numnames + 1;
        filenames[(signed long int)tmp_post_7]=pstrdup(file->d_name);
      }

    }

  }
  while((_Bool)1);
  signed int *return_value___errno_location_13;
  return_value___errno_location_13=__errno_location();
  if(!(*return_value___errno_location_13 == 0))
  {
    char *return_value_gettext_10;
    return_value_gettext_10=gettext("could not read directory \"%s\": %s\n");
    signed int *return_value___errno_location_11;
    return_value___errno_location_11=__errno_location();
    char *return_value_strerror_12;
    return_value_strerror_12=strerror(*return_value___errno_location_11);
    fprintf(stderr, return_value_gettext_10, path, return_value_strerror_12);
  }

  filenames[(signed long int)numnames] = (char *)(void *)0;
  signed int return_value_closedir_17;
  return_value_closedir_17=closedir(dir);
  if(!(return_value_closedir_17 == 0))
  {
    char *return_value_gettext_14;
    return_value_gettext_14=gettext("could not close directory \"%s\": %s\n");
    signed int *return_value___errno_location_15;
    return_value___errno_location_15=__errno_location();
    char *return_value_strerror_16;
    return_value_strerror_16=strerror(*return_value___errno_location_15);
    fprintf(stderr, return_value_gettext_14, path, return_value_strerror_16);
  }

  return filenames;
}

// pgfnames_cleanup
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/pgfnames.c line 99
extern void pgfnames_cleanup(char **filenames)
{
  char **fn = filenames;
  for( ; !(*fn == ((char *)NULL)); fn = fn + 1l)
    pfree((void *)*fn);
  pfree((void *)filenames);
}

// pipe_read_line
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 348
static char * pipe_read_line(char *cmd, char *line, signed int maxsize)
{
  struct _IO_FILE *pgver;
  fflush(stdout);
  fflush(stderr);
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  pgver=popen(cmd, "r");
  if(pgver == ((struct _IO_FILE *)NULL))
  {
    perror("popen failure");
    return (char *)(void *)0;
  }

  else
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 0;
    char *return_value_fgets_4;
    return_value_fgets_4=fgets(line, maxsize, pgver);
    if(return_value_fgets_4 == ((char *)NULL))
    {
      signed int return_value_feof_3;
      return_value_feof_3=feof(pgver);
      if(!(return_value_feof_3 == 0))
        fprintf(stderr, "no data was returned by command \"%s\"\n", cmd);

      else
        perror("fgets failure");
      pclose(pgver);
      return (char *)(void *)0;
    }

    signed int return_value_pclose_check_5;
    return_value_pclose_check_5=pclose_check(pgver);
    if(!(return_value_pclose_check_5 == 0))
      return (char *)(void *)0;

    else
      return line;
  }
}

// pipe_read_line_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 348
static char * pipe_read_line_link1(char *cmd_link1, char *line_link1, signed int maxsize_link1)
{
  struct _IO_FILE *pgver_link1;
  fflush(stdout);
  fflush(stderr);
  signed int *return_value___errno_location_1_link1;
  return_value___errno_location_1_link1=__errno_location();
  *return_value___errno_location_1_link1 = 0;
  pgver_link1=popen(cmd_link1, "r");
  if(pgver_link1 == ((struct _IO_FILE *)NULL))
  {
    perror("popen failure");
    return (char *)(void *)0;
  }

  else
  {
    signed int *return_value___errno_location_2_link1;
    return_value___errno_location_2_link1=__errno_location();
    *return_value___errno_location_2_link1 = 0;
    char *return_value_fgets_4_link1;
    return_value_fgets_4_link1=fgets(line_link1, maxsize_link1, pgver_link1);
    if(return_value_fgets_4_link1 == ((char *)NULL))
    {
      signed int return_value_feof_3_link1;
      return_value_feof_3_link1=feof(pgver_link1);
      if(!(return_value_feof_3_link1 == 0))
        fprintf(stderr, "no data was returned by command \"%s\"\n", cmd_link1);

      else
        perror("fgets failure");
      pclose(pgver_link1);
      return (char *)(void *)0;
    }

    signed int return_value_pclose_check_5_link1;
    return_value_pclose_check_5_link1=pclose_check(pgver_link1);
    if(!(return_value_pclose_check_5_link1 == 0))
      return (char *)(void *)0;

    else
      return line_link1;
  }
}

// pqAddTuple
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 851
static char pqAddTuple(struct pg_result *res, struct pgresAttValue *tup)
{
  signed int tmp_if_expr_1;
  void *return_value_malloc_2;
  void *return_value_realloc_3;
  if(res->ntups >= res->tupArrSize)
  {
    signed int newSize;
    if(res->tupArrSize >= 1)
      tmp_if_expr_1 = res->tupArrSize * 2;

    else
      tmp_if_expr_1 = 128;
    newSize = tmp_if_expr_1;
    struct pgresAttValue **newTuples;
    if(res->tuples == ((struct pgresAttValue **)NULL))
    {
      return_value_malloc_2=malloc((unsigned long int)newSize * sizeof(struct pgresAttValue *) /*8ul*/ );
      newTuples = (struct pgresAttValue **)return_value_malloc_2;
    }

    else
    {
      return_value_realloc_3=realloc((void *)res->tuples, (unsigned long int)newSize * sizeof(struct pgresAttValue *) /*8ul*/ );
      newTuples = (struct pgresAttValue **)return_value_realloc_3;
    }
    if(newTuples == ((struct pgresAttValue **)NULL))
      return (char)0;

    res->tupArrSize = newSize;
    res->tuples = newTuples;
  }

  res->tuples[(signed long int)res->ntups] = tup;
  res->ntups = res->ntups + 1;
  return (char)1;
}

// pqBuildStartupPacket2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 542
extern char * pqBuildStartupPacket2(struct pg_conn *conn, signed int *packetlen, const struct PQEnvironmentOption *options)
{
  struct StartupPacket *startpacket;
  *packetlen = (signed int)sizeof(struct StartupPacket) /*292ul*/ ;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct StartupPacket) /*292ul*/ );
  startpacket = (struct StartupPacket *)return_value_malloc_1;
  signed long int *tmp_post_2;
  if(startpacket == ((struct StartupPacket *)NULL))
    return (char *)(void *)0;

  else
  {
    do
    {
      void *_vstart = (void *)startpacket;
      signed int _val = 0;
      unsigned long int _len = sizeof(struct StartupPacket) /*292ul*/ ;
      if((7ul & _len) == 0ul && (7ul & (unsigned long int)_vstart) == 0ul && _val == 0 && !(_len >= 1025ul))
      {
        signed long int *pqBuildStartupPacket2__1__1__1___start = (signed long int *)_vstart;
        signed long int *_stop = (signed long int *)((char *)pqBuildStartupPacket2__1__1__1___start + (signed long int)_len);
        for( ; !(pqBuildStartupPacket2__1__1__1___start >= _stop); *tmp_post_2 = (signed long int)0)
        {
          tmp_post_2 = pqBuildStartupPacket2__1__1__1___start;
          pqBuildStartupPacket2__1__1__1___start = pqBuildStartupPacket2__1__1__1___start + 1l;
        }
      }

      else
        memset(_vstart, _val, _len);
    }
    while((_Bool)0);
    startpacket->protoVersion=htonl(conn->pversion);
    strncpy(startpacket->user, conn->pguser, (unsigned long int)32);
    strncpy(startpacket->database, conn->dbName, (unsigned long int)64);
    strncpy(startpacket->tty, conn->pgtty, (unsigned long int)64);
    if(!(conn->pgoptions == ((char *)NULL)))
      strncpy(startpacket->options, conn->pgoptions, (unsigned long int)64);

    return (char *)startpacket;
  }
}

// pqBuildStartupPacket3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 556
extern char * pqBuildStartupPacket3(struct pg_conn *conn, signed int *packetlen, const struct PQEnvironmentOption *options)
{
  char *startpacket;
  *packetlen=build_startup_packet(conn, (char *)(void *)0, options);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)*packetlen);
  startpacket = (char *)return_value_malloc_1;
  if(startpacket == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    *packetlen=build_startup_packet(conn, startpacket, options);
    return startpacket;
  }
}

// pqCatenateResultError
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 630
extern void pqCatenateResultError(struct pg_result *res, const char *msg)
{
  struct PQExpBufferData errorBuf;
  if(!(msg == ((const char *)NULL)) && !(res == ((struct pg_result *)NULL)))
  {
    initPQExpBuffer(&errorBuf);
    if(!(res->errMsg == ((char *)NULL)))
      appendPQExpBufferStr(&errorBuf, res->errMsg);

    appendPQExpBufferStr(&errorBuf, msg);
    pqSetResultError(res, errorBuf.data);
    termPQExpBuffer(&errorBuf);
  }

}

// pqCheckInBufferSpace
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 577
extern signed int pqCheckInBufferSpace(unsigned long int bytes_needed, struct pg_conn *conn)
{
  signed int newsize = conn->inBufSize;
  char *newbuf;
  if((unsigned long int)newsize >= bytes_needed)
    return 0;

  else
  {
    bytes_needed = bytes_needed - (unsigned long int)conn->inStart;
    if(!(conn->inStart >= conn->inEnd))
    {
      if(conn->inStart >= 1)
      {
        memmove((void *)conn->inBuffer, (const void *)(conn->inBuffer + (signed long int)conn->inStart), (unsigned long int)(conn->inEnd - conn->inStart));
        conn->inEnd = conn->inEnd - conn->inStart;
        conn->inCursor = conn->inCursor - conn->inStart;
        conn->inStart = 0;
      }

    }

    else
    {
      conn->inEnd = 0;
      conn->inCursor = conn->inEnd;
      conn->inStart = conn->inCursor;
    }
    if((unsigned long int)newsize >= bytes_needed)
      return 0;

    else
    {
      do
        newsize = newsize * 2;
      while(newsize >= 1 && !((unsigned long int)newsize >= bytes_needed));
      if(newsize >= 1 && (unsigned long int)newsize >= bytes_needed)
      {
        void *return_value_realloc_1;
        return_value_realloc_1=realloc((void *)conn->inBuffer, (unsigned long int)newsize);
        newbuf = (char *)return_value_realloc_1;
        if(!(newbuf == ((char *)NULL)))
        {
          conn->inBuffer = newbuf;
          conn->inBufSize = newsize;
          return 0;
        }

      }

      newsize = conn->inBufSize;
      do
        newsize = newsize + 8192;
      while(newsize >= 1 && !((unsigned long int)newsize >= bytes_needed));
      if(newsize >= 1 && (unsigned long int)newsize >= bytes_needed)
      {
        void *return_value_realloc_2;
        return_value_realloc_2=realloc((void *)conn->inBuffer, (unsigned long int)newsize);
        newbuf = (char *)return_value_realloc_2;
        if(!(newbuf == ((char *)NULL)))
        {
          conn->inBuffer = newbuf;
          conn->inBufSize = newsize;
          return 0;
        }

      }

      printfPQExpBuffer(&conn->errorMessage, "cannot allocate memory for input buffer\n");
      return -1;
    }
  }
}

// pqCheckOutBufferSpace
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 576
extern signed int pqCheckOutBufferSpace(unsigned long int bytes_needed, struct pg_conn *conn)
{
  signed int newsize = conn->outBufSize;
  char *newbuf;
  if((unsigned long int)newsize >= bytes_needed)
    return 0;

  else
  {
    do
      newsize = newsize * 2;
    while(newsize >= 1 && !((unsigned long int)newsize >= bytes_needed));
    if(newsize >= 1 && (unsigned long int)newsize >= bytes_needed)
    {
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)conn->outBuffer, (unsigned long int)newsize);
      newbuf = (char *)return_value_realloc_1;
      if(!(newbuf == ((char *)NULL)))
      {
        conn->outBuffer = newbuf;
        conn->outBufSize = newsize;
        return 0;
      }

    }

    newsize = conn->outBufSize;
    do
      newsize = newsize + 8192;
    while(newsize >= 1 && !((unsigned long int)newsize >= bytes_needed));
    if(newsize >= 1 && (unsigned long int)newsize >= bytes_needed)
    {
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)conn->outBuffer, (unsigned long int)newsize);
      newbuf = (char *)return_value_realloc_2;
      if(!(newbuf == ((char *)NULL)))
      {
        conn->outBuffer = newbuf;
        conn->outBufSize = newsize;
        return 0;
      }

    }

    printfPQExpBuffer(&conn->errorMessage, "cannot allocate memory for output buffer\n");
    return -1;
  }
}

// pqClearAsyncResult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 524
extern void pqClearAsyncResult(struct pg_conn *conn)
{
  if(!(conn->result == ((struct pg_result *)NULL)))
    PQclear(conn->result);

  conn->result = (struct pg_result *)(void *)0;
  if(!(conn->next_result == ((struct pg_result *)NULL)))
    PQclear(conn->next_result);

  conn->next_result = (struct pg_result *)(void *)0;
}

// pqDropConnection
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 396
extern void pqDropConnection(struct pg_conn *conn)
{
  pqsecure_close(conn);
  if(!(conn->sock == -1))
    close(conn->sock);

  conn->sock = -1;
  conn->inEnd = 0;
  conn->inCursor = conn->inEnd;
  conn->inStart = conn->inCursor;
  conn->outCount = 0;
}

// pqEndcopy2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 548
extern signed int pqEndcopy2(struct pg_conn *conn)
{
  struct pg_result *result;
  if(!((signed int)conn->asyncStatus == PGASYNC_COPY_IN))
  {
    if(!((signed int)conn->asyncStatus == PGASYNC_COPY_OUT))
    {
      char *return_value_libpq_gettext_1;
      return_value_libpq_gettext_1=libpq_gettext("no COPY in progress\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
      return 1;
    }

  }

  signed int return_value_pqFlush_2;
  return_value_pqFlush_2=pqFlush(conn);
  signed int return_value_PQisBusy_3;
  if(!(return_value_pqFlush_2 == 0))
  {
    if(conn->nonblocking == 0)
      goto __CPROVER_DUMP_L2;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(!(conn->nonblocking == 0))
    {
      return_value_PQisBusy_3=PQisBusy(conn);
      if(return_value_PQisBusy_3 == 0)
        goto __CPROVER_DUMP_L3;

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      conn->asyncStatus = (enum anonymous_9)PGASYNC_BUSY;
      resetPQExpBuffer(&conn->errorMessage);
      result=PQgetResult(conn);
      if(!(result == ((struct pg_result *)NULL)))
      {
        if(!((signed int)result->resultStatus == PGRES_COMMAND_OK))
          goto __CPROVER_DUMP_L4;

        PQclear(result);
        return 0;
      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        if(conn->errorMessage.len >= 1ul)
        {
          char svLast = conn->errorMessage.data[(signed long int)(conn->errorMessage.len - (unsigned long int)1)];
          if((signed int)svLast == 10)
            conn->errorMessage.data[(signed long int)(conn->errorMessage.len - (unsigned long int)1)] = (char)0;

          pqInternalNotice(&conn->noticeHooks, "%s", conn->errorMessage.data);
          conn->errorMessage.data[(signed long int)(conn->errorMessage.len - (unsigned long int)1)] = svLast;
        }

        PQclear(result);
        pqInternalNotice(&conn->noticeHooks, "lost synchronization with server, resetting connection");
        if(!(conn->nonblocking == 0))
          PQresetStart(conn);

        else
          PQreset(conn);
        return 1;
      }
    }
  }
}

// pqEndcopy3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 563
extern signed int pqEndcopy3(struct pg_conn *conn)
{
  struct pg_result *result;
  if(!((signed int)conn->asyncStatus == PGASYNC_COPY_IN))
  {
    if(!((signed int)conn->asyncStatus == PGASYNC_COPY_OUT))
    {
      if(!((signed int)conn->asyncStatus == PGASYNC_COPY_BOTH))
      {
        char *return_value_libpq_gettext_1;
        return_value_libpq_gettext_1=libpq_gettext("no COPY in progress\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
        return 1;
      }

    }

  }

  _Bool tmp_if_expr_8;
  if((signed int)conn->asyncStatus == PGASYNC_COPY_IN)
    tmp_if_expr_8 = (_Bool)1;

  else
    tmp_if_expr_8 = (signed int)conn->asyncStatus == PGASYNC_COPY_BOTH ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  signed int return_value_pqPutMsgEnd_3;
  _Bool tmp_if_expr_7;
  signed int return_value_pqPutMsgEnd_6;
  if(tmp_if_expr_8)
  {
    signed int return_value_pqPutMsgStart_2;
    return_value_pqPutMsgStart_2=pqPutMsgStart((char)99, (char)0, conn);
    if(!(return_value_pqPutMsgStart_2 >= 0))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_pqPutMsgEnd_3=pqPutMsgEnd(conn);
      tmp_if_expr_4 = return_value_pqPutMsgEnd_3 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      return 1;

    if(!((signed int)conn->queryclass == PGQUERY_SIMPLE))
    {
      signed int return_value_pqPutMsgStart_5;
      return_value_pqPutMsgStart_5=pqPutMsgStart((char)83, (char)0, conn);
      if(!(return_value_pqPutMsgStart_5 >= 0))
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_pqPutMsgEnd_6=pqPutMsgEnd(conn);
        tmp_if_expr_7 = return_value_pqPutMsgEnd_6 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
        return 1;

    }

  }

  signed int return_value_pqFlush_9;
  return_value_pqFlush_9=pqFlush(conn);
  signed int return_value_PQisBusy_10;
  if(!(return_value_pqFlush_9 == 0))
  {
    if(conn->nonblocking == 0)
      goto __CPROVER_DUMP_L12;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L12:
    ;
    conn->asyncStatus = (enum anonymous_9)PGASYNC_BUSY;
    resetPQExpBuffer(&conn->errorMessage);
    if(!(conn->nonblocking == 0))
    {
      return_value_PQisBusy_10=PQisBusy(conn);
      if(return_value_PQisBusy_10 == 0)
        goto __CPROVER_DUMP_L13;

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L13:
      ;
      result=PQgetResult(conn);
      if(!(result == ((struct pg_result *)NULL)))
      {
        if(!((signed int)result->resultStatus == PGRES_COMMAND_OK))
          goto __CPROVER_DUMP_L14;

        PQclear(result);
        return 0;
      }

      else
      {

      __CPROVER_DUMP_L14:
        ;
        if(conn->errorMessage.len >= 1ul)
        {
          char svLast = conn->errorMessage.data[(signed long int)(conn->errorMessage.len - (unsigned long int)1)];
          if((signed int)svLast == 10)
            conn->errorMessage.data[(signed long int)(conn->errorMessage.len - (unsigned long int)1)] = (char)0;

          pqInternalNotice(&conn->noticeHooks, "%s", conn->errorMessage.data);
          conn->errorMessage.data[(signed long int)(conn->errorMessage.len - (unsigned long int)1)] = svLast;
        }

        PQclear(result);
        return 1;
      }
    }
  }
}

// pqFlush
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 591
extern signed int pqFlush(struct pg_conn *conn)
{
  if(!(conn->Pfdebug == ((struct _IO_FILE *)NULL)))
    fflush(conn->Pfdebug);

  signed int return_value_pqSendSome_1;
  if(conn->outCount >= 1)
  {
    return_value_pqSendSome_1=pqSendSome(conn, conn->outCount);
    return return_value_pqSendSome_1;
  }

  else
    return 0;
}

// pqFunctionCall2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 549
extern struct pg_result * pqFunctionCall2(struct pg_conn *conn, unsigned int fnid, signed int *result_buf, signed int *actual_result_len, signed int result_is_int, const struct anonymous_33 *args, signed int nargs)
{
  char needInput = (char)0;
  enum anonymous_20 status = (enum anonymous_20)PGRES_FATAL_ERROR;
  char id;
  signed int i;
  signed int return_value_pqPutMsgStart_1;
  return_value_pqPutMsgStart_1=pqPutMsgStart((char)70, (char)0, conn);
  _Bool tmp_if_expr_3;
  signed int return_value_pqPuts_2;
  if(!(return_value_pqPutMsgStart_1 >= 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_pqPuts_2=pqPuts(" ", conn);
    tmp_if_expr_3 = return_value_pqPuts_2 < 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  signed int return_value_pqPutInt_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_pqPutInt_4=pqPutInt((signed int)fnid, (unsigned long int)4, conn);
    tmp_if_expr_5 = return_value_pqPutInt_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int return_value_pqPutInt_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_pqPutInt_6=pqPutInt(nargs, (unsigned long int)4, conn);
    tmp_if_expr_7 = return_value_pqPutInt_6 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_13;
  signed int return_value_pqFlush_12;
  _Bool tmp_if_expr_16;
  signed int return_value_pqReadData_15;
  signed int return_value_pqGetc_18;
  signed int return_value_pqGetErrorNotice2_25;
  signed int return_value_getNotify_26;
  signed int return_value_pqGetErrorNotice2_27;
  struct pg_result *return_value_pqPrepareAsyncResult_28;
  struct pg_result *return_value_PQmakeEmptyPGresult_29;
  char *return_value_libpq_gettext_30;
  struct pg_result *return_value_pqPrepareAsyncResult_31;
  if(tmp_if_expr_7)
  {
    pqHandleSendFailure(conn);
    return (struct pg_result *)(void *)0;
  }

  else
  {
    i = 0;
    for( ; !(i >= nargs); i = i + 1)
    {
      signed int return_value_pqPutInt_8;
      return_value_pqPutInt_8=pqPutInt((args + (signed long int)i)->len, (unsigned long int)4, conn);
      if(!(return_value_pqPutInt_8 == 0))
      {
        pqHandleSendFailure(conn);
        return (struct pg_result *)(void *)0;
      }

      if(!((args + (signed long int)i)->isint == 0))
      {
        signed int return_value_pqPutInt_9;
        return_value_pqPutInt_9=pqPutInt((args + (signed long int)i)->u.integer, (unsigned long int)4, conn);
        if(!(return_value_pqPutInt_9 == 0))
        {
          pqHandleSendFailure(conn);
          return (struct pg_result *)(void *)0;
        }

      }

      else
      {
        signed int return_value_pqPutnchar_10;
        return_value_pqPutnchar_10=pqPutnchar((char *)(args + (signed long int)i)->u.ptr, (unsigned long int)(args + (signed long int)i)->len, conn);
        if(!(return_value_pqPutnchar_10 == 0))
        {
          pqHandleSendFailure(conn);
          return (struct pg_result *)(void *)0;
        }

      }
    }
    signed int return_value_pqPutMsgEnd_11;
    return_value_pqPutMsgEnd_11=pqPutMsgEnd(conn);
    if(!(return_value_pqPutMsgEnd_11 >= 0))
      tmp_if_expr_13 = (_Bool)1;

    else
    {
      return_value_pqFlush_12=pqFlush(conn);
      tmp_if_expr_13 = return_value_pqFlush_12 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_13)
    {
      pqHandleSendFailure(conn);
      return (struct pg_result *)(void *)0;
    }

    else
    {
      while((_Bool)1)
      {
        if(!(needInput == 0))
        {
          signed int return_value_pqWait_14;
          return_value_pqWait_14=pqWait(1, 0, conn);
          if(!(return_value_pqWait_14 == 0))
            tmp_if_expr_16 = (_Bool)1;

          else
          {
            return_value_pqReadData_15=pqReadData(conn);
            tmp_if_expr_16 = return_value_pqReadData_15 < 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_16)
            goto __CPROVER_DUMP_L43;

        }

        conn->inCursor = conn->inStart;
        needInput = (char)1;
        signed int return_value_pqGetc_17;
        return_value_pqGetc_17=pqGetc(&id, conn);
        if(return_value_pqGetc_17 == 0)
        {
          switch((signed int)id)
          {
            case 86:
            {
              return_value_pqGetc_18=pqGetc(&id, conn);
              if(!(return_value_pqGetc_18 == 0))
                goto __CPROVER_DUMP_L42;

              if((signed int)id == 71)
              {
                signed int return_value_pqGetInt_19;
                return_value_pqGetInt_19=pqGetInt(actual_result_len, (unsigned long int)4, conn);
                if(!(return_value_pqGetInt_19 == 0))
                  goto __CPROVER_DUMP_L42;

                if(!(result_is_int == 0))
                {
                  signed int return_value_pqGetInt_20;
                  return_value_pqGetInt_20=pqGetInt(result_buf, (unsigned long int)4, conn);
                  if(!(return_value_pqGetInt_20 == 0))
                    goto __CPROVER_DUMP_L42;

                }

                else
                {
                  signed int return_value_pqGetnchar_21;
                  return_value_pqGetnchar_21=pqGetnchar((char *)result_buf, (unsigned long int)*actual_result_len, conn);
                  if(!(return_value_pqGetnchar_21 == 0))
                    goto __CPROVER_DUMP_L42;

                }
                signed int return_value_pqGetc_22;
                return_value_pqGetc_22=pqGetc(&id, conn);
                if(!(return_value_pqGetc_22 == 0))
                  goto __CPROVER_DUMP_L42;

              }

              if((signed int)id == 48)
                status = (enum anonymous_20)PGRES_COMMAND_OK;

              else
              {
                char *return_value_libpq_gettext_23;
                return_value_libpq_gettext_23=libpq_gettext("protocol error: id=0x%x\n");
                printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_23, id);
                pqSaveErrorResult(conn);
                conn->inStart = conn->inCursor;
                struct pg_result *return_value_pqPrepareAsyncResult_24;
                return_value_pqPrepareAsyncResult_24=pqPrepareAsyncResult(conn);
                return return_value_pqPrepareAsyncResult_24;
              }
              break;
            }
            case 69:
            {
              return_value_pqGetErrorNotice2_25=pqGetErrorNotice2(conn, (char)1);
              if(!(return_value_pqGetErrorNotice2_25 == 0))
                goto __CPROVER_DUMP_L42;

              status = (enum anonymous_20)PGRES_FATAL_ERROR;
              break;
            }
            case 65:
            {
              return_value_getNotify_26=getNotify(conn);
              if(!(return_value_getNotify_26 == 0))
                goto __CPROVER_DUMP_L42;

              break;
            }
            case 78:
            {
              return_value_pqGetErrorNotice2_27=pqGetErrorNotice2(conn, (char)0);
              if(!(return_value_pqGetErrorNotice2_27 == 0))
                goto __CPROVER_DUMP_L42;

              break;
            }
            case 90:
            {
              conn->inStart = conn->inCursor;
              if(!(conn->result == ((struct pg_result *)NULL)))
              {
                return_value_pqPrepareAsyncResult_28=pqPrepareAsyncResult(conn);
                return return_value_pqPrepareAsyncResult_28;
              }

              return_value_PQmakeEmptyPGresult_29=PQmakeEmptyPGresult(conn, status);
              return return_value_PQmakeEmptyPGresult_29;
            }
            default:
            {
              return_value_libpq_gettext_30=libpq_gettext("protocol error: id=0x%x\n");
              printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_30, id);
              pqSaveErrorResult(conn);
              conn->inStart = conn->inCursor;
              return_value_pqPrepareAsyncResult_31=pqPrepareAsyncResult(conn);
              return return_value_pqPrepareAsyncResult_31;
            }
          }
          conn->inStart = conn->inCursor;
          needInput = (char)0;
        }


      __CPROVER_DUMP_L42:
        ;
      }

    __CPROVER_DUMP_L43:
      ;
      pqSaveErrorResult(conn);
      struct pg_result *return_value_pqPrepareAsyncResult_32;
      return_value_pqPrepareAsyncResult_32=pqPrepareAsyncResult(conn);
      return return_value_pqPrepareAsyncResult_32;
    }
  }
}

// pqFunctionCall3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 564
extern struct pg_result * pqFunctionCall3(struct pg_conn *conn, unsigned int fnid, signed int *result_buf, signed int *actual_result_len, signed int result_is_int, const struct anonymous_33 *args, signed int nargs)
{
  char needInput = (char)0;
  enum anonymous_20 status = (enum anonymous_20)PGRES_FATAL_ERROR;
  char id;
  signed int msgLength;
  signed int avail;
  signed int i;
  signed int return_value_pqPutMsgStart_1;
  return_value_pqPutMsgStart_1=pqPutMsgStart((char)70, (char)0, conn);
  _Bool tmp_if_expr_3;
  signed int return_value_pqPutInt_2;
  if(!(return_value_pqPutMsgStart_1 >= 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_pqPutInt_2=pqPutInt((signed int)fnid, (unsigned long int)4, conn);
    tmp_if_expr_3 = return_value_pqPutInt_2 < 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  signed int return_value_pqPutInt_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_pqPutInt_4=pqPutInt(1, (unsigned long int)2, conn);
    tmp_if_expr_5 = return_value_pqPutInt_4 < 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int return_value_pqPutInt_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_pqPutInt_6=pqPutInt(1, (unsigned long int)2, conn);
    tmp_if_expr_7 = return_value_pqPutInt_6 < 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_9;
  signed int return_value_pqPutInt_8;
  if(tmp_if_expr_7)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value_pqPutInt_8=pqPutInt(nargs, (unsigned long int)2, conn);
    tmp_if_expr_9 = return_value_pqPutInt_8 < 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_16;
  signed int return_value_pqFlush_15;
  _Bool tmp_if_expr_19;
  signed int return_value_pqReadData_18;
  signed int return_value_pqGetInt_23;
  signed int return_value_pqGetErrorNotice3_26;
  signed int return_value_getNotify_27;
  signed int return_value_pqGetErrorNotice3_28;
  signed int return_value_getReadyForQuery_29;
  struct pg_result *return_value_pqPrepareAsyncResult_30;
  struct pg_result *return_value_PQmakeEmptyPGresult_31;
  signed int return_value_getParameterStatus_32;
  char *return_value_libpq_gettext_33;
  struct pg_result *return_value_pqPrepareAsyncResult_34;
  if(tmp_if_expr_9)
  {
    pqHandleSendFailure(conn);
    return (struct pg_result *)(void *)0;
  }

  else
  {
    i = 0;
    for( ; !(i >= nargs); i = i + 1)
    {
      signed int return_value_pqPutInt_10;
      return_value_pqPutInt_10=pqPutInt((args + (signed long int)i)->len, (unsigned long int)4, conn);
      if(!(return_value_pqPutInt_10 == 0))
      {
        pqHandleSendFailure(conn);
        return (struct pg_result *)(void *)0;
      }

      if(!((args + (signed long int)i)->len == -1))
      {
        if(!((args + (signed long int)i)->isint == 0))
        {
          signed int return_value_pqPutInt_11;
          return_value_pqPutInt_11=pqPutInt((args + (signed long int)i)->u.integer, (unsigned long int)(args + (signed long int)i)->len, conn);
          if(!(return_value_pqPutInt_11 == 0))
          {
            pqHandleSendFailure(conn);
            return (struct pg_result *)(void *)0;
          }

        }

        else
        {
          signed int return_value_pqPutnchar_12;
          return_value_pqPutnchar_12=pqPutnchar((char *)(args + (signed long int)i)->u.ptr, (unsigned long int)(args + (signed long int)i)->len, conn);
          if(!(return_value_pqPutnchar_12 == 0))
          {
            pqHandleSendFailure(conn);
            return (struct pg_result *)(void *)0;
          }

        }
      }

    }
    signed int return_value_pqPutInt_13;
    return_value_pqPutInt_13=pqPutInt(1, (unsigned long int)2, conn);
    if(!(return_value_pqPutInt_13 >= 0))
    {
      pqHandleSendFailure(conn);
      return (struct pg_result *)(void *)0;
    }

    else
    {
      signed int return_value_pqPutMsgEnd_14;
      return_value_pqPutMsgEnd_14=pqPutMsgEnd(conn);
      if(!(return_value_pqPutMsgEnd_14 >= 0))
        tmp_if_expr_16 = (_Bool)1;

      else
      {
        return_value_pqFlush_15=pqFlush(conn);
        tmp_if_expr_16 = return_value_pqFlush_15 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_16)
      {
        pqHandleSendFailure(conn);
        return (struct pg_result *)(void *)0;
      }

      else
      {
        while((_Bool)1)
        {
          if(!(needInput == 0))
          {
            signed int return_value_pqWait_17;
            return_value_pqWait_17=pqWait(1, 0, conn);
            if(!(return_value_pqWait_17 == 0))
              tmp_if_expr_19 = (_Bool)1;

            else
            {
              return_value_pqReadData_18=pqReadData(conn);
              tmp_if_expr_19 = return_value_pqReadData_18 < 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_19)
              goto __CPROVER_DUMP_L51;

          }

          needInput = (char)1;
          conn->inCursor = conn->inStart;
          signed int return_value_pqGetc_20;
          return_value_pqGetc_20=pqGetc(&id, conn);
          if(return_value_pqGetc_20 == 0)
          {
            signed int return_value_pqGetInt_21;
            return_value_pqGetInt_21=pqGetInt(&msgLength, (unsigned long int)4, conn);
            if(return_value_pqGetInt_21 == 0)
            {
              if(!(msgLength >= 4))
              {
                handleSyncLoss(conn, id, msgLength);
                break;
              }

              if(msgLength >= 30001 && !((signed int)id == 65) && !((signed int)id == 68) && !((signed int)id == 69) && !((signed int)id == 78) && !((signed int)id == 84) && !((signed int)id == 86) && !((signed int)id == 100))
              {
                handleSyncLoss(conn, id, msgLength);
                break;
              }

              msgLength = msgLength - 4;
              avail = conn->inEnd - conn->inCursor;
              if(!(avail >= msgLength))
              {
                signed int return_value_pqCheckInBufferSpace_22;
                return_value_pqCheckInBufferSpace_22=pqCheckInBufferSpace((unsigned long int)conn->inCursor + (unsigned long int)msgLength, conn);
                if(!(return_value_pqCheckInBufferSpace_22 == 0))
                {
                  handleSyncLoss(conn, id, msgLength);
                  break;
                }

                continue;
              }

              switch((signed int)id)
              {
                case 86:
                {
                  return_value_pqGetInt_23=pqGetInt(actual_result_len, (unsigned long int)4, conn);
                  if(!(return_value_pqGetInt_23 == 0))
                    goto __CPROVER_DUMP_L50;

                  if(!(*actual_result_len == -1))
                  {
                    if(!(result_is_int == 0))
                    {
                      signed int return_value_pqGetInt_24;
                      return_value_pqGetInt_24=pqGetInt(result_buf, (unsigned long int)*actual_result_len, conn);
                      if(!(return_value_pqGetInt_24 == 0))
                        goto __CPROVER_DUMP_L50;

                    }

                    else
                    {
                      signed int return_value_pqGetnchar_25;
                      return_value_pqGetnchar_25=pqGetnchar((char *)result_buf, (unsigned long int)*actual_result_len, conn);
                      if(!(return_value_pqGetnchar_25 == 0))
                        goto __CPROVER_DUMP_L50;

                    }
                  }

                  status = (enum anonymous_20)PGRES_COMMAND_OK;
                  break;
                }
                case 69:
                {
                  return_value_pqGetErrorNotice3_26=pqGetErrorNotice3(conn, (char)1);
                  if(!(return_value_pqGetErrorNotice3_26 == 0))
                    goto __CPROVER_DUMP_L50;

                  status = (enum anonymous_20)PGRES_FATAL_ERROR;
                  break;
                }
                case 65:
                {
                  return_value_getNotify_27=getNotify_link1(conn);
                  if(!(return_value_getNotify_27 == 0))
                    goto __CPROVER_DUMP_L50;

                  break;
                }
                case 78:
                {
                  return_value_pqGetErrorNotice3_28=pqGetErrorNotice3(conn, (char)0);
                  if(!(return_value_pqGetErrorNotice3_28 == 0))
                    goto __CPROVER_DUMP_L50;

                  break;
                }
                case 90:
                {
                  return_value_getReadyForQuery_29=getReadyForQuery(conn);
                  if(!(return_value_getReadyForQuery_29 == 0))
                    goto __CPROVER_DUMP_L50;

                  conn->inStart = conn->inStart + 5 + msgLength;
                  if(!(conn->result == ((struct pg_result *)NULL)))
                  {
                    return_value_pqPrepareAsyncResult_30=pqPrepareAsyncResult(conn);
                    return return_value_pqPrepareAsyncResult_30;
                  }

                  return_value_PQmakeEmptyPGresult_31=PQmakeEmptyPGresult(conn, status);
                  return return_value_PQmakeEmptyPGresult_31;
                }
                case 83:
                {
                  return_value_getParameterStatus_32=getParameterStatus(conn);
                  if(!(return_value_getParameterStatus_32 == 0))
                    goto __CPROVER_DUMP_L50;

                  break;
                }
                default:
                {
                  return_value_libpq_gettext_33=libpq_gettext("protocol error: id=0x%x\n");
                  printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_33, id);
                  pqSaveErrorResult(conn);
                  conn->inStart = conn->inStart + 5 + msgLength;
                  return_value_pqPrepareAsyncResult_34=pqPrepareAsyncResult(conn);
                  return return_value_pqPrepareAsyncResult_34;
                }
              }
              conn->inStart = conn->inStart + 5 + msgLength;
              needInput = (char)0;
            }

          }


        __CPROVER_DUMP_L50:
          ;
        }

      __CPROVER_DUMP_L51:
        ;
        pqSaveErrorResult(conn);
        struct pg_result *return_value_pqPrepareAsyncResult_35;
        return_value_pqPrepareAsyncResult_35=pqPrepareAsyncResult(conn);
        return return_value_pqPrepareAsyncResult_35;
      }
    }
  }
}

// pqGetCopyData2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 545
extern signed int pqGetCopyData2(struct pg_conn *conn, char **buffer, signed int async)
{
  char found;
  signed int msgLength;
  signed int tmp_post_1;
  signed int return_value_strncmp_2;
  void *return_value_malloc_3;
  _Bool tmp_if_expr_7;
  signed int return_value_pqReadData_6;
  do
  {
    conn->inCursor = conn->inStart;
    found = (char)0;
    while(!(conn->inCursor >= conn->inEnd))
    {
      char c;
      tmp_post_1 = conn->inCursor;
      conn->inCursor = conn->inCursor + 1;
      c = conn->inBuffer[(signed long int)tmp_post_1];
      if((signed int)c == 10)
      {
        found = (char)1;
        break;
      }

    }
    if(!(found == 0))
    {
      msgLength = conn->inCursor - conn->inStart;
      if(msgLength == 3)
      {
        return_value_strncmp_2=strncmp(&conn->inBuffer[(signed long int)conn->inStart], "\\.\n", (unsigned long int)3);
        if(return_value_strncmp_2 == 0)
        {
          conn->inStart = conn->inCursor;
          conn->asyncStatus = (enum anonymous_9)PGASYNC_BUSY;
          return -1;
        }

      }

      return_value_malloc_3=malloc((unsigned long int)(msgLength + 1));
      *buffer = (char *)return_value_malloc_3;
      if(*buffer == ((char *)NULL))
      {
        char *return_value_libpq_gettext_4;
        return_value_libpq_gettext_4=libpq_gettext("out of memory\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_4);
        return -2;
      }

      memcpy((void *)*buffer, (const void *)&conn->inBuffer[(signed long int)conn->inStart], (unsigned long int)msgLength);
      (*buffer)[(signed long int)msgLength] = (char)0;
      conn->inStart = conn->inCursor;
      return msgLength;
    }


  nodata:
    ;
    if(!(async == 0))
      return 0;

    signed int return_value_pqWait_5;
    return_value_pqWait_5=pqWait(1, 0, conn);
    if(!(return_value_pqWait_5 == 0))
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_pqReadData_6=pqReadData(conn);
      tmp_if_expr_7 = return_value_pqReadData_6 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      return -2;

  }
  while((_Bool)1);
}

// pqGetCopyData3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 560
extern signed int pqGetCopyData3(struct pg_conn *conn, char **buffer, signed int async)
{
  signed int msgLength;
  _Bool tmp_if_expr_3;
  signed int return_value_pqReadData_2;
  do
  {
    msgLength=getCopyDataMessage(conn);
    if(!(msgLength >= 0))
      return msgLength;

    if(msgLength == 0)
    {
      if(!(async == 0))
        return 0;

      signed int return_value_pqWait_1;
      return_value_pqWait_1=pqWait(1, 0, conn);
      if(!(return_value_pqWait_1 == 0))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_pqReadData_2=pqReadData(conn);
        tmp_if_expr_3 = return_value_pqReadData_2 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        return -2;

      continue;
    }

    msgLength = msgLength - 4;
    if(msgLength >= 1)
    {
      void *return_value_malloc_4;
      return_value_malloc_4=malloc((unsigned long int)(msgLength + 1));
      *buffer = (char *)return_value_malloc_4;
      if(*buffer == ((char *)NULL))
      {
        char *return_value_libpq_gettext_5;
        return_value_libpq_gettext_5=libpq_gettext("out of memory\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_5);
        return -2;
      }

      memcpy((void *)*buffer, (const void *)&conn->inBuffer[(signed long int)conn->inCursor], (unsigned long int)msgLength);
      (*buffer)[(signed long int)msgLength] = (char)0;
      conn->inStart = conn->inCursor + msgLength;
      return msgLength;
    }

    conn->inStart = conn->inCursor;
  }
  while((_Bool)1);
}

// pqGetErrorNotice2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol2.c line 963
static signed int pqGetErrorNotice2(struct pg_conn *conn, char isError)
{
  struct pg_result *res = (struct pg_result *)(void *)0;
  struct PQExpBufferData workBuf;
  char *startp;
  char *splitp;
  initPQExpBuffer(&workBuf);
  signed int return_value_pqGets_1;
  return_value_pqGets_1=pqGets(&workBuf, conn);
  char *tmp_post_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  _Bool tmp_if_expr_5;
  char *return_value_libpq_gettext_4;
  if(return_value_pqGets_1 == 0)
  {
    res=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_EMPTY_QUERY);
    if(!(res == ((struct pg_result *)NULL)))
    {
      res->resultStatus = (enum anonymous_20)(isError != 0 ? PGRES_FATAL_ERROR : PGRES_NONFATAL_ERROR);
      res->errMsg=pqResultStrdup(res, workBuf.data);
    }

    for( ; workBuf.len >= 1ul; workBuf.data[(signed long int)workBuf.len] = (char)0)
    {
      if(!((signed int)workBuf.data[-1l + (signed long int)workBuf.len] == 10))
        break;

      workBuf.len = workBuf.len - 1ul;
    }
    splitp=strstr(workBuf.data, ":  ");
    if(!(splitp == ((char *)NULL)))
    {
      *splitp = (char)0;
      pqSaveMessageField(res, (char)83, workBuf.data);
      startp = splitp + (signed long int)3;
    }

    else
      startp = workBuf.data;
    splitp=strchr(startp, 10);
    if(!(splitp == ((char *)NULL)))
    {
      tmp_post_2 = splitp;
      splitp = splitp + 1l;
      *tmp_post_2 = (char)0;
      pqSaveMessageField(res, (char)77, startp);
      for( ; !(*splitp == 0); splitp = splitp + 1l)
      {
        return_value___ctype_b_loc_3=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)(unsigned char)*splitp]) == 0)
          break;

      }
      pqSaveMessageField(res, (char)68, splitp);
    }

    else
      pqSaveMessageField(res, (char)77, startp);
    if(!(isError == 0))
    {
      pqClearAsyncResult(conn);
      conn->result = res;
      resetPQExpBuffer(&conn->errorMessage);
      if(!(workBuf.maxlen == 0ul) && !(res == ((struct pg_result *)NULL)))
        tmp_if_expr_5 = res->errMsg != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        appendPQExpBufferStr(&conn->errorMessage, res->errMsg);

      else
      {
        return_value_libpq_gettext_4=libpq_gettext("out of memory");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_4);
      }
      if((signed int)conn->xactStatus == PQTRANS_INTRANS)
        conn->xactStatus = (enum anonymous_3)PQTRANS_INERROR;

    }

    else
      if(!(res == ((struct pg_result *)NULL)))
      {
        if(!(res->noticeHooks.noticeRec == ((void (*)(void *, const struct pg_result *))NULL)))
          res->noticeHooks.noticeRec(res->noticeHooks.noticeRecArg, res);

        PQclear(res);
      }

    termPQExpBuffer(&workBuf);
    return 0;
  }

  else
  {

  failure:
    ;
    if(!(res == ((struct pg_result *)NULL)))
      PQclear(res);

    termPQExpBuffer(&workBuf);
    return -1;
  }
}

// pqGetErrorNotice3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 559
extern signed int pqGetErrorNotice3(struct pg_conn *conn, char isError)
{
  struct pg_result *res = (struct pg_result *)(void *)0;
  struct PQExpBufferData workBuf;
  char id;
  const char *val;
  const char *querytext = (const char *)(void *)0;
  signed int querypos = 0;
  initPQExpBuffer(&workBuf);
  res=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_EMPTY_QUERY);
  if(!(res == ((struct pg_result *)NULL)))
    res->resultStatus = (enum anonymous_20)(isError != 0 ? PGRES_FATAL_ERROR : PGRES_NONFATAL_ERROR);

  do
  {
    signed int return_value_pqGetc_1;
    return_value_pqGetc_1=pqGetc(&id, conn);
    if(!(return_value_pqGetc_1 == 0))
      goto fail;

    if((signed int)id == 0)
      break;

    signed int return_value_pqGets_2;
    return_value_pqGets_2=pqGets(&workBuf, conn);
    if(!(return_value_pqGets_2 == 0))
      goto fail;

    pqSaveMessageField(res, id, workBuf.data);
  }
  while((_Bool)1);
  resetPQExpBuffer(&workBuf);
  val=PQresultErrorField(res, 83);
  if(!(val == ((const char *)NULL)))
    appendPQExpBuffer(&workBuf, "%s:  ", val);

  val=PQresultErrorField(res, 67);
  if(!(val == ((const char *)NULL)))
  {
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(val);
    if(!(return_value_strlen_3 >= sizeof(char [6l]) /*6ul*/ ))
      strcpy(conn->last_sqlstate, val);

    if((signed int)conn->verbosity == PQERRORS_VERBOSE)
      appendPQExpBuffer(&workBuf, "%s: ", val);

  }

  val=PQresultErrorField(res, 77);
  if(!(val == ((const char *)NULL)))
    appendPQExpBufferStr(&workBuf, val);

  val=PQresultErrorField(res, 80);
  _Bool tmp_if_expr_5;
  if(!(val == ((const char *)NULL)))
  {
    if(!((signed int)conn->verbosity == PQERRORS_TERSE))
      tmp_if_expr_5 = conn->last_query != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      querytext = conn->last_query;
      querypos=atoi(val);
    }

    else
    {
      char *return_value_libpq_gettext_4;
      return_value_libpq_gettext_4=libpq_gettext(" at character %s");
      appendPQExpBuffer(&workBuf, return_value_libpq_gettext_4, val);
    }
  }

  else
  {
    val=PQresultErrorField(res, 112);
    if(!(val == ((const char *)NULL)))
    {
      querytext=PQresultErrorField(res, 113);
      if(!(querytext == ((const char *)NULL)) && !((signed int)conn->verbosity == PQERRORS_TERSE))
        querypos=atoi(val);

      else
      {
        char *return_value_libpq_gettext_6;
        return_value_libpq_gettext_6=libpq_gettext(" at character %s");
        appendPQExpBuffer(&workBuf, return_value_libpq_gettext_6, val);
      }
    }

  }
  appendPQExpBufferChar(&workBuf, (char)10);
  char *return_value_libpq_gettext_7;
  char *return_value_libpq_gettext_8;
  char *return_value_libpq_gettext_9;
  char *return_value_libpq_gettext_10;
  if(!((signed int)conn->verbosity == PQERRORS_TERSE))
  {
    if(querypos >= 1 && !(querytext == ((const char *)NULL)))
      reportErrorPosition(&workBuf, querytext, querypos, conn->client_encoding);

    val=PQresultErrorField(res, 68);
    if(!(val == ((const char *)NULL)))
    {
      return_value_libpq_gettext_7=libpq_gettext("DETAIL:  %s\n");
      appendPQExpBuffer(&workBuf, return_value_libpq_gettext_7, val);
    }

    val=PQresultErrorField(res, 72);
    if(!(val == ((const char *)NULL)))
    {
      return_value_libpq_gettext_8=libpq_gettext("HINT:  %s\n");
      appendPQExpBuffer(&workBuf, return_value_libpq_gettext_8, val);
    }

    val=PQresultErrorField(res, 113);
    if(!(val == ((const char *)NULL)))
    {
      return_value_libpq_gettext_9=libpq_gettext("QUERY:  %s\n");
      appendPQExpBuffer(&workBuf, return_value_libpq_gettext_9, val);
    }

    val=PQresultErrorField(res, 87);
    if(!(val == ((const char *)NULL)))
    {
      return_value_libpq_gettext_10=libpq_gettext("CONTEXT:  %s\n");
      appendPQExpBuffer(&workBuf, return_value_libpq_gettext_10, val);
    }

  }

  char *return_value_libpq_gettext_11;
  char *return_value_libpq_gettext_12;
  char *return_value_libpq_gettext_13;
  char *return_value_libpq_gettext_14;
  char *return_value_libpq_gettext_15;
  if((signed int)conn->verbosity == PQERRORS_VERBOSE)
  {
    val=PQresultErrorField(res, 115);
    if(!(val == ((const char *)NULL)))
    {
      return_value_libpq_gettext_11=libpq_gettext("SCHEMA NAME:  %s\n");
      appendPQExpBuffer(&workBuf, return_value_libpq_gettext_11, val);
    }

    val=PQresultErrorField(res, 116);
    if(!(val == ((const char *)NULL)))
    {
      return_value_libpq_gettext_12=libpq_gettext("TABLE NAME:  %s\n");
      appendPQExpBuffer(&workBuf, return_value_libpq_gettext_12, val);
    }

    val=PQresultErrorField(res, 99);
    if(!(val == ((const char *)NULL)))
    {
      return_value_libpq_gettext_13=libpq_gettext("COLUMN NAME:  %s\n");
      appendPQExpBuffer(&workBuf, return_value_libpq_gettext_13, val);
    }

    val=PQresultErrorField(res, 100);
    if(!(val == ((const char *)NULL)))
    {
      return_value_libpq_gettext_14=libpq_gettext("DATATYPE NAME:  %s\n");
      appendPQExpBuffer(&workBuf, return_value_libpq_gettext_14, val);
    }

    val=PQresultErrorField(res, 110);
    if(!(val == ((const char *)NULL)))
    {
      return_value_libpq_gettext_15=libpq_gettext("CONSTRAINT NAME:  %s\n");
      appendPQExpBuffer(&workBuf, return_value_libpq_gettext_15, val);
    }

  }

  char *return_value_libpq_gettext_17;
  char *return_value_libpq_gettext_18;
  if((signed int)conn->verbosity == PQERRORS_VERBOSE)
  {
    const char *valf;
    const char *vall;
    valf=PQresultErrorField(res, 70);
    vall=PQresultErrorField(res, 76);
    val=PQresultErrorField(res, 82);
    if(!(valf == ((const char *)NULL)) || !(vall == ((const char *)NULL)) || !(val == ((const char *)NULL)))
    {
      char *return_value_libpq_gettext_16;
      return_value_libpq_gettext_16=libpq_gettext("LOCATION:  ");
      appendPQExpBufferStr(&workBuf, return_value_libpq_gettext_16);
      if(!(val == ((const char *)NULL)))
      {
        return_value_libpq_gettext_17=libpq_gettext("%s, ");
        appendPQExpBuffer(&workBuf, return_value_libpq_gettext_17, val);
      }

      if(!(valf == ((const char *)NULL)) && !(vall == ((const char *)NULL)))
      {
        return_value_libpq_gettext_18=libpq_gettext("%s:%s");
        appendPQExpBuffer(&workBuf, return_value_libpq_gettext_18, valf, vall);
      }

      appendPQExpBufferChar(&workBuf, (char)10);
    }

  }

  char *return_value_libpq_gettext_19;
  if(!(isError == 0))
  {
    if(!(res == ((struct pg_result *)NULL)))
      res->errMsg=pqResultStrdup(res, workBuf.data);

    pqClearAsyncResult(conn);
    conn->result = res;
    if(workBuf.maxlen == 0ul)
    {
      return_value_libpq_gettext_19=libpq_gettext("out of memory");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_19);
    }

    else
      appendPQExpBufferStr(&conn->errorMessage, workBuf.data);
  }

  else
    if(!(res == ((struct pg_result *)NULL)))
    {
      res->errMsg = workBuf.data;
      if(!(res->noticeHooks.noticeRec == ((void (*)(void *, const struct pg_result *))NULL)))
        res->noticeHooks.noticeRec(res->noticeHooks.noticeRecArg, res);

      PQclear(res);
    }

  termPQExpBuffer(&workBuf);
  return 0;

fail:
  ;
  PQclear(res);
  termPQExpBuffer(&workBuf);
  return -1;
}

// pqGetHomeDirectory
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5856
extern char pqGetHomeDirectory(char *buf, signed int bufsize)
{
  char pwdbuf[8192l];
  struct passwd pwdstr;
  struct passwd *pwd = (struct passwd *)(void *)0;
  unsigned int return_value_geteuid_1;
  return_value_geteuid_1=geteuid();
  pqGetpwuid(return_value_geteuid_1, &pwdstr, pwdbuf, sizeof(char [8192l]) /*8192ul*/ , &pwd);
  if(pwd == ((struct passwd *)NULL))
    return (char)0;

  else
  {
    strlcpy(buf, pwd->pw_dir, (unsigned long int)bufsize);
    return (char)1;
  }
}

// pqGetInt
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 586
extern signed int pqGetInt(signed int *result, unsigned long int bytes, struct pg_conn *conn)
{
  unsigned short int tmp2;
  unsigned int tmp4;
  unsigned short int return_value_ntohs_1;
  unsigned int return_value_ntohl_2;
  switch(bytes)
  {
    case (unsigned long int)2:
    {
      if(!(conn->inEnd >= 2 + conn->inCursor))
        return -1;

      memcpy((void *)&tmp2, (const void *)(conn->inBuffer + (signed long int)conn->inCursor), (unsigned long int)2);
      conn->inCursor = conn->inCursor + 2;
      return_value_ntohs_1=ntohs(tmp2);
      *result = (signed int)return_value_ntohs_1;
      break;
    }
    case (unsigned long int)4:
    {
      if(!(conn->inEnd >= 4 + conn->inCursor))
        return -1;

      memcpy((void *)&tmp4, (const void *)(conn->inBuffer + (signed long int)conn->inCursor), (unsigned long int)4);
      conn->inCursor = conn->inCursor + 4;
      return_value_ntohl_2=ntohl(tmp4);
      *result = (signed int)return_value_ntohl_2;
      break;
    }
    default:
    {
      pqInternalNotice(&conn->noticeHooks, "integer of size %lu not supported by pqGetInt", (unsigned long int)bytes);
      return -1;
    }
  }
  if(!(conn->Pfdebug == ((struct _IO_FILE *)NULL)))
    fprintf(conn->Pfdebug, "From backend (#%lu)> %d\n", (unsigned long int)bytes, *result);

  return 0;
}

// pqGetc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 578
extern signed int pqGetc(char *result, struct pg_conn *conn)
{
  signed int tmp_post_1;
  if(conn->inCursor >= conn->inEnd)
    return -1;

  else
  {
    tmp_post_1 = conn->inCursor;
    conn->inCursor = conn->inCursor + 1;
    *result = conn->inBuffer[(signed long int)tmp_post_1];
    if(!(conn->Pfdebug == ((struct _IO_FILE *)NULL)))
      fprintf(conn->Pfdebug, "From backend> %c\n", *result);

    return 0;
  }
}

// pqGetline2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 546
extern signed int pqGetline2(struct pg_conn *conn, char *s, signed int maxlen)
{
  signed int result = 1;
  _Bool tmp_if_expr_1;
  if(conn->sock == -1)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)conn->asyncStatus != PGASYNC_COPY_OUT ? (_Bool)1 : (_Bool)0;
  signed int tmp_post_2;
  char *tmp_post_3;
  _Bool tmp_if_expr_6;
  signed int return_value_pqReadData_5;
  if(tmp_if_expr_1)
  {
    *s = (char)0;
    return -1;
  }

  else
  {
    while(maxlen >= 2)
      if(!(conn->inStart >= conn->inEnd))
      {
        char c;
        tmp_post_2 = conn->inStart;
        conn->inStart = conn->inStart + 1;
        c = conn->inBuffer[(signed long int)tmp_post_2];
        if((signed int)c == 10)
        {
          result = 0;
          break;
        }

        tmp_post_3 = s;
        s = s + 1l;
        *tmp_post_3 = c;
        maxlen = maxlen - 1;
      }

      else
      {
        signed int return_value_pqWait_4;
        return_value_pqWait_4=pqWait(1, 0, conn);
        if(!(return_value_pqWait_4 == 0))
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value_pqReadData_5=pqReadData(conn);
          tmp_if_expr_6 = return_value_pqReadData_5 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
        {
          result = -1;
          break;
        }

      }
    *s = (char)0;
    return result;
  }
}

// pqGetline3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 561
extern signed int pqGetline3(struct pg_conn *conn, char *s, signed int maxlen)
{
  signed int status;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  if(conn->sock == -1)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    if(!((signed int)conn->asyncStatus == PGASYNC_COPY_OUT))
      tmp_if_expr_2 = (signed int)conn->asyncStatus != PGASYNC_COPY_BOTH ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = conn->copy_is_binary != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_4)
  {
    char *return_value_libpq_gettext_1;
    return_value_libpq_gettext_1=libpq_gettext("PQgetline: not doing text COPY OUT\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
    *s = (char)0;
    return -1;
  }

  _Bool tmp_if_expr_7;
  signed int return_value_pqReadData_6;
  do
  {
    status=PQgetlineAsync(conn, s, maxlen - 1);
    if(!(status == 0))
      break;

    signed int return_value_pqWait_5;
    return_value_pqWait_5=pqWait(1, 0, conn);
    if(!(return_value_pqWait_5 == 0))
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_pqReadData_6=pqReadData(conn);
      tmp_if_expr_7 = return_value_pqReadData_6 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
    {
      *s = (char)0;
      return -1;
    }

  }
  while((_Bool)1);
  if(!(status >= 0))
  {
    strcpy(s, "\\.");
    return 0;
  }

  else
    if((signed int)s[(signed long int)(status + -1)] == 10)
    {
      s[(signed long int)(status - 1)] = (char)0;
      return 0;
    }

    else
    {
      s[(signed long int)status] = (char)0;
      return 1;
    }
}

// pqGetlineAsync2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 547
extern signed int pqGetlineAsync2(struct pg_conn *conn, char *buffer, signed int bufsize)
{
  signed int avail;
  signed int tmp_post_1;
  char *tmp_post_2;
  if(!((signed int)conn->asyncStatus == PGASYNC_COPY_OUT))
    return -1;

  else
  {
    conn->inCursor = conn->inStart;
    avail = bufsize;
    while(avail >= 1)
    {
      if(conn->inCursor >= conn->inEnd)
        break;

      char c;
      tmp_post_1 = conn->inCursor;
      conn->inCursor = conn->inCursor + 1;
      c = conn->inBuffer[(signed long int)tmp_post_1];
      tmp_post_2 = buffer;
      buffer = buffer + 1l;
      *tmp_post_2 = c;
      avail = avail - 1;
      if((signed int)c == 10)
      {
        conn->inStart = conn->inCursor;
        if(bufsize + -avail == 3)
        {
          if((signed int)buffer[-3l] == 92)
          {
            if((signed int)buffer[-2l] == 46)
              return -1;

          }

        }

        return bufsize - avail;
      }

    }
    if(avail == 0 && bufsize >= 4)
    {
      conn->inStart = conn->inCursor - 3;
      return bufsize - 3;
    }

    else
      return 0;
  }
}

// pqGetlineAsync3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 562
extern signed int pqGetlineAsync3(struct pg_conn *conn, char *buffer, signed int bufsize)
{
  signed int msgLength;
  signed int avail;
  if(!((signed int)conn->asyncStatus == PGASYNC_COPY_OUT))
  {
    if((signed int)conn->asyncStatus == PGASYNC_COPY_BOTH)
      goto __CPROVER_DUMP_L1;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    msgLength=getCopyDataMessage(conn);
    if(!(msgLength >= 0))
      return -1;

    else
      if(msgLength == 0)
        return 0;

      else
      {
        conn->inCursor = conn->inCursor + conn->copy_already_done;
        avail = (msgLength - 4) - conn->copy_already_done;
        if(bufsize >= avail)
        {
          memcpy((void *)buffer, (const void *)&conn->inBuffer[(signed long int)conn->inCursor], (unsigned long int)avail);
          conn->inStart = conn->inCursor + avail;
          conn->copy_already_done = 0;
          return avail;
        }

        else
        {
          memcpy((void *)buffer, (const void *)&conn->inBuffer[(signed long int)conn->inCursor], (unsigned long int)bufsize);
          conn->copy_already_done = conn->copy_already_done + bufsize;
          return bufsize;
        }
      }
  }
}

// pqGetnchar
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 583
extern signed int pqGetnchar(char *s, unsigned long int len, struct pg_conn *conn)
{
  if(!((unsigned long int)(conn->inEnd + -conn->inCursor) >= len))
    return -1;

  else
  {
    memcpy((void *)s, (const void *)(conn->inBuffer + (signed long int)conn->inCursor), len);
    conn->inCursor = conn->inCursor + (signed int)len;
    if(!(conn->Pfdebug == ((struct _IO_FILE *)NULL)))
    {
      fprintf(conn->Pfdebug, "From backend (%lu)> ", (unsigned long int)len);
      fputnbytes(conn->Pfdebug, s, len);
      fprintf(conn->Pfdebug, "\n");
    }

    return 0;
  }
}

// pqGetpwuid
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 435
extern signed int pqGetpwuid(unsigned int uid, struct passwd *resultbuf, char *buffer, unsigned long int buflen, struct passwd **result)
{
  signed int return_value_getpwuid_r_1;
  return_value_getpwuid_r_1=getpwuid_r(uid, resultbuf, buffer, buflen, result);
  return return_value_getpwuid_r_1;
}

// pqGets
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 168
extern signed int pqGets(struct PQExpBufferData *buf, struct pg_conn *conn)
{
  signed int return_value_pqGets_internal_1;
  return_value_pqGets_internal_1=pqGets_internal(buf, conn, (char)1);
  return return_value_pqGets_internal_1;
}

// pqGets_append
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 581
extern signed int pqGets_append(struct PQExpBufferData *buf, struct pg_conn *conn)
{
  signed int return_value_pqGets_internal_1;
  return_value_pqGets_internal_1=pqGets_internal(buf, conn, (char)0);
  return return_value_pqGets_internal_1;
}

// pqGets_internal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 137
static signed int pqGets_internal(struct PQExpBufferData *buf, struct pg_conn *conn, char resetbuffer)
{
  char *inBuffer = conn->inBuffer;
  signed int inCursor = conn->inCursor;
  signed int inEnd = conn->inEnd;
  signed int slen;
  for( ; !(inCursor >= inEnd); inCursor = inCursor + 1)
    if(inBuffer[(signed long int)inCursor] == 0)
      break;

  if(inCursor >= inEnd)
    return -1;

  else
  {
    slen = inCursor - conn->inCursor;
    if(!(resetbuffer == 0))
      resetPQExpBuffer(buf);

    appendBinaryPQExpBuffer(buf, inBuffer + (signed long int)conn->inCursor, (unsigned long int)slen);
    inCursor = inCursor + 1;
    conn->inCursor = inCursor;
    if(!(conn->Pfdebug == ((struct _IO_FILE *)NULL)))
      fprintf(conn->Pfdebug, "From backend> \"%s\"\n", buf->data);

    return 0;
  }
}

// pqHandleSendFailure
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1561
extern void pqHandleSendFailure(struct pg_conn *conn)
{
  signed int return_value_pqReadData_1;
  do
  {
    return_value_pqReadData_1=pqReadData(conn);
    if(!(return_value_pqReadData_1 >= 1))
      break;

  }
  while((_Bool)1);
  parseInput(conn);
}

// pqInternalNotice
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 800
extern void pqInternalNotice(const struct anonymous_8 *hooks, const char *fmt, ...)
{
  char msgBuf[1024l];
  void **args;
  struct pg_result *res;
  if(!(hooks->noticeRec == ((void (*)(void *, const struct pg_result *))NULL)))
  {
    args = (void **)&fmt;
    char *return_value_libpq_gettext_1;
    return_value_libpq_gettext_1=libpq_gettext(fmt);
    vsnprintf(msgBuf, sizeof(char [1024l]) /*1024ul*/ , return_value_libpq_gettext_1, args);
    args = ((void **)NULL);
    msgBuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
    res=PQmakeEmptyPGresult((struct pg_conn *)(void *)0, (enum anonymous_20)PGRES_NONFATAL_ERROR);
    if(!(res == ((struct pg_result *)NULL)))
    {
      res->noticeHooks = *hooks;
      pqSaveMessageField(res, (char)77, msgBuf);
      char *return_value_libpq_gettext_2;
      return_value_libpq_gettext_2=libpq_gettext("NOTICE");
      pqSaveMessageField(res, (char)83, return_value_libpq_gettext_2);
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(msgBuf);
      void *return_value_pqResultAlloc_4;
      return_value_pqResultAlloc_4=pqResultAlloc(res, return_value_strlen_3 + (unsigned long int)2, (char)0);
      res->errMsg = (char *)return_value_pqResultAlloc_4;
      if(!(res->errMsg == ((char *)NULL)))
      {
        sprintf(res->errMsg, "%s\n", (const void *)msgBuf);
        res->noticeHooks.noticeRec(res->noticeHooks.noticeRecArg, res);
      }

      PQclear(res);
    }

  }

}

// pqPacketSend
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 497
extern signed int pqPacketSend(struct pg_conn *conn, char pack_type, const void *buf, unsigned long int buf_len)
{
  signed int return_value_pqPutMsgStart_1;
  return_value_pqPutMsgStart_1=pqPutMsgStart(pack_type, (char)1, conn);
  if(!(return_value_pqPutMsgStart_1 == 0))
    return -1;

  else
  {
    signed int return_value_pqPutnchar_2;
    return_value_pqPutnchar_2=pqPutnchar((const char *)buf, buf_len, conn);
    if(!(return_value_pqPutnchar_2 == 0))
      return -1;

    else
    {
      signed int return_value_pqPutMsgEnd_3;
      return_value_pqPutMsgEnd_3=pqPutMsgEnd(conn);
      if(!(return_value_pqPutMsgEnd_3 == 0))
        return -1;

      else
      {
        signed int return_value_pqFlush_4;
        return_value_pqFlush_4=pqFlush(conn);
        if(!(return_value_pqFlush_4 == 0))
          return -1;

        else
          return 0;
      }
    }
  }
}

// pqParseInput2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 544
extern void pqParseInput2(struct pg_conn *conn)
{
  char id;
  signed int return_value_pqGets_5;
  signed int return_value_pqGetErrorNotice2_7;
  signed int return_value_pqGetc_8;
  signed int return_value_pqGetInt_10;
  signed int return_value_pqGetInt_11;
  signed int return_value_pqGets_12;
  char *return_value_libpq_gettext_16;
  while((_Bool)1)
  {
    if((signed int)conn->asyncStatus == PGASYNC_COPY_OUT)
      goto __CPROVER_DUMP_L47;

    conn->inCursor = conn->inStart;
    signed int return_value_pqGetc_1;
    return_value_pqGetc_1=pqGetc(&id, conn);
    if(!(return_value_pqGetc_1 == 0))
      goto __CPROVER_DUMP_L47;

    if((signed int)id == 65)
    {
      signed int return_value_getNotify_2;
      return_value_getNotify_2=getNotify(conn);
      if(!(return_value_getNotify_2 == 0))
        goto __CPROVER_DUMP_L47;

    }

    else
      if((signed int)id == 78)
      {
        signed int return_value_pqGetErrorNotice2_3;
        return_value_pqGetErrorNotice2_3=pqGetErrorNotice2(conn, (char)0);
        if(!(return_value_pqGetErrorNotice2_3 == 0))
          goto __CPROVER_DUMP_L47;

      }

      else
        if(!((signed int)conn->asyncStatus == PGASYNC_BUSY))
        {
          if(!((signed int)conn->asyncStatus == PGASYNC_IDLE))
            goto __CPROVER_DUMP_L47;

          if((signed int)id == 69)
          {
            signed int return_value_pqGetErrorNotice2_4;
            return_value_pqGetErrorNotice2_4=pqGetErrorNotice2(conn, (char)0);
            if(!(return_value_pqGetErrorNotice2_4 == 0))
              goto __CPROVER_DUMP_L47;

          }

          else
          {
            pqInternalNotice(&conn->noticeHooks, "message type 0x%02x arrived from server while idle", id);
            conn->inStart = conn->inEnd;
            break;
          }
        }

        else
          switch((signed int)id)
          {
            case 67:
            {
              return_value_pqGets_5=pqGets(&conn->workBuffer, conn);
              if(!(return_value_pqGets_5 == 0))
                goto __CPROVER_DUMP_L47;

              if(conn->result == ((struct pg_result *)NULL))
              {
                conn->result=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_COMMAND_OK);
                if(conn->result == ((struct pg_result *)NULL))
                {
                  char *return_value_libpq_gettext_6;
                  return_value_libpq_gettext_6=libpq_gettext("out of memory");
                  printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_6);
                  pqSaveErrorResult(conn);
                }

              }

              if(!(conn->result == ((struct pg_result *)NULL)))
                strlcpy(conn->result->cmdStatus, conn->workBuffer.data, (unsigned long int)64);

              checkXactStatus(conn, conn->workBuffer.data);
              conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
              break;
            }
            case 69:
            {
              return_value_pqGetErrorNotice2_7=pqGetErrorNotice2(conn, (char)1);
              if(!(return_value_pqGetErrorNotice2_7 == 0))
                goto __CPROVER_DUMP_L47;

              conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
              break;
            }
            case 90:
            {
              conn->asyncStatus = (enum anonymous_9)PGASYNC_IDLE;
              break;
            }
            case 73:
            {
              return_value_pqGetc_8=pqGetc(&id, conn);
              if(!(return_value_pqGetc_8 == 0))
                goto __CPROVER_DUMP_L47;

              if(!((signed int)id == 0))
                pqInternalNotice(&conn->noticeHooks, "unexpected character %c following empty query response (\"I\" message)", id);

              if(conn->result == ((struct pg_result *)NULL))
              {
                conn->result=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_EMPTY_QUERY);
                if(conn->result == ((struct pg_result *)NULL))
                {
                  char *return_value_libpq_gettext_9;
                  return_value_libpq_gettext_9=libpq_gettext("out of memory");
                  printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_9);
                  pqSaveErrorResult(conn);
                }

              }

              conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
              break;
            }
            case 75:
            {
              return_value_pqGetInt_10=pqGetInt(&conn->be_pid, (unsigned long int)4, conn);
              if(!(return_value_pqGetInt_10 == 0))
                goto __CPROVER_DUMP_L47;

              return_value_pqGetInt_11=pqGetInt(&conn->be_key, (unsigned long int)4, conn);
              if(!(return_value_pqGetInt_11 == 0))
                goto __CPROVER_DUMP_L47;

              break;
            }
            case 80:
            {
              return_value_pqGets_12=pqGets(&conn->workBuffer, conn);
              if(!(return_value_pqGets_12 == 0))
                goto __CPROVER_DUMP_L47;

              break;
            }
            case 84:
              if(conn->result == ((struct pg_result *)NULL))
              {
                signed int return_value_getRowDescriptions_13;
                return_value_getRowDescriptions_13=getRowDescriptions(conn);
                if(!(return_value_getRowDescriptions_13 == 0))
                  goto __CPROVER_DUMP_L47;

                goto __CPROVER_DUMP_L45;
              }

              else
              {
                conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
                goto __CPROVER_DUMP_L47;
              }
            case 68:
              if(!(conn->result == ((struct pg_result *)NULL)))
              {
                signed int return_value_getAnotherTuple_14;
                return_value_getAnotherTuple_14=getAnotherTuple(conn, (char)0);
                if(!(return_value_getAnotherTuple_14 == 0))
                  goto __CPROVER_DUMP_L47;

                goto __CPROVER_DUMP_L45;
              }

              else
              {
                pqInternalNotice(&conn->noticeHooks, "server sent data (\"D\" message) without prior row description (\"T\" message)");
                conn->inStart = conn->inEnd;
                goto __CPROVER_DUMP_L47;
              }
            case 66:
              if(!(conn->result == ((struct pg_result *)NULL)))
              {
                signed int return_value_getAnotherTuple_15;
                return_value_getAnotherTuple_15=getAnotherTuple(conn, (char)1);
                if(!(return_value_getAnotherTuple_15 == 0))
                  goto __CPROVER_DUMP_L47;

                goto __CPROVER_DUMP_L45;
              }

              else
              {
                pqInternalNotice(&conn->noticeHooks, "server sent binary data (\"B\" message) without prior row description (\"T\" message)");
                conn->inStart = conn->inEnd;
                goto __CPROVER_DUMP_L47;
              }
            case 71:
            {
              conn->asyncStatus = (enum anonymous_9)PGASYNC_COPY_IN;
              break;
            }
            case 72:
            {
              conn->asyncStatus = (enum anonymous_9)PGASYNC_COPY_OUT;
              break;
            }
            default:
            {
              return_value_libpq_gettext_16=libpq_gettext("unexpected response from server; first received character was \"%c\"\n");
              printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_16, id);
              pqSaveErrorResult(conn);
              conn->inStart = conn->inEnd;
              conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
              goto __CPROVER_DUMP_L47;
            }
          }
    conn->inStart = conn->inCursor;

  __CPROVER_DUMP_L45:
    ;
  }

__CPROVER_DUMP_L47:
  ;
}

// pqParseInput3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 558
extern void pqParseInput3(struct pg_conn *conn)
{
  char id;
  signed int msgLength;
  signed int avail;
  signed int return_value_pqGets_8;
  signed int return_value_pqGetErrorNotice3_10;
  signed int return_value_getReadyForQuery_11;
  signed int return_value_getParameterStatus_14;
  signed int return_value_pqGetInt_15;
  signed int return_value_pqGetInt_16;
  _Bool tmp_if_expr_18;
  signed int return_value_getParamDescriptions_20;
  _Bool tmp_if_expr_24;
  _Bool tmp_if_expr_23;
  signed int return_value_getCopyStart_25;
  signed int return_value_getCopyStart_26;
  signed int return_value_getCopyStart_27;
  char *return_value_libpq_gettext_28;
  do
  {
    conn->inCursor = conn->inStart;
    signed int return_value_pqGetc_1;
    return_value_pqGetc_1=pqGetc(&id, conn);
    if(!(return_value_pqGetc_1 == 0))
      break;

    signed int return_value_pqGetInt_2;
    return_value_pqGetInt_2=pqGetInt(&msgLength, (unsigned long int)4, conn);
    if(!(return_value_pqGetInt_2 == 0))
      break;

    if(!(msgLength >= 4))
    {
      handleSyncLoss(conn, id, msgLength);
      break;
    }

    if(msgLength >= 30001 && !((signed int)id == 65) && !((signed int)id == 68) && !((signed int)id == 69) && !((signed int)id == 78) && !((signed int)id == 84) && !((signed int)id == 86) && !((signed int)id == 100))
    {
      handleSyncLoss(conn, id, msgLength);
      break;
    }

    msgLength = msgLength - 4;
    avail = conn->inEnd - conn->inCursor;
    if(!(avail >= msgLength))
    {
      signed int return_value_pqCheckInBufferSpace_3;
      return_value_pqCheckInBufferSpace_3=pqCheckInBufferSpace((unsigned long int)conn->inCursor + (unsigned long int)msgLength, conn);
      if(!(return_value_pqCheckInBufferSpace_3 == 0))
        handleSyncLoss(conn, id, msgLength);

      break;
    }

    if((signed int)id == 65)
    {
      signed int return_value_getNotify_4;
      return_value_getNotify_4=getNotify_link1(conn);
      if(!(return_value_getNotify_4 == 0))
        break;

    }

    else
      if((signed int)id == 78)
      {
        signed int return_value_pqGetErrorNotice3_5;
        return_value_pqGetErrorNotice3_5=pqGetErrorNotice3(conn, (char)0);
        if(!(return_value_pqGetErrorNotice3_5 == 0))
          break;

      }

      else
        if(!((signed int)conn->asyncStatus == PGASYNC_BUSY))
        {
          if(!((signed int)conn->asyncStatus == PGASYNC_IDLE))
            break;

          if((signed int)id == 69)
          {
            signed int return_value_pqGetErrorNotice3_6;
            return_value_pqGetErrorNotice3_6=pqGetErrorNotice3(conn, (char)0);
            if(!(return_value_pqGetErrorNotice3_6 == 0))
              break;

          }

          else
            if((signed int)id == 83)
            {
              signed int return_value_getParameterStatus_7;
              return_value_getParameterStatus_7=getParameterStatus(conn);
              if(!(return_value_getParameterStatus_7 == 0))
                break;

            }

            else
            {
              pqInternalNotice(&conn->noticeHooks, "message type 0x%02x arrived from server while idle", id);
              conn->inCursor = conn->inCursor + msgLength;
            }
        }

        else
          switch((signed int)id)
          {
            case 67:
            {
              return_value_pqGets_8=pqGets(&conn->workBuffer, conn);
              if(!(return_value_pqGets_8 == 0))
                goto __CPROVER_DUMP_L71;

              if(conn->result == ((struct pg_result *)NULL))
              {
                conn->result=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_COMMAND_OK);
                if(conn->result == ((struct pg_result *)NULL))
                {
                  char *return_value_libpq_gettext_9;
                  return_value_libpq_gettext_9=libpq_gettext("out of memory");
                  printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_9);
                  pqSaveErrorResult(conn);
                }

              }

              if(!(conn->result == ((struct pg_result *)NULL)))
                strlcpy(conn->result->cmdStatus, conn->workBuffer.data, (unsigned long int)64);

              conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
              break;
            }
            case 69:
            {
              return_value_pqGetErrorNotice3_10=pqGetErrorNotice3(conn, (char)1);
              if(!(return_value_pqGetErrorNotice3_10 == 0))
                goto __CPROVER_DUMP_L71;

              conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
              break;
            }
            case 90:
            {
              return_value_getReadyForQuery_11=getReadyForQuery(conn);
              if(!(return_value_getReadyForQuery_11 == 0))
                goto __CPROVER_DUMP_L71;

              conn->asyncStatus = (enum anonymous_9)PGASYNC_IDLE;
              break;
            }
            case 73:
            {
              if(conn->result == ((struct pg_result *)NULL))
              {
                conn->result=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_EMPTY_QUERY);
                if(conn->result == ((struct pg_result *)NULL))
                {
                  char *return_value_libpq_gettext_12;
                  return_value_libpq_gettext_12=libpq_gettext("out of memory");
                  printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_12);
                  pqSaveErrorResult(conn);
                }

              }

              conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
              break;
            }
            case 49:
            {
              if((signed int)conn->queryclass == PGQUERY_PREPARE)
              {
                if(conn->result == ((struct pg_result *)NULL))
                {
                  conn->result=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_COMMAND_OK);
                  if(conn->result == ((struct pg_result *)NULL))
                  {
                    char *return_value_libpq_gettext_13;
                    return_value_libpq_gettext_13=libpq_gettext("out of memory");
                    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_13);
                    pqSaveErrorResult(conn);
                  }

                }

                conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
              }

              break;
            }
            case 50:

            case 51:
              break;
            case 83:
            {
              return_value_getParameterStatus_14=getParameterStatus(conn);
              if(!(return_value_getParameterStatus_14 == 0))
                goto __CPROVER_DUMP_L71;

              break;
            }
            case 75:
            {
              return_value_pqGetInt_15=pqGetInt(&conn->be_pid, (unsigned long int)4, conn);
              if(!(return_value_pqGetInt_15 == 0))
                goto __CPROVER_DUMP_L71;

              return_value_pqGetInt_16=pqGetInt(&conn->be_key, (unsigned long int)4, conn);
              if(!(return_value_pqGetInt_16 == 0))
                goto __CPROVER_DUMP_L71;

              break;
            }
            case 84:
            {
              if(conn->result == ((struct pg_result *)NULL))
                tmp_if_expr_18 = (_Bool)1;

              else
                tmp_if_expr_18 = (signed int)conn->queryclass == PGQUERY_DESCRIBE ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_18)
              {
                signed int return_value_getRowDescriptions_17;
                return_value_getRowDescriptions_17=getRowDescriptions_link1(conn, msgLength);
                if(!(return_value_getRowDescriptions_17 == 0))
                  goto __CPROVER_DUMP_L71;

                goto __CPROVER_DUMP_L70;
              }

              else
              {
                conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
                goto __CPROVER_DUMP_L71;
              }
            }
            case 110:
            {
              if((signed int)conn->queryclass == PGQUERY_DESCRIBE)
              {
                if(conn->result == ((struct pg_result *)NULL))
                {
                  conn->result=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_COMMAND_OK);
                  if(conn->result == ((struct pg_result *)NULL))
                  {
                    char *return_value_libpq_gettext_19;
                    return_value_libpq_gettext_19=libpq_gettext("out of memory");
                    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_19);
                    pqSaveErrorResult(conn);
                  }

                }

                conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
              }

              break;
            }
            case 116:
            {
              return_value_getParamDescriptions_20=getParamDescriptions(conn);
              if(!(return_value_getParamDescriptions_20 == 0))
                goto __CPROVER_DUMP_L71;

              break;
            }
            case 68:
            {
              if(!(conn->result == ((struct pg_result *)NULL)))
                tmp_if_expr_24 = (signed int)conn->result->resultStatus == PGRES_TUPLES_OK ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_24 = (_Bool)0;
              if(tmp_if_expr_24)
              {
                signed int return_value_getAnotherTuple_21;
                return_value_getAnotherTuple_21=getAnotherTuple_link1(conn, msgLength);
                if(!(return_value_getAnotherTuple_21 == 0))
                  goto __CPROVER_DUMP_L71;

                goto __CPROVER_DUMP_L70;
              }

              else
              {
                if(!(conn->result == ((struct pg_result *)NULL)))
                  tmp_if_expr_23 = (signed int)conn->result->resultStatus == PGRES_FATAL_ERROR ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_23 = (_Bool)0;
                if(tmp_if_expr_23)
                  conn->inCursor = conn->inCursor + msgLength;

                else
                {
                  char *return_value_libpq_gettext_22;
                  return_value_libpq_gettext_22=libpq_gettext("server sent data (\"D\" message) without prior row description (\"T\" message)\n");
                  printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_22);
                  pqSaveErrorResult(conn);
                  conn->inCursor = conn->inCursor + msgLength;
                }
              }
              break;
            }
            case 71:
            {
              return_value_getCopyStart_25=getCopyStart(conn, (enum anonymous_20)PGRES_COPY_IN);
              if(!(return_value_getCopyStart_25 == 0))
                goto __CPROVER_DUMP_L71;

              conn->asyncStatus = (enum anonymous_9)PGASYNC_COPY_IN;
              break;
            }
            case 72:
            {
              return_value_getCopyStart_26=getCopyStart(conn, (enum anonymous_20)PGRES_COPY_OUT);
              if(!(return_value_getCopyStart_26 == 0))
                goto __CPROVER_DUMP_L71;

              conn->asyncStatus = (enum anonymous_9)PGASYNC_COPY_OUT;
              conn->copy_already_done = 0;
              break;
            }
            case 87:
            {
              return_value_getCopyStart_27=getCopyStart(conn, (enum anonymous_20)PGRES_COPY_BOTH);
              if(!(return_value_getCopyStart_27 == 0))
                goto __CPROVER_DUMP_L71;

              conn->asyncStatus = (enum anonymous_9)PGASYNC_COPY_BOTH;
              conn->copy_already_done = 0;
              break;
            }
            case 100:
            {
              conn->inCursor = conn->inCursor + msgLength;
              break;
            }
            case 99:
              break;
            default:
            {
              return_value_libpq_gettext_28=libpq_gettext("unexpected response from server; first received character was \"%c\"\n");
              printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_28, id);
              pqSaveErrorResult(conn);
              conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
              conn->inCursor = conn->inCursor + msgLength;
            }
          }
    if(conn->inCursor == 5 + conn->inStart + msgLength)
      conn->inStart = conn->inCursor;

    else
    {
      char *return_value_libpq_gettext_29;
      return_value_libpq_gettext_29=libpq_gettext("message contents do not agree with length in message type \"%c\"\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_29, id);
      pqSaveErrorResult(conn);
      conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
      conn->inStart = conn->inStart + 5 + msgLength;
    }

  __CPROVER_DUMP_L70:
    ;
  }
  while((_Bool)1);

__CPROVER_DUMP_L71:
  ;
}

// pqPrepareAsyncResult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 755
extern struct pg_result * pqPrepareAsyncResult(struct pg_conn *conn)
{
  struct pg_result *res = conn->result;
  if(res == ((struct pg_result *)NULL))
    res=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_FATAL_ERROR);

  else
  {
    resetPQExpBuffer(&conn->errorMessage);
    char *return_value_PQresultErrorMessage_1;
    return_value_PQresultErrorMessage_1=PQresultErrorMessage(res);
    appendPQExpBufferStr(&conn->errorMessage, return_value_PQresultErrorMessage_1);
  }
  conn->result = conn->next_result;
  conn->next_result = (struct pg_result *)(void *)0;
  return res;
}

// pqPutInt
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 587
extern signed int pqPutInt(signed int value, unsigned long int bytes, struct pg_conn *conn)
{
  unsigned short int tmp2;
  unsigned int tmp4;
  signed int return_value_pqPutMsgBytes_1;
  signed int return_value_pqPutMsgBytes_2;
  switch(bytes)
  {
    case (unsigned long int)2:
    {
      tmp2=htons((unsigned short int)value);
      return_value_pqPutMsgBytes_1=pqPutMsgBytes((const void *)(const char *)&tmp2, (unsigned long int)2, conn);
      if(!(return_value_pqPutMsgBytes_1 == 0))
        return -1;

      break;
    }
    case (unsigned long int)4:
    {
      tmp4=htonl((unsigned int)value);
      return_value_pqPutMsgBytes_2=pqPutMsgBytes((const void *)(const char *)&tmp4, (unsigned long int)4, conn);
      if(!(return_value_pqPutMsgBytes_2 == 0))
        return -1;

      break;
    }
    default:
    {
      pqInternalNotice(&conn->noticeHooks, "integer of size %lu not supported by pqPutInt", (unsigned long int)bytes);
      return -1;
    }
  }
  if(!(conn->Pfdebug == ((struct _IO_FILE *)NULL)))
    fprintf(conn->Pfdebug, "To backend (%lu#)> %d\n", (unsigned long int)bytes, value);

  return 0;
}

// pqPutMsgBytes
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 569
static signed int pqPutMsgBytes(const void *buf, unsigned long int len, struct pg_conn *conn)
{
  signed int return_value_pqCheckOutBufferSpace_1;
  return_value_pqCheckOutBufferSpace_1=pqCheckOutBufferSpace((unsigned long int)conn->outMsgEnd + len, conn);
  if(!(return_value_pqCheckOutBufferSpace_1 == 0))
    return -1;

  else
  {
    memcpy((void *)(conn->outBuffer + (signed long int)conn->outMsgEnd), buf, len);
    conn->outMsgEnd = conn->outMsgEnd + (signed int)len;
    return 0;
  }
}

// pqPutMsgEnd
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 589
extern signed int pqPutMsgEnd(struct pg_conn *conn)
{
  if(!(conn->Pfdebug == ((struct _IO_FILE *)NULL)))
    fprintf(conn->Pfdebug, "To backend> Msg complete, length %u\n", conn->outMsgEnd - conn->outCount);

  if(conn->outMsgStart >= 0)
  {
    unsigned int msgLen = (unsigned int)(conn->outMsgEnd - conn->outMsgStart);
    msgLen=htonl(msgLen);
    memcpy((void *)(conn->outBuffer + (signed long int)conn->outMsgStart), (const void *)&msgLen, (unsigned long int)4);
  }

  conn->outCount = conn->outMsgEnd;
  if(conn->outCount >= 8192)
  {
    signed int toSend = conn->outCount - conn->outCount % 8192;
    signed int return_value_pqSendSome_1;
    return_value_pqSendSome_1=pqSendSome(conn, toSend);
    if(!(return_value_pqSendSome_1 >= 0))
      return -1;

  }

  return 0;
}

// pqPutMsgStart
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 588
extern signed int pqPutMsgStart(char msg_type, char force_len, struct pg_conn *conn)
{
  signed int lenPos;
  signed int endPos;
  if(!(msg_type == 0))
    endPos = conn->outCount + 1;

  else
    endPos = conn->outCount;
  _Bool tmp_if_expr_1;
  if(!(force_len == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = conn->pversion >> 16 >= (unsigned int)3 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    lenPos = endPos;
    endPos = endPos + 4;
  }

  else
    lenPos = -1;
  signed int return_value_pqCheckOutBufferSpace_2;
  return_value_pqCheckOutBufferSpace_2=pqCheckOutBufferSpace((unsigned long int)endPos, conn);
  if(!(return_value_pqCheckOutBufferSpace_2 == 0))
    return -1;

  else
  {
    if(!(msg_type == 0))
      conn->outBuffer[(signed long int)conn->outCount] = msg_type;

    conn->outMsgStart = lenPos;
    conn->outMsgEnd = endPos;
    if(!(conn->Pfdebug == ((struct _IO_FILE *)NULL)))
      fprintf(conn->Pfdebug, "To backend> Msg %c\n", msg_type != 0 ? (signed int)msg_type : 32);

    return 0;
  }
}

// pqPutc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 579
extern signed int pqPutc(char c, struct pg_conn *conn)
{
  signed int return_value_pqPutMsgBytes_1;
  return_value_pqPutMsgBytes_1=pqPutMsgBytes((const void *)&c, (unsigned long int)1, conn);
  if(!(return_value_pqPutMsgBytes_1 == 0))
    return -1;

  else
  {
    if(!(conn->Pfdebug == ((struct _IO_FILE *)NULL)))
      fprintf(conn->Pfdebug, "To backend> %c\n", c);

    return 0;
  }
}

// pqPutnchar
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 585
extern signed int pqPutnchar(const char *s, unsigned long int len, struct pg_conn *conn)
{
  signed int return_value_pqPutMsgBytes_1;
  return_value_pqPutMsgBytes_1=pqPutMsgBytes((const void *)s, len, conn);
  if(!(return_value_pqPutMsgBytes_1 == 0))
    return -1;

  else
  {
    if(!(conn->Pfdebug == ((struct _IO_FILE *)NULL)))
    {
      fprintf(conn->Pfdebug, "To backend> ");
      fputnbytes(conn->Pfdebug, s, len);
      fprintf(conn->Pfdebug, "\n");
    }

    return 0;
  }
}

// pqPuts
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 582
extern signed int pqPuts(const char *s, struct pg_conn *conn)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  signed int return_value_pqPutMsgBytes_2;
  return_value_pqPutMsgBytes_2=pqPutMsgBytes((const void *)s, return_value_strlen_1 + (unsigned long int)1, conn);
  if(!(return_value_pqPutMsgBytes_2 == 0))
    return -1;

  else
  {
    if(!(conn->Pfdebug == ((struct _IO_FILE *)NULL)))
      fprintf(conn->Pfdebug, "To backend> \"%s\"\n", s);

    return 0;
  }
}

// pqReadData
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 590
extern signed int pqReadData(struct pg_conn *conn)
{
  signed int someread = 0;
  signed int nread;
  if(conn->sock == -1)
  {
    char *return_value_libpq_gettext_1;
    return_value_libpq_gettext_1=libpq_gettext("connection not open\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
    return -1;
  }

  if(!(conn->inStart >= conn->inEnd))
  {
    if(conn->inStart >= 1)
    {
      memmove((void *)conn->inBuffer, (const void *)(conn->inBuffer + (signed long int)conn->inStart), (unsigned long int)(conn->inEnd - conn->inStart));
      conn->inEnd = conn->inEnd - conn->inStart;
      conn->inCursor = conn->inCursor - conn->inStart;
      conn->inStart = 0;
    }

  }

  else
  {
    conn->inEnd = 0;
    conn->inCursor = conn->inEnd;
    conn->inStart = conn->inCursor;
  }
  if(!(conn->inBufSize + -conn->inEnd >= 8192))
  {
    signed int return_value_pqCheckInBufferSpace_2;
    return_value_pqCheckInBufferSpace_2=pqCheckInBufferSpace((unsigned long int)conn->inEnd + (unsigned long int)8192, conn);
    if(!(return_value_pqCheckInBufferSpace_2 == 0))
    {
      if(!(conn->inBufSize + -conn->inEnd >= 100))
        return -1;

    }

  }

  signed long int return_value_pqsecure_read_3;
  do
  {

  retry3:
    ;
    return_value_pqsecure_read_3=pqsecure_read(conn, (void *)(conn->inBuffer + (signed long int)conn->inEnd), (unsigned long int)(conn->inBufSize - conn->inEnd));
    nread = (signed int)return_value_pqsecure_read_3;
    if(!(nread >= 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      if(*return_value___errno_location_4 == 4)
        goto retry3;

      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      if(*return_value___errno_location_5 == 11)
        return someread;

      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      if(*return_value___errno_location_6 == 104)
        goto definitelyFailed;

      return -1;
    }

    if(!(nread >= 1))
      goto __CPROVER_DUMP_L10;

    conn->inEnd = conn->inEnd + nread;
    if(!(conn->inEnd >= 32769))
      break;

    if(!(conn->inBufSize + -conn->inEnd >= 8192))
      break;

    someread = 1;
  }
  while((_Bool)1);
  return 1;

__CPROVER_DUMP_L10:
  ;
  signed long int return_value_pqsecure_read_8;
  signed int *return_value___errno_location_9;
  char *return_value_libpq_gettext_12;
  if(!(someread == 0))
    return 1;

  else
    if(!(conn->ssl == ((struct ssl_st *)NULL)))
      return 0;

    else
    {
      signed int return_value_pqReadReady_7;
      return_value_pqReadReady_7=pqReadReady(conn);
      switch(return_value_pqReadReady_7)
      {
        case 0:
          return 0;
        case 1:
          break;
        default:
          goto definitelyEOF;
      }
      do
      {

      retry4:
        ;
        return_value_pqsecure_read_8=pqsecure_read(conn, (void *)(conn->inBuffer + (signed long int)conn->inEnd), (unsigned long int)(conn->inBufSize - conn->inEnd));
        nread = (signed int)return_value_pqsecure_read_8;
        if(nread >= 0)
          goto __CPROVER_DUMP_L18;

        return_value___errno_location_9=__errno_location();
      }
      while(*return_value___errno_location_9 == 4);
      signed int *return_value___errno_location_10;
      return_value___errno_location_10=__errno_location();
      if(*return_value___errno_location_10 == 11)
        return 0;

      else
      {
        signed int *return_value___errno_location_11;
        return_value___errno_location_11=__errno_location();
        if(!(*return_value___errno_location_11 == 104))
        {
          return -1;

        __CPROVER_DUMP_L18:
          ;
          if(nread >= 1)
          {
            conn->inEnd = conn->inEnd + nread;
            return 1;
          }


        definitelyEOF:
          ;
          return_value_libpq_gettext_12=libpq_gettext("server closed the connection unexpectedly\n\tThis probably means the server terminated abnormally\n\tbefore or while processing the request.\n");
          printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_12);
        }


      definitelyFailed:
        ;
        pqDropConnection(conn);
        conn->status = (enum anonymous_24)CONNECTION_BAD;
        return -1;
      }
    }
}

// pqReadReady
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 1026
extern signed int pqReadReady(struct pg_conn *conn)
{
  signed int return_value_pqSocketCheck_1;
  return_value_pqSocketCheck_1=pqSocketCheck(conn, 1, 0, (signed long int)0);
  return return_value_pqSocketCheck_1;
}

// pqResultAlloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 505
extern void * pqResultAlloc(struct pg_result *res, unsigned long int nBytes, char isBinary)
{
  char *space;
  union pgresult_data *block;
  if(res == ((struct pg_result *)NULL))
    return (void *)0;

  else
    if(!(nBytes >= 1ul))
      return (void *)res->null_field;

    else
    {
      if(!(isBinary == 0))
      {
        signed int offset = res->curOffset % 8;
        if(!(offset == 0))
        {
          res->curOffset = res->curOffset + (8 - offset);
          res->spaceLeft = res->spaceLeft - (8 - offset);
        }

      }

      if((unsigned long int)res->spaceLeft >= nBytes)
      {
        space = res->curBlock->space + (signed long int)res->curOffset;
        res->curOffset = res->curOffset + (signed int)nBytes;
        res->spaceLeft = res->spaceLeft - (signed int)nBytes;
        return (void *)space;
      }

      else
      {
        if(nBytes >= 1024ul)
        {
          void *return_value_malloc_1;
          return_value_malloc_1=malloc(nBytes + (sizeof(union pgresult_data) /*8ul*/  > (unsigned long int)8 ? sizeof(union pgresult_data) /*8ul*/  : (unsigned long int)8));
          block = (union pgresult_data *)return_value_malloc_1;
          if(block == ((union pgresult_data *)NULL))
            return (void *)0;

          space = block->space + (signed long int)(sizeof(union pgresult_data) /*8ul*/  > (unsigned long int)8 ? sizeof(union pgresult_data) /*8ul*/  : (unsigned long int)8);
          if(!(res->curBlock == ((union pgresult_data *)NULL)))
          {
            block->next = res->curBlock->next;
            res->curBlock->next = block;
          }

          else
          {
            block->next = (union pgresult_data *)(void *)0;
            res->curBlock = block;
            res->spaceLeft = 0;
          }
          return (void *)space;
        }

        void *return_value_malloc_2;
        return_value_malloc_2=malloc((unsigned long int)2048);
        block = (union pgresult_data *)return_value_malloc_2;
        if(block == ((union pgresult_data *)NULL))
          return (void *)0;

        else
        {
          block->next = res->curBlock;
          res->curBlock = block;
          if(!(isBinary == 0))
          {
            res->curOffset = (signed int)(sizeof(union pgresult_data) /*8ul*/  > (unsigned long int)8 ? sizeof(union pgresult_data) /*8ul*/  : (unsigned long int)8);
            res->spaceLeft = (signed int)((unsigned long int)2048 - (sizeof(union pgresult_data) /*8ul*/  > (unsigned long int)8 ? sizeof(union pgresult_data) /*8ul*/  : (unsigned long int)8));
          }

          else
          {
            res->curOffset = (signed int)sizeof(union pgresult_data) /*8ul*/ ;
            res->spaceLeft = (signed int)((unsigned long int)2048 - sizeof(union pgresult_data) /*8ul*/ );
          }
          space = block->space + (signed long int)res->curOffset;
          res->curOffset = res->curOffset + (signed int)nBytes;
          res->spaceLeft = res->spaceLeft - (signed int)nBytes;
          return (void *)space;
        }
      }
    }
}

// pqResultStrdup
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 601
extern char * pqResultStrdup(struct pg_result *res, const char *str)
{
  char *space;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  void *return_value_pqResultAlloc_2;
  return_value_pqResultAlloc_2=pqResultAlloc(res, return_value_strlen_1 + (unsigned long int)1, (char)0);
  space = (char *)return_value_pqResultAlloc_2;
  if(!(space == ((char *)NULL)))
    strcpy(space, str);

  return space;
}

// pqRowProcessor
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 1010
extern signed int pqRowProcessor(struct pg_conn *conn, const char **errmsgp)
{
  struct pg_result *res = conn->result;
  signed int nfields = res->numAttributes;
  const struct pgDataValue *columns = conn->rowBuf;
  struct pgresAttValue *tup;
  signed int i;
  char return_value_pqAddTuple_3;
  if(!(conn->singleRowMode == 0))
  {
    res=PQcopyResult(res, 0x01 | 0x04 | 0x08);
    if(!(res == ((struct pg_result *)NULL)))
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    void *return_value_pqResultAlloc_1;
    return_value_pqResultAlloc_1=pqResultAlloc(res, (unsigned long int)nfields * sizeof(struct pgresAttValue) /*16ul*/ , (char)1);
    tup = (struct pgresAttValue *)return_value_pqResultAlloc_1;
    if(!(tup == ((struct pgresAttValue *)NULL)))
    {
      i = 0;
      for( ; !(i >= nfields); i = i + 1)
      {
        signed int clen = (columns + (signed long int)i)->len;
        if(!(clen >= 0))
        {
          (tup + (signed long int)i)->len = -1;
          (tup + (signed long int)i)->value = res->null_field;
        }

        else
        {
          char isbinary = (char)((res->attDescs + (signed long int)i)->format != 0);
          char *val;
          void *return_value_pqResultAlloc_2;
          return_value_pqResultAlloc_2=pqResultAlloc(res, (unsigned long int)(clen + 1), isbinary);
          val = (char *)return_value_pqResultAlloc_2;
          if(val == ((char *)NULL))
            goto fail;

          memcpy((void *)val, (const void *)(columns + (signed long int)i)->value, (unsigned long int)clen);
          val[(signed long int)clen] = (char)0;
          (tup + (signed long int)i)->len = clen;
          (tup + (signed long int)i)->value = val;
        }
      }
      return_value_pqAddTuple_3=pqAddTuple(res, tup);
      if(return_value_pqAddTuple_3 == 0)
        goto fail;

      if(!(conn->singleRowMode == 0))
      {
        res->resultStatus = (enum anonymous_20)PGRES_SINGLE_TUPLE;
        conn->next_result = conn->result;
        conn->result = res;
        conn->asyncStatus = (enum anonymous_9)PGASYNC_READY;
      }

      return 1;
    }

    else
    {

    fail:
      ;
      if(!(res == conn->result))
        PQclear(res);

      return 0;
    }
  }
}

// pqSaveErrorResult
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 727
extern void pqSaveErrorResult(struct pg_conn *conn)
{
  _Bool tmp_if_expr_1;
  if(conn->result == ((struct pg_result *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)conn->result->resultStatus != PGRES_FATAL_ERROR ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = conn->result->errMsg == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    pqClearAsyncResult(conn);
    conn->result=PQmakeEmptyPGresult(conn, (enum anonymous_20)PGRES_FATAL_ERROR);
  }

  else
    pqCatenateResultError(conn->result, conn->errorMessage.data);
}

// pqSaveMessageField
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 889
extern void pqSaveMessageField(struct pg_result *res, char code, const char *value)
{
  struct pgMessageField *pfield;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(value);
  void *return_value_pqResultAlloc_2;
  return_value_pqResultAlloc_2=pqResultAlloc(res, sizeof(struct pgMessageField) /*16ul*/  + return_value_strlen_1, (char)1);
  pfield = (struct pgMessageField *)return_value_pqResultAlloc_2;
  if(!(pfield == ((struct pgMessageField *)NULL)))
  {
    pfield->code = code;
    strcpy(pfield->contents, value);
    pfield->next = res->errFields;
    res->errFields = pfield;
  }

}

// pqSaveParameterStatus
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 533
extern void pqSaveParameterStatus(struct pg_conn *conn, const char *name, const char *value)
{
  struct pgParameterStatus *pstatus;
  struct pgParameterStatus *prev;
  if(!(conn->Pfdebug == ((struct _IO_FILE *)NULL)))
    fprintf(conn->Pfdebug, "pqSaveParameterStatus: '%s' = '%s'\n", name, value);

  pstatus = conn->pstatus;
  prev = (struct pgParameterStatus *)(void *)0;
  for( ; !(pstatus == ((struct pgParameterStatus *)NULL)); pstatus = pstatus->next)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(pstatus->name, name);
    if(return_value_strcmp_1 == 0)
    {
      if(!(prev == ((struct pgParameterStatus *)NULL)))
        prev->next = pstatus->next;

      else
        conn->pstatus = pstatus->next;
      free((void *)pstatus);
      break;
    }

    prev = pstatus;
  }
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(name);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(value);
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(sizeof(struct pgParameterStatus) /*24ul*/  + return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)2);
  pstatus = (struct pgParameterStatus *)return_value_malloc_4;
  if(!(pstatus == ((struct pgParameterStatus *)NULL)))
  {
    char *ptr = (char *)pstatus + (signed long int)sizeof(struct pgParameterStatus) /*24ul*/ ;
    pstatus->name = ptr;
    strcpy(ptr, name);
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(name);
    ptr = ptr + (signed long int)(return_value_strlen_5 + (unsigned long int)1);
    pstatus->value = ptr;
    strcpy(ptr, value);
    pstatus->next = conn->pstatus;
    conn->pstatus = pstatus;
  }

  signed int return_value_strcmp_9;
  return_value_strcmp_9=strcmp(name, "client_encoding");
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_7;
  if(return_value_strcmp_9 == 0)
  {
    conn->client_encoding=pg_char_to_encoding(value);
    if(!(conn->client_encoding >= 0))
      conn->client_encoding = PG_SQL_ASCII;

    static_client_encoding = conn->client_encoding;
  }

  else
  {
    return_value_strcmp_8=strcmp(name, "standard_conforming_strings");
    if(return_value_strcmp_8 == 0)
    {
      signed int return_value_strcmp_6;
      return_value_strcmp_6=strcmp(value, "on");
      conn->std_strings = (char)(return_value_strcmp_6 == 0);
      static_std_strings = conn->std_strings;
    }

    else
    {
      return_value_strcmp_7=strcmp(name, "server_version");
      if(return_value_strcmp_7 == 0)
      {
        signed int cnt;
        signed int vmaj;
        signed int vmin;
        signed int vrev;
        cnt=sscanf(value, "%d.%d.%d", &vmaj, &vmin, &vrev);
        if(!(cnt >= 2))
          conn->sversion = 0;

        else
        {
          if(cnt == 2)
            vrev = 0;

          conn->sversion = (100 * vmaj + vmin) * 100 + vrev;
        }
      }

    }
  }
}

// pqSendSome
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 832
static signed int pqSendSome(struct pg_conn *conn, signed int len)
{
  char *ptr = conn->outBuffer;
  signed int remaining = conn->outCount;
  signed int result = 0;
  if(conn->sock == -1)
  {
    char *return_value_libpq_gettext_1;
    return_value_libpq_gettext_1=libpq_gettext("connection not open\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
    conn->outCount = 0;
    return -1;
  }

  while(len >= 1)
  {
    signed int sent;
    signed long int return_value_pqsecure_write_2;
    return_value_pqsecure_write_2=pqsecure_write(conn, (const void *)ptr, (unsigned long int)len);
    sent = (signed int)return_value_pqsecure_write_2;
    if(!(sent >= 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      switch(*return_value___errno_location_3)
      {
        case 11:
          break;
        case 4:
          goto __CPROVER_DUMP_L12;
        default:
        {
          conn->outCount = 0;
          return -1;
        }
      }
    }

    else
    {
      ptr = ptr + (signed long int)sent;
      len = len - sent;
      remaining = remaining - sent;
    }
    if(len >= 1)
    {
      signed int return_value_pqReadData_4;
      return_value_pqReadData_4=pqReadData(conn);
      if(!(return_value_pqReadData_4 >= 0))
      {
        result = -1;
        break;
      }

      if(!(conn->nonblocking == 0))
      {
        result = 1;
        break;
      }

      signed int return_value_pqWait_5;
      return_value_pqWait_5=pqWait(1, 1, conn);
      if(!(return_value_pqWait_5 == 0))
      {
        result = -1;
        break;
      }

    }


  __CPROVER_DUMP_L12:
    ;
  }
  if(remaining >= 1)
    memmove((void *)conn->outBuffer, (const void *)ptr, (unsigned long int)remaining);

  conn->outCount = remaining;
  return result;
}

// pqSetResultError
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-exec.c line 615
extern void pqSetResultError(struct pg_result *res, const char *msg)
{
  _Bool tmp_if_expr_1;
  if(!(res == ((struct pg_result *)NULL)))
  {
    if(!(msg == ((const char *)NULL)))
      tmp_if_expr_1 = *msg != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      res->errMsg=pqResultStrdup(res, msg);

    else
      res->errMsg = (char *)(void *)0;
  }

}

// pqSetenvPoll
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 540
extern enum anonymous_4 pqSetenvPoll(struct pg_conn *conn)
{
  struct pg_result *res;
  _Bool tmp_if_expr_1;
  if(conn == ((struct pg_conn *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)conn->status == CONNECTION_BAD ? (_Bool)1 : (_Bool)0;
  signed int n;
  char *return_value_libpq_gettext_2;
  char setQuery[100l];
  const char *val;
  char pqSetenvPoll__1__2__1__1__2__setQuery[100l];
  signed int return_value_PQisBusy_7;
  signed int return_value_PQisBusy_9;
  signed int return_value_PQsendQuery_11;
  signed int return_value_PQisBusy_12;
  _Bool tmp_if_expr_16;
  signed int return_value_PQntuples_15;
  signed int return_value_strncmp_17;
  const char *query;
  _Bool tmp_if_expr_18;
  signed int return_value_PQsendQuery_19;
  signed int return_value_PQisBusy_20;
  _Bool tmp_if_expr_25;
  signed int return_value_PQntuples_24;
  _Bool tmp_if_expr_22;
  char *return_value_libpq_gettext_26;
  if(tmp_if_expr_1)
    return (enum anonymous_4)PGRES_POLLING_FAILED;

  else
  {
    switch((signed int)conn->setenv_state)
    {
      case SETENV_STATE_CLIENT_ENCODING_WAIT:

      case SETENV_STATE_OPTION_WAIT:

      case SETENV_STATE_QUERY1_WAIT:

      case SETENV_STATE_QUERY2_WAIT:
      {
        n=pqReadData(conn);
        if(!(n >= 0))
          goto error_return;

        if(n == 0)
          return (enum anonymous_4)PGRES_POLLING_READING;

        break;
      }
      case SETENV_STATE_CLIENT_ENCODING_SEND:

      case SETENV_STATE_OPTION_SEND:

      case SETENV_STATE_QUERY1_SEND:

      case SETENV_STATE_QUERY2_SEND:
        break;
      case SETENV_STATE_IDLE:
        return (enum anonymous_4)PGRES_POLLING_OK;
      default:
      {
        return_value_libpq_gettext_2=libpq_gettext("invalid setenv state %c, probably indicative of memory corruption\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_2, conn->setenv_state);
        goto error_return;
      }
    }
    while((_Bool)1)
      switch((signed int)conn->setenv_state)
      {
        case SETENV_STATE_CLIENT_ENCODING_SEND:
        {
          val = conn->client_encoding_initial;
          if(!(val == ((const char *)NULL)))
          {
            signed int return_value_pg_strcasecmp_3;
            return_value_pg_strcasecmp_3=pg_strcasecmp(val, "default");
            if(return_value_pg_strcasecmp_3 == 0)
              sprintf(setQuery, "SET client_encoding = DEFAULT");

            else
              sprintf(setQuery, "SET client_encoding = '%.60s'", val);
            signed int return_value_PQsendQuery_4;
            return_value_PQsendQuery_4=PQsendQuery(conn, setQuery);
            if(return_value_PQsendQuery_4 == 0)
              goto error_return;

            conn->setenv_state = (enum anonymous_11)SETENV_STATE_CLIENT_ENCODING_WAIT;
          }

          else
            conn->setenv_state = (enum anonymous_11)SETENV_STATE_OPTION_SEND;
          break;
        }
        case SETENV_STATE_OPTION_SEND:
        {
          if(!(conn->next_eo->envName == ((const char *)NULL)))
          {
            const char *pqSetenvPoll__1__2__1__1__2__1__val;
            pqSetenvPoll__1__2__1__1__2__1__val=getenv(conn->next_eo->envName);
            if(!(pqSetenvPoll__1__2__1__1__2__1__val == ((const char *)NULL)))
            {
              signed int return_value_pg_strcasecmp_5;
              return_value_pg_strcasecmp_5=pg_strcasecmp(pqSetenvPoll__1__2__1__1__2__1__val, "default");
              if(return_value_pg_strcasecmp_5 == 0)
                sprintf(pqSetenvPoll__1__2__1__1__2__setQuery, "SET %s = DEFAULT", conn->next_eo->pgName);

              else
                sprintf(pqSetenvPoll__1__2__1__1__2__setQuery, "SET %s = '%.60s'", conn->next_eo->pgName, pqSetenvPoll__1__2__1__1__2__1__val);
              signed int return_value_PQsendQuery_6;
              return_value_PQsendQuery_6=PQsendQuery(conn, pqSetenvPoll__1__2__1__1__2__setQuery);
              if(return_value_PQsendQuery_6 == 0)
                goto error_return;

              conn->setenv_state = (enum anonymous_11)SETENV_STATE_OPTION_WAIT;
            }

            else
              conn->next_eo = conn->next_eo + 1l;
          }

          else
            conn->setenv_state = (enum anonymous_11)SETENV_STATE_QUERY1_SEND;
          break;
        }
        case SETENV_STATE_CLIENT_ENCODING_WAIT:
        {
          return_value_PQisBusy_7=PQisBusy(conn);
          if(!(return_value_PQisBusy_7 == 0))
            return (enum anonymous_4)PGRES_POLLING_READING;

          res=PQgetResult(conn);
          if(!(res == ((struct pg_result *)NULL)))
          {
            enum anonymous_20 return_value_PQresultStatus_8;
            return_value_PQresultStatus_8=PQresultStatus(res);
            if(!((signed int)return_value_PQresultStatus_8 == PGRES_COMMAND_OK))
            {
              PQclear(res);
              goto error_return;
            }

            PQclear(res);
          }

          else
            conn->setenv_state = (enum anonymous_11)SETENV_STATE_OPTION_SEND;
          break;
        }
        case SETENV_STATE_OPTION_WAIT:
        {
          return_value_PQisBusy_9=PQisBusy(conn);
          if(!(return_value_PQisBusy_9 == 0))
            return (enum anonymous_4)PGRES_POLLING_READING;

          res=PQgetResult(conn);
          if(!(res == ((struct pg_result *)NULL)))
          {
            enum anonymous_20 return_value_PQresultStatus_10;
            return_value_PQresultStatus_10=PQresultStatus(res);
            if(!((signed int)return_value_PQresultStatus_10 == PGRES_COMMAND_OK))
            {
              PQclear(res);
              goto error_return;
            }

            PQclear(res);
          }

          else
          {
            conn->next_eo = conn->next_eo + 1l;
            conn->setenv_state = (enum anonymous_11)SETENV_STATE_OPTION_SEND;
          }
          break;
        }
        case SETENV_STATE_QUERY1_SEND:
        {
          return_value_PQsendQuery_11=PQsendQuery(conn, "begin; select version(); end");
          if(return_value_PQsendQuery_11 == 0)
            goto error_return;

          conn->setenv_state = (enum anonymous_11)SETENV_STATE_QUERY1_WAIT;
          return (enum anonymous_4)PGRES_POLLING_READING;
        }
        case SETENV_STATE_QUERY1_WAIT:
        {
          return_value_PQisBusy_12=PQisBusy(conn);
          if(!(return_value_PQisBusy_12 == 0))
            return (enum anonymous_4)PGRES_POLLING_READING;

          res=PQgetResult(conn);
          if(!(res == ((struct pg_result *)NULL)))
          {
            char *pqSetenvPoll__1__2__1__1__6__1__val;
            enum anonymous_20 return_value_PQresultStatus_13;
            return_value_PQresultStatus_13=PQresultStatus(res);
            if((signed int)return_value_PQresultStatus_13 == PGRES_COMMAND_OK)
            {
              PQclear(res);
              break;
            }

            enum anonymous_20 return_value_PQresultStatus_14;
            return_value_PQresultStatus_14=PQresultStatus(res);
            if(!((signed int)return_value_PQresultStatus_14 == PGRES_TUPLES_OK))
              tmp_if_expr_16 = (_Bool)1;

            else
            {
              return_value_PQntuples_15=PQntuples(res);
              tmp_if_expr_16 = return_value_PQntuples_15 != 1 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_16)
            {
              PQclear(res);
              goto error_return;
            }

            pqSetenvPoll__1__2__1__1__6__1__val=PQgetvalue(res, 0, 0);
            if(!(pqSetenvPoll__1__2__1__1__6__1__val == ((char *)NULL)))
            {
              return_value_strncmp_17=strncmp(pqSetenvPoll__1__2__1__1__6__1__val, "PostgreSQL ", (unsigned long int)11);
              if(return_value_strncmp_17 == 0)
              {
                char *ptr;
                pqSetenvPoll__1__2__1__1__6__1__val = pqSetenvPoll__1__2__1__1__6__1__val + (signed long int)11;
                ptr=strchr(pqSetenvPoll__1__2__1__1__6__1__val, 32);
                if(!(ptr == ((char *)NULL)))
                  *ptr = (char)0;

                pqSaveParameterStatus(conn, "server_version", pqSetenvPoll__1__2__1__1__6__1__val);
              }

            }

            PQclear(res);
          }

          else
            conn->setenv_state = (enum anonymous_11)SETENV_STATE_QUERY2_SEND;
          break;
        }
        case SETENV_STATE_QUERY2_SEND:
        {
          if(conn->sversion >= 70300)
            tmp_if_expr_18 = conn->sversion < 70400 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_18 = (_Bool)0;
          if(tmp_if_expr_18)
            query = "begin; select pg_catalog.pg_client_encoding(); end";

          else
            query = "select pg_client_encoding()";
          return_value_PQsendQuery_19=PQsendQuery(conn, query);
          if(return_value_PQsendQuery_19 == 0)
            goto error_return;

          conn->setenv_state = (enum anonymous_11)SETENV_STATE_QUERY2_WAIT;
          return (enum anonymous_4)PGRES_POLLING_READING;
        }
        case SETENV_STATE_QUERY2_WAIT:
        {
          return_value_PQisBusy_20=PQisBusy(conn);
          if(!(return_value_PQisBusy_20 == 0))
            return (enum anonymous_4)PGRES_POLLING_READING;

          res=PQgetResult(conn);
          if(!(res == ((struct pg_result *)NULL)))
          {
            const char *pqSetenvPoll__1__2__1__1__8__1__val;
            enum anonymous_20 return_value_PQresultStatus_21;
            return_value_PQresultStatus_21=PQresultStatus(res);
            if((signed int)return_value_PQresultStatus_21 == PGRES_COMMAND_OK)
            {
              PQclear(res);
              break;
            }

            enum anonymous_20 return_value_PQresultStatus_23;
            return_value_PQresultStatus_23=PQresultStatus(res);
            if((signed int)return_value_PQresultStatus_23 == PGRES_TUPLES_OK)
            {
              return_value_PQntuples_24=PQntuples(res);
              tmp_if_expr_25 = return_value_PQntuples_24 == 1 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_25 = (_Bool)0;
            if(tmp_if_expr_25)
            {
              pqSetenvPoll__1__2__1__1__8__1__val=PQgetvalue(res, 0, 0);
              if(!(pqSetenvPoll__1__2__1__1__8__1__val == ((const char *)NULL)))
              {
                if(!(*pqSetenvPoll__1__2__1__1__8__1__val == 0))
                  pqSaveParameterStatus(conn, "client_encoding", pqSetenvPoll__1__2__1__1__8__1__val);

              }

            }

            else
            {
              pqSetenvPoll__1__2__1__1__8__1__val=getenv("PGCLIENTENCODING");
              if(!(pqSetenvPoll__1__2__1__1__8__1__val == ((const char *)NULL)))
                tmp_if_expr_22 = *pqSetenvPoll__1__2__1__1__8__1__val != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_22 = (_Bool)0;
              if(tmp_if_expr_22)
                pqSaveParameterStatus(conn, "client_encoding", pqSetenvPoll__1__2__1__1__8__1__val);

              else
                pqSaveParameterStatus(conn, "client_encoding", "SQL_ASCII");
            }
            PQclear(res);
          }

          else
          {
            conn->setenv_state = (enum anonymous_11)SETENV_STATE_IDLE;
            return (enum anonymous_4)PGRES_POLLING_OK;
          }
          break;
        }
        default:
        {
          return_value_libpq_gettext_26=libpq_gettext("invalid state %c, probably indicative of memory corruption\n");
          printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_26, conn->setenv_state);
          goto error_return;
        }
      }

  error_return:
    ;
    conn->setenv_state = (enum anonymous_11)SETENV_STATE_IDLE;
    return (enum anonymous_4)PGRES_POLLING_FAILED;
  }
}

// pqSkipnchar
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 229
extern signed int pqSkipnchar(unsigned long int len, struct pg_conn *conn)
{
  if(!((unsigned long int)(conn->inEnd + -conn->inCursor) >= len))
    return -1;

  else
  {
    if(!(conn->Pfdebug == ((struct _IO_FILE *)NULL)))
    {
      fprintf(conn->Pfdebug, "From backend (%lu)> ", (unsigned long int)len);
      fputnbytes(conn->Pfdebug, conn->inBuffer + (signed long int)conn->inCursor, len);
      fprintf(conn->Pfdebug, "\n");
    }

    conn->inCursor = conn->inCursor + (signed int)len;
    return 0;
  }
}

// pqSocketCheck
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 1050
static signed int pqSocketCheck(struct pg_conn *conn, signed int forRead, signed int forWrite, signed long int end_time)
{
  signed int result;
  signed int return_value_SSL_pending_2;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_3;
  if(conn == ((struct pg_conn *)NULL))
    return -1;

  else
  {
    if(conn->sock == -1)
    {
      char *return_value_libpq_gettext_1;
      return_value_libpq_gettext_1=libpq_gettext("socket not open\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
      return -1;
    }

    if(!(forRead == 0))
    {
      if(conn->ssl == ((struct ssl_st *)NULL))
        goto __CPROVER_DUMP_L3;

      return_value_SSL_pending_2=SSL_pending(conn->ssl);
      if(!(return_value_SSL_pending_2 >= 1))
        goto __CPROVER_DUMP_L3;

      return 1;
    }

    else
    {
      do
      {

      __CPROVER_DUMP_L3:
        ;
        result=pqSocketPoll(conn->sock, forRead, forWrite, end_time);
        if(!(result >= 0))
        {
          return_value___errno_location_3=__errno_location();
          tmp_if_expr_4 = *return_value___errno_location_3 == 4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_4 = (_Bool)0;
      }
      while(tmp_if_expr_4);
      if(!(result >= 0))
      {
        char sebuf[256l];
        char *return_value_libpq_gettext_5;
        return_value_libpq_gettext_5=libpq_gettext("select() failed: %s\n");
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        char *return_value_pqStrerror_7;
        return_value_pqStrerror_7=pqStrerror(*return_value___errno_location_6, sebuf, sizeof(char [256l]) /*256ul*/ );
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_5, return_value_pqStrerror_7);
      }

      return result;
    }
  }
}

// pqSocketPoll
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 1100
static signed int pqSocketPoll(signed int sock, signed int forRead, signed int forWrite, signed long int end_time)
{
  struct pollfd input_fd;
  signed int timeout_ms;
  if(forRead == 0 && forWrite == 0)
    return 0;

  else
  {
    input_fd.fd = sock;
    input_fd.events = (signed short int)0x008;
    input_fd.revents = (signed short int)0;
    if(!(forRead == 0))
      input_fd.events = input_fd.events | (signed short int)0x001;

    if(!(forWrite == 0))
      input_fd.events = input_fd.events | (signed short int)0x004;

    if(end_time == -1l)
      timeout_ms = -1;

    else
    {
      signed long int now;
      now=time((signed long int *)(void *)0);
      if(!(now >= end_time))
        timeout_ms = (signed int)((end_time - now) * (signed long int)1000);

      else
        timeout_ms = 0;
    }
    signed int return_value_poll_1;
    return_value_poll_1=poll(&input_fd, (unsigned long int)1, timeout_ms);
    return return_value_poll_1;
  }
}

// pqStrerror
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/thread.c line 61
extern char * pqStrerror(signed int errnum, char *strerrbuf, unsigned long int buflen)
{
  char *return_value_strerror_r_1;
  return_value_strerror_r_1=strerror_r(errnum, strerrbuf, buflen);
  return return_value_strerror_r_1;
}

// pqWait
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 592
extern signed int pqWait(signed int forRead, signed int forWrite, struct pg_conn *conn)
{
  signed int return_value_pqWaitTimed_1;
  return_value_pqWaitTimed_1=pqWaitTimed(forRead, forWrite, conn, (signed long int)-1);
  return return_value_pqWaitTimed_1;
}

// pqWaitTimed
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 593
extern signed int pqWaitTimed(signed int forRead, signed int forWrite, struct pg_conn *conn, signed long int finish_time)
{
  signed int result;
  result=pqSocketCheck(conn, forRead, forWrite, finish_time);
  if(!(result >= 0))
    return -1;

  else
  {
    if(result == 0)
    {
      char *return_value_libpq_gettext_1;
      return_value_libpq_gettext_1=libpq_gettext("timeout expired\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1);
      return -1;
    }

    return 0;
  }
}

// pqWriteReady
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-misc.c line 1036
extern signed int pqWriteReady(struct pg_conn *conn)
{
  signed int return_value_pqSocketCheck_1;
  return_value_pqSocketCheck_1=pqSocketCheck(conn, 0, 1, (signed long int)0);
  return return_value_pqSocketCheck_1;
}

// pq_block_sigpipe
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 608
extern signed int pq_block_sigpipe(struct anonymous_6 *osigset, char *sigpipe_pending)
{
  struct anonymous_6 sigpipe_sigset;
  struct anonymous_6 sigset;
  sigemptyset(&sigpipe_sigset);
  sigaddset(&sigpipe_sigset, 13);
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1=pthread_sigmask(0, &sigpipe_sigset, osigset);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  if(!(*return_value___errno_location_2 == 0))
    return -1;

  else
  {
    signed int return_value_sigismember_5;
    return_value_sigismember_5=sigismember(osigset, 13);
    if(!(return_value_sigismember_5 == 0))
    {
      signed int return_value_sigpending_3;
      return_value_sigpending_3=sigpending(&sigset);
      if(!(return_value_sigpending_3 == 0))
        return -1;

      signed int return_value_sigismember_4;
      return_value_sigismember_4=sigismember(&sigset, 13);
      if(!(return_value_sigismember_4 == 0))
        *sigpipe_pending = (char)1;

      else
        *sigpipe_pending = (char)0;
    }

    else
      *sigpipe_pending = (char)0;
    return 0;
  }
}

// pq_lockingcallback
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 870
static void pq_lockingcallback(signed int mode, signed int n, const char *file, signed int line)
{
  if(!((1 & mode) == 0))
  {
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&pq_lockarray[(signed long int)n]);
    if(!(return_value_pthread_mutex_lock_1 == 0))
      do
      {
        fprintf(stderr, "%s\n", (const void *)"failed to lock mutex");
        abort();
      }
      while((_Bool)0);

  }

  else
  {
    signed int return_value_pthread_mutex_unlock_2;
    return_value_pthread_mutex_unlock_2=pthread_mutex_unlock(&pq_lockarray[(signed long int)n]);
    if(!(return_value_pthread_mutex_unlock_2 == 0))
      do
      {
        fprintf(stderr, "%s\n", (const void *)"failed to unlock mutex");
        abort();
      }
      while((_Bool)0);

  }
}

// pq_reset_sigpipe
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 609
extern void pq_reset_sigpipe(struct anonymous_6 *osigset, char sigpipe_pending, char got_epipe)
{
  signed int save_errno;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  save_errno = *return_value___errno_location_1;
  signed int signo;
  struct anonymous_6 sigset;
  signed int return_value_sigismember_2;
  if(sigpipe_pending == 0 && !(got_epipe == 0))
  {
    signed int return_value_sigpending_3;
    return_value_sigpending_3=sigpending(&sigset);
    if(return_value_sigpending_3 == 0)
    {
      return_value_sigismember_2=sigismember(&sigset, 13);
      if(!(return_value_sigismember_2 == 0))
      {
        struct anonymous_6 sigpipe_sigset;
        sigemptyset(&sigpipe_sigset);
        sigaddset(&sigpipe_sigset, 13);
        sigwait(&sigpipe_sigset, &signo);
      }

    }

  }

  pthread_sigmask(2, osigset, (struct anonymous_6 *)(void *)0);
  signed int *return_value___errno_location_4;
  return_value___errno_location_4=__errno_location();
  *return_value___errno_location_4 = save_errno;
}

// pq_threadidcallback
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 857
static unsigned long int pq_threadidcallback(void)
{
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  return (unsigned long int)return_value_pthread_self_1;
}

// pqsecure_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 603
extern void pqsecure_close(struct pg_conn *conn)
{
  if(!(conn->ssl == ((struct ssl_st *)NULL)))
    close_SSL(conn);

}

// pqsecure_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 242
extern void pqsecure_destroy(void)
{
  destroySSL();
}

// pqsecure_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 600
extern signed int pqsecure_initialize(struct pg_conn *conn)
{
  signed int r = 0;
  r=init_ssl_system(conn);
  return r;
}

// pqsecure_open_client
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 602
extern enum anonymous_4 pqsecure_open_client(struct pg_conn *conn)
{
  _Bool tmp_if_expr_5;
  signed int return_value_SSL_set_ex_data_4;
  _Bool tmp_if_expr_7;
  signed int return_value_SSL_set_fd_6;
  if(conn->ssl == ((struct ssl_st *)NULL))
  {
    signed int rc;
    conn->sigpipe_flag = (char)0;
    rc=pthread_mutex_lock(&ssl_config_mutex);
    if(!(rc == 0))
    {
      char *return_value_libpq_gettext_1;
      return_value_libpq_gettext_1=libpq_gettext("could not acquire mutex: %s\n");
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(rc);
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1, return_value_strerror_2);
      return (enum anonymous_4)PGRES_POLLING_FAILED;
    }

    conn->ssl=SSL_new(SSL_context);
    if(conn->ssl == ((struct ssl_st *)NULL))
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_SSL_set_ex_data_4=SSL_set_ex_data(conn->ssl, 0, (void *)(char *)conn);
      tmp_if_expr_5 = !(return_value_SSL_set_ex_data_4 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_SSL_set_fd_6=SSL_set_fd(conn->ssl, conn->sock);
      tmp_if_expr_7 = !(return_value_SSL_set_fd_6 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
    {
      char *err;
      err=SSLerrmessage();
      char *return_value_libpq_gettext_3;
      return_value_libpq_gettext_3=libpq_gettext("could not establish SSL connection: %s\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3, err);
      SSLerrfree(err);
      pthread_mutex_unlock(&ssl_config_mutex);
      close_SSL(conn);
      return (enum anonymous_4)PGRES_POLLING_FAILED;
    }

    pthread_mutex_unlock(&ssl_config_mutex);
    signed int return_value_initialize_SSL_8;
    return_value_initialize_SSL_8=initialize_SSL(conn);
    if(!(return_value_initialize_SSL_8 == 0))
    {
      close_SSL(conn);
      return (enum anonymous_4)PGRES_POLLING_FAILED;
    }

  }

  enum anonymous_4 return_value_open_client_SSL_9;
  return_value_open_client_SSL_9=open_client_SSL(conn);
  return return_value_open_client_SSL_9;
}

// pqsecure_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 604
extern signed long int pqsecure_read(struct pg_conn *conn, void *ptr, unsigned long int len)
{
  signed long int n;
  signed int result_errno = 0;
  char sebuf[256l];
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_3;
  signed int return_value_SSL_read_4;
  char *return_value_libpq_gettext_6;
  char *return_value_libpq_gettext_7;
  char *return_value_pqStrerror_8;
  _Bool tmp_if_expr_13;
  char *return_value_libpq_gettext_15;
  char *return_value_libpq_gettext_16;
  char *return_value_pqStrerror_17;
  if(!(conn->ssl == ((struct ssl_st *)NULL)))
  {
    signed int err;
    struct sigpipe_info spinfo;
    do
    {
      spinfo.got_epipe = (char)0;
      if(!(conn->sigpipe_so == 0))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = conn->sigpipe_flag != 0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_2)
      {
        signed int return_value_pq_block_sigpipe_1;
        return_value_pq_block_sigpipe_1=pq_block_sigpipe(&spinfo.oldsigmask, &spinfo.sigpipe_pending);
        if(!(return_value_pq_block_sigpipe_1 >= 0))
          return (signed long int)-1;

      }

    }
    while((_Bool)0);
    do
    {

    rloop:
      ;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 0;
      return_value_SSL_read_4=SSL_read(conn->ssl, ptr, (signed int)len);
      n = (signed long int)return_value_SSL_read_4;
      err=SSL_get_error(conn->ssl, (signed int)n);
      if(!(err == 0))
      {
        if(err == 2)
          goto __CPROVER_DUMP_L9;

        if(err == 3)
          continue;

        if(err == 5)
          break;

        if(err == 1)
          goto __CPROVER_DUMP_L18;

        if(err == 6)
          goto __CPROVER_DUMP_L19;

        goto __CPROVER_DUMP_L20;
      }

      if(!(n >= 0l))
      {
        printfPQExpBuffer(&conn->errorMessage, "SSL_read failed but did not provide error information\n");
        result_errno = 104;
      }

      goto __CPROVER_DUMP_L21;

    __CPROVER_DUMP_L9:
      ;
      n = (signed long int)0;
      goto __CPROVER_DUMP_L21;
    }
    while((_Bool)1);
    if(!(n >= 0l))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      result_errno = *return_value___errno_location_5;
      do
        if(result_errno == 32)
          spinfo.got_epipe = (char)1;

      while((_Bool)0);
      if(result_errno == 32 || result_errno == 104)
      {
        return_value_libpq_gettext_6=libpq_gettext("server closed the connection unexpectedly\n\tThis probably means the server terminated abnormally\n\tbefore or while processing the request.\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_6);
      }

      else
      {
        return_value_libpq_gettext_7=libpq_gettext("SSL SYSCALL error: %s\n");
        return_value_pqStrerror_8=pqStrerror(result_errno, sebuf, sizeof(char [256l]) /*256ul*/ );
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_7, return_value_pqStrerror_8);
      }
    }

    else
    {
      char *return_value_libpq_gettext_9;
      return_value_libpq_gettext_9=libpq_gettext("SSL SYSCALL error: EOF detected\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_9);
      result_errno = 104;
      n = (signed long int)-1;
    }
    goto __CPROVER_DUMP_L21;

  __CPROVER_DUMP_L18:
    ;
    char *errm;
    errm=SSLerrmessage();
    char *return_value_libpq_gettext_10;
    return_value_libpq_gettext_10=libpq_gettext("SSL error: %s\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_10, errm);
    SSLerrfree(errm);
    result_errno = 104;
    n = (signed long int)-1;
    goto __CPROVER_DUMP_L21;

  __CPROVER_DUMP_L19:
    ;
    char *return_value_libpq_gettext_11;
    return_value_libpq_gettext_11=libpq_gettext("SSL connection has been closed unexpectedly\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_11);
    result_errno = 104;
    n = (signed long int)-1;
    goto __CPROVER_DUMP_L21;

  __CPROVER_DUMP_L20:
    ;
    char *return_value_libpq_gettext_12;
    return_value_libpq_gettext_12=libpq_gettext("unrecognized SSL error code: %d\n");
    printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_12, err);
    result_errno = 104;
    n = (signed long int)-1;
    goto __CPROVER_DUMP_L21;
    do
    {

    __CPROVER_DUMP_L21:
      ;
      if(!(conn->sigpipe_so == 0))
        tmp_if_expr_13 = (_Bool)1;

      else
        tmp_if_expr_13 = conn->sigpipe_flag != 0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_13)
        pq_reset_sigpipe(&spinfo.oldsigmask, spinfo.sigpipe_pending, spinfo.got_epipe);

    }
    while((_Bool)0);
  }

  else
  {
    n=recv(conn->sock, ptr, len, 0);
    if(!(n >= 0l))
    {
      signed int *return_value___errno_location_14;
      return_value___errno_location_14=__errno_location();
      result_errno = *return_value___errno_location_14;
      switch(result_errno)
      {
        case 11:

        case 4:
          break;
        case 104:
        {
          return_value_libpq_gettext_15=libpq_gettext("server closed the connection unexpectedly\n\tThis probably means the server terminated abnormally\n\tbefore or while processing the request.\n");
          printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_15);
          break;
        }
        default:
        {
          return_value_libpq_gettext_16=libpq_gettext("could not receive data from server: %s\n");
          return_value_pqStrerror_17=pqStrerror(result_errno, sebuf, sizeof(char [256l]) /*256ul*/ );
          printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_16, return_value_pqStrerror_17);
        }
      }
    }

  }
  signed int *return_value___errno_location_18;
  return_value___errno_location_18=__errno_location();
  *return_value___errno_location_18 = result_errno;
  return n;
}

// pqsecure_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/libpq-int.h line 605
extern signed long int pqsecure_write(struct pg_conn *conn, const void *ptr, unsigned long int len)
{
  signed long int n;
  signed int result_errno = 0;
  char sebuf[256l];
  struct sigpipe_info spinfo;
  _Bool tmp_if_expr_2;
  char *return_value_libpq_gettext_6;
  char *return_value_libpq_gettext_7;
  char *return_value_pqStrerror_8;
  char *errm;
  char *return_value_libpq_gettext_10;
  char *return_value_libpq_gettext_11;
  char *return_value_libpq_gettext_12;
  _Bool tmp_if_expr_14;
  signed int *return_value___errno_location_15;
  char *return_value_libpq_gettext_16;
  char *return_value_libpq_gettext_17;
  char *return_value_pqStrerror_18;
  if(!(conn->ssl == ((struct ssl_st *)NULL)))
  {
    signed int err;
    do
    {
      spinfo.got_epipe = (char)0;
      if(!(conn->sigpipe_so == 0))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = conn->sigpipe_flag != 0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_2)
      {
        signed int return_value_pq_block_sigpipe_1;
        return_value_pq_block_sigpipe_1=pq_block_sigpipe(&spinfo.oldsigmask, &spinfo.sigpipe_pending);
        if(!(return_value_pq_block_sigpipe_1 >= 0))
          return (signed long int)-1;

      }

    }
    while((_Bool)0);
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = 0;
    signed int return_value_SSL_write_4;
    return_value_SSL_write_4=SSL_write(conn->ssl, ptr, (signed int)len);
    n = (signed long int)return_value_SSL_write_4;
    err=SSL_get_error(conn->ssl, (signed int)n);
    switch(err)
    {
      case 0:
      {
        if(!(n >= 0l))
        {
          printfPQExpBuffer(&conn->errorMessage, "SSL_write failed but did not provide error information\n");
          result_errno = 104;
        }

        break;
      }
      case 2:
      {
        n = (signed long int)0;
        break;
      }
      case 3:
      {
        n = (signed long int)0;
        break;
      }
      case 5:
      {
        if(!(n >= 0l))
        {
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          result_errno = *return_value___errno_location_5;
          do
            if(result_errno == 32)
              spinfo.got_epipe = (char)1;

          while((_Bool)0);
          if(result_errno == 32 || result_errno == 104)
          {
            return_value_libpq_gettext_6=libpq_gettext("server closed the connection unexpectedly\n\tThis probably means the server terminated abnormally\n\tbefore or while processing the request.\n");
            printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_6);
          }

          else
          {
            return_value_libpq_gettext_7=libpq_gettext("SSL SYSCALL error: %s\n");
            return_value_pqStrerror_8=pqStrerror(result_errno, sebuf, sizeof(char [256l]) /*256ul*/ );
            printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_7, return_value_pqStrerror_8);
          }
        }

        else
        {
          char *return_value_libpq_gettext_9;
          return_value_libpq_gettext_9=libpq_gettext("SSL SYSCALL error: EOF detected\n");
          printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_9);
          result_errno = 104;
          n = (signed long int)-1;
        }
        break;
      }
      case 1:
      {
        errm=SSLerrmessage();
        return_value_libpq_gettext_10=libpq_gettext("SSL error: %s\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_10, errm);
        SSLerrfree(errm);
        result_errno = 104;
        n = (signed long int)-1;
        break;
      }
      case 6:
      {
        return_value_libpq_gettext_11=libpq_gettext("SSL connection has been closed unexpectedly\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_11);
        result_errno = 104;
        n = (signed long int)-1;
        break;
      }
      default:
      {
        return_value_libpq_gettext_12=libpq_gettext("unrecognized SSL error code: %d\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_12, err);
        result_errno = 104;
        n = (signed long int)-1;
      }
    }
  }

  else
  {
    signed int flags = 0;
    if(!(conn->sigpipe_flag == 0))
      flags = flags | 16384;

    do
    {

    retry_masked:
      ;
      spinfo.got_epipe = (char)0;
      if(!(conn->sigpipe_so == 0))
        tmp_if_expr_14 = (_Bool)1;

      else
        tmp_if_expr_14 = conn->sigpipe_flag != 0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_14)
      {
        signed int return_value_pq_block_sigpipe_13;
        return_value_pq_block_sigpipe_13=pq_block_sigpipe(&spinfo.oldsigmask, &spinfo.sigpipe_pending);
        if(!(return_value_pq_block_sigpipe_13 >= 0))
          return (signed long int)-1;

      }

      n=send(conn->sock, ptr, len, flags);
      if(n >= 0l)
        goto __CPROVER_DUMP_L34;

      return_value___errno_location_15=__errno_location();
      result_errno = *return_value___errno_location_15;
      if(!(result_errno == 22) || flags == 0)
        break;

      conn->sigpipe_flag = (char)0;
      flags = 0;
    }
    while((_Bool)1);
    switch(result_errno)
    {
      case 11:

      case 4:
        break;
      case 32:
        do
          spinfo.got_epipe = (char)1;
        while((_Bool)0);
      case 104:
      {
        return_value_libpq_gettext_16=libpq_gettext("server closed the connection unexpectedly\n\tThis probably means the server terminated abnormally\n\tbefore or while processing the request.\n");
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_16);
        break;
      }
      default:
      {
        return_value_libpq_gettext_17=libpq_gettext("could not send data to server: %s\n");
        return_value_pqStrerror_18=pqStrerror(result_errno, sebuf, sizeof(char [256l]) /*256ul*/ );
        printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_17, return_value_pqStrerror_18);
      }
    }
  }

__CPROVER_DUMP_L34:
  ;
  _Bool tmp_if_expr_19;
  do
  {
    if(!(conn->sigpipe_so == 0))
      tmp_if_expr_19 = (_Bool)1;

    else
      tmp_if_expr_19 = conn->sigpipe_flag != 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_19)
      pq_reset_sigpipe(&spinfo.oldsigmask, spinfo.sigpipe_pending, spinfo.got_epipe);

  }
  while((_Bool)0);
  signed int *return_value___errno_location_20;
  return_value___errno_location_20=__errno_location();
  *return_value___errno_location_20 = result_errno;
  return n;
}

// pqsignal
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 475
extern void (*pqsignal(signed int signo, void (*func)(signed int)))(signed int)
{
  struct sigaction act;
  struct sigaction oact;
  act.__sigaction_handler.sa_handler = func;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0x10000000;
  if(signo == 17)
    act.sa_flags = act.sa_flags | 1;

  signed int return_value_sigaction_1;
  return_value_sigaction_1=sigaction(signo, &act, &oact);
  if(!(return_value_sigaction_1 >= 0))
    return (void (*)(signed int))-1;

  else
    return oact.__sigaction_handler.sa_handler;
}

// preparedStatementName
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 896
static void preparedStatementName(char *buffer, signed int file, signed int state)
{
  sprintf(buffer, "P%d_%d", file, state);
}

// printResults
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 2260
static void printResults(signed int ttype, signed long int normal_xacts, signed int nclients, struct anonymous_17 *threads, signed int nthreads, struct timeval total_time, struct timeval conn_total_time, signed long int total_latencies, signed long int total_sqlats, signed long int throttle_lag, signed long int throttle_lag_max)
{
  double time_include;
  double tps_include;
  double tps_exclude;
  char *s;
  time_include = (double)total_time.tv_sec + (double)total_time.tv_usec / 1000000.0;
  tps_include = (double)normal_xacts / time_include;
  tps_exclude = (double)normal_xacts / (time_include - ((double)conn_total_time.tv_sec + (double)conn_total_time.tv_usec / 1000000.0) / (double)nthreads);
  if(ttype == 0)
    s = "TPC-B (sort of)";

  else
    if(ttype == 2)
      s = "Update only pgbench_accounts";

    else
      if(ttype == 1)
        s = "SELECT only";

      else
        s = "Custom query";
  printf("transaction type: %s\n", s);
  printf("scaling factor: %d\n", scale);
  printf("query mode: %s\n", QUERYMODE[(signed long int)querymode]);
  printf("number of clients: %d\n", nclients);
  printf("number of threads: %d\n", nthreads);
  if(!(duration >= 1))
  {
    printf("number of transactions per client: %d\n", nxacts);
    printf("number of transactions actually processed: %ld/%ld\n", normal_xacts, (signed long int)nxacts * (signed long int)nclients);
  }

  else
  {
    printf("duration: %d s\n", duration);
    printf("number of transactions actually processed: %ld\n", normal_xacts);
  }
  if(normal_xacts >= 1l)
  {
    if(!(progress == 0) || !(throttle_delay == 0l))
    {
      double latency = (0.001 * (double)total_latencies) / (double)normal_xacts;
      double sqlat = (double)total_sqlats / (double)normal_xacts;
      double return_value_sqrt_1;
      return_value_sqrt_1=sqrt(sqlat - 1000000.0 * latency * latency);
      printf("latency average: %.3f ms\nlatency stddev: %.3f ms\n", latency, 0.001 * return_value_sqrt_1);
    }

    else
      printf("latency average: %.3f ms\n", (1000.0 * (double)duration * (double)nclients) / (double)normal_xacts);
    if(!(throttle_delay == 0l))
      printf("rate limit schedule lag: avg %.3f (max %.3f) ms\n", (0.001 * (double)throttle_lag) / (double)normal_xacts, 0.001 * (double)throttle_lag_max);

    printf("tps = %f (including connections establishing)\n", tps_include);
    printf("tps = %f (excluding connections establishing)\n", tps_exclude);
    if(!(is_latencies == 0))
    {
      signed int i = 0;
      for( ; !(i >= num_files); i = i + 1)
      {
        struct anonymous_22 **commands;
        if(num_files >= 2)
          printf("statement latencies in milliseconds, file %d:\n", i + 1);

        else
          printf("statement latencies in milliseconds:\n");
        commands = sql_files[(signed long int)i];
        for( ; !(*commands == ((struct anonymous_22 *)NULL)); commands = commands + 1l)
        {
          struct anonymous_22 *command = *commands;
          signed int cnum = command->command_num;
          double printResults__1__6__1__1__1__1__total_time;
          struct timeval total_exec_elapsed;
          signed int total_exec_count;
          signed int t;
          total_exec_elapsed.tv_sec = (signed long int)0;
          total_exec_elapsed.tv_usec = (signed long int)0;
          total_exec_count = 0;
          t = 0;
          for( ; !(t >= nthreads); t = t + 1)
          {
            struct anonymous_17 *thread = &threads[(signed long int)t];
            do
            {
              total_exec_elapsed.tv_sec = total_exec_elapsed.tv_sec + (thread->exec_elapsed + (signed long int)cnum)->tv_sec;
              total_exec_elapsed.tv_usec = total_exec_elapsed.tv_usec + (thread->exec_elapsed + (signed long int)cnum)->tv_usec;
              for( ; total_exec_elapsed.tv_usec >= 1000000l; total_exec_elapsed.tv_sec = total_exec_elapsed.tv_sec + 1l)
                total_exec_elapsed.tv_usec = total_exec_elapsed.tv_usec - (signed long int)1000000;
            }
            while((_Bool)0);
            total_exec_count = total_exec_count + thread->exec_count[(signed long int)cnum];
          }
          if(total_exec_count >= 1)
            printResults__1__6__1__1__1__1__total_time = ((double)total_exec_elapsed.tv_sec * 1000.0 + (double)total_exec_elapsed.tv_usec / 1000.0) / (double)total_exec_count;

          else
            printResults__1__6__1__1__1__1__total_time = 0.0;
          printf("\t%f\t%s\n", printResults__1__6__1__1__1__1__total_time, command->line);
        }
      }
    }

  }

}

// print_val
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/tar.c line 10
static void print_val(char *s, unsigned long int val, unsigned int base, unsigned long int len)
{
  signed int i = (signed int)len;
  for( ; i >= 1; i = i - 1)
  {
    signed int digit = (signed int)(val % (unsigned long int)base);
    s[(signed long int)(i - 1)] = (char)(48 + digit);
    val = val / (unsigned long int)base;
  }
}

// print_val_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/tar.c line 10
static void print_val_link1(char *s_link1, unsigned long int val_link1, unsigned int base_link1, unsigned long int len_link1)
{
  signed int i_link1 = (signed int)len_link1;
  for( ; i_link1 >= 1; i_link1 = i_link1 - 1)
  {
    signed int digit_link1 = (signed int)(val_link1 % (unsigned long int)base_link1);
    s_link1[(signed long int)(i_link1 - 1)] = (char)(48 + digit_link1);
    val_link1 = val_link1 / (unsigned long int)base_link1;
  }
}

// printfPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 150
extern void printfPQExpBuffer(struct PQExpBufferData *str, const char *fmt, ...)
{
  void **args;
  char done;
  resetPQExpBuffer(str);
  _Bool tmp_if_expr_1;
  if(str == ((struct PQExpBufferData *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = str->maxlen == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
    do
    {
      args = (void **)&fmt;
      done=appendPQExpBufferVA(str, fmt, args);
      args = ((void **)NULL);
    }
    while(done == 0);

}

// process_builtin
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 2208
static struct anonymous_22 ** process_builtin(char *tb)
{
  struct anonymous_22 **my_commands;
  signed int lineno;
  char buf[8192l];
  signed int alloc_num = 128;
  void *return_value_pg_malloc_1;
  return_value_pg_malloc_1=pg_malloc(sizeof(struct anonymous_22 *) /*8ul*/  * (unsigned long int)alloc_num);
  my_commands = (struct anonymous_22 **)return_value_pg_malloc_1;
  lineno = 0;
  char *tmp_post_2;
  char *tmp_post_3;
  do
  {
    char *p;
    struct anonymous_22 *command;
    p = buf;
    for( ; !(*tb == 0); *tmp_post_2 = *tmp_post_3)
    {
      if((signed int)*tb == 10)
        break;

      tmp_post_2 = p;
      p = p + 1l;
      tmp_post_3 = tb;
      tb = tb + 1l;
    }
    if((signed int)*tb == 0)
      break;

    if((signed int)*tb == 10)
      tb = tb + 1l;

    *p = (char)0;
    command=process_commands(buf);
    if(!(command == ((struct anonymous_22 *)NULL)))
    {
      my_commands[(signed long int)lineno] = command;
      lineno = lineno + 1;
      if(lineno >= alloc_num)
      {
        alloc_num = alloc_num + 128;
        void *return_value_pg_realloc_4;
        return_value_pg_realloc_4=pg_realloc((void *)my_commands, sizeof(struct anonymous_22 *) /*8ul*/  * (unsigned long int)alloc_num);
        my_commands = (struct anonymous_22 **)return_value_pg_realloc_4;
      }

    }

  }
  while((_Bool)1);
  my_commands[(signed long int)lineno] = (struct anonymous_22 *)(void *)0;
  return my_commands;
}

// process_commands
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 1948
static struct anonymous_22 * process_commands(char *buf)
{
  const char delim[7l] = { ' ', 12, '\n', '\r', '\t', 11, 0 };
  struct anonymous_22 *my_commands;
  signed int j;
  char *p;
  char *tok;
  p=strchr(buf, 10);
  if(!(p == ((char *)NULL)))
    *p = (char)0;

  p = buf;
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*p]) == 0)
      break;

    p = p + 1l;
  }
  while((_Bool)1);
  _Bool tmp_if_expr_3;
  signed int return_value_strncmp_2;
  if((signed int)*p == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strncmp_2=strncmp(p, "--", (unsigned long int)2);
    tmp_if_expr_3 = return_value_strncmp_2 == 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int tmp_post_5;
  signed int tmp_post_6;
  signed int return_value_pg_strcasecmp_14;
  signed int return_value_pg_strcasecmp_13;
  const unsigned short int **return_value___ctype_b_loc_7;
  signed int return_value_pg_strcasecmp_9;
  signed int return_value_pg_strcasecmp_8;
  signed int return_value_pg_strcasecmp_12;
  signed int return_value_pg_strcasecmp_11;
  char return_value_parseQuery_16;
  if(tmp_if_expr_3)
    return (struct anonymous_22 *)(void *)0;

  else
  {
    void *return_value_pg_malloc_4;
    return_value_pg_malloc_4=pg_malloc(sizeof(struct anonymous_22) /*104ul*/ );
    my_commands = (struct anonymous_22 *)return_value_pg_malloc_4;
    my_commands->line=pg_strdup(buf);
    tmp_post_5 = num_commands;
    num_commands = num_commands + 1;
    my_commands->command_num = tmp_post_5;
    my_commands->type = 0;
    my_commands->argc = 0;
    if((signed int)*p == 92)
    {
      my_commands->type = 2;
      j = 0;
      p = p + 1l;
      tok=strtok(p, delim);
      while(!(tok == ((char *)NULL)))
      {
        tmp_post_6 = j;
        j = j + 1;
        my_commands->argv[(signed long int)tmp_post_6]=pg_strdup(tok);
        my_commands->argc = my_commands->argc + 1;
        tok=strtok((char *)(void *)0, delim);
      }
      signed int return_value_pg_strcasecmp_15;
      return_value_pg_strcasecmp_15=pg_strcasecmp(my_commands->argv[(signed long int)0], "setrandom");
      if(return_value_pg_strcasecmp_15 == 0)
      {
        if(!(my_commands->argc >= 4))
        {
          fprintf(stderr, "%s: missing argument\n", my_commands->argv[(signed long int)0]);
          exit(1);
        }

        j = 4;
        for( ; !(j >= my_commands->argc); j = j + 1)
          fprintf(stderr, "%s: extra argument \"%s\" ignored\n", my_commands->argv[(signed long int)0], my_commands->argv[(signed long int)j]);
      }

      else
      {
        return_value_pg_strcasecmp_14=pg_strcasecmp(my_commands->argv[(signed long int)0], "set");
        if(return_value_pg_strcasecmp_14 == 0)
        {
          if(!(my_commands->argc >= 3))
          {
            fprintf(stderr, "%s: missing argument\n", my_commands->argv[(signed long int)0]);
            exit(1);
          }

          j = my_commands->argc < 5 ? 3 : 5;
          for( ; !(j >= my_commands->argc); j = j + 1)
            fprintf(stderr, "%s: extra argument \"%s\" ignored\n", my_commands->argv[(signed long int)0], my_commands->argv[(signed long int)j]);
        }

        else
        {
          return_value_pg_strcasecmp_13=pg_strcasecmp(my_commands->argv[(signed long int)0], "sleep");
          if(return_value_pg_strcasecmp_13 == 0)
          {
            if(!(my_commands->argc >= 2))
            {
              fprintf(stderr, "%s: missing argument\n", my_commands->argv[(signed long int)0]);
              exit(1);
            }

            if(!((signed int)*my_commands->argv[1l] == 58))
            {
              char *c = my_commands->argv[(signed long int)1];
              do
              {
                return_value___ctype_b_loc_7=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)(unsigned char)*c]) == 0)
                  break;

                c = c + 1l;
              }
              while((_Bool)1);
              if(!(*c == 0))
              {
                my_commands->argv[(signed long int)2] = c;
                if(!(my_commands->argc >= 3))
                  my_commands->argc = 3;

              }

            }

            if(my_commands->argc >= 3)
            {
              signed int return_value_pg_strcasecmp_10;
              return_value_pg_strcasecmp_10=pg_strcasecmp(my_commands->argv[(signed long int)2], "us");
              if(!(return_value_pg_strcasecmp_10 == 0))
              {
                return_value_pg_strcasecmp_9=pg_strcasecmp(my_commands->argv[(signed long int)2], "ms");
                if(!(return_value_pg_strcasecmp_9 == 0))
                {
                  return_value_pg_strcasecmp_8=pg_strcasecmp(my_commands->argv[(signed long int)2], "s");
                  if(!(return_value_pg_strcasecmp_8 == 0))
                  {
                    fprintf(stderr, "%s: unknown time unit '%s' - must be us, ms or s\n", my_commands->argv[(signed long int)0], my_commands->argv[(signed long int)2]);
                    exit(1);
                  }

                }

              }

            }

            j = 3;
            for( ; !(j >= my_commands->argc); j = j + 1)
              fprintf(stderr, "%s: extra argument \"%s\" ignored\n", my_commands->argv[(signed long int)0], my_commands->argv[(signed long int)j]);
          }

          else
          {
            return_value_pg_strcasecmp_12=pg_strcasecmp(my_commands->argv[(signed long int)0], "setshell");
            if(return_value_pg_strcasecmp_12 == 0)
            {
              if(!(my_commands->argc >= 3))
              {
                fprintf(stderr, "%s: missing argument\n", my_commands->argv[(signed long int)0]);
                exit(1);
              }

            }

            else
            {
              return_value_pg_strcasecmp_11=pg_strcasecmp(my_commands->argv[(signed long int)0], "shell");
              if(return_value_pg_strcasecmp_11 == 0)
              {
                if(!(my_commands->argc >= 1))
                {
                  fprintf(stderr, "%s: missing command\n", my_commands->argv[(signed long int)0]);
                  exit(1);
                }

              }

              else
              {
                fprintf(stderr, "Invalid command %s\n", my_commands->argv[(signed long int)0]);
                exit(1);
              }
            }
          }
        }
      }
    }

    else
    {
      my_commands->type = 1;
      switch((signed int)querymode)
      {
        case QUERY_SIMPLE:
        {
          my_commands->argv[(signed long int)0]=pg_strdup(p);
          my_commands->argc = my_commands->argc + 1;
          break;
        }
        case QUERY_EXTENDED:

        case QUERY_PREPARED:
        {
          return_value_parseQuery_16=parseQuery(my_commands, p);
          if(return_value_parseQuery_16 == 0)
            exit(1);

          break;
        }
        default:
          exit(1);
      }
    }
    return my_commands;
  }
}

// process_file
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 2148
static signed int process_file(char *filename)
{
  struct anonymous_22 **my_commands;
  struct _IO_FILE *fd;
  signed int lineno;
  char *buf;
  signed int alloc_num;
  if(num_files >= 128)
  {
    fprintf(stderr, "Up to only %d SQL files are allowed\n", 128);
    exit(1);
  }

  alloc_num = 128;
  void *return_value_pg_malloc_1;
  return_value_pg_malloc_1=pg_malloc(sizeof(struct anonymous_22 *) /*8ul*/  * (unsigned long int)alloc_num);
  my_commands = (struct anonymous_22 **)return_value_pg_malloc_1;
  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(filename, "-");
  if(return_value_strcmp_4 == 0)
    fd = stdin;

  else
  {
    fd=fopen(filename, "r");
    if(fd == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      fprintf(stderr, "%s: %s\n", filename, return_value_strerror_3);
      pg_free((void *)my_commands);
      return (signed int)(char)0;
    }

  }
  lineno = 0;
  do
  {
    buf=read_line_from_file(fd);
    if(buf == ((char *)NULL))
      break;

    struct anonymous_22 *command;
    command=process_commands(buf);
    free((void *)buf);
    if(!(command == ((struct anonymous_22 *)NULL)))
    {
      my_commands[(signed long int)lineno] = command;
      lineno = lineno + 1;
      if(lineno >= alloc_num)
      {
        alloc_num = alloc_num + 128;
        void *return_value_pg_realloc_5;
        return_value_pg_realloc_5=pg_realloc((void *)my_commands, sizeof(struct anonymous_22 *) /*8ul*/  * (unsigned long int)alloc_num);
        my_commands = (struct anonymous_22 **)return_value_pg_realloc_5;
      }

    }

  }
  while((_Bool)1);
  fclose(fd);
  my_commands[(signed long int)lineno] = (struct anonymous_22 *)(void *)0;
  signed int tmp_post_6 = num_files;
  num_files = num_files + 1;
  sql_files[(signed long int)tmp_post_6] = my_commands;
  return (signed int)(char)1;
}

// psprintf
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/psprintf.c line 46
extern char * psprintf(const char *fmt, ...)
{
  unsigned long int len = (unsigned long int)128;
  do
  {
    char *result;
    void **args;
    unsigned long int newlen;
    void *return_value_palloc_1;
    return_value_palloc_1=palloc(len);
    result = (char *)return_value_palloc_1;
    args = (void **)&fmt;
    newlen=pvsnprintf(result, len, fmt, args);
    args = ((void **)NULL);
    if(!(newlen >= len))
      return result;

    pfree((void *)result);
    len = newlen;
  }
  while((_Bool)1);
}

// pstrdup
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 20
extern char * pstrdup(const char *in)
{
  char *return_value_pg_strdup_1;
  return_value_pg_strdup_1=pg_strdup(in);
  return return_value_pg_strdup_1;
}

// putVariable
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 639
static signed int putVariable(struct anonymous_18 *st, const char *context, char *name, char *value)
{
  struct anonymous_21 key;
  struct anonymous_21 *var;
  key.name = name;
  void *return_value_bsearch_1;
  if(st->nvariables >= 1)
  {
    return_value_bsearch_1=bsearch((void *)&key, (void *)st->variables, (unsigned long int)st->nvariables, sizeof(struct anonymous_21) /*16ul*/ , compareVariables);
    var = (struct anonymous_21 *)return_value_bsearch_1;
  }

  else
    var = (struct anonymous_21 *)(void *)0;
  void *return_value_pg_realloc_3;
  void *return_value_pg_malloc_4;
  if(var == ((struct anonymous_21 *)NULL))
  {
    struct anonymous_21 *newvars;
    char return_value_isLegalVariableName_2;
    return_value_isLegalVariableName_2=isLegalVariableName(name);
    if(return_value_isLegalVariableName_2 == 0)
    {
      fprintf(stderr, "%s: invalid variable name '%s'\n", context, name);
      return (signed int)(char)0;
    }

    if(!(st->variables == ((struct anonymous_21 *)NULL)))
    {
      return_value_pg_realloc_3=pg_realloc((void *)st->variables, (unsigned long int)(st->nvariables + 1) * sizeof(struct anonymous_21) /*16ul*/ );
      newvars = (struct anonymous_21 *)return_value_pg_realloc_3;
    }

    else
    {
      return_value_pg_malloc_4=pg_malloc(sizeof(struct anonymous_21) /*16ul*/ );
      newvars = (struct anonymous_21 *)return_value_pg_malloc_4;
    }
    st->variables = newvars;
    var = &newvars[(signed long int)st->nvariables];
    var->name=pg_strdup(name);
    var->value=pg_strdup(value);
    st->nvariables = st->nvariables + 1;
    pg_qsort((void *)st->variables, (unsigned long int)st->nvariables, sizeof(struct anonymous_21) /*16ul*/ , compareVariables);
  }

  else
  {
    char *val;
    val=pg_strdup(value);
    free((void *)var->value);
    var->value = val;
  }
  return (signed int)(char)1;
}

// pvsnprintf
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/psprintf.c line 104
extern unsigned long int pvsnprintf(char *buf, unsigned long int len, const char *fmt, void **args)
{
  signed int nprinted;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  nprinted=vsnprintf(buf, len, fmt, args);
  signed int *return_value___errno_location_5;
  signed int *return_value___errno_location_4;
  if(!(nprinted >= 0))
  {
    return_value___errno_location_5=__errno_location();
    if(!(*return_value___errno_location_5 == 0))
    {
      return_value___errno_location_4=__errno_location();
      if(!(*return_value___errno_location_4 == 12))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        char *return_value_strerror_3;
        return_value_strerror_3=strerror(*return_value___errno_location_2);
        fprintf(stderr, "vsnprintf failed: %s\n", return_value_strerror_3);
        exit(1);
      }

    }

  }

  if(nprinted >= 0 && !((unsigned long int)nprinted >= len + 18446744073709551615ul))
    return (unsigned long int)nprinted;

  else
    if(nprinted >= 0 && !(len >= (unsigned long int)nprinted))
    {
      if((unsigned long int)nprinted >= 1073741822ul)
        goto __CPROVER_DUMP_L3;

      return (unsigned long int)(nprinted + 2);
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      if(len >= 1073741823ul)
      {
        char *return_value_gettext_6;
        return_value_gettext_6=gettext("out of memory\n");
        fprintf(stderr, return_value_gettext_6);
        exit(1);
      }

      if(len >= 536870911ul)
        return (unsigned long int)0x3fffffff;

      else
        return len * (unsigned long int)2;
    }
}

// pwdfMatchesString
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 5646
static char * pwdfMatchesString(char *buf, char *token)
{
  char *tbuf;
  char *ttok;
  char bslash = (char)0;
  if(buf == ((char *)NULL) || token == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    tbuf = buf;
    ttok = token;
    if((signed int)*tbuf == 42)
    {
      if(!((signed int)tbuf[1l] == 58))
        goto __CPROVER_DUMP_L2;

      return tbuf + (signed long int)2;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      while(!((signed int)*tbuf == 0))
      {
        if((signed int)*tbuf == 92)
        {
          if(bslash == 0)
          {
            tbuf = tbuf + 1l;
            bslash = (char)1;
          }

        }

        if((signed int)*tbuf == 58)
        {
          if((signed int)*ttok == 0)
          {
            if(bslash == 0)
              return tbuf + (signed long int)1;

          }

        }

        bslash = (char)0;
        if((signed int)*ttok == 0)
          return (char *)(void *)0;

        if(*tbuf == *ttok)
        {
          tbuf = tbuf + 1l;
          ttok = ttok + 1l;
        }

        else
          return (char *)(void *)0;
      }
      return (char *)(void *)0;
    }
  }
}

// qsort_arg
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort_arg.c line 113
extern void qsort_arg(void *a, unsigned long int n, unsigned long int es, signed int (*cmp)(const void *, const void *, void *), void *arg)
{
  char *pa;
  char *pb;
  char *pc;
  char *pd;
  char *pl;
  char *pm;
  char *pn;
  unsigned long int d1;
  unsigned long int d2;
  signed int r;
  signed int swaptype;
  signed int presorted;
  _Bool tmp_if_expr_1;
  signed int return_value;
  do
  {

  loop:
    ;
    swaptype = (unsigned long int)((char *)a - (char *)0) % sizeof(signed long int) /*8ul*/  != 0ul || es % sizeof(signed long int) /*8ul*/  != 0ul ? 2 : (es == sizeof(signed long int) /*8ul*/  ? 0 : 1);
    if(!(n >= 7ul))
    {
      pm = (char *)a + (signed long int)es;
      for( ; !(pm >= (char *)a + (signed long int)es * (signed long int)n); pm = pm + (signed long int)es)
      {
        pl = pm;
        do
        {
          if(!((char *)a >= pl))
          {
            return_value=cmp((const void *)(pl - (signed long int)es), (const void *)pl, arg);
            tmp_if_expr_1 = return_value > 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_1 = (_Bool)0;
          if(!tmp_if_expr_1)
            break;

          if(swaptype == 0)
          {
            signed long int t = *((signed long int *)(void *)pl);
            *((signed long int *)(void *)pl) = *((signed long int *)(void *)(pl - (signed long int)es));
            *((signed long int *)(void *)(pl - (signed long int)es)) = t;
          }

          else
            swapfunc_link1(pl, pl - (signed long int)es, es, swaptype);
          pl = pl - (signed long int)es;
        }
        while((_Bool)1);
      }
      goto __CPROVER_DUMP_L38;
    }

    presorted = 1;
    pm = (char *)a + (signed long int)es;
    if(!(pm >= (char *)a + (signed long int)es * (signed long int)n))
    {
      signed int return_value_1;
      return_value_1=cmp((const void *)(pm - (signed long int)es), (const void *)pm, arg);
      if(return_value_1 >= 1)
        presorted = 0;

      else
        pm = pm + (signed long int)es;
    }

    if(!(presorted == 0))
      goto __CPROVER_DUMP_L38;

    pm = (char *)a + (signed long int)((n / (unsigned long int)2) * es);
    if(n >= 8ul)
    {
      pl = (char *)a;
      pn = (char *)a + (signed long int)((n - (unsigned long int)1) * es);
      if(n >= 41ul)
      {
        unsigned long int d = (n / (unsigned long int)8) * es;
        pl=med3_link1(pl, pl + (signed long int)d, pl + (signed long int)((unsigned long int)2 * d), cmp, arg);
        pm=med3_link1(pm - (signed long int)d, pm, pm + (signed long int)d, cmp, arg);
        pn=med3_link1(pn - (signed long int)((unsigned long int)2 * d), pn - (signed long int)d, pn, cmp, arg);
      }

      pm=med3_link1(pl, pm, pn, cmp, arg);
    }

    if(swaptype == 0)
    {
      signed long int qsort_arg__1__4__t = *((signed long int *)(void *)a);
      *((signed long int *)(void *)a) = *((signed long int *)(void *)pm);
      *((signed long int *)(void *)pm) = qsort_arg__1__4__t;
    }

    else
      swapfunc_link1((char *)a, pm, es, swaptype);
    pb = (char *)a + (signed long int)es;
    pa = pb;
    pd = (char *)a + (signed long int)((n - (unsigned long int)1) * es);
    pc = pd;
    for( ; (_Bool)1; pc = pc - (signed long int)es)
    {
      if(pc >= pb)
      {
        r=cmp((const void *)pb, a, arg);
        if(!(r >= 1))
        {
          if(r == 0)
          {
            if(swaptype == 0)
            {
              signed long int qsort_arg__1__5__1__1__1__1__t = *((signed long int *)(void *)pa);
              *((signed long int *)(void *)pa) = *((signed long int *)(void *)pb);
              *((signed long int *)(void *)pb) = qsort_arg__1__5__1__1__1__1__t;
            }

            else
              swapfunc_link1(pa, pb, es, swaptype);
            pa = pa + (signed long int)es;
          }

          pb = pb + (signed long int)es;
        }

      }

      if(pc >= pb)
      {
        r=cmp((const void *)pc, a, arg);
        if(r >= 0)
        {
          if(r == 0)
          {
            if(swaptype == 0)
            {
              signed long int qsort_arg__1__5__1__2__1__1__t = *((signed long int *)(void *)pc);
              *((signed long int *)(void *)pc) = *((signed long int *)(void *)pd);
              *((signed long int *)(void *)pd) = qsort_arg__1__5__1__2__1__1__t;
            }

            else
              swapfunc_link1(pc, pd, es, swaptype);
            pd = pd - (signed long int)es;
          }

          pc = pc - (signed long int)es;
        }

      }

      if(!(pc >= pb))
        break;

      if(swaptype == 0)
      {
        signed long int qsort_arg__1__5__1__3__t = *((signed long int *)(void *)pb);
        *((signed long int *)(void *)pb) = *((signed long int *)(void *)pc);
        *((signed long int *)(void *)pc) = qsort_arg__1__5__1__3__t;
      }

      else
        swapfunc_link1(pb, pc, es, swaptype);
      pb = pb + (signed long int)es;
    }
    pn = (char *)a + (signed long int)(n * es);
    d1 = (unsigned long int)(pa - (char *)a < pb - pa ? pa - (char *)a : pb - pa);
    if(d1 >= 1ul)
      swapfunc_link1((char *)a, pb - (signed long int)d1, d1, swaptype);

    d1 = (unsigned long int)(pd - pc) < (unsigned long int)(pn - pd) - es ? (unsigned long int)(pd - pc) : (unsigned long int)(pn - pd) - es;
    if(d1 >= 1ul)
      swapfunc_link1(pb, pn - (signed long int)d1, d1, swaptype);

    d1 = (unsigned long int)(pb - pa);
    d2 = (unsigned long int)(pd - pc);
    if(d2 >= d1)
    {
      if(!(es >= d1))
        qsort_arg(a, d1 / es, es, cmp, arg);

      if(!(es >= d2))
      {
        a = (void *)(pn - (signed long int)d2);
        n = d2 / es;
        goto loop;
      }

      break;
    }

    if(!(es >= d2))
      qsort_arg((void *)(pn - (signed long int)d2), d2 / es, es, cmp, arg);

    if(es >= d1)
      break;

    n = d1 / es;
  }
  while((_Bool)1);

__CPROVER_DUMP_L38:
  ;
}

// range_sockaddr_AF_INET
// file ip.c line 295
static signed int range_sockaddr_AF_INET(struct sockaddr_in *addr, struct sockaddr_in *netaddr, struct sockaddr_in *netmask)
{
  if(((addr->sin_addr.s_addr ^ netaddr->sin_addr.s_addr) & netmask->sin_addr.s_addr) == 0u)
    return 1;

  else
    return 0;
}

// range_sockaddr_AF_INET6
// file ip.c line 310
static signed int range_sockaddr_AF_INET6(struct sockaddr_in6 *addr, struct sockaddr_in6 *netaddr, struct sockaddr_in6 *netmask)
{
  signed int i = 0;
  for( ; !(i >= 16); i = i + 1)
    if(!((((signed int)addr->sin6_addr.__in6_u.__u6_addr8[(signed long int)i] ^ (signed int)netaddr->sin6_addr.__in6_u.__u6_addr8[(signed long int)i]) & (signed int)netmask->sin6_addr.__in6_u.__u6_addr8[(signed long int)i]) == 0))
      return 0;

  return 1;
}

// read_line_from_file
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 2112
static char * read_line_from_file(struct _IO_FILE *fd)
{
  char tmpbuf[8192l];
  char *buf;
  unsigned long int buflen = (unsigned long int)8192;
  unsigned long int used = (unsigned long int)0;
  void *return_value_palloc_1;
  return_value_palloc_1=palloc(buflen);
  buf = (char *)return_value_palloc_1;
  buf[(signed long int)0] = (char)0;
  char *return_value_fgets_2;
  do
  {
    return_value_fgets_2=fgets(tmpbuf, 8192, fd);
    if(return_value_fgets_2 == ((char *)NULL))
      break;

    unsigned long int thislen;
    thislen=strlen(tmpbuf);
    memcpy((void *)(buf + (signed long int)used), (const void *)tmpbuf, thislen + (unsigned long int)1);
    used = used + thislen;
    if(thislen >= 1ul)
    {
      if((signed int)tmpbuf[-1l + (signed long int)thislen] == 10)
        break;

    }

    buflen = buflen + (unsigned long int)8192;
    void *return_value_pg_realloc_3;
    return_value_pg_realloc_3=pg_realloc((void *)buf, buflen);
    buf = (char *)return_value_pg_realloc_3;
  }
  while((_Bool)1);
  if(used >= 1ul)
    return buf;

  else
  {
    free((void *)buf);
    return (char *)(void *)0;
  }
}

// recognized_connection_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4222
static char recognized_connection_string(const char *connstr)
{
  signed int return_value_uri_prefix_length_1;
  return_value_uri_prefix_length_1=uri_prefix_length(connstr);
  _Bool tmp_if_expr_3;
  char *return_value_strchr_2;
  if(!(return_value_uri_prefix_length_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strchr_2=strchr(connstr, 61);
    tmp_if_expr_3 = return_value_strchr_2 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  return (char)tmp_if_expr_3;
}

// repalloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/common/fe_memutils.h line 23
extern void * repalloc(void *pointer, unsigned long int size)
{
  void *return_value_pg_realloc_1;
  return_value_pg_realloc_1=pg_realloc(pointer, size);
  return return_value_pg_realloc_1;
}

// replaceVariable
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 723
static char * replaceVariable(char **sql, char *param, signed int len, char *value)
{
  signed int valueln;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(value);
  valueln = (signed int)return_value_strlen_1;
  if(!(len >= valueln))
  {
    unsigned long int offset = (unsigned long int)(param - *sql);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(*sql);
    void *return_value_pg_realloc_3;
    return_value_pg_realloc_3=pg_realloc((void *)*sql, (return_value_strlen_2 - (unsigned long int)len) + (unsigned long int)valueln + (unsigned long int)1);
    *sql = (char *)return_value_pg_realloc_3;
    param = *sql + (signed long int)offset;
  }

  unsigned long int return_value_strlen_4;
  if(!(valueln == len))
  {
    return_value_strlen_4=strlen(param + (signed long int)len);
    memmove((void *)(param + (signed long int)valueln), (const void *)(param + (signed long int)len), return_value_strlen_4 + (unsigned long int)1);
  }

  strncpy(param, value, (unsigned long int)valueln);
  return param + (signed long int)valueln;
}

// reportErrorPosition
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-protocol3.c line 1028
static void reportErrorPosition(struct PQExpBufferData *msg, const char *query, signed int loc, signed int encoding)
{
  char *wquery;
  signed int slen;
  signed int cno;
  signed int i;
  signed int *qidx;
  signed int *scridx;
  signed int qoffset;
  signed int scroffset;
  signed int ibeg;
  signed int iend;
  signed int loc_line;
  char mb_encoding;
  char beg_trunc;
  char end_trunc;
  loc = loc - 1;
  _Bool tmp_if_expr_5;
  signed int return_value_pg_encoding_mblen_8;
  if(loc >= 0)
  {
    wquery=strdup(query);
    if(!(wquery == ((char *)NULL)))
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(wquery);
      slen = (signed int)(return_value_strlen_1 + (unsigned long int)1);
      void *return_value_malloc_2;
      return_value_malloc_2=malloc((unsigned long int)slen * sizeof(signed int) /*4ul*/ );
      qidx = (signed int *)return_value_malloc_2;
      if(qidx == ((signed int *)NULL))
        free((void *)wquery);

      else
      {
        void *return_value_malloc_3;
        return_value_malloc_3=malloc((unsigned long int)slen * sizeof(signed int) /*4ul*/ );
        scridx = (signed int *)return_value_malloc_3;
        if(scridx == ((signed int *)NULL))
        {
          free((void *)qidx);
          free((void *)wquery);
        }

        else
        {
          signed int return_value_pg_encoding_max_length_4;
          return_value_pg_encoding_max_length_4=pg_encoding_max_length(encoding);
          mb_encoding = (char)(return_value_pg_encoding_max_length_4 != 1);
          qoffset = 0;
          scroffset = 0;
          loc_line = 1;
          ibeg = 0;
          iend = -1;
          cno = 0;
          for( ; !((signed int)wquery[(signed long int)qoffset] == 0); cno = cno + 1)
          {
            char ch = wquery[(signed long int)qoffset];
            qidx[(signed long int)cno] = qoffset;
            scridx[(signed long int)cno] = scroffset;
            if((signed int)ch == 9)
              wquery[(signed long int)qoffset] = (char)32;

            else
              if((signed int)ch == 10 || (signed int)ch == 13)
              {
                if(!(cno >= loc))
                {
                  if(cno == 0 || (signed int)ch == 13)
                    tmp_if_expr_5 = (_Bool)1;

                  else
                    tmp_if_expr_5 = (signed int)wquery[(signed long int)qidx[(signed long int)(cno - 1)]] != 13 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_5)
                    loc_line = loc_line + 1;

                  ibeg = cno + 1;
                }

                else
                {
                  iend = cno;
                  break;
                }
              }

            if(!(mb_encoding == 0))
            {
              signed int w;
              w=pg_encoding_dsplen(encoding, &wquery[(signed long int)qoffset]);
              if(!(w >= 1))
                w = 1;

              scroffset = scroffset + w;
              signed int return_value_pg_encoding_mblen_6;
              return_value_pg_encoding_mblen_6=pg_encoding_mblen(encoding, &wquery[(signed long int)qoffset]);
              qoffset = qoffset + return_value_pg_encoding_mblen_6;
            }

            else
            {
              scroffset = scroffset + 1;
              qoffset = qoffset + 1;
            }
          }
          if(!(iend >= 0))
          {
            iend = cno;
            qidx[(signed long int)iend] = qoffset;
            scridx[(signed long int)iend] = scroffset;
          }

          if(cno >= loc)
          {
            beg_trunc = (char)0;
            end_trunc = (char)0;
            if(scridx[(signed long int)iend] + -scridx[(signed long int)ibeg] >= 61)
            {
              if(60 + scridx[(signed long int)ibeg] >= 10 + scridx[(signed long int)loc])
              {
                for( ; scridx[(signed long int)iend] + -scridx[(signed long int)ibeg] >= 61; iend = iend - 1)
                  ;
                end_trunc = (char)1;
              }

              else
              {
                for( ; !(10 + scridx[(signed long int)loc] >= scridx[(signed long int)iend]); end_trunc = (char)1)
                  iend = iend - 1;
                for( ; scridx[(signed long int)iend] + -scridx[(signed long int)ibeg] >= 61; beg_trunc = (char)1)
                  ibeg = ibeg + 1;
              }
            }

            wquery[(signed long int)qidx[(signed long int)iend]] = (char)0;
            i = (signed int)msg->len;
            char *return_value_libpq_gettext_7;
            return_value_libpq_gettext_7=libpq_gettext("LINE %d: ");
            appendPQExpBuffer(msg, return_value_libpq_gettext_7, loc_line);
            if(!(beg_trunc == 0))
              appendPQExpBufferStr(msg, "...");

            scroffset = 0;
            for( ; !((unsigned long int)i >= msg->len); i = i + return_value_pg_encoding_mblen_8)
            {
              signed int reportErrorPosition__1__5__2__1__w;
              reportErrorPosition__1__5__2__1__w=pg_encoding_dsplen(encoding, &msg->data[(signed long int)i]);
              if(!(reportErrorPosition__1__5__2__1__w >= 1))
                reportErrorPosition__1__5__2__1__w = 1;

              scroffset = scroffset + reportErrorPosition__1__5__2__1__w;
              return_value_pg_encoding_mblen_8=pg_encoding_mblen(encoding, &msg->data[(signed long int)i]);
            }
            appendPQExpBufferStr(msg, &wquery[(signed long int)qidx[(signed long int)ibeg]]);
            if(!(end_trunc == 0))
              appendPQExpBufferStr(msg, "...");

            appendPQExpBufferChar(msg, (char)10);
            scroffset = scroffset + (scridx[(signed long int)loc] - scridx[(signed long int)ibeg]);
            i = 0;
            for( ; !(i >= scroffset); i = i + 1)
              appendPQExpBufferChar(msg, (char)32);
            appendPQExpBufferChar(msg, (char)94);
            appendPQExpBufferChar(msg, (char)10);
          }

          free((void *)scridx);
          free((void *)qidx);
          free((void *)wquery);
        }
      }
    }

  }

}

// resetPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 130
extern void resetPQExpBuffer(struct PQExpBufferData *str)
{
  if(!(str == ((struct PQExpBufferData *)NULL)))
  {
    if(!(str->data == oom_buffer))
    {
      str->len = (unsigned long int)0;
      str->data[(signed long int)0] = (char)0;
    }

    else
      initPQExpBuffer(str);
  }

}

// resolve_symlinks
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 219
static signed int resolve_symlinks(char *path)
{
  struct stat buf;
  char orig_wd[1024l];
  char link_buf[1024l];
  char *fname;
  char *return_value_getcwd_4;
  return_value_getcwd_4=getcwd(orig_wd, (unsigned long int)1024);
  if(return_value_getcwd_4 == ((char *)NULL))
  {
    char *return_value_gettext_1;
    return_value_gettext_1=gettext("could not identify current directory: %s");
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    fprintf(stderr, return_value_gettext_1, return_value_strerror_3);
    fputc(10, stderr);
    return -1;
  }

  do
  {
    char *lsep;
    signed int rllen;
    lsep=last_dir_separator(path);
    if(!(lsep == ((char *)NULL)))
    {
      *lsep = (char)0;
      signed int return_value_chdir_8;
      return_value_chdir_8=chdir(path);
      if(return_value_chdir_8 == -1)
      {
        char *return_value_gettext_5;
        return_value_gettext_5=gettext("could not change directory to \"%s\": %s");
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        char *return_value_strerror_7;
        return_value_strerror_7=strerror(*return_value___errno_location_6);
        fprintf(stderr, return_value_gettext_5, path, return_value_strerror_7);
        fputc(10, stderr);
        return -1;
      }

      fname = lsep + (signed long int)1;
    }

    else
      fname = path;
    signed int return_value_lstat_9;
    return_value_lstat_9=lstat(fname, &buf);
    if(!((61440u & buf.st_mode) == 40960u) || !(return_value_lstat_9 >= 0))
      break;

    signed long int return_value_readlink_10;
    return_value_readlink_10=readlink(fname, link_buf, sizeof(char [1024l]) /*1024ul*/ );
    rllen = (signed int)return_value_readlink_10;
    if((unsigned long int)rllen >= sizeof(char [1024l]) /*1024ul*/  || !(rllen >= 0))
    {
      char *return_value_gettext_11;
      return_value_gettext_11=gettext("could not read symbolic link \"%s\"");
      fprintf(stderr, return_value_gettext_11, fname);
      fputc(10, stderr);
      return -1;
    }

    link_buf[(signed long int)rllen] = (char)0;
    strcpy(path, link_buf);
  }
  while((_Bool)1);
  strlcpy(link_buf, fname, sizeof(char [1024l]) /*1024ul*/ );
  char *return_value_getcwd_15;
  return_value_getcwd_15=getcwd(path, (unsigned long int)1024);
  if(return_value_getcwd_15 == ((char *)NULL))
  {
    char *return_value_gettext_12;
    return_value_gettext_12=gettext("could not identify current directory: %s");
    signed int *return_value___errno_location_13;
    return_value___errno_location_13=__errno_location();
    char *return_value_strerror_14;
    return_value_strerror_14=strerror(*return_value___errno_location_13);
    fprintf(stderr, return_value_gettext_12, return_value_strerror_14);
    fputc(10, stderr);
    return -1;
  }

  join_path_components(path, path, link_buf);
  canonicalize_path(path);
  signed int return_value_chdir_19;
  return_value_chdir_19=chdir(orig_wd);
  if(return_value_chdir_19 == -1)
  {
    char *return_value_gettext_16;
    return_value_gettext_16=gettext("could not change directory to \"%s\": %s");
    signed int *return_value___errno_location_17;
    return_value___errno_location_17=__errno_location();
    char *return_value_strerror_18;
    return_value_strerror_18=strerror(*return_value___errno_location_17);
    fprintf(stderr, return_value_gettext_16, (const void *)orig_wd, return_value_strerror_18);
    fputc(10, stderr);
    return -1;
  }

  return 0;
}

// resolve_symlinks_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 219
static signed int resolve_symlinks_link1(char *path_link1)
{
  struct stat buf_link1;
  char orig_wd_link1[1024l];
  char link_buf_link1[1024l];
  char *fname_link1;
  char *return_value_getcwd_4_link1;
  return_value_getcwd_4_link1=getcwd(orig_wd_link1, (unsigned long int)1024);
  if(return_value_getcwd_4_link1 == ((char *)NULL))
  {
    char *return_value_gettext_1_link1;
    return_value_gettext_1_link1=gettext("could not identify current directory: %s");
    signed int *return_value___errno_location_2_link1;
    return_value___errno_location_2_link1=__errno_location();
    char *return_value_strerror_3_link1;
    return_value_strerror_3_link1=strerror(*return_value___errno_location_2_link1);
    fprintf(stderr, return_value_gettext_1_link1, return_value_strerror_3_link1);
    fputc(10, stderr);
    return -1;
  }

  do
  {
    char *lsep_link1;
    signed int rllen_link1;
    lsep_link1=last_dir_separator(path_link1);
    if(!(lsep_link1 == ((char *)NULL)))
    {
      *lsep_link1 = (char)0;
      signed int return_value_chdir_8_link1;
      return_value_chdir_8_link1=chdir(path_link1);
      if(return_value_chdir_8_link1 == -1)
      {
        char *return_value_gettext_5_link1;
        return_value_gettext_5_link1=gettext("could not change directory to \"%s\": %s");
        signed int *return_value___errno_location_6_link1;
        return_value___errno_location_6_link1=__errno_location();
        char *return_value_strerror_7_link1;
        return_value_strerror_7_link1=strerror(*return_value___errno_location_6_link1);
        fprintf(stderr, return_value_gettext_5_link1, path_link1, return_value_strerror_7_link1);
        fputc(10, stderr);
        return -1;
      }

      fname_link1 = lsep_link1 + (signed long int)1;
    }

    else
      fname_link1 = path_link1;
    signed int return_value_lstat_9_link1;
    return_value_lstat_9_link1=lstat(fname_link1, &buf_link1);
    if(!((61440u & buf_link1.st_mode) == 40960u) || !(return_value_lstat_9_link1 >= 0))
      break;

    signed long int return_value_readlink_10_link1;
    return_value_readlink_10_link1=readlink(fname_link1, link_buf_link1, sizeof(char [1024l]) /*1024ul*/ );
    rllen_link1 = (signed int)return_value_readlink_10_link1;
    if((unsigned long int)rllen_link1 >= sizeof(char [1024l]) /*1024ul*/  || !(rllen_link1 >= 0))
    {
      char *return_value_gettext_11_link1;
      return_value_gettext_11_link1=gettext("could not read symbolic link \"%s\"");
      fprintf(stderr, return_value_gettext_11_link1, fname_link1);
      fputc(10, stderr);
      return -1;
    }

    link_buf_link1[(signed long int)rllen_link1] = (char)0;
    strcpy(path_link1, link_buf_link1);
  }
  while((_Bool)1);
  strlcpy(link_buf_link1, fname_link1, sizeof(char [1024l]) /*1024ul*/ );
  char *return_value_getcwd_15_link1;
  return_value_getcwd_15_link1=getcwd(path_link1, (unsigned long int)1024);
  if(return_value_getcwd_15_link1 == ((char *)NULL))
  {
    char *return_value_gettext_12_link1;
    return_value_gettext_12_link1=gettext("could not identify current directory: %s");
    signed int *return_value___errno_location_13_link1;
    return_value___errno_location_13_link1=__errno_location();
    char *return_value_strerror_14_link1;
    return_value_strerror_14_link1=strerror(*return_value___errno_location_13_link1);
    fprintf(stderr, return_value_gettext_12_link1, return_value_strerror_14_link1);
    fputc(10, stderr);
    return -1;
  }

  join_path_components(path_link1, path_link1, link_buf_link1);
  canonicalize_path(path_link1);
  signed int return_value_chdir_19_link1;
  return_value_chdir_19_link1=chdir(orig_wd_link1);
  if(return_value_chdir_19_link1 == -1)
  {
    char *return_value_gettext_16_link1;
    return_value_gettext_16_link1=gettext("could not change directory to \"%s\": %s");
    signed int *return_value___errno_location_17_link1;
    return_value___errno_location_17_link1=__errno_location();
    char *return_value_strerror_18_link1;
    return_value_strerror_18_link1=strerror(*return_value___errno_location_17_link1);
    fprintf(stderr, return_value_gettext_16_link1, (const void *)orig_wd_link1, return_value_strerror_18_link1);
    fputc(10, stderr);
    return -1;
  }

  return 0;
}

// rmtree
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/rmtree.c line 36
extern char rmtree(const char *path, char rmtopdir)
{
  char result = (char)1;
  char pathbuf[1024l];
  char **filenames;
  char **filename;
  struct stat statbuf;
  filenames=pgfnames(path);
  if(filenames == ((char **)NULL))
    return (char)0;

  else
  {
    filename = filenames;
    for( ; !(*filename == ((char *)NULL)); filename = filename + 1l)
    {
      snprintf(pathbuf, (unsigned long int)1024, "%s/%s", path, *filename);
      signed int return_value_lstat_5;
      return_value_lstat_5=lstat(pathbuf, &statbuf);
      if(!(return_value_lstat_5 == 0))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(!(*return_value___errno_location_4 == 2))
        {
          char *return_value_gettext_1;
          return_value_gettext_1=gettext("could not stat file or directory \"%s\": %s\n");
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          char *return_value_strerror_3;
          return_value_strerror_3=strerror(*return_value___errno_location_2);
          fprintf(stderr, return_value_gettext_1, (const void *)pathbuf, return_value_strerror_3);
          result = (char)0;
        }

        goto __CPROVER_DUMP_L10;
      }

      if((61440u & statbuf.st_mode) == 16384u)
      {
        char return_value_rmtree_6;
        return_value_rmtree_6=rmtree(pathbuf, (char)1);
        if(return_value_rmtree_6 == 0)
          result = (char)0;

      }

      else
      {
        signed int return_value_unlink_11;
        return_value_unlink_11=unlink(pathbuf);
        if(!(return_value_unlink_11 == 0))
        {
          signed int *return_value___errno_location_10;
          return_value___errno_location_10=__errno_location();
          if(!(*return_value___errno_location_10 == 2))
          {
            char *return_value_gettext_7;
            return_value_gettext_7=gettext("could not remove file or directory \"%s\": %s\n");
            signed int *return_value___errno_location_8;
            return_value___errno_location_8=__errno_location();
            char *return_value_strerror_9;
            return_value_strerror_9=strerror(*return_value___errno_location_8);
            fprintf(stderr, return_value_gettext_7, (const void *)pathbuf, return_value_strerror_9);
            result = (char)0;
          }

        }

      }

    __CPROVER_DUMP_L10:
      ;
    }
    if(!(rmtopdir == 0))
    {
      signed int return_value_rmdir_15;
      return_value_rmdir_15=rmdir(path);
      if(!(return_value_rmdir_15 == 0))
      {
        char *return_value_gettext_12;
        return_value_gettext_12=gettext("could not remove file or directory \"%s\": %s\n");
        signed int *return_value___errno_location_13;
        return_value___errno_location_13=__errno_location();
        char *return_value_strerror_14;
        return_value_strerror_14=strerror(*return_value___errno_location_13);
        fprintf(stderr, return_value_gettext_12, path, return_value_strerror_14);
        result = (char)0;
      }

    }

    pgfnames_cleanup(filenames);
    return result;
  }
}

// runShellCommand
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 792
static char runShellCommand(struct anonymous_18 *st, char *variable, char **argv, signed int argc)
{
  char command[256l];
  signed int i;
  signed int len = 0;
  struct _IO_FILE *fp;
  char res[64l];
  char *endptr;
  signed int retval;
  i = 0;
  signed int tmp_post_2;
  for( ; !(i >= argc); i = i + 1)
  {
    char *arg;
    signed int arglen;
    if(!((signed int)*argv[(signed long int)i] == 58))
      arg = argv[(signed long int)i];

    else
      if((signed int)argv[(signed long int)i][1l] == 58)
        arg = argv[(signed long int)i] + (signed long int)1;

      else
      {
        arg=getVariable(st, argv[(signed long int)i] + (signed long int)1);
        if(arg == ((char *)NULL))
        {
          fprintf(stderr, "%s: undefined variable %s\n", argv[(signed long int)0], argv[(signed long int)i]);
          return (char)0;
        }

      }
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(arg);
    arglen = (signed int)return_value_strlen_1;
    if((i >= 1 ? 1 : 0) + arglen + len >= 256)
    {
      fprintf(stderr, "%s: too long shell command\n", argv[(signed long int)0]);
      return (char)0;
    }

    if(i >= 1)
    {
      tmp_post_2 = len;
      len = len + 1;
      command[(signed long int)tmp_post_2] = (char)32;
    }

    memcpy((void *)(command + (signed long int)len), (const void *)arg, (unsigned long int)arglen);
    len = len + arglen;
  }
  command[(signed long int)len] = (char)0;
  if(variable == ((char *)NULL))
  {
    signed int return_value_system_3;
    return_value_system_3=system(command);
    if(!(return_value_system_3 == 0))
    {
      if(timer_exceeded == 0)
        fprintf(stderr, "%s: cannot launch shell command\n", argv[(signed long int)0]);

      return (char)0;
    }

    return (char)1;
  }

  fp=popen(command, "r");
  const unsigned short int **return_value___ctype_b_loc_7;
  _Bool tmp_if_expr_8;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    fprintf(stderr, "%s: cannot launch shell command\n", argv[(signed long int)0]);
    return (char)0;
  }

  else
  {
    char *return_value_fgets_4;
    return_value_fgets_4=fgets(res, (signed int)sizeof(char [64l]) /*64ul*/ , fp);
    if(return_value_fgets_4 == ((char *)NULL))
    {
      if(timer_exceeded == 0)
        fprintf(stderr, "%s: cannot read the result\n", argv[(signed long int)0]);

      pclose(fp);
      return (char)0;
    }

    else
    {
      signed int return_value_pclose_5;
      return_value_pclose_5=pclose(fp);
      if(!(return_value_pclose_5 >= 0))
      {
        fprintf(stderr, "%s: cannot close shell command\n", argv[(signed long int)0]);
        return (char)0;
      }

      else
      {
        signed long int return_value_strtol_6;
        return_value_strtol_6=strtol(res, &endptr, 10);
        retval = (signed int)return_value_strtol_6;
        for( ; !((signed int)*endptr == 0); endptr = endptr + 1l)
        {
          return_value___ctype_b_loc_7=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)(unsigned char)*endptr]) == 0)
            break;

        }
        if((signed int)res[0l] == 0)
          tmp_if_expr_8 = (_Bool)1;

        else
          tmp_if_expr_8 = (signed int)*endptr != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_8)
        {
          fprintf(stderr, "%s: must return an integer ('%s' returned)\n", argv[(signed long int)0], (const void *)res);
          return (char)0;
        }

        else
        {
          snprintf(res, sizeof(char [64l]) /*64ul*/ , "%d", retval);
          signed int return_value_putVariable_9;
          return_value_putVariable_9=putVariable(st, "setshell", variable, res);
          if(return_value_putVariable_9 == 0)
            return (char)0;

          else
            return (char)1;
        }
      }
    }
  }
}

// run_ifaddr_callback
// file ip.c line 415
static void run_ifaddr_callback(void (*callback)(struct sockaddr *, struct sockaddr *, void *), void *cb_data, struct sockaddr *addr, struct sockaddr *mask)
{
  struct sockaddr_storage fullmask;
  _Bool tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!(addr == ((struct sockaddr *)NULL)))
  {
    if(!(mask == ((struct sockaddr *)NULL)))
    {
      if(!(mask->sa_family == addr->sa_family))
        mask = (struct sockaddr *)(void *)0;

      else
        if((signed int)mask->sa_family == 2)
        {
          if(((struct sockaddr_in *)mask)->sin_addr.s_addr == 0u)
            mask = (struct sockaddr *)(void *)0;

        }

        else
          if((signed int)mask->sa_family == 10)
          {
            struct in6_addr *__a = (struct in6_addr *)&((struct sockaddr_in6 *)mask)->sin6_addr;
            if(__a->__in6_u.__u6_addr32[0l] == 0u)
              tmp_if_expr_2 = __a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_2 = (_Bool)0;
            if(tmp_if_expr_2)
              tmp_if_expr_3 = __a->__in6_u.__u6_addr32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_3 = (_Bool)0;
            if(tmp_if_expr_3)
              tmp_if_expr_4 = __a->__in6_u.__u6_addr32[(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_4 = (_Bool)0;
            tmp_statement_expression_1 = tmp_if_expr_4;
            if(tmp_statement_expression_1)
              mask = (struct sockaddr *)(void *)0;

          }

    }

    if(mask == ((struct sockaddr *)NULL))
    {
      pg_sockaddr_cidr_mask(&fullmask, (char *)(void *)0, (signed int)addr->sa_family);
      mask = (struct sockaddr *)&fullmask;
    }

    callback(addr, mask, cb_data);
  }

}

// setKeepalivesCount
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1302
static signed int setKeepalivesCount(struct pg_conn *conn)
{
  signed int count;
  if(conn->keepalives_count == ((char *)NULL))
    return 1;

  else
  {
    count=atoi(conn->keepalives_count);
    if(!(count >= 0))
      count = 0;

    signed int return_value_setsockopt_4;
    return_value_setsockopt_4=setsockopt(conn->sock, 6, 6, (const void *)(char *)&count, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_4 >= 0))
    {
      char sebuf[256l];
      char *return_value_libpq_gettext_1;
      return_value_libpq_gettext_1=libpq_gettext("setsockopt(TCP_KEEPCNT) failed: %s\n");
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_pqStrerror_3;
      return_value_pqStrerror_3=pqStrerror(*return_value___errno_location_2, sebuf, sizeof(char [256l]) /*256ul*/ );
      appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1, return_value_pqStrerror_3);
      return 0;
    }

    return 1;
  }
}

// setKeepalivesIdle
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1225
static signed int setKeepalivesIdle(struct pg_conn *conn)
{
  signed int idle;
  if(conn->keepalives_idle == ((char *)NULL))
    return 1;

  else
  {
    idle=atoi(conn->keepalives_idle);
    if(!(idle >= 0))
      idle = 0;

    signed int return_value_setsockopt_4;
    return_value_setsockopt_4=setsockopt(conn->sock, 6, 4, (const void *)(char *)&idle, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_4 >= 0))
    {
      char sebuf[256l];
      char *return_value_libpq_gettext_1;
      return_value_libpq_gettext_1=libpq_gettext("setsockopt(TCP_KEEPIDLE) failed: %s\n");
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_pqStrerror_3;
      return_value_pqStrerror_3=pqStrerror(*return_value___errno_location_2, sebuf, sizeof(char [256l]) /*256ul*/ );
      appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1, return_value_pqStrerror_3);
      return 0;
    }

    return 1;
  }
}

// setKeepalivesInterval
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1270
static signed int setKeepalivesInterval(struct pg_conn *conn)
{
  signed int interval;
  if(conn->keepalives_interval == ((char *)NULL))
    return 1;

  else
  {
    interval=atoi(conn->keepalives_interval);
    if(!(interval >= 0))
      interval = 0;

    signed int return_value_setsockopt_4;
    return_value_setsockopt_4=setsockopt(conn->sock, 6, 5, (const void *)(char *)&interval, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_4 >= 0))
    {
      char sebuf[256l];
      char *return_value_libpq_gettext_1;
      return_value_libpq_gettext_1=libpq_gettext("setsockopt(TCP_KEEPINTVL) failed: %s\n");
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_pqStrerror_3;
      return_value_pqStrerror_3=pqStrerror(*return_value___errno_location_2, sebuf, sizeof(char [256l]) /*256ul*/ );
      appendPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_1, return_value_pqStrerror_3);
      return 0;
    }

    return 1;
  }
}

// set_pglocale_pgservice
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 550
extern void set_pglocale_pgservice(const char *argv0, const char *app)
{
  char path[1024l];
  char my_exec_path[1024l];
  char env_path[(signed long int)(sizeof(char [14l]) * 74 + 2) /*1038l*/ ];
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(app, "postgres-9.4");
  if(!(return_value_strcmp_1 == 0))
    setlocale(6, "");

  signed int return_value_find_my_exec_2;
  return_value_find_my_exec_2=find_my_exec(argv0, my_exec_path);
  if(return_value_find_my_exec_2 >= 0)
  {
    get_locale_path(my_exec_path, path);
    bindtextdomain(app, path);
    textdomain(app);
    char *return_value_getenv_4;
    return_value_getenv_4=getenv("PGLOCALEDIR");
    if(return_value_getenv_4 == ((char *)NULL))
    {
      snprintf(env_path, sizeof(char [1038l]) /*1038ul*/ , "PGLOCALEDIR=%s", (const void *)path);
      canonicalize_path(env_path + (signed long int)12);
      char *return_value_strdup_3;
      return_value_strdup_3=strdup(env_path);
      putenv(return_value_strdup_3);
    }

    char *return_value_getenv_6;
    return_value_getenv_6=getenv("PGSYSCONFDIR");
    if(return_value_getenv_6 == ((char *)NULL))
    {
      get_etc_path(my_exec_path, path);
      snprintf(env_path, sizeof(char [1038l]) /*1038ul*/ , "PGSYSCONFDIR=%s", (const void *)path);
      canonicalize_path(env_path + (signed long int)13);
      char *return_value_strdup_5;
      return_value_strdup_5=strdup(env_path);
      putenv(return_value_strdup_5);
    }

  }

}

// setalarm
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 3460
static void setalarm(signed int seconds)
{
  pqsignal(14, handle_sig_alarm);
  alarm((unsigned int)seconds);
}

// simple_prompt
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 217
extern char * simple_prompt(const char *prompt, signed int maxlen, char echo)
{
  signed int length;
  char *destination;
  struct _IO_FILE *termin;
  struct _IO_FILE *termout;
  struct termios t_orig;
  struct termios t;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(maxlen + 1));
  destination = (char *)return_value_malloc_1;
  _Bool tmp_if_expr_7;
  if(destination == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    termin=fopen("/dev/tty", "r");
    termout=fopen("/dev/tty", "w");
    if(termin == ((struct _IO_FILE *)NULL) || termout == ((struct _IO_FILE *)NULL))
    {
      if(!(termin == ((struct _IO_FILE *)NULL)))
        fclose(termin);

      if(!(termout == ((struct _IO_FILE *)NULL)))
        fclose(termout);

      termin = stdin;
      termout = stderr;
    }

    if(echo == 0)
    {
      signed int return_value_fileno_2;
      return_value_fileno_2=fileno(termin);
      tcgetattr(return_value_fileno_2, &t);
      t_orig = t;
      t.c_lflag = t.c_lflag & (unsigned int)~0000010;
      signed int return_value_fileno_3;
      return_value_fileno_3=fileno(termin);
      tcsetattr(return_value_fileno_3, 2, &t);
    }

    if(!(prompt == ((const char *)NULL)))
    {
      char *return_value_gettext_4;
      return_value_gettext_4=gettext(prompt);
      fputs(return_value_gettext_4, termout);
      fflush(termout);
    }

    char *return_value_fgets_5;
    return_value_fgets_5=fgets(destination, maxlen + 1, termin);
    if(return_value_fgets_5 == ((char *)NULL))
      destination[(signed long int)0] = (char)0;

    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(destination);
    length = (signed int)return_value_strlen_6;
    if(length >= 1)
    {
      if(!((signed int)destination[(signed long int)(length + -1)] == 10))
      {
        char buf[128l];
        signed int buflen;
        do
        {
          char *return_value_fgets_8;
          return_value_fgets_8=fgets(buf, (signed int)sizeof(char [128l]) /*128ul*/ , termin);
          if(return_value_fgets_8 == ((char *)NULL))
            break;

          unsigned long int return_value_strlen_9;
          return_value_strlen_9=strlen(buf);
          buflen = (signed int)return_value_strlen_9;
          if(buflen >= 1)
            tmp_if_expr_7 = (signed int)buf[(signed long int)(buflen - 1)] != 10 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_7 = (_Bool)0;
        }
        while(tmp_if_expr_7);
      }

    }

    if(length >= 1)
    {
      if((signed int)destination[(signed long int)(length + -1)] == 10)
        destination[(signed long int)(length - 1)] = (char)0;

    }

    if(echo == 0)
    {
      signed int return_value_fileno_10;
      return_value_fileno_10=fileno(termin);
      tcsetattr(return_value_fileno_10, 2, &t_orig);
      fputs("\n", termout);
      fflush(termout);
    }

    if(!(termin == stdin))
    {
      fclose(termin);
      fclose(termout);
    }

    return destination;
  }
}

// strlcat
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/strlcat.c line 33
extern unsigned long int strlcat(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  unsigned long int dlen;
  unsigned long int tmp_post_1;
  do
  {
    tmp_post_1 = n;
    n = n - 1ul;
    if(tmp_post_1 == 0ul)
      break;

    if((signed int)*d == 0)
      break;

    d = d + 1l;
  }
  while((_Bool)1);
  dlen = (unsigned long int)(d - dst);
  n = siz - dlen;
  unsigned long int return_value_strlen_2;
  char *tmp_post_3;
  if(n == 0ul)
  {
    return_value_strlen_2=strlen(s);
    return dlen + return_value_strlen_2;
  }

  else
  {
    for( ; !((signed int)*s == 0); s = s + 1l)
      if(!(n == 1ul))
      {
        tmp_post_3 = d;
        d = d + 1l;
        *tmp_post_3 = *s;
        n = n - 1ul;
      }

    *d = (char)0;
    return dlen + (unsigned long int)(s - src);
  }
}

// strlcpy
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 412
extern unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  char *tmp_post_1;
  const char *tmp_post_2;
  if(!(n == 0ul))
    do
    {
      n = n - 1ul;
      if(n == 0ul)
        break;

      tmp_post_1 = d;
      d = d + 1l;
      tmp_post_2 = s;
      s = s + 1l;
      *tmp_post_1 = *tmp_post_2;
      if((signed int)*tmp_post_1 == 0)
        break;

    }
    while((_Bool)1);

  const char *tmp_post_3;
  if(n == 0ul)
  {
    if(!(siz == 0ul))
      *d = (char)0;

    do
    {
      tmp_post_3 = s;
      s = s + 1l;
      if(*tmp_post_3 == 0)
        break;

    }
    while((_Bool)1);
  }

  return (unsigned long int)((s - src) - (signed long int)1);
}

// strtoint64
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 402
static signed long int strtoint64(const char *str)
{
  const char *ptr = str;
  signed long int result = (signed long int)0;
  signed int sign = 1;
  const unsigned short int **return_value___ctype_b_loc_1;
  for( ; !(*ptr == 0); ptr = ptr + 1l)
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*ptr]) == 0)
      break;

  }
  if((signed int)*ptr == 45)
  {
    ptr = ptr + 1l;
    signed int return_value_strncmp_2;
    return_value_strncmp_2=strncmp(ptr, "9223372036854775808", (unsigned long int)19);
    if(return_value_strncmp_2 == 0)
    {
      result = -((signed long int)0x7fffffffffffffff) - (signed long int)1;
      ptr = ptr + (signed long int)19;
      goto gotdigits;
    }

    sign = -1;
  }

  else
    if((signed int)*ptr == 43)
      ptr = ptr + 1l;

  const unsigned short int **return_value___ctype_b_loc_3;
  return_value___ctype_b_loc_3=__ctype_b_loc();
  if((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)(unsigned char)*ptr]) == 0)
    fprintf(stderr, "invalid input syntax for integer: \"%s\"\n", str);

  const unsigned short int **return_value___ctype_b_loc_4;
  const char *tmp_post_5;
  while(!(*ptr == 0))
  {
    return_value___ctype_b_loc_4=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)*ptr]) == 0)
      break;

    signed long int tmp;
    tmp_post_5 = ptr;
    ptr = ptr + 1l;
    tmp = result * (signed long int)10 + (signed long int)((signed int)*tmp_post_5 - 48);
    if(!(tmp / 10l == result))
      fprintf(stderr, "value \"%s\" is out of range for type bigint\n", str);

    result = tmp;
  }

gotdigits:
  ;
  const unsigned short int **return_value___ctype_b_loc_6;
  for( ; !((signed int)*ptr == 0); ptr = ptr + 1l)
  {
    return_value___ctype_b_loc_6=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)(unsigned char)*ptr]) == 0)
      break;

  }
  if(!((signed int)*ptr == 0))
    fprintf(stderr, "invalid input syntax for integer: \"%s\"\n", str);

  return sign < 0 ? -result : result;
}

// swapfunc
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort.c line 86
static void swapfunc(char *a, char *b, unsigned long int n, signed int swaptype)
{
  signed long int *tmp_post_1;
  signed long int *tmp_post_2;
  char *tmp_post_3;
  char *tmp_post_4;
  if(!(swaptype >= 2))
    do
    {
      unsigned long int i = n / sizeof(signed long int) /*8ul*/ ;
      signed long int *swapfunc__1__1__pi = (signed long int *)(void *)a;
      signed long int *swapfunc__1__1__pj = (signed long int *)(void *)b;
      do
      {
        signed long int swapfunc__1__1__1__t = *swapfunc__1__1__pi;
        tmp_post_1 = swapfunc__1__1__pi;
        swapfunc__1__1__pi = swapfunc__1__1__pi + 1l;
        *tmp_post_1 = *swapfunc__1__1__pj;
        tmp_post_2 = swapfunc__1__1__pj;
        swapfunc__1__1__pj = swapfunc__1__1__pj + 1l;
        *tmp_post_2 = swapfunc__1__1__1__t;
        i = i - 1ul;
      }
      while(i >= 1ul);
    }
    while((_Bool)0);

  else
    do
    {
      unsigned long int swapfunc__1__2__i = n / sizeof(char) /*1ul*/ ;
      char *pi = (char *)(void *)a;
      char *pj = (char *)(void *)b;
      do
      {
        char t = *pi;
        tmp_post_3 = pi;
        pi = pi + 1l;
        *tmp_post_3 = *pj;
        tmp_post_4 = pj;
        pj = pj + 1l;
        *tmp_post_4 = t;
        swapfunc__1__2__i = swapfunc__1__2__i - 1ul;
      }
      while(swapfunc__1__2__i >= 1ul);
    }
    while((_Bool)0);
}

// swapfunc_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort_arg.c line 86
static void swapfunc_link1(char *a_link1, char *b_link1, unsigned long int n_link1, signed int swaptype_link1)
{
  signed long int *tmp_post_1_link1;
  signed long int *tmp_post_2_link1;
  char *tmp_post_3_link1;
  char *tmp_post_4_link1;
  if(!(swaptype_link1 >= 2))
    do
    {
      unsigned long int i_link1 = n_link1 / sizeof(signed long int) /*8ul*/ ;
      signed long int *pi_link1 = (signed long int *)(void *)a_link1;
      signed long int *pj_link1 = (signed long int *)(void *)b_link1;
      do
      {
        signed long int t_link1 = *pi_link1;
        tmp_post_1_link1 = pi_link1;
        pi_link1 = pi_link1 + 1l;
        *tmp_post_1_link1 = *pj_link1;
        tmp_post_2_link1 = pj_link1;
        pj_link1 = pj_link1 + 1l;
        *tmp_post_2_link1 = t_link1;
        i_link1 = i_link1 - 1ul;
      }
      while(i_link1 >= 1ul);
    }
    while((_Bool)0);

  else
    do
    {
      unsigned long int swapfunc__1__2__i_link1 = n_link1 / sizeof(char) /*1ul*/ ;
      char *swapfunc__1__2__pi_link1 = (char *)(void *)a_link1;
      char *swapfunc__1__2__pj_link1 = (char *)(void *)b_link1;
      do
      {
        char swapfunc__1__2__1__t_link1 = *swapfunc__1__2__pi_link1;
        tmp_post_3_link1 = swapfunc__1__2__pi_link1;
        swapfunc__1__2__pi_link1 = swapfunc__1__2__pi_link1 + 1l;
        *tmp_post_3_link1 = *swapfunc__1__2__pj_link1;
        tmp_post_4_link1 = swapfunc__1__2__pj_link1;
        swapfunc__1__2__pj_link1 = swapfunc__1__2__pj_link1 + 1l;
        *tmp_post_4_link1 = swapfunc__1__2__1__t_link1;
        swapfunc__1__2__i_link1 = swapfunc__1__2__i_link1 - 1ul;
      }
      while(swapfunc__1__2__i_link1 >= 1ul);
    }
    while((_Bool)0);
}

// swapfunc_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort.c line 86
static void swapfunc_link2(char *a_link2, char *b_link2, unsigned long int n_link2, signed int swaptype_link2)
{
  signed long int *tmp_post_1_link2;
  signed long int *tmp_post_2_link2;
  char *tmp_post_3_link2;
  char *tmp_post_4_link2;
  if(!(swaptype_link2 >= 2))
    do
    {
      unsigned long int i_link2 = n_link2 / sizeof(signed long int) /*8ul*/ ;
      signed long int *pi_link2 = (signed long int *)(void *)a_link2;
      signed long int *swapfunc__1__1__pj_link2 = (signed long int *)(void *)b_link2;
      do
      {
        signed long int swapfunc__1__1__1__t_link2 = *pi_link2;
        tmp_post_1_link2 = pi_link2;
        pi_link2 = pi_link2 + 1l;
        *tmp_post_1_link2 = *swapfunc__1__1__pj_link2;
        tmp_post_2_link2 = swapfunc__1__1__pj_link2;
        swapfunc__1__1__pj_link2 = swapfunc__1__1__pj_link2 + 1l;
        *tmp_post_2_link2 = swapfunc__1__1__1__t_link2;
        i_link2 = i_link2 - 1ul;
      }
      while(i_link2 >= 1ul);
    }
    while((_Bool)0);

  else
    do
    {
      unsigned long int swapfunc__1__2__i_link2 = n_link2 / sizeof(char) /*1ul*/ ;
      char *swapfunc__1__2__pi_link2 = (char *)(void *)a_link2;
      char *pj_link2 = (char *)(void *)b_link2;
      do
      {
        char t_link2 = *swapfunc__1__2__pi_link2;
        tmp_post_3_link2 = swapfunc__1__2__pi_link2;
        swapfunc__1__2__pi_link2 = swapfunc__1__2__pi_link2 + 1l;
        *tmp_post_3_link2 = *pj_link2;
        tmp_post_4_link2 = pj_link2;
        pj_link2 = pj_link2 + 1l;
        *tmp_post_4_link2 = t_link2;
        swapfunc__1__2__i_link2 = swapfunc__1__2__i_link2 - 1ul;
      }
      while(swapfunc__1__2__i_link2 >= 1ul);
    }
    while((_Bool)0);
}

// swapfunc_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/qsort_arg.c line 86
static void swapfunc_link3(char *a_link3, char *b_link3, unsigned long int n_link3, signed int swaptype_link3)
{
  signed long int *tmp_post_1_link3;
  signed long int *tmp_post_2_link3;
  char *tmp_post_3_link3;
  char *tmp_post_4_link3;
  if(!(swaptype_link3 >= 2))
    do
    {
      unsigned long int swapfunc__1__1__i_link3 = n_link3 / sizeof(signed long int) /*8ul*/ ;
      signed long int *pi_link3 = (signed long int *)(void *)a_link3;
      signed long int *pj_link3 = (signed long int *)(void *)b_link3;
      do
      {
        signed long int t_link3 = *pi_link3;
        tmp_post_1_link3 = pi_link3;
        pi_link3 = pi_link3 + 1l;
        *tmp_post_1_link3 = *pj_link3;
        tmp_post_2_link3 = pj_link3;
        pj_link3 = pj_link3 + 1l;
        *tmp_post_2_link3 = t_link3;
        swapfunc__1__1__i_link3 = swapfunc__1__1__i_link3 - 1ul;
      }
      while(swapfunc__1__1__i_link3 >= 1ul);
    }
    while((_Bool)0);

  else
    do
    {
      unsigned long int i_link3 = n_link3 / sizeof(char) /*1ul*/ ;
      char *swapfunc__1__2__pi_link3 = (char *)(void *)a_link3;
      char *swapfunc__1__2__pj_link3 = (char *)(void *)b_link3;
      do
      {
        char swapfunc__1__2__1__t_link3 = *swapfunc__1__2__pi_link3;
        tmp_post_3_link3 = swapfunc__1__2__pi_link3;
        swapfunc__1__2__pi_link3 = swapfunc__1__2__pi_link3 + 1l;
        *tmp_post_3_link3 = *swapfunc__1__2__pj_link3;
        tmp_post_4_link3 = swapfunc__1__2__pj_link3;
        swapfunc__1__2__pj_link3 = swapfunc__1__2__pj_link3 + 1l;
        *tmp_post_4_link3 = swapfunc__1__2__1__t_link3;
        i_link3 = i_link3 - 1ul;
      }
      while(i_link3 >= 1ul);
    }
    while((_Bool)0);
}

// tarChecksum
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/tar.c line 29
extern signed int tarChecksum(char *header)
{
  signed int i;
  signed int sum = 8 * 32;
  i = 0;
  for( ; !(i >= 512); i = i + 1)
    if(i >= 156 || !(i >= 148))
      sum = sum + (0xFF & (signed int)header[(signed long int)i]);

  return sum;
}

// tarCreateHeader
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/tar.c line 53
extern void tarCreateHeader(char *h, const char *filename, const char *linktarget, unsigned long int size, unsigned int mode, unsigned int uid, unsigned int gid, signed long int mtime)
{
  memset((void *)h, 0, (unsigned long int)512);
  strlcpy(&h[(signed long int)0], filename, (unsigned long int)100);
  if((61440u & mode) == 16384u || !(linktarget == ((const char *)NULL)))
  {
    signed int flen;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(filename);
    flen = (signed int)return_value_strlen_1;
    flen = flen < 99 ? flen : 99;
    h[(signed long int)flen] = (char)47;
    h[(signed long int)(flen + 1)] = (char)0;
  }

  sprintf(&h[(signed long int)100], "%07o ", (signed int)mode);
  sprintf(&h[(signed long int)108], "%07o ", (signed int)uid);
  sprintf(&h[(signed long int)116], "%07o ", (signed int)gid);
  if((61440u & mode) == 16384u || !(linktarget == ((const char *)NULL)))
    print_val(&h[(signed long int)124], (unsigned long int)0, (unsigned int)8, (unsigned long int)11);

  else
    print_val(&h[(signed long int)124], size, (unsigned int)8, (unsigned long int)11);
  sprintf(&h[(signed long int)135], " ");
  sprintf(&h[(signed long int)136], "%011o ", (signed int)mtime);
  if(!(linktarget == ((const char *)NULL)))
  {
    sprintf(&h[(signed long int)156], "2");
    strlcpy(&h[(signed long int)157], linktarget, (unsigned long int)100);
  }

  else
    if((61440u & mode) == 16384u)
      sprintf(&h[(signed long int)156], "5");

    else
      sprintf(&h[(signed long int)156], "0");
  sprintf(&h[(signed long int)257], "ustar");
  sprintf(&h[(signed long int)263], "00");
  strlcpy(&h[(signed long int)265], "postgres", (unsigned long int)32);
  strlcpy(&h[(signed long int)297], "postgres", (unsigned long int)32);
  sprintf(&h[(signed long int)329], "%07o ", 0);
  sprintf(&h[(signed long int)337], "%07o ", 0);
  signed int return_value_tarChecksum_2;
  return_value_tarChecksum_2=tarChecksum(h);
  sprintf(&h[(signed long int)148], "%06o ", return_value_tarChecksum_2);
}

// termPQExpBuffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/pqexpbuffer.h line 122
extern void termPQExpBuffer(struct PQExpBufferData *str)
{
  if(!(str->data == oom_buffer))
    free((void *)str->data);

  str->data = (char *)oom_buffer;
  str->maxlen = (unsigned long int)0;
  str->len = (unsigned long int)0;
}

// threadRun
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 3055
static void * threadRun(void *arg)
{
  struct anonymous_17 *thread = (struct anonymous_17 *)arg;
  struct anonymous_18 *state = thread->state;
  struct anonymous_30 *result;
  struct _IO_FILE *logfile = (struct _IO_FILE *)(void *)0;
  struct timeval start;
  struct timeval end;
  signed int nstate = thread->nstate;
  signed int remains = nstate;
  signed int i;
  signed long int thread_start = (signed long int)((unsigned long int)thread->start_time.tv_sec * (unsigned long int)1000000 + (unsigned long int)thread->start_time.tv_usec);
  signed long int last_report = thread_start;
  signed long int next_report = last_report + (signed long int)progress * (signed long int)1000000;
  signed long int last_count = (signed long int)0;
  signed long int last_lats = (signed long int)0;
  signed long int last_sqlats = (signed long int)0;
  signed long int last_lags = (signed long int)0;
  struct anonymous_19 aggs;
  gettimeofday(&start, (struct timezone *)(void *)0);
  thread->throttle_trigger = (signed long int)((unsigned long int)start.tv_sec * (unsigned long int)1000000 + (unsigned long int)start.tv_usec);
  thread->throttle_lag = (signed long int)0;
  thread->throttle_lag_max = (signed long int)0;
  void *return_value_pg_malloc_1;
  return_value_pg_malloc_1=pg_malloc(sizeof(struct anonymous_30) /*56ul*/ );
  result = (struct anonymous_30 *)return_value_pg_malloc_1;
  result->conn_time.tv_sec = (signed long int)0;
  result->conn_time.tv_usec = (signed long int)0;
  if(!(use_log == 0))
  {
    char logpath[64l];
    if(thread->tid == 0)
      snprintf(logpath, sizeof(char [64l]) /*64ul*/ , "pgbench_log.%d", main_pid);

    else
      snprintf(logpath, sizeof(char [64l]) /*64ul*/ , "pgbench_log.%d.%d", main_pid, thread->tid);
    logfile=fopen(logpath, "w");
    if(logfile == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      fprintf(stderr, "Couldn't open logfile \"%s\": %s", (const void *)logpath, return_value_strerror_3);
      goto done;
    }

  }

  if(is_connect == 0)
  {
    i = 0;
    for( ; !(i >= nstate); i = i + 1)
    {
      (state + (signed long int)i)->con=doConnect();
      if((state + (signed long int)i)->con == ((struct pg_conn *)NULL))
        goto done;

    }
  }

  gettimeofday(&result->conn_time, (struct timezone *)(void *)0);
  do
  {
    result->conn_time.tv_sec = result->conn_time.tv_sec - thread->start_time.tv_sec;
    result->conn_time.tv_usec = result->conn_time.tv_usec - thread->start_time.tv_usec;
    for( ; !(result->conn_time.tv_usec >= 0l); result->conn_time.tv_sec = result->conn_time.tv_sec - 1l)
      result->conn_time.tv_usec = result->conn_time.tv_usec + (signed long int)1000000;
  }
  while((_Bool)0);
  agg_vals_init(&aggs, thread->start_time);
  i = 0;
  for( ; !(i >= nstate); i = i + 1)
  {
    struct anonymous_18 *threadRun__1__4__1__st = &state[(signed long int)i];
    struct anonymous_22 **threadRun__1__4__1__commands = sql_files[(signed long int)threadRun__1__4__1__st->use_file];
    signed int prev_ecnt = threadRun__1__4__1__st->ecnt;
    signed long int return_value_getrand_4;
    return_value_getrand_4=getrand(thread, (signed long int)0, (signed long int)(num_files - 1));
    threadRun__1__4__1__st->use_file = (signed int)return_value_getrand_4;
    char return_value_doCustom_5;
    return_value_doCustom_5=doCustom(thread, threadRun__1__4__1__st, &result->conn_time, logfile, &aggs);
    if(return_value_doCustom_5 == 0)
      remains = remains - 1;

    if(!(prev_ecnt >= threadRun__1__4__1__st->ecnt))
    {
      if(threadRun__1__4__1__commands[(signed long int)threadRun__1__4__1__st->state]->type == 2)
      {
        fprintf(stderr, "Client %d aborted in state %d. Execution meta-command failed.\n", i, threadRun__1__4__1__st->state);
        remains = remains - 1;
        PQfinish(threadRun__1__4__1__st->con);
        threadRun__1__4__1__st->con = (struct pg_conn *)(void *)0;
      }

    }

  }
  signed int return_value_PQsocket_12;
  signed int return_value_PQsocket_13;
  _Bool tmp_if_expr_14;
  while(remains >= 1)
  {
    struct anonymous_28 input_mask;
    signed int maxsock;
    signed long int now_usec = (signed long int)0;
    signed long int min_usec;
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_28) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&input_mask)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    maxsock = -1;
    min_usec = 9223372036854775807L;
    i = 0;
    for( ; !(i >= nstate); i = i + 1)
    {
      struct anonymous_18 *threadRun__1__5__2__1__st = &state[(signed long int)i];
      struct anonymous_22 **commands = sql_files[(signed long int)threadRun__1__5__2__1__st->use_file];
      signed int sock;
      if(threadRun__1__5__2__1__st->con == ((struct pg_conn *)NULL))
        goto __CPROVER_DUMP_L25;

      else
        if(!(threadRun__1__5__2__1__st->sleeping == 0))
        {
          if(!(threadRun__1__5__2__1__st->throttling == 0) && !(timer_exceeded == 0))
          {
            remains = remains - 1;
            threadRun__1__5__2__1__st->sleeping = 0;
            threadRun__1__5__2__1__st->throttling = (char)0;
            PQfinish(threadRun__1__5__2__1__st->con);
            threadRun__1__5__2__1__st->con = (struct pg_conn *)(void *)0;
            goto __CPROVER_DUMP_L25;
          }

          else
          {
            signed int this_usec;
            if(min_usec == 9223372036854775807L)
            {
              struct timeval now;
              gettimeofday(&now, (struct timezone *)(void *)0);
              now_usec = (signed long int)((unsigned long int)now.tv_sec * (unsigned long int)1000000 + (unsigned long int)now.tv_usec);
            }

            this_usec = (signed int)(threadRun__1__5__2__1__st->txn_scheduled - now_usec);
            if(!((signed long int)this_usec >= min_usec))
              min_usec = (signed long int)this_usec;

          }
        }

        else
          if(commands[(signed long int)threadRun__1__5__2__1__st->state]->type == 2)
          {
            min_usec = (signed long int)0;
            break;
          }

      sock=PQsocket(threadRun__1__5__2__1__st->con);
      if(!(sock >= 0))
      {
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        char *return_value_strerror_7;
        return_value_strerror_7=strerror(*return_value___errno_location_6);
        fprintf(stderr, "bad socket: %s\n", return_value_strerror_7);
        goto done;
      }

      (&input_mask)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&input_mask)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      if(!(maxsock >= sock))
        maxsock = sock;


    __CPROVER_DUMP_L25:
      ;
    }
    if(min_usec >= 1l && !(progress == 0))
    {
      if(thread->tid == 0)
      {
        if(now_usec == 0l)
        {
          struct timeval threadRun__1__5__3__1__now;
          gettimeofday(&threadRun__1__5__3__1__now, (struct timezone *)(void *)0);
          now_usec = (signed long int)((unsigned long int)threadRun__1__5__3__1__now.tv_sec * (unsigned long int)1000000 + (unsigned long int)threadRun__1__5__3__1__now.tv_usec);
        }

        if(now_usec >= next_report)
          min_usec = (signed long int)0;

        else
          if(!(next_report + -now_usec >= min_usec))
            min_usec = next_report - now_usec;

      }

    }

    if(min_usec >= 1l && !(maxsock == -1))
    {
      signed int nsocks;
      if(!(min_usec == 9223372036854775807L))
      {
        struct timeval timeout;
        timeout.tv_sec = min_usec / (signed long int)1000000;
        timeout.tv_usec = min_usec % (signed long int)1000000;
        nsocks=select(maxsock + 1, &input_mask, (struct anonymous_28 *)(void *)0, (struct anonymous_28 *)(void *)0, &timeout);
      }

      else
        nsocks=select(maxsock + 1, &input_mask, (struct anonymous_28 *)(void *)0, (struct anonymous_28 *)(void *)0, (struct timeval *)(void *)0);
      if(!(nsocks >= 0))
      {
        signed int *return_value___errno_location_8;
        return_value___errno_location_8=__errno_location();
        if(*return_value___errno_location_8 == 4)
          continue;

        signed int *return_value___errno_location_9;
        return_value___errno_location_9=__errno_location();
        char *return_value_strerror_10;
        return_value_strerror_10=strerror(*return_value___errno_location_9);
        fprintf(stderr, "select failed: %s\n", return_value_strerror_10);
        break;
      }

    }

    i = 0;
    for( ; !(i >= nstate); i = i + 1)
    {
      struct anonymous_18 *st = &state[(signed long int)i];
      struct anonymous_22 **threadRun__1__5__5__1__commands = sql_files[(signed long int)st->use_file];
      signed int threadRun__1__5__5__1__prev_ecnt = st->ecnt;
      if(!(st->con == ((struct pg_conn *)NULL)))
      {
        return_value_PQsocket_12=PQsocket(st->con);
        return_value_PQsocket_13=PQsocket(st->con);
        if(!((input_mask.fds_bits[(signed long int)(return_value_PQsocket_12 / 8)] & (signed long int)(1UL << return_value_PQsocket_13 % 8)) == 0l))
          tmp_if_expr_14 = (_Bool)1;

        else
          tmp_if_expr_14 = threadRun__1__5__5__1__commands[(signed long int)st->state]->type == 2 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_14)
        {
          char return_value_doCustom_11;
          return_value_doCustom_11=doCustom(thread, st, &result->conn_time, logfile, &aggs);
          if(return_value_doCustom_11 == 0)
            remains = remains - 1;

        }

      }

      if(!(threadRun__1__5__5__1__prev_ecnt >= st->ecnt))
      {
        if(threadRun__1__5__5__1__commands[(signed long int)st->state]->type == 2)
        {
          fprintf(stderr, "Client %d aborted in state %d. Execution of meta-command failed.\n", i, st->state);
          remains = remains - 1;
          PQfinish(st->con);
          st->con = (struct pg_conn *)(void *)0;
        }

      }

    }
    if(!(progress == 0))
    {
      if(thread->tid == 0)
      {
        struct timeval now_time;
        signed long int threadRun__1__5__6__now;
        gettimeofday(&now_time, (struct timezone *)(void *)0);
        threadRun__1__5__6__now = (signed long int)((unsigned long int)now_time.tv_sec * (unsigned long int)1000000 + (unsigned long int)now_time.tv_usec);
        if(threadRun__1__5__6__now >= next_report)
        {
          signed long int count = (signed long int)0;
          signed long int lats = (signed long int)0;
          signed long int sqlats = (signed long int)0;
          signed long int lags = (signed long int)0;
          signed long int run = threadRun__1__5__6__now - last_report;
          double tps;
          double total_run;
          double latency;
          double sqlat;
          double lag;
          double stdev;
          i = 0;
          for( ; !(i >= progress_nclients); i = i + 1)
          {
            count = count + (signed long int)(state + (signed long int)i)->cnt;
            lats = lats + (state + (signed long int)i)->txn_latencies;
            sqlats = sqlats + (state + (signed long int)i)->txn_sqlats;
          }
          i = 0;
          for( ; !(i >= progress_nthreads); i = i + 1)
            lags = lags + (thread + (signed long int)i)->throttle_lag;
          total_run = (double)(threadRun__1__5__6__now - thread_start) / 1000000.0;
          tps = (1000000.0 * (double)(count - last_count)) / (double)run;
          latency = (0.001 * (double)(lats - last_lats)) / (double)(count - last_count);
          sqlat = (1.0 * (double)(sqlats - last_sqlats)) / (double)(count - last_count);
          double return_value_sqrt_15;
          return_value_sqrt_15=sqrt(sqlat - 1000000.0 * latency * latency);
          stdev = 0.001 * return_value_sqrt_15;
          lag = (0.001 * (double)(lags - last_lags)) / (double)(count - last_count);
          if(!(throttle_delay == 0l))
            fprintf(stderr, "progress: %.1f s, %.1f tps, lat %.3f ms stddev %.3f, lag %.3f ms\n", total_run, tps, latency, stdev, lag);

          else
            fprintf(stderr, "progress: %.1f s, %.1f tps, lat %.3f ms stddev %.3f\n", total_run, tps, latency, stdev);
          last_count = count;
          last_lats = lats;
          last_sqlats = sqlats;
          last_lags = lags;
          last_report = threadRun__1__5__6__now;
          do
            next_report = next_report + (signed long int)progress * (signed long int)1000000;
          while(threadRun__1__5__6__now >= next_report);
        }

      }

    }

  }

done:
  ;
  gettimeofday(&start, (struct timezone *)(void *)0);
  disconnect_all(state, nstate);
  result->xacts = (signed long int)0;
  result->latencies = (signed long int)0;
  result->sqlats = (signed long int)0;
  i = 0;
  for( ; !(i >= nstate); i = i + 1)
  {
    result->xacts = result->xacts + (signed long int)(state + (signed long int)i)->cnt;
    result->latencies = result->latencies + (state + (signed long int)i)->txn_latencies;
    result->sqlats = result->sqlats + (state + (signed long int)i)->txn_sqlats;
  }
  result->throttle_lag = thread->throttle_lag;
  result->throttle_lag_max = thread->throttle_lag_max;
  gettimeofday(&end, (struct timezone *)(void *)0);
  do
  {
    result->conn_time.tv_sec = result->conn_time.tv_sec + (end.tv_sec - start.tv_sec);
    result->conn_time.tv_usec = result->conn_time.tv_usec + (end.tv_usec - start.tv_usec);
    for( ; !(result->conn_time.tv_usec >= 0l); result->conn_time.tv_sec = result->conn_time.tv_sec - 1l)
      result->conn_time.tv_usec = result->conn_time.tv_usec + (signed long int)1000000;
    for( ; result->conn_time.tv_usec >= 1000000l; result->conn_time.tv_sec = result->conn_time.tv_sec + 1l)
      result->conn_time.tv_usec = result->conn_time.tv_usec - (signed long int)1000000;
  }
  while((_Bool)0);
  if(!(logfile == ((struct _IO_FILE *)NULL)))
    fclose(logfile);

  return (void *)result;
}

// trim_directory
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 834
static void trim_directory(char *path)
{
  char *p;
  path = path;
  _Bool tmp_if_expr_2;
  if(!((signed int)*path == 0))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(path);
    p = (path + (signed long int)return_value_strlen_1) - (signed long int)1;
    for( ; (signed int)*p == 47 && !(path >= p); p = p - 1l)
      ;
    for( ; !((signed int)*p == 47) && !(path >= p); p = p - 1l)
      ;
    do
    {
      if(!(path >= p))
        tmp_if_expr_2 = (signed int)*(p - (signed long int)1) == 47 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        break;

      p = p - 1l;
    }
    while((_Bool)1);
    if(p == path)
    {
      if((signed int)*p == 47)
        p = p + 1l;

    }

    *p = (char)0;
  }

}

// trim_directory_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 834
static void trim_directory_link1(char *path_link1)
{
  char *p_link1;
  path_link1 = path_link1;
  _Bool tmp_if_expr_2_link1;
  if(!((signed int)*path_link1 == 0))
  {
    unsigned long int return_value_strlen_1_link1;
    return_value_strlen_1_link1=strlen(path_link1);
    p_link1 = (path_link1 + (signed long int)return_value_strlen_1_link1) - (signed long int)1;
    for( ; (signed int)*p_link1 == 47 && !(path_link1 >= p_link1); p_link1 = p_link1 - 1l)
      ;
    for( ; !((signed int)*p_link1 == 47) && !(path_link1 >= p_link1); p_link1 = p_link1 - 1l)
      ;
    do
    {
      if(!(path_link1 >= p_link1))
        tmp_if_expr_2_link1 = (signed int)*(p_link1 - (signed long int)1) == 47 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2_link1 = (_Bool)0;
      if(!tmp_if_expr_2_link1)
        break;

      p_link1 = p_link1 - 1l;
    }
    while((_Bool)1);
    if(p_link1 == path_link1)
    {
      if((signed int)*p_link1 == 47)
        p_link1 = p_link1 + 1l;

    }

    *p_link1 = (char)0;
  }

}

// trim_trailing_separator
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 865
static void trim_trailing_separator(char *path)
{
  char *p;
  path = path;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(path);
  p = path + (signed long int)return_value_strlen_1;
  _Bool tmp_if_expr_2;
  if(!(path >= p))
  {
    p = p - 1l;
    do
    {
      if(!(path >= p))
        tmp_if_expr_2 = (signed int)*p == 47 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        break;

      *p = (char)0;
      p = p - 1l;
    }
    while((_Bool)1);
  }

}

// trim_trailing_separator_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/port/path.c line 865
static void trim_trailing_separator_link1(char *path_link1)
{
  char *p_link1;
  path_link1 = path_link1;
  unsigned long int return_value_strlen_1_link1;
  return_value_strlen_1_link1=strlen(path_link1);
  p_link1 = path_link1 + (signed long int)return_value_strlen_1_link1;
  _Bool tmp_if_expr_2_link1;
  if(!(path_link1 >= p_link1))
  {
    p_link1 = p_link1 - 1l;
    do
    {
      if(!(path_link1 >= p_link1))
        tmp_if_expr_2_link1 = (signed int)*p_link1 == 47 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2_link1 = (_Bool)0;
      if(!tmp_if_expr_2_link1)
        break;

      *p_link1 = (char)0;
      p_link1 = p_link1 - 1l;
    }
    while((_Bool)1);
  }

}

// ucs_wcwidth
// file wchar.c line 637
static signed int ucs_wcwidth(unsigned int ucs)
{
  if(ucs == 0u)
    return 0;

  else
    if(ucs >= 1114112u || ucs >= 127u && !(ucs >= 160u) || !(ucs >= 32u))
      return -1;

    else
    {
      signed int return_value_mbbisearch_1;
      static struct mbinterval combining[100l] = { { .first=(unsigned short int)0x0300, .last=(unsigned short int)0x034E },
    { .first=(unsigned short int)0x0360, .last=(unsigned short int)0x0362 },
    { .first=(unsigned short int)0x0483, .last=(unsigned short int)0x0486 },
    { .first=(unsigned short int)0x0488, .last=(unsigned short int)0x0489 },
    { .first=(unsigned short int)0x0591, .last=(unsigned short int)0x05A1 },
    { .first=(unsigned short int)0x05A3, .last=(unsigned short int)0x05B9 },
    { .first=(unsigned short int)0x05BB, .last=(unsigned short int)0x05BD },
    { .first=(unsigned short int)0x05BF, .last=(unsigned short int)0x05BF },
    { .first=(unsigned short int)0x05C1, .last=(unsigned short int)0x05C2 },
    { .first=(unsigned short int)0x05C4, .last=(unsigned short int)0x05C4 },
    { .first=(unsigned short int)0x064B, .last=(unsigned short int)0x0655 },
    { .first=(unsigned short int)0x0670, .last=(unsigned short int)0x0670 },
    { .first=(unsigned short int)0x06D6, .last=(unsigned short int)0x06E4 },
    { .first=(unsigned short int)0x06E7, .last=(unsigned short int)0x06E8 },
    { .first=(unsigned short int)0x06EA, .last=(unsigned short int)0x06ED },
    { .first=(unsigned short int)0x070F, .last=(unsigned short int)0x070F },
    { .first=(unsigned short int)0x0711, .last=(unsigned short int)0x0711 },
    { .first=(unsigned short int)0x0730, .last=(unsigned short int)0x074A },
    { .first=(unsigned short int)0x07A6, .last=(unsigned short int)0x07B0 },
    { .first=(unsigned short int)0x0901, .last=(unsigned short int)0x0902 },
    { .first=(unsigned short int)0x093C, .last=(unsigned short int)0x093C },
    { .first=(unsigned short int)0x0941, .last=(unsigned short int)0x0948 },
    { .first=(unsigned short int)0x094D, .last=(unsigned short int)0x094D },
    { .first=(unsigned short int)0x0951, .last=(unsigned short int)0x0954 },
    { .first=(unsigned short int)0x0962, .last=(unsigned short int)0x0963 },
    { .first=(unsigned short int)0x0981, .last=(unsigned short int)0x0981 },
    { .first=(unsigned short int)0x09BC, .last=(unsigned short int)0x09BC },
    { .first=(unsigned short int)0x09C1, .last=(unsigned short int)0x09C4 },
    { .first=(unsigned short int)0x09CD, .last=(unsigned short int)0x09CD },
    { .first=(unsigned short int)0x09E2, .last=(unsigned short int)0x09E3 },
    { .first=(unsigned short int)0x0A02, .last=(unsigned short int)0x0A02 },
    { .first=(unsigned short int)0x0A3C, .last=(unsigned short int)0x0A3C },
    { .first=(unsigned short int)0x0A41, .last=(unsigned short int)0x0A42 },
    { .first=(unsigned short int)0x0A47, .last=(unsigned short int)0x0A48 },
    { .first=(unsigned short int)0x0A4B, .last=(unsigned short int)0x0A4D },
    { .first=(unsigned short int)0x0A70, .last=(unsigned short int)0x0A71 },
    { .first=(unsigned short int)0x0A81, .last=(unsigned short int)0x0A82 },
    { .first=(unsigned short int)0x0ABC, .last=(unsigned short int)0x0ABC },
    { .first=(unsigned short int)0x0AC1, .last=(unsigned short int)0x0AC5 },
    { .first=(unsigned short int)0x0AC7, .last=(unsigned short int)0x0AC8 },
    { .first=(unsigned short int)0x0ACD, .last=(unsigned short int)0x0ACD },
    { .first=(unsigned short int)0x0B01, .last=(unsigned short int)0x0B01 },
    { .first=(unsigned short int)0x0B3C, .last=(unsigned short int)0x0B3C },
    { .first=(unsigned short int)0x0B3F, .last=(unsigned short int)0x0B3F },
    { .first=(unsigned short int)0x0B41, .last=(unsigned short int)0x0B43 },
    { .first=(unsigned short int)0x0B4D, .last=(unsigned short int)0x0B4D },
    { .first=(unsigned short int)0x0B56, .last=(unsigned short int)0x0B56 },
    { .first=(unsigned short int)0x0B82, .last=(unsigned short int)0x0B82 },
    { .first=(unsigned short int)0x0BC0, .last=(unsigned short int)0x0BC0 },
    { .first=(unsigned short int)0x0BCD, .last=(unsigned short int)0x0BCD },
    { .first=(unsigned short int)0x0C3E, .last=(unsigned short int)0x0C40 },
    { .first=(unsigned short int)0x0C46, .last=(unsigned short int)0x0C48 },
    { .first=(unsigned short int)0x0C4A, .last=(unsigned short int)0x0C4D },
    { .first=(unsigned short int)0x0C55, .last=(unsigned short int)0x0C56 },
    { .first=(unsigned short int)0x0CBF, .last=(unsigned short int)0x0CBF },
    { .first=(unsigned short int)0x0CC6, .last=(unsigned short int)0x0CC6 },
    { .first=(unsigned short int)0x0CCC, .last=(unsigned short int)0x0CCD },
    { .first=(unsigned short int)0x0D41, .last=(unsigned short int)0x0D43 },
    { .first=(unsigned short int)0x0D4D, .last=(unsigned short int)0x0D4D },
    { .first=(unsigned short int)0x0DCA, .last=(unsigned short int)0x0DCA },
    { .first=(unsigned short int)0x0DD2, .last=(unsigned short int)0x0DD4 },
    { .first=(unsigned short int)0x0DD6, .last=(unsigned short int)0x0DD6 },
    { .first=(unsigned short int)0x0E31, .last=(unsigned short int)0x0E31 },
    { .first=(unsigned short int)0x0E34, .last=(unsigned short int)0x0E3A },
    { .first=(unsigned short int)0x0E47, .last=(unsigned short int)0x0E4E },
    { .first=(unsigned short int)0x0EB1, .last=(unsigned short int)0x0EB1 },
    { .first=(unsigned short int)0x0EB4, .last=(unsigned short int)0x0EB9 },
    { .first=(unsigned short int)0x0EBB, .last=(unsigned short int)0x0EBC },
    { .first=(unsigned short int)0x0EC8, .last=(unsigned short int)0x0ECD },
    { .first=(unsigned short int)0x0F18, .last=(unsigned short int)0x0F19 },
    { .first=(unsigned short int)0x0F35, .last=(unsigned short int)0x0F35 },
    { .first=(unsigned short int)0x0F37, .last=(unsigned short int)0x0F37 },
    { .first=(unsigned short int)0x0F39, .last=(unsigned short int)0x0F39 },
    { .first=(unsigned short int)0x0F71, .last=(unsigned short int)0x0F7E },
    { .first=(unsigned short int)0x0F80, .last=(unsigned short int)0x0F84 },
    { .first=(unsigned short int)0x0F86, .last=(unsigned short int)0x0F87 },
    { .first=(unsigned short int)0x0F90, .last=(unsigned short int)0x0F97 },
    { .first=(unsigned short int)0x0F99, .last=(unsigned short int)0x0FBC },
    { .first=(unsigned short int)0x0FC6, .last=(unsigned short int)0x0FC6 },
    { .first=(unsigned short int)0x102D, .last=(unsigned short int)0x1030 },
    { .first=(unsigned short int)0x1032, .last=(unsigned short int)0x1032 },
    { .first=(unsigned short int)0x1036, .last=(unsigned short int)0x1037 },
    { .first=(unsigned short int)0x1039, .last=(unsigned short int)0x1039 },
    { .first=(unsigned short int)0x1058, .last=(unsigned short int)0x1059 },
    { .first=(unsigned short int)0x1160, .last=(unsigned short int)0x11FF },
    { .first=(unsigned short int)0x17B7, .last=(unsigned short int)0x17BD },
    { .first=(unsigned short int)0x17C6, .last=(unsigned short int)0x17C6 },
    { .first=(unsigned short int)0x17C9, .last=(unsigned short int)0x17D3 },
    { .first=(unsigned short int)0x180B, .last=(unsigned short int)0x180E },
    { .first=(unsigned short int)0x18A9, .last=(unsigned short int)0x18A9 },
    { .first=(unsigned short int)0x200B, .last=(unsigned short int)0x200F },
    { .first=(unsigned short int)0x202A, .last=(unsigned short int)0x202E },
    { .first=(unsigned short int)0x206A, .last=(unsigned short int)0x206F },
    { .first=(unsigned short int)0x20D0, .last=(unsigned short int)0x20E3 },
    { .first=(unsigned short int)0x302A, .last=(unsigned short int)0x302F },
    { .first=(unsigned short int)0x3099, .last=(unsigned short int)0x309A },
    { .first=(unsigned short int)0xFB1E, .last=(unsigned short int)0xFB1E },
    { .first=(unsigned short int)0xFE20, .last=(unsigned short int)0xFE23 },
    { .first=(unsigned short int)0xFEFF, .last=(unsigned short int)0xFEFF },
    { .first=(unsigned short int)0xFFF9, .last=(unsigned short int)0xFFFB } };
      return_value_mbbisearch_1=mbbisearch(ucs, combining, (signed int)(sizeof(struct mbinterval [100l]) /*400ul*/  / sizeof(struct mbinterval) /*4ul*/  - (unsigned long int)1));
      if(!(return_value_mbbisearch_1 == 0))
        return 0;

      else
        return 1 + (signed int)(ucs >= (unsigned int)0x1100 && (ucs <= (unsigned int)0x115f || ucs >= (unsigned int)0x2e80 && ucs <= (unsigned int)0xa4cf && (ucs & (unsigned int)~0x0011) != (unsigned int)0x300a && ucs != (unsigned int)0x303f || ucs >= (unsigned int)0xac00 && ucs <= (unsigned int)0xd7a3 || ucs >= (unsigned int)0xf900 && ucs <= (unsigned int)0xfaff || ucs >= (unsigned int)0xfe30 && ucs <= (unsigned int)0xfe6f || ucs >= (unsigned int)0xff00 && ucs <= (unsigned int)0xff5f || ucs >= (unsigned int)0xffe0 && ucs <= (unsigned int)0xffe6 || ucs >= (unsigned int)0x20000 && ucs <= (unsigned int)0x2ffff));
    }
}

// unicode_to_utf8
// file wchar.c line 475
extern unsigned char * unicode_to_utf8(unsigned int c, unsigned char *utf8string)
{
  if(!(c >= 128u))
    utf8string[(signed long int)0] = (unsigned char)c;

  else
    if(!(c >= 2048u))
    {
      utf8string[(signed long int)0] = (unsigned char)((unsigned int)0xC0 | c >> 6 & (unsigned int)0x1F);
      utf8string[(signed long int)1] = (unsigned char)((unsigned int)0x80 | c & (unsigned int)0x3F);
    }

    else
      if(!(c >= 65536u))
      {
        utf8string[(signed long int)0] = (unsigned char)((unsigned int)0xE0 | c >> 12 & (unsigned int)0x0F);
        utf8string[(signed long int)1] = (unsigned char)((unsigned int)0x80 | c >> 6 & (unsigned int)0x3F);
        utf8string[(signed long int)2] = (unsigned char)((unsigned int)0x80 | c & (unsigned int)0x3F);
      }

      else
      {
        utf8string[(signed long int)0] = (unsigned char)((unsigned int)0xF0 | c >> 18 & (unsigned int)0x07);
        utf8string[(signed long int)1] = (unsigned char)((unsigned int)0x80 | c >> 12 & (unsigned int)0x3F);
        utf8string[(signed long int)2] = (unsigned char)((unsigned int)0x80 | c >> 6 & (unsigned int)0x3F);
        utf8string[(signed long int)3] = (unsigned char)((unsigned int)0x80 | c & (unsigned int)0x3F);
      }
  return utf8string;
}

// uri_prefix_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 4201
static signed int uri_prefix_length(const char *connstr)
{
  signed int return_value_strncmp_1;
  return_value_strncmp_1=strncmp(connstr, uri_designator, sizeof(const char [14l]) /*14ul*/  - (unsigned long int)1);
  if(return_value_strncmp_1 == 0)
    return (signed int)(sizeof(const char [14l]) /*14ul*/  - (unsigned long int)1);

  else
  {
    signed int return_value_strncmp_2;
    return_value_strncmp_2=strncmp(connstr, short_uri_designator, sizeof(const char [12l]) /*12ul*/  - (unsigned long int)1);
    if(return_value_strncmp_2 == 0)
      return (signed int)(sizeof(const char [12l]) /*12ul*/  - (unsigned long int)1);

    else
      return 0;
  }
}

// usage
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../contrib/pgbench/pgbench.c line 345
static void usage(void)
{
  printf("%s is a benchmarking tool for PostgreSQL.\n\nUsage:\n  %s [OPTION]... [DBNAME]\n\nInitialization options:\n  -i, --initialize         invokes initialization mode\n  -F, --fillfactor=NUM     set fill factor\n  -n, --no-vacuum          do not run VACUUM after initialization\n  -q, --quiet              quiet logging (one message each 5 seconds)\n  -s, --scale=NUM          scaling factor\n  --foreign-keys           create foreign key constraints between tables\n  --index-tablespace=TABLESPACE\n                           create indexes in the specified tablespace\n  --tablespace=TABLESPACE  create tables in the specified tablespace\n  --unlogged-tables        create tables as unlogged tables\n\nBenchmarking options:\n  -c, --client=NUM         number of concurrent database clients (default: 1)\n  -C, --connect            establish new connection for each transaction\n  -D, --define=VARNAME=VALUE\n                           define variable for use by custom script\n  -f, --file=FILENAME      read transaction script from FILENAME\n  -j, --jobs=NUM           number of threads (default: 1)\n  -l, --log                write transaction times to log file\n  -M, --protocol=simple|extended|prepared\n                           protocol for submitting queries (default: simple)\n  -n, --no-vacuum          do not run VACUUM before tests\n  -N, --skip-some-updates  skip updates of pgbench_tellers and pgbench_branches\n  -P, --progress=NUM       show thread progress report every NUM seconds\n  -r, --report-latencies   report average latency per command\n  -R, --rate=NUM           target rate in transactions per second\n  -s, --scale=NUM          report this scale factor in output\n  -S, --select-only        perform SELECT-only transactions\n  -t, --transactions=NUM   number of transactions each client runs (default: 10)\n  -T, --time=NUM           duration of benchmark test in seconds\n  -v, --vacuum-all         vacuum all four standard tables before tests\n  --aggregate-interval=NUM aggregate data over NUM seconds\n  --sampling-rate=NUM      fraction of transactions to log (e.g. 0.01 for 1%%)\n\nCommon options:\n  -d, --debug              print debugging output\n  -h, --host=HOSTNAME      database server host or socket directory\n  -p, --port=PORT          database server port number\n  -U, --username=USERNAME  connect as specified database user\n  -V, --version            output version information, then exit\n  -?, --help               show this help, then exit\n\nReport bugs to <pgsql-bugs@postgresql.org>.\n", progname, progname);
}

// useKeepalives
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-connect.c line 1207
static signed int useKeepalives(struct pg_conn *conn)
{
  char *ep;
  signed int val;
  if(conn->keepalives == ((char *)NULL))
    return 1;

  else
  {
    signed long int return_value_strtol_1;
    return_value_strtol_1=strtol(conn->keepalives, &ep, 10);
    val = (signed int)return_value_strtol_1;
    if(!(*ep == 0))
      return -1;

    else
      return val != 0 ? 1 : 0;
  }
}

// utf8_to_unicode
// file wchar.c line 714
extern unsigned int utf8_to_unicode(const unsigned char *c)
{
  if((0x80 & (signed int)*c) == 0)
    return (unsigned int)c[(signed long int)0];

  else
    if((0xe0 & (signed int)*c) == 0xc0)
      return (unsigned int)(((signed int)c[(signed long int)0] & 0x1f) << 6 | (signed int)c[(signed long int)1] & 0x3f);

    else
      if((0xf0 & (signed int)*c) == 0xe0)
        return (unsigned int)(((signed int)c[(signed long int)0] & 0x0f) << 12 | ((signed int)c[(signed long int)1] & 0x3f) << 6 | (signed int)c[(signed long int)2] & 0x3f);

      else
        if((0xf8 & (signed int)*c) == 0xf0)
          return (unsigned int)(((signed int)c[(signed long int)0] & 0x07) << 18 | ((signed int)c[(signed long int)1] & 0x3f) << 12 | ((signed int)c[(signed long int)2] & 0x3f) << 6 | (signed int)c[(signed long int)3] & 0x3f);

        else
          return 0xffffffff;
}

// validate_exec
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 58
static signed int validate_exec(const char *path)
{
  struct stat buf;
  signed int is_r;
  signed int is_x;
  signed int return_value_stat_1;
  return_value_stat_1=stat(path, &buf);
  if(!(return_value_stat_1 >= 0))
    return -1;

  else
    if(!((61440u & buf.st_mode) == 32768u))
      return -1;

    else
    {
      signed int return_value_access_2;
      return_value_access_2=access(path, 4);
      is_r = (signed int)(return_value_access_2 == 0);
      signed int return_value_access_3;
      return_value_access_3=access(path, 1);
      is_x = (signed int)(return_value_access_3 == 0);
      return is_x != 0 ? (is_r != 0 ? 0 : -2) : -1;
    }
}

// validate_exec_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/common/exec.c line 58
static signed int validate_exec_link1(const char *path_link1)
{
  struct stat buf_link1;
  signed int is_r_link1;
  signed int is_x_link1;
  signed int return_value_stat_1_link1;
  return_value_stat_1_link1=stat(path_link1, &buf_link1);
  if(!(return_value_stat_1_link1 >= 0))
    return -1;

  else
    if(!((61440u & buf_link1.st_mode) == 32768u))
      return -1;

    else
    {
      signed int return_value_access_2_link1;
      return_value_access_2_link1=access(path_link1, 4);
      is_r_link1 = (signed int)(return_value_access_2_link1 == 0);
      signed int return_value_access_3_link1;
      return_value_access_3_link1=access(path_link1, 1);
      is_x_link1 = (signed int)(return_value_access_3_link1 == 0);
      return is_x_link1 != 0 ? (is_r_link1 != 0 ? 0 : -2) : -1;
    }
}

// verify_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 698
static signed int verify_cb(signed int ok, struct x509_store_ctx_st *ctx)
{
  return ok;
}

// verify_peer_name_matches_certificate
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 760
static char verify_peer_name_matches_certificate(struct pg_conn *conn)
{
  char *peer_cn;
  signed int r;
  signed int len;
  char result;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(conn->sslmode, "verify-full");
  _Bool tmp_if_expr_14;
  signed int return_value_wildcard_certificate_match_12;
  if(!(return_value_strcmp_1 == 0))
    return (char)1;

  else
  {
    struct X509_name_st *return_value_X509_get_subject_name_2;
    return_value_X509_get_subject_name_2=X509_get_subject_name(conn->peer);
    len=X509_NAME_get_text_by_NID(return_value_X509_get_subject_name_2, 13, (char *)(void *)0, 0);
    if(len == -1)
    {
      char *return_value_libpq_gettext_3;
      return_value_libpq_gettext_3=libpq_gettext("could not get server common name from server certificate\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_3);
      return (char)0;
    }

    void *return_value_malloc_4;
    return_value_malloc_4=malloc((unsigned long int)(len + 1));
    peer_cn = (char *)return_value_malloc_4;
    if(peer_cn == ((char *)NULL))
    {
      char *return_value_libpq_gettext_5;
      return_value_libpq_gettext_5=libpq_gettext("out of memory\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_5);
      return (char)0;
    }

    struct X509_name_st *return_value_X509_get_subject_name_6;
    return_value_X509_get_subject_name_6=X509_get_subject_name(conn->peer);
    r=X509_NAME_get_text_by_NID(return_value_X509_get_subject_name_6, 13, peer_cn, len + 1);
    if(!(r == len))
    {
      char *return_value_libpq_gettext_7;
      return_value_libpq_gettext_7=libpq_gettext("could not get server common name from server certificate\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_7);
      free((void *)peer_cn);
      return (char)0;
    }

    peer_cn[(signed long int)len] = (char)0;
    unsigned long int return_value_strlen_9;
    return_value_strlen_9=strlen(peer_cn);
    if(!((unsigned long int)len == return_value_strlen_9))
    {
      char *return_value_libpq_gettext_8;
      return_value_libpq_gettext_8=libpq_gettext("SSL certificate's common name contains embedded null\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_8);
      free((void *)peer_cn);
      return (char)0;
    }

    if(!(conn->pghost == ((char *)NULL)))
      tmp_if_expr_14 = (signed int)conn->pghost[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_14 = (_Bool)0;
    if(!tmp_if_expr_14)
    {
      char *return_value_libpq_gettext_10;
      return_value_libpq_gettext_10=libpq_gettext("host name must be specified for a verified SSL connection\n");
      printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_10);
      result = (char)0;
    }

    else
    {
      signed int return_value_pg_strcasecmp_13;
      return_value_pg_strcasecmp_13=pg_strcasecmp(peer_cn, conn->pghost);
      if(return_value_pg_strcasecmp_13 == 0)
        result = (char)1;

      else
      {
        return_value_wildcard_certificate_match_12=wildcard_certificate_match(peer_cn, conn->pghost);
        if(!(return_value_wildcard_certificate_match_12 == 0))
          result = (char)1;

        else
        {
          char *return_value_libpq_gettext_11;
          return_value_libpq_gettext_11=libpq_gettext("server common name \"%s\" does not match host name \"%s\"\n");
          printfPQExpBuffer(&conn->errorMessage, return_value_libpq_gettext_11, peer_cn, conn->pghost);
          result = (char)0;
        }
      }
    }
    free((void *)peer_cn);
    return result;
  }
}

// wait_result_to_str
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/include/port.h line 481
extern char * wait_result_to_str(signed int exitstatus)
{
  char str[512l];
  char *return_value_gettext_1;
  char *return_value_gettext_2;
  const char *tmp_if_expr_4;
  char *return_value_gettext_6;
  /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_34
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
  ;
  if((0x7f & exitstatus) == 0)
    switch((((union anonymous_34){ .__in=exitstatus }).__i & 0xff00) >> 8)
    {
      case 126:
      {
        return_value_gettext_1=gettext("command not executable");
        snprintf(str, sizeof(char [512l]) /*512ul*/ , return_value_gettext_1);
        break;
      }
      case 127:
      {
        return_value_gettext_2=gettext("command not found");
        snprintf(str, sizeof(char [512l]) /*512ul*/ , return_value_gettext_2);
        break;
      }
      default:
      {
        char *return_value_gettext_3;
        return_value_gettext_3=gettext("child process exited with exit code %d");
        snprintf(str, sizeof(char [512l]) /*512ul*/ , return_value_gettext_3, (((union anonymous_34){ .__in=exitstatus }).__i & 0xff00) >> 8);
      }
    }

  else
    if((signed int)((127 & (signed char)exitstatus) + 1) >> 1 >= 1)
    {
      char str2[256l];
      if(!((0x7f & exitstatus) >= 65))
        tmp_if_expr_4 = sys_siglist[(signed long int)(((union anonymous_34){ .__in=exitstatus }).__i & 0x7f)];

      else
        tmp_if_expr_4 = "(unknown)";
      snprintf(str2, sizeof(char [256l]) /*256ul*/ , "%d: %s", ((union anonymous_34){ .__in=exitstatus }).__i & 0x7f, tmp_if_expr_4);
      char *return_value_gettext_5;
      return_value_gettext_5=gettext("child process was terminated by signal %s");
      snprintf(str, sizeof(char [512l]) /*512ul*/ , return_value_gettext_5, (const void *)str2);
    }

    else
    {
      return_value_gettext_6=gettext("child process exited with unrecognized status %d");
      snprintf(str, sizeof(char [512l]) /*512ul*/ , return_value_gettext_6, exitstatus);
    }
  char *return_value_pstrdup_7;
  return_value_pstrdup_7=pstrdup(str);
  return return_value_pstrdup_7;
}

// wildcard_certificate_match
// file /srv/jenkins-slave/workspace/sid-goto-cc-postgresql-9.4/postgresql-9.4-9.4.5/build/../src/interfaces/libpq/fe-secure.c line 720
static signed int wildcard_certificate_match(const char *pattern, const char *string)
{
  signed int lenpat;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(pattern);
  lenpat = (signed int)return_value_strlen_1;
  signed int lenstr;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(string);
  lenstr = (signed int)return_value_strlen_2;
  _Bool tmp_if_expr_3;
  if(!(lenpat >= 3))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)pattern[(signed long int)0] != 42 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = (signed int)pattern[(signed long int)1] != 46 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_4)
    return 0;

  else
    if(!(lenstr >= lenpat))
      return 0;

    else
    {
      signed int return_value_pg_strcasecmp_5;
      return_value_pg_strcasecmp_5=pg_strcasecmp(pattern + (signed long int)1, ((string + (signed long int)lenstr) - (signed long int)lenpat) + (signed long int)1);
      if(!(return_value_pg_strcasecmp_5 == 0))
        return 0;

      else
      {
        char *return_value_strchr_6;
        return_value_strchr_6=strchr(string, 46);
        if(!(return_value_strchr_6 >= string + (signed long int)lenstr + -((signed long int)lenpat)))
          return 0;

        else
          return 1;
      }
    }
}

