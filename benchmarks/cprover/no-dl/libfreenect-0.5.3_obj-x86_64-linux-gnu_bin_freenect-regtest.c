// #anon_enum_FREENECT_AUTO_EXPOSURE=16384_FREENECT_AUTO_WHITE_BALANCE=2_FREENECT_RAW_COLOR=16_FREENECT_MIRROR_DEPTH=65536_FREENECT_MIRROR_VIDEO=131072_FREENECT_NEAR_MODE=262144
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 110
enum anonymous_8 { FREENECT_AUTO_EXPOSURE=16384, FREENECT_AUTO_WHITE_BALANCE=2, FREENECT_RAW_COLOR=16, FREENECT_MIRROR_DEPTH=65536, FREENECT_MIRROR_VIDEO=131072, FREENECT_NEAR_MODE=262144 };

// #anon_enum_FREENECT_DEPTH_11BIT=0_FREENECT_DEPTH_10BIT=1_FREENECT_DEPTH_11BIT_PACKED=2_FREENECT_DEPTH_10BIT_PACKED=3_FREENECT_DEPTH_REGISTERED=4_FREENECT_DEPTH_MM=5_FREENECT_DEPTH_DUMMY=2147483647
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 99
enum anonymous_5 { FREENECT_DEPTH_11BIT=0, FREENECT_DEPTH_10BIT=1, FREENECT_DEPTH_11BIT_PACKED=2, FREENECT_DEPTH_10BIT_PACKED=3, FREENECT_DEPTH_REGISTERED=4, FREENECT_DEPTH_MM=5, FREENECT_DEPTH_DUMMY=2147483647 };

// #anon_enum_FREENECT_DEVICE_MOTOR=1_FREENECT_DEVICE_CAMERA=2_FREENECT_DEVICE_AUDIO=4
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 58
enum anonymous_22 { FREENECT_DEVICE_MOTOR=1, FREENECT_DEVICE_CAMERA=2, FREENECT_DEVICE_AUDIO=4 };

// #anon_enum_FREENECT_LOG_FATAL=0_FREENECT_LOG_ERROR=1_FREENECT_LOG_WARNING=2_FREENECT_LOG_NOTICE=3_FREENECT_LOG_INFO=4_FREENECT_LOG_DEBUG=5_FREENECT_LOG_SPEW=6_FREENECT_LOG_FLOOD=7
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 201
enum anonymous_21 { FREENECT_LOG_FATAL=0, FREENECT_LOG_ERROR=1, FREENECT_LOG_WARNING=2, FREENECT_LOG_NOTICE=3, FREENECT_LOG_INFO=4, FREENECT_LOG_DEBUG=5, FREENECT_LOG_SPEW=6, FREENECT_LOG_FLOOD=7 };

// #anon_enum_FREENECT_OFF=0_FREENECT_ON=1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 122
enum anonymous_9 { FREENECT_OFF=0, FREENECT_ON=1 };

// #anon_enum_FREENECT_RESOLUTION_LOW=0_FREENECT_RESOLUTION_MEDIUM=1_FREENECT_RESOLUTION_HIGH=2_FREENECT_RESOLUTION_DUMMY=2147483647
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 77
enum anonymous_13 { FREENECT_RESOLUTION_LOW=0, FREENECT_RESOLUTION_MEDIUM=1, FREENECT_RESOLUTION_HIGH=2, FREENECT_RESOLUTION_DUMMY=2147483647 };

// #anon_enum_FREENECT_VIDEO_RGB=0_FREENECT_VIDEO_BAYER=1_FREENECT_VIDEO_IR_8BIT=2_FREENECT_VIDEO_IR_10BIT=3_FREENECT_VIDEO_IR_10BIT_PACKED=4_FREENECT_VIDEO_YUV_RGB=5_FREENECT_VIDEO_YUV_RAW=6_FREENECT_VIDEO_DUMMY=2147483647
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 86
enum anonymous_4 { FREENECT_VIDEO_RGB=0, FREENECT_VIDEO_BAYER=1, FREENECT_VIDEO_IR_8BIT=2, FREENECT_VIDEO_IR_10BIT=3, FREENECT_VIDEO_IR_10BIT_PACKED=4, FREENECT_VIDEO_YUV_RGB=5, FREENECT_VIDEO_YUV_RAW=6, FREENECT_VIDEO_DUMMY=2147483647 };

// #anon_enum_LED_OFF=0_LED_GREEN=1_LED_RED=2_LED_YELLOW=3_LED_BLINK_GREEN=4_LED_BLINK_RED_YELLOW=6
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 149
enum anonymous_23 { LED_OFF=0, LED_GREEN=1, LED_RED=2, LED_YELLOW=3, LED_BLINK_GREEN=4, LED_BLINK_RED_YELLOW=6 };

// #anon_enum_TILT_STATUS_STOPPED=0_TILT_STATUS_LIMIT=1_TILT_STATUS_MOVING=4
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 161
enum anonymous_32 { TILT_STATUS_STOPPED=0, TILT_STATUS_LIMIT=1, TILT_STATUS_MOVING=4 };

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_freenect_device#}_SYM#tag-_freenect_device#_'parent'||*{SYM#tag-libusb_device_handle#}_SYM#tag-libusb_device_handle#_'dev'||S32'device_dead'||S32'VID'||S32'PID'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_freenect_device#}_SYM#tag-_freenect_device#_'parent'||*{SYM#tag-libusb_device_handle#}_SYM#tag-libusb_device_handle#_'dev'||S32'device_dead'||S32'VID'||S32'PID'||U32'_pad0'|]#_'parent'||*{*{SYM#tag-libusb_transfer#}_SYM#tag-libusb_transfer#_}_*{SYM#tag-libusb_transfer#}_SYM#tag-libusb_transfer#__'xfers'||*{U8}_U8_'buffer'||*{V(*{SYM#tag-_freenect_device#}_SYM#tag-_freenect_device#_|*{U8}_U8_|S32)->V}_V(*{SYM#tag-_freenect_device#}_SYM#tag-_freenect_device#_|*{U8}_U8_|S32)->V_'cb'||S32'num_xfers'||S32'pkts'||S32'len'||S32'dead'||S32'dead_xfers'||U32'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 65
struct anonymous_11;

// tag-#anon#ST[*{SYM#tag-_freenect_device#}_SYM#tag-_freenect_device#_'parent'||*{SYM#tag-libusb_device_handle#}_SYM#tag-libusb_device_handle#_'dev'||S32'device_dead'||S32'VID'||S32'PID'||U32'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 57
struct anonymous_10;

// tag-#anon#ST[*{SYM#tag-libusb_context#}_SYM#tag-libusb_context#_'ctx'||S32'should_free_ctx'||U32'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 52
struct anonymous_20;

// tag-#anon#ST[ARR2{U8}_U8_'magic'||U16'len'||U16'cmd'||U16'tag'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 132
struct anonymous_19;

// tag-#anon#ST[F32'dcmos_emitter_dist'||F32'dcmos_rcmos_dist'||F32'reference_distance'||F32'reference_pixel_size'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_registration.h line 91
struct anonymous_12;

// tag-#anon#ST[S16'accelerometer_x'||S16'accelerometer_y'||S16'accelerometer_z'||S8'tilt_angle'||U8'_pad0'||EN#anon_enum_TILT_STATUS_STOPPED=0_TILT_STATUS_LIMIT=1_TILT_STATUS_MOVING=4#{U32}_U32_'tilt_status'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 168
struct anonymous_18;

// tag-#anon#ST[S16'left'||S16'right'||S16'center'||S16'lfe'||S16'surround_left'||S16'surround_right'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_audio.h line 36
struct anonymous_16;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_1;

// tag-#anon#ST[S32'dx_center'||S32'ax'||S32'bx'||S32'cx'||S32'dx'||S32'dx_start'||S32'ay'||S32'by'||S32'cy'||S32'dy'||S32'dy_start'||S32'dx_beta_start'||S32'dy_beta_start'||S32'rollout_blank'||S32'rollout_size'||S32'dx_beta_inc'||S32'dy_beta_inc'||S32'dxdx_start'||S32'dxdy_start'||S32'dydx_start'||S32'dydy_start'||S32'dxdxdx_start'||S32'dydxdx_start'||S32'dxdxdy_start'||S32'dydxdy_start'||S32'back_comp1'||S32'dydydx_start'||S32'back_comp2'||S32'dydydy_start'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_registration.h line 38
struct anonymous_25;

// tag-#anon#ST[S32'running'||U32'_pad0'||*{SYM#tag-#anon#ST[S16'left'||S16'right'||S16'center'||S16'lfe'||S16'surround_left'||S16'surround_right'|]#}_SYM#tag-#anon#ST[S16'left'||S16'right'||S16'center'||S16'lfe'||S16'surround_left'||S16'surround_right'|]#_'audio_out_ring'||S32'ring_reader_idx'||S32'ring_writer_idx'||U16'out_window'||U8'out_seq'||U8'out_counter_within_window'||U16'out_weird_timestamp'||U8'out_window_parity'||U8'_pad1'||U16'in_window'||ARR10{U16}_U16_'last_seen_window'||U8'in_counter'||U8'_pad2'||ARR4{*{S32}_S32_}_*{S32}_S32__'mic_buffer'||*{S16}_S16_'cancelled_buffer'||*{V}_V_'in_unknown'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/freenect_internal.h line 174
struct anonymous_17;

// tag-#anon#ST[S32'running'||U8'flag'||U24'_pad0'||S32'synced'||U8'seq'||U24'_pad1'||S32'got_pkts'||S32'pkt_num'||S32'pkts_per_frame'||S32'pkt_size'||S32'frame_size'||S32'last_pkt_size'||S32'valid_pkts'||U32'lost_pkts'||S32'valid_frames'||S32'variable_length'||U32'last_timestamp'||U32'timestamp'||S32'split_bufs'||U32'_pad2'||*{V}_V_'lib_buf'||*{V}_V_'usr_buf'||*{U8}_U8_'raw_buf'||*{V}_V_'proc_buf'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/freenect_internal.h line 150
struct anonymous_14;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'dx_center'||S32'ax'||S32'bx'||S32'cx'||S32'dx'||S32'dx_start'||S32'ay'||S32'by'||S32'cy'||S32'dy'||S32'dy_start'||S32'dx_beta_start'||S32'dy_beta_start'||S32'rollout_blank'||S32'rollout_size'||S32'dx_beta_inc'||S32'dy_beta_inc'||S32'dxdx_start'||S32'dxdy_start'||S32'dydx_start'||S32'dydy_start'||S32'dxdxdx_start'||S32'dydxdx_start'||S32'dxdxdy_start'||S32'dydxdy_start'||S32'back_comp1'||S32'dydydx_start'||S32'back_comp2'||S32'dydydy_start'|]#'reg_info'||SYM#tag-#anon#ST[U16'start_lines'||U16'end_lines'||U16'cropping_lines'|]#'reg_pad_info'||U16'_pad0'||SYM#tag-#anon#ST[F32'dcmos_emitter_dist'||F32'dcmos_rcmos_dist'||F32'reference_distance'||F32'reference_pixel_size'|]#'zero_plane_info'||U32'_pad1'||F64'const_shift'||*{U16}_U16_'raw_to_mm_shift'||*{S32}_S32_'depth_to_rgb_shift'||*{ARR2{S32}_S32_}_ARR2{S32}_S32__'registration_table'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_registration.h line 99
struct anonymous_15;

// tag-#anon#ST[U16'start_lines'||U16'end_lines'||U16'cropping_lines'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_registration.h line 84
struct anonymous_24;

// tag-#anon#ST[U32'magic'||U16'channel'||U16'len'||U16'window'||U16'unknown'||ARR0{S32}_S32_'samples'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/freenect_internal.h line 197
struct anonymous_29;

// tag-#anon#ST[U32'magic'||U16'ver_minor'||U16'ver_major'||U16'ver_release'||U16'ver_patch'||U32'base_addr'||U32'size'||U32'entry_addr'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.h line 42
struct anonymous_33;

// tag-#anon#ST[U32'magic'||U32'tag'||U32'arg1'||U32'cmd'||U32'arg2'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 43
struct anonymous_26;

// tag-#anon#ST[U32'magic'||U32'tag'||U32'arg1'||U32'cmd'||U32'arg2'||ARR8{U32}_U32_'zeros'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.h line 53
struct anonymous_30;

// tag-#anon#ST[U32'magic'||U32'tag'||U32'bytes'||U32'cmd'||U32'addr'||U32'unk'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.h line 33
struct anonymous_31;

// tag-#anon#ST[U32'magic'||U32'tag'||U32'status'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 51
struct anonymous_3;

// tag-#anon#ST[U32'reserved'||EN#anon_enum_FREENECT_RESOLUTION_LOW=0_FREENECT_RESOLUTION_MEDIUM=1_FREENECT_RESOLUTION_HIGH=2_FREENECT_RESOLUTION_DUMMY=2147483647#{U32}_U32_'resolution'||SYM#tag-#anon#UN[S32'dummy'||EN#anon_enum_FREENECT_VIDEO_RGB=0_FREENECT_VIDEO_BAYER=1_FREENECT_VIDEO_IR_8BIT=2_FREENECT_VIDEO_IR_10BIT=3_FREENECT_VIDEO_IR_10BIT_PACKED=4_FREENECT_VIDEO_YUV_RGB=5_FREENECT_VIDEO_YUV_RAW=6_FREENECT_VIDEO_DUMMY=2147483647#{U32}_U32_'video_format'||EN#anon_enum_FREENECT_DEPTH_11BIT=0_FREENECT_DEPTH_10BIT=1_FREENECT_DEPTH_11BIT_PACKED=2_FREENECT_DEPTH_10BIT_PACKED=3_FREENECT_DEPTH_REGISTERED=4_FREENECT_DEPTH_MM=5_FREENECT_DEPTH_DUMMY=2147483647#{U32}_U32_'depth_format'|]#'_anon0'||S32'bytes'||S16'width'||S16'height'||S8'data_bits_per_pixel'||S8'padding_bits_per_pixel'||S8'framerate'||S8'is_valid'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 130
struct anonymous_6;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_0;

// tag-#anon#UN[S32'dummy'||EN#anon_enum_FREENECT_VIDEO_RGB=0_FREENECT_VIDEO_BAYER=1_FREENECT_VIDEO_IR_8BIT=2_FREENECT_VIDEO_IR_10BIT=3_FREENECT_VIDEO_IR_10BIT_PACKED=4_FREENECT_VIDEO_YUV_RGB=5_FREENECT_VIDEO_YUV_RAW=6_FREENECT_VIDEO_DUMMY=2147483647#{U32}_U32_'video_format'||EN#anon_enum_FREENECT_DEPTH_11BIT=0_FREENECT_DEPTH_10BIT=1_FREENECT_DEPTH_11BIT_PACKED=2_FREENECT_DEPTH_10BIT_PACKED=3_FREENECT_DEPTH_REGISTERED=4_FREENECT_DEPTH_MM=5_FREENECT_DEPTH_DUMMY=2147483647#{U32}_U32_'depth_format'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 133
union anonymous_27;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_2;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_freenect_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 176
struct _freenect_context;

// tag-_freenect_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 179
struct _freenect_device;

// tag-buffer_ring
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 34
struct buffer_ring;

// tag-freenect_device_attributes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 67
struct freenect_device_attributes;

// tag-libusb_config_descriptor
// file /usr/include/libusb-1.0/libusb.h line 643
struct libusb_config_descriptor;

// tag-libusb_context
// file /usr/include/libusb-1.0/libusb.h line 898
struct libusb_context;

// tag-libusb_device
// file /usr/include/libusb-1.0/libusb.h line 899
struct libusb_device;

// tag-libusb_device_descriptor
// file /usr/include/libusb-1.0/libusb.h line 477
struct libusb_device_descriptor;

// tag-libusb_device_handle
// file /usr/include/libusb-1.0/libusb.h line 900
struct libusb_device_handle;

// tag-libusb_endpoint_descriptor
// file /usr/include/libusb-1.0/libusb.h line 531
struct libusb_endpoint_descriptor;

// tag-libusb_interface
// file /usr/include/libusb-1.0/libusb.h line 629
struct libusb_interface;

// tag-libusb_interface_descriptor
// file /usr/include/libusb-1.0/libusb.h line 581
struct libusb_interface_descriptor;

// tag-libusb_iso_packet_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1177
struct libusb_iso_packet_descriptor;

// tag-libusb_transfer
// file /usr/include/libusb-1.0/libusb.h line 1188
struct libusb_transfer;

// tag-libusb_transfer_status
// file /usr/include/libusb-1.0/libusb.h line 1106
enum libusb_transfer_status { LIBUSB_TRANSFER_COMPLETED=0, LIBUSB_TRANSFER_ERROR=1, LIBUSB_TRANSFER_TIMED_OUT=2, LIBUSB_TRANSFER_CANCELLED=3, LIBUSB_TRANSFER_STALL=4, LIBUSB_TRANSFER_NO_DEVICE=5, LIBUSB_TRANSFER_OVERFLOW=6 };

// tag-pkt_hdr
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 76
struct pkt_hdr;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sync_kinect
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 44
struct sync_kinect;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// alloc_buffer_ring_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 96
static signed int alloc_buffer_ring_depth(enum anonymous_13 res, enum anonymous_5 fmt, struct buffer_ring *buf);
// alloc_buffer_ring_video
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 72
static signed int alloc_buffer_ring_video(enum anonymous_13 res, enum anonymous_4 fmt, struct buffer_ring *buf);
// alloc_kinect
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 249
static struct sync_kinect * alloc_kinect(signed int index);
// change_depth_format
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 237
static signed int change_depth_format(struct sync_kinect *kinect, enum anonymous_13 res, enum anonymous_5 fmt);
// change_video_format
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 225
static signed int change_video_format(struct sync_kinect *kinect, enum anonymous_13 res, enum anonymous_4 fmt);
// complete_tables
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 306
static void complete_tables(struct anonymous_15 *reg);
// complete_tables_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 306
static void complete_tables_link1(struct anonymous_15 *reg_link1);
// convert_bayer_to_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 453
static void convert_bayer_to_rgb(unsigned char *raw_buf, unsigned char *proc_buf, struct anonymous_6 frame_mode);
// convert_bayer_to_rgb_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 453
static void convert_bayer_to_rgb_link1(unsigned char *raw_buf_link1, unsigned char *proc_buf_link1, struct anonymous_6 frame_mode_link1);
// convert_packed11_to_16bit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 345
static void convert_packed11_to_16bit(unsigned char *raw, unsigned short int *frame, signed int n);
// convert_packed11_to_16bit_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 345
static void convert_packed11_to_16bit_link1(unsigned char *raw_link1, unsigned short int *frame_link1, signed int n_link1);
// convert_packed_to_16bit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 304
static inline void convert_packed_to_16bit(unsigned char *src, unsigned short int *dest, signed int vw, signed int n);
// convert_packed_to_16bit_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 304
static inline void convert_packed_to_16bit_link1(unsigned char *src_link1, unsigned short int *dest_link1, signed int vw_link1, signed int n_link1);
// convert_packed_to_8bit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 330
static inline void convert_packed_to_8bit(unsigned char *src, unsigned char *dest, signed int vw, signed int n);
// convert_packed_to_8bit_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 330
static inline void convert_packed_to_8bit_link1(unsigned char *src_link1, unsigned char *dest_link1, signed int vw_link1, signed int n_link1);
// convert_uyvy_to_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 420
static void convert_uyvy_to_rgb(unsigned char *raw_buf, unsigned char *proc_buf, struct anonymous_6 frame_mode);
// convert_uyvy_to_rgb_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 420
static void convert_uyvy_to_rgb_link1(unsigned char *raw_buf_link1, unsigned char *proc_buf_link1, struct anonymous_6 frame_mode_link1);
// depth_process
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 377
static void depth_process(struct _freenect_device *dev, unsigned char *pkt, signed int len);
// depth_process_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 377
static void depth_process_link1(struct _freenect_device *dev_link1, unsigned char *pkt_link1, signed int len_link1);
// depth_producer_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 153
static void depth_producer_cb(struct _freenect_device *dev, void *data, unsigned int timestamp);
// dump_bl_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 36
static void dump_bl_cmd(struct _freenect_context *ctx, struct anonymous_31 cmd);
// dump_bl_cmd_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 36
static void dump_bl_cmd_link1(struct _freenect_context *ctx_link1, struct anonymous_31 cmd_link1);
// dump_cemd_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 43
static void dump_cemd_cmd(struct _freenect_context *ctx, struct anonymous_30 cmd);
// dump_cemd_cmd_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 43
static void dump_cemd_cmd_link1(struct _freenect_context *ctx_link1, struct anonymous_30 cmd_link1);
// dump_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regtest.c line 44
void dump_depth(struct _IO_FILE *fp, void *data, unsigned int width, unsigned int height);
// dump_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regtest.c line 50
void dump_rgb(struct _IO_FILE *fp, void *data, unsigned int width, unsigned int height);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fn_log
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 262
void fn_log(struct _freenect_context *ctx, enum anonymous_21 level, const char *fmt, ...);
// fnusb_bulk
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 879
signed int fnusb_bulk(struct anonymous_10 *dev, unsigned char endpoint, unsigned char *data, signed int len, signed int *transferred);
// fnusb_claim_camera
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 255
signed int fnusb_claim_camera(struct _freenect_device *dev);
// fnusb_close_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 86
signed int fnusb_close_subdevices(struct _freenect_device *dev);
// fnusb_control
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 92
signed int fnusb_control(struct anonymous_10 *dev, unsigned char bmRequestType, unsigned char bRequest, unsigned short int wValue, unsigned short int wIndex, unsigned char *data, unsigned short int wLength);
// fnusb_find_connected_audio_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 69
struct libusb_device * fnusb_find_connected_audio_device(struct libusb_device *camera, struct libusb_device **deviceList, signed int cnt);
// fnusb_get_max_iso_packet_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 90
signed int fnusb_get_max_iso_packet_size(struct anonymous_10 *dev, unsigned char endpoint, signed int default_size);
// fnusb_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 80
signed int fnusb_init(struct anonymous_20 *ctx, void *usb_ctx);
// fnusb_is_pid_k4w_audio
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 64
signed int fnusb_is_pid_k4w_audio(signed int pid);
// fnusb_list_device_attributes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 78
signed int fnusb_list_device_attributes(struct anonymous_20 *ctx, struct freenect_device_attributes **attribute_list);
// fnusb_num_devices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 77
signed int fnusb_num_devices(struct anonymous_20 *ctx);
// fnusb_num_interfaces
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 884
signed int fnusb_num_interfaces(struct anonymous_10 *dev);
// fnusb_open_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 85
signed int fnusb_open_subdevices(struct _freenect_device *dev, signed int index);
// fnusb_process_events
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 245
signed int fnusb_process_events(struct anonymous_20 *ctx);
// fnusb_process_events_timeout
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 83
signed int fnusb_process_events_timeout(struct anonymous_20 *ctx, struct timeval *timeout);
// fnusb_set_led_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 246
signed int fnusb_set_led_alt(struct libusb_device_handle *dev, struct _freenect_context *ctx, enum anonymous_23 state);
// fnusb_shutdown
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 81
signed int fnusb_shutdown(struct anonymous_20 *ctx);
// fnusb_start_iso
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 88
signed int fnusb_start_iso(struct anonymous_10 *dev, struct anonymous_11 *strm, void (*cb)(struct _freenect_device *, unsigned char *, signed int), unsigned char endpoint, signed int xfers, signed int pkts, signed int len);
// fnusb_start_iso::cb_link1_object
//
void cb_link1_object(struct _freenect_device *, unsigned char *, signed int);
// fnusb_start_iso::cb_object
//
void cb_object(struct _freenect_device *, unsigned char *, signed int);
// fnusb_stop_iso
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 89
signed int fnusb_stop_iso(struct anonymous_10 *dev, struct anonymous_11 *strm);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_buffer_ring
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 121
static void free_buffer_ring(struct buffer_ring *buf);
// freenect_apply_depth_to_mm
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.h line 34
signed int freenect_apply_depth_to_mm(struct _freenect_device *dev, unsigned char *input_packed, unsigned short int *output_mm);
// freenect_apply_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.h line 33
signed int freenect_apply_registration(struct _freenect_device *dev, unsigned char *input_packed, unsigned short int *output_mm);
// freenect_camera_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.h line 35
signed int freenect_camera_init(struct _freenect_device *dev);
// freenect_camera_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.h line 36
signed int freenect_camera_teardown(struct _freenect_device *dev);
// freenect_camera_to_world
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_registration.h line 120
void freenect_camera_to_world(struct _freenect_device *dev, signed int cx, signed int cy, signed int wz, double *wx, double *wy);
// freenect_close_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 365
signed int freenect_close_device(struct _freenect_device *dev);
// freenect_copy_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 420
struct anonymous_15 freenect_copy_registration(struct _freenect_device *dev);
// freenect_create_dxdy_tables
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 194
static void freenect_create_dxdy_tables(double *reg_x_table, double *reg_y_table, signed int resolution_x, signed int resolution_y, struct anonymous_25 *regdata);
// freenect_create_dxdy_tables_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 194
static void freenect_create_dxdy_tables_link1(double *reg_x_table_link1, double *reg_y_table_link1, signed int resolution_x_link1, signed int resolution_y_link1, struct anonymous_25 *regdata_link1);
// freenect_destroy_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_registration.h line 116
signed int freenect_destroy_registration(struct anonymous_15 *reg);
// freenect_enabled_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 138
enum anonymous_22 freenect_enabled_subdevices(struct _freenect_context *ctx);
// freenect_fetch_reg_const_shift
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 769
static signed int freenect_fetch_reg_const_shift(struct _freenect_device *dev);
// freenect_fetch_reg_const_shift_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 769
static signed int freenect_fetch_reg_const_shift_link1(struct _freenect_device *dev_link1);
// freenect_fetch_reg_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 664
static signed int freenect_fetch_reg_info(struct _freenect_device *dev);
// freenect_fetch_reg_info_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 664
static signed int freenect_fetch_reg_info_link1(struct _freenect_device *dev_link1);
// freenect_fetch_reg_pad_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 742
static signed int freenect_fetch_reg_pad_info(struct _freenect_device *dev);
// freenect_fetch_reg_pad_info_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 742
static signed int freenect_fetch_reg_pad_info_link1(struct _freenect_device *dev_link1);
// freenect_fetch_zero_plane_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 794
static signed int freenect_fetch_zero_plane_info(struct _freenect_device *dev);
// freenect_fetch_zero_plane_info_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 794
static signed int freenect_fetch_zero_plane_info_link1(struct _freenect_device *dev_link1);
// freenect_find_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 650
struct anonymous_6 freenect_find_depth_mode(enum anonymous_13 res, enum anonymous_5 fmt);
// freenect_find_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 598
struct anonymous_6 freenect_find_video_mode(enum anonymous_13 res, enum anonymous_4 fmt);
// freenect_free_device_attributes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 112
void freenect_free_device_attributes(struct freenect_device_attributes *attribute_list);
// freenect_get_current_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1197
struct anonymous_6 freenect_get_current_depth_mode(struct _freenect_device *dev);
// freenect_get_current_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1134
struct anonymous_6 freenect_get_current_video_mode(struct _freenect_device *dev);
// freenect_get_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1188
struct anonymous_6 freenect_get_depth_mode(signed int mode_num);
// freenect_get_depth_mode_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1183
signed int freenect_get_depth_mode_count();
// freenect_get_ir_brightness
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 96
signed int freenect_get_ir_brightness(struct _freenect_device *dev);
// freenect_get_mks_accel
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 331
void freenect_get_mks_accel(struct anonymous_18 *state, double *x, double *y, double *z);
// freenect_get_tilt_degs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 321
double freenect_get_tilt_degs(struct anonymous_18 *state);
// freenect_get_tilt_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 503
struct anonymous_18 * freenect_get_tilt_state(struct _freenect_device *dev);
// freenect_get_tilt_status
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 326
enum anonymous_32 freenect_get_tilt_status(struct anonymous_18 *state);
// freenect_get_user
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 383
void * freenect_get_user(struct _freenect_device *dev);
// freenect_get_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1125
struct anonymous_6 freenect_get_video_mode(signed int mode_num);
// freenect_get_video_mode_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1120
signed int freenect_get_video_mode_count();
// freenect_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 221
signed int freenect_init(struct _freenect_context **ctx, void *usb_ctx);
// freenect_init_depth_to_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 60
static void freenect_init_depth_to_rgb(signed int *depth_to_rgb, struct anonymous_12 *zpi);
// freenect_init_depth_to_rgb_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 60
static void freenect_init_depth_to_rgb_link1(signed int *depth_to_rgb_link1, struct anonymous_12 *zpi_link1);
// freenect_init_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.h line 32
signed int freenect_init_registration(struct _freenect_device *dev);
// freenect_init_registration_table
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 264
static void freenect_init_registration_table(signed int (*registration_table)[2l], struct anonymous_25 *reg_info);
// freenect_init_registration_table_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 264
static void freenect_init_registration_table_link1(signed int (*registration_table_link1)[2l], struct anonymous_25 *reg_info_link1);
// freenect_list_device_attributes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 107
signed int freenect_list_device_attributes(struct _freenect_context *ctx, struct freenect_device_attributes **attribute_list);
// freenect_map_rgb_to_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 333
void freenect_map_rgb_to_depth(struct _freenect_device *dev, unsigned short int *depth_mm, unsigned char *rgb_raw, unsigned char *rgb_registered);
// freenect_num_devices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 102
signed int freenect_num_devices(struct _freenect_context *ctx);
// freenect_open_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 343
signed int freenect_open_device(struct _freenect_context *ctx, struct _freenect_device **dev, signed int index);
// freenect_open_device_by_camera_serial
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 181
signed int freenect_open_device_by_camera_serial(struct _freenect_context *ctx, struct _freenect_device **dev, const char *camera_serial);
// freenect_process_events
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 259
signed int freenect_process_events(struct _freenect_context *ctx);
// freenect_process_events_timeout
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 80
signed int freenect_process_events_timeout(struct _freenect_context *ctx, struct timeval *timeout);
// freenect_raw_to_mm
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 297
static unsigned short int freenect_raw_to_mm(unsigned short int raw, struct anonymous_15 *reg);
// freenect_raw_to_mm_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 297
static unsigned short int freenect_raw_to_mm_link1(unsigned short int raw_link1, struct anonymous_15 *reg_link1);
// freenect_select_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 321
void freenect_select_subdevices(struct _freenect_context *ctx, enum anonymous_22 subdevs);
// freenect_set_audio_in_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 142
void freenect_set_audio_in_callback(struct _freenect_device *dev, void (*callback)(struct _freenect_device *, signed int, signed int *, signed int *, signed int *, signed int *, signed short int *, void *));
// freenect_set_audio_in_callback::callback_link1_object
//
void callback_link1_object(struct _freenect_device *, signed int, signed int *, signed int *, signed int *, signed int *, signed short int *, void *);
// freenect_set_audio_in_callback::callback_object
//
void callback_object(struct _freenect_device *, signed int, signed int *, signed int *, signed int *, signed int *, signed short int *, void *);
// freenect_set_audio_out_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 145
void freenect_set_audio_out_callback(struct _freenect_device *dev, void (*callback)(struct _freenect_device *, struct anonymous_16 *, signed int *));
// freenect_set_audio_out_callback::callback_link1_object
//
void callback_link1_object(struct _freenect_device *, struct anonymous_16 *, signed int *);
// freenect_set_audio_out_callback::callback_object
//
void callback_object(struct _freenect_device *, struct anonymous_16 *, signed int *);
// freenect_set_depth_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 435
signed int freenect_set_depth_buffer(struct _freenect_device *dev, void *buf);
// freenect_set_depth_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 399
void freenect_set_depth_callback(struct _freenect_device *dev, void (*cb)(struct _freenect_device *, void *, unsigned int));
// freenect_set_depth_callback::cb_link1_object
//
void cb_link1_object(struct _freenect_device *, void *, unsigned int);
// freenect_set_depth_callback::cb_object
//
void cb_object(struct _freenect_device *, void *, unsigned int);
// freenect_set_depth_chunk_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1110
void freenect_set_depth_chunk_callback(struct _freenect_device *dev, void (*cb)(void *, void *, signed int, signed int, void *));
// freenect_set_depth_chunk_callback::cb_link1_object
//
void cb_link1_object(void *, void *, signed int, signed int, void *);
// freenect_set_depth_chunk_callback::cb_object
//
void cb_object(void *, void *, signed int, signed int, void *);
// freenect_set_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 661
signed int freenect_set_depth_mode(struct _freenect_device *dev, const struct anonymous_6 mode);
// freenect_set_flag
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 46
signed int freenect_set_flag(struct _freenect_device *dev, enum anonymous_8 flag, enum anonymous_9 value);
// freenect_set_fw_address_k4w
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 292
void freenect_set_fw_address_k4w(struct _freenect_context *ctx, unsigned char *fw_ptr, unsigned int num_bytes);
// freenect_set_fw_address_nui
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 286
void freenect_set_fw_address_nui(struct _freenect_context *ctx, unsigned char *fw_ptr, unsigned int num_bytes);
// freenect_set_ir_brightness
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 110
signed int freenect_set_ir_brightness(struct _freenect_device *dev, unsigned short int brightness);
// freenect_set_led
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 547
signed int freenect_set_led(struct _freenect_device *dev, enum anonymous_23 option);
// freenect_set_led_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 290
signed int freenect_set_led_alt(struct _freenect_device *dev, enum anonymous_23 state);
// freenect_set_log_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 257
void freenect_set_log_callback(struct _freenect_context *ctx, void (*cb)(struct _freenect_context *, enum anonymous_21, const char *));
// freenect_set_log_callback::cb_link1_object
//
void cb_link1_object(struct _freenect_context *, enum anonymous_21, const char *);
// freenect_set_log_callback::cb_object
//
void cb_object(struct _freenect_context *, enum anonymous_21, const char *);
// freenect_set_log_level
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 252
void freenect_set_log_level(struct _freenect_context *ctx, enum anonymous_21 level);
// freenect_set_tilt_degs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 526
signed int freenect_set_tilt_degs(struct _freenect_device *dev, double angle);
// freenect_set_tilt_degs_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 189
signed int freenect_set_tilt_degs_alt(struct _freenect_device *dev, signed int tilt_degrees);
// freenect_set_user
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 374
void freenect_set_user(struct _freenect_device *dev, void *user);
// freenect_set_video_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 447
signed int freenect_set_video_buffer(struct _freenect_device *dev, void *buf);
// freenect_set_video_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 407
void freenect_set_video_callback(struct _freenect_device *dev, void (*cb)(struct _freenect_device *, void *, unsigned int));
// freenect_set_video_callback::cb_link1_object
//
void cb_link1_object(struct _freenect_device *, void *, unsigned int);
// freenect_set_video_callback::cb_object
//
void cb_object(struct _freenect_device *, void *, unsigned int);
// freenect_set_video_chunk_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1115
void freenect_set_video_chunk_callback(struct _freenect_device *dev, void (*cb)(void *, void *, signed int, signed int, void *));
// freenect_set_video_chunk_callback::cb_link1_object
//
void cb_link1_object(void *, void *, signed int, signed int, void *);
// freenect_set_video_chunk_callback::cb_object
//
void cb_object(void *, void *, signed int, signed int, void *);
// freenect_set_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 612
signed int freenect_set_video_mode(struct _freenect_device *dev, const struct anonymous_6 mode);
// freenect_shutdown
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 230
signed int freenect_shutdown(struct _freenect_context *ctx);
// freenect_start_audio
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 149
signed int freenect_start_audio(struct _freenect_device *dev);
// freenect_start_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 456
signed int freenect_start_depth(struct _freenect_device *dev);
// freenect_start_video
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 465
signed int freenect_start_video(struct _freenect_device *dev);
// freenect_stop_audio
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_audio.h line 110
signed int freenect_stop_audio(struct _freenect_device *dev);
// freenect_stop_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 474
signed int freenect_stop_depth(struct _freenect_device *dev);
// freenect_stop_video
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 483
signed int freenect_stop_video(struct _freenect_device *dev);
// freenect_supported_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 128
signed int freenect_supported_subdevices(void);
// freenect_sync_camera_to_world
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 426
signed int freenect_sync_camera_to_world(signed int cx, signed int cy, signed int wz, double *wx, double *wy, signed int index);
// freenect_sync_get_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/../wrappers/c_sync/libfreenect_sync.h line 92
signed int freenect_sync_get_depth(void **depth, unsigned int *timestamp, signed int index, enum anonymous_5 fmt);
// freenect_sync_get_depth_with_res
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 383
signed int freenect_sync_get_depth_with_res(void **depth, unsigned int *timestamp, signed int index, enum anonymous_13 res, enum anonymous_5 fmt);
// freenect_sync_get_tilt_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 403
signed int freenect_sync_get_tilt_state(struct anonymous_18 **state, signed int index);
// freenect_sync_get_video
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/../wrappers/c_sync/libfreenect_sync.h line 68
signed int freenect_sync_get_video(void **video, unsigned int *timestamp, signed int index, enum anonymous_4 fmt);
// freenect_sync_get_video_with_res
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 364
signed int freenect_sync_get_video_with_res(void **video, unsigned int *timestamp, signed int index, enum anonymous_13 res, enum anonymous_4 fmt);
// freenect_sync_set_led
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 419
signed int freenect_sync_set_led(enum anonymous_23 led, signed int index);
// freenect_sync_set_tilt_degs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 412
signed int freenect_sync_set_tilt_degs(signed int angle, signed int index);
// freenect_sync_stop
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 433
void freenect_sync_stop(void);
// freenect_update_tilt_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 494
signed int freenect_update_tilt_state(struct _freenect_device *dev);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_reply
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 60
signed int get_reply(struct libusb_device_handle *dev, struct _freenect_context *ctx);
// get_reply_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 50
static signed int get_reply_link1(struct anonymous_10 *dev_link1);
// get_reply_link1_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 50
static signed int get_reply_link1_link1(struct anonymous_10 *dev_link1_link1);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 185
static void * init(void *unused);
// init_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 214
static void init_thread(void);
// iso_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 703
static void iso_callback(struct libusb_transfer *xfer);
// iso_callback_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 703
static void iso_callback_link1(struct libusb_transfer *xfer_link1);
// iso_in_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 85
static void iso_in_callback(struct _freenect_device *dev, unsigned char *pkt, signed int len);
// iso_in_callback_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 85
static void iso_in_callback_link1(struct _freenect_device *dev_link1, unsigned char *pkt_link1, signed int len_link1);
// iso_out_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 81
static void iso_out_callback(struct _freenect_device *dev, unsigned char *pkt, signed int len);
// iso_out_callback_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 81
static void iso_out_callback_link1(struct _freenect_device *dev_link1, unsigned char *pkt_link1, signed int len_link1);
// libusb_alloc_transfer
// file /usr/include/libusb-1.0/libusb.h line 1477
struct libusb_transfer * libusb_alloc_transfer(signed int);
// libusb_attach_kernel_driver
// file /usr/include/libusb-1.0/libusb.h line 1399
signed int libusb_attach_kernel_driver(struct libusb_device_handle *, signed int);
// libusb_bulk_transfer
// file /usr/include/libusb-1.0/libusb.h line 1744
signed int libusb_bulk_transfer(struct libusb_device_handle *, unsigned char, unsigned char *, signed int, signed int *, unsigned int);
// libusb_cancel_transfer
// file /usr/include/libusb-1.0/libusb.h line 1479
signed int libusb_cancel_transfer(struct libusb_transfer *);
// libusb_claim_interface
// file /usr/include/libusb-1.0/libusb.h line 1376
signed int libusb_claim_interface(struct libusb_device_handle *, signed int);
// libusb_close
// file /usr/include/libusb-1.0/libusb.h line 1371
void libusb_close(struct libusb_device_handle *);
// libusb_control_transfer
// file /usr/include/libusb-1.0/libusb.h line 1740
signed int libusb_control_transfer(struct libusb_device_handle *, unsigned char, unsigned char, unsigned short int, unsigned short int, unsigned char *, unsigned short int, unsigned int);
// libusb_detach_kernel_driver
// file /usr/include/libusb-1.0/libusb.h line 1397
signed int libusb_detach_kernel_driver(struct libusb_device_handle *, signed int);
// libusb_error_name
// file /usr/include/libusb-1.0/libusb.h line 1308
const char * libusb_error_name(signed int);
// libusb_exit
// file /usr/include/libusb-1.0/libusb.h line 1304
void libusb_exit(struct libusb_context *);
// libusb_fill_iso_transfer
// file /usr/include/libusb-1.0/libusb.h line 1630
static inline void libusb_fill_iso_transfer(struct libusb_transfer *transfer, struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *buffer, signed int length, signed int num_iso_packets, void (*callback)(struct libusb_transfer *), void *user_data, unsigned int timeout);
// libusb_fill_iso_transfer_link1
// file /usr/include/libusb-1.0/libusb.h line 1630
static inline void libusb_fill_iso_transfer_link1(struct libusb_transfer *transfer_link1, struct libusb_device_handle *dev_handle_link1, unsigned char endpoint_link1, unsigned char *buffer_link1, signed int length_link1, signed int num_iso_packets_link1, void (*callback_link1)(struct libusb_transfer *), void *user_data_link1, unsigned int timeout_link1);
// libusb_fill_iso_transfer::callback_link1_object
//
void callback_link1_object(struct libusb_transfer *);
// libusb_fill_iso_transfer::callback_object
//
void callback_object(struct libusb_transfer *);
// libusb_free_config_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1329
void libusb_free_config_descriptor(struct libusb_config_descriptor *);
// libusb_free_device_list
// file /usr/include/libusb-1.0/libusb.h line 1314
void libusb_free_device_list(struct libusb_device **, signed int);
// libusb_free_transfer
// file /usr/include/libusb-1.0/libusb.h line 1480
void libusb_free_transfer(struct libusb_transfer *);
// libusb_get_active_config_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1323
signed int libusb_get_active_config_descriptor(struct libusb_device *, struct libusb_config_descriptor **);
// libusb_get_bus_number
// file /usr/include/libusb-1.0/libusb.h line 1357
unsigned char libusb_get_bus_number(struct libusb_device *);
// libusb_get_device
// file /usr/include/libusb-1.0/libusb.h line 1372
struct libusb_device * libusb_get_device(struct libusb_device_handle *);
// libusb_get_device_descriptor
// file /usr/include/libusb-1.0/libusb.h line 1321
signed int libusb_get_device_descriptor(struct libusb_device *, struct libusb_device_descriptor *);
// libusb_get_device_list
// file /usr/include/libusb-1.0/libusb.h line 1312
signed long int libusb_get_device_list(struct libusb_context *, struct libusb_device ***);
// libusb_get_max_iso_packet_size
// file /usr/include/libusb-1.0/libusb.h line 1367
signed int libusb_get_max_iso_packet_size(struct libusb_device *, unsigned char);
// libusb_get_parent
// file /usr/include/libusb-1.0/libusb.h line 1362
struct libusb_device * libusb_get_parent(struct libusb_device *);
// libusb_get_string_descriptor_ascii
// file /usr/include/libusb-1.0/libusb.h line 1794
signed int libusb_get_string_descriptor_ascii(struct libusb_device_handle *, unsigned char, unsigned char *, signed int);
// libusb_handle_events
// file /usr/include/libusb-1.0/libusb.h line 1812
signed int libusb_handle_events(struct libusb_context *);
// libusb_handle_events_timeout
// file /usr/include/libusb-1.0/libusb.h line 1808
signed int libusb_handle_events_timeout(struct libusb_context *, struct timeval *);
// libusb_init
// file /usr/include/libusb-1.0/libusb.h line 1303
signed int libusb_init(struct libusb_context **);
// libusb_kernel_driver_active
// file /usr/include/libusb-1.0/libusb.h line 1395
signed int libusb_kernel_driver_active(struct libusb_device_handle *, signed int);
// libusb_open
// file /usr/include/libusb-1.0/libusb.h line 1370
signed int libusb_open(struct libusb_device *, struct libusb_device_handle **);
// libusb_release_interface
// file /usr/include/libusb-1.0/libusb.h line 1378
signed int libusb_release_interface(struct libusb_device_handle *, signed int);
// libusb_reset_device
// file /usr/include/libusb-1.0/libusb.h line 1388
signed int libusb_reset_device(struct libusb_device_handle *);
// libusb_set_interface_alt_setting
// file /usr/include/libusb-1.0/libusb.h line 1384
signed int libusb_set_interface_alt_setting(struct libusb_device_handle *, signed int, signed int);
// libusb_set_iso_packet_lengths
// file /usr/include/libusb-1.0/libusb.h line 1654
static inline void libusb_set_iso_packet_lengths(struct libusb_transfer *transfer, unsigned int length);
// libusb_set_iso_packet_lengths_link1
// file /usr/include/libusb-1.0/libusb.h line 1654
static inline void libusb_set_iso_packet_lengths_link1(struct libusb_transfer *transfer_link1, unsigned int length_link1);
// libusb_submit_transfer
// file /usr/include/libusb-1.0/libusb.h line 1478
signed int libusb_submit_transfer(struct libusb_transfer *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// no_kinect_quit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regtest.c line 56
void no_kinect_quit(void);
// open_dump
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regtest.c line 33
struct _IO_FILE * open_dump(const char *filename);
// pending_runloop_tasks_dec
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 167
static void pending_runloop_tasks_dec(void);
// pending_runloop_tasks_inc
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 159
static void pending_runloop_tasks_inc(void);
// pending_runloop_tasks_wait_zero
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 177
static void pending_runloop_tasks_wait_zero(void);
// prepare_iso_out_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 34
static void prepare_iso_out_data(struct _freenect_device *dev, unsigned char *buffer);
// prepare_iso_out_data_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 34
static void prepare_iso_out_data_link1(struct _freenect_device *dev_link1, unsigned char *buffer_link1);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// producer_cb_inner
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 134
static void producer_cb_inner(struct _freenect_device *dev, void *data, unsigned int timestamp, struct buffer_ring *buf, signed int (*set_buffer)(struct _freenect_device *, void *));
// producer_cb_inner::set_buffer_object
//
signed int set_buffer_object(struct _freenect_device *, void *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_2 *, const union anonymous_0 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_2 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_2 *, union anonymous *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous *, const union anonymous_0 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous *);
// read_cmos_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 252
unsigned short int read_cmos_register(struct _freenect_device *dev, unsigned short int reg);
// read_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 209
unsigned short int read_register(struct _freenect_device *dev, unsigned short int reg);
// register_for_flag
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 33
signed int register_for_flag(signed int flag);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// runloop_enter
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 343
static signed int runloop_enter(signed int index);
// runloop_exit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 358
static void runloop_exit();
// send_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.h line 32
signed int send_cmd(struct _freenect_device *dev, unsigned short int cmd, void *cmdbuf, unsigned int cmd_len, void *replybuf, signed int reply_len);
// setup_kinect
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 274
static signed int setup_kinect(signed int index, signed int res, signed int fmt, signed int is_depth);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// stream_freebufs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 260
static void stream_freebufs(struct _freenect_context *ctx, struct anonymous_14 *strm);
// stream_freebufs_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 260
static void stream_freebufs_link1(struct _freenect_context *ctx_link1, struct anonymous_14 *strm_link1);
// stream_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 231
static void stream_init(struct _freenect_context *ctx, struct anonymous_14 *strm, signed int rlen, signed int plen);
// stream_init_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 231
static void stream_init_link1(struct _freenect_context *ctx_link1, struct anonymous_14 *strm_link1, signed int rlen_link1, signed int plen_link1);
// stream_process
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 87
static signed int stream_process(struct _freenect_context *ctx, struct anonymous_14 *strm, unsigned char *pkt, signed int len, void (*cb)(void *, void *, signed int, signed int, void *), void *user_data);
// stream_process_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 87
static signed int stream_process_link1(struct _freenect_context *ctx_link1, struct anonymous_14 *strm_link1, unsigned char *pkt_link1, signed int len_link1, void (*cb_link1)(void *, void *, signed int, signed int, void *), void *user_data_link1);
// stream_process::cb_link1_object
//
void cb_link1_object(void *, void *, signed int, signed int, void *);
// stream_process::cb_object
//
void cb_object(void *, void *, signed int, signed int, void *);
// stream_setbuf
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 272
static signed int stream_setbuf(struct _freenect_context *ctx, struct anonymous_14 *strm, void *pbuf);
// stream_setbuf_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 272
static signed int stream_setbuf_link1(struct _freenect_context *ctx_link1, struct anonymous_14 *strm_link1, void *pbuf_link1);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// sync_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 318
static signed int sync_get(void **data, unsigned int *timestamp, struct buffer_ring *buf);
// unpack_8_pixels
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 77
static inline void unpack_8_pixels(unsigned char *raw, unsigned short int *frame);
// unpack_8_pixels_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 77
static inline void unpack_8_pixels_link1(unsigned char *raw_link1, unsigned short int *frame_link1);
// update_tilt_state_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 100
signed int update_tilt_state_alt(struct _freenect_device *dev);
// upload_cemd_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 341
signed int upload_cemd_data(struct anonymous_10 *dev);
// upload_firmware
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.h line 68
signed int upload_firmware(struct anonymous_10 *dev, char *filename);
// upload_firmware_from_memory
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.h line 69
signed int upload_firmware_from_memory(struct anonymous_10 *dev, unsigned char *fw_from_mem, unsigned int fw_size_in_btyes);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// video_process
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 617
static void video_process(struct _freenect_device *dev, unsigned char *pkt, signed int len);
// video_process_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 617
static void video_process_link1(struct _freenect_device *dev_link1, unsigned char *pkt_link1, signed int len_link1);
// video_producer_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 148
static void video_producer_cb(struct _freenect_device *dev, void *data, unsigned int timestamp);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// write_cmos_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 273
signed int write_cmos_register(struct _freenect_device *dev, unsigned short int reg, unsigned short int value);
// write_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.h line 36
signed int write_register(struct _freenect_device *dev, unsigned short int reg, unsigned short int data);

struct anonymous_11
{
  // parent
  struct anonymous_10 *parent;
  // xfers
  struct libusb_transfer **xfers;
  // buffer
  unsigned char *buffer;
  // cb
  void (*cb)(struct _freenect_device *, unsigned char *, signed int);
  // num_xfers
  signed int num_xfers;
  // pkts
  signed int pkts;
  // len
  signed int len;
  // dead
  signed int dead;
  // dead_xfers
  signed int dead_xfers;
};

struct anonymous_10
{
  // parent
  struct _freenect_device *parent;
  // dev
  struct libusb_device_handle *dev;
  // device_dead
  signed int device_dead;
  // VID
  signed int VID;
  // PID
  signed int PID;
};

struct anonymous_20
{
  // ctx
  struct libusb_context *ctx;
  // should_free_ctx
  signed int should_free_ctx;
};

struct anonymous_19
{
  // magic
  unsigned char magic[2l];
  // len
  unsigned short int len;
  // cmd
  unsigned short int cmd;
  // tag
  unsigned short int tag;
};

struct anonymous_12
{
  // dcmos_emitter_dist
  float dcmos_emitter_dist;
  // dcmos_rcmos_dist
  float dcmos_rcmos_dist;
  // reference_distance
  float reference_distance;
  // reference_pixel_size
  float reference_pixel_size;
};

struct anonymous_18
{
  // accelerometer_x
  signed short int accelerometer_x;
  // accelerometer_y
  signed short int accelerometer_y;
  // accelerometer_z
  signed short int accelerometer_z;
  // tilt_angle
  signed char tilt_angle;
  // tilt_status
  enum anonymous_32 tilt_status;
};

struct anonymous_16
{
  // left
  signed short int left;
  // right
  signed short int right;
  // center
  signed short int center;
  // lfe
  signed short int lfe;
  // surround_left
  signed short int surround_left;
  // surround_right
  signed short int surround_right;
};

struct anonymous_1
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_25
{
  // dx_center
  signed int dx_center;
  // ax
  signed int ax;
  // bx
  signed int bx;
  // cx
  signed int cx;
  // dx
  signed int dx;
  // dx_start
  signed int dx_start;
  // ay
  signed int ay;
  // by
  signed int by;
  // cy
  signed int cy;
  // dy
  signed int dy;
  // dy_start
  signed int dy_start;
  // dx_beta_start
  signed int dx_beta_start;
  // dy_beta_start
  signed int dy_beta_start;
  // rollout_blank
  signed int rollout_blank;
  // rollout_size
  signed int rollout_size;
  // dx_beta_inc
  signed int dx_beta_inc;
  // dy_beta_inc
  signed int dy_beta_inc;
  // dxdx_start
  signed int dxdx_start;
  // dxdy_start
  signed int dxdy_start;
  // dydx_start
  signed int dydx_start;
  // dydy_start
  signed int dydy_start;
  // dxdxdx_start
  signed int dxdxdx_start;
  // dydxdx_start
  signed int dydxdx_start;
  // dxdxdy_start
  signed int dxdxdy_start;
  // dydxdy_start
  signed int dydxdy_start;
  // back_comp1
  signed int back_comp1;
  // dydydx_start
  signed int dydydx_start;
  // back_comp2
  signed int back_comp2;
  // dydydy_start
  signed int dydydy_start;
};

struct anonymous_17
{
  // running
  signed int running;
  // audio_out_ring
  struct anonymous_16 *audio_out_ring;
  // ring_reader_idx
  signed int ring_reader_idx;
  // ring_writer_idx
  signed int ring_writer_idx;
  // out_window
  unsigned short int out_window;
  // out_seq
  unsigned char out_seq;
  // out_counter_within_window
  unsigned char out_counter_within_window;
  // out_weird_timestamp
  unsigned short int out_weird_timestamp;
  // out_window_parity
  unsigned char out_window_parity;
  // in_window
  unsigned short int in_window;
  // last_seen_window
  unsigned short int last_seen_window[10l];
  // in_counter
  unsigned char in_counter;
  // mic_buffer
  signed int *mic_buffer[4l];
  // cancelled_buffer
  signed short int *cancelled_buffer;
  // in_unknown
  void *in_unknown;
};

struct anonymous_14
{
  // running
  signed int running;
  // flag
  unsigned char flag;
  // synced
  signed int synced;
  // seq
  unsigned char seq;
  // got_pkts
  signed int got_pkts;
  // pkt_num
  signed int pkt_num;
  // pkts_per_frame
  signed int pkts_per_frame;
  // pkt_size
  signed int pkt_size;
  // frame_size
  signed int frame_size;
  // last_pkt_size
  signed int last_pkt_size;
  // valid_pkts
  signed int valid_pkts;
  // lost_pkts
  unsigned int lost_pkts;
  // valid_frames
  signed int valid_frames;
  // variable_length
  signed int variable_length;
  // last_timestamp
  unsigned int last_timestamp;
  // timestamp
  unsigned int timestamp;
  // split_bufs
  signed int split_bufs;
  // lib_buf
  void *lib_buf;
  // usr_buf
  void *usr_buf;
  // raw_buf
  unsigned char *raw_buf;
  // proc_buf
  void *proc_buf;
};

struct anonymous_24
{
  // start_lines
  unsigned short int start_lines;
  // end_lines
  unsigned short int end_lines;
  // cropping_lines
  unsigned short int cropping_lines;
};

struct anonymous_15
{
  // reg_info
  struct anonymous_25 reg_info;
  // reg_pad_info
  struct anonymous_24 reg_pad_info;
  // zero_plane_info
  struct anonymous_12 zero_plane_info;
  // const_shift
  double const_shift;
  // raw_to_mm_shift
  unsigned short int *raw_to_mm_shift;
  // depth_to_rgb_shift
  signed int *depth_to_rgb_shift;
  // registration_table
  signed int (*registration_table)[2l];
};

struct anonymous_29
{
  // magic
  unsigned int magic;
  // channel
  unsigned short int channel;
  // len
  unsigned short int len;
  // window
  unsigned short int window;
  // unknown
  unsigned short int unknown;
  // samples
  signed int samples[0l];
};

struct anonymous_33
{
  // magic
  unsigned int magic;
  // ver_minor
  unsigned short int ver_minor;
  // ver_major
  unsigned short int ver_major;
  // ver_release
  unsigned short int ver_release;
  // ver_patch
  unsigned short int ver_patch;
  // base_addr
  unsigned int base_addr;
  // size
  unsigned int size;
  // entry_addr
  unsigned int entry_addr;
};

struct anonymous_26
{
  // magic
  unsigned int magic;
  // tag
  unsigned int tag;
  // arg1
  unsigned int arg1;
  // cmd
  unsigned int cmd;
  // arg2
  unsigned int arg2;
};

struct anonymous_30
{
  // magic
  unsigned int magic;
  // tag
  unsigned int tag;
  // arg1
  unsigned int arg1;
  // cmd
  unsigned int cmd;
  // arg2
  unsigned int arg2;
  // zeros
  unsigned int zeros[8l];
};

struct anonymous_31
{
  // magic
  unsigned int magic;
  // tag
  unsigned int tag;
  // bytes
  unsigned int bytes;
  // cmd
  unsigned int cmd;
  // addr
  unsigned int addr;
  // unk
  unsigned int unk;
};

struct anonymous_3
{
  // magic
  unsigned int magic;
  // tag
  unsigned int tag;
  // status
  unsigned int status;
};

union anonymous_27
{
  // dummy
  signed int dummy;
  // video_format
  enum anonymous_4 video_format;
  // depth_format
  enum anonymous_5 depth_format;
};

struct anonymous_6
{
  // reserved
  unsigned int reserved;
  // resolution
  enum anonymous_13 resolution;
  // _anon0
  union anonymous_27 _anon0;
  // bytes
  signed int bytes;
  // width
  signed short int width;
  // height
  signed short int height;
  // data_bits_per_pixel
  signed char data_bits_per_pixel;
  // padding_bits_per_pixel
  signed char padding_bits_per_pixel;
  // framerate
  signed char framerate;
  // is_valid
  signed char is_valid;
};

union anonymous_0
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_2
{
  // __data
  struct anonymous_1 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _freenect_context
{
  // log_level
  enum anonymous_21 log_level;
  // log_cb
  void (*log_cb)(struct _freenect_context *, enum anonymous_21, const char *);
  // usb
  struct anonymous_20 usb;
  // enabled_subdevices
  enum anonymous_22 enabled_subdevices;
  // first
  struct _freenect_device *first;
  // zero_plane_res
  signed int zero_plane_res;
  // fn_fw_nui_ptr
  unsigned char *fn_fw_nui_ptr;
  // fn_fw_nui_size
  unsigned int fn_fw_nui_size;
  // fn_fw_k4w_ptr
  unsigned char *fn_fw_k4w_ptr;
  // fn_fw_k4w_size
  unsigned int fn_fw_k4w_size;
};

struct _freenect_device
{
  // parent
  struct _freenect_context *parent;
  // next
  struct _freenect_device *next;
  // user_data
  void *user_data;
  // usb_cam
  struct anonymous_10 usb_cam;
  // depth_isoc
  struct anonymous_11 depth_isoc;
  // video_isoc
  struct anonymous_11 video_isoc;
  // depth_cb
  void (*depth_cb)(struct _freenect_device *, void *, unsigned int);
  // video_cb
  void (*video_cb)(struct _freenect_device *, void *, unsigned int);
  // depth_chunk_cb
  void (*depth_chunk_cb)(void *, void *, signed int, signed int, void *);
  // video_chunk_cb
  void (*video_chunk_cb)(void *, void *, signed int, signed int, void *);
  // video_format
  enum anonymous_4 video_format;
  // depth_format
  enum anonymous_5 depth_format;
  // video_resolution
  enum anonymous_13 video_resolution;
  // depth_resolution
  enum anonymous_13 depth_resolution;
  // cam_inited
  signed int cam_inited;
  // cam_tag
  unsigned short int cam_tag;
  // depth
  struct anonymous_14 depth;
  // video
  struct anonymous_14 video;
  // registration
  struct anonymous_15 registration;
  // usb_audio
  struct anonymous_10 usb_audio;
  // audio_out_isoc
  struct anonymous_11 audio_out_isoc;
  // audio_in_isoc
  struct anonymous_11 audio_in_isoc;
  // audio_in_cb
  void (*audio_in_cb)(struct _freenect_device *, signed int, signed int *, signed int *, signed int *, signed int *, signed short int *, void *);
  // audio_out_cb
  void (*audio_out_cb)(struct _freenect_device *, struct anonymous_16 *, signed int *);
  // audio
  struct anonymous_17 audio;
  // audio_tag
  unsigned int audio_tag;
  // usb_motor
  struct anonymous_10 usb_motor;
  // raw_state
  struct anonymous_18 raw_state;
  // device_does_motor_control_with_audio
  signed int device_does_motor_control_with_audio;
  // motor_control_with_audio_enabled
  signed int motor_control_with_audio_enabled;
};

struct buffer_ring
{
  // lock
  union anonymous lock;
  // cb_cond
  union anonymous_2 cb_cond;
  // bufs
  void *bufs[3l];
  // timestamp
  unsigned int timestamp;
  // valid
  signed int valid;
  // fmt
  signed int fmt;
  // res
  signed int res;
};

struct freenect_device_attributes
{
  // next
  struct freenect_device_attributes *next;
  // camera_serial
  const char *camera_serial;
};

struct libusb_config_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // wTotalLength
  unsigned short int wTotalLength;
  // bNumInterfaces
  unsigned char bNumInterfaces;
  // bConfigurationValue
  unsigned char bConfigurationValue;
  // iConfiguration
  unsigned char iConfiguration;
  // bmAttributes
  unsigned char bmAttributes;
  // MaxPower
  unsigned char MaxPower;
  // interface
  struct libusb_interface *interface;
  // extra
  const unsigned char *extra;
  // extra_length
  signed int extra_length;
};

struct libusb_device_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bcdUSB
  unsigned short int bcdUSB;
  // bDeviceClass
  unsigned char bDeviceClass;
  // bDeviceSubClass
  unsigned char bDeviceSubClass;
  // bDeviceProtocol
  unsigned char bDeviceProtocol;
  // bMaxPacketSize0
  unsigned char bMaxPacketSize0;
  // idVendor
  unsigned short int idVendor;
  // idProduct
  unsigned short int idProduct;
  // bcdDevice
  unsigned short int bcdDevice;
  // iManufacturer
  unsigned char iManufacturer;
  // iProduct
  unsigned char iProduct;
  // iSerialNumber
  unsigned char iSerialNumber;
  // bNumConfigurations
  unsigned char bNumConfigurations;
};

struct libusb_endpoint_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bEndpointAddress
  unsigned char bEndpointAddress;
  // bmAttributes
  unsigned char bmAttributes;
  // wMaxPacketSize
  unsigned short int wMaxPacketSize;
  // bInterval
  unsigned char bInterval;
  // bRefresh
  unsigned char bRefresh;
  // bSynchAddress
  unsigned char bSynchAddress;
  // extra
  const unsigned char *extra;
  // extra_length
  signed int extra_length;
};

struct libusb_interface
{
  // altsetting
  struct libusb_interface_descriptor *altsetting;
  // num_altsetting
  signed int num_altsetting;
};

struct libusb_interface_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bInterfaceNumber
  unsigned char bInterfaceNumber;
  // bAlternateSetting
  unsigned char bAlternateSetting;
  // bNumEndpoints
  unsigned char bNumEndpoints;
  // bInterfaceClass
  unsigned char bInterfaceClass;
  // bInterfaceSubClass
  unsigned char bInterfaceSubClass;
  // bInterfaceProtocol
  unsigned char bInterfaceProtocol;
  // iInterface
  unsigned char iInterface;
  // endpoint
  struct libusb_endpoint_descriptor *endpoint;
  // extra
  const unsigned char *extra;
  // extra_length
  signed int extra_length;
};

struct libusb_iso_packet_descriptor
{
  // length
  unsigned int length;
  // actual_length
  unsigned int actual_length;
  // status
  enum libusb_transfer_status status;
};

struct libusb_transfer
{
  // dev_handle
  struct libusb_device_handle *dev_handle;
  // flags
  unsigned char flags;
  // endpoint
  unsigned char endpoint;
  // type
  unsigned char type;
  // timeout
  unsigned int timeout;
  // status
  enum libusb_transfer_status status;
  // length
  signed int length;
  // actual_length
  signed int actual_length;
  // callback
  void (*callback)(struct libusb_transfer *);
  // user_data
  void *user_data;
  // buffer
  unsigned char *buffer;
  // num_iso_packets
  signed int num_iso_packets;
  // iso_packet_desc
  struct libusb_iso_packet_descriptor iso_packet_desc[0l];
};

struct pkt_hdr
{
  // magic
  unsigned char magic[2l];
  // pad
  unsigned char pad;
  // flag
  unsigned char flag;
  // unk1
  unsigned char unk1;
  // seq
  unsigned char seq;
  // unk2
  unsigned char unk2;
  // unk3
  unsigned char unk3;
  // timestamp
  unsigned int timestamp;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sync_kinect
{
  // dev
  struct _freenect_device *dev;
  // video
  struct buffer_ring video;
  // depth
  struct buffer_ring depth;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};


// ctx
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 54
static struct _freenect_context *ctx;
// kinects
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 53
static struct sync_kinect *kinects[64l] = { ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL), ((struct sync_kinect *)NULL) };
// parameter_coefficient
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 292
static double parameter_coefficient = (double)4;
// parameter_coefficient_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 292
static double parameter_coefficient_link1 = (double)4;
// pending_runloop_tasks
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 58
static signed int pending_runloop_tasks = 0;
// pending_runloop_tasks_cond
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 60
static union anonymous_2 pending_runloop_tasks_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// pending_runloop_tasks_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 59
static union anonymous pending_runloop_tasks_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// pixel_size_factor
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 294
static double pixel_size_factor = (double)1;
// pixel_size_factor_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 294
static double pixel_size_factor_link1 = (double)1;
// runloop_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 57
static union anonymous runloop_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// shift_scale
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 293
static double shift_scale = (double)10;
// shift_scale_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 293
static double shift_scale_link1 = (double)10;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// supported_depth_modes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 65
static struct anonymous_6 supported_depth_modes[6l] = { { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_11BIT & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_11BIT },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)11, .padding_bits_per_pixel=(signed char)5,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_10BIT & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_10BIT },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)6,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_11BIT_PACKED & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_11BIT_PACKED },
    .bytes=(640 * 480 * 11) / 8,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)11, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_10BIT_PACKED & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_10BIT_PACKED },
    .bytes=(640 * 480 * 10) / 8,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_REGISTERED & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_REGISTERED },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)16, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_MM & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_MM },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)16, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 } };
// supported_depth_modes_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 65
static struct anonymous_6 supported_depth_modes_link1[6l] = { { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_11BIT & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_11BIT },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)11, .padding_bits_per_pixel=(signed char)5,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_10BIT & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_10BIT },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)6,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_11BIT_PACKED & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_11BIT_PACKED },
    .bytes=(640 * 480 * 11) / 8,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)11, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_10BIT_PACKED & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_10BIT_PACKED },
    .bytes=(640 * 480 * 10) / 8,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_REGISTERED & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_REGISTERED },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)16, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_DEPTH_MM & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_DEPTH_MM },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)16, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 } };
// supported_video_modes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 42
static struct anonymous_6 supported_video_modes[12l] = { { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_RGB & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_RGB },
    .bytes=1280 * 1024 * 3,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)24, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_RGB & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_RGB },
    .bytes=640 * 480 * 3,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)24, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_BAYER & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_BAYER },
    .bytes=1280 * 1024,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)8, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_BAYER & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_BAYER },
    .bytes=640 * 480,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)8, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_IR_8BIT & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_8BIT },
    .bytes=1280 * 1024,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)8, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_IR_8BIT & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_8BIT },
    .bytes=640 * 488,
    .width=(signed short int)640, .height=(signed short int)488,
    .data_bits_per_pixel=(signed char)8, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_IR_10BIT & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_10BIT },
    .bytes=1280 * 1024 * 2,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)6,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_IR_10BIT & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_10BIT },
    .bytes=640 * 488 * 2,
    .width=(signed short int)640, .height=(signed short int)488,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)6,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_IR_10BIT_PACKED & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_10BIT_PACKED },
    .bytes=(1280 * 1024 * 10) / 8,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_IR_10BIT_PACKED & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_10BIT_PACKED },
    .bytes=(640 * 488 * 10) / 8,
    .width=(signed short int)640, .height=(signed short int)488,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_YUV_RGB & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_YUV_RGB },
    .bytes=640 * 480 * 3,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)24, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)15,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_YUV_RAW & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_YUV_RAW },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)16, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)15,
    .is_valid=(signed char)1 } };
// supported_video_modes_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 42
static struct anonymous_6 supported_video_modes_link1[12l] = { { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_RGB & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_RGB },
    .bytes=1280 * 1024 * 3,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)24, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_RGB & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_RGB },
    .bytes=640 * 480 * 3,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)24, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_BAYER & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_BAYER },
    .bytes=1280 * 1024,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)8, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_BAYER & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_BAYER },
    .bytes=640 * 480,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)8, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_IR_8BIT & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_8BIT },
    .bytes=1280 * 1024,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)8, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_IR_8BIT & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_8BIT },
    .bytes=640 * 488,
    .width=(signed short int)640, .height=(signed short int)488,
    .data_bits_per_pixel=(signed char)8, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_IR_10BIT & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_10BIT },
    .bytes=1280 * 1024 * 2,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)6,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_IR_10BIT & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_10BIT },
    .bytes=640 * 488 * 2,
    .width=(signed short int)640, .height=(signed short int)488,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)6,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_HIGH & 0xff) << 8 | FREENECT_VIDEO_IR_10BIT_PACKED & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_HIGH,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_10BIT_PACKED },
    .bytes=(1280 * 1024 * 10) / 8,
    .width=(signed short int)1280, .height=(signed short int)1024,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)10,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_IR_10BIT_PACKED & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_IR_10BIT_PACKED },
    .bytes=(640 * 488 * 10) / 8,
    .width=(signed short int)640, .height=(signed short int)488,
    .data_bits_per_pixel=(signed char)10, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)30,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_YUV_RGB & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_YUV_RGB },
    .bytes=640 * 480 * 3,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)24, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)15,
    .is_valid=(signed char)1 },
    { .reserved=(unsigned int)((FREENECT_RESOLUTION_MEDIUM & 0xff) << 8 | FREENECT_VIDEO_YUV_RAW & 0xff), .resolution=(enum anonymous_13)FREENECT_RESOLUTION_MEDIUM,
    ._anon0={ .dummy=FREENECT_VIDEO_YUV_RAW },
    .bytes=640 * 480 * 2,
    .width=(signed short int)640, .height=(signed short int)480,
    .data_bits_per_pixel=(signed char)16, .padding_bits_per_pixel=(signed char)0,
    .framerate=(signed char)15,
    .is_valid=(signed char)1 } };
// tag_next_ack
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 58
static signed int tag_next_ack = 0;
// tag_next_ack_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 58
static signed int tag_next_ack_link1 = 0;
// tag_seq
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 57
static signed int tag_seq = 0;
// tag_seq_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 57
static signed int tag_seq_link1 = 0;
// thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 56
static unsigned long int thread;
// thread_running
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 55
static signed int thread_running = 0;

// alloc_buffer_ring_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 96
static signed int alloc_buffer_ring_depth(enum anonymous_13 res, enum anonymous_5 fmt, struct buffer_ring *buf)
{
  signed int sz;
  signed int i;
  struct anonymous_6 return_value_freenect_find_depth_mode_1;
  if((signed int)fmt == FREENECT_DEPTH_11BIT || (signed int)fmt == FREENECT_DEPTH_10BIT || (signed int)fmt == FREENECT_DEPTH_11BIT_PACKED || (signed int)fmt == FREENECT_DEPTH_10BIT_PACKED || (signed int)fmt == FREENECT_DEPTH_REGISTERED || (signed int)fmt == FREENECT_DEPTH_MM)
  {
    return_value_freenect_find_depth_mode_1=freenect_find_depth_mode(res, fmt);
    sz = return_value_freenect_find_depth_mode_1.bytes;
    goto __CPROVER_DUMP_L3;
  }

  printf("Invalid depth format %d\n", fmt);
  return -1;

__CPROVER_DUMP_L3:
  ;
  i = 0;
  for( ; !(i >= 3); i = i + 1)
    buf->bufs[(signed long int)i]=malloc((unsigned long int)sz);
  buf->timestamp = (unsigned int)0;
  buf->valid = 0;
  buf->fmt = (signed int)fmt;
  buf->res = (signed int)res;
  return 0;
}

// alloc_buffer_ring_video
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 72
static signed int alloc_buffer_ring_video(enum anonymous_13 res, enum anonymous_4 fmt, struct buffer_ring *buf)
{
  signed int sz;
  signed int i;
  struct anonymous_6 return_value_freenect_find_video_mode_1;
  if((signed int)fmt == FREENECT_VIDEO_RGB || (signed int)fmt == FREENECT_VIDEO_BAYER || (signed int)fmt == FREENECT_VIDEO_IR_8BIT || (signed int)fmt == FREENECT_VIDEO_IR_10BIT || (signed int)fmt == FREENECT_VIDEO_IR_10BIT_PACKED)
  {
    return_value_freenect_find_video_mode_1=freenect_find_video_mode(res, fmt);
    sz = return_value_freenect_find_video_mode_1.bytes;
    goto __CPROVER_DUMP_L3;
  }

  printf("Invalid video format %d\n", fmt);
  return -1;

__CPROVER_DUMP_L3:
  ;
  i = 0;
  for( ; !(i >= 3); i = i + 1)
    buf->bufs[(signed long int)i]=malloc((unsigned long int)sz);
  buf->timestamp = (unsigned int)0;
  buf->valid = 0;
  buf->fmt = (signed int)fmt;
  buf->res = (signed int)res;
  return 0;
}

// alloc_kinect
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 249
static struct sync_kinect * alloc_kinect(signed int index)
{
  struct sync_kinect *kinect;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct sync_kinect) /*264ul*/ );
  kinect = (struct sync_kinect *)return_value_malloc_1;
  signed int return_value_freenect_open_device_2;
  return_value_freenect_open_device_2=freenect_open_device(ctx, &kinect->dev, index);
  if(!(return_value_freenect_open_device_2 == 0))
  {
    free((void *)kinect);
    return (struct sync_kinect *)(void *)0;
  }

  else
  {
    signed int i = 0;
    for( ; !(i >= 3); i = i + 1)
    {
      kinect->video.bufs[(signed long int)i] = (void *)0;
      kinect->depth.bufs[(signed long int)i] = (void *)0;
    }
    kinect->video.fmt = -1;
    kinect->video.res = -1;
    kinect->depth.fmt = -1;
    kinect->depth.res = -1;
    freenect_set_video_callback(kinect->dev, video_producer_cb);
    freenect_set_depth_callback(kinect->dev, depth_producer_cb);
    pthread_mutex_init(&kinect->video.lock, (const union anonymous_0 *)(void *)0);
    pthread_mutex_init(&kinect->depth.lock, (const union anonymous_0 *)(void *)0);
    pthread_cond_init(&kinect->video.cb_cond, (const union anonymous_0 *)(void *)0);
    pthread_cond_init(&kinect->depth.cb_cond, (const union anonymous_0 *)(void *)0);
    return kinect;
  }
}

// change_depth_format
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 237
static signed int change_depth_format(struct sync_kinect *kinect, enum anonymous_13 res, enum anonymous_5 fmt)
{
  freenect_stop_depth(kinect->dev);
  free_buffer_ring(&kinect->depth);
  signed int return_value_alloc_buffer_ring_depth_1;
  return_value_alloc_buffer_ring_depth_1=alloc_buffer_ring_depth(res, fmt, &kinect->depth);
  if(!(return_value_alloc_buffer_ring_depth_1 == 0))
    return -1;

  else
  {
    struct anonymous_6 return_value_freenect_find_depth_mode_2;
    return_value_freenect_find_depth_mode_2=freenect_find_depth_mode(res, fmt);
    freenect_set_depth_mode(kinect->dev, return_value_freenect_find_depth_mode_2);
    freenect_set_depth_buffer(kinect->dev, kinect->depth.bufs[(signed long int)2]);
    freenect_start_depth(kinect->dev);
    return 0;
  }
}

// change_video_format
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 225
static signed int change_video_format(struct sync_kinect *kinect, enum anonymous_13 res, enum anonymous_4 fmt)
{
  freenect_stop_video(kinect->dev);
  free_buffer_ring(&kinect->video);
  signed int return_value_alloc_buffer_ring_video_1;
  return_value_alloc_buffer_ring_video_1=alloc_buffer_ring_video(res, fmt, &kinect->video);
  if(!(return_value_alloc_buffer_ring_video_1 == 0))
    return -1;

  else
  {
    struct anonymous_6 return_value_freenect_find_video_mode_2;
    return_value_freenect_find_video_mode_2=freenect_find_video_mode(res, fmt);
    freenect_set_video_mode(kinect->dev, return_value_freenect_find_video_mode_2);
    freenect_set_video_buffer(kinect->dev, kinect->video.bufs[(signed long int)2]);
    freenect_start_video(kinect->dev);
    return 0;
  }
}

// complete_tables
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 306
static void complete_tables(struct anonymous_15 *reg)
{
  unsigned short int i = (unsigned short int)0;
  for( ; !((signed int)i >= 2048); i = i + 1)
    reg->raw_to_mm_shift[(signed long int)i]=freenect_raw_to_mm(i, reg);
  reg->raw_to_mm_shift[(signed long int)2047] = (unsigned short int)0;
  freenect_init_depth_to_rgb(reg->depth_to_rgb_shift, &reg->zero_plane_info);
  freenect_init_registration_table(reg->registration_table, &reg->reg_info);
}

// complete_tables_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 306
static void complete_tables_link1(struct anonymous_15 *reg_link1)
{
  unsigned short int i_link1 = (unsigned short int)0;
  for( ; !((signed int)i_link1 >= 2048); i_link1 = i_link1 + 1)
    reg_link1->raw_to_mm_shift[(signed long int)i_link1]=freenect_raw_to_mm_link1(i_link1, reg_link1);
  reg_link1->raw_to_mm_shift[(signed long int)2047] = (unsigned short int)0;
  freenect_init_depth_to_rgb_link1(reg_link1->depth_to_rgb_shift, &reg_link1->zero_plane_info);
  freenect_init_registration_table_link1(reg_link1->registration_table, &reg_link1->reg_info);
}

// convert_bayer_to_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 453
static void convert_bayer_to_rgb(unsigned char *raw_buf, unsigned char *proc_buf, struct anonymous_6 frame_mode)
{
  signed int x;
  signed int y;
  unsigned char *dst = proc_buf;
  unsigned char *prevLine;
  unsigned char *curLine;
  unsigned char *nextLine;
  unsigned int hVals;
  unsigned int vSums;
  curLine = raw_buf;
  nextLine = curLine + (signed long int)frame_mode.width;
  y = 0;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  unsigned char *tmp_post_9;
  unsigned char *tmp_post_10;
  unsigned char *tmp_post_11;
  unsigned char *tmp_post_12;
  unsigned char *tmp_post_13;
  unsigned char *tmp_post_14;
  unsigned char *tmp_post_15;
  unsigned char *tmp_post_16;
  unsigned char *tmp_post_17;
  unsigned char *tmp_post_18;
  unsigned char *tmp_post_19;
  unsigned char *tmp_post_20;
  unsigned char *tmp_post_21;
  unsigned char *tmp_post_22;
  unsigned char *tmp_post_23;
  unsigned char *tmp_post_24;
  unsigned char *tmp_post_25;
  unsigned char *tmp_post_26;
  unsigned char *tmp_post_27;
  unsigned char *tmp_post_28;
  unsigned char *tmp_post_29;
  unsigned char *tmp_post_30;
  for( ; !(y >= (signed int)frame_mode.height); y = y + 1)
  {
    if(y >= 1 && !(y >= (signed int)frame_mode.height + -1))
      prevLine = curLine - (signed long int)frame_mode.width;

    else
      if(y == 0)
        prevLine = nextLine;

      else
        nextLine = prevLine;
    tmp_post_1 = curLine;
    curLine = curLine + 1l;
    hVals = (unsigned int)((signed int)*tmp_post_1 << 8);
    hVals = hVals | (unsigned int)((signed int)*curLine << 16);
    tmp_post_2 = prevLine;
    prevLine = prevLine + 1l;
    tmp_post_3 = nextLine;
    nextLine = nextLine + 1l;
    vSums = (unsigned int)((signed int)*tmp_post_2 + (signed int)*tmp_post_3 << 7 & 0xFF00);
    vSums = vSums | (unsigned int)((signed int)*prevLine + (signed int)*nextLine << 15 & 0xFF0000);
    unsigned char yOdd = (unsigned char)(y & 1);
    x = 0;
    for( ; !(x >= (signed int)frame_mode.width + -1); x = x + 1)
    {
      tmp_post_4 = curLine;
      curLine = curLine + 1l;
      hVals = hVals | (unsigned int)*tmp_post_4;
      tmp_post_5 = prevLine;
      prevLine = prevLine + 1l;
      tmp_post_6 = nextLine;
      nextLine = nextLine + 1l;
      vSums = vSums | (unsigned int)((signed int)*tmp_post_5 + (signed int)*tmp_post_6 >> 1);
      unsigned char convert_bayer_to_rgb__1__1__1__1__1__hSum = (unsigned char)((signed int)(unsigned char)(hVals >> 16) + (signed int)(unsigned char)hVals >> 1);
      if((signed int)yOdd == 0)
      {
        if((1 & x) == 0)
        {
          tmp_post_7 = dst;
          dst = dst + 1l;
          *tmp_post_7 = convert_bayer_to_rgb__1__1__1__1__1__hSum;
          tmp_post_8 = dst;
          dst = dst + 1l;
          *tmp_post_8 = (unsigned char)(hVals >> 8);
          tmp_post_9 = dst;
          dst = dst + 1l;
          *tmp_post_9 = (unsigned char)(vSums >> 8);
        }

        else
        {
          tmp_post_10 = dst;
          dst = dst + 1l;
          *tmp_post_10 = (unsigned char)(hVals >> 8);
          tmp_post_11 = dst;
          dst = dst + 1l;
          *tmp_post_11 = (unsigned char)((signed int)convert_bayer_to_rgb__1__1__1__1__1__hSum + (signed int)(unsigned char)(vSums >> 8) >> 1);
          tmp_post_12 = dst;
          dst = dst + 1l;
          *tmp_post_12 = (unsigned char)((signed int)(unsigned char)(vSums >> 16) + (signed int)(unsigned char)vSums >> 1);
        }
      }

      else
        if((1 & x) == 0)
        {
          tmp_post_13 = dst;
          dst = dst + 1l;
          *tmp_post_13 = (unsigned char)((signed int)(unsigned char)(vSums >> 16) + (signed int)(unsigned char)vSums >> 1);
          tmp_post_14 = dst;
          dst = dst + 1l;
          *tmp_post_14 = (unsigned char)((signed int)convert_bayer_to_rgb__1__1__1__1__1__hSum + (signed int)(unsigned char)(vSums >> 8) >> 1);
          tmp_post_15 = dst;
          dst = dst + 1l;
          *tmp_post_15 = (unsigned char)(hVals >> 8);
        }

        else
        {
          tmp_post_16 = dst;
          dst = dst + 1l;
          *tmp_post_16 = (unsigned char)(vSums >> 8);
          tmp_post_17 = dst;
          dst = dst + 1l;
          *tmp_post_17 = (unsigned char)(hVals >> 8);
          tmp_post_18 = dst;
          dst = dst + 1l;
          *tmp_post_18 = convert_bayer_to_rgb__1__1__1__1__1__hSum;
        }
      hVals = hVals << 8;
      vSums = vSums << 8;
    }
    hVals = hVals | (unsigned int)(unsigned char)(hVals >> 16);
    vSums = vSums | (unsigned int)(unsigned char)(vSums >> 16);
    unsigned char hSum = (unsigned char)hVals;
    if((signed int)yOdd == 0)
    {
      if((1 & x) == 0)
      {
        tmp_post_19 = dst;
        dst = dst + 1l;
        *tmp_post_19 = hSum;
        tmp_post_20 = dst;
        dst = dst + 1l;
        *tmp_post_20 = (unsigned char)(hVals >> 8);
        tmp_post_21 = dst;
        dst = dst + 1l;
        *tmp_post_21 = (unsigned char)(vSums >> 8);
      }

      else
      {
        tmp_post_22 = dst;
        dst = dst + 1l;
        *tmp_post_22 = (unsigned char)(hVals >> 8);
        tmp_post_23 = dst;
        dst = dst + 1l;
        *tmp_post_23 = (unsigned char)((signed int)hSum + (signed int)(unsigned char)(vSums >> 8) >> 1);
        tmp_post_24 = dst;
        dst = dst + 1l;
        *tmp_post_24 = (unsigned char)vSums;
      }
    }

    else
      if((1 & x) == 0)
      {
        tmp_post_25 = dst;
        dst = dst + 1l;
        *tmp_post_25 = (unsigned char)vSums;
        tmp_post_26 = dst;
        dst = dst + 1l;
        *tmp_post_26 = (unsigned char)((signed int)hSum + (signed int)(unsigned char)(vSums >> 8) >> 1);
        tmp_post_27 = dst;
        dst = dst + 1l;
        *tmp_post_27 = (unsigned char)(hVals >> 8);
      }

      else
      {
        tmp_post_28 = dst;
        dst = dst + 1l;
        *tmp_post_28 = (unsigned char)(vSums >> 8);
        tmp_post_29 = dst;
        dst = dst + 1l;
        *tmp_post_29 = (unsigned char)(hVals >> 8);
        tmp_post_30 = dst;
        dst = dst + 1l;
        *tmp_post_30 = hSum;
      }
  }
}

// convert_bayer_to_rgb_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 453
static void convert_bayer_to_rgb_link1(unsigned char *raw_buf_link1, unsigned char *proc_buf_link1, struct anonymous_6 frame_mode_link1)
{
  signed int x_link1;
  signed int y_link1;
  unsigned char *dst_link1 = proc_buf_link1;
  unsigned char *prevLine_link1;
  unsigned char *curLine_link1;
  unsigned char *nextLine_link1;
  unsigned int hVals_link1;
  unsigned int vSums_link1;
  curLine_link1 = raw_buf_link1;
  nextLine_link1 = curLine_link1 + (signed long int)frame_mode_link1.width;
  y_link1 = 0;
  unsigned char *tmp_post_1_link1;
  unsigned char *tmp_post_2_link1;
  unsigned char *tmp_post_3_link1;
  unsigned char *tmp_post_4_link1;
  unsigned char *tmp_post_5_link1;
  unsigned char *tmp_post_6_link1;
  unsigned char *tmp_post_7_link1;
  unsigned char *tmp_post_8_link1;
  unsigned char *tmp_post_9_link1;
  unsigned char *tmp_post_10_link1;
  unsigned char *tmp_post_11_link1;
  unsigned char *tmp_post_12_link1;
  unsigned char *tmp_post_13_link1;
  unsigned char *tmp_post_14_link1;
  unsigned char *tmp_post_15_link1;
  unsigned char *tmp_post_16_link1;
  unsigned char *tmp_post_17_link1;
  unsigned char *tmp_post_18_link1;
  unsigned char *tmp_post_19_link1;
  unsigned char *tmp_post_20_link1;
  unsigned char *tmp_post_21_link1;
  unsigned char *tmp_post_22_link1;
  unsigned char *tmp_post_23_link1;
  unsigned char *tmp_post_24_link1;
  unsigned char *tmp_post_25_link1;
  unsigned char *tmp_post_26_link1;
  unsigned char *tmp_post_27_link1;
  unsigned char *tmp_post_28_link1;
  unsigned char *tmp_post_29_link1;
  unsigned char *tmp_post_30_link1;
  for( ; !(y_link1 >= (signed int)frame_mode_link1.height); y_link1 = y_link1 + 1)
  {
    if(y_link1 >= 1 && !(y_link1 >= (signed int)frame_mode_link1.height + -1))
      prevLine_link1 = curLine_link1 - (signed long int)frame_mode_link1.width;

    else
      if(y_link1 == 0)
        prevLine_link1 = nextLine_link1;

      else
        nextLine_link1 = prevLine_link1;
    tmp_post_1_link1 = curLine_link1;
    curLine_link1 = curLine_link1 + 1l;
    hVals_link1 = (unsigned int)((signed int)*tmp_post_1_link1 << 8);
    hVals_link1 = hVals_link1 | (unsigned int)((signed int)*curLine_link1 << 16);
    tmp_post_2_link1 = prevLine_link1;
    prevLine_link1 = prevLine_link1 + 1l;
    tmp_post_3_link1 = nextLine_link1;
    nextLine_link1 = nextLine_link1 + 1l;
    vSums_link1 = (unsigned int)((signed int)*tmp_post_2_link1 + (signed int)*tmp_post_3_link1 << 7 & 0xFF00);
    vSums_link1 = vSums_link1 | (unsigned int)((signed int)*prevLine_link1 + (signed int)*nextLine_link1 << 15 & 0xFF0000);
    unsigned char yOdd_link1 = (unsigned char)(y_link1 & 1);
    x_link1 = 0;
    for( ; !(x_link1 >= (signed int)frame_mode_link1.width + -1); x_link1 = x_link1 + 1)
    {
      tmp_post_4_link1 = curLine_link1;
      curLine_link1 = curLine_link1 + 1l;
      hVals_link1 = hVals_link1 | (unsigned int)*tmp_post_4_link1;
      tmp_post_5_link1 = prevLine_link1;
      prevLine_link1 = prevLine_link1 + 1l;
      tmp_post_6_link1 = nextLine_link1;
      nextLine_link1 = nextLine_link1 + 1l;
      vSums_link1 = vSums_link1 | (unsigned int)((signed int)*tmp_post_5_link1 + (signed int)*tmp_post_6_link1 >> 1);
      unsigned char convert_bayer_to_rgb__1__1__1__1__1__hSum_link1 = (unsigned char)((signed int)(unsigned char)(hVals_link1 >> 16) + (signed int)(unsigned char)hVals_link1 >> 1);
      if((signed int)yOdd_link1 == 0)
      {
        if((1 & x_link1) == 0)
        {
          tmp_post_7_link1 = dst_link1;
          dst_link1 = dst_link1 + 1l;
          *tmp_post_7_link1 = convert_bayer_to_rgb__1__1__1__1__1__hSum_link1;
          tmp_post_8_link1 = dst_link1;
          dst_link1 = dst_link1 + 1l;
          *tmp_post_8_link1 = (unsigned char)(hVals_link1 >> 8);
          tmp_post_9_link1 = dst_link1;
          dst_link1 = dst_link1 + 1l;
          *tmp_post_9_link1 = (unsigned char)(vSums_link1 >> 8);
        }

        else
        {
          tmp_post_10_link1 = dst_link1;
          dst_link1 = dst_link1 + 1l;
          *tmp_post_10_link1 = (unsigned char)(hVals_link1 >> 8);
          tmp_post_11_link1 = dst_link1;
          dst_link1 = dst_link1 + 1l;
          *tmp_post_11_link1 = (unsigned char)((signed int)convert_bayer_to_rgb__1__1__1__1__1__hSum_link1 + (signed int)(unsigned char)(vSums_link1 >> 8) >> 1);
          tmp_post_12_link1 = dst_link1;
          dst_link1 = dst_link1 + 1l;
          *tmp_post_12_link1 = (unsigned char)((signed int)(unsigned char)(vSums_link1 >> 16) + (signed int)(unsigned char)vSums_link1 >> 1);
        }
      }

      else
        if((1 & x_link1) == 0)
        {
          tmp_post_13_link1 = dst_link1;
          dst_link1 = dst_link1 + 1l;
          *tmp_post_13_link1 = (unsigned char)((signed int)(unsigned char)(vSums_link1 >> 16) + (signed int)(unsigned char)vSums_link1 >> 1);
          tmp_post_14_link1 = dst_link1;
          dst_link1 = dst_link1 + 1l;
          *tmp_post_14_link1 = (unsigned char)((signed int)convert_bayer_to_rgb__1__1__1__1__1__hSum_link1 + (signed int)(unsigned char)(vSums_link1 >> 8) >> 1);
          tmp_post_15_link1 = dst_link1;
          dst_link1 = dst_link1 + 1l;
          *tmp_post_15_link1 = (unsigned char)(hVals_link1 >> 8);
        }

        else
        {
          tmp_post_16_link1 = dst_link1;
          dst_link1 = dst_link1 + 1l;
          *tmp_post_16_link1 = (unsigned char)(vSums_link1 >> 8);
          tmp_post_17_link1 = dst_link1;
          dst_link1 = dst_link1 + 1l;
          *tmp_post_17_link1 = (unsigned char)(hVals_link1 >> 8);
          tmp_post_18_link1 = dst_link1;
          dst_link1 = dst_link1 + 1l;
          *tmp_post_18_link1 = convert_bayer_to_rgb__1__1__1__1__1__hSum_link1;
        }
      hVals_link1 = hVals_link1 << 8;
      vSums_link1 = vSums_link1 << 8;
    }
    hVals_link1 = hVals_link1 | (unsigned int)(unsigned char)(hVals_link1 >> 16);
    vSums_link1 = vSums_link1 | (unsigned int)(unsigned char)(vSums_link1 >> 16);
    unsigned char hSum_link1 = (unsigned char)hVals_link1;
    if((signed int)yOdd_link1 == 0)
    {
      if((1 & x_link1) == 0)
      {
        tmp_post_19_link1 = dst_link1;
        dst_link1 = dst_link1 + 1l;
        *tmp_post_19_link1 = hSum_link1;
        tmp_post_20_link1 = dst_link1;
        dst_link1 = dst_link1 + 1l;
        *tmp_post_20_link1 = (unsigned char)(hVals_link1 >> 8);
        tmp_post_21_link1 = dst_link1;
        dst_link1 = dst_link1 + 1l;
        *tmp_post_21_link1 = (unsigned char)(vSums_link1 >> 8);
      }

      else
      {
        tmp_post_22_link1 = dst_link1;
        dst_link1 = dst_link1 + 1l;
        *tmp_post_22_link1 = (unsigned char)(hVals_link1 >> 8);
        tmp_post_23_link1 = dst_link1;
        dst_link1 = dst_link1 + 1l;
        *tmp_post_23_link1 = (unsigned char)((signed int)hSum_link1 + (signed int)(unsigned char)(vSums_link1 >> 8) >> 1);
        tmp_post_24_link1 = dst_link1;
        dst_link1 = dst_link1 + 1l;
        *tmp_post_24_link1 = (unsigned char)vSums_link1;
      }
    }

    else
      if((1 & x_link1) == 0)
      {
        tmp_post_25_link1 = dst_link1;
        dst_link1 = dst_link1 + 1l;
        *tmp_post_25_link1 = (unsigned char)vSums_link1;
        tmp_post_26_link1 = dst_link1;
        dst_link1 = dst_link1 + 1l;
        *tmp_post_26_link1 = (unsigned char)((signed int)hSum_link1 + (signed int)(unsigned char)(vSums_link1 >> 8) >> 1);
        tmp_post_27_link1 = dst_link1;
        dst_link1 = dst_link1 + 1l;
        *tmp_post_27_link1 = (unsigned char)(hVals_link1 >> 8);
      }

      else
      {
        tmp_post_28_link1 = dst_link1;
        dst_link1 = dst_link1 + 1l;
        *tmp_post_28_link1 = (unsigned char)(vSums_link1 >> 8);
        tmp_post_29_link1 = dst_link1;
        dst_link1 = dst_link1 + 1l;
        *tmp_post_29_link1 = (unsigned char)(hVals_link1 >> 8);
        tmp_post_30_link1 = dst_link1;
        dst_link1 = dst_link1 + 1l;
        *tmp_post_30_link1 = hSum_link1;
      }
  }
}

// convert_packed11_to_16bit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 345
static void convert_packed11_to_16bit(unsigned char *raw, unsigned short int *frame, signed int n)
{
  unsigned short int baseMask = (unsigned short int)((1 << 11) - 1);
  while(n >= 8)
  {
    unsigned char r0 = raw[(signed long int)0];
    unsigned char r1 = raw[(signed long int)1];
    unsigned char r2 = raw[(signed long int)2];
    unsigned char r3 = raw[(signed long int)3];
    unsigned char r4 = raw[(signed long int)4];
    unsigned char r5 = raw[(signed long int)5];
    unsigned char r6 = raw[(signed long int)6];
    unsigned char r7 = raw[(signed long int)7];
    unsigned char r8 = raw[(signed long int)8];
    unsigned char r9 = raw[(signed long int)9];
    unsigned char r10 = raw[(signed long int)10];
    frame[(signed long int)0] = (unsigned short int)((signed int)r0 << 3 | (signed int)r1 >> 5);
    frame[(signed long int)1] = (unsigned short int)(((signed int)r1 << 6 | (signed int)r2 >> 2) & (signed int)baseMask);
    frame[(signed long int)2] = (unsigned short int)(((signed int)r2 << 9 | (signed int)r3 << 1 | (signed int)r4 >> 7) & (signed int)baseMask);
    frame[(signed long int)3] = (unsigned short int)(((signed int)r4 << 4 | (signed int)r5 >> 4) & (signed int)baseMask);
    frame[(signed long int)4] = (unsigned short int)(((signed int)r5 << 7 | (signed int)r6 >> 1) & (signed int)baseMask);
    frame[(signed long int)5] = (unsigned short int)(((signed int)r6 << 10 | (signed int)r7 << 2 | (signed int)r8 >> 6) & (signed int)baseMask);
    frame[(signed long int)6] = (unsigned short int)(((signed int)r8 << 5 | (signed int)r9 >> 3) & (signed int)baseMask);
    frame[(signed long int)7] = (unsigned short int)(((signed int)r9 << 8 | (signed int)r10) & (signed int)baseMask);
    n = n - 8;
    raw = raw + (signed long int)11;
    frame = frame + (signed long int)8;
  }
}

// convert_packed11_to_16bit_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 345
static void convert_packed11_to_16bit_link1(unsigned char *raw_link1, unsigned short int *frame_link1, signed int n_link1)
{
  unsigned short int baseMask_link1 = (unsigned short int)((1 << 11) - 1);
  while(n_link1 >= 8)
  {
    unsigned char r0_link1 = raw_link1[(signed long int)0];
    unsigned char r1_link1 = raw_link1[(signed long int)1];
    unsigned char r2_link1 = raw_link1[(signed long int)2];
    unsigned char r3_link1 = raw_link1[(signed long int)3];
    unsigned char r4_link1 = raw_link1[(signed long int)4];
    unsigned char r5_link1 = raw_link1[(signed long int)5];
    unsigned char r6_link1 = raw_link1[(signed long int)6];
    unsigned char r7_link1 = raw_link1[(signed long int)7];
    unsigned char r8_link1 = raw_link1[(signed long int)8];
    unsigned char r9_link1 = raw_link1[(signed long int)9];
    unsigned char r10_link1 = raw_link1[(signed long int)10];
    frame_link1[(signed long int)0] = (unsigned short int)((signed int)r0_link1 << 3 | (signed int)r1_link1 >> 5);
    frame_link1[(signed long int)1] = (unsigned short int)(((signed int)r1_link1 << 6 | (signed int)r2_link1 >> 2) & (signed int)baseMask_link1);
    frame_link1[(signed long int)2] = (unsigned short int)(((signed int)r2_link1 << 9 | (signed int)r3_link1 << 1 | (signed int)r4_link1 >> 7) & (signed int)baseMask_link1);
    frame_link1[(signed long int)3] = (unsigned short int)(((signed int)r4_link1 << 4 | (signed int)r5_link1 >> 4) & (signed int)baseMask_link1);
    frame_link1[(signed long int)4] = (unsigned short int)(((signed int)r5_link1 << 7 | (signed int)r6_link1 >> 1) & (signed int)baseMask_link1);
    frame_link1[(signed long int)5] = (unsigned short int)(((signed int)r6_link1 << 10 | (signed int)r7_link1 << 2 | (signed int)r8_link1 >> 6) & (signed int)baseMask_link1);
    frame_link1[(signed long int)6] = (unsigned short int)(((signed int)r8_link1 << 5 | (signed int)r9_link1 >> 3) & (signed int)baseMask_link1);
    frame_link1[(signed long int)7] = (unsigned short int)(((signed int)r9_link1 << 8 | (signed int)r10_link1) & (signed int)baseMask_link1);
    n_link1 = n_link1 - 8;
    raw_link1 = raw_link1 + (signed long int)11;
    frame_link1 = frame_link1 + (signed long int)8;
  }
}

// convert_packed_to_16bit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 304
static inline void convert_packed_to_16bit(unsigned char *src, unsigned short int *dest, signed int vw, signed int n)
{
  unsigned int mask = (unsigned int)((1 << vw) - 1);
  unsigned int buffer = (unsigned int)0;
  signed int bitsIn = 0;
  signed int tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned short int *tmp_post_3;
  do
  {
    tmp_post_1 = n;
    n = n - 1;
    if(tmp_post_1 == 0)
      break;

    for( ; !(bitsIn >= vw); bitsIn = bitsIn + 8)
    {
      tmp_post_2 = src;
      src = src + 1l;
      buffer = buffer << 8 | (unsigned int)*tmp_post_2;
    }
    bitsIn = bitsIn - vw;
    tmp_post_3 = dest;
    dest = dest + 1l;
    *tmp_post_3 = (unsigned short int)(buffer >> bitsIn & mask);
  }
  while((_Bool)1);
}

// convert_packed_to_16bit_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 304
static inline void convert_packed_to_16bit_link1(unsigned char *src_link1, unsigned short int *dest_link1, signed int vw_link1, signed int n_link1)
{
  unsigned int mask_link1 = (unsigned int)((1 << vw_link1) - 1);
  unsigned int buffer_link1 = (unsigned int)0;
  signed int bitsIn_link1 = 0;
  signed int tmp_post_1_link1;
  unsigned char *tmp_post_2_link1;
  unsigned short int *tmp_post_3_link1;
  do
  {
    tmp_post_1_link1 = n_link1;
    n_link1 = n_link1 - 1;
    if(tmp_post_1_link1 == 0)
      break;

    for( ; !(bitsIn_link1 >= vw_link1); bitsIn_link1 = bitsIn_link1 + 8)
    {
      tmp_post_2_link1 = src_link1;
      src_link1 = src_link1 + 1l;
      buffer_link1 = buffer_link1 << 8 | (unsigned int)*tmp_post_2_link1;
    }
    bitsIn_link1 = bitsIn_link1 - vw_link1;
    tmp_post_3_link1 = dest_link1;
    dest_link1 = dest_link1 + 1l;
    *tmp_post_3_link1 = (unsigned short int)(buffer_link1 >> bitsIn_link1 & mask_link1);
  }
  while((_Bool)1);
}

// convert_packed_to_8bit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 330
static inline void convert_packed_to_8bit(unsigned char *src, unsigned char *dest, signed int vw, signed int n)
{
  unsigned int buffer = (unsigned int)0;
  signed int bitsIn = 0;
  signed int tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  do
  {
    tmp_post_1 = n;
    n = n - 1;
    if(tmp_post_1 == 0)
      break;

    for( ; !(bitsIn >= vw); bitsIn = bitsIn + 8)
    {
      tmp_post_2 = src;
      src = src + 1l;
      buffer = buffer << 8 | (unsigned int)*tmp_post_2;
    }
    bitsIn = bitsIn - vw;
    tmp_post_3 = dest;
    dest = dest + 1l;
    *tmp_post_3 = (unsigned char)(buffer >> (bitsIn + vw) - 8);
  }
  while((_Bool)1);
}

// convert_packed_to_8bit_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 330
static inline void convert_packed_to_8bit_link1(unsigned char *src_link1, unsigned char *dest_link1, signed int vw_link1, signed int n_link1)
{
  unsigned int buffer_link1 = (unsigned int)0;
  signed int bitsIn_link1 = 0;
  signed int tmp_post_1_link1;
  unsigned char *tmp_post_2_link1;
  unsigned char *tmp_post_3_link1;
  do
  {
    tmp_post_1_link1 = n_link1;
    n_link1 = n_link1 - 1;
    if(tmp_post_1_link1 == 0)
      break;

    for( ; !(bitsIn_link1 >= vw_link1); bitsIn_link1 = bitsIn_link1 + 8)
    {
      tmp_post_2_link1 = src_link1;
      src_link1 = src_link1 + 1l;
      buffer_link1 = buffer_link1 << 8 | (unsigned int)*tmp_post_2_link1;
    }
    bitsIn_link1 = bitsIn_link1 - vw_link1;
    tmp_post_3_link1 = dest_link1;
    dest_link1 = dest_link1 + 1l;
    *tmp_post_3_link1 = (unsigned char)(buffer_link1 >> (bitsIn_link1 + vw_link1) - 8);
  }
  while((_Bool)1);
}

// convert_uyvy_to_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 420
static void convert_uyvy_to_rgb(unsigned char *raw_buf, unsigned char *proc_buf, struct anonymous_6 frame_mode)
{
  signed int x;
  signed int y = 0;
  for( ; !(y >= (signed int)frame_mode.height); y = y + 1)
  {
    x = 0;
    for( ; !(x >= (signed int)frame_mode.width); x = x + 2)
    {
      signed int i = (signed int)frame_mode.width * y + x;
      signed int u = (signed int)raw_buf[(signed long int)(2 * i)];
      signed int y1 = (signed int)raw_buf[(signed long int)(2 * i + 1)];
      signed int v = (signed int)raw_buf[(signed long int)(2 * i + 2)];
      signed int y2 = (signed int)raw_buf[(signed long int)(2 * i + 3)];
      signed int r1 = ((y1 - 16) * 1164) / 1000 + ((v - 128) * 1596) / 1000;
      signed int g1 = (((y1 - 16) * 1164) / 1000 - ((v - 128) * 813) / 1000) - ((u - 128) * 391) / 1000;
      signed int b1 = ((y1 - 16) * 1164) / 1000 + ((u - 128) * 2018) / 1000;
      signed int r2 = ((y2 - 16) * 1164) / 1000 + ((v - 128) * 1596) / 1000;
      signed int g2 = (((y2 - 16) * 1164) / 1000 - ((v - 128) * 813) / 1000) - ((u - 128) * 391) / 1000;
      signed int b2 = ((y2 - 16) * 1164) / 1000 + ((u - 128) * 2018) / 1000;
      if(!(r1 >= 0))
        r1 = 0;

      if(r1 >= 256)
        r1 = 255;

      if(!(g1 >= 0))
        g1 = 0;

      if(g1 >= 256)
        g1 = 255;

      if(!(b1 >= 0))
        b1 = 0;

      if(b1 >= 256)
        b1 = 255;

      if(!(r2 >= 0))
        r2 = 0;

      if(r2 >= 256)
        r2 = 255;

      if(!(g2 >= 0))
        g2 = 0;

      if(g2 >= 256)
        g2 = 255;

      if(!(b2 >= 0))
        b2 = 0;

      if(b2 >= 256)
        b2 = 255;

      proc_buf[(signed long int)(3 * i)] = (unsigned char)r1;
      proc_buf[(signed long int)(3 * i + 1)] = (unsigned char)g1;
      proc_buf[(signed long int)(3 * i + 2)] = (unsigned char)b1;
      proc_buf[(signed long int)(3 * i + 3)] = (unsigned char)r2;
      proc_buf[(signed long int)(3 * i + 4)] = (unsigned char)g2;
      proc_buf[(signed long int)(3 * i + 5)] = (unsigned char)b2;
    }
  }
}

// convert_uyvy_to_rgb_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 420
static void convert_uyvy_to_rgb_link1(unsigned char *raw_buf_link1, unsigned char *proc_buf_link1, struct anonymous_6 frame_mode_link1)
{
  signed int x_link1;
  signed int y_link1 = 0;
  for( ; !(y_link1 >= (signed int)frame_mode_link1.height); y_link1 = y_link1 + 1)
  {
    x_link1 = 0;
    for( ; !(x_link1 >= (signed int)frame_mode_link1.width); x_link1 = x_link1 + 2)
    {
      signed int i_link1 = (signed int)frame_mode_link1.width * y_link1 + x_link1;
      signed int u_link1 = (signed int)raw_buf_link1[(signed long int)(2 * i_link1)];
      signed int y1_link1 = (signed int)raw_buf_link1[(signed long int)(2 * i_link1 + 1)];
      signed int v_link1 = (signed int)raw_buf_link1[(signed long int)(2 * i_link1 + 2)];
      signed int y2_link1 = (signed int)raw_buf_link1[(signed long int)(2 * i_link1 + 3)];
      signed int r1_link1 = ((y1_link1 - 16) * 1164) / 1000 + ((v_link1 - 128) * 1596) / 1000;
      signed int g1_link1 = (((y1_link1 - 16) * 1164) / 1000 - ((v_link1 - 128) * 813) / 1000) - ((u_link1 - 128) * 391) / 1000;
      signed int b1_link1 = ((y1_link1 - 16) * 1164) / 1000 + ((u_link1 - 128) * 2018) / 1000;
      signed int r2_link1 = ((y2_link1 - 16) * 1164) / 1000 + ((v_link1 - 128) * 1596) / 1000;
      signed int g2_link1 = (((y2_link1 - 16) * 1164) / 1000 - ((v_link1 - 128) * 813) / 1000) - ((u_link1 - 128) * 391) / 1000;
      signed int b2_link1 = ((y2_link1 - 16) * 1164) / 1000 + ((u_link1 - 128) * 2018) / 1000;
      if(!(r1_link1 >= 0))
        r1_link1 = 0;

      if(r1_link1 >= 256)
        r1_link1 = 255;

      if(!(g1_link1 >= 0))
        g1_link1 = 0;

      if(g1_link1 >= 256)
        g1_link1 = 255;

      if(!(b1_link1 >= 0))
        b1_link1 = 0;

      if(b1_link1 >= 256)
        b1_link1 = 255;

      if(!(r2_link1 >= 0))
        r2_link1 = 0;

      if(r2_link1 >= 256)
        r2_link1 = 255;

      if(!(g2_link1 >= 0))
        g2_link1 = 0;

      if(g2_link1 >= 256)
        g2_link1 = 255;

      if(!(b2_link1 >= 0))
        b2_link1 = 0;

      if(b2_link1 >= 256)
        b2_link1 = 255;

      proc_buf_link1[(signed long int)(3 * i_link1)] = (unsigned char)r1_link1;
      proc_buf_link1[(signed long int)(3 * i_link1 + 1)] = (unsigned char)g1_link1;
      proc_buf_link1[(signed long int)(3 * i_link1 + 2)] = (unsigned char)b1_link1;
      proc_buf_link1[(signed long int)(3 * i_link1 + 3)] = (unsigned char)r2_link1;
      proc_buf_link1[(signed long int)(3 * i_link1 + 4)] = (unsigned char)g2_link1;
      proc_buf_link1[(signed long int)(3 * i_link1 + 5)] = (unsigned char)b2_link1;
    }
  }
}

// depth_process
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 377
static void depth_process(struct _freenect_device *dev, unsigned char *pkt, signed int len)
{
  struct _freenect_context *depth_process__1__ctx = dev->parent;
  if(!(len == 0))
  {
    if(!(dev->depth.running == 0))
    {
      signed int got_frame_size;
      got_frame_size=stream_process(depth_process__1__ctx, &dev->depth, pkt, len, dev->depth_chunk_cb, dev->user_data);
      if(!(got_frame_size == 0))
      {
        fn_log(depth_process__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "Got depth frame of size %d/%d, %d/%d packets arrived, TS %08x\n", got_frame_size, dev->depth.frame_size, dev->depth.valid_pkts, dev->depth.pkts_per_frame, dev->depth.timestamp);
        switch((signed int)dev->depth_format)
        {
          case FREENECT_DEPTH_11BIT:
          {
            convert_packed11_to_16bit(dev->depth.raw_buf, (unsigned short int *)dev->depth.proc_buf, 640 * 480);
            break;
          }
          case FREENECT_DEPTH_REGISTERED:
          {
            freenect_apply_registration(dev, dev->depth.raw_buf, (unsigned short int *)dev->depth.proc_buf);
            break;
          }
          case FREENECT_DEPTH_MM:
          {
            freenect_apply_depth_to_mm(dev, dev->depth.raw_buf, (unsigned short int *)dev->depth.proc_buf);
            break;
          }
          case FREENECT_DEPTH_10BIT:
          {
            convert_packed_to_16bit(dev->depth.raw_buf, (unsigned short int *)dev->depth.proc_buf, 10, 640 * 480);
            break;
          }
          case FREENECT_DEPTH_10BIT_PACKED:

          case FREENECT_DEPTH_11BIT_PACKED:
            break;
          default:
            fn_log(depth_process__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "depth_process() was called, but an invalid depth_format is set\n");
        }
        if(!(dev->depth_cb == ((void (*)(struct _freenect_device *, void *, unsigned int))NULL)))
          dev->depth_cb(dev, dev->depth.proc_buf, dev->depth.timestamp);

      }

    }

  }

}

// depth_process_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 377
static void depth_process_link1(struct _freenect_device *dev_link1, unsigned char *pkt_link1, signed int len_link1)
{
  struct _freenect_context *ctx_link1 = dev_link1->parent;
  if(!(len_link1 == 0))
  {
    if(!(dev_link1->depth.running == 0))
    {
      signed int got_frame_size_link1;
      got_frame_size_link1=stream_process_link1(ctx_link1, &dev_link1->depth, pkt_link1, len_link1, dev_link1->depth_chunk_cb, dev_link1->user_data);
      if(!(got_frame_size_link1 == 0))
      {
        fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "Got depth frame of size %d/%d, %d/%d packets arrived, TS %08x\n", got_frame_size_link1, dev_link1->depth.frame_size, dev_link1->depth.valid_pkts, dev_link1->depth.pkts_per_frame, dev_link1->depth.timestamp);
        switch((signed int)dev_link1->depth_format)
        {
          case FREENECT_DEPTH_11BIT:
          {
            convert_packed11_to_16bit_link1(dev_link1->depth.raw_buf, (unsigned short int *)dev_link1->depth.proc_buf, 640 * 480);
            break;
          }
          case FREENECT_DEPTH_REGISTERED:
          {
            freenect_apply_registration(dev_link1, dev_link1->depth.raw_buf, (unsigned short int *)dev_link1->depth.proc_buf);
            break;
          }
          case FREENECT_DEPTH_MM:
          {
            freenect_apply_depth_to_mm(dev_link1, dev_link1->depth.raw_buf, (unsigned short int *)dev_link1->depth.proc_buf);
            break;
          }
          case FREENECT_DEPTH_10BIT:
          {
            convert_packed_to_16bit_link1(dev_link1->depth.raw_buf, (unsigned short int *)dev_link1->depth.proc_buf, 10, 640 * 480);
            break;
          }
          case FREENECT_DEPTH_10BIT_PACKED:

          case FREENECT_DEPTH_11BIT_PACKED:
            break;
          default:
            fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "depth_process() was called, but an invalid depth_format is set\n");
        }
        if(!(dev_link1->depth_cb == ((void (*)(struct _freenect_device *, void *, unsigned int))NULL)))
          dev_link1->depth_cb(dev_link1, dev_link1->depth.proc_buf, dev_link1->depth.timestamp);

      }

    }

  }

}

// depth_producer_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 153
static void depth_producer_cb(struct _freenect_device *dev, void *data, unsigned int timestamp)
{
  void *return_value_freenect_get_user_1;
  return_value_freenect_get_user_1=freenect_get_user(dev);
  producer_cb_inner(dev, data, timestamp, &((struct sync_kinect *)return_value_freenect_get_user_1)->depth, freenect_set_depth_buffer);
}

// dump_bl_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 36
static void dump_bl_cmd(struct _freenect_context *ctx, struct anonymous_31 cmd)
{
  signed int i = 0;
  for( ; !(i >= 24); i = i + 1)
    fn_log(ctx, (enum anonymous_21)FREENECT_LOG_INFO, "%02X ", ((unsigned char *)&cmd)[(signed long int)i]);
  fn_log(ctx, (enum anonymous_21)FREENECT_LOG_INFO, "\n");
}

// dump_bl_cmd_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 36
static void dump_bl_cmd_link1(struct _freenect_context *ctx_link1, struct anonymous_31 cmd_link1)
{
  signed int i_link1 = 0;
  for( ; !(i_link1 >= 24); i_link1 = i_link1 + 1)
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_INFO, "%02X ", ((unsigned char *)&cmd_link1)[(signed long int)i_link1]);
  fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_INFO, "\n");
}

// dump_cemd_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 43
static void dump_cemd_cmd(struct _freenect_context *ctx, struct anonymous_30 cmd)
{
  signed int i = 0;
  for( ; !(i >= 24); i = i + 1)
    fn_log(ctx, (enum anonymous_21)FREENECT_LOG_INFO, "%02X ", ((unsigned char *)&cmd)[(signed long int)i]);
  fn_log(ctx, (enum anonymous_21)FREENECT_LOG_INFO, "(%d more zeros)\n", (signed int)(sizeof(struct anonymous_30) /*52ul*/  - (unsigned long int)24));
}

// dump_cemd_cmd_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 43
static void dump_cemd_cmd_link1(struct _freenect_context *ctx_link1, struct anonymous_30 cmd_link1)
{
  signed int i_link1 = 0;
  for( ; !(i_link1 >= 24); i_link1 = i_link1 + 1)
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_INFO, "%02X ", ((unsigned char *)&cmd_link1)[(signed long int)i_link1]);
  fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_INFO, "(%d more zeros)\n", (signed int)(sizeof(struct anonymous_30) /*52ul*/  - (unsigned long int)24));
}

// dump_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regtest.c line 44
void dump_depth(struct _IO_FILE *fp, void *data, unsigned int width, unsigned int height)
{
  fprintf(fp, "P5 %u %u 65535\n", width, height);
  fwrite(data, (unsigned long int)(width * height * (unsigned int)2), (unsigned long int)1, fp);
}

// dump_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regtest.c line 50
void dump_rgb(struct _IO_FILE *fp, void *data, unsigned int width, unsigned int height)
{
  fprintf(fp, "P6 %u %u 255\n", width, height);
  fwrite(data, (unsigned long int)(width * height * (unsigned int)3), (unsigned long int)1, fp);
}

// fn_log
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 262
void fn_log(struct _freenect_context *ctx, enum anonymous_21 level, const char *fmt, ...)
{
  void **ap;
  if((signed int)ctx->log_level >= (signed int)level)
  {
    if(!(ctx->log_cb == ((void (*)(struct _freenect_context *, enum anonymous_21, const char *))NULL)))
    {
      char msgbuf[1024l];
      ap = (void **)&fmt;
      vsnprintf(msgbuf, (unsigned long int)1024, fmt, ap);
      msgbuf[(signed long int)1023] = (char)0;
      ap = ((void **)NULL);
      ctx->log_cb(ctx, level, msgbuf);
    }

    else
    {
      ap = (void **)&fmt;
      vfprintf(stderr, fmt, ap);
      ap = ((void **)NULL);
    }
  }

}

// fnusb_bulk
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 879
signed int fnusb_bulk(struct anonymous_10 *dev, unsigned char endpoint, unsigned char *data, signed int len, signed int *transferred)
{
  *transferred = 0;
  signed int return_value_libusb_bulk_transfer_1;
  return_value_libusb_bulk_transfer_1=libusb_bulk_transfer(dev->dev, endpoint, data, len, transferred, (unsigned int)0);
  return return_value_libusb_bulk_transfer_1;
}

// fnusb_claim_camera
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 255
signed int fnusb_claim_camera(struct _freenect_device *dev)
{
  struct _freenect_context *fnusb_claim_camera__1__ctx = dev->parent;
  signed int ret = 0;
  ret=libusb_kernel_driver_active(dev->usb_cam.dev, 0);
  if(ret == 1)
  {
    ret=libusb_detach_kernel_driver(dev->usb_cam.dev, 0);
    if(!(ret >= 0))
    {
      const char *return_value_libusb_error_name_1;
      return_value_libusb_error_name_1=libusb_error_name(ret);
      fn_log(fnusb_claim_camera__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Failed to detach camera kernel driver: %s\n", return_value_libusb_error_name_1);
      libusb_close(dev->usb_cam.dev);
      dev->usb_cam.dev = (struct libusb_device_handle *)(void *)0;
      return ret;
    }

  }

  ret=libusb_claim_interface(dev->usb_cam.dev, 0);
  if(!(ret >= 0))
  {
    const char *return_value_libusb_error_name_2;
    return_value_libusb_error_name_2=libusb_error_name(ret);
    fn_log(fnusb_claim_camera__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Failed to claim camera interface: %s\n", return_value_libusb_error_name_2);
    libusb_close(dev->usb_cam.dev);
    dev->usb_cam.dev = (struct libusb_device_handle *)(void *)0;
    return ret;
  }

  if(dev->usb_cam.PID == 0x02bf)
  {
    ret=libusb_set_interface_alt_setting(dev->usb_cam.dev, 0, 1);
    if(!(ret == 0))
    {
      const char *return_value_libusb_error_name_3;
      return_value_libusb_error_name_3=libusb_error_name(ret);
      fn_log(fnusb_claim_camera__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Failed to set alternate interface #1 for K4W: %s\n", return_value_libusb_error_name_3);
      libusb_close(dev->usb_cam.dev);
      dev->usb_cam.dev = (struct libusb_device_handle *)(void *)0;
      return ret;
    }

  }

  return ret;
}

// fnusb_close_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 86
signed int fnusb_close_subdevices(struct _freenect_device *dev)
{
  if(!(dev->usb_cam.dev == ((struct libusb_device_handle *)NULL)))
  {
    libusb_release_interface(dev->usb_cam.dev, 0);
    libusb_attach_kernel_driver(dev->usb_cam.dev, 0);
    libusb_close(dev->usb_cam.dev);
    dev->usb_cam.dev = (struct libusb_device_handle *)(void *)0;
  }

  if(!(dev->usb_motor.dev == ((struct libusb_device_handle *)NULL)))
  {
    libusb_release_interface(dev->usb_motor.dev, 0);
    libusb_close(dev->usb_motor.dev);
    dev->usb_motor.dev = (struct libusb_device_handle *)(void *)0;
  }

  if(!(dev->usb_audio.dev == ((struct libusb_device_handle *)NULL)))
  {
    libusb_release_interface(dev->usb_audio.dev, 0);
    libusb_close(dev->usb_audio.dev);
    dev->usb_audio.dev = (struct libusb_device_handle *)(void *)0;
  }

  return 0;
}

// fnusb_control
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 92
signed int fnusb_control(struct anonymous_10 *dev, unsigned char bmRequestType, unsigned char bRequest, unsigned short int wValue, unsigned short int wIndex, unsigned char *data, unsigned short int wLength)
{
  signed int return_value_libusb_control_transfer_1;
  return_value_libusb_control_transfer_1=libusb_control_transfer(dev->dev, bmRequestType, bRequest, wValue, wIndex, data, wLength, (unsigned int)0);
  return return_value_libusb_control_transfer_1;
}

// fnusb_find_connected_audio_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 69
struct libusb_device * fnusb_find_connected_audio_device(struct libusb_device *camera, struct libusb_device **deviceList, signed int cnt)
{
  _Bool tmp_if_expr_4;
  signed int return_value_fnusb_is_pid_k4w_audio_3;
  if(!(cnt >= 1))
    return (struct libusb_device *)(void *)0;

  else
  {
    signed int cameraBusNo;
    unsigned char return_value_libusb_get_bus_number_1;
    return_value_libusb_get_bus_number_1=libusb_get_bus_number(camera);
    cameraBusNo = (signed int)return_value_libusb_get_bus_number_1;
    if(!(cameraBusNo >= 0))
      return (struct libusb_device *)(void *)0;

    else
    {
      struct libusb_device *cameraParent;
      cameraParent=libusb_get_parent(camera);
      signed int i = 0;
      i = 0;
      for( ; !(i >= cnt); i = i + 1)
      {
        struct libusb_device_descriptor desc;
        signed int res;
        res=libusb_get_device_descriptor(deviceList[(signed long int)i], &desc);
        if(res >= 0)
        {
          if((signed int)desc.idVendor == 0x45e)
          {
            if((signed int)desc.idProduct == 0x02ad)
              tmp_if_expr_4 = (_Bool)1;

            else
            {
              return_value_fnusb_is_pid_k4w_audio_3=fnusb_is_pid_k4w_audio((signed int)desc.idProduct);
              tmp_if_expr_4 = return_value_fnusb_is_pid_k4w_audio_3 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_4)
            {
              signed int audioBusNo;
              unsigned char return_value_libusb_get_bus_number_2;
              return_value_libusb_get_bus_number_2=libusb_get_bus_number(deviceList[(signed long int)i]);
              audioBusNo = (signed int)return_value_libusb_get_bus_number_2;
              if(audioBusNo == cameraBusNo)
              {
                struct libusb_device *audioParent;
                audioParent=libusb_get_parent(deviceList[(signed long int)i]);
                if(cameraParent == audioParent)
                  return deviceList[(signed long int)i];

              }

            }

          }

        }

      }
      return (struct libusb_device *)(void *)0;
    }
  }
}

// fnusb_get_max_iso_packet_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 90
signed int fnusb_get_max_iso_packet_size(struct anonymous_10 *dev, unsigned char endpoint, signed int default_size)
{
  struct _freenect_context *fnusb_get_max_iso_packet_size__1__ctx = dev->parent->parent;
  signed int size;
  struct libusb_device *return_value_libusb_get_device_1;
  return_value_libusb_get_device_1=libusb_get_device(dev->dev);
  size=libusb_get_max_iso_packet_size(return_value_libusb_get_device_1, endpoint);
  if(!(size >= 1))
  {
    fn_log(fnusb_get_max_iso_packet_size__1__ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "libusb_get_max_iso_packet_size() returned %d; using default %d\n", size, default_size);
    size = default_size;
  }

  return size;
}

// fnusb_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 80
signed int fnusb_init(struct anonymous_20 *ctx, void *usb_ctx)
{
  signed int res;
  if(usb_ctx == NULL)
  {
    res=libusb_init(&ctx->ctx);
    if(res >= 0)
    {
      ctx->should_free_ctx = 1;
      return 0;
    }

    else
    {
      ctx->should_free_ctx = 0;
      ctx->ctx = (struct libusb_context *)(void *)0;
      return res;
    }
  }

  else
  {
    ctx->ctx = (struct libusb_context *)usb_ctx;
    ctx->should_free_ctx = 0;
    return 0;
  }
}

// fnusb_is_pid_k4w_audio
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 64
signed int fnusb_is_pid_k4w_audio(signed int pid)
{
  return (signed int)(pid == 0x02be || pid == 0x02c3 || pid == 0x02bb);
}

// fnusb_list_device_attributes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 78
signed int fnusb_list_device_attributes(struct anonymous_20 *ctx, struct freenect_device_attributes **attribute_list)
{
  *attribute_list = (struct freenect_device_attributes *)(void *)0;
  struct libusb_device **devs;
  signed long int count;
  count=libusb_get_device_list(ctx->ctx, &devs);
  if(!(count >= 0l))
    return -1;

  else
  {
    struct freenect_device_attributes **next_attr = attribute_list;
    signed int num_cams = 0;
    signed int i = 0;
    for( ; !((signed long int)i >= count); i = i + 1)
    {
      struct libusb_device *camera_device = devs[(signed long int)i];
      struct libusb_device_descriptor desc;
      signed int res;
      res=libusb_get_device_descriptor(camera_device, &desc);
      if(res >= 0)
      {
        if((signed int)desc.idVendor == 0x45e && ((signed int)desc.idProduct == 0x02ae || (signed int)desc.idProduct == 0x02bf))
        {
          if((signed int)desc.iSerialNumber == 0)
            goto __CPROVER_DUMP_L12;

          struct libusb_device_handle *camera_handle;
          res=libusb_open(camera_device, &camera_handle);
          if(!(res == 0))
            goto __CPROVER_DUMP_L12;

          unsigned char serial[256l];
          res=libusb_get_string_descriptor_ascii(camera_handle, desc.iSerialNumber, serial, 256);
          libusb_close(camera_handle);
          if(!(res >= 0))
            goto __CPROVER_DUMP_L12;

          const char * const K4W_1473_SERIAL = "0000000000000000";
          signed int return_value_strncmp_1;
          return_value_strncmp_1=strncmp((const char *)serial, K4W_1473_SERIAL, (unsigned long int)16);
          if(return_value_strncmp_1 == 0)
          {
            struct libusb_device *audio_device;
            audio_device=fnusb_find_connected_audio_device(camera_device, devs, (signed int)count);
            if(!(audio_device == ((struct libusb_device *)NULL)))
            {
              struct libusb_device_descriptor audio_desc;
              res=libusb_get_device_descriptor(audio_device, &audio_desc);
              if(res == 0)
              {
                struct libusb_device_handle *audio_handle = (struct libusb_device_handle *)(void *)0;
                res=libusb_open(audio_device, &audio_handle);
                if(res == 0)
                {
                  res=libusb_get_string_descriptor_ascii(audio_handle, audio_desc.iSerialNumber, serial, 256);
                  libusb_close(audio_handle);
                }

              }

            }

          }

          struct freenect_device_attributes *current_attr;
          void *return_value_malloc_2;
          return_value_malloc_2=malloc(sizeof(struct freenect_device_attributes) /*16ul*/ );
          current_attr = (struct freenect_device_attributes *)return_value_malloc_2;
          memset((void *)current_attr, 0, sizeof(struct freenect_device_attributes) /*16ul*/ );
          current_attr->camera_serial=strdup((char *)serial);
          *next_attr = current_attr;
          next_attr = &current_attr->next;
          num_cams = num_cams + 1;
        }

      }


    __CPROVER_DUMP_L12:
      ;
    }
    libusb_free_device_list(devs, 1);
    return num_cams;
  }
}

// fnusb_num_devices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 77
signed int fnusb_num_devices(struct anonymous_20 *ctx)
{
  struct libusb_device **devs;
  signed long int cnt;
  cnt=libusb_get_device_list(ctx->ctx, &devs);
  if(!(cnt >= 0l))
    return -1;

  else
  {
    signed int nr = 0;
    signed int i = 0;
    struct libusb_device_descriptor desc;
    i = 0;
    for( ; !((signed long int)i >= cnt); i = i + 1)
    {
      signed int r;
      r=libusb_get_device_descriptor(devs[(signed long int)i], &desc);
      if(r >= 0)
      {
        if((signed int)desc.idVendor == 0x45e && ((signed int)desc.idProduct == 0x02ae || (signed int)desc.idProduct == 0x02bf))
          nr = nr + 1;

      }

    }
    libusb_free_device_list(devs, 1);
    return nr;
  }
}

// fnusb_num_interfaces
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 884
signed int fnusb_num_interfaces(struct anonymous_10 *dev)
{
  signed int retval = 0;
  signed int res;
  struct libusb_device *d;
  d=libusb_get_device(dev->dev);
  struct libusb_config_descriptor *config;
  res=libusb_get_active_config_descriptor(d, &config);
  if(!(res >= 0))
    return res;

  else
  {
    retval = (signed int)config->bNumInterfaces;
    libusb_free_config_descriptor(config);
    return retval;
  }
}

// fnusb_open_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 85
signed int fnusb_open_subdevices(struct _freenect_device *dev, signed int index)
{
  struct _freenect_context *fnusb_open_subdevices__1__ctx = dev->parent;
  dev->device_does_motor_control_with_audio = 0;
  dev->motor_control_with_audio_enabled = 0;
  dev->usb_cam.parent = dev;
  dev->usb_cam.dev = (struct libusb_device_handle *)(void *)0;
  dev->usb_motor.parent = dev;
  dev->usb_motor.dev = (struct libusb_device_handle *)(void *)0;
  dev->usb_audio.parent = dev;
  dev->usb_audio.dev = (struct libusb_device_handle *)(void *)0;
  struct libusb_device **devs;
  signed long int cnt;
  cnt=libusb_get_device_list(dev->parent->usb.ctx, &devs);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_14;
  signed int return_value_fnusb_is_pid_k4w_audio_13;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_12;
  signed int return_value_fnusb_is_pid_k4w_audio_11;
  _Bool tmp_if_expr_10;
  signed int return_value_strcmp_9;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_15;
  if(!(cnt >= 0l))
    return -1;

  else
  {
    signed int i = 0;
    signed int nr_cam = 0;
    signed int nr_mot = 0;
    signed int nr_audio = 0;
    signed int res;
    struct libusb_device_descriptor desc;
    i = 0;
    for( ; !((signed long int)i >= cnt); i = i + 1)
    {
      signed int r;
      r=libusb_get_device_descriptor(devs[(signed long int)i], &desc);
      if(r >= 0)
      {
        if((signed int)desc.idVendor == 0x45e)
        {
          res = 0;
          if(!((FREENECT_DEVICE_CAMERA & (signed int)fnusb_open_subdevices__1__ctx->enabled_subdevices) == 0))
          {
            if(dev->usb_cam.dev == ((struct libusb_device_handle *)NULL))
            {
              if((signed int)desc.idProduct == 0x02ae || (signed int)desc.idProduct == 0x02bf)
              {
                if(nr_cam == index)
                {
                  dev->usb_cam.VID = (signed int)desc.idVendor;
                  dev->usb_cam.PID = (signed int)desc.idProduct;
                  res=libusb_open(devs[(signed long int)i], &dev->usb_cam.dev);
                  if(!(res >= 0))
                    tmp_if_expr_1 = (_Bool)1;

                  else
                    tmp_if_expr_1 = !(dev->usb_cam.dev != ((struct libusb_device_handle *)NULL)) ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_1)
                  {
                    fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Could not open camera: %d\n", res);
                    dev->usb_cam.dev = (struct libusb_device_handle *)(void *)0;
                    break;
                  }

                  if((signed int)desc.idProduct == 0x02bf || !((signed int)desc.bcdDevice == 267))
                  {
                    enum anonymous_22 requested_devices = fnusb_open_subdevices__1__ctx->enabled_subdevices;
                    fnusb_open_subdevices__1__ctx->enabled_subdevices = (enum anonymous_22)((signed int)fnusb_open_subdevices__1__ctx->enabled_subdevices & ~FREENECT_DEVICE_MOTOR);
                    fnusb_open_subdevices__1__ctx->zero_plane_res = 334;
                    dev->device_does_motor_control_with_audio = 1;
                    struct libusb_device *audioDevice;
                    audioDevice=fnusb_find_connected_audio_device(devs[(signed long int)i], devs, (signed int)cnt);
                    if(!(audioDevice == ((struct libusb_device *)NULL)))
                    {
                      struct libusb_device_handle *audioHandle = (struct libusb_device_handle *)(void *)0;
                      res=libusb_open(audioDevice, &audioHandle);
                      if(!(res == 0))
                        fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Failed to set the LED of K4W or 1473 device: %d\n", res);

                      else
                      {
                        libusb_reset_device(audioHandle);
                        libusb_close(audioHandle);
                        res=libusb_open(audioDevice, &audioHandle);
                        if(res == 0)
                        {
                          res=libusb_claim_interface(audioHandle, 0);
                          if(!(res == 0))
                            fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Unable to claim interface %d\n", res);

                          else
                          {
                            fnusb_set_led_alt(audioHandle, fnusb_open_subdevices__1__ctx, (enum anonymous_23)LED_GREEN);
                            libusb_release_interface(audioHandle, 0);
                          }
                          libusb_close(audioHandle);
                        }

                      }
                    }

                    if((FREENECT_DEVICE_AUDIO & (signed int)requested_devices) == 0 && !((FREENECT_DEVICE_MOTOR & (signed int)requested_devices) == 0))
                      fnusb_open_subdevices__1__ctx->enabled_subdevices = (enum anonymous_22)((signed int)fnusb_open_subdevices__1__ctx->enabled_subdevices | FREENECT_DEVICE_AUDIO);

                  }

                  else
                    fnusb_open_subdevices__1__ctx->zero_plane_res = 322;
                  res=fnusb_claim_camera(dev);
                  if(!(res >= 0))
                    break;

                }

                else
                  nr_cam = nr_cam + 1;
              }

            }

          }

        }

      }

    }
    if((signed int)fnusb_open_subdevices__1__ctx->enabled_subdevices == FREENECT_DEVICE_CAMERA || !(res >= 0))
      cnt = (signed long int)0;

    i = 0;
    for( ; !((signed long int)i >= cnt); i = i + 1)
    {
      signed int fnusb_open_subdevices__1__2__1__r;
      fnusb_open_subdevices__1__2__1__r=libusb_get_device_descriptor(devs[(signed long int)i], &desc);
      if(fnusb_open_subdevices__1__2__1__r >= 0)
      {
        if((signed int)desc.idVendor == 0x45e)
        {
          if(!((FREENECT_DEVICE_MOTOR & (signed int)fnusb_open_subdevices__1__ctx->enabled_subdevices) == 0))
          {
            if(dev->usb_motor.dev == ((struct libusb_device_handle *)NULL))
            {
              if((signed int)desc.idProduct == 0x02b0)
              {
                if(nr_mot == index)
                {
                  dev->usb_motor.VID = (signed int)desc.idVendor;
                  dev->usb_motor.PID = (signed int)desc.idProduct;
                  res=libusb_open(devs[(signed long int)i], &dev->usb_motor.dev);
                  if(!(res >= 0))
                    tmp_if_expr_2 = (_Bool)1;

                  else
                    tmp_if_expr_2 = !(dev->usb_motor.dev != ((struct libusb_device_handle *)NULL)) ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_2)
                  {
                    fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Could not open motor: %d\n", res);
                    dev->usb_motor.dev = (struct libusb_device_handle *)(void *)0;
                    break;
                  }

                  res=libusb_claim_interface(dev->usb_motor.dev, 0);
                  if(!(res >= 0))
                  {
                    fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Could not claim interface on motor: %d\n", res);
                    libusb_close(dev->usb_motor.dev);
                    dev->usb_motor.dev = (struct libusb_device_handle *)(void *)0;
                    break;
                  }

                }

                else
                  nr_mot = nr_mot + 1;
              }

            }

          }

          if(!((FREENECT_DEVICE_AUDIO & (signed int)fnusb_open_subdevices__1__ctx->enabled_subdevices) == 0))
          {
            if(dev->usb_audio.dev == ((struct libusb_device_handle *)NULL))
            {
              if((signed int)desc.idProduct == 0x02ad)
                tmp_if_expr_14 = (_Bool)1;

              else
              {
                return_value_fnusb_is_pid_k4w_audio_13=fnusb_is_pid_k4w_audio((signed int)desc.idProduct);
                tmp_if_expr_14 = return_value_fnusb_is_pid_k4w_audio_13 != 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_14)
              {
                if(nr_audio == index)
                {
                  dev->usb_audio.VID = (signed int)desc.idVendor;
                  dev->usb_audio.PID = (signed int)desc.idProduct;
                  res=libusb_open(devs[(signed long int)i], &dev->usb_audio.dev);
                  if(!(res >= 0))
                    tmp_if_expr_3 = (_Bool)1;

                  else
                    tmp_if_expr_3 = !(dev->usb_audio.dev != ((struct libusb_device_handle *)NULL)) ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_3)
                  {
                    fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Could not open audio: %d\n", res);
                    dev->usb_audio.dev = (struct libusb_device_handle *)(void *)0;
                    break;
                  }

                  res=libusb_claim_interface(dev->usb_audio.dev, 0);
                  if(!(res >= 0))
                  {
                    fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Could not claim interface on audio: %d\n", res);
                    libusb_close(dev->usb_audio.dev);
                    dev->usb_audio.dev = (struct libusb_device_handle *)(void *)0;
                    break;
                  }

                  signed int num_interfaces;
                  num_interfaces=fnusb_num_interfaces(&dev->usb_audio);
                  if(num_interfaces >= 2)
                  {
                    if(!(dev->device_does_motor_control_with_audio == 0))
                      dev->motor_control_with_audio_enabled = 1;

                  }

                  else
                  {
                    unsigned char string_desc[256l];
                    res=libusb_get_string_descriptor_ascii(dev->usb_audio.dev, desc.iSerialNumber, string_desc, 256);
                    if(!(res >= 0))
                    {
                      fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Failed to retrieve serial number for audio device in bootloader state\n");
                      break;
                    }

                    char *audio_serial;
                    audio_serial=strdup((char *)string_desc);
                    fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "Uploading firmware to audio device in bootloader state.\n");
                    if((signed int)desc.idProduct == 0x02ad)
                      tmp_if_expr_6 = fnusb_open_subdevices__1__ctx->fn_fw_nui_ptr != ((unsigned char *)NULL) ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_6 = (_Bool)0;
                    if(tmp_if_expr_6)
                      tmp_if_expr_7 = fnusb_open_subdevices__1__ctx->fn_fw_nui_size > (unsigned int)0 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_7 = (_Bool)0;
                    if(tmp_if_expr_7)
                    {
                      fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "loading firmware from memory\n");
                      res=upload_firmware_from_memory(&dev->usb_audio, fnusb_open_subdevices__1__ctx->fn_fw_nui_ptr, fnusb_open_subdevices__1__ctx->fn_fw_nui_size);
                    }

                    else
                    {
                      if((signed int)desc.idProduct == 0x02be)
                        tmp_if_expr_4 = fnusb_open_subdevices__1__ctx->fn_fw_k4w_ptr != ((unsigned char *)NULL) ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr_4 = (_Bool)0;
                      if(tmp_if_expr_4)
                        tmp_if_expr_5 = fnusb_open_subdevices__1__ctx->fn_fw_k4w_size > (unsigned int)0 ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr_5 = (_Bool)0;
                      if(tmp_if_expr_5)
                      {
                        fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "loading firmware from memory\n");
                        res=upload_firmware_from_memory(&dev->usb_audio, fnusb_open_subdevices__1__ctx->fn_fw_k4w_ptr, fnusb_open_subdevices__1__ctx->fn_fw_k4w_size);
                      }

                      else
                        res=upload_firmware(&dev->usb_audio, "audios.bin");
                    }
                    if(!(res >= 0))
                    {
                      fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "upload_firmware failed: %d\n", res);
                      break;
                    }

                    libusb_close(dev->usb_audio.dev);
                    dev->usb_audio.dev = (struct libusb_device_handle *)(void *)0;
                    signed int loops = 0;
                    loops = 0;
                    for( ; !(loops >= 10); loops = loops + 1)
                    {
                      fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "Try %d: Looking for new audio device matching serial %s\n", loops, audio_serial);
                      struct libusb_device **new_dev_list;
                      signed int dev_index;
                      signed long int num_new_devs;
                      num_new_devs=libusb_get_device_list(fnusb_open_subdevices__1__ctx->usb.ctx, &new_dev_list);
                      dev_index = 0;
                      for( ; !((signed long int)dev_index >= num_new_devs); dev_index = dev_index + 1)
                      {
                        struct libusb_device_descriptor new_dev_desc;
                        signed int fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r;
                        fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r=libusb_get_device_descriptor(new_dev_list[(signed long int)dev_index], &new_dev_desc);
                        if(fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r >= 0)
                        {
                          if((signed int)new_dev_desc.idVendor == 0x45e)
                          {
                            if((signed int)new_dev_desc.idProduct == 0x02ad)
                              tmp_if_expr_12 = (_Bool)1;

                            else
                            {
                              return_value_fnusb_is_pid_k4w_audio_11=fnusb_is_pid_k4w_audio((signed int)desc.idProduct);
                              tmp_if_expr_12 = return_value_fnusb_is_pid_k4w_audio_11 != 0 ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr_12)
                            {
                              fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "Matched VID/PID!\n");
                              struct libusb_device_handle *new_dev_handle;
                              fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r=libusb_open(new_dev_list[(signed long int)dev_index], &new_dev_handle);
                              if(!(fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r >= 0))
                                goto __CPROVER_DUMP_L68;

                              fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r=libusb_get_string_descriptor_ascii(new_dev_handle, new_dev_desc.iSerialNumber, string_desc, 256);
                              if(!(fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r >= 0))
                              {
                                fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "Lost new audio device while fetching serial number.\n");
                                libusb_close(new_dev_handle);
                                goto __CPROVER_DUMP_L68;
                              }

                              unsigned long int return_value_strlen_8;
                              return_value_strlen_8=strlen(audio_serial);
                              if((unsigned long int)fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r == return_value_strlen_8)
                              {
                                return_value_strcmp_9=strcmp((char *)string_desc, audio_serial);
                                tmp_if_expr_10 = return_value_strcmp_9 == 0 ? (_Bool)1 : (_Bool)0;
                              }

                              else
                                tmp_if_expr_10 = (_Bool)0;
                              if(tmp_if_expr_10)
                              {
                                fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r=libusb_claim_interface(new_dev_handle, 0);
                                if(!(fnusb_open_subdevices__1__2__1__2__1__4__6__1__1__1__r == 0))
                                {
                                  fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "Device with serial %s reappeared but couldn't claim interface 0\n", audio_serial);
                                  libusb_close(new_dev_handle);
                                  goto __CPROVER_DUMP_L68;
                                }

                                dev->usb_audio.dev = new_dev_handle;
                                num_interfaces=fnusb_num_interfaces(&dev->usb_audio);
                                if(num_interfaces >= 2)
                                {
                                  if(!(dev->device_does_motor_control_with_audio == 0))
                                    dev->motor_control_with_audio_enabled = 1;

                                }

                                else
                                {
                                  fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "Opened audio with matching serial but too few interfaces.\n");
                                  dev->usb_audio.dev = (struct libusb_device_handle *)(void *)0;
                                  libusb_close(new_dev_handle);
                                  goto __CPROVER_DUMP_L68;
                                }
                                break;
                              }

                              else
                                fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "Got serial %s, expected serial %s\n", (char *)string_desc, audio_serial);
                            }

                          }

                        }


                      __CPROVER_DUMP_L68:
                        ;
                      }
                      libusb_free_device_list(new_dev_list, 1);
                      if(!(dev->usb_audio.dev == ((struct libusb_device_handle *)NULL)))
                        break;

                      sleep((unsigned int)1);
                    }
                    free((void *)audio_serial);
                  }
                }

                else
                  nr_audio = nr_audio + 1;
              }

            }

          }

        }

      }

    }
    libusb_free_device_list(devs, 1);
    if(!(dev->usb_cam.dev == ((struct libusb_device_handle *)NULL)))
      tmp_if_expr_16 = (_Bool)1;

    else
      tmp_if_expr_16 = !(((signed int)fnusb_open_subdevices__1__ctx->enabled_subdevices & FREENECT_DEVICE_CAMERA) != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_16)
    {
      if(!(dev->usb_motor.dev == ((struct libusb_device_handle *)NULL)))
        tmp_if_expr_15 = (_Bool)1;

      else
        tmp_if_expr_15 = !(((signed int)fnusb_open_subdevices__1__ctx->enabled_subdevices & FREENECT_DEVICE_MOTOR) != 0) ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_15)
        goto __CPROVER_DUMP_L80;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L80:
      ;
      if(!(dev->usb_cam.dev == ((struct libusb_device_handle *)NULL)))
      {
        libusb_release_interface(dev->usb_cam.dev, 0);
        libusb_close(dev->usb_cam.dev);
      }

      else
        fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Failed to open camera subdevice or it is not disabled.");
      if(!(dev->usb_motor.dev == ((struct libusb_device_handle *)NULL)))
      {
        libusb_release_interface(dev->usb_motor.dev, 0);
        libusb_close(dev->usb_motor.dev);
      }

      else
        fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Failed to open motor subddevice or it is not disabled.");
      if(!(dev->usb_audio.dev == ((struct libusb_device_handle *)NULL)))
      {
        libusb_release_interface(dev->usb_audio.dev, 0);
        libusb_close(dev->usb_audio.dev);
      }

      else
        fn_log(fnusb_open_subdevices__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Failed to open audio subdevice or it is not disabled.");
      return -1;
    }
  }
}

// fnusb_process_events
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 245
signed int fnusb_process_events(struct anonymous_20 *ctx)
{
  signed int return_value_libusb_handle_events_1;
  return_value_libusb_handle_events_1=libusb_handle_events(ctx->ctx);
  return return_value_libusb_handle_events_1;
}

// fnusb_process_events_timeout
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 83
signed int fnusb_process_events_timeout(struct anonymous_20 *ctx, struct timeval *timeout)
{
  signed int return_value_libusb_handle_events_timeout_1;
  return_value_libusb_handle_events_timeout_1=libusb_handle_events_timeout(ctx->ctx, timeout);
  return return_value_libusb_handle_events_timeout_1;
}

// fnusb_set_led_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 246
signed int fnusb_set_led_alt(struct libusb_device_handle *dev, struct _freenect_context *ctx, enum anonymous_23 state)
{
  if((signed int)state == LED_GREEN)
    state = (enum anonymous_23)3;

  else
    if((signed int)state == LED_RED)
      state = (enum anonymous_23)4;

    else
      if((signed int)state == LED_YELLOW)
        state = (enum anonymous_23)3;

      else
        if((signed int)state == LED_OFF)
          state = (enum anonymous_23)1;

        else
          if((signed int)state == LED_BLINK_GREEN)
            state = (enum anonymous_23)2;

          else
            state = (enum anonymous_23)LED_GREEN;
  struct anonymous_26 cmd;
  cmd.magic = (unsigned int)0x06022009;
  signed int tmp_post_1 = tag_seq;
  tag_seq = tag_seq + 1;
  cmd.tag = (unsigned int)tmp_post_1;
  cmd.arg1 = (unsigned int)0;
  cmd.cmd = (unsigned int)0x10;
  cmd.arg2 = (unsigned int)(signed int)state;
  unsigned char buffer[20l];
  memcpy((void *)buffer, (const void *)&cmd, (unsigned long int)20);
  signed int transferred = 0;
  signed int res;
  res=libusb_bulk_transfer(dev, (unsigned char)0x01, buffer, 20, &transferred, (unsigned int)100);
  if(!(res == 0))
  {
    fn_log(ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "fnusb_set_led_alt(): libusb_bulk_transfer failed: %d (transferred = %d)\n", res, transferred);
    return res;
  }

  else
  {
    signed int return_value_get_reply_2;
    return_value_get_reply_2=get_reply(dev, ctx);
    return return_value_get_reply_2;
  }
}

// fnusb_shutdown
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 81
signed int fnusb_shutdown(struct anonymous_20 *ctx)
{
  if(!(ctx->should_free_ctx == 0))
  {
    libusb_exit(ctx->ctx);
    ctx->ctx = (struct libusb_context *)(void *)0;
  }

  return 0;
}

// fnusb_start_iso
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 88
signed int fnusb_start_iso(struct anonymous_10 *dev, struct anonymous_11 *strm, void (*cb)(struct _freenect_device *, unsigned char *, signed int), unsigned char endpoint, signed int xfers, signed int pkts, signed int len)
{
  struct _freenect_context *fnusb_start_iso__1__ctx = dev->parent->parent;
  strm->parent = dev;
  strm->cb = cb;
  strm->num_xfers = xfers;
  strm->pkts = pkts;
  strm->len = len;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(xfers * pkts * len));
  strm->buffer = (unsigned char *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct libusb_transfer *) /*8ul*/  * (unsigned long int)xfers);
  strm->xfers = (struct libusb_transfer **)return_value_malloc_2;
  strm->dead = 0;
  strm->dead_xfers = 0;
  signed int i;
  unsigned char *bufp = strm->buffer;
  i = 0;
  for( ; !(i >= xfers); i = i + 1)
  {
    fn_log(fnusb_start_iso__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "Creating endpoint %02x transfer #%d\n", endpoint, i);
    strm->xfers[(signed long int)i]=libusb_alloc_transfer(pkts);
    if(strm->xfers[(signed long int)i] == ((struct libusb_transfer *)NULL))
    {
      fn_log(fnusb_start_iso__1__ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "Failed to allocate transfer\n");
      strm->dead_xfers = strm->dead_xfers + 1;
    }

    else
    {
      libusb_fill_iso_transfer(strm->xfers[(signed long int)i], dev->dev, endpoint, bufp, pkts * len, pkts, iso_callback, (void *)strm, (unsigned int)0);
      libusb_set_iso_packet_lengths(strm->xfers[(signed long int)i], (unsigned int)len);
      signed int ret;
      ret=libusb_submit_transfer(strm->xfers[(signed long int)i]);
      if(!(ret >= 0))
      {
        fn_log(fnusb_start_iso__1__ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "Failed to submit isochronous transfer %d: %d\n", i, ret);
        strm->dead_xfers = strm->dead_xfers + 1;
      }

    }
    bufp = bufp + (signed long int)(pkts * len);
  }
  return 0;
}

// fnusb_stop_iso
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.h line 89
signed int fnusb_stop_iso(struct anonymous_10 *dev, struct anonymous_11 *strm)
{
  struct _freenect_context *fnusb_stop_iso__1__ctx = dev->parent->parent;
  signed int i;
  fn_log(fnusb_stop_iso__1__ctx, (enum anonymous_21)FREENECT_LOG_FLOOD, "fnusb_stop_iso() called\n");
  strm->dead = 1;
  i = 0;
  for( ; !(i >= strm->num_xfers); i = i + 1)
    libusb_cancel_transfer(strm->xfers[(signed long int)i]);
  fn_log(fnusb_stop_iso__1__ctx, (enum anonymous_21)FREENECT_LOG_FLOOD, "fnusb_stop_iso() cancelled all transfers\n");
  while(!(strm->dead_xfers >= strm->num_xfers))
  {
    fn_log(fnusb_stop_iso__1__ctx, (enum anonymous_21)FREENECT_LOG_FLOOD, "fnusb_stop_iso() dead = %d\tnum = %d\n", strm->dead_xfers, strm->num_xfers);
    libusb_handle_events(fnusb_stop_iso__1__ctx->usb.ctx);
  }
  i = 0;
  for( ; !(i >= strm->num_xfers); i = i + 1)
    libusb_free_transfer(strm->xfers[(signed long int)i]);
  fn_log(fnusb_stop_iso__1__ctx, (enum anonymous_21)FREENECT_LOG_FLOOD, "fnusb_stop_iso() freed all transfers\n");
  free((void *)strm->buffer);
  free((void *)strm->xfers);
  fn_log(fnusb_stop_iso__1__ctx, (enum anonymous_21)FREENECT_LOG_FLOOD, "fnusb_stop_iso() freed buffers and stream\n");
  fn_log(fnusb_stop_iso__1__ctx, (enum anonymous_21)FREENECT_LOG_FLOOD, "fnusb_stop_iso() done\n");
  return 0;
}

// free_buffer_ring
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 121
static void free_buffer_ring(struct buffer_ring *buf)
{
  signed int i = 0;
  for( ; !(i >= 3); i = i + 1)
  {
    free(buf->bufs[(signed long int)i]);
    buf->bufs[(signed long int)i] = (void *)0;
  }
  buf->timestamp = (unsigned int)0;
  buf->valid = 0;
  buf->fmt = -1;
  buf->res = -1;
}

// freenect_apply_depth_to_mm
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.h line 34
signed int freenect_apply_depth_to_mm(struct _freenect_device *dev, unsigned char *input_packed, unsigned short int *output_mm)
{
  struct anonymous_15 *reg = &dev->registration;
  unsigned short int unpack[8l];
  unsigned int x;
  unsigned int y;
  unsigned int source_index = (unsigned int)8;
  y = (unsigned int)0;
  unsigned int tmp_post_1;
  for( ; !(y >= 480u); y = y + 1u)
  {
    x = (unsigned int)0;
    for( ; !(x >= 640u); x = x + 1u)
    {
      if(source_index == 8u)
      {
        unpack_8_pixels(input_packed, unpack);
        source_index = (unsigned int)0;
        input_packed = input_packed + (signed long int)11;
      }

      unsigned short int metric_depth;
      tmp_post_1 = source_index;
      source_index = source_index + 1u;
      metric_depth = reg->raw_to_mm_shift[(signed long int)unpack[(signed long int)tmp_post_1]];
      output_mm[(signed long int)(y * (unsigned int)640 + x)] = (unsigned short int)((signed int)metric_depth < 10000 ? (signed int)metric_depth : 10000);
    }
  }
  return 0;
}

// freenect_apply_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.h line 33
signed int freenect_apply_registration(struct _freenect_device *dev, unsigned char *input_packed, unsigned short int *output_mm)
{
  struct anonymous_15 *reg = &dev->registration;
  unsigned long int i;
  unsigned long int *wipe = (unsigned long int *)output_mm;
  i = (unsigned long int)0;
  for( ; !(i >= 76800ul); i = i + 1ul)
    wipe[(signed long int)i] = (unsigned long int)0;
  unsigned short int unpack[8l];
  unsigned int target_offset = (unsigned int)(480 * (signed int)reg->reg_pad_info.start_lines);
  unsigned int x;
  unsigned int y;
  unsigned int source_index = (unsigned int)8;
  y = (unsigned int)0;
  unsigned int tmp_post_1;
  for( ; !(y >= 480u); y = y + 1u)
  {
    x = (unsigned int)0;
    for( ; !(x >= 640u); x = x + 1u)
    {
      if(source_index == 8u)
      {
        unpack_8_pixels(input_packed, unpack);
        source_index = (unsigned int)0;
        input_packed = input_packed + (signed long int)11;
      }

      unsigned short int metric_depth;
      tmp_post_1 = source_index;
      source_index = source_index + 1u;
      metric_depth = reg->raw_to_mm_shift[(signed long int)unpack[(signed long int)tmp_post_1]];
      if(!((signed int)metric_depth == 0))
      {
        if(!((signed int)metric_depth >= 10000))
        {
          unsigned int reg_index = 0 != 0 ? ((y + (unsigned int)1) * (unsigned int)640 - x) - (unsigned int)1 : y * (unsigned int)640 + x;
          unsigned int nx = (unsigned int)((reg->registration_table[(signed long int)reg_index][(signed long int)0] + reg->depth_to_rgb_shift[(signed long int)metric_depth]) / 256);
          unsigned int ny = (unsigned int)reg->registration_table[(signed long int)reg_index][(signed long int)1];
          if(!(nx >= 640u))
          {
            unsigned int target_index = (0 != 0 ? ((ny + (unsigned int)1) * (unsigned int)640 - nx) - (unsigned int)1 : ny * (unsigned int)640 + nx) - target_offset;
            unsigned short int current_depth = output_mm[(signed long int)target_index];
            if((signed int)current_depth == 0 || !((signed int)metric_depth >= (signed int)current_depth))
              output_mm[(signed long int)target_index] = metric_depth;

          }

        }

      }

    }
  }
  return 0;
}

// freenect_camera_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.h line 35
signed int freenect_camera_init(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_camera_init__1__ctx = dev->parent;
  signed int res;
  res=freenect_fetch_reg_pad_info(dev);
  if(!(res >= 0))
  {
    fn_log(freenect_camera_init__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_camera_init(): Failed to fetch registration pad info for device\n");
    return res;
  }

  else
  {
    res=freenect_fetch_zero_plane_info(dev);
    if(!(res >= 0))
    {
      fn_log(freenect_camera_init__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_camera_init(): Failed to fetch zero plane info for device\n");
      return res;
    }

    else
    {
      struct anonymous_6 return_value_freenect_find_video_mode_1;
      return_value_freenect_find_video_mode_1=freenect_find_video_mode((enum anonymous_13)FREENECT_RESOLUTION_MEDIUM, (enum anonymous_4)FREENECT_VIDEO_RGB);
      res=freenect_set_video_mode(dev, return_value_freenect_find_video_mode_1);
      struct anonymous_6 return_value_freenect_find_depth_mode_2;
      return_value_freenect_find_depth_mode_2=freenect_find_depth_mode((enum anonymous_13)FREENECT_RESOLUTION_MEDIUM, (enum anonymous_5)FREENECT_DEPTH_11BIT);
      res=freenect_set_depth_mode(dev, return_value_freenect_find_depth_mode_2);
      res=freenect_fetch_reg_const_shift(dev);
      if(!(res >= 0))
      {
        fn_log(freenect_camera_init__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_camera_init(): Failed to fetch const shift for device\n");
        return res;
      }

      else
        return 0;
    }
  }
}

// freenect_camera_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.h line 36
signed int freenect_camera_teardown(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_camera_teardown__1__ctx = dev->parent;
  signed int res = 0;
  if(!(dev->depth.running == 0))
  {
    res=freenect_stop_depth(dev);
    if(!(res >= 0))
      fn_log(freenect_camera_teardown__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_camera_teardown(): Failed to stop depth camera\n");

    return res;
  }

  else
    if(!(dev->video.running == 0))
    {
      res=freenect_stop_video(dev);
      if(!(res >= 0))
        fn_log(freenect_camera_teardown__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_camera_teardown(): Failed to stop video camera\n");

      return res;
    }

    else
    {
      freenect_destroy_registration(&dev->registration);
      return 0;
    }
}

// freenect_camera_to_world
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_registration.h line 120
void freenect_camera_to_world(struct _freenect_device *dev, signed int cx, signed int cy, signed int wz, double *wx, double *wy)
{
  double ref_pix_size = (double)dev->registration.zero_plane_info.reference_pixel_size;
  double ref_distance = (double)dev->registration.zero_plane_info.reference_distance;
  double factor = ((double)2 * ref_pix_size * (double)wz) / ref_distance;
  *wx = (double)(cx - 640 / 2) * factor;
  *wy = (double)(cy - 480 / 2) * factor;
}

// freenect_close_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 365
signed int freenect_close_device(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_close_device__1__ctx = dev->parent;
  signed int res;
  if(!(dev->usb_cam.dev == ((struct libusb_device_handle *)NULL)))
    freenect_camera_teardown(dev);

  res=fnusb_close_subdevices(dev);
  if(!(res >= 0))
  {
    fn_log(freenect_close_device__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "fnusb_close_subdevices failed: %d\n", res);
    return res;
  }

  else
  {
    struct _freenect_device *last = (struct _freenect_device *)(void *)0;
    struct _freenect_device *cur = freenect_close_device__1__ctx->first;
    for( ; !(cur == ((struct _freenect_device *)NULL)) && !(cur == dev); cur = cur->next)
      last = cur;
    if(cur == ((struct _freenect_device *)NULL))
    {
      fn_log(freenect_close_device__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "device %p not found in linked list for this context!\n", dev);
      return -1;
    }

    else
    {
      if(!(last == ((struct _freenect_device *)NULL)))
        last->next = cur->next;

      else
        freenect_close_device__1__ctx->first = cur->next;
      free((void *)dev);
      return 0;
    }
  }
}

// freenect_copy_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 420
struct anonymous_15 freenect_copy_registration(struct _freenect_device *dev)
{
  struct anonymous_15 retval;
  retval.reg_info = dev->registration.reg_info;
  retval.reg_pad_info = dev->registration.reg_pad_info;
  retval.zero_plane_info = dev->registration.zero_plane_info;
  retval.const_shift = dev->registration.const_shift;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(unsigned short int) /*2ul*/  * (unsigned long int)2048);
  retval.raw_to_mm_shift = (unsigned short int *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)10000);
  retval.depth_to_rgb_shift = (signed int *)return_value_malloc_2;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)640 * (unsigned long int)480 * (unsigned long int)2);
  retval.registration_table = (signed int (*)[2l])return_value_malloc_3;
  complete_tables(&retval);
  return retval;
}

// freenect_create_dxdy_tables
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 194
static void freenect_create_dxdy_tables(double *reg_x_table, double *reg_y_table, signed int resolution_x, signed int resolution_y, struct anonymous_25 *regdata)
{
  signed long int AX6 = (signed long int)regdata->ax;
  signed long int BX6 = (signed long int)regdata->bx;
  signed long int CX2 = (signed long int)regdata->cx;
  signed long int DX2 = (signed long int)regdata->dx;
  signed long int AY6 = (signed long int)regdata->ay;
  signed long int BY6 = (signed long int)regdata->by;
  signed long int CY2 = (signed long int)regdata->cy;
  signed long int DY2 = (signed long int)regdata->dy;
  signed long int dX0 = (signed long int)((regdata->dx_start << 13) >> 4);
  signed long int dY0 = (signed long int)((regdata->dy_start << 13) >> 4);
  signed long int dXdX0 = (signed long int)((regdata->dxdx_start << 11) >> 3);
  signed long int dXdY0 = (signed long int)((regdata->dxdy_start << 11) >> 3);
  signed long int dYdX0 = (signed long int)((regdata->dydx_start << 11) >> 3);
  signed long int dYdY0 = (signed long int)((regdata->dydy_start << 11) >> 3);
  signed long int dXdXdX0 = (signed long int)((regdata->dxdxdx_start << 5) << 3);
  signed long int dYdXdX0 = (signed long int)((regdata->dydxdx_start << 5) << 3);
  signed long int dYdXdY0 = (signed long int)((regdata->dydxdy_start << 5) << 3);
  signed long int dXdXdY0 = (signed long int)((regdata->dxdxdy_start << 5) << 3);
  signed long int dYdYdX0 = (signed long int)((regdata->dydydx_start << 5) << 3);
  signed long int dYdYdY0 = (signed long int)((regdata->dydydy_start << 5) << 3);
  signed int row;
  signed int col;
  signed int tOffs = 0;
  row = 0;
  for( ; !(row >= resolution_y); row = row + 1)
  {
    dXdXdX0 = dXdXdX0 + CX2;
    dXdX0 = dXdX0 + (dYdXdX0 >> 8);
    dYdXdX0 = dYdXdX0 + DX2;
    dX0 = dX0 + (dYdX0 >> 6);
    dYdX0 = dYdX0 + (dYdYdX0 >> 8);
    dYdYdX0 = dYdYdX0 + BX6;
    dXdXdY0 = dXdXdY0 + CY2;
    dXdY0 = dXdY0 + (dYdXdY0 >> 8);
    dYdXdY0 = dYdXdY0 + DY2;
    dY0 = dY0 + (dYdY0 >> 6);
    dYdY0 = dYdY0 + (dYdYdY0 >> 8);
    dYdYdY0 = dYdYdY0 + BY6;
    signed long int coldXdXdY0 = dXdXdY0;
    signed long int coldXdY0 = dXdY0;
    signed long int coldY0 = dY0;
    signed long int coldXdXdX0 = dXdXdX0;
    signed long int coldXdX0 = dXdX0;
    signed long int coldX0 = dX0;
    col = 0;
    for( ; !(col >= resolution_x); tOffs = tOffs + 1)
    {
      reg_x_table[(signed long int)tOffs] = (double)coldX0 * (1.0 / (double)(1 << 17));
      reg_y_table[(signed long int)tOffs] = (double)coldY0 * (1.0 / (double)(1 << 17));
      coldX0 = coldX0 + (coldXdX0 >> 6);
      coldXdX0 = coldXdX0 + (coldXdXdX0 >> 8);
      coldXdXdX0 = coldXdXdX0 + AX6;
      coldY0 = coldY0 + (coldXdY0 >> 6);
      coldXdY0 = coldXdY0 + (coldXdXdY0 >> 8);
      coldXdXdY0 = coldXdXdY0 + AY6;
      col = col + 1;
    }
  }
}

// freenect_create_dxdy_tables_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 194
static void freenect_create_dxdy_tables_link1(double *reg_x_table_link1, double *reg_y_table_link1, signed int resolution_x_link1, signed int resolution_y_link1, struct anonymous_25 *regdata_link1)
{
  signed long int AX6_link1 = (signed long int)regdata_link1->ax;
  signed long int BX6_link1 = (signed long int)regdata_link1->bx;
  signed long int CX2_link1 = (signed long int)regdata_link1->cx;
  signed long int DX2_link1 = (signed long int)regdata_link1->dx;
  signed long int AY6_link1 = (signed long int)regdata_link1->ay;
  signed long int BY6_link1 = (signed long int)regdata_link1->by;
  signed long int CY2_link1 = (signed long int)regdata_link1->cy;
  signed long int DY2_link1 = (signed long int)regdata_link1->dy;
  signed long int dX0_link1 = (signed long int)((regdata_link1->dx_start << 13) >> 4);
  signed long int dY0_link1 = (signed long int)((regdata_link1->dy_start << 13) >> 4);
  signed long int dXdX0_link1 = (signed long int)((regdata_link1->dxdx_start << 11) >> 3);
  signed long int dXdY0_link1 = (signed long int)((regdata_link1->dxdy_start << 11) >> 3);
  signed long int dYdX0_link1 = (signed long int)((regdata_link1->dydx_start << 11) >> 3);
  signed long int dYdY0_link1 = (signed long int)((regdata_link1->dydy_start << 11) >> 3);
  signed long int dXdXdX0_link1 = (signed long int)((regdata_link1->dxdxdx_start << 5) << 3);
  signed long int dYdXdX0_link1 = (signed long int)((regdata_link1->dydxdx_start << 5) << 3);
  signed long int dYdXdY0_link1 = (signed long int)((regdata_link1->dydxdy_start << 5) << 3);
  signed long int dXdXdY0_link1 = (signed long int)((regdata_link1->dxdxdy_start << 5) << 3);
  signed long int dYdYdX0_link1 = (signed long int)((regdata_link1->dydydx_start << 5) << 3);
  signed long int dYdYdY0_link1 = (signed long int)((regdata_link1->dydydy_start << 5) << 3);
  signed int row_link1;
  signed int col_link1;
  signed int tOffs_link1 = 0;
  row_link1 = 0;
  for( ; !(row_link1 >= resolution_y_link1); row_link1 = row_link1 + 1)
  {
    dXdXdX0_link1 = dXdXdX0_link1 + CX2_link1;
    dXdX0_link1 = dXdX0_link1 + (dYdXdX0_link1 >> 8);
    dYdXdX0_link1 = dYdXdX0_link1 + DX2_link1;
    dX0_link1 = dX0_link1 + (dYdX0_link1 >> 6);
    dYdX0_link1 = dYdX0_link1 + (dYdYdX0_link1 >> 8);
    dYdYdX0_link1 = dYdYdX0_link1 + BX6_link1;
    dXdXdY0_link1 = dXdXdY0_link1 + CY2_link1;
    dXdY0_link1 = dXdY0_link1 + (dYdXdY0_link1 >> 8);
    dYdXdY0_link1 = dYdXdY0_link1 + DY2_link1;
    dY0_link1 = dY0_link1 + (dYdY0_link1 >> 6);
    dYdY0_link1 = dYdY0_link1 + (dYdYdY0_link1 >> 8);
    dYdYdY0_link1 = dYdYdY0_link1 + BY6_link1;
    signed long int coldXdXdY0_link1 = dXdXdY0_link1;
    signed long int coldXdY0_link1 = dXdY0_link1;
    signed long int coldY0_link1 = dY0_link1;
    signed long int coldXdXdX0_link1 = dXdXdX0_link1;
    signed long int coldXdX0_link1 = dXdX0_link1;
    signed long int coldX0_link1 = dX0_link1;
    col_link1 = 0;
    for( ; !(col_link1 >= resolution_x_link1); tOffs_link1 = tOffs_link1 + 1)
    {
      reg_x_table_link1[(signed long int)tOffs_link1] = (double)coldX0_link1 * (1.0 / (double)(1 << 17));
      reg_y_table_link1[(signed long int)tOffs_link1] = (double)coldY0_link1 * (1.0 / (double)(1 << 17));
      coldX0_link1 = coldX0_link1 + (coldXdX0_link1 >> 6);
      coldXdX0_link1 = coldXdX0_link1 + (coldXdXdX0_link1 >> 8);
      coldXdXdX0_link1 = coldXdXdX0_link1 + AX6_link1;
      coldY0_link1 = coldY0_link1 + (coldXdY0_link1 >> 6);
      coldXdY0_link1 = coldXdY0_link1 + (coldXdXdY0_link1 >> 8);
      coldXdXdY0_link1 = coldXdXdY0_link1 + AY6_link1;
      col_link1 = col_link1 + 1;
    }
  }
}

// freenect_destroy_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_registration.h line 116
signed int freenect_destroy_registration(struct anonymous_15 *reg)
{
  if(!(reg->raw_to_mm_shift == ((unsigned short int *)NULL)))
  {
    free((void *)reg->raw_to_mm_shift);
    reg->raw_to_mm_shift = (unsigned short int *)(void *)0;
  }

  if(!(reg->depth_to_rgb_shift == ((signed int *)NULL)))
  {
    free((void *)reg->depth_to_rgb_shift);
    reg->depth_to_rgb_shift = (signed int *)(void *)0;
  }

  if(!(reg->registration_table == ((signed int (*)[2l])NULL)))
  {
    free((void *)reg->registration_table);
    reg->registration_table = (signed int (*)[2l])(void *)0;
  }

  return 0;
}

// freenect_enabled_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 138
enum anonymous_22 freenect_enabled_subdevices(struct _freenect_context *ctx)
{
  return ctx->enabled_subdevices;
}

// freenect_fetch_reg_const_shift
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 769
static signed int freenect_fetch_reg_const_shift(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_fetch_reg_const_shift__1__ctx = dev->parent;
  char reply[512l];
  unsigned short int cmd[5l];
  struct anonymous_6 mode;
  mode=freenect_get_current_video_mode(dev);
  cmd[(signed long int)0] = (unsigned short int)0x00;
  cmd[(signed long int)1] = (unsigned short int)0;
  cmd[(signed long int)2] = (unsigned short int)mode.resolution;
  cmd[(signed long int)3] = (unsigned short int)mode.framerate;
  cmd[(signed long int)4] = (unsigned short int)0;
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x16, (void *)cmd, (unsigned int)10, (void *)reply, 4);
  if(!(res == 4))
  {
    fn_log(freenect_fetch_reg_const_shift__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_fetch_reg_const_shift: send_cmd read %d bytes (expected 8)\n", res);
    return -1;
  }

  else
  {
    unsigned short int shift;
    memcpy((void *)&shift, (const void *)(reply + (signed long int)2), sizeof(unsigned short int) /*2ul*/ );
    shift = shift;
    dev->registration.const_shift = (double)shift;
    fn_log(freenect_fetch_reg_const_shift__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "const_shift: %f\n", dev->registration.const_shift);
    return 0;
  }
}

// freenect_fetch_reg_const_shift_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 769
static signed int freenect_fetch_reg_const_shift_link1(struct _freenect_device *dev_link1)
{
  struct _freenect_context *ctx_link1 = dev_link1->parent;
  char reply_link1[512l];
  unsigned short int cmd_link1[5l];
  struct anonymous_6 mode_link1;
  mode_link1=freenect_get_current_video_mode(dev_link1);
  cmd_link1[(signed long int)0] = (unsigned short int)0x00;
  cmd_link1[(signed long int)1] = (unsigned short int)0;
  cmd_link1[(signed long int)2] = (unsigned short int)mode_link1.resolution;
  cmd_link1[(signed long int)3] = (unsigned short int)mode_link1.framerate;
  cmd_link1[(signed long int)4] = (unsigned short int)0;
  signed int res_link1;
  res_link1=send_cmd(dev_link1, (unsigned short int)0x16, (void *)cmd_link1, (unsigned int)10, (void *)reply_link1, 4);
  if(!(res_link1 == 4))
  {
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_fetch_reg_const_shift: send_cmd read %d bytes (expected 8)\n", res_link1);
    return -1;
  }

  else
  {
    unsigned short int shift_link1;
    memcpy((void *)&shift_link1, (const void *)(reply_link1 + (signed long int)2), sizeof(unsigned short int) /*2ul*/ );
    shift_link1 = shift_link1;
    dev_link1->registration.const_shift = (double)shift_link1;
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "const_shift: %f\n", dev_link1->registration.const_shift);
    return 0;
  }
}

// freenect_fetch_reg_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 664
static signed int freenect_fetch_reg_info(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_fetch_reg_info__1__ctx = dev->parent;
  char reply[512l];
  unsigned short int cmd[5l];
  struct anonymous_6 mode;
  mode=freenect_get_current_video_mode(dev);
  cmd[(signed long int)0] = (unsigned short int)0x40;
  cmd[(signed long int)1] = (unsigned short int)0;
  cmd[(signed long int)2] = (unsigned short int)mode.resolution;
  cmd[(signed long int)3] = (unsigned short int)mode.framerate;
  cmd[(signed long int)4] = (unsigned short int)0;
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x16, (void *)cmd, (unsigned int)10, (void *)reply, 118);
  if(!(res == 118))
  {
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_fetch_reg_info: send_cmd read %d bytes (expected 118)\n", res);
    return -1;
  }

  else
  {
    memcpy((void *)&dev->registration.reg_info, (const void *)(reply + (signed long int)2), sizeof(struct anonymous_25) /*116ul*/ );
    dev->registration.reg_info.ax = dev->registration.reg_info.ax;
    dev->registration.reg_info.bx = dev->registration.reg_info.bx;
    dev->registration.reg_info.cx = dev->registration.reg_info.cx;
    dev->registration.reg_info.dx = dev->registration.reg_info.dx;
    dev->registration.reg_info.ay = dev->registration.reg_info.ay;
    dev->registration.reg_info.by = dev->registration.reg_info.by;
    dev->registration.reg_info.cy = dev->registration.reg_info.cy;
    dev->registration.reg_info.dy = dev->registration.reg_info.dy;
    dev->registration.reg_info.dx_start = dev->registration.reg_info.dx_start;
    dev->registration.reg_info.dy_start = dev->registration.reg_info.dy_start;
    dev->registration.reg_info.dx_beta_start = dev->registration.reg_info.dx_beta_start;
    dev->registration.reg_info.dy_beta_start = dev->registration.reg_info.dy_beta_start;
    dev->registration.reg_info.dx_beta_inc = dev->registration.reg_info.dx_beta_inc;
    dev->registration.reg_info.dy_beta_inc = dev->registration.reg_info.dy_beta_inc;
    dev->registration.reg_info.dxdx_start = dev->registration.reg_info.dxdx_start;
    dev->registration.reg_info.dxdy_start = dev->registration.reg_info.dxdy_start;
    dev->registration.reg_info.dydx_start = dev->registration.reg_info.dydx_start;
    dev->registration.reg_info.dydy_start = dev->registration.reg_info.dydy_start;
    dev->registration.reg_info.dxdxdx_start = dev->registration.reg_info.dxdxdx_start;
    dev->registration.reg_info.dydxdx_start = dev->registration.reg_info.dydxdx_start;
    dev->registration.reg_info.dxdxdy_start = dev->registration.reg_info.dxdxdy_start;
    dev->registration.reg_info.dydxdy_start = dev->registration.reg_info.dydxdy_start;
    dev->registration.reg_info.dydydx_start = dev->registration.reg_info.dydydx_start;
    dev->registration.reg_info.dydydy_start = dev->registration.reg_info.dydydy_start;
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "ax:                %d\n", dev->registration.reg_info.ax);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "bx:                %d\n", dev->registration.reg_info.bx);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "cx:                %d\n", dev->registration.reg_info.cx);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dx:                %d\n", dev->registration.reg_info.dx);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "ay:                %d\n", dev->registration.reg_info.ay);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "by:                %d\n", dev->registration.reg_info.by);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "cy:                %d\n", dev->registration.reg_info.cy);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dy:                %d\n", dev->registration.reg_info.dy);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dx_start:          %d\n", dev->registration.reg_info.dx_start);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dy_start:          %d\n", dev->registration.reg_info.dy_start);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dx_beta_start:     %d\n", dev->registration.reg_info.dx_beta_start);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dy_beta_start:     %d\n", dev->registration.reg_info.dy_beta_start);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dx_beta_inc:       %d\n", dev->registration.reg_info.dx_beta_inc);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dy_beta_inc:       %d\n", dev->registration.reg_info.dy_beta_inc);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dxdx_start:        %d\n", dev->registration.reg_info.dxdx_start);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dxdy_start:        %d\n", dev->registration.reg_info.dxdy_start);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dydx_start:        %d\n", dev->registration.reg_info.dydx_start);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dydy_start:        %d\n", dev->registration.reg_info.dydy_start);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dxdxdx_start:      %d\n", dev->registration.reg_info.dxdxdx_start);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dydxdx_start:      %d\n", dev->registration.reg_info.dydxdx_start);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dxdxdy_start:      %d\n", dev->registration.reg_info.dxdxdy_start);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dydxdy_start:      %d\n", dev->registration.reg_info.dydxdy_start);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dydydx_start:      %d\n", dev->registration.reg_info.dydydx_start);
    fn_log(freenect_fetch_reg_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dydydy_start:      %d\n", dev->registration.reg_info.dydydy_start);
    return 0;
  }
}

// freenect_fetch_reg_info_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 664
static signed int freenect_fetch_reg_info_link1(struct _freenect_device *dev_link1)
{
  struct _freenect_context *ctx_link1 = dev_link1->parent;
  char reply_link1[512l];
  unsigned short int cmd_link1[5l];
  struct anonymous_6 mode_link1;
  mode_link1=freenect_get_current_video_mode(dev_link1);
  cmd_link1[(signed long int)0] = (unsigned short int)0x40;
  cmd_link1[(signed long int)1] = (unsigned short int)0;
  cmd_link1[(signed long int)2] = (unsigned short int)mode_link1.resolution;
  cmd_link1[(signed long int)3] = (unsigned short int)mode_link1.framerate;
  cmd_link1[(signed long int)4] = (unsigned short int)0;
  signed int res_link1;
  res_link1=send_cmd(dev_link1, (unsigned short int)0x16, (void *)cmd_link1, (unsigned int)10, (void *)reply_link1, 118);
  if(!(res_link1 == 118))
  {
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_fetch_reg_info: send_cmd read %d bytes (expected 118)\n", res_link1);
    return -1;
  }

  else
  {
    memcpy((void *)&dev_link1->registration.reg_info, (const void *)(reply_link1 + (signed long int)2), sizeof(struct anonymous_25) /*116ul*/ );
    dev_link1->registration.reg_info.ax = dev_link1->registration.reg_info.ax;
    dev_link1->registration.reg_info.bx = dev_link1->registration.reg_info.bx;
    dev_link1->registration.reg_info.cx = dev_link1->registration.reg_info.cx;
    dev_link1->registration.reg_info.dx = dev_link1->registration.reg_info.dx;
    dev_link1->registration.reg_info.ay = dev_link1->registration.reg_info.ay;
    dev_link1->registration.reg_info.by = dev_link1->registration.reg_info.by;
    dev_link1->registration.reg_info.cy = dev_link1->registration.reg_info.cy;
    dev_link1->registration.reg_info.dy = dev_link1->registration.reg_info.dy;
    dev_link1->registration.reg_info.dx_start = dev_link1->registration.reg_info.dx_start;
    dev_link1->registration.reg_info.dy_start = dev_link1->registration.reg_info.dy_start;
    dev_link1->registration.reg_info.dx_beta_start = dev_link1->registration.reg_info.dx_beta_start;
    dev_link1->registration.reg_info.dy_beta_start = dev_link1->registration.reg_info.dy_beta_start;
    dev_link1->registration.reg_info.dx_beta_inc = dev_link1->registration.reg_info.dx_beta_inc;
    dev_link1->registration.reg_info.dy_beta_inc = dev_link1->registration.reg_info.dy_beta_inc;
    dev_link1->registration.reg_info.dxdx_start = dev_link1->registration.reg_info.dxdx_start;
    dev_link1->registration.reg_info.dxdy_start = dev_link1->registration.reg_info.dxdy_start;
    dev_link1->registration.reg_info.dydx_start = dev_link1->registration.reg_info.dydx_start;
    dev_link1->registration.reg_info.dydy_start = dev_link1->registration.reg_info.dydy_start;
    dev_link1->registration.reg_info.dxdxdx_start = dev_link1->registration.reg_info.dxdxdx_start;
    dev_link1->registration.reg_info.dydxdx_start = dev_link1->registration.reg_info.dydxdx_start;
    dev_link1->registration.reg_info.dxdxdy_start = dev_link1->registration.reg_info.dxdxdy_start;
    dev_link1->registration.reg_info.dydxdy_start = dev_link1->registration.reg_info.dydxdy_start;
    dev_link1->registration.reg_info.dydydx_start = dev_link1->registration.reg_info.dydydx_start;
    dev_link1->registration.reg_info.dydydy_start = dev_link1->registration.reg_info.dydydy_start;
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "ax:                %d\n", dev_link1->registration.reg_info.ax);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "bx:                %d\n", dev_link1->registration.reg_info.bx);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "cx:                %d\n", dev_link1->registration.reg_info.cx);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dx:                %d\n", dev_link1->registration.reg_info.dx);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "ay:                %d\n", dev_link1->registration.reg_info.ay);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "by:                %d\n", dev_link1->registration.reg_info.by);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "cy:                %d\n", dev_link1->registration.reg_info.cy);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dy:                %d\n", dev_link1->registration.reg_info.dy);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dx_start:          %d\n", dev_link1->registration.reg_info.dx_start);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dy_start:          %d\n", dev_link1->registration.reg_info.dy_start);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dx_beta_start:     %d\n", dev_link1->registration.reg_info.dx_beta_start);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dy_beta_start:     %d\n", dev_link1->registration.reg_info.dy_beta_start);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dx_beta_inc:       %d\n", dev_link1->registration.reg_info.dx_beta_inc);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dy_beta_inc:       %d\n", dev_link1->registration.reg_info.dy_beta_inc);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dxdx_start:        %d\n", dev_link1->registration.reg_info.dxdx_start);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dxdy_start:        %d\n", dev_link1->registration.reg_info.dxdy_start);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dydx_start:        %d\n", dev_link1->registration.reg_info.dydx_start);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dydy_start:        %d\n", dev_link1->registration.reg_info.dydy_start);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dxdxdx_start:      %d\n", dev_link1->registration.reg_info.dxdxdx_start);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dydxdx_start:      %d\n", dev_link1->registration.reg_info.dydxdx_start);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dxdxdy_start:      %d\n", dev_link1->registration.reg_info.dxdxdy_start);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dydxdy_start:      %d\n", dev_link1->registration.reg_info.dydxdy_start);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dydydx_start:      %d\n", dev_link1->registration.reg_info.dydydx_start);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dydydy_start:      %d\n", dev_link1->registration.reg_info.dydydy_start);
    return 0;
  }
}

// freenect_fetch_reg_pad_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 742
static signed int freenect_fetch_reg_pad_info(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_fetch_reg_pad_info__1__ctx = dev->parent;
  char reply[512l];
  unsigned short int cmd[5l];
  struct anonymous_6 mode;
  mode=freenect_get_current_video_mode(dev);
  cmd[(signed long int)0] = (unsigned short int)0x41;
  cmd[(signed long int)1] = (unsigned short int)0;
  cmd[(signed long int)2] = (unsigned short int)mode.resolution;
  cmd[(signed long int)3] = (unsigned short int)mode.framerate;
  cmd[(signed long int)4] = (unsigned short int)0;
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x16, (void *)cmd, (unsigned int)10, (void *)reply, 8);
  if(!(res == 8))
  {
    fn_log(freenect_fetch_reg_pad_info__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_fetch_reg_pad_info: send_cmd read %d bytes (expected 8)\n", res);
    return -1;
  }

  else
  {
    memcpy((void *)&dev->registration.reg_pad_info, (const void *)(reply + (signed long int)2), sizeof(struct anonymous_24) /*6ul*/ );
    dev->registration.reg_pad_info.start_lines = dev->registration.reg_pad_info.start_lines;
    dev->registration.reg_pad_info.end_lines = dev->registration.reg_pad_info.end_lines;
    dev->registration.reg_pad_info.cropping_lines = dev->registration.reg_pad_info.cropping_lines;
    fn_log(freenect_fetch_reg_pad_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "start_lines:    %u\n", dev->registration.reg_pad_info.start_lines);
    fn_log(freenect_fetch_reg_pad_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "end_lines:      %u\n", dev->registration.reg_pad_info.end_lines);
    fn_log(freenect_fetch_reg_pad_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "cropping_lines: %u\n", dev->registration.reg_pad_info.cropping_lines);
    return 0;
  }
}

// freenect_fetch_reg_pad_info_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 742
static signed int freenect_fetch_reg_pad_info_link1(struct _freenect_device *dev_link1)
{
  struct _freenect_context *ctx_link1 = dev_link1->parent;
  char reply_link1[512l];
  unsigned short int cmd_link1[5l];
  struct anonymous_6 mode_link1;
  mode_link1=freenect_get_current_video_mode(dev_link1);
  cmd_link1[(signed long int)0] = (unsigned short int)0x41;
  cmd_link1[(signed long int)1] = (unsigned short int)0;
  cmd_link1[(signed long int)2] = (unsigned short int)mode_link1.resolution;
  cmd_link1[(signed long int)3] = (unsigned short int)mode_link1.framerate;
  cmd_link1[(signed long int)4] = (unsigned short int)0;
  signed int res_link1;
  res_link1=send_cmd(dev_link1, (unsigned short int)0x16, (void *)cmd_link1, (unsigned int)10, (void *)reply_link1, 8);
  if(!(res_link1 == 8))
  {
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_fetch_reg_pad_info: send_cmd read %d bytes (expected 8)\n", res_link1);
    return -1;
  }

  else
  {
    memcpy((void *)&dev_link1->registration.reg_pad_info, (const void *)(reply_link1 + (signed long int)2), sizeof(struct anonymous_24) /*6ul*/ );
    dev_link1->registration.reg_pad_info.start_lines = dev_link1->registration.reg_pad_info.start_lines;
    dev_link1->registration.reg_pad_info.end_lines = dev_link1->registration.reg_pad_info.end_lines;
    dev_link1->registration.reg_pad_info.cropping_lines = dev_link1->registration.reg_pad_info.cropping_lines;
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "start_lines:    %u\n", dev_link1->registration.reg_pad_info.start_lines);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "end_lines:      %u\n", dev_link1->registration.reg_pad_info.end_lines);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "cropping_lines: %u\n", dev_link1->registration.reg_pad_info.cropping_lines);
    return 0;
  }
}

// freenect_fetch_zero_plane_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 794
static signed int freenect_fetch_zero_plane_info(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_fetch_zero_plane_info__1__ctx = dev->parent;
  char reply[512l];
  unsigned short int cmd[5l] = { (unsigned short int)0, 0, 0, 0, 0 };
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x04, (void *)cmd, (unsigned int)10, (void *)reply, freenect_fetch_zero_plane_info__1__ctx->zero_plane_res);
  if(!(res == freenect_fetch_zero_plane_info__1__ctx->zero_plane_res))
  {
    fn_log(freenect_fetch_zero_plane_info__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_fetch_zero_plane_info: send_cmd read %d bytes (expected %d)\n", res, freenect_fetch_zero_plane_info__1__ctx->zero_plane_res);
    return -1;
  }

  else
  {
    memcpy((void *)&dev->registration.zero_plane_info, (const void *)(reply + (signed long int)94), sizeof(struct anonymous_12) /*16ul*/ );
    /* tag-#anon#lUN[U32'ui'||F32'f'|] */
union anonymous_7
{
  // ui
  unsigned int ui;
  // f
  float f;
};

/* */
    ;
    union anonymous_7 conversion_union;
    conversion_union.f = dev->registration.zero_plane_info.dcmos_emitter_dist;
    conversion_union.ui = conversion_union.ui;
    dev->registration.zero_plane_info.dcmos_emitter_dist = conversion_union.f;
    conversion_union.f = dev->registration.zero_plane_info.dcmos_rcmos_dist;
    conversion_union.ui = conversion_union.ui;
    dev->registration.zero_plane_info.dcmos_rcmos_dist = conversion_union.f;
    conversion_union.f = dev->registration.zero_plane_info.reference_distance;
    conversion_union.ui = conversion_union.ui;
    dev->registration.zero_plane_info.reference_distance = conversion_union.f;
    conversion_union.f = dev->registration.zero_plane_info.reference_pixel_size;
    conversion_union.ui = conversion_union.ui;
    dev->registration.zero_plane_info.reference_pixel_size = conversion_union.f;
    fn_log(freenect_fetch_zero_plane_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dcmos_emitter_distance: %f\n", dev->registration.zero_plane_info.dcmos_emitter_dist);
    fn_log(freenect_fetch_zero_plane_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "dcmos_rcmos_distance:   %f\n", dev->registration.zero_plane_info.dcmos_rcmos_dist);
    fn_log(freenect_fetch_zero_plane_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "reference_distance:     %f\n", dev->registration.zero_plane_info.reference_distance);
    fn_log(freenect_fetch_zero_plane_info__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "reference_pixel_size:   %f\n", dev->registration.zero_plane_info.reference_pixel_size);
    dev->registration.zero_plane_info.dcmos_rcmos_dist = 2.4f;
    return 0;
  }
}

// freenect_fetch_zero_plane_info_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 794
static signed int freenect_fetch_zero_plane_info_link1(struct _freenect_device *dev_link1)
{
  struct _freenect_context *ctx_link1 = dev_link1->parent;
  char reply_link1[512l];
  unsigned short int cmd_link1[5l] = { (unsigned short int)0, 0, 0, 0, 0 };
  signed int res_link1;
  res_link1=send_cmd(dev_link1, (unsigned short int)0x04, (void *)cmd_link1, (unsigned int)10, (void *)reply_link1, ctx_link1->zero_plane_res);
  if(!(res_link1 == ctx_link1->zero_plane_res))
  {
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_fetch_zero_plane_info: send_cmd read %d bytes (expected %d)\n", res_link1, ctx_link1->zero_plane_res);
    return -1;
  }

  else
  {
    memcpy((void *)&dev_link1->registration.zero_plane_info, (const void *)(reply_link1 + (signed long int)94), sizeof(struct anonymous_12) /*16ul*/ );
    /* tag-#anon#lUN[U32'ui'||F32'f'|] */
union anonymous_7
{
  // ui
  unsigned int ui;
  // f
  float f;
};

/* */
    ;
    union anonymous_7 conversion_union_link1;
    conversion_union_link1.f = dev_link1->registration.zero_plane_info.dcmos_emitter_dist;
    conversion_union_link1.ui = conversion_union_link1.ui;
    dev_link1->registration.zero_plane_info.dcmos_emitter_dist = conversion_union_link1.f;
    conversion_union_link1.f = dev_link1->registration.zero_plane_info.dcmos_rcmos_dist;
    conversion_union_link1.ui = conversion_union_link1.ui;
    dev_link1->registration.zero_plane_info.dcmos_rcmos_dist = conversion_union_link1.f;
    conversion_union_link1.f = dev_link1->registration.zero_plane_info.reference_distance;
    conversion_union_link1.ui = conversion_union_link1.ui;
    dev_link1->registration.zero_plane_info.reference_distance = conversion_union_link1.f;
    conversion_union_link1.f = dev_link1->registration.zero_plane_info.reference_pixel_size;
    conversion_union_link1.ui = conversion_union_link1.ui;
    dev_link1->registration.zero_plane_info.reference_pixel_size = conversion_union_link1.f;
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dcmos_emitter_distance: %f\n", dev_link1->registration.zero_plane_info.dcmos_emitter_dist);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "dcmos_rcmos_distance:   %f\n", dev_link1->registration.zero_plane_info.dcmos_rcmos_dist);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "reference_distance:     %f\n", dev_link1->registration.zero_plane_info.reference_distance);
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "reference_pixel_size:   %f\n", dev_link1->registration.zero_plane_info.reference_pixel_size);
    dev_link1->registration.zero_plane_info.dcmos_rcmos_dist = 2.4f;
    return 0;
  }
}

// freenect_find_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 650
struct anonymous_6 freenect_find_depth_mode(enum anonymous_13 res, enum anonymous_5 fmt)
{
  unsigned int unique_id = (unsigned int)(((signed int)res & 0xff) << 8 | (signed int)fmt & 0xff);
  signed int i = 0;
  for( ; !(i >= 6); i = i + 1)
    if(supported_depth_modes[(signed long int)i].reserved == unique_id)
      return supported_depth_modes[(signed long int)i];

  struct anonymous_6 retval;
  retval.is_valid = (signed char)0;
  return retval;
}

// freenect_find_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 598
struct anonymous_6 freenect_find_video_mode(enum anonymous_13 res, enum anonymous_4 fmt)
{
  unsigned int unique_id = (unsigned int)(((signed int)res & 0xff) << 8 | (signed int)fmt & 0xff);
  signed int i = 0;
  for( ; !(i >= 12); i = i + 1)
    if(supported_video_modes[(signed long int)i].reserved == unique_id)
      return supported_video_modes[(signed long int)i];

  struct anonymous_6 retval;
  retval.is_valid = (signed char)0;
  return retval;
}

// freenect_free_device_attributes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 112
void freenect_free_device_attributes(struct freenect_device_attributes *attribute_list)
{
  struct freenect_device_attributes *to_free;
  while(!(attribute_list == ((struct freenect_device_attributes *)NULL)))
  {
    to_free = attribute_list;
    if(!(attribute_list->camera_serial == ((const char *)NULL)))
    {
      free((void *)(char *)attribute_list->camera_serial);
      attribute_list->camera_serial = (const char *)(void *)0;
    }

    attribute_list = attribute_list->next;
    free((void *)to_free);
  }
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
}

// freenect_get_current_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1197
struct anonymous_6 freenect_get_current_depth_mode(struct _freenect_device *dev)
{
  struct anonymous_6 return_value_freenect_find_depth_mode_1;
  return_value_freenect_find_depth_mode_1=freenect_find_depth_mode(dev->depth_resolution, dev->depth_format);
  return return_value_freenect_find_depth_mode_1;
}

// freenect_get_current_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1134
struct anonymous_6 freenect_get_current_video_mode(struct _freenect_device *dev)
{
  struct anonymous_6 return_value_freenect_find_video_mode_1;
  return_value_freenect_find_video_mode_1=freenect_find_video_mode(dev->video_resolution, dev->video_format);
  return return_value_freenect_find_video_mode_1;
}

// freenect_get_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1188
struct anonymous_6 freenect_get_depth_mode(signed int mode_num)
{
  if(mode_num >= 0 && !(mode_num >= 6))
    return supported_depth_modes[(signed long int)mode_num];

  else
  {
    struct anonymous_6 retval;
    retval.is_valid = (signed char)0;
    return retval;
  }
}

// freenect_get_depth_mode_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1183
signed int freenect_get_depth_mode_count()
{
  return 6;
}

// freenect_get_ir_brightness
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 96
signed int freenect_get_ir_brightness(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_get_ir_brightness__1__ctx = dev->parent;
  unsigned short int brightness;
  brightness=read_register(dev, (unsigned short int)0x15);
  if((signed int)brightness == 65535)
  {
    fn_log(freenect_get_ir_brightness__1__ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "Failed to get IR brightness!");
    return -1;
  }

  else
    return (signed int)brightness;
}

// freenect_get_mks_accel
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 331
void freenect_get_mks_accel(struct anonymous_18 *state, double *x, double *y, double *z)
{
  *x = ((double)state->accelerometer_x / (double)819) * 9.80665;
  *y = ((double)state->accelerometer_y / (double)819) * 9.80665;
  *z = ((double)state->accelerometer_z / (double)819) * 9.80665;
}

// freenect_get_tilt_degs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 321
double freenect_get_tilt_degs(struct anonymous_18 *state)
{
  return (double)state->tilt_angle / 2.;
}

// freenect_get_tilt_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 503
struct anonymous_18 * freenect_get_tilt_state(struct _freenect_device *dev)
{
  return &dev->raw_state;
}

// freenect_get_tilt_status
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 326
enum anonymous_32 freenect_get_tilt_status(struct anonymous_18 *state)
{
  return state->tilt_status;
}

// freenect_get_user
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 383
void * freenect_get_user(struct _freenect_device *dev)
{
  return dev->user_data;
}

// freenect_get_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1125
struct anonymous_6 freenect_get_video_mode(signed int mode_num)
{
  if(mode_num >= 0 && !(mode_num >= 12))
    return supported_video_modes[(signed long int)mode_num];

  else
  {
    struct anonymous_6 retval;
    retval.is_valid = (signed char)0;
    return retval;
  }
}

// freenect_get_video_mode_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1120
signed int freenect_get_video_mode_count()
{
  return 12;
}

// freenect_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 221
signed int freenect_init(struct _freenect_context **ctx, void *usb_ctx)
{
  signed int res;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _freenect_context) /*88ul*/ );
  *ctx = (struct _freenect_context *)return_value_malloc_1;
  if(*ctx == ((struct _freenect_context *)NULL))
    return -1;

  else
  {
    memset((void *)*ctx, 0, sizeof(struct _freenect_context) /*88ul*/ );
    (*ctx)->log_level = (enum anonymous_21)FREENECT_LOG_WARNING;
    (*ctx)->enabled_subdevices = (enum anonymous_22)(FREENECT_DEVICE_MOTOR | FREENECT_DEVICE_CAMERA);
    res=fnusb_init(&(*ctx)->usb, usb_ctx);
    if(!(res >= 0))
    {
      free((void *)*ctx);
      *ctx = (struct _freenect_context *)(void *)0;
    }

    return res;
  }
}

// freenect_init_depth_to_rgb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 60
static void freenect_init_depth_to_rgb(signed int *depth_to_rgb, struct anonymous_12 *zpi)
{
  unsigned int i;
  unsigned int x_scale = (unsigned int)(1280 / 640);
  double pixel_size = 1.0 / (double)(zpi->reference_pixel_size * (float)x_scale * (float)10);
  double pixels_between_rgb_and_ir_cmos = (double)zpi->dcmos_rcmos_dist * pixel_size * (double)10;
  double reference_distance_in_pixels = (double)zpi->reference_distance * pixel_size * (double)10;
  memset((void *)depth_to_rgb, 0, (unsigned long int)10000 * sizeof(signed int) /*4ul*/ );
  i = (unsigned int)0;
  for( ; !(i >= 10000u); i = i + 1u)
  {
    double current_depth_in_pixels = (double)i * pixel_size;
    depth_to_rgb[(signed long int)i] = (signed int)(((pixels_between_rgb_and_ir_cmos * (current_depth_in_pixels - reference_distance_in_pixels)) / current_depth_in_pixels + 0.375) * (double)256);
  }
}

// freenect_init_depth_to_rgb_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 60
static void freenect_init_depth_to_rgb_link1(signed int *depth_to_rgb_link1, struct anonymous_12 *zpi_link1)
{
  unsigned int i_link1;
  unsigned int x_scale_link1 = (unsigned int)(1280 / 640);
  double pixel_size_link1 = 1.0 / (double)(zpi_link1->reference_pixel_size * (float)x_scale_link1 * (float)10);
  double pixels_between_rgb_and_ir_cmos_link1 = (double)zpi_link1->dcmos_rcmos_dist * pixel_size_link1 * (double)10;
  double reference_distance_in_pixels_link1 = (double)zpi_link1->reference_distance * pixel_size_link1 * (double)10;
  memset((void *)depth_to_rgb_link1, 0, (unsigned long int)10000 * sizeof(signed int) /*4ul*/ );
  i_link1 = (unsigned int)0;
  for( ; !(i_link1 >= 10000u); i_link1 = i_link1 + 1u)
  {
    double current_depth_in_pixels_link1 = (double)i_link1 * pixel_size_link1;
    depth_to_rgb_link1[(signed long int)i_link1] = (signed int)(((pixels_between_rgb_and_ir_cmos_link1 * (current_depth_in_pixels_link1 - reference_distance_in_pixels_link1)) / current_depth_in_pixels_link1 + 0.375) * (double)256);
  }
}

// freenect_init_registration
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.h line 32
signed int freenect_init_registration(struct _freenect_device *dev)
{
  struct anonymous_15 *reg = &dev->registration;
  freenect_destroy_registration(&dev->registration);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(unsigned short int) /*2ul*/  * (unsigned long int)2048);
  reg->raw_to_mm_shift = (unsigned short int *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)10000);
  reg->depth_to_rgb_shift = (signed int *)return_value_malloc_2;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)640 * (unsigned long int)480 * (unsigned long int)2);
  reg->registration_table = (signed int (*)[2l])return_value_malloc_3;
  complete_tables(reg);
  return 0;
}

// freenect_init_registration_table
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 264
static void freenect_init_registration_table(signed int (*registration_table)[2l], struct anonymous_25 *reg_info)
{
  double *regtable_dx;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(640 * 480) * sizeof(double) /*8ul*/ );
  regtable_dx = (double *)return_value_malloc_1;
  double *regtable_dy;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(640 * 480) * sizeof(double) /*8ul*/ );
  regtable_dy = (double *)return_value_malloc_2;
  memset((void *)regtable_dx, 0, (unsigned long int)(640 * 480) * sizeof(double) /*8ul*/ );
  memset((void *)regtable_dy, 0, (unsigned long int)(640 * 480) * sizeof(double) /*8ul*/ );
  signed int x;
  signed int y;
  signed int index = 0;
  freenect_create_dxdy_tables(regtable_dx, regtable_dy, 640, 480, reg_info);
  y = 0;
  for( ; !(y >= 480); y = y + 1)
  {
    x = 0;
    for( ; !(x >= 640); index = index + 1)
    {
      double new_x = (double)x + regtable_dx[(signed long int)index] + (double)1;
      double new_y = (double)y + regtable_dy[(signed long int)index] + (double)1;
      if(new_x < 0.000000 || new_y < 0.000000 || new_x >= 640.000000 || new_y >= 480.000000)
        new_x = (double)(2 * 640);

      registration_table[(signed long int)index][(signed long int)0] = (signed int)(new_x * (double)256);
      registration_table[(signed long int)index][(signed long int)1] = (signed int)new_y;
      x = x + 1;
    }
  }
  free((void *)regtable_dx);
  free((void *)regtable_dy);
}

// freenect_init_registration_table_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 264
static void freenect_init_registration_table_link1(signed int (*registration_table_link1)[2l], struct anonymous_25 *reg_info_link1)
{
  double *regtable_dx_link1;
  void *return_value_malloc_1_link1;
  return_value_malloc_1_link1=malloc((unsigned long int)(640 * 480) * sizeof(double) /*8ul*/ );
  regtable_dx_link1 = (double *)return_value_malloc_1_link1;
  double *regtable_dy_link1;
  void *return_value_malloc_2_link1;
  return_value_malloc_2_link1=malloc((unsigned long int)(640 * 480) * sizeof(double) /*8ul*/ );
  regtable_dy_link1 = (double *)return_value_malloc_2_link1;
  memset((void *)regtable_dx_link1, 0, (unsigned long int)(640 * 480) * sizeof(double) /*8ul*/ );
  memset((void *)regtable_dy_link1, 0, (unsigned long int)(640 * 480) * sizeof(double) /*8ul*/ );
  signed int x_link1;
  signed int y_link1;
  signed int index_link1 = 0;
  freenect_create_dxdy_tables_link1(regtable_dx_link1, regtable_dy_link1, 640, 480, reg_info_link1);
  y_link1 = 0;
  for( ; !(y_link1 >= 480); y_link1 = y_link1 + 1)
  {
    x_link1 = 0;
    for( ; !(x_link1 >= 640); index_link1 = index_link1 + 1)
    {
      double new_x_link1 = (double)x_link1 + regtable_dx_link1[(signed long int)index_link1] + (double)1;
      double new_y_link1 = (double)y_link1 + regtable_dy_link1[(signed long int)index_link1] + (double)1;
      if(new_x_link1 < 0.000000 || new_y_link1 < 0.000000 || new_x_link1 >= 640.000000 || new_y_link1 >= 480.000000)
        new_x_link1 = (double)(2 * 640);

      registration_table_link1[(signed long int)index_link1][(signed long int)0] = (signed int)(new_x_link1 * (double)256);
      registration_table_link1[(signed long int)index_link1][(signed long int)1] = (signed int)new_y_link1;
      x_link1 = x_link1 + 1;
    }
  }
  free((void *)regtable_dx_link1);
  free((void *)regtable_dy_link1);
}

// freenect_list_device_attributes
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 107
signed int freenect_list_device_attributes(struct _freenect_context *ctx, struct freenect_device_attributes **attribute_list)
{
  signed int return_value_fnusb_list_device_attributes_1;
  return_value_fnusb_list_device_attributes_1=fnusb_list_device_attributes(&ctx->usb, attribute_list);
  return return_value_fnusb_list_device_attributes_1;
}

// freenect_map_rgb_to_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 333
void freenect_map_rgb_to_depth(struct _freenect_device *dev, unsigned short int *depth_mm, unsigned char *rgb_raw, unsigned char *rgb_registered)
{
  unsigned int target_offset = (unsigned int)((signed int)dev->registration.reg_pad_info.start_lines * 480);
  signed int x;
  signed int y;
  signed int *map;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(480 * 640) * sizeof(signed int) /*4ul*/ );
  map = (signed int *)return_value_malloc_1;
  unsigned short int *zBuffer;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(480 * 640) * sizeof(unsigned short int) /*2ul*/ );
  zBuffer = (unsigned short int *)return_value_malloc_2;
  memset((void *)zBuffer, 0, (unsigned long int)(640 * 480) * sizeof(unsigned short int) /*2ul*/ );
  y = 0;
  _Bool tmp_if_expr_3;
  for( ; !(y >= 480); y = y + 1)
  {
    x = 0;
    for( ; !(x >= 640); x = x + 1)
    {
      unsigned int index = (unsigned int)(y * 640 + x);
      unsigned int cx;
      unsigned int cy;
      unsigned int cindex;
      map[(signed long int)index] = -1;
      signed int wz = (signed int)depth_mm[(signed long int)index];
      if(!(wz == 0))
      {
        cx = (unsigned int)((dev->registration.registration_table[(signed long int)index][(signed long int)0] + dev->registration.depth_to_rgb_shift[(signed long int)wz]) / 256);
        cy = (unsigned int)dev->registration.registration_table[(signed long int)index][(signed long int)1] - target_offset;
        if(!(cx >= 640u))
        {
          cindex = cy * (unsigned int)640 + cx;
          map[(signed long int)index] = (signed int)cindex;
          if((signed int)zBuffer[(signed long int)cindex] == 0)
            tmp_if_expr_3 = (_Bool)1;

          else
            tmp_if_expr_3 = (signed int)zBuffer[(signed long int)cindex] > wz ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_3)
            zBuffer[(signed long int)cindex] = (unsigned short int)wz;

        }

      }

    }
  }
  y = 0;
  for( ; !(y >= 480); y = y + 1)
  {
    x = 0;
    for( ; !(x >= 640); x = x + 1)
    {
      unsigned int freenect_map_rgb_to_depth__1__2__1__1__index = (unsigned int)(y * 640 + x);
      unsigned int freenect_map_rgb_to_depth__1__2__1__1__cindex = (unsigned int)map[(signed long int)freenect_map_rgb_to_depth__1__2__1__1__index];
      if(freenect_map_rgb_to_depth__1__2__1__1__cindex == 4294967295u)
      {
        freenect_map_rgb_to_depth__1__2__1__1__index = freenect_map_rgb_to_depth__1__2__1__1__index * (unsigned int)3;
        rgb_registered[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__index + (unsigned int)0)] = (unsigned char)0;
        rgb_registered[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__index + (unsigned int)1)] = (unsigned char)0;
        rgb_registered[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__index + (unsigned int)2)] = (unsigned char)0;
      }

      else
      {
        unsigned short int currentDepth = depth_mm[(signed long int)freenect_map_rgb_to_depth__1__2__1__1__index];
        unsigned short int minDepth = zBuffer[(signed long int)freenect_map_rgb_to_depth__1__2__1__1__cindex];
        if((signed int)minDepth >= (signed int)currentDepth)
        {
          freenect_map_rgb_to_depth__1__2__1__1__index = freenect_map_rgb_to_depth__1__2__1__1__index * (unsigned int)3;
          freenect_map_rgb_to_depth__1__2__1__1__cindex = freenect_map_rgb_to_depth__1__2__1__1__cindex * (unsigned int)3;
          rgb_registered[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__index + (unsigned int)0)] = rgb_raw[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__cindex + (unsigned int)0)];
          rgb_registered[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__index + (unsigned int)1)] = rgb_raw[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__cindex + (unsigned int)1)];
          rgb_registered[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__index + (unsigned int)2)] = rgb_raw[(signed long int)(freenect_map_rgb_to_depth__1__2__1__1__cindex + (unsigned int)2)];
        }

      }
    }
  }
  free((void *)zBuffer);
  free((void *)map);
}

// freenect_num_devices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 102
signed int freenect_num_devices(struct _freenect_context *ctx)
{
  signed int return_value_fnusb_num_devices_1;
  return_value_fnusb_num_devices_1=fnusb_num_devices(&ctx->usb);
  return return_value_fnusb_num_devices_1;
}

// freenect_open_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 343
signed int freenect_open_device(struct _freenect_context *ctx, struct _freenect_device **dev, signed int index)
{
  signed int res;
  struct _freenect_device *pdev;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _freenect_device) /*936ul*/ );
  pdev = (struct _freenect_device *)return_value_malloc_1;
  if(pdev == ((struct _freenect_device *)NULL))
    return -1;

  else
  {
    memset((void *)pdev, 0, sizeof(struct _freenect_device) /*936ul*/ );
    pdev->parent = ctx;
    res=fnusb_open_subdevices(pdev, index);
    if(!(res >= 0))
    {
      free((void *)pdev);
      return res;
    }

    else
    {
      if(ctx->first == ((struct _freenect_device *)NULL))
        ctx->first = pdev;

      else
      {
        struct _freenect_device *prev = ctx->first;
        for( ; !(prev->next == ((struct _freenect_device *)NULL)); prev = prev->next)
          ;
        prev->next = pdev;
      }
      *dev = pdev;
      if(!(pdev->usb_cam.dev == ((struct libusb_device_handle *)NULL)))
      {
        signed int return_value_freenect_camera_init_2;
        return_value_freenect_camera_init_2=freenect_camera_init(pdev);
        if(!(return_value_freenect_camera_init_2 >= 0))
          return -1;

      }

      return 0;
    }
  }
}

// freenect_open_device_by_camera_serial
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 181
signed int freenect_open_device_by_camera_serial(struct _freenect_context *ctx, struct _freenect_device **dev, const char *camera_serial)
{
  struct freenect_device_attributes *attrlist;
  struct freenect_device_attributes *item;
  signed int count;
  count=fnusb_list_device_attributes(&ctx->usb, &attrlist);
  signed int return_value_strcmp_2;
  if(!(count >= 0))
  {
    fn_log(ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_open_device_by_camera_serial: Couldn't enumerate serial numbers\n");
    return count;
  }

  else
  {
    signed int index = 0;
    item = attrlist;
    for( ; !(item == ((struct freenect_device_attributes *)NULL)); index = index + 1)
    {
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(item->camera_serial);
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(camera_serial);
      if(return_value_strlen_3 == return_value_strlen_4)
      {
        return_value_strcmp_2=strcmp(item->camera_serial, camera_serial);
        if(return_value_strcmp_2 == 0)
        {
          freenect_free_device_attributes(attrlist);
          signed int return_value_freenect_open_device_1;
          return_value_freenect_open_device_1=freenect_open_device(ctx, dev, index);
          return return_value_freenect_open_device_1;
        }

      }

      item = item->next;
    }
    freenect_free_device_attributes(attrlist);
    fn_log(ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_open_device_by_camera_serial: Couldn't find a device with serial %s\n", camera_serial);
    return -1;
  }
}

// freenect_process_events
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 259
signed int freenect_process_events(struct _freenect_context *ctx)
{
  struct timeval timeout;
  timeout.tv_sec = (signed long int)60;
  timeout.tv_usec = (signed long int)0;
  signed int return_value_freenect_process_events_timeout_1;
  return_value_freenect_process_events_timeout_1=freenect_process_events_timeout(ctx, &timeout);
  return return_value_freenect_process_events_timeout_1;
}

// freenect_process_events_timeout
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 80
signed int freenect_process_events_timeout(struct _freenect_context *ctx, struct timeval *timeout)
{
  signed int res;
  res=fnusb_process_events_timeout(&ctx->usb, timeout);
  struct _freenect_device *dev = ctx->first;
  for( ; !(dev == ((struct _freenect_device *)NULL)); dev = dev->next)
  {
    if(!(dev->usb_cam.device_dead == 0))
    {
      fn_log(ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "USB camera marked dead, stopping streams\n");
      res = -1;
      freenect_stop_video(dev);
      freenect_stop_depth(dev);
    }

    if(!(dev->usb_audio.device_dead == 0))
    {
      fn_log(ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "USB audio marked dead, stopping streams\n");
      res = -1;
      freenect_stop_audio(dev);
    }

  }
  return res;
}

// freenect_raw_to_mm
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 297
static unsigned short int freenect_raw_to_mm(unsigned short int raw, struct anonymous_15 *reg)
{
  struct anonymous_12 *zpi = &reg->zero_plane_info;
  double fixed_ref_x = ((double)raw - (parameter_coefficient * reg->const_shift) / pixel_size_factor) / parameter_coefficient - 0.375;
  double metric = fixed_ref_x * (double)zpi->reference_pixel_size * pixel_size_factor;
  return (unsigned short int)(shift_scale * ((metric * (double)zpi->reference_distance) / ((double)zpi->dcmos_emitter_dist - metric) + (double)zpi->reference_distance));
}

// freenect_raw_to_mm_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 297
static unsigned short int freenect_raw_to_mm_link1(unsigned short int raw_link1, struct anonymous_15 *reg_link1)
{
  struct anonymous_12 *zpi_link1 = &reg_link1->zero_plane_info;
  double fixed_ref_x_link1 = ((double)raw_link1 - (parameter_coefficient_link1 * reg_link1->const_shift) / pixel_size_factor_link1) / parameter_coefficient_link1 - 0.375;
  double metric_link1 = fixed_ref_x_link1 * (double)zpi_link1->reference_pixel_size * pixel_size_factor_link1;
  return (unsigned short int)(shift_scale_link1 * ((metric_link1 * (double)zpi_link1->reference_distance) / ((double)zpi_link1->dcmos_emitter_dist - metric_link1) + (double)zpi_link1->reference_distance));
}

// freenect_select_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 321
void freenect_select_subdevices(struct _freenect_context *ctx, enum anonymous_22 subdevs)
{
  ctx->enabled_subdevices = (enum anonymous_22)((signed int)subdevs & (FREENECT_DEVICE_MOTOR | FREENECT_DEVICE_CAMERA | FREENECT_DEVICE_AUDIO));
}

// freenect_set_audio_in_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 142
void freenect_set_audio_in_callback(struct _freenect_device *dev, void (*callback)(struct _freenect_device *, signed int, signed int *, signed int *, signed int *, signed int *, signed short int *, void *))
{
  dev->audio_in_cb = callback;
}

// freenect_set_audio_out_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 145
void freenect_set_audio_out_callback(struct _freenect_device *dev, void (*callback)(struct _freenect_device *, struct anonymous_16 *, signed int *))
{
  dev->audio_out_cb = callback;
}

// freenect_set_depth_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 435
signed int freenect_set_depth_buffer(struct _freenect_device *dev, void *buf)
{
  signed int return_value_stream_setbuf_1;
  return_value_stream_setbuf_1=stream_setbuf(dev->parent, &dev->depth, buf);
  return return_value_stream_setbuf_1;
}

// freenect_set_depth_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 399
void freenect_set_depth_callback(struct _freenect_device *dev, void (*cb)(struct _freenect_device *, void *, unsigned int))
{
  dev->depth_cb = cb;
}

// freenect_set_depth_chunk_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1110
void freenect_set_depth_chunk_callback(struct _freenect_device *dev, void (*cb)(void *, void *, signed int, signed int, void *))
{
  dev->depth_chunk_cb = cb;
}

// freenect_set_depth_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 661
signed int freenect_set_depth_mode(struct _freenect_device *dev, const struct anonymous_6 mode)
{
  struct _freenect_context *freenect_set_depth_mode__1__ctx = dev->parent;
  if(!(dev->depth.running == 0))
  {
    fn_log(freenect_set_depth_mode__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Tried to set depth mode while stream is active\n");
    return -1;
  }

  else
  {
    signed int found = 0;
    signed int i = 0;
    for( ; !(i >= 6); i = i + 1)
      if(supported_depth_modes[(signed long int)i].reserved == mode.reserved)
      {
        found = 1;
        break;
      }

    if(found == 0)
    {
      fn_log(freenect_set_depth_mode__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_set_depth_mode: freenect_frame_mode provided is invalid\n");
      return -1;
    }

    else
    {
      enum anonymous_13 res = (enum anonymous_13)(mode.reserved >> 8 & (unsigned int)0xff);
      enum anonymous_5 fmt = (enum anonymous_5)(mode.reserved & (unsigned int)0xff);
      dev->depth_format = fmt;
      dev->depth_resolution = res;
      return 0;
    }
  }
}

// freenect_set_flag
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 46
signed int freenect_set_flag(struct _freenect_device *dev, enum anonymous_8 flag, enum anonymous_9 value)
{
  struct _freenect_context *freenect_set_flag__1__ctx = dev->parent;
  if((signed int)flag == FREENECT_NEAR_MODE)
  {
    if(!(dev->usb_cam.PID == 0x02bf))
    {
      fn_log(freenect_set_flag__1__ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "Near mode is only supported by K4W");
      return -1;
    }

    if((signed int)value == FREENECT_ON)
    {
      signed int freenect_set_flag__1__1__2__ret;
      freenect_set_flag__1__1__2__ret=write_register(dev, (unsigned short int)0x0015, (unsigned short int)0x0007);
      if(!(freenect_set_flag__1__1__2__ret >= 0))
        return freenect_set_flag__1__1__2__ret;

      usleep((unsigned int)100000);
      signed int return_value_write_register_1;
      return_value_write_register_1=write_register(dev, (unsigned short int)0x02EF, (unsigned short int)0x0000);
      return return_value_write_register_1;
    }

    else
    {
      signed int ret;
      ret=write_register(dev, (unsigned short int)0x0015, (unsigned short int)0x001E);
      if(!(ret >= 0))
        return ret;

      usleep((unsigned int)100000);
      signed int return_value_write_register_2;
      return_value_write_register_2=write_register(dev, (unsigned short int)0x02EF, (unsigned short int)0x0190);
      return return_value_write_register_2;
    }
  }

  if((signed int)flag >= 65536)
  {
    signed int reg;
    reg=register_for_flag((signed int)flag);
    if(!(reg >= 0))
      return reg;

    signed int return_value_write_register_3;
    return_value_write_register_3=write_register(dev, (unsigned short int)reg, (unsigned short int)value);
    return return_value_write_register_3;
  }

  unsigned short int cmos_value;
  cmos_value=read_cmos_register(dev, (unsigned short int)0x0106);
  if((signed int)cmos_value == 65535)
    return -1;

  else
  {
    if((signed int)value == FREENECT_ON)
      cmos_value = cmos_value | (unsigned short int)flag;

    else
      cmos_value = cmos_value & (unsigned short int)~((signed int)flag);
    signed int return_value_write_cmos_register_4;
    return_value_write_cmos_register_4=write_cmos_register(dev, (unsigned short int)0x0106, cmos_value);
    return return_value_write_cmos_register_4;
  }
}

// freenect_set_fw_address_k4w
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 292
void freenect_set_fw_address_k4w(struct _freenect_context *ctx, unsigned char *fw_ptr, unsigned int num_bytes)
{
  ctx->fn_fw_k4w_ptr = fw_ptr;
  ctx->fn_fw_k4w_size = num_bytes;
}

// freenect_set_fw_address_nui
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 286
void freenect_set_fw_address_nui(struct _freenect_context *ctx, unsigned char *fw_ptr, unsigned int num_bytes)
{
  ctx->fn_fw_nui_ptr = fw_ptr;
  ctx->fn_fw_nui_size = num_bytes;
}

// freenect_set_ir_brightness
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 110
signed int freenect_set_ir_brightness(struct _freenect_device *dev, unsigned short int brightness)
{
  struct _freenect_context *freenect_set_ir_brightness__1__ctx = dev->parent;
  if(!((signed int)brightness >= 1))
    brightness = (unsigned short int)1;

  if((signed int)brightness >= 51)
    brightness = (unsigned short int)50;

  signed int ret;
  ret=write_register(dev, (unsigned short int)0x15, brightness);
  if(!(ret >= 0))
    fn_log(freenect_set_ir_brightness__1__ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "Failed to set IR brightness");

  return ret;
}

// freenect_set_led
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 547
signed int freenect_set_led(struct _freenect_device *dev, enum anonymous_23 option)
{
  struct _freenect_context *freenect_set_led__1__ctx = dev->parent;
  if(!(dev->motor_control_with_audio_enabled == 0))
  {
    signed int return_value_freenect_set_led_alt_1;
    return_value_freenect_set_led_alt_1=freenect_set_led_alt(dev, option);
    return return_value_freenect_set_led_alt_1;
  }

  if((FREENECT_DEVICE_MOTOR & (signed int)freenect_set_led__1__ctx->enabled_subdevices) == 0)
    return 0;

  else
  {
    signed int ret;
    unsigned char empty[1l];
    ret=fnusb_control(&dev->usb_motor, (unsigned char)0x40, (unsigned char)0x06, (unsigned short int)option, (unsigned short int)0x0, empty, (unsigned short int)0x0);
    return ret;
  }
}

// freenect_set_led_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 290
signed int freenect_set_led_alt(struct _freenect_device *dev, enum anonymous_23 state)
{
  struct _freenect_context *freenect_set_led_alt__1__ctx = dev->parent;
  if(dev->usb_audio.dev == ((struct libusb_device_handle *)NULL))
  {
    fn_log(freenect_set_led_alt__1__ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "Motor control failed: audio device missing");
    return -1;
  }

  else
  {
    signed int return_value_fnusb_set_led_alt_1;
    return_value_fnusb_set_led_alt_1=fnusb_set_led_alt(dev->usb_audio.dev, freenect_set_led_alt__1__ctx, state);
    return return_value_fnusb_set_led_alt_1;
  }
}

// freenect_set_log_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 257
void freenect_set_log_callback(struct _freenect_context *ctx, void (*cb)(struct _freenect_context *, enum anonymous_21, const char *))
{
  ctx->log_cb = cb;
}

// freenect_set_log_level
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 252
void freenect_set_log_level(struct _freenect_context *ctx, enum anonymous_21 level)
{
  ctx->log_level = level;
}

// freenect_set_tilt_degs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 526
signed int freenect_set_tilt_degs(struct _freenect_device *dev, double angle)
{
  struct _freenect_context *freenect_set_tilt_degs__1__ctx = dev->parent;
  if(!(dev->motor_control_with_audio_enabled == 0))
  {
    signed int return_value_freenect_set_tilt_degs_alt_1;
    return_value_freenect_set_tilt_degs_alt_1=freenect_set_tilt_degs_alt(dev, (signed int)angle);
    return return_value_freenect_set_tilt_degs_alt_1;
  }

  if((FREENECT_DEVICE_MOTOR & (signed int)freenect_set_tilt_degs__1__ctx->enabled_subdevices) == 0)
    return 0;

  else
  {
    signed int ret;
    unsigned char empty[1l];
    angle = angle < (double)-31 ? (double)-31 : (angle > (double)31 ? (double)31 : angle);
    angle = angle * (double)2;
    ret=fnusb_control(&dev->usb_motor, (unsigned char)0x40, (unsigned char)0x31, (unsigned short int)(signed short int)angle, (unsigned short int)0x0, empty, (unsigned short int)0x0);
    return ret;
  }
}

// freenect_set_tilt_degs_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 189
signed int freenect_set_tilt_degs_alt(struct _freenect_device *dev, signed int tilt_degrees)
{
  struct _freenect_context *freenect_set_tilt_degs_alt__1__ctx = dev->parent;
  signed int tmp_post_1;
  if(tilt_degrees >= 32 || !(tilt_degrees >= -31))
  {
    fn_log(freenect_set_tilt_degs_alt__1__ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "set_tilt(): degrees %d out of safe range [-31, 31]\n", tilt_degrees);
    return -1;
  }

  else
    if(dev->usb_audio.dev == ((struct libusb_device_handle *)NULL))
    {
      fn_log(freenect_set_tilt_degs_alt__1__ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "Motor control failed: audio device missing");
      return -1;
    }

    else
    {
      struct anonymous_26 cmd;
      cmd.magic = (unsigned int)0x06022009;
      tmp_post_1 = tag_seq;
      tag_seq = tag_seq + 1;
      cmd.tag = (unsigned int)tmp_post_1;
      cmd.arg1 = (unsigned int)0;
      cmd.cmd = (unsigned int)0x803b;
      cmd.arg2 = (unsigned int)(signed int)tilt_degrees;
      signed int transferred = 0;
      signed int res = 0;
      unsigned char buffer[20l];
      memcpy((void *)buffer, (const void *)&cmd, (unsigned long int)20);
      res=libusb_bulk_transfer(dev->usb_audio.dev, (unsigned char)0x01, buffer, 20, &transferred, (unsigned int)250);
      if(!(res == 0))
      {
        fn_log(freenect_set_tilt_degs_alt__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_set_tilt_alt(): libusb_bulk_transfer failed: %d (transferred = %d)\n", res, transferred);
        return res;
      }

      else
      {
        signed int return_value_get_reply_2;
        return_value_get_reply_2=get_reply(dev->usb_audio.dev, freenect_set_tilt_degs_alt__1__ctx);
        return return_value_get_reply_2;
      }
    }
}

// freenect_set_user
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 374
void freenect_set_user(struct _freenect_device *dev, void *user)
{
  dev->user_data = user;
}

// freenect_set_video_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 447
signed int freenect_set_video_buffer(struct _freenect_device *dev, void *buf)
{
  signed int return_value_stream_setbuf_1;
  return_value_stream_setbuf_1=stream_setbuf(dev->parent, &dev->video, buf);
  return return_value_stream_setbuf_1;
}

// freenect_set_video_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 407
void freenect_set_video_callback(struct _freenect_device *dev, void (*cb)(struct _freenect_device *, void *, unsigned int))
{
  dev->video_cb = cb;
}

// freenect_set_video_chunk_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 1115
void freenect_set_video_chunk_callback(struct _freenect_device *dev, void (*cb)(void *, void *, signed int, signed int, void *))
{
  dev->video_chunk_cb = cb;
}

// freenect_set_video_mode
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 612
signed int freenect_set_video_mode(struct _freenect_device *dev, const struct anonymous_6 mode)
{
  struct _freenect_context *freenect_set_video_mode__1__ctx = dev->parent;
  if(!(dev->video.running == 0))
  {
    fn_log(freenect_set_video_mode__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Tried to set video mode while stream is active\n");
    return -1;
  }

  else
  {
    signed int found = 0;
    signed int i = 0;
    for( ; !(i >= 12); i = i + 1)
      if(supported_video_modes[(signed long int)i].reserved == mode.reserved)
      {
        found = 1;
        break;
      }

    if(found == 0)
    {
      fn_log(freenect_set_video_mode__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_set_video_mode: freenect_frame_mode provided is invalid\n");
      return -1;
    }

    else
    {
      enum anonymous_13 res = (enum anonymous_13)(mode.reserved >> 8 & (unsigned int)0xff);
      enum anonymous_4 fmt = (enum anonymous_4)(mode.reserved & (unsigned int)0xff);
      dev->video_format = fmt;
      dev->video_resolution = res;
      freenect_fetch_reg_info(dev);
      return 0;
    }
  }
}

// freenect_shutdown
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 230
signed int freenect_shutdown(struct _freenect_context *ctx)
{
  while(!(ctx->first == ((struct _freenect_device *)NULL)))
  {
    fn_log(ctx, (enum anonymous_21)FREENECT_LOG_NOTICE, "Device %p open during shutdown, closing...\n", ctx->first);
    freenect_close_device(ctx->first);
  }
  fnusb_shutdown(&ctx->usb);
  free((void *)ctx);
  return 0;
}

// freenect_start_audio
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 149
signed int freenect_start_audio(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_start_audio__1__ctx = dev->parent;
  signed int res;
  if(!(dev->audio.running == 0))
    return -1;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)256 * sizeof(struct anonymous_16) /*12ul*/ );
    dev->audio.audio_out_ring = (struct anonymous_16 *)return_value_malloc_1;
    memset((void *)dev->audio.audio_out_ring, 0, (unsigned long int)256 * sizeof(struct anonymous_16) /*12ul*/ );
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)256 * sizeof(signed short int) /*2ul*/ );
    dev->audio.cancelled_buffer = (signed short int *)return_value_malloc_2;
    memset((void *)dev->audio.cancelled_buffer, 0, (unsigned long int)256 * sizeof(signed short int) /*2ul*/ );
    signed int i = 0;
    for( ; !(i >= 4); i = i + 1)
    {
      void *return_value_malloc_3;
      return_value_malloc_3=malloc((unsigned long int)256 * sizeof(signed int) /*4ul*/ );
      dev->audio.mic_buffer[(signed long int)i] = (signed int *)return_value_malloc_3;
      memset((void *)dev->audio.mic_buffer[(signed long int)i], 0, (unsigned long int)256 * sizeof(signed int) /*4ul*/ );
    }
    dev->audio.in_unknown=malloc((unsigned long int)48);
    dev->audio.ring_reader_idx = 0;
    dev->audio.ring_writer_idx = 0;
    dev->audio.out_window = (unsigned short int)0;
    dev->audio.out_seq = (unsigned char)0;
    dev->audio.out_counter_within_window = (unsigned char)0;
    dev->audio.out_weird_timestamp = (unsigned short int)0;
    dev->audio.out_window_parity = (unsigned char)0;
    dev->audio.in_window = (unsigned short int)0;
    dev->audio.in_counter = (unsigned char)0;
    i = 0;
    for( ; !(i >= 10); i = i + 1)
      dev->audio.last_seen_window[(signed long int)i] = (unsigned short int)0;
    res=fnusb_start_iso(&dev->usb_audio, &dev->audio_in_isoc, iso_in_callback, (unsigned char)0x82, 16, 16, 524);
    if(!(res >= 0))
    {
      fn_log(freenect_start_audio__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "audio: failed to start isochronous IN stream: %d\n", res);
      return res;
    }

    else
    {
      res=fnusb_start_iso(&dev->usb_audio, &dev->audio_out_isoc, iso_out_callback, (unsigned char)0x02, 16, 16, 76);
      if(!(res >= 0))
      {
        fn_log(freenect_start_audio__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "audio: failed to start isochronous OUT stream: %d\n", res);
        return res;
      }

      else
      {
        dev->audio.running = 1;
        return 0;
      }
    }
  }
}

// freenect_start_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 456
signed int freenect_start_depth(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_start_depth__1__ctx = dev->parent;
  struct anonymous_6 return_value_freenect_find_depth_mode_1;
  struct anonymous_6 return_value_freenect_find_depth_mode_2;
  struct anonymous_6 return_value_freenect_find_depth_mode_3;
  struct anonymous_6 return_value_freenect_find_depth_mode_4;
  struct anonymous_6 return_value_freenect_find_depth_mode_5;
  if(!(dev->depth.running == 0))
    return -1;

  else
  {
    dev->depth.pkt_size = 1760 - 12;
    dev->depth.flag = (unsigned char)0x70;
    dev->depth.variable_length = 0;
    switch((signed int)dev->depth_format)
    {
      case FREENECT_DEPTH_REGISTERED:

      case FREENECT_DEPTH_MM:
        freenect_init_registration(dev);
      case FREENECT_DEPTH_11BIT:
      {
        return_value_freenect_find_depth_mode_1=freenect_find_depth_mode(dev->depth_resolution, (enum anonymous_5)FREENECT_DEPTH_11BIT_PACKED);
        return_value_freenect_find_depth_mode_2=freenect_find_depth_mode(dev->depth_resolution, (enum anonymous_5)FREENECT_DEPTH_11BIT);
        stream_init(freenect_start_depth__1__ctx, &dev->depth, return_value_freenect_find_depth_mode_1.bytes, return_value_freenect_find_depth_mode_2.bytes);
        break;
      }
      case FREENECT_DEPTH_10BIT:
      {
        return_value_freenect_find_depth_mode_3=freenect_find_depth_mode(dev->depth_resolution, (enum anonymous_5)FREENECT_DEPTH_10BIT_PACKED);
        return_value_freenect_find_depth_mode_4=freenect_find_depth_mode(dev->depth_resolution, (enum anonymous_5)FREENECT_DEPTH_10BIT);
        stream_init(freenect_start_depth__1__ctx, &dev->depth, return_value_freenect_find_depth_mode_3.bytes, return_value_freenect_find_depth_mode_4.bytes);
        break;
      }
      case FREENECT_DEPTH_11BIT_PACKED:

      case FREENECT_DEPTH_10BIT_PACKED:
      {
        return_value_freenect_find_depth_mode_5=freenect_find_depth_mode(dev->depth_resolution, dev->depth_format);
        stream_init(freenect_start_depth__1__ctx, &dev->depth, 0, return_value_freenect_find_depth_mode_5.bytes);
        break;
      }
      default:
      {
        fn_log(freenect_start_depth__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_start_depth() called with invalid depth format %d\n", dev->depth_format);
        return -1;
      }
    }
    const unsigned char depth_endpoint = (const unsigned char)0x82;
    signed int packet_size;
    packet_size=fnusb_get_max_iso_packet_size(&dev->usb_cam, depth_endpoint, 1920);
    fn_log(freenect_start_depth__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "[Stream 70] Negotiated packet size %d\n", packet_size);
    signed int res;
    res=fnusb_start_iso(&dev->usb_cam, &dev->depth_isoc, depth_process, depth_endpoint, 16, 16, packet_size);
    if(!(res >= 0))
      return res;

    else
    {
      write_register(dev, (unsigned short int)0x105, (unsigned short int)0x00);
      write_register(dev, (unsigned short int)0x06, (unsigned short int)0x00);
      switch((signed int)dev->depth_format)
      {
        case FREENECT_DEPTH_11BIT:

        case FREENECT_DEPTH_11BIT_PACKED:

        case FREENECT_DEPTH_REGISTERED:

        case FREENECT_DEPTH_MM:
        {
          write_register(dev, (unsigned short int)0x12, (unsigned short int)0x03);
          goto __CPROVER_DUMP_L11;
        }
        case FREENECT_DEPTH_10BIT:

        case FREENECT_DEPTH_10BIT_PACKED:
          write_register(dev, (unsigned short int)0x12, (unsigned short int)0x02);
        case FREENECT_DEPTH_DUMMY:

        default:
        {

        __CPROVER_DUMP_L11:
          ;
          write_register(dev, (unsigned short int)0x13, (unsigned short int)0x01);
          write_register(dev, (unsigned short int)0x14, (unsigned short int)0x1e);
          write_register(dev, (unsigned short int)0x06, (unsigned short int)0x02);
          write_register(dev, (unsigned short int)0x17, (unsigned short int)0x00);
          dev->depth.running = 1;
          return 0;
        }
      }
    }
  }
}

// freenect_start_video
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 465
signed int freenect_start_video(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_start_video__1__ctx = dev->parent;
  struct anonymous_6 return_value_freenect_find_video_mode_1;
  struct anonymous_6 return_value_freenect_find_video_mode_2;
  struct anonymous_6 return_value_freenect_find_video_mode_3;
  struct anonymous_6 return_value_freenect_find_video_mode_4;
  if(!(dev->video.running == 0))
    return -1;

  else
  {
    dev->video.pkt_size = 1920 - 12;
    dev->video.flag = (unsigned char)0x80;
    dev->video.variable_length = 0;
    unsigned short int mode_reg;
    unsigned short int mode_value;
    unsigned short int res_reg;
    unsigned short int res_value;
    unsigned short int fps_reg;
    unsigned short int fps_value;
    unsigned short int hflip_reg;
    switch((signed int)dev->video_format)
    {
      case FREENECT_VIDEO_RGB:

      case FREENECT_VIDEO_BAYER:
      {
        if((signed int)dev->video_resolution == FREENECT_RESOLUTION_HIGH)
        {
          mode_value = (unsigned short int)0x00;
          res_value = (unsigned short int)0x02;
          fps_value = (unsigned short int)0x0f;
        }

        else
          if((signed int)dev->video_resolution == FREENECT_RESOLUTION_MEDIUM)
          {
            mode_value = (unsigned short int)0x00;
            res_value = (unsigned short int)0x01;
            fps_value = (unsigned short int)0x1e;
          }

          else
          {
            fn_log(freenect_start_video__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_start_video(): called with invalid format/resolution combination\n");
            return -1;
          }
        mode_reg = (unsigned short int)0x0c;
        res_reg = (unsigned short int)0x0d;
        fps_reg = (unsigned short int)0x0e;
        hflip_reg = (unsigned short int)0x47;
        break;
      }
      case FREENECT_VIDEO_IR_8BIT:

      case FREENECT_VIDEO_IR_10BIT:

      case FREENECT_VIDEO_IR_10BIT_PACKED:
      {
        if((signed int)dev->video_resolution == FREENECT_RESOLUTION_HIGH)
        {
          if(!(dev->depth.running == 0))
          {
            fn_log(freenect_start_video__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_start_video(): cannot stream high-resolution IR at same time as depth stream\n");
            return -1;
          }

          write_register(dev, (unsigned short int)0x13, (unsigned short int)0x01);
          write_register(dev, (unsigned short int)0x14, (unsigned short int)0x1e);
          write_register(dev, (unsigned short int)0x06, (unsigned short int)0x02);
          write_register(dev, (unsigned short int)0x06, (unsigned short int)0x00);
          mode_value = (unsigned short int)0x00;
          res_value = (unsigned short int)0x02;
          fps_value = (unsigned short int)0x0f;
        }

        else
          if((signed int)dev->video_resolution == FREENECT_RESOLUTION_MEDIUM)
          {
            mode_value = (unsigned short int)0x00;
            res_value = (unsigned short int)0x01;
            fps_value = (unsigned short int)0x1e;
          }

          else
          {
            fn_log(freenect_start_video__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_start_video(): called with invalid format/resolution combination\n");
            return -1;
          }
        mode_reg = (unsigned short int)0x19;
        res_reg = (unsigned short int)0x1a;
        fps_reg = (unsigned short int)0x1b;
        hflip_reg = (unsigned short int)0x48;
        break;
      }
      case FREENECT_VIDEO_YUV_RGB:

      case FREENECT_VIDEO_YUV_RAW:
      {
        if((signed int)dev->video_resolution == FREENECT_RESOLUTION_MEDIUM)
        {
          mode_value = (unsigned short int)0x05;
          res_value = (unsigned short int)0x01;
          fps_value = (unsigned short int)0x0f;
        }

        else
        {
          fn_log(freenect_start_video__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_start_video(): called with invalid format/resolution combination\n");
          return -1;
        }
        mode_reg = (unsigned short int)0x0c;
        res_reg = (unsigned short int)0x0d;
        fps_reg = (unsigned short int)0x0e;
        hflip_reg = (unsigned short int)0x47;
        break;
      }
      default:
      {
        fn_log(freenect_start_video__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "freenect_start_video(): called with invalid video format %d\n", dev->video_format);
        return -1;
      }
    }
    struct anonymous_6 frame_mode;
    frame_mode=freenect_get_current_video_mode(dev);
    switch((signed int)dev->video_format)
    {
      case FREENECT_VIDEO_RGB:
      {
        return_value_freenect_find_video_mode_1=freenect_find_video_mode(dev->video_resolution, (enum anonymous_4)FREENECT_VIDEO_BAYER);
        stream_init(freenect_start_video__1__ctx, &dev->video, return_value_freenect_find_video_mode_1.bytes, frame_mode.bytes);
        break;
      }
      case FREENECT_VIDEO_BAYER:
      {
        stream_init(freenect_start_video__1__ctx, &dev->video, 0, frame_mode.bytes);
        break;
      }
      case FREENECT_VIDEO_IR_8BIT:
      {
        return_value_freenect_find_video_mode_2=freenect_find_video_mode(dev->video_resolution, (enum anonymous_4)FREENECT_VIDEO_IR_10BIT_PACKED);
        stream_init(freenect_start_video__1__ctx, &dev->video, return_value_freenect_find_video_mode_2.bytes, frame_mode.bytes);
        break;
      }
      case FREENECT_VIDEO_IR_10BIT:
      {
        return_value_freenect_find_video_mode_3=freenect_find_video_mode(dev->video_resolution, (enum anonymous_4)FREENECT_VIDEO_IR_10BIT_PACKED);
        stream_init(freenect_start_video__1__ctx, &dev->video, return_value_freenect_find_video_mode_3.bytes, frame_mode.bytes);
        break;
      }
      case FREENECT_VIDEO_IR_10BIT_PACKED:
      {
        stream_init(freenect_start_video__1__ctx, &dev->video, 0, frame_mode.bytes);
        break;
      }
      case FREENECT_VIDEO_YUV_RGB:
      {
        return_value_freenect_find_video_mode_4=freenect_find_video_mode(dev->video_resolution, (enum anonymous_4)FREENECT_VIDEO_YUV_RAW);
        stream_init(freenect_start_video__1__ctx, &dev->video, return_value_freenect_find_video_mode_4.bytes, frame_mode.bytes);
        break;
      }
      case FREENECT_VIDEO_YUV_RAW:
      {
        stream_init(freenect_start_video__1__ctx, &dev->video, 0, frame_mode.bytes);
        break;
      }
      case FREENECT_VIDEO_DUMMY:
        ;
    }
    const unsigned char video_endpoint = (const unsigned char)0x81;
    signed int packet_size;
    packet_size=fnusb_get_max_iso_packet_size(&dev->usb_cam, video_endpoint, 1920);
    fn_log(freenect_start_video__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "[Stream 80] Negotiated packet size %d\n", packet_size);
    signed int res;
    res=fnusb_start_iso(&dev->usb_cam, &dev->video_isoc, video_process, video_endpoint, 16, 16, packet_size);
    if(!(res >= 0))
      return res;

    else
    {
      write_register(dev, mode_reg, mode_value);
      write_register(dev, res_reg, res_value);
      write_register(dev, fps_reg, fps_value);
      switch((signed int)dev->video_format)
      {
        case FREENECT_VIDEO_RGB:

        case FREENECT_VIDEO_BAYER:

        case FREENECT_VIDEO_YUV_RGB:

        case FREENECT_VIDEO_YUV_RAW:
        {
          write_register(dev, (unsigned short int)0x05, (unsigned short int)0x01);
          goto __CPROVER_DUMP_L28;
        }
        case FREENECT_VIDEO_IR_8BIT:

        case FREENECT_VIDEO_IR_10BIT:

        case FREENECT_VIDEO_IR_10BIT_PACKED:
        {
          write_register(dev, (unsigned short int)0x105, (unsigned short int)0x00);
          write_register(dev, (unsigned short int)0x05, (unsigned short int)0x03);
        }
        case FREENECT_VIDEO_DUMMY:

        default:
        {

        __CPROVER_DUMP_L28:
          ;
          write_register(dev, hflip_reg, (unsigned short int)0x00);
          dev->video.running = 1;
          return 0;
        }
      }
    }
  }
}

// freenect_stop_audio
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect_audio.h line 110
signed int freenect_stop_audio(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_stop_audio__1__ctx = dev->parent;
  signed int res;
  signed int ret = 0;
  if(dev->audio.running == 0)
    return -1;

  else
  {
    dev->audio.running = 0;
    res=fnusb_stop_iso(&dev->usb_audio, &dev->audio_in_isoc);
    if(!(res >= 0))
    {
      fn_log(freenect_stop_audio__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "audio: failed to stop isochronous IN stream: %d\n", res);
      return res;
    }

    else
    {
      res=fnusb_stop_iso(&dev->usb_audio, &dev->audio_out_isoc);
      if(!(res >= 0))
      {
        fn_log(freenect_stop_audio__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "audio: failed to stop isochronous OUT stream: %d\n", res);
        return res;
      }

      else
      {
        if(!(dev->audio.audio_out_ring == ((struct anonymous_16 *)NULL)))
          free((void *)dev->audio.audio_out_ring);

        if(!(dev->audio.cancelled_buffer == ((signed short int *)NULL)))
          free((void *)dev->audio.cancelled_buffer);

        if(!(dev->audio.in_unknown == NULL))
          free(dev->audio.in_unknown);

        signed int i = 0;
        for( ; !(i >= 4); i = i + 1)
        {
          if(!(dev->audio.mic_buffer[(signed long int)i] == ((signed int *)NULL)))
            free((void *)dev->audio.mic_buffer[(signed long int)i]);

          dev->audio.mic_buffer[(signed long int)i] = (signed int *)(void *)0;
        }
        dev->audio.audio_out_ring = (struct anonymous_16 *)(void *)0;
        dev->audio.cancelled_buffer = (signed short int *)(void *)0;
        dev->audio.in_unknown = (void *)0;
        return ret;
      }
    }
  }
}

// freenect_stop_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 474
signed int freenect_stop_depth(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_stop_depth__1__ctx = dev->parent;
  signed int res;
  if(dev->depth.running == 0)
    return -1;

  else
  {
    dev->depth.running = 0;
    write_register(dev, (unsigned short int)0x06, (unsigned short int)0x00);
    res=fnusb_stop_iso(&dev->usb_cam, &dev->depth_isoc);
    if(!(res >= 0))
    {
      fn_log(freenect_stop_depth__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Failed to stop depth isochronous stream: %d\n", res);
      return res;
    }

    else
    {
      freenect_destroy_registration(&dev->registration);
      stream_freebufs(freenect_stop_depth__1__ctx, &dev->depth);
      return 0;
    }
  }
}

// freenect_stop_video
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 483
signed int freenect_stop_video(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_stop_video__1__ctx = dev->parent;
  signed int res;
  if(dev->video.running == 0)
    return -1;

  else
  {
    dev->video.running = 0;
    write_register(dev, (unsigned short int)0x05, (unsigned short int)0x00);
    res=fnusb_stop_iso(&dev->usb_cam, &dev->video_isoc);
    if(!(res >= 0))
    {
      fn_log(freenect_stop_video__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Failed to stop RGB isochronous stream: %d\n", res);
      return res;
    }

    else
    {
      stream_freebufs(freenect_stop_video__1__ctx, &dev->video);
      return 0;
    }
  }
}

// freenect_supported_subdevices
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/core.c line 128
signed int freenect_supported_subdevices(void)
{
  return FREENECT_DEVICE_MOTOR | FREENECT_DEVICE_CAMERA | FREENECT_DEVICE_AUDIO;
}

// freenect_sync_camera_to_world
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 426
signed int freenect_sync_camera_to_world(signed int cx, signed int cy, signed int wz, double *wx, double *wy, signed int index)
{
  signed int return_value_runloop_enter_1;
  return_value_runloop_enter_1=runloop_enter(index);
  if(!(return_value_runloop_enter_1 == 0))
    return -1;

  else
  {
    freenect_camera_to_world(kinects[(signed long int)index]->dev, cx, cy, wz, wx, wy);
    runloop_exit();
    return 0;
  }
}

// freenect_sync_get_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/../wrappers/c_sync/libfreenect_sync.h line 92
signed int freenect_sync_get_depth(void **depth, unsigned int *timestamp, signed int index, enum anonymous_5 fmt)
{
  signed int return_value_freenect_sync_get_depth_with_res_1;
  return_value_freenect_sync_get_depth_with_res_1=freenect_sync_get_depth_with_res(depth, timestamp, index, (enum anonymous_13)FREENECT_RESOLUTION_MEDIUM, fmt);
  return return_value_freenect_sync_get_depth_with_res_1;
}

// freenect_sync_get_depth_with_res
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 383
signed int freenect_sync_get_depth_with_res(void **depth, unsigned int *timestamp, signed int index, enum anonymous_13 res, enum anonymous_5 fmt)
{
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  signed int return_value_setup_kinect_1;
  if(index >= 64 || !(index >= 0))
  {
    printf("Error: Invalid index [%d]\n", index);
    return -1;
  }

  else
  {
    if(thread_running == 0)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = !(kinects[(signed long int)index] != ((struct sync_kinect *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = kinects[(signed long int)index]->depth.fmt != (signed int)fmt ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = kinects[(signed long int)index]->depth.res != (signed int)res ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
    {
      return_value_setup_kinect_1=setup_kinect(index, (signed int)res, (signed int)fmt, 1);
      if(return_value_setup_kinect_1 == 0)
        goto __CPROVER_DUMP_L8;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      sync_get(depth, timestamp, &kinects[(signed long int)index]->depth);
      return 0;
    }
  }
}

// freenect_sync_get_tilt_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 403
signed int freenect_sync_get_tilt_state(struct anonymous_18 **state, signed int index)
{
  signed int return_value_runloop_enter_1;
  return_value_runloop_enter_1=runloop_enter(index);
  if(!(return_value_runloop_enter_1 == 0))
    return -1;

  else
  {
    freenect_update_tilt_state(kinects[(signed long int)index]->dev);
    *state=freenect_get_tilt_state(kinects[(signed long int)index]->dev);
    runloop_exit();
    return 0;
  }
}

// freenect_sync_get_video
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/../wrappers/c_sync/libfreenect_sync.h line 68
signed int freenect_sync_get_video(void **video, unsigned int *timestamp, signed int index, enum anonymous_4 fmt)
{
  signed int return_value_freenect_sync_get_video_with_res_1;
  return_value_freenect_sync_get_video_with_res_1=freenect_sync_get_video_with_res(video, timestamp, index, (enum anonymous_13)FREENECT_RESOLUTION_MEDIUM, fmt);
  return return_value_freenect_sync_get_video_with_res_1;
}

// freenect_sync_get_video_with_res
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 364
signed int freenect_sync_get_video_with_res(void **video, unsigned int *timestamp, signed int index, enum anonymous_13 res, enum anonymous_4 fmt)
{
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  signed int return_value_setup_kinect_1;
  if(index >= 64 || !(index >= 0))
  {
    printf("Error: Invalid index [%d]\n", index);
    return -1;
  }

  else
  {
    if(thread_running == 0)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = !(kinects[(signed long int)index] != ((struct sync_kinect *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = kinects[(signed long int)index]->video.fmt != (signed int)fmt ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = kinects[(signed long int)index]->video.res != (signed int)res ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
    {
      return_value_setup_kinect_1=setup_kinect(index, (signed int)res, (signed int)fmt, 0);
      if(return_value_setup_kinect_1 == 0)
        goto __CPROVER_DUMP_L8;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      sync_get(video, timestamp, &kinects[(signed long int)index]->video);
      return 0;
    }
  }
}

// freenect_sync_set_led
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 419
signed int freenect_sync_set_led(enum anonymous_23 led, signed int index)
{
  signed int return_value_runloop_enter_1;
  return_value_runloop_enter_1=runloop_enter(index);
  if(!(return_value_runloop_enter_1 == 0))
    return -1;

  else
  {
    freenect_set_led(kinects[(signed long int)index]->dev, led);
    runloop_exit();
    return 0;
  }
}

// freenect_sync_set_tilt_degs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 412
signed int freenect_sync_set_tilt_degs(signed int angle, signed int index)
{
  signed int return_value_runloop_enter_1;
  return_value_runloop_enter_1=runloop_enter(index);
  if(!(return_value_runloop_enter_1 == 0))
    return -1;

  else
  {
    freenect_set_tilt_degs(kinects[(signed long int)index]->dev, (double)angle);
    runloop_exit();
    return 0;
  }
}

// freenect_sync_stop
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 433
void freenect_sync_stop(void)
{
  if(!(thread_running == 0))
  {
    thread_running = 0;
    pthread_join(thread, (void **)(void *)0);
  }

}

// freenect_update_tilt_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/include/libfreenect.h line 494
signed int freenect_update_tilt_state(struct _freenect_device *dev)
{
  struct _freenect_context *freenect_update_tilt_state__1__ctx = dev->parent;
  if(!(dev->motor_control_with_audio_enabled == 0))
  {
    signed int return_value_update_tilt_state_alt_1;
    return_value_update_tilt_state_alt_1=update_tilt_state_alt(dev);
    return return_value_update_tilt_state_alt_1;
  }

  if((FREENECT_DEVICE_MOTOR & (signed int)freenect_update_tilt_state__1__ctx->enabled_subdevices) == 0)
    return 0;

  else
  {
    unsigned char buf[10l];
    unsigned short int ux;
    unsigned short int uy;
    unsigned short int uz;
    signed int ret;
    ret=fnusb_control(&dev->usb_motor, (unsigned char)0xC0, (unsigned char)0x32, (unsigned short int)0x0, (unsigned short int)0x0, buf, (unsigned short int)10);
    if(!(ret == 10))
    {
      fn_log(freenect_update_tilt_state__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Error in accelerometer reading, libusb_control_transfer returned %d\n", ret);
      return ret < 0 ? ret : -1;
    }

    else
    {
      ux = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)2] << 8 | (signed int)buf[(signed long int)3]);
      uy = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)4] << 8 | (signed int)buf[(signed long int)5]);
      uz = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)6] << 8 | (signed int)buf[(signed long int)7]);
      dev->raw_state.accelerometer_x = (signed short int)ux;
      dev->raw_state.accelerometer_y = (signed short int)uy;
      dev->raw_state.accelerometer_z = (signed short int)uz;
      dev->raw_state.tilt_angle = (signed char)buf[(signed long int)8];
      dev->raw_state.tilt_status = (enum anonymous_32)buf[(signed long int)9];
      return ret;
    }
  }
}

// get_reply
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 60
signed int get_reply(struct libusb_device_handle *dev, struct _freenect_context *ctx)
{
  unsigned char buffer[512l];
  memset((void *)buffer, 0, (unsigned long int)512);
  signed int transferred = 0;
  signed int res = 0;
  res=libusb_bulk_transfer(dev, (unsigned char)0x81, buffer, 512, &transferred, (unsigned int)100);
  if(!(res == 0))
    fn_log(ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "get_reply(): libusb_bulk_transfer failed: %d (transferred = %d)\n", res, transferred);

  else
    if(!(transferred == 12))
      fn_log(ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "get_reply(): weird - got %d bytes (expected 12)\n", transferred);

    else
    {
      struct anonymous_3 reply;
      memcpy((void *)&reply, (const void *)buffer, sizeof(struct anonymous_3) /*12ul*/ );
      if(!(reply.magic == 175104000u))
      {
        fn_log(ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Bad magic: %08X (expected 0A6FE000\n", reply.magic);
        res = -1;
      }

      if(!(reply.status == 0u))
      {
        fn_log(ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "reply status != 0: failure?\n");
        res = -1;
      }

      tag_next_ack = tag_next_ack + 1;
    }
  return res;
}

// get_reply_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 50
static signed int get_reply_link1(struct anonymous_10 *dev_link1)
{
  struct _freenect_context *get_reply__1__ctx = dev_link1->parent->parent;
  unsigned char dump[512l];
  struct anonymous_3 buffer_link1;
  signed int res_link1;
  signed int transferred_link1;
  res_link1=fnusb_bulk(dev_link1, (unsigned char)0x81, dump, 512, &transferred_link1);
  if(!(res_link1 == 0) || !((unsigned long int)transferred_link1 == sizeof(struct anonymous_3) /*12ul*/ ))
  {
    fn_log(get_reply__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Error reading reply: %d\ttransferred: %d (expected %d)\n", res_link1, transferred_link1, (signed int)sizeof(struct anonymous_3) /*12ul*/ );
    return res_link1;
  }

  else
  {
    memcpy((void *)&buffer_link1, (const void *)dump, sizeof(struct anonymous_3) /*12ul*/ );
    if(!(buffer_link1.magic == 175104000u))
    {
      fn_log(get_reply__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Error reading reply: invalid magic %08X\n", buffer_link1.magic);
      return -1;
    }

    else
      if(!(buffer_link1.tag == dev_link1->parent->audio_tag))
      {
        fn_log(get_reply__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Error reading reply: non-matching tag number %08X (expected %08X)\n", buffer_link1.tag, dev_link1->parent->audio_tag);
        return -1;
      }

      else
      {
        if(!(buffer_link1.status == 0u))
          fn_log(get_reply__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Notice reading reply: last uint32_t was nonzero: %d\n", buffer_link1.status);

        fn_log(get_reply__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "Reading reply: ");
        signed int i = 0;
        for( ; !(i >= transferred_link1); i = i + 1)
          fn_log(get_reply__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "%02X ", ((unsigned char *)&buffer_link1)[(signed long int)i]);
        fn_log(get_reply__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "\n");
        return res_link1;
      }
  }
}

// get_reply_link1_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 50
static signed int get_reply_link1_link1(struct anonymous_10 *dev_link1_link1)
{
  struct _freenect_context *ctx_link1 = dev_link1_link1->parent->parent;
  unsigned char dump_link1[512l];
  struct anonymous_3 buffer_link1_link1;
  signed int res_link1_link1;
  signed int transferred_link1_link1;
  res_link1_link1=fnusb_bulk(dev_link1_link1, (unsigned char)0x81, dump_link1, 512, &transferred_link1_link1);
  if(!(res_link1_link1 == 0) || !((unsigned long int)transferred_link1_link1 == sizeof(struct anonymous_3) /*12ul*/ ))
  {
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "Error reading reply: %d\ttransferred: %d (expected %d)\n", res_link1_link1, transferred_link1_link1, (signed int)sizeof(struct anonymous_3) /*12ul*/ );
    return res_link1_link1;
  }

  else
  {
    memcpy((void *)&buffer_link1_link1, (const void *)dump_link1, sizeof(struct anonymous_3) /*12ul*/ );
    if(!(buffer_link1_link1.magic == 175104000u))
    {
      fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "Error reading reply: invalid magic %08X\n", buffer_link1_link1.magic);
      return -1;
    }

    else
      if(!(buffer_link1_link1.tag == dev_link1_link1->parent->audio_tag))
      {
        fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "Error reading reply: non-matching tag number %08X (expected %08X)\n", buffer_link1_link1.tag, dev_link1_link1->parent->audio_tag);
        return -1;
      }

      else
      {
        if(!(buffer_link1_link1.status == 0u))
          fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "Notice reading reply: last uint32_t was nonzero: %d\n", buffer_link1_link1.status);

        fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_INFO, "Reading reply: ");
        signed int i_link1 = 0;
        for( ; !(i_link1 >= transferred_link1_link1); i_link1 = i_link1 + 1)
          fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_INFO, "%02X ", ((unsigned char *)&buffer_link1_link1)[(signed long int)i_link1]);
        fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_INFO, "\n");
        return res_link1_link1;
      }
  }
}

// init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 185
static void * init(void *unused)
{
  pending_runloop_tasks_wait_zero();
  pthread_mutex_lock(&runloop_lock);
  signed int return_value_freenect_process_events_1;
  while(!(thread_running == 0))
  {
    return_value_freenect_process_events_1=freenect_process_events(ctx);
    if(!(return_value_freenect_process_events_1 >= 0))
      break;

    pthread_mutex_unlock(&runloop_lock);
    pending_runloop_tasks_wait_zero();
    pthread_mutex_lock(&runloop_lock);
  }
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!(kinects[(signed long int)i] == ((struct sync_kinect *)NULL)))
    {
      freenect_stop_video(kinects[(signed long int)i]->dev);
      freenect_stop_depth(kinects[(signed long int)i]->dev);
      freenect_set_user(kinects[(signed long int)i]->dev, (void *)0);
      freenect_close_device(kinects[(signed long int)i]->dev);
      free_buffer_ring(&kinects[(signed long int)i]->video);
      free_buffer_ring(&kinects[(signed long int)i]->depth);
      free((void *)kinects[(signed long int)i]);
      kinects[(signed long int)i] = (struct sync_kinect *)(void *)0;
    }

  freenect_shutdown(ctx);
  pthread_mutex_unlock(&runloop_lock);
  return (void *)0;
}

// init_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 214
static void init_thread(void)
{
  thread_running = 1;
  freenect_init(&ctx, NULL);
  freenect_select_subdevices(ctx, (enum anonymous_22)(FREENECT_DEVICE_MOTOR | FREENECT_DEVICE_CAMERA));
  pthread_create(&thread, (const union pthread_attr_t *)(void *)0, init, (void *)0);
}

// iso_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 703
static void iso_callback(struct libusb_transfer *xfer)
{
  signed int i;
  struct anonymous_11 *strm = (struct anonymous_11 *)xfer->user_data;
  struct _freenect_context *iso_callback__1__ctx = strm->parent->parent->parent;
  unsigned char *buf;
  signed int iso_callback__1__2__1__res;
  signed int res;
  if(!(strm->dead == 0))
  {
    strm->dead_xfers = strm->dead_xfers + 1;
    fn_log(iso_callback__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "EP %02x transfer complete, %d left\n", xfer->endpoint, strm->num_xfers - strm->dead_xfers);
  }

  else
    switch((signed int)xfer->status)
    {
      case LIBUSB_TRANSFER_COMPLETED:
      {
        buf = (unsigned char *)xfer->buffer;
        i = 0;
        if(!(i >= strm->pkts))
        {
          strm->cb(strm->parent->parent, buf, (signed int)xfer->iso_packet_desc[(signed long int)i].actual_length);
          buf = buf + (signed long int)strm->len;
          i = i + 1;
        }

        iso_callback__1__2__1__res=libusb_submit_transfer(xfer);
        if(!(iso_callback__1__2__1__res == 0))
        {
          fn_log(iso_callback__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "iso_callback(): failed to resubmit transfer after successful completion: %d\n", iso_callback__1__2__1__res);
          strm->dead_xfers = strm->dead_xfers + 1;
          if(iso_callback__1__2__1__res == -4)
            strm->parent->device_dead = 1;

        }

        break;
      }
      case LIBUSB_TRANSFER_NO_DEVICE:
      {
        if(strm->parent->device_dead == 0)
          fn_log(iso_callback__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "USB device disappeared, cancelling stream %02x :(\n", xfer->endpoint);

        strm->dead_xfers = strm->dead_xfers + 1;
        strm->parent->device_dead = 1;
        break;
      }
      case LIBUSB_TRANSFER_CANCELLED:
      {
        if(!(strm->dead == 0))
          fn_log(iso_callback__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "EP %02x transfer cancelled\n", xfer->endpoint);

        else
        {
          if(strm->parent->device_dead == 0)
            fn_log(iso_callback__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Got cancelled transfer, but we didn't request it - device disconnected?\n");

          strm->parent->device_dead = 1;
        }
        strm->dead_xfers = strm->dead_xfers + 1;
        break;
      }
      default:
      {
        fn_log(iso_callback__1__ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "Isochronous transfer error: %d\n", xfer->status);
        res=libusb_submit_transfer(xfer);
        if(!(res == 0))
        {
          fn_log(iso_callback__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Isochronous transfer resubmission failed after unknown error: %d\n", res);
          strm->dead_xfers = strm->dead_xfers + 1;
          if(res == -4)
            strm->parent->device_dead = 1;

        }

      }
    }
}

// iso_callback_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/usb_libusb10.c line 703
static void iso_callback_link1(struct libusb_transfer *xfer_link1)
{
  signed int i_link1;
  struct anonymous_11 *strm_link1 = (struct anonymous_11 *)xfer_link1->user_data;
  struct _freenect_context *ctx_link1 = strm_link1->parent->parent->parent;
  unsigned char *buf_link1;
  signed int iso_callback__1__2__1__res_link1;
  signed int res_link1;
  if(!(strm_link1->dead == 0))
  {
    strm_link1->dead_xfers = strm_link1->dead_xfers + 1;
    fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "EP %02x transfer complete, %d left\n", xfer_link1->endpoint, strm_link1->num_xfers - strm_link1->dead_xfers);
  }

  else
    switch((signed int)xfer_link1->status)
    {
      case LIBUSB_TRANSFER_COMPLETED:
      {
        buf_link1 = (unsigned char *)xfer_link1->buffer;
        i_link1 = 0;
        if(!(i_link1 >= strm_link1->pkts))
        {
          strm_link1->cb(strm_link1->parent->parent, buf_link1, (signed int)xfer_link1->iso_packet_desc[(signed long int)i_link1].actual_length);
          buf_link1 = buf_link1 + (signed long int)strm_link1->len;
          i_link1 = i_link1 + 1;
        }

        iso_callback__1__2__1__res_link1=libusb_submit_transfer(xfer_link1);
        if(!(iso_callback__1__2__1__res_link1 == 0))
        {
          fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "iso_callback(): failed to resubmit transfer after successful completion: %d\n", iso_callback__1__2__1__res_link1);
          strm_link1->dead_xfers = strm_link1->dead_xfers + 1;
          if(iso_callback__1__2__1__res_link1 == -4)
            strm_link1->parent->device_dead = 1;

        }

        break;
      }
      case LIBUSB_TRANSFER_NO_DEVICE:
      {
        if(strm_link1->parent->device_dead == 0)
          fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "USB device disappeared, cancelling stream %02x :(\n", xfer_link1->endpoint);

        strm_link1->dead_xfers = strm_link1->dead_xfers + 1;
        strm_link1->parent->device_dead = 1;
        break;
      }
      case LIBUSB_TRANSFER_CANCELLED:
      {
        if(!(strm_link1->dead == 0))
          fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "EP %02x transfer cancelled\n", xfer_link1->endpoint);

        else
        {
          if(strm_link1->parent->device_dead == 0)
            fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "Got cancelled transfer, but we didn't request it - device disconnected?\n");

          strm_link1->parent->device_dead = 1;
        }
        strm_link1->dead_xfers = strm_link1->dead_xfers + 1;
        break;
      }
      default:
      {
        fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_WARNING, "Isochronous transfer error: %d\n", xfer_link1->status);
        res_link1=libusb_submit_transfer(xfer_link1);
        if(!(res_link1 == 0))
        {
          fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "Isochronous transfer resubmission failed after unknown error: %d\n", res_link1);
          strm_link1->dead_xfers = strm_link1->dead_xfers + 1;
          if(res_link1 == -4)
            strm_link1->parent->device_dead = 1;

        }

      }
    }
}

// iso_in_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 85
static void iso_in_callback(struct _freenect_device *dev, unsigned char *pkt, signed int len)
{
  struct _freenect_context *iso_in_callback__1__ctx = dev->parent;
  if(len == 524)
  {
    struct anonymous_29 *block = (struct anonymous_29 *)pkt;
    if(!(block->magic == 0x80000080))
    {
      fn_log(iso_in_callback__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "audio: invalid magic in iso IN packet: %08X\n", block->magic);
      goto __CPROVER_DUMP_L16;
    }

    if(!(block->window == dev->audio.in_window))
    {
      fn_log(iso_in_callback__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "audio: IN window changed: was %04X now %04X\n", dev->audio.in_window, block->window);
      if(!(dev->audio_in_cb == ((void (*)(struct _freenect_device *, signed int, signed int *, signed int *, signed int *, signed int *, signed short int *, void *))NULL)))
        dev->audio_in_cb(dev, 256, dev->audio.mic_buffer[(signed long int)0], dev->audio.mic_buffer[(signed long int)1], dev->audio.mic_buffer[(signed long int)2], dev->audio.mic_buffer[(signed long int)3], dev->audio.cancelled_buffer, dev->audio.in_unknown);

      signed int t = 0;
      for( ; !(t >= 10); t = t + 1)
        if(!(dev->audio.last_seen_window[(signed long int)t] == dev->audio.in_window))
          fn_log(iso_in_callback__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "audio: did not receive data for channel 0x%02x\n", t + 1);

      if((signed int)block->window + -((signed int)dev->audio.in_window) >= 4)
        fn_log(iso_in_callback__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "audio: packet loss, dropped %d windows\n", (((signed int)block->window - (signed int)dev->audio.in_window) - 3) / 3);

      dev->audio.in_window = block->window;
    }

    switch((signed int)block->channel)
    {
      case 1:
      {
        memcpy((void *)dev->audio.cancelled_buffer, (const void *)&block->samples, (unsigned long int)512);
        break;
      }
      case 2:

      case 3:

      case 4:

      case 5:

      case 6:

      case 7:

      case 8:

      case 9:
      {
        if(!((1 & (signed int)block->channel) == 0))
          memcpy((void *)&dev->audio.mic_buffer[(signed long int)(((signed int)block->channel - 2) / 2)][(signed long int)128], (const void *)&block->samples, (unsigned long int)512);

        else
          memcpy((void *)dev->audio.mic_buffer[(signed long int)(((signed int)block->channel - 2) / 2)], (const void *)&block->samples, (unsigned long int)512);
        break;
      }
      default:
        fn_log(iso_in_callback__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "audio: invalid channel in iso IN packet: %d\n", block->channel);
    }
    dev->audio.last_seen_window[(signed long int)((signed int)block->channel - 1)] = block->window;
  }

  else
    if(!(len == 60))
    {
      if(!(len == 0))
        fn_log(iso_in_callback__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "audio: received an iso IN packet of strange length: %d\n", len);

    }


__CPROVER_DUMP_L16:
  ;
}

// iso_in_callback_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 85
static void iso_in_callback_link1(struct _freenect_device *dev_link1, unsigned char *pkt_link1, signed int len_link1)
{
  struct _freenect_context *ctx_link1 = dev_link1->parent;
  if(len_link1 == 524)
  {
    struct anonymous_29 *block_link1 = (struct anonymous_29 *)pkt_link1;
    if(!(block_link1->magic == 0x80000080))
    {
      fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "audio: invalid magic in iso IN packet: %08X\n", block_link1->magic);
      goto __CPROVER_DUMP_L16;
    }

    if(!(block_link1->window == dev_link1->audio.in_window))
    {
      fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "audio: IN window changed: was %04X now %04X\n", dev_link1->audio.in_window, block_link1->window);
      if(!(dev_link1->audio_in_cb == ((void (*)(struct _freenect_device *, signed int, signed int *, signed int *, signed int *, signed int *, signed short int *, void *))NULL)))
        dev_link1->audio_in_cb(dev_link1, 256, dev_link1->audio.mic_buffer[(signed long int)0], dev_link1->audio.mic_buffer[(signed long int)1], dev_link1->audio.mic_buffer[(signed long int)2], dev_link1->audio.mic_buffer[(signed long int)3], dev_link1->audio.cancelled_buffer, dev_link1->audio.in_unknown);

      signed int t_link1 = 0;
      for( ; !(t_link1 >= 10); t_link1 = t_link1 + 1)
        if(!(dev_link1->audio.last_seen_window[(signed long int)t_link1] == dev_link1->audio.in_window))
          fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "audio: did not receive data for channel 0x%02x\n", t_link1 + 1);

      if((signed int)block_link1->window + -((signed int)dev_link1->audio.in_window) >= 4)
        fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "audio: packet loss, dropped %d windows\n", (((signed int)block_link1->window - (signed int)dev_link1->audio.in_window) - 3) / 3);

      dev_link1->audio.in_window = block_link1->window;
    }

    switch((signed int)block_link1->channel)
    {
      case 1:
      {
        memcpy((void *)dev_link1->audio.cancelled_buffer, (const void *)&block_link1->samples, (unsigned long int)512);
        break;
      }
      case 2:

      case 3:

      case 4:

      case 5:

      case 6:

      case 7:

      case 8:

      case 9:
      {
        if(!((1 & (signed int)block_link1->channel) == 0))
          memcpy((void *)&dev_link1->audio.mic_buffer[(signed long int)(((signed int)block_link1->channel - 2) / 2)][(signed long int)128], (const void *)&block_link1->samples, (unsigned long int)512);

        else
          memcpy((void *)dev_link1->audio.mic_buffer[(signed long int)(((signed int)block_link1->channel - 2) / 2)], (const void *)&block_link1->samples, (unsigned long int)512);
        break;
      }
      default:
        fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "audio: invalid channel in iso IN packet: %d\n", block_link1->channel);
    }
    dev_link1->audio.last_seen_window[(signed long int)((signed int)block_link1->channel - 1)] = block_link1->window;
  }

  else
    if(!(len_link1 == 60))
    {
      if(!(len_link1 == 0))
        fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "audio: received an iso IN packet of strange length: %d\n", len_link1);

    }


__CPROVER_DUMP_L16:
  ;
}

// iso_out_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 81
static void iso_out_callback(struct _freenect_device *dev, unsigned char *pkt, signed int len)
{
  prepare_iso_out_data(dev, pkt);
}

// iso_out_callback_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 81
static void iso_out_callback_link1(struct _freenect_device *dev_link1, unsigned char *pkt_link1, signed int len_link1)
{
  prepare_iso_out_data_link1(dev_link1, pkt_link1);
}

// libusb_fill_iso_transfer
// file /usr/include/libusb-1.0/libusb.h line 1630
static inline void libusb_fill_iso_transfer(struct libusb_transfer *transfer, struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *buffer, signed int length, signed int num_iso_packets, void (*callback)(struct libusb_transfer *), void *user_data, unsigned int timeout)
{
  transfer->dev_handle = dev_handle;
  transfer->endpoint = endpoint;
  transfer->type = (unsigned char)1;
  transfer->timeout = timeout;
  transfer->buffer = buffer;
  transfer->length = length;
  transfer->num_iso_packets = num_iso_packets;
  transfer->user_data = user_data;
  transfer->callback = callback;
}

// libusb_fill_iso_transfer_link1
// file /usr/include/libusb-1.0/libusb.h line 1630
static inline void libusb_fill_iso_transfer_link1(struct libusb_transfer *transfer_link1, struct libusb_device_handle *dev_handle_link1, unsigned char endpoint_link1, unsigned char *buffer_link1, signed int length_link1, signed int num_iso_packets_link1, void (*callback_link1)(struct libusb_transfer *), void *user_data_link1, unsigned int timeout_link1)
{
  transfer_link1->dev_handle = dev_handle_link1;
  transfer_link1->endpoint = endpoint_link1;
  transfer_link1->type = (unsigned char)1;
  transfer_link1->timeout = timeout_link1;
  transfer_link1->buffer = buffer_link1;
  transfer_link1->length = length_link1;
  transfer_link1->num_iso_packets = num_iso_packets_link1;
  transfer_link1->user_data = user_data_link1;
  transfer_link1->callback = callback_link1;
}

// libusb_set_iso_packet_lengths
// file /usr/include/libusb-1.0/libusb.h line 1654
static inline void libusb_set_iso_packet_lengths(struct libusb_transfer *transfer, unsigned int length)
{
  signed int i = 0;
  for( ; !(i >= transfer->num_iso_packets); i = i + 1)
    transfer->iso_packet_desc[(signed long int)i].length = length;
}

// libusb_set_iso_packet_lengths_link1
// file /usr/include/libusb-1.0/libusb.h line 1654
static inline void libusb_set_iso_packet_lengths_link1(struct libusb_transfer *transfer_link1, unsigned int length_link1)
{
  signed int i_link1 = 0;
  for( ; !(i_link1 >= transfer_link1->num_iso_packets); i_link1 = i_link1 + 1)
    transfer_link1->iso_packet_desc[(signed long int)i_link1].length = length_link1;
}

// main
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regtest.c line 62
signed int main(void)
{
  signed short int *depth = ((signed short int *)NULL);
  char *rgb = ((char *)NULL);
  unsigned int ts;
  struct _IO_FILE *fp;
  signed int ret;
  ret=freenect_sync_get_video((void **)&rgb, &ts, 0, (enum anonymous_4)FREENECT_VIDEO_RGB);
  if(!(ret >= 0))
    no_kinect_quit();

  fp=open_dump("registration_test_rgb.ppm");
  dump_rgb(fp, (void *)rgb, (unsigned int)640, (unsigned int)480);
  fclose(fp);
  ret=freenect_sync_get_depth((void **)&depth, &ts, 0, (enum anonymous_5)FREENECT_DEPTH_11BIT);
  if(!(ret >= 0))
    no_kinect_quit();

  fp=open_dump("registration_test_depth_raw.pgm");
  dump_depth(fp, (void *)depth, (unsigned int)640, (unsigned int)480);
  fclose(fp);
  ret=freenect_sync_get_depth((void **)&depth, &ts, 0, (enum anonymous_5)FREENECT_DEPTH_REGISTERED);
  if(!(ret >= 0))
    no_kinect_quit();

  fp=open_dump("registration_test_depth_registered.pgm");
  dump_depth(fp, (void *)depth, (unsigned int)640, (unsigned int)480);
  fclose(fp);
  ret=freenect_sync_get_depth((void **)&depth, &ts, 0, (enum anonymous_5)FREENECT_DEPTH_MM);
  if(!(ret >= 0))
    no_kinect_quit();

  fp=open_dump("registration_test_depth_mm.pgm");
  dump_depth(fp, (void *)depth, (unsigned int)640, (unsigned int)480);
  fclose(fp);
  return 0;
}

// no_kinect_quit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regtest.c line 56
void no_kinect_quit(void)
{
  fprintf(stderr, "Error: Kinect not connected?\n");
  exit(1);
}

// open_dump
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/examples/regtest.c line 33
struct _IO_FILE * open_dump(const char *filename)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "w");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    fprintf(stderr, "Error: Cannot open file [%s]\n", filename);
    exit(1);
  }

  printf("%s\n", filename);
  return fp;
}

// pending_runloop_tasks_dec
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 167
static void pending_runloop_tasks_dec(void)
{
  pthread_mutex_lock(&pending_runloop_tasks_lock);
  pending_runloop_tasks = pending_runloop_tasks - 1;
  /* assertion pending_runloop_tasks >= 0 */
  assert(pending_runloop_tasks >= 0);
  if(pending_runloop_tasks == 0)
    pthread_cond_signal(&pending_runloop_tasks_cond);

  pthread_mutex_unlock(&pending_runloop_tasks_lock);
}

// pending_runloop_tasks_inc
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 159
static void pending_runloop_tasks_inc(void)
{
  pthread_mutex_lock(&pending_runloop_tasks_lock);
  /* assertion pending_runloop_tasks >= 0 */
  assert(pending_runloop_tasks >= 0);
  pending_runloop_tasks = pending_runloop_tasks + 1;
  pthread_mutex_unlock(&pending_runloop_tasks_lock);
}

// pending_runloop_tasks_wait_zero
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 177
static void pending_runloop_tasks_wait_zero(void)
{
  pthread_mutex_lock(&pending_runloop_tasks_lock);
  while(!(pending_runloop_tasks == 0))
    pthread_cond_wait(&pending_runloop_tasks_cond, &pending_runloop_tasks_lock);
  pthread_mutex_unlock(&pending_runloop_tasks_lock);
}

// prepare_iso_out_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 34
static void prepare_iso_out_data(struct _freenect_device *dev, unsigned char *buffer)
{
  struct anonymous_17 *stream = &dev->audio;
  if(dev->audio_out_cb == ((void (*)(struct _freenect_device *, struct anonymous_16 *, signed int *))NULL))
    memset((void *)buffer, 0, (unsigned long int)76);

  ((unsigned short int *)buffer)[(signed long int)0] = stream->out_window;
  buffer[(signed long int)2] = stream->out_seq;
  if((signed int)stream->out_window_parity == 0)
  {
    if(!((signed int)stream->out_counter_within_window >= 4))
      buffer[(signed long int)3] = (unsigned char)(((signed int)stream->out_weird_timestamp >> (signed int)stream->out_counter_within_window * 4 & 0x000f) << 4 | 0x05);

    else
      if(!((signed int)stream->out_counter_within_window >= 8))
        buffer[(signed long int)3] = (unsigned char)(((signed int)stream->out_weird_timestamp + 23 >> ((signed int)stream->out_counter_within_window - 4) * 4 & 0x000f) << 4 | 0x05);

      else
        buffer[(signed long int)3] = (unsigned char)0x01;
  }

  else
    if(!((signed int)stream->out_counter_within_window >= 4))
      buffer[(signed long int)3] = (unsigned char)(((signed int)stream->out_weird_timestamp >> (signed int)stream->out_counter_within_window * 4 & 0x000f) << 4 | 0x05);

    else
      buffer[(signed long int)3] = (unsigned char)0x01;
  stream->out_seq = stream->out_seq + 1;
  stream->out_counter_within_window = stream->out_counter_within_window + 1;
  stream->out_weird_timestamp = stream->out_weird_timestamp + (unsigned short int)((signed int)stream->out_window_parity == 1 ? 6 : 5);
  switch((signed int)stream->out_seq)
  {
    case 0x80:
      stream->out_seq = (unsigned char)0;
    case 0x2b:

    case 0x56:
    {
      stream->out_counter_within_window = (unsigned char)0;
      stream->out_window = stream->out_window + 1;
      stream->out_window_parity = stream->out_window_parity + 1;
    }
    default:
      if((signed int)stream->out_window_parity == 3)
        stream->out_window_parity = (unsigned char)0;

  }
}

// prepare_iso_out_data_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/audio.c line 34
static void prepare_iso_out_data_link1(struct _freenect_device *dev_link1, unsigned char *buffer_link1)
{
  struct anonymous_17 *stream_link1 = &dev_link1->audio;
  if(dev_link1->audio_out_cb == ((void (*)(struct _freenect_device *, struct anonymous_16 *, signed int *))NULL))
    memset((void *)buffer_link1, 0, (unsigned long int)76);

  ((unsigned short int *)buffer_link1)[(signed long int)0] = stream_link1->out_window;
  buffer_link1[(signed long int)2] = stream_link1->out_seq;
  if((signed int)stream_link1->out_window_parity == 0)
  {
    if(!((signed int)stream_link1->out_counter_within_window >= 4))
      buffer_link1[(signed long int)3] = (unsigned char)(((signed int)stream_link1->out_weird_timestamp >> (signed int)stream_link1->out_counter_within_window * 4 & 0x000f) << 4 | 0x05);

    else
      if(!((signed int)stream_link1->out_counter_within_window >= 8))
        buffer_link1[(signed long int)3] = (unsigned char)(((signed int)stream_link1->out_weird_timestamp + 23 >> ((signed int)stream_link1->out_counter_within_window - 4) * 4 & 0x000f) << 4 | 0x05);

      else
        buffer_link1[(signed long int)3] = (unsigned char)0x01;
  }

  else
    if(!((signed int)stream_link1->out_counter_within_window >= 4))
      buffer_link1[(signed long int)3] = (unsigned char)(((signed int)stream_link1->out_weird_timestamp >> (signed int)stream_link1->out_counter_within_window * 4 & 0x000f) << 4 | 0x05);

    else
      buffer_link1[(signed long int)3] = (unsigned char)0x01;
  stream_link1->out_seq = stream_link1->out_seq + 1;
  stream_link1->out_counter_within_window = stream_link1->out_counter_within_window + 1;
  stream_link1->out_weird_timestamp = stream_link1->out_weird_timestamp + (unsigned short int)((signed int)stream_link1->out_window_parity == 1 ? 6 : 5);
  switch((signed int)stream_link1->out_seq)
  {
    case 0x80:
      stream_link1->out_seq = (unsigned char)0;
    case 0x2b:

    case 0x56:
    {
      stream_link1->out_counter_within_window = (unsigned char)0;
      stream_link1->out_window = stream_link1->out_window + 1;
      stream_link1->out_window_parity = stream_link1->out_window_parity + 1;
    }
    default:
      if((signed int)stream_link1->out_window_parity == 3)
        stream_link1->out_window_parity = (unsigned char)0;

  }
}

// producer_cb_inner
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 134
static void producer_cb_inner(struct _freenect_device *dev, void *data, unsigned int timestamp, struct buffer_ring *buf, signed int (*set_buffer)(struct _freenect_device *, void *))
{
  pthread_mutex_lock(&buf->lock);
  /* assertion data == buf->bufs[2] */
  assert(data == buf->bufs[(signed long int)2]);
  void *temp_buf = buf->bufs[(signed long int)1];
  buf->bufs[(signed long int)1] = buf->bufs[(signed long int)2];
  buf->bufs[(signed long int)2] = temp_buf;
  set_buffer(dev, temp_buf);
  buf->timestamp = timestamp;
  buf->valid = 1;
  pthread_cond_signal(&buf->cb_cond);
  pthread_mutex_unlock(&buf->lock);
}

// read_cmos_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 252
unsigned short int read_cmos_register(struct _freenect_device *dev, unsigned short int reg)
{
  struct _freenect_context *read_cmos_register__1__ctx = dev->parent;
  unsigned short int replybuf[512l];
  unsigned short int cmdbuf[3l];
  cmdbuf[(signed long int)0] = (unsigned short int)1;
  cmdbuf[(signed long int)1] = (unsigned short int)((signed int)reg & 0x7fff);
  cmdbuf[(signed long int)2] = (unsigned short int)0;
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x95, (void *)cmdbuf, (unsigned int)6, (void *)replybuf, 6);
  if(!(res >= 0))
  {
    fn_log(read_cmos_register__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "read_cmos_register: send_cmd() returned %d\n", res);
    return (unsigned short int)65535;
  }

  else
  {
    fn_log(read_cmos_register__1__ctx, (enum anonymous_21)FREENECT_LOG_DEBUG, "read_cmos_register: 0x%04x => 0x%04x\n", reg, replybuf[(signed long int)2]);
    return replybuf[(signed long int)2];
  }
}

// read_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 209
unsigned short int read_register(struct _freenect_device *dev, unsigned short int reg)
{
  struct _freenect_context *read_register__1__ctx = dev->parent;
  unsigned short int reply[2l];
  unsigned short int cmd = reg;
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x02, (void *)&cmd, (unsigned int)2, (void *)reply, 4);
  if(!(res >= 0))
  {
    fn_log(read_register__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "read_register: send_cmd() failed: %d\n", res);
    return (unsigned short int)65535;
  }

  else
  {
    if(!(res == 4))
      fn_log(read_register__1__ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "read_register: send_cmd() returned %d [%04x %04x], 0000 expected\n", res, reply[(signed long int)0], reply[(signed long int)1]);

    fn_log(read_register__1__ctx, (enum anonymous_21)FREENECT_LOG_DEBUG, "read_register: 0x%04x => 0x%04x\n", reg, reply[(signed long int)1]);
    return reply[(signed long int)1];
  }
}

// register_for_flag
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 33
signed int register_for_flag(signed int flag)
{
  switch(flag)
  {
    case FREENECT_MIRROR_DEPTH:
      return 0x17;
    case FREENECT_MIRROR_VIDEO:
      return 0x47;
    default:
      return -1;
  }
}

// runloop_enter
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 343
static signed int runloop_enter(signed int index)
{
  _Bool tmp_if_expr_2;
  signed int return_value_setup_kinect_1;
  if(index >= 64 || !(index >= 0))
  {
    printf("Error: Invalid index [%d]\n", index);
    return -1;
  }

  else
  {
    if(thread_running == 0)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = !(kinects[(signed long int)index] != ((struct sync_kinect *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      return_value_setup_kinect_1=setup_kinect(index, FREENECT_RESOLUTION_MEDIUM, FREENECT_DEPTH_11BIT, 1);
      if(return_value_setup_kinect_1 == 0)
        goto __CPROVER_DUMP_L4;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      pending_runloop_tasks_inc();
      pthread_mutex_lock(&runloop_lock);
      return 0;
    }
  }
}

// runloop_exit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 358
static void runloop_exit()
{
  pthread_mutex_unlock(&runloop_lock);
  pending_runloop_tasks_dec();
}

// send_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.h line 32
signed int send_cmd(struct _freenect_device *dev, unsigned short int cmd, void *cmdbuf, unsigned int cmd_len, void *replybuf, signed int reply_len)
{
  struct _freenect_context *send_cmd__1__ctx = dev->parent;
  signed int res;
  signed int actual_len;
  unsigned char obuf[1024l];
  unsigned char ibuf[512l];
  struct anonymous_19 *chdr = (struct anonymous_19 *)obuf;
  struct anonymous_19 *rhdr = (struct anonymous_19 *)ibuf;
  _Bool tmp_if_expr_1;
  if((unsigned long int)cmd_len >= 1017ul || !((1u & cmd_len) == 0u))
  {
    fn_log(send_cmd__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "send_cmd: Invalid command length (0x%x)\n", cmd_len);
    return -1;
  }

  else
  {
    chdr->magic[(signed long int)0] = (unsigned char)0x47;
    chdr->magic[(signed long int)1] = (unsigned char)0x4d;
    chdr->cmd = cmd;
    chdr->tag = dev->cam_tag;
    chdr->len = (unsigned short int)(cmd_len / (unsigned int)2);
    memcpy((void *)(obuf + (signed long int)sizeof(struct anonymous_19) /*8ul*/ ), cmdbuf, (unsigned long int)cmd_len);
    res=fnusb_control(&dev->usb_cam, (unsigned char)0x40, (unsigned char)0, (unsigned short int)0, (unsigned short int)0, obuf, (unsigned short int)((unsigned long int)cmd_len + sizeof(struct anonymous_19) /*8ul*/ ));
    fn_log(send_cmd__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "send_cmd: cmd=%04x tag=%04x len=%04x: %d\n", cmd, dev->cam_tag, cmd_len, res);
    if(!(res >= 0))
    {
      fn_log(send_cmd__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "send_cmd: Output control transfer failed (%d)\n", res);
      return res;
    }

    else
    {
      do
      {
        actual_len=fnusb_control(&dev->usb_cam, (unsigned char)0xc0, (unsigned char)0, (unsigned short int)0, (unsigned short int)0, ibuf, (unsigned short int)0x200);
        fn_log(send_cmd__1__ctx, (enum anonymous_21)FREENECT_LOG_FLOOD, "send_cmd: actual length = %d\n", actual_len);
      }
      while(actual_len == 0 || actual_len == 0x200);
      fn_log(send_cmd__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "Control reply: %d\n", res);
      if(!(actual_len >= (signed int)sizeof(struct anonymous_19) /*8*/ ))
      {
        fn_log(send_cmd__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "send_cmd: Input control transfer failed (%d)\n", res);
        return res;
      }

      else
      {
        actual_len = actual_len - (signed int)sizeof(struct anonymous_19) /*8ul*/ ;
        if(!((signed int)rhdr->magic[0l] == 0x52))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = (signed int)rhdr->magic[(signed long int)1] != 0x42 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          fn_log(send_cmd__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "send_cmd: Bad magic %02x %02x\n", rhdr->magic[(signed long int)0], rhdr->magic[(signed long int)1]);
          return -1;
        }

        else
          if(!(rhdr->cmd == chdr->cmd))
          {
            fn_log(send_cmd__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "send_cmd: Bad cmd %02x != %02x\n", rhdr->cmd, chdr->cmd);
            return -1;
          }

          else
            if(!(rhdr->tag == chdr->tag))
            {
              fn_log(send_cmd__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "send_cmd: Bad tag %04x != %04x\n", rhdr->tag, chdr->tag);
              return -1;
            }

            else
              if(!((signed int)rhdr->len == actual_len / 2))
              {
                fn_log(send_cmd__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "send_cmd: Bad len %04x != %04x\n", rhdr->len, (signed int)(actual_len / 2));
                return -1;
              }

              else
              {
                if(!(reply_len >= actual_len))
                {
                  fn_log(send_cmd__1__ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "send_cmd: Data buffer is %d bytes long, but got %d bytes\n", reply_len, actual_len);
                  memcpy(replybuf, (const void *)(ibuf + (signed long int)sizeof(struct anonymous_19) /*8ul*/ ), (unsigned long int)reply_len);
                }

                else
                  memcpy(replybuf, (const void *)(ibuf + (signed long int)sizeof(struct anonymous_19) /*8ul*/ ), (unsigned long int)actual_len);
                dev->cam_tag = dev->cam_tag + 1;
                return actual_len;
              }
      }
    }
  }
}

// setup_kinect
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 274
static signed int setup_kinect(signed int index, signed int res, signed int fmt, signed int is_depth)
{
  pending_runloop_tasks_inc();
  pthread_mutex_lock(&runloop_lock);
  signed int thread_running_prev = thread_running;
  if(thread_running == 0)
    init_thread();

  if(kinects[(signed long int)index] == ((struct sync_kinect *)NULL))
    kinects[(signed long int)index]=alloc_kinect(index);

  _Bool tmp_if_expr_1;
  if(kinects[(signed long int)index] == ((struct sync_kinect *)NULL))
  {
    printf("Error: Invalid index [%d]\n", index);
    if(thread_running_prev == 0)
    {
      thread_running = 0;
      pthread_mutex_unlock(&runloop_lock);
      pending_runloop_tasks_dec();
      pthread_join(thread, (void **)(void *)0);
    }

    else
    {
      pthread_mutex_unlock(&runloop_lock);
      pending_runloop_tasks_dec();
    }
    return -1;
  }

  else
  {
    freenect_set_user(kinects[(signed long int)index]->dev, (void *)kinects[(signed long int)index]);
    struct buffer_ring *buf;
    if(!(is_depth == 0))
      buf = &kinects[(signed long int)index]->depth;

    else
      buf = &kinects[(signed long int)index]->video;
    pthread_mutex_lock(&buf->lock);
    if(!(buf->fmt == fmt))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = buf->res != res ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if(!(is_depth == 0))
        change_depth_format(kinects[(signed long int)index], (enum anonymous_13)res, (enum anonymous_5)fmt);

      else
        change_video_format(kinects[(signed long int)index], (enum anonymous_13)res, (enum anonymous_4)fmt);
    }

    pthread_mutex_unlock(&buf->lock);
    pthread_mutex_unlock(&runloop_lock);
    pending_runloop_tasks_dec();
    return 0;
  }
}

// stream_freebufs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 260
static void stream_freebufs(struct _freenect_context *ctx, struct anonymous_14 *strm)
{
  if(!(strm->split_bufs == 0))
    free((void *)strm->raw_buf);

  if(!(strm->lib_buf == NULL))
    free(strm->lib_buf);

  strm->raw_buf = (unsigned char *)(void *)0;
  strm->proc_buf = (void *)0;
  strm->lib_buf = (void *)0;
}

// stream_freebufs_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 260
static void stream_freebufs_link1(struct _freenect_context *ctx_link1, struct anonymous_14 *strm_link1)
{
  if(!(strm_link1->split_bufs == 0))
    free((void *)strm_link1->raw_buf);

  if(!(strm_link1->lib_buf == NULL))
    free(strm_link1->lib_buf);

  strm_link1->raw_buf = (unsigned char *)(void *)0;
  strm_link1->proc_buf = (void *)0;
  strm_link1->lib_buf = (void *)0;
}

// stream_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 231
static void stream_init(struct _freenect_context *ctx, struct anonymous_14 *strm, signed int rlen, signed int plen)
{
  strm->valid_frames = 0;
  strm->synced = 0;
  if(!(strm->usr_buf == NULL))
  {
    strm->lib_buf = (void *)0;
    strm->proc_buf = strm->usr_buf;
  }

  else
  {
    strm->lib_buf=malloc((unsigned long int)plen);
    strm->proc_buf = strm->lib_buf;
  }
  if(rlen == 0)
  {
    strm->split_bufs = 0;
    strm->raw_buf = (unsigned char *)strm->proc_buf;
    strm->frame_size = plen;
  }

  else
  {
    strm->split_bufs = 1;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)rlen);
    strm->raw_buf = (unsigned char *)return_value_malloc_1;
    strm->frame_size = rlen;
  }
  strm->last_pkt_size = strm->frame_size % strm->pkt_size;
  if(strm->last_pkt_size == 0)
    strm->last_pkt_size = strm->pkt_size;

  strm->pkts_per_frame = ((strm->frame_size + strm->pkt_size) - 1) / strm->pkt_size;
}

// stream_init_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 231
static void stream_init_link1(struct _freenect_context *ctx_link1, struct anonymous_14 *strm_link1, signed int rlen_link1, signed int plen_link1)
{
  strm_link1->valid_frames = 0;
  strm_link1->synced = 0;
  if(!(strm_link1->usr_buf == NULL))
  {
    strm_link1->lib_buf = (void *)0;
    strm_link1->proc_buf = strm_link1->usr_buf;
  }

  else
  {
    strm_link1->lib_buf=malloc((unsigned long int)plen_link1);
    strm_link1->proc_buf = strm_link1->lib_buf;
  }
  if(rlen_link1 == 0)
  {
    strm_link1->split_bufs = 0;
    strm_link1->raw_buf = (unsigned char *)strm_link1->proc_buf;
    strm_link1->frame_size = plen_link1;
  }

  else
  {
    strm_link1->split_bufs = 1;
    void *return_value_malloc_1_link1;
    return_value_malloc_1_link1=malloc((unsigned long int)rlen_link1);
    strm_link1->raw_buf = (unsigned char *)return_value_malloc_1_link1;
    strm_link1->frame_size = rlen_link1;
  }
  strm_link1->last_pkt_size = strm_link1->frame_size % strm_link1->pkt_size;
  if(strm_link1->last_pkt_size == 0)
    strm_link1->last_pkt_size = strm_link1->pkt_size;

  strm_link1->pkts_per_frame = ((strm_link1->frame_size + strm_link1->pkt_size) - 1) / strm_link1->pkt_size;
}

// stream_process
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 87
static signed int stream_process(struct _freenect_context *ctx, struct anonymous_14 *strm, unsigned char *pkt, signed int len, void (*cb)(void *, void *, signed int, signed int, void *), void *user_data)
{
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  signed int tmp_if_expr_3;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  if(!(len >= 12))
    return 0;

  else
  {
    struct pkt_hdr *hdr = (struct pkt_hdr *)pkt;
    unsigned char *data = pkt + (signed long int)sizeof(struct pkt_hdr) /*12ul*/ ;
    signed int datalen = (signed int)((unsigned long int)len - sizeof(struct pkt_hdr) /*12ul*/ );
    enum anonymous_21 l_info = (enum anonymous_21)FREENECT_LOG_INFO;
    enum anonymous_21 l_notice = (enum anonymous_21)FREENECT_LOG_NOTICE;
    enum anonymous_21 l_warning = (enum anonymous_21)FREENECT_LOG_WARNING;
    if(!(strm->valid_frames >= 2))
    {
      l_warning = (enum anonymous_21)FREENECT_LOG_SPEW;
      l_notice = l_warning;
      l_info = l_notice;
    }

    if(!((signed int)hdr->magic[0l] == 82))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)hdr->magic[(signed long int)1] != 66 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      fn_log(ctx, l_notice, "[Stream %02x] Invalid magic %02x%02x\n", strm->flag, hdr->magic[(signed long int)0], hdr->magic[(signed long int)1]);
      return 0;
    }

    else
    {
      fn_log(ctx, (enum anonymous_21)FREENECT_LOG_FLOOD, "[Stream %02x] Packet with flag: %02x\n", strm->flag, hdr->flag);
      unsigned char sof = (unsigned char)((signed int)strm->flag | 1);
      unsigned char mof = (unsigned char)((signed int)strm->flag | 2);
      unsigned char eof = (unsigned char)((signed int)strm->flag | 5);
      if(strm->synced == 0)
      {
        if(!(hdr->flag == sof))
        {
          fn_log(ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "[Stream %02x] Not synced yet...\n", strm->flag);
          return 0;
        }

        strm->synced = 1;
        strm->seq = hdr->seq;
        strm->pkt_num = 0;
        strm->valid_pkts = 0;
        strm->got_pkts = 0;
      }

      signed int got_frame_size = 0;
      if(!(strm->seq == hdr->seq))
      {
        unsigned char lost = (unsigned char)((signed int)hdr->seq - (signed int)strm->seq);
        strm->lost_pkts = strm->lost_pkts + (unsigned int)lost;
        fn_log(ctx, l_info, "[Stream %02x] Lost %d packets\n", strm->flag, lost);
        fn_log(ctx, (enum anonymous_21)FREENECT_LOG_DEBUG, "[Stream %02x] Lost %d total packets in %d frames (%f lppf)\n", strm->flag, strm->lost_pkts, strm->valid_frames, (float)strm->lost_pkts / (float)strm->valid_frames);
        if((signed int)lost >= 6)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = strm->variable_length != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
        {
          fn_log(ctx, l_notice, "[Stream %02x] Lost too many packets, resyncing...\n", strm->flag);
          strm->synced = 0;
          return 0;
        }

        strm->seq = hdr->seq;
        signed int left = strm->pkts_per_frame - strm->pkt_num;
        if((signed int)lost >= left)
        {
          strm->pkt_num = (signed int)lost - left;
          strm->valid_pkts = strm->got_pkts;
          strm->got_pkts = 0;
          got_frame_size = strm->frame_size;
          strm->timestamp = strm->last_timestamp;
          strm->valid_frames = strm->valid_frames + 1;
        }

        else
          strm->pkt_num = strm->pkt_num + (signed int)lost;
      }

      signed int expected_pkt_size;
      if(strm->pkt_num == strm->pkts_per_frame + -1)
        tmp_if_expr_3 = strm->last_pkt_size;

      else
        tmp_if_expr_3 = strm->pkt_size;
      expected_pkt_size = tmp_if_expr_3;
      if(strm->variable_length == 0)
      {
        if(strm->pkt_num == 0)
          tmp_if_expr_7 = hdr->flag == sof ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        if(!tmp_if_expr_7)
        {
          if(strm->pkt_num == strm->pkts_per_frame + -1)
            tmp_if_expr_6 = hdr->flag == eof ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6 = (_Bool)0;
          if(!tmp_if_expr_6)
          {
            if(strm->pkt_num >= 1)
              tmp_if_expr_4 = strm->pkt_num < strm->pkts_per_frame - 1 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_4 = (_Bool)0;
            if(tmp_if_expr_4)
              tmp_if_expr_5 = hdr->flag == mof ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_5 = (_Bool)0;
            if(!tmp_if_expr_5)
            {
              fn_log(ctx, l_notice, "[Stream %02x] Inconsistent flag %02x with %d packets in buf (%d total), resyncing...\n", strm->flag, hdr->flag, strm->pkt_num, strm->pkts_per_frame);
              strm->synced = 0;
              return got_frame_size;
            }

          }

        }

        if(!(expected_pkt_size >= datalen))
        {
          fn_log(ctx, l_warning, "[Stream %02x] Expected max %d data bytes, but got %d. Dropping...\n", strm->flag, expected_pkt_size, datalen);
          return got_frame_size;
        }

        if(!(datalen >= expected_pkt_size))
          fn_log(ctx, l_warning, "[Stream %02x] Expected %d data bytes, but got %d\n", strm->flag, expected_pkt_size, datalen);

      }

      else
      {
        if(strm->pkt_num == 0)
          tmp_if_expr_10 = hdr->flag == sof ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_10 = (_Bool)0;
        if(!tmp_if_expr_10)
        {
          if(!(strm->pkt_num >= strm->pkts_per_frame))
          {
            if(hdr->flag == eof)
              tmp_if_expr_8 = (_Bool)1;

            else
              tmp_if_expr_8 = hdr->flag == mof ? (_Bool)1 : (_Bool)0;
            tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_9 = (_Bool)0;
          if(!tmp_if_expr_9)
          {
            fn_log(ctx, l_notice, "[Stream %02x] Inconsistent flag %02x with %d packets in buf (%d total), resyncing...\n", strm->flag, hdr->flag, strm->pkt_num, strm->pkts_per_frame);
            strm->synced = 0;
            return got_frame_size;
          }

        }

        if(!(expected_pkt_size >= datalen))
        {
          fn_log(ctx, l_warning, "[Stream %02x] Expected max %d data bytes, but got %d. Resyncng...\n", strm->flag, expected_pkt_size, datalen);
          strm->synced = 0;
          return got_frame_size;
        }

        if(!(datalen >= expected_pkt_size))
        {
          if(!(hdr->flag == eof))
          {
            fn_log(ctx, l_warning, "[Stream %02x] Expected %d data bytes, but got %d. Resyncing...\n", strm->flag, expected_pkt_size, datalen);
            strm->synced = 0;
            return got_frame_size;
          }

        }

      }
      unsigned char *dbuf = strm->raw_buf + (signed long int)(strm->pkt_num * strm->pkt_size);
      if(!(cb == ((void (*)(void *, void *, signed int, signed int, void *))NULL)))
        cb((void *)strm->raw_buf, (void *)data, strm->pkt_num, datalen, user_data);

      else
        memcpy((void *)dbuf, (const void *)data, (unsigned long int)datalen);
      strm->pkt_num = strm->pkt_num + 1;
      strm->seq = strm->seq + 1;
      strm->got_pkts = strm->got_pkts + 1;
      strm->last_timestamp = hdr->timestamp;
      if(hdr->flag == eof)
      {
        if(!(strm->variable_length == 0))
          got_frame_size = (signed int)((dbuf - strm->raw_buf) + (signed long int)datalen);

        else
          got_frame_size = (signed int)((dbuf - strm->raw_buf) + (signed long int)strm->last_pkt_size);
        strm->pkt_num = 0;
        strm->valid_pkts = strm->got_pkts;
        strm->got_pkts = 0;
        strm->timestamp = strm->last_timestamp;
        strm->valid_frames = strm->valid_frames + 1;
      }

      return got_frame_size;
    }
  }
}

// stream_process_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 87
static signed int stream_process_link1(struct _freenect_context *ctx_link1, struct anonymous_14 *strm_link1, unsigned char *pkt_link1, signed int len_link1, void (*cb_link1)(void *, void *, signed int, signed int, void *), void *user_data_link1)
{
  _Bool tmp_if_expr_1_link1;
  _Bool tmp_if_expr_2_link1;
  signed int tmp_if_expr_3_link1;
  _Bool tmp_if_expr_7_link1;
  _Bool tmp_if_expr_6_link1;
  _Bool tmp_if_expr_4_link1;
  _Bool tmp_if_expr_5_link1;
  _Bool tmp_if_expr_10_link1;
  _Bool tmp_if_expr_9_link1;
  _Bool tmp_if_expr_8_link1;
  if(!(len_link1 >= 12))
    return 0;

  else
  {
    struct pkt_hdr *hdr_link1 = (struct pkt_hdr *)pkt_link1;
    unsigned char *data_link1 = pkt_link1 + (signed long int)sizeof(struct pkt_hdr) /*12ul*/ ;
    signed int datalen_link1 = (signed int)((unsigned long int)len_link1 - sizeof(struct pkt_hdr) /*12ul*/ );
    enum anonymous_21 l_info_link1 = (enum anonymous_21)FREENECT_LOG_INFO;
    enum anonymous_21 l_notice_link1 = (enum anonymous_21)FREENECT_LOG_NOTICE;
    enum anonymous_21 l_warning_link1 = (enum anonymous_21)FREENECT_LOG_WARNING;
    if(!(strm_link1->valid_frames >= 2))
    {
      l_warning_link1 = (enum anonymous_21)FREENECT_LOG_SPEW;
      l_notice_link1 = l_warning_link1;
      l_info_link1 = l_notice_link1;
    }

    if(!((signed int)hdr_link1->magic[0l] == 82))
      tmp_if_expr_1_link1 = (_Bool)1;

    else
      tmp_if_expr_1_link1 = (signed int)hdr_link1->magic[(signed long int)1] != 66 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1_link1)
    {
      fn_log(ctx_link1, l_notice_link1, "[Stream %02x] Invalid magic %02x%02x\n", strm_link1->flag, hdr_link1->magic[(signed long int)0], hdr_link1->magic[(signed long int)1]);
      return 0;
    }

    else
    {
      fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_FLOOD, "[Stream %02x] Packet with flag: %02x\n", strm_link1->flag, hdr_link1->flag);
      unsigned char sof_link1 = (unsigned char)((signed int)strm_link1->flag | 1);
      unsigned char mof_link1 = (unsigned char)((signed int)strm_link1->flag | 2);
      unsigned char eof_link1 = (unsigned char)((signed int)strm_link1->flag | 5);
      if(strm_link1->synced == 0)
      {
        if(!(hdr_link1->flag == sof_link1))
        {
          fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "[Stream %02x] Not synced yet...\n", strm_link1->flag);
          return 0;
        }

        strm_link1->synced = 1;
        strm_link1->seq = hdr_link1->seq;
        strm_link1->pkt_num = 0;
        strm_link1->valid_pkts = 0;
        strm_link1->got_pkts = 0;
      }

      signed int got_frame_size_link1 = 0;
      if(!(strm_link1->seq == hdr_link1->seq))
      {
        unsigned char lost_link1 = (unsigned char)((signed int)hdr_link1->seq - (signed int)strm_link1->seq);
        strm_link1->lost_pkts = strm_link1->lost_pkts + (unsigned int)lost_link1;
        fn_log(ctx_link1, l_info_link1, "[Stream %02x] Lost %d packets\n", strm_link1->flag, lost_link1);
        fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_DEBUG, "[Stream %02x] Lost %d total packets in %d frames (%f lppf)\n", strm_link1->flag, strm_link1->lost_pkts, strm_link1->valid_frames, (float)strm_link1->lost_pkts / (float)strm_link1->valid_frames);
        if((signed int)lost_link1 >= 6)
          tmp_if_expr_2_link1 = (_Bool)1;

        else
          tmp_if_expr_2_link1 = strm_link1->variable_length != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2_link1)
        {
          fn_log(ctx_link1, l_notice_link1, "[Stream %02x] Lost too many packets, resyncing...\n", strm_link1->flag);
          strm_link1->synced = 0;
          return 0;
        }

        strm_link1->seq = hdr_link1->seq;
        signed int left_link1 = strm_link1->pkts_per_frame - strm_link1->pkt_num;
        if((signed int)lost_link1 >= left_link1)
        {
          strm_link1->pkt_num = (signed int)lost_link1 - left_link1;
          strm_link1->valid_pkts = strm_link1->got_pkts;
          strm_link1->got_pkts = 0;
          got_frame_size_link1 = strm_link1->frame_size;
          strm_link1->timestamp = strm_link1->last_timestamp;
          strm_link1->valid_frames = strm_link1->valid_frames + 1;
        }

        else
          strm_link1->pkt_num = strm_link1->pkt_num + (signed int)lost_link1;
      }

      signed int expected_pkt_size_link1;
      if(strm_link1->pkt_num == strm_link1->pkts_per_frame + -1)
        tmp_if_expr_3_link1 = strm_link1->last_pkt_size;

      else
        tmp_if_expr_3_link1 = strm_link1->pkt_size;
      expected_pkt_size_link1 = tmp_if_expr_3_link1;
      if(strm_link1->variable_length == 0)
      {
        if(strm_link1->pkt_num == 0)
          tmp_if_expr_7_link1 = hdr_link1->flag == sof_link1 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7_link1 = (_Bool)0;
        if(!tmp_if_expr_7_link1)
        {
          if(strm_link1->pkt_num == strm_link1->pkts_per_frame + -1)
            tmp_if_expr_6_link1 = hdr_link1->flag == eof_link1 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6_link1 = (_Bool)0;
          if(!tmp_if_expr_6_link1)
          {
            if(strm_link1->pkt_num >= 1)
              tmp_if_expr_4_link1 = strm_link1->pkt_num < strm_link1->pkts_per_frame - 1 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_4_link1 = (_Bool)0;
            if(tmp_if_expr_4_link1)
              tmp_if_expr_5_link1 = hdr_link1->flag == mof_link1 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_5_link1 = (_Bool)0;
            if(!tmp_if_expr_5_link1)
            {
              fn_log(ctx_link1, l_notice_link1, "[Stream %02x] Inconsistent flag %02x with %d packets in buf (%d total), resyncing...\n", strm_link1->flag, hdr_link1->flag, strm_link1->pkt_num, strm_link1->pkts_per_frame);
              strm_link1->synced = 0;
              return got_frame_size_link1;
            }

          }

        }

        if(!(expected_pkt_size_link1 >= datalen_link1))
        {
          fn_log(ctx_link1, l_warning_link1, "[Stream %02x] Expected max %d data bytes, but got %d. Dropping...\n", strm_link1->flag, expected_pkt_size_link1, datalen_link1);
          return got_frame_size_link1;
        }

        if(!(datalen_link1 >= expected_pkt_size_link1))
          fn_log(ctx_link1, l_warning_link1, "[Stream %02x] Expected %d data bytes, but got %d\n", strm_link1->flag, expected_pkt_size_link1, datalen_link1);

      }

      else
      {
        if(strm_link1->pkt_num == 0)
          tmp_if_expr_10_link1 = hdr_link1->flag == sof_link1 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_10_link1 = (_Bool)0;
        if(!tmp_if_expr_10_link1)
        {
          if(!(strm_link1->pkt_num >= strm_link1->pkts_per_frame))
          {
            if(hdr_link1->flag == eof_link1)
              tmp_if_expr_8_link1 = (_Bool)1;

            else
              tmp_if_expr_8_link1 = hdr_link1->flag == mof_link1 ? (_Bool)1 : (_Bool)0;
            tmp_if_expr_9_link1 = tmp_if_expr_8_link1 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_9_link1 = (_Bool)0;
          if(!tmp_if_expr_9_link1)
          {
            fn_log(ctx_link1, l_notice_link1, "[Stream %02x] Inconsistent flag %02x with %d packets in buf (%d total), resyncing...\n", strm_link1->flag, hdr_link1->flag, strm_link1->pkt_num, strm_link1->pkts_per_frame);
            strm_link1->synced = 0;
            return got_frame_size_link1;
          }

        }

        if(!(expected_pkt_size_link1 >= datalen_link1))
        {
          fn_log(ctx_link1, l_warning_link1, "[Stream %02x] Expected max %d data bytes, but got %d. Resyncng...\n", strm_link1->flag, expected_pkt_size_link1, datalen_link1);
          strm_link1->synced = 0;
          return got_frame_size_link1;
        }

        if(!(datalen_link1 >= expected_pkt_size_link1))
        {
          if(!(hdr_link1->flag == eof_link1))
          {
            fn_log(ctx_link1, l_warning_link1, "[Stream %02x] Expected %d data bytes, but got %d. Resyncing...\n", strm_link1->flag, expected_pkt_size_link1, datalen_link1);
            strm_link1->synced = 0;
            return got_frame_size_link1;
          }

        }

      }
      unsigned char *dbuf_link1 = strm_link1->raw_buf + (signed long int)(strm_link1->pkt_num * strm_link1->pkt_size);
      if(!(cb_link1 == ((void (*)(void *, void *, signed int, signed int, void *))NULL)))
        cb_link1((void *)strm_link1->raw_buf, (void *)data_link1, strm_link1->pkt_num, datalen_link1, user_data_link1);

      else
        memcpy((void *)dbuf_link1, (const void *)data_link1, (unsigned long int)datalen_link1);
      strm_link1->pkt_num = strm_link1->pkt_num + 1;
      strm_link1->seq = strm_link1->seq + 1;
      strm_link1->got_pkts = strm_link1->got_pkts + 1;
      strm_link1->last_timestamp = hdr_link1->timestamp;
      if(hdr_link1->flag == eof_link1)
      {
        if(!(strm_link1->variable_length == 0))
          got_frame_size_link1 = (signed int)((dbuf_link1 - strm_link1->raw_buf) + (signed long int)datalen_link1);

        else
          got_frame_size_link1 = (signed int)((dbuf_link1 - strm_link1->raw_buf) + (signed long int)strm_link1->last_pkt_size);
        strm_link1->pkt_num = 0;
        strm_link1->valid_pkts = strm_link1->got_pkts;
        strm_link1->got_pkts = 0;
        strm_link1->timestamp = strm_link1->last_timestamp;
        strm_link1->valid_frames = strm_link1->valid_frames + 1;
      }

      return got_frame_size_link1;
    }
  }
}

// stream_setbuf
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 272
static signed int stream_setbuf(struct _freenect_context *ctx, struct anonymous_14 *strm, void *pbuf)
{
  if(strm->running == 0)
  {
    strm->usr_buf = pbuf;
    return 0;
  }

  else
  {
    if(pbuf == NULL)
    {
      if(strm->lib_buf == NULL)
      {
        fn_log(ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Attempted to set buffer to NULL but stream was started with no internal buffer\n");
        return -1;
      }

    }

    strm->usr_buf = pbuf;
    if(pbuf == NULL)
      strm->proc_buf = strm->lib_buf;

    else
      strm->proc_buf = pbuf;
    if(strm->split_bufs == 0)
      strm->raw_buf = (unsigned char *)strm->proc_buf;

    return 0;
  }
}

// stream_setbuf_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 272
static signed int stream_setbuf_link1(struct _freenect_context *ctx_link1, struct anonymous_14 *strm_link1, void *pbuf_link1)
{
  if(strm_link1->running == 0)
  {
    strm_link1->usr_buf = pbuf_link1;
    return 0;
  }

  else
  {
    if(pbuf_link1 == NULL)
    {
      if(strm_link1->lib_buf == NULL)
      {
        fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "Attempted to set buffer to NULL but stream was started with no internal buffer\n");
        return -1;
      }

    }

    strm_link1->usr_buf = pbuf_link1;
    if(pbuf_link1 == NULL)
      strm_link1->proc_buf = strm_link1->lib_buf;

    else
      strm_link1->proc_buf = pbuf_link1;
    if(strm_link1->split_bufs == 0)
      strm_link1->raw_buf = (unsigned char *)strm_link1->proc_buf;

    return 0;
  }
}

// sync_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 318
static signed int sync_get(void **data, unsigned int *timestamp, struct buffer_ring *buf)
{
  pthread_mutex_lock(&buf->lock);
  while(buf->valid == 0)
    pthread_cond_wait(&buf->cb_cond, &buf->lock);
  void *temp_buf = buf->bufs[(signed long int)0];
  buf->bufs[(signed long int)0] = buf->bufs[(signed long int)1];
  *data = buf->bufs[(signed long int)0];
  buf->bufs[(signed long int)1] = temp_buf;
  buf->valid = 0;
  *timestamp = buf->timestamp;
  pthread_mutex_unlock(&buf->lock);
  return 0;
}

// unpack_8_pixels
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 77
static inline void unpack_8_pixels(unsigned char *raw, unsigned short int *frame)
{
  unsigned short int baseMask = (unsigned short int)0x7FF;
  unsigned char r0 = raw[(signed long int)0];
  unsigned char r1 = raw[(signed long int)1];
  unsigned char r2 = raw[(signed long int)2];
  unsigned char r3 = raw[(signed long int)3];
  unsigned char r4 = raw[(signed long int)4];
  unsigned char r5 = raw[(signed long int)5];
  unsigned char r6 = raw[(signed long int)6];
  unsigned char r7 = raw[(signed long int)7];
  unsigned char r8 = raw[(signed long int)8];
  unsigned char r9 = raw[(signed long int)9];
  unsigned char r10 = raw[(signed long int)10];
  frame[(signed long int)0] = (unsigned short int)((signed int)r0 << 3 | (signed int)r1 >> 5);
  frame[(signed long int)1] = (unsigned short int)(((signed int)r1 << 6 | (signed int)r2 >> 2) & (signed int)baseMask);
  frame[(signed long int)2] = (unsigned short int)(((signed int)r2 << 9 | (signed int)r3 << 1 | (signed int)r4 >> 7) & (signed int)baseMask);
  frame[(signed long int)3] = (unsigned short int)(((signed int)r4 << 4 | (signed int)r5 >> 4) & (signed int)baseMask);
  frame[(signed long int)4] = (unsigned short int)(((signed int)r5 << 7 | (signed int)r6 >> 1) & (signed int)baseMask);
  frame[(signed long int)5] = (unsigned short int)(((signed int)r6 << 10 | (signed int)r7 << 2 | (signed int)r8 >> 6) & (signed int)baseMask);
  frame[(signed long int)6] = (unsigned short int)(((signed int)r8 << 5 | (signed int)r9 >> 3) & (signed int)baseMask);
  frame[(signed long int)7] = (unsigned short int)(((signed int)r9 << 8 | (signed int)r10) & (signed int)baseMask);
}

// unpack_8_pixels_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/registration.c line 77
static inline void unpack_8_pixels_link1(unsigned char *raw_link1, unsigned short int *frame_link1)
{
  unsigned short int baseMask_link1 = (unsigned short int)0x7FF;
  unsigned char r0_link1 = raw_link1[(signed long int)0];
  unsigned char r1_link1 = raw_link1[(signed long int)1];
  unsigned char r2_link1 = raw_link1[(signed long int)2];
  unsigned char r3_link1 = raw_link1[(signed long int)3];
  unsigned char r4_link1 = raw_link1[(signed long int)4];
  unsigned char r5_link1 = raw_link1[(signed long int)5];
  unsigned char r6_link1 = raw_link1[(signed long int)6];
  unsigned char r7_link1 = raw_link1[(signed long int)7];
  unsigned char r8_link1 = raw_link1[(signed long int)8];
  unsigned char r9_link1 = raw_link1[(signed long int)9];
  unsigned char r10_link1 = raw_link1[(signed long int)10];
  frame_link1[(signed long int)0] = (unsigned short int)((signed int)r0_link1 << 3 | (signed int)r1_link1 >> 5);
  frame_link1[(signed long int)1] = (unsigned short int)(((signed int)r1_link1 << 6 | (signed int)r2_link1 >> 2) & (signed int)baseMask_link1);
  frame_link1[(signed long int)2] = (unsigned short int)(((signed int)r2_link1 << 9 | (signed int)r3_link1 << 1 | (signed int)r4_link1 >> 7) & (signed int)baseMask_link1);
  frame_link1[(signed long int)3] = (unsigned short int)(((signed int)r4_link1 << 4 | (signed int)r5_link1 >> 4) & (signed int)baseMask_link1);
  frame_link1[(signed long int)4] = (unsigned short int)(((signed int)r5_link1 << 7 | (signed int)r6_link1 >> 1) & (signed int)baseMask_link1);
  frame_link1[(signed long int)5] = (unsigned short int)(((signed int)r6_link1 << 10 | (signed int)r7_link1 << 2 | (signed int)r8_link1 >> 6) & (signed int)baseMask_link1);
  frame_link1[(signed long int)6] = (unsigned short int)(((signed int)r8_link1 << 5 | (signed int)r9_link1 >> 3) & (signed int)baseMask_link1);
  frame_link1[(signed long int)7] = (unsigned short int)(((signed int)r9_link1 << 8 | (signed int)r10_link1) & (signed int)baseMask_link1);
}

// update_tilt_state_alt
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/tilt.c line 100
signed int update_tilt_state_alt(struct _freenect_device *dev)
{
  struct _freenect_context *update_tilt_state_alt__1__ctx = dev->parent;
  signed int tmp_post_1;
  if(dev->usb_audio.dev == ((struct libusb_device_handle *)NULL))
  {
    fn_log(update_tilt_state_alt__1__ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "Motor control failed: audio device missing");
    return -1;
  }

  else
  {
    signed int transferred = 0;
    signed int res = 0;
    struct anonymous_26 cmd;
    cmd.magic = (unsigned int)0x06022009;
    tmp_post_1 = tag_seq;
    tag_seq = tag_seq + 1;
    cmd.tag = (unsigned int)tmp_post_1;
    cmd.arg1 = (unsigned int)0x68;
    cmd.cmd = (unsigned int)0x8032;
    unsigned char buffer[256l];
    memcpy((void *)buffer, (const void *)&cmd, (unsigned long int)16);
    res=libusb_bulk_transfer(dev->usb_audio.dev, (unsigned char)0x01, buffer, 16, &transferred, (unsigned int)250);
    if(!(res == 0))
      return res;

    else
    {
      res=libusb_bulk_transfer(dev->usb_audio.dev, (unsigned char)0x81, buffer, 256, &transferred, (unsigned int)250);
      if(!(res == 0))
        return res;

      else
      {
        /* tag-#anon#lST[S32'x'||S32'y'||S32'z'||S32'tilt'|] */
struct anonymous_28
{
  // x
  signed int x;
  // y
  signed int y;
  // z
  signed int z;
  // tilt
  signed int tilt;
};

/* */
        ;
        struct anonymous_28 accel_and_tilt;
        memcpy((void *)&accel_and_tilt, (const void *)(buffer + (signed long int)16), sizeof(struct anonymous_28) /*16ul*/ );
        fn_log(update_tilt_state_alt__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "Accelerometer state: X == %d \t Y == %d \t Z == %d \t Tilt == %d\n", accel_and_tilt.x, accel_and_tilt.y, accel_and_tilt.z, accel_and_tilt.tilt);
        dev->raw_state.accelerometer_x = (signed short int)accel_and_tilt.x;
        dev->raw_state.accelerometer_y = (signed short int)accel_and_tilt.y;
        dev->raw_state.accelerometer_z = (signed short int)accel_and_tilt.z;
        dev->raw_state.tilt_angle = (signed char)((signed int)(signed char)accel_and_tilt.tilt * 2);
        signed int return_value_get_reply_2;
        return_value_get_reply_2=get_reply(dev->usb_audio.dev, update_tilt_state_alt__1__ctx);
        return return_value_get_reply_2;
      }
    }
  }
}

// upload_cemd_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.c line 341
signed int upload_cemd_data(struct anonymous_10 *dev)
{
  struct _freenect_context *upload_cemd_data__1__ctx = dev->parent->parent;
  struct anonymous_30 cemdcmd;
  memset((void *)&cemdcmd, 0, sizeof(struct anonymous_30) /*52ul*/ );
  cemdcmd.magic = (unsigned int)0x06022009;
  cemdcmd.tag = dev->parent->audio_tag;
  cemdcmd.arg1 = (unsigned int)0;
  cemdcmd.cmd = (unsigned int)0x00000133;
  cemdcmd.arg2 = (unsigned int)0x00064014;
  fn_log(upload_cemd_data__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "Starting CEMD data upload:\n");
  signed int res;
  signed int transferred;
  res=fnusb_bulk(dev, (unsigned char)1, (unsigned char *)&cemdcmd, (signed int)sizeof(struct anonymous_30) /*52ul*/ , &transferred);
  if(!(res == 0) || !((unsigned long int)transferred == sizeof(struct anonymous_30) /*52ul*/ ))
  {
    fn_log(upload_cemd_data__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Error: res: %d\ttransferred: %d (expected %d)\n", res, transferred, (signed int)sizeof(struct anonymous_30) /*52ul*/ );
    return -1;
  }

  else
  {
    res=get_reply_link1(dev);
    dev->parent->audio_tag = dev->parent->audio_tag + 1u;
    const char *cemd_filename = "cemd_data.bin";
    struct _IO_FILE *cf;
    cf=fopen(cemd_filename, "r");
    if(cf == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      fn_log(upload_cemd_data__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "upload_cemd_data: Failed to open %s: error %d", cemd_filename, *return_value___errno_location_1);
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      return *return_value___errno_location_2;
    }

    unsigned int addr = (unsigned int)0x00000000;
    signed int read = 0;
    unsigned char page[16384l];
    do
    {
      unsigned long int return_value_fread_3;
      return_value_fread_3=fread((void *)page, (unsigned long int)1, (unsigned long int)0x4000, cf);
      read = (signed int)return_value_fread_3;
      if(!(read >= 1))
        break;

      cemdcmd.tag = dev->parent->audio_tag;
      cemdcmd.arg1 = (unsigned int)read;
      cemdcmd.cmd = (unsigned int)0x134;
      cemdcmd.arg2 = addr;
      fn_log(upload_cemd_data__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "About to send: ");
      dump_cemd_cmd(upload_cemd_data__1__ctx, cemdcmd);
      res=fnusb_bulk(dev, (unsigned char)1, (unsigned char *)&cemdcmd, (signed int)sizeof(struct anonymous_30) /*52ul*/ , &transferred);
      if(!(res == 0) || !((unsigned long int)transferred == sizeof(struct anonymous_30) /*52ul*/ ))
      {
        fn_log(upload_cemd_data__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Error: res: %d\ttransferred: %d (expected %d)\n", res, transferred, (signed int)sizeof(struct anonymous_30) /*52ul*/ );
        return -1;
      }

      signed int bytes_sent = 0;
      while(!(bytes_sent >= read))
      {
        signed int to_send = read - bytes_sent > 512 ? 512 : read - bytes_sent;
        res=fnusb_bulk(dev, (unsigned char)1, &page[(signed long int)bytes_sent], to_send, &transferred);
        if(!(res == 0) || !(transferred == to_send))
        {
          fn_log(upload_cemd_data__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "Error: res: %d\ttransferred: %d (expected %d)\n", res, transferred, to_send);
          return -1;
        }

        bytes_sent = bytes_sent + to_send;
      }
      res=get_reply_link1(dev);
      addr = addr + (unsigned int)read;
      dev->parent->audio_tag = dev->parent->audio_tag + 1u;
    }
    while(read >= 1);
    fclose(cf);
    cf = (struct _IO_FILE *)(void *)0;
    cemdcmd.tag = dev->parent->audio_tag;
    cemdcmd.arg1 = (unsigned int)0;
    cemdcmd.cmd = (unsigned int)0x135;
    cemdcmd.arg2 = (unsigned int)0x00064000;
    fn_log(upload_cemd_data__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "Finishing CEMD data upload...\n");
    res=fnusb_bulk(dev, (unsigned char)1, (unsigned char *)&cemdcmd, (signed int)sizeof(struct anonymous_30) /*52ul*/ , &transferred);
    if(!(res == 0) || !((unsigned long int)transferred == sizeof(struct anonymous_30) /*52ul*/ ))
    {
      fn_log(upload_cemd_data__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "upload_cemd_data(): Error: res: %d\ttransferred: %d (expected %d)\n", res, transferred, (signed int)sizeof(struct anonymous_30) /*52ul*/ );
      return -1;
    }

    else
    {
      res=get_reply_link1(dev);
      dev->parent->audio_tag = dev->parent->audio_tag + 1u;
      fn_log(upload_cemd_data__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "CEMD data uploaded successfully.\n");
      return 0;
    }
  }
}

// upload_firmware
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.h line 68
signed int upload_firmware(struct anonymous_10 *dev, char *filename)
{
  struct _freenect_context *upload_firmware__1__ctx = dev->parent->parent;
  char fw_filename[1024l];
  sprintf(fw_filename, "/%s", filename);
  signed int filenamelen;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(fw_filename);
  filenamelen = (signed int)return_value_strlen_1;
  signed int i;
  signed int searchpathcount;
  struct _IO_FILE *fw = (struct _IO_FILE *)(void *)0;
  i = 0;
  searchpathcount = 6;
  void *return_value_malloc_4;
  void *return_value_malloc_8;
  void *return_value_malloc_9;
  void *return_value_malloc_10;
  for( ; fw == ((struct _IO_FILE *)NULL) && !(i >= searchpathcount); i = i + 1)
  {
    char *fwfile;
    signed int needs_free = 0;
    switch(i)
    {
      case 0:
      {
        char *envpath;
        envpath=getenv("LIBFREENECT_FIRMWARE_PATH");
        if(envpath == ((char *)NULL))
          goto __CPROVER_DUMP_L13;

        signed int pathlen;
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(envpath);
        pathlen = (signed int)return_value_strlen_2;
        void *return_value_malloc_3;
        return_value_malloc_3=malloc((unsigned long int)(pathlen + filenamelen + 1));
        fwfile = (char *)return_value_malloc_3;
        strcpy(fwfile, envpath);
        strcat(fwfile, fw_filename);
        needs_free = 1;
        break;
      }
      case 1:
      {
        return_value_malloc_4=malloc((unsigned long int)2048);
        fwfile = (char *)return_value_malloc_4;
        needs_free = 1;
        sprintf(fwfile, ".%s", (const void *)fw_filename);
        break;
      }
      case 2:
      {
        char *home;
        home=getenv("HOME");
        if(home == ((char *)NULL))
          goto __CPROVER_DUMP_L13;

        signed int homelen;
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(home);
        homelen = (signed int)return_value_strlen_5;
        char *dotfolder = "/.libfreenect";
        signed int locallen;
        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen(dotfolder);
        locallen = (signed int)return_value_strlen_6;
        void *return_value_malloc_7;
        return_value_malloc_7=malloc((unsigned long int)(homelen + locallen + filenamelen + 1));
        fwfile = (char *)return_value_malloc_7;
        strcpy(fwfile, home);
        strcat(fwfile, dotfolder);
        strcat(fwfile, fw_filename);
        needs_free = 1;
        break;
      }
      case 3:
      {
        return_value_malloc_8=malloc((unsigned long int)2048);
        fwfile = (char *)return_value_malloc_8;
        needs_free = 1;
        sprintf(fwfile, "/usr/local/share/libfreenect%s", (const void *)fw_filename);
        break;
      }
      case 4:
      {
        return_value_malloc_9=malloc((unsigned long int)2048);
        fwfile = (char *)return_value_malloc_9;
        needs_free = 1;
        sprintf(fwfile, "/usr/share/libfreenect%s", (const void *)fw_filename);
        break;
      }
      case 5:
      {
        return_value_malloc_10=malloc((unsigned long int)2048);
        fwfile = (char *)return_value_malloc_10;
        needs_free = 1;
        sprintf(fwfile, "./../Resources%s", (const void *)fw_filename);
        break;
      }
      default:
        ;
    }
    fn_log(upload_firmware__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "Trying to open %s as firmware...\n", fwfile);
    fw=fopen(fwfile, "rb");
    if(!(needs_free == 0))
      free((void *)fwfile);


  __CPROVER_DUMP_L13:
    ;
  }
  if(fw == ((struct _IO_FILE *)NULL))
  {
    fn_log(upload_firmware__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "upload_firmware: failed to find firmware file.\n");
    signed int *return_value___errno_location_11;
    return_value___errno_location_11=__errno_location();
    return -(*return_value___errno_location_11);
  }

  fseek(fw, (signed long int)0, 2);
  signed int fw_num_bytes;
  signed long int return_value_ftell_12;
  return_value_ftell_12=ftell(fw);
  fw_num_bytes = (signed int)return_value_ftell_12;
  rewind(fw);
  if(!(fw_num_bytes >= 1))
  {
    fn_log(upload_firmware__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "upload_firmware: failed to find file with any data.\n");
    signed int *return_value___errno_location_13;
    return_value___errno_location_13=__errno_location();
    return -(*return_value___errno_location_13);
  }

  unsigned char *fw_bytes;
  void *return_value_malloc_14;
  return_value_malloc_14=malloc((unsigned long int)fw_num_bytes);
  fw_bytes = (unsigned char *)return_value_malloc_14;
  signed int numRead;
  unsigned long int return_value_fread_15;
  return_value_fread_15=fread((void *)fw_bytes, (unsigned long int)1, (unsigned long int)fw_num_bytes, fw);
  numRead = (signed int)return_value_fread_15;
  fw_num_bytes = numRead;
  signed int retVal;
  retVal=upload_firmware_from_memory(dev, fw_bytes, (unsigned int)fw_num_bytes);
  fclose(fw);
  fw = (struct _IO_FILE *)(void *)0;
  return retVal;
}

// upload_firmware_from_memory
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/loader.h line 69
signed int upload_firmware_from_memory(struct anonymous_10 *dev, unsigned char *fw_from_mem, unsigned int fw_size_in_btyes)
{
  struct _freenect_context *upload_firmware_from_memory__1__ctx = dev->parent->parent;
  struct anonymous_31 bootcmd;
  memset((void *)&bootcmd, 0, sizeof(struct anonymous_31) /*24ul*/ );
  bootcmd.magic = (unsigned int)0x06022009;
  signed int res;
  signed int transferred;
  struct anonymous_33 fwheader;
  signed int read = 0;
  signed int bytesLeft = (signed int)fw_size_in_btyes;
  unsigned char *readPtr = &fw_from_mem[(signed long int)0];
  if(!((unsigned long int)fw_size_in_btyes >= sizeof(struct anonymous_33) /*24ul*/ ))
  {
    fn_log(upload_firmware_from_memory__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "upload_firmware: firmware image too small, has no header?\n");
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    return -(*return_value___errno_location_1);
  }

  memcpy((void *)&fwheader, (const void *)readPtr, sizeof(struct anonymous_33) /*24ul*/ );
  fwheader.magic = fwheader.magic;
  fwheader.ver_major = fwheader.ver_major;
  fwheader.ver_minor = fwheader.ver_minor;
  fwheader.ver_release = fwheader.ver_release;
  fwheader.ver_patch = fwheader.ver_patch;
  fwheader.base_addr = fwheader.base_addr;
  fwheader.size = fwheader.size;
  fwheader.entry_addr = fwheader.entry_addr;
  fn_log(upload_firmware_from_memory__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "Found firmware image:\n");
  fn_log(upload_firmware_from_memory__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "\tmagic        %08X\n", fwheader.magic);
  fn_log(upload_firmware_from_memory__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "\tversion      %02d.%02d.%02d.%02d\n", fwheader.ver_major, fwheader.ver_minor, fwheader.ver_release, fwheader.ver_patch);
  fn_log(upload_firmware_from_memory__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "\tbase address 0x%08x\n", fwheader.base_addr);
  fn_log(upload_firmware_from_memory__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "\tsize         0x%08x\n", fwheader.size);
  fn_log(upload_firmware_from_memory__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "\tentry point  0x%08x\n", fwheader.entry_addr);
  unsigned int addr = fwheader.base_addr;
  unsigned char page[16384l];
  signed int readIndex = 0;
  signed int total_bytes_sent = 0;
  do
  {
    read = (signed int)((unsigned int)0x4000 > fwheader.size - (unsigned int)total_bytes_sent ? fwheader.size - (unsigned int)total_bytes_sent : (unsigned int)0x4000);
    if(!(bytesLeft >= read))
      read = bytesLeft;

    if(!(read >= 1))
      break;

    memcpy((void *)page, (const void *)&readPtr[(signed long int)readIndex], (unsigned long int)read);
    readIndex = readIndex + read;
    bytesLeft = bytesLeft - read;
    bootcmd.tag = dev->parent->audio_tag;
    bootcmd.bytes = (unsigned int)read;
    bootcmd.cmd = (unsigned int)0x03;
    bootcmd.addr = addr;
    fn_log(upload_firmware_from_memory__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "About to send: ");
    dump_bl_cmd(upload_firmware_from_memory__1__ctx, bootcmd);
    res=fnusb_bulk(dev, (unsigned char)1, (unsigned char *)&bootcmd, (signed int)sizeof(struct anonymous_31) /*24ul*/ , &transferred);
    if(!(res == 0) || !((unsigned long int)transferred == sizeof(struct anonymous_31) /*24ul*/ ))
    {
      fn_log(upload_firmware_from_memory__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "upload_firmware(): Error: res: %d\ttransferred: %d (expected %d)\n", res, transferred, (signed int)sizeof(struct anonymous_31) /*24ul*/ );
      return -1;
    }

    signed int bytes_sent = 0;
    while(!(bytes_sent >= read))
    {
      signed int to_send = read - bytes_sent > 512 ? 512 : read - bytes_sent;
      res=fnusb_bulk(dev, (unsigned char)1, &page[(signed long int)bytes_sent], to_send, &transferred);
      if(!(res == 0) || !(transferred == to_send))
      {
        fn_log(upload_firmware_from_memory__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "upload_firmware(): Error: res: %d\ttransferred: %d (expected %d)\n", res, transferred, to_send);
        return -1;
      }

      bytes_sent = bytes_sent + to_send;
      total_bytes_sent = total_bytes_sent + to_send;
    }
    res=get_reply_link1(dev);
    addr = addr + (unsigned int)read;
    dev->parent->audio_tag = dev->parent->audio_tag + 1u;
  }
  while(read >= 1);
  if(!((unsigned int)total_bytes_sent == fwheader.size))
  {
    fn_log(upload_firmware_from_memory__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "upload_firmware: firmware image declared %d bytes, but file only contained %d bytes\n", fwheader.size, total_bytes_sent);
    return -1;
  }

  else
  {
    bootcmd.tag = dev->parent->audio_tag;
    bootcmd.bytes = (unsigned int)0;
    bootcmd.cmd = (unsigned int)0x04;
    bootcmd.addr = fwheader.entry_addr;
    dump_bl_cmd(upload_firmware_from_memory__1__ctx, bootcmd);
    res=fnusb_bulk(dev, (unsigned char)1, (unsigned char *)&bootcmd, (signed int)sizeof(struct anonymous_31) /*24ul*/ , &transferred);
    if(!(res == 0) || !((unsigned long int)transferred == sizeof(struct anonymous_31) /*24ul*/ ))
    {
      fn_log(upload_firmware_from_memory__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "upload_firmware(): Error: res: %d\ttransferred: %d (expected %d)\n", res, transferred, (signed int)sizeof(struct anonymous_31) /*24ul*/ );
      return -1;
    }

    else
    {
      res=get_reply_link1(dev);
      dev->parent->audio_tag = dev->parent->audio_tag + 1u;
      fn_log(upload_firmware_from_memory__1__ctx, (enum anonymous_21)FREENECT_LOG_INFO, "Firmware successfully uploaded and launched.  Device will disconnect and reenumerate.\n");
      return 0;
    }
  }
}

// video_process
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 617
static void video_process(struct _freenect_device *dev, unsigned char *pkt, signed int len)
{
  struct _freenect_context *video_process__1__ctx = dev->parent;
  if(!(len == 0))
  {
    if(!(dev->video.running == 0))
    {
      signed int got_frame_size;
      got_frame_size=stream_process(video_process__1__ctx, &dev->video, pkt, len, dev->video_chunk_cb, dev->user_data);
      if(!(got_frame_size == 0))
      {
        fn_log(video_process__1__ctx, (enum anonymous_21)FREENECT_LOG_SPEW, "Got video frame of size %d/%d, %d/%d packets arrived, TS %08x\n", got_frame_size, dev->video.frame_size, dev->video.valid_pkts, dev->video.pkts_per_frame, dev->video.timestamp);
        struct anonymous_6 frame_mode;
        frame_mode=freenect_get_current_video_mode(dev);
        switch((signed int)dev->video_format)
        {
          case FREENECT_VIDEO_RGB:
          {
            convert_bayer_to_rgb(dev->video.raw_buf, (unsigned char *)dev->video.proc_buf, frame_mode);
            break;
          }
          case FREENECT_VIDEO_BAYER:
            break;
          case FREENECT_VIDEO_IR_10BIT:
          {
            convert_packed_to_16bit(dev->video.raw_buf, (unsigned short int *)dev->video.proc_buf, 10, (signed int)frame_mode.width * (signed int)frame_mode.height);
            break;
          }
          case FREENECT_VIDEO_IR_10BIT_PACKED:
            break;
          case FREENECT_VIDEO_IR_8BIT:
          {
            convert_packed_to_8bit(dev->video.raw_buf, (unsigned char *)dev->video.proc_buf, 10, (signed int)frame_mode.width * (signed int)frame_mode.height);
            break;
          }
          case FREENECT_VIDEO_YUV_RGB:
          {
            convert_uyvy_to_rgb(dev->video.raw_buf, (unsigned char *)dev->video.proc_buf, frame_mode);
            break;
          }
          case FREENECT_VIDEO_YUV_RAW:
            break;
          default:
            fn_log(video_process__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "video_process() was called, but an invalid video_format is set\n");
        }
        if(!(dev->video_cb == ((void (*)(struct _freenect_device *, void *, unsigned int))NULL)))
          dev->video_cb(dev, dev->video.proc_buf, dev->video.timestamp);

      }

    }

  }

}

// video_process_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/cameras.c line 617
static void video_process_link1(struct _freenect_device *dev_link1, unsigned char *pkt_link1, signed int len_link1)
{
  struct _freenect_context *ctx_link1 = dev_link1->parent;
  if(!(len_link1 == 0))
  {
    if(!(dev_link1->video.running == 0))
    {
      signed int got_frame_size_link1;
      got_frame_size_link1=stream_process_link1(ctx_link1, &dev_link1->video, pkt_link1, len_link1, dev_link1->video_chunk_cb, dev_link1->user_data);
      if(!(got_frame_size_link1 == 0))
      {
        fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_SPEW, "Got video frame of size %d/%d, %d/%d packets arrived, TS %08x\n", got_frame_size_link1, dev_link1->video.frame_size, dev_link1->video.valid_pkts, dev_link1->video.pkts_per_frame, dev_link1->video.timestamp);
        struct anonymous_6 frame_mode_link1;
        frame_mode_link1=freenect_get_current_video_mode(dev_link1);
        switch((signed int)dev_link1->video_format)
        {
          case FREENECT_VIDEO_RGB:
          {
            convert_bayer_to_rgb_link1(dev_link1->video.raw_buf, (unsigned char *)dev_link1->video.proc_buf, frame_mode_link1);
            break;
          }
          case FREENECT_VIDEO_BAYER:
            break;
          case FREENECT_VIDEO_IR_10BIT:
          {
            convert_packed_to_16bit_link1(dev_link1->video.raw_buf, (unsigned short int *)dev_link1->video.proc_buf, 10, (signed int)frame_mode_link1.width * (signed int)frame_mode_link1.height);
            break;
          }
          case FREENECT_VIDEO_IR_10BIT_PACKED:
            break;
          case FREENECT_VIDEO_IR_8BIT:
          {
            convert_packed_to_8bit_link1(dev_link1->video.raw_buf, (unsigned char *)dev_link1->video.proc_buf, 10, (signed int)frame_mode_link1.width * (signed int)frame_mode_link1.height);
            break;
          }
          case FREENECT_VIDEO_YUV_RGB:
          {
            convert_uyvy_to_rgb_link1(dev_link1->video.raw_buf, (unsigned char *)dev_link1->video.proc_buf, frame_mode_link1);
            break;
          }
          case FREENECT_VIDEO_YUV_RAW:
            break;
          default:
            fn_log(ctx_link1, (enum anonymous_21)FREENECT_LOG_ERROR, "video_process() was called, but an invalid video_format is set\n");
        }
        if(!(dev_link1->video_cb == ((void (*)(struct _freenect_device *, void *, unsigned int))NULL)))
          dev_link1->video_cb(dev_link1, dev_link1->video.proc_buf, dev_link1->video.timestamp);

      }

    }

  }

}

// video_producer_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/wrappers/c_sync/libfreenect_sync.c line 148
static void video_producer_cb(struct _freenect_device *dev, void *data, unsigned int timestamp)
{
  void *return_value_freenect_get_user_1;
  return_value_freenect_get_user_1=freenect_get_user(dev);
  producer_cb_inner(dev, data, timestamp, &((struct sync_kinect *)return_value_freenect_get_user_1)->video, freenect_set_video_buffer);
}

// write_cmos_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.c line 273
signed int write_cmos_register(struct _freenect_device *dev, unsigned short int reg, unsigned short int value)
{
  struct _freenect_context *write_cmos_register__1__ctx = dev->parent;
  unsigned short int replybuf[512l];
  unsigned short int cmdbuf[3l];
  cmdbuf[(signed long int)0] = (unsigned short int)1;
  cmdbuf[(signed long int)1] = (unsigned short int)((signed int)reg | 0x8000);
  cmdbuf[(signed long int)2] = value;
  fn_log(write_cmos_register__1__ctx, (enum anonymous_21)FREENECT_LOG_DEBUG, "write_cmos_register: 0x%04x <= 0x%04x\n", reg, value);
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x95, (void *)cmdbuf, (unsigned int)6, (void *)replybuf, 6);
  if(!(res >= 0))
    fn_log(write_cmos_register__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "write_cmos_register: send_cmd() returned %d\n", res);

  return res;
}

// write_register
// file /srv/jenkins-slave/workspace/sid-goto-cc-libfreenect/libfreenect-0.5.3/src/flags.h line 36
signed int write_register(struct _freenect_device *dev, unsigned short int reg, unsigned short int data)
{
  struct _freenect_context *write_register__1__ctx = dev->parent;
  unsigned short int reply[2l];
  unsigned short int cmd[2l];
  cmd[(signed long int)0] = reg;
  cmd[(signed long int)1] = data;
  fn_log(write_register__1__ctx, (enum anonymous_21)FREENECT_LOG_DEBUG, "write_register: 0x%04x <= 0x%02x\n", reg, data);
  signed int res;
  res=send_cmd(dev, (unsigned short int)0x03, (void *)cmd, (unsigned int)4, (void *)reply, 4);
  if(!(res >= 0))
  {
    fn_log(write_register__1__ctx, (enum anonymous_21)FREENECT_LOG_ERROR, "write_register: send_cmd() returned %d\n", res);
    return res;
  }

  else
  {
    if(!(res == 2))
      fn_log(write_register__1__ctx, (enum anonymous_21)FREENECT_LOG_WARNING, "write_register: send_cmd() returned %d [%04x %04x], 0000 expected\n", res, reply[(signed long int)0], reply[(signed long int)1]);

    return 0;
  }
}

