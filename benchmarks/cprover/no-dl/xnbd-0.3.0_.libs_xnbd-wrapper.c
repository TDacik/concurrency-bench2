// #anon_enum_G_LOG_FLAG_RECURSION=1_G_LOG_FLAG_FATAL=2_G_LOG_LEVEL_ERROR=4_G_LOG_LEVEL_CRITICAL=8_G_LOG_LEVEL_WARNING=16_G_LOG_LEVEL_MESSAGE=32_G_LOG_LEVEL_INFO=64_G_LOG_LEVEL_DEBUG=128_G_LOG_LEVEL_MASK=-4
// file /usr/include/glib-2.0/glib/gmessages.h line 51
enum anonymous_2 { G_LOG_FLAG_RECURSION=1, G_LOG_FLAG_FATAL=2, G_LOG_LEVEL_ERROR=4, G_LOG_LEVEL_CRITICAL=8, G_LOG_LEVEL_WARNING=16, G_LOG_LEVEL_MESSAGE=32, G_LOG_LEVEL_INFO=64, G_LOG_LEVEL_DEBUG=128, G_LOG_LEVEL_MASK=-4 };

// tag-#anon#ST[*{S8}_S8_'target_host'||*{S8}_S8_'target_port'||*{S8}_S8_'bitmap_image'||*{S8}_S8_'control_socket_path'||*{S8}_S8_'target_exportname'|]
// file xnbd_wrapper.c line 63
struct anonymous_4;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_0;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_6;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_3;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_1;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_5;

// tag-_GAsyncQueue
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 36
struct _GAsyncQueue;

// tag-_GHashTable
// file /usr/include/glib-2.0/glib/ghash.h line 37
struct _GHashTable;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GMutex
// file /usr/include/glib-2.0/glib/gthread.h line 51
union _GMutex;

// tag-_GString
// file /usr/include/glib-2.0/glib/gstring.h line 39
struct _GString;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_t_disk_data
// file xnbd_wrapper.c line 59
struct _t_disk_data;

// tag-_t_listing_state
// file xnbd_wrapper.c line 81
struct _t_listing_state;

// tag-_t_thread_data
// file xnbd_wrapper.c line 75
struct _t_thread_data;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-cachestat
// file xnbd_cachestat.c line 33
struct cachestat;

// tag-cmsghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 242
struct cmsghdr;

// tag-custom_log_handler_params
// file lib/common.h line 85
struct custom_log_handler_params;

// tag-disk_image
// file xnbd.h line 90
struct disk_image;

// tag-disk_stack
// file xnbd.h line 103
struct disk_stack;

// tag-disk_stack_io
// file xnbd.h line 110
struct disk_stack_io;

// tag-epoll_data
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 79
union epoll_data;

// tag-epoll_event
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 87
struct epoll_event;

// tag-exec_params
// file xnbd_wrapper.c line 974
struct exec_params;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-mmap_partial
// file xnbd.h line 208
struct mmap_partial;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-nbd_negotiate_pdu_new_0
// file nbd.c line 321
struct nbd_negotiate_pdu_new_0;

// tag-nbd_negotiate_pdu_new_1
// file nbd.c line 327
struct nbd_negotiate_pdu_new_1;

// tag-nbd_negotiate_pdu_new_2
// file nbd.c line 334
struct nbd_negotiate_pdu_new_2;

// tag-nbd_negotiate_pdu_old
// file nbd.c line 525
struct nbd_negotiate_pdu_old;

// tag-nbd_reply
// file lib/nbd.h line 53
struct nbd_reply;

// tag-nbd_request
// file nbd.h line 45
struct nbd_request;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-proxy_priv
// file xnbd_proxy.h line 37
struct proxy_priv;

// tag-proxy_session
// file xnbd_proxy.c line 37
struct proxy_session;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 309
union pthread_attr_t;

// tag-remote_read_request
// file xnbd_proxy.h line 29
struct remote_read_request;

// tag-signalfd_siginfo
// file /usr/include/x86_64-linux-gnu/sys/signalfd.h line 28
struct signalfd_siginfo;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-xnbd_cmd_type
// file xnbd.h line 124
enum xnbd_cmd_type { xnbd_cmd_unknown=-1, xnbd_cmd_target=0, xnbd_cmd_cow_target=1, xnbd_cmd_proxy=2, xnbd_cmd_help=3, xnbd_cmd_version=4 };

// tag-xnbd_info
// file xnbd.h line 135
struct xnbd_info;

// tag-xnbd_proxy
// file xnbd_proxy.h line 75
struct xnbd_proxy;

// tag-xnbd_proxy_cmd_type
// file xnbd_proxy.h line 109
enum xnbd_proxy_cmd_type { XNBD_PROXY_CMD_UNKNOWN=0, XNBD_PROXY_CMD_QUERY_STATUS=1, XNBD_PROXY_CMD_REGISTER_FD=2, XNBD_PROXY_CMD_REGISTER_FORWARDER_FD=3, XNBD_PROXY_CMD_REGISTER_SHARED_BUFFER_FD=4, XNBD_PROXY_CMD_DETECT_SWITCH=5 };

// tag-xnbd_proxy_query
// file xnbd_proxy.h line 119
struct xnbd_proxy_query;

// tag-xnbd_session
// file xnbd.h line 175
struct xnbd_session;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __bswap_64
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 109
static inline unsigned long int __bswap_64(unsigned long int __bsx);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// about_to_execute
// file xnbd_wrapper.c line 150
static void about_to_execute(const char * const *argv);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous_5, unsigned int *);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// add_diskimg
// file xnbd_wrapper.c line 215
static signed int add_diskimg(struct _t_disk_data *p_disk_data);
// add_read_block_to_tail
// file xnbd_proxy_forwarder.c line 56
void add_read_block_to_tail(struct proxy_priv *priv, unsigned long int i);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous_5, unsigned int);
// bitmap_alloc
// file bitmap.c line 43
unsigned long int * bitmap_alloc(unsigned long int bits);
// bitmap_close_file
// file lib/bitmap.h line 37
void bitmap_close_file(unsigned long int *bitmap, unsigned long int bitmaplen);
// bitmap_create
// file bitmap.c line 147
unsigned long int * bitmap_create(char *bitmapfile, unsigned long int bits, signed int *cbitmapfd, unsigned long int *cbitmaplen);
// bitmap_on
// file lib/bitmap.h line 40
void bitmap_on(unsigned long int *bitmap_array, unsigned long int block_index);
// bitmap_open_file
// file lib/bitmap.h line 36
unsigned long int * bitmap_open_file(const char *bitmapfile, unsigned long int bits, unsigned long int *bitmaplen, signed int readonly, signed int zeroclear);
// bitmap_size
// file bitmap.c line 37
unsigned long int bitmap_size(unsigned long int bits);
// bitmap_test
// file lib/bitmap.h line 39
signed int bitmap_test(unsigned long int *bitmap_array, unsigned long int block_index);
// block_all_signals
// file xnbd_proxy.c line 51
void block_all_signals(void);
// cachestat_cache_bgcopy
// file xnbd_cachestat.c line 254
inline void cachestat_cache_bgcopy(void);
// cachestat_cache_odread
// file xnbd_cachestat.c line 252
inline void cachestat_cache_odread(void);
// cachestat_cache_odwrite
// file xnbd_cachestat.c line 253
inline void cachestat_cache_odwrite(void);
// cachestat_dump
// file xnbd_cachestat.c line 48
void cachestat_dump(char *path);
// cachestat_dump_loop
// file xnbd_cachestat.c line 84
void cachestat_dump_loop(char *path, unsigned int interval);
// cachestat_hit
// file xnbd_cachestat.c line 258
inline void cachestat_hit(void);
// cachestat_initialize
// file xnbd_cachestat.c line 259
signed int cachestat_initialize(const char *path, unsigned long int nblocks);
// cachestat_miss
// file xnbd_cachestat.c line 257
inline void cachestat_miss(void);
// cachestat_read_block
// file xnbd_cachestat.c line 255
inline void cachestat_read_block(void);
// cachestat_shutdown
// file xnbd_cachestat.c line 260
signed int cachestat_shutdown(void);
// cachestat_write_block
// file xnbd_cachestat.c line 256
inline void cachestat_write_block(void);
// calc_block_index
// file lib/io.h line 49
void calc_block_index(const unsigned int blocksize, const signed long int iofrom, const unsigned long int iolen, unsigned long int *index_start, unsigned long int *index_end);
// check_disksize
// file xnbd_common.c line 160
void check_disksize(char *diskpath, signed long int disksize, _Bool force_cblock);
// check_done
// file net.c line 489
void check_done(signed int ret, signed int errcode);
// check_fin
// file net.c line 517
signed int check_fin(signed int ret, signed int errcode, unsigned long int len);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// command_available
// file xnbd_wrapper.c line 1034
static _Bool command_available(const char *command);
// compress_iovec_and_send
// file xnbd_target_cow_lzo.c line 737
void compress_iovec_and_send(signed int csock, struct iovec *iov, signed int count);
// compress_iovec_and_send_advanced
// file xnbd_target_cow_lzo.c line 729
void compress_iovec_and_send_advanced(signed int csock, struct iovec *iov, const unsigned int count, signed int lzo_enabled);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous_5, unsigned int);
// copy_disk_data
// file xnbd_wrapper.c line 108
static struct _t_disk_data * copy_disk_data(const struct _t_disk_data *source);
// count_mgr_threads
// file xnbd_wrapper.c line 595
static signed int count_mgr_threads(signed int val);
// create_disk_data
// file xnbd_wrapper.c line 174
static struct _t_disk_data * create_disk_data(const char *local_exportname, const char *target_host, const char *target_port, const char *cache_image, const char *bitmap_image, const char *control_socket_path, const char *target_exportname);
// create_disk_stack
// file xnbd_target_cow_lzo.c line 170
struct disk_stack * create_disk_stack(char *diskpath);
// create_disk_stack_io
// file xnbd_target_cow_lzo.c line 401
static struct disk_stack_io * create_disk_stack_io(struct disk_stack *ds);
// custom_log_handler
// file lib/common.h line 91
void custom_log_handler(const char *log_domain, enum anonymous_2 log_level, const char *message, void *data);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// decode_percent_encoding
// file xnbd_wrapper.c line 484
static void decode_percent_encoding(char *text);
// del_diskimg_by_exportname
// file xnbd_wrapper.c line 263
static signed int del_diskimg_by_exportname(const char *local_exportname);
// del_diskimg_by_file
// file xnbd_wrapper.c line 254
static signed int del_diskimg_by_file(const char *filename);
// del_diskimg_by_index
// file xnbd_wrapper.c line 240
static signed int del_diskimg_by_index(signed int num);
// destroy_disk_stack
// file xnbd_target_cow_lzo.c line 255
void destroy_disk_stack(struct disk_stack *ds);
// destroy_value
// file xnbd_wrapper.c line 88
static void destroy_value(struct _t_disk_data *p_disk_data);
// disk_stack_add_image
// file xnbd_target_cow_lzo.c line 279
void disk_stack_add_image(struct disk_stack *ds, char *diskpath, signed int newfile);
// disk_stack_mmap
// file xnbd_target_cow_lzo.c line 418
struct disk_stack_io * disk_stack_mmap(struct disk_stack *ds, signed long int iofrom, unsigned long int iolen, signed int reading);
// dump_buffer
// file io.c line 104
void dump_buffer(const char *buff, unsigned long int bufflen);
// dump_buffer_all
// file io.c line 99
void dump_buffer_all(const char *buff, unsigned long int bufflen);
// dump_buffer_main
// file io.c line 70
static void dump_buffer_main(const char *buff, unsigned long int bufflen, signed int all);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// ensure_command_available
// file xnbd_wrapper.c line 1073
static void ensure_command_available(const char *command);
// epoll_create1
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 104
extern signed int epoll_create1(signed int);
// epoll_ctl
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 113
extern signed int epoll_ctl(signed int, signed int, signed int, struct epoll_event *);
// epoll_wait
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 127
extern signed int epoll_wait(signed int, struct epoll_event *, signed int, signed int);
// exec_xnbd_server
// file xnbd_wrapper.c line 983
static void exec_xnbd_server(struct exec_params *params, char *fd_num, const struct _t_disk_data *disk_data);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// execvp_or_abort
// file xnbd_wrapper.c line 166
static void execvp_or_abort(const char * const *argv);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// extract_decode_check_usage
// file xnbd_wrapper.c line 531
static signed int extract_decode_check_usage(char *buf, char ***p_argv, unsigned int *p_argc, unsigned int argc_min, unsigned int argc_max);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// find_by_exportname
// file xnbd_wrapper.c line 209
static signed int find_by_exportname(const char *key, const struct _t_disk_data *p_disk_data, const char *local_exportname);
// find_by_file
// file xnbd_wrapper.c line 203
static signed int find_by_file(const char *key, const struct _t_disk_data *p_disk_data, const char *filename);
// find_by_index
// file xnbd_wrapper.c line 196
static signed int find_by_index(const char *key, const struct _t_disk_data *p_disk_data, const void *user_data);
// find_smallest_index_iterator
// file xnbd_wrapper.c line 344
static void find_smallest_index_iterator(void *key, const struct _t_disk_data *p_disk_data, struct _t_listing_state *p_listing_state);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fork_or_abort
// file lib/io.h line 45
signed int fork_or_abort(void);
// forwarder_rx_thread_main
// file xnbd_proxy.h line 135
void * forwarder_rx_thread_main(void *arg);
// forwarder_rx_thread_mainloop
// file xnbd_proxy_forwarder.c line 295
signed int forwarder_rx_thread_mainloop(struct xnbd_proxy *proxy);
// forwarder_tx_thread_main
// file xnbd_proxy.h line 136
void * forwarder_tx_thread_main(void *arg);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_disk_stack_io
// file xnbd_target_cow_lzo.c line 409
void free_disk_stack_io(struct disk_stack_io *io);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 219
extern signed int fstat(signed int, struct stat *);
// ftruncate
// file /usr/include/unistd.h line 1019
extern signed int ftruncate(signed int, signed long int);
// g_assertion_message_expr
// file /usr/include/glib-2.0/glib/gtestutils.h line 302
extern void g_assertion_message_expr(const char *, const char *, signed int, const char *, const char *);
// g_async_queue_length
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 88
extern signed int g_async_queue_length(struct _GAsyncQueue *);
// g_async_queue_new
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 39
extern struct _GAsyncQueue * g_async_queue_new(void);
// g_async_queue_pop
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 74
extern void * g_async_queue_pop(struct _GAsyncQueue *);
// g_async_queue_push
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 58
extern void g_async_queue_push(struct _GAsyncQueue *, void *);
// g_async_queue_push_sorted
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 64
extern void g_async_queue_push_sorted(struct _GAsyncQueue *, void *, signed int (*)(const void *, const void *, void *), void *);
// g_async_queue_push_unshift
// file xnbd_proxy.c line 529
static void g_async_queue_push_unshift(struct _GAsyncQueue *queue, void *data);
// g_async_queue_try_pop
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 78
extern void * g_async_queue_try_pop(struct _GAsyncQueue *);
// g_async_queue_unref
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 49
extern void g_async_queue_unref(struct _GAsyncQueue *);
// g_direct_equal
// file /usr/include/glib-2.0/glib/ghash.h line 180
extern signed int g_direct_equal(const void *, const void *);
// g_direct_hash
// file /usr/include/glib-2.0/glib/ghash.h line 178
extern unsigned int g_direct_hash(const void *);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_hash_table_destroy
// file /usr/include/glib-2.0/glib/ghash.h line 65
extern void g_hash_table_destroy(struct _GHashTable *);
// g_hash_table_foreach
// file /usr/include/glib-2.0/glib/ghash.h line 99
extern void g_hash_table_foreach(struct _GHashTable *, void (*)(void *, void *, void *), void *);
// g_hash_table_foreach_remove
// file /usr/include/glib-2.0/glib/ghash.h line 107
extern unsigned int g_hash_table_foreach_remove(struct _GHashTable *, signed int (*)(void *, void *, void *), void *);
// g_hash_table_insert
// file /usr/include/glib-2.0/glib/ghash.h line 67
extern signed int g_hash_table_insert(struct _GHashTable *, void *, void *);
// g_hash_table_lookup
// file /usr/include/glib-2.0/glib/ghash.h line 88
extern void * g_hash_table_lookup(struct _GHashTable *, const void *);
// g_hash_table_new
// file /usr/include/glib-2.0/glib/ghash.h line 57
extern struct _GHashTable * g_hash_table_new(unsigned int (*)(const void *), signed int (*)(const void *, const void *));
// g_hash_table_new_full
// file /usr/include/glib-2.0/glib/ghash.h line 60
extern struct _GHashTable * g_hash_table_new_full(unsigned int (*)(const void *), signed int (*)(const void *, const void *), void (*)(void *), void (*)(void *));
// g_hash_table_size
// file /usr/include/glib-2.0/glib/ghash.h line 115
extern unsigned int g_hash_table_size(struct _GHashTable *);
// g_list_append
// file /usr/include/glib-2.0/glib/glist.h line 59
extern struct _GList * g_list_append(struct _GList *, void *);
// g_list_first
// file /usr/include/glib-2.0/glib/glist.h line 128
extern struct _GList * g_list_first(struct _GList *);
// g_list_length
// file /usr/include/glib-2.0/glib/glist.h line 130
extern unsigned int g_list_length(struct _GList *);
// g_list_remove
// file /usr/include/glib-2.0/glib/glist.h line 85
extern struct _GList * g_list_remove(struct _GList *, const void *);
// g_log
// file /usr/include/glib-2.0/glib/gmessages.h line 101
extern void g_log(const char *, enum anonymous_2, const char *, ...);
// g_log_set_default_handler
// file /usr/include/glib-2.0/glib/gmessages.h line 98
extern void (*g_log_set_default_handler(void (*)(const char *, enum anonymous_2, const char *, void *), void *))(const char *, enum anonymous_2, const char *, void *);
// g_malloc
// file /usr/include/glib-2.0/glib/gmem.h line 78
extern void * g_malloc(unsigned long int);
// g_malloc0
// file /usr/include/glib-2.0/glib/gmem.h line 80
extern void * g_malloc0(unsigned long int);
// g_malloc0_n
// file /usr/include/glib-2.0/glib/gmem.h line 96
extern void * g_malloc0_n(unsigned long int, unsigned long int);
// g_mutex_clear
// file /usr/include/glib-2.0/glib/gthread.h line 166
extern void g_mutex_clear(union _GMutex *);
// g_mutex_init
// file /usr/include/glib-2.0/glib/gthread.h line 164
extern void g_mutex_init(union _GMutex *);
// g_mutex_lock
// file /usr/include/glib-2.0/glib/gthread.h line 168
extern void g_mutex_lock(union _GMutex *);
// g_mutex_unlock
// file /usr/include/glib-2.0/glib/gthread.h line 172
extern void g_mutex_unlock(union _GMutex *);
// g_slice_alloc0
// file /usr/include/glib-2.0/glib/gslice.h line 34
extern void * g_slice_alloc0(unsigned long int);
// g_slice_free1
// file /usr/include/glib-2.0/glib/gslice.h line 39
extern void g_slice_free1(unsigned long int, void *);
// g_str_equal
// file /usr/include/glib-2.0/glib/ghash.h line 154
extern signed int g_str_equal(const void *, const void *);
// g_str_hash
// file /usr/include/glib-2.0/glib/ghash.h line 157
extern unsigned int g_str_hash(const void *);
// g_strdup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 216
extern char * g_strdup(const char *);
// g_strdup_printf
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 218
extern char * g_strdup_printf(const char *, ...);
// g_strfreev
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 281
extern void g_strfreev(char **);
// g_string_append
// file /usr/include/glib-2.0/glib/gstring.h line 80
extern struct _GString * g_string_append(struct _GString *, const char *);
// g_string_append_printf
// file /usr/include/glib-2.0/glib/gstring.h line 149
extern void g_string_append_printf(struct _GString *, const char *, ...);
// g_string_free
// file /usr/include/glib-2.0/glib/gstring.h line 56
extern char * g_string_free(struct _GString *, signed int);
// g_string_new
// file /usr/include/glib-2.0/glib/gstring.h line 49
extern struct _GString * g_string_new(const char *);
// g_strlcpy
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 117
extern unsigned long int g_strlcpy(char *, const char *, unsigned long int);
// g_strsplit
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 270
extern char ** g_strsplit(const char *, const char *, signed int);
// g_try_malloc_n
// file /usr/include/glib-2.0/glib/gmem.h line 103
extern void * g_try_malloc_n(unsigned long int, unsigned long int);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_disk_data_for
// file xnbd_wrapper.c line 272
static struct _t_disk_data * get_disk_data_for(const char *local_exportname);
// get_disk_nblocks
// file xnbd_common.c line 183
unsigned long int get_disk_nblocks(signed long int disksize);
// get_disksize
// file lib/io.h line 47
signed long int get_disksize(signed int fd);
// get_disksize_of_path
// file io.c line 172
signed long int get_disksize_of_path(const char *path);
// get_event_connecter
// file io.c line 344
void get_event_connecter(signed int *notifier, signed int *listener);
// get_io_range_index
// file xnbd_common.c line 98
void get_io_range_index(signed long int iofrom, unsigned long int iolen, unsigned long int *index_start, unsigned long int *index_end);
// get_line
// file io.c line 200
char * get_line(signed int fd);
// get_log_fd
// file xnbd_common.h line 4
signed int get_log_fd(const char *path);
// get_nameinfo_string
// file net.c line 29
static char * get_nameinfo_string(struct addrinfo *ai);
// get_session_from_read_fd
// file xnbd_proxy.c line 411
struct proxy_session * get_session_from_read_fd(struct _GList *list_head, signed int fd);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpagesize
// file /usr/include/unistd.h line 978
extern signed int getpagesize(void);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getppid
// file /usr/include/unistd.h line 631
extern signed int getppid(void);
// gnu_dev_major
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 27
extern unsigned int gnu_dev_major(unsigned long long int);
// handle_bgctl_command
// file xnbd_wrapper.c line 628
static signed int handle_bgctl_command(const char *usage, const char *mode, unsigned int expected_argc_min, unsigned int expected_argc_max, char *buf, struct _IO_FILE *fp, const char *xnbd_bgctl_command, unsigned int *p_argc, char ***p_argv, signed int *p_child_process_count);
// hexdig_char_to_int
// file xnbd_wrapper.c line 421
static signed int hexdig_char_to_int(char c);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// inform_xnbd_server_termination
// file xnbd_wrapper.c line 142
static void inform_xnbd_server_termination(signed int pid, signed int status);
// invoke_bgctl
// file xnbd_wrapper.c line 604
static signed int invoke_bgctl(struct _IO_FILE *fp, const char **argv);
// io_all
// file io.c line 26
static void io_all(signed int fd, void *buf, unsigned long int len, signed int read_ops);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// list_diskimg
// file xnbd_wrapper.c line 386
static void list_diskimg(struct _IO_FILE *fp);
// list_images_iterator
// file xnbd_wrapper.c line 353
static void list_images_iterator(void *key, const struct _t_disk_data *p_disk_data, struct _t_listing_state *p_listing_state);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// lseek
// file /usr/include/unistd.h line 337
extern signed long int lseek(signed int, signed long int, signed int);
// main_loop
// file xnbd_proxy.c line 534
signed int main_loop(struct xnbd_proxy *proxy, signed int unix_listen_fd, signed int master_fd);
// make_pipe
// file lib/io.h line 61
void make_pipe(signed int *write_fd, signed int *read_fd);
// make_sockpair
// file lib/io.h line 62
void make_sockpair(signed int *fd0, signed int *fd1);
// make_tcp_sock
// file xnbd_wrapper.c line 926
static signed int make_tcp_sock(const char *addr_or_name, const char *port);
// make_unix_sock
// file xnbd_wrapper.c line 570
static signed int make_unix_sock(const char *uxsock_path);
// mark_proxy_mode_ended
// file xnbd_wrapper.c line 292
static void mark_proxy_mode_ended(const char *local_exportname);
// mem_usage_add
// file xnbd_proxy.c line 112
static void mem_usage_add(struct xnbd_proxy *proxy, struct proxy_priv *priv);
// mem_usage_del
// file xnbd_proxy.c line 170
static void mem_usage_del(struct xnbd_proxy *proxy, struct proxy_priv *priv);
// mem_usage_wait
// file xnbd_proxy.c line 134
static void mem_usage_wait(struct xnbd_proxy *proxy);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 61
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// mmap_iorange
// file xnbd_common.c line 107
void * mmap_iorange(const signed long int disksize, const _Bool readonly, const signed int fd, const signed long int iofrom, const unsigned long int iolen, char **mmaped_buf, unsigned long int *mmaped_len, signed long int *mmaped_offset);
// mmap_partial_map
// file xnbd_common.c line 38
struct mmap_partial * mmap_partial_map(signed int fd, signed long int iofrom, const unsigned long int iolen_in, signed int readonly);
// mmap_partial_unmap
// file xnbd_common.c line 89
void mmap_partial_unmap(struct mmap_partial *mpinfo);
// msync
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 89
extern signed int msync(void *, unsigned long int, signed int);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// munmap_or_abort
// file lib/io.h line 65
void munmap_or_abort(void *addr, unsigned long int len);
// nbd_client_recv_header
// file lib/nbd.h line 104
signed int nbd_client_recv_header(signed int remotefd);
// nbd_client_recv_read_reply
// file lib/nbd.h line 103
signed int nbd_client_recv_read_reply(signed int remotefd, char *buf, unsigned long int len);
// nbd_client_recv_read_reply_iov
// file nbd.c line 171
signed int nbd_client_recv_read_reply_iov(signed int remotefd, struct iovec *iov, unsigned int count);
// nbd_client_send_disc_request
// file lib/nbd.h line 101
void nbd_client_send_disc_request(signed int remotefd);
// nbd_client_send_read_request
// file lib/nbd.h line 100
signed int nbd_client_send_read_request(signed int remotefd, signed long int iofrom, unsigned long int len);
// nbd_client_send_request_header
// file lib/nbd.h line 99
signed int nbd_client_send_request_header(signed int remotefd, unsigned int iotype, signed long int iofrom, unsigned long int len, unsigned long int handle);
// nbd_get_iotype_string
// file nbd.c line 26
const char * nbd_get_iotype_string(unsigned int iotype);
// nbd_negotiate_with_client
// file nbd.c line 573
signed int nbd_negotiate_with_client(signed int sockfd, signed long int exportsize);
// nbd_negotiate_with_client_common
// file nbd.c line 535
static signed int nbd_negotiate_with_client_common(signed int sockfd, signed long int exportsize, signed int readonly);
// nbd_negotiate_with_client_new_phase_0
// file lib/nbd.h line 78
char * nbd_negotiate_with_client_new_phase_0(signed int sockfd);
// nbd_negotiate_with_client_new_phase_1
// file lib/nbd.h line 79
signed int nbd_negotiate_with_client_new_phase_1(signed int sockfd, signed long int exportsize, signed int readonly);
// nbd_negotiate_with_client_readonly
// file nbd.c line 568
signed int nbd_negotiate_with_client_readonly(signed int sockfd, signed long int exportsize);
// nbd_negotiate_with_server
// file nbd.c line 646
signed long int nbd_negotiate_with_server(signed int sockfd);
// nbd_negotiate_with_server2
// file lib/nbd.h line 82
signed int nbd_negotiate_with_server2(signed int sockfd, signed long int *exportsize, unsigned int *exportflags);
// nbd_negotiate_with_server_new
// file lib/nbd.h line 83
signed int nbd_negotiate_with_server_new(signed int sockfd, signed long int *exportsize, unsigned int *exportflags, unsigned long int namesize, const char *target_name);
// nbd_reply_dump
// file nbd.c line 55
void nbd_reply_dump(struct nbd_reply *reply);
// nbd_request_dump
// file nbd.c line 45
void nbd_request_dump(struct nbd_request *request);
// nbd_server_recv_request
// file lib/nbd.h line 97
signed int nbd_server_recv_request(signed int clientfd, signed long int disksize, unsigned int *iotype_arg, signed long int *iofrom_arg, unsigned long int *iolen_arg, struct nbd_reply *reply);
// net_accept
// file net.c line 157
signed int net_accept(signed int lsock);
// net_connect
// file lib/net.h line 55
signed int net_connect(const char *hostname, const char *service, signed int socktype, signed int proto);
// net_create_server_sockets
// file net.c line 79
unsigned int net_create_server_sockets(struct addrinfo *ai_head, signed int *fds, unsigned long int nfds);
// net_getaddrinfo
// file net.c line 57
struct addrinfo * net_getaddrinfo(char *host, signed int port, signed int ai_family, signed int socktype, signed int proto);
// net_iov_all
// file net.c line 331
static signed int net_iov_all(signed int fd, struct iovec *iov, signed int count, signed int reading);
// net_readv_all
// file net.c line 456
signed int net_readv_all(signed int fd, struct iovec *iov, signed int count);
// net_readv_all_or_abort
// file lib/net.h line 70
void net_readv_all_or_abort(signed int fd, struct iovec *iov, unsigned int count);
// net_readv_all_or_error
// file net.h line 71
signed int net_readv_all_or_error(signed int fd, struct iovec *iov, unsigned int count);
// net_recv_all
// file net.c line 472
signed long int net_recv_all(signed int sockfd, void *buff, unsigned long int bufflen);
// net_recv_all_or_abort
// file lib/net.h line 61
void net_recv_all_or_abort(signed int sockfd, void *buff, unsigned long int bufflen);
// net_recv_all_or_error
// file lib/net.h line 62
signed int net_recv_all_or_error(signed int sockfd, void *buff, unsigned long int bufflen);
// net_send_all
// file net.h line 64
signed long int net_send_all(signed int sockfd, const void *buff, unsigned long int bufflen);
// net_send_all_or_abort
// file lib/net.h line 65
void net_send_all_or_abort(signed int sockfd, const void *buff, unsigned long int bufflen);
// net_send_all_or_error
// file lib/net.h line 66
signed int net_send_all_or_error(signed int sockfd, const void *buff, unsigned long int bufflen);
// net_set_bindv6only
// file net.c line 216
signed int net_set_bindv6only(signed int sockfd);
// net_set_keepalive
// file net.c line 228
signed int net_set_keepalive(signed int sockfd);
// net_set_nodelay
// file net.c line 204
signed int net_set_nodelay(signed int sockfd);
// net_set_reuseaddr
// file net.c line 192
signed int net_set_reuseaddr(signed int sockfd);
// net_writev_all
// file net.c line 450
signed int net_writev_all(signed int fd, struct iovec *iov, signed int count);
// net_writev_all_or_abort
// file lib/net.h line 68
void net_writev_all_or_abort(signed int fd, struct iovec *iov, unsigned int count);
// net_writev_all_or_error
// file lib/net.h line 69
signed int net_writev_all_or_error(signed int fd, struct iovec *iov, unsigned int count);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// perform_shutdown
// file xnbd_wrapper.c line 411
static void perform_shutdown(struct _IO_FILE *fp);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// poll_data_and_event
// file io.c line 317
signed int poll_data_and_event(signed int datafd, signed int event_listener_fd);
// poll_request_arrival
// file xnbd_common.c line 155
signed int poll_request_arrival(struct xnbd_session *ses);
// prctl
// file /usr/include/x86_64-linux-gnu/sys/prctl.h line 27
extern signed int prctl(signed int, ...);
// prepare_read_priv
// file xnbd_proxy_forwarder.c line 82
void prepare_read_priv(struct xnbd_proxy *proxy, struct proxy_priv *priv);
// prepare_write_priv
// file xnbd_proxy_forwarder.c line 113
void prepare_write_priv(struct xnbd_proxy *proxy, struct proxy_priv *priv);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// proxy_initialize
// file xnbd_proxy.c line 355
void proxy_initialize(struct xnbd_info *xnbd, struct xnbd_proxy *proxy);
// proxy_initialize_forwarder
// file xnbd_proxy.c line 324
void proxy_initialize_forwarder(struct xnbd_proxy *proxy, signed int remotefd);
// proxy_priv_dump
// file xnbd_proxy.h line 139
void proxy_priv_dump(struct proxy_priv *priv);
// proxy_shutdown
// file xnbd_proxy.c line 388
void proxy_shutdown(struct xnbd_proxy *proxy);
// proxy_shutdown_forwarder
// file xnbd_proxy.c line 331
void proxy_shutdown_forwarder(struct xnbd_proxy *proxy);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_create_or_abort
// file lib/io.h line 44
unsigned long int pthread_create_or_abort(void * (*start_routine)(void *), void *arg);
// pthread_create_or_abort::start_routine_object
//
void * start_routine_object(void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_3 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_3 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_0 *, struct anonymous_0 *);
// put_line
// file io.c line 250
signed int put_line(signed int fd, const char *msg);
// query_remote_disk_size
// file xnbd_wrapper.c line 1094
static void query_remote_disk_size(signed long int *p_disk_size_bytes, const char *host, const char *port, const char *exportname);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_all
// file io.c line 59
void read_all(signed int fd, void *buf, unsigned long int len);
// readv
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 39
extern signed long int readv(signed int, struct iovec *, signed int);
// recv_request
// file xnbd_proxy.c line 189
signed int recv_request(struct proxy_session *ps);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// report_return_code
// file xnbd_wrapper.c line 376
static void report_return_code(struct _IO_FILE *fp, signed int code);
// rx_thread_main
// file xnbd_proxy.c line 424
void * rx_thread_main(void *arg);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// set_process_name
// file lib/common.h line 95
void set_process_name(const char *name);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_0 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_0 *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous_0 *);
// sigmask_all
// file io.c line 270
void sigmask_all(void);
// signalfd
// file /usr/include/x86_64-linux-gnu/sys/signalfd.h line 53
extern signed int signalfd(signed int, const struct anonymous_0 *, signed int);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous_0 *, struct anonymous_0 *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_filemgr_thread
// file xnbd_wrapper.c line 724
static void * start_filemgr_thread(void *pointer);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strnlen
// file /usr/include/string.h line 405
extern unsigned long int strnlen(const char *, unsigned long int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// syscall
// file /usr/include/unistd.h line 1058
extern signed long int syscall(signed long int, ...);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// syslog_level
// file common.c line 46
signed int syslog_level(signed int glib_log_level);
// target_mode_main_cow
// file xnbd_target_cow_lzo.c line 748
signed int target_mode_main_cow(struct xnbd_session *ses);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tx_thread_main
// file xnbd_proxy.c line 448
void * tx_thread_main(void *arg);
// unix_connect
// file lib/net.h line 80
signed int unix_connect(const char *path);
// unix_recv_fd
// file lib/net.h line 82
signed int unix_recv_fd(signed int socket);
// unix_send_fd
// file lib/net.h line 81
signed int unix_send_fd(signed int socket, signed int fd);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unshift_func
// file xnbd_proxy.c line 522
static signed int unshift_func(const void *a, const void *b, void *user_data);
// update_block_with_found
// file xnbd_target_cow_lzo.c line 320
static void update_block_with_found(struct disk_stack *ds, struct disk_stack_io *io, unsigned long int index, unsigned long int start_index);
// update_proxy_settings
// file xnbd_wrapper.c line 312
static void update_proxy_settings(const char *local_exportname, const char *host, const char *port, const char *target_exportname);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// wait_until_readable
// file lib/io.h line 60
signed int wait_until_readable(signed int fd, signed int unblock_fd);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// waitpid_nohang_ghrfunc
// file xnbd_wrapper.c line 323
static signed int waitpid_nohang_ghrfunc(void *key, void *value, void *user_data);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_all
// file lib/io.h line 40
void write_all(signed int fd, const void *buf, unsigned long int len);
// writev
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 50
extern signed long int writev(signed int, struct iovec *, signed int);
// xnbd_cow_target_close_disk
// file xnbd_target_cow_lzo.c line 379
void xnbd_cow_target_close_disk(struct disk_stack *ds, signed int delete_cow);
// xnbd_cow_target_open_disk
// file xnbd_target_cow_lzo.c line 347
struct disk_stack * xnbd_cow_target_open_disk(char *diskpath, signed int newfile, signed int cowid);
// xnbd_cow_target_session_server
// file xnbd_target_cow_lzo.c line 857
signed int xnbd_cow_target_session_server(struct xnbd_session *ses);
// xnbd_proxy_control_cache_block
// file xnbd_proxy.c line 65
void xnbd_proxy_control_cache_block(signed int ctl_fd, unsigned long int index, unsigned long int nblocks);
// xnbd_proxy_session_server
// file xnbd_proxy.c line 885
signed int xnbd_proxy_session_server(struct xnbd_session *ses);
// xnbd_proxy_start
// file xnbd_proxy.c line 771
void xnbd_proxy_start(struct xnbd_info *xnbd);
// xnbd_proxy_stop
// file xnbd_proxy.c line 754
void xnbd_proxy_stop(struct xnbd_info *xnbd);

struct anonymous_4
{
  // target_host
  char *target_host;
  // target_port
  char *target_port;
  // bitmap_image
  char *bitmap_image;
  // control_socket_path
  char *control_socket_path;
  // target_exportname
  char *target_exportname;
};

struct anonymous_0
{
  // __val
  unsigned long int __val[16l];
};

union anonymous_6
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_3
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous_1
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_5
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

union _GMutex
{
  // p
  void *p;
  // i
  unsigned int i[2l];
};

struct _GString
{
  // str
  char *str;
  // len
  unsigned long int len;
  // allocated_len
  unsigned long int allocated_len;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _t_disk_data
{
  // local_exportname
  char *local_exportname;
  // disk_file_name
  char *disk_file_name;
  // index
  unsigned int index;
  // proxy
  struct anonymous_4 proxy;
};

struct _t_listing_state
{
  // index_to_print
  unsigned int index_to_print;
  // index_up_next
  unsigned int index_up_next;
  // fp
  struct _IO_FILE *fp;
};

struct _t_thread_data
{
  // unix_sock_fd
  signed int unix_sock_fd;
  // xnbd_bgctl_command
  const char *xnbd_bgctl_command;
  // p_child_process_count
  signed int *p_child_process_count;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct cachestat
{
  // nblocks
  unsigned long int nblocks;
  // cache_odread
  unsigned long int cache_odread;
  // cache_odwrite
  unsigned long int cache_odwrite;
  // cache_bgcopy
  unsigned long int cache_bgcopy;
  // io_blocks
  unsigned long int io_blocks;
  // read_blocks
  unsigned long int read_blocks;
  // written_blocks
  unsigned long int written_blocks;
  // cache_hit
  unsigned long int cache_hit;
  // cache_miss
  unsigned long int cache_miss;
};

struct cmsghdr
{
  // cmsg_len
  unsigned long int cmsg_len;
  // cmsg_level
  signed int cmsg_level;
  // cmsg_type
  signed int cmsg_type;
  // __cmsg_data
  unsigned char __cmsg_data[0l];
};

struct custom_log_handler_params
{
  // use_syslog
  signed int use_syslog;
  // use_fd
  signed int use_fd;
  // fd
  signed int fd;
};

struct disk_image
{
  // path
  char *path;
  // diskfd
  signed int diskfd;
  // bmpath
  char *bmpath;
  // bm
  unsigned long int *bm;
  // bmlen
  unsigned long int bmlen;
};

struct disk_stack
{
  // nlayers
  signed int nlayers;
  // image
  struct disk_image *image[10l];
  // disksize
  signed long int disksize;
};

struct disk_stack_io
{
  // ds
  struct disk_stack *ds;
  // bufs
  char *bufs[10l];
  // buflen
  unsigned long int buflen;
  // iov
  struct iovec *iov;
  // iov_size
  unsigned int iov_size;
};

union epoll_data
{
  // ptr
  void *ptr;
  // fd
  signed int fd;
  // u32
  unsigned int u32;
  // u64
  unsigned long int u64;
};

struct epoll_event
{
  // events
  unsigned int events;
  // data
  union epoll_data data;
} __attribute__ ((__packed__));

struct exec_params
{
  // binpath
  const char *binpath;
  // target_mode
  const char *target_mode;
  // readonly
  signed int readonly;
  // syslog
  signed int syslog;
  // proxy_max_que_size_str
  const char *proxy_max_que_size_str;
  // proxy_max_buf_size_str
  const char *proxy_max_buf_size_str;
};

struct in6_addr
{
  // __in6_u
  union anonymous_6 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct mmap_partial
{
  // iobuf
  void *iobuf;
  // buf
  void *buf;
  // len
  unsigned long int len;
  // offset
  signed long int offset;
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct nbd_negotiate_pdu_new_0
{
  // passwd
  unsigned long int passwd;
  // magic
  unsigned long int magic;
  // flag16
  unsigned short int flag16;
} __attribute__ ((__packed__));

struct nbd_negotiate_pdu_new_1
{
  // reserved
  unsigned int reserved;
  // opt_magic
  unsigned long int opt_magic;
  // opt
  unsigned int opt;
  // namesize
  unsigned int namesize;
} __attribute__ ((__packed__));

struct nbd_negotiate_pdu_new_2
{
  // size
  unsigned long int size;
  // flags
  unsigned short int flags;
  // padding
  char padding[124l];
} __attribute__ ((__packed__));

struct nbd_negotiate_pdu_old
{
  // passwd
  unsigned long int passwd;
  // magic
  unsigned long int magic;
  // size
  unsigned long int size;
  // flags
  unsigned int flags;
  // padding
  char padding[124l];
} __attribute__ ((__packed__));

struct nbd_reply
{
  // magic
  unsigned int magic;
  // error
  unsigned int error;
  // handle
  unsigned long int handle;
};

struct nbd_request
{
  // magic
  unsigned int magic;
  // type
  unsigned int type;
  // handle
  unsigned long int handle;
  // from
  unsigned long int from;
  // len
  unsigned int len;
} __attribute__ ((__packed__));

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

struct remote_read_request
{
  // bindex_iofrom
  signed long int bindex_iofrom;
  // bindex_iolen
  unsigned long int bindex_iolen;
};

struct proxy_priv
{
  // clientfd
  signed int clientfd;
  // iotype
  unsigned int iotype;
  // nreq
  signed int nreq;
  // req
  struct remote_read_request req[32l];
  // iofrom
  signed long int iofrom;
  // iolen
  unsigned long int iolen;
  // block_index_start
  unsigned long int block_index_start;
  // block_index_end
  unsigned long int block_index_end;
  // reply
  struct nbd_reply reply;
  // write_buff
  char *write_buff;
  // read_buff
  char *read_buff;
  // tx_queue
  struct _GAsyncQueue *tx_queue;
  // need_exit
  signed int need_exit;
  // need_retry
  signed int need_retry;
  // prepare_done
  signed int prepare_done;
  // seqnum
  unsigned long int seqnum;
};

struct proxy_session
{
  // nbd_fd
  signed int nbd_fd;
  // wrk_fd
  signed int wrk_fd;
  // tx_queue
  struct _GAsyncQueue *tx_queue;
  // proxy
  struct xnbd_proxy *proxy;
  // tid_tx
  unsigned long int tid_tx;
  // tid_rx
  unsigned long int tid_rx;
  // pipe_write_fd
  signed int pipe_write_fd;
  // pipe_read_fd
  signed int pipe_read_fd;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct signalfd_siginfo
{
  // ssi_signo
  unsigned int ssi_signo;
  // ssi_errno
  signed int ssi_errno;
  // ssi_code
  signed int ssi_code;
  // ssi_pid
  unsigned int ssi_pid;
  // ssi_uid
  unsigned int ssi_uid;
  // ssi_fd
  signed int ssi_fd;
  // ssi_tid
  unsigned int ssi_tid;
  // ssi_band
  unsigned int ssi_band;
  // ssi_overrun
  unsigned int ssi_overrun;
  // ssi_trapno
  unsigned int ssi_trapno;
  // ssi_status
  signed int ssi_status;
  // ssi_int
  signed int ssi_int;
  // ssi_ptr
  unsigned long int ssi_ptr;
  // ssi_utime
  unsigned long int ssi_utime;
  // ssi_stime
  unsigned long int ssi_stime;
  // ssi_addr
  unsigned long int ssi_addr;
  // __pad
  unsigned char __pad[48l];
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct xnbd_info
{
  // cmd
  enum xnbd_cmd_type cmd;
  // disksize
  signed long int disksize;
  // nblocks
  unsigned long int nblocks;
  // readonly
  signed int readonly;
  // sessions
  struct _GList *sessions;
  // target_diskpath
  char *target_diskpath;
  // target_diskfd
  signed int target_diskfd;
  // cow_diskpath
  char *cow_diskpath;
  // cow_ds
  struct disk_stack *cow_ds;
  // proxy_pid
  signed int proxy_pid;
  // proxy_sockpair_proxy_fd
  signed int proxy_sockpair_proxy_fd;
  // proxy_sockpair_master_fd
  signed int proxy_sockpair_master_fd;
  // proxy_diskpath
  char *proxy_diskpath;
  // proxy_bmpath
  char *proxy_bmpath;
  // proxy_rhost
  char *proxy_rhost;
  // proxy_rport
  char *proxy_rport;
  // proxy_unixpath
  char *proxy_unixpath;
  // proxy_target_exportname
  char *proxy_target_exportname;
  // proxy_clear_bitmap
  _Bool proxy_clear_bitmap;
  // proxy_max_buf_size
  unsigned long int proxy_max_buf_size;
  // proxy_max_que_size
  unsigned long int proxy_max_que_size;
};

struct xnbd_proxy
{
  // tid_fwd_tx
  unsigned long int tid_fwd_tx;
  // tid_fwd_rx
  unsigned long int tid_fwd_rx;
  // fwd_tx_queue
  struct _GAsyncQueue *fwd_tx_queue;
  // fwd_rx_queue
  struct _GAsyncQueue *fwd_rx_queue;
  // fwd_retry_queue
  struct _GAsyncQueue *fwd_retry_queue;
  // xnbd
  struct xnbd_info *xnbd;
  // remotefd
  signed int remotefd;
  // cachefd
  signed int cachefd;
  // cbitmap
  unsigned long int *cbitmap;
  // cbitmaplen
  unsigned long int cbitmaplen;
  // shared_buff
  char *shared_buff;
  // curr_use_mutex
  union _GMutex curr_use_mutex;
  // cur_use_buf
  unsigned long int cur_use_buf;
  // cur_use_que
  unsigned long int cur_use_que;
};

struct xnbd_proxy_query
{
  // disksize
  signed long int disksize;
  // diskpath
  char diskpath[4096l];
  // bmpath
  char bmpath[4096l];
  // master_pid
  signed int master_pid;
  // rhost
  char rhost[4096l];
  // rport
  char rport[4096l];
  // max_use_buf
  unsigned long int max_use_buf;
  // max_use_que
  unsigned long int max_use_que;
  // cur_use_buf
  unsigned long int cur_use_buf;
  // cur_use_que
  unsigned long int cur_use_que;
};

struct xnbd_session
{
  // clientfd
  signed int clientfd;
  // xnbd
  struct xnbd_info *xnbd;
  // pipe_worker_fd
  signed int pipe_worker_fd;
  // pipe_master_fd
  signed int pipe_master_fd;
  // pid
  signed int pid;
  // notifying
  signed int notifying;
};


// CBLOCKSIZE
// file xnbd_common.c line 28
const unsigned int CBLOCKSIZE = (const unsigned int)4096;
// MAX_CTL_CONNS
// file xnbd_wrapper.c line 591
static const signed int MAX_CTL_CONNS = 8;
// NBD_NEGOTIATE_MAGIC_NEW
// file nbd.c line 315
const unsigned long int NBD_NEGOTIATE_MAGIC_NEW = (const unsigned long int)0x49484156454F5054LL;
// NBD_NEGOTIATE_MAGIC_OLD
// file nbd.c line 314
const unsigned long int NBD_NEGOTIATE_MAGIC_OLD = (const unsigned long int)0x0000420281861253LL;
// NBD_OPT_EXPORT_NAME
// file nbd.c line 316
const unsigned int NBD_OPT_EXPORT_NAME = (const unsigned int)1;
// NBD_PASSWD
// file nbd.c line 312
const unsigned long int NBD_PASSWD = (const unsigned long int)0x4e42444d41474943LL;
// PAGESIZE
// file xnbd_common.c line 29
unsigned int PAGESIZE = (unsigned int)4096;
// XNBD_PORT
// file xnbd_common.c line 31
const signed int XNBD_PORT = 8520;
// conn_list
// file xnbd_proxy.c line 409
struct _GList *conn_list = (struct _GList *)(void *)0;
// fwd_counter
// file xnbd_proxy_forwarder.c line 219
static unsigned long int fwd_counter = (unsigned long int)0;
// help_string
// file xnbd_wrapper.c line 1120
static const char help_string[1313l] = { '\n', '\n', 'U', 's', 'a', 'g', 'e', ':', ' ', '\n', ' ', ' ', '%', 's', ' ', '[', 'o', 'p', 't', 'i', 'o', 'n', 's', ']', '\n', '\n', 'O', 'p', 't', 'i', 'o', 'n', 's', ':', ' ', '\n', ' ', ' ', '-', '-', 'd', 'a', 'e', 'm', 'o', 'n', 'i', 'z', 'e', ' ', ' ', ' ', ' ', 'r', 'u', 'n', ' ', 'w', 'r', 'a', 'p', 'p', 'e', 'r', ' ', 'a', 's', ' ', 'a', ' ', 'd', 'a', 'e', 'm', 'o', 'n', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', '\n', ' ', ' ', '-', '-', 'c', 'o', 'w', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'r', 'u', 'n', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'i', 'n', 's', 't', 'a', 'n', 'c', 'e', 's', ' ', 'a', 's', ' ', 'a', ' ', 'c', 'o', 'w', ' ', 't', 'a', 'r', 'g', 'e', 't', '\n', ' ', ' ', '-', '-', 'r', 'e', 'a', 'd', 'o', 'n', 'l', 'y', ' ', ' ', ' ', ' ', ' ', 'r', 'u', 'n', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'i', 'n', 's', 't', 'a', 'n', 'c', 'e', 's', ' ', 'a', 's', ' ', 'a', ' ', 'r', 'e', 'a', 'd', 'o', 'n', 'l', 'y', ' ', 't', 'a', 'r', 'g', 'e', 't', '\n', ' ', ' ', '-', '-', 'l', 'a', 'd', 'd', 'r', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'l', 'i', 's', 't', 'e', 'n', 'i', 'n', 'g', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', '\n', ' ', ' ', '-', '-', 'l', 'p', 'o', 'r', 't', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'l', 'i', 's', 't', 'e', 'n', 'i', 'n', 'g', ' ', 'p', 'o', 'r', 't', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ':', ' ', '8', '5', '2', '0', ')', '\n', ' ', '(', '-', '-', 'p', 'o', 'r', 't', ')', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'd', 'e', 'p', 'r', 'e', 'c', 'a', 't', 'e', 'd', ',', ' ', 'u', 's', 'e', ' ', '-', '-', 'l', 'p', 'o', 'r', 't', ' ', 'i', 'n', 's', 't', 'e', 'a', 'd', '\n', ' ', ' ', '-', '-', 'x', 'n', 'b', 'd', '-', 'b', 'g', 'c', 't', 'l', ' ', ' ', ' ', 'p', 'a', 't', 'h', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'x', 'n', 'b', 'd', '-', 'b', 'g', 'c', 't', 'l', ' ', 'e', 'x', 'e', 'c', 'u', 't', 'a', 'b', 'l', 'e', '\n', ' ', ' ', '-', '-', 'x', 'n', 'b', 'd', '-', 's', 'e', 'r', 'v', 'e', 'r', ' ', ' ', 'p', 'a', 't', 'h', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'x', 'n', 'b', 'd', '-', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'e', 'x', 'e', 'c', 'u', 't', 'a', 'b', 'l', 'e', '\n', ' ', ' ', '-', '-', 'i', 'm', 'g', 'f', 'i', 'l', 'e', ' ', ' ', ' ', ' ', ' ', ' ', 'p', 'a', 't', 'h', ' ', 't', 'o', ' ', 'a', ' ', 'd', 'i', 's', 'k', ' ', 'i', 'm', 'a', 'g', 'e', ' ', 'f', 'i', 'l', 'e', '.', ' ', 'T', 'h', 'i', 's', ' ', 'o', 'p', 't', 'i', 'o', 'n', 's', ' ', 'c', 'a', 'n', ' ', 'b', 'e', ' ', 'u', 's', 'e', 'd', ' ', 'm', 'u', 'l', 't', 'i', 'p', 'l', 'e', ' ', 't', 'i', 'm', 'e', 's', '.', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'U', 's', 'e', ' ', 'a', 'l', 's', 'o', ' ', 'x', 'n', 'b', 'd', '-', 'w', 'r', 'a', 'p', 'p', 'e', 'r', '-', 'c', 't', 'l', ' ', 't', 'o', ' ', '(', 'd', 'e', ')', 'r', 'e', 'g', 'i', 's', 't', 'e', 'r', ' ', 'd', 'i', 's', 'k', ' ', 'i', 'm', 'a', 'g', 'e', 's', ' ', 'd', 'y', 'n', 'a', 'm', 'i', 'c', 'a', 'l', 'l', 'y', '.', '\n', ' ', ' ', '-', '-', 'l', 'o', 'g', 'p', 'a', 't', 'h', ' ', 'P', 'A', 'T', 'H', ' ', 'u', 's', 'e', ' ', 't', 'h', 'e', ' ', 'g', 'i', 'v', 'e', 'n', ' ', 'p', 'a', 't', 'h', ' ', 'f', 'o', 'r', ' ', 'l', 'o', 'g', 'g', 'i', 'n', 'g', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ':', ' ', 's', 't', 'd', 'e', 'r', 'r', '/', 's', 'y', 's', 'l', 'o', 'g', ')', '\n', ' ', ' ', '-', '-', 's', 'o', 'c', 'k', 'e', 't', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'u', 'n', 'i', 'x', ' ', 's', 'o', 'c', 'k', 'e', 't', ' ', 'p', 'a', 't', 'h', ' ', 't', 'o', ' ', 'l', 'i', 's', 't', 'e', 'n', ' ', 'o', 'n', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ':', ' ', '/', 'v', 'a', 'r', '/', 'r', 'u', 'n', '/', 'x', 'n', 'b', 'd', '-', 'w', 'r', 'a', 'p', 'p', 'e', 'r', '.', 'c', 't', 'l', ')', '.', '\n', ' ', ' ', '-', '-', 's', 'y', 's', 'l', 'o', 'g', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'u', 's', 'e', ' ', 's', 'y', 's', 'l', 'o', 'g', ' ', 'f', 'o', 'r', ' ', 'l', 'o', 'g', 'g', 'i', 'n', 'g', '\n', ' ', ' ', '-', '-', 'm', 'a', 'x', '-', 'q', 'u', 'e', 'u', 'e', '-', 's', 'i', 'z', 'e', ' ', 'S', 'I', 'Z', 'E', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 's', 'e', 't', ' ', 't', 'h', 'e', ' ', 'l', 'i', 'm', 'i', 't', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', ' ', 'q', 'u', 'e', 'u', 'e', ' ', 's', 'i', 'z', 'e', ' ', 'p', 'e', 'r', ' ', 'x', 'n', 'b', 'd', '-', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ':', ' ', '0', ',', ' ', 'n', 'o', ' ', 'l', 'i', 'm', 'i', 't', ')', '\n', ' ', ' ', '-', '-', 'm', 'a', 'x', '-', 'b', 'u', 'f', '-', 's', 'i', 'z', 'e', ' ', 'S', 'I', 'Z', 'E', ' ', '(', 'b', 'y', 't', 'e', 's', ')', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 's', 'e', 't', ' ', 't', 'h', 'e', ' ', 'l', 'i', 'm', 'i', 't', ' ', 'o', 'f', ' ', 'i', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'b', 'u', 'f', 'f', 'e', 'r', ' ', 'u', 's', 'a', 'g', 'e', ' ', 'p', 'e', 'r', ' ', 'x', 'n', 'b', 'd', '-', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ':', ' ', '0', ',', ' ', 'n', 'o', ' ', 'l', 'i', 'm', 'i', 't', ')', '\n', '\n', 'E', 'x', 'a', 'm', 'p', 'l', 'e', 's', ':', ' ', '\n', ' ', ' ', 'x', 'n', 'b', 'd', '-', 'w', 'r', 'a', 'p', 'p', 'e', 'r', ' ', '-', '-', 'i', 'm', 'g', 'f', 'i', 'l', 'e', ' ', '/', 'd', 'a', 't', 'a', '/', 'd', 'i', 's', 'k', '1', '\n', ' ', ' ', 'x', 'n', 'b', 'd', '-', 'w', 'r', 'a', 'p', 'p', 'e', 'r', ' ', '-', '-', 'i', 'm', 'g', 'f', 'i', 'l', 'e', ' ', '/', 'd', 'a', 't', 'a', '/', 'd', 'i', 's', 'k', '1', ' ', '-', '-', 'i', 'm', 'g', 'f', 'i', 'l', 'e', ' ', '/', 'd', 'a', 't', 'a', '/', 'd', 'i', 's', 'k', '2', ' ', '-', '-', 'x', 'n', 'b', 'd', '-', 's', 'e', 'r', 'v', 'e', 'r', ' ', '/', 'u', 's', 'r', '/', 'l', 'o', 'c', 'a', 'l', '/', 'b', 'i', 'n', '/', 'x', 'n', 'b', 'd', '-', 's', 'e', 'r', 'v', 'e', 'r', ' ', '-', '-', 'x', 'n', 'b', 'd', '-', 'b', 'g', 'c', 't', 'l', ' ', '/', 'u', 's', 'r', '/', 'l', 'o', 'c', 'a', 'l', '/', 'b', 'i', 'n', '/', 'x', 'n', 'b', 'd', '-', 'b', 'g', 'c', 't', 'l', ' ', '-', '-', 'l', 'a', 'd', 'd', 'r', ' ', '1', '2', '7', '.', '0', '.', '0', '.', '1', ' ', '-', '-', 'l', 'p', 'o', 'r', 't', ' ', '1', '8', '5', '2', '0', ' ', '-', '-', 's', 'o', 'c', 'k', 'e', 't', ' ', '/', 't', 'm', 'p', '/', 'x', 'n', 'b', 'd', '-', 'w', 'r', 'a', 'p', 'p', 'e', 'r', '.', 'c', 't', 'l', '\n', 0 };
// images_added_ever
// file xnbd_wrapper.c line 56
unsigned int images_added_ever = (unsigned int)0;
// mgr_threads
// file xnbd_wrapper.c line 593
static signed int mgr_threads = 0;
// mutex
// file xnbd_wrapper.c line 53
union anonymous_3 mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// myhandle
// file nbd.c line 93
static const unsigned long int myhandle = 18446744073709551615UL;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// p_disk_dict
// file xnbd_wrapper.c line 54
struct _GHashTable *p_disk_dict = (struct _GHashTable *)(void *)0;
// p_server_pid_set
// file xnbd_wrapper.c line 55
struct _GHashTable *p_server_pid_set = (struct _GHashTable *)(void *)0;
// priv_stop_forwarder
// file xnbd_proxy.c line 29
struct proxy_priv priv_stop_forwarder = { .clientfd=0, .iotype=(unsigned int)6, .nreq=0, .req={ { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul } },
    .iofrom=0l,
    .iolen=0ul, .block_index_start=0ul, .block_index_end=0ul,
    .reply={ .magic=0u, .error=0u, .handle=0ul }, .write_buff=(char *)(void *)0,
    .read_buff=(char *)(void *)0, .tx_queue=((struct _GAsyncQueue *)NULL),
    .need_exit=0,
    .need_retry=0, .prepare_done=0, .seqnum=0ul };
// receiving_failed
// file xnbd_proxy_forwarder.c line 294
static signed int receiving_failed = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;

// __bswap_64
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 109
static inline unsigned long int __bswap_64(unsigned long int __bsx)
{
  signed long long int return_value___builtin_bswap64_1;
  return_value___builtin_bswap64_1=__builtin_bswap64((signed long long int)__bsx);
  return (unsigned long int)return_value___builtin_bswap64_1;
}

// about_to_execute
// file xnbd_wrapper.c line 150
static void about_to_execute(const char * const *argv)
{
  (void)argv;
}

// add_diskimg
// file xnbd_wrapper.c line 215
static signed int add_diskimg(struct _t_disk_data *p_disk_data)
{
  signed int fd;
  fd=open(p_disk_data->disk_file_name, 00);
  unsigned int tmp_post_1;
  if(!(fd >= 0))
    return -1;

  else
  {
    close(fd);
    pthread_mutex_lock(&mutex);
    signed int res = 0;
    void *return_value_g_hash_table_lookup_2;
    return_value_g_hash_table_lookup_2=g_hash_table_lookup(p_disk_dict, (const void *)p_disk_data->local_exportname);
    if(!(return_value_g_hash_table_lookup_2 == NULL))
      res = -4;

    else
    {
      tmp_post_1 = images_added_ever;
      images_added_ever = images_added_ever + 1u;
      p_disk_data->index = tmp_post_1;
      g_hash_table_insert(p_disk_dict, (void *)p_disk_data->local_exportname, (void *)p_disk_data);
    }
    pthread_mutex_unlock(&mutex);
    return res;
  }
}

// add_read_block_to_tail
// file xnbd_proxy_forwarder.c line 56
void add_read_block_to_tail(struct proxy_priv *priv, unsigned long int i)
{
  signed int cur_nreq = priv->nreq;
  if(cur_nreq >= 1)
  {
    struct remote_read_request *last_req = &priv->req[(signed long int)(cur_nreq - 1)];
    if(i == last_req->bindex_iolen + (unsigned long int)last_req->bindex_iofrom)
    {
      last_req->bindex_iolen = last_req->bindex_iolen + (unsigned long int)1;
      goto __CPROVER_DUMP_L6;
    }

  }

  priv->req[(signed long int)cur_nreq].bindex_iofrom = (signed long int)i;
  priv->req[(signed long int)cur_nreq].bindex_iolen = (unsigned long int)1;
  priv->nreq = priv->nreq + 1;
  if(priv->nreq == 32)
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bug, MAXNBLOCK is too small", return_value_pthread_self_1, (const void *)"add_read_block_to_tail");

  __CPROVER_DUMP_L4:
    ;
    goto __CPROVER_DUMP_L4;
  }


__CPROVER_DUMP_L6:
  ;
}

// bitmap_alloc
// file bitmap.c line 43
unsigned long int * bitmap_alloc(unsigned long int bits)
{
  unsigned long int *bitmap_array;
  unsigned long int narrays = ((bits + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ );
  void *return_value_g_malloc0_n_1;
  return_value_g_malloc0_n_1=g_malloc0_n(narrays, sizeof(unsigned long int) /*8ul*/ );
  bitmap_array = (unsigned long int *)return_value_g_malloc0_n_1;
  return bitmap_array;
}

// bitmap_close_file
// file lib/bitmap.h line 37
void bitmap_close_file(unsigned long int *bitmap, unsigned long int bitmaplen)
{

__CPROVER_DUMP_L1:
  ;
  signed int ret;
  ret=msync((void *)bitmap, bitmaplen, 4);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) msync bitmap failed", return_value_pthread_self_1, (const void *)"bitmap_close_file");

  __CPROVER_DUMP_L3:
    ;
    goto __CPROVER_DUMP_L3;
  }

  munmap_or_abort((void *)bitmap, bitmaplen);
}

// bitmap_create
// file bitmap.c line 147
unsigned long int * bitmap_create(char *bitmapfile, unsigned long int bits, signed int *cbitmapfd, unsigned long int *cbitmaplen)
{
  signed int fd;
  signed int bitmap_create__1__ret;
  void *buf = (void *)0;
  unsigned long int narrays = ((bits + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ );
  unsigned long int buflen = sizeof(unsigned long int) /*8ul*/  * narrays;
  fd=open(bitmapfile, 02 | 0100 | 01000000, 0400 | 0200);
  if(!(fd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open bitmapfile", return_value_pthread_self_1, (const void *)"bitmap_create");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  signed long int ret;
  ret=lseek(fd, (signed long int)buflen - (signed long int)1, 0);
  if(!(ret >= 0l))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) lseek", return_value_pthread_self_2, (const void *)"bitmap_create");

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

  ret=write(fd, (const void *)"\0", (unsigned long int)1);
  if(!(ret >= 0l))
  {
    unsigned long int return_value_pthread_self_3;
    return_value_pthread_self_3=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) write", return_value_pthread_self_3, (const void *)"bitmap_create");

  __CPROVER_DUMP_L8:
    ;
    goto __CPROVER_DUMP_L8;
  }

  buf=mmap((void *)0, buflen, 0x1 | 0x2, 0x01, fd, (signed long int)0);
  if(buf == (void *)-1)
  {
    unsigned long int return_value_pthread_self_4;
    return_value_pthread_self_4=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bitmap mapping failed", return_value_pthread_self_4, (const void *)"bitmap_create");

  __CPROVER_DUMP_L11:
    ;
    goto __CPROVER_DUMP_L11;
  }

  memset(buf, 0, buflen);
  bitmap_create__1__ret=msync(buf, buflen, 4);
  if(!(bitmap_create__1__ret >= 0))
  {
    unsigned long int return_value_pthread_self_5;
    return_value_pthread_self_5=pthread_self();
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    char *return_value_strerror_7;
    return_value_strerror_7=strerror(*return_value___errno_location_6);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bitmap msync failed, %s", return_value_pthread_self_5, (const void *)"bitmap_create", return_value_strerror_7);

  __CPROVER_DUMP_L14:
    ;
    goto __CPROVER_DUMP_L14;
  }

  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "bitmap %s, %lu arrays of %zu bytes, %lu nbits", bitmapfile, narrays, sizeof(unsigned long int) /*8ul*/ , bits);
  while((_Bool)0);
  *cbitmapfd = fd;
  *cbitmaplen = buflen;
  return (unsigned long int *)buf;
}

// bitmap_on
// file lib/bitmap.h line 40
void bitmap_on(unsigned long int *bitmap_array, unsigned long int block_index)
{
  unsigned long int bitmap_index = block_index / (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8);
  unsigned long int *bitmap = &bitmap_array[(signed long int)bitmap_index];
  *bitmap = *bitmap | 1UL << block_index % (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8);
}

// bitmap_open_file
// file lib/bitmap.h line 36
unsigned long int * bitmap_open_file(const char *bitmapfile, unsigned long int bits, unsigned long int *bitmaplen, signed int readonly, signed int zeroclear)
{
  void *buf = (void *)0;
  unsigned long int narrays = ((bits + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ );
  unsigned long int buflen = sizeof(unsigned long int) /*8ul*/  * narrays;
  signed int mmap_flag = readonly != 0 ? 0x1 : 0x2;
  signed int open_flag = readonly != 0 ? 00 : 02 | 0100;
  struct stat st;
  signed int ret;
  ret=stat(bitmapfile, &st);
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 2)
      open_flag = open_flag | 01000000;

    else
    {
      unsigned long int return_value_pthread_self_1;
      return_value_pthread_self_1=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) stat %s, %m", return_value_pthread_self_1, (const void *)"bitmap_open_file", bitmapfile);

    __CPROVER_DUMP_L2:
      ;
      goto __CPROVER_DUMP_L2;
    }
  }

  else
  {
    unsigned int return_value_geteuid_3;
    return_value_geteuid_3=geteuid();
    if(st.st_uid == return_value_geteuid_3)
      open_flag = open_flag | 01000000;

  }
  signed int fd;
  fd=open(bitmapfile, open_flag, 0400 | 0200);
  if(!(fd >= 0))
  {
    unsigned long int return_value_pthread_self_4;
    return_value_pthread_self_4=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bitmap open %s, %m", return_value_pthread_self_4, (const void *)"bitmap_open_file", bitmapfile);

  __CPROVER_DUMP_L8:
    ;
    goto __CPROVER_DUMP_L8;
  }

  if(!(readonly == 0))
  {
    unsigned long int size;
    signed long int return_value_get_disksize_5;
    return_value_get_disksize_5=get_disksize(fd);
    size = (unsigned long int)return_value_get_disksize_5;
    if(!(size == buflen))
    {
      unsigned long int return_value_pthread_self_6;
      return_value_pthread_self_6=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bitmap size mismatch, %ju %zu", return_value_pthread_self_6, (const void *)"bitmap_open_file", size, buflen);

    __CPROVER_DUMP_L11:
      ;
      goto __CPROVER_DUMP_L11;
    }

  }

  else
  {
    unsigned long int previous_size;
    signed long int return_value_get_disksize_7;
    return_value_get_disksize_7=get_disksize(fd);
    previous_size = (const unsigned long int)return_value_get_disksize_7;
    if(previous_size == 0ul)
      zeroclear = 1;

    if(!(previous_size == buflen))
    {
      if(!(zeroclear == 0))
      {
        signed int bitmap_open_file__1__2__3__2__1__ret;
        bitmap_open_file__1__2__3__2__1__ret=ftruncate(fd, (signed long int)buflen);
        if(!(bitmap_open_file__1__2__3__2__1__ret >= 0))
        {
          unsigned long int return_value_pthread_self_8;
          return_value_pthread_self_8=pthread_self();
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) ftruncate %m", return_value_pthread_self_8, (const void *)"bitmap_open_file");

        __CPROVER_DUMP_L16:
          ;
          goto __CPROVER_DUMP_L16;
        }

      }

      else
      {
        unsigned long int return_value_pthread_self_9;
        return_value_pthread_self_9=pthread_self();
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) Denying to re-use existing bitmap file of different size with no --clear-bitmap given.", return_value_pthread_self_9, (const void *)"bitmap_open_file");

      __CPROVER_DUMP_L19:
        ;
        goto __CPROVER_DUMP_L19;
      }
    }

  }
  buf=mmap((void *)0, buflen, mmap_flag, 0x01, fd, (signed long int)0);
  if(buf == (void *)-1)
  {
    unsigned long int return_value_pthread_self_10;
    return_value_pthread_self_10=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bitmap mapping failed", return_value_pthread_self_10, (const void *)"bitmap_open_file");

  __CPROVER_DUMP_L23:
    ;
    goto __CPROVER_DUMP_L23;
  }

  close(fd);
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "bitmap file %s (%zu bytes = %lu arrays of %zu bytes), %lu nbits", bitmapfile, buflen, narrays, sizeof(unsigned long int) /*8ul*/ , bits);
  while((_Bool)0);
  if(readonly == 0)
  {
    if(!(zeroclear == 0))
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "bitmap file %s zero-cleared", bitmapfile);
      while((_Bool)0);
      memset(buf, 0, buflen);
    }

    else
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "re-using previous state from bitmap file %s", bitmapfile);
      while((_Bool)0);
    signed int bitmap_open_file__1__4__ret;
    bitmap_open_file__1__4__ret=msync(buf, buflen, 4);
    if(!(bitmap_open_file__1__4__ret >= 0))
    {
      unsigned long int return_value_pthread_self_11;
      return_value_pthread_self_11=pthread_self();
      signed int *return_value___errno_location_12;
      return_value___errno_location_12=__errno_location();
      char *return_value_strerror_13;
      return_value_strerror_13=strerror(*return_value___errno_location_12);
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bitmap msync failed, %s", return_value_pthread_self_11, (const void *)"bitmap_open_file", return_value_strerror_13);

    __CPROVER_DUMP_L30:
      ;
      goto __CPROVER_DUMP_L30;
    }

  }

  *bitmaplen = buflen;
  return (unsigned long int *)buf;
}

// bitmap_size
// file bitmap.c line 37
unsigned long int bitmap_size(unsigned long int bits)
{
  unsigned long int narrays = ((bits + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ );
  return sizeof(unsigned long int) /*8ul*/  * narrays;
}

// bitmap_test
// file lib/bitmap.h line 39
signed int bitmap_test(unsigned long int *bitmap_array, unsigned long int block_index)
{
  unsigned long int bitmap_index = block_index / (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8);
  unsigned long int *bitmap = &bitmap_array[(signed long int)bitmap_index];
  unsigned long int val = *bitmap & 1UL << block_index % (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8);
  if(val >= 1ul)
    return 1;

  else
    return 0;
}

// block_all_signals
// file xnbd_proxy.c line 51
void block_all_signals(void)
{
  struct anonymous_0 sig;
  signed int ret;
  ret=sigfillset(&sig);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) sigfillset", return_value_pthread_self_1, (const void *)"block_all_signals");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  ret=pthread_sigmask(2, &sig, (struct anonymous_0 *)(void *)0);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) sigmask", return_value_pthread_self_2, (const void *)"block_all_signals");

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

}

// cachestat_cache_bgcopy
// file xnbd_cachestat.c line 254
inline void cachestat_cache_bgcopy(void)
{
  ;
}

// cachestat_cache_odread
// file xnbd_cachestat.c line 252
inline void cachestat_cache_odread(void)
{
  ;
}

// cachestat_cache_odwrite
// file xnbd_cachestat.c line 253
inline void cachestat_cache_odwrite(void)
{
  ;
}

// cachestat_dump
// file xnbd_cachestat.c line 48
void cachestat_dump(char *path)
{
  signed int fd;
  char *buf;
  fd=open(path, 00);
  if(!(fd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open cachestat file %s, %s", return_value_pthread_self_1, (const void *)"cachestat_dump", path, return_value_strerror_3);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  void *return_value_mmap_4;
  return_value_mmap_4=mmap((void *)0, (unsigned long int)PAGESIZE, 0x1, 0x01, fd, (signed long int)0);
  buf = (char *)return_value_mmap_4;
  if(buf == (char *)-1)
  {
    unsigned long int return_value_pthread_self_5;
    return_value_pthread_self_5=pthread_self();
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    char *return_value_strerror_7;
    return_value_strerror_7=strerror(*return_value___errno_location_6);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) disk mapping failed, %s", return_value_pthread_self_5, (const void *)"cachestat_dump", return_value_strerror_7);

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

  struct cachestat *st = (struct cachestat *)buf;
  printf("nblocks %lu\n", st->nblocks);
  printf("cached_by_ondemand_read %lu\n", st->cache_odread);
  printf("cached_by_ondemand_write %lu\n", st->cache_odwrite);
  printf("cached_by_bgcopy %lu\n", st->cache_bgcopy);
  printf("io_blocks %lu\n", st->io_blocks);
  printf("read_blocks %lu\n", st->read_blocks);
  printf("written_blocks  %lu\n", st->written_blocks);
  printf("cache_hit %lu\n", st->cache_hit);
  printf("cache_miss %lu\n", st->cache_miss);
  printf("cache_hit_ratio %lf\n", (100.0 * (double)st->cache_hit) / (double)(st->cache_hit + st->cache_miss));
  printf("transferred blocks %lu\n", st->cache_miss + st->cache_bgcopy);
  munmap_or_abort((void *)buf, (unsigned long int)PAGESIZE);
  close(fd);
}

// cachestat_dump_loop
// file xnbd_cachestat.c line 84
void cachestat_dump_loop(char *path, unsigned int interval)
{
  signed int fd;
  char *buf;
  fd=open(path, 00);
  if(!(fd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open cachestat file %s, %s", return_value_pthread_self_1, (const void *)"cachestat_dump_loop", path, return_value_strerror_3);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  void *return_value_mmap_4;
  return_value_mmap_4=mmap((void *)0, (unsigned long int)PAGESIZE, 0x1, 0x01, fd, (signed long int)0);
  buf = (char *)return_value_mmap_4;
  if(buf == (char *)-1)
  {
    unsigned long int return_value_pthread_self_5;
    return_value_pthread_self_5=pthread_self();
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    char *return_value_strerror_7;
    return_value_strerror_7=strerror(*return_value___errno_location_6);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) disk mapping failed, %s", return_value_pthread_self_5, (const void *)"cachestat_dump_loop", return_value_strerror_7);

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

  struct cachestat *st = (struct cachestat *)buf;
  printf("#time nblocks ");
  printf("cached_by_ondemand_read ");
  printf("cached_by_ondemand_write ");
  printf("cached_by_bgcopy ");
  printf("cached_ratio  ");
  printf("io_blocks ");
  printf("read_blocks ");
  printf("written_blocks  ");
  printf("io_blocks_per_sec  ");
  printf("cache_hit ");
  printf("cache_miss ");
  printf("cache_hit_ratio ");
  printf("cache_hit_ratio_total  ");
  printf("transferred_blocks ");
  printf("transferred_blocks_per_sec\n");
  unsigned long int io_blocks_prev = (unsigned long int)0;
  unsigned long int cache_hit_prev = (unsigned long int)0;
  unsigned long int cache_miss_prev = (unsigned long int)0;
  unsigned long int transferred_blocks_prev = (unsigned long int)0;
  do
  {
    signed long int now;
    now=time((signed long int *)(void *)0);
    printf("%lu ", now);
    printf("%lu ", st->nblocks);
    printf("%lu ", st->cache_odread);
    printf("%lu ", st->cache_odwrite);
    printf("%lu ", st->cache_bgcopy);
    printf("%lf  ", ((double)(st->cache_odread + st->cache_odwrite + st->cache_bgcopy) * 100.0) / (double)st->nblocks);
    printf("%lu ", st->io_blocks);
    printf("%lu ", st->read_blocks);
    printf("%lu ", st->written_blocks);
    printf("%lf  ", (1.0 * (double)(st->io_blocks - io_blocks_prev)) / (double)interval);
    printf("%lu ", st->cache_hit);
    printf("%lu ", st->cache_miss);
    unsigned long int cache_hit_diff = st->cache_hit - cache_hit_prev;
    unsigned long int cache_miss_diff = st->cache_miss - cache_miss_prev;
    printf("%lf ", (100.0 * (double)cache_hit_diff) / (double)(cache_hit_diff + cache_miss_diff));
    printf("%lf  ", (100.0 * (double)st->cache_hit) / (double)(st->cache_hit + st->cache_miss));
    unsigned long int transferred_blocks = st->cache_miss + st->cache_bgcopy;
    double transferred_blocks_per_sec = (1.0 * (double)(transferred_blocks - transferred_blocks_prev)) / (double)interval;
    printf("%lu ", transferred_blocks);
    printf("%lf\n", transferred_blocks_per_sec);
    io_blocks_prev = st->io_blocks;
    cache_hit_prev = st->cache_hit;
    cache_miss_prev = st->cache_miss;
    transferred_blocks_prev = transferred_blocks;
    fflush(stdout);
    sleep(interval);
  }
  while((_Bool)1);
  munmap_or_abort((void *)buf, (unsigned long int)PAGESIZE);
  close(fd);
}

// cachestat_hit
// file xnbd_cachestat.c line 258
inline void cachestat_hit(void)
{
  ;
}

// cachestat_initialize
// file xnbd_cachestat.c line 259
signed int cachestat_initialize(const char *path, unsigned long int nblocks)
{
  return 0;
}

// cachestat_miss
// file xnbd_cachestat.c line 257
inline void cachestat_miss(void)
{
  ;
}

// cachestat_read_block
// file xnbd_cachestat.c line 255
inline void cachestat_read_block(void)
{
  ;
}

// cachestat_shutdown
// file xnbd_cachestat.c line 260
signed int cachestat_shutdown(void)
{
  return 0;
}

// cachestat_write_block
// file xnbd_cachestat.c line 256
inline void cachestat_write_block(void)
{
  ;
}

// calc_block_index
// file lib/io.h line 49
void calc_block_index(const unsigned int blocksize, const signed long int iofrom, const unsigned long int iolen, unsigned long int *index_start, unsigned long int *index_end)
{
  unsigned long int block_index_start = (unsigned long int)(iofrom / (signed long int)blocksize);
  unsigned long int block_index_end;
  if((iolen + (unsigned long int)iofrom) % (unsigned long int)blocksize == 0ul)
    block_index_end = ((unsigned long int)iofrom + iolen) / (unsigned long int)blocksize - (unsigned long int)1;

  else
    block_index_end = ((unsigned long int)iofrom + iolen) / (unsigned long int)blocksize;
  *index_start = block_index_start;
  *index_end = block_index_end;
}

// check_disksize
// file xnbd_common.c line 160
void check_disksize(char *diskpath, signed long int disksize, _Bool force_cblock)
{
  signed int pgsize;
  pgsize=getpagesize();
  if(!(disksize % 1024l == 0l))
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "disksize %jd is not a multiple of 1024 (nbd's default block size)", disksize);
    while((_Bool)0);

  if(!(disksize % (signed long int)pgsize == 0l))
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "disksize %jd is not a multiple of a page size (%d)", disksize, pgsize);
    while((_Bool)0);

  if(!(disksize % (signed long int)CBLOCKSIZE == 0l))
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "disksize %jd is not a multiple of %d (xnbd's cache block size)", disksize, CBLOCKSIZE);
    while((_Bool)0);
    if(!(force_cblock == (_Bool)0))
      exit(1);

  }

  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "disk %s size %ju B (%ju MB)", diskpath, disksize, (disksize / (signed long int)1024) / (signed long int)1024);
  while((_Bool)0);
}

// check_done
// file net.c line 489
void check_done(signed int ret, signed int errcode)
{
  if(ret == -1)
  {
    if(errcode == 32 || errcode == 104)
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "got RST. abort");
      while((_Bool)0);
      exit(0);
    }

    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "unknown err");
    while((_Bool)0);
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(errcode);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) xmit: %s (%d)", return_value_pthread_self_1, (const void *)"check_done", return_value_strerror_2, errcode);

  __CPROVER_DUMP_L4:
    ;
    goto __CPROVER_DUMP_L4;
  }

  else
    if(ret >= 0)
      goto __CPROVER_DUMP_L8;

  unsigned long int return_value_pthread_self_3;
  return_value_pthread_self_3=pthread_self();
  g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) not reached", return_value_pthread_self_3, (const void *)"check_done");

__CPROVER_DUMP_L7:
  ;
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L8:
  ;
}

// check_fin
// file net.c line 517
signed int check_fin(signed int ret, signed int errcode, unsigned long int len)
{
  if(ret == -1)
  {
    if(errcode == 32 || errcode == 104)
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "got RST. abort");
      while((_Bool)0);
      exit(0);
    }

    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(errcode);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) xmit: %s (%d)", return_value_pthread_self_1, (const void *)"check_fin", return_value_strerror_2, errcode);

  __CPROVER_DUMP_L3:
    ;
    goto __CPROVER_DUMP_L3;
  }

  else
    if(ret == 0)
    {
      if(len >= 1ul)
        return 1;

      else
      {
        unsigned long int return_value_pthread_self_3;
        return_value_pthread_self_3=pthread_self();
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) len must be larger than 0", return_value_pthread_self_3, (const void *)"check_fin");

      __CPROVER_DUMP_L6:
        ;
        goto __CPROVER_DUMP_L6;
      }
    }

    else
      if(ret >= 1)
      {
        if(!(ret >= (signed int)len))
          return 1;

        else
          if(ret == (signed int)len)
            return 0;

          else
          {
            unsigned long int return_value_pthread_self_4;
            return_value_pthread_self_4=pthread_self();
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) len mismatch", return_value_pthread_self_4, (const void *)"check_fin");

          __CPROVER_DUMP_L11:
            ;
            goto __CPROVER_DUMP_L11;
          }
      }

  unsigned long int return_value_pthread_self_5;
  return_value_pthread_self_5=pthread_self();
  g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) not reached", return_value_pthread_self_5, (const void *)"check_fin");

__CPROVER_DUMP_L13:
  ;
  goto __CPROVER_DUMP_L13;
  return -1;
}

// command_available
// file xnbd_wrapper.c line 1034
static _Bool command_available(const char *command)
{
  signed int pid;
  pid=fork();
  if(pid == 0)
  {
    const char * const argv[3l] = { "/usr/bin/which", command, (const char *)(void *)0 };
    about_to_execute(argv);
    close(0);
    signed int output_fd;
    output_fd=open("/dev/null", 01);
    if(!(output_fd == -1))
    {
      dup2(output_fd, 1);
      dup2(output_fd, 2);
    }

    execvp_or_abort(argv);
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) should never get here", return_value_pthread_self_1, (const void *)"command_available");

  __CPROVER_DUMP_L3:
    ;
    goto __CPROVER_DUMP_L3;
    return (_Bool)0;
  }

  signed int status;
  signed int waitpid_res;
  waitpid_res=waitpid(pid, &status, 0);
  if(!(waitpid_res == pid))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) waitpid failed: %m", return_value_pthread_self_2, (const void *)"command_available");

  __CPROVER_DUMP_L6:
    ;
    goto __CPROVER_DUMP_L6;
  }

  /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
  ;
  /* assertion ((((__extension__ (((union { __typeof(status) __in; int __i; }) { .__in = (status) }).__i))) & 0x7f) == 0) */
  assert((((union anonymous){ .__in=status }).__i & 0x7f) == 0);
  return (_Bool)((((union anonymous){ .__in=status }).__i & 0xff00) >> 8 == 0 ? 1 : 0);
}

// compress_iovec_and_send
// file xnbd_target_cow_lzo.c line 737
void compress_iovec_and_send(signed int csock, struct iovec *iov, signed int count)
{
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) lzo support was not compiled", return_value_pthread_self_1, (const void *)"compress_iovec_and_send");

__CPROVER_DUMP_L2:
  ;
  goto __CPROVER_DUMP_L2;
}

// compress_iovec_and_send_advanced
// file xnbd_target_cow_lzo.c line 729
void compress_iovec_and_send_advanced(signed int csock, struct iovec *iov, const unsigned int count, signed int lzo_enabled)
{
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) compression support was not compiled", return_value_pthread_self_1, (const void *)"compress_iovec_and_send_advanced");

__CPROVER_DUMP_L2:
  ;
  goto __CPROVER_DUMP_L2;
}

// copy_disk_data
// file xnbd_wrapper.c line 108
static struct _t_disk_data * copy_disk_data(const struct _t_disk_data *source)
{
  signed int fine = 1;
  struct _t_disk_data *res;
  void *return_value_g_try_malloc_n_1;
  return_value_g_try_malloc_n_1=g_try_malloc_n((unsigned long int)1, sizeof(struct _t_disk_data) /*64ul*/ );
  res = (struct _t_disk_data *)return_value_g_try_malloc_n_1;
  if(res == ((struct _t_disk_data *)NULL))
    fine = 0;

  if(!(fine == 0))
  {
    memset((void *)res, 0, sizeof(struct _t_disk_data) /*64ul*/ );
    res->index = source->index;
  }

  do
    if(!(fine == 0))
    {
      if(!(source->local_exportname == ((char *)NULL)))
      {
        res->local_exportname=g_strdup(source->local_exportname);
        if(res->local_exportname == ((char *)NULL))
          fine = 0;

      }

    }

  while((_Bool)0);
  do
    if(!(fine == 0))
    {
      if(!(source->disk_file_name == ((char *)NULL)))
      {
        res->disk_file_name=g_strdup(source->disk_file_name);
        if(res->disk_file_name == ((char *)NULL))
          fine = 0;

      }

    }

  while((_Bool)0);
  do
    if(!(fine == 0))
    {
      if(!(source->proxy.target_host == ((char *)NULL)))
      {
        res->proxy.target_host=g_strdup(source->proxy.target_host);
        if(res->proxy.target_host == ((char *)NULL))
          fine = 0;

      }

    }

  while((_Bool)0);
  do
    if(!(fine == 0))
    {
      if(!(source->proxy.target_port == ((char *)NULL)))
      {
        res->proxy.target_port=g_strdup(source->proxy.target_port);
        if(res->proxy.target_port == ((char *)NULL))
          fine = 0;

      }

    }

  while((_Bool)0);
  do
    if(!(fine == 0))
    {
      if(!(source->proxy.bitmap_image == ((char *)NULL)))
      {
        res->proxy.bitmap_image=g_strdup(source->proxy.bitmap_image);
        if(res->proxy.bitmap_image == ((char *)NULL))
          fine = 0;

      }

    }

  while((_Bool)0);
  do
    if(!(fine == 0))
    {
      if(!(source->proxy.control_socket_path == ((char *)NULL)))
      {
        res->proxy.control_socket_path=g_strdup(source->proxy.control_socket_path);
        if(res->proxy.control_socket_path == ((char *)NULL))
          fine = 0;

      }

    }

  while((_Bool)0);
  do
    if(!(fine == 0))
    {
      if(!(source->proxy.target_exportname == ((char *)NULL)))
      {
        res->proxy.target_exportname=g_strdup(source->proxy.target_exportname);
        if(res->proxy.target_exportname == ((char *)NULL))
          fine = 0;

      }

    }

  while((_Bool)0);
  if(!(fine == 0))
    return res;

  else
  {
    g_free((void *)res->local_exportname);
    g_free((void *)res->disk_file_name);
    g_free((void *)res->proxy.target_host);
    g_free((void *)res->proxy.target_port);
    g_free((void *)res->proxy.bitmap_image);
    g_free((void *)res->proxy.control_socket_path);
    g_free((void *)res->proxy.target_exportname);
    g_free((void *)res);
    return (struct _t_disk_data *)(void *)0;
  }
}

// count_mgr_threads
// file xnbd_wrapper.c line 595
static signed int count_mgr_threads(signed int val)
{
  signed int ret;
  pthread_mutex_lock(&mutex);
  mgr_threads = mgr_threads + val;
  ret = mgr_threads;
  pthread_mutex_unlock(&mutex);
  return ret;
}

// create_disk_data
// file xnbd_wrapper.c line 174
static struct _t_disk_data * create_disk_data(const char *local_exportname, const char *target_host, const char *target_port, const char *cache_image, const char *bitmap_image, const char *control_socket_path, const char *target_exportname)
{
  /* assertion cache_image */
  assert(cache_image != ((const char *)NULL));
  struct _t_disk_data source;
  memset((void *)&source, 0, sizeof(struct _t_disk_data) /*64ul*/ );
  source.local_exportname = (char *)local_exportname;
  source.disk_file_name = (char *)cache_image;
  source.proxy.target_host = (char *)target_host;
  source.proxy.target_port = (char *)target_port;
  source.proxy.bitmap_image = (char *)bitmap_image;
  source.proxy.control_socket_path = (char *)control_socket_path;
  source.proxy.target_exportname = (char *)target_exportname;
  struct _t_disk_data *return_value_copy_disk_data_1;
  return_value_copy_disk_data_1=copy_disk_data(&source);
  return return_value_copy_disk_data_1;
}

// create_disk_stack
// file xnbd_target_cow_lzo.c line 170
struct disk_stack * create_disk_stack(char *diskpath)
{
  signed int diskfd;
  signed long int disksize;
  diskfd=open(diskpath, 00);
  if(!(diskfd >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 75)
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "enable large file support!");
      while((_Bool)0);

    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open, %s", return_value_pthread_self_2, (const void *)"create_disk_stack", return_value_strerror_4);

  __CPROVER_DUMP_L3:
    ;
    goto __CPROVER_DUMP_L3;
  }

  disksize=get_disksize(diskfd);
  check_disksize(diskpath, disksize, (_Bool)1);
  struct disk_stack *ds;
  void *return_value_g_malloc0_5;
  return_value_g_malloc0_5=g_malloc0(sizeof(struct disk_stack) /*96ul*/ );
  ds = (struct disk_stack *)return_value_g_malloc0_5;
  ds->nlayers = 1;
  ds->disksize = disksize;
  struct disk_image *di;
  void *return_value_g_malloc0_6;
  return_value_g_malloc0_6=g_malloc0(sizeof(struct disk_image) /*40ul*/ );
  di = (struct disk_image *)return_value_g_malloc0_6;
  di->diskfd = diskfd;
  di->path=g_strdup(diskpath);
  unsigned long int nblocks;
  nblocks=get_disk_nblocks(ds->disksize);
  do
  {
    signed long int suffix;
    suffix=random();
    di->bmpath=g_strdup_printf("/dev/shm/xnbd-server-cow-base-%lx.bm", suffix);
    signed int fd;
    fd=open(di->bmpath, 02 | 0100 | 0200, 0600);
    if(!(fd >= 0))
    {
      g_free((void *)di->bmpath);
      continue;
    }

    else
    {
      close(fd);
      break;
    }
  }
  while((_Bool)1);
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "create new base bitmap %s", di->bmpath);
  while((_Bool)0);
  unsigned long int tmp_bmlen;
  unsigned long int *tmp_bm;
  tmp_bm=bitmap_open_file(di->bmpath, nblocks, &tmp_bmlen, 0, 1);
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "bitmap file %s filled by 1", di->bmpath);
  while((_Bool)0);
  memset((void *)tmp_bm, 0xff, tmp_bmlen);
  bitmap_close_file(tmp_bm, tmp_bmlen);
  di->bm=bitmap_open_file(di->bmpath, nblocks, &di->bmlen, 1, 0);
  unlink(di->bmpath);
  ds->image[(signed long int)0] = di;
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "disk_stack[0] %s %s", di->path, di->bmpath);
  while((_Bool)0);
  return ds;
}

// create_disk_stack_io
// file xnbd_target_cow_lzo.c line 401
static struct disk_stack_io * create_disk_stack_io(struct disk_stack *ds)
{
  struct disk_stack_io *io;
  void *return_value_g_malloc0_1;
  return_value_g_malloc0_1=g_malloc0(sizeof(struct disk_stack_io) /*112ul*/ );
  io = (struct disk_stack_io *)return_value_g_malloc0_1;
  io->ds = ds;
  return io;
}

// custom_log_handler
// file lib/common.h line 91
void custom_log_handler(const char *log_domain, enum anonymous_2 log_level, const char *message, void *data)
{
  struct custom_log_handler_params *params = (struct custom_log_handler_params *)data;
  struct _GString *gstring;
  gstring=g_string_new((const char *)(void *)0);
  char *header;
  header=getenv("LOG_HEADER");
  if(!(header == ((char *)NULL)))
    g_string_append(gstring, header);

  char name[20l];
  signed int ret;
  ret=prctl(16, (unsigned long int)name);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) PR_GET_NAME, %m", return_value_pthread_self_1, (const void *)"custom_log_handler");

  __CPROVER_DUMP_L3:
    ;
    goto __CPROVER_DUMP_L3;
  }

  g_string_append(gstring, name);
  g_string_append(gstring, "(");
  signed int pid;
  pid=getpid();
  signed int tid;
  signed long int return_value_syscall_2;
  return_value_syscall_2=syscall((signed long int)186);
  tid = (signed int)return_value_syscall_2;
  if(pid == tid)
    g_string_append_printf(gstring, "%d", pid);

  else
    g_string_append_printf(gstring, "%d.%d", pid, tid);
  g_string_append(gstring, ") ");
  if(!(log_domain == ((const char *)NULL)))
  {
    g_string_append(gstring, log_domain);
    g_string_append(gstring, ">");
  }

  switch((signed int)log_level & G_LOG_LEVEL_MASK)
  {
    case G_LOG_LEVEL_ERROR:
    {
      g_string_append(gstring, "ERR");
      break;
    }
    case G_LOG_LEVEL_CRITICAL:
    {
      g_string_append(gstring, "CRIT");
      break;
    }
    case G_LOG_LEVEL_WARNING:
    {
      g_string_append(gstring, "WARN");
      break;
    }
    case G_LOG_LEVEL_MESSAGE:
    {
      g_string_append(gstring, "msg");
      break;
    }
    case G_LOG_LEVEL_INFO:
    {
      g_string_append(gstring, "info");
      break;
    }
    case G_LOG_LEVEL_DEBUG:
    {
      g_string_append(gstring, "dbg");
      break;
    }
    default:
      g_string_append(gstring, "log");
  }
  if(!((G_LOG_FLAG_RECURSION & (signed int)log_level) == 0))
    g_string_append(gstring, " (recursed)");

  g_string_append(gstring, ": ");
  if(!(message == ((const char *)NULL)))
    g_string_append(gstring, message);

  else
    g_string_append(gstring, "(NULL) message");
  signed int is_fatal = (signed int)(((signed int)log_level & G_LOG_FLAG_FATAL) != 0);
  if(!(is_fatal == 0))
    g_string_append(gstring, "\naborting...\n");

  else
    g_string_append(gstring, "\n");
  signed int return_value_syslog_level_3;
  if(!(params == ((struct custom_log_handler_params *)NULL)))
  {
    if(!(params->use_syslog == 0))
    {
      return_value_syslog_level_3=syslog_level((signed int)log_level);
      syslog(return_value_syslog_level_3, "%s", gstring->str);
    }

    if(!(params->use_fd == 0))
    {
      do
        if(params->fd == -1)
          g_assertion_message_expr((char *)0, "common.c", 188, (const char *)"custom_log_handler", "params->fd != -1");

      while((_Bool)0);
      write(params->fd, (const void *)gstring->str, gstring->len);
    }

  }

  else
    write(2, (const void *)gstring->str, gstring->len);
  g_string_free(gstring, (signed int)!(0 != 0));
}

// decode_percent_encoding
// file xnbd_wrapper.c line 484
static void decode_percent_encoding(char *text)
{
  _Bool tmp_if_expr_1;
  if(!(text == ((char *)NULL)))
  {
    const char *read_head = text;
    char *write_head = text;
    while(!(*read_head == 0))
    {
      if(!((signed int)*read_head == 37))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = !(read_head[(signed long int)1] != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        do
        {
          if(!(write_head >= read_head))
            write_head[(signed long int)0] = read_head[(signed long int)0];

          read_head = read_head + (signed long int)1;
          write_head = write_head + (signed long int)1;
        }
        while((_Bool)0);

      else
      {
        signed int higher;
        higher=hexdig_char_to_int(read_head[(signed long int)1]);
        if(higher == -1)
          do
          {
            if(!(write_head >= read_head))
              write_head[(signed long int)0] = read_head[(signed long int)0];

            read_head = read_head + (signed long int)1;
            write_head = write_head + (signed long int)1;
          }
          while((_Bool)0);

        else
          if(read_head[2l] == 0)
            do
            {
              if(!(write_head >= read_head))
              {
                write_head[(signed long int)0] = read_head[(signed long int)0];
                write_head[(signed long int)1] = read_head[(signed long int)1];
              }

              read_head = read_head + (signed long int)2;
              write_head = write_head + (signed long int)2;
            }
            while((_Bool)0);

          else
          {
            signed int lower;
            lower=hexdig_char_to_int(read_head[(signed long int)2]);
            if(lower == -1)
              do
              {
                if(!(write_head >= read_head))
                {
                  write_head[(signed long int)0] = read_head[(signed long int)0];
                  write_head[(signed long int)1] = read_head[(signed long int)1];
                }

                read_head = read_head + (signed long int)2;
                write_head = write_head + (signed long int)2;
              }
              while((_Bool)0);

            else
            {
              /* assertion (0 <= higher) && (higher < 16) */
              assert(0 <= higher && higher < 16);
              /* assertion (0 <= lower) && (lower < 16) */
              assert(0 <= lower && lower < 16);
              write_head[(signed long int)0] = (char)(16 * higher + lower);
              read_head = read_head + (signed long int)3;
              write_head = write_head + (signed long int)1;
            }
          }
      }
    }
    if(!(write_head >= read_head))
      write_head[(signed long int)0] = (char)0;

  }

}

// del_diskimg_by_exportname
// file xnbd_wrapper.c line 263
static signed int del_diskimg_by_exportname(const char *local_exportname)
{
  pthread_mutex_lock(&mutex);
  unsigned int removed_count;
  removed_count=g_hash_table_foreach_remove(p_disk_dict, (signed int (*)(void *, void *, void *))find_by_exportname, (void *)local_exportname);
  pthread_mutex_unlock(&mutex);
  return removed_count > (unsigned int)0 ? 0 : 1;
}

// del_diskimg_by_file
// file xnbd_wrapper.c line 254
static signed int del_diskimg_by_file(const char *filename)
{
  pthread_mutex_lock(&mutex);
  unsigned int removed_count;
  removed_count=g_hash_table_foreach_remove(p_disk_dict, (signed int (*)(void *, void *, void *))find_by_file, (void *)filename);
  pthread_mutex_unlock(&mutex);
  return removed_count > (unsigned int)0 ? 0 : 1;
}

// del_diskimg_by_index
// file xnbd_wrapper.c line 240
static signed int del_diskimg_by_index(signed int num)
{
  unsigned int removed_count = (unsigned int)0;
  num = num - 1;
  if(num >= 0)
  {
    pthread_mutex_lock(&mutex);
    removed_count=g_hash_table_foreach_remove(p_disk_dict, (signed int (*)(void *, void *, void *))find_by_index, (void *)(unsigned long int)(unsigned int)num);
    pthread_mutex_unlock(&mutex);
  }

  return removed_count > (unsigned int)0 ? 0 : 1;
}

// destroy_disk_stack
// file xnbd_target_cow_lzo.c line 255
void destroy_disk_stack(struct disk_stack *ds)
{
  signed int i = 0;
  for( ; !(i >= ds->nlayers); i = i + 1)
  {
    struct disk_image *di = ds->image[(signed long int)i];
    close(di->diskfd);
    if(!(di->bm == ((unsigned long int *)NULL)))
    {
      signed int ret;
      ret=msync((void *)di->bm, di->bmlen, 4);
      if(!(ret >= 0))
      {
        unsigned long int return_value_pthread_self_1;
        return_value_pthread_self_1=pthread_self();
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) msync", return_value_pthread_self_1, (const void *)"destroy_disk_stack");

      __CPROVER_DUMP_L3:
        ;
        goto __CPROVER_DUMP_L3;
      }

      munmap_or_abort((void *)di->bm, di->bmlen);
    }

    g_free((void *)di->path);
    g_free((void *)di->bmpath);
    g_free((void *)di);
  }
  g_free((void *)ds);
}

// destroy_value
// file xnbd_wrapper.c line 88
static void destroy_value(struct _t_disk_data *p_disk_data)
{
  g_free((void *)p_disk_data->local_exportname);
  g_free((void *)p_disk_data->disk_file_name);
  g_free((void *)p_disk_data->proxy.target_host);
  g_free((void *)p_disk_data->proxy.target_port);
  g_free((void *)p_disk_data->proxy.bitmap_image);
  g_free((void *)p_disk_data->proxy.control_socket_path);
  g_free((void *)p_disk_data->proxy.target_exportname);
  g_free((void *)p_disk_data);
}

// disk_stack_add_image
// file xnbd_target_cow_lzo.c line 279
void disk_stack_add_image(struct disk_stack *ds, char *diskpath, signed int newfile)
{
  signed int diskfd;
  signed long int disksize;
  if(ds->nlayers == 10)
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) no space", return_value_pthread_self_1, (const void *)"disk_stack_add_image");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  diskfd=open(diskpath, 02 | 0100, 0644);
  if(!(diskfd >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 75)
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "enable large file support!");
      while((_Bool)0);

    unsigned long int return_value_pthread_self_3;
    return_value_pthread_self_3=pthread_self();
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open, %s", return_value_pthread_self_3, (const void *)"disk_stack_add_image", return_value_strerror_5);

  __CPROVER_DUMP_L6:
    ;
    goto __CPROVER_DUMP_L6;
  }

  disksize=get_disksize(diskfd);
  if(!(disksize == ds->disksize))
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "ftruncate %s (%ju -> %ju)", diskpath, disksize, ds->disksize);
    while((_Bool)0);
    signed int ret;
    ret=ftruncate(diskfd, ds->disksize);
    if(!(ret >= 0))
    {
      unsigned long int return_value_pthread_self_6;
      return_value_pthread_self_6=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) ftruncate", return_value_pthread_self_6, (const void *)"disk_stack_add_image");

    __CPROVER_DUMP_L10:
      ;
      goto __CPROVER_DUMP_L10;
    }

  }

  struct disk_image *di;
  void *return_value_g_malloc0_7;
  return_value_g_malloc0_7=g_malloc0(sizeof(struct disk_image) /*40ul*/ );
  di = (struct disk_image *)return_value_g_malloc0_7;
  di->diskfd = diskfd;
  di->path=g_strdup(diskpath);
  di->bmpath=g_strdup_printf("%s.bm", diskpath);
  unsigned long int return_value_get_disk_nblocks_8;
  unsigned long int return_value_get_disk_nblocks_9;
  if(!(newfile == 0))
  {
    return_value_get_disk_nblocks_8=get_disk_nblocks(ds->disksize);
    di->bm=bitmap_open_file(di->bmpath, return_value_get_disk_nblocks_8, &di->bmlen, 0, 1);
  }

  else
  {
    return_value_get_disk_nblocks_9=get_disk_nblocks(ds->disksize);
    di->bm=bitmap_open_file(di->bmpath, return_value_get_disk_nblocks_9, &di->bmlen, 1, 0);
  }
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "disk_stack[%d] %s %s", ds->nlayers, di->path, di->bmpath);
  while((_Bool)0);
  ds->image[(signed long int)ds->nlayers] = di;
  ds->nlayers = ds->nlayers + 1;
}

// disk_stack_mmap
// file xnbd_target_cow_lzo.c line 418
struct disk_stack_io * disk_stack_mmap(struct disk_stack *ds, signed long int iofrom, unsigned long int iolen, signed int reading)
{
  unsigned long int index_start;
  unsigned long int index_end;
  get_io_range_index(iofrom, iolen, &index_start, &index_end);

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;
  signed long int mapping_start = (signed long int)index_start * (signed long int)CBLOCKSIZE;
  unsigned long int mapping_length = ((index_end - index_start) + (unsigned long int)1) * (unsigned long int)CBLOCKSIZE;

__CPROVER_DUMP_L3:
  ;
  struct disk_stack_io *io;
  io=create_disk_stack_io(ds);
  signed int disk_stack_mmap__1__4__i = 0;
  for( ; !(disk_stack_mmap__1__4__i >= ds->nlayers); disk_stack_mmap__1__4__i = disk_stack_mmap__1__4__i + 1)
  {
    struct disk_image *di = ds->image[(signed long int)disk_stack_mmap__1__4__i];
    signed int flags = 0x1;
    if(disk_stack_mmap__1__4__i == ds->nlayers + -1)
      flags = flags | 0x2;

    void *return_value_mmap_1;
    return_value_mmap_1=mmap((void *)0, mapping_length, flags, 0x01, di->diskfd, mapping_start);
    io->bufs[(signed long int)disk_stack_mmap__1__4__i] = (char *)return_value_mmap_1;
    if(io->bufs[(signed long int)disk_stack_mmap__1__4__i] == (char *)-1)
    {
      unsigned long int return_value_pthread_self_2;
      return_value_pthread_self_2=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) mmap, %m", return_value_pthread_self_2, (const void *)"disk_stack_mmap");

    __CPROVER_DUMP_L7:
      ;
      goto __CPROVER_DUMP_L7;
    }

    io->buflen = mapping_length;

  __CPROVER_DUMP_L9:
    ;
  }
  struct iovec *iov = (struct iovec *)(void *)0;
  unsigned int iov_size = (unsigned int)0;
  signed int return_value_bitmap_test_7;
  signed int return_value_bitmap_test_8;
  if(!(reading == 0))
  {
    do
      if(1ul + index_end + -index_start >= 4294967296ul)
        g_assertion_message_expr((char *)0, "xnbd_target_cow_lzo.c", 464, (const char *)"disk_stack_mmap", "(index_end - index_start + 1) <= UINT32_MAX");

    while((_Bool)0);
    iov_size = (unsigned int)((index_end - index_start) + (unsigned long int)1);
    void *return_value_g_malloc0_n_3;
    return_value_g_malloc0_n_3=g_malloc0_n((unsigned long int)iov_size, sizeof(struct iovec) /*16ul*/ );
    iov = (struct iovec *)return_value_g_malloc0_n_3;
    unsigned long int index = index_start;
    for( ; index_end >= index; index = index + 1ul)
    {
      unsigned long int iofrom_inbuf = (unsigned long int)0;
      unsigned long int iolen_inbuf = (unsigned long int)0;
      iofrom_inbuf = (unsigned long int)((signed long int)index * (signed long int)CBLOCKSIZE - mapping_start);
      iolen_inbuf = (unsigned long int)CBLOCKSIZE;
      if(index_start == index_end)
      {
        iofrom_inbuf = (unsigned long int)(iofrom - mapping_start);
        iolen_inbuf = iolen;
      }

      else
        if(index == index_start)
        {
          iofrom_inbuf = (unsigned long int)(iofrom - mapping_start);
          iolen_inbuf = (unsigned long int)CBLOCKSIZE - iofrom_inbuf;
        }

        else
          if(index == index_end)
          {
            iofrom_inbuf = (unsigned long int)((signed long int)index * (signed long int)CBLOCKSIZE - mapping_start);
            iolen_inbuf = (unsigned long int)(((unsigned long int)iofrom + iolen) - index * (unsigned long int)CBLOCKSIZE);
          }


    __CPROVER_DUMP_L17:
      ;
      signed int found = 0;
      signed int i = ds->nlayers - 1;
      for( ; i >= 0; i = i - 1)
      {
        struct disk_image *disk_stack_mmap__1__5__2__1__4__1__di = ds->image[(signed long int)i];
        signed int return_value_bitmap_test_4;
        return_value_bitmap_test_4=bitmap_test(disk_stack_mmap__1__5__2__1__4__1__di->bm, index);
        if(!(return_value_bitmap_test_4 == 0))
        {

        __CPROVER_DUMP_L19:
          ;
          (iov + (signed long int)(index - index_start))->iov_base = (void *)(io->bufs[(signed long int)i] + (signed long int)iofrom_inbuf);
          (iov + (signed long int)(index - index_start))->iov_len = iolen_inbuf;
          found = 1;
          break;
        }

      }
      if(found == 0)
      {
        unsigned long int return_value_pthread_self_5;
        return_value_pthread_self_5=pthread_self();
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bug", return_value_pthread_self_5, (const void *)"disk_stack_mmap");

      __CPROVER_DUMP_L23:
        ;
        goto __CPROVER_DUMP_L23;
      }

    }
  }

  else
  {
    iov_size = (unsigned int)1;
    void *return_value_g_malloc0_6;
    return_value_g_malloc0_6=g_malloc0(sizeof(struct iovec) /*16ul*/ );
    iov = (struct iovec *)return_value_g_malloc0_6;
    unsigned long int disk_stack_mmap__1__6__iofrom_inbuf = (unsigned long int)(iofrom - mapping_start);
    (iov + (signed long int)0)->iov_base = (void *)(io->bufs[(signed long int)(ds->nlayers - 1)] + (signed long int)disk_stack_mmap__1__6__iofrom_inbuf);
    (iov + (signed long int)0)->iov_len = iolen;
    signed int get_start_block = 0;
    signed int get_end_block = 0;
    if(!(iofrom % (signed long int)CBLOCKSIZE == 0l))
    {
      return_value_bitmap_test_7=bitmap_test(ds->image[(signed long int)(ds->nlayers - 1)]->bm, index_start);
      if(return_value_bitmap_test_7 == 0)
        get_start_block = 1;

    }

    if(!((iolen + (unsigned long int)iofrom) % (unsigned long int)CBLOCKSIZE == 0ul))
    {
      if(get_start_block == 0 && index_end == index_start || !(index_start >= index_end))
      {
        return_value_bitmap_test_8=bitmap_test(ds->image[(signed long int)(ds->nlayers - 1)]->bm, index_end);
        if(return_value_bitmap_test_8 == 0)
          get_end_block = 1;

      }

    }

    if(!(get_start_block == 0))
      update_block_with_found(ds, io, index_start, index_start);

    if(!(get_end_block == 0))
      update_block_with_found(ds, io, index_end, index_start);

    unsigned long int disk_stack_mmap__1__6__2__index = index_start;
    for( ; index_end >= disk_stack_mmap__1__6__2__index; disk_stack_mmap__1__6__2__index = disk_stack_mmap__1__6__2__index + 1ul)
      bitmap_on(ds->image[(signed long int)(ds->nlayers - 1)]->bm, disk_stack_mmap__1__6__2__index);
  }
  unsigned int disk_stack_mmap__1__7__i = (unsigned int)0;
  for( ; !(disk_stack_mmap__1__7__i >= iov_size); disk_stack_mmap__1__7__i = disk_stack_mmap__1__7__i + 1u)

    __CPROVER_DUMP_L36:
      ;
  io->iov = iov;
  io->iov_size = iov_size;
  return io;
}

// dump_buffer
// file io.c line 104
void dump_buffer(const char *buff, unsigned long int bufflen)
{
  dump_buffer_main(buff, bufflen, 0);
}

// dump_buffer_all
// file io.c line 99
void dump_buffer_all(const char *buff, unsigned long int bufflen)
{
  dump_buffer_main(buff, bufflen, 1);
}

// dump_buffer_main
// file io.c line 70
static void dump_buffer_main(const char *buff, unsigned long int bufflen, signed int all)
{
  unsigned int i;
  if(all == 0 && bufflen >= 129ul)
  {
    i = (unsigned int)0;
    for( ; !(i >= 128u); i = i + 1u)
    {
      if(i % 24u == 0u)
        printf("   ");

      printf("%02x ", (unsigned char)buff[(signed long int)i]);
      if(i % 4u == 3u)
        printf("| ");

      if(i % 24u == 23u)
        printf("\n");

    }
    printf("... (%zu byte)\n", bufflen);
  }

  else
  {
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= bufflen); i = i + 1u)
    {
      if(i % 24u == 0u)
        printf("%4d|| ", i);

      printf("%02x ", (unsigned char)buff[(signed long int)i]);
      if(i % 4u == 3u)
        printf("| ");

      if(i % 24u == 23u)
        printf("\n");

    }
    printf("\n");
  }
}

// ensure_command_available
// file xnbd_wrapper.c line 1073
static void ensure_command_available(const char *command)
{
  /* assertion command */
  assert(command != ((const char *)NULL));
  _Bool return_value_command_available_6;
  return_value_command_available_6=command_available(command);
  if(return_value_command_available_6 == (_Bool)0)
  {
    char *return_value_strchr_5;
    return_value_strchr_5=strchr(command, 47);
    if(!(return_value_strchr_5 == ((char *)NULL)))
    {
      struct stat buf;
      signed int statt_res;
      statt_res=stat(command, &buf);
      if(statt_res == 1)
      {
        unsigned long int return_value_pthread_self_1;
        return_value_pthread_self_1=pthread_self();
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) Cannot access file \"%s\": %m", return_value_pthread_self_1, (const void *)"ensure_command_available", command);

      __CPROVER_DUMP_L2:
        ;
        goto __CPROVER_DUMP_L2;
      }

      signed int return_value_access_3;
      return_value_access_3=access(command, 1);
      if(!(return_value_access_3 == 0))
      {
        unsigned long int return_value_pthread_self_2;
        return_value_pthread_self_2=pthread_self();
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) Will not be able to execute file \"%s\" later: %m", return_value_pthread_self_2, (const void *)"ensure_command_available", command);

      __CPROVER_DUMP_L5:
        ;
        goto __CPROVER_DUMP_L5;
      }

    }

    else
    {
      unsigned long int return_value_pthread_self_4;
      return_value_pthread_self_4=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) Command \"%s\" not found", return_value_pthread_self_4, (const void *)"ensure_command_available", command);

    __CPROVER_DUMP_L8:
      ;
      goto __CPROVER_DUMP_L8;
    }
  }

}

// exec_xnbd_server
// file xnbd_wrapper.c line 983
static void exec_xnbd_server(struct exec_params *params, char *fd_num, const struct _t_disk_data *disk_data)
{
  char *args[18l];
  signed int i = 0;
  args[(signed long int)i] = (char *)params->binpath;
  if(!(disk_data->proxy.target_host == ((char *)NULL)))
  {
    i = i + 1;
    args[(signed long int)i] = (char *)"--proxy";
  }

  else
  {
    i = i + 1;
    args[(signed long int)i] = (char *)params->target_mode;
  }
  if(!(params->readonly == 0))
  {
    i = i + 1;
    args[(signed long int)i] = (char *)"--readonly";
  }

  if(!(params->syslog == 0))
  {
    i = i + 1;
    args[(signed long int)i] = (char *)"--syslog";
  }

  i = i + 1;
  args[(signed long int)i] = (char *)"--connected-fd";
  i = i + 1;
  args[(signed long int)i] = fd_num;
  if(!(disk_data->proxy.target_host == ((char *)NULL)))
  {
    if(!(params->proxy_max_que_size_str == ((const char *)NULL)))
    {
      i = i + 1;
      args[(signed long int)i] = (char *)"--max-queue-size";
      i = i + 1;
      args[(signed long int)i] = (char *)params->proxy_max_que_size_str;
    }

    if(!(params->proxy_max_buf_size_str == ((const char *)NULL)))
    {
      i = i + 1;
      args[(signed long int)i] = (char *)"--max-buf-size";
      i = i + 1;
      args[(signed long int)i] = (char *)params->proxy_max_buf_size_str;
    }

    if(!(disk_data->proxy.target_exportname == ((char *)NULL)))
    {
      i = i + 1;
      args[(signed long int)i] = (char *)"--target-exportname";
      i = i + 1;
      args[(signed long int)i] = disk_data->proxy.target_exportname;
    }

    i = i + 1;
    args[(signed long int)i] = disk_data->proxy.target_host;
    i = i + 1;
    args[(signed long int)i] = disk_data->proxy.target_port;
    i = i + 1;
    args[(signed long int)i] = disk_data->disk_file_name;
    i = i + 1;
    args[(signed long int)i] = disk_data->proxy.bitmap_image;
    i = i + 1;
    args[(signed long int)i] = disk_data->proxy.control_socket_path;
  }

  else
  {
    i = i + 1;
    args[(signed long int)i] = disk_data->disk_file_name;
  }
  i = i + 1;
  args[(signed long int)i] = (char *)(void *)0;
  about_to_execute((const char * const *)args);
  execvp_or_abort((const char * const *)args);
}

// execvp_or_abort
// file xnbd_wrapper.c line 166
static void execvp_or_abort(const char * const *argv)
{
  execvp(argv[(signed long int)0], (char **)argv);
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "exec failed");
  while((_Bool)0);
  _exit(1);
}

// extract_decode_check_usage
// file xnbd_wrapper.c line 531
static signed int extract_decode_check_usage(char *buf, char ***p_argv, unsigned int *p_argc, unsigned int argc_min, unsigned int argc_max)
{
  unsigned long int buf_len;
  buf_len=strlen(buf);
  if(buf_len >= 1ul)
  {
    if((signed int)buf[-1l + (signed long int)buf_len] == 10)
      buf[(signed long int)(buf_len - (unsigned long int)1)] = (char)0;

  }

  char **argv;
  argv=g_strsplit(buf, " ", (signed int)(argc_max + (unsigned int)1));
  if(argv == ((char ** const )NULL))
  {
    *p_argv = (char **)(void *)0;
    *p_argc = (unsigned int)0;
    return 1;
  }

  else
  {
    unsigned int argc = (unsigned int)0;
    for( ; !(argv[(signed long int)argc] == ((char *)NULL)); argc = argc + 1u)
      ;
    if(!(argc >= argc_min) || !(argc_max >= argc))
    {
      g_strfreev(argv);
      *p_argv = (char **)(void *)0;
      *p_argc = (unsigned int)0;
      return 2;
    }

    else
    {
      unsigned int i = (unsigned int)1;
      for( ; !(i >= argc); i = i + 1u)
        decode_percent_encoding(argv[(signed long int)i]);
      *p_argv = argv;
      *p_argc = argc;
      return 0;
    }
  }
}

// find_by_exportname
// file xnbd_wrapper.c line 209
static signed int find_by_exportname(const char *key, const struct _t_disk_data *p_disk_data, const char *local_exportname)
{
  (void)key;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(p_disk_data->local_exportname, local_exportname);
  return (signed int)(return_value_strcmp_1 == 0);
}

// find_by_file
// file xnbd_wrapper.c line 203
static signed int find_by_file(const char *key, const struct _t_disk_data *p_disk_data, const char *filename)
{
  (void)key;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(p_disk_data->disk_file_name, filename);
  return (signed int)(return_value_strcmp_1 == 0);
}

// find_by_index
// file xnbd_wrapper.c line 196
static signed int find_by_index(const char *key, const struct _t_disk_data *p_disk_data, const void *user_data)
{
  (void)key;
  const unsigned int index_at_addition_time = (unsigned int)(unsigned long int)user_data;
  return (signed int)(p_disk_data->index == index_at_addition_time);
}

// find_smallest_index_iterator
// file xnbd_wrapper.c line 344
static void find_smallest_index_iterator(void *key, const struct _t_disk_data *p_disk_data, struct _t_listing_state *p_listing_state)
{
  (void)key;
  if(!(p_disk_data->index >= p_listing_state->index_to_print))
    p_listing_state->index_to_print = p_disk_data->index;

}

// fork_or_abort
// file lib/io.h line 45
signed int fork_or_abort(void)
{
  signed int pid;
  pid=fork();
  if(!(pid >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) fork() %m", return_value_pthread_self_1, (const void *)"fork_or_abort");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  return pid;
}

// forwarder_rx_thread_main
// file xnbd_proxy.h line 135
void * forwarder_rx_thread_main(void *arg)
{
  struct xnbd_proxy *proxy = (struct xnbd_proxy *)arg;
  set_process_name("proxy_fwd_rx");
  receiving_failed = 0;
  block_all_signals();
  do
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "create forwarder_rx thread %lu", return_value_pthread_self_1);
  }
  while((_Bool)0);
  do
  {
    signed int ret;
    ret=forwarder_rx_thread_mainloop(proxy);
    if(!(ret >= 0))
      break;

  }
  while((_Bool)1);
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "bye forwarder_rx thread");
  while((_Bool)0);
  return (void *)0;
}

// forwarder_rx_thread_mainloop
// file xnbd_proxy_forwarder.c line 295
signed int forwarder_rx_thread_mainloop(struct xnbd_proxy *proxy)
{
  struct xnbd_info *xnbd = proxy->xnbd;
  struct proxy_priv *priv;
  signed int ret;

__CPROVER_DUMP_L1:
  ;
  void *return_value_g_async_queue_pop_1;
  return_value_g_async_queue_pop_1=g_async_queue_pop(proxy->fwd_rx_queue);
  priv = (struct proxy_priv *)return_value_g_async_queue_pop_1;

__CPROVER_DUMP_L2:
  ;
  proxy_priv_dump(priv);
  char *mmaped_buf;
  unsigned long int mmaped_len;
  signed long int mmaped_offset;
  char *iobuf;
  void *return_value_mmap_iorange_2;
  if(priv == &priv_stop_forwarder)
    return -1;

  else
    if(priv->need_exit == 0)
    {
      mmaped_buf = (char *)(void *)0;
      mmaped_len = (unsigned long int)0;
      mmaped_offset = (signed long int)0;
      iobuf = (char *)(void *)0;
      return_value_mmap_iorange_2=mmap_iorange(xnbd->disksize, (const _Bool)0, proxy->cachefd, priv->iofrom, priv->iolen, &mmaped_buf, &mmaped_len, &mmaped_offset);
      iobuf = (char *)return_value_mmap_iorange_2;

    __CPROVER_DUMP_L4:
      ;

    __CPROVER_DUMP_L5:
      ;
      signed int i = 0;
      for( ; !(i >= priv->nreq); i = i + 1)
      {

      __CPROVER_DUMP_L7:
        ;
        signed long int block_iofrom = priv->req[(signed long int)i].bindex_iofrom * (signed long int)CBLOCKSIZE;
        unsigned long int block_iolen = priv->req[(signed long int)i].bindex_iolen * (unsigned long int)CBLOCKSIZE;
        char *iobuf_partial = (char *)(void *)0;
        iobuf_partial = mmaped_buf + (block_iofrom - mmaped_offset);

      __CPROVER_DUMP_L8:
        ;
        ret=nbd_client_recv_read_reply(proxy->remotefd, iobuf_partial, block_iolen);
        if(!(ret >= 0))
        {
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "forwarder: receiving a read reply failed, seqnum %lu", priv->seqnum);
          while((_Bool)0);
          receiving_failed = 1;
          break;
        }

      }
      if(!(receiving_failed == 0))
        priv->need_retry = 1;

      if(priv->need_retry == 0)
      {
        if(priv->iotype == 0u)
          memcpy((void *)priv->read_buff, (const void *)iobuf, priv->iolen);

        else
          if(priv->iotype == 1u)
            memcpy((void *)iobuf, (const void *)priv->write_buff, priv->iolen);

      }

      munmap_or_abort((void *)mmaped_buf, mmaped_len);
      if(priv->need_retry == 0)
        goto got_stop_session;

      g_async_queue_push(proxy->fwd_retry_queue, (void *)priv);
      return 0;
    }

    else
    {
      do

        got_stop_session:
          ;
      while((_Bool)0);
      g_async_queue_push(priv->tx_queue, (void *)priv);

    __CPROVER_DUMP_L16:
      ;
      return 0;
    }
}

// forwarder_tx_thread_main
// file xnbd_proxy.h line 136
void * forwarder_tx_thread_main(void *arg)
{
  struct xnbd_proxy *proxy = (struct xnbd_proxy *)arg;
  signed int sending_failed = 0;
  set_process_name("proxy_fwd_tx");
  block_all_signals();
  do
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "create forwarder_tx thread %lu", return_value_pthread_self_1);
  }
  while((_Bool)0);
  _Bool tmp_if_expr_3;
  do
  {
    struct proxy_priv *priv;
    void *return_value_g_async_queue_pop_2;
    return_value_g_async_queue_pop_2=g_async_queue_pop(proxy->fwd_tx_queue);
    priv = (struct proxy_priv *)return_value_g_async_queue_pop_2;

  __CPROVER_DUMP_L3:
    ;
    if(priv == &priv_stop_forwarder)
    {
      g_async_queue_push(proxy->fwd_rx_queue, (void *)priv);
      break;
    }

    if(!(priv->need_exit == 0))
      g_async_queue_push(proxy->fwd_rx_queue, (void *)priv);

    else
    {
      if(priv->prepare_done == 0)
      {
        if(priv->iotype == 1u)
          prepare_write_priv(proxy, priv);

        else
        {
          if(priv->iotype == 0u)
            tmp_if_expr_3 = (_Bool)1;

          else
            tmp_if_expr_3 = priv->iotype == (unsigned int)3 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_3)
            prepare_read_priv(proxy, priv);

        }
        priv->seqnum = fwd_counter;
        fwd_counter = fwd_counter + (unsigned long int)1;
        priv->prepare_done = 1;
      }

      signed int i = 0;
      for( ; !(i >= priv->nreq); i = i + 1)
      {
        signed long int iofrom = (signed long int)priv->req[(signed long int)i].bindex_iofrom * (signed long int)CBLOCKSIZE;
        unsigned long int length = priv->req[(signed long int)i].bindex_iolen * (unsigned long int)CBLOCKSIZE;
        signed int ret;
        ret=nbd_client_send_read_request(proxy->remotefd, iofrom, length);
        if(!(ret >= 0))
        {
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "sending read request failed, seqnum %lu", priv->seqnum);
          while((_Bool)0);
          sending_failed = 1;
          break;
        }

      }
      if(!(sending_failed == 0))
        priv->need_retry = 1;

      g_async_queue_push(proxy->fwd_rx_queue, (void *)priv);
    }
  }
  while((_Bool)1);
  do
  {

  out_of_loop:
    ;
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "bye forwarder_tx thread");
  }
  while((_Bool)0);
  return (void *)0;
}

// free_disk_stack_io
// file xnbd_target_cow_lzo.c line 409
void free_disk_stack_io(struct disk_stack_io *io)
{
  signed int i = 0;
  for( ; !(i >= io->ds->nlayers); i = i + 1)
    munmap_or_abort((void *)io->bufs[(signed long int)i], io->buflen);
  g_free((void *)io->iov);
  g_free((void *)io);
}

// g_async_queue_push_unshift
// file xnbd_proxy.c line 529
static void g_async_queue_push_unshift(struct _GAsyncQueue *queue, void *data)
{
  g_async_queue_push_sorted(queue, data, unshift_func, (void *)0);
}

// get_disk_data_for
// file xnbd_wrapper.c line 272
static struct _t_disk_data * get_disk_data_for(const char *local_exportname)
{
  struct _t_disk_data *res = (struct _t_disk_data *)(void *)0;
  pthread_mutex_lock(&mutex);
  const struct _t_disk_data *source;
  void *return_value_g_hash_table_lookup_1;
  return_value_g_hash_table_lookup_1=g_hash_table_lookup(p_disk_dict, (const void *)local_exportname);
  source = (struct _t_disk_data *)return_value_g_hash_table_lookup_1;
  if(!(source == ((const struct _t_disk_data *)NULL)))
    res=copy_disk_data(source);

  pthread_mutex_unlock(&mutex);
  return res;
}

// get_disk_nblocks
// file xnbd_common.c line 183
unsigned long int get_disk_nblocks(signed long int disksize)
{
  if(!(disksize % (signed long int)CBLOCKSIZE == 0l))
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "disksize is not a multiple of CBLOCKSIZE");
    while((_Bool)0);

  signed long int nblocks64 = disksize / (signed long int)CBLOCKSIZE + (signed long int)(disksize % (signed long int)CBLOCKSIZE != 0l ? 1U : 0U);
  return (unsigned long int)nblocks64;
}

// get_disksize
// file lib/io.h line 47
signed long int get_disksize(signed int fd)
{
  struct stat st;
  signed long int disksize = (signed long int)0;
  signed int ret;
  ret=fstat(fd, &st);
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 75)
    {
      unsigned long int return_value_pthread_self_1;
      return_value_pthread_self_1=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) enable 64bit offset support", return_value_pthread_self_1, (const void *)"get_disksize");

    __CPROVER_DUMP_L2:
      ;
      goto __CPROVER_DUMP_L2;
    }

  }

  signed long int return_value_lseek_5;
  if((61440u & st.st_mode) == 32768u)
  {
    disksize = st.st_size;
    return disksize;
  }

  else
    if((61440u & st.st_mode) == 24576u)
    {
      disksize=lseek(fd, (signed long int)0, 2);
      if(!(disksize >= 0l))
      {
        unsigned long int return_value_pthread_self_3;
        return_value_pthread_self_3=pthread_self();
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) lseek failed: %d", return_value_pthread_self_3, (const void *)"get_disksize", *return_value___errno_location_4);

      __CPROVER_DUMP_L7:
        ;
        goto __CPROVER_DUMP_L7;
      }

      return disksize;
    }

    else
      if((61440u & st.st_mode) == 8192u)
      {
        unsigned int return_value_gnu_dev_major_6;
        return_value_gnu_dev_major_6=gnu_dev_major(st.st_rdev);
        if(return_value_gnu_dev_major_6 == 259u)
        {
          return_value_lseek_5=lseek(fd, (signed long int)0, 2);
          return return_value_lseek_5;
        }

      }

      else
      {
        unsigned long int return_value_pthread_self_7;
        return_value_pthread_self_7=pthread_self();
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) file type %d not supported", return_value_pthread_self_7, (const void *)"get_disksize", st.st_mode);

      __CPROVER_DUMP_L12:
        ;
        goto __CPROVER_DUMP_L12;
      }
  unsigned long int return_value_pthread_self_8;
  return_value_pthread_self_8=pthread_self();
  g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) failed to detect disk size", return_value_pthread_self_8, (const void *)"get_disksize");

__CPROVER_DUMP_L14:
  ;
  goto __CPROVER_DUMP_L14;
  return (signed long int)0;
}

// get_disksize_of_path
// file io.c line 172
signed long int get_disksize_of_path(const char *path)
{
  signed int fd;
  fd=open(path, 00);
  if(!(fd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) disk open, %s", return_value_pthread_self_1, (const void *)"get_disksize_of_path", path);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  signed long int disksize;
  disksize=get_disksize(fd);
  close(fd);
  return disksize;
}

// get_event_connecter
// file io.c line 344
void get_event_connecter(signed int *notifier, signed int *listener)
{
  make_pipe(notifier, listener);
}

// get_io_range_index
// file xnbd_common.c line 98
void get_io_range_index(signed long int iofrom, unsigned long int iolen, unsigned long int *index_start, unsigned long int *index_end)
{
  calc_block_index(CBLOCKSIZE, iofrom, iolen, index_start, index_end);
}

// get_line
// file io.c line 200
char * get_line(signed int fd)
{
  signed int found_eol = 0;
  char *line;
  void *return_value_g_malloc0_1;
  return_value_g_malloc0_1=g_malloc0((unsigned long int)100);
  line = (char *)return_value_g_malloc0_1;

__CPROVER_DUMP_L1:
  ;
  signed int i = 0;
  for( ; !(i >= 100); i = i + 1)
  {
    char ch = (char)48;
    signed int ret;
    signed long int return_value_read_2;
    return_value_read_2=read(fd, (void *)&ch, (unsigned long int)1);
    ret = (signed int)return_value_read_2;
    if(ret == 0)
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "get_line: peer closed");
      while((_Bool)0);
      goto err_eof;
    }

    else
      if(ret == -1)
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(*return_value___errno_location_4 == 104)
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "get_line: peer closed (%m)");
          while((_Bool)0);

        else
          do
          {
            signed int *return_value___errno_location_3;
            return_value___errno_location_3=__errno_location();
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "get_line: err %d (%m)", *return_value___errno_location_3);
          }
          while((_Bool)0);
        goto err_eof;
      }


  __CPROVER_DUMP_L8:
    ;
    if((signed int)ch == 10)
    {
      found_eol = 1;
      break;
    }

    line[(signed long int)i] = ch;
  }
  if(found_eol == 0)
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "no eol found before MAX_LINE(%d)", 100);
    while((_Bool)0);

  else
  {

  __CPROVER_DUMP_L12:
    ;
    return line;
  }

err_eof:

  err:
    ;
  g_free((void *)line);
  return (char *)(void *)0;
}

// get_log_fd
// file xnbd_common.h line 4
signed int get_log_fd(const char *path)
{
  signed int fd;
  fd=open(path, 01 | 0100 | 02000, 0400 | 0200);
  if(!(fd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open %s, %m", return_value_pthread_self_1, (const void *)"get_log_fd", path);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  return fd;
}

// get_nameinfo_string
// file net.c line 29
static char * get_nameinfo_string(struct addrinfo *ai)
{
  signed int ret;
  char hbuf[1025l];
  char sbuf[32l];
  ret=getnameinfo(ai->ai_addr, ai->ai_addrlen, hbuf, (unsigned int)sizeof(char [1025l]) /*1025ul*/ , sbuf, (unsigned int)sizeof(char [32l]) /*32ul*/ , 1 | 2);
  if(!(ret == 0))
    do
    {
      const char *return_value_gai_strerror_1;
      return_value_gai_strerror_1=gai_strerror(ret);
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "getnameinfo failed, %s", return_value_gai_strerror_1);
    }
    while((_Bool)0);

  const char *type = "unknown_ai_socktype";
  if(ai->ai_protocol == 6)
    type = "TCP";

  else
    if(ai->ai_protocol == 17)
      type = "UDP";

    else
      if(ai->ai_protocol == 132)
        type = "SCTP";

      else
        if(ai->ai_protocol == 33)
          type = "DCCP";

  char *return_value_g_strdup_printf_2;
  char *return_value_g_strdup_printf_3;
  if(ai->ai_family == 2)
  {
    return_value_g_strdup_printf_2=g_strdup_printf("%s:%s,%s", (const void *)hbuf, (const void *)sbuf, type);
    return return_value_g_strdup_printf_2;
  }

  else
  {
    return_value_g_strdup_printf_3=g_strdup_printf("[%s]:%s,%s", (const void *)hbuf, (const void *)sbuf, type);
    return return_value_g_strdup_printf_3;
  }
}

// get_session_from_read_fd
// file xnbd_proxy.c line 411
struct proxy_session * get_session_from_read_fd(struct _GList *list_head, signed int fd)
{
  struct _GList *list;
  list=g_list_first(list_head);
  struct _GList *tmp_if_expr_1;
  for( ; !(list == ((struct _GList *)NULL)); list = tmp_if_expr_1)
  {
    struct proxy_session *ps = (struct proxy_session *)list->data;
    if(ps->pipe_read_fd == fd)
      return ps;

    if(!(list == ((struct _GList *)NULL)))
      tmp_if_expr_1 = ((struct _GList *)list)->next;

    else
      tmp_if_expr_1 = (struct _GList *)(void *)0;
  }
  return (struct proxy_session *)(void *)0;
}

// handle_bgctl_command
// file xnbd_wrapper.c line 628
static signed int handle_bgctl_command(const char *usage, const char *mode, unsigned int expected_argc_min, unsigned int expected_argc_max, char *buf, struct _IO_FILE *fp, const char *xnbd_bgctl_command, unsigned int *p_argc, char ***p_argv, signed int *p_child_process_count)
{
  signed int return_code = -1;
  char **argv = (char **)(void *)0;
  unsigned int argc = (unsigned int)0;
  signed int res;
  res=extract_decode_check_usage(buf, &argv, &argc, expected_argc_min, expected_argc_max);
  signed int return_value_access_8;
  signed int tmp_post_1;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  signed int tmp_post_5;
  signed int tmp_post_6;
  signed int tmp_post_7;
  if(res == 2)
    fprintf(fp, "usage: %s\n", usage);

  else
    if(res == 1)
      fprintf(fp, "%s\n", (const void *)"out of memory");

    else
      if(res == 0)
      {
        if(!(p_argv == ((char ***)NULL)) && !(p_argc == ((unsigned int *)NULL)))
        {
          *p_argc = argc;
          *p_argv = argv;
        }

        const char * const local_exportname = argv[(signed long int)1];
        struct _t_disk_data *p_disk_data;
        p_disk_data=get_disk_data_for(local_exportname);
        if(p_disk_data == ((struct _t_disk_data *)NULL))
          fprintf(fp, "There is no export named \"%s\".\n", local_exportname);

        else
        {
          if(p_disk_data->proxy.target_host == ((char *)NULL))
            fprintf(fp, "Export \"%s\" not configured for proxy mode.\n", local_exportname);

          else
          {
            return_value_access_8=access(p_disk_data->proxy.control_socket_path, 4);
            if(return_value_access_8 == -1)
              fprintf(fp, "Export \"%s\" not being served to any client at the moment.\n", local_exportname);

            else
            {
              const _Bool target_exportname_present = argc == expected_argc_max;
              const signed int positional_args_to_append = (const signed int)(((argc - (unsigned int)1) - (unsigned int)1) - (unsigned int)(target_exportname_present != (_Bool)0 ? 1 : 0));
              const signed long int positional_args_to_append_array_size0 = (signed long int)(1 + (target_exportname_present != (_Bool)0 ? 2 : 0) + 1 + 1 + positional_args_to_append + 1);
              const char *bgctl_argv[positional_args_to_append_array_size0];
              signed int bgctl_argc = 0;
              tmp_post_1 = bgctl_argc;
              bgctl_argc = bgctl_argc + 1;
              bgctl_argv[(signed long int)tmp_post_1] = xnbd_bgctl_command;
              if(!(target_exportname_present == (_Bool)0))
              {
                tmp_post_2 = bgctl_argc;
                bgctl_argc = bgctl_argc + 1;
                bgctl_argv[(signed long int)tmp_post_2] = "--exportname";
                tmp_post_3 = bgctl_argc;
                bgctl_argc = bgctl_argc + 1;
                bgctl_argv[(signed long int)tmp_post_3] = argv[(signed long int)(expected_argc_max - (unsigned int)1)];
              }

              tmp_post_4 = bgctl_argc;
              bgctl_argc = bgctl_argc + 1;
              bgctl_argv[(signed long int)tmp_post_4] = mode;
              tmp_post_5 = bgctl_argc;
              bgctl_argc = bgctl_argc + 1;
              bgctl_argv[(signed long int)tmp_post_5] = p_disk_data->proxy.control_socket_path;
              signed int i = 0;
              for( ; !(i >= positional_args_to_append); i = i + 1)
              {
                tmp_post_6 = bgctl_argc;
                bgctl_argc = bgctl_argc + 1;
                bgctl_argv[(signed long int)tmp_post_6] = argv[(signed long int)(1 + 1 + i)];
              }
              tmp_post_7 = bgctl_argc;
              bgctl_argc = bgctl_argc + 1;
              bgctl_argv[(signed long int)tmp_post_7] = (const char *)(void *)0;
              signed int bgctl_pid;
              bgctl_pid=invoke_bgctl(fp, bgctl_argv);
              if(!(bgctl_pid == -1))
              {
                pthread_mutex_lock(&mutex);
                *p_child_process_count = *p_child_process_count + 1;
                do
                  g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "child_process_count++ : %d  (forked to execute xnbd-bgctl)", *p_child_process_count);
                while((_Bool)0);
                pthread_mutex_unlock(&mutex);
              }

              if(bgctl_pid == -1)
                fprintf(fp, "xnbd-bgctl could not be executed.\n");

              else
              {
                signed int status = -1;
                signed int waitpid_res;
                waitpid_res=waitpid(bgctl_pid, &status, 0);
                if(!(waitpid_res == bgctl_pid))
                  do
                    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "waiting for xnbd-bgctl(%d), waitpid : %m", bgctl_pid);
                  while((_Bool)0);

                pthread_mutex_lock(&mutex);
                *p_child_process_count = *p_child_process_count - 1;
                do
                  g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "child_process_count-- : %d  (xnbd-bgctl terminated)", *p_child_process_count);
                while((_Bool)0);
                pthread_mutex_unlock(&mutex);
                /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
                ;
                if((0x7f & status) == 0)
                  return_code = (signed int)(unsigned char)((((union anonymous){ .__in=status }).__i & 0xff00) >> 8);

                else
                {
                  /* assertion (((signed char) ((((__extension__ (((union { __typeof(status) __in; int __i; }) { .__in = (status) }).__i))) & 0x7f) + 1) >> 1) > 0) */
                  assert((signed int)(signed char)((((union anonymous){ .__in=status }).__i & 0x7f) + 1) >> 1 > 0);
                  return_code = (signed int)(unsigned char)(128 + (((union anonymous){ .__in=status }).__i & 0x7f));
                }
                if(!(return_code == 0))
                  fprintf(fp, "Execution of xnbd-bgctl failed with code %d.\n", return_code);

              }
            }
          }
          destroy_value(p_disk_data);
        }
      }

  if(p_argv == ((char ***)NULL) || p_argc == ((unsigned int *)NULL))
    g_strfreev(argv);

  return return_code;
}

// hexdig_char_to_int
// file xnbd_wrapper.c line 421
static signed int hexdig_char_to_int(char c)
{
  switch((signed int)c)
  {
    case 48:
      return 0;
    case 49:
      return 1;
    case 50:
      return 2;
    case 51:
      return 3;
    case 52:
      return 4;
    case 53:
      return 5;
    case 54:
      return 6;
    case 55:
      return 7;
    case 56:
      return 8;
    case 57:
      return 9;
    case 97:

    case 65:
      return 10;
    case 98:

    case 66:
      return 11;
    case 99:

    case 67:
      return 12;
    case 100:

    case 68:
      return 13;
    case 101:

    case 69:
      return 14;
    case 102:

    case 70:
      return 15;
    default:
      return -1;
  }
}

// inform_xnbd_server_termination
// file xnbd_wrapper.c line 142
static void inform_xnbd_server_termination(signed int pid, signed int status)
{
  /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
  ;
  if((0x7f & status) == 0)
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "pid %ld : exit status %d", (signed long int)pid, (((union anonymous){ .__in=status }).__i & 0xff00) >> 8);
    while((_Bool)0);

  else
    if((signed int)((127 & (signed char)status) + 1) >> 1 >= 1)
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "pid %ld : terminated by signal %d", (signed long int)pid, ((union anonymous){ .__in=status }).__i & 0x7f);
      while((_Bool)0);

}

// invoke_bgctl
// file xnbd_wrapper.c line 604
static signed int invoke_bgctl(struct _IO_FILE *fp, const char **argv)
{
  signed int pid;
  pid=fork();
  if(!(pid == 0))
    return pid;

  else
  {
    about_to_execute(argv);
    close(0);
    signed int output_fd;
    output_fd=fileno(fp);
    if(!(output_fd == -1))
    {
      dup2(output_fd, 1);
      dup2(output_fd, 2);
    }

    execvp_or_abort(argv);
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) should never get here", return_value_pthread_self_1, (const void *)"invoke_bgctl");

  __CPROVER_DUMP_L4:
    ;
    goto __CPROVER_DUMP_L4;
    return 0;
  }
}

// io_all
// file io.c line 26
static void io_all(signed int fd, void *buf, unsigned long int len, signed int read_ops)
{
  signed int next_len = (signed int)len;
  char *next_buf = (char *)buf;
  const char *mode = read_ops != 0 ? "read" : "write";
  unsigned long int total = (unsigned long int)0;
  signed long int return_value_read_1;
  signed long int return_value_write_2;
  do
  {
    signed int ret = 0;
    if(!(read_ops == 0))
    {
      return_value_read_1=read(fd, (void *)next_buf, (unsigned long int)next_len);
      ret = (signed int)return_value_read_1;
    }

    else
    {
      return_value_write_2=write(fd, (const void *)next_buf, (unsigned long int)next_len);
      ret = (signed int)return_value_write_2;
    }
    if(ret == 0)
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "%s() returned 0 (fd %d)", mode, fd);

    if(ret == -1)
    {
      unsigned long int return_value_pthread_self_3;
      return_value_pthread_self_3=pthread_self();
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) %s error %s (%d) (fd %d)", return_value_pthread_self_3, (const void *)"io_all", mode, return_value_strerror_5, *return_value___errno_location_6, fd);

    __CPROVER_DUMP_L6:
      ;
      goto __CPROVER_DUMP_L6;
    }

    total = total + (unsigned long int)ret;
    next_len = next_len - ret;
    next_buf = next_buf + (signed long int)ret;
    if(total == len)
      break;

  }
  while((_Bool)1);
}

// list_diskimg
// file xnbd_wrapper.c line 386
static void list_diskimg(struct _IO_FILE *fp)
{
  pthread_mutex_lock(&mutex);
  unsigned int return_value_g_hash_table_size_1;
  return_value_g_hash_table_size_1=g_hash_table_size(p_disk_dict);
  if(return_value_g_hash_table_size_1 >= 1u)
  {
    struct _t_listing_state listing_state;
    listing_state.index_to_print = (unsigned int)-1;
    listing_state.index_up_next = (unsigned int)-1;
    listing_state.fp = fp;
    g_hash_table_foreach(p_disk_dict, (void (*)(void *, void *, void *))find_smallest_index_iterator, (void *)&listing_state);
    for( ; !(listing_state.index_to_print >= 4294967295u); listing_state.index_to_print = listing_state.index_up_next)
    {
      listing_state.index_up_next = (unsigned int)-1;
      g_hash_table_foreach(p_disk_dict, (void (*)(void *, void *, void *))list_images_iterator, (void *)&listing_state);
    }
  }

  else
    fprintf(fp, "no item\n");
  pthread_mutex_unlock(&mutex);
}

// list_images_iterator
// file xnbd_wrapper.c line 353
static void list_images_iterator(void *key, const struct _t_disk_data *p_disk_data, struct _t_listing_state *p_listing_state)
{
  (void)key;
  char *tmp_if_expr_1;
  if(p_disk_data->index == p_listing_state->index_to_print)
  {
    unsigned int one_based_index = p_disk_data->index + (unsigned int)1;
    if(!(p_disk_data->proxy.target_host == ((char *)NULL)))
    {
      if(!(p_disk_data->proxy.target_exportname == ((char *)NULL)))
        tmp_if_expr_1 = p_disk_data->proxy.target_exportname;

      else
        tmp_if_expr_1 = "";
      fprintf(p_listing_state->fp, "%d : %s  (%s:%s%s%s, %s, %s, %s)\n", one_based_index, p_disk_data->local_exportname, p_disk_data->proxy.target_host, p_disk_data->proxy.target_port, p_disk_data->proxy.target_exportname != ((char *)NULL) ? ":" : "", tmp_if_expr_1, p_disk_data->disk_file_name, p_disk_data->proxy.bitmap_image, p_disk_data->proxy.control_socket_path);
    }

    else
      fprintf(p_listing_state->fp, "%d : %s  (%s)\n", one_based_index, p_disk_data->local_exportname, p_disk_data->disk_file_name);
  }

  else
    if(!(p_listing_state->index_to_print >= p_disk_data->index))
    {
      if(!(p_disk_data->index >= p_listing_state->index_up_next))
        p_listing_state->index_up_next = p_disk_data->index;

    }

}

// main
// file xnbd_wrapper.c line 1149
signed int main(signed int argc, char **argv)
{
  char *fd_num;
  signed int pid;
  const char *xnbd_server_command = "xnbd-server";
  char *laddr = (char *)(void *)0;
  char *port = (char *)(void *)0;
  signed int sockfd;
  signed int conn_sockfd;
  signed int ux_sockfd;
  signed int ch;
  signed int ret;
  char *requested_img = (char *)(void *)0;
  unsigned long int thread;
  const char default_ctl_path[26l] = { '/', 'v', 'a', 'r', '/', 'r', 'u', 'n', '/', 'x', 'n', 'b', 'd', '-', 'w', 'r', 'a', 'p', 'p', 'e', 'r', '.', 'c', 't', 'l', 0 };
  char *ctl_path = (char *)(void *)0;
  signed int child_process_count = 0;
  const signed int MAX_NSRVS = 512;
  const char default_server_target[9l] = { '-', '-', 't', 'a', 'r', 'g', 'e', 't', 0 };
  const char *server_target = (const char *)(void *)0;
  signed int daemonize = 0;
  signed int main__1__syslog = 0;
  const char *logpath = (const char *)(void *)0;
  struct exec_params exec_srv_params = { .binpath=((const char *)NULL), .target_mode=((const char *)NULL), .readonly=0,
    .syslog=0, .proxy_max_que_size_str=((const char *)NULL), .proxy_max_buf_size_str=((const char *)NULL) };
  const char *xnbd_bgctl_command = "xnbd-bgctl";
  p_disk_dict=g_hash_table_new_full(g_str_hash, g_str_equal, (void (*)(void *))(void *)0, (void (*)(void *))destroy_value);
  p_server_pid_set=g_hash_table_new(g_direct_hash, g_direct_equal);
  struct anonymous_0 sigset;
  signed int sigfd;
  struct signalfd_siginfo sfd_siginfo;
  signed long int rbytes;
  const signed int MAX_EVENTS = 8;
  const signed long int tcpfd_ev_array_size0 = (signed long int)MAX_EVENTS;
  struct epoll_event sigfd_ev;
  struct epoll_event uxfd_ev;
  struct epoll_event tcpfd_ev;
  struct epoll_event ep_events[tcpfd_ev_array_size0];
  signed int epoll_fd;
  set_process_name("xnbd-wrapper");
  struct option longopts[17l] = { { .name="imgfile", .has_arg=1, .flag=(signed int *)(void *)0, .val=102 },
    { .name="laddr", .has_arg=1, .flag=(signed int *)(void *)0, .val=108 },
    { .name="lport", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 },
    { .name="port", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 },
    { .name="socket", .has_arg=1, .flag=(signed int *)(void *)0, .val=115 },
    { .name="xnbd-bgctl", .has_arg=1, .flag=(signed int *)(void *)0, .val=116 },
    { .name="xnbd-server", .has_arg=1, .flag=(signed int *)(void *)0, .val=98 },
    { .name="xnbd-binary", .has_arg=1, .flag=(signed int *)(void *)0, .val=98 },
    { .name="cow", .has_arg=0, .flag=(signed int *)(void *)0, .val=99 },
    { .name="readonly", .has_arg=0, .flag=(signed int *)(void *)0, .val=114 },
    { .name="daemonize", .has_arg=0, .flag=(signed int *)(void *)0, .val=100 },
    { .name="logpath", .has_arg=1, .flag=(signed int *)(void *)0, .val=76 },
    { .name="syslog", .has_arg=0, .flag=(signed int *)(void *)0, .val=83 },
    { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name="max-queue-size", .has_arg=1, .flag=(signed int *)(void *)0, .val=81 },
    { .name="max-buf-size", .has_arg=1, .flag=(signed int *)(void *)0, .val=66 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
  struct custom_log_handler_params log_params;
  signed int return_value_fileno_1;
  return_value_fileno_1=fileno(stderr);
  log_params = (struct custom_log_handler_params){ .use_syslog=0, .use_fd=1, .fd=return_value_fileno_1 };
  g_log_set_default_handler(custom_log_handler, (void *)&log_params);
  const char *local_exportname;
  const char *filename;
  struct _t_disk_data *p_disk_data;
  unsigned long int proxy_max_que_size;
  unsigned long int proxy_max_buf_size;
  do
  {
    ch=getopt_long(argc, argv, "b:f:hl:p:s:SdL:Q:B:", longopts, (signed int *)(void *)0);
    if(ch == -1)
      break;

    switch(ch)
    {
      case 76:
      {
        logpath = optarg;
        log_params.use_fd = 1;
        log_params.fd=get_log_fd(logpath);
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "LOGFILE: %s", logpath);
        while((_Bool)0);
        g_log_set_default_handler(custom_log_handler, (void *)&log_params);
        break;
      }
      case 99:
      {
        server_target = "--cow-target";
        break;
      }
      case 114:
      {
        exec_srv_params.readonly = 1;
        break;
      }
      case 100:
      {
        daemonize = 1;
        break;
      }
      case 108:
      {
        laddr = optarg;
        break;
      }
      case 112:
      {
        port = optarg;
        break;
      }
      case 102:
      {
        local_exportname = optarg;
        filename = optarg;
        p_disk_data=create_disk_data(local_exportname, (const char *)(void *)0, (const char *)(void *)0, filename, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0);
        if(!(p_disk_data == ((struct _t_disk_data *)NULL)))
        {
          ret=add_diskimg(p_disk_data);
          if(!(ret >= 0))
          {
            if(ret == -1)
              do
                g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "cannot open %s", filename);
              while((_Bool)0);

            else
              if(ret == -4)
                do
                  g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "image cannot be added twice");
                while((_Bool)0);

          }

        }

        else
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "out of memory");
          while((_Bool)0);
        break;
      }
      case 98:
      {
        xnbd_server_command = optarg;
        break;
      }
      case 116:
      {
        xnbd_bgctl_command = optarg;
        break;
      }
      case 115:
      {
        ctl_path = optarg;
        break;
      }
      case 83:
      {
        main__1__syslog = 1;
        break;
      }
      case 81:
      {
        proxy_max_que_size=strtoul(optarg, (char ** restrict )(void *)0, 0);
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "max_queue_size %zu", proxy_max_que_size);
        while((_Bool)0);
        exec_srv_params.proxy_max_que_size_str = optarg;
        break;
      }
      case 66:
      {
        proxy_max_buf_size=strtoul(optarg, (char ** restrict )(void *)0, 0);
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "max_buf_size %zu", proxy_max_buf_size);
        while((_Bool)0);
        exec_srv_params.proxy_max_buf_size_str = optarg;
        break;
      }
      case 104:
      {
        log_params.fd=fileno(stdout);
        g_log_set_default_handler(custom_log_handler, (void *)&log_params);
      }
      default:
      {
        struct _IO_FILE * const target = ch == 104 ? stdout : stderr;
        fprintf(target, help_string, argv[(signed long int)0]);
        if(ch == 104)
          return 0;

        return 1;
      }
    }
  }
  while((_Bool)1);
  if(logpath == ((const char *)NULL) && !(daemonize == 0) || !(main__1__syslog == 0))
  {
    log_params.use_syslog = 1;
    exec_srv_params.syslog = 1;
    if(daemonize == 0)
      log_params.use_fd = 0;

  }

  else
    exec_srv_params.syslog = 0;
  ensure_command_available("which");
  ensure_command_available(xnbd_bgctl_command);
  ensure_command_available(xnbd_server_command);
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "xnbd-bgctl executable: %s", xnbd_bgctl_command);
  while((_Bool)0);
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "xnbd-server executable: %s", xnbd_server_command);
  while((_Bool)0);
  exec_srv_params.binpath = xnbd_server_command;
  if(port == ((char *)NULL))
  {
    signed int return_value_asprintf_2;
    return_value_asprintf_2=asprintf(&port, "%d", XNBD_PORT);
    if(return_value_asprintf_2 == -1)
      return 1;

  }

  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "port: %s", port);
  while((_Bool)0);
  if(ctl_path == ((char *)NULL))
    ctl_path = (char *)default_ctl_path;

  if(server_target == ((const char *)NULL))
    server_target = default_server_target;

  exec_srv_params.target_mode = server_target;
  signed int return_value_daemon_4;
  if(!(daemonize == 0))
  {
    return_value_daemon_4=daemon(0, 0);
    if(return_value_daemon_4 == -1)
    {
      unsigned long int return_value_pthread_self_3;
      return_value_pthread_self_3=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) daemon %m", return_value_pthread_self_3, (const void *)"main");

    __CPROVER_DUMP_L39:
      ;
      goto __CPROVER_DUMP_L39;
    }

  }

  sigemptyset(&sigset);
  sigaddset(&sigset, 2);
  sigaddset(&sigset, 15);
  sigaddset(&sigset, 17);
  sigaddset(&sigset, 13);
  signed int return_value_sigprocmask_6;
  return_value_sigprocmask_6=sigprocmask(0, &sigset, (struct anonymous_0 *)(void *)0);
  if(return_value_sigprocmask_6 == -1)
  {
    unsigned long int return_value_pthread_self_5;
    return_value_pthread_self_5=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) sigprocmask() : %m", return_value_pthread_self_5, (const void *)"main");

  __CPROVER_DUMP_L42:
    ;
    goto __CPROVER_DUMP_L42;
  }

  sigfd=signalfd(-1, &sigset, 0);
  if(sigfd == -1)
  {
    unsigned long int return_value_pthread_self_7;
    return_value_pthread_self_7=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) signalfd() : %m", return_value_pthread_self_7, (const void *)"main");

  __CPROVER_DUMP_L45:
    ;
    goto __CPROVER_DUMP_L45;
  }

  epoll_fd=epoll_create1(0);
  if(epoll_fd == -1)
  {
    unsigned long int return_value_pthread_self_8;
    return_value_pthread_self_8=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) epoll_create : %m", return_value_pthread_self_8, (const void *)"main");

  __CPROVER_DUMP_L48:
    ;
    goto __CPROVER_DUMP_L48;
  }

  memset((void *)&sigfd_ev, 0, sizeof(struct epoll_event) /*12ul*/ );
  sigfd_ev.events = (unsigned int)0x001;
  sigfd_ev.data.fd = sigfd;
  signed int return_value_epoll_ctl_10;
  return_value_epoll_ctl_10=epoll_ctl(epoll_fd, 1, sigfd, &sigfd_ev);
  if(return_value_epoll_ctl_10 == -1)
  {
    unsigned long int return_value_pthread_self_9;
    return_value_pthread_self_9=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) epoll_ctl : %m", return_value_pthread_self_9, (const void *)"main");

  __CPROVER_DUMP_L51:
    ;
    goto __CPROVER_DUMP_L51;
  }

  sockfd=make_tcp_sock(laddr, port);
  if(sockfd == -1)
  {
    unsigned long int return_value_pthread_self_11;
    return_value_pthread_self_11=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) make_tcp_sock() returned %d", return_value_pthread_self_11, (const void *)"main", sockfd);

  __CPROVER_DUMP_L54:
    ;
    goto __CPROVER_DUMP_L54;
  }

  memset((void *)&tcpfd_ev, 0, sizeof(struct epoll_event) /*12ul*/ );
  tcpfd_ev.events = (unsigned int)0x001;
  tcpfd_ev.data.fd = sockfd;
  signed int return_value_epoll_ctl_13;
  return_value_epoll_ctl_13=epoll_ctl(epoll_fd, 1, sockfd, &tcpfd_ev);
  if(return_value_epoll_ctl_13 == -1)
  {
    unsigned long int return_value_pthread_self_12;
    return_value_pthread_self_12=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) epoll_ctl : %m", return_value_pthread_self_12, (const void *)"main");

  __CPROVER_DUMP_L57:
    ;
    goto __CPROVER_DUMP_L57;
  }

  ux_sockfd=make_unix_sock(ctl_path);
  if(!(ux_sockfd >= 0))
  {
    unsigned long int return_value_pthread_self_14;
    return_value_pthread_self_14=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) make_unix_sock() returned %d", return_value_pthread_self_14, (const void *)"main", ux_sockfd);

  __CPROVER_DUMP_L60:
    ;
    goto __CPROVER_DUMP_L60;
  }

  memset((void *)&uxfd_ev, 0, sizeof(struct epoll_event) /*12ul*/ );
  uxfd_ev.events = (unsigned int)0x001;
  uxfd_ev.data.fd = ux_sockfd;
  signed int return_value_epoll_ctl_16;
  return_value_epoll_ctl_16=epoll_ctl(epoll_fd, 1, ux_sockfd, &uxfd_ev);
  if(return_value_epoll_ctl_16 == -1)
  {
    unsigned long int return_value_pthread_self_15;
    return_value_pthread_self_15=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) epoll_ctl : %m", return_value_pthread_self_15, (const void *)"main");

  __CPROVER_DUMP_L63:
    ;
    goto __CPROVER_DUMP_L63;
  }

  do
  {
    signed int num_of_fds;
    num_of_fds=epoll_wait(epoll_fd, ep_events, MAX_EVENTS, -1);
    if(num_of_fds == -1)
    {
      signed int *return_value___errno_location_17;
      return_value___errno_location_17=__errno_location();
      if(*return_value___errno_location_17 == 4)
        continue;

      unsigned long int return_value_pthread_self_18;
      return_value_pthread_self_18=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) epoll_wait : %m", return_value_pthread_self_18, (const void *)"main");

    __CPROVER_DUMP_L66:
      ;
      goto __CPROVER_DUMP_L66;
    }

    signed int c_ev = 0;
    for( ; !(c_ev >= num_of_fds); c_ev = c_ev + 1)
      if(ep_events[(signed long int)c_ev].data.fd == sigfd)
      {
        rbytes=read(sigfd, (void *)&sfd_siginfo, sizeof(struct signalfd_siginfo) /*128ul*/ );
        if(!((unsigned long int)rbytes == sizeof(struct signalfd_siginfo) /*128ul*/ ))
        {
          unsigned long int return_value_pthread_self_19;
          return_value_pthread_self_19=pthread_self();
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) read sigfd : %m", return_value_pthread_self_19, (const void *)"main");

        __CPROVER_DUMP_L70:
          ;
          goto __CPROVER_DUMP_L70;
        }

        if(sfd_siginfo.ssi_signo == 2u || sfd_siginfo.ssi_signo == 15u)
        {
          close(epoll_fd);
          close(sockfd);
          close(ux_sockfd);
          close(sigfd);
          unlink(ctl_path);
          exit(0);
        }

        else
          if(sfd_siginfo.ssi_signo == 17u)
            g_hash_table_foreach_remove(p_server_pid_set, waitpid_nohang_ghrfunc, (void *)&child_process_count);

      }

      else
        if(ep_events[(signed long int)c_ev].data.fd == ux_sockfd)
        {
          struct _t_thread_data *p_thread_data;
          void *return_value_g_try_malloc_n_20;
          return_value_g_try_malloc_n_20=g_try_malloc_n((unsigned long int)1, sizeof(struct _t_thread_data) /*24ul*/ );
          p_thread_data = (struct _t_thread_data *)return_value_g_try_malloc_n_20;
          if(p_thread_data == ((struct _t_thread_data *)NULL))
            do
              g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "Could not start thread: %s", (const void *)"out of memory");
            while((_Bool)0);

          else
          {
            p_thread_data->unix_sock_fd = ux_sockfd;
            p_thread_data->xnbd_bgctl_command = xnbd_bgctl_command;
            p_thread_data->p_child_process_count = &child_process_count;
            signed int return_value_pthread_create_21;
            return_value_pthread_create_21=pthread_create(&thread, (const union pthread_attr_t *)(void *)0, start_filemgr_thread, (void *)p_thread_data);
            if(!(return_value_pthread_create_21 == 0))
              do
                g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "pthread_create : %m");
              while((_Bool)0);

            signed int return_value_pthread_detach_22;
            return_value_pthread_detach_22=pthread_detach(thread);
            if(!(return_value_pthread_detach_22 == 0))
              do
                g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "pthread_detach : %m");
              while((_Bool)0);

          }
        }

        else
          if(ep_events[(signed long int)c_ev].data.fd == sockfd)
          {
            conn_sockfd=accept(sockfd, (void *)0, (unsigned int *)(void *)0);
            if(conn_sockfd == -1)
            {
              do
                g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "accept : %m");
              while((_Bool)0);
              break;
            }

            signed int return_value_asprintf_23;
            return_value_asprintf_23=asprintf(&fd_num, "%d", conn_sockfd);
            if(return_value_asprintf_23 == -1)
              break;

            do
              g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "conn_sockfd: %d", conn_sockfd);
            while((_Bool)0);
            pthread_mutex_lock(&mutex);
            const signed int child_process_limit_reached = (const signed int)(child_process_count >= MAX_NSRVS);
            pthread_mutex_unlock(&mutex);
            if(!(child_process_limit_reached == 0))
            {
              close(conn_sockfd);
              do
                g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "fork : reached the limit");
              while((_Bool)0);
              break;
            }

            pid=fork();
            if(pid == 0)
            {
              signed int return_value_sigprocmask_24;
              return_value_sigprocmask_24=sigprocmask(1, &sigset, (struct anonymous_0 *)(void *)0);
              if(return_value_sigprocmask_24 == -1)
              {
                do
                  g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "sigprocmask() : %m");
                while((_Bool)0);
                _exit(1);
              }

              close(sockfd);
              close(epoll_fd);
              close(ux_sockfd);
              close(sigfd);
              requested_img=nbd_negotiate_with_client_new_phase_0(conn_sockfd);
              if(requested_img == ((char *)NULL))
              {
                do
                  g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "requested_img: NULL");
                while((_Bool)0);
                close(conn_sockfd);
                _exit(1);
              }

              do
                g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "requested_img: %s", requested_img);
              while((_Bool)0);
              const struct _t_disk_data *disk_data;
              disk_data=get_disk_data_for(requested_img);
              if(disk_data == ((const struct _t_disk_data *)NULL))
              {
                signed int return_value_close_25;
                return_value_close_25=close(conn_sockfd);
                if(!(return_value_close_25 == 0))
                  do
                    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "close(p0)");
                  while((_Bool)0);

                _exit(1);
              }

              signed long int disk_size_bytes = (signed long int)-1;
              if(!(disk_data->proxy.target_host == ((char *)NULL)))
              {
                query_remote_disk_size(&disk_size_bytes, disk_data->proxy.target_host, disk_data->proxy.target_port, disk_data->proxy.target_exportname);
                if(!(disk_size_bytes >= 0l))
                {
                  do
                    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "could query remote disk size for image: %s", disk_data->disk_file_name);
                  while((_Bool)0);
                  signed int return_value_close_26;
                  return_value_close_26=close(conn_sockfd);
                  if(!(return_value_close_26 == 0))
                    do
                      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "close(p1.1)");
                    while((_Bool)0);

                  _exit(1);
                }

              }

              else
              {
                signed int fd;
                fd=open(disk_data->disk_file_name, 00);
                if(fd == -1)
                {
                  do
                    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "stat failed: %s", disk_data->disk_file_name);
                  while((_Bool)0);
                  signed int return_value_close_27;
                  return_value_close_27=close(conn_sockfd);
                  if(!(return_value_close_27 == 0))
                    do
                      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "close(p1.2)");
                    while((_Bool)0);

                  _exit(1);
                }

                disk_size_bytes=get_disksize(fd);
                close(fd);
              }
              do
                g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "disk_size_bytes: %jd", disk_size_bytes);
              while((_Bool)0);
              signed int return_value_nbd_negotiate_with_client_new_phase_1_29;
              return_value_nbd_negotiate_with_client_new_phase_1_29=nbd_negotiate_with_client_new_phase_1(conn_sockfd, disk_size_bytes, 0);
              if(!(return_value_nbd_negotiate_with_client_new_phase_1_29 == 0))
              {
                signed int return_value_close_28;
                return_value_close_28=close(conn_sockfd);
                if(!(return_value_close_28 == 0))
                  do
                    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "close(p2)");
                  while((_Bool)0);

                _exit(1);
              }

              exec_xnbd_server(&exec_srv_params, fd_num, disk_data);
            }

            else
              if(pid >= 1)
              {
                free((void *)fd_num);
                g_hash_table_insert(p_server_pid_set, (void *)(signed long int)pid, (void *)0);
                pthread_mutex_lock(&mutex);
                child_process_count = child_process_count + 1;
                do
                  g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "child_process_count++ : %d  (forked to execute xnbd-server)", child_process_count);
                while((_Bool)0);
                pthread_mutex_unlock(&mutex);
                do
                  g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "fork: pid %ld", (signed long int)pid);
                while((_Bool)0);
                close(conn_sockfd);
              }

              else
              {
                unsigned long int return_value_pthread_self_30;
                return_value_pthread_self_30=pthread_self();
                g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) fork: %m", return_value_pthread_self_30, (const void *)"main");

              __CPROVER_DUMP_L112:
                ;
                goto __CPROVER_DUMP_L112;
                break;
              }
          }

  }
  while((_Bool)1);
  return 1;
}

// main_loop
// file xnbd_proxy.c line 534
signed int main_loop(struct xnbd_proxy *proxy, signed int unix_listen_fd, signed int master_fd)
{
  signed int ret;
  signed long int ret_array_size0;
  unsigned int return_value_g_list_length_1;
  return_value_g_list_length_1=g_list_length(conn_list);
  ret_array_size0 = (signed long int)((unsigned int)2 + return_value_g_list_length_1);
  struct pollfd eventfds[ret_array_size0];
  unsigned long int neventfds = (unsigned long int)0;
  eventfds[(signed long int)neventfds].fd = unix_listen_fd;
  eventfds[(signed long int)neventfds].events = (signed short int)(0x040 | 0x2000);
  neventfds = neventfds + (unsigned long int)1;
  eventfds[(signed long int)neventfds].fd = master_fd;
  eventfds[(signed long int)neventfds].events = (signed short int)(0x040 | 0x2000);
  neventfds = neventfds + (unsigned long int)1;
  struct _GList *list;
  list=g_list_first(conn_list);
  struct _GList *tmp_if_expr_2;
  for( ; !(list == ((struct _GList *)NULL)); list = tmp_if_expr_2)
  {
    struct proxy_session *main_loop__1__1__1__ps = (struct proxy_session *)list->data;
    eventfds[(signed long int)neventfds].fd = main_loop__1__1__1__ps->pipe_read_fd;
    eventfds[(signed long int)neventfds].events = (signed short int)(0x040 | 0x2000);
    neventfds = neventfds + (unsigned long int)1;
    if(!(list == ((struct _GList *)NULL)))
      tmp_if_expr_2 = ((struct _GList *)list)->next;

    else
      tmp_if_expr_2 = (struct _GList *)(void *)0;
  }
  signed int nready;
  nready=poll(eventfds, neventfds, -1);
  if(nready == -1)
  {
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    if(*return_value___errno_location_7 == 4)
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "polling signal cached");
      while((_Bool)0);
      return -1;
    }

    else
    {
      unsigned long int return_value_pthread_self_3;
      return_value_pthread_self_3=pthread_self();
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) polling, %s, (%d)", return_value_pthread_self_3, (const void *)"main_loop", return_value_strerror_5, *return_value___errno_location_6);

    __CPROVER_DUMP_L7:
      ;
      goto __CPROVER_DUMP_L7;
    }
  }

  if(!((8256 & (signed int)eventfds[0l].revents) == 0))
  {
    struct sockaddr_un cliaddr;
    unsigned int cliaddr_len = (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ ;
    signed int wrk_fd;
    wrk_fd=accept(eventfds[(signed long int)0].fd, &cliaddr, &cliaddr_len);
    if(!(wrk_fd >= 0))
    {
      unsigned long int return_value_pthread_self_8;
      return_value_pthread_self_8=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) accept %m", return_value_pthread_self_8, (const void *)"main_loop");

    __CPROVER_DUMP_L11:
      ;
      goto __CPROVER_DUMP_L11;
    }

    signed int close_wrk_fd = 1;
    enum xnbd_proxy_cmd_type cmd;
    ret=net_recv_all_or_error(wrk_fd, (void *)&cmd, sizeof(enum xnbd_proxy_cmd_type) /*4ul*/ );
    if(!(ret >= 0))
      cmd = (enum xnbd_proxy_cmd_type)XNBD_PROXY_CMD_UNKNOWN;

    switch((signed int)cmd)
    {
      case XNBD_PROXY_CMD_QUERY_STATUS:
      {
        struct xnbd_proxy_query query;
        memset((void *)&query, 0, sizeof(struct xnbd_proxy_query) /*16432ul*/ );
        query.disksize = proxy->xnbd->disksize;
        g_strlcpy(query.diskpath, proxy->xnbd->proxy_diskpath, sizeof(char [4096l]) /*4096ul*/ );
        g_strlcpy(query.bmpath, proxy->xnbd->proxy_bmpath, sizeof(char [4096l]) /*4096ul*/ );
        g_strlcpy(query.rhost, proxy->xnbd->proxy_rhost, sizeof(char [4096l]) /*4096ul*/ );
        g_strlcpy(query.rport, proxy->xnbd->proxy_rport, sizeof(char [4096l]) /*4096ul*/ );
        query.master_pid=getppid();
        query.max_use_buf = proxy->xnbd->proxy_max_buf_size;
        query.cur_use_buf = proxy->cur_use_buf;
        query.max_use_que = proxy->xnbd->proxy_max_que_size;
        query.cur_use_que = proxy->cur_use_que;
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "send current status (wrk_fd %d)", wrk_fd);
        while((_Bool)0);
        net_send_all_or_error(wrk_fd, (const void *)&query, sizeof(struct xnbd_proxy_query) /*16432ul*/ );
        break;
      }
      case XNBD_PROXY_CMD_REGISTER_FD:
      {
        signed int nbd_fd;
        nbd_fd=unix_recv_fd(wrk_fd);
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "create proxy_session (nbd_fd %d wrk_fd %d)", nbd_fd, wrk_fd);
        while((_Bool)0);
        struct proxy_session *main_loop__1__3__2__2__ps;
        void *return_value_g_malloc0_9;
        return_value_g_malloc0_9=g_malloc0(sizeof(struct proxy_session) /*48ul*/ );
        main_loop__1__3__2__2__ps = (struct proxy_session *)return_value_g_malloc0_9;
        main_loop__1__3__2__2__ps->nbd_fd = nbd_fd;
        main_loop__1__3__2__2__ps->wrk_fd = wrk_fd;
        main_loop__1__3__2__2__ps->tx_queue=g_async_queue_new();
        main_loop__1__3__2__2__ps->proxy = proxy;
        main_loop__1__3__2__2__ps->tid_tx=pthread_create_or_abort(tx_thread_main, (void *)main_loop__1__3__2__2__ps);
        main_loop__1__3__2__2__ps->tid_rx=pthread_create_or_abort(rx_thread_main, (void *)main_loop__1__3__2__2__ps);
        make_pipe(&main_loop__1__3__2__2__ps->pipe_write_fd, &main_loop__1__3__2__2__ps->pipe_read_fd);
        conn_list=g_list_append(conn_list, (void *)main_loop__1__3__2__2__ps);
        close_wrk_fd = 0;
        break;
      }
      case XNBD_PROXY_CMD_REGISTER_FORWARDER_FD:
      {
        signed int fwd_fd;
        fwd_fd=unix_recv_fd(wrk_fd);
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "register forwarder fd (nbd_fd %d wrk_fd %d)", fwd_fd, wrk_fd);
        while((_Bool)0);
        proxy_shutdown_forwarder(proxy);
        nbd_client_send_disc_request(proxy->remotefd);
        close(proxy->remotefd);
        do
        {
          struct proxy_priv *priv;
          void *return_value_g_async_queue_try_pop_10;
          return_value_g_async_queue_try_pop_10=g_async_queue_try_pop(proxy->fwd_retry_queue);
          priv = (struct proxy_priv *)return_value_g_async_queue_try_pop_10;
          if(priv == ((struct proxy_priv *)NULL))
            break;

          priv->need_retry = 0;
          g_async_queue_push_unshift(proxy->fwd_tx_queue, (void *)priv);
        }
        while((_Bool)1);
        proxy_initialize_forwarder(proxy, fwd_fd);
        break;
      }
      case XNBD_PROXY_CMD_REGISTER_SHARED_BUFFER_FD:
      {
        if(!(proxy->shared_buff == ((char *)NULL)))
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "shared_buff was already assigned; do nothing");
          while((_Bool)0);

        else
        {
          signed int buf_fd;
          buf_fd=unix_recv_fd(wrk_fd);
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "register shared buffer fd (buf_fd %d wrk_fd %d)", buf_fd, wrk_fd);
          while((_Bool)0);
          void *return_value_mmap_11;
          return_value_mmap_11=mmap((void *)0, (unsigned long int)(CBLOCKSIZE * (unsigned int)1000), 0x1, 0x01, buf_fd, (signed long int)0);
          proxy->shared_buff = (char *)return_value_mmap_11;
          if(proxy->shared_buff == (char *)-1)
          {
            unsigned long int return_value_pthread_self_12;
            return_value_pthread_self_12=pthread_self();
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) mmap, %m", return_value_pthread_self_12, (const void *)"main_loop");

          __CPROVER_DUMP_L28:
            ;
            goto __CPROVER_DUMP_L28;
          }

          close(buf_fd);
        }
        break;
      }
      case XNBD_PROXY_CMD_DETECT_SWITCH:
      {
        close_wrk_fd = 0;
        break;
      }
      case XNBD_PROXY_CMD_UNKNOWN:

      default:
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "unknown proxy cmd %d (wrk_fd %d)", cmd, wrk_fd);
        while((_Bool)0);
    }
    if(!(close_wrk_fd == 0))
      close(wrk_fd);

  }

  _Bool tmp_if_expr_13;
  if(!((8256 & (signed int)eventfds[1l].revents) == 0))
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "mainloop exit is requested");
    while((_Bool)0);
    unsigned int remaining_sessions;
    remaining_sessions=g_list_length(conn_list);
    if(remaining_sessions >= 1u)
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "terminate %u xnbd-bgctl session(s)", remaining_sessions);
      while((_Bool)0);

    if(!(proxy->cur_use_buf == 0ul))
      tmp_if_expr_13 = (_Bool)1;

    else
      tmp_if_expr_13 = proxy->cur_use_que != (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_13)
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "terminate pending requests");
      while((_Bool)0);

    return -1;
  }

  else
  {
    unsigned long int i = (unsigned long int)2;
    for( ; !(i >= neventfds); i = i + 1ul)
      if(!((8256 & (signed int)eventfds[(signed long int)i].revents) == 0))
      {
        signed int pipe_read_fd = eventfds[(signed long int)i].fd;
        struct proxy_session *ps;
        ps=get_session_from_read_fd(conn_list, pipe_read_fd);
        do
          if(ps == ((struct proxy_session *)NULL))
            g_assertion_message_expr((char *)0, "xnbd_proxy.c", 715, (const char *)"main_loop", "ps");

        while((_Bool)0);
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "cleanup proxy_session (nbd_fd %d wrk_fd %d)", ps->nbd_fd, ps->wrk_fd);
        while((_Bool)0);
        pthread_join(ps->tid_rx, (void **)(void *)0);
        pthread_join(ps->tid_tx, (void **)(void *)0);
        do
        {
          signed int return_value_g_async_queue_length_14;
          return_value_g_async_queue_length_14=g_async_queue_length(ps->tx_queue);
          if(!(return_value_g_async_queue_length_14 == 0))
            g_assertion_message_expr((char *)0, "xnbd_proxy.c", 730, (const char *)"main_loop", "g_async_queue_length(ps->tx_queue) == 0");

        }
        while((_Bool)0);
        g_async_queue_unref(ps->tx_queue);
        close(ps->pipe_read_fd);
        close(ps->pipe_write_fd);
        close(ps->nbd_fd);
        signed long int return_value_write_15;
        return_value_write_15=write(ps->wrk_fd, (const void *)"", (unsigned long int)1);
        ret = (signed int)return_value_write_15;
        if(!(ret >= 0))
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "notifying the worker process failed: %m");
          while((_Bool)0);

        close(ps->wrk_fd);
        conn_list=g_list_remove(conn_list, (const void *)ps);
        g_free((void *)ps);
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "cleanup proxy_session done");
        while((_Bool)0);
      }

    return 0;
  }
}

// make_pipe
// file lib/io.h line 61
void make_pipe(signed int *write_fd, signed int *read_fd)
{
  signed int pipefds[2l];
  signed int ret;
  ret=pipe(pipefds);
  if(ret == -1)
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) pipe, %m", return_value_pthread_self_1, (const void *)"make_pipe");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  *write_fd = pipefds[(signed long int)1];
  *read_fd = pipefds[(signed long int)0];
}

// make_sockpair
// file lib/io.h line 62
void make_sockpair(signed int *fd0, signed int *fd1)
{
  signed int sockfds[2l];
  signed int ret;
  ret=socketpair(1, 1, 0, sockfds);
  if(ret == -1)
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) socketpair, %m", return_value_pthread_self_1, (const void *)"make_sockpair");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  *fd0 = sockfds[(signed long int)0];
  *fd1 = sockfds[(signed long int)1];
}

// make_tcp_sock
// file xnbd_wrapper.c line 926
static signed int make_tcp_sock(const char *addr_or_name, const char *port)
{
  signed int tcp_sock;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *rp;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_socktype = 1;
  hints.ai_flags = 0x0001;
  signed int error;
  error=getaddrinfo(addr_or_name, port, &hints, &res);
  if(!(error == 0))
  {
    do
    {
      const char *return_value_gai_strerror_1;
      return_value_gai_strerror_1=gai_strerror(error);
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "%s: %s", port, return_value_gai_strerror_1);
    }
    while((_Bool)0);
    return -1;
  }

  else
  {
    rp = res;
    for( ; !(rp == ((struct addrinfo *)NULL)); rp = rp->ai_next)
    {
      tcp_sock=socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
      if(!(tcp_sock == -1))
        break;

    }
    if(rp == ((struct addrinfo *)NULL))
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "rp is NULL\n");
      while((_Bool)0);
      return -1;
    }

    else
    {
      signed int optval = 1;
      signed int return_value_setsockopt_2;
      return_value_setsockopt_2=setsockopt(tcp_sock, 1, 2, (const void *)&optval, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_2 == 0))
      {
        perror("setsockopt");
        return -1;
      }

      else
      {
        signed int return_value_bind_3;
        return_value_bind_3=bind(tcp_sock, rp->ai_addr, rp->ai_addrlen);
        if(!(return_value_bind_3 == 0))
        {
          perror("bind");
          return -1;
        }

        else
        {
          freeaddrinfo(res);
          signed int return_value_listen_4;
          return_value_listen_4=listen(tcp_sock, 64);
          if(!(return_value_listen_4 == 0))
          {
            perror("listen");
            return -1;
          }

          else
            return tcp_sock;
        }
      }
    }
  }
}

// make_unix_sock
// file xnbd_wrapper.c line 570
static signed int make_unix_sock(const char *uxsock_path)
{
  signed int uxsock;
  uxsock=socket(1, 1, 0);
  if(uxsock == -1)
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "socket(AF_UNIX): %m");
    while((_Bool)0);
    return -1;
  }

  else
  {
    struct sockaddr_un ux_saddr;
    strcpy(ux_saddr.sun_path, uxsock_path);
    ux_saddr.sun_family = (unsigned short int)1;
    signed int return_value_bind_1;
    return_value_bind_1=bind(uxsock, &ux_saddr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
    if(!(return_value_bind_1 == 0))
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "bind(AF_UNIX), socket \"%s\": %m", uxsock_path);
      while((_Bool)0);
      return -2;
    }

    else
    {
      signed int return_value_listen_2;
      return_value_listen_2=listen(uxsock, 8);
      if(!(return_value_listen_2 == 0))
      {
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "listen(AF_UNIX), socket \"%s\": %m", uxsock_path);
        while((_Bool)0);
        return -3;
      }

      else
        return uxsock;
    }
  }
}

// mark_proxy_mode_ended
// file xnbd_wrapper.c line 292
static void mark_proxy_mode_ended(const char *local_exportname)
{
  pthread_mutex_lock(&mutex);
  struct _t_disk_data *p_disk_data;
  void *return_value_g_hash_table_lookup_1;
  return_value_g_hash_table_lookup_1=g_hash_table_lookup(p_disk_dict, (const void *)local_exportname);
  p_disk_data = (struct _t_disk_data *)return_value_g_hash_table_lookup_1;
  if(!(p_disk_data == ((struct _t_disk_data *)NULL)))
  {
    do
    {
      g_free((void *)p_disk_data->proxy.target_host);
      p_disk_data->proxy.target_host = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      g_free((void *)p_disk_data->proxy.target_port);
      p_disk_data->proxy.target_port = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      g_free((void *)p_disk_data->proxy.bitmap_image);
      p_disk_data->proxy.bitmap_image = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      g_free((void *)p_disk_data->proxy.control_socket_path);
      p_disk_data->proxy.control_socket_path = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      g_free((void *)p_disk_data->proxy.target_exportname);
      p_disk_data->proxy.target_exportname = (char *)(void *)0;
    }
    while((_Bool)0);
  }

  pthread_mutex_unlock(&mutex);
}

// mem_usage_add
// file xnbd_proxy.c line 112
static void mem_usage_add(struct xnbd_proxy *proxy, struct proxy_priv *priv)
{
  _Bool tmp_if_expr_1;
  do
  {
    if(!(priv->write_buff == ((char *)NULL)))
      tmp_if_expr_1 = priv->read_buff != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      g_assertion_message_expr((char *)0, "xnbd_proxy.c", 115, (const char *)"mem_usage_add", "(priv->write_buff != NULL && priv->read_buff != NULL) == false");

  }
  while((_Bool)0);
  g_mutex_lock(&proxy->curr_use_mutex);
  _Bool tmp_if_expr_2;
  if(!(proxy->xnbd->proxy_max_buf_size == 0ul))
  {
    proxy->cur_use_buf = proxy->cur_use_buf + sizeof(struct proxy_priv) /*624ul*/ ;
    if(!(priv->write_buff == ((char *)NULL)))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = priv->read_buff != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      proxy->cur_use_buf = proxy->cur_use_buf + priv->iolen;

  }

  if(!(proxy->xnbd->proxy_max_que_size == 0ul))
    proxy->cur_use_que = proxy->cur_use_que + (unsigned long int)1;

  g_mutex_unlock(&proxy->curr_use_mutex);
}

// mem_usage_del
// file xnbd_proxy.c line 170
static void mem_usage_del(struct xnbd_proxy *proxy, struct proxy_priv *priv)
{
  g_mutex_lock(&proxy->curr_use_mutex);
  _Bool tmp_if_expr_1;
  if(!(proxy->xnbd->proxy_max_buf_size == 0ul))
  {
    proxy->cur_use_buf = proxy->cur_use_buf - sizeof(struct proxy_priv) /*624ul*/ ;
    if(!(priv->write_buff == ((char *)NULL)))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = priv->read_buff != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      proxy->cur_use_buf = proxy->cur_use_buf - priv->iolen;

  }

  if(!(proxy->xnbd->proxy_max_que_size == 0ul))
    proxy->cur_use_que = proxy->cur_use_que - (unsigned long int)1;

  g_mutex_unlock(&proxy->curr_use_mutex);
}

// mem_usage_wait
// file xnbd_proxy.c line 134
static void mem_usage_wait(struct xnbd_proxy *proxy)
{
  do
  {
    _Bool mem_is_full = (_Bool)0;
    _Bool queue_is_full = (_Bool)0;
    g_mutex_lock(&proxy->curr_use_mutex);
    if(!(proxy->xnbd->proxy_max_buf_size == 0ul))
    {
      if(!(proxy->xnbd->proxy_max_buf_size >= proxy->cur_use_buf))
        mem_is_full = (_Bool)1;

    }

    if(!(proxy->xnbd->proxy_max_que_size == 0ul))
    {
      if(!(proxy->xnbd->proxy_max_que_size >= proxy->cur_use_que))
        queue_is_full = (_Bool)1;

    }

    g_mutex_unlock(&proxy->curr_use_mutex);
    if(mem_is_full == (_Bool)0 && queue_is_full == (_Bool)0)
      break;

    if(!(mem_is_full == (_Bool)0))

      __CPROVER_DUMP_L5:
        ;

    if(!(queue_is_full == (_Bool)0))

      __CPROVER_DUMP_L7:
        ;

    usleep((unsigned int)(200 * 1000));
  }
  while((_Bool)1);
}

// mmap_iorange
// file xnbd_common.c line 107
void * mmap_iorange(const signed long int disksize, const _Bool readonly, const signed int fd, const signed long int iofrom, const unsigned long int iolen, char **mmaped_buf, unsigned long int *mmaped_len, signed long int *mmaped_offset)
{
  unsigned long int index_start;
  unsigned long int index_end;
  char *buf;
  get_io_range_index(iofrom, iolen, &index_start, &index_end);
  signed long int mapping_start = (signed long int)index_start * (signed long int)CBLOCKSIZE;
  unsigned long int mapping_length = ((index_end - index_start) + (unsigned long int)1) * (unsigned long int)CBLOCKSIZE;
  if(!(disksize >= mapping_start + (signed long int)mapping_length))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) exceed disksize", return_value_pthread_self_1, (const void *)"mmap_iorange");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  void *return_value_mmap_2;
  void *return_value_mmap_3;
  if(!(readonly == (_Bool)0))
  {
    return_value_mmap_2=mmap((void *)0, mapping_length, 0x1, 0x01, fd, mapping_start);
    buf = (char *)return_value_mmap_2;
  }

  else
  {
    return_value_mmap_3=mmap((void *)0, mapping_length, 0x1 | 0x2, 0x01, fd, mapping_start);
    buf = (char *)return_value_mmap_3;
  }
  if(buf == (char *)-1)
  {
    unsigned long int return_value_pthread_self_4;
    return_value_pthread_self_4=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) disk mapping failed (iofrom %ju iolen %zu), %m", return_value_pthread_self_4, (const void *)"mmap_iorange", iofrom, iolen);

  __CPROVER_DUMP_L7:
    ;
    goto __CPROVER_DUMP_L7;
  }

  *mmaped_buf = buf;
  *mmaped_len = mapping_length;
  *mmaped_offset = mapping_start;
  char *iobuf = buf + (iofrom - mapping_start);
  return (void *)iobuf;
}

// mmap_partial_map
// file xnbd_common.c line 38
struct mmap_partial * mmap_partial_map(signed int fd, signed long int iofrom, const unsigned long int iolen_in, signed int readonly)
{
  const signed long int iolen = (const signed long int)iolen_in;
  unsigned long int mmap_length;
  signed long int iofrom_fraction = iofrom % (signed long int)PAGESIZE;
  signed long int mmap_offset = iofrom - iofrom_fraction;
  signed long int ioend_fraction = (iofrom + iolen) % (signed long int)PAGESIZE;
  if(!(ioend_fraction == 0l))
    mmap_length = (unsigned long int)((((iofrom + iolen) - ioend_fraction) + (signed long int)PAGESIZE) - mmap_offset);

  else
    mmap_length = (unsigned long int)((iofrom + iolen) - mmap_offset);
  unsigned long int inds;
  unsigned long int inde;
  calc_block_index(PAGESIZE, iofrom, iolen_in, &inds, &inde);
  if(!((signed long int)PAGESIZE * (signed long int)inds == mmap_offset))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) check failed 0: %ju, %ju", return_value_pthread_self_1, (const void *)"mmap_partial_map", (signed long int)inds * (signed long int)PAGESIZE, mmap_offset);

  __CPROVER_DUMP_L4:
    ;
    goto __CPROVER_DUMP_L4;
  }

  unsigned long int mmap_len2 = ((inde - inds) + (unsigned long int)1) * (unsigned long int)(unsigned int)PAGESIZE;
  if(!(mmap_len2 == mmap_length))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) check failed 1: %zu, %zu", return_value_pthread_self_2, (const void *)"mmap_partial_map", mmap_len2, mmap_length);

  __CPROVER_DUMP_L7:
    ;
    goto __CPROVER_DUMP_L7;
  }

  char *buf = (char *)(void *)0;
  void *return_value_mmap_3;
  void *return_value_mmap_4;
  if(!(readonly == 0))
  {
    return_value_mmap_3=mmap((void *)0, mmap_length, 0x1, 0x01, fd, mmap_offset);
    buf = (char *)return_value_mmap_3;
  }

  else
  {
    return_value_mmap_4=mmap((void *)0, mmap_length, 0x1 | 0x2, 0x01, fd, mmap_offset);
    buf = (char *)return_value_mmap_4;
  }
  if(buf == (char *)-1)
  {
    unsigned long int return_value_pthread_self_5;
    return_value_pthread_self_5=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) disk mapping failed (iofrom %ju iolen %zu), %m", return_value_pthread_self_5, (const void *)"mmap_partial_map", iofrom, iolen);

  __CPROVER_DUMP_L12:
    ;
    goto __CPROVER_DUMP_L12;
  }

  struct mmap_partial *mpinfo;
  void *return_value_g_malloc_6;
  return_value_g_malloc_6=g_malloc(sizeof(struct mmap_partial) /*32ul*/ );
  mpinfo = (struct mmap_partial *)return_value_g_malloc_6;
  mpinfo->buf = (void *)buf;
  mpinfo->len = mmap_length;
  mpinfo->offset = mmap_offset;
  mpinfo->iobuf = (void *)(buf + iofrom_fraction);
  return mpinfo;
}

// mmap_partial_unmap
// file xnbd_common.c line 89
void mmap_partial_unmap(struct mmap_partial *mpinfo)
{
  munmap_or_abort(mpinfo->buf, mpinfo->len);
  g_free((void *)mpinfo);
}

// munmap_or_abort
// file lib/io.h line 65
void munmap_or_abort(void *addr, unsigned long int len)
{
  signed int ret;
  ret=munmap(addr, len);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) munmap %m", return_value_pthread_self_1, (const void *)"munmap_or_abort");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

}

// nbd_client_recv_header
// file lib/nbd.h line 104
signed int nbd_client_recv_header(signed int remotefd)
{
  struct nbd_reply reply;

__CPROVER_DUMP_L1:
  ;
  memset((void *)&reply, 0, sizeof(struct nbd_reply) /*16ul*/ );
  signed int ret;
  ret=net_recv_all_or_error(remotefd, (void *)&reply, sizeof(struct nbd_reply) /*16ul*/ );
  if(!(ret >= 0))
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "proxy error: redirect tcp down");
    while((_Bool)0);
    return -32;
  }

  else
  {
    unsigned int return_value_ntohl_2;
    return_value_ntohl_2=ntohl(reply.magic);
    if(!(return_value_ntohl_2 == 1732535960u))
    {
      do
      {
        unsigned int return_value_ntohl_1;
        return_value_ntohl_1=ntohl(reply.magic);
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "proxy error: unknown reply magic, %x %x", reply.magic, return_value_ntohl_1);
      }
      while((_Bool)0);
      return -32;
    }

    else
    {
      unsigned long int return_value___bswap_64_4;
      return_value___bswap_64_4=__bswap_64(myhandle);
      if(!(reply.handle == return_value___bswap_64_4))
      {
        do
        {
          unsigned long int return_value___bswap_64_3;
          return_value___bswap_64_3=__bswap_64(myhandle);
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "proxy error: unknown reply handle, %ju %ju", reply.handle, return_value___bswap_64_3);
        }
        while((_Bool)0);
        return -32;
      }

      else
      {
        unsigned int error;
        error=ntohl(reply.error);
        if(!(error == 0u))
        {
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "proxy error: remote internal, reply state %d", error);
          while((_Bool)0);
          return (signed int)-error;
        }

        else
          return 0;
      }
    }
  }
}

// nbd_client_recv_read_reply
// file lib/nbd.h line 103
signed int nbd_client_recv_read_reply(signed int remotefd, char *buf, unsigned long int len)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(buf == ((char *)NULL))
      g_assertion_message_expr((char *)0, "nbd.c", 195, (const char *)"nbd_client_recv_read_reply", "buf");

  while((_Bool)0);
  do
    if(len >= 4294967296ul)
      g_assertion_message_expr((char *)0, "nbd.c", 196, (const char *)"nbd_client_recv_read_reply", "len <= UINT32_MAX");

  while((_Bool)0);
  struct iovec iov[1l];
  iov[(signed long int)0].iov_base = (void *)buf;
  iov[(signed long int)0].iov_len = len;
  signed int return_value_nbd_client_recv_read_reply_iov_1;
  return_value_nbd_client_recv_read_reply_iov_1=nbd_client_recv_read_reply_iov(remotefd, iov, (unsigned int)1);
  return return_value_nbd_client_recv_read_reply_iov_1;
}

// nbd_client_recv_read_reply_iov
// file nbd.c line 171
signed int nbd_client_recv_read_reply_iov(signed int remotefd, struct iovec *iov, unsigned int count)
{
  signed int ret;
  ret=nbd_client_recv_header(remotefd);
  if(!(ret >= 0))
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "recv header");
    while((_Bool)0);
    return -32;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    ret=net_readv_all_or_error(remotefd, iov, count);
    if(!(ret >= 0))
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "recv data");
      while((_Bool)0);
      return -32;
    }

    else
      return 0;
  }
}

// nbd_client_send_disc_request
// file lib/nbd.h line 101
void nbd_client_send_disc_request(signed int remotefd)
{
  struct nbd_request request;
  signed int ret;
  memset((void *)&request, 0, sizeof(struct nbd_request) /*28ul*/ );
  request.magic=htonl((unsigned int)0x25609513);
  request.type=htonl((unsigned int)2);
  signed long int return_value_net_send_all_1;
  return_value_net_send_all_1=net_send_all(remotefd, (const void *)&request, sizeof(struct nbd_request) /*28ul*/ );
  ret = (signed int)return_value_net_send_all_1;
  if(!((signed long int)ret >= (signed long int)sizeof(struct nbd_request) /*28l*/ ))
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "sending NBD_DISC failed");
    while((_Bool)0);

}

// nbd_client_send_read_request
// file lib/nbd.h line 100
signed int nbd_client_send_read_request(signed int remotefd, signed long int iofrom, unsigned long int len)
{

__CPROVER_DUMP_L1:
  ;
  signed int return_value_nbd_client_send_request_header_1;
  return_value_nbd_client_send_request_header_1=nbd_client_send_request_header(remotefd, (unsigned int)0, iofrom, len, myhandle);
  return return_value_nbd_client_send_request_header_1;
}

// nbd_client_send_request_header
// file lib/nbd.h line 99
signed int nbd_client_send_request_header(signed int remotefd, unsigned int iotype, signed long int iofrom, unsigned long int len, unsigned long int handle)
{
  do
    if(len >= 4294967296ul)
      g_assertion_message_expr((char *)0, "nbd.c", 66, (const char *)"nbd_client_send_request_header", "len <= UINT32_MAX");

  while((_Bool)0);
  do
    if(len + (unsigned long int)iofrom >= 9223372036854775808ul)
      g_assertion_message_expr((char *)0, "nbd.c", 67, (const char *)"nbd_client_send_request_header", "iofrom + len <= OFF_MAX");

  while((_Bool)0);
  do
    if(!(iofrom >= 0l))
      g_assertion_message_expr((char *)0, "nbd.c", 68, (const char *)"nbd_client_send_request_header", "iofrom >= 0");

  while((_Bool)0);

__CPROVER_DUMP_L10:
  ;
  struct nbd_request request;
  memset((void *)&request, 0, sizeof(struct nbd_request) /*28ul*/ );
  request.magic=htonl((unsigned int)0x25609513);
  request.type=htonl(iotype);
  request.from=__bswap_64((unsigned long int)iofrom);
  request.len=htonl((unsigned int)len);
  request.handle=__bswap_64(handle);
  signed long int ret;
  ret=net_send_all(remotefd, (const void *)&request, sizeof(struct nbd_request) /*28ul*/ );
  if(!(ret >= (signed long int)sizeof(struct nbd_request) /*28l*/ ))
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "sending a nbd client header failed");
    while((_Bool)0);
    return -1;
  }

  else
    return 0;
}

// nbd_get_iotype_string
// file nbd.c line 26
const char * nbd_get_iotype_string(unsigned int iotype)
{
  const char *nbd_iotype_string_table[7l] = { "NBD_CMD_READ", "NBD_CMD_WRITE", "NBD_CMD_DISC", "NBD_CMD_BGCOPY", "NBD_CMD_READ_COMPRESS", "NBD_CMD_READ_COMPRESS_LZO", "NBD_CMD_UNDEFINED" };
  if((unsigned long int)iotype >= 7ul)
    return "NBD_CMD_UNDEFINED";

  else
    return nbd_iotype_string_table[(signed long int)iotype];
}

// nbd_negotiate_with_client
// file nbd.c line 573
signed int nbd_negotiate_with_client(signed int sockfd, signed long int exportsize)
{
  signed int return_value_nbd_negotiate_with_client_common_1;
  return_value_nbd_negotiate_with_client_common_1=nbd_negotiate_with_client_common(sockfd, exportsize, 0);
  return return_value_nbd_negotiate_with_client_common_1;
}

// nbd_negotiate_with_client_common
// file nbd.c line 535
static signed int nbd_negotiate_with_client_common(signed int sockfd, signed long int exportsize, signed int readonly)
{
  do
    if(!(exportsize >= 0l))
      g_assertion_message_expr((char *)0, "nbd.c", 537, (const char *)"nbd_negotiate_with_client_common", "exportsize >= 0");

  while((_Bool)0);
  signed int ret;
  struct nbd_negotiate_pdu_old pdu;
  memset((void *)&pdu, 0, sizeof(struct nbd_negotiate_pdu_old) /*152ul*/ );
  unsigned int flags = (unsigned int)(1 << 0);
  if(!(readonly == 0))
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "nbd_negotiate: readonly");
    while((_Bool)0);
    flags = flags | (unsigned int)(1 << 1);
  }

  pdu.passwd=__bswap_64(NBD_PASSWD);
  pdu.magic=__bswap_64(NBD_NEGOTIATE_MAGIC_OLD);
  pdu.size=__bswap_64((unsigned long int)exportsize);
  pdu.flags=htonl(flags);
  ret=net_send_all_or_error(sockfd, (const void *)&pdu, sizeof(struct nbd_negotiate_pdu_old) /*152ul*/ );
  if(ret >= 0)
  {

  __CPROVER_DUMP_L6:
    ;
    return 0;
  }

  else
  {
    do
    {

    err_out:
      ;
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "negotiation failed");
    }
    while((_Bool)0);
    return -1;
  }
}

// nbd_negotiate_with_client_new_phase_0
// file lib/nbd.h line 78
char * nbd_negotiate_with_client_new_phase_0(signed int sockfd)
{
  signed int ret;
  struct nbd_negotiate_pdu_new_0 pdu0;
  memset((void *)&pdu0, 0, sizeof(struct nbd_negotiate_pdu_new_0) /*18ul*/ );
  pdu0.passwd=__bswap_64(NBD_PASSWD);
  pdu0.magic=__bswap_64(NBD_NEGOTIATE_MAGIC_NEW);
  pdu0.flag16 = (unsigned short int)0;
  ret=net_send_all_or_error(sockfd, (const void *)&pdu0, sizeof(struct nbd_negotiate_pdu_new_0) /*18ul*/ );
  _Bool tmp_if_expr_3;
  unsigned int return_value_ntohl_2;
  if(ret >= 0)
  {
    struct nbd_negotiate_pdu_new_1 pdu1;
    ret=net_recv_all_or_error(sockfd, (void *)&pdu1, sizeof(struct nbd_negotiate_pdu_new_1) /*20ul*/ );
    unsigned long int return_value___bswap_64_1;
    return_value___bswap_64_1=__bswap_64(pdu1.opt_magic);
    if(!(return_value___bswap_64_1 == NBD_NEGOTIATE_MAGIC_NEW))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_ntohl_2=ntohl(pdu1.opt);
      tmp_if_expr_3 = return_value_ntohl_2 != NBD_OPT_EXPORT_NAME ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "header mismatch");
      while((_Bool)0);

    else
    {
      unsigned int namesize;
      namesize=ntohl(pdu1.namesize);
      if(namesize >= 257u)
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "namesize error");
        while((_Bool)0);

      else
      {
        char *target_name;
        void *return_value_g_malloc0_4;
        return_value_g_malloc0_4=g_malloc0((unsigned long int)(namesize + (unsigned int)1));
        target_name = (char *)return_value_g_malloc0_4;
        ret=net_recv_all_or_error(sockfd, (void *)target_name, (unsigned long int)namesize);
        if(ret >= 0)
        {
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "requested target_name %s", target_name);
          while((_Bool)0);
          return target_name;
        }

      }
    }
  }


err_out:
  ;
  return (char *)(void *)0;
}

// nbd_negotiate_with_client_new_phase_1
// file lib/nbd.h line 79
signed int nbd_negotiate_with_client_new_phase_1(signed int sockfd, signed long int exportsize, signed int readonly)
{
  do
    if(!(exportsize >= 0l))
      g_assertion_message_expr((char *)0, "nbd.c", 417, (const char *)"nbd_negotiate_with_client_new_phase_1", "exportsize >= 0");

  while((_Bool)0);
  signed int ret;
  struct nbd_negotiate_pdu_new_2 pdu2;
  memset((void *)&pdu2, 0, sizeof(struct nbd_negotiate_pdu_new_2) /*134ul*/ );
  unsigned int flags = (unsigned int)(1 << 0);
  if(!(readonly == 0))
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "nbd_negotiate: readonly");
    while((_Bool)0);
    flags = flags | (unsigned int)(1 << 1);
  }

  pdu2.size=__bswap_64((unsigned long int)exportsize);
  unsigned int return_value_htonl_1;
  return_value_htonl_1=htonl(flags);
  pdu2.flags = (unsigned short int)return_value_htonl_1;
  ret=net_send_all_or_error(sockfd, (const void *)&pdu2, sizeof(struct nbd_negotiate_pdu_new_2) /*134ul*/ );
  if(ret >= 0)
  {

  __CPROVER_DUMP_L6:
    ;
    return 0;
  }

  else
  {
    do
    {

    err_out:
      ;
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "negotiation failed");
    }
    while((_Bool)0);
    return -1;
  }
}

// nbd_negotiate_with_client_readonly
// file nbd.c line 568
signed int nbd_negotiate_with_client_readonly(signed int sockfd, signed long int exportsize)
{
  signed int return_value_nbd_negotiate_with_client_common_1;
  return_value_nbd_negotiate_with_client_common_1=nbd_negotiate_with_client_common(sockfd, exportsize, 1);
  return return_value_nbd_negotiate_with_client_common_1;
}

// nbd_negotiate_with_server
// file nbd.c line 646
signed long int nbd_negotiate_with_server(signed int sockfd)
{
  signed long int size;
  signed int ret;
  ret=nbd_negotiate_with_server2(sockfd, &size, (unsigned int *)(void *)0);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) negotiate with server", return_value_pthread_self_1, (const void *)"nbd_negotiate_with_server");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  return size;
}

// nbd_negotiate_with_server2
// file lib/nbd.h line 82
signed int nbd_negotiate_with_server2(signed int sockfd, signed long int *exportsize, unsigned int *exportflags)
{
  struct nbd_negotiate_pdu_old pdu;
  const unsigned long int passwd_plus_magic_len = sizeof(unsigned long int) /*8ul*/  + sizeof(unsigned long int) /*8ul*/ ;
  signed int ret;
  ret=net_recv_all_or_error(sockfd, (void *)&pdu, passwd_plus_magic_len);
  if(!(ret >= 0))
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "receiving negotiate header failed");
    while((_Bool)0);
    return -1;
  }

  else
  {
    unsigned long int return_value___bswap_64_1;
    return_value___bswap_64_1=__bswap_64(pdu.passwd);
    if(!(return_value___bswap_64_1 == NBD_PASSWD))
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "password mismatch");
      while((_Bool)0);
      return -1;
    }

    else
    {
      unsigned long int return_value___bswap_64_2;
      return_value___bswap_64_2=__bswap_64(pdu.magic);
      if(return_value___bswap_64_2 == NBD_NEGOTIATE_MAGIC_NEW)
      {
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "plain server expected, wrapped server found");
        while((_Bool)0);
        return -1;
      }

      else
      {
        ret=net_recv_all_or_error(sockfd, (void *)((char *)&pdu + (signed long int)passwd_plus_magic_len), sizeof(struct nbd_negotiate_pdu_old) /*152ul*/  - passwd_plus_magic_len);
        if(!(ret >= 0))
        {
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "receiving negotiate header failed");
          while((_Bool)0);
          return -1;
        }

        else
        {
          unsigned long int return_value___bswap_64_3;
          return_value___bswap_64_3=__bswap_64(pdu.magic);
          if(!(return_value___bswap_64_3 == NBD_NEGOTIATE_MAGIC_OLD))
          {
            do
              g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "negotiate magic mismatch");
            while((_Bool)0);
            return -1;
          }

          else
          {
            unsigned long int size;
            size=__bswap_64(pdu.size);
            unsigned int flags;
            flags=ntohl(pdu.flags);
            do
              g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "remote size: %ju bytes (%ju MBytes)", size, (size / (unsigned long int)1024) / (unsigned long int)1024);
            while((_Bool)0);
            if(size >= 9223372036854775808ul)
            {
              do
                g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "remote size exceeds a local off_t(%zd bytes) value", sizeof(signed long int) /*8ul*/ );
              while((_Bool)0);
              return -1;
            }

            else
            {
              *exportsize = (signed long int)size;
              if(!(exportflags == ((unsigned int *)NULL)))
                *exportflags = flags;

              return 0;
            }
          }
        }
      }
    }
  }
}

// nbd_negotiate_with_server_new
// file lib/nbd.h line 83
signed int nbd_negotiate_with_server_new(signed int sockfd, signed long int *exportsize, unsigned int *exportflags, unsigned long int namesize, const char *target_name)
{
  signed int ret;
  struct nbd_negotiate_pdu_new_0 pdu0;
  ret=net_recv_all_or_error(sockfd, (void *)&pdu0, sizeof(struct nbd_negotiate_pdu_new_0) /*18ul*/ );
  if(ret >= 0)
  {
    unsigned long int return_value___bswap_64_1;
    return_value___bswap_64_1=__bswap_64(pdu0.passwd);
    if(!(return_value___bswap_64_1 == NBD_PASSWD))
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "password mismatch");
      while((_Bool)0);
      goto err_out;
    }

    unsigned long int return_value___bswap_64_2;
    return_value___bswap_64_2=__bswap_64(pdu0.magic);
    if(return_value___bswap_64_2 == NBD_NEGOTIATE_MAGIC_OLD)
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "wrapped server expected, plain server found");
      while((_Bool)0);
      goto err_out;
    }

    unsigned long int return_value___bswap_64_3;
    return_value___bswap_64_3=__bswap_64(pdu0.magic);
    if(!(return_value___bswap_64_3 == NBD_NEGOTIATE_MAGIC_NEW))
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "negotiate magic mismatch");
      while((_Bool)0);
      goto err_out;
    }

    struct nbd_negotiate_pdu_new_1 pdu1;
    pdu1.reserved = (unsigned int)0;
    pdu1.opt_magic=__bswap_64(NBD_NEGOTIATE_MAGIC_NEW);
    pdu1.opt=htonl(NBD_OPT_EXPORT_NAME);
    pdu1.namesize=htonl((unsigned int)namesize);
    ret=net_send_all_or_error(sockfd, (const void *)&pdu1, sizeof(struct nbd_negotiate_pdu_new_1) /*20ul*/ );
    if(!(ret >= 0))
      goto err_out;

    ret=net_send_all_or_error(sockfd, (const void *)target_name, namesize);
    if(!(ret >= 0))
      goto err_out;

    struct nbd_negotiate_pdu_new_2 pdu2;
    ret=net_recv_all_or_error(sockfd, (void *)&pdu2, sizeof(struct nbd_negotiate_pdu_new_2) /*134ul*/ );
    if(!(ret >= 0))
      goto err_out;

    unsigned long int size;
    size=__bswap_64(pdu2.size);
    unsigned int flags;
    flags=ntohl((unsigned int)pdu2.flags);
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "remote size: %ju bytes (%ju MBytes)", size, (size / (unsigned long int)1024) / (unsigned long int)1024);
    while((_Bool)0);
    if(size >= 9223372036854775808ul)
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "remote size exceeds a local off_t(%zd bytes) value", sizeof(signed long int) /*8ul*/ );
      while((_Bool)0);
      return -1;
    }

    *exportsize = (signed long int)size;
    if(!(exportflags == ((unsigned int *)NULL)))
      *exportflags = flags;

    return 0;
  }

  else
  {

  err_out:
    ;
    return -1;
  }
}

// nbd_reply_dump
// file nbd.c line 55
void nbd_reply_dump(struct nbd_reply *reply)
{
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "nbd_reply %p", reply);
  while((_Bool)0);
  do
  {
    unsigned int return_value_ntohl_1;
    return_value_ntohl_1=ntohl(reply->magic);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, " reply.magic  %x %x", reply->magic, return_value_ntohl_1);
  }
  while((_Bool)0);
  do
  {
    unsigned int return_value_ntohl_2;
    return_value_ntohl_2=ntohl(reply->magic);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, " reply.error  %u %u", reply->error, return_value_ntohl_2);
  }
  while((_Bool)0);
  do
  {
    unsigned long int return_value___bswap_64_3;
    return_value___bswap_64_3=__bswap_64(reply->handle);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, " reply.handle %ju %ju", reply->handle, return_value___bswap_64_3);
  }
  while((_Bool)0);
}

// nbd_request_dump
// file nbd.c line 45
void nbd_request_dump(struct nbd_request *request)
{
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "nbd_request %p", request);
  while((_Bool)0);
  do
  {
    unsigned int return_value_ntohl_1;
    return_value_ntohl_1=ntohl(request->magic);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, " request.magic  %x %x", request->magic, return_value_ntohl_1);
  }
  while((_Bool)0);
  do
  {
    unsigned int return_value_ntohl_2;
    return_value_ntohl_2=ntohl(request->type);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, " request.type  %u %u", request->type, return_value_ntohl_2);
  }
  while((_Bool)0);
  do
  {
    unsigned long int return_value___bswap_64_3;
    return_value___bswap_64_3=__bswap_64(request->from);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, " request.from  %ju %ju", request->from, return_value___bswap_64_3);
  }
  while((_Bool)0);
  do
  {
    unsigned int return_value_ntohl_4;
    return_value_ntohl_4=ntohl(request->len);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, " request.len  %u %u", request->len, return_value_ntohl_4);
  }
  while((_Bool)0);
  do
  {
    unsigned long int return_value___bswap_64_5;
    return_value___bswap_64_5=__bswap_64(request->handle);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, " request.handle %ju %ju", request->handle, return_value___bswap_64_5);
  }
  while((_Bool)0);
}

// nbd_server_recv_request
// file lib/nbd.h line 97
signed int nbd_server_recv_request(signed int clientfd, signed long int disksize, unsigned int *iotype_arg, signed long int *iofrom_arg, unsigned long int *iolen_arg, struct nbd_reply *reply)
{
  struct nbd_request request;
  unsigned int magic = (unsigned int)0;
  unsigned int iotype = (unsigned int)0;
  unsigned long int iofrom = (unsigned long int)0;
  unsigned int iolen = (unsigned int)0;
  signed int ret;
  memset((void *)&request, 0, sizeof(struct nbd_request) /*28ul*/ );
  ret=net_recv_all_or_error(clientfd, (void *)&request, sizeof(struct nbd_request) /*28ul*/ );
  if(!(ret >= 0))
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "recv_request: peer closed or error");
    while((_Bool)0);
    return -3;
  }

  else
  {
    magic=ntohl(request.magic);
    iotype=ntohl(request.type);
    iofrom=__bswap_64(request.from);
    iolen=ntohl(request.len);
    if(iotype == 2u)
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "recv_request: disconnect request");
      while((_Bool)0);
      return -3;
    }

    else
      if(!(magic == 627086611u))
      {
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "recv_request: magic mismatch, %u %u", magic, 0x25609513);
        while((_Bool)0);
        nbd_request_dump(&request);
        dump_buffer((char *)&request, sizeof(struct nbd_request) /*28ul*/ );
        return -2;
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        reply->handle = request.handle;
        if(!((unsigned long int)disksize >= iofrom + (unsigned long int)iolen))
        {
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "error offset exceeds the end of disk, offset %ju (iofrom %ju + iolen %u) disksize %jd", iofrom + (unsigned long int)iolen, iofrom, iolen, disksize);
          while((_Bool)0);
          reply->error=htonl((unsigned int)22);
          return -1;
        }

        else
        {
          *iotype_arg = iotype;
          *iofrom_arg = (signed long int)iofrom;
          *iolen_arg = (unsigned long int)iolen;
          return 0;
        }
      }
  }
}

// net_accept
// file net.c line 157
signed int net_accept(signed int lsock)
{
  signed int csock;
  struct sockaddr_storage ss;
  unsigned int len = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  char host[1025l];
  char port[32l];
  signed int ret;
  memset((void *)&ss, 0, sizeof(struct sockaddr_storage) /*128ul*/ );
  csock=accept(lsock, (struct sockaddr *)&ss, &len);
  if(!(csock >= 0))
  {
    do
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "accept failed, fd %d, %s (%d)", csock, return_value_strerror_2, *return_value___errno_location_3);
    }
    while((_Bool)0);
    return -1;
  }

  else
  {
    ret=getnameinfo((struct sockaddr *)&ss, len, host, (unsigned int)sizeof(char [1025l]) /*1025ul*/ , port, (unsigned int)sizeof(char [32l]) /*32ul*/ , 1 | 2);
    if(!(ret == 0))
      do
      {
        const char *return_value_gai_strerror_4;
        return_value_gai_strerror_4=gai_strerror(ret);
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "getnameinfo failed, %s", return_value_gai_strerror_4);
      }
      while((_Bool)0);

    if((signed int)ss.ss_family == 2)
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "connected from %s:%s", (const void *)host, (const void *)port);
      while((_Bool)0);

    else
      if((signed int)ss.ss_family == 10)
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "connected from [%s]:%s", (const void *)host, (const void *)port);
        while((_Bool)0);

      else
        if((signed int)ss.ss_family == 1)
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "connected (unix)");
          while((_Bool)0);

        else
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "connected (unknown pf)");
          while((_Bool)0);
    return csock;
  }
}

// net_connect
// file lib/net.h line 55
signed int net_connect(const char *hostname, const char *service, signed int socktype, signed int proto)
{
  struct addrinfo hints;
  struct addrinfo *ai_head;
  signed int sockfd;
  signed int found = 0;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_socktype = socktype;
  hints.ai_protocol = proto;
  signed int ret;
  ret=getaddrinfo(hostname, service, &hints, &ai_head);
  if(!(ret == 0))
  {
    do
    {
      const char *return_value_gai_strerror_1;
      return_value_gai_strerror_1=gai_strerror(ret);
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "getaddrinfo failed, %s %s: %s", hostname, service, return_value_gai_strerror_1);
    }
    while((_Bool)0);
    return -1;
  }

  else
  {
    struct addrinfo *ai = ai_head;
    for( ; !(ai == ((struct addrinfo *)NULL)); ai = ai->ai_next)
    {
      char *nameinfo;
      nameinfo=get_nameinfo_string(ai);

    __CPROVER_DUMP_L4:
      ;
      sockfd=socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
      if(!(sockfd >= 0))
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "socket() failed, %m");
        while((_Bool)0);

      else
      {
        if(proto == 6)
        {
          net_set_nodelay(sockfd);
          net_set_keepalive(sockfd);
        }

        ret=connect(sockfd, ai->ai_addr, ai->ai_addrlen);
        if(!(ret >= 0))
        {

        __CPROVER_DUMP_L8:
          ;
          close(sockfd);
        }

        else
        {
          found = 1;
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "connected to %s", nameinfo);
          while((_Bool)0);
        }
      }

    cleanup:
      ;
      g_free((void *)nameinfo);
      if(!(found == 0))
        break;

    }
    freeaddrinfo(ai_head);
    if(!(found == 0))
      return sockfd;

    else
    {

    __CPROVER_DUMP_L13:
      ;
      return -1;
    }
  }
}

// net_create_server_sockets
// file net.c line 79
unsigned int net_create_server_sockets(struct addrinfo *ai_head, signed int *fds, unsigned long int nfds)
{
  struct addrinfo *ai;
  unsigned long int index = (unsigned long int)0;
  ai = ai_head;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  for( ; !(ai == ((struct addrinfo *)NULL)); ai = ai->ai_next)
  {
    if(index >= nfds)
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "skip other addresses");
      while((_Bool)0);
      break;
    }

    char *name;
    name=get_nameinfo_string(ai);
    signed int reuseaddr = 0;
    signed int tcpnodelay = 0;
    signed int sockfd;
    sockfd=socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
    if(!(sockfd >= 0))
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "socket(%s) failed, %m", name);
      while((_Bool)0);
      g_free((void *)name);
    }

    else
    {
      net_set_reuseaddr(sockfd);
      reuseaddr = 1;
      if(ai->ai_socktype == 1)
      {
        if(ai->ai_protocol == 6)
        {
          net_set_nodelay(sockfd);
          tcpnodelay = 1;
        }

      }

      if(ai->ai_family == 10)
        net_set_bindv6only(sockfd);

      if(sockfd >= 1024)
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "select/poll() may fail because sockfd (%d) >= FD_SETSIZE.", sockfd);
        while((_Bool)0);

      signed int ret;
      ret=bind(sockfd, ai->ai_addr, ai->ai_addrlen);
      if(!(ret >= 0))
      {
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "bind(%s) failed, %m", name);

      __CPROVER_DUMP_L11:
        ;
        goto __CPROVER_DUMP_L11;
      }

      if(ai->ai_socktype == 1)
        tmp_if_expr_1 = ai->ai_protocol == 6 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        if(ai->ai_socktype == 6)
          tmp_if_expr_2 = ai->ai_protocol == 33 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
      {
        ret=listen(sockfd, 128);
        if(!(ret >= 0))
        {
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "listen(%s) failed, %m", name);

        __CPROVER_DUMP_L20:
          ;
          goto __CPROVER_DUMP_L20;
        }

      }

      struct _GString *gs;
      gs=g_string_new((const char *)(void *)0);
      g_string_append_printf(gs, "server %s,fd=%d", name, sockfd);
      if(!(reuseaddr == 0))
        g_string_append(gs, ",reuseaddr");

      if(!(tcpnodelay == 0))
        g_string_append(gs, ",nodelay");

      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "%s", gs->str);
      while((_Bool)0);
      g_string_free(gs, (signed int)!(0 != 0));
      fds[(signed long int)index] = sockfd;
      index = index + 1ul;
      g_free((void *)name);
    }
  }
  if(index == 0ul)
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "no server sockets created");
    while((_Bool)0);

  return (unsigned int)index;
}

// net_getaddrinfo
// file net.c line 57
struct addrinfo * net_getaddrinfo(char *host, signed int port, signed int ai_family, signed int socktype, signed int proto)
{
  signed int ret;
  struct addrinfo hints;
  struct addrinfo *ai_head;
  char portstr[32l];
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = ai_family;
  hints.ai_socktype = socktype;
  hints.ai_flags = 0x0001;
  hints.ai_protocol = proto;
  snprintf(portstr, sizeof(char [32l]) /*32ul*/ , "%d", port);
  ret=getaddrinfo(host, portstr, &hints, &ai_head);
  if(!(ret == 0))
  {
    const char *return_value_gai_strerror_1;
    return_value_gai_strerror_1=gai_strerror(ret);
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "getaddrinfo() failed %s: %s", (const void *)portstr, return_value_gai_strerror_1);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  return ai_head;
}

// net_iov_all
// file net.c line 331
static signed int net_iov_all(signed int fd, struct iovec *iov, signed int count, signed int reading)
{
  signed int next_count = count;
  struct iovec *next_iov = iov;
  const char *mode = reading != 0 ? "readv" : "writev";
  signed long int total = (signed long int)0;
  signed int *return_value___errno_location_4;
  do
  {
    signed long int sent = (signed long int)0;
    signed int expected = 0;
    signed int do_next = 0;

  __CPROVER_DUMP_L2:
    ;
    if(!(reading == 0))
      sent=readv(fd, next_iov, next_count);

    else
      sent=writev(fd, next_iov, next_count);
    if(sent == 0l)
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "%s() returned 0 (fd %d)", mode, fd);
      while((_Bool)0);
      return (signed int)total;
    }

    if(sent == -1l)
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      if(*return_value___errno_location_5 == 104)
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "received TCP_RST (fd %d)", fd);
        while((_Bool)0);

      else
      {
        return_value___errno_location_4=__errno_location();
        if(*return_value___errno_location_4 == 32)
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "raised EPIPE (fd %d)", fd);
          while((_Bool)0);

        else
          do
          {
            signed int *return_value___errno_location_1;
            return_value___errno_location_1=__errno_location();
            char *return_value_strerror_2;
            return_value_strerror_2=strerror(*return_value___errno_location_1);
            signed int *return_value___errno_location_3;
            return_value___errno_location_3=__errno_location();
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "%s error %s (%d) (fd %d)", mode, return_value_strerror_2, *return_value___errno_location_3, fd);
          }
          while((_Bool)0);
      }
      return -1;
    }

    total = total + sent;
    signed int i = 0;
    for( ; !(i >= next_count); i = i + 1)
    {
      expected = expected + (signed int)(next_iov + (signed long int)i)->iov_len;
      if(!(sent >= (signed long int)expected))
      {

      __CPROVER_DUMP_L14:
        ;
        signed int rest_in_block = (signed int)((signed long int)expected - sent);
        signed int sent_in_block = (signed int)((next_iov + (signed long int)i)->iov_len - (unsigned long int)rest_in_block);
        (next_iov + (signed long int)i)->iov_base = (void *)((char *)(next_iov + (signed long int)i)->iov_base + (signed long int)sent_in_block);
        (next_iov + (signed long int)i)->iov_len = (unsigned long int)rest_in_block;
        next_iov = &next_iov[(signed long int)i];
        next_count = next_count - i;
        do_next = 1;
        break;
      }

    }
    if(do_next == 0)
      break;

  }
  while((_Bool)1);

__CPROVER_DUMP_L17:
  ;
  return (signed int)total;
}

// net_readv_all
// file net.c line 456
signed int net_readv_all(signed int fd, struct iovec *iov, signed int count)
{

__CPROVER_DUMP_L1:
  ;
  signed int return_value_net_iov_all_1;
  return_value_net_iov_all_1=net_iov_all(fd, iov, count, 1);
  return return_value_net_iov_all_1;
}

// net_readv_all_or_abort
// file lib/net.h line 70
void net_readv_all_or_abort(signed int fd, struct iovec *iov, unsigned int count)
{
  unsigned long int bufflen = (unsigned long int)0;
  unsigned int i = (unsigned int)0;
  for( ; !(i >= count); i = i + 1u)
    bufflen = bufflen + (iov + (signed long int)i)->iov_len;
  signed int ret;
  ret=net_readv_all(fd, iov, (signed int)count);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  signed int return_value_check_fin_3;
  return_value_check_fin_3=check_fin(ret, *return_value___errno_location_2, bufflen);
  if(!(return_value_check_fin_3 == 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) sockfd (%d) closed", return_value_pthread_self_1, (const void *)"net_readv_all_or_abort", fd);

  __CPROVER_DUMP_L4:
    ;
    goto __CPROVER_DUMP_L4;
  }

}

// net_readv_all_or_error
// file net.h line 71
signed int net_readv_all_or_error(signed int fd, struct iovec *iov, unsigned int count)
{
  unsigned long int bufflen = (unsigned long int)0;
  unsigned int i = (unsigned int)0;
  for( ; !(i >= count); i = i + 1u)
    bufflen = bufflen + (iov + (signed long int)i)->iov_len;
  signed int ret;
  ret=net_readv_all(fd, iov, (signed int)count);
  if(!(ret == (signed int)bufflen))
    return -1;

  else
    return ret;
}

// net_recv_all
// file net.c line 472
signed long int net_recv_all(signed int sockfd, void *buff, unsigned long int bufflen)
{
  struct iovec iov[1l];
  iov[(signed long int)0].iov_base = buff;
  iov[(signed long int)0].iov_len = bufflen;
  signed int return_value_net_iov_all_1;
  return_value_net_iov_all_1=net_iov_all(sockfd, iov, 1, 1);
  return (signed long int)return_value_net_iov_all_1;
}

// net_recv_all_or_abort
// file lib/net.h line 61
void net_recv_all_or_abort(signed int sockfd, void *buff, unsigned long int bufflen)
{
  signed int ret;
  signed long int return_value_net_recv_all_1;
  return_value_net_recv_all_1=net_recv_all(sockfd, buff, bufflen);
  ret = (signed int)return_value_net_recv_all_1;
  signed int *return_value___errno_location_3;
  return_value___errno_location_3=__errno_location();
  signed int return_value_check_fin_4;
  return_value_check_fin_4=check_fin(ret, *return_value___errno_location_3, bufflen);
  if(!(return_value_check_fin_4 == 0))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) sockfd (%d) closed", return_value_pthread_self_2, (const void *)"net_recv_all_or_abort", sockfd);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

}

// net_recv_all_or_error
// file lib/net.h line 62
signed int net_recv_all_or_error(signed int sockfd, void *buff, unsigned long int bufflen)
{
  signed int ret;
  signed long int return_value_net_recv_all_1;
  return_value_net_recv_all_1=net_recv_all(sockfd, buff, bufflen);
  ret = (signed int)return_value_net_recv_all_1;
  if(!(ret == (signed int)bufflen))
    return -1;

  else
    return ret;
}

// net_send_all
// file net.h line 64
signed long int net_send_all(signed int sockfd, const void *buff, unsigned long int bufflen)
{
  struct iovec iov[1l];
  iov[(signed long int)0].iov_base = (void *)buff;
  iov[(signed long int)0].iov_len = bufflen;
  signed int return_value_net_iov_all_1;
  return_value_net_iov_all_1=net_iov_all(sockfd, iov, 1, 0);
  return (signed long int)return_value_net_iov_all_1;
}

// net_send_all_or_abort
// file lib/net.h line 65
void net_send_all_or_abort(signed int sockfd, const void *buff, unsigned long int bufflen)
{
  signed int ret;
  signed long int return_value_net_send_all_1;
  return_value_net_send_all_1=net_send_all(sockfd, buff, bufflen);
  ret = (signed int)return_value_net_send_all_1;
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  check_done(ret, *return_value___errno_location_2);
}

// net_send_all_or_error
// file lib/net.h line 66
signed int net_send_all_or_error(signed int sockfd, const void *buff, unsigned long int bufflen)
{
  signed int ret;
  signed long int return_value_net_send_all_1;
  return_value_net_send_all_1=net_send_all(sockfd, buff, bufflen);
  ret = (signed int)return_value_net_send_all_1;
  if(!(ret == (signed int)bufflen))
    return -1;

  else
    return ret;
}

// net_set_bindv6only
// file net.c line 216
signed int net_set_bindv6only(signed int sockfd)
{
  const signed int val = 1;
  signed int ret;
  ret=setsockopt(sockfd, 41, 26, (const void *)&val, (unsigned int)sizeof(const signed int) /*4ul*/ );
  if(!(ret >= 0))
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "setsockopt IPV6_V6ONLY failed");
    while((_Bool)0);

  return ret;
}

// net_set_keepalive
// file net.c line 228
signed int net_set_keepalive(signed int sockfd)
{
  const signed int val = 1;
  signed int ret;
  ret=setsockopt(sockfd, 1, 9, (const void *)&val, (unsigned int)sizeof(const signed int) /*4ul*/ );
  if(!(ret >= 0))
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "setsockopt SO_KEEPALIVE failed");
    while((_Bool)0);

  return ret;
}

// net_set_nodelay
// file net.c line 204
signed int net_set_nodelay(signed int sockfd)
{
  const signed int val = 1;
  signed int ret;
  ret=setsockopt(sockfd, 6, 1, (const void *)&val, (unsigned int)sizeof(const signed int) /*4ul*/ );
  if(!(ret >= 0))
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "setsockopt TCP_NODELAY failed");
    while((_Bool)0);

  return ret;
}

// net_set_reuseaddr
// file net.c line 192
signed int net_set_reuseaddr(signed int sockfd)
{
  const signed int val = 1;
  signed int ret;
  ret=setsockopt(sockfd, 1, 2, (const void *)&val, (unsigned int)sizeof(const signed int) /*4ul*/ );
  if(!(ret >= 0))
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "setsockopt SO_REUSEADDR failed");
    while((_Bool)0);

  return ret;
}

// net_writev_all
// file net.c line 450
signed int net_writev_all(signed int fd, struct iovec *iov, signed int count)
{

__CPROVER_DUMP_L1:
  ;
  signed int return_value_net_iov_all_1;
  return_value_net_iov_all_1=net_iov_all(fd, iov, count, 0);
  return return_value_net_iov_all_1;
}

// net_writev_all_or_abort
// file lib/net.h line 68
void net_writev_all_or_abort(signed int fd, struct iovec *iov, unsigned int count)
{
  signed int ret;
  ret=net_writev_all(fd, iov, (signed int)count);
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  check_done(ret, *return_value___errno_location_1);
}

// net_writev_all_or_error
// file lib/net.h line 69
signed int net_writev_all_or_error(signed int fd, struct iovec *iov, unsigned int count)
{
  unsigned long int bufflen = (unsigned long int)0;
  unsigned int i = (unsigned int)0;
  for( ; !(i >= count); i = i + 1u)
    bufflen = bufflen + (iov + (signed long int)i)->iov_len;
  signed int ret;
  ret=net_writev_all(fd, iov, (signed int)count);
  if(!(ret == (signed int)bufflen))
    return -1;

  else
    return ret;
}

// perform_shutdown
// file xnbd_wrapper.c line 411
static void perform_shutdown(struct _IO_FILE *fp)
{
  pthread_mutex_lock(&mutex);
  g_hash_table_destroy(p_disk_dict);
  pthread_mutex_unlock(&mutex);
  fprintf(fp, "All images terminated\n");
  kill(0, 15);
}

// poll_data_and_event
// file io.c line 317
signed int poll_data_and_event(signed int datafd, signed int event_listener_fd)
{
  signed int return_value_wait_until_readable_1;
  return_value_wait_until_readable_1=wait_until_readable(datafd, event_listener_fd);
  return return_value_wait_until_readable_1;
}

// poll_request_arrival
// file xnbd_common.c line 155
signed int poll_request_arrival(struct xnbd_session *ses)
{
  signed int return_value_wait_until_readable_1;
  return_value_wait_until_readable_1=wait_until_readable(ses->clientfd, ses->pipe_worker_fd);
  return return_value_wait_until_readable_1;
}

// prepare_read_priv
// file xnbd_proxy_forwarder.c line 82
void prepare_read_priv(struct xnbd_proxy *proxy, struct proxy_priv *priv)
{
  unsigned long int block_index_start = priv->block_index_start;
  unsigned long int block_index_end = priv->block_index_end;
  unsigned long int i = block_index_start;
  for( ; block_index_end >= i; i = i + 1ul)
  {
    cachestat_read_block();
    signed int return_value_bitmap_test_1;
    return_value_bitmap_test_1=bitmap_test(proxy->cbitmap, i);
    if(return_value_bitmap_test_1 == 0)
    {
      bitmap_on(proxy->cbitmap, i);
      cachestat_miss();
      cachestat_cache_odread();
      add_read_block_to_tail(priv, i);
    }

    else
      cachestat_hit();
  }
}

// prepare_write_priv
// file xnbd_proxy_forwarder.c line 113
void prepare_write_priv(struct xnbd_proxy *proxy, struct proxy_priv *priv)
{
  unsigned long int block_index_start = priv->block_index_start;
  unsigned long int block_index_end = priv->block_index_end;
  signed long int iofrom = priv->iofrom;
  unsigned long int iolen = priv->iolen;
  signed int get_start_block = 0;
  signed int get_end_block = 0;
  signed int return_value_bitmap_test_1;
  if(!(iofrom % (signed long int)CBLOCKSIZE == 0l))
  {
    return_value_bitmap_test_1=bitmap_test(proxy->cbitmap, block_index_start);
    if(return_value_bitmap_test_1 == 0)
      get_start_block = 1;

  }

  signed int return_value_bitmap_test_2;
  if(!((iolen + (unsigned long int)iofrom) % (unsigned long int)CBLOCKSIZE == 0ul))
  {
    if(get_start_block == 0 && block_index_end == block_index_start || !(block_index_start >= block_index_end))
    {
      return_value_bitmap_test_2=bitmap_test(proxy->cbitmap, block_index_end);
      if(return_value_bitmap_test_2 == 0)
        get_end_block = 1;

    }

  }

  unsigned long int i = block_index_start;
  for( ; block_index_end >= i; i = i + 1ul)
  {
    cachestat_write_block();
    signed int return_value_bitmap_test_3;
    return_value_bitmap_test_3=bitmap_test(proxy->cbitmap, i);
    if(return_value_bitmap_test_3 == 0)
    {
      bitmap_on(proxy->cbitmap, i);
      cachestat_cache_odwrite();
    }

  }
  if(!(get_start_block == 0))
  {
    do
      if(1 + priv->nreq >= 33)
        g_assertion_message_expr((char *)0, "xnbd_proxy_forwarder.c", 168, (const char *)"prepare_write_priv", "priv->nreq + 1 <= MAXNBLOCK");

    while((_Bool)0);
    signed int cur_nreq = priv->nreq;
    priv->req[(signed long int)cur_nreq].bindex_iofrom = (signed long int)block_index_start;
    priv->req[(signed long int)cur_nreq].bindex_iolen = (unsigned long int)1;
    priv->nreq = priv->nreq + 1;
    cachestat_miss();
  }

  else
    cachestat_hit();
  if(!(get_end_block == 0))
  {
    do
      if(1 + priv->nreq >= 33)
        g_assertion_message_expr((char *)0, "xnbd_proxy_forwarder.c", 181, (const char *)"prepare_write_priv", "priv->nreq + 1 <= MAXNBLOCK");

    while((_Bool)0);
    signed int prepare_write_priv__1__4__cur_nreq = priv->nreq;
    priv->req[(signed long int)prepare_write_priv__1__4__cur_nreq].bindex_iofrom = (signed long int)block_index_end;
    priv->req[(signed long int)prepare_write_priv__1__4__cur_nreq].bindex_iolen = (unsigned long int)1;
    priv->nreq = priv->nreq + 1;
    cachestat_miss();
  }

  else
    cachestat_hit();
}

// proxy_initialize
// file xnbd_proxy.c line 355
void proxy_initialize(struct xnbd_info *xnbd, struct xnbd_proxy *proxy)
{
  proxy->xnbd = xnbd;
  proxy->fwd_tx_queue=g_async_queue_new();
  proxy->fwd_rx_queue=g_async_queue_new();
  proxy->fwd_retry_queue=g_async_queue_new();
  proxy->cbitmap=bitmap_open_file(xnbd->proxy_bmpath, xnbd->nblocks, &proxy->cbitmaplen, 0, xnbd->proxy_clear_bitmap != (_Bool)0 ? 1 : 0);
  signed int cachefd;
  cachefd=open(xnbd->proxy_diskpath, 02 | 0100 | 01000000, 0400 | 0200);
  if(!(cachefd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open", return_value_pthread_self_1, (const void *)"proxy_initialize");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  signed long int size;
  size=get_disksize(cachefd);
  if(!(size == xnbd->disksize))
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "cache disk size (%ju) != target disk size (%ju)", size, xnbd->disksize);
    while((_Bool)0);
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "now ftruncate() it");
    while((_Bool)0);
    signed int ret;
    ret=ftruncate(cachefd, xnbd->disksize);
    if(!(ret >= 0))
    {
      unsigned long int return_value_pthread_self_2;
      return_value_pthread_self_2=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) ftruncate", return_value_pthread_self_2, (const void *)"proxy_initialize");

    __CPROVER_DUMP_L7:
      ;
      goto __CPROVER_DUMP_L7;
    }

  }

  proxy->cachefd = cachefd;
  g_mutex_init(&proxy->curr_use_mutex);
  proxy->cur_use_buf = (unsigned long int)0;
  proxy->cur_use_que = (unsigned long int)0;
}

// proxy_initialize_forwarder
// file xnbd_proxy.c line 324
void proxy_initialize_forwarder(struct xnbd_proxy *proxy, signed int remotefd)
{
  proxy->remotefd = remotefd;
  proxy->tid_fwd_rx=pthread_create_or_abort(forwarder_rx_thread_main, (void *)proxy);
  proxy->tid_fwd_tx=pthread_create_or_abort(forwarder_tx_thread_main, (void *)proxy);
}

// proxy_priv_dump
// file xnbd_proxy.h line 139
void proxy_priv_dump(struct proxy_priv *priv)
{

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;

__CPROVER_DUMP_L3:
  ;

__CPROVER_DUMP_L4:
  ;

__CPROVER_DUMP_L5:
  ;

__CPROVER_DUMP_L6:
  ;

__CPROVER_DUMP_L7:
  ;

__CPROVER_DUMP_L8:
  ;
  signed int i = 0;
  for( ; !(i >= priv->nreq); i = i + 1)
  {

  __CPROVER_DUMP_L10:
    ;

  __CPROVER_DUMP_L11:
    ;
  }

__CPROVER_DUMP_L13:
  ;

__CPROVER_DUMP_L14:
  ;

__CPROVER_DUMP_L15:
  ;

__CPROVER_DUMP_L16:
  ;

__CPROVER_DUMP_L17:
  ;

__CPROVER_DUMP_L18:
  ;

__CPROVER_DUMP_L19:
  ;
}

// proxy_shutdown
// file xnbd_proxy.c line 388
void proxy_shutdown(struct xnbd_proxy *proxy)
{
  g_mutex_clear(&proxy->curr_use_mutex);
  _Bool tmp_if_expr_1;
  if(!(proxy->cur_use_buf == 0ul))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = proxy->cur_use_que != (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "cur_use_buf %zu cur_use_que %zu", proxy->cur_use_buf, proxy->cur_use_que);
    while((_Bool)0);

  g_async_queue_unref(proxy->fwd_retry_queue);
  g_async_queue_unref(proxy->fwd_tx_queue);
  g_async_queue_unref(proxy->fwd_rx_queue);
  if(!(proxy->shared_buff == ((char *)NULL)))
    munmap_or_abort((void *)proxy->shared_buff, (unsigned long int)(CBLOCKSIZE * (unsigned int)1000));

  close(proxy->cachefd);
  bitmap_close_file(proxy->cbitmap, proxy->cbitmaplen);
}

// proxy_shutdown_forwarder
// file xnbd_proxy.c line 331
void proxy_shutdown_forwarder(struct xnbd_proxy *proxy)
{
  g_async_queue_push(proxy->fwd_tx_queue, (void *)&priv_stop_forwarder);
  pthread_join(proxy->tid_fwd_tx, (void **)(void *)0);
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "forwarder_tx exited");
  while((_Bool)0);
  pthread_join(proxy->tid_fwd_rx, (void **)(void *)0);
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "forwarder_rx exited");
  while((_Bool)0);
}

// pthread_create_or_abort
// file lib/io.h line 44
unsigned long int pthread_create_or_abort(void * (*start_routine)(void *), void *arg)
{
  unsigned long int tid;
  signed int ret;
  ret=pthread_create(&tid, (const union pthread_attr_t *)(void *)0, start_routine, arg);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) create thread", return_value_pthread_self_1, (const void *)"pthread_create_or_abort");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  return tid;
}

// put_line
// file io.c line 250
signed int put_line(signed int fd, const char *msg)
{
  char line[100l];
  unsigned long int return_value_strnlen_1;
  return_value_strnlen_1=strnlen(msg, (unsigned long int)(100 - 2));
  if(return_value_strnlen_1 == 98ul)
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "too large msg for a line");
    while((_Bool)0);
    return -1;
  }

  else
  {
    sprintf(line, "%s\n", msg);

  __CPROVER_DUMP_L3:
    ;
    signed int ret;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(line);
    ret=net_send_all_or_error(fd, (const void *)line, return_value_strlen_2);
    if(!(ret >= 0))
      return -1;

    else
      return 0;
  }
}

// query_remote_disk_size
// file xnbd_wrapper.c line 1094
static void query_remote_disk_size(signed long int *p_disk_size_bytes, const char *host, const char *port, const char *exportname)
{
  /* assertion p_disk_size_bytes && host && port */
  assert(p_disk_size_bytes != ((signed long int *)NULL) && host != ((const char *)NULL) && port != ((const char *)NULL));
  signed int sockfd;
  sockfd=net_connect(host, port, 1, 6);
  unsigned long int return_value_strlen_1;
  if(!(sockfd >= 0))
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "cannot connect to %s(%s)", host, port);
    while((_Bool)0);

  else
  {
    signed int ret;
    if(!(exportname == ((const char *)NULL)))
    {
      return_value_strlen_1=strlen(exportname);
      ret=nbd_negotiate_with_server_new(sockfd, p_disk_size_bytes, (unsigned int *)(void *)0, return_value_strlen_1, exportname);
    }

    else
      ret=nbd_negotiate_with_server2(sockfd, p_disk_size_bytes, (unsigned int *)(void *)0);
    close(sockfd);
    if(!(ret >= 0))
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "negotiation with %s:%s failed", host, port);
      while((_Bool)0);

  }
}

// read_all
// file io.c line 59
void read_all(signed int fd, void *buf, unsigned long int len)
{
  io_all(fd, buf, len, 1);
}

// recv_request
// file xnbd_proxy.c line 189
signed int recv_request(struct proxy_session *ps)
{
  struct xnbd_proxy *proxy = ps->proxy;
  signed int nbd_client_fd = ps->nbd_fd;
  struct proxy_priv *priv;
  void *return_value_g_slice_alloc0_1;
  return_value_g_slice_alloc0_1=g_slice_alloc0(sizeof(struct proxy_priv) /*624ul*/ );
  priv = (struct proxy_priv *)return_value_g_slice_alloc0_1;
  unsigned int iotype = (unsigned int)0;
  signed long int iofrom = (signed long int)0;
  unsigned long int iolen = (unsigned long int)0;
  signed int ret = 0;
  priv->nreq = 0;
  priv->clientfd = nbd_client_fd;
  priv->tx_queue = ps->tx_queue;
  priv->reply.magic=htonl((unsigned int)0x67446698);
  priv->reply.error = (unsigned int)0;
  ret=wait_until_readable(nbd_client_fd, ps->wrk_fd);
  unsigned long int block_index_start;
  unsigned long int block_index_end;
  if(ret >= 0)
  {
    ret=nbd_server_recv_request(nbd_client_fd, proxy->xnbd->disksize, &iotype, &iofrom, &iolen, &priv->reply);
    if(ret == -1)
      goto err_handle;

    else
      if(ret == -2)
      {
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "client bug: invalid header");
        while((_Bool)0);
        goto err_handle;
      }

      else
        if(ret == -3)
          goto err_handle;


  __CPROVER_DUMP_L4:
    ;
    if(!(proxy->xnbd->readonly == 0))
    {
      if(iotype == 1u)
      {
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "NBD_CMD_WRITE to a readonly server. disconnect.");
        while((_Bool)0);
        goto err_handle;
      }

    }

    get_io_range_index(iofrom, iolen, &block_index_start, &block_index_end);

  __CPROVER_DUMP_L7:
    ;

  __CPROVER_DUMP_L8:
    ;
    priv->iotype = iotype;
    priv->iofrom = iofrom;
    priv->iolen = iolen;
    priv->block_index_start = block_index_start;
    priv->block_index_end = block_index_end;
    if(iotype == 1u)
    {
      void *return_value_g_malloc_2;
      return_value_g_malloc_2=g_malloc(iolen);
      priv->write_buff = (char *)return_value_g_malloc_2;
      ret=net_recv_all_or_error(priv->clientfd, (void *)priv->write_buff, priv->iolen);
      if(!(ret >= 0))
      {
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "recv write data");
        while((_Bool)0);
        goto err_handle;
      }

    }

    else
      if(iotype == 0u)
      {
        void *return_value_g_malloc_3;
        return_value_g_malloc_3=g_malloc(iolen);
        priv->read_buff = (char *)return_value_g_malloc_3;
      }

      else
        if(!(iotype == 3u))
        {
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "client bug: unknown iotype");
          while((_Bool)0);
          goto err_handle;
        }

    mem_usage_wait(proxy);
    mem_usage_add(proxy, priv);
    g_async_queue_push(proxy->fwd_tx_queue, (void *)priv);
    return 0;
  }

  else
  {
    do
    {

    err_handle:
      ;
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "start terminating session (nbd_fd %d wrk_fd %d)", ps->nbd_fd, ps->wrk_fd);
    }
    while((_Bool)0);
    priv->need_exit = 1;
    priv->iotype = (unsigned int)6;
    mem_usage_add(proxy, priv);
    g_async_queue_push(proxy->fwd_tx_queue, (void *)priv);
    return -1;
  }
}

// report_return_code
// file xnbd_wrapper.c line 376
static void report_return_code(struct _IO_FILE *fp, signed int code)
{
  if(!(code >= 0))
    code = 1;

  fprintf(fp, "return code %d\n", code);
  fflush(fp);
}

// rx_thread_main
// file xnbd_proxy.c line 424
void * rx_thread_main(void *arg)
{
  struct proxy_session *ps = (struct proxy_session *)arg;
  set_process_name("proxy_rx");
  block_all_signals();
  do
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "rx_thread %lu starts", return_value_pthread_self_1);
  }
  while((_Bool)0);
  do
  {
    signed int ret;
    ret=recv_request(ps);
    if(!(ret >= 0))
      break;

  }
  while((_Bool)1);
  do
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "rx_thread %lu exits", return_value_pthread_self_2);
  }
  while((_Bool)0);
  return (void *)0;
}

// set_process_name
// file lib/common.h line 95
void set_process_name(const char *name)
{
  char comm[16l];
  strncpy(comm, name, sizeof(char [16l]) /*16ul*/ );
  signed int ret;
  ret=prctl(15, (unsigned long int)comm, 0l, 0l, 0l);
  if(!(ret >= 0))
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "set_name %m");
    while((_Bool)0);

}

// sigmask_all
// file io.c line 270
void sigmask_all(void)
{
  struct anonymous_0 sig;
  signed int ret;
  ret=sigfillset(&sig);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) sigfillset", return_value_pthread_self_1, (const void *)"sigmask_all");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  ret=pthread_sigmask(2, &sig, (struct anonymous_0 *)(void *)0);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) sigmask", return_value_pthread_self_2, (const void *)"sigmask_all");

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

}

// start_filemgr_thread
// file xnbd_wrapper.c line 724
static void * start_filemgr_thread(void *pointer)
{
  struct _t_thread_data * const p_thread_data = (struct _t_thread_data *)pointer;
  const signed int rbufsize = 128 * 8;
  const signed long int rbufsize_array_size0 = (signed long int)rbufsize;
  char buf[rbufsize_array_size0];
  const signed long int buf_array_size0 = (signed long int)rbufsize;
  char cmd[buf_array_size0];
  const signed long int cmd_array_size0 = (signed long int)rbufsize;
  char arg[cmd_array_size0];
  signed int ret;
  signed int conn_uxsock;
  conn_uxsock=accept(p_thread_data->unix_sock_fd, (void *)0, (unsigned int *)(void *)0);
  if(conn_uxsock == -1)
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "accept(AF_UNIX): %m");
    while((_Bool)0);
    pthread_exit((void *)0);
  }

  struct _IO_FILE *fp;
  fp=fdopen(conn_uxsock, "r+");
  signed int return_value_count_mgr_threads_23;
  return_value_count_mgr_threads_23=count_mgr_threads(1);
  signed int return_value_strcmp_19;
  _Bool tmp_if_expr_21;
  signed int return_value_strcmp_20;
  char *tmp_if_expr_4;
  char *tmp_if_expr_5;
  signed int return_value_strcmp_18;
  char *tmp_if_expr_6;
  signed int return_value_strcmp_17;
  signed int return_value_strcmp_16;
  signed int return_value_strcmp_15;
  signed int return_value_strcmp_14;
  signed int return_value_strcmp_13;
  signed int return_value_strcmp_12;
  signed int return_value_strcmp_11;
  signed int return_value_strcmp_10;
  char *tmp_if_expr_7;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  if(MAX_CTL_CONNS >= return_value_count_mgr_threads_23)
  {
    fprintf(fp, "\"help\" command displays help for other commands\n");
    do
    {
      signed int return_value_fputs_1;
      return_value_fputs_1=fputs("(xnbd) ", fp);
      if(return_value_fputs_1 == -1)
      {
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "fputs : EOF");
        while((_Bool)0);
        break;
      }

      fflush(fp);
      char *return_value_fgets_2;
      return_value_fgets_2=fgets(buf, rbufsize, fp);
      if(return_value_fgets_2 == ((char *)NULL))
        break;

      signed int return_value_sscanf_3;
      return_value_sscanf_3=sscanf(buf, "%s%s", (const void *)cmd, (const void *)arg);
      if(return_value_sscanf_3 >= 1)
      {
        signed int return_code = 0;
        signed int return_value_strcmp_22;
        return_value_strcmp_22=strcmp(cmd, "list");
        if(return_value_strcmp_22 == 0)
          list_diskimg(fp);

        else
        {
          return_value_strcmp_19=strcmp(cmd, "add");
          if(return_value_strcmp_19 == 0)
            tmp_if_expr_21 = (_Bool)1;

          else
          {
            return_value_strcmp_20=strcmp(cmd, "add-target");
            tmp_if_expr_21 = return_value_strcmp_20 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_21)
          {
            char **start_filemgr_thread__1__2__1__1__3__argv = (char **)(void *)0;
            unsigned int start_filemgr_thread__1__2__1__1__3__argc = (unsigned int)0;
            signed int res;
            res=extract_decode_check_usage(buf, &start_filemgr_thread__1__2__1__1__3__argv, &start_filemgr_thread__1__2__1__1__3__argc, (unsigned int)2, (unsigned int)3);
            if(res == 1)
            {
              fprintf(fp, "%s\n", (const void *)"out of memory");
              return_code = 1;
            }

            else
              if(res == 2)
              {
                fprintf(fp, "usage: %s\n", (const void *)"add-target <LOCAL_EXPORTNAME> <FILE>");
                return_code = 1;
              }

              else
                if(res == 0)
                {
                  const char *file;
                  if(start_filemgr_thread__1__2__1__1__3__argc == 3u)
                    tmp_if_expr_4 = start_filemgr_thread__1__2__1__1__3__argv[(signed long int)2];

                  else
                    tmp_if_expr_4 = start_filemgr_thread__1__2__1__1__3__argv[(signed long int)1];
                  file = tmp_if_expr_4;
                  const char *exportname;
                  if(start_filemgr_thread__1__2__1__1__3__argc == 3u)
                    tmp_if_expr_5 = start_filemgr_thread__1__2__1__1__3__argv[(signed long int)1];

                  else
                    tmp_if_expr_5 = file;
                  exportname = tmp_if_expr_5;
                  struct _t_disk_data *start_filemgr_thread__1__2__1__1__3__3__p_disk_data;
                  start_filemgr_thread__1__2__1__1__3__3__p_disk_data=create_disk_data(exportname, (const char *)(void *)0, (const char *)(void *)0, file, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0);
                  if(!(start_filemgr_thread__1__2__1__1__3__3__p_disk_data == ((struct _t_disk_data *)NULL)))
                  {
                    ret=add_diskimg(start_filemgr_thread__1__2__1__1__3__3__p_disk_data);
                    if(ret == -1)
                      fprintf(fp, "cannot open %s\n", file);

                    else
                      if(ret == -4)
                        fprintf(fp, "image cannot be added twice\n");

                    return_code = ret == 0 ? 0 : 1;
                  }

                  else
                  {
                    fprintf(fp, "%s\n", (const void *)"out of memory");
                    return_code = 1;
                  }
                  g_strfreev(start_filemgr_thread__1__2__1__1__3__argv);
                }

          }

          else
          {
            return_value_strcmp_18=strcmp(cmd, "add-proxy");
            if(return_value_strcmp_18 == 0)
            {
              char **start_filemgr_thread__1__2__1__1__4__argv = (char **)(void *)0;
              unsigned int start_filemgr_thread__1__2__1__1__4__argc = (unsigned int)0;
              signed int start_filemgr_thread__1__2__1__1__4__res;
              start_filemgr_thread__1__2__1__1__4__res=extract_decode_check_usage(buf, &start_filemgr_thread__1__2__1__1__4__argv, &start_filemgr_thread__1__2__1__1__4__argc, (unsigned int)7, (unsigned int)8);
              if(start_filemgr_thread__1__2__1__1__4__res == 1)
              {
                fprintf(fp, "%s\n", (const void *)"out of memory");
                return_code = 1;
              }

              else
                if(start_filemgr_thread__1__2__1__1__4__res == 2)
                {
                  fprintf(fp, "usage: %s\n", (const void *)"add-proxy <LOCAL_EXPORTNAME> <TARGET_HOST> <TARGET_PORT> <CACHE_IMAGE> <BITMAP_IMAGE> <CONTROL_SOCKET_PATH> [<TARGET_EXPORTNAME>]");
                  return_code = 1;
                }

                else
                  if(start_filemgr_thread__1__2__1__1__4__res == 0)
                  {
                    const char * const local_exportname = start_filemgr_thread__1__2__1__1__4__argv[(signed long int)1];
                    const char * const target_host = start_filemgr_thread__1__2__1__1__4__argv[(signed long int)2];
                    const char * const target_port = start_filemgr_thread__1__2__1__1__4__argv[(signed long int)3];
                    const char * const cache_image = start_filemgr_thread__1__2__1__1__4__argv[(signed long int)4];
                    const char * const bitmap_image = start_filemgr_thread__1__2__1__1__4__argv[(signed long int)5];
                    const char * const control_socket_path = start_filemgr_thread__1__2__1__1__4__argv[(signed long int)6];
                    const char *target_exportname;
                    if(start_filemgr_thread__1__2__1__1__4__argc >= 8u)
                      tmp_if_expr_6 = start_filemgr_thread__1__2__1__1__4__argv[(signed long int)7];

                    else
                      tmp_if_expr_6 = (char *)(void *)0;
                    target_exportname = tmp_if_expr_6;
                    struct _t_disk_data *p_disk_data;
                    p_disk_data=create_disk_data(local_exportname, target_host, target_port, cache_image, bitmap_image, control_socket_path, target_exportname);
                    if(p_disk_data == ((struct _t_disk_data *)NULL))
                    {
                      fprintf(fp, "%s\n", (const void *)"out of memory");
                      return_code = 1;
                    }

                    else
                    {
                      ret=add_diskimg(p_disk_data);
                      if(ret == -1)
                        fprintf(fp, "cannot open %s\n", cache_image);

                      else
                        if(ret == -4)
                          fprintf(fp, "image cannot be added twice\n");

                      return_code = ret == 0 ? 0 : 1;
                    }
                    g_strfreev(start_filemgr_thread__1__2__1__1__4__argv);
                  }

            }

            else
            {
              return_value_strcmp_17=strcmp(cmd, "del");
              if(return_value_strcmp_17 == 0)
              {
                signed int number;
                number=atoi(arg);
                return_code=del_diskimg_by_index(number);
                if(!(return_code == 0))
                  fprintf(fp, "Image number %d could not be deleted.\n", number);

              }

              else
              {
                return_value_strcmp_16=strcmp(cmd, "del-file");
                if(return_value_strcmp_16 == 0)
                {
                  decode_percent_encoding(arg);
                  return_code=del_diskimg_by_file(arg);
                  if(!(return_code == 0))
                    fprintf(fp, "Image with filename \"%s\" could not be deleted.\n", (const void *)arg);

                }

                else
                {
                  return_value_strcmp_15=strcmp(cmd, "del-exportname");
                  if(return_value_strcmp_15 == 0)
                  {
                    decode_percent_encoding(arg);
                    return_code=del_diskimg_by_exportname(arg);
                    if(!(return_code == 0))
                      fprintf(fp, "Image with exportname \"%s\" could not be deleted.\n", (const void *)arg);

                  }

                  else
                  {
                    return_value_strcmp_14=strcmp(cmd, "shutdown");
                    if(return_value_strcmp_14 == 0)
                      perform_shutdown(fp);

                    else
                    {
                      return_value_strcmp_13=strcmp(cmd, "bgctl-query");
                      if(return_value_strcmp_13 == 0)
                        return_code=handle_bgctl_command("bgctl-query EXPORTNAME", "--query", (unsigned int)2, (unsigned int)2, buf, fp, p_thread_data->xnbd_bgctl_command, (unsigned int *)(void *)0, (char ***)(void *)0, p_thread_data->p_child_process_count);

                      else
                      {
                        return_value_strcmp_12=strcmp(cmd, "bgctl-switch");
                        if(return_value_strcmp_12 == 0)
                        {
                          unsigned int argc = (unsigned int)0;
                          char **argv = (char **)(void *)0;
                          return_code=handle_bgctl_command("bgctl-switch EXPORTNAME", "--switch", (unsigned int)2, (unsigned int)2, buf, fp, p_thread_data->xnbd_bgctl_command, &argc, &argv, p_thread_data->p_child_process_count);
                          if(return_code == 0)
                          {
                            const char * const start_filemgr_thread__1__2__1__1__10__1__local_exportname = argv[(signed long int)1];
                            mark_proxy_mode_ended(start_filemgr_thread__1__2__1__1__10__1__local_exportname);
                          }

                          g_strfreev(argv);
                        }

                        else
                        {
                          return_value_strcmp_11=strcmp(cmd, "bgctl-cache-all");
                          if(return_value_strcmp_11 == 0)
                            return_code=handle_bgctl_command("bgctl-cache-all EXPORTNAME", "--cache-all", (unsigned int)2, (unsigned int)2, buf, fp, p_thread_data->xnbd_bgctl_command, (unsigned int *)(void *)0, (char ***)(void *)0, p_thread_data->p_child_process_count);

                          else
                          {
                            return_value_strcmp_10=strcmp(cmd, "bgctl-reconnect");
                            if(return_value_strcmp_10 == 0)
                            {
                              unsigned int start_filemgr_thread__1__2__1__1__12__argc = (unsigned int)0;
                              char **start_filemgr_thread__1__2__1__1__12__argv = (char **)(void *)0;
                              return_code=handle_bgctl_command("bgctl-reconnect LOCAL_EXPORTNAME HOST PORT [TARGET_EXPORTNAME]", "--reconnect", (unsigned int)4, (unsigned int)5, buf, fp, p_thread_data->xnbd_bgctl_command, &start_filemgr_thread__1__2__1__1__12__argc, &start_filemgr_thread__1__2__1__1__12__argv, p_thread_data->p_child_process_count);
                              if(return_code == 0)
                              {
                                const char * const start_filemgr_thread__1__2__1__1__12__1__local_exportname = start_filemgr_thread__1__2__1__1__12__argv[(signed long int)1];
                                const char * const host = start_filemgr_thread__1__2__1__1__12__argv[(signed long int)2];
                                const char * const port = start_filemgr_thread__1__2__1__1__12__argv[(signed long int)3];
                                const char *start_filemgr_thread__1__2__1__1__12__1__target_exportname;
                                if(start_filemgr_thread__1__2__1__1__12__argc >= 5u)
                                  tmp_if_expr_7 = start_filemgr_thread__1__2__1__1__12__argv[(signed long int)4];

                                else
                                  tmp_if_expr_7 = (char *)(void *)0;
                                start_filemgr_thread__1__2__1__1__12__1__target_exportname = tmp_if_expr_7;
                                update_proxy_settings(start_filemgr_thread__1__2__1__1__12__1__local_exportname, host, port, start_filemgr_thread__1__2__1__1__12__1__target_exportname);
                              }

                              g_strfreev(start_filemgr_thread__1__2__1__1__12__argv);
                            }

                            else
                            {
                              return_value_strcmp_9=strcmp(cmd, "help");
                              if(return_value_strcmp_9 == 0)
                                fprintf(fp, "  list                 : show list of disk images\n\n  add-target NAME PATH : add disk image in target mode\n  add-proxy ...        : add disk image in proxy mode\n (add [NAME] PATH)     : add disk image in target mode, deprecated\n\n  del-file FILE        : delete disk image by file name\n  del-exportname NAME  : delete disk image by export name\n (del INDEX)           : delete disk image by index, deprecated\n\n  bgctl-query NAME     : Query status of proxy\n  bgctl-switch NAME    : Switch from proxy to target mode\n  bgctl-cache-all NAME : Instruct proxy to cache all blocks\n  bgctl-reconnect ...  : Reconnect proxy to a given location\n\n  shutdown             : terminate all images and shutdown xnbd-wrapper instance\n  quit                 : quit (disconnect)\n");

                              else
                              {
                                return_value_strcmp_8=strcmp(cmd, "quit");
                                if(return_value_strcmp_8 == 0)
                                  break;

                                else
                                {
                                  fprintf(fp, "unknown command\n");
                                  return_code = 1;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        report_return_code(fp, return_code);
      }

    }
    while((_Bool)1);
  }

  else
  {
    fprintf(fp, "too many connections\n");
    fflush(fp);
  }
  fclose(fp);
  close(conn_uxsock);
  count_mgr_threads(-1);
  g_free((void *)p_thread_data);
  return (void *)0;
}

// syslog_level
// file common.c line 46
signed int syslog_level(signed int glib_log_level)
{
  signed int level = 6;
  switch(glib_log_level & G_LOG_LEVEL_MASK)
  {
    case G_LOG_LEVEL_CRITICAL:
    {
      level = 2;
      break;
    }
    case G_LOG_LEVEL_ERROR:
    {
      level = 3;
      break;
    }
    case G_LOG_LEVEL_WARNING:
    {
      level = 4;
      break;
    }
    case G_LOG_LEVEL_MESSAGE:
    {
      level = 5;
      break;
    }
    case G_LOG_LEVEL_INFO:
    {
      level = 6;
      break;
    }
    case G_LOG_LEVEL_DEBUG:
    {
      level = 7;
      break;
    }
    default:
      level = 2;
  }
  return level | 3 << 3;
}

// target_mode_main_cow
// file xnbd_target_cow_lzo.c line 748
signed int target_mode_main_cow(struct xnbd_session *ses)
{
  struct xnbd_info *xnbd = ses->xnbd;
  struct nbd_reply reply;
  signed int csock = ses->clientfd;
  unsigned int iotype = (unsigned int)0;
  signed long int iofrom = (signed long int)0;
  unsigned long int iolen = (unsigned long int)0;
  signed int ret;
  memset((void *)&reply, 0, sizeof(struct nbd_reply) /*16ul*/ );
  reply.magic=htonl((unsigned int)0x67446698);
  reply.error = (unsigned int)0;
  ret=poll_request_arrival(ses);
  unsigned long int return_value_pthread_self_3;
  if(!(ret >= 0))
    return -1;

  else
  {
    ret=nbd_server_recv_request(csock, xnbd->disksize, &iotype, &iofrom, &iolen, &reply);
    if(ret == -1)
    {
      net_send_all_or_abort(csock, (const void *)&reply, sizeof(struct nbd_reply) /*16ul*/ );
      return 0;
    }

    else
      if(ret == -2)
      {
        unsigned long int return_value_pthread_self_1;
        return_value_pthread_self_1=pthread_self();
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) client bug: invalid header", return_value_pthread_self_1, (const void *)"target_mode_main_cow");

      __CPROVER_DUMP_L4:
        ;
        goto __CPROVER_DUMP_L4;
      }

      else
        if(ret == -3)
          return ret;

    signed int compression_enabled = 0;
    signed int compression_lzo = 0;
    if(iotype == 4u || iotype == 5u)
    {

    __CPROVER_DUMP_L7:
      ;
      compression_enabled = 1;
      if(iotype == 5u)
        compression_lzo = 1;


    __CPROVER_DUMP_L8:
      ;
      iotype = (unsigned int)0;
    }

    if(!(xnbd->readonly == 0))
    {
      if(iotype == 1u)
      {
        unsigned long int return_value_pthread_self_2;
        return_value_pthread_self_2=pthread_self();
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) NBD_CMD_WRITE to a readonly disk. disconnect.", return_value_pthread_self_2, (const void *)"target_mode_main_cow");

      __CPROVER_DUMP_L12:
        ;
        goto __CPROVER_DUMP_L12;
      }

    }


  __CPROVER_DUMP_L13:
    ;
    struct disk_stack_io *io;
    io=disk_stack_mmap(xnbd->cow_ds, iofrom, iolen, (signed int)(iotype == (unsigned int)0));
    switch(iotype)
    {
      case (unsigned int)1:
      {

      __CPROVER_DUMP_L14:
        ;
        net_readv_all_or_abort(csock, io->iov, io->iov_size);
        net_send_all_or_abort(csock, (const void *)&reply, sizeof(struct nbd_reply) /*16ul*/ );
        break;
      }
      case (unsigned int)0:
      {

      __CPROVER_DUMP_L15:
        ;
        net_send_all_or_abort(csock, (const void *)&reply, sizeof(struct nbd_reply) /*16ul*/ );
        if(!(compression_enabled == 0))
          compress_iovec_and_send_advanced(csock, io->iov, io->iov_size, compression_lzo);

        else
          net_writev_all_or_abort(csock, io->iov, io->iov_size);
        break;
      }
      default:
      {
        return_value_pthread_self_3=pthread_self();
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) unknown command %u", return_value_pthread_self_3, (const void *)"target_mode_main_cow", iotype);

      __CPROVER_DUMP_L19:
        ;
        goto __CPROVER_DUMP_L19;
      }
    }
    free_disk_stack_io(io);
    return 0;
  }
}

// tx_thread_main
// file xnbd_proxy.c line 448
void * tx_thread_main(void *arg)
{
  struct proxy_session *ps = (struct proxy_session *)arg;
  signed int need_exit = 0;
  signed int need_skip = 0;
  set_process_name("proxy_tx");
  block_all_signals();
  do
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "tx_thread %lu starts", return_value_pthread_self_1);
  }
  while((_Bool)0);
  do
  {
    struct proxy_priv *priv;
    void *return_value_g_async_queue_pop_2;
    return_value_g_async_queue_pop_2=g_async_queue_pop(ps->tx_queue);
    priv = (struct proxy_priv *)return_value_g_async_queue_pop_2;
    proxy_priv_dump(priv);
    if(!(priv->need_exit == 0))
      need_exit = 1;

    else
      if(need_skip == 0)
      {
        struct iovec iov[2l];
        unsigned int iov_size = (unsigned int)0;
        iov[(signed long int)iov_size].iov_base = (void *)&priv->reply;
        iov[(signed long int)iov_size].iov_len = sizeof(struct nbd_reply) /*16ul*/ ;
        iov_size = iov_size + (unsigned int)1;
        if(priv->iotype == 0u)
        {
          iov[(signed long int)iov_size].iov_base = (void *)priv->read_buff;
          iov[(signed long int)iov_size].iov_len = priv->iolen;
          iov_size = iov_size + (unsigned int)1;
        }

        signed int ret;
        ret=net_writev_all_or_error(priv->clientfd, iov, iov_size);
        if(!(ret >= 0))
        {
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "clientfd %d is dead", priv->clientfd);
          while((_Bool)0);
          need_skip = 1;
        }

      }

    if(!(priv->read_buff == ((char *)NULL)))
      g_free((void *)priv->read_buff);

    if(!(priv->write_buff == ((char *)NULL)))
      g_free((void *)priv->write_buff);

    mem_usage_del(ps->proxy, priv);
    do
      g_slice_free1(sizeof(struct proxy_priv) /*624ul*/ , (void *)priv);
    while((_Bool)0);
    if(!(need_exit == 0))
      break;

  }
  while((_Bool)1);
  net_send_all_or_abort(ps->pipe_write_fd, (const void *)"", (unsigned long int)1);
  do
  {
    unsigned long int return_value_pthread_self_3;
    return_value_pthread_self_3=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "tx_thread %lu exits", return_value_pthread_self_3);
  }
  while((_Bool)0);
  return (void *)0;
}

// unix_connect
// file lib/net.h line 80
signed int unix_connect(const char *path)
{
  signed int fd;
  fd=socket(1, 1, 0);
  if(!(fd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) socket %m", return_value_pthread_self_1, (const void *)"unix_connect");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  struct sockaddr_un cliaddr;
  cliaddr.sun_family = (unsigned short int)1;
  g_strlcpy(cliaddr.sun_path, path, sizeof(char [108l]) /*108ul*/ );
  signed int ret;
  ret=connect(fd, (struct sockaddr *)&cliaddr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) connect %m", return_value_pthread_self_2, (const void *)"unix_connect");

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

  return fd;
}

// unix_recv_fd
// file lib/net.h line 82
signed int unix_recv_fd(signed int socket)
{
  struct msghdr msg;
  memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
  signed int fd;
  char buf[1l];
  struct iovec iov[1l];
  iov[(signed long int)0].iov_base = (void *)buf;
  iov[(signed long int)0].iov_len = sizeof(char [1l]) /*1ul*/ ;
  msg.msg_iov = iov;
  msg.msg_iovlen = (unsigned long int)1;
  char data_buf[24l];
  msg.msg_control = (void *)data_buf;
  msg.msg_controllen = sizeof(char [24l]) /*24ul*/ ;
  signed int ret;
  signed long int return_value_recvmsg_1;
  return_value_recvmsg_1=recvmsg(socket, &msg, 0);
  ret = (signed int)return_value_recvmsg_1;
  if(ret == -1)
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) recv_fd, %m", return_value_pthread_self_2, (const void *)"unix_recv_fd");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  else
    if(ret == 0)
    {
      unsigned long int return_value_pthread_self_3;
      return_value_pthread_self_3=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) recv_fd, peer closed", return_value_pthread_self_3, (const void *)"unix_recv_fd");

    __CPROVER_DUMP_L5:
      ;
      goto __CPROVER_DUMP_L5;
    }

  struct cmsghdr *cmsg;
  struct cmsghdr *tmp_if_expr_4;
  if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
    tmp_if_expr_4 = (struct cmsghdr *)(&msg)->msg_control;

  else
    tmp_if_expr_4 = (struct cmsghdr *)0;
  cmsg = tmp_if_expr_4;
  if(cmsg == ((struct cmsghdr *)NULL))
  {
    unsigned long int return_value_pthread_self_5;
    return_value_pthread_self_5=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) no cmsghdr", return_value_pthread_self_5, (const void *)"unix_recv_fd");

  __CPROVER_DUMP_L10:
    ;
    goto __CPROVER_DUMP_L10;
  }

  _Bool tmp_if_expr_7;
  if(cmsg->cmsg_len == sizeof(signed int) * 5 /*20ul*/ )
    tmp_if_expr_7 = cmsg->cmsg_level == 1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_7 = (_Bool)0;
  _Bool tmp_if_expr_8;
  if(tmp_if_expr_7)
    tmp_if_expr_8 = cmsg->cmsg_type == 1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_8 = (_Bool)0;
  if(tmp_if_expr_8)
  {
    signed int *fdptr = (signed int *)cmsg->__cmsg_data;
    fd = *fdptr;
  }

  else
  {
    unsigned long int return_value_pthread_self_6;
    return_value_pthread_self_6=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) no descriptor", return_value_pthread_self_6, (const void *)"unix_recv_fd");

  __CPROVER_DUMP_L17:
    ;
    goto __CPROVER_DUMP_L17;
  }
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "fd %d received", fd);
  while((_Bool)0);
  return fd;
}

// unix_send_fd
// file lib/net.h line 81
signed int unix_send_fd(signed int socket, signed int fd)
{
  struct msghdr msg;
  memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
  struct iovec iov[1l];
  iov[(signed long int)0].iov_base = (void *)(char *)"";
  iov[(signed long int)0].iov_len = (unsigned long int)1;
  msg.msg_iov = iov;
  msg.msg_iovlen = (unsigned long int)1;
  char data_buf[24l];
  msg.msg_control = (void *)data_buf;
  msg.msg_controllen = sizeof(char [24l]) /*24ul*/ ;
  struct cmsghdr *cmsg;
  struct cmsghdr *tmp_if_expr_1;
  if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
    tmp_if_expr_1 = (struct cmsghdr *)(&msg)->msg_control;

  else
    tmp_if_expr_1 = (struct cmsghdr *)0;
  cmsg = tmp_if_expr_1;
  cmsg->cmsg_level = 1;
  cmsg->cmsg_type = 1;
  cmsg->cmsg_len = ((sizeof(struct cmsghdr) /*16ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1)) + sizeof(signed int) /*4ul*/ ;
  signed int *fdptr = (signed int *)cmsg->__cmsg_data;
  *fdptr = fd;
  msg.msg_controllen = cmsg->cmsg_len;
  signed int ret;
  signed long int return_value_sendmsg_2;
  return_value_sendmsg_2=sendmsg(socket, &msg, 0);
  ret = (signed int)return_value_sendmsg_2;
  if(ret == -1)
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "send_fd, %m");
    while((_Bool)0);

  else
    if(ret == 0)
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "send_fd, peer closed");
      while((_Bool)0);

  return ret;
}

// unshift_func
// file xnbd_proxy.c line 522
static signed int unshift_func(const void *a, const void *b, void *user_data)
{
  return -1;
}

// update_block_with_found
// file xnbd_target_cow_lzo.c line 320
static void update_block_with_found(struct disk_stack *ds, struct disk_stack_io *io, unsigned long int index, unsigned long int start_index)
{
  signed int found = 0;
  signed int i = ds->nlayers - 1;
  for( ; i >= 0; i = i - 1)
  {
    struct disk_image *di = ds->image[(signed long int)i];
    signed int return_value_bitmap_test_1;
    return_value_bitmap_test_1=bitmap_test(di->bm, index);
    if(!(return_value_bitmap_test_1 == 0))
    {

    __CPROVER_DUMP_L2:
      ;
      char *dstptr = io->bufs[(signed long int)(ds->nlayers - 1)] + (signed long int)((unsigned long int)CBLOCKSIZE * (index - start_index));
      char *srcptr = io->bufs[(signed long int)i] + (signed long int)((unsigned long int)CBLOCKSIZE * (index - start_index));
      memcpy((void *)dstptr, (const void *)srcptr, (unsigned long int)CBLOCKSIZE);
      found = 1;
      break;
    }

  }
  if(found == 0)
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bug", return_value_pthread_self_2, (const void *)"update_block_with_found");

  __CPROVER_DUMP_L6:
    ;
    goto __CPROVER_DUMP_L6;
  }

}

// update_proxy_settings
// file xnbd_wrapper.c line 312
static void update_proxy_settings(const char *local_exportname, const char *host, const char *port, const char *target_exportname)
{
  pthread_mutex_lock(&mutex);
  struct _t_disk_data *p_disk_data;
  void *return_value_g_hash_table_lookup_1;
  return_value_g_hash_table_lookup_1=g_hash_table_lookup(p_disk_dict, (const void *)local_exportname);
  p_disk_data = (struct _t_disk_data *)return_value_g_hash_table_lookup_1;
  if(!(p_disk_data == ((struct _t_disk_data *)NULL)))
  {
    do
    {
      g_free((void *)p_disk_data->proxy.target_host);
      p_disk_data->proxy.target_host=g_strdup(host);
    }
    while((_Bool)0);
    do
    {
      g_free((void *)p_disk_data->proxy.target_port);
      p_disk_data->proxy.target_port=g_strdup(port);
    }
    while((_Bool)0);
    do
    {
      g_free((void *)p_disk_data->proxy.target_exportname);
      p_disk_data->proxy.target_exportname=g_strdup(target_exportname);
    }
    while((_Bool)0);
  }

  pthread_mutex_unlock(&mutex);
}

// wait_until_readable
// file lib/io.h line 60
signed int wait_until_readable(signed int fd, signed int unblock_fd)
{
  struct pollfd eventfds[2l];

__CPROVER_DUMP_L1:
  ;
  eventfds[(signed long int)0].fd = fd;
  eventfds[(signed long int)0].events = (signed short int)(0x040 | 0x2000);
  eventfds[(signed long int)1].fd = unblock_fd;
  eventfds[(signed long int)1].events = (signed short int)(0x040 | 0x2000);
  signed int nready;
  nready=poll(eventfds, (unsigned long int)2, -1);
  if(nready == -1)
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    if(*return_value___errno_location_5 == 4)
    {
      do
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "polling signal cached");
      while((_Bool)0);
      return -1;
    }

    else
    {
      unsigned long int return_value_pthread_self_1;
      return_value_pthread_self_1=pthread_self();
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) polling, %s, (%d)", return_value_pthread_self_1, (const void *)"wait_until_readable", return_value_strerror_3, *return_value___errno_location_4);

    __CPROVER_DUMP_L5:
      ;
      goto __CPROVER_DUMP_L5;
    }
  }

  if(!((8256 & (signed int)eventfds[1l].revents) == 0))
  {
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "notified");
    while((_Bool)0);
    return -1;
  }

  else
    if(!((8256 & (signed int)eventfds[0l].revents) == 0))
      return 0;

    else
    {
      unsigned long int return_value_pthread_self_6;
      return_value_pthread_self_6=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) unknown ppoll events", return_value_pthread_self_6, (const void *)"wait_until_readable");

    __CPROVER_DUMP_L11:
      ;
      goto __CPROVER_DUMP_L11;
    }
}

// waitpid_nohang_ghrfunc
// file xnbd_wrapper.c line 323
static signed int waitpid_nohang_ghrfunc(void *key, void *value, void *user_data)
{
  (void)value;
  const signed int server_pid = (signed int)(signed long int)key;
  signed int * const p_child_process_count = (signed int *)user_data;
  signed int status;
  signed int waitpid_res;
  waitpid_res=waitpid(server_pid, &status, 1);
  if(!(waitpid_res == server_pid))
    return 0;

  else
  {
    inform_xnbd_server_termination(server_pid, status);
    pthread_mutex_lock(&mutex);
    *p_child_process_count = *p_child_process_count - 1;
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "child_process_count-- : %d  (xnbd-server terminated)", *p_child_process_count);
    while((_Bool)0);
    pthread_mutex_unlock(&mutex);
    return (signed int)!(0 != 0);
  }
}

// write_all
// file lib/io.h line 40
void write_all(signed int fd, const void *buf, unsigned long int len)
{
  io_all(fd, (void *)buf, len, 0);
}

// xnbd_cow_target_close_disk
// file xnbd_target_cow_lzo.c line 379
void xnbd_cow_target_close_disk(struct disk_stack *ds, signed int delete_cow)
{
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "close cow disk");
  while((_Bool)0);
  do
    if(ds == ((struct disk_stack *)NULL))
      g_assertion_message_expr((char *)0, "xnbd_target_cow_lzo.c", 382, (const char *)"xnbd_cow_target_close_disk", "ds");

  while((_Bool)0);
  if(!(delete_cow == 0))
  {
    struct disk_image *di_cow = ds->image[(signed long int)(ds->nlayers - 1)];
    signed int ret;
    ret=unlink(di_cow->path);
    if(!(ret >= 0))
    {
      unsigned long int return_value_pthread_self_1;
      return_value_pthread_self_1=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) unlink %m", return_value_pthread_self_1, (const void *)"xnbd_cow_target_close_disk");

    __CPROVER_DUMP_L6:
      ;
      goto __CPROVER_DUMP_L6;
    }

    ret=unlink(di_cow->bmpath);
    if(!(ret >= 0))
    {
      unsigned long int return_value_pthread_self_2;
      return_value_pthread_self_2=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) unlink %m", return_value_pthread_self_2, (const void *)"xnbd_cow_target_close_disk");

    __CPROVER_DUMP_L9:
      ;
      goto __CPROVER_DUMP_L9;
    }

  }

  destroy_disk_stack(ds);
}

// xnbd_cow_target_open_disk
// file xnbd_target_cow_lzo.c line 347
struct disk_stack * xnbd_cow_target_open_disk(char *diskpath, signed int newfile, signed int cowid)
{
  struct disk_stack *ds;
  ds=create_disk_stack(diskpath);
  char *cowpath;
  if(!(newfile == 0))
    do
    {
      cowpath=g_strdup_printf("%s.cow%d.layer%d", diskpath, cowid, ds->nlayers - 1);
      signed int fd;
      fd=open(cowpath, 02 | 0100 | 0200, 0600);
      if(!(fd >= 0))
      {
        cowid = cowid + 1;
        g_free((void *)cowpath);
        continue;
      }

      else
      {
        close(fd);
        break;
      }
    }
    while((_Bool)1);

  else
    cowpath=g_strdup_printf("%s.cow%d.layer%d", diskpath, cowid, ds->nlayers - 1);
  disk_stack_add_image(ds, cowpath, newfile);
  g_free((void *)cowpath);
  return ds;
}

// xnbd_cow_target_session_server
// file xnbd_target_cow_lzo.c line 857
signed int xnbd_cow_target_session_server(struct xnbd_session *ses)
{
  set_process_name("cow_wrk");
  do
  {
    signed int ret = 0;
    ret=target_mode_main_cow(ses);
    if(!(ret >= 0))
      return ret;

  }
  while((_Bool)1);
  return 0;
}

// xnbd_proxy_control_cache_block
// file xnbd_proxy.c line 65
void xnbd_proxy_control_cache_block(signed int ctl_fd, unsigned long int index, unsigned long int nblocks)
{
  signed long int iofrom = (signed long int)index * (signed long int)CBLOCKSIZE;
  unsigned long int iolen = nblocks * (unsigned long int)CBLOCKSIZE;
  signed int ret;
  ret=nbd_client_send_request_header(ctl_fd, (unsigned int)3, iofrom, iolen, 18446744073709551615UL);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) send_read_request, %m", return_value_pthread_self_1, (const void *)"xnbd_proxy_control_cache_block");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  ret=nbd_client_recv_header(ctl_fd);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) recv header, %m", return_value_pthread_self_2, (const void *)"xnbd_proxy_control_cache_block");

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

}

// xnbd_proxy_session_server
// file xnbd_proxy.c line 885
signed int xnbd_proxy_session_server(struct xnbd_session *ses)
{
  struct xnbd_info *xnbd = ses->xnbd;
  set_process_name("proxy_wrk");
  signed int unix_fd;
  unix_fd=unix_connect(xnbd->proxy_unixpath);
  enum xnbd_proxy_cmd_type cmd = (enum xnbd_proxy_cmd_type)XNBD_PROXY_CMD_REGISTER_FD;
  net_send_all_or_abort(unix_fd, (const void *)&cmd, sizeof(enum xnbd_proxy_cmd_type) /*4ul*/ );
  unix_send_fd(unix_fd, ses->clientfd);
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "proxy worker: send fd %d via unix_fd %d", ses->clientfd, unix_fd);
  while((_Bool)0);
  signed int ret;
  struct pollfd eventfds[2l];
  unsigned long int neventfds = (unsigned long int)0;
  eventfds[(signed long int)neventfds].fd = unix_fd;
  eventfds[(signed long int)neventfds].events = (signed short int)(0x040 | 0x2000);
  neventfds = neventfds + (unsigned long int)1;
  eventfds[(signed long int)neventfds].fd = ses->pipe_worker_fd;
  eventfds[(signed long int)neventfds].events = (signed short int)(0x040 | 0x2000);
  neventfds = neventfds + (unsigned long int)1;
  block_all_signals();
  do
  {
    signed int nready;
    nready=poll(eventfds, neventfds, -1);
    if(nready == -1)
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      if(*return_value___errno_location_6 == 4)
      {
        unsigned long int return_value_pthread_self_1;
        return_value_pthread_self_1=pthread_self();
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) proxy worker: catch an unexpected signal", return_value_pthread_self_1, (const void *)"xnbd_proxy_session_server");

      __CPROVER_DUMP_L4:
        ;
        goto __CPROVER_DUMP_L4;
      }

      else
      {
        unsigned long int return_value_pthread_self_2;
        return_value_pthread_self_2=pthread_self();
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        char *return_value_strerror_4;
        return_value_strerror_4=strerror(*return_value___errno_location_3);
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) polling, %s, (%d)", return_value_pthread_self_2, (const void *)"xnbd_proxy_session_server", return_value_strerror_4, *return_value___errno_location_5);

      __CPROVER_DUMP_L6:
        ;
        goto __CPROVER_DUMP_L6;
      }
    }

    if(!((8256 & (signed int)eventfds[0l].revents) == 0))
    {
      char buf[1l];
      ret=net_recv_all_or_error(eventfds[(signed long int)0].fd, (void *)buf, (unsigned long int)1);
      if(!(ret >= 0))
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "proxy worker: detect the incorrect termination of xnbd_proxy");
        while((_Bool)0);

      else
        do
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "proxy worker: detect the session exited");
        while((_Bool)0);
      break;
    }

    else
      if(!((8256 & (signed int)eventfds[1l].revents) == 0))
      {
        char xnbd_proxy_session_server__1__2__1__3__buf[1l];
        ret=net_recv_all_or_error(eventfds[(signed long int)1].fd, (void *)xnbd_proxy_session_server__1__2__1__3__buf, (unsigned long int)1);
        if(!(ret >= 0))
        {
          unsigned long int return_value_pthread_self_7;
          return_value_pthread_self_7=pthread_self();
          g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) proxy worker: the master server was incorrectly terminated?", return_value_pthread_self_7, (const void *)"xnbd_proxy_session_server");

        __CPROVER_DUMP_L14:
          ;
          goto __CPROVER_DUMP_L14;
        }

        else
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "proxy worker: be requested session termination");
          while((_Bool)0);
        ret=net_send_all_or_error(unix_fd, (const void *)"", (unsigned long int)1);
        if(!(ret >= 0))
          do
            g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_WARNING, "proxy worker: sending session termination request failed");
          while((_Bool)0);

      }

      else
      {
        unsigned long int return_value_pthread_self_8;
        return_value_pthread_self_8=pthread_self();
        g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) not reached", return_value_pthread_self_8, (const void *)"xnbd_proxy_session_server");

      __CPROVER_DUMP_L20:
        ;
        goto __CPROVER_DUMP_L20;
      }
  }
  while((_Bool)1);
  return 0;
}

// xnbd_proxy_start
// file xnbd_proxy.c line 771
void xnbd_proxy_start(struct xnbd_info *xnbd)
{
  signed int ret;

__CPROVER_DUMP_L1:
  ;
  char *tmp_if_expr_1;
  do
  {
    if(!(xnbd->proxy_target_exportname == ((char *)NULL)))
      tmp_if_expr_1 = xnbd->proxy_target_exportname;

    else
      tmp_if_expr_1 = "";
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "proxymode mode %s %s (%s%s) cache %s cachebitmap %s", xnbd->proxy_rhost, xnbd->proxy_rport, xnbd->proxy_target_exportname != ((char *)NULL) ? "xnbd-wrapper:" : "xnbd-server", tmp_if_expr_1, xnbd->proxy_diskpath, xnbd->proxy_bmpath);
  }
  while((_Bool)0);
  signed int remotefd;
  remotefd=net_connect(xnbd->proxy_rhost, xnbd->proxy_rport, 1, 6);
  if(!(remotefd >= 0))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) connecting %s:%s failed", return_value_pthread_self_2, (const void *)"xnbd_proxy_start", xnbd->proxy_rhost, xnbd->proxy_rport);

  __CPROVER_DUMP_L6:
    ;
    goto __CPROVER_DUMP_L6;
  }

  unsigned long int return_value_strlen_3;
  if(!(xnbd->proxy_target_exportname == ((char *)NULL)))
  {
    return_value_strlen_3=strlen(xnbd->proxy_target_exportname);
    ret=nbd_negotiate_with_server_new(remotefd, &xnbd->disksize, (unsigned int *)(void *)0, return_value_strlen_3, xnbd->proxy_target_exportname);
  }

  else
    ret=nbd_negotiate_with_server2(remotefd, &xnbd->disksize, (unsigned int *)(void *)0);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_4;
    return_value_pthread_self_4=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) negotiation with %s:%s failed", return_value_pthread_self_4, (const void *)"xnbd_proxy_start", xnbd->proxy_rhost, xnbd->proxy_rport);

  __CPROVER_DUMP_L11:
    ;
    goto __CPROVER_DUMP_L11;
  }

  xnbd->nblocks=get_disk_nblocks(xnbd->disksize);
  make_sockpair(&xnbd->proxy_sockpair_master_fd, &xnbd->proxy_sockpair_proxy_fd);
  signed int pid;
  pid=fork_or_abort();
  if(pid == 0)
  {
    set_process_name("proxy_main");
    close(xnbd->proxy_sockpair_master_fd);
    block_all_signals();
    struct xnbd_proxy *proxy;
    void *return_value_g_malloc0_5;
    return_value_g_malloc0_5=g_malloc0(sizeof(struct xnbd_proxy) /*104ul*/ );
    proxy = (struct xnbd_proxy *)return_value_g_malloc0_5;
    proxy_initialize(xnbd, proxy);
    proxy_initialize_forwarder(proxy, remotefd);
    signed int unix_listen_fd;
    unix_listen_fd=socket(1, 1, 0);
    if(!(unix_listen_fd >= 0))
    {
      unsigned long int return_value_pthread_self_6;
      return_value_pthread_self_6=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) socket %m", return_value_pthread_self_6, (const void *)"xnbd_proxy_start");

    __CPROVER_DUMP_L14:
      ;
      goto __CPROVER_DUMP_L14;
    }

    struct sockaddr_un srvaddr;
    srvaddr.sun_family = (unsigned short int)1;
    g_strlcpy(srvaddr.sun_path, xnbd->proxy_unixpath, sizeof(char [108l]) /*108ul*/ );
    ret=bind(unix_listen_fd, &srvaddr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
    if(!(ret >= 0))
    {
      unsigned long int return_value_pthread_self_7;
      return_value_pthread_self_7=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) binding to %s: %m", return_value_pthread_self_7, (const void *)"xnbd_proxy_start", xnbd->proxy_unixpath);

    __CPROVER_DUMP_L17:
      ;
      goto __CPROVER_DUMP_L17;
    }

    ret=listen(unix_listen_fd, 10);
    if(!(ret >= 0))
    {
      unsigned long int return_value_pthread_self_8;
      return_value_pthread_self_8=pthread_self();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) listening to %s: %m", return_value_pthread_self_8, (const void *)"xnbd_proxy_start", xnbd->proxy_unixpath);

    __CPROVER_DUMP_L20:
      ;
      goto __CPROVER_DUMP_L20;
    }

    do
    {
      signed int return_value_getpid_9;
      return_value_getpid_9=getpid();
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "xnbd_proxy (pid %d) remote %s:%s, cache %s (%s), ctl %s", return_value_getpid_9, xnbd->proxy_rhost, xnbd->proxy_rport, xnbd->proxy_diskpath, xnbd->proxy_bmpath, xnbd->proxy_unixpath);
    }
    while((_Bool)0);
    net_send_all_or_abort(xnbd->proxy_sockpair_proxy_fd, (const void *)"", (unsigned long int)1);
    shutdown(xnbd->proxy_sockpair_proxy_fd, 1);
    do
    {
      ret=main_loop(proxy, unix_listen_fd, xnbd->proxy_sockpair_proxy_fd);
      if(!(ret >= 0))
        break;

    }
    while((_Bool)1);
    proxy_shutdown_forwarder(proxy);
    proxy_shutdown(proxy);
    nbd_client_send_disc_request(proxy->remotefd);
    close(proxy->remotefd);
    g_free((void *)proxy);
    close(unix_listen_fd);
    unlink(xnbd->proxy_unixpath);
    do
      g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "xnbd_proxy successfully exits");
    while((_Bool)0);
    exit(0);
  }

  xnbd->proxy_pid = pid;
  close(xnbd->proxy_sockpair_proxy_fd);
  close(remotefd);
  char buf[1l];
  net_recv_all_or_abort(xnbd->proxy_sockpair_master_fd, (void *)buf, (unsigned long int)1);
  shutdown(xnbd->proxy_sockpair_master_fd, 0);
  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "xnbd_proxy gets ready");
  while((_Bool)0);
}

// xnbd_proxy_stop
// file xnbd_proxy.c line 754
void xnbd_proxy_stop(struct xnbd_info *xnbd)
{
  do
  {
    unsigned int return_value_g_list_length_1;
    return_value_g_list_length_1=g_list_length(xnbd->sessions);
    if(!(return_value_g_list_length_1 == 0u))
      g_assertion_message_expr((char *)0, "xnbd_proxy.c", 756, (const char *)"xnbd_proxy_stop", "g_list_length(xnbd->sessions) == 0");

  }
  while((_Bool)0);
  write_all(xnbd->proxy_sockpair_master_fd, (const void *)"", (unsigned long int)1);
  close(xnbd->proxy_sockpair_master_fd);
  signed int ret;
  ret=waitpid(xnbd->proxy_pid, (signed int *)(void *)0, 0);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) waitpid %d, %m", return_value_pthread_self_2, (const void *)"xnbd_proxy_stop", xnbd->proxy_pid);

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

  do
    g_log((char *)0, (enum anonymous_2)G_LOG_LEVEL_MESSAGE, "xnbd_proxy (pid %d) exited", xnbd->proxy_pid);
  while((_Bool)0);
}

