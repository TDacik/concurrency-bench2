// tag-#anon#ST[*{SYM#tag-#anon#ST[S16'x'||S16'y'||SYM#tag-#anon#ST[BF{S32}_S32_'decal_for_dir'||BF{S32}_S32_'size'|]#'side'||ARR6{SYM#tag-#anon#ST[SYM#tag-#anon#UN[S32'time'||SYM#tag-#anon#ST[S16'x'||S16'y'|]#'cursor'|]#'update'||SYM#tag-#anon#ST[BF{S32}_S32_'dir'||BF{S32}_S32_'grad'|]#'state'|]#}_SYM#tag-#anon#ST[SYM#tag-#anon#UN[S32'time'||SYM#tag-#anon#ST[S16'x'||S16'y'|]#'cursor'|]#'update'||SYM#tag-#anon#ST[BF{S32}_S32_'dir'||BF{S32}_S32_'grad'|]#'state'|]#_'info'||ARR12{*{V}_V_}_*{V}_V__'link'|]#}_SYM#tag-#anon#ST[S16'x'||S16'y'||SYM#tag-#anon#ST[BF{S32}_S32_'decal_for_dir'||BF{S32}_S32_'size'|]#'side'||ARR6{SYM#tag-#anon#ST[SYM#tag-#anon#UN[S32'time'||SYM#tag-#anon#ST[S16'x'||S16'y'|]#'cursor'|]#'update'||SYM#tag-#anon#ST[BF{S32}_S32_'dir'||BF{S32}_S32_'grad'|]#'state'|]#}_SYM#tag-#anon#ST[SYM#tag-#anon#UN[S32'time'||SYM#tag-#anon#ST[S16'x'||S16'y'|]#'cursor'|]#'update'||SYM#tag-#anon#ST[BF{S32}_S32_'dir'||BF{S32}_S32_'grad'|]#'state'|]#_'info'||ARR12{*{V}_V_}_*{V}_V__'link'|]#_'mesh'||*{SYM#tag-#anon#ST[S16'x'||S16'y'||S16'health'||S8'team'||S8'last_dir'|]#}_SYM#tag-#anon#ST[S16'x'||S16'y'||S16'health'||S8'team'||S8'last_dir'|]#_'fighter'|]
// file area.h line 74
struct anonymous_22;

// tag-#anon#ST[*{U8}_U8_'data'||S32'len'||U32'_pad0'|]
// file /usr/include/allegro/midi.h line 36
struct anonymous_26;

// tag-#anon#ST[*{V}_V_'data'|]
// file mutxgen.h line 57
struct anonymous_1;

// tag-#anon#ST[ARR11{S8}_S8_'author'||ARR81{S8}_S8_'content'|]
// file chat.h line 70
struct anonymous_24;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_14;

// tag-#anon#ST[ARR50{S8}_S8_'label'||ARR16{S8}_S8_'ip'||U16'_pad0'||S32'port'||S32'uptime'||S32'busy_players'||S32'max_players'||S32'password'||ARR101{S8}_S8_'comment'||U24'_pad1'||S32'ping_delay'|]
// file wwwcli.h line 68
struct anonymous_15;

// tag-#anon#ST[ARR6{S32}_S32_'key_states'||S32'cmd'||S32'arg'||U32'checksum'|]
// file netkey.h line 74
struct anonymous_5;

// tag-#anon#ST[BF{S32}_S32_'decal_for_dir'||BF{S32}_S32_'size'|]
// file mesh.h line 96
struct anonymous_20;

// tag-#anon#ST[BF{S32}_S32_'dir'||BF{S32}_S32_'grad'|]
// file mesh.h line 82
struct anonymous_18;

// tag-#anon#ST[S16'x'||S16'y'|]
// file mesh.h line 73
struct anonymous_16;

// tag-#anon#ST[S16'x'||S16'y'||S16'health'||S8'team'||S8'last_dir'|]
// file area.h line 64
struct anonymous_21;

// tag-#anon#ST[S16'x'||S16'y'||SYM#tag-#anon#ST[BF{S32}_S32_'decal_for_dir'||BF{S32}_S32_'size'|]#'side'||ARR6{SYM#tag-#anon#ST[SYM#tag-#anon#UN[S32'time'||SYM#tag-#anon#ST[S16'x'||S16'y'|]#'cursor'|]#'update'||SYM#tag-#anon#ST[BF{S32}_S32_'dir'||BF{S32}_S32_'grad'|]#'state'|]#}_SYM#tag-#anon#ST[SYM#tag-#anon#UN[S32'time'||SYM#tag-#anon#ST[S16'x'||S16'y'|]#'cursor'|]#'update'||SYM#tag-#anon#ST[BF{S32}_S32_'dir'||BF{S32}_S32_'grad'|]#'state'|]#_'info'||ARR12{*{V}_V_}_*{V}_V__'link'|]
// file mesh.h line 107
struct anonymous_0;

// tag-#anon#ST[S32'active'||S32'network'||S32'server_id'||S32'control_type'||S32'color'||S32'part'||ARR11{S8}_S8_'name'||U8'_pad0'|]
// file network.h line 64
struct anonymous_8;

// tag-#anon#ST[S32'active'||S32'start'||ARR11{S8}_S8_'name'||U8'_pad0'|]
// file startinf.h line 63
struct anonymous_12;

// tag-#anon#ST[S32'argc'||S32'code'||*{*{S8}_S8_}_*{S8}_S8__'argv'|]
// file netmess.h line 66
struct anonymous_6;

// tag-#anon#ST[S32'cursor_increase_speed'||S32'fighter_attack'||S32'fighter_defense'||S32'fighter_new_health'||S32'number_influence'||S32'fighter_number'||S32'game_time'||S32'cpu_advantage'||S32'cpu_vs_human'||S32'asm_algorithm'||S32'min_map_res'|]
// file netconf.h line 64
struct anonymous_4;

// tag-#anon#ST[S32'n'||ARR20{SYM#tag-#anon#ST[ARR11{S8}_S8_'author'||ARR81{S8}_S8_'content'|]#}_SYM#tag-#anon#ST[ARR11{S8}_S8_'author'||ARR81{S8}_S8_'content'|]#_'messages'|]
// file chat.h line 77
struct anonymous_13;

// tag-#anon#ST[S32'sock'||ARR16{S8}_S8_'address'||S32'port'||S32'allow_exit'||S32'done'||S32'result'|]
// file ping.c line 89
struct anonymous_9;

// tag-#anon#ST[S32'sock'||ARR16{S8}_S8_'address'||S32'port'||S32'running'||S32'allow_exit'||S32'free_data'||S32'result'|]
// file netplay.c line 92
struct anonymous_7;

// tag-#anon#ST[S32'sock'||ARR6{SYM#tag-#anon#ST[S32'active'||S32'start'||ARR11{S8}_S8_'name'||U8'_pad0'|]#}_SYM#tag-#anon#ST[S32'active'||S32'start'||ARR11{S8}_S8_'name'||U8'_pad0'|]#_'team_start_info'||S32'waited_teams'||S32'start'||S32'force_start'||S32'thread_running'||S32'result'||S32'finished'||ARR81{S8}_S8_'chat_buffer'||U24'_pad0'||SYM#tag-#anon#ST[S32'n'||ARR20{SYM#tag-#anon#ST[ARR11{S8}_S8_'author'||ARR81{S8}_S8_'content'|]#}_SYM#tag-#anon#ST[ARR11{S8}_S8_'author'||ARR81{S8}_S8_'content'|]#_'messages'|]#'chat_history'||S32'chat_send'|]
// file connect.c line 92
struct anonymous_25;

// tag-#anon#ST[S32'start'||S32'record_number'||S32'total_time'|]
// file profile.c line 64
struct anonymous_11;

// tag-#anon#ST[S32'val'||S32'x'||S32'y'||S32'active'||S32'team'||S32'loose_time'||S32'score_order'||S32'color_entry'||S32'key_state'||S32'control_type'||S32'from_network'||ARR11{S8}_S8_'name'||U8'_pad0'|]
// file cursor.h line 64
struct anonymous_23;

// tag-#anon#ST[S32'x'||S32'y'||S32'color'||S32'row'|]
// file pion.c line 71
struct anonymous_10;

// tag-#anon#ST[S8'used'||U8'_pad0'||S16'size'||U32'_pad1'||ARR12{*{V}_V_}_*{V}_V__'link'||S32'corres'||U32'_pad2'|]
// file mesh.c line 68
struct anonymous;

// tag-#anon#ST[SYM#tag-#anon#UN[S32'time'||SYM#tag-#anon#ST[S16'x'||S16'y'|]#'cursor'|]#'update'||SYM#tag-#anon#ST[BF{S32}_S32_'dir'||BF{S32}_S32_'grad'|]#'state'|]
// file mesh.h line 89
struct anonymous_19;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_3;

// tag-#anon#UN[S32'time'||SYM#tag-#anon#ST[S16'x'||S16'y'|]#'cursor'|]
// file mesh.h line 70
union anonymous_17;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_2;

// tag-BITMAP
// file /usr/include/allegro/system.h line 31
struct BITMAP;

// tag-DATAFILE
// file /usr/include/allegro/datafile.h line 59
struct DATAFILE;

// tag-DATAFILE_PROPERTY
// file /usr/include/allegro/datafile.h line 52
struct DATAFILE_PROPERTY;

// tag-DIALOG
// file /usr/include/allegro/gui.h line 29
struct DIALOG;

// tag-DIALOG_PLAYER
// file /usr/include/allegro/gui.h line 57
struct DIALOG_PLAYER;

// tag-DIGI_DRIVER
// file /usr/include/allegro/digi.h line 52
struct DIGI_DRIVER;

// tag-FONT
// file /usr/include/allegro/text.h line 32
struct FONT;

// tag-FONT_GLYPH
// file /usr/include/allegro/gfx.h line 31
struct FONT_GLYPH;

// tag-FONT_VTABLE
// file /usr/include/allegro/text.h line 30
struct FONT_VTABLE;

// tag-GFX_DRIVER
// file /usr/include/allegro/gfx.h line 80
struct GFX_DRIVER;

// tag-GFX_MODE
// file /usr/include/allegro/system.h line 33
struct GFX_MODE;

// tag-GFX_MODE_LIST
// file /usr/include/allegro/gfx.h line 74
struct GFX_MODE_LIST;

// tag-GFX_VTABLE
// file /usr/include/allegro/system.h line 32
struct GFX_VTABLE;

// tag-JOYSTICK_AXIS_INFO
// file /usr/include/allegro/joystick.h line 39
struct JOYSTICK_AXIS_INFO;

// tag-JOYSTICK_BUTTON_INFO
// file /usr/include/allegro/joystick.h line 58
struct JOYSTICK_BUTTON_INFO;

// tag-JOYSTICK_DRIVER
// file /usr/include/allegro/joystick.h line 96
struct JOYSTICK_DRIVER;

// tag-JOYSTICK_INFO
// file /usr/include/allegro/joystick.h line 66
struct JOYSTICK_INFO;

// tag-JOYSTICK_STICK_INFO
// file /usr/include/allegro/joystick.h line 48
struct JOYSTICK_STICK_INFO;

// tag-KEYBOARD_DRIVER
// file /usr/include/allegro/keyboard.h line 28
struct KEYBOARD_DRIVER;

// tag-MIDI
// file /usr/include/allegro/midi.h line 33
struct MIDI;

// tag-MIDI_DRIVER
// file /usr/include/allegro/midi.h line 48
struct MIDI_DRIVER;

// tag-MOUSE_DRIVER
// file /usr/include/allegro/mouse.h line 32
struct MOUSE_DRIVER;

// tag-RGB
// file /usr/include/allegro/system.h line 30
struct RGB;

// tag-RLE_SPRITE
// file /usr/include/allegro/gfx.h line 30
struct RLE_SPRITE;

// tag-SAMPLE
// file /usr/include/allegro/digi.h line 35
struct SAMPLE;

// tag-SYSTEM_DRIVER
// file /usr/include/allegro/system.h line 199
struct SYSTEM_DRIVER;

// tag-TIMER_DRIVER
// file /usr/include/allegro/timer.h line 34
struct TIMER_DRIVER;

// tag-V3D
// file /usr/include/allegro/3d.h line 31
struct V3D;

// tag-V3D_f
// file /usr/include/allegro/3d.h line 39
struct V3D_f;

// tag-_DRIVER_INFO
// file /usr/include/allegro/base.h line 96
struct _DRIVER_INFO;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-linger
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 379
struct linger;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// _allegro_hline
// file /usr/include/allegro/inline/draw.inl line 54
static inline void _allegro_hline(struct BITMAP *bmp, signed int x1, signed int y, signed int x2, signed int color);
// _allegro_hline_link1
// file /usr/include/allegro/inline/draw.inl line 54
static inline void _allegro_hline_link1(struct BITMAP *bmp_link1, signed int x1_link1, signed int y_link1, signed int x2_link1, signed int color_link1);
// _allegro_hline_link2
// file /usr/include/allegro/inline/draw.inl line 54
static inline void _allegro_hline_link2(struct BITMAP *bmp_link2, signed int x1_link2, signed int y_link2, signed int x2_link2, signed int color_link2);
// _allegro_vline
// file /usr/include/allegro/inline/draw.inl line 46
static inline void _allegro_vline(struct BITMAP *bmp, signed int x, signed int y_1, signed int y2, signed int color);
// _allegro_vline_link1
// file /usr/include/allegro/inline/draw.inl line 46
static inline void _allegro_vline_link1(struct BITMAP *bmp_link1, signed int x_link1, signed int y_1_link1, signed int y2_link1, signed int color_link1);
// _allegro_vline_link2
// file /usr/include/allegro/inline/draw.inl line 46
static inline void _allegro_vline_link2(struct BITMAP *bmp_link2, signed int x_link2, signed int y_1_link2, signed int y2_link2, signed int color_link2);
// _allegro_vline_link3
// file /usr/include/allegro/inline/draw.inl line 46
static inline void _allegro_vline_link3(struct BITMAP *bmp_link3, signed int x_link3, signed int y_1_link3, signed int y2_link3, signed int color_link3);
// _draw_scrollable_frame
// file alleg2.c line 71
extern void _draw_scrollable_frame(struct DIALOG *, signed int, signed int, signed int, signed int, signed int);
// _install_allegro_version_check
// file /usr/include/allegro/system.h line 80
signed int _install_allegro_version_check(signed int, signed int *, signed int (*)(void (*)(void)), signed int);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// add_fighter
// file army.c line 97
static signed int add_fighter(struct anonymous_21 *f, signed int team, signed int x, signed int y, signed int health);
// advanced_options
// file advanced.c line 119
signed int advanced_options(void);
// allegro_exit
// file /usr/include/allegro/system.h line 94
void allegro_exit(void);
// apply_all_cursor
// file cursor.c line 152
void apply_all_cursor(void);
// ascii_hexa_to_int
// file netkey.c line 137
static signed int ascii_hexa_to_int(char src);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// atoi_link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link1(const char *__nptr_link1);
// atoi_link2
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link2(const char *__nptr_link2);
// atoi_link3
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link3(const char *__nptr_link3);
// atoi_link4
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link4(const char *__nptr_link4);
// auto_cursor
// file cursor.h line 135
void auto_cursor(signed int index, signed int team, char *name);
// bestfit_color
// file /usr/include/allegro/color.h line 125
signed int bestfit_color(struct RGB *, signed int, signed int, signed int);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bitmap_color_depth
// file /usr/include/allegro/inline/gfx.inl line 104
static inline signed int bitmap_color_depth(struct BITMAP *bmp);
// blank_round
// file game.c line 459
signed int blank_round(void);
// blit
// file /usr/include/allegro/draw.h line 55
void blit(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int);
// box_for_choose_map
// file level.c line 339
static void box_for_choose_map(void);
// broadcast_dialog_message
// file /usr/include/allegro/gui.h line 207
signed int broadcast_dialog_message(signed int, signed int);
// calc_playing_teams
// file game.c line 119
void calc_playing_teams(void);
// calc_real_texture_number
// file maptex.c line 76
static signed int calc_real_texture_number(signed int num, signed int texture, signed int network, signed int random, signed int use_default_texture, signed int *found);
// calc_zoom_factor
// file map.c line 87
static signed int calc_zoom_factor(signed int w, signed int h, signed int min_w, signed int min_h);
// calculate_computer_path
// file autoplay.c line 86
static void calculate_computer_path(signed int dst_x, signed int dst_y, signed int cursor);
// center_one_dialog
// file dialog.c line 127
void center_one_dialog(struct DIALOG *d, signed int x, signed int y, signed int w, signed int h);
// change_key
// file team.c line 252
static void change_key(struct DIALOG *d, signed int *val);
// change_palette_brightness
// file palette.c line 113
static void change_palette_brightness(struct RGB *old_pal, struct RGB *new_pal);
// check_boolean_codes
// file code.c line 209
static void check_boolean_codes(void);
// check_code
// file code.c line 265
void check_code(void);
// check_config_range
// file config.c line 613
void check_config_range(void);
// check_free_memory
// file bigdata.c line 222
signed int check_free_memory(void);
// check_grad_to_disp
// file code.c line 158
static void check_grad_to_disp(void);
// check_if_playable
// file map.c line 266
static signed int check_if_playable(struct BITMAP *bmp);
// check_info_state
// file info.h line 62
void check_info_state(void);
// check_loose_team
// file game.c line 200
signed int check_loose_team(void);
// choose_different_color
// file network.c line 135
signed int choose_different_color();
// choose_map
// file level.c line 593
signed int choose_map(void);
// choose_teams
// file team.h line 66
signed int choose_teams(void);
// clean_buffer
// file sockex.c line 120
static void clean_buffer(char *buffer, signed int len);
// cleanup_player_names
// file team.c line 213
static void cleanup_player_names();
// clear_keybuf
// file /usr/include/allegro/keyboard.h line 73
void clear_keybuf(void);
// clear_message
// file message.h line 58
void clear_message(void);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// color_one_dialog
// file dialog.h line 105
void color_one_dialog(struct DIALOG *d);
// confirm_quit
// file menu.h line 66
signed int confirm_quit(void);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// connect_on_server_continue
// file netplay.c line 292
static signed int connect_on_server_continue(signed int sock);
// connect_on_server_finish
// file netplay.c line 443
static signed int connect_on_server_finish(signed int sock);
// connect_on_server_keepalive
// file connect.c line 448
static void connect_on_server_keepalive(void *arg);
// connect_on_server_start
// file netplay.c line 164
static signed int connect_on_server_start(signed int *sock, char *address, signed int port);
// connect_on_server_start_callback
// file netplay.c line 259
static void connect_on_server_start_callback(void *arg);
// controls_options
// file controls.c line 92
signed int controls_options(void);
// convert_to_buffer
// file map.c line 332
static void convert_to_buffer(struct BITMAP *bmp, char *buffer, signed int *size, signed int *bg_size);
// correct_palette
// file texture.c line 163
static void correct_palette(struct RGB *pal, signed int first_color, signed int number_of_colors);
// correct_path_dir
// file startup.c line 285
static void correct_path_dir(char *path);
// correct_path_file
// file startup.c line 306
static void correct_path_file(char *path);
// create_army
// file army.c line 263
signed int create_army(void);
// create_bitmap
// file /usr/include/allegro/gfx.h line 419
struct BITMAP * create_bitmap(signed int, signed int);
// create_converted_bitmap
// file texture.c line 183
static void create_converted_bitmap(struct BITMAP *bmp, struct RGB *dst, struct RGB *src, signed int first_color, signed int number_of_colors);
// create_default_back
// file disk.c line 259
static void create_default_back(void);
// create_dir_bitmap
// file grad.c line 108
struct BITMAP * create_dir_bitmap(signed int team);
// create_first_mesher
// file mesh.c line 103
static struct anonymous * create_first_mesher(struct BITMAP *map);
// create_game_area
// file area.c line 86
signed int create_game_area(void);
// create_gradient_bitmap
// file grad.h line 71
struct BITMAP * create_gradient_bitmap(signed int team);
// create_mesh
// file mesh.h line 134
signed int create_mesh(void);
// create_mesh_bitmap
// file mesh.h line 135
struct BITMAP * create_mesh_bitmap(signed int mode);
// create_mono_texture
// file texture.c line 385
static struct BITMAP * create_mono_texture(signed int first);
// create_new_palette
// file texture.c line 127
static void create_new_palette(struct RGB *dst, struct RGB *src, struct BITMAP *bmp, signed int first_color, signed int number_of_colors);
// create_raw_texture
// file texture.c line 325
static struct BITMAP * create_raw_texture(void *ptr, signed int first);
// create_sub_bitmap
// file /usr/include/allegro/gfx.h line 421
struct BITMAP * create_sub_bitmap(struct BITMAP *, signed int, signed int, signed int, signed int);
// create_texture
// file texture.c line 396
static struct BITMAP * create_texture(signed int num, signed int first);
// create_wave_line
// file distor.c line 159
static void create_wave_line(signed int *buffer, signed int length, signed int number, signed int ampli, signed int speed, signed int sens);
// d_box_proc
// file /usr/include/allegro/gui.h line 152
signed int d_box_proc(signed int, struct DIALOG *, signed int);
// d_button_proc
// file /usr/include/allegro/gui.h line 158
signed int d_button_proc(signed int, struct DIALOG *, signed int);
// d_keyboard_proc
// file /usr/include/allegro/gui.h line 162
signed int d_keyboard_proc(signed int, struct DIALOG *, signed int);
// decode
// file netkey.c line 198
static void decode(struct anonymous_5 *dst, unsigned char *src);
// delete_file
// file /usr/include/allegro/file.h line 44
signed int delete_file(const char *);
// destroy_bitmap
// file /usr/include/allegro/gfx.h line 424
void destroy_bitmap(struct BITMAP *);
// disp_all_cursors
// file pion.h line 63
void disp_all_cursors(void);
// disp_base_message
// file exit.c line 128
static void disp_base_message(void);
// disp_big_data_message
// file exit.c line 206
static void disp_big_data_message(void);
// disp_common_memory_message
// file exit.c line 167
static void disp_common_memory_message(void);
// disp_cursor
// file pion.c line 166
static void disp_cursor(signed int number);
// disp_custom_fail_message
// file exit.c line 236
static void disp_custom_fail_message(void);
// disp_distorted_area
// file distor.h line 66
void disp_distorted_area(void);
// disp_error_message
// file exit.c line 142
static void disp_error_message(void);
// disp_fighter
// file fighter.c line 137
static void disp_fighter(struct anonymous_21 *f);
// disp_graphics_fail_message
// file exit.c line 253
static void disp_graphics_fail_message(void);
// disp_init_fail_message
// file exit.c line 150
static void disp_init_fail_message(void);
// disp_load_fail_message
// file exit.c line 219
static void disp_load_fail_message(void);
// disp_mem_trouble_message
// file exit.c line 194
static void disp_mem_trouble_message(void);
// disp_ok_message
// file exit.c line 135
static void disp_ok_message(void);
// disp_stretch_area
// file disp.c line 73
static void disp_stretch_area(void);
// display
// file game.c line 639
static void display(void);
// display_a_back_image
// file back.c line 73
void display_a_back_image(struct BITMAP *bmp);
// display_area
// file disp.c line 82
void display_area(void);
// display_back_image
// file back.h line 69
void display_back_image(void);
// display_center_message
// file dialog.c line 332
void display_center_message(char *str);
// display_chosen_level
// file level.c line 164
static void display_chosen_level(void);
// display_gradient
// file disp.c line 94
void display_gradient(signed int i);
// display_help
// file help.h line 67
signed int display_help(char *str);
// display_horizontal_info
// file info.c line 241
static void display_horizontal_info(signed int w, signed int h, signed int epaisseur);
// display_info
// file info.h line 60
void display_info(void);
// display_mesh
// file disp.c line 109
void display_mesh(signed int i);
// display_message
// file message.h line 59
void display_message(void);
// display_scores
// file score.h line 66
signed int display_scores(void);
// display_special_info
// file code.c line 90
static void display_special_info(void);
// display_success
// file init.h line 64
void display_success(signed int success);
// display_success_driver
// file init.h line 65
void display_success_driver(char *driver);
// display_time
// file info.c line 212
static void display_time(signed int x, signed int y, signed int w, signed int h);
// display_vertical_info
// file info.c line 269
static void display_vertical_info(signed int w, signed int h, signed int epaisseur);
// distance_between_colors
// file network.c line 95
signed int distance_between_colors(signed int col1, signed int col2);
// draw_score_bitmap
// file score.c line 207
static signed int draw_score_bitmap(struct BITMAP *bitmap, signed int cursor, signed int ellipse_h, signed int fill_level);
// draw_sprite
// file /usr/include/allegro/inline/draw.inl line 238
static inline void draw_sprite(struct BITMAP *bmp, struct BITMAP *sprite, signed int x, signed int y);
// draw_sprite_link1
// file /usr/include/allegro/inline/draw.inl line 238
static inline void draw_sprite_link1(struct BITMAP *bmp_link1, struct BITMAP *sprite_link1, signed int x_link1, signed int y_link1);
// draw_sprite_link2
// file /usr/include/allegro/inline/draw.inl line 238
static inline void draw_sprite_link2(struct BITMAP *bmp_link2, struct BITMAP *sprite_link2, signed int x_link2, signed int y_link2);
// eat_space
// file netmess.c line 91
static signed int eat_space(char **message);
// eliminate_team
// file decal.c line 89
signed int eliminate_team(signed int team);
// ellipse
// file /usr/include/allegro/inline/draw.inl line 137
static inline void ellipse(struct BITMAP *bmp, signed int x, signed int y, signed int rx, signed int ry, signed int color);
// ellipsefill
// file /usr/include/allegro/inline/draw.inl line 146
static inline void ellipsefill(struct BITMAP *bmp, signed int x, signed int y, signed int rx, signed int ry, signed int color);
// encode
// file netkey.c line 160
static void encode(unsigned char *dst, struct anonymous_5 *src);
// erase_fighter
// file fighter.c line 129
static void erase_fighter(struct anonymous_21 *f);
// error_bad_config_range
// file error.c line 206
signed int error_bad_config_range(void);
// error_bad_password
// file error.c line 199
signed int error_bad_password(void);
// error_cant_receive_map
// file error.c line 184
signed int error_cant_receive_map(void);
// error_cant_send_map
// file error.c line 177
signed int error_cant_send_map(void);
// error_graphics_init_failed
// file error.c line 129
signed int error_graphics_init_failed(void);
// error_network_problem
// file error.h line 73
signed int error_network_problem(void);
// error_no_network_support
// file error.c line 137
signed int error_no_network_support(void);
// error_not_a_liquidwar_server
// file error.c line 153
signed int error_not_a_liquidwar_server(void);
// error_not_enough_big_data
// file error.c line 121
signed int error_not_enough_big_data(void);
// error_not_enough_teams
// file error.c line 113
signed int error_not_enough_teams(void);
// error_server_full
// file error.c line 192
signed int error_server_full(void);
// error_unable_to_connect
// file error.c line 145
signed int error_unable_to_connect(void);
// error_wrong_version
// file error.c line 161
signed int error_wrong_version(void);
// exist_argument
// file parser.h line 69
signed int exist_argument(char *str);
// exist_argument_value
// file parser.c line 140
signed int exist_argument_value(char *str);
// exist_color
// file texture.c line 97
static signed int exist_color(struct RGB *pal, struct RGB rgb);
// exists
// file /usr/include/allegro/file.h line 41
signed int exists(const char *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_all
// file exit.c line 96
static void exit_all(void);
// extract_significant_part
// file map.c line 127
static struct BITMAP * extract_significant_part(struct BITMAP *src);
// fade_in
// file /usr/include/allegro/color.h line 86
void fade_in(struct RGB *, signed int);
// fade_out
// file /usr/include/allegro/color.h line 87
void fade_out(signed int);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fcos
// file /usr/include/allegro/alcompat.h line 50
static inline signed int fcos(signed int x);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fill_next_screen
// file game.c line 508
static void fill_next_screen(void);
// fill_with_fg_and_bg
// file map.c line 312
static void fill_with_fg_and_bg(struct BITMAP *bmp, signed int fg, signed int bg);
// find_center
// file dialog.c line 107
signed int find_center(signed int pos, signed int num, signed int space, signed int size);
// find_color
// file texture.c line 84
static signed int find_color(struct RGB *pal, struct RGB rgb);
// fix_filename_case
// file /usr/include/allegro/file.h line 28
char * fix_filename_case(char *);
// fix_filename_slashes
// file /usr/include/allegro/file.h line 29
char * fix_filename_slashes(char *);
// fixcos
// file /usr/include/allegro/inline/fmaths.inl line 193
static inline signed int fixcos(signed int x);
// fixdiv
// file /usr/include/allegro/inline/fmaths.inl line 147
static inline signed int fixdiv(signed int x, signed int y);
// fixfloor
// file /usr/include/allegro/inline/fmaths.inl line 158
static inline signed int fixfloor(signed int x);
// fixsin
// file /usr/include/allegro/inline/fmaths.inl line 199
static inline signed int fixsin(signed int x);
// fixsqrt
// file /usr/include/allegro/fmaths.h line 29
signed int fixsqrt(signed int);
// fixtof
// file /usr/include/allegro/inline/fmaths.inl line 48
static inline double fixtof(signed int x);
// fixtoi
// file /usr/include/allegro/inline/fmaths.inl line 187
static inline signed int fixtoi(signed int x);
// for_each_file_ex
// file /usr/include/allegro/file.h line 45
signed int for_each_file_ex(const char *, signed int, signed int, signed int (*)(const char *, signed int, void *), void *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_game_memory
// file game.c line 419
void free_game_memory(void);
// free_info_bar
// file info.h line 59
void free_info_bar(void);
// free_last_big_data_bottom
// file bigdata.c line 206
void free_last_big_data_bottom(void);
// free_last_big_data_top
// file bigdata.c line 214
void free_last_big_data_top(void);
// fsin
// file /usr/include/allegro/alcompat.h line 51
static inline signed int fsin(signed int x);
// fsqrt
// file /usr/include/allegro/alcompat.h line 57
static inline signed int fsqrt(signed int x);
// fsqrt_link1
// file /usr/include/allegro/alcompat.h line 57
static inline signed int fsqrt_link1(signed int x_link1);
// fsqrt_link2
// file /usr/include/allegro/alcompat.h line 57
static inline signed int fsqrt_link2(signed int x_link2);
// ftofix
// file /usr/include/allegro/inline/fmaths.inl line 32
static inline signed int ftofix(double x);
// game
// file game.c line 721
signed int game(void);
// generate_bitmap
// file random.c line 115
static struct BITMAP * generate_bitmap();
// generate_bw_palette
// file random.c line 101
static void generate_bw_palette(struct RGB *pal);
// get_allow_network_bots_str
// file advanced.c line 105
static char * get_allow_network_bots_str(void);
// get_argc
// file netmess.c line 321
static signed int get_argc(char *message);
// get_argument_int
// file parser.c line 169
signed int get_argument_int(char *str);
// get_argument_str
// file parser.c line 153
char * get_argument_str(char *str);
// get_argv
// file netmess.c line 364
static char ** get_argv(char *message, signed int argc);
// get_asm_algorithm_str
// file advanced.c line 73
static char * get_asm_algorithm_str(void);
// get_battle_room
// file army.c line 84
static signed int get_battle_room(void);
// get_close_dir
// file fighter.c line 271
static signed int get_close_dir(struct anonymous_0 *mesh, struct anonymous_21 *f, signed int team, signed int sens, signed int start);
// get_code
// file netmess.c line 197
static signed int get_code(char **message);
// get_computer_next_move
// file autoplay.c line 273
char get_computer_next_move(signed int cursor);
// get_config_int
// file /usr/include/allegro/config.h line 42
signed int get_config_int(const char *, const char *, signed int);
// get_config_string
// file /usr/include/allegro/config.h line 41
const char * get_config_string(const char *, const char *, const char *);
// get_cpu_vs_human_str
// file advanced.c line 83
static char * get_cpu_vs_human_str(void);
// get_cursor
// file score.c line 97
static signed int get_cursor(signed int classement);
// get_cursor_from_team
// file decal.c line 76
signed int get_cursor_from_team(signed int team);
// get_fullscreen_str
// file graphics.c line 129
static char * get_fullscreen_str(void);
// get_game_res_str
// file graphics.c line 81
static char * get_game_res_str(void);
// get_key_name
// file team.c line 242
static char * get_key_name(signed int num);
// get_logic_rate
// file profile.h line 76
signed int get_logic_rate(void);
// get_main_dir
// file fighter.h line 70
signed int get_main_dir(struct anonymous_0 *mesh, signed int team, signed int sens, signed int start);
// get_menu_res_str
// file graphics.c line 95
static char * get_menu_res_str(void);
// get_mono_texture_color
// file palette.c line 191
static void get_mono_texture_color(struct RGB *rgb, signed int num);
// get_page_flip_str
// file graphics.c line 119
static char * get_page_flip_str(void);
// get_palette
// file /usr/include/allegro/color.h line 78
void get_palette(struct RGB *);
// get_profile
// file profile.h line 74
signed int get_profile(signed int indice);
// get_raw_texture
// file texture.c line 360
static void * get_raw_texture(signed int num);
// get_ticker
// file ticker.h line 64
signed int get_ticker(void);
// get_wave_mode_str
// file graphics.c line 109
static char * get_wave_mode_str(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getpixel
// file /usr/include/allegro/inline/draw.inl line 30
static inline signed int getpixel(struct BITMAP *bmp, signed int x, signed int y);
// getpixel_link1
// file /usr/include/allegro/inline/draw.inl line 30
static inline signed int getpixel_link1(struct BITMAP *bmp_link1, signed int x_link1, signed int y_link1);
// getpixel_link2
// file /usr/include/allegro/inline/draw.inl line 30
static inline signed int getpixel_link2(struct BITMAP *bmp_link2, signed int x_link2, signed int y_link2);
// getpixel_link3
// file /usr/include/allegro/inline/draw.inl line 30
static inline signed int getpixel_link3(struct BITMAP *bmp_link3, signed int x_link3, signed int y_link3);
// getpixel_link4
// file /usr/include/allegro/inline/draw.inl line 30
static inline signed int getpixel_link4(struct BITMAP *bmp_link4, signed int x_link4, signed int y_link4);
// getpixel_link5
// file /usr/include/allegro/inline/draw.inl line 30
static inline signed int getpixel_link5(struct BITMAP *bmp_link5, signed int x_link5, signed int y_link5);
// getpixel_link6
// file /usr/include/allegro/inline/draw.inl line 30
static inline signed int getpixel_link6(struct BITMAP *bmp_link6, signed int x_link6, signed int y_link6);
// graphic_options
// file graphics.c line 187
signed int graphic_options(void);
// group_mesher
// file mesh.c line 166
static signed int group_mesher(struct anonymous *mesher, struct BITMAP *map, signed int step);
// gui_get_screen
// file /usr/include/allegro/gui.h line 197
struct BITMAP * gui_get_screen(void);
// gui_mouse_b_object
//
signed int gui_mouse_b_object(void);
// gui_mouse_x_object
//
signed int gui_mouse_x_object(void);
// gui_mouse_y_object
//
signed int gui_mouse_y_object(void);
// gui_textout_ex
// file /usr/include/allegro/gui.h line 198
signed int gui_textout_ex(struct BITMAP *, const char *, signed int, signed int, signed int, signed int, signed int);
// hline
// file /usr/include/allegro/inline/draw.inl line 68
static inline void hline(struct BITMAP *bmp, signed int x1, signed int y, signed int x2, signed int color);
// hline_link1
// file /usr/include/allegro/inline/draw.inl line 68
static inline void hline_link1(struct BITMAP *bmp_link1, signed int x1_link1, signed int y_link1, signed int x2_link1, signed int color_link1);
// hline_link2
// file /usr/include/allegro/inline/draw.inl line 68
static inline void hline_link2(struct BITMAP *bmp_link2, signed int x1_link2, signed int y_link2, signed int x2_link2, signed int color_link2);
// hsv_to_rgb
// file /usr/include/allegro/color.h line 122
void hsv_to_rgb(float, float, float, signed int *, signed int *, signed int *);
// inet_aton
// file /usr/include/arpa/inet.h line 73
extern signed int inet_aton(const char *, struct in_addr *);
// inet_ntoa
// file /usr/include/arpa/inet.h line 53
extern char * inet_ntoa(struct in_addr);
// init_all
// file init.c line 113
signed int init_all();
// init_cursor
// file cursor.c line 101
static void init_cursor(signed int index, signed int team, signed int x, signed int y, char *name);
// init_cursor_control_method
// file game.c line 167
static void init_cursor_control_method(void);
// init_dialog
// file /usr/include/allegro/gui.h line 210
struct DIALOG_PLAYER * init_dialog(struct DIALOG *, signed int);
// init_disp_cursor
// file pion.h line 62
void init_disp_cursor(void);
// init_distorsion_displayer
// file distor.c line 119
void init_distorsion_displayer(void);
// init_distorsion_target
// file distor.c line 99
static void init_distorsion_target(void);
// init_game
// file game.c line 255
char * init_game(void);
// init_info_bar
// file info.c line 97
signed int init_info_bar(signed int w, signed int h, signed int epaisseur);
// init_move_fighters
// file fighter.c line 146
void init_move_fighters(void);
// init_tombola
// file score.c line 195
static void init_tombola();
// init_viewport_size
// file viewport.c line 96
static void init_viewport_size(signed int x, signed int y, signed int w, signed int h);
// install_int_ex
// file /usr/include/allegro/timer.h line 58
signed int install_int_ex(void (*)(void), signed long int);
// install_joystick
// file /usr/include/allegro/joystick.h line 128
signed int install_joystick(signed int);
// install_keyboard
// file /usr/include/allegro/keyboard.h line 50
signed int install_keyboard(void);
// install_mouse
// file /usr/include/allegro/mouse.h line 56
signed int install_mouse(void);
// install_sound
// file /usr/include/allegro/sound.h line 34
signed int install_sound(signed int, signed int, const char *);
// install_timer
// file /usr/include/allegro/timer.h line 55
signed int install_timer(void);
// int_to_ascii_hexa
// file netkey.c line 115
static char int_to_ascii_hexa(signed int src);
// internet_find
// file internet.c line 122
signed int internet_find(void);
// is_arg_marker
// file parser.c line 75
static signed int is_arg_marker(char c);
// is_linear_bitmap
// file /usr/include/allegro/inline/gfx.inl line 138
static inline signed int is_linear_bitmap(struct BITMAP *bmp);
// is_memory_bitmap
// file /usr/include/allegro/inline/gfx.inl line 154
static inline signed int is_memory_bitmap(struct BITMAP *bmp);
// is_touched_key
// file keyboard.c line 99
signed int is_touched_key(signed int i);
// itofix
// file /usr/include/allegro/inline/fmaths.inl line 181
static inline signed int itofix(signed int x);
// itofix_link1
// file /usr/include/allegro/inline/fmaths.inl line 181
static inline signed int itofix_link1(signed int x_link1);
// keypressed
// file /usr/include/allegro/keyboard.h line 68
signed int keypressed(void);
// language_options
// file language.c line 89
signed int language_options(void);
// last_flip
// file viewport.h line 77
void last_flip(void);
// list_callback
// file internet.c line 286
static char * list_callback(signed int index, signed int *size);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// load_bitmap
// file /usr/include/allegro/datafile.h line 91
struct BITMAP * load_bitmap(const char *, struct RGB *);
// load_config_options
// file config.c line 502
signed int load_config_options(void);
// load_custom
// file disk.c line 566
signed int load_custom(void);
// load_custom_map
// file disk.c line 504
static signed int load_custom_map(void);
// load_custom_map_callback
// file disk.c line 481
static signed int load_custom_map_callback(const char *file, signed int mode, void *unused);
// load_custom_music
// file disk.c line 547
static signed int load_custom_music(void);
// load_custom_music_callback
// file disk.c line 523
static signed int load_custom_music_callback(const char *file, signed int mode, void *unused);
// load_custom_texture
// file disk.c line 462
static signed int load_custom_texture(void);
// load_custom_texture_callback
// file disk.c line 438
static signed int load_custom_texture_callback(const char *file, signed int mode, void *unused);
// load_dat
// file disk.c line 306
signed int load_dat(void);
// load_datafile_object
// file /usr/include/allegro/datafile.h line 81
struct DATAFILE * load_datafile_object(const char *, const char *);
// load_default_options
// file config.c line 194
void load_default_options(void);
// load_default_rules
// file config.c line 318
void load_default_rules(void);
// load_disk_options
// file config.c line 336
static signed int load_disk_options(void);
// load_midi
// file /usr/include/allegro/midi.h line 118
struct MIDI * load_midi(const char *);
// lock_sound
// file disk.c line 126
static void lock_sound(struct SAMPLE *smp);
// log_beep
// file logcli.c line 253
void log_beep();
// log_exit
// file log.h line 69
void log_exit(void);
// log_flush
// file log.h line 75
void log_flush();
// log_init
// file log.h line 68
void log_init(void);
// log_print_int
// file log.h line 71
void log_print_int(signed int i);
// log_print_str
// file log.h line 70
void log_print_str(char *str);
// log_println
// file log.h line 72
void log_println();
// log_println_int
// file logcli.c line 214
void log_println_int(signed int i);
// log_println_str
// file log.h line 73
void log_println_str(char *str);
// log_set_server_mode
// file logcli.c line 277
void log_set_server_mode(signed int mode);
// logic
// file game.c line 557
static void logic(void);
// lw_about
// file about.c line 79
signed int lw_about(void);
// lw_asm_check_struct_align
// file asm.c line 97
extern signed int lw_asm_check_struct_align(void);
// lw_basicopt_legal_info
// file basicopt.c line 121
void lw_basicopt_legal_info(char *name);
// lw_basicopt_process
// file basicopt.c line 74
signed int lw_basicopt_process(char *name);
// lw_capture_dump_game
// file capture.c line 163
extern signed int lw_capture_dump_game();
// lw_capture_dump_menu
// file capture.c line 112
extern signed int lw_capture_dump_menu();
// lw_capture_get_mode
// file capture.c line 90
extern signed int lw_capture_get_mode();
// lw_capture_set_mode
// file capture.c line 100
extern void lw_capture_set_mode(signed int mode);
// lw_chat_get
// file chat.c line 135
signed int lw_chat_get(struct anonymous_13 *history, struct anonymous_24 *message, signed int i);
// lw_chat_pop
// file chat.c line 105
signed int lw_chat_pop(struct anonymous_13 *history, struct anonymous_24 *message);
// lw_chat_push
// file chat.c line 79
void lw_chat_push(struct anonymous_13 *history, char *author, char *content);
// lw_chat_reset
// file chat.c line 69
void lw_chat_reset(struct anonymous_13 *history);
// lw_checksum_calc
// file checksum.c line 81
signed int lw_checksum_calc(struct anonymous_21 *army, signed int army_size);
// lw_config_set_current_rules_to_default
// file config.c line 627
void lw_config_set_current_rules_to_default(void);
// lw_connect_menu
// file connect.c line 125
signed int lw_connect_menu(signed int sock);
// lw_dnsutil_name_to_ip
// file dnsutil.c line 84
signed int lw_dnsutil_name_to_ip(char *ip, char *name);
// lw_exec2_run
// file exec2.c line 69
signed int lw_exec2_run(char *file, char *commandline);
// lw_httputil_get_page
// file httputil.c line 104
signed int lw_httputil_get_page(char *content, char *url, signed int size);
// lw_httputil_text_to_urlparam
// file httputil.c line 229
void lw_httputil_text_to_urlparam(char *urlparam, char *text, signed int size);
// lw_info_get_room_for_viewport
// file info.c line 364
void lw_info_get_room_for_viewport(signed int *x, signed int *y, signed int *w, signed int *h);
// lw_keyboard_reset_hack
// file keyboard.h line 69
void lw_keyboard_reset_hack(void);
// lw_keyexch_flush
// file keyexch.c line 173
signed int lw_keyexch_flush(struct anonymous_23 *cursors, unsigned int checksum);
// lw_lang_auto
// file lang.c line 156
extern signed int lw_lang_auto();
// lw_lang_init
// file lang.h line 298
extern void lw_lang_init();
// lw_lang_language
// file lang.c line 124
extern char * lw_lang_language(signed int lang);
// lw_lang_string
// file lang.h line 299
extern char * lw_lang_string(signed int id);
// lw_langde_init
// file langde.h line 69
extern void lw_langde_init();
// lw_langde_string
// file langde.h line 70
extern char * lw_langde_string(signed int id);
// lw_langdk_init
// file langdk.h line 69
extern void lw_langdk_init();
// lw_langdk_string
// file langdk.h line 70
extern char * lw_langdk_string(signed int id);
// lw_langen_init
// file langen.h line 69
extern void lw_langen_init();
// lw_langen_string
// file langen.h line 70
extern char * lw_langen_string(signed int id);
// lw_langfr_init
// file langfr.h line 69
extern void lw_langfr_init();
// lw_langfr_string
// file langfr.h line 70
extern char * lw_langfr_string(signed int id);
// lw_map_archive_raw
// file map.h line 71
void * lw_map_archive_raw(const char *filename);
// lw_map_archive_raw_bmp
// file map.c line 371
void * lw_map_archive_raw_bmp(struct BITMAP *bmp, struct RGB *pal, const char *filename);
// lw_map_create_bicolor
// file map.c line 502
struct BITMAP * lw_map_create_bicolor(signed int num, signed int fg, signed int bg, signed int network, signed int random, signed int min_w, signed int min_h, signed int *zoom_factor);
// lw_map_create_textured
// file map.c line 590
struct BITMAP * lw_map_create_textured(signed int num, signed int fg, signed int bg, signed int network, signed int random, signed int min_w, signed int min_h);
// lw_map_get_readable_name
// file map.h line 81
char * lw_map_get_readable_name(signed int num, signed int network, signed int random);
// lw_map_get_res
// file map.h line 82
void lw_map_get_res(signed int num, signed int *w, signed int *h, signed int network, signed int random, signed int min_w, signed int min_h);
// lw_map_get_safe
// file map.c line 471
static void * lw_map_get_safe(signed int num, signed int network, signed int random);
// lw_map_get_system_name
// file map.c line 656
char * lw_map_get_system_name(signed int num, signed int network, signed int random);
// lw_maptex_create_bg
// file maptex.h line 77
struct BITMAP * lw_maptex_create_bg(signed int num, signed int bg, signed int network, signed int random, signed int use_default_texture);
// lw_maptex_create_fg
// file maptex.h line 75
struct BITMAP * lw_maptex_create_fg(signed int num, signed int fg, signed int network, signed int random, signed int use_default_texture);
// lw_maptex_create_map
// file maptex.h line 72
struct BITMAP * lw_maptex_create_map(signed int num, signed int fg, signed int bg, signed int network, signed int random, signed int min_w, signed int min_h, signed int use_default_texture);
// lw_maptex_is_custom_texture_used
// file maptex.h line 68
signed int lw_maptex_is_custom_texture_used(signed int num, signed int texture, signed int network, signed int random, signed int use_default_texture);
// lw_maptex_set_bg_palette
// file maptex.h line 81
void lw_maptex_set_bg_palette(signed int num, signed int bg, signed int network, signed int random, signed int use_default_texture);
// lw_maptex_set_fg_palette
// file maptex.h line 79
void lw_maptex_set_fg_palette(signed int num, signed int fg, signed int network, signed int random, signed int use_default_texture);
// lw_mouse_hide
// file mouse.c line 169
void lw_mouse_hide(void);
// lw_mouse_reset_control
// file mouse.h line 79
void lw_mouse_reset_control(void);
// lw_mouse_show
// file mouse.h line 81
void lw_mouse_show(void);
// lw_mouse_update_control
// file mouse.h line 78
void lw_mouse_update_control(void);
// lw_mouse_update_show_hide
// file mouse.c line 139
void lw_mouse_update_show_hide(void);
// lw_mutex_init
// file mutxunix.c line 78
signed int lw_mutex_init(struct anonymous_1 *mutex);
// lw_mutex_lock
// file mutxgen.h line 68
signed int lw_mutex_lock(struct anonymous_1 *mutex);
// lw_mutex_trylock
// file mutxgen.h line 69
signed int lw_mutex_trylock(struct anonymous_1 *mutex);
// lw_mutex_unlock
// file mutxgen.h line 70
signed int lw_mutex_unlock(struct anonymous_1 *mutex);
// lw_netconf_check
// file netconf.h line 86
signed int lw_netconf_check(struct anonymous_4 *config);
// lw_netconf_print
// file netconf.c line 266
void lw_netconf_print(struct anonymous_4 *config);
// lw_netconf_recv
// file netconf.c line 178
signed int lw_netconf_recv(signed int *sock, struct anonymous_4 *config);
// lw_netconf_send
// file netconf.c line 112
signed int lw_netconf_send(signed int *sock, struct anonymous_4 *config);
// lw_netkey_peek
// file netkey.h line 90
signed int lw_netkey_peek(signed int *sock, signed int num);
// lw_netkey_recv
// file netkey.h line 89
signed int lw_netkey_recv(signed int *sock, struct anonymous_5 *netkey);
// lw_netkey_reset
// file netkey.h line 87
void lw_netkey_reset(struct anonymous_5 *netkey);
// lw_netkey_send
// file netkey.h line 88
signed int lw_netkey_send(signed int *sock, struct anonymous_5 *netkey);
// lw_netmap_recv
// file netmap.c line 140
signed int lw_netmap_recv(signed int *sock, void **netmap);
// lw_netmap_send
// file netmap.c line 86
signed int lw_netmap_send(signed int *sock, void *netmap);
// lw_netmess_cleanup_arg
// file netmess.h line 137
extern void lw_netmess_cleanup_arg(char *string);
// lw_netmess_free
// file netmess.c line 432
extern void lw_netmess_free(struct anonymous_6 *ptr);
// lw_netmess_read
// file netmess.c line 411
extern struct anonymous_6 * lw_netmess_read(char *message);
// lw_network_attribute_colors
// file network.h line 89
extern void lw_network_attribute_colors();
// lw_network_attribute_parts
// file network.h line 90
extern void lw_network_attribute_parts();
// lw_path_get_system_name
// file path.h line 69
char * lw_path_get_system_name(const char *filename);
// lw_ping_try_server
// file ping.c line 117
signed int lw_ping_try_server(char *address, signed int port);
// lw_protocol_ask_free_teams
// file protocol.h line 84
signed int lw_protocol_ask_free_teams(signed int *sock, signed int *nb);
// lw_protocol_ask_teamstartinfo
// file protocol.h line 96
signed int lw_protocol_ask_teamstartinfo(signed int *sock, signed int team, struct anonymous_12 *team_start_info);
// lw_protocol_ask_who
// file protocol.h line 87
signed int lw_protocol_ask_who(signed int *sock, signed int num, struct anonymous_8 *who);
// lw_protocol_chat_listen
// file protocol.h line 99
signed int lw_protocol_chat_listen(signed int *sock, struct anonymous_13 *chat_history);
// lw_protocol_chat_talk
// file protocol.h line 98
signed int lw_protocol_chat_talk(signed int *sock, char *text);
// lw_protocol_do_ping
// file protocol.h line 80
signed int lw_protocol_do_ping(signed int *sock);
// lw_protocol_force_start
// file protocol.h line 94
signed int lw_protocol_force_start(signed int *sock);
// lw_protocol_i_am_ready
// file protocol.h line 92
signed int lw_protocol_i_am_ready(signed int *sock);
// lw_protocol_next
// file protocol.h line 95
signed int lw_protocol_next(signed int *sock);
// lw_protocol_quit
// file protocol.h line 100
signed int lw_protocol_quit(signed int *sock);
// lw_protocol_recv_config
// file protocol.h line 91
signed int lw_protocol_recv_config(signed int *sock);
// lw_protocol_recv_map
// file protocol.h line 89
signed int lw_protocol_recv_map(signed int *sock, void **map);
// lw_protocol_reserve_team
// file protocol.h line 85
signed int lw_protocol_reserve_team(signed int *sock, signed int num, signed int control_type, char *name);
// lw_protocol_send_config
// file protocol.h line 90
signed int lw_protocol_send_config(signed int *sock);
// lw_protocol_send_map
// file protocol.h line 88
signed int lw_protocol_send_map(signed int *sock, void *map);
// lw_protocol_tell_password
// file protocol.h line 83
signed int lw_protocol_tell_password(signed int *sock, char *password);
// lw_protocol_tell_program
// file protocol.h line 82
signed int lw_protocol_tell_program(signed int *sock, char *program);
// lw_protocol_tell_version
// file protocol.h line 81
signed int lw_protocol_tell_version(signed int *sock, char *version);
// lw_protocol_waiting
// file protocol.h line 93
signed int lw_protocol_waiting(signed int *sock, signed int *waited_teams);
// lw_random_generate_map
// file random.h line 76
signed int lw_random_generate_map();
// lw_serial_get_int
// file serial.c line 83
signed int lw_serial_get_int(void *raw);
// lw_serial_get_map_header
// file serial.h line 76
void lw_serial_get_map_header(void *raw_map, signed int *size, signed short int *w, signed short int *h);
// lw_serial_get_short
// file serial.c line 126
signed short int lw_serial_get_short(void *raw);
// lw_serial_get_texture_header
// file serial.c line 196
void lw_serial_get_texture_header(void *raw_texture, signed short int *w, signed short int *h);
// lw_serial_set_int
// file serial.c line 105
void lw_serial_set_int(void *raw, signed int i);
// lw_serial_set_map_header
// file serial.h line 77
void lw_serial_set_map_header(void *raw_map, signed int size, signed short int w, signed short int h);
// lw_serial_set_short
// file serial.c line 144
void lw_serial_set_short(void *raw, signed int s);
// lw_serial_set_texture_header
// file serial.c line 214
void lw_serial_set_texture_header(void *raw_texture, signed short int w, signed short int h);
// lw_sock_accept
// file sockunix.c line 175
signed int lw_sock_accept(signed int *new_sock, char *ip, signed int *port, signed int listening_sock, signed int wait);
// lw_sock_close
// file sockgen.h line 68
signed int lw_sock_close(signed int *sock);
// lw_sock_connect
// file sockgen.h line 62
signed int lw_sock_connect(signed int *sock, char *ip, signed int port);
// lw_sock_exit
// file sockgen.h line 58
signed int lw_sock_exit();
// lw_sock_init
// file sockgen.h line 57
signed int lw_sock_init();
// lw_sock_init::_tmp::return_value_signal_1_object
//
void return_value_signal_1_object(signed int);
// lw_sock_listen
// file sockunix.c line 142
signed int lw_sock_listen(signed int *sock, signed int port);
// lw_sock_peek
// file sock2gen.h line 72
signed int lw_sock_peek(signed int *sock, signed int len);
// lw_sock_peek_ex
// file sockgen.h line 63
signed int lw_sock_peek_ex(signed int *sock, signed int len);
// lw_sock_recv_buffer
// file sock2gen.h line 76
signed int lw_sock_recv_buffer(signed int *sock, char *buffer, signed int len);
// lw_sock_recv_buffer_ex
// file sockgen.h line 67
signed int lw_sock_recv_buffer_ex(signed int *sock, char *buffer, signed int len);
// lw_sock_recv_str
// file sock2gen.h line 74
signed int lw_sock_recv_str(signed int *sock, char *str);
// lw_sock_recv_str_ex
// file sockgen.h line 65
signed int lw_sock_recv_str_ex(signed int *sock, char *str);
// lw_sock_send_buffer
// file sock2gen.h line 75
signed int lw_sock_send_buffer(signed int *sock, char *buffer, signed int len);
// lw_sock_send_buffer_ex
// file sockgen.h line 66
signed int lw_sock_send_buffer_ex(signed int *sock, char *buffer, signed int len);
// lw_sock_send_str
// file sock2gen.h line 73
signed int lw_sock_send_str(signed int *sock, char *str);
// lw_sock_send_str_ex
// file sockgen.h line 64
signed int lw_sock_send_str_ex(signed int *sock, char *str);
// lw_teamstartinfo_reset
// file startinf.h line 71
void lw_teamstartinfo_reset(struct anonymous_12 *teamstartinfo);
// lw_texture_archive_raw
// file texture.h line 71
void * lw_texture_archive_raw(const char *filename);
// lw_texture_create_bg
// file texture.h line 72
struct BITMAP * lw_texture_create_bg(signed int num);
// lw_texture_create_fg
// file texture.h line 73
struct BITMAP * lw_texture_create_fg(signed int num);
// lw_texture_get_system_name
// file texture.h line 74
char * lw_texture_get_system_name(signed int num);
// lw_thread_start
// file thrdgen.h line 53
signed int lw_thread_start(void (*func)(void *), void *args);

//

// lw_viewport_register_change
// file viewport.h line 78
void lw_viewport_register_change(signed int count);
// lw_wwwcli_get_games
// file wwwcli.h line 86
signed int lw_wwwcli_get_games(struct anonymous_15 *buffer, signed int *size);
// main_info
// file dialog.c line 249
void main_info(struct DIALOG *d, char *str);
// main_menu
// file menu.h line 67
void main_menu(void);
// main_message
// file dialog.c line 237
void main_message(struct DIALOG *d, char *str);
// makecol
// file /usr/include/allegro/color.h line 127
signed int makecol(signed int, signed int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// malloc_big_data
// file bigdata.c line 104
void * malloc_big_data(void);
// malloc_in_big_data_bottom
// file bigdata.h line 70
void * malloc_in_big_data_bottom(signed int size);
// malloc_in_big_data_top
// file bigdata.c line 177
void * malloc_in_big_data_top(signed int size);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// menu_real_coord
// file dialog.h line 103
void menu_real_coord(struct DIALOG *d);
// menu_real_x
// file dialog.c line 79
signed int menu_real_x(signed int x);
// menu_real_y
// file dialog.c line 86
signed int menu_real_y(signed int y);
// mesher_to_mesh
// file mesh.c line 240
static struct anonymous_0 * mesher_to_mesh(struct anonymous *mesher, struct BITMAP *map, signed int *size, signed int *w, signed int *h);
// message_int
// file message.c line 146
void message_int(signed int val);
// message_str
// file message.h line 60
void message_str(char *str);
// message_str_int
// file message.h line 62
void message_str_int(char *str, signed int val);
// move_all_cursors
// file move.h line 71
void move_all_cursors(void);
// move_cursor
// file move.c line 206
static void move_cursor(signed int indice);
// move_fighters
// file fighter.c line 300
void move_fighters(void);
// move_if_free
// file move.c line 87
static signed int move_if_free(signed int *x, signed int *y, signed int dir);
// my_button_proc
// file alleg2.h line 69
signed int my_button_proc(signed int msg, struct DIALOG *d, signed int c);
// my_create_bitmap
// file alleg2.c line 1647
struct BITMAP * my_create_bitmap(signed int w, signed int h);
// my_ctext_proc
// file alleg2.c line 644
signed int my_ctext_proc(signed int msg, struct DIALOG *d, signed int c);
// my_do_dialog
// file dialog.h line 117
signed int my_do_dialog(struct DIALOG *d, signed int f);
// my_do_dialog_no_clear
// file dialog.c line 273
signed int my_do_dialog_no_clear(struct DIALOG *d, signed int f);
// my_dotted_rect
// file alleg2.c line 95
static void my_dotted_rect(signed int x1, signed int y1, signed int x2, signed int y2, signed int fg, signed int bg);
// my_draw_listbox
// file alleg2.c line 1378
static void my_draw_listbox(struct DIALOG *d);
// my_draw_textbox
// file alleg2.c line 118
static void my_draw_textbox(char *thetext, signed int *listsize, signed int draw, signed int offset, signed int wword, signed int tabsize, signed int x, signed int y, signed int w, signed int h, signed int disabled, signed int fore, signed int deselect, signed int disable);
// my_edit_proc
// file alleg2.c line 956
signed int my_edit_proc(signed int msg, struct DIALOG *d, signed int c);
// my_exit
// file exit.h line 76
void my_exit(signed int code);
// my_exit_close_button
// file exit.c line 266
void my_exit_close_button(void);
// my_exit_poll
// file exit.h line 75
void my_exit_poll();
// my_fade_in
// file palette.h line 91
void my_fade_in(void);
// my_fade_out
// file palette.h line 90
void my_fade_out(void);
// my_handle_listbox_click
// file alleg2.c line 1297
static void my_handle_listbox_click(struct DIALOG *d);
// my_handle_scrollable_scroll
// file alleg2.c line 1245
static void my_handle_scrollable_scroll(struct DIALOG *d, signed int listsize, signed int *index, signed int *offset);
// my_handle_scrollable_scroll_click
// file alleg2.c line 1181
static void my_handle_scrollable_scroll_click(struct DIALOG *d, signed int listsize, signed int *offset, signed int height);
// my_idle_cb
// file alleg2.c line 1286
static void my_idle_cb(void);
// my_init_dialog
// file dialog.h line 115
struct DIALOG_PLAYER * my_init_dialog(struct DIALOG *d, signed int f);
// my_initialise_joystick
// file joystick.h line 98
signed int my_initialise_joystick(void);
// my_list_proc
// file alleg2.c line 1478
signed int my_list_proc(signed int msg, struct DIALOG *d, signed int c);
// my_play_sample
// file sound.c line 153
static void my_play_sample(struct SAMPLE *s, signed int vol);
// my_poll_joystick
// file joystick.h line 99
void my_poll_joystick(void);
// my_set_palette
// file palette.h line 85
void my_set_palette(void);
// my_slider_proc
// file alleg2.h line 72
signed int my_slider_proc(signed int msg, struct DIALOG *d, signed int c);

//

// my_text_proc
// file alleg2.c line 617
signed int my_text_proc(signed int msg, struct DIALOG *d, signed int c);
// my_textbox_proc
// file alleg2.h line 68
signed int my_textbox_proc(signed int msg, struct DIALOG *d, signed int c);
// my_update_dialog
// file dialog.h line 118
signed int my_update_dialog(struct DIALOG_PLAYER *player);
// need_to_change_mode
// file gfxmode.c line 137
signed int need_to_change_mode(signed int res1, signed int res2, signed int flip);
// netplay_sequence
// file netplay.h line 65
signed int netplay_sequence(void);
// network_game
// file netgame.h line 61
signed int network_game(void);
// next_line
// file wwwcli.c line 416
static void next_line(char **str);
// object_message
// file /usr/include/allegro/gui.h line 205
signed int object_message(struct DIALOG *, signed int, signed int);
// options
// file options.h line 66
signed int options(void);
// order_map
// file disk.c line 611
void order_map(void);
// page_flip
// file viewport.h line 76
struct BITMAP * page_flip(void);
// palette_128
// file level.c line 86
static void palette_128(struct DIALOG *d, signed int x, signed int y, signed int w, signed int h);
// parse_line
// file wwwcli.c line 199
static signed int parse_line(struct anonymous_15 *result, char **str);
// place_all_team
// file army.c line 192
void place_all_team(void);
// place_team
// file army.c line 119
static void place_team(signed int part, signed int team);
// play_click
// file sound.h line 66
void play_click(void);
// play_connect
// file sound.h line 71
void play_connect(void);
// play_go
// file sound.h line 67
void play_go(void);
// play_loose
// file sound.h line 70
void play_loose(void);
// play_midi
// file /usr/include/allegro/midi.h line 120
signed int play_midi(struct MIDI *, signed int);
// play_sample
// file /usr/include/allegro/digi.h line 151
signed int play_sample(const struct SAMPLE *, signed int, signed int, signed int, signed int);
// play_sequence
// file play.h line 66
signed int play_sequence(void);
// play_sequence_ex
// file play.h line 67
signed int play_sequence_ex(void);
// play_time
// file sound.c line 204
void play_time(void);
// play_win
// file sound.h line 68
void play_win(void);
// poll_joystick
// file /usr/include/allegro/joystick.h line 131
signed int poll_joystick(void);
// position_chat_history
// file connect.c line 567
static void position_chat_history(struct DIALOG *d);
// position_comment
// file internet.c line 266
static void position_comment(struct DIALOG *d);
// position_list
// file internet.c line 250
static void position_list(struct DIALOG *d);
// position_mouse
// file /usr/include/allegro/mouse.h line 103
void position_mouse(signed int, signed int);
// position_players_list
// file connect.c line 552
static void position_players_list(struct DIALOG *d);
// prepare_help
// file help.c line 74
void prepare_help(struct DIALOG *d, char *str);
// prepare_wave_shapes
// file distor.c line 243
void prepare_wave_shapes(void);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_2 *, const union anonymous_3 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_2 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous_2 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_2 *);
// putpixel
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel(struct BITMAP *bmp, signed int x, signed int y, signed int color);
// putpixel_link1
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link1(struct BITMAP *bmp_link1, signed int x_link1, signed int y_link1, signed int color_link1);
// putpixel_link2
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link2(struct BITMAP *bmp_link2, signed int x_link2, signed int y_link2, signed int color_link2);
// putpixel_link3
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link3(struct BITMAP *bmp_link3, signed int x_link3, signed int y_link3, signed int color_link3);
// putpixel_link4
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link4(struct BITMAP *bmp_link4, signed int x_link4, signed int y_link4, signed int color_link4);
// putpixel_link5
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link5(struct BITMAP *bmp_link5, signed int x_link5, signed int y_link5, signed int color_link5);
// putpixel_link6
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link6(struct BITMAP *bmp_link6, signed int x_link6, signed int y_link6, signed int color_link6);
// putpixel_link7
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link7(struct BITMAP *bmp_link7, signed int x_link7, signed int y_link7, signed int color_link7);
// putpixel_link8
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link8(struct BITMAP *bmp_link8, signed int x_link8, signed int y_link8, signed int color_link8);
// quick_buttons
// file dialog.h line 107
void quick_buttons(struct DIALOG *d);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// random_free_xy_by_control_type
// file autoplay.c line 185
static signed int random_free_xy_by_control_type(signed int *x, signed int *y, signed int team, signed int control_type);
// random_free_xy_different_team
// file autoplay.c line 244
static void random_free_xy_different_team(signed int *x, signed int *y, signed int team);
// read_back_dat
// file disk.c line 233
static void read_back_dat(struct DATAFILE *df);
// read_command_line
// file parser.h line 68
void read_command_line(signed int argc, char **argv);
// read_eol
// file wwwcli.c line 365
static signed int read_eol(char **str);
// read_eol_n
// file wwwcli.c line 390
static signed int read_eol_n(char **str, signed int n);
// read_font_dat
// file disk.c line 275
static void read_font_dat(struct DATAFILE *df);
// read_int
// file wwwcli.c line 311
static signed int read_int(signed int *result, char **str);
// read_map_dat
// file disk.c line 219
static void read_map_dat(struct DATAFILE *df);
// read_maptex_dat
// file disk.c line 205
static void read_maptex_dat(struct DATAFILE *df);
// read_music_dat
// file disk.c line 292
static void read_music_dat(struct DATAFILE *df);
// read_separator
// file netmess.c line 109
static signed int read_separator(char **message);
// read_separator_link1
// file wwwcli.c line 340
static signed int read_separator_link1(char **str);
// read_sfx_dat
// file disk.c line 138
static void read_sfx_dat(struct DATAFILE *df);
// read_string
// file wwwcli.c line 259
static signed int read_string(char *result, char **str, signed int size);
// read_texture_dat
// file disk.c line 191
static void read_texture_dat(struct DATAFILE *df);
// read_water_dat
// file disk.c line 173
static void read_water_dat(struct DATAFILE *df);
// read_word
// file netmess.c line 130
static char * read_word(char **message);
// readkey
// file /usr/include/allegro/keyboard.h line 69
signed int readkey(void);
// recalculate_number_of_colors
// file texture.c line 104
static signed int recalculate_number_of_colors(signed int max_number, struct BITMAP *bmp, struct RGB *pal);
// rect
// file /usr/include/allegro/inline/draw.inl line 112
static inline void rect(struct BITMAP *bmp, signed int x1, signed int y_1, signed int x2, signed int y2, signed int color);
// rect_link1
// file /usr/include/allegro/inline/draw.inl line 112
static inline void rect_link1(struct BITMAP *bmp_link1, signed int x1_link1, signed int y_1_link1, signed int x2_link1, signed int y2_link1, signed int color_link1);
// rect_for_viewport
// file viewport.h line 75
void rect_for_viewport(void);
// rectfill
// file /usr/include/allegro/inline/draw.inl line 88
static inline void rectfill(struct BITMAP *bmp, signed int x1, signed int y_1, signed int x2, signed int y2, signed int color);
// rectfill_link1
// file /usr/include/allegro/inline/draw.inl line 88
static inline void rectfill_link1(struct BITMAP *bmp_link1, signed int x1_link1, signed int y_1_link1, signed int x2_link1, signed int y2_link1, signed int color_link1);
// rectfill_link2
// file /usr/include/allegro/inline/draw.inl line 88
static inline void rectfill_link2(struct BITMAP *bmp_link2, signed int x1_link2, signed int y_1_link2, signed int x2_link2, signed int y2_link2, signed int color_link2);
// rectfill_link3
// file /usr/include/allegro/inline/draw.inl line 88
static inline void rectfill_link3(struct BITMAP *bmp_link3, signed int x1_link3, signed int y_1_link3, signed int x2_link3, signed int y2_link3, signed int color_link3);
// rectfill_link4
// file /usr/include/allegro/inline/draw.inl line 88
static inline void rectfill_link4(struct BITMAP *bmp_link4, signed int x1_link4, signed int y_1_link4, signed int x2_link4, signed int y2_link4, signed int color_link4);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// recv_keys
// file keyexch.c line 136
static signed int recv_keys(signed int *sock, struct anonymous_23 *cursors);
// recv_ok
// file protocol.c line 79
static signed int recv_ok(signed int *sock);
// red8col
// file texture.c line 205
static void red8col(struct BITMAP *bmp, struct RGB *pal, signed int first_color, signed int number_of_colors);
// redraw_team_box
// file team.c line 292
static void redraw_team_box(struct DIALOG *d, signed int number);
// remove_int
// file /usr/include/allegro/timer.h line 60
void remove_int(void (*)(void));
// remove_keyboard
// file /usr/include/allegro/keyboard.h line 51
void remove_keyboard(void);
// remove_mouse
// file /usr/include/allegro/mouse.h line 57
void remove_mouse(void);
// remove_sound
// file /usr/include/allegro/sound.h line 35
void remove_sound(void);
// remove_timer
// file /usr/include/allegro/timer.h line 56
void remove_timer(void);
// reset_all_cursor
// file cursor.c line 86
void reset_all_cursor(void);
// reset_all_profile
// file profile.h line 70
void reset_all_profile(void);
// reset_big_data
// file bigdata.c line 89
void reset_big_data(void);
// reset_code
// file code.c line 257
void reset_code(void);
// reset_computer_path
// file autoplay.c line 172
void reset_computer_path(void);
// reset_game_area
// file area.c line 72
void reset_game_area(void);
// reset_mesh
// file mesh.h line 132
void reset_mesh(void);
// reset_profile
// file profile.c line 98
void reset_profile(signed int indice);
// rest
// file /usr/include/allegro/timer.h line 68
void rest(unsigned int);
// rest_callback
// file /usr/include/allegro/timer.h line 69
void rest_callback(unsigned int, void (*)(void));
// retrieve_choose_level_xy
// file level.c line 135
static void retrieve_choose_level_xy(signed int *x1, signed int *x2, signed int *x3, signed int *x4, signed int *x5, signed int *x6, signed int *x7, signed int *x8, signed int *y1, signed int *y2, signed int *y3, signed int *y4, signed int *y5, signed int *y6, signed int *y7, signed int *y8);
// return_d_close
// file error.c line 73
static signed int return_d_close(void);
// rules_options
// file rules.h line 65
signed int rules_options(void);
// save_bitmap
// file /usr/include/allegro/datafile.h line 100
signed int save_bitmap(const char *, struct BITMAP *, struct RGB *);
// save_config_options
// file config.c line 518
signed int save_config_options(void);
// scare_mouse
// file /usr/include/allegro/mouse.h line 100
void scare_mouse(void);
// scroll_screen
// file /usr/include/allegro/gfx.h line 413
signed int scroll_screen(signed int, signed int);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_14 *, struct anonymous_14 *, struct anonymous_14 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// send_keys
// file keyexch.c line 85
static signed int send_keys(signed int *sock, struct anonymous_23 *cursors, unsigned int checksum);
// set_auto_check
// file startup.c line 243
static void set_auto_check(void);
// set_bg_dialogs_visibility
// file level.c line 310
static void set_bg_dialogs_visibility(struct DIALOG *d, signed int *just_hidden);
// set_bg_texture_palette
// file palette.h line 86
void set_bg_texture_palette(signed int num);
// set_bigdata_size
// file startup.c line 166
static void set_bigdata_size(void);
// set_c_or_asm
// file startup.c line 227
static void set_c_or_asm(void);
// set_clip_rect
// file /usr/include/allegro/gfx.h line 425
void set_clip_rect(struct BITMAP *, signed int, signed int, signed int, signed int);
// set_close_button_callback
// file /usr/include/allegro/system.h line 98
signed int set_close_button_callback(void (*)(void));
// set_color_conversion
// file /usr/include/allegro/gfx.h line 408
void set_color_conversion(signed int);
// set_color_depth
// file /usr/include/allegro/gfx.h line 406
void set_color_depth(signed int);
// set_config_file
// file /usr/include/allegro/config.h line 28
void set_config_file(const char *);
// set_config_int
// file /usr/include/allegro/config.h line 50
void set_config_int(const char *, const char *, signed int);
// set_config_string
// file /usr/include/allegro/config.h line 49
void set_config_string(const char *, const char *, const char *);
// set_dialog_visibility
// file level.c line 258
static void set_dialog_visibility(struct DIALOG *d, signed int state);
// set_fg_dialogs_visibility
// file level.c line 281
static void set_fg_dialogs_visibility(struct DIALOG *d, signed int *just_hidden);
// set_fg_texture_palette
// file palette.h line 87
void set_fg_texture_palette(signed int num);
// set_gfx_mode
// file /usr/include/allegro/gfx.h line 412
signed int set_gfx_mode(signed int, signed int, signed int, signed int, signed int);
// set_graphic_possibilities
// file startup.c line 219
static void set_graphic_possibilities(void);
// set_joystick
// file startup.c line 183
static void set_joystick(void);
// set_load_states
// file startup.c line 191
static void set_load_states(void);
// set_metaserver
// file startup.c line 411
static void set_metaserver(void);
// set_misc
// file startup.c line 426
static void set_misc(void);
// set_mono_texture_palette
// file palette.c line 227
static void set_mono_texture_palette(signed int num, signed int first);
// set_mouse_sprite
// file /usr/include/allegro/mouse.h line 112
void set_mouse_sprite(struct BITMAP *);
// set_palette
// file /usr/include/allegro/color.h line 74
void set_palette(struct RGB *);
// set_palette_for_choose_color
// file palette.h line 88
void set_palette_for_choose_color(void);
// set_path
// file startup.c line 314
static void set_path(void);
// set_playing_teams_palette
// file palette.c line 365
void set_playing_teams_palette(void);
// set_raw_texture_palette
// file palette.c line 174
static void set_raw_texture_palette(void *ptr, signed int first);
// set_resolution
// file gfxmode.c line 187
signed int set_resolution(signed int res, signed int flip, signed int fullscreen, signed int *flip_enabled);
// set_safe
// file startup.c line 260
static void set_safe(void);
// set_startup
// file startup.h line 104
void set_startup(void);
// set_stop
// file startup.c line 235
static void set_stop(void);
// set_team_color
// file palette.c line 339
static void set_team_color(signed int teinte, signed int first, signed int num);
// set_uformat
// file /usr/include/allegro/unicode.h line 34
void set_uformat(signed int);
// set_various_hacks
// file startup.c line 440
static void set_various_hacks(void);
// set_volume
// file /usr/include/allegro/sound.h line 40
void set_volume(signed int, signed int);
// set_window_title
// file /usr/include/allegro/inline/system.inl line 29
static inline void set_window_title(const char *name);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// show_mouse
// file /usr/include/allegro/mouse.h line 99
void show_mouse(struct BITMAP *);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// shutdown_dialog
// file /usr/include/allegro/gui.h line 212
signed int shutdown_dialog(struct DIALOG_PLAYER *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// skip_space
// file wwwcli.c line 245
static void skip_space(char **str);
// slider_bg
// file level.c line 562
static signed int slider_bg(void *dp3, signed int d2);
// slider_brightness
// file graphics.c line 173
static signed int slider_brightness(void *dp3, signed int d2);
// slider_cis
// file rules.c line 98
static signed int slider_cis(void *dp3, signed int d2);
// slider_fg
// file level.c line 547
static signed int slider_fg(void *dp3, signed int d2);
// slider_fps
// file speeds.c line 106
static signed int slider_fps(void *dp3, signed int d2);
// slider_game_res
// file graphics.c line 139
static signed int slider_game_res(void *dp3, signed int d2);
// slider_int
// file dialog.h line 120
signed int slider_int(void *dp3, signed int d2);
// slider_map
// file level.c line 532
static signed int slider_map(void *dp3, signed int d2);
// slider_menu_res
// file graphics.c line 155
static signed int slider_menu_res(void *dp3, signed int d2);
// slider_mmr
// file rules.c line 170
static signed int slider_mmr(void *dp3, signed int d2);
// slider_mouse
// file controls.c line 75
static signed int slider_mouse(void *dp3, signed int d2);
// slider_rps
// file speeds.c line 150
static signed int slider_rps(void *dp3, signed int d2);
// slider_time
// file rules.c line 129
static signed int slider_time(void *dp3, signed int d2);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sort_light_and_dark
// file map.c line 107
static void sort_light_and_dark(struct BITMAP *bmp, struct RGB *pal);
// sound_options
// file volume.h line 66
signed int sound_options(void);
// speeds_options
// file speeds.h line 65
signed int speeds_options(void);
// spread_color_down
// file map.c line 169
static signed int spread_color_down(struct BITMAP *bmp, signed int color1, signed int color2);
// spread_color_up
// file map.c line 217
static signed int spread_color_up(struct BITMAP *bmp, signed int color1, signed int color2);
// spread_single_gradient
// file grad.h line 73
void spread_single_gradient(void);
// sqr255
// file palette.c line 100
static signed int sqr255(signed int i);
// sqrt255
// file palette.c line 87
static signed int sqrt255(signed int i);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// standard_big_button
// file dialog.h line 111
void standard_big_button(struct DIALOG *d, signed int x_pos, signed int y_pos, signed int x_num, signed int y_num);
// standard_button
// file dialog.h line 108
void standard_button(struct DIALOG *d, signed int x_pos, signed int y_pos, signed int x_num, signed int y_num);
// standard_error
// file error.c line 80
static signed int standard_error(char *str);
// standard_small_button
// file dialog.c line 193
void standard_small_button(struct DIALOG *d, signed int x_pos, signed int y_pos, signed int x_num, signed int y_num);
// start_graphic
// file init.c line 260
signed int start_graphic(void);
// start_music
// file music.c line 80
extern signed int start_music(void);
// start_play_time
// file time.h line 76
void start_play_time(void);
// start_profile
// file profile.h line 72
void start_profile(signed int indice);
// start_ticker
// file ticker.h line 62
signed int start_ticker(void);
// start_water
// file sound.h line 63
signed int start_water(void);
// stop_music
// file music.c line 128
extern void stop_music(void);
// stop_profile
// file profile.h line 73
void stop_profile(signed int indice);
// stop_ticker
// file ticker.h line 63
void stop_ticker(void);
// stop_water
// file sound.h line 64
void stop_water(void);
// stretch_blit
// file /usr/include/allegro/draw.h line 57
void stretch_blit(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int, signed int, signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// suppress_conflicting_color
// file team.c line 225
static signed int suppress_conflicting_color(signed int color, signed int replacement_color);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// team_param
// file team.c line 308
static void team_param(struct DIALOG *d, signed int x, signed int y, signed int number);
// test_army
// file army.c line 240
void test_army(void);
// test_mesh
// file mesh.c line 322
void test_mesh(void);
// test_one_mesh
// file mesh.c line 306
static void test_one_mesh(struct anonymous_0 *test);
// text_height
// file /usr/include/allegro/text.h line 45
signed int text_height(struct FONT *);
// text_length
// file /usr/include/allegro/text.h line 44
signed int text_length(struct FONT *, const char *);
// textout_ex
// file /usr/include/allegro/text.h line 36
void textout_ex(struct BITMAP *, struct FONT *, const char *, signed int, signed int, signed int, signed int);
// texture_8to5
// file texture.c line 222
static void texture_8to5(struct BITMAP *bmp, struct RGB *pal, void *result, signed int first_color, signed int number_of_colors, char *filename);
// ticker_handler
// file ticker.c line 81
static void ticker_handler(void);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tmpnam
// file /usr/include/stdio.h line 209
extern char * tmpnam(char *);
// try_one_mode
// file gfxmode.c line 147
static signed int try_one_mode(signed int res, signed int flip, signed int fullscreen);
// try_server_callback
// file ping.c line 164
static void try_server_callback(void *arg);
// ugetat
// file /usr/include/allegro/unicode.h line 60
signed int ugetat(const char *, signed int);
// ugetc_object
//
signed int ugetc_object(const char *);
// ugetx_object
//
signed int ugetx_object(char **);
// uinsert
// file /usr/include/allegro/unicode.h line 62
signed int uinsert(char *, signed int, signed int);
// uisok_object
//
signed int uisok_object(signed int);
// uisspace
// file /usr/include/allegro/unicode.h line 66
signed int uisspace(signed int);
// undisp_all_cursors
// file pion.h line 64
void undisp_all_cursors(void);
// undisp_cursor
// file pion.c line 198
static void undisp_cursor(signed int number);
// unscare_mouse
// file /usr/include/allegro/mouse.h line 102
void unscare_mouse(void);
// uoffset
// file /usr/include/allegro/unicode.h line 59
signed int uoffset(const char *, signed int);
// update_choose_map
// file level.c line 410
static void update_choose_map(struct DIALOG *d, signed int map, signed int fg, signed int bg, signed int random, signed int use_default_texture);
// update_connect_menu
// file connect.c line 331
static signed int update_connect_menu(struct DIALOG *d, signed int waited_teams, struct anonymous_12 *team_start_info, struct anonymous_13 *chat_history, signed int *connected_teams_prev);
// update_dialog
// file /usr/include/allegro/gui.h line 211
signed int update_dialog(struct DIALOG_PLAYER *);
// update_key_cpu_cursor
// file move.c line 452
static void update_key_cpu_cursor(signed int indice);
// update_key_local_cursor
// file move.c line 429
static void update_key_local_cursor(signed int indice);
// update_language
// file language.c line 74
static void update_language(struct DIALOG *d);
// update_logic_rate
// file profile.h line 75
void update_logic_rate(signed int logic_number);
// update_play_time
// file time.h line 75
void update_play_time(void);
// update_team_box
// file team.c line 264
static void update_team_box(struct DIALOG *d, signed int number);
// update_text_comment
// file internet.c line 507
static void update_text_comment(signed int i);
// update_text_password
// file internet.c line 396
static void update_text_password(signed int i);
// update_text_ping
// file internet.c line 340
static void update_text_ping(signed int i);
// update_text_port
// file internet.c line 373
static void update_text_port(signed int i);
// update_text_uptime
// file internet.c line 432
static void update_text_uptime(signed int i);
// update_use_default_texture_state
// file level.c line 577
static void update_use_default_texture_state(struct DIALOG *d);
// uremove
// file /usr/include/allegro/unicode.h line 63
signed int uremove(char *, signed int);
// usetat
// file /usr/include/allegro/unicode.h line 61
signed int usetat(char *, signed int, signed int);
// usetc_object
//
signed int usetc_object(char *, signed int);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// ustrlen
// file /usr/include/allegro/unicode.h line 73
signed int ustrlen(const char *);
// ustrzcpy
// file /usr/include/allegro/unicode.h line 71
char * ustrzcpy(char *, signed int, const char *);
// uwidth_object
//
signed int uwidth_object(const char *);
// vline
// file /usr/include/allegro/inline/draw.inl line 67
static inline void vline(struct BITMAP *bmp, signed int x, signed int y_1, signed int y2, signed int color);
// vline_link1
// file /usr/include/allegro/inline/draw.inl line 67
static inline void vline_link1(struct BITMAP *bmp_link1, signed int x_link1, signed int y_1_link1, signed int y2_link1, signed int color_link1);
// vline_link2
// file /usr/include/allegro/inline/draw.inl line 67
static inline void vline_link2(struct BITMAP *bmp_link2, signed int x_link2, signed int y_1_link2, signed int y2_link2, signed int color_link2);
// vline_link3
// file /usr/include/allegro/inline/draw.inl line 67
static inline void vline_link3(struct BITMAP *bmp_link3, signed int x_link3, signed int y_1_link3, signed int y2_link3, signed int color_link3);
// wait_key_pressed
// file keyboard.c line 231
signed int wait_key_pressed(void);
// wait_no_key
// file keyboard.c line 202
void wait_no_key(void);
// watchdog_is_keyword
// file watchdog.h line 71
signed int watchdog_is_keyword(char *keyword);
// watchdog_reset
// file watchdog.h line 70
void watchdog_reset();
// watchdog_update
// file watchdog.h line 69
void watchdog_update();
// water_handler
// file sound.c line 89
static void water_handler(void);
// wave_options
// file wave.h line 66
signed int wave_options(void);
// write_cis_setting
// file rules.c line 84
static void write_cis_setting(struct DIALOG *d);
// write_fps_setting
// file speeds.c line 82
static void write_fps_setting(struct DIALOG *d);
// write_mmr_setting
// file rules.c line 155
static void write_mmr_setting(struct DIALOG *d);
// write_rps_setting
// file speeds.c line 126
static void write_rps_setting(struct DIALOG *d);
// write_score
// file score.c line 130
static void write_score(signed int indice, char *buffer, signed int fill_level);
// write_time
// file time.h line 77
void write_time(signed int time, char *buffer);
// write_time_setting
// file rules.c line 118
static void write_time_setting(struct DIALOG *d);

struct anonymous_22
{
  // mesh
  struct anonymous_0 *mesh;
  // fighter
  struct anonymous_21 *fighter;
};

struct anonymous_26
{
  // data
  unsigned char *data;
  // len
  signed int len;
};

struct anonymous_1
{
  // data
  void *data;
};

struct anonymous_24
{
  // author
  char author[11l];
  // content
  char content[81l];
};

struct anonymous_14
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_15
{
  // label
  char label[50l];
  // ip
  char ip[16l];
  // port
  signed int port;
  // uptime
  signed int uptime;
  // busy_players
  signed int busy_players;
  // max_players
  signed int max_players;
  // password
  signed int password;
  // comment
  char comment[101l];
  // ping_delay
  signed int ping_delay;
};

struct anonymous_5
{
  // key_states
  signed int key_states[6l];
  // cmd
  signed int cmd;
  // arg
  signed int arg;
  // checksum
  unsigned int checksum;
};

struct anonymous_20
{
  // decal_for_dir
  signed int decal_for_dir : 8;
  // size
  signed int size : 24;
};

struct anonymous_18
{
  // dir
  signed int dir : 8;
  // grad
  signed int grad : 24;
};

struct anonymous_16
{
  // x
  signed short int x;
  // y
  signed short int y;
};

struct anonymous_21
{
  // x
  signed short int x;
  // y
  signed short int y;
  // health
  signed short int health;
  // team
  char team;
  // last_dir
  char last_dir;
};

union anonymous_17
{
  // time
  signed int time;
  // cursor
  struct anonymous_16 cursor;
};

struct anonymous_19
{
  // update
  union anonymous_17 update;
  // state
  struct anonymous_18 state;
};

struct anonymous_0
{
  // x
  signed short int x;
  // y
  signed short int y;
  // side
  struct anonymous_20 side;
  // info
  struct anonymous_19 info[6l];
  // link
  void *link[12l];
};

struct anonymous_8
{
  // active
  signed int active;
  // network
  signed int network;
  // server_id
  signed int server_id;
  // control_type
  signed int control_type;
  // color
  signed int color;
  // part
  signed int part;
  // name
  char name[11l];
};

struct anonymous_12
{
  // active
  signed int active;
  // start
  signed int start;
  // name
  char name[11l];
};

struct anonymous_6
{
  // argc
  signed int argc;
  // code
  signed int code;
  // argv
  char **argv;
};

struct anonymous_4
{
  // cursor_increase_speed
  signed int cursor_increase_speed;
  // fighter_attack
  signed int fighter_attack;
  // fighter_defense
  signed int fighter_defense;
  // fighter_new_health
  signed int fighter_new_health;
  // number_influence
  signed int number_influence;
  // fighter_number
  signed int fighter_number;
  // game_time
  signed int game_time;
  // cpu_advantage
  signed int cpu_advantage;
  // cpu_vs_human
  signed int cpu_vs_human;
  // asm_algorithm
  signed int asm_algorithm;
  // min_map_res
  signed int min_map_res;
};

struct anonymous_13
{
  // n
  signed int n;
  // messages
  struct anonymous_24 messages[20l];
};

struct anonymous_9
{
  // sock
  signed int sock;
  // address
  char address[16l];
  // port
  signed int port;
  // allow_exit
  signed int allow_exit;
  // done
  signed int done;
  // result
  signed int result;
};

struct anonymous_7
{
  // sock
  signed int sock;
  // address
  char address[16l];
  // port
  signed int port;
  // running
  signed int running;
  // allow_exit
  signed int allow_exit;
  // free_data
  signed int free_data;
  // result
  signed int result;
};

struct anonymous_25
{
  // sock
  signed int sock;
  // team_start_info
  struct anonymous_12 team_start_info[6l];
  // waited_teams
  signed int waited_teams;
  // start
  signed int start;
  // force_start
  signed int force_start;
  // thread_running
  signed int thread_running;
  // result
  signed int result;
  // finished
  signed int finished;
  // chat_buffer
  char chat_buffer[81l];
  // chat_history
  struct anonymous_13 chat_history;
  // chat_send
  signed int chat_send;
};

struct anonymous_11
{
  // start
  signed int start;
  // record_number
  signed int record_number;
  // total_time
  signed int total_time;
};

struct anonymous_23
{
  // val
  signed int val;
  // x
  signed int x;
  // y
  signed int y;
  // active
  signed int active;
  // team
  signed int team;
  // loose_time
  signed int loose_time;
  // score_order
  signed int score_order;
  // color_entry
  signed int color_entry;
  // key_state
  signed int key_state;
  // control_type
  signed int control_type;
  // from_network
  signed int from_network;
  // name
  char name[11l];
};

struct anonymous_10
{
  // x
  signed int x;
  // y
  signed int y;
  // color
  signed int color;
  // row
  signed int row;
};

struct anonymous
{
  // used
  char used;
  // size
  signed short int size;
  // link
  void *link[12l];
  // corres
  signed int corres;
};

union anonymous_3
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_2
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct BITMAP
{
  // w
  signed int w;
  // h
  signed int h;
  // clip
  signed int clip;
  // cl
  signed int cl;
  // cr
  signed int cr;
  // ct
  signed int ct;
  // cb
  signed int cb;
  // vtable
  struct GFX_VTABLE *vtable;
  // write_bank
  void *write_bank;
  // read_bank
  void *read_bank;
  // dat
  void *dat;
  // id
  unsigned long int id;
  // extra
  void *extra;
  // x_ofs
  signed int x_ofs;
  // y_ofs
  signed int y_ofs;
  // seg
  signed int seg;
  // line
  unsigned char *line[0l];
};

struct DATAFILE
{
  // dat
  void *dat;
  // type
  signed int type;
  // size
  signed long int size;
  // prop
  struct DATAFILE_PROPERTY *prop;
};

struct DATAFILE_PROPERTY
{
  // dat
  char *dat;
  // type
  signed int type;
};

struct DIALOG
{
  // proc
  signed int (*proc)(signed int, struct DIALOG *, signed int);
  // x
  signed int x;
  // y
  signed int y;
  // w
  signed int w;
  // h
  signed int h;
  // fg
  signed int fg;
  // bg
  signed int bg;
  // key
  signed int key;
  // flags
  signed int flags;
  // d1
  signed int d1;
  // d2
  signed int d2;
  // dp
  void *dp;
  // dp2
  void *dp2;
  // dp3
  void *dp3;
};

struct DIALOG_PLAYER
{
  // obj
  signed int obj;
  // res
  signed int res;
  // mouse_obj
  signed int mouse_obj;
  // focus_obj
  signed int focus_obj;
  // joy_on
  signed int joy_on;
  // click_wait
  signed int click_wait;
  // mouse_ox
  signed int mouse_ox;
  // mouse_oy
  signed int mouse_oy;
  // mouse_oz
  signed int mouse_oz;
  // mouse_b
  signed int mouse_b;
  // dialog
  struct DIALOG *dialog;
};

struct DIGI_DRIVER
{
  // id
  signed int id;
  // name
  const char *name;
  // desc
  const char *desc;
  // ascii_name
  const char *ascii_name;
  // voices
  signed int voices;
  // basevoice
  signed int basevoice;
  // max_voices
  signed int max_voices;
  // def_voices
  signed int def_voices;
  // detect
  signed int (*detect)(signed int);
  // init
  signed int (*init)(signed int, signed int);
  // exit
  void (*exit)(signed int);
  // set_mixer_volume
  signed int (*set_mixer_volume)(signed int);
  // get_mixer_volume
  signed int (*get_mixer_volume)(void);
  // lock_voice
  void * (*lock_voice)(signed int, signed int, signed int);
  // unlock_voice
  void (*unlock_voice)(signed int);
  // buffer_size
  signed int (*buffer_size)(void);
  // init_voice
  void (*init_voice)(signed int, const struct SAMPLE *);
  // release_voice
  void (*release_voice)(signed int);
  // start_voice
  void (*start_voice)(signed int);
  // stop_voice
  void (*stop_voice)(signed int);
  // loop_voice
  void (*loop_voice)(signed int, signed int);
  // get_position
  signed int (*get_position)(signed int);
  // set_position
  void (*set_position)(signed int, signed int);
  // get_volume
  signed int (*get_volume)(signed int);
  // set_volume
  void (*set_volume)(signed int, signed int);
  // ramp_volume
  void (*ramp_volume)(signed int, signed int, signed int);
  // stop_volume_ramp
  void (*stop_volume_ramp)(signed int);
  // get_frequency
  signed int (*get_frequency)(signed int);
  // set_frequency
  void (*set_frequency)(signed int, signed int);
  // sweep_frequency
  void (*sweep_frequency)(signed int, signed int, signed int);
  // stop_frequency_sweep
  void (*stop_frequency_sweep)(signed int);
  // get_pan
  signed int (*get_pan)(signed int);
  // set_pan
  void (*set_pan)(signed int, signed int);
  // sweep_pan
  void (*sweep_pan)(signed int, signed int, signed int);
  // stop_pan_sweep
  void (*stop_pan_sweep)(signed int);
  // set_echo
  void (*set_echo)(signed int, signed int, signed int);
  // set_tremolo
  void (*set_tremolo)(signed int, signed int, signed int);
  // set_vibrato
  void (*set_vibrato)(signed int, signed int, signed int);
  // rec_cap_bits
  signed int rec_cap_bits;
  // rec_cap_stereo
  signed int rec_cap_stereo;
  // rec_cap_rate
  signed int (*rec_cap_rate)(signed int, signed int);
  // rec_cap_parm
  signed int (*rec_cap_parm)(signed int, signed int, signed int);
  // rec_source
  signed int (*rec_source)(signed int);
  // rec_start
  signed int (*rec_start)(signed int, signed int, signed int);
  // rec_stop
  void (*rec_stop)(void);
  // rec_read
  signed int (*rec_read)(void *);
};

struct FONT
{
  // data
  void *data;
  // height
  signed int height;
  // vtable
  struct FONT_VTABLE *vtable;
};

struct FONT_GLYPH
{
  // w
  signed short int w;
  // h
  signed short int h;
  // dat
  unsigned char dat[0l];
};

struct GFX_DRIVER
{
  // id
  signed int id;
  // name
  const char *name;
  // desc
  const char *desc;
  // ascii_name
  const char *ascii_name;
  // init
  struct BITMAP * (*init)(signed int, signed int, signed int, signed int, signed int);
  // exit
  void (*exit)(struct BITMAP *);
  // scroll
  signed int (*scroll)(signed int, signed int);
  // vsync
  void (*vsync)(void);
  // set_palette
  void (*set_palette)(struct RGB *, signed int, signed int, signed int);
  // request_scroll
  signed int (*request_scroll)(signed int, signed int);
  // poll_scroll
  signed int (*poll_scroll)(void);
  // enable_triple_buffer
  void (*enable_triple_buffer)(void);
  // create_video_bitmap
  struct BITMAP * (*create_video_bitmap)(signed int, signed int);
  // destroy_video_bitmap
  void (*destroy_video_bitmap)(struct BITMAP *);
  // show_video_bitmap
  signed int (*show_video_bitmap)(struct BITMAP *);
  // request_video_bitmap
  signed int (*request_video_bitmap)(struct BITMAP *);
  // create_system_bitmap
  struct BITMAP * (*create_system_bitmap)(signed int, signed int);
  // destroy_system_bitmap
  void (*destroy_system_bitmap)(struct BITMAP *);
  // set_mouse_sprite
  signed int (*set_mouse_sprite)(struct BITMAP *, signed int, signed int);
  // show_mouse
  signed int (*show_mouse)(struct BITMAP *, signed int, signed int);
  // hide_mouse
  void (*hide_mouse)(void);
  // move_mouse
  void (*move_mouse)(signed int, signed int);
  // drawing_mode
  void (*drawing_mode)(void);
  // save_video_state
  void (*save_video_state)(void);
  // restore_video_state
  void (*restore_video_state)(void);
  // set_blender_mode
  void (*set_blender_mode)(signed int, signed int, signed int, signed int, signed int);
  // fetch_mode_list
  struct GFX_MODE_LIST * (*fetch_mode_list)(void);
  // w
  signed int w;
  // h
  signed int h;
  // linear
  signed int linear;
  // bank_size
  signed long int bank_size;
  // bank_gran
  signed long int bank_gran;
  // vid_mem
  signed long int vid_mem;
  // vid_phys_base
  signed long int vid_phys_base;
  // windowed
  signed int windowed;
};

struct GFX_MODE
{
  // width
  signed int width;
  // height
  signed int height;
  // bpp
  signed int bpp;
};

struct GFX_MODE_LIST
{
  // num_modes
  signed int num_modes;
  // mode
  struct GFX_MODE *mode;
};

struct GFX_VTABLE
{
  // color_depth
  signed int color_depth;
  // mask_color
  signed int mask_color;
  // unwrite_bank
  void *unwrite_bank;
  // set_clip
  void (*set_clip)(struct BITMAP *);
  // acquire
  void (*acquire)(struct BITMAP *);
  // release
  void (*release)(struct BITMAP *);
  // create_sub_bitmap
  struct BITMAP * (*create_sub_bitmap)(struct BITMAP *, signed int, signed int, signed int, signed int);
  // created_sub_bitmap
  void (*created_sub_bitmap)(struct BITMAP *, struct BITMAP *);
  // getpixel
  signed int (*getpixel)(struct BITMAP *, signed int, signed int);
  // putpixel
  void (*putpixel)(struct BITMAP *, signed int, signed int, signed int);
  // vline
  void (*vline)(struct BITMAP *, signed int, signed int, signed int, signed int);
  // hline
  void (*hline)(struct BITMAP *, signed int, signed int, signed int, signed int);
  // hfill
  void (*hfill)(struct BITMAP *, signed int, signed int, signed int, signed int);
  // line
  void (*line)(struct BITMAP *, signed int, signed int, signed int, signed int, signed int);
  // fastline
  void (*fastline)(struct BITMAP *, signed int, signed int, signed int, signed int, signed int);
  // rectfill
  void (*rectfill)(struct BITMAP *, signed int, signed int, signed int, signed int, signed int);
  // triangle
  void (*triangle)(struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int, signed int);
  // draw_sprite
  void (*draw_sprite)(struct BITMAP *, struct BITMAP *, signed int, signed int);
  // draw_256_sprite
  void (*draw_256_sprite)(struct BITMAP *, struct BITMAP *, signed int, signed int);
  // draw_sprite_v_flip
  void (*draw_sprite_v_flip)(struct BITMAP *, struct BITMAP *, signed int, signed int);
  // draw_sprite_h_flip
  void (*draw_sprite_h_flip)(struct BITMAP *, struct BITMAP *, signed int, signed int);
  // draw_sprite_vh_flip
  void (*draw_sprite_vh_flip)(struct BITMAP *, struct BITMAP *, signed int, signed int);
  // draw_trans_sprite
  void (*draw_trans_sprite)(struct BITMAP *, struct BITMAP *, signed int, signed int);
  // draw_trans_rgba_sprite
  void (*draw_trans_rgba_sprite)(struct BITMAP *, struct BITMAP *, signed int, signed int);
  // draw_lit_sprite
  void (*draw_lit_sprite)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int);
  // draw_rle_sprite
  void (*draw_rle_sprite)(struct BITMAP *, struct RLE_SPRITE *, signed int, signed int);
  // draw_trans_rle_sprite
  void (*draw_trans_rle_sprite)(struct BITMAP *, struct RLE_SPRITE *, signed int, signed int);
  // draw_trans_rgba_rle_sprite
  void (*draw_trans_rgba_rle_sprite)(struct BITMAP *, struct RLE_SPRITE *, signed int, signed int);
  // draw_lit_rle_sprite
  void (*draw_lit_rle_sprite)(struct BITMAP *, struct RLE_SPRITE *, signed int, signed int, signed int);
  // draw_character
  void (*draw_character)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int);
  // draw_glyph
  void (*draw_glyph)(struct BITMAP *, struct FONT_GLYPH *, signed int, signed int, signed int, signed int);
  // blit_from_memory
  void (*blit_from_memory)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int);
  // blit_to_memory
  void (*blit_to_memory)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int);
  // blit_from_system
  void (*blit_from_system)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int);
  // blit_to_system
  void (*blit_to_system)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int);
  // blit_to_self
  void (*blit_to_self)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int);
  // blit_to_self_forward
  void (*blit_to_self_forward)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int);
  // blit_to_self_backward
  void (*blit_to_self_backward)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int);
  // blit_between_formats
  void (*blit_between_formats)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int);
  // masked_blit
  void (*masked_blit)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int);
  // clear_to_color
  void (*clear_to_color)(struct BITMAP *, signed int);
  // pivot_scaled_sprite_flip
  void (*pivot_scaled_sprite_flip)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int, signed int);
  // do_stretch_blit
  void (*do_stretch_blit)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int, signed int, signed int, signed int);
  // draw_gouraud_sprite
  void (*draw_gouraud_sprite)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int);
  // draw_sprite_end
  void (*draw_sprite_end)(void);
  // blit_end
  void (*blit_end)(void);
  // polygon
  void (*polygon)(struct BITMAP *, signed int, const signed int *, signed int);
  // rect
  void (*rect)(struct BITMAP *, signed int, signed int, signed int, signed int, signed int);
  // circle
  void (*circle)(struct BITMAP *, signed int, signed int, signed int, signed int);
  // circlefill
  void (*circlefill)(struct BITMAP *, signed int, signed int, signed int, signed int);
  // ellipse
  void (*ellipse)(struct BITMAP *, signed int, signed int, signed int, signed int, signed int);
  // ellipsefill
  void (*ellipsefill)(struct BITMAP *, signed int, signed int, signed int, signed int, signed int);
  // arc
  void (*arc)(struct BITMAP *, signed int, signed int, signed int, signed int, signed int, signed int);
  // spline
  void (*spline)(struct BITMAP *, const signed int *, signed int);
  // floodfill
  void (*floodfill)(struct BITMAP *, signed int, signed int, signed int);
  // polygon3d
  void (*polygon3d)(struct BITMAP *, signed int, struct BITMAP *, signed int, struct V3D **);
  // polygon3d_f
  void (*polygon3d_f)(struct BITMAP *, signed int, struct BITMAP *, signed int, struct V3D_f **);
  // triangle3d
  void (*triangle3d)(struct BITMAP *, signed int, struct BITMAP *, struct V3D *, struct V3D *, struct V3D *);
  // triangle3d_f
  void (*triangle3d_f)(struct BITMAP *, signed int, struct BITMAP *, struct V3D_f *, struct V3D_f *, struct V3D_f *);
  // quad3d
  void (*quad3d)(struct BITMAP *, signed int, struct BITMAP *, struct V3D *, struct V3D *, struct V3D *, struct V3D *);
  // quad3d_f
  void (*quad3d_f)(struct BITMAP *, signed int, struct BITMAP *, struct V3D_f *, struct V3D_f *, struct V3D_f *, struct V3D_f *);
  // draw_sprite_ex
  void (*draw_sprite_ex)(struct BITMAP *, struct BITMAP *, signed int, signed int, signed int, signed int);
};

struct JOYSTICK_AXIS_INFO
{
  // pos
  signed int pos;
  // d1
  signed int d1;
  // d2
  signed int d2;
  // name
  const char *name;
};

struct JOYSTICK_BUTTON_INFO
{
  // b
  signed int b;
  // name
  const char *name;
};

struct JOYSTICK_DRIVER
{
  // id
  signed int id;
  // name
  const char *name;
  // desc
  const char *desc;
  // ascii_name
  const char *ascii_name;
  // init
  signed int (*init)(void);
  // exit
  void (*exit)(void);
  // poll
  signed int (*poll)(void);
  // save_data
  signed int (*save_data)(void);
  // load_data
  signed int (*load_data)(void);
  // calibrate_name
  const char * (*calibrate_name)(signed int);
  // calibrate
  signed int (*calibrate)(signed int);
};

struct JOYSTICK_STICK_INFO
{
  // flags
  signed int flags;
  // num_axis
  signed int num_axis;
  // axis
  struct JOYSTICK_AXIS_INFO axis[3l];
  // name
  const char *name;
};

struct JOYSTICK_INFO
{
  // flags
  signed int flags;
  // num_sticks
  signed int num_sticks;
  // num_buttons
  signed int num_buttons;
  // stick
  struct JOYSTICK_STICK_INFO stick[5l];
  // button
  struct JOYSTICK_BUTTON_INFO button[32l];
};

struct KEYBOARD_DRIVER
{
  // id
  signed int id;
  // name
  const char *name;
  // desc
  const char *desc;
  // ascii_name
  const char *ascii_name;
  // autorepeat
  signed int autorepeat;
  // init
  signed int (*init)(void);
  // exit
  void (*exit)(void);
  // poll
  void (*poll)(void);
  // set_leds
  void (*set_leds)(signed int);
  // set_rate
  void (*set_rate)(signed int, signed int);
  // wait_for_input
  void (*wait_for_input)(void);
  // stop_waiting_for_input
  void (*stop_waiting_for_input)(void);
  // scancode_to_ascii
  signed int (*scancode_to_ascii)(signed int);
  // scancode_to_name
  const char * (*scancode_to_name)(signed int);
};

struct MIDI
{
  // divisions
  signed int divisions;
  // track
  struct anonymous_26 track[32l];
};

struct MIDI_DRIVER
{
  // id
  signed int id;
  // name
  const char *name;
  // desc
  const char *desc;
  // ascii_name
  const char *ascii_name;
  // voices
  signed int voices;
  // basevoice
  signed int basevoice;
  // max_voices
  signed int max_voices;
  // def_voices
  signed int def_voices;
  // xmin
  signed int xmin;
  // xmax
  signed int xmax;
  // detect
  signed int (*detect)(signed int);
  // init
  signed int (*init)(signed int, signed int);
  // exit
  void (*exit)(signed int);
  // set_mixer_volume
  signed int (*set_mixer_volume)(signed int);
  // get_mixer_volume
  signed int (*get_mixer_volume)(void);
  // raw_midi
  void (*raw_midi)(signed int);
  // load_patches
  signed int (*load_patches)(const char *, const char *);
  // adjust_patches
  void (*adjust_patches)(const char *, const char *);
  // key_on
  void (*key_on)(signed int, signed int, signed int, signed int, signed int);
  // key_off
  void (*key_off)(signed int);
  // set_volume
  void (*set_volume)(signed int, signed int);
  // set_pitch
  void (*set_pitch)(signed int, signed int, signed int);
  // set_pan
  void (*set_pan)(signed int, signed int);
  // set_vibrato
  void (*set_vibrato)(signed int, signed int);
};

struct MOUSE_DRIVER
{
  // id
  signed int id;
  // name
  const char *name;
  // desc
  const char *desc;
  // ascii_name
  const char *ascii_name;
  // init
  signed int (*init)(void);
  // exit
  void (*exit)(void);
  // poll
  void (*poll)(void);
  // timer_poll
  void (*timer_poll)(void);
  // position
  void (*position)(signed int, signed int);
  // set_range
  void (*set_range)(signed int, signed int, signed int, signed int);
  // set_speed
  void (*set_speed)(signed int, signed int);
  // get_mickeys
  void (*get_mickeys)(signed int *, signed int *);
  // analyse_data
  signed int (*analyse_data)(const char *, signed int);
  // enable_hardware_cursor
  void (*enable_hardware_cursor)(signed int);
  // select_system_cursor
  signed int (*select_system_cursor)(signed int);
};

struct RGB
{
  // r
  unsigned char r;
  // g
  unsigned char g;
  // b
  unsigned char b;
  // filler
  unsigned char filler;
};

struct RLE_SPRITE
{
  // w
  signed int w;
  // h
  signed int h;
  // color_depth
  signed int color_depth;
  // size
  signed int size;
  // dat
  signed char dat[0l];
};

struct SAMPLE
{
  // bits
  signed int bits;
  // stereo
  signed int stereo;
  // freq
  signed int freq;
  // priority
  signed int priority;
  // len
  unsigned long int len;
  // loop_start
  unsigned long int loop_start;
  // loop_end
  unsigned long int loop_end;
  // param
  unsigned long int param;
  // data
  void *data;
};

struct SYSTEM_DRIVER
{
  // id
  signed int id;
  // name
  const char *name;
  // desc
  const char *desc;
  // ascii_name
  const char *ascii_name;
  // init
  signed int (*init)(void);
  // exit
  void (*exit)(void);
  // get_executable_name
  void (*get_executable_name)(char *, signed int);
  // find_resource
  signed int (*find_resource)(char *, const char *, signed int);
  // set_window_title
  void (*set_window_title)(const char *);
  // set_close_button_callback
  signed int (*set_close_button_callback)(void (*)(void));
  // message
  void (*message)(const char *);
  // assert
  void (*assert)(const char *);
  // save_console_state
  void (*save_console_state)(void);
  // restore_console_state
  void (*restore_console_state)(void);
  // create_bitmap
  struct BITMAP * (*create_bitmap)(signed int, signed int, signed int);
  // created_bitmap
  void (*created_bitmap)(struct BITMAP *);
  // create_sub_bitmap
  struct BITMAP * (*create_sub_bitmap)(struct BITMAP *, signed int, signed int, signed int, signed int);
  // created_sub_bitmap
  void (*created_sub_bitmap)(struct BITMAP *, struct BITMAP *);
  // destroy_bitmap
  signed int (*destroy_bitmap)(struct BITMAP *);
  // read_hardware_palette
  void (*read_hardware_palette)(void);
  // set_palette_range
  void (*set_palette_range)(struct RGB *, signed int, signed int, signed int);
  // get_vtable
  struct GFX_VTABLE * (*get_vtable)(signed int);
  // set_display_switch_mode
  signed int (*set_display_switch_mode)(signed int);
  // display_switch_lock
  void (*display_switch_lock)(signed int, signed int);
  // desktop_color_depth
  signed int (*desktop_color_depth)(void);
  // get_desktop_resolution
  signed int (*get_desktop_resolution)(signed int *, signed int *);
  // get_gfx_safe_mode
  void (*get_gfx_safe_mode)(signed int *, struct GFX_MODE *);
  // yield_timeslice
  void (*yield_timeslice)(void);
  // create_mutex
  void * (*create_mutex)(void);
  // destroy_mutex
  void (*destroy_mutex)(void *);
  // lock_mutex
  void (*lock_mutex)(void *);
  // unlock_mutex
  void (*unlock_mutex)(void *);
  // gfx_drivers
  struct _DRIVER_INFO * (*gfx_drivers)(void);
  // digi_drivers
  struct _DRIVER_INFO * (*digi_drivers)(void);
  // midi_drivers
  struct _DRIVER_INFO * (*midi_drivers)(void);
  // keyboard_drivers
  struct _DRIVER_INFO * (*keyboard_drivers)(void);
  // mouse_drivers
  struct _DRIVER_INFO * (*mouse_drivers)(void);
  // joystick_drivers
  struct _DRIVER_INFO * (*joystick_drivers)(void);
  // timer_drivers
  struct _DRIVER_INFO * (*timer_drivers)(void);
};

struct TIMER_DRIVER
{
  // id
  signed int id;
  // name
  const char *name;
  // desc
  const char *desc;
  // ascii_name
  const char *ascii_name;
  // init
  signed int (*init)(void);
  // exit
  void (*exit)(void);
  // install_int
  signed int (*install_int)(void (*)(void), signed long int);
  // remove_int
  void (*remove_int)(void (*)(void));
  // install_param_int
  signed int (*install_param_int)(void (*)(void *), void *, signed long int);
  // remove_param_int
  void (*remove_param_int)(void (*)(void *), void *);
  // can_simulate_retrace
  signed int (*can_simulate_retrace)(void);
  // simulate_retrace
  void (*simulate_retrace)(signed int);
  // rest
  void (*rest)(unsigned int, void (*)(void));
};

struct V3D
{
  // x
  signed int x;
  // y
  signed int y;
  // z
  signed int z;
  // u
  signed int u;
  // v
  signed int v;
  // c
  signed int c;
};

struct V3D_f
{
  // x
  float x;
  // y
  float y;
  // z
  float z;
  // u
  float u;
  // v
  float v;
  // c
  signed int c;
};

struct _DRIVER_INFO
{
  // id
  signed int id;
  // driver
  void *driver;
  // autodetect
  signed int autodetect;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct linger
{
  // l_onoff
  signed int l_onoff;
  // l_linger
  signed int l_linger;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};


// ACTIVE_FIGHTERS
// file decal.c line 67
signed int ACTIVE_FIGHTERS[6l];
// ALLOWED_KEYBOARD_KEY
// file keyboard.c line 82
static char ALLOWED_KEYBOARD_KEY[128l] = { (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0 };
// ARGUMENT_NAME
// file parser.c line 66
static char *ARGUMENT_NAME[256l];
// ARGUMENT_VALUE
// file parser.c line 67
static char *ARGUMENT_VALUE[256l];
// BACK_IMAGE
// file disk.c line 105
struct BITMAP *BACK_IMAGE = (struct BITMAP *)(void *)0;
// BACK_PALETTE
// file disk.c line 114
static struct RGB *BACK_PALETTE = (struct RGB *)(void *)0;
// BELL_RINGING
// file time.c line 78
static signed int BELL_RINGING;
// BIG_DATA_BOTTOM
// file bigdata.c line 75
static signed int BIG_DATA_BOTTOM = 0;
// BIG_DATA_PTR
// file bigdata.c line 73
static void *BIG_DATA_PTR = NULL;
// BIG_DATA_SIZE
// file bigdata.c line 74
static signed int BIG_DATA_SIZE = 0;
// BIG_DATA_TABLE
// file bigdata.c line 77
static signed int BIG_DATA_TABLE[64l];
// BIG_DATA_TOP
// file bigdata.c line 76
static signed int BIG_DATA_TOP = 64 - 1;
// BIG_FONT
// file disk.c line 107
struct FONT *BIG_FONT = (struct FONT *)(void *)0;
// BIG_MOUSE_CURSOR
// file disk.c line 109
struct BITMAP *BIG_MOUSE_CURSOR = (struct BITMAP *)(void *)0;
// CHANGED_INFO_BAR
// file code.c line 82
signed int CHANGED_INFO_BAR = 0;
// COLORS_PER_TEAM
// file palette.c line 74
signed int COLORS_PER_TEAM = 0;
// COLOR_FIRST_ENTRY
// file decal.c line 68
signed int COLOR_FIRST_ENTRY[6l];
// COMPUTER_PATH_KEYS
// file autoplay.c line 76
static char COMPUTER_PATH_KEYS[6l][1024l];
// COMPUTER_PATH_SIZE
// file autoplay.c line 77
static signed int COMPUTER_PATH_SIZE[6l];
// COMPUTER_PATH_WAIT
// file autoplay.c line 78
static signed int COMPUTER_PATH_WAIT[6l];
// CONFIG_ALLOW_NETWORK_BOTS
// file config.c line 171
signed int CONFIG_ALLOW_NETWORK_BOTS;
// CONFIG_ASM_ALGORITHM
// file config.c line 167
signed int CONFIG_ASM_ALGORITHM;
// CONFIG_BRIGHTNESS
// file config.c line 132
signed int CONFIG_BRIGHTNESS;
// CONFIG_CLICK_VOLUME
// file config.c line 139
signed int CONFIG_CLICK_VOLUME;
// CONFIG_CONTROL_TYPE
// file config.c line 152
signed int CONFIG_CONTROL_TYPE[6l];
// CONFIG_CPU_ADVANTAGE
// file config.c line 158
signed int CONFIG_CPU_ADVANTAGE;
// CONFIG_CPU_VS_HUMAN
// file config.c line 159
signed int CONFIG_CPU_VS_HUMAN;
// CONFIG_CURSOR_INCREASE_SPEED
// file config.c line 133
signed int CONFIG_CURSOR_INCREASE_SPEED;
// CONFIG_FIGHTER_ATTACK
// file config.c line 134
signed int CONFIG_FIGHTER_ATTACK;
// CONFIG_FIGHTER_DEFENSE
// file config.c line 135
signed int CONFIG_FIGHTER_DEFENSE;
// CONFIG_FIGHTER_NEW_HEALTH
// file config.c line 136
signed int CONFIG_FIGHTER_NEW_HEALTH;
// CONFIG_FIGHTER_NUMBER
// file config.c line 146
signed int CONFIG_FIGHTER_NUMBER;
// CONFIG_FRAMES_PER_SEC_LIMIT
// file config.c line 163
signed int CONFIG_FRAMES_PER_SEC_LIMIT;
// CONFIG_FULLSCREEN
// file config.c line 127
signed int CONFIG_FULLSCREEN;
// CONFIG_GAME_TIME
// file config.c line 154
signed int CONFIG_GAME_TIME;
// CONFIG_GFX_GAME
// file config.c line 125
signed int CONFIG_GFX_GAME;
// CONFIG_GFX_MENU
// file config.c line 126
signed int CONFIG_GFX_MENU;
// CONFIG_INFO_BAR
// file config.c line 155
signed int CONFIG_INFO_BAR;
// CONFIG_JOYSTICK_ON
// file config.c line 157
signed int CONFIG_JOYSTICK_ON;
// CONFIG_KEY_DOWN
// file config.c line 149
signed int CONFIG_KEY_DOWN[6l];
// CONFIG_KEY_LEFT
// file config.c line 148
signed int CONFIG_KEY_LEFT[6l];
// CONFIG_KEY_RIGHT
// file config.c line 150
signed int CONFIG_KEY_RIGHT[6l];
// CONFIG_KEY_UP
// file config.c line 147
signed int CONFIG_KEY_UP[6l];
// CONFIG_LANGUAGE
// file config.c line 161
signed int CONFIG_LANGUAGE;
// CONFIG_LEVEL_BG
// file config.c line 145
signed int CONFIG_LEVEL_BG;
// CONFIG_LEVEL_FG
// file config.c line 144
signed int CONFIG_LEVEL_FG;
// CONFIG_LEVEL_MAP
// file config.c line 143
signed int CONFIG_LEVEL_MAP;
// CONFIG_MIN_MAP_RES
// file config.c line 169
signed int CONFIG_MIN_MAP_RES;
// CONFIG_MOUSE_GAP
// file config.c line 156
signed int CONFIG_MOUSE_GAP;
// CONFIG_MUSIC_VOLUME
// file config.c line 142
signed int CONFIG_MUSIC_VOLUME;
// CONFIG_NUMBER_INFLUENCE
// file config.c line 137
signed int CONFIG_NUMBER_INFLUENCE;
// CONFIG_PAGE_FLIP
// file config.c line 160
signed int CONFIG_PAGE_FLIP;
// CONFIG_PASSWORD
// file config.c line 168
char CONFIG_PASSWORD[21l];
// CONFIG_PLAYER_NAME
// file config.c line 153
char CONFIG_PLAYER_NAME[6l][11l];
// CONFIG_ROUNDS_PER_SEC_LIMIT
// file config.c line 164
signed int CONFIG_ROUNDS_PER_SEC_LIMIT;
// CONFIG_SERVER_ADDRESS
// file config.c line 165
char CONFIG_SERVER_ADDRESS[51l];
// CONFIG_SERVER_PORT
// file config.c line 166
signed int CONFIG_SERVER_PORT;
// CONFIG_SFX_VOLUME
// file config.c line 138
signed int CONFIG_SFX_VOLUME;
// CONFIG_TEAM_COLOR
// file config.c line 151
signed int CONFIG_TEAM_COLOR[6l];
// CONFIG_USE_DEFAULT_TEXTURE
// file config.c line 170
signed int CONFIG_USE_DEFAULT_TEXTURE;
// CONFIG_VIEWPORT_SIZE
// file config.c line 128
signed int CONFIG_VIEWPORT_SIZE;
// CONFIG_WATER_VOLUME_GAME
// file config.c line 141
signed int CONFIG_WATER_VOLUME_GAME;
// CONFIG_WATER_VOLUME_MENU
// file config.c line 140
signed int CONFIG_WATER_VOLUME_MENU;
// CONFIG_WAVE_AMPLI
// file config.c line 130
signed int CONFIG_WAVE_AMPLI[4l];
// CONFIG_WAVE_NUMBER
// file config.c line 129
signed int CONFIG_WAVE_NUMBER[4l];
// CONFIG_WAVE_ON
// file config.c line 162
signed int CONFIG_WAVE_ON;
// CONFIG_WAVE_SPEED
// file config.c line 131
signed int CONFIG_WAVE_SPEED[4l];
// CURRENT_AREA
// file area.c line 64
struct anonymous_22 *CURRENT_AREA = (struct anonymous_22 *)(void *)0;
// CURRENT_AREA_BACK
// file mesh.c line 91
struct BITMAP *CURRENT_AREA_BACK = (struct BITMAP *)(void *)0;
// CURRENT_AREA_DISP
// file mesh.c line 90
struct BITMAP *CURRENT_AREA_DISP = (struct BITMAP *)(void *)0;
// CURRENT_AREA_H
// file mesh.c line 89
signed int CURRENT_AREA_H = 0;
// CURRENT_AREA_W
// file mesh.c line 88
signed int CURRENT_AREA_W = 0;
// CURRENT_ARMY
// file army.c line 75
struct anonymous_21 *CURRENT_ARMY = (struct anonymous_21 *)(void *)0;
// CURRENT_ARMY_SIZE
// file army.c line 76
signed int CURRENT_ARMY_SIZE = 0;
// CURRENT_CURSOR
// file cursor.c line 75
struct anonymous_23 CURRENT_CURSOR[6l];
// CURRENT_MESH
// file mesh.c line 86
struct anonymous_0 *CURRENT_MESH = (struct anonymous_0 *)(void *)0;
// CURRENT_MESH_SIZE
// file mesh.c line 87
signed int CURRENT_MESH_SIZE = 0;
// CURSOR_COLOR_BACK
// file pion.c line 138
static char CURSOR_COLOR_BACK[32l];
// CURSOR_COLOR_MAP
// file pion.c line 137
static char CURSOR_COLOR_MAP[32l];
// CURSOR_GRAPHIC_MEMORY
// file pion.c line 135
static char CURSOR_GRAPHIC_MEMORY[6l][68l];
// CURSOR_LAYOUT
// file pion.c line 97
static struct anonymous_10 CURSOR_LAYOUT[68l] = { { .x=0, .y=-3, .color=0, .row=0 }, { .x=0, .y=-4, .color=0, .row=2 }, { .x=0, .y=-5, .color=0, .row=3 }, { .x=1, .y=-4, .color=1, .row=1 }, { .x=1, .y=-5, .color=1, .row=3 }, { .x=1, .y=-3, .color=2, .row=0 }, { .x=2, .y=-4, .color=2, .row=3 }, { .x=2, .y=-3, .color=3, .row=1 }, { .x=3, .y=-4, .color=3, .row=3 }, { .x=2, .y=-2, .color=4, .row=0 }, { .x=3, .y=-3, .color=4, .row=2 }, { .x=3, .y=-2, .color=5, .row=1 }, { .x=4, .y=-3, .color=5, .row=3 }, { .x=3, .y=-1, .color=6, .row=0 }, { .x=4, .y=-2, .color=6, .row=3 }, { .x=4, .y=-1, .color=7, .row=1 }, { .x=5, .y=-1, .color=7, .row=3 }, { .x=3, .y=0, .color=8, .row=0 }, { .x=4, .y=0, .color=8, .row=2 }, { .x=5, .y=0, .color=8, .row=3 }, { .x=4, .y=1, .color=9, .row=1 }, { .x=5, .y=1, .color=9, .row=3 }, { .x=3, .y=1, .color=10, .row=0 }, { .x=4, .y=2, .color=10, .row=3 }, { .x=3, .y=2, .color=11, .row=1 }, { .x=4, .y=3, .color=11, .row=3 }, { .x=2, .y=2, .color=12, .row=0 }, { .x=3, .y=3, .color=12, .row=2 }, { .x=2, .y=3, .color=13, .row=1 }, { .x=3, .y=4, .color=13, .row=3 }, { .x=1, .y=3, .color=14, .row=0 }, { .x=2, .y=4, .color=14, .row=3 }, { .x=1, .y=4, .color=15, .row=1 }, { .x=1, .y=5, .color=15, .row=3 }, { .x=-0, .y=3, .color=16, .row=0 }, { .x=-0, .y=4, .color=16, .row=2 }, { .x=-0, .y=5, .color=16, .row=3 }, { .x=-1, .y=4, .color=17, .row=1 }, { .x=-1, .y=5, .color=17, .row=3 }, { .x=-1, .y=3, .color=18, .row=0 }, { .x=-2, .y=4, .color=18, .row=3 }, { .x=-2, .y=3, .color=19, .row=1 }, { .x=-3, .y=4, .color=19, .row=3 }, { .x=-2, .y=2, .color=20, .row=0 }, { .x=-3, .y=3, .color=20, .row=2 }, { .x=-3, .y=2, .color=21, .row=1 }, { .x=-4, .y=3, .color=21, .row=3 }, { .x=-3, .y=1, .color=22, .row=0 }, { .x=-4, .y=2, .color=22, .row=3 }, { .x=-4, .y=1, .color=23, .row=1 }, { .x=-5, .y=1, .color=23, .row=3 }, { .x=-3, .y=-0, .color=8, .row=0 }, { .x=-4, .y=-0, .color=24, .row=2 }, { .x=-5, .y=-0, .color=25, .row=3 }, { .x=-4, .y=-1, .color=25, .row=1 }, { .x=-5, .y=-1, .color=26, .row=3 }, { .x=-3, .y=-1, .color=10, .row=0 }, { .x=-4, .y=-2, .color=27, .row=3 }, { .x=-3, .y=-2, .color=27, .row=1 }, { .x=-4, .y=-3, .color=28, .row=3 }, { .x=-2, .y=-2, .color=12, .row=0 }, { .x=-3, .y=-3, .color=28, .row=2 }, { .x=-2, .y=-3, .color=29, .row=1 }, { .x=-3, .y=-4, .color=29, .row=3 }, { .x=-1, .y=-3, .color=14, .row=0 }, { .x=-2, .y=-4, .color=30, .row=3 }, { .x=-1, .y=-4, .color=31, .row=1 }, { .x=-1, .y=-5, .color=31, .row=3 } };
// CUSTOM_MAP_OK
// file disk.c line 117
static signed int CUSTOM_MAP_OK = 0;
// CUSTOM_MUSIC_OK
// file disk.c line 118
static signed int CUSTOM_MUSIC_OK = 0;
// CUSTOM_TEXTURE_OK
// file disk.c line 116
static signed int CUSTOM_TEXTURE_OK = 0;
// DEFAULT_CFG_PATH
// file startup.c line 120
static char *DEFAULT_CFG_PATH = ".liquidwarrc";
// DEFAULT_DAT_PATH
// file startup.c line 122
static char *DEFAULT_DAT_PATH = "/usr/share/games/liquidwar/liquidwar.dat";
// DEFAULT_GEN_PATH
// file startup.c line 127
static char *DEFAULT_GEN_PATH = "/usr/games/liquidwar-mapgen";
// DEFAULT_LOG_PATH
// file startup.c line 121
static char *DEFAULT_LOG_PATH = "";
// DEFAULT_MAP_PATH
// file startup.c line 123
static char *DEFAULT_MAP_PATH = "/usr/share/games/liquidwar/map/";
// DEFAULT_METASERVER
// file startup.c line 147
static char *DEFAULT_METASERVER = "www.ufoot.org/metaserver/";
// DEFAULT_MID_PATH
// file startup.c line 125
static char *DEFAULT_MID_PATH = "/usr/share/games/liquidwar/music/";
// DEFAULT_SRV_PATH
// file startup.c line 126
static char *DEFAULT_SRV_PATH = "/usr/games/liquidwar-server";
// DEFAULT_TEX_PATH
// file startup.c line 124
static char *DEFAULT_TEX_PATH = "/usr/share/games/liquidwar/texture/";
// DISPLAY_DELAY_MIN
// file config.c line 179
signed int DISPLAY_DELAY_MIN[9l] = { 0, 10, 15, 20, 25, 33, 40, 55, 100 };
// DISPLAY_NUMBER
// file profile.c line 79
static signed int DISPLAY_NUMBER;
// DISTORSION_H
// file distor.c line 79
static signed int DISTORSION_H;
// DISTORSION_TARGET
// file distor.c line 81
static struct BITMAP *DISTORSION_TARGET = (struct BITMAP *)(void *)0;
// DISTORSION_W
// file distor.c line 78
static signed int DISTORSION_W;
// EXECUTABLE_NAME
// file parser.c line 64
char *EXECUTABLE_NAME;
// FIGHTER_MOVE_DIR
// file fighter.c line 82
static signed int FIGHTER_MOVE_DIR[2l][12l][5l] = { { { 0, 1, 10, 2, 9 }, { 1, 2, 0, 4, 10 }, { 2, 1, 4, 0, 5 }, { 3, 4, 1, 5, 0 }, { 4, 5, 3, 7, 1 }, { 5, 4, 7, 3, 8 }, { 6, 7, 4, 8, 3 }, { 7, 8, 6, 10, 4 }, { 8, 7, 10, 6, 11 }, { 9, 10, 7, 11, 5 }, { 10, 11, 9, 1, 7 }, { 11, 10, 1, 9, 2 } },
    { { 0, 1, 10, 2, 9 }, { 1, 0, 2, 10, 4 }, { 2, 1, 4, 0, 5 }, { 3, 4, 1, 5, 0 }, { 4, 3, 5, 1, 7 }, { 5, 4, 7, 3, 8 }, { 6, 7, 4, 8, 3 }, { 7, 6, 8, 4, 10 }, { 8, 7, 10, 6, 11 }, { 9, 10, 7, 11, 5 }, { 10, 9, 11, 7, 1 }, { 11, 10, 1, 9, 2 } } };
// FIGHTER_MOVE_OFFSET
// file fighter.c line 119
static signed int FIGHTER_MOVE_OFFSET[2l][12l][5l];
// FIGHTER_MOVE_OFFSET_ASM
// file fighter.c line 116
static signed int FIGHTER_MOVE_OFFSET_ASM[2l][60l];
// FIGHTER_MOVE_X
// file fighter.h line 62
signed int FIGHTER_MOVE_X[2l][12l][5l];
// FIGHTER_MOVE_XY_ASM
// file fighter.c line 117
static signed int FIGHTER_MOVE_XY_ASM[2l][60l];
// FIGHTER_MOVE_X_REF
// file fighter.c line 110
static signed int FIGHTER_MOVE_X_REF[12l] = { 0, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, 0 };
// FIGHTER_MOVE_Y
// file fighter.h line 63
signed int FIGHTER_MOVE_Y[2l][12l][5l];
// FIGHTER_MOVE_Y_REF
// file fighter.c line 113
static signed int FIGHTER_MOVE_Y_REF[12l] = { -1, -1, 0, 0, 1, 1, 1, 1, 0, 0, -1, -1 };
// FONT_PALETTE
// file disk.c line 113
static struct RGB *FONT_PALETTE = (struct RGB *)(void *)0;
// GFX_MODE_H
// file gfxmode.c line 83
signed int GFX_MODE_H[5l] = { 240, 384, 480, 600, 768 };
// GFX_MODE_TYPE_FULLSCREEN
// file gfxmode.c line 117
static signed int GFX_MODE_TYPE_FULLSCREEN[5l] = { 1, 1, 1, 1, 1 };
// GFX_MODE_TYPE_WINDOWED
// file gfxmode.c line 123
static signed int GFX_MODE_TYPE_WINDOWED[5l] = { 2, 2, 2, 2, 2 };
// GFX_MODE_W
// file gfxmode.c line 82
signed int GFX_MODE_W[5l] = { 320, 512, 640, 800, 1024 };
// GLOBAL_CLOCK
// file time.c line 83
signed int GLOBAL_CLOCK = 0;
// GLOBAL_CONNECT_DATA
// file connect.c line 108
struct anonymous_25 GLOBAL_CONNECT_DATA;
// GLOBAL_PALETTE
// file palette.c line 75
struct RGB GLOBAL_PALETTE[256l];
// GLOBAL_TICKER
// file time.c line 82
signed int GLOBAL_TICKER;
// GRAD_TO_DISP
// file code.c line 80
signed int GRAD_TO_DISP = 0;
// HASARD_INDEX
// file sound.c line 68
static signed int HASARD_INDEX;
// HASARD_VALUE
// file sound.c line 67
static signed int HASARD_VALUE[1024l];
// INFO_BAR
// file info.c line 81
static struct BITMAP *INFO_BAR = (struct BITMAP *)(void *)0;
// INFO_BAR_BACK
// file info.c line 80
static struct BITMAP *INFO_BAR_BACK = (struct BITMAP *)(void *)0;
// INFO_BAR_POS_H
// file info.c line 85
static signed int INFO_BAR_POS_H;
// INFO_BAR_POS_W
// file info.c line 84
static signed int INFO_BAR_POS_W;
// INFO_BAR_POS_X
// file info.c line 82
static signed int INFO_BAR_POS_X[6l];
// INFO_BAR_POS_Y
// file info.c line 83
static signed int INFO_BAR_POS_Y[6l];
// INVISIBLE_MOUSE_CURSOR
// file disk.c line 111
struct BITMAP *INVISIBLE_MOUSE_CURSOR = (struct BITMAP *)(void *)0;
// JOY1_MAX_X
// file joystick.c line 98
static signed int JOY1_MAX_X = -1000;
// JOY1_MAX_Y
// file joystick.c line 101
static signed int JOY1_MAX_Y = -1000;
// JOY1_MID_X
// file joystick.c line 97
static signed int JOY1_MID_X = 0;
// JOY1_MID_Y
// file joystick.c line 100
static signed int JOY1_MID_Y = 0;
// JOY1_MIN_X
// file joystick.c line 96
static signed int JOY1_MIN_X = 1000;
// JOY1_MIN_Y
// file joystick.c line 99
static signed int JOY1_MIN_Y = 1000;
// JOY2_MAX_X
// file joystick.c line 105
static signed int JOY2_MAX_X = -1000;
// JOY2_MAX_Y
// file joystick.c line 108
static signed int JOY2_MAX_Y = -1000;
// JOY2_MID_X
// file joystick.c line 104
static signed int JOY2_MID_X = 0;
// JOY2_MID_Y
// file joystick.c line 107
static signed int JOY2_MID_Y = 0;
// JOY2_MIN_X
// file joystick.c line 103
static signed int JOY2_MIN_X = 1000;
// JOY2_MIN_Y
// file joystick.c line 106
static signed int JOY2_MIN_Y = 1000;
// JOYSTICK_CONTROL_JOY1_B1
// file joystick.c line 80
signed int JOYSTICK_CONTROL_JOY1_B1 = 0;
// JOYSTICK_CONTROL_JOY1_B2
// file joystick.c line 81
signed int JOYSTICK_CONTROL_JOY1_B2 = 0;
// JOYSTICK_CONTROL_JOY1_B3
// file joystick.c line 82
signed int JOYSTICK_CONTROL_JOY1_B3 = 0;
// JOYSTICK_CONTROL_JOY1_B4
// file joystick.c line 83
signed int JOYSTICK_CONTROL_JOY1_B4 = 0;
// JOYSTICK_CONTROL_JOY1_DOWN
// file joystick.c line 78
signed int JOYSTICK_CONTROL_JOY1_DOWN = 0;
// JOYSTICK_CONTROL_JOY1_LEFT
// file joystick.c line 79
signed int JOYSTICK_CONTROL_JOY1_LEFT = 0;
// JOYSTICK_CONTROL_JOY1_RIGHT
// file joystick.c line 77
signed int JOYSTICK_CONTROL_JOY1_RIGHT = 0;
// JOYSTICK_CONTROL_JOY1_UP
// file joystick.c line 76
signed int JOYSTICK_CONTROL_JOY1_UP = 0;
// JOYSTICK_CONTROL_JOY2_B1
// file joystick.c line 89
signed int JOYSTICK_CONTROL_JOY2_B1 = 0;
// JOYSTICK_CONTROL_JOY2_B2
// file joystick.c line 90
signed int JOYSTICK_CONTROL_JOY2_B2 = 0;
// JOYSTICK_CONTROL_JOY2_DOWN
// file joystick.c line 87
signed int JOYSTICK_CONTROL_JOY2_DOWN = 0;
// JOYSTICK_CONTROL_JOY2_LEFT
// file joystick.c line 88
signed int JOYSTICK_CONTROL_JOY2_LEFT = 0;
// JOYSTICK_CONTROL_JOY2_RIGHT
// file joystick.c line 86
signed int JOYSTICK_CONTROL_JOY2_RIGHT = 0;
// JOYSTICK_CONTROL_JOY2_UP
// file joystick.c line 85
signed int JOYSTICK_CONTROL_JOY2_UP = 0;
// LOADED_BACK
// file disk.c line 84
signed int LOADED_BACK = 0;
// LOADED_MAPTEX
// file disk.c line 86
signed int LOADED_MAPTEX = 0;
// LOADED_MUSIC
// file disk.c line 89
signed int LOADED_MUSIC = 0;
// LOADED_SFX
// file disk.c line 87
signed int LOADED_SFX = 0;
// LOADED_TEXTURE
// file disk.c line 85
signed int LOADED_TEXTURE = 0;
// LOADED_WATER
// file disk.c line 88
signed int LOADED_WATER = 0;
// LOCAL_DIR
// file fighter.c line 80
static signed int LOCAL_DIR[32l];
// LOGIC_DELAY_MIN
// file config.c line 182
signed int LOGIC_DELAY_MIN[9l] = { 0, 1, 2, 5, 10, 15, 20, 33, 50 };
// LOGIC_NUMBER
// file profile.c line 80
static signed int LOGIC_NUMBER;
// LOG_MUTEX
// file logcli.c line 90
static struct anonymous_1 LOG_MUTEX = { .data=(void *)0 };
// LW_CAPTURE_MODE
// file capture.c line 79
static signed int LW_CAPTURE_MODE = 0;
// LW_CONFIG_CURRENT_RULES
// file config.c line 173
struct anonymous_4 LW_CONFIG_CURRENT_RULES;
// LW_EXIT_FORCE_SHUTDOWN
// file exit.c line 84
static signed int LW_EXIT_FORCE_SHUTDOWN = 0;
// LW_GAME_RUNNING
// file game.c line 108
signed int LW_GAME_RUNNING = 0;
// LW_INIT_ALLEGRO_OK
// file init.c line 80
signed int LW_INIT_ALLEGRO_OK = 0;
// LW_KEYEXCH_SOCK
// file keyexch.c line 70
signed int LW_KEYEXCH_SOCK = -1;
// LW_LANGDE_DATA
// file langde.c line 65
static char *LW_LANGDE_DATA[185l];
// LW_LANGDK_DATA
// file langdk.c line 64
static char *LW_LANGDK_DATA[185l];
// LW_LANGEN_DATA
// file langen.c line 65
static char *LW_LANGEN_DATA[185l];
// LW_LANGFR_DATA
// file langfr.c line 65
static char *LW_LANGFR_DATA[185l];
// LW_LOG_BEEP
// file logcli.c line 89
signed int LW_LOG_BEEP = 1;
// LW_NETWORK_ERROR_DETECTED
// file network.c line 76
signed int LW_NETWORK_ERROR_DETECTED = 0;
// LW_NETWORK_INFO
// file network.c line 75
struct anonymous_8 LW_NETWORK_INFO[6l];
// LW_NETWORK_ON
// file network.c line 74
signed int LW_NETWORK_ON = 0;
// LW_NETWORK_RAW_MAP
// file network.c line 77
void *LW_NETWORK_RAW_MAP = (void *)0;
// LW_RANDOM_ON
// file random.h line 70
signed int LW_RANDOM_ON = 0;
// LW_RANDOM_RAW_MAP
// file random.h line 69
void *LW_RANDOM_RAW_MAP = (void *)0;
// LW_SCORE_TOMBOLA_RESULT
// file score.c line 89
signed int LW_SCORE_TOMBOLA_RESULT[6l];
// LW_SOCK_LOG
// file sockunix.c line 94
signed int LW_SOCK_LOG = 0;
// MENU_KEY_NAMES
// file team.c line 76
static char *MENU_KEY_NAMES[128l] = { "None", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "Pad0", "Pad1", "Pad2", "Pad3", "Pad4", "Pad5", "Pad6", "Pad7", "Pad8", "Pad9", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "ESC", "~", "-", "=", "Back", "Tab", "{", "}", "Enter", ":", "'", "\\", "\\", ",", ".", "/", "Space", "Ins", "Del", "Home", "End", "Pgup", "Pgdn", "<", ">", "/\\", "\\/", "Pad/", "*", "Pad-", "Pad+", "Pad.", "PadE", "PScr", "Pause", "LShf", "RShf", "LCnt", "RCnt", "Alt", "Altgr", "LWin", "RWin", "Menu", "SLock", "NLock", "CLock", "None", "None", "None", "None", "J1/\\", "J1>", "J1\\/", "J1<", "J1B1", "J1B2", "J1B3", "J1B4", "J2/\\", "J2>", "J2\\/", "J2<", "J2B1", "J2B2", "M/\\", "M>", "M\\/", "M<" };
// MESSAGE
// file message.c line 72
static char MESSAGE[12l][65l];
// MESSAGE_DELAY
// file message.c line 75
static signed int MESSAGE_DELAY = 1000;
// MESSAGE_DISPLAYED
// file message.c line 74
static signed int MESSAGE_DISPLAYED[12l];
// MESSAGE_NB
// file message.c line 71
static signed int MESSAGE_NB = 0;
// MESSAGE_TICKER
// file message.c line 73
static signed int MESSAGE_TICKER[12l];
// MIDI_MUSIC
// file disk.c line 103
struct MIDI *MIDI_MUSIC[256l];
// MIDI_MUSIC_NUMBER
// file disk.c line 82
signed int MIDI_MUSIC_NUMBER = 0;
// MIN_MAP_RES_H
// file config.c line 186
signed int MIN_MAP_RES_H[9l] = { 0, 60, 90, 120, 150, 180, 240, 360, 480 };
// MIN_MAP_RES_W
// file config.c line 185
signed int MIN_MAP_RES_W[9l] = { 0, 80, 120, 160, 200, 240, 320, 480, 640 };
// MOUSE_CONTROL_DOWN
// file mouse.c line 69
signed int MOUSE_CONTROL_DOWN = 0;
// MOUSE_CONTROL_GAP
// file mouse.c line 72
static signed int MOUSE_CONTROL_GAP = 1000;
// MOUSE_CONTROL_LEFT
// file mouse.c line 70
signed int MOUSE_CONTROL_LEFT = 0;
// MOUSE_CONTROL_REF_X
// file mouse.c line 65
signed int MOUSE_CONTROL_REF_X = 0;
// MOUSE_CONTROL_REF_Y
// file mouse.c line 66
signed int MOUSE_CONTROL_REF_Y = 0;
// MOUSE_CONTROL_RIGHT
// file mouse.c line 68
signed int MOUSE_CONTROL_RIGHT = 0;
// MOUSE_CONTROL_UP
// file mouse.c line 67
signed int MOUSE_CONTROL_UP = 0;
// MOUSE_ON
// file mouse.c line 73
static signed int MOUSE_ON = 1;
// MUSIC_VOLUME
// file music.c line 65
signed int MUSIC_VOLUME = 0;
// MUSIC_VOLUME_VALUES
// file music.c line 67
static signed int MUSIC_VOLUME_VALUES[17l] = { 0, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 255 };
// NEXT_SCREEN
// file viewport.c line 72
struct BITMAP *NEXT_SCREEN = (struct BITMAP *)(void *)0;
// PAGE_FLIP_H
// file viewport.c line 71
signed int PAGE_FLIP_H = 0;
// PAUSE_ON
// file code.c line 81
signed int PAUSE_ON = 0;
// PLAYING_TEAMS
// file decal.c line 66
signed int PLAYING_TEAMS = 0;
// PROFILE_DATA
// file profile.c line 78
static struct anonymous_11 PROFILE_DATA[256l];
// RAW_MAP
// file disk.c line 99
void *RAW_MAP[1024l];
// RAW_MAPTEX
// file disk.c line 102
void *RAW_MAPTEX[1024l];
// RAW_MAPTEX_NUMBER
// file disk.c line 80
signed int RAW_MAPTEX_NUMBER = 0;
// RAW_MAP_NUMBER
// file disk.c line 81
signed int RAW_MAP_NUMBER = 0;
// RAW_MAP_ORDERED
// file disk.c line 100
void *RAW_MAP_ORDERED[1024l];
// RAW_TEXTURE
// file disk.c line 101
void *RAW_TEXTURE[1024l];
// RAW_TEXTURE_NUMBER
// file disk.c line 79
signed int RAW_TEXTURE_NUMBER = 0;
// SAMPLE_SFX_CLICK
// file disk.c line 94
struct SAMPLE *SAMPLE_SFX_CLICK = (struct SAMPLE *)(void *)0;
// SAMPLE_SFX_CONNECT
// file disk.c line 96
struct SAMPLE *SAMPLE_SFX_CONNECT = (struct SAMPLE *)(void *)0;
// SAMPLE_SFX_GO
// file disk.c line 93
struct SAMPLE *SAMPLE_SFX_GO = (struct SAMPLE *)(void *)0;
// SAMPLE_SFX_LOOSE
// file disk.c line 95
struct SAMPLE *SAMPLE_SFX_LOOSE = (struct SAMPLE *)(void *)0;
// SAMPLE_SFX_TIME
// file disk.c line 91
struct SAMPLE *SAMPLE_SFX_TIME = (struct SAMPLE *)(void *)0;
// SAMPLE_SFX_WIN
// file disk.c line 92
struct SAMPLE *SAMPLE_SFX_WIN = (struct SAMPLE *)(void *)0;
// SAMPLE_WATER
// file disk.c line 98
struct SAMPLE *SAMPLE_WATER[32l];
// SAMPLE_WATER_NUMBER
// file disk.c line 78
signed int SAMPLE_WATER_NUMBER = 0;
// SMALL_FONT
// file disk.c line 108
struct FONT *SMALL_FONT = (struct FONT *)(void *)0;
// SMALL_MOUSE_CURSOR
// file disk.c line 110
struct BITMAP *SMALL_MOUSE_CURSOR = (struct BITMAP *)(void *)0;
// SOUND_VOLUME_VALUES
// file sound.c line 70
static signed int SOUND_VOLUME_VALUES[17l] = { 0, 8, 10, 13, 16, 20, 25, 32, 40, 51, 64, 81, 101, 128, 161, 204, 255 };
// STARTUP_ASM
// file startup.c line 111
signed int STARTUP_ASM = 1;
// STARTUP_AUTO
// file startup.c line 114
signed int STARTUP_AUTO = 0;
// STARTUP_BACK_STATE
// file startup.c line 105
signed int STARTUP_BACK_STATE = 1;
// STARTUP_BIG_DATA
// file startup.c line 100
signed int STARTUP_BIG_DATA = 16;
// STARTUP_CAPTURE
// file startup.c line 116
signed int STARTUP_CAPTURE = 0;
// STARTUP_CFG_PATH
// file startup.c line 149
char STARTUP_CFG_PATH[1000l];
// STARTUP_CHECK
// file startup.c line 115
signed int STARTUP_CHECK = 0;
// STARTUP_CUSTOM_STATE
// file startup.c line 110
signed int STARTUP_CUSTOM_STATE = 1;
// STARTUP_DAT_PATH
// file startup.c line 150
char STARTUP_DAT_PATH[1000l];
// STARTUP_DIGI_CARD
// file startup.c line 102
signed int STARTUP_DIGI_CARD = -1;
// STARTUP_GEN_PATH
// file startup.c line 156
char STARTUP_GEN_PATH[1000l];
// STARTUP_JOYSTICK_ON
// file startup.c line 104
signed int STARTUP_JOYSTICK_ON = 1;
// STARTUP_LOG_PATH
// file startup.c line 151
char STARTUP_LOG_PATH[1000l];
// STARTUP_MAP_PATH
// file startup.c line 152
char STARTUP_MAP_PATH[1000l];
// STARTUP_METASERVER
// file startup.c line 158
char STARTUP_METASERVER[200l];
// STARTUP_MIDI_CARD
// file startup.c line 103
signed int STARTUP_MIDI_CARD = -1;
// STARTUP_MID_PATH
// file startup.c line 154
char STARTUP_MID_PATH[1000l];
// STARTUP_MUSIC_STATE
// file startup.c line 109
signed int STARTUP_MUSIC_STATE = 1;
// STARTUP_SFX_STATE
// file startup.c line 108
signed int STARTUP_SFX_STATE = 1;
// STARTUP_SRV_PATH
// file startup.c line 155
char STARTUP_SRV_PATH[1000l];
// STARTUP_STOP
// file startup.c line 113
signed int STARTUP_STOP = 0;
// STARTUP_SVGA
// file startup.c line 112
signed int STARTUP_SVGA = 1;
// STARTUP_TEXTURE_STATE
// file startup.c line 106
signed int STARTUP_TEXTURE_STATE = 1;
// STARTUP_TEX_PATH
// file startup.c line 153
char STARTUP_TEX_PATH[1000l];
// STARTUP_TOMBOLA
// file startup.c line 117
signed int STARTUP_TOMBOLA = 0;
// STARTUP_WATER_STATE
// file startup.c line 107
signed int STARTUP_WATER_STATE = 1;
// TICKER_PAUSED
// file time.c line 75
static signed int TICKER_PAUSED;
// TICKER_PAUSE_START
// file time.c line 77
static signed int TICKER_PAUSE_START;
// TICKER_START
// file time.c line 76
static signed int TICKER_START;
// TICKER_VALUE
// file ticker.c line 68
static signed int TICKER_VALUE = 0;
// TIME_ELAPSED
// file time.c line 80
signed int TIME_ELAPSED;
// TIME_LEFT
// file time.c line 81
signed int TIME_LEFT;
// TIME_TABLE
// file time.c line 69
static signed int TIME_TABLE[17l] = { 15, 30, 45, 60, 90, 120, 150, 180, 240, 300, 360, 480, 600, 900, 1200, 1800, 3600 };
// VIEWPORT_CHANGE_REGISTERED
// file viewport.c line 79
static signed int VIEWPORT_CHANGE_REGISTERED = 0;
// VIEWPORT_H
// file viewport.c line 77
static signed int VIEWPORT_H = 0;
// VIEWPORT_W
// file viewport.c line 76
static signed int VIEWPORT_W = 0;
// VIEWPORT_X
// file viewport.c line 74
static signed int VIEWPORT_X = 0;
// VIEWPORT_Y
// file viewport.c line 75
static signed int VIEWPORT_Y = 0;
// WATCHDOG_ASCII
// file watchdog.c line 71
char WATCHDOG_ASCII[256l];
// WATCHDOG_BUFFER
// file watchdog.c line 73
static signed int WATCHDOG_BUFFER[1024l];
// WATCHDOG_KEYS_IN_BUFFER
// file watchdog.c line 74
static signed int WATCHDOG_KEYS_IN_BUFFER;
// WATCHDOG_SCANCODE
// file watchdog.c line 72
char WATCHDOG_SCANCODE[128l];
// WATER_DELAY
// file sound.c line 77
static signed int WATER_DELAY = 2000;
// WATER_VOLUME
// file sound.c line 64
signed int WATER_VOLUME = 0;
// WAVE_SHAPE_HX
// file distor.c line 89
static signed int WAVE_SHAPE_HX[12l][768l];
// WAVE_SHAPE_HY
// file distor.c line 88
static signed int WAVE_SHAPE_HY[768l];
// WAVE_SHAPE_WX
// file distor.c line 83
static signed int WAVE_SHAPE_WX[1024l];
// WAVE_SHAPE_WY
// file distor.c line 84
static signed int WAVE_SHAPE_WY[12l][1024l];
// WAVE_SHAPE_X_CORRES
// file distor.c line 86
static signed int *WAVE_SHAPE_X_CORRES[1024l];
// WAVE_SHAPE_Y_CORRES
// file distor.c line 91
static signed int *WAVE_SHAPE_Y_CORRES[768l];
// _cos_tbl
// file /usr/include/allegro/fmaths.h line 34
extern signed int _cos_tbl[];
// allegro_errno
// file /usr/include/allegro/base.h line 94
extern signed int *allegro_errno;
// allegro_id
// file /usr/include/allegro/system.h line 37
extern char allegro_id[];
// black_palette
// file /usr/include/allegro/color.h line 31
extern struct RGB black_palette[256l];
// buffer_comment
// file internet.c line 95
static char buffer_comment[101l];
// buffer_password
// file internet.c line 93
static char buffer_password[50l];
// buffer_ping
// file internet.c line 91
static char buffer_ping[50l];
// buffer_port
// file internet.c line 92
static char buffer_port[50l];
// buffer_uptime
// file internet.c line 94
static char buffer_uptime[50l];
// dialog_comment
// file internet.c line 101
static struct DIALOG *dialog_comment = (struct DIALOG *)(void *)0;
// dialog_list
// file internet.c line 96
static struct DIALOG *dialog_list = (struct DIALOG *)(void *)0;
// dialog_password
// file internet.c line 99
static struct DIALOG *dialog_password = (struct DIALOG *)(void *)0;
// dialog_ping
// file internet.c line 97
static struct DIALOG *dialog_ping = (struct DIALOG *)(void *)0;
// dialog_port
// file internet.c line 98
static struct DIALOG *dialog_port = (struct DIALOG *)(void *)0;
// dialog_uptime
// file internet.c line 100
static struct DIALOG *dialog_uptime = (struct DIALOG *)(void *)0;
// digi_driver
// file /usr/include/allegro/digi.h line 131
extern struct DIGI_DRIVER *digi_driver;
// font
// file /usr/include/allegro/text.h line 34
extern struct FONT *font;
// gfx_driver
// file /usr/include/allegro/gfx.h line 119
extern struct GFX_DRIVER *gfx_driver;
// gui_mg_color
// file /usr/include/allegro/gui.h line 186
extern signed int gui_mg_color;
// gui_mouse_b
// file /usr/include/allegro/gui.h line 194
extern signed int (*gui_mouse_b)(void);
// gui_mouse_x
// file /usr/include/allegro/gui.h line 191
extern signed int (*gui_mouse_x)(void);
// gui_mouse_y
// file /usr/include/allegro/gui.h line 192
extern signed int (*gui_mouse_y)(void);
// joy
// file /usr/include/allegro/joystick.h line 92
extern struct JOYSTICK_INFO joy[];
// joystick_driver
// file /usr/include/allegro/joystick.h line 113
extern struct JOYSTICK_DRIVER *joystick_driver;
// key
// file /usr/include/allegro/keyboard.h line 62
extern volatile char key[];
// key_shifts
// file /usr/include/allegro/keyboard.h line 63
extern volatile signed int key_shifts;
// keyboard_driver
// file /usr/include/allegro/keyboard.h line 47
extern struct KEYBOARD_DRIVER *keyboard_driver;
// list_data
// file internet.c line 89
static struct anonymous_15 *list_data = (struct anonymous_15 *)(void *)0;
// list_size
// file internet.c line 90
static signed int *list_size = (signed int *)(void *)0;
// midi_driver
// file /usr/include/allegro/midi.h line 102
extern struct MIDI_DRIVER *midi_driver;
// mouse_driver
// file /usr/include/allegro/mouse.h line 53
extern struct MOUSE_DRIVER *mouse_driver;
// mouse_x
// file /usr/include/allegro/mouse.h line 78
extern volatile signed int mouse_x;
// mouse_y
// file /usr/include/allegro/mouse.h line 79
extern volatile signed int mouse_y;
// num_joysticks
// file /usr/include/allegro/joystick.h line 93
extern signed int num_joysticks;
// screen
// file /usr/include/allegro/gfx.h line 302
extern struct BITMAP *screen;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// system_driver
// file /usr/include/allegro/system.h line 244
extern struct SYSTEM_DRIVER *system_driver;
// timer_driver
// file /usr/include/allegro/timer.h line 52
extern struct TIMER_DRIVER *timer_driver;
// ugetc
// file /usr/include/allegro/unicode.h line 52
extern signed int (*ugetc)(const char *);
// ugetx
// file /usr/include/allegro/unicode.h line 53
extern signed int (*ugetx)(char **);
// uisok
// file /usr/include/allegro/unicode.h line 58
extern signed int (*uisok)(signed int);
// usetc
// file /usr/include/allegro/unicode.h line 55
extern signed int (*usetc)(char *, signed int);
// uwidth
// file /usr/include/allegro/unicode.h line 56
extern signed int (*uwidth)(const char *);

// _allegro_hline
// file /usr/include/allegro/inline/draw.inl line 54
static inline void _allegro_hline(struct BITMAP *bmp, signed int x1, signed int y, signed int x2, signed int color)
{
  bmp->vtable->hline(bmp, x1, y, x2, color);
}

// _allegro_hline_link1
// file /usr/include/allegro/inline/draw.inl line 54
static inline void _allegro_hline_link1(struct BITMAP *bmp_link1, signed int x1_link1, signed int y_link1, signed int x2_link1, signed int color_link1)
{
  bmp_link1->vtable->hline(bmp_link1, x1_link1, y_link1, x2_link1, color_link1);
}

// _allegro_hline_link2
// file /usr/include/allegro/inline/draw.inl line 54
static inline void _allegro_hline_link2(struct BITMAP *bmp_link2, signed int x1_link2, signed int y_link2, signed int x2_link2, signed int color_link2)
{
  bmp_link2->vtable->hline(bmp_link2, x1_link2, y_link2, x2_link2, color_link2);
}

// _allegro_vline
// file /usr/include/allegro/inline/draw.inl line 46
static inline void _allegro_vline(struct BITMAP *bmp, signed int x, signed int y_1, signed int y2, signed int color)
{
  bmp->vtable->vline(bmp, x, y_1, y2, color);
}

// _allegro_vline_link1
// file /usr/include/allegro/inline/draw.inl line 46
static inline void _allegro_vline_link1(struct BITMAP *bmp_link1, signed int x_link1, signed int y_1_link1, signed int y2_link1, signed int color_link1)
{
  bmp_link1->vtable->vline(bmp_link1, x_link1, y_1_link1, y2_link1, color_link1);
}

// _allegro_vline_link2
// file /usr/include/allegro/inline/draw.inl line 46
static inline void _allegro_vline_link2(struct BITMAP *bmp_link2, signed int x_link2, signed int y_1_link2, signed int y2_link2, signed int color_link2)
{
  bmp_link2->vtable->vline(bmp_link2, x_link2, y_1_link2, y2_link2, color_link2);
}

// _allegro_vline_link3
// file /usr/include/allegro/inline/draw.inl line 46
static inline void _allegro_vline_link3(struct BITMAP *bmp_link3, signed int x_link3, signed int y_1_link3, signed int y2_link3, signed int color_link3)
{
  bmp_link3->vtable->vline(bmp_link3, x_link3, y_1_link3, y2_link3, color_link3);
}

// add_fighter
// file army.c line 97
static signed int add_fighter(struct anonymous_21 *f, signed int team, signed int x, signed int y, signed int health)
{
  signed int j = y * CURRENT_AREA_W + x;
  _Bool tmp_if_expr_1;
  if(!((CURRENT_AREA + (signed long int)j)->mesh == ((struct anonymous_0 *)NULL)))
    tmp_if_expr_1 = !((CURRENT_AREA + (signed long int)j)->fighter != ((struct anonymous_21 *)NULL)) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    (CURRENT_AREA + (signed long int)j)->fighter = f;
    f->health = (signed short int)health;
    f->team = (char)team;
    f->x = (signed short int)x;
    f->y = (signed short int)y;
    f->last_dir = (char)(j % 12);
    return 1;
  }

  else
    return 0;
}

// advanced_options
// file advanced.c line 119
signed int advanced_options(void)
{
  signed int *temp;
  struct DIALOG d[21l];
  signed int i;
  signed int retour = 0;
  signed int choix = 4;
  memset((void *)d, 0, sizeof(struct DIALOG [21l]) /*1512ul*/ );
  i = 0;
  static signed int y_pos[8l] = { 0, 1, 2, 3, 4, 5, 6, 7 };
  for( ; !(i >= 8); i = i + 1)
  {
    standard_button(d + (signed long int)i + (signed long int)4, 0, y_pos[(signed long int)i], 2, 8);
    d[(signed long int)(i + 4)].proc = my_textbox_proc;
  }
  i = 0;
  for( ; !(i >= 8); i = i + 1)
  {
    standard_button(d + (signed long int)i + (signed long int)12, 1, y_pos[(signed long int)i], 2, 8);
    d[(signed long int)(i + 12)].proc = my_slider_proc;
  }
  d[(signed long int)19].proc = my_button_proc;
  d[(signed long int)18].proc = d[(signed long int)19].proc;
  d[(signed long int)17].proc = d[(signed long int)18].proc;
  quick_buttons(d);
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(62);
  d[(signed long int)4].dp = (void *)return_value_lw_lang_string_1;
  char *return_value_lw_lang_string_2;
  return_value_lw_lang_string_2=lw_lang_string(63);
  d[(signed long int)5].dp = (void *)return_value_lw_lang_string_2;
  char *return_value_lw_lang_string_3;
  return_value_lw_lang_string_3=lw_lang_string(64);
  d[(signed long int)6].dp = (void *)return_value_lw_lang_string_3;
  char *return_value_lw_lang_string_4;
  return_value_lw_lang_string_4=lw_lang_string(65);
  d[(signed long int)7].dp = (void *)return_value_lw_lang_string_4;
  char *return_value_lw_lang_string_5;
  return_value_lw_lang_string_5=lw_lang_string(66);
  d[(signed long int)8].dp = (void *)return_value_lw_lang_string_5;
  char *return_value_lw_lang_string_6;
  return_value_lw_lang_string_6=lw_lang_string(67);
  d[(signed long int)9].dp = (void *)return_value_lw_lang_string_6;
  char *return_value_lw_lang_string_7;
  return_value_lw_lang_string_7=lw_lang_string(74);
  d[(signed long int)10].dp = (void *)return_value_lw_lang_string_7;
  char *return_value_lw_lang_string_8;
  return_value_lw_lang_string_8=lw_lang_string(71);
  d[(signed long int)11].dp = (void *)return_value_lw_lang_string_8;
  d[(signed long int)15].d1 = 16;
  d[(signed long int)14].d1 = d[(signed long int)15].d1;
  d[(signed long int)13].d1 = d[(signed long int)14].d1;
  d[(signed long int)12].d1 = d[(signed long int)13].d1;
  d[(signed long int)16].d1 = 4;
  d[(signed long int)12].dp3 = (void *)&CONFIG_FIGHTER_ATTACK;
  d[(signed long int)13].dp3 = (void *)&CONFIG_FIGHTER_DEFENSE;
  d[(signed long int)14].dp3 = (void *)&CONFIG_FIGHTER_NEW_HEALTH;
  d[(signed long int)15].dp3 = (void *)&CONFIG_NUMBER_INFLUENCE;
  d[(signed long int)16].dp3 = (void *)&CONFIG_CPU_ADVANTAGE;
  char *return_value_get_cpu_vs_human_str_9;
  return_value_get_cpu_vs_human_str_9=get_cpu_vs_human_str();
  d[(signed long int)17].dp = (void *)return_value_get_cpu_vs_human_str_9;
  char *return_value_get_allow_network_bots_str_10;
  return_value_get_allow_network_bots_str_10=get_allow_network_bots_str();
  d[(signed long int)18].dp = (void *)return_value_get_allow_network_bots_str_10;
  char *return_value_get_asm_algorithm_str_11;
  return_value_get_asm_algorithm_str_11=get_asm_algorithm_str();
  d[(signed long int)19].dp = (void *)return_value_get_asm_algorithm_str_11;
  i = 12;
  for( ; !(i >= 17); i = i + 1)
  {
    d[(signed long int)i].dp = (void *)0;
    d[(signed long int)i].dp2 = (void *)slider_int;
    temp = (signed int *)d[(signed long int)i].dp3;
    d[(signed long int)i].d2 = *temp;
  }
  d[(signed long int)10].flags = 16;
  d[(signed long int)18].flags = 16;
  d[(signed long int)20].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
  while(retour == 0)
  {
    choix=my_do_dialog(d, choix);
    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 2)
        goto __CPROVER_DUMP_L9;

      if(choix == 0)
        goto __CPROVER_DUMP_L10;

      if(choix == 1)
        goto __CPROVER_DUMP_L12;

      if(choix == 17)
        goto __CPROVER_DUMP_L13;

      if(choix == 18)
        goto __CPROVER_DUMP_L14;

      if(choix == 19)
        goto __CPROVER_DUMP_L15;

    }

    else
    {
      retour = 1;
      continue;

    __CPROVER_DUMP_L9:
      ;
      retour = -1;
      continue;

    __CPROVER_DUMP_L10:
      ;
      signed int return_value_confirm_quit_12;
      return_value_confirm_quit_12=confirm_quit();
      if(!(return_value_confirm_quit_12 == 0))
        retour = -2;

      continue;

    __CPROVER_DUMP_L12:
      ;
      retour = -3;
      continue;

    __CPROVER_DUMP_L13:
      ;
      CONFIG_CPU_VS_HUMAN = (CONFIG_CPU_VS_HUMAN + 1) % 3;
      char *return_value_get_cpu_vs_human_str_13;
      return_value_get_cpu_vs_human_str_13=get_cpu_vs_human_str();
      d[(signed long int)17].dp = (void *)return_value_get_cpu_vs_human_str_13;
      scare_mouse();
      my_button_proc(3, d + (signed long int)17, 0);
      unscare_mouse();
      continue;

    __CPROVER_DUMP_L14:
      ;
      CONFIG_ALLOW_NETWORK_BOTS = CONFIG_ALLOW_NETWORK_BOTS != 0 ? 0 : 1;
      char *return_value_get_allow_network_bots_str_14;
      return_value_get_allow_network_bots_str_14=get_allow_network_bots_str();
      d[(signed long int)18].dp = (void *)return_value_get_allow_network_bots_str_14;
      scare_mouse();
      my_button_proc(3, d + (signed long int)18, 0);
      unscare_mouse();
      continue;

    __CPROVER_DUMP_L15:
      ;
      CONFIG_ASM_ALGORITHM = CONFIG_ASM_ALGORITHM != 0 ? 0 : 1;
      char *return_value_get_asm_algorithm_str_15;
      return_value_get_asm_algorithm_str_15=get_asm_algorithm_str();
      d[(signed long int)19].dp = (void *)return_value_get_asm_algorithm_str_15;
      scare_mouse();
      my_button_proc(3, d + (signed long int)19, 0);
      unscare_mouse();
    }
  }
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// apply_all_cursor
// file cursor.c line 152
void apply_all_cursor(void)
{
  signed int i;
  signed int x;
  signed int y;
  struct anonymous_0 *temp;
  i = 0;
  for( ; !(i >= 6); i = i + 1)
    if(!(CURRENT_CURSOR[(signed long int)i].active == 0))
    {
      x = CURRENT_CURSOR[(signed long int)i].x;
      y = CURRENT_CURSOR[(signed long int)i].y;
      temp = (CURRENT_AREA + (signed long int)(y * CURRENT_AREA_W + x))->mesh;
      if(!(temp == ((struct anonymous_0 *)NULL)))
        temp->info[(signed long int)CURRENT_CURSOR[(signed long int)i].team].state.grad = CURRENT_CURSOR[(signed long int)i].val;

    }

}

// ascii_hexa_to_int
// file netkey.c line 137
static signed int ascii_hexa_to_int(char src)
{
  signed int dst = 0;
  if((signed int)src >= 48 && !((signed int)src >= 58))
    dst = (signed int)src - 48;

  if((signed int)src >= 65 && !((signed int)src >= 71))
    dst = ((signed int)src - 65) + 10;

  return dst;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1;
}

// atoi_link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link1(const char *__nptr_link1)
{
  signed long int return_value_strtol_1_link1;
  return_value_strtol_1_link1=strtol(__nptr_link1, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1_link1;
}

// atoi_link2
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link2(const char *__nptr_link2)
{
  signed long int return_value_strtol_1_link2;
  return_value_strtol_1_link2=strtol(__nptr_link2, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1_link2;
}

// atoi_link3
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link3(const char *__nptr_link3)
{
  signed long int return_value_strtol_1_link3;
  return_value_strtol_1_link3=strtol(__nptr_link3, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1_link3;
}

// atoi_link4
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link4(const char *__nptr_link4)
{
  signed long int return_value_strtol_1_link4;
  return_value_strtol_1_link4=strtol(__nptr_link4, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1_link4;
}

// auto_cursor
// file cursor.h line 135
void auto_cursor(signed int index, signed int team, char *name)
{
  signed int i;
  signed int x;
  signed int y;
  signed int x_min;
  signed int x_max;
  signed int y_min;
  signed int y_max;
  signed int ok;
  signed int x0;
  signed int y0;
  signed int n = 0;
  y = n;
  x = y;
  i = 0;
  for( ; !(i >= CURRENT_ARMY_SIZE); i = i + 1)
    if((signed int)(CURRENT_ARMY + (signed long int)i)->team == team)
    {
      x = x + (signed int)(CURRENT_ARMY + (signed long int)i)->x;
      y = y + (signed int)(CURRENT_ARMY + (signed long int)i)->y;
      n = n + 1;
    }

  x = x / n;
  x_min = x;
  x_max = x_min;
  x0 = x_max;
  y = y / n;
  y_min = y;
  y_max = y_min;
  y0 = y_max;
  ok = 0;
  while(ok == 0)
  {
    x = x_min;
    for( ; ok == 0 && x_max >= x; x = x + 1)
      if(!((CURRENT_AREA + (signed long int)(CURRENT_AREA_W * y + x))->mesh == ((struct anonymous_0 *)NULL)))
      {
        ok = 1;
        x0 = x;
        y0 = y;
      }

    if(!(x_max >= CURRENT_AREA_W + -1))
      x_max = x_max + 1;

    y = y_min;
    for( ; ok == 0 && y_max >= y; y = y + 1)
      if(!((CURRENT_AREA + (signed long int)(CURRENT_AREA_W * y + x))->mesh == ((struct anonymous_0 *)NULL)))
      {
        ok = 1;
        x0 = x;
        y0 = y;
      }

    if(!(y_max >= CURRENT_AREA_H + -1))
      y_max = y_max + 1;

    x = x_max;
    for( ; ok == 0 && x >= x_min; x = x - 1)
      if(!((CURRENT_AREA + (signed long int)(CURRENT_AREA_W * y + x))->mesh == ((struct anonymous_0 *)NULL)))
      {
        ok = 1;
        x0 = x;
        y0 = y;
      }

    if(x_min >= 1)
      x_min = x_min - 1;

    y = y_max;
    for( ; ok == 0 && y >= y_min; y = y - 1)
      if(!((CURRENT_AREA + (signed long int)(CURRENT_AREA_W * y + x))->mesh == ((struct anonymous_0 *)NULL)))
      {
        ok = 1;
        x0 = x;
        y0 = y;
      }

    if(y_min >= 1)
      y_min = y_min - 1;

  }
  init_cursor(index, team, x0, y0, name);
}

// bitmap_color_depth
// file /usr/include/allegro/inline/gfx.inl line 104
static inline signed int bitmap_color_depth(struct BITMAP *bmp)
{
  return bmp->vtable->color_depth;
}

// blank_round
// file game.c line 459
signed int blank_round(void)
{
  struct BITMAP *return_value_page_flip_1;
  return_value_page_flip_1=page_flip();
  if(!(return_value_page_flip_1 == ((struct BITMAP *)NULL)))
  {
    init_distorsion_displayer();
    display_back_image();
    rect_for_viewport();
    disp_all_cursors();
    display_area();
    undisp_all_cursors();
    page_flip();
    display_back_image();
    rect_for_viewport();
    clear_message();
    return 0;
  }

  else
    return -1;
}

// box_for_choose_map
// file level.c line 339
static void box_for_choose_map(void)
{
  struct DIALOG d[10l];
  struct DIALOG_PLAYER *dp;
  signed int i;
  signed int x1;
  signed int x2;
  signed int x3;
  signed int x4;
  signed int x5;
  signed int x6;
  signed int x7;
  signed int x8;
  signed int y1;
  signed int y2;
  signed int y3;
  signed int y4;
  signed int y5;
  signed int y6;
  signed int y7;
  signed int y8;
  memset((void *)d, 0, sizeof(struct DIALOG [10l]) /*720ul*/ );
  retrieve_choose_level_xy(&x1, &x2, &x3, &x4, &x5, &x6, &x7, &x8, &y1, &y2, &y3, &y4, &y5, &y6, &y7, &y8);
  d[(signed long int)0].x = x4;
  d[(signed long int)0].y = y1;
  d[(signed long int)0].w = 160;
  d[(signed long int)0].h = 120;
  d[(signed long int)1].x = x1;
  d[(signed long int)1].y = y1;
  d[(signed long int)1].w = 40;
  d[(signed long int)1].h = 40;
  d[(signed long int)2].x = x8;
  d[(signed long int)2].y = y1;
  d[(signed long int)2].w = 40;
  d[(signed long int)2].h = 40;
  d[(signed long int)3].x = x8;
  d[(signed long int)3].y = y5;
  d[(signed long int)3].w = 40;
  d[(signed long int)3].h = 15;
  d[(signed long int)4].x = x1;
  d[(signed long int)4].y = y4;
  d[(signed long int)4].w = 40;
  d[(signed long int)4].h = 15;
  d[(signed long int)5].x = x8;
  d[(signed long int)5].y = y4;
  d[(signed long int)5].w = 40;
  d[(signed long int)5].h = 15;
  i = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    d[(signed long int)i].proc = d_box_proc;
    d[(signed long int)i].flags = 0;
    color_one_dialog(d + (signed long int)i);
    menu_real_coord(d + (signed long int)i);
    d[(signed long int)i].x = d[(signed long int)i].x - 1;
    d[(signed long int)i].y = d[(signed long int)i].y - 1;
    d[(signed long int)i].w = d[(signed long int)i].w + 2;
    d[(signed long int)i].h = d[(signed long int)i].h + 2;
  }
  signed int return_value_lw_maptex_is_custom_texture_used_1;
  return_value_lw_maptex_is_custom_texture_used_1=lw_maptex_is_custom_texture_used(CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, 0, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
  if(!(return_value_lw_maptex_is_custom_texture_used_1 == 0))
  {
    d[(signed long int)4].flags = d[(signed long int)4].flags | 16;
    d[(signed long int)1].flags = d[(signed long int)4].flags;
  }

  signed int return_value_lw_maptex_is_custom_texture_used_2;
  return_value_lw_maptex_is_custom_texture_used_2=lw_maptex_is_custom_texture_used(CONFIG_LEVEL_MAP, CONFIG_LEVEL_BG, 0, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
  if(!(return_value_lw_maptex_is_custom_texture_used_2 == 0))
  {
    d[(signed long int)5].flags = d[(signed long int)5].flags | 16;
    d[(signed long int)2].flags = d[(signed long int)5].flags;
  }

  d[(signed long int)6].proc = (signed int (*)(signed int, struct DIALOG *, signed int))(void *)0;
  dp=my_init_dialog(d, 0);
  my_update_dialog(dp);
  shutdown_dialog(dp);
}

// calc_playing_teams
// file game.c line 119
void calc_playing_teams(void)
{
  signed int i;
  PLAYING_TEAMS = 0;
  i = 0;
  for( ; !(i >= 6); i = i + 1)
    if(!(LW_NETWORK_ON == 0))
    {
      if(!(LW_NETWORK_INFO[(signed long int)i].active == 0))
        PLAYING_TEAMS = PLAYING_TEAMS + 1;

    }

    else
      if(!(CONFIG_CONTROL_TYPE[(signed long int)i] == 0))
        PLAYING_TEAMS = PLAYING_TEAMS + 1;

}

// calc_real_texture_number
// file maptex.c line 76
static signed int calc_real_texture_number(signed int num, signed int texture, signed int network, signed int random, signed int use_default_texture, signed int *found)
{
  signed int i;
  char *map_name;
  signed int real_texture;
  *found = 0;
  real_texture = texture;
  _Bool tmp_if_expr_1;
  signed int tmp_statement_expression_2;
  if(!(use_default_texture == 0))
  {
    map_name=lw_map_get_system_name(num, network, random);
    i = 128;
    do
    {
      if(!(i >= 128 + RAW_MAPTEX_NUMBER + RAW_TEXTURE_NUMBER))
        tmp_if_expr_1 = !(*found != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      unsigned long int __s1_len;
      unsigned long int __s2_len;
      char *return_value_lw_texture_get_system_name_3;
      return_value_lw_texture_get_system_name_3=lw_texture_get_system_name(i);
      signed int return_value___builtin_strcmp_4;
      return_value___builtin_strcmp_4=__builtin_strcmp(map_name, return_value_lw_texture_get_system_name_3);
      tmp_statement_expression_2 = return_value___builtin_strcmp_4;
      if(tmp_statement_expression_2 == 0)
      {
        *found = 1;
        real_texture = i;
      }

      i = i + 1;
    }
    while((_Bool)1);
  }

  return real_texture;
}

// calc_zoom_factor
// file map.c line 87
static signed int calc_zoom_factor(signed int w, signed int h, signed int min_w, signed int min_h)
{
  signed int factor_w;
  signed int factor_h;
  signed int factor;
  if(!(h >= 1) || !(w >= 1))
  {
    log_println_str("Error: map size is null or negative!");
    h = 1;
    w = h;
  }

  factor_w = (min_w - 1) / w + 1;
  factor_h = (min_h - 1) / h + 1;
  factor = factor_w > factor_h ? factor_w : factor_h;
  return factor;
}

// calculate_computer_path
// file autoplay.c line 86
static void calculate_computer_path(signed int dst_x, signed int dst_y, signed int cursor)
{
  signed int team;
  signed int src_x;
  signed int src_y;
  signed int pos;
  signed int dir;
  signed int x;
  signed int y;
  signed int dx;
  signed int dy;
  struct anonymous_0 *path_mesh;
  struct anonymous_0 *src_mesh;
  signed int sens;
  signed int start;
  signed int table = GLOBAL_CLOCK % 2;
  team = CURRENT_CURSOR[(signed long int)cursor].team;
  src_x = CURRENT_CURSOR[(signed long int)cursor].x;
  src_y = CURRENT_CURSOR[(signed long int)cursor].y;
  src_mesh = (CURRENT_AREA + (signed long int)(src_y * CURRENT_AREA_W + src_x))->mesh;
  x = dst_x;
  y = dst_y;
  path_mesh = (CURRENT_AREA + (signed long int)(y * CURRENT_AREA_W + x))->mesh;
  start = 0;
  sens = start;
  pos = sens;
  while(!(path_mesh == ((struct anonymous_0 *)NULL)) && !(path_mesh == src_mesh) && !(pos >= 1024))
  {
    dir=get_main_dir(path_mesh, team, sens, start);
    dx = FIGHTER_MOVE_X[(signed long int)table][(signed long int)dir][(signed long int)0];
    x = x + dx;
    dy = FIGHTER_MOVE_Y[(signed long int)table][(signed long int)dir][(signed long int)0];
    y = y + dy;
    path_mesh = (CURRENT_AREA + (signed long int)(y * CURRENT_AREA_W + x))->mesh;
    if(!(path_mesh == ((struct anonymous_0 *)NULL)))
    {
      COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] = (char)0;
      if(dy >= 1)
        COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] = COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] + (char)1;

      if(!(dx >= 0))
        COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] = COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] + (char)2;

      if(!(dy >= 0))
        COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] = COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] + (char)4;

      if(dx >= 1)
        COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] = COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] + (char)8;

      pos = pos + 1;
    }

    start = start + 1;
    if(start == 12)
    {
      start = 0;
      sens = (signed int)!(sens != 0);
    }

  }
  if(path_mesh == src_mesh)
  {
    for( ; !(pos >= 1024) && (!(x == src_x) || !(y == src_y)); pos = pos + 1)
    {
      COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] = (char)0;
      if(!(y >= src_y))
      {
        y = y + 1;
        COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] = COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] + (char)1;
      }

      if(!(src_x >= x))
      {
        x = x - 1;
        COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] = COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] + (char)2;
      }

      if(!(src_y >= y))
      {
        y = y - 1;
        COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] = COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] + (char)4;
      }

      if(!(x >= src_x))
      {
        x = x + 1;
        COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] = COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)pos] + (char)8;
      }

    }
    COMPUTER_PATH_SIZE[(signed long int)cursor] = pos;
  }

  else
    COMPUTER_PATH_SIZE[(signed long int)cursor] = 0;
  COMPUTER_PATH_WAIT[(signed long int)cursor] = COMPUTER_PATH_SIZE[(signed long int)cursor];
}

// center_one_dialog
// file dialog.c line 127
void center_one_dialog(struct DIALOG *d, signed int x, signed int y, signed int w, signed int h)
{
  d->x = x - w / 2;
  d->y = y - h / 2;
  d->w = w;
  d->h = h;
}

// change_key
// file team.c line 252
static void change_key(struct DIALOG *d, signed int *val)
{
  lw_mouse_reset_control();
  wait_no_key();
  *val=wait_key_pressed();
  play_click();
  clear_keybuf();
  char *return_value_get_key_name_1;
  return_value_get_key_name_1=get_key_name(*val);
  d->dp = (void *)return_value_get_key_name_1;
}

// change_palette_brightness
// file palette.c line 113
static void change_palette_brightness(struct RGB *old_pal, struct RGB *new_pal)
{
  signed int r;
  signed int g;
  signed int b;
  signed int i;
  signed int brightness;
  struct RGB *rgb;
  brightness = CONFIG_BRIGHTNESS - 8;
  if(!(brightness == 0))
  {
    i = 0;
    for( ; !(i >= 256); i = i + 1)
    {
      rgb = old_pal + (signed long int)i;
      r = (signed int)rgb->r * 4;
      g = (signed int)rgb->g * 4;
      b = (signed int)rgb->b * 4;
      if(brightness >= 1)
      {
        signed int return_value_sqrt255_1;
        return_value_sqrt255_1=sqrt255(r);
        r = (brightness * return_value_sqrt255_1 + (8 - brightness) * r) / 8;
        signed int return_value_sqrt255_2;
        return_value_sqrt255_2=sqrt255(g);
        g = (brightness * return_value_sqrt255_2 + (8 - brightness) * g) / 8;
        signed int return_value_sqrt255_3;
        return_value_sqrt255_3=sqrt255(b);
        b = (brightness * return_value_sqrt255_3 + (8 - brightness) * b) / 8;
      }

      if(!(brightness >= 0))
      {
        signed int return_value_sqr255_4;
        return_value_sqr255_4=sqr255(r);
        r = (-brightness * return_value_sqr255_4 + (8 + brightness) * r) / 8;
        signed int return_value_sqr255_5;
        return_value_sqr255_5=sqr255(g);
        g = (-brightness * return_value_sqr255_5 + (8 + brightness) * g) / 8;
        signed int return_value_sqr255_6;
        return_value_sqr255_6=sqr255(b);
        b = (-brightness * return_value_sqr255_6 + (8 + brightness) * b) / 8;
      }

      rgb = new_pal + (signed long int)i;
      rgb->r = (unsigned char)(r / 4);
      rgb->g = (unsigned char)(g / 4);
      rgb->b = (unsigned char)(b / 4);
    }
  }

  else
  {
    i = 0;
    for( ; !(i >= 256); i = i + 1)
      new_pal[(signed long int)i] = old_pal[(signed long int)i];
  }
}

// check_boolean_codes
// file code.c line 209
static void check_boolean_codes(void)
{
  if(!(WATCHDOG_SCANCODE[49l] == 0))
  {
    if(LW_NETWORK_ON == 0)
    {
      if(!(PAUSE_ON == 0))
      {
        PAUSE_ON = 0;
        char *return_value_lw_lang_string_1;
        return_value_lw_lang_string_1=lw_lang_string(154);
        message_str(return_value_lw_lang_string_1);
      }

      else
      {
        PAUSE_ON = 1;
        char *return_value_lw_lang_string_2;
        return_value_lw_lang_string_2=lw_lang_string(155);
        message_str(return_value_lw_lang_string_2);
      }
    }

  }

  if(!(WATCHDOG_SCANCODE[50l] == 0))
  {
    if(!(CONFIG_WAVE_ON == 0))
    {
      CONFIG_WAVE_ON = 0;
      char *return_value_lw_lang_string_3;
      return_value_lw_lang_string_3=lw_lang_string(156);
      message_str(return_value_lw_lang_string_3);
    }

    else
    {
      CONFIG_WAVE_ON = 1;
      char *return_value_lw_lang_string_4;
      return_value_lw_lang_string_4=lw_lang_string(157);
      message_str(return_value_lw_lang_string_4);
    }
  }

  if(!(WATCHDOG_SCANCODE[55l] == 0))
  {
    signed int return_value_lw_capture_get_mode_7;
    return_value_lw_capture_get_mode_7=lw_capture_get_mode();
    if(!(return_value_lw_capture_get_mode_7 == 0))
    {
      lw_capture_set_mode(0);
      char *return_value_lw_lang_string_5;
      return_value_lw_lang_string_5=lw_lang_string(158);
      message_str(return_value_lw_lang_string_5);
    }

    else
    {
      lw_capture_set_mode(1);
      char *return_value_lw_lang_string_6;
      return_value_lw_lang_string_6=lw_lang_string(159);
      message_str(return_value_lw_lang_string_6);
    }
  }

}

// check_code
// file code.c line 265
void check_code(void)
{
  display_special_info();
  check_grad_to_disp();
  check_boolean_codes();
}

// check_config_range
// file config.c line 613
void check_config_range(void)
{
  if(!(RAW_MAP_NUMBER + -1 >= CONFIG_LEVEL_MAP))
    CONFIG_LEVEL_MAP = (RAW_MAP_NUMBER - 1) / 2;

  if(!(128 + RAW_TEXTURE_NUMBER + -1 >= CONFIG_LEVEL_FG))
    CONFIG_LEVEL_FG = 120;

  if(!(128 + RAW_TEXTURE_NUMBER + -1 >= CONFIG_LEVEL_BG))
    CONFIG_LEVEL_BG = 127;

  lw_netconf_check(&LW_CONFIG_CURRENT_RULES);
}

// check_free_memory
// file bigdata.c line 222
signed int check_free_memory(void)
{
  struct BITMAP *result;
  result=my_create_bitmap(1024 / 2, 1024);
  if(!(result == ((struct BITMAP *)NULL)))
    destroy_bitmap(result);

  return (signed int)(result != (struct BITMAP *)(void *)0);
}

// check_grad_to_disp
// file code.c line 158
static void check_grad_to_disp(void)
{
  char grad_codes[6l];
  signed int i;
  signed int old;
  memset((void *)grad_codes, 0, sizeof(char [6l]) /*6ul*/ );
  __builtin_strncpy(grad_codes, "gradn", sizeof(char [6l]) /*6ul*/  - (unsigned long int)1);
  grad_codes[(signed long int)(sizeof(char [6l]) /*6ul*/  - (unsigned long int)1)] = (char)0;
  old = GRAD_TO_DISP;
  i = 0;
  for( ; !(i >= 9); i = i + 1)
  {
    grad_codes[(signed long int)4] = (char)(48 + i);
    signed int return_value_watchdog_is_keyword_1;
    return_value_watchdog_is_keyword_1=watchdog_is_keyword(grad_codes);
    if(!(return_value_watchdog_is_keyword_1 == 0))
      GRAD_TO_DISP = i;

  }
  if(GRAD_TO_DISP >= 1 && !(GRAD_TO_DISP >= 7) && !(PLAYING_TEAMS >= GRAD_TO_DISP))
    GRAD_TO_DISP = 0;

  char *return_value_lw_lang_string_2;
  char *return_value_lw_lang_string_3;
  char *return_value_lw_lang_string_4;
  char *return_value_lw_lang_string_5;
  char *return_value_lw_lang_string_6;
  char *return_value_lw_lang_string_7;
  char *return_value_lw_lang_string_8;
  char *return_value_lw_lang_string_9;
  char *return_value_lw_lang_string_10;
  if(!(old == GRAD_TO_DISP))
    switch(GRAD_TO_DISP)
    {
      case 0:
      {
        return_value_lw_lang_string_2=lw_lang_string(145);
        message_str(return_value_lw_lang_string_2);
        break;
      }
      case 1:
      {
        return_value_lw_lang_string_3=lw_lang_string(146);
        message_str(return_value_lw_lang_string_3);
        break;
      }
      case 2:
      {
        return_value_lw_lang_string_4=lw_lang_string(147);
        message_str(return_value_lw_lang_string_4);
        break;
      }
      case 3:
      {
        return_value_lw_lang_string_5=lw_lang_string(148);
        message_str(return_value_lw_lang_string_5);
        break;
      }
      case 4:
      {
        return_value_lw_lang_string_6=lw_lang_string(149);
        message_str(return_value_lw_lang_string_6);
        break;
      }
      case 5:
      {
        return_value_lw_lang_string_7=lw_lang_string(150);
        message_str(return_value_lw_lang_string_7);
        break;
      }
      case 6:
      {
        return_value_lw_lang_string_8=lw_lang_string(151);
        message_str(return_value_lw_lang_string_8);
        break;
      }
      case 7:
      {
        return_value_lw_lang_string_9=lw_lang_string(152);
        message_str(return_value_lw_lang_string_9);
        break;
      }
      case 8:
      {
        return_value_lw_lang_string_10=lw_lang_string(153);
        message_str(return_value_lw_lang_string_10);
      }
    }

}

// check_if_playable
// file map.c line 266
static signed int check_if_playable(struct BITMAP *bmp)
{
  signed int x = 0;
  signed int y = 0;
  signed int x0;
  signed int y0;
  signed int unplayable = 0;
  signed int playable_place = 0;
  hline_link2(bmp, 0, 0, bmp->w - 1, 0);
  hline_link2(bmp, 0, bmp->h - 1, bmp->w - 1, 0);
  vline_link2(bmp, 0, 0, bmp->h - 1, 0);
  vline_link2(bmp, bmp->w - 1, 0, bmp->h - 1, 0);
  y0 = -1;
  x0 = y0;
  y = 0;
  signed int return_value_getpixel_1;
  for( ; !(y >= bmp->h) && !(y0 >= 0); y = y + 1)
  {
    x = 0;
    for( ; !(x >= bmp->w) && !(x0 >= 0); x = x + 1)
    {
      return_value_getpixel_1=getpixel_link3(bmp, x, y);
      if(return_value_getpixel_1 == 2)
      {
        x0 = x;
        y0 = y;
      }

    }
  }
  signed int return_value_spread_color_down_2;
  signed int return_value_spread_color_up_3;
  if(x0 >= 1 && y0 >= 1)
  {
    putpixel_link6(bmp, x, y, 1);
    do
    {
      return_value_spread_color_down_2=spread_color_down(bmp, 2, 1);
      return_value_spread_color_up_3=spread_color_up(bmp, 2, 1);
      if(return_value_spread_color_down_2 + return_value_spread_color_up_3 == 0)
        break;

    }
    while((_Bool)1);
  }

  else
    unplayable = unplayable | 1;
  y = 0;
  signed int return_value_getpixel_4;
  for( ; !(y >= bmp->h); y = y + 1)
  {
    x = 0;
    for( ; !(x >= bmp->w); x = x + 1)
    {
      return_value_getpixel_4=getpixel_link3(bmp, x, y);
      if(return_value_getpixel_4 == 1)
        playable_place = playable_place + 1;

    }
  }
  unplayable = unplayable | (signed int)(playable_place < 1024);
  return (signed int)!(unplayable != 0);
}

// check_info_state
// file info.h line 62
void check_info_state(void)
{
  static signed int changed;
  if(!(WATCHDOG_SCANCODE[47l] == 0))
  {
    if(CONFIG_INFO_BAR >= 4)
      CONFIG_INFO_BAR = CONFIG_INFO_BAR - 4;

    else
      CONFIG_INFO_BAR = CONFIG_INFO_BAR + 4;
    free_info_bar();
    changed = CONFIG_PAGE_FLIP != 0 ? 2 : 1;
    lw_viewport_register_change(changed);
  }

  if(!(WATCHDOG_SCANCODE[48l] == 0))
  {
    if(!(CONFIG_INFO_BAR >= 4))
    {
      CONFIG_INFO_BAR = CONFIG_INFO_BAR + 1;
      if(CONFIG_INFO_BAR == 4)
        CONFIG_INFO_BAR = 0;

      if(CONFIG_INFO_BAR == 8)
        CONFIG_INFO_BAR = 4;

      free_info_bar();
      changed = CONFIG_PAGE_FLIP != 0 ? 2 : 1;
      lw_viewport_register_change(changed);
    }

  }

  if(changed >= 1)
  {
    display_back_image();
    changed = changed - 1;
  }

}

// check_loose_team
// file game.c line 200
signed int check_loose_team(void)
{
  signed int i = 0;
  signed int lost = 0;
  while(lost == 0 && !(i >= PLAYING_TEAMS))
    if(ACTIVE_FIGHTERS[(signed long int)i] == 0)
    {
      eliminate_team(i);
      lost = 1;
    }

    else
      i = i + 1;
  if(!(lost == 0))
  {
    play_loose();
    free_info_bar();
  }

  return lost;
}

// choose_different_color
// file network.c line 135
signed int choose_different_color()
{
  signed int color;
  signed int closeness[12l];
  signed int closeness_min;
  signed int dist;
  signed int i;
  signed int j;
  i = 0;
  for( ; !(i >= 12); i = i + 1)
  {
    closeness[(signed long int)i] = 0;
    j = 0;
    for( ; !(j >= 6); j = j + 1)
      if(!(LW_NETWORK_INFO[(signed long int)j].active == 0))
      {
        dist=distance_between_colors(LW_NETWORK_INFO[(signed long int)j].color, i);
        if(dist >= 1)
        {
          if(!(LW_NETWORK_INFO[(signed long int)j].network == 0))
            dist = dist + 1;

          closeness[(signed long int)i] = closeness[(signed long int)i] + 1000 / (dist * dist);
        }

        else
          closeness[(signed long int)i] = 1000000;
      }

  }
  closeness_min = 1000000;
  color = 0;
  i = 0;
  for( ; !(i >= 12); i = i + 1)
    if(!(closeness[(signed long int)i] >= closeness_min))
    {
      color = i;
      closeness_min = closeness[(signed long int)i];
    }

  return color;
}

// choose_map
// file level.c line 593
signed int choose_map(void)
{
  signed int retour = 0;
  signed int choix = 3;
  signed int i;
  signed int x1;
  signed int x2;
  signed int x3;
  signed int x4;
  signed int x5;
  signed int x6;
  signed int x7;
  signed int x8;
  signed int y1;
  signed int y2;
  signed int y3;
  signed int y4;
  signed int y5;
  signed int y6;
  signed int y7;
  signed int y8;
  struct DIALOG d[278l];
  char buf1[34l];
  char buf2[34l];
  char buf3[34l];
  memset((void *)d, 0, sizeof(struct DIALOG [278l]) /*20016ul*/ );
  buf1[(signed long int)0] = (char)0;
  buf2[(signed long int)0] = (char)0;
  display_back_image();
  set_palette_for_choose_color();
  quick_buttons(d);
  retrieve_choose_level_xy(&x1, &x2, &x3, &x4, &x5, &x6, &x7, &x8, &y1, &y2, &y3, &y4, &y5, &y6, &y7, &y8);
  d[(signed long int)6].proc = my_slider_proc;
  d[(signed long int)5].proc = d[(signed long int)6].proc;
  d[(signed long int)4].proc = d[(signed long int)5].proc;
  d[(signed long int)6].dp = (void *)0;
  d[(signed long int)5].dp = d[(signed long int)6].dp;
  d[(signed long int)4].dp = d[(signed long int)5].dp;
  d[(signed long int)6].key = 0;
  d[(signed long int)5].key = d[(signed long int)6].key;
  d[(signed long int)4].key = d[(signed long int)5].key;
  d[(signed long int)4].dp2 = (void *)slider_map;
  d[(signed long int)5].dp2 = (void *)slider_fg;
  d[(signed long int)6].dp2 = (void *)slider_bg;
  d[(signed long int)6].dp3 = (void *)d;
  d[(signed long int)5].dp3 = d[(signed long int)6].dp3;
  d[(signed long int)4].dp3 = d[(signed long int)5].dp3;
  d[(signed long int)6].flags = 0;
  d[(signed long int)5].flags = d[(signed long int)6].flags;
  d[(signed long int)4].flags = d[(signed long int)5].flags;
  d[(signed long int)4].d1 = RAW_MAP_NUMBER - 1;
  d[(signed long int)6].d1 = RAW_TEXTURE_NUMBER - 1;
  d[(signed long int)5].d1 = d[(signed long int)6].d1;
  d[(signed long int)4].d2 = CONFIG_LEVEL_MAP;
  d[(signed long int)5].d2 = CONFIG_LEVEL_FG;
  d[(signed long int)6].d2 = CONFIG_LEVEL_BG;
  d[(signed long int)4].x = x4;
  d[(signed long int)4].y = y5;
  d[(signed long int)4].w = 160;
  d[(signed long int)4].h = 15;
  d[(signed long int)5].x = x3;
  d[(signed long int)6].x = x7;
  d[(signed long int)6].y = y2;
  d[(signed long int)5].y = d[(signed long int)6].y;
  d[(signed long int)6].w = 15;
  d[(signed long int)5].w = d[(signed long int)6].w;
  d[(signed long int)6].h = (y4 - y2) - 3;
  d[(signed long int)5].h = d[(signed long int)6].h;
  i = 7;
  for( ; !(i >= 13); i = i + 1)
  {
    d[(signed long int)i].proc = my_button_proc;
    d[(signed long int)i].key = 0;
    d[(signed long int)i].flags = 1;
    d[(signed long int)i].h = 15;
    d[(signed long int)i].w = d[(signed long int)i].h;
  }
  d[(signed long int)11].dp = (void *)"-";
  d[(signed long int)9].dp = d[(signed long int)11].dp;
  d[(signed long int)7].dp = d[(signed long int)9].dp;
  d[(signed long int)12].dp = (void *)"+";
  d[(signed long int)10].dp = d[(signed long int)12].dp;
  d[(signed long int)8].dp = d[(signed long int)10].dp;
  d[(signed long int)7].x = x3;
  d[(signed long int)8].y = y5;
  d[(signed long int)7].y = d[(signed long int)8].y;
  d[(signed long int)8].x = x7;
  d[(signed long int)10].x = x3;
  d[(signed long int)9].x = d[(signed long int)10].x;
  d[(signed long int)12].x = x7;
  d[(signed long int)11].x = d[(signed long int)12].x;
  d[(signed long int)11].y = y4;
  d[(signed long int)9].y = d[(signed long int)11].y;
  d[(signed long int)12].y = y1;
  d[(signed long int)10].y = d[(signed long int)12].y;
  d[(signed long int)15].proc = my_edit_proc;
  d[(signed long int)14].proc = d[(signed long int)15].proc;
  d[(signed long int)13].proc = d[(signed long int)14].proc;
  d[(signed long int)15].flags = 1;
  d[(signed long int)14].flags = d[(signed long int)15].flags;
  d[(signed long int)13].flags = d[(signed long int)14].flags;
  d[(signed long int)13].dp = (void *)buf1;
  d[(signed long int)14].dp = (void *)buf2;
  d[(signed long int)15].dp = (void *)buf3;
  d[(signed long int)15].d1 = 33;
  d[(signed long int)14].d1 = d[(signed long int)15].d1;
  d[(signed long int)13].d1 = d[(signed long int)14].d1;
  d[(signed long int)15].d2 = 0;
  d[(signed long int)14].d2 = d[(signed long int)15].d2;
  d[(signed long int)13].d2 = d[(signed long int)14].d2;
  d[(signed long int)15].x = x8;
  d[(signed long int)13].x = d[(signed long int)15].x;
  d[(signed long int)14].x = x1;
  d[(signed long int)15].w = 40;
  d[(signed long int)14].w = d[(signed long int)15].w;
  d[(signed long int)13].w = d[(signed long int)14].w;
  d[(signed long int)15].h = 15;
  d[(signed long int)14].h = d[(signed long int)15].h;
  d[(signed long int)13].h = d[(signed long int)14].h;
  d[(signed long int)13].y = y5;
  d[(signed long int)15].y = y4;
  d[(signed long int)14].y = d[(signed long int)15].y;
  d[(signed long int)16].proc = my_textbox_proc;
  d[(signed long int)16].x = x1;
  d[(signed long int)16].y = y6;
  d[(signed long int)16].w = (x5 - x1) - 3;
  d[(signed long int)16].h = 15;
  d[(signed long int)16].flags = 0;
  d[(signed long int)16].dp = (void *)"";
  d[(signed long int)17].proc = my_textbox_proc;
  d[(signed long int)17].x = x5;
  d[(signed long int)17].y = y6;
  d[(signed long int)17].w = (x8 - x5) + 40;
  d[(signed long int)17].h = 15;
  d[(signed long int)17].flags = 0;
  d[(signed long int)17].dp = (void *)"";
  d[(signed long int)18].proc = my_textbox_proc;
  d[(signed long int)18].x = x1;
  d[(signed long int)18].y = y7;
  d[(signed long int)18].w = (x6 - x1) - 3;
  d[(signed long int)18].h = 15;
  d[(signed long int)18].flags = 0;
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(131);
  d[(signed long int)18].dp = (void *)return_value_lw_lang_string_1;
  d[(signed long int)19].proc = my_button_proc;
  d[(signed long int)19].x = x6;
  d[(signed long int)19].y = y7;
  d[(signed long int)19].w = (x8 - x6) + 40;
  d[(signed long int)19].h = 15;
  d[(signed long int)19].flags = 1;
  d[(signed long int)19].dp = (void *)"";
  d[(signed long int)20].proc = my_button_proc;
  d[(signed long int)20].x = x3;
  d[(signed long int)20].y = y8;
  d[(signed long int)20].w = (x8 - x3) - 3;
  d[(signed long int)20].h = 15;
  d[(signed long int)20].flags = 1;
  char *return_value_lw_lang_string_2;
  return_value_lw_lang_string_2=lw_lang_string(134);
  d[(signed long int)20].dp = (void *)return_value_lw_lang_string_2;
  i = 4;
  for( ; !(i >= 21); i = i + 1)
  {
    color_one_dialog(d + (signed long int)i);
    menu_real_coord(d + (signed long int)i);
  }
  signed int return_value_menu_real_x_3;
  return_value_menu_real_x_3=menu_real_x(x1);
  signed int return_value_menu_real_y_4;
  return_value_menu_real_y_4=menu_real_y(y3);
  signed int return_value_menu_real_x_5;
  return_value_menu_real_x_5=menu_real_x(40);
  signed int return_value_menu_real_y_6;
  return_value_menu_real_y_6=menu_real_y((y4 - y3) - 3);
  palette_128(d + (signed long int)21, return_value_menu_real_x_3, return_value_menu_real_y_4, return_value_menu_real_x_5, return_value_menu_real_y_6);
  signed int return_value_menu_real_x_7;
  return_value_menu_real_x_7=menu_real_x(x8);
  signed int return_value_menu_real_y_8;
  return_value_menu_real_y_8=menu_real_y(y3);
  signed int return_value_menu_real_x_9;
  return_value_menu_real_x_9=menu_real_x(40);
  signed int return_value_menu_real_y_10;
  return_value_menu_real_y_10=menu_real_y((y4 - y3) - 3);
  palette_128(d + (signed long int)149, return_value_menu_real_x_7, return_value_menu_real_y_8, return_value_menu_real_x_9, return_value_menu_real_y_10);
  box_for_choose_map();
  d[(signed long int)277].proc = (signed int (*)(signed int, struct DIALOG *, signed int))(void *)0;
  update_use_default_texture_state(d);
  update_choose_map(d, CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, CONFIG_LEVEL_BG, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
  signed int return_value_confirm_quit_11;
  signed int return_value_atoi_12;
  signed int return_value_atoi_13;
  signed int return_value_atoi_14;
  signed int return_value_lw_random_generate_map_15;
  while(retour == 0)
  {
    choix=my_do_dialog_no_clear(d, choix);
    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 2)
        goto __CPROVER_DUMP_L7;

      if(choix == 0)
        goto __CPROVER_DUMP_L8;

      if(choix == 1)
        goto __CPROVER_DUMP_L11;

      if(choix == 7)
        goto __CPROVER_DUMP_L12;

      if(choix == 8)
        goto __CPROVER_DUMP_L14;

      if(choix == 9)
        goto __CPROVER_DUMP_L16;

      if(choix == 10)
        goto __CPROVER_DUMP_L18;

      if(choix == 11)
        goto __CPROVER_DUMP_L20;

      if(choix == 12)
        goto __CPROVER_DUMP_L22;

      if(choix == 13)
        goto __CPROVER_DUMP_L24;

      if(choix == 14)
        goto __CPROVER_DUMP_L26;

      if(choix == 15)
        goto __CPROVER_DUMP_L28;

      if(choix == 19)
        goto __CPROVER_DUMP_L30;

      if(choix == 20)
        goto __CPROVER_DUMP_L31;

    }

    else
    {
      retour = 1;
      continue;

    __CPROVER_DUMP_L7:
      ;
      retour = -1;
      continue;

    __CPROVER_DUMP_L8:
      ;
      return_value_confirm_quit_11=confirm_quit();
      if(!(return_value_confirm_quit_11 == 0))
        retour = -2;

      else
      {
        display_back_image();
        box_for_choose_map();
        update_choose_map(d, CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, CONFIG_LEVEL_BG, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
      }
      continue;

    __CPROVER_DUMP_L11:
      ;
      retour = -3;
      continue;

    __CPROVER_DUMP_L12:
      ;
      d[(signed long int)4].d2 = d[(signed long int)4].d2 - 1;
      if(!(d[4l].d2 >= 0))
        d[(signed long int)4].d2 = d[(signed long int)4].d1;

      slider_map(d[(signed long int)4].dp3, d[(signed long int)4].d2);
      continue;

    __CPROVER_DUMP_L14:
      ;
      d[(signed long int)4].d2 = d[(signed long int)4].d2 + 1;
      if(!(d[4l].d1 >= d[4l].d2))
        d[(signed long int)4].d2 = 0;

      slider_map(d[(signed long int)4].dp3, d[(signed long int)4].d2);
      continue;

    __CPROVER_DUMP_L16:
      ;
      d[(signed long int)5].d2 = d[(signed long int)5].d2 - 1;
      if(!(d[5l].d2 >= 0))
        d[(signed long int)5].d2 = d[(signed long int)5].d1;

      slider_fg(d[(signed long int)5].dp3, d[(signed long int)5].d2);
      continue;

    __CPROVER_DUMP_L18:
      ;
      d[(signed long int)5].d2 = d[(signed long int)5].d2 + 1;
      if(!(d[5l].d1 >= d[5l].d2))
        d[(signed long int)5].d2 = 0;

      slider_fg(d[(signed long int)5].dp3, d[(signed long int)5].d2);
      continue;

    __CPROVER_DUMP_L20:
      ;
      d[(signed long int)6].d2 = d[(signed long int)6].d2 - 1;
      if(!(d[6l].d2 >= 0))
        d[(signed long int)6].d2 = d[(signed long int)6].d1;

      slider_bg(d[(signed long int)6].dp3, d[(signed long int)6].d2);
      continue;

    __CPROVER_DUMP_L22:
      ;
      d[(signed long int)6].d2 = d[(signed long int)6].d2 + 1;
      if(!(d[6l].d1 >= d[6l].d2))
        d[(signed long int)6].d2 = 0;

      slider_bg(d[(signed long int)6].dp3, d[(signed long int)6].d2);
      continue;

    __CPROVER_DUMP_L24:
      ;
      return_value_atoi_12=atoi((const char *)d[(signed long int)13].dp);
      i = return_value_atoi_12 - 1;
      if(!(i >= 0) || i >= RAW_MAP_NUMBER)
        i = CONFIG_LEVEL_MAP;

      play_click();
      update_choose_map(d, i, CONFIG_LEVEL_FG, CONFIG_LEVEL_BG, 0, CONFIG_USE_DEFAULT_TEXTURE);
      continue;

    __CPROVER_DUMP_L26:
      ;
      return_value_atoi_13=atoi((const char *)d[(signed long int)14].dp);
      i = return_value_atoi_13 - 1;
      if(!(i >= 0) || i >= 128 + RAW_TEXTURE_NUMBER)
        i = CONFIG_LEVEL_FG;

      play_click();
      update_choose_map(d, CONFIG_LEVEL_MAP, i, CONFIG_LEVEL_BG, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
      continue;

    __CPROVER_DUMP_L28:
      ;
      return_value_atoi_14=atoi((const char *)d[(signed long int)15].dp);
      i = return_value_atoi_14 - 1;
      if(!(i >= 0) || i >= 128 + RAW_TEXTURE_NUMBER)
        i = CONFIG_LEVEL_BG;

      play_click();
      update_choose_map(d, CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, i, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
      continue;

    __CPROVER_DUMP_L30:
      ;
      i = CONFIG_USE_DEFAULT_TEXTURE != 0 ? 0 : 1;
      update_choose_map(d, CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, CONFIG_LEVEL_BG, LW_RANDOM_ON, i);
      update_use_default_texture_state(d);
      continue;

    __CPROVER_DUMP_L31:
      ;
      return_value_lw_random_generate_map_15=lw_random_generate_map();
      if(!(return_value_lw_random_generate_map_15 == 0))
        update_choose_map(d, CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, CONFIG_LEVEL_BG, 1, CONFIG_USE_DEFAULT_TEXTURE);

      continue;
    }
    if(choix >= 21 && !(choix >= 149))
    {
      i = choix - 21;
      update_choose_map(d, CONFIG_LEVEL_MAP, i, CONFIG_LEVEL_BG, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
    }

    if(choix >= 149 && !(choix >= 277))
    {
      i = choix - 149;
      update_choose_map(d, CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, i, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
    }

  }
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// choose_teams
// file team.h line 66
signed int choose_teams(void)
{
  signed int retour = 0;
  struct DIALOG d[125l];
  signed int i;
  signed int choix = 0;
  signed int x1;
  signed int x2;
  signed int x3;
  signed int y1;
  signed int y2;
  signed int button_team;
  signed int button_type;
  memset((void *)d, 0, sizeof(struct DIALOG [125l]) /*9000ul*/ );
  quick_buttons(d);
  x1 = (320 - (3 * 75 + 2 * 3)) / 2;
  x2 = x1 + 75 + 3;
  x3 = x2 + 75 + 3;
  y1 = (240 - (2 * 90 + 3)) / 2;
  y2 = y1 + 90 + 3;
  x1=menu_real_x(x1);
  x2=menu_real_x(x2);
  x3=menu_real_x(x3);
  y1=menu_real_y(y1);
  y2=menu_real_y(y2);
  team_param(d + (signed long int)4, x1, y1, 0);
  team_param(d + (signed long int)24, x2, y1, 1);
  team_param(d + (signed long int)44, x3, y1, 2);
  team_param(d + (signed long int)64, x1, y2, 3);
  team_param(d + (signed long int)84, x2, y2, 4);
  team_param(d + (signed long int)104, x3, y2, 5);
  d[(signed long int)124].proc = (signed int (*)(signed int, struct DIALOG *, signed int))(void *)0;
  set_palette_for_choose_color();
  my_set_palette();
  display_back_image();
  signed int return_value_confirm_quit_1;
  while(retour == 0)
  {
    choix=my_do_dialog_no_clear(d, choix);
    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 2)
        goto __CPROVER_DUMP_L3;

      if(choix == 0)
        goto __CPROVER_DUMP_L4;

      if(choix == 1)
        goto __CPROVER_DUMP_L7;

    }

    else
    {
      retour = 1;
      continue;

    __CPROVER_DUMP_L3:
      ;
      retour = -1;
      continue;

    __CPROVER_DUMP_L4:
      ;
      return_value_confirm_quit_1=confirm_quit();
      if(!(return_value_confirm_quit_1 == 0))
        retour = -2;

      else
        display_back_image();
      continue;

    __CPROVER_DUMP_L7:
      ;
      retour = -3;
      continue;
    }
    button_team = (choix - 4) / 20;
    button_type = (choix - 4) % 20;
    switch(button_type)
    {
      case 15:
      {
        switch(CONFIG_CONTROL_TYPE[(signed long int)button_team])
        {
          case 0:
          {
            CONFIG_CONTROL_TYPE[(signed long int)button_team] = 1;
            break;
          }
          case 1:
          {
            CONFIG_CONTROL_TYPE[(signed long int)button_team] = 2;
            break;
          }
          default:
            CONFIG_CONTROL_TYPE[(signed long int)button_team] = 0;
        }
        redraw_team_box(d + (signed long int)4 + (signed long int)(20 * button_team), button_team);
        break;
      }
      case 16:
      {
        change_key(d + (signed long int)choix, &CONFIG_KEY_UP[(signed long int)button_team]);
        break;
      }
      case 17:
      {
        change_key(d + (signed long int)choix, &CONFIG_KEY_LEFT[(signed long int)button_team]);
        break;
      }
      case 18:
      {
        change_key(d + (signed long int)choix, &CONFIG_KEY_RIGHT[(signed long int)button_team]);
        break;
      }
      case 19:
      {
        change_key(d + (signed long int)choix, &CONFIG_KEY_DOWN[(signed long int)button_team]);
        break;
      }
      default:
        if(button_type >= 2 && !(button_type >= 14))
        {
          i=suppress_conflicting_color(button_type - 2, CONFIG_TEAM_COLOR[(signed long int)button_team]);
          if(i >= 0)
            redraw_team_box(d + (signed long int)4 + (signed long int)(20 * i), i);

          CONFIG_TEAM_COLOR[(signed long int)button_team] = button_type - 2;
          redraw_team_box(d + (signed long int)4 + (signed long int)(20 * button_team), button_team);
        }

    }
  }
  cleanup_player_names();
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// clean_buffer
// file sockex.c line 120
static void clean_buffer(char *buffer, signed int len)
{
  signed int i = 0;
  for( ; !(i >= len); i = i + 1)
  {
    const unsigned short int **return_value___ctype_b_loc_1;
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)buffer[(signed long int)i]]) == 0)
    {
      if(!((signed int)buffer[(signed long int)i] == 45))
      {
        if(!((signed int)buffer[(signed long int)i] == 43))
          buffer[(signed long int)i] = (char)46;

      }

    }

  }
}

// cleanup_player_names
// file team.c line 213
static void cleanup_player_names()
{
  signed int i = 0;
  for( ; !(i >= 6); i = i + 1)
    lw_netmess_cleanup_arg(CONFIG_PLAYER_NAME[(signed long int)i]);
}

// clear_message
// file message.h line 58
void clear_message(void)
{
  MESSAGE_NB = 0;
}

// color_one_dialog
// file dialog.h line 105
void color_one_dialog(struct DIALOG *d)
{
  d->fg = 17;
  d->bg = 16;
}

// confirm_quit
// file menu.h line 66
signed int confirm_quit(void)
{
  struct DIALOG d[3l];
  memset((void *)d, 0, sizeof(struct DIALOG [3l]) /*216ul*/ );
  d[(signed long int)2].proc = (signed int (*)(signed int, struct DIALOG *, signed int))(void *)0;
  standard_button(d, 0, 0, 2, 1);
  standard_button(d + (signed long int)1, 1, 0, 2, 1);
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(12);
  d[(signed long int)0].dp = (void *)return_value_lw_lang_string_1;
  char *return_value_lw_lang_string_2;
  return_value_lw_lang_string_2=lw_lang_string(15);
  d[(signed long int)0].dp = (void *)return_value_lw_lang_string_2;
  char *return_value_lw_lang_string_3;
  return_value_lw_lang_string_3=lw_lang_string(16);
  d[(signed long int)1].dp = (void *)return_value_lw_lang_string_3;
  d[(signed long int)0].key = 100;
  d[(signed long int)1].key = 119;
  signed int return_value_my_do_dialog_4;
  return_value_my_do_dialog_4=my_do_dialog(d, 0);
  return (signed int)(return_value_my_do_dialog_4 == 0);
}

// connect_on_server_continue
// file netplay.c line 292
static signed int connect_on_server_continue(signed int sock)
{
  signed int result = 1;
  signed int free_teams;
  signed int i;
  if(result == 1)
  {
    char *return_value_lw_lang_string_1;
    return_value_lw_lang_string_1=lw_lang_string(119);
    display_center_message(return_value_lw_lang_string_1);
    signed int return_value_lw_protocol_do_ping_2;
    return_value_lw_protocol_do_ping_2=lw_protocol_do_ping(&sock);
    if(return_value_lw_protocol_do_ping_2 == 0)
    {
      result = 0;
      error_not_a_liquidwar_server();
    }

  }

  if(result == 1)
  {
    char *return_value_lw_lang_string_3;
    return_value_lw_lang_string_3=lw_lang_string(120);
    display_center_message(return_value_lw_lang_string_3);
    signed int return_value_lw_protocol_tell_program_4;
    return_value_lw_protocol_tell_program_4=lw_protocol_tell_program(&sock, "liquidwar");
    if(return_value_lw_protocol_tell_program_4 == 0)
    {
      result = 0;
      error_not_a_liquidwar_server();
    }

  }

  if(result == 1)
  {
    char *return_value_lw_lang_string_5;
    return_value_lw_lang_string_5=lw_lang_string(121);
    display_center_message(return_value_lw_lang_string_5);
    signed int return_value_lw_protocol_tell_version_6;
    return_value_lw_protocol_tell_version_6=lw_protocol_tell_version(&sock, "5.6.4");
    if(return_value_lw_protocol_tell_version_6 == 0)
    {
      result = 0;
      error_wrong_version();
    }

  }

  if(result == 1)
  {
    char *return_value_lw_lang_string_7;
    return_value_lw_lang_string_7=lw_lang_string(122);
    display_center_message(return_value_lw_lang_string_7);
    signed int return_value_lw_protocol_tell_password_8;
    return_value_lw_protocol_tell_password_8=lw_protocol_tell_password(&sock, CONFIG_PASSWORD);
    if(return_value_lw_protocol_tell_password_8 == 0)
    {
      result = 0;
      error_bad_password();
    }

  }

  if(result == 1)
  {
    char *return_value_lw_lang_string_9;
    return_value_lw_lang_string_9=lw_lang_string(123);
    display_center_message(return_value_lw_lang_string_9);
    signed int return_value_lw_protocol_ask_free_teams_10;
    return_value_lw_protocol_ask_free_teams_10=lw_protocol_ask_free_teams(&sock, &free_teams);
    if(!(return_value_lw_protocol_ask_free_teams_10 == 0))
    {
      if(!(free_teams >= 1))
      {
        result = 0;
        error_server_full();
      }

    }

    else
    {
      result = 0;
      error_network_problem();
    }
  }

  _Bool tmp_if_expr_13;
  if(result == 1)
  {
    char *return_value_lw_lang_string_11;
    return_value_lw_lang_string_11=lw_lang_string(124);
    display_center_message(return_value_lw_lang_string_11);
    i = 0;
    for( ; result == 1 && free_teams >= 1 && !(i >= 6); i = i + 1)
    {
      if(CONFIG_CONTROL_TYPE[(signed long int)i] == 1)
        tmp_if_expr_13 = (_Bool)1;

      else
        tmp_if_expr_13 = (CONFIG_CONTROL_TYPE[(signed long int)i] == 2 ? (CONFIG_ALLOW_NETWORK_BOTS != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_13)
      {
        signed int return_value_lw_protocol_reserve_team_12;
        return_value_lw_protocol_reserve_team_12=lw_protocol_reserve_team(&sock, i, CONFIG_CONTROL_TYPE[(signed long int)i], CONFIG_PLAYER_NAME[(signed long int)i]);
        if(!(return_value_lw_protocol_reserve_team_12 == 0))
          free_teams = free_teams - 1;

        else
        {
          result = 0;
          error_network_problem();
        }
      }

    }
  }

  if(result == 1)
  {
    char *return_value_lw_lang_string_14;
    return_value_lw_lang_string_14=lw_lang_string(125);
    display_center_message(return_value_lw_lang_string_14);
    signed int return_value_lw_protocol_send_config_15;
    return_value_lw_protocol_send_config_15=lw_protocol_send_config(&sock);
    if(return_value_lw_protocol_send_config_15 == 0)
    {
      result = 0;
      error_network_problem();
    }

  }

  void *tmp_if_expr_17;
  if(result == 1)
  {
    char *return_value_lw_lang_string_16;
    return_value_lw_lang_string_16=lw_lang_string(126);
    display_center_message(return_value_lw_lang_string_16);
    if(!(LW_RANDOM_ON == 0))
      tmp_if_expr_17 = LW_RANDOM_RAW_MAP;

    else
      tmp_if_expr_17 = RAW_MAP_ORDERED[(signed long int)CONFIG_LEVEL_MAP];
    signed int return_value_lw_protocol_send_map_18;
    return_value_lw_protocol_send_map_18=lw_protocol_send_map(&sock, tmp_if_expr_17);
    if(return_value_lw_protocol_send_map_18 == 0)
    {
      result = 0;
      error_cant_send_map();
    }

  }

  if(result == 1)
  {
    char *return_value_lw_lang_string_19;
    return_value_lw_lang_string_19=lw_lang_string(127);
    display_center_message(return_value_lw_lang_string_19);
    signed int return_value_lw_protocol_i_am_ready_20;
    return_value_lw_protocol_i_am_ready_20=lw_protocol_i_am_ready(&sock);
    if(return_value_lw_protocol_i_am_ready_20 == 0)
    {
      result = 0;
      error_network_problem();
    }

  }

  if(!(result == 0))
    LW_KEYEXCH_SOCK = sock;

  else
  {
    LW_KEYEXCH_SOCK = -1;
    lw_sock_close(&sock);
  }
  return result;
}

// connect_on_server_finish
// file netplay.c line 443
static signed int connect_on_server_finish(signed int sock)
{
  signed int result = 1;
  signed int i;
  if(result == 1)
  {
    char *return_value_lw_lang_string_1;
    return_value_lw_lang_string_1=lw_lang_string(128);
    display_center_message(return_value_lw_lang_string_1);
    i = 0;
    for( ; result == 1 && !(i >= 6); i = i + 1)
    {
      signed int return_value_lw_protocol_ask_who_2;
      return_value_lw_protocol_ask_who_2=lw_protocol_ask_who(&sock, i, &LW_NETWORK_INFO[(signed long int)i]);
      if(return_value_lw_protocol_ask_who_2 == 0)
      {
        result = 0;
        error_network_problem();
      }

    }
  }

  if(result == 1)
  {
    char *return_value_lw_lang_string_3;
    return_value_lw_lang_string_3=lw_lang_string(129);
    display_center_message(return_value_lw_lang_string_3);
    signed int return_value_lw_protocol_recv_config_4;
    return_value_lw_protocol_recv_config_4=lw_protocol_recv_config(&sock);
    if(return_value_lw_protocol_recv_config_4 == 0)
    {
      result = 0;
      error_network_problem();
    }

  }

  if(result == 1)
  {
    signed int return_value_lw_netconf_check_5;
    return_value_lw_netconf_check_5=lw_netconf_check(&LW_CONFIG_CURRENT_RULES);
    if(return_value_lw_netconf_check_5 == 0)
    {
      result = 0;
      error_bad_config_range();
    }

  }

  if(result == 1)
  {
    char *return_value_lw_lang_string_6;
    return_value_lw_lang_string_6=lw_lang_string(130);
    display_center_message(return_value_lw_lang_string_6);
    signed int return_value_lw_protocol_recv_map_7;
    return_value_lw_protocol_recv_map_7=lw_protocol_recv_map(&sock, &LW_NETWORK_RAW_MAP);
    if(return_value_lw_protocol_recv_map_7 == 0)
    {
      result = 0;
      error_cant_receive_map();
    }

  }

  if(result == 1)
  {
    char *return_value_lw_lang_string_8;
    return_value_lw_lang_string_8=lw_lang_string(127);
    display_center_message(return_value_lw_lang_string_8);
    signed int return_value_lw_protocol_i_am_ready_9;
    return_value_lw_protocol_i_am_ready_9=lw_protocol_i_am_ready(&sock);
    if(return_value_lw_protocol_i_am_ready_9 == 0)
    {
      result = 0;
      error_network_problem();
    }

  }

  if(result == 0)
  {
    LW_KEYEXCH_SOCK = -1;
    lw_sock_close(&sock);
  }

  return result;
}

// connect_on_server_keepalive
// file connect.c line 448
static void connect_on_server_keepalive(void *arg)
{
  signed int result = 1;
  signed int i;
  struct anonymous_25 *data = (struct anonymous_25 *)arg;
  if(data->finished == 0)
  {
    if(result == 1)
    {
      signed int return_value_lw_protocol_waiting_1;
      return_value_lw_protocol_waiting_1=lw_protocol_waiting(&data->sock, &data->waited_teams);
      if(return_value_lw_protocol_waiting_1 == 0)
        result = 0;

    }

    if(result == 1)
    {
      if(data->waited_teams >= 1)
      {
        i = 0;
        for( ; !(i >= 6); i = i + 1)
          if(result == 1)
          {
            signed int return_value_lw_protocol_ask_teamstartinfo_2;
            return_value_lw_protocol_ask_teamstartinfo_2=lw_protocol_ask_teamstartinfo(&data->sock, i, &data->team_start_info[(signed long int)i]);
            if(return_value_lw_protocol_ask_teamstartinfo_2 == 0)
              result = 0;

          }

        if(result == 1)
        {
          if(!(data->chat_send == 0))
          {
            lw_netmess_cleanup_arg(data->chat_buffer);
            signed int return_value_lw_protocol_chat_talk_3;
            return_value_lw_protocol_chat_talk_3=lw_protocol_chat_talk(&data->sock, data->chat_buffer);
            if(return_value_lw_protocol_chat_talk_3 == 0)
              result = 0;

            data->chat_send = 0;
          }

        }

        if(result == 1)
        {
          signed int return_value_lw_protocol_chat_listen_4;
          return_value_lw_protocol_chat_listen_4=lw_protocol_chat_listen(&data->sock, &data->chat_history);
          if(return_value_lw_protocol_chat_listen_4 == 0)
            result = 0;

        }

        if(result == 1)
        {
          if(!(data->force_start == 0))
          {
            signed int return_value_lw_protocol_force_start_5;
            return_value_lw_protocol_force_start_5=lw_protocol_force_start(&data->sock);
            if(return_value_lw_protocol_force_start_5 == 0)
              result = 0;

            data->force_start = 0;
          }

        }

        if(result == 1)
        {
          signed int return_value_lw_protocol_next_6;
          return_value_lw_protocol_next_6=lw_protocol_next(&data->sock);
          if(return_value_lw_protocol_next_6 == 0)
            result = 0;

        }

      }

      else
        if(result == 1)
        {
          signed int return_value_lw_protocol_i_am_ready_7;
          return_value_lw_protocol_i_am_ready_7=lw_protocol_i_am_ready(&data->sock);
          if(return_value_lw_protocol_i_am_ready_7 == 0)
            result = 0;

          data->finished = 1;
        }

    }

  }

  data->result = result;
  data->thread_running = 0;
}

// connect_on_server_start
// file netplay.c line 164
static signed int connect_on_server_start(signed int *sock, char *address, signed int port)
{
  signed int result = 1;
  struct anonymous_7 *connect_data;
  struct anonymous_7 connect_data_stack;
  signed int esc_pressed = 0;
  signed int dummy;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_7) /*40ul*/ );
  connect_data = (struct anonymous_7 *)return_value_malloc_1;
  if(connect_data == ((struct anonymous_7 *)NULL))
    connect_data = &connect_data_stack;

  connect_data->sock = -1;
  __builtin_strncpy(connect_data->address, address, sizeof(char [16l]) /*16ul*/ );
  connect_data->address[(signed long int)(sizeof(char [16l]) /*16ul*/  - (unsigned long int)1)] = (char)0;
  connect_data->port = port;
  connect_data->running = 0;
  connect_data->allow_exit = 0;
  connect_data->free_data = 1;
  connect_data->result = 0;
  char *return_value_lw_lang_string_2;
  return_value_lw_lang_string_2=lw_lang_string(118);
  display_center_message(return_value_lw_lang_string_2);
  connect_data->running = 1;
  _Bool tmp_if_expr_4;
  signed int return_value_lw_thread_start_3;
  if(!(connect_data == &connect_data_stack))
  {
    return_value_lw_thread_start_3=lw_thread_start(connect_on_server_start_callback, (void *)connect_data);
    tmp_if_expr_4 = return_value_lw_thread_start_3 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_4 = (_Bool)0;
  if(!tmp_if_expr_4)
  {
    connect_data->free_data = 0;
    connect_on_server_start_callback((void *)connect_data);
  }

  while(!(connect_data->running == 0))
  {
    if(!(esc_pressed == 0))
      break;

    if(!(key[59l] == 0))
      esc_pressed = 1;

    dummy=keypressed();
    rest((unsigned int)10);
    lw_capture_dump_menu();
    my_exit_poll();
  }
  result = connect_data->result;
  *sock = connect_data->sock;
  if(result == 0)
  {
    *sock = -1;
    if(esc_pressed == 0)
      error_unable_to_connect();

  }

  connect_data->allow_exit = 1;
  return result;
}

// connect_on_server_start_callback
// file netplay.c line 259
static void connect_on_server_start_callback(void *arg)
{
  struct anonymous_7 *connect_data = (struct anonymous_7 *)arg;
  connect_data->result=lw_sock_connect(&connect_data->sock, connect_data->address, connect_data->port);
  connect_data->running = 0;
  while(connect_data->allow_exit == 0)
    rest((unsigned int)10);
  if(!(connect_data->free_data == 0))
    free((void *)connect_data);

}

// controls_options
// file controls.c line 92
signed int controls_options(void)
{
  struct DIALOG d[9l];
  signed int choix = 4;
  signed int retour = 0;
  memset((void *)d, 0, sizeof(struct DIALOG [9l]) /*648ul*/ );
  char *return_value_lw_lang_string_2;
  char *return_value_lw_lang_string_3;
  char *return_value_lw_lang_string_4;
  char *return_value_lw_lang_string_5;
  while(retour == 0)
  {
    standard_button(d + (signed long int)4, 0, 0, 2, 4);
    standard_button(d + (signed long int)5, 1, 0, 2, 4);
    standard_big_button(d + (signed long int)6, 0, 2, 1, 4);
    standard_button(d + (signed long int)7, 0, 3, 1, 4);
    quick_buttons(d);
    d[(signed long int)4].proc = my_textbox_proc;
    char *return_value_lw_lang_string_1;
    return_value_lw_lang_string_1=lw_lang_string(81);
    d[(signed long int)4].dp = (void *)return_value_lw_lang_string_1;
    switch(CONFIG_JOYSTICK_ON)
    {
      case 1:
      {
        return_value_lw_lang_string_2=lw_lang_string(83);
        d[(signed long int)5].dp = (void *)return_value_lw_lang_string_2;
        break;
      }
      case 2:
      {
        return_value_lw_lang_string_3=lw_lang_string(84);
        d[(signed long int)5].dp = (void *)return_value_lw_lang_string_3;
        break;
      }
      case 3:
      {
        return_value_lw_lang_string_4=lw_lang_string(85);
        d[(signed long int)5].dp = (void *)return_value_lw_lang_string_4;
        break;
      }
      default:
      {
        return_value_lw_lang_string_5=lw_lang_string(82);
        d[(signed long int)5].dp = (void *)return_value_lw_lang_string_5;
      }
    }
    d[(signed long int)6].proc = my_textbox_proc;
    char *return_value_lw_lang_string_6;
    return_value_lw_lang_string_6=lw_lang_string(86);
    d[(signed long int)6].dp = (void *)return_value_lw_lang_string_6;
    d[(signed long int)7].proc = my_slider_proc;
    d[(signed long int)7].dp = (void *)0;
    d[(signed long int)7].d1 = 8;
    d[(signed long int)7].d2 = CONFIG_MOUSE_GAP;
    d[(signed long int)7].dp2 = (void *)slider_mouse;
    d[(signed long int)7].dp3 = (void *)&CONFIG_MOUSE_GAP;
    d[(signed long int)8].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
    choix=my_do_dialog(d, choix);
    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 2)
        goto __CPROVER_DUMP_L8;

      if(choix == 0)
        goto __CPROVER_DUMP_L9;

      if(choix == 1)
        goto __CPROVER_DUMP_L12;

      if(choix == 5)
        goto __CPROVER_DUMP_L13;

    }

    else
    {
      retour = 1;
      goto __CPROVER_DUMP_L15;

    __CPROVER_DUMP_L8:
      ;
      retour = -1;
      goto __CPROVER_DUMP_L15;

    __CPROVER_DUMP_L9:
      ;
      signed int return_value_confirm_quit_7;
      return_value_confirm_quit_7=confirm_quit();
      if(!(return_value_confirm_quit_7 == 0))
        retour = -2;

      else
        display_back_image();
      goto __CPROVER_DUMP_L15;

    __CPROVER_DUMP_L12:
      ;
      retour = -3;
      goto __CPROVER_DUMP_L15;

    __CPROVER_DUMP_L13:
      ;
      CONFIG_JOYSTICK_ON = CONFIG_JOYSTICK_ON + 1;
      if(CONFIG_JOYSTICK_ON >= 4)
        CONFIG_JOYSTICK_ON = 0;

      my_initialise_joystick();
    }

  __CPROVER_DUMP_L15:
    ;
  }
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// convert_to_buffer
// file map.c line 332
static void convert_to_buffer(struct BITMAP *bmp, char *buffer, signed int *size, signed int *bg_size)
{
  signed int pos_src;
  signed int l;
  signed int wh;
  char *data;
  wh = bmp->h * bmp->w;
  data = (char *)bmp->dat;
  pos_src = 0;
  *size = 0;
  *bg_size = 0;
  signed int tmp_post_1;
  signed int tmp_post_2;
  while(!(pos_src >= wh))
  {
    l = 0;
    if(!((signed int)data[(signed long int)pos_src] == 1))
    {
      for( ; !(pos_src >= wh); pos_src = pos_src + 1)
      {
        if((signed int)data[(signed long int)pos_src] == 1)
          break;

        if(l >= 127)
          break;

        l = l + 1;
      }
      tmp_post_1 = *size;
      *size = *size + 1;
      buffer[(signed long int)tmp_post_1] = (char)l;
    }

    else
    {
      for( ; !(pos_src >= wh); pos_src = pos_src + 1)
      {
        if(!((signed int)data[(signed long int)pos_src] == 1))
          break;

        if(l >= 127)
          break;

        l = l + 1;
      }
      tmp_post_2 = *size;
      *size = *size + 1;
      buffer[(signed long int)tmp_post_2] = (char)-l;
      *bg_size = *bg_size + l;
    }
  }
  signed int tmp_post_3 = *size;
  *size = *size + 1;
  buffer[(signed long int)tmp_post_3] = (char)0;
}

// correct_palette
// file texture.c line 163
static void correct_palette(struct RGB *pal, signed int first_color, signed int number_of_colors)
{
  signed int i = 0;
  for( ; !(i >= first_color); i = i + 1)
  {
    (pal + (signed long int)i)->r = (unsigned char)0;
    (pal + (signed long int)i)->g = (unsigned char)0;
    (pal + (signed long int)i)->b = (unsigned char)0;
  }
  i = first_color + number_of_colors;
  for( ; !(i >= 256); i = i + 1)
  {
    (pal + (signed long int)i)->r = (unsigned char)63;
    (pal + (signed long int)i)->g = (unsigned char)63;
    (pal + (signed long int)i)->b = (unsigned char)63;
  }
}

// correct_path_dir
// file startup.c line 285
static void correct_path_dir(char *path)
{
  signed int l;
  char c;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(path);
  l = (signed int)return_value_strlen_1;
  if(l >= 1)
  {
    c = path[(signed long int)(l - 1)];
    if((signed int)c == 47 || (signed int)c == 92)
    {
      l = l - 1;
      path[(signed long int)l] = (char)0;
    }

  }

  fix_filename_case(path);
  fix_filename_slashes(path);
}

// correct_path_file
// file startup.c line 306
static void correct_path_file(char *path)
{
  fix_filename_case(path);
  fix_filename_slashes(path);
}

// create_army
// file army.c line 263
signed int create_army(void)
{
  signed int ret = -1;
  signed int i;
  signed int fill_table[33l] = { 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 16, 18, 20, 22, 24, 25, 27, 29, 31, 33, 36, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 99 };
  signed int return_value_get_battle_room_1;
  return_value_get_battle_room_1=get_battle_room();
  CURRENT_ARMY_SIZE = (return_value_get_battle_room_1 * fill_table[(signed long int)LW_CONFIG_CURRENT_RULES.fighter_number]) / 100;
  CURRENT_ARMY_SIZE = CURRENT_ARMY_SIZE / PLAYING_TEAMS;
  if(!(CURRENT_ARMY_SIZE >= 1))
    CURRENT_ARMY_SIZE = 1;

  CURRENT_ARMY_SIZE = CURRENT_ARMY_SIZE * PLAYING_TEAMS;
  void *return_value_malloc_in_big_data_bottom_2;
  return_value_malloc_in_big_data_bottom_2=malloc_in_big_data_bottom((signed int)((unsigned long int)CURRENT_ARMY_SIZE * sizeof(struct anonymous_21) /*8ul*/ ));
  CURRENT_ARMY = (struct anonymous_21 *)return_value_malloc_in_big_data_bottom_2;
  if(!(CURRENT_ARMY == ((struct anonymous_21 *)NULL)))
  {
    i = 0;
    for( ; !(i >= CURRENT_ARMY_SIZE); i = i + 1)
    {
      (CURRENT_ARMY + (signed long int)i)->health = (signed short int)0;
      (CURRENT_ARMY + (signed long int)i)->team = (char)-1;
      (CURRENT_ARMY + (signed long int)i)->x = (signed short int)0;
      (CURRENT_ARMY + (signed long int)i)->y = (signed short int)0;
      (CURRENT_ARMY + (signed long int)i)->last_dir = (char)0;
    }
    ret = 0;
  }

  return ret;
}

// create_converted_bitmap
// file texture.c line 183
static void create_converted_bitmap(struct BITMAP *bmp, struct RGB *dst, struct RGB *src, signed int first_color, signed int number_of_colors)
{
  char corres[256l];
  signed int i;
  signed int x;
  signed int y;
  signed int index;
  i = 0;
  signed int return_value_bestfit_color_1;
  for( ; !(i >= 256); i = i + 1)
  {
    return_value_bestfit_color_1=bestfit_color(dst, (signed int)(src + (signed long int)i)->r, (signed int)(src + (signed long int)i)->g, (signed int)(src + (signed long int)i)->b);
    corres[(signed long int)i] = (char)return_value_bestfit_color_1;
  }
  y = 0;
  for( ; !(y >= bmp->h); y = y + 1)
  {
    x = 0;
    for( ; !(x >= bmp->w); x = x + 1)
    {
      signed int return_value_getpixel_2;
      return_value_getpixel_2=getpixel_link6(bmp, x, y);
      index = (signed int)corres[(signed long int)return_value_getpixel_2];
      index = index < first_color || index >= first_color + number_of_colors ? first_color : index;
      putpixel_link8(bmp, x, y, index);
    }
  }
}

// create_default_back
// file disk.c line 259
static void create_default_back(void)
{
  static struct RGB back_coul;
  memset((void *)&back_coul, 0, sizeof(struct RGB) /*4ul*/ );
  back_coul.r = (unsigned char)1;
  back_coul.g = (unsigned char)1;
  back_coul.b = (unsigned char)8;
  BACK_IMAGE=my_create_bitmap(1, 1);
  putpixel_link1(BACK_IMAGE, 0, 0, 18);
  GLOBAL_PALETTE[(signed long int)18] = back_coul;
}

// create_dir_bitmap
// file grad.c line 108
struct BITMAP * create_dir_bitmap(signed int team)
{
  struct BITMAP *result;
  signed int x;
  signed int y;
  signed int i;
  struct anonymous_0 *temp;
  result=my_create_bitmap(CURRENT_AREA_W, CURRENT_AREA_H);
  i = 0;
  y = 0;
  signed int tmp_post_1;
  for( ; !(y >= CURRENT_AREA_H); y = y + 1)
  {
    x = 0;
    for( ; !(x >= CURRENT_AREA_W); x = x + 1)
    {
      tmp_post_1 = i;
      i = i + 1;
      temp = (CURRENT_AREA + (signed long int)tmp_post_1)->mesh;
      if(!(temp == ((struct anonymous_0 *)NULL)))
        putpixel_link4(result, x, y, 134 + ((signed int)temp->info[(signed long int)team].state.dir / 4) * 42 + ((signed int)temp->info[(signed long int)team].state.dir % 4) * 10);

    }
  }
  return result;
}

// create_first_mesher
// file mesh.c line 103
static struct anonymous * create_first_mesher(struct BITMAP *map)
{
  struct anonymous *result;
  signed int x;
  signed int y;
  signed int h;
  signed int w;
  signed int size;
  signed int i;
  signed int j;
  w = map->w;
  h = map->h;
  size = h * w;
  void *return_value_malloc_in_big_data_top_1;
  return_value_malloc_in_big_data_top_1=malloc_in_big_data_top((signed int)((unsigned long int)size * sizeof(struct anonymous) /*112ul*/ ));
  result = (struct anonymous *)return_value_malloc_in_big_data_top_1;
  signed int return_value_getpixel_2;
  if(!(result == ((struct anonymous *)NULL)))
  {
    i = 0;
    for( ; !(i >= size); i = i + 1)
    {
      (result + (signed long int)i)->size = (signed short int)1;
      (result + (signed long int)i)->corres = 3;
      j = 0;
      for( ; !(j >= 12); j = j + 1)
        (result + (signed long int)i)->link[(signed long int)j] = (void *)0;
    }
    y = 0;
    for( ; !(y >= h); y = y + 1)
    {
      x = 0;
      for( ; !(x >= w); x = x + 1)
      {
        return_value_getpixel_2=getpixel_link4(map, x, y);
        (result + (signed long int)(y * w + x))->used = (char)(return_value_getpixel_2 == 1 ? 0 : 1);
      }
    }
    y = 1;
    for( ; !(y >= h + -1); y = y + 1)
    {
      x = 1;
      for( ; !(x >= w + -1); x = x + 1)
      {
        i = y * w + x;
        if(!((result + (signed long int)i)->used == 0))
        {
          if(!((result + (signed long int)(i + -w))->used == 0))
          {
            (result + (signed long int)i)->link[(signed long int)0] = (void *)((result + (signed long int)i) - (signed long int)w);
            (result + (signed long int)i)->link[(signed long int)11] = (result + (signed long int)i)->link[(signed long int)0];
          }

          if(!((result + (signed long int)(1 + i + -w))->used == 0))
            (result + (signed long int)i)->link[(signed long int)1] = (void *)(((result + (signed long int)i) - (signed long int)w) + (signed long int)1);

          if(!((result + (signed long int)(1 + i))->used == 0))
          {
            (result + (signed long int)i)->link[(signed long int)3] = (void *)(result + (signed long int)i + (signed long int)1);
            (result + (signed long int)i)->link[(signed long int)2] = (result + (signed long int)i)->link[(signed long int)3];
          }

          if(!((result + (signed long int)(1 + i + w))->used == 0))
            (result + (signed long int)i)->link[(signed long int)4] = (void *)(result + (signed long int)i + (signed long int)w + (signed long int)1);

          if(!((result + (signed long int)(i + w))->used == 0))
          {
            (result + (signed long int)i)->link[(signed long int)6] = (void *)(result + (signed long int)i + (signed long int)w);
            (result + (signed long int)i)->link[(signed long int)5] = (result + (signed long int)i)->link[(signed long int)6];
          }

          if(!((result + (signed long int)(i + w + -1))->used == 0))
            (result + (signed long int)i)->link[(signed long int)7] = (void *)((result + (signed long int)i + (signed long int)w) - (signed long int)1);

          if(!((result + (signed long int)(i + -1))->used == 0))
          {
            (result + (signed long int)i)->link[(signed long int)9] = (void *)((result + (signed long int)i) - (signed long int)1);
            (result + (signed long int)i)->link[(signed long int)8] = (result + (signed long int)i)->link[(signed long int)9];
          }

          if(!((result + (signed long int)(i + -w + -1))->used == 0))
            (result + (signed long int)i)->link[(signed long int)10] = (void *)(((result + (signed long int)i) - (signed long int)w) - (signed long int)1);

        }

      }
    }
  }

  return result;
}

// create_game_area
// file area.c line 86
signed int create_game_area(void)
{
  signed int x;
  signed int y;
  signed int i;
  signed int test;
  void *return_value_malloc_in_big_data_bottom_1;
  return_value_malloc_in_big_data_bottom_1=malloc_in_big_data_bottom((signed int)((unsigned long int)(CURRENT_AREA_W * CURRENT_AREA_H) * sizeof(struct anonymous_22) /*16ul*/ ));
  CURRENT_AREA = (struct anonymous_22 *)return_value_malloc_in_big_data_bottom_1;
  if(!(CURRENT_AREA == ((struct anonymous_22 *)NULL)) && !(CURRENT_MESH == ((struct anonymous_0 *)NULL)))
  {
    i = 0;
    y = 0;
    for( ; !(y >= CURRENT_AREA_H); y = y + 1)
    {
      x = 0;
      for( ; !(x >= CURRENT_AREA_W); x = x + 1)
      {
        (CURRENT_AREA + (signed long int)i)->mesh = (struct anonymous_0 *)(void *)0;
        (CURRENT_AREA + (signed long int)i)->fighter = (struct anonymous_21 *)(void *)0;
        i = i + 1;
      }
    }
    i = 0;
    for( ; !(i >= CURRENT_MESH_SIZE); i = i + 1)
    {
      y = 0;
      for( ; !(y >= (signed int)(CURRENT_MESH + (signed long int)i)->side.size); y = y + 1)
      {
        x = 0;
        for( ; !(x >= (signed int)(CURRENT_MESH + (signed long int)i)->side.size); x = x + 1)
        {
          (CURRENT_AREA + (signed long int)(((signed int)(CURRENT_MESH + (signed long int)i)->y + y) * CURRENT_AREA_W + (signed int)(CURRENT_MESH + (signed long int)i)->x + x))->mesh = CURRENT_MESH + (signed long int)i;
          test = (signed int)(CURRENT_MESH + (signed long int)i)->info[(signed long int)0].state.grad;
        }
      }
    }
  }

  return CURRENT_AREA != ((struct anonymous_22 *)NULL) ? 0 : -1;
}

// create_gradient_bitmap
// file grad.h line 71
struct BITMAP * create_gradient_bitmap(signed int team)
{
  struct BITMAP *result;
  signed int x;
  signed int y;
  signed int i;
  signed int color;
  struct anonymous_0 *temp;
  result=my_create_bitmap(CURRENT_AREA_W, CURRENT_AREA_H);
  signed int tmp_post_1;
  if(!(result == ((struct BITMAP *)NULL)))
  {
    i = 0;
    y = 0;
    for( ; !(y >= CURRENT_AREA_H); y = y + 1)
    {
      x = 0;
      for( ; !(x >= CURRENT_AREA_W); x = x + 1)
      {
        tmp_post_1 = i;
        i = i + 1;
        temp = (CURRENT_AREA + (signed long int)tmp_post_1)->mesh;
        if(!(temp == ((struct anonymous_0 *)NULL)))
        {
          color = ((signed int)temp->info[(signed long int)team].state.grad + 2000000) % COLORS_PER_TEAM;
          putpixel_link4(result, x, y, color + COLOR_FIRST_ENTRY[(signed long int)team]);
        }

        else
          putpixel_link4(result, x, y, 16);
      }
    }
  }

  return result;
}

// create_mesh
// file mesh.h line 134
signed int create_mesh(void)
{
  signed int retour = 0;
  signed int i;
  struct BITMAP *map;
  struct anonymous *mesher;
  signed int zoom_factor = 1;
  CURRENT_MESH = (struct anonymous_0 *)(void *)0;
  CURRENT_MESH_SIZE = 0;
  CURRENT_AREA_W = 0;
  CURRENT_AREA_H = 0;
  map=lw_map_create_bicolor(CONFIG_LEVEL_MAP, 1, 2, LW_NETWORK_ON, LW_RANDOM_ON, MIN_MAP_RES_W[(signed long int)LW_CONFIG_CURRENT_RULES.min_map_res], MIN_MAP_RES_H[(signed long int)LW_CONFIG_CURRENT_RULES.min_map_res], &zoom_factor);
  signed int return_value_group_mesher_1;
  if(!(map == ((struct BITMAP *)NULL)))
  {
    mesher=create_first_mesher(map);
    if(!(mesher == ((struct anonymous *)NULL)))
    {
      i = 1;
      for( ; !(i >= 9); i = i * 2)
      {
        return_value_group_mesher_1=group_mesher(mesher, map, i);
        if(return_value_group_mesher_1 == 0)
          break;

      }
      CURRENT_MESH=mesher_to_mesh(mesher, map, &CURRENT_MESH_SIZE, &CURRENT_AREA_W, &CURRENT_AREA_H);
      free_last_big_data_top();
    }

    destroy_bitmap(map);
  }

  if(CURRENT_MESH == ((struct anonymous_0 *)NULL))
    retour = -1;

  return retour;
}

// create_mesh_bitmap
// file mesh.h line 135
struct BITMAP * create_mesh_bitmap(signed int mode)
{
  struct BITMAP *result;
  signed int i;
  signed int j;
  signed int color;
  result=lw_maptex_create_map(CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, CONFIG_LEVEL_BG, LW_NETWORK_ON, LW_RANDOM_ON, MIN_MAP_RES_W[(signed long int)LW_CONFIG_CURRENT_RULES.min_map_res], MIN_MAP_RES_H[(signed long int)LW_CONFIG_CURRENT_RULES.min_map_res], CONFIG_USE_DEFAULT_TEXTURE);
  if(!(result == ((struct BITMAP *)NULL)))
  {
    i = 0;
    for( ; !(i >= CURRENT_MESH_SIZE); i = i + 1)
    {
      if(mode == 0)
      {
        color = 0;
        j = (signed int)(CURRENT_MESH + (signed long int)i)->side.size;
        for( ; j >= 2; color = color + 1)
          j = j / 2;
        goto __CPROVER_DUMP_L6;
      }

      color = i;

    __CPROVER_DUMP_L6:
      ;
      rectfill_link3(result, (signed int)(CURRENT_MESH + (signed long int)i)->x, (signed int)(CURRENT_MESH + (signed long int)i)->y, ((signed int)(CURRENT_MESH + (signed long int)i)->x + (signed int)(CURRENT_MESH + (signed long int)i)->side.size) - 1, ((signed int)(CURRENT_MESH + (signed long int)i)->y + (signed int)(CURRENT_MESH + (signed long int)i)->side.size) - 1, 96 + color % 32);
    }
  }

  return result;
}

// create_mono_texture
// file texture.c line 385
static struct BITMAP * create_mono_texture(signed int first)
{
  struct BITMAP *result;
  result=my_create_bitmap(1, 1);
  putpixel_link8(result, 0, 0, first);
  return result;
}

// create_new_palette
// file texture.c line 127
static void create_new_palette(struct RGB *dst, struct RGB *src, struct BITMAP *bmp, signed int first_color, signed int number_of_colors)
{
  signed int i;
  signed int x;
  signed int y;
  signed int index;
  signed int nb_retries = 0;
  struct RGB color;
  signed long int return_value_random_1;
  return_value_random_1=random();
  x = (signed int)(return_value_random_1 % (signed long int)bmp->w);
  signed long int return_value_random_2;
  return_value_random_2=random();
  y = (signed int)(return_value_random_2 % (signed long int)bmp->h);
  signed int return_value_getpixel_3;
  return_value_getpixel_3=getpixel_link6(bmp, x, y);
  color = src[(signed long int)return_value_getpixel_3];
  i = 0;
  for( ; !(i >= 256); i = i + 1)
    dst[(signed long int)i] = color;
  i = 1;
  signed int tmp_post_6;
  while(!(i >= number_of_colors))
  {
    signed long int return_value_random_4;
    return_value_random_4=random();
    x = (signed int)(return_value_random_4 % (signed long int)bmp->w);
    signed long int return_value_random_5;
    return_value_random_5=random();
    y = (signed int)(return_value_random_5 % (signed long int)bmp->h);
    index=getpixel_link6(bmp, x, y);
    color = src[(signed long int)index];
    signed int return_value_exist_color_7;
    return_value_exist_color_7=exist_color(dst, color);
    if(return_value_exist_color_7 == 0 || nb_retries >= 10001)
    {
      tmp_post_6 = i;
      i = i + 1;
      dst[(signed long int)(first_color + tmp_post_6)] = color;
      nb_retries = 0;
    }

    else
      nb_retries = nb_retries + 1;
  }
}

// create_raw_texture
// file texture.c line 325
static struct BITMAP * create_raw_texture(void *ptr, signed int first)
{
  signed int x;
  signed int y;
  signed int pos8 = 0;
  signed int color;
  char totest;
  char *data;
  struct BITMAP *result;
  signed short int w;
  signed short int h;
  data = (char *)ptr;
  lw_serial_get_texture_header((void *)data, &w, &h);
  data = data + (signed long int)((unsigned long int)2 * sizeof(signed short int) /*2ul*/  + (unsigned long int)16 + (unsigned long int)(3 * 32));
  result=my_create_bitmap((signed int)w, (signed int)h);
  if(!(result == ((struct BITMAP *)NULL)))
  {
    y = 0;
    for( ; !(y >= (signed int)h); y = y + 1)
    {
      x = 0;
      for( ; !(x >= (signed int)w); x = x + 1)
      {
        totest = (char)(1 << pos8);
        color = first + (((signed int)data[(signed long int)0] & (signed int)totest) != 0 ? 1 : 0) + (((signed int)data[(signed long int)1] & (signed int)totest) != 0 ? 2 : 0) + (((signed int)data[(signed long int)2] & (signed int)totest) != 0 ? 4 : 0) + (((signed int)data[(signed long int)3] & (signed int)totest) != 0 ? 8 : 0) + (((signed int)data[(signed long int)4] & (signed int)totest) != 0 ? 16 : 0);
        putpixel_link8(result, x, y, color);
        if(pos8 == 7)
        {
          data = data + (signed long int)5;
          pos8 = 0;
        }

        else
          pos8 = pos8 + 1;
      }
    }
  }

  return result;
}

// create_texture
// file texture.c line 396
static struct BITMAP * create_texture(signed int num, signed int first)
{
  struct BITMAP *result;
  void *texture;
  texture=get_raw_texture(num);
  if(!(texture == NULL))
    result=create_raw_texture(texture, first);

  else
    result=create_mono_texture(first);
  return result;
}

// create_wave_line
// file distor.c line 159
static void create_wave_line(signed int *buffer, signed int length, signed int number, signed int ampli, signed int speed, signed int sens)
{
  signed int i;
  signed int period;
  signed int period2;
  signed int cycle_tmp;
  signed int ampli_cst;
  signed int ampli_cos;
  signed int freq_coef;
  signed int cycle_coef;
  signed int f0;
  signed int fp0x0;
  signed int alphax03;
  signed int betax02;
  signed int temp;
  signed int first_entry;
  signed int last_entry;
  signed int real_length;
  signed int *buffer2;
  length = length - 1;
  do
  {
    period = length / (number + 1);
    number = number - 1;
  }
  while(number >= 0 && !(period >= 64));
  period2 = period / 2;
  if(!(period2 >= 1))
    period2 = 1;

  period = period2 * 2;
  real_length = period * (number + 1);
  first_entry = (length - real_length) / 2;
  last_entry = first_entry + real_length;
  buffer2 = buffer + (signed long int)first_entry;
  freq_coef = 16777216 / period;
  ampli_cst = (ampli * 4096) / period2;
  ampli_cos = (ampli_cst * 3217) / 1024;
  cycle_tmp = 65536;
  for( ; speed >= 1; speed = speed - 1)
    cycle_tmp = cycle_tmp / 2;
  signed int return_value_fsqrt_1;
  return_value_fsqrt_1=fsqrt(cycle_tmp);
  signed int return_value_fsqrt_2;
  return_value_fsqrt_2=fsqrt(return_value_fsqrt_1);
  cycle_tmp = return_value_fsqrt_2 / 2;
  signed int tmp_if_expr_3;
  if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
    tmp_if_expr_3 = gfx_driver->w;

  else
    tmp_if_expr_3 = 0;
  cycle_tmp = cycle_tmp / tmp_if_expr_3;
  cycle_tmp = cycle_tmp * period;
  if(!(cycle_tmp >= 1))
    cycle_tmp = 1;

  signed int return_value_itofix_4;
  return_value_itofix_4=itofix_link1(GLOBAL_TICKER % cycle_tmp);
  cycle_coef = sens * 256 * (return_value_itofix_4 / cycle_tmp);
  f0=fsin(cycle_coef + freq_coef * period2);
  signed int return_value_fcos_5;
  return_value_fcos_5=fcos(cycle_coef + freq_coef * period2);
  fp0x0 = (3217 * return_value_fcos_5) / 1024;
  alphax03 = (ampli_cst / 256) * ((fp0x0 - 2 * f0) / 256);
  betax02 = (ampli_cst / 256) * ((-fp0x0 + 3 * f0) / 256);
  i = 0;
  for( ; !(i >= period2); i = i + 1)
  {
    temp = (3 * alphax03 * i) / period2 + 2 * betax02;
    temp = (temp * i) / period2;
    buffer2[(signed long int)i] = temp / 4;
  }
  i = period2;
  for( ; !(i >= real_length + -period2); i = i + 1)
  {
    signed int return_value_fcos_6;
    return_value_fcos_6=fcos(cycle_coef + freq_coef * i);
    temp = (ampli_cos / 256) * (return_value_fcos_6 / 256);
    buffer2[(signed long int)i] = temp / 4;
  }
  alphax03 = (ampli_cst / 256) * ((-fp0x0 - 2 * f0) / 256);
  betax02 = (ampli_cst / 256) * ((fp0x0 + 3 * f0) / 256);
  i = 0;
  for( ; !(i >= period2); i = i + 1)
  {
    temp = (3 * alphax03 * i) / period2 + 2 * betax02;
    temp = (-temp * i) / period2;
    buffer2[(signed long int)((real_length - 1) - i)] = temp / 4;
  }
  i = 0;
  for( ; !(i >= first_entry); i = i + 1)
    buffer[(signed long int)i] = 0;
  i = last_entry;
  for( ; !(i >= length); i = i + 1)
    buffer[(signed long int)i] = 0;
  buffer[(signed long int)length] = 0;
}

// decode
// file netkey.c line 198
static void decode(struct anonymous_5 *dst, unsigned char *src)
{
  signed int i = 0;
  for( ; !(i >= 6); i = i + 1)
    dst->key_states[(signed long int)i]=ascii_hexa_to_int((char)src[(signed long int)i]);
  dst->cmd = (signed int)src[(signed long int)6];
  dst->arg=ascii_hexa_to_int((char)src[(signed long int)(6 + 1)]);
  dst->checksum = (unsigned int)src[(signed long int)(6 + 2 + 3)] << 24 | (unsigned int)src[(signed long int)(6 + 2 + 2)] << 16 | (unsigned int)src[(signed long int)(6 + 2 + 1)] << 8 | (unsigned int)src[(signed long int)(6 + 2 + 0)];
}

// disp_all_cursors
// file pion.h line 63
void disp_all_cursors(void)
{
  signed int i;
  signed int degrad_size;
  signed int fp;
  signed int ip;
  degrad_size = 32 / (2 * 2);
  ip = ((GLOBAL_TICKER * COLORS_PER_TEAM) / 256) % (COLORS_PER_TEAM * 2);
  fp = 0;
  i = 0;
  for( ; !(i >= 32); i = i + 1)
  {
    if(!(ip >= COLORS_PER_TEAM))
      CURSOR_COLOR_MAP[(signed long int)i] = (char)ip;

    else
      CURSOR_COLOR_MAP[(signed long int)i] = (char)((2 * COLORS_PER_TEAM - 1) - ip);
    fp = fp + COLORS_PER_TEAM;
    for( ; fp >= degrad_size; ip = ip + 1)
      fp = fp - degrad_size;
    for( ; ip >= 2 * COLORS_PER_TEAM; ip = ip - 2 * COLORS_PER_TEAM)
      ;
  }
  i = 0;
  for( ; !(i >= 6); i = i + 1)
    if(!(CURRENT_CURSOR[(signed long int)i].active == 0))
      disp_cursor(i);

}

// disp_base_message
// file exit.c line 128
static void disp_base_message(void)
{
  lw_basicopt_legal_info("Liquid War by U-Foot");
}

// disp_big_data_message
// file exit.c line 206
static void disp_big_data_message(void)
{
  log_println_str("Liquid War was unable to allocate memory for its calculus.");
  log_println();
  disp_common_memory_message();
}

// disp_common_memory_message
// file exit.c line 167
static void disp_common_memory_message(void)
{
  log_println_str("Try \"lw -auto\" if you don't want to waste your time.");
  log_println();
  log_println_str("Try \"lw -mem n\" where 'n' is the number of Mb to be allocated by Liquid War");
  log_println_str("to do all his calculus. The lower it is, the safer it is in general, but you");
  log_println_str("won't be able to play with all the levels if 'n' is too small.");
  log_println_str("'n' can range from 1 to 32, default is 8.");
  log_println();
  log_println_str("If you run Liquid War from Windows, try and give it more DPMI memory.");
  log_println();
  log_println_str("Try \"lw -noback\" to skip background image loading.");
  log_println_str("Try \"lw -notex\" to skip texture loading.");
  log_println_str("Try \"lw -nowater\" to skip water sounds loading.");
  log_println_str("Try \"lw -nosfx\" to skip sound fx loading.");
  log_println();
  log_println_str("Try \"lw -nice\" if \"lw -auto\" doesn't work correctly.");
  log_println_str("Try \"lw -safe\" if nothing else works.");
}

// disp_cursor
// file pion.c line 166
static void disp_cursor(signed int number)
{
  signed int i;
  signed int x;
  signed int y;
  signed int x0;
  signed int y0;
  signed int color_offset;
  x0 = CURRENT_CURSOR[(signed long int)number].x;
  y0 = CURRENT_CURSOR[(signed long int)number].y;
  color_offset = COLOR_FIRST_ENTRY[(signed long int)CURRENT_CURSOR[(signed long int)number].team];
  i = 0;
  for( ; !(i >= 68); i = i + 1)
  {
    x = x0 + CURSOR_LAYOUT[(signed long int)i].x;
    y = y0 + CURSOR_LAYOUT[(signed long int)i].y;
    signed int return_value_getpixel_1;
    return_value_getpixel_1=getpixel_link5(CURRENT_AREA_DISP, x, y);
    CURSOR_GRAPHIC_MEMORY[(signed long int)number][(signed long int)i] = (char)return_value_getpixel_1;
    switch(CURSOR_LAYOUT[(signed long int)i].row)
    {
      case 3:

      case 0:

      case 1:
      {
        putpixel_link7(CURRENT_AREA_DISP, x, y, (signed int)CURSOR_COLOR_MAP[(signed long int)CURSOR_LAYOUT[(signed long int)i].color] + color_offset);
        break;
      }
      case 2:
        putpixel_link7(CURRENT_AREA_DISP, x, y, (signed int)CURSOR_COLOR_BACK[(signed long int)CURSOR_LAYOUT[(signed long int)i].color]);
    }
  }
}

// disp_custom_fail_message
// file exit.c line 236
static void disp_custom_fail_message(void)
{
  log_println_str("Liquid War was unable to load your custom maps.");
  log_println();
  log_println_str("This can happen when:");
  log_println();
  log_println_str("The path is wrong, use \"lw -tex path\" or \"lw -map path\".");
  log_println_str("Your bitmaps are not correct, just change them.");
  log_println_str("You don't have enough memory.");
}

// disp_distorted_area
// file distor.h line 66
void disp_distorted_area(void)
{
  char *src;
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  signed int lim_w;
  signed int lim_h;
  signed int init_w;
  signed int init_h;
  signed int *y_corres;
  signed int fp_x;
  signed int ip_x;
  signed int fp_y;
  signed int ip_y;
  signed int fp_y0;
  signed int ip_y0;
  signed int fp_x0[1024l];
  signed int reste_x;
  signed int temp = 0;
  signed int bmp_color_depth;
  signed int bmp_linear;
  signed int bmp_memory;
  bmp_color_depth=bitmap_color_depth(DISTORSION_TARGET);
  bmp_linear=is_linear_bitmap(DISTORSION_TARGET);
  bmp_memory=is_memory_bitmap(DISTORSION_TARGET);
  w = DISTORSION_TARGET->w;
  h = DISTORSION_TARGET->h;
  lim_w = 4096 * w;
  lim_h = 4096 * h;
  init_w = (CURRENT_AREA_W * 4096) / 2;
  init_h = (CURRENT_AREA_H * 4096) / 2;
  prepare_wave_shapes();
  x = 0;
  for( ; !(x >= w); x = x + 1)
    fp_x0[(signed long int)x] = 0;
  fp_y0 = init_h;
  ip_y0 = 0;
  y = 0;
  for( ; !(y >= h); y = y + 1)
  {
    fp_y = fp_y0;
    ip_y = ip_y0;
    fp_x = init_w;
    ip_x = 0;
    src = (char *)CURRENT_AREA_DISP->dat + (signed long int)(ip_y0 * CURRENT_AREA_W);
    y_corres = WAVE_SHAPE_Y_CORRES[(signed long int)y];
    temp = 0;
    x = 0;
    for( ; !(x >= w); x = x + 1)
    {
      putpixel_link2(DISTORSION_TARGET, x, y, (signed int)*src);
      fp_x0[(signed long int)x] = fp_x0[(signed long int)x] + WAVE_SHAPE_X_CORRES[(signed long int)x][(signed long int)y];
      reste_x = fp_x0[(signed long int)x];
      fp_x = fp_x + WAVE_SHAPE_WX[(signed long int)x];
      for( ; !(reste_x >= -fp_x); src = src - 1l)
        fp_x = fp_x + lim_w;
      for( ; fp_x + reste_x >= lim_w; src = src + 1l)
        fp_x = fp_x - lim_w;
      fp_y = fp_y + y_corres[(signed long int)x];
      for( ; !(fp_y >= 0); src = src - (signed long int)CURRENT_AREA_W)
        fp_y = fp_y + lim_h;
      for( ; fp_y >= lim_h; src = src + (signed long int)CURRENT_AREA_W)
        fp_y = fp_y - lim_h;
    }
    fp_y0 = fp_y0 + WAVE_SHAPE_HY[(signed long int)y];
    for( ; fp_y0 >= lim_h; ip_y0 = ip_y0 + 1)
      fp_y0 = fp_y0 - lim_h;
  }
  blit(DISTORSION_TARGET, NEXT_SCREEN, 0, 0, 0, 0, DISTORSION_TARGET->w, DISTORSION_TARGET->h);
}

// disp_error_message
// file exit.c line 142
static void disp_error_message(void)
{
  log_println_str("Thanks for trying to play, sorry about the trouble Liquid War is causing you.");
}

// disp_fighter
// file fighter.c line 137
static void disp_fighter(struct anonymous_21 *f)
{
  putpixel_link3(CURRENT_AREA_DISP, (signed int)f->x, (signed int)f->y, COLOR_FIRST_ENTRY[(signed long int)(signed int)f->team] + ((signed int)f->health * COLORS_PER_TEAM) / 16384);
}

// disp_graphics_fail_message
// file exit.c line 253
static void disp_graphics_fail_message(void)
{
  log_println_str("Unable to set up a graphic mode.");
  log_println();
  log_println_str("Liquid War _needs_ to set up a graphic mode.");
  log_println_str("Please check that your config is supported by Allegro.");
}

// disp_init_fail_message
// file exit.c line 150
static void disp_init_fail_message(void)
{
  log_println_str("An error occured during the init process.");
  log_println();
  log_println_str("Try \"lw -silent\" to disable sound management.");
  log_println_str("Try \"lw -nojoy\" to disable joystick control.");
  log_println();
  log_print_str("Try to delete the \"");
  log_print_str(STARTUP_CFG_PATH);
  log_println_str("\" file and restart Liquid War.");
}

// disp_load_fail_message
// file exit.c line 219
static void disp_load_fail_message(void)
{
  log_println_str("Liquid War was unable to load its datafile.");
  log_println();
  log_print_str("Please first check that \"");
  log_print_str(STARTUP_DAT_PATH);
  log_print_str("\" exists.");
  log_println();
  log_println();
  disp_common_memory_message();
}

// disp_mem_trouble_message
// file exit.c line 194
static void disp_mem_trouble_message(void)
{
  log_println_str("Liquid War is running short of memory for its bitmaps.");
  log_println();
  disp_common_memory_message();
}

// disp_ok_message
// file exit.c line 135
static void disp_ok_message(void)
{
  log_println_str("Thanks for playing Liquid War, I hope you enjoyed it!");
}

// disp_stretch_area
// file disp.c line 73
static void disp_stretch_area(void)
{
  stretch_blit(CURRENT_AREA_DISP, NEXT_SCREEN, 0, 0, CURRENT_AREA_W, CURRENT_AREA_H, 0, 0, NEXT_SCREEN->w, NEXT_SCREEN->h);
}

// display
// file game.c line 639
static void display(void)
{
  watchdog_update();
  check_code();
  start_profile(2);
  fill_next_screen();
  stop_profile(2);
  check_info_state();
  update_play_time();
  signed int return_value_lw_capture_get_mode_1;
  return_value_lw_capture_get_mode_1=lw_capture_get_mode();
  if(!(return_value_lw_capture_get_mode_1 == 0))
  {
    display_info();
    lw_capture_dump_game();
    display_message();
  }

  else
  {
    display_message();
    display_info();
  }
  start_profile(3);
  page_flip();
  stop_profile(3);
}

// display_a_back_image
// file back.c line 73
void display_a_back_image(struct BITMAP *bmp)
{
  scare_mouse();
  signed int tmp_if_expr_1;
  if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
    tmp_if_expr_1 = gfx_driver->w;

  else
    tmp_if_expr_1 = 0;
  signed int tmp_if_expr_2;
  if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
    tmp_if_expr_2 = gfx_driver->h;

  else
    tmp_if_expr_2 = 0;
  stretch_blit(bmp, screen, 0, 0, bmp->w, bmp->h, 0, PAGE_FLIP_H, tmp_if_expr_1, tmp_if_expr_2);
  unscare_mouse();
}

// display_area
// file disp.c line 82
void display_area(void)
{
  _Bool tmp_if_expr_1;
  if(!(CONFIG_WAVE_AMPLI[0l] == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = CONFIG_WAVE_AMPLI[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = CONFIG_WAVE_AMPLI[(signed long int)2] != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = CONFIG_WAVE_AMPLI[(signed long int)3] != 0 ? (_Bool)1 : (_Bool)0;
  if(!(CONFIG_WAVE_ON == 0) && tmp_if_expr_3)
    disp_distorted_area();

  else
    disp_stretch_area();
}

// display_back_image
// file back.h line 69
void display_back_image(void)
{
  display_a_back_image(BACK_IMAGE);
}

// display_center_message
// file dialog.c line 332
void display_center_message(char *str)
{
  struct DIALOG d[2l];
  struct DIALOG_PLAYER *dp;
  memset((void *)d, 0, sizeof(struct DIALOG [2l]) /*144ul*/ );
  display_back_image();
  main_message(d, str);
  d[(signed long int)1].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
  dp=my_init_dialog(d, 0);
  my_update_dialog(dp);
  shutdown_dialog(dp);
}

// display_chosen_level
// file level.c line 164
static void display_chosen_level(void)
{
  signed int x1;
  signed int x2;
  signed int x3;
  signed int x4;
  signed int x5;
  signed int x6;
  signed int x7;
  signed int x8;
  signed int y1;
  signed int y2;
  signed int y3;
  signed int y4;
  signed int y5;
  signed int y6;
  signed int y7;
  signed int y8;
  signed int sample_x;
  signed int sample_y;
  signed int sample_w;
  signed int sample_h;
  signed int max_w;
  signed int max_h;
  signed int bmp_w;
  signed int bmp_h;
  struct BITMAP *pour_voir;
  retrieve_choose_level_xy(&x1, &x2, &x3, &x4, &x5, &x6, &x7, &x8, &y1, &y2, &y3, &y4, &y5, &y6, &y7, &y8);
  signed int return_value_menu_real_x_1;
  return_value_menu_real_x_1=menu_real_x(x4);
  signed int return_value_menu_real_y_2;
  return_value_menu_real_y_2=menu_real_y(y1);
  signed int return_value_menu_real_x_3;
  return_value_menu_real_x_3=menu_real_x(x4 + 160);
  signed int return_value_menu_real_y_4;
  return_value_menu_real_y_4=menu_real_y(y1 + 120);
  rectfill_link2(screen, return_value_menu_real_x_1, return_value_menu_real_y_2, return_value_menu_real_x_3 - 1, return_value_menu_real_y_4 - 1, 16);
  lw_maptex_set_fg_palette(CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, 0, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
  lw_maptex_set_bg_palette(CONFIG_LEVEL_MAP, CONFIG_LEVEL_BG, 0, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
  my_set_palette();
  pour_voir=lw_maptex_create_map(CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, CONFIG_LEVEL_BG, 0, LW_RANDOM_ON, MIN_MAP_RES_W[(signed long int)CONFIG_MIN_MAP_RES], MIN_MAP_RES_H[(signed long int)CONFIG_MIN_MAP_RES], CONFIG_USE_DEFAULT_TEXTURE);
  if(!(pour_voir == ((struct BITMAP *)NULL)))
  {
    max_w=menu_real_x(160);
    max_h=menu_real_y(120);
    bmp_w = pour_voir->w;
    bmp_h = pour_voir->h;
    if(!(bmp_h * max_w >= bmp_w * max_h))
    {
      sample_w = max_w;
      sample_h = (max_w * bmp_h) / bmp_w;
    }

    else
    {
      sample_w = (max_h * bmp_w) / bmp_h;
      sample_h = max_h;
    }
    signed int return_value_menu_real_x_5;
    return_value_menu_real_x_5=menu_real_x(x4);
    sample_x = return_value_menu_real_x_5 + (max_w - sample_w) / 2;
    signed int return_value_menu_real_y_6;
    return_value_menu_real_y_6=menu_real_y(y1);
    sample_y = return_value_menu_real_y_6 + (max_h - sample_h) / 2;
    stretch_blit(pour_voir, screen, 0, 0, bmp_w, bmp_h, sample_x, sample_y, sample_w, sample_h);
    destroy_bitmap(pour_voir);
  }

  signed int return_value_lw_maptex_is_custom_texture_used_15;
  return_value_lw_maptex_is_custom_texture_used_15=lw_maptex_is_custom_texture_used(CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, 0, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
  if(return_value_lw_maptex_is_custom_texture_used_15 == 0)
  {
    signed int return_value_menu_real_x_7;
    return_value_menu_real_x_7=menu_real_x(x1);
    signed int return_value_menu_real_y_8;
    return_value_menu_real_y_8=menu_real_y(y1);
    signed int return_value_menu_real_x_9;
    return_value_menu_real_x_9=menu_real_x(x1 + 40);
    signed int return_value_menu_real_y_10;
    return_value_menu_real_y_10=menu_real_y(y1 + 40);
    rectfill_link2(screen, return_value_menu_real_x_7, return_value_menu_real_y_8, return_value_menu_real_x_9 - 1, return_value_menu_real_y_10 - 1, 16);
    pour_voir=lw_maptex_create_fg(CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, 0, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
    if(!(pour_voir == ((struct BITMAP *)NULL)))
    {
      signed int return_value_menu_real_x_11;
      return_value_menu_real_x_11=menu_real_x(x1);
      signed int return_value_menu_real_x_12;
      return_value_menu_real_x_12=menu_real_x(y1);
      signed int return_value_menu_real_x_13;
      return_value_menu_real_x_13=menu_real_x(40);
      signed int return_value_menu_real_x_14;
      return_value_menu_real_x_14=menu_real_x(40);
      stretch_blit(pour_voir, screen, 0, 0, pour_voir->w, pour_voir->h, return_value_menu_real_x_11, return_value_menu_real_x_12, return_value_menu_real_x_13, return_value_menu_real_x_14);
      destroy_bitmap(pour_voir);
    }

  }

  signed int return_value_lw_maptex_is_custom_texture_used_24;
  return_value_lw_maptex_is_custom_texture_used_24=lw_maptex_is_custom_texture_used(CONFIG_LEVEL_MAP, CONFIG_LEVEL_BG, 0, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
  if(return_value_lw_maptex_is_custom_texture_used_24 == 0)
  {
    signed int return_value_menu_real_x_16;
    return_value_menu_real_x_16=menu_real_x(x8);
    signed int return_value_menu_real_y_17;
    return_value_menu_real_y_17=menu_real_y(y1);
    signed int return_value_menu_real_x_18;
    return_value_menu_real_x_18=menu_real_x(x8 + 40);
    signed int return_value_menu_real_y_19;
    return_value_menu_real_y_19=menu_real_y(y1 + 40);
    rectfill_link2(screen, return_value_menu_real_x_16, return_value_menu_real_y_17, return_value_menu_real_x_18 - 1, return_value_menu_real_y_19 - 1, 16);
    pour_voir=lw_maptex_create_bg(CONFIG_LEVEL_MAP, CONFIG_LEVEL_BG, 0, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
    if(!(pour_voir == ((struct BITMAP *)NULL)))
    {
      signed int return_value_menu_real_x_20;
      return_value_menu_real_x_20=menu_real_x(x8);
      signed int return_value_menu_real_x_21;
      return_value_menu_real_x_21=menu_real_x(y1);
      signed int return_value_menu_real_x_22;
      return_value_menu_real_x_22=menu_real_x(40);
      signed int return_value_menu_real_x_23;
      return_value_menu_real_x_23=menu_real_x(40);
      stretch_blit(pour_voir, screen, 0, 0, pour_voir->w, pour_voir->h, return_value_menu_real_x_20, return_value_menu_real_x_21, return_value_menu_real_x_22, return_value_menu_real_x_23);
      destroy_bitmap(pour_voir);
    }

  }

}

// display_gradient
// file disp.c line 94
void display_gradient(signed int i)
{
  struct BITMAP *bmp;
  bmp=create_gradient_bitmap(i);
  if(!(bmp == ((struct BITMAP *)NULL)))
  {
    stretch_blit(bmp, NEXT_SCREEN, 0, 0, bmp->w, bmp->h, 0, 0, NEXT_SCREEN->w, NEXT_SCREEN->h);
    destroy_bitmap(bmp);
  }

}

// display_help
// file help.h line 67
signed int display_help(char *str)
{
  signed int retour = 0;
  signed int choix = 3;
  struct DIALOG d[6l];
  memset((void *)d, 0, sizeof(struct DIALOG [6l]) /*432ul*/ );
  prepare_help(d, str);
  display_back_image();
  while(retour == 0)
  {
    choix=my_do_dialog_no_clear(d, choix);
    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 1)
        goto __CPROVER_DUMP_L3;

      if(choix == 2)
        goto __CPROVER_DUMP_L4;

      if(choix == 0)
        goto __CPROVER_DUMP_L5;

    }

    else
    {
      retour = 1;
      continue;

    __CPROVER_DUMP_L3:
      ;
      retour = -3;
      continue;

    __CPROVER_DUMP_L4:
      ;
      retour = -1;
      continue;

    __CPROVER_DUMP_L5:
      ;
      signed int return_value_confirm_quit_1;
      return_value_confirm_quit_1=confirm_quit();
      if(!(return_value_confirm_quit_1 == 0))
        retour = -2;

    }
  }
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// display_horizontal_info
// file info.c line 241
static void display_horizontal_info(signed int w, signed int h, signed int epaisseur)
{
  signed int i;
  signed int barre_w;
  signed int barre_x;
  signed int barre_y;
  w = w;
  display_time(0, 0, epaisseur, h);
  i = 0;
  for( ; !(i >= PLAYING_TEAMS); i = i + 1)
  {
    barre_w = (ACTIVE_FIGHTERS[(signed long int)i] * (INFO_BAR_POS_W - 1)) / CURRENT_ARMY_SIZE + 1;
    barre_x = (INFO_BAR_POS_X[(signed long int)i] + INFO_BAR_POS_W) - barre_w;
    barre_y = INFO_BAR_POS_Y[(signed long int)i];
    rectfill_link1(INFO_BAR, barre_x, barre_y, (barre_x + barre_w) - 1, (barre_y + INFO_BAR_POS_H) - 1, (COLOR_FIRST_ENTRY[(signed long int)i] + COLORS_PER_TEAM) - 1);
  }
}

// display_info
// file info.h line 60
void display_info(void)
{
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  signed int epaisseur;
  signed int temp_h;
  signed int temp_w;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_5;
  signed int tmp_if_expr_6;
  if((4 & CONFIG_INFO_BAR) == 0)
  {
    signed int return_value_text_length_1;
    return_value_text_length_1=text_length(font, "00:00");
    temp_w = return_value_text_length_1 + 2;
    signed int return_value_text_height_2;
    return_value_text_height_2=text_height(font);
    temp_h = return_value_text_height_2 + 2;
    if(!(CONFIG_INFO_BAR == 0) && !(CONFIG_INFO_BAR == 2))
    {
      if(CONFIG_INFO_BAR == 1)
        goto __CPROVER_DUMP_L5;

    }

    else
    {
      if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
        tmp_if_expr_3 = gfx_driver->w;

      else
        tmp_if_expr_3 = 0;
      w = tmp_if_expr_3;
      h = temp_h;
      if(!(h >= 13))
        h = 13;

      epaisseur = temp_w;
      goto __CPROVER_DUMP_L9;
    }

  __CPROVER_DUMP_L5:
    ;
    w = temp_w;
    if(!(w >= 13))
      w = 13;

    if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
      tmp_if_expr_4 = gfx_driver->h;

    else
      tmp_if_expr_4 = 0;
    h = tmp_if_expr_4;
    epaisseur = temp_h;

  __CPROVER_DUMP_L9:
    ;
    if(INFO_BAR == ((struct BITMAP *)NULL))
      init_info_bar(w, h, epaisseur);

    draw_sprite_link1(INFO_BAR, INFO_BAR_BACK, 0, 0);
    switch(CONFIG_INFO_BAR)
    {
      case 0:
      {
        x = 0;
        y = PAGE_FLIP_H;
        hline_link1(screen, x, y + h, (x + w) - 1, 17);
        display_horizontal_info(w, h, epaisseur);
        break;
      }
      case 1:
      {
        if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
          tmp_if_expr_5 = gfx_driver->w;

        else
          tmp_if_expr_5 = 0;
        x = tmp_if_expr_5 - w;
        y = PAGE_FLIP_H;
        vline_link1(screen, x - 1, y, (y + h) - 1, 17);
        display_vertical_info(w, h, epaisseur);
        break;
      }
      case 2:
      {
        x = 0;
        if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
          tmp_if_expr_6 = gfx_driver->h;

        else
          tmp_if_expr_6 = 0;
        y = (PAGE_FLIP_H + tmp_if_expr_6) - h;
        hline_link1(screen, x, y - 1, (x + w) - 1, 17);
        display_horizontal_info(w, h, epaisseur);
        break;
      }
      default:
      {
        x = 0;
        y = PAGE_FLIP_H;
        vline_link1(screen, x + w, y, (y + h) - 1, 17);
        display_vertical_info(w, h, epaisseur);
      }
    }
    draw_sprite_link1(screen, INFO_BAR, x, y);
  }

}

// display_mesh
// file disp.c line 109
void display_mesh(signed int i)
{
  struct BITMAP *bmp;
  bmp=create_mesh_bitmap(i);
  if(!(bmp == ((struct BITMAP *)NULL)))
  {
    stretch_blit(bmp, NEXT_SCREEN, 0, 0, bmp->w, bmp->h, 0, 0, NEXT_SCREEN->w, NEXT_SCREEN->h);
    destroy_bitmap(bmp);
  }

}

// display_message
// file message.h line 59
void display_message(void)
{
  signed int i;
  signed int h;
  signed int j;
  signed int new_ticker;
  new_ticker=get_ticker();
  i = 0;
  for( ; !(i >= MESSAGE_NB); i = i + 1)
    if(MESSAGE_DISPLAYED[(signed long int)i] == 0)
    {
      MESSAGE_DISPLAYED[(signed long int)i] = 1;
      MESSAGE_TICKER[(signed long int)i] = new_ticker + MESSAGE_DELAY * (i + 1);
    }

  for( ; MESSAGE_NB >= 1; MESSAGE_NB = MESSAGE_NB - 1)
  {
    if(MESSAGE_DISPLAYED[0l] == 0)
      break;

    if(MESSAGE_TICKER[0l] >= new_ticker)
      break;

    i = 0;
    for( ; !(i >= MESSAGE_NB + -1); i = i + 1)
    {
      j = 0;
      for( ; !(j >= 1); j = j + 1)
      {
        MESSAGE[(signed long int)i][(signed long int)j] = MESSAGE[(signed long int)(i + 1)][(signed long int)j];
        MESSAGE_TICKER[(signed long int)i] = MESSAGE_TICKER[(signed long int)(i + 1)];
      }
    }
  }
  h=text_height(font);
  i = 0;
  signed int return_value_text_length_1;
  for( ; !(i >= MESSAGE_NB); i = i + 1)
  {
    return_value_text_length_1=text_length(font, MESSAGE[(signed long int)i]);
    textout_ex(NEXT_SCREEN, font, MESSAGE[(signed long int)i], NEXT_SCREEN->w - return_value_text_length_1, NEXT_SCREEN->h - (MESSAGE_NB - i) * h, -1, -1);
  }
}

// display_scores
// file score.h line 66
signed int display_scores(void)
{
  signed int last_draw_done = 0;
  signed int first_ticker;
  signed int diff_ticker;
  signed int retour = 0;
  signed int choix = 2;
  struct DIALOG d[11l];
  struct DIALOG_PLAYER *dp;
  char buf[3l][33l];
  char buf_old[3l][33l];
  signed int x[3l];
  signed int h[3l];
  signed int w;
  signed int y;
  signed int ellipse_h;
  signed int i;
  signed int cursor[3l];
  struct BITMAP *eprouvette[3l];
  signed int time_delay[3l] = { 500, 2500, 1500 };
  signed int fill_level;
  signed int done[3l];
  memset((void *)d, 0, sizeof(struct DIALOG [11l]) /*792ul*/ );
  quick_buttons(d);
  i = 0;
  for( ; !(i >= 3); i = i + 1)
  {
    standard_small_button(d + (signed long int)i + (signed long int)4, i, 10, 3, 11);
    d[(signed long int)(i + 4)].proc = my_textbox_proc;
  }
  d[(signed long int)4].dp = (void *)"";
  d[(signed long int)5].dp = (void *)"";
  d[(signed long int)6].dp = (void *)"";
  standard_button(d + (signed long int)7, 0, 4, 3, 11);
  standard_button(d + (signed long int)8, 1, 0, 3, 11);
  standard_button(d + (signed long int)9, 2, 2, 3, 11);
  i = 0;
  for( ; !(i >= 3); i = i + 1)
  {
    d[(signed long int)(i + 7)].proc = my_textbox_proc;
    d[(signed long int)(i + 7)].flags = 16;
  }
  d[(signed long int)7].dp = (void *)"";
  d[(signed long int)8].dp = (void *)"";
  d[(signed long int)9].dp = (void *)"";
  d[(signed long int)10].proc = (signed int (*)(signed int, struct DIALOG *, signed int))(void *)0;
  init_tombola();
  ellipse_h = d[(signed long int)4].h;
  signed int return_value_menu_real_y_1;
  return_value_menu_real_y_1=menu_real_y(3);
  y = d[(signed long int)4].y - return_value_menu_real_y_1;
  signed int tmp_if_expr_2;
  if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
    tmp_if_expr_2 = gfx_driver->h;

  else
    tmp_if_expr_2 = 0;
  h[(signed long int)1] = 2 * y - tmp_if_expr_2;
  h[(signed long int)0] = h[(signed long int)1] / 2;
  h[(signed long int)2] = (3 * h[(signed long int)1]) / 4;
  w = d[(signed long int)4].w;
  x[(signed long int)0] = d[(signed long int)4].x;
  x[(signed long int)1] = d[(signed long int)5].x;
  x[(signed long int)2] = d[(signed long int)6].x;
  cursor[(signed long int)0]=get_cursor(3);
  cursor[(signed long int)1]=get_cursor(1);
  cursor[(signed long int)2]=get_cursor(2);
  i = 0;
  for( ; !(i >= 3); i = i + 1)
  {
    done[(signed long int)i] = 0;
    write_score(cursor[(signed long int)i], buf[(signed long int)i], 0);
    buf_old[(signed long int)i][(signed long int)0] = (char)0;
    eprouvette[(signed long int)i]=my_create_bitmap(w, h[(signed long int)i]);
  }
  d[(signed long int)0].flags = 16;
  d[(signed long int)1].flags = 16;
  display_back_image();
  dp=my_init_dialog(d, 0);
  my_update_dialog(dp);
  shutdown_dialog(dp);
  my_fade_in();
  play_win();
  first_ticker=get_ticker();
  signed int return_value_my_update_dialog_3;
  signed int tmp_statement_expression_5;
  while(retour == 0)
  {
    if(last_draw_done == 0)
    {
      dp=my_init_dialog(d, choix);
      do
      {
        return_value_my_update_dialog_3=my_update_dialog(dp);
        if(return_value_my_update_dialog_3 == 0)
          break;

        if(!(last_draw_done == 0))
          break;

        scare_mouse();
        signed int return_value_get_ticker_4;
        return_value_get_ticker_4=get_ticker();
        diff_ticker = return_value_get_ticker_4 - first_ticker;
        if(!(cursor[0l] >= 0))
          diff_ticker = diff_ticker + 1000;

        i = 0;
        for( ; !(i >= 3); i = i + 1)
          if(done[(signed long int)i] == 0)
          {
            fill_level = diff_ticker - time_delay[(signed long int)i];
            signed int return_value_draw_score_bitmap_7;
            return_value_draw_score_bitmap_7=draw_score_bitmap(eprouvette[(signed long int)i], cursor[(signed long int)i], ellipse_h, fill_level);
            if(!(return_value_draw_score_bitmap_7 == 0))
            {
              draw_sprite_link2(screen, eprouvette[(signed long int)i], x[(signed long int)i], y - h[(signed long int)i]);
              if(fill_level >= 1)
              {
                write_score(cursor[(signed long int)i], buf[(signed long int)i], fill_level);
                unsigned long int __s1_len;
                unsigned long int __s2_len;
                signed int return_value___builtin_strcmp_6;
                return_value___builtin_strcmp_6=__builtin_strcmp(buf[(signed long int)i], buf_old[(signed long int)i]);
                tmp_statement_expression_5 = return_value___builtin_strcmp_6;
                if(!(tmp_statement_expression_5 == 0))
                {
                  d[(signed long int)(4 + i)].dp = (void *)buf[(signed long int)i];
                  d[(signed long int)(4 + i)].proc(3, d + (signed long int)4 + (signed long int)i, 0);
                  memset((void *)buf_old[(signed long int)i], 0, sizeof(char [33l]) /*33ul*/ );
                  __builtin_strncpy(buf_old[(signed long int)i], buf[(signed long int)i], sizeof(char [33l]) /*33ul*/  - (unsigned long int)1);
                  buf_old[(signed long int)i][(signed long int)(sizeof(char [33l]) /*33ul*/  - (unsigned long int)1)] = (char)0;
                }

              }

            }

            else
            {
              if(i == 1)
                last_draw_done = 1;

              d[(signed long int)(7 + i)].dp = (void *)CURRENT_CURSOR[(signed long int)cursor[(signed long int)i]].name;
              d[(signed long int)(7 + i)].flags = 0;
              d[(signed long int)(7 + i)].proc(3, d + (signed long int)7 + (signed long int)i, 0);
              done[(signed long int)i] = 1;
            }
          }

        unscare_mouse();
        rest((unsigned int)10);
      }
      while((_Bool)1);
      choix=shutdown_dialog(dp);
    }

    if(!(last_draw_done == 0))
    {
      scare_mouse();
      i = 0;
      for( ; !(i >= 3); i = i + 1)
        draw_sprite_link2(screen, eprouvette[(signed long int)i], x[(signed long int)i], y - h[(signed long int)i]);
      unscare_mouse();
      d[(signed long int)0].flags = 1;
      d[(signed long int)1].flags = 1;
      choix=my_do_dialog_no_clear(d, last_draw_done == 1 ? 3 : choix);
      last_draw_done = 2;
    }

    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 2)
        goto __CPROVER_DUMP_L25;

      if(choix == 0)
        goto __CPROVER_DUMP_L26;

      if(choix == 1)
        goto __CPROVER_DUMP_L29;

    }

    else
    {
      retour = 1;
      continue;

    __CPROVER_DUMP_L25:
      ;
      retour = -1;
      continue;

    __CPROVER_DUMP_L26:
      ;
      signed int return_value_confirm_quit_8;
      return_value_confirm_quit_8=confirm_quit();
      if(!(return_value_confirm_quit_8 == 0))
        retour = -2;

      else
        display_back_image();
      continue;

    __CPROVER_DUMP_L29:
      ;
      retour = -3;
    }
  }
  i = 0;
  for( ; !(i >= 3); i = i + 1)
    destroy_bitmap(eprouvette[(signed long int)i]);
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// display_special_info
// file code.c line 90
static void display_special_info(void)
{
  signed int global;
  signed int spread;
  signed int move;
  signed int disp;
  signed int flip;
  if(!(WATCHDOG_SCANCODE[51l] == 0))
  {
    global=get_profile(4);
    if(!(global >= 1))
      global = 1;

    char *return_value_lw_lang_string_1;
    return_value_lw_lang_string_1=lw_lang_string(135);
    message_str_int(return_value_lw_lang_string_1, 1000 / global);
  }

  if(!(WATCHDOG_SCANCODE[52l] == 0))
  {
    global=get_logic_rate();
    if(!(global >= 1))
      global = 1;

    char *return_value_lw_lang_string_2;
    return_value_lw_lang_string_2=lw_lang_string(136);
    message_str_int(return_value_lw_lang_string_2, 1000 / global);
  }

  if(!(WATCHDOG_SCANCODE[53l] == 0))
  {
    global=get_profile(4);
    spread=get_profile(0);
    move=get_profile(1);
    if(!(global >= 1))
      global = 1;

    char *return_value_lw_lang_string_3;
    return_value_lw_lang_string_3=lw_lang_string(137);
    message_str_int(return_value_lw_lang_string_3, (100 * (spread + move)) / global);
  }

  if(!(WATCHDOG_SCANCODE[54l] == 0))
  {
    global=get_profile(4);
    disp=get_profile(2);
    flip=get_profile(3);
    if(!(global >= 1))
      global = 1;

    char *return_value_lw_lang_string_4;
    return_value_lw_lang_string_4=lw_lang_string(138);
    message_str_int(return_value_lw_lang_string_4, (100 * (disp + flip)) / global);
  }

  signed int return_value_watchdog_is_keyword_11;
  return_value_watchdog_is_keyword_11=watchdog_is_keyword("speed");
  if(!(return_value_watchdog_is_keyword_11 == 0))
  {
    global=get_profile(4);
    spread=get_profile(0);
    move=get_profile(1);
    disp=get_profile(2);
    flip=get_profile(3);
    char *return_value_lw_lang_string_5;
    return_value_lw_lang_string_5=lw_lang_string(139);
    message_str_int(return_value_lw_lang_string_5, spread);
    char *return_value_lw_lang_string_6;
    return_value_lw_lang_string_6=lw_lang_string(140);
    message_str_int(return_value_lw_lang_string_6, move);
    char *return_value_lw_lang_string_7;
    return_value_lw_lang_string_7=lw_lang_string(141);
    message_str_int(return_value_lw_lang_string_7, disp);
    char *return_value_lw_lang_string_8;
    return_value_lw_lang_string_8=lw_lang_string(142);
    message_str_int(return_value_lw_lang_string_8, flip);
    char *return_value_lw_lang_string_9;
    return_value_lw_lang_string_9=lw_lang_string(143);
    message_str_int(return_value_lw_lang_string_9, (((global - spread) - move) - disp) - flip);
    char *return_value_lw_lang_string_10;
    return_value_lw_lang_string_10=lw_lang_string(144);
    message_str_int(return_value_lw_lang_string_10, global);
  }

}

// display_success
// file init.h line 64
void display_success(signed int success)
{
  if(!(success == 0))
    log_println_str(" - success!");

  else
    log_println_str(" - failed...");
  log_flush();
}

// display_success_driver
// file init.h line 65
void display_success_driver(char *driver)
{
  log_print_str(" (driver=\"");
  log_print_str(driver);
  log_println_str("\") - success!");
  log_flush();
}

// display_time
// file info.c line 212
static void display_time(signed int x, signed int y, signed int w, signed int h)
{
  char buffer[6l];
  signed int min;
  signed int sec;
  signed int display_time__1__time;
  w = w;
  h = h;
  display_time__1__time = TIME_LEFT;
  if(!(display_time__1__time >= 0))
    display_time__1__time = 0;

  min = display_time__1__time / 60;
  sec = display_time__1__time % 60;
  buffer[(signed long int)0] = (char)(48 + min / 10);
  buffer[(signed long int)1] = (char)(48 + min % 10);
  buffer[(signed long int)2] = (char)58;
  buffer[(signed long int)3] = (char)(48 + sec / 10);
  buffer[(signed long int)4] = (char)(48 + sec % 10);
  buffer[(signed long int)5] = (char)0;
  textout_ex(INFO_BAR, font, buffer, x + 1, y + 1, -1, -1);
}

// display_vertical_info
// file info.c line 269
static void display_vertical_info(signed int w, signed int h, signed int epaisseur)
{
  signed int i;
  signed int barre_h;
  signed int barre_x;
  signed int barre_y;
  h = h;
  display_time(0, 0, w, epaisseur);
  i = 0;
  for( ; !(i >= PLAYING_TEAMS); i = i + 1)
  {
    barre_h = (ACTIVE_FIGHTERS[(signed long int)i] * (INFO_BAR_POS_H - 1)) / CURRENT_ARMY_SIZE + 1;
    barre_y = (INFO_BAR_POS_Y[(signed long int)i] + INFO_BAR_POS_H) - barre_h;
    barre_x = INFO_BAR_POS_X[(signed long int)i];
    rectfill_link1(INFO_BAR, barre_x, barre_y, (barre_x + INFO_BAR_POS_W) - 1, (barre_y + barre_h) - 1, (COLOR_FIRST_ENTRY[(signed long int)i] + COLORS_PER_TEAM) - 1);
  }
}

// distance_between_colors
// file network.c line 95
signed int distance_between_colors(signed int col1, signed int col2)
{
  signed int dist;
  if(!(col1 >= 0) || !(col2 >= 0))
    dist = 6;

  else
    dist=abs(col1 - col2);
  if(dist >= 13)
    dist = 12 / 2;

  if(dist >= 7)
    dist = 12 - dist;

  return dist;
}

// draw_score_bitmap
// file score.c line 207
static signed int draw_score_bitmap(struct BITMAP *bitmap, signed int cursor, signed int ellipse_h, signed int fill_level)
{
  signed int w;
  signed int h;
  signed int color1 = 0;
  signed int color2 = 0;
  signed int y_rect1;
  signed int y_rect2;
  signed int x_mid;
  signed int to_be_filled;
  signed int to_be_drawn;
  w = bitmap->w;
  if((1 & w) == 0)
    w = w - 1;

  h = bitmap->h;
  y_rect1 = ellipse_h / 2;
  y_rect2 = (h - y_rect1) - 1;
  x_mid = w / 2;
  if(!(cursor >= 0))
    fill_level = 0;

  else
  {
    color1 = CURRENT_CURSOR[(signed long int)cursor].color_entry + COLORS_PER_TEAM / 2;
    color2 = (CURRENT_CURSOR[(signed long int)cursor].color_entry + COLORS_PER_TEAM) - 1;
  }
  if(!(fill_level >= 0))
    fill_level = 0;

  to_be_filled = fill_level != 0 ? 1 : 0;
  to_be_drawn = fill_level > 1000 ? 0 : 1;
  if(fill_level >= 1001)
    fill_level = 1000;

  if(!(to_be_drawn == 0))
  {
    fill_level = 1000 - fill_level;
    fill_level = fill_level * (h - 3 * y_rect1);
    fill_level = fill_level / 1000;
    fill_level = fill_level + 2 * y_rect1;
    rectfill_link4(bitmap, 0, 0, w, h, 0);
    if(!(to_be_filled == 0))
      ellipsefill(bitmap, x_mid, y_rect2, x_mid, ellipse_h / 2, color1);

    ellipse(bitmap, x_mid, y_rect2, x_mid, ellipse_h / 2, 17);
    if(!(to_be_filled == 0))
    {
      rectfill_link4(bitmap, 1, fill_level, x_mid * 2 - 1, y_rect2 - 1, color1);
      ellipsefill(bitmap, x_mid, fill_level, x_mid - 1, ellipse_h / 2 - 1, color2);
    }

    vline_link3(bitmap, 0, y_rect1, y_rect2, 17);
    vline_link3(bitmap, x_mid * 2, y_rect1, y_rect2, 17);
    ellipse(bitmap, x_mid, y_rect1, x_mid, ellipse_h / 2, 17);
  }

  return to_be_drawn;
}

// draw_sprite
// file /usr/include/allegro/inline/draw.inl line 238
static inline void draw_sprite(struct BITMAP *bmp, struct BITMAP *sprite, signed int x, signed int y)
{
  if(sprite->vtable->color_depth == 8)
    bmp->vtable->draw_256_sprite(bmp, sprite, x, y);

  else
    bmp->vtable->draw_sprite(bmp, sprite, x, y);
}

// draw_sprite_link1
// file /usr/include/allegro/inline/draw.inl line 238
static inline void draw_sprite_link1(struct BITMAP *bmp_link1, struct BITMAP *sprite_link1, signed int x_link1, signed int y_link1)
{
  if(sprite_link1->vtable->color_depth == 8)
    bmp_link1->vtable->draw_256_sprite(bmp_link1, sprite_link1, x_link1, y_link1);

  else
    bmp_link1->vtable->draw_sprite(bmp_link1, sprite_link1, x_link1, y_link1);
}

// draw_sprite_link2
// file /usr/include/allegro/inline/draw.inl line 238
static inline void draw_sprite_link2(struct BITMAP *bmp_link2, struct BITMAP *sprite_link2, signed int x_link2, signed int y_link2)
{
  if(sprite_link2->vtable->color_depth == 8)
    bmp_link2->vtable->draw_256_sprite(bmp_link2, sprite_link2, x_link2, y_link2);

  else
    bmp_link2->vtable->draw_sprite(bmp_link2, sprite_link2, x_link2, y_link2);
}

// eat_space
// file netmess.c line 91
static signed int eat_space(char **message)
{
  signed int result = 0;
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*(*message)]) == 0)
      break;

    result = result + 1;
    *message = *message + 1l;
  }
  while((_Bool)1);
  return result;
}

// eliminate_team
// file decal.c line 89
signed int eliminate_team(signed int team)
{
  signed int i;
  signed int j;
  if(PLAYING_TEAMS >= 1)
  {
    PLAYING_TEAMS = PLAYING_TEAMS - 1;
    i = 0;
    for( ; !(i >= 6); i = i + 1)
      if(CURRENT_CURSOR[(signed long int)i].team == team)
      {
        if(!(CURRENT_CURSOR[(signed long int)i].active == 0))
        {
          CURRENT_CURSOR[(signed long int)i].active = 0;
          CURRENT_CURSOR[(signed long int)i].loose_time = TIME_ELAPSED;
          CURRENT_CURSOR[(signed long int)i].score_order = PLAYING_TEAMS + 1;
        }

      }

    i = 0;
    for( ; !(i >= 6); i = i + 1)
      if(!(team >= CURRENT_CURSOR[(signed long int)i].team))
        CURRENT_CURSOR[(signed long int)i].team = CURRENT_CURSOR[(signed long int)i].team - 1;

    i = 0;
    for( ; !(i >= CURRENT_ARMY_SIZE); i = i + 1)
      if(!(team >= (signed int)(CURRENT_ARMY + (signed long int)i)->team))
        (CURRENT_ARMY + (signed long int)i)->team = (CURRENT_ARMY + (signed long int)i)->team - 1;

    j = team;
    for( ; !(j >= PLAYING_TEAMS); j = j + 1)
    {
      ACTIVE_FIGHTERS[(signed long int)j] = ACTIVE_FIGHTERS[(signed long int)(j + 1)];
      COLOR_FIRST_ENTRY[(signed long int)j] = COLOR_FIRST_ENTRY[(signed long int)(j + 1)];
      i = 0;
      for( ; !(i >= CURRENT_MESH_SIZE); i = i + 1)
        (CURRENT_MESH + (signed long int)i)->info[(signed long int)j] = (CURRENT_MESH + (signed long int)i)->info[(signed long int)(j + 1)];
    }
    return 0;
  }

  else
    return 1;
}

// ellipse
// file /usr/include/allegro/inline/draw.inl line 137
static inline void ellipse(struct BITMAP *bmp, signed int x, signed int y, signed int rx, signed int ry, signed int color)
{
  bmp->vtable->ellipse(bmp, x, y, rx, ry, color);
}

// ellipsefill
// file /usr/include/allegro/inline/draw.inl line 146
static inline void ellipsefill(struct BITMAP *bmp, signed int x, signed int y, signed int rx, signed int ry, signed int color)
{
  bmp->vtable->ellipsefill(bmp, x, y, rx, ry, color);
}

// encode
// file netkey.c line 160
static void encode(unsigned char *dst, struct anonymous_5 *src)
{
  signed int i = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    char return_value_int_to_ascii_hexa_1;
    return_value_int_to_ascii_hexa_1=int_to_ascii_hexa(src->key_states[(signed long int)i]);
    dst[(signed long int)i] = (unsigned char)return_value_int_to_ascii_hexa_1;
  }
  dst[(signed long int)6] = (unsigned char)src->cmd;
  char return_value_int_to_ascii_hexa_2;
  return_value_int_to_ascii_hexa_2=int_to_ascii_hexa(src->arg);
  dst[(signed long int)(6 + 1)] = (unsigned char)return_value_int_to_ascii_hexa_2;
  dst[(signed long int)(6 + 2 + 0)] = (unsigned char)(src->checksum & (unsigned int)0xFF);
  dst[(signed long int)(6 + 2 + 1)] = (unsigned char)(src->checksum >> 8 & (unsigned int)0xFF);
  dst[(signed long int)(6 + 2 + 2)] = (unsigned char)(src->checksum >> 16 & (unsigned int)0xFF);
  dst[(signed long int)(6 + 2 + 3)] = (unsigned char)(src->checksum >> 24 & (unsigned int)0xFF);
}

// erase_fighter
// file fighter.c line 129
static void erase_fighter(struct anonymous_21 *f)
{
  signed int return_value_getpixel_1;
  return_value_getpixel_1=getpixel_link1(CURRENT_AREA_BACK, (signed int)f->x, (signed int)f->y);
  putpixel_link3(CURRENT_AREA_DISP, (signed int)f->x, (signed int)f->y, return_value_getpixel_1);
}

// error_bad_config_range
// file error.c line 206
signed int error_bad_config_range(void)
{
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(178);
  signed int return_value_standard_error_2;
  return_value_standard_error_2=standard_error(return_value_lw_lang_string_1);
  return return_value_standard_error_2;
}

// error_bad_password
// file error.c line 199
signed int error_bad_password(void)
{
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(177);
  signed int return_value_standard_error_2;
  return_value_standard_error_2=standard_error(return_value_lw_lang_string_1);
  return return_value_standard_error_2;
}

// error_cant_receive_map
// file error.c line 184
signed int error_cant_receive_map(void)
{
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(175);
  signed int return_value_standard_error_2;
  return_value_standard_error_2=standard_error(return_value_lw_lang_string_1);
  return return_value_standard_error_2;
}

// error_cant_send_map
// file error.c line 177
signed int error_cant_send_map(void)
{
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(174);
  signed int return_value_standard_error_2;
  return_value_standard_error_2=standard_error(return_value_lw_lang_string_1);
  return return_value_standard_error_2;
}

// error_graphics_init_failed
// file error.c line 129
signed int error_graphics_init_failed(void)
{
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(168);
  signed int return_value_standard_error_2;
  return_value_standard_error_2=standard_error(return_value_lw_lang_string_1);
  return return_value_standard_error_2;
}

// error_network_problem
// file error.h line 73
signed int error_network_problem(void)
{
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(173);
  signed int return_value_standard_error_2;
  return_value_standard_error_2=standard_error(return_value_lw_lang_string_1);
  return return_value_standard_error_2;
}

// error_no_network_support
// file error.c line 137
signed int error_no_network_support(void)
{
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(169);
  signed int return_value_standard_error_2;
  return_value_standard_error_2=standard_error(return_value_lw_lang_string_1);
  return return_value_standard_error_2;
}

// error_not_a_liquidwar_server
// file error.c line 153
signed int error_not_a_liquidwar_server(void)
{
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(171);
  signed int return_value_standard_error_2;
  return_value_standard_error_2=standard_error(return_value_lw_lang_string_1);
  return return_value_standard_error_2;
}

// error_not_enough_big_data
// file error.c line 121
signed int error_not_enough_big_data(void)
{
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(167);
  signed int return_value_standard_error_2;
  return_value_standard_error_2=standard_error(return_value_lw_lang_string_1);
  return return_value_standard_error_2;
}

// error_not_enough_teams
// file error.c line 113
signed int error_not_enough_teams(void)
{
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(166);
  signed int return_value_standard_error_2;
  return_value_standard_error_2=standard_error(return_value_lw_lang_string_1);
  return return_value_standard_error_2;
}

// error_server_full
// file error.c line 192
signed int error_server_full(void)
{
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(176);
  signed int return_value_standard_error_2;
  return_value_standard_error_2=standard_error(return_value_lw_lang_string_1);
  return return_value_standard_error_2;
}

// error_unable_to_connect
// file error.c line 145
signed int error_unable_to_connect(void)
{
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(170);
  signed int return_value_standard_error_2;
  return_value_standard_error_2=standard_error(return_value_lw_lang_string_1);
  return return_value_standard_error_2;
}

// error_wrong_version
// file error.c line 161
signed int error_wrong_version(void)
{
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(172);
  signed int return_value_standard_error_2;
  return_value_standard_error_2=standard_error(return_value_lw_lang_string_1);
  return return_value_standard_error_2;
}

// exist_argument
// file parser.h line 69
signed int exist_argument(char *str)
{
  signed int i;
  signed int found = 0;
  i = 0;
  signed int tmp_statement_expression_1;
  for( ; found == 0 && !(i >= 256); i = i + 1)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(str, ARGUMENT_NAME[(signed long int)i]);
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    found = (signed int)!(tmp_statement_expression_1 != 0);
  }
  return found;
}

// exist_argument_value
// file parser.c line 140
signed int exist_argument_value(char *str)
{
  signed int i;
  signed int found = 0;
  i = 0;
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_5;
  signed int tmp_statement_expression_3;
  for( ; found == 0 && !(i >= 256); i = i + 1)
  {
    unsigned long int exist_argument_value__1__1__1____s1_len;
    unsigned long int exist_argument_value__1__1__1____s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(str, ARGUMENT_NAME[(signed long int)i]);
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    if(tmp_statement_expression_1 == 0)
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_4;
      return_value___builtin_strcmp_4=__builtin_strcmp("", ARGUMENT_VALUE[(signed long int)i]);
      tmp_statement_expression_3 = return_value___builtin_strcmp_4;
      tmp_if_expr_5 = tmp_statement_expression_3 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_5 = (_Bool)0;
    found = (signed int)tmp_if_expr_5;
  }
  return found;
}

// exist_color
// file texture.c line 97
static signed int exist_color(struct RGB *pal, struct RGB rgb)
{
  signed int return_value_find_color_1;
  return_value_find_color_1=find_color(pal, rgb);
  return (signed int)(return_value_find_color_1 >= 0);
}

// exit_all
// file exit.c line 96
static void exit_all(void)
{
  if(!(LW_INIT_ALLEGRO_OK == 0))
  {
    rest((unsigned int)10);
    last_flip();
    set_gfx_mode(-1, 0, 0, 0, 0);
    rest((unsigned int)10);
    log_println();
    log_println_str("Leaving Allegro (http://www.talula.demon.co.uk/allegro)");
    save_config_options();
    stop_water();
    stop_ticker();
    remove_sound();
    remove_mouse();
    clear_keybuf();
    remove_keyboard();
    remove_timer();
    allegro_exit();
    lw_sock_exit();
  }

}

// extract_significant_part
// file map.c line 127
static struct BITMAP * extract_significant_part(struct BITMAP *src)
{
  signed int min_x = src->w;
  signed int min_y = src->h;
  signed int max_x = -1;
  signed int max_y = -1;
  signed int dst_x;
  signed int dst_y;
  signed int dst_w;
  signed int dst_h;
  signed int x;
  signed int y;
  struct BITMAP *result;
  y = 0;
  signed int return_value_getpixel_1;
  for( ; !(y >= src->h); y = y + 1)
  {
    x = 0;
    for( ; !(x >= src->w); x = x + 1)
    {
      return_value_getpixel_1=getpixel_link3(src, x, y);
      if(return_value_getpixel_1 == 0)
      {
        if(!(x >= min_x))
          min_x = x;

        if(!(y >= min_y))
          min_y = y;

        if(!(max_x >= x))
          max_x = x;

        if(!(max_y >= y))
          max_y = y;

      }

    }
  }
  dst_x = min_x;
  dst_y = min_y;
  dst_w = (max_x - min_x) + 1;
  dst_h = (max_y - min_y) + 1;
  if(!(dst_h >= 4) || !(dst_w >= 4))
    result = (struct BITMAP *)(void *)0;

  else
  {
    result=my_create_bitmap(dst_w, dst_h);
    if(!(result == ((struct BITMAP *)NULL)))
      blit(src, result, dst_x, dst_y, 0, 0, dst_w, dst_h);

  }
  return result;
}

// fcos
// file /usr/include/allegro/alcompat.h line 50
static inline signed int fcos(signed int x)
{
  signed int return_value_fixcos_1;
  return_value_fixcos_1=fixcos(x);
  return return_value_fixcos_1;
}

// fill_next_screen
// file game.c line 508
static void fill_next_screen(void)
{
  if(GRAD_TO_DISP == 0)
  {
    disp_all_cursors();
    display_area();
    undisp_all_cursors();
  }

  if(GRAD_TO_DISP >= 1 && !(GRAD_TO_DISP >= 7))
    display_gradient(GRAD_TO_DISP - 1);

  if(GRAD_TO_DISP >= 7 && !(GRAD_TO_DISP >= 9))
    display_mesh(GRAD_TO_DISP - 7);

}

// fill_with_fg_and_bg
// file map.c line 312
static void fill_with_fg_and_bg(struct BITMAP *bmp, signed int fg, signed int bg)
{
  signed int x;
  signed int y = 0;
  for( ; !(y >= bmp->h); y = y + 1)
  {
    x = 0;
    for( ; !(x >= bmp->w); x = x + 1)
    {
      signed int return_value_getpixel_1;
      return_value_getpixel_1=getpixel_link3(bmp, x, y);
      putpixel_link6(bmp, x, y, return_value_getpixel_1 == 1 ? bg : fg);
    }
  }
}

// find_center
// file dialog.c line 107
signed int find_center(signed int pos, signed int num, signed int space, signed int size)
{
  signed int center = (size - num * space) / 2;
  center = center + pos * space + space / 2;
  return center;
}

// find_color
// file texture.c line 84
static signed int find_color(struct RGB *pal, struct RGB rgb)
{
  signed int i;
  signed int found = -1;
  i = 0;
  for( ; !(found >= 0) && !(i >= 256); i = i + 1)
    if((pal + (signed long int)i)->r == rgb.r)
    {
      if((pal + (signed long int)i)->g == rgb.g)
      {
        if((pal + (signed long int)i)->b == rgb.b)
          found = i;

      }

    }

  return found;
}

// fixcos
// file /usr/include/allegro/inline/fmaths.inl line 193
static inline signed int fixcos(signed int x)
{
  return _cos_tbl[(signed long int)(x + 0x4000 >> 15 & 0x1FF)];
}

// fixdiv
// file /usr/include/allegro/inline/fmaths.inl line 147
static inline signed int fixdiv(signed int x, signed int y)
{
  double return_value_fixtof_1;
  double return_value_fixtof_2;
  signed int return_value_ftofix_3;
  if(y == 0)
  {
    *allegro_errno = 34;
    return x < 0 ? -0x7FFFFFFF : 0x7FFFFFFF;
  }

  else
  {
    return_value_fixtof_1=fixtof(x);
    return_value_fixtof_2=fixtof(y);
    return_value_ftofix_3=ftofix(return_value_fixtof_1 / return_value_fixtof_2);
    return return_value_ftofix_3;
  }
}

// fixfloor
// file /usr/include/allegro/inline/fmaths.inl line 158
static inline signed int fixfloor(signed int x)
{
  if(x >= 0)
    return x >> 16;

  else
    return ~(~x >> 16);
}

// fixsin
// file /usr/include/allegro/inline/fmaths.inl line 199
static inline signed int fixsin(signed int x)
{
  return _cos_tbl[(signed long int)((x - 0x400000) + 0x4000 >> 15 & 0x1FF)];
}

// fixtof
// file /usr/include/allegro/inline/fmaths.inl line 48
static inline double fixtof(signed int x)
{
  return (double)x / 65536.0;
}

// fixtoi
// file /usr/include/allegro/inline/fmaths.inl line 187
static inline signed int fixtoi(signed int x)
{
  signed int return_value_fixfloor_1;
  return_value_fixfloor_1=fixfloor(x);
  return return_value_fixfloor_1 + ((x & 0x8000) >> 15);
}

// free_game_memory
// file game.c line 419
void free_game_memory(void)
{
  free_info_bar();
  reset_big_data();
  if(!(CURRENT_AREA_DISP == ((struct BITMAP *)NULL)))
  {
    destroy_bitmap(CURRENT_AREA_DISP);
    CURRENT_AREA_DISP = ((struct BITMAP *)NULL);
  }

  if(!(CURRENT_AREA_BACK == ((struct BITMAP *)NULL)))
  {
    destroy_bitmap(CURRENT_AREA_BACK);
    CURRENT_AREA_BACK = ((struct BITMAP *)NULL);
  }

}

// free_info_bar
// file info.h line 59
void free_info_bar(void)
{
  if(!(INFO_BAR == ((struct BITMAP *)NULL)))
  {
    destroy_bitmap(INFO_BAR);
    INFO_BAR = (struct BITMAP *)(void *)0;
  }

  if(!(INFO_BAR_BACK == ((struct BITMAP *)NULL)))
  {
    destroy_bitmap(INFO_BAR_BACK);
    INFO_BAR_BACK = (struct BITMAP *)(void *)0;
  }

}

// free_last_big_data_bottom
// file bigdata.c line 206
void free_last_big_data_bottom(void)
{
  if(BIG_DATA_BOTTOM >= 1)
    BIG_DATA_BOTTOM = BIG_DATA_BOTTOM - 1;

}

// free_last_big_data_top
// file bigdata.c line 214
void free_last_big_data_top(void)
{
  if(!(BIG_DATA_TOP >= 64))
    BIG_DATA_TOP = BIG_DATA_TOP + 1;

}

// fsin
// file /usr/include/allegro/alcompat.h line 51
static inline signed int fsin(signed int x)
{
  signed int return_value_fixsin_1;
  return_value_fixsin_1=fixsin(x);
  return return_value_fixsin_1;
}

// fsqrt
// file /usr/include/allegro/alcompat.h line 57
static inline signed int fsqrt(signed int x)
{
  signed int return_value_fixsqrt_1;
  return_value_fixsqrt_1=fixsqrt(x);
  return return_value_fixsqrt_1;
}

// fsqrt_link1
// file /usr/include/allegro/alcompat.h line 57
static inline signed int fsqrt_link1(signed int x_link1)
{
  signed int return_value_fixsqrt_1_link1;
  return_value_fixsqrt_1_link1=fixsqrt(x_link1);
  return return_value_fixsqrt_1_link1;
}

// fsqrt_link2
// file /usr/include/allegro/alcompat.h line 57
static inline signed int fsqrt_link2(signed int x_link2)
{
  signed int return_value_fixsqrt_1_link2;
  return_value_fixsqrt_1_link2=fixsqrt(x_link2);
  return return_value_fixsqrt_1_link2;
}

// ftofix
// file /usr/include/allegro/inline/fmaths.inl line 32
static inline signed int ftofix(double x)
{
  if(x > 32767.0)
  {
    *allegro_errno = 34;
    return 0x7FFFFFFF;
  }

  else
    if(x < -32767.000000)
    {
      *allegro_errno = 34;
      return -0x7FFFFFFF;
    }

    else
      return (signed int)(x * 65536.0 + (x < (double)0 ? -0.5 : 0.5));
}

// game
// file game.c line 721
signed int game(void)
{
  signed int retour = 0;
  signed int last_display_time;
  last_display_time=get_ticker();
  signed int last_logic_time;
  last_logic_time=get_ticker();
  signed int lr;
  start_play_time();
  watchdog_reset();
  reset_code();
  lw_mouse_reset_control();
  reset_computer_path();
  reset_all_profile();
  play_go();
  signed int return_value_get_ticker_3;
  _Bool tmp_if_expr_2;
  signed int return_value_get_ticker_1;
  while(WATCHDOG_SCANCODE[59l] == 0)
  {
    if(!(PLAYING_TEAMS >= 2))
      break;

    if(!(TIME_LEFT >= 1))
      break;

    if(!(LW_NETWORK_ERROR_DETECTED == 0))
      break;

    start_profile(4);
    lr = 0;
    do
    {
      logic();
      do
      {
        return_value_get_ticker_3=get_ticker();
        if(return_value_get_ticker_3 >= LOGIC_DELAY_MIN[(signed long int)CONFIG_ROUNDS_PER_SEC_LIMIT] + last_logic_time)
          break;

        usleep((unsigned int)1000);
      }
      while((_Bool)1);
      last_logic_time=get_ticker();
      lr = lr + 1;
      if(!(CONFIG_FRAMES_PER_SEC_LIMIT == 0))
      {
        return_value_get_ticker_1=get_ticker();
        tmp_if_expr_2 = return_value_get_ticker_1 < last_display_time + DISPLAY_DELAY_MIN[(signed long int)CONFIG_FRAMES_PER_SEC_LIMIT] ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
    }
    while(tmp_if_expr_2);
    update_logic_rate(lr);
    last_display_time=get_ticker();
    display();
    my_exit_poll();
    stop_profile(4);
  }
  last_flip();
  clear_keybuf();
  return retour;
}

// generate_bitmap
// file random.c line 115
static struct BITMAP * generate_bitmap()
{
  struct BITMAP *bmp;
  struct RGB pal[256l];
  char filename[1000l];
  char command[1000l];
  signed int size;
  signed int ok = 0;
  signed long int return_value_random_1;
  return_value_random_1=random();
  size = (signed int)(return_value_random_1 % (signed long int)6);
  memset((void *)filename, 0, sizeof(char [1000l]) /*1000ul*/ );
  char *return_value_tmpnam_2;
  return_value_tmpnam_2=tmpnam((char *)(void *)0);
  snprintf(filename, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%s.bmp", return_value_tmpnam_2);
  filename[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  memset((void *)command, 0, sizeof(char [1000l]) /*1000ul*/ );
  snprintf(command, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%s --out %s --size %d%s", (const void *)STARTUP_GEN_PATH, (const void *)filename, size, (const void *)" > /dev/null 2>&1");
  command[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  log_print_str("Generating random map with command: \"");
  log_print_str(command);
  log_print_str("\"");
  ok=lw_exec2_run(STARTUP_GEN_PATH, command);
  display_success(ok);
  if(!(ok == 0))
    bmp=load_bitmap(filename, pal);

  else
    bmp = (struct BITMAP *)(void *)0;
  delete_file(filename);
  return bmp;
}

// generate_bw_palette
// file random.c line 101
static void generate_bw_palette(struct RGB *pal)
{
  signed int i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    (pal + (signed long int)i)->r = (unsigned char)i;
    (pal + (signed long int)i)->g = (unsigned char)i;
    (pal + (signed long int)i)->b = (unsigned char)i;
  }
}

// get_allow_network_bots_str
// file advanced.c line 105
static char * get_allow_network_bots_str(void)
{
  char *return_value_lw_lang_string_1;
  char *return_value_lw_lang_string_2;
  if(!(CONFIG_ALLOW_NETWORK_BOTS == 0))
  {
    return_value_lw_lang_string_1=lw_lang_string(75);
    return return_value_lw_lang_string_1;
  }

  else
  {
    return_value_lw_lang_string_2=lw_lang_string(76);
    return return_value_lw_lang_string_2;
  }
}

// get_argc
// file netmess.c line 321
static signed int get_argc(char *message)
{
  signed int result = 0;
  char *word = (char *)(void *)0;
  signed int null_arg = 0;
  signed int return_value_read_separator_2;
  return_value_read_separator_2=read_separator(&message);
  signed int return_value_read_separator_1;
  if(return_value_read_separator_2 == 0)
  {
    if((signed int)*message == 0)
      null_arg = 1;

    word=read_word(&message);
    if(!(word == ((char *)NULL)))
    {
      free((void *)word);
      result = 1;
      do
      {
        return_value_read_separator_1=read_separator(&message);
        if(!(return_value_read_separator_1 == 1))
          break;

        word=read_word(&message);
        if(!(word == ((char *)NULL)))
        {
          free((void *)word);
          result = result + 1;
        }

      }
      while((_Bool)1);
    }

  }

  if(result == 1 && !(null_arg == 0))
    result = 0;

  return result;
}

// get_argument_int
// file parser.c line 169
signed int get_argument_int(char *str)
{
  char *return_value_get_argument_str_1;
  return_value_get_argument_str_1=get_argument_str(str);
  signed int return_value_atoi_2;
  return_value_atoi_2=atoi_link3(return_value_get_argument_str_1);
  return return_value_atoi_2;
}

// get_argument_str
// file parser.c line 153
char * get_argument_str(char *str)
{
  signed int i;
  signed int place = 0;
  signed int found = 0;
  i = 0;
  signed int tmp_statement_expression_1;
  for( ; found == 0 && !(i >= 256); i = i + 1)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(str, ARGUMENT_NAME[(signed long int)i]);
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    found = (signed int)!(tmp_statement_expression_1 != 0);
    if(!(found == 0))
      place = i;

  }
  if(!(found == 0))
    return ARGUMENT_VALUE[(signed long int)place];

  else
    return "";
}

// get_argv
// file netmess.c line 364
static char ** get_argv(char *message, signed int argc)
{
  char **result = (char **)(void *)0;
  char *word;
  signed int i = 0;
  signed int return_value_read_separator_3;
  signed int return_value_read_separator_2;
  if(argc >= 1)
  {
    return_value_read_separator_3=read_separator(&message);
    if(return_value_read_separator_3 == 0)
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc((unsigned long int)argc * sizeof(char *) /*8ul*/ );
      result = (char **)return_value_malloc_1;
      if(!(result == ((char **)NULL)))
      {
        word=read_word(&message);
        if(!(word == ((char *)NULL)))
        {
          result[(signed long int)i] = word;
          i = 1;
          while(!(i >= argc))
          {
            return_value_read_separator_2=read_separator(&message);
            if(!(return_value_read_separator_2 == 1))
              break;

            word=read_word(&message);
            if(!(word == ((char *)NULL)))
            {
              result[(signed long int)i] = word;
              i = i + 1;
            }

          }
        }

      }

      if(!(i == argc))
      {
        free((void *)result);
        result = (char **)(void *)0;
      }

    }

  }

  return result;
}

// get_asm_algorithm_str
// file advanced.c line 73
static char * get_asm_algorithm_str(void)
{
  char *return_value_lw_lang_string_1;
  char *return_value_lw_lang_string_2;
  if(!(CONFIG_ASM_ALGORITHM == 0))
  {
    return_value_lw_lang_string_1=lw_lang_string(72);
    return return_value_lw_lang_string_1;
  }

  else
  {
    return_value_lw_lang_string_2=lw_lang_string(73);
    return return_value_lw_lang_string_2;
  }
}

// get_battle_room
// file army.c line 84
static signed int get_battle_room(void)
{
  signed int i;
  signed int n = 0;
  i = 0;
  for( ; !(i >= CURRENT_MESH_SIZE); i = i + 1)
    n = n + (signed int)(CURRENT_MESH + (signed long int)i)->side.size * (signed int)(CURRENT_MESH + (signed long int)i)->side.size;
  return n;
}

// get_close_dir
// file fighter.c line 271
static signed int get_close_dir(struct anonymous_0 *mesh, struct anonymous_21 *f, signed int team, signed int sens, signed int start)
{
  signed int cursor_x;
  signed int cursor_y;
  signed int fighter_x;
  signed int fighter_y;
  signed int code_dir = 0;
  signed int dir;
  fighter_x = (signed int)f->x;
  fighter_y = (signed int)f->y;
  cursor_x = (signed int)mesh->info[(signed long int)team].update.cursor.x;
  cursor_y = (signed int)mesh->info[(signed long int)team].update.cursor.y;
  if(!(cursor_y >= fighter_y))
    code_dir = code_dir + 1;

  if(!(fighter_x >= cursor_x))
    code_dir = code_dir + 2;

  if(!(fighter_y >= cursor_y))
    code_dir = code_dir + 4;

  if(!(cursor_x >= fighter_x))
    code_dir = code_dir + 8;

  if(!(code_dir == 0))
    dir = LOCAL_DIR[(signed long int)((code_dir - 1) * 2 + (sens != 0 ? 1 : 0))];

  else
    dir = start;
  return dir;
}

// get_code
// file netmess.c line 197
static signed int get_code(char **message)
{
  char *command;
  signed int result = 0;
  signed int return_value_read_separator_51;
  return_value_read_separator_51=read_separator(message);
  signed int tmp_statement_expression_49;
  signed int tmp_statement_expression_47;
  signed int tmp_statement_expression_45;
  signed int tmp_statement_expression_43;
  signed int tmp_statement_expression_41;
  signed int tmp_statement_expression_39;
  signed int tmp_statement_expression_37;
  signed int tmp_statement_expression_35;
  signed int tmp_statement_expression_33;
  signed int tmp_statement_expression_31;
  signed int tmp_statement_expression_29;
  signed int tmp_statement_expression_27;
  signed int tmp_statement_expression_25;
  signed int tmp_statement_expression_23;
  signed int tmp_statement_expression_21;
  signed int tmp_statement_expression_19;
  signed int tmp_statement_expression_17;
  signed int tmp_statement_expression_15;
  signed int tmp_statement_expression_13;
  signed int tmp_statement_expression_11;
  signed int tmp_statement_expression_9;
  signed int tmp_statement_expression_7;
  signed int tmp_statement_expression_5;
  signed int tmp_statement_expression_3;
  signed int tmp_statement_expression_1;
  if(return_value_read_separator_51 == 0)
  {
    command=read_word(message);
    if(!(command == ((char *)NULL)))
    {
      unsigned long int get_code__1__1__1__1____s1_len;
      unsigned long int get_code__1__1__1__1____s2_len;
      signed int return_value___builtin_strcmp_50;
      return_value___builtin_strcmp_50=__builtin_strcmp(command, "OK");
      tmp_statement_expression_49 = return_value___builtin_strcmp_50;
      if(tmp_statement_expression_49 == 0)
        result = 1;

      else
      {
        unsigned long int get_code__1__1__1__3____s1_len;
        unsigned long int get_code__1__1__1__3____s2_len;
        signed int return_value___builtin_strcmp_48;
        return_value___builtin_strcmp_48=__builtin_strcmp(command, "ERR");
        tmp_statement_expression_47 = return_value___builtin_strcmp_48;
        if(tmp_statement_expression_47 == 0)
          result = 2;

        else
        {
          unsigned long int get_code__1__1__1__5____s1_len;
          unsigned long int get_code__1__1__1__5____s2_len;
          signed int return_value___builtin_strcmp_46;
          return_value___builtin_strcmp_46=__builtin_strcmp(command, "PING");
          tmp_statement_expression_45 = return_value___builtin_strcmp_46;
          if(tmp_statement_expression_45 == 0)
            result = 3;

          else
          {
            unsigned long int get_code__1__1__1__7____s1_len;
            unsigned long int get_code__1__1__1__7____s2_len;
            signed int return_value___builtin_strcmp_44;
            return_value___builtin_strcmp_44=__builtin_strcmp(command, "ECHO");
            tmp_statement_expression_43 = return_value___builtin_strcmp_44;
            if(tmp_statement_expression_43 == 0)
              result = 4;

            else
            {
              unsigned long int get_code__1__1__1__9____s1_len;
              unsigned long int get_code__1__1__1__9____s2_len;
              signed int return_value___builtin_strcmp_42;
              return_value___builtin_strcmp_42=__builtin_strcmp(command, "PROGRAM");
              tmp_statement_expression_41 = return_value___builtin_strcmp_42;
              if(tmp_statement_expression_41 == 0)
                result = 5;

              else
              {
                unsigned long int get_code__1__1__1__11____s1_len;
                unsigned long int get_code__1__1__1__11____s2_len;
                signed int return_value___builtin_strcmp_40;
                return_value___builtin_strcmp_40=__builtin_strcmp(command, "VERSION");
                tmp_statement_expression_39 = return_value___builtin_strcmp_40;
                if(tmp_statement_expression_39 == 0)
                  result = 6;

                else
                {
                  unsigned long int get_code__1__1__1__13____s1_len;
                  unsigned long int get_code__1__1__1__13____s2_len;
                  signed int return_value___builtin_strcmp_38;
                  return_value___builtin_strcmp_38=__builtin_strcmp(command, "PASSWORD");
                  tmp_statement_expression_37 = return_value___builtin_strcmp_38;
                  if(tmp_statement_expression_37 == 0)
                    result = 7;

                  else
                  {
                    unsigned long int get_code__1__1__1__15____s1_len;
                    unsigned long int get_code__1__1__1__15____s2_len;
                    signed int return_value___builtin_strcmp_36;
                    return_value___builtin_strcmp_36=__builtin_strcmp(command, "FREE");
                    tmp_statement_expression_35 = return_value___builtin_strcmp_36;
                    if(tmp_statement_expression_35 == 0)
                      result = 8;

                    else
                    {
                      unsigned long int get_code__1__1__1__17____s1_len;
                      unsigned long int get_code__1__1__1__17____s2_len;
                      signed int return_value___builtin_strcmp_34;
                      return_value___builtin_strcmp_34=__builtin_strcmp(command, "TEAM");
                      tmp_statement_expression_33 = return_value___builtin_strcmp_34;
                      if(tmp_statement_expression_33 == 0)
                        result = 9;

                      else
                      {
                        unsigned long int get_code__1__1__1__19____s1_len;
                        unsigned long int get_code__1__1__1__19____s2_len;
                        signed int return_value___builtin_strcmp_32;
                        return_value___builtin_strcmp_32=__builtin_strcmp(command, "READY");
                        tmp_statement_expression_31 = return_value___builtin_strcmp_32;
                        if(tmp_statement_expression_31 == 0)
                          result = 10;

                        else
                        {
                          unsigned long int get_code__1__1__1__21____s1_len;
                          unsigned long int get_code__1__1__1__21____s2_len;
                          signed int return_value___builtin_strcmp_30;
                          return_value___builtin_strcmp_30=__builtin_strcmp(command, "START");
                          tmp_statement_expression_29 = return_value___builtin_strcmp_30;
                          if(tmp_statement_expression_29 == 0)
                            result = 11;

                          else
                          {
                            unsigned long int get_code__1__1__1__23____s1_len;
                            unsigned long int get_code__1__1__1__23____s2_len;
                            signed int return_value___builtin_strcmp_28;
                            return_value___builtin_strcmp_28=__builtin_strcmp(command, "WAITING");
                            tmp_statement_expression_27 = return_value___builtin_strcmp_28;
                            if(tmp_statement_expression_27 == 0)
                              result = 12;

                            else
                            {
                              unsigned long int get_code__1__1__1__25____s1_len;
                              unsigned long int get_code__1__1__1__25____s2_len;
                              signed int return_value___builtin_strcmp_26;
                              return_value___builtin_strcmp_26=__builtin_strcmp(command, "NEXT");
                              tmp_statement_expression_25 = return_value___builtin_strcmp_26;
                              if(tmp_statement_expression_25 == 0)
                                result = 13;

                              else
                              {
                                unsigned long int get_code__1__1__1__27____s1_len;
                                unsigned long int get_code__1__1__1__27____s2_len;
                                signed int return_value___builtin_strcmp_24;
                                return_value___builtin_strcmp_24=__builtin_strcmp(command, "TEAMSTARTINFO");
                                tmp_statement_expression_23 = return_value___builtin_strcmp_24;
                                if(tmp_statement_expression_23 == 0)
                                  result = 14;

                                else
                                {
                                  unsigned long int get_code__1__1__1__29____s1_len;
                                  unsigned long int get_code__1__1__1__29____s2_len;
                                  signed int return_value___builtin_strcmp_22;
                                  return_value___builtin_strcmp_22=__builtin_strcmp(command, "WHO");
                                  tmp_statement_expression_21 = return_value___builtin_strcmp_22;
                                  if(tmp_statement_expression_21 == 0)
                                    result = 15;

                                  else
                                  {
                                    unsigned long int get_code__1__1__1__31____s1_len;
                                    unsigned long int get_code__1__1__1__31____s2_len;
                                    signed int return_value___builtin_strcmp_20;
                                    return_value___builtin_strcmp_20=__builtin_strcmp(command, "LOCAL");
                                    tmp_statement_expression_19 = return_value___builtin_strcmp_20;
                                    if(tmp_statement_expression_19 == 0)
                                      result = 16;

                                    else
                                    {
                                      unsigned long int get_code__1__1__1__33____s1_len;
                                      unsigned long int get_code__1__1__1__33____s2_len;
                                      signed int return_value___builtin_strcmp_18;
                                      return_value___builtin_strcmp_18=__builtin_strcmp(command, "NETWORK");
                                      tmp_statement_expression_17 = return_value___builtin_strcmp_18;
                                      if(tmp_statement_expression_17 == 0)
                                        result = 17;

                                      else
                                      {
                                        unsigned long int get_code__1__1__1__35____s1_len;
                                        unsigned long int get_code__1__1__1__35____s2_len;
                                        signed int return_value___builtin_strcmp_16;
                                        return_value___builtin_strcmp_16=__builtin_strcmp(command, "NOBODY");
                                        tmp_statement_expression_15 = return_value___builtin_strcmp_16;
                                        if(tmp_statement_expression_15 == 0)
                                          result = 18;

                                        else
                                        {
                                          unsigned long int get_code__1__1__1__37____s1_len;
                                          unsigned long int get_code__1__1__1__37____s2_len;
                                          signed int return_value___builtin_strcmp_14;
                                          return_value___builtin_strcmp_14=__builtin_strcmp(command, "SENDMAP");
                                          tmp_statement_expression_13 = return_value___builtin_strcmp_14;
                                          if(tmp_statement_expression_13 == 0)
                                            result = 19;

                                          else
                                          {
                                            unsigned long int __s1_len;
                                            unsigned long int __s2_len;
                                            signed int return_value___builtin_strcmp_12;
                                            return_value___builtin_strcmp_12=__builtin_strcmp(command, "RECVMAP");
                                            tmp_statement_expression_11 = return_value___builtin_strcmp_12;
                                            if(tmp_statement_expression_11 == 0)
                                              result = 20;

                                            else
                                            {
                                              unsigned long int get_code__1__1__1__41____s1_len;
                                              unsigned long int get_code__1__1__1__41____s2_len;
                                              signed int return_value___builtin_strcmp_10;
                                              return_value___builtin_strcmp_10=__builtin_strcmp(command, "SENDCONFIG");
                                              tmp_statement_expression_9 = return_value___builtin_strcmp_10;
                                              if(tmp_statement_expression_9 == 0)
                                                result = 21;

                                              else
                                              {
                                                unsigned long int get_code__1__1__1__43____s1_len;
                                                unsigned long int get_code__1__1__1__43____s2_len;
                                                signed int return_value___builtin_strcmp_8;
                                                return_value___builtin_strcmp_8=__builtin_strcmp(command, "RECVCONFIG");
                                                tmp_statement_expression_7 = return_value___builtin_strcmp_8;
                                                if(tmp_statement_expression_7 == 0)
                                                  result = 22;

                                                else
                                                {
                                                  unsigned long int get_code__1__1__1__45____s1_len;
                                                  unsigned long int get_code__1__1__1__45____s2_len;
                                                  signed int return_value___builtin_strcmp_6;
                                                  return_value___builtin_strcmp_6=__builtin_strcmp(command, "CHATTALK");
                                                  tmp_statement_expression_5 = return_value___builtin_strcmp_6;
                                                  if(tmp_statement_expression_5 == 0)
                                                    result = 23;

                                                  else
                                                  {
                                                    unsigned long int get_code__1__1__1__47____s1_len;
                                                    unsigned long int get_code__1__1__1__47____s2_len;
                                                    signed int return_value___builtin_strcmp_4;
                                                    return_value___builtin_strcmp_4=__builtin_strcmp(command, "CHATLISTEN");
                                                    tmp_statement_expression_3 = return_value___builtin_strcmp_4;
                                                    if(tmp_statement_expression_3 == 0)
                                                      result = 24;

                                                    else
                                                    {
                                                      unsigned long int get_code__1__1__1__49____s1_len;
                                                      unsigned long int get_code__1__1__1__49____s2_len;
                                                      signed int return_value___builtin_strcmp_2;
                                                      return_value___builtin_strcmp_2=__builtin_strcmp(command, "QUIT");
                                                      tmp_statement_expression_1 = return_value___builtin_strcmp_2;
                                                      if(tmp_statement_expression_1 == 0)
                                                        result = 25;

                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      free((void *)command);
    }

  }

  return result;
}

// get_computer_next_move
// file autoplay.c line 273
char get_computer_next_move(signed int cursor)
{
  struct anonymous_21 *f;
  char key_info;
  signed int x;
  signed int y;
  signed int meme_equipe;
  signed int team;
  if(COMPUTER_PATH_SIZE[(signed long int)cursor] >= 1)
  {
    COMPUTER_PATH_SIZE[(signed long int)cursor] = COMPUTER_PATH_SIZE[(signed long int)cursor] - 1;
    key_info = COMPUTER_PATH_KEYS[(signed long int)cursor][(signed long int)COMPUTER_PATH_SIZE[(signed long int)cursor]];
  }

  else
  {
    key_info = (char)0;
    team = CURRENT_CURSOR[(signed long int)cursor].team;
    f = (CURRENT_AREA + (signed long int)(CURRENT_CURSOR[(signed long int)cursor].y * CURRENT_AREA_W + CURRENT_CURSOR[(signed long int)cursor].x))->fighter;
    if(!(f == ((struct anonymous_21 *)NULL)))
      meme_equipe = (signed int)((signed int)f->team == team);

    else
      meme_equipe = 1;
    COMPUTER_PATH_WAIT[(signed long int)cursor] = COMPUTER_PATH_WAIT[(signed long int)cursor] - 1;
    if(!(meme_equipe == 0) || !(COMPUTER_PATH_WAIT[(signed long int)cursor] >= 0))
    {
      random_free_xy_different_team(&x, &y, team);
      calculate_computer_path(x, y, cursor);
    }

  }
  return key_info;
}

// get_cpu_vs_human_str
// file advanced.c line 83
static char * get_cpu_vs_human_str(void)
{
  char *result = "";
  switch(CONFIG_CPU_VS_HUMAN)
  {
    case 0:
    {
      result=lw_lang_string(68);
      break;
    }
    case 2:
    {
      result=lw_lang_string(70);
      break;
    }
    default:
      result=lw_lang_string(69);
  }
  return result;
}

// get_cursor
// file score.c line 97
static signed int get_cursor(signed int classement)
{
  signed int i;
  signed int j;
  signed int indice_curseur = -1;
  i = 0;
  for( ; !(i >= 6); i = i + 1)
    if(!(CURRENT_CURSOR[(signed long int)i].active == 0))
    {
      if(!(CURRENT_CURSOR[(signed long int)i].loose_time >= 0))
      {
        CURRENT_CURSOR[(signed long int)i].score_order = 1;
        j = 0;
        for( ; !(j >= i); j = j + 1)
          if(!(CURRENT_CURSOR[(signed long int)j].active == 0))
          {
            if(ACTIVE_FIGHTERS[(signed long int)CURRENT_CURSOR[(signed long int)j].team] >= ACTIVE_FIGHTERS[(signed long int)CURRENT_CURSOR[(signed long int)i].team])
              CURRENT_CURSOR[(signed long int)i].score_order = CURRENT_CURSOR[(signed long int)i].score_order + 1;

          }

        j = i + 1;
        for( ; !(j >= 6); j = j + 1)
          if(!(CURRENT_CURSOR[(signed long int)j].active == 0))
          {
            if(!(ACTIVE_FIGHTERS[(signed long int)CURRENT_CURSOR[(signed long int)i].team] >= ACTIVE_FIGHTERS[(signed long int)CURRENT_CURSOR[(signed long int)j].team]))
              CURRENT_CURSOR[(signed long int)i].score_order = CURRENT_CURSOR[(signed long int)i].score_order + 1;

          }

      }

    }

  i = 0;
  _Bool tmp_if_expr_1;
  for( ; !(i >= 6); i = i + 1)
    if(CURRENT_CURSOR[(signed long int)i].score_order == classement)
    {
      if(!(CURRENT_CURSOR[(signed long int)i].active == 0))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = CURRENT_CURSOR[(signed long int)i].loose_time >= 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        indice_curseur = i;

    }

  return indice_curseur;
}

// get_cursor_from_team
// file decal.c line 76
signed int get_cursor_from_team(signed int team)
{
  signed int i;
  signed int cursor = -1;
  i = 0;
  for( ; !(cursor >= 0) && !(i >= 6); i = i + 1)
    if(team == CURRENT_CURSOR[(signed long int)i].team)
      cursor = i;

  return i;
}

// get_fullscreen_str
// file graphics.c line 129
static char * get_fullscreen_str(void)
{
  char *return_value_lw_lang_string_1;
  char *return_value_lw_lang_string_2;
  if(!(CONFIG_FULLSCREEN == 0))
  {
    return_value_lw_lang_string_1=lw_lang_string(43);
    return return_value_lw_lang_string_1;
  }

  else
  {
    return_value_lw_lang_string_2=lw_lang_string(44);
    return return_value_lw_lang_string_2;
  }
}

// get_game_res_str
// file graphics.c line 81
static char * get_game_res_str(void)
{
  static char str[30l];
  memset((void *)str, 0, sizeof(char [30l]) /*30ul*/ );
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(39);
  snprintf(str, sizeof(char [30l]) /*30ul*/  - (unsigned long int)1, "%s:%dx%d", return_value_lw_lang_string_1, GFX_MODE_W[(signed long int)CONFIG_GFX_GAME], GFX_MODE_H[(signed long int)CONFIG_GFX_GAME]);
  str[(signed long int)(sizeof(char [30l]) /*30ul*/  - (unsigned long int)1)] = (char)0;
  return str;
}

// get_key_name
// file team.c line 242
static char * get_key_name(signed int num)
{
  if(!(MENU_KEY_NAMES[(signed long int)num] == ((char *)NULL)))
    return MENU_KEY_NAMES[(signed long int)num];

  else
    return "None";
}

// get_logic_rate
// file profile.h line 76
signed int get_logic_rate(void)
{
  signed int return_value_get_profile_1;
  return_value_get_profile_1=get_profile(4);
  return (return_value_get_profile_1 * DISPLAY_NUMBER) / LOGIC_NUMBER;
}

// get_main_dir
// file fighter.h line 70
signed int get_main_dir(struct anonymous_0 *mesh, signed int team, signed int sens, signed int start)
{
  signed int i;
  signed int dir;
  signed int dist;
  struct anonymous_0 *mesh2;
  dist = 2000000;
  dir = -1;
  i = start;
  if(!(sens == 0))
    do
    {
      mesh2 = (struct anonymous_0 *)mesh->link[(signed long int)i];
      if(!(mesh2 == ((struct anonymous_0 *)NULL)))
      {
        if(!((signed int)mesh2->info[(signed long int)team].state.grad >= dist))
        {
          dir = i;
          dist = (signed int)mesh2->info[(signed long int)team].state.grad;
        }

      }

      i = i < 12 - 1 ? i + 1 : 0;
    }
    while(!(i == start));

  else
    do
    {
      mesh2 = (struct anonymous_0 *)mesh->link[(signed long int)i];
      if(!(mesh2 == ((struct anonymous_0 *)NULL)))
      {
        if(!((signed int)mesh2->info[(signed long int)team].state.grad >= dist))
        {
          dir = i;
          dist = (signed int)mesh2->info[(signed long int)team].state.grad;
        }

      }

      i = i > 0 ? i - 1 : 12 - 1;
    }
    while(!(i == start));
  if(dir >= 0)
    return dir;

  else
    return GLOBAL_CLOCK % 6;
}

// get_menu_res_str
// file graphics.c line 95
static char * get_menu_res_str(void)
{
  static char str[30l];
  memset((void *)str, 0, sizeof(char [30l]) /*30ul*/ );
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(40);
  snprintf(str, sizeof(char [30l]) /*30ul*/  - (unsigned long int)1, "%s:%dx%d", return_value_lw_lang_string_1, GFX_MODE_W[(signed long int)CONFIG_GFX_MENU], GFX_MODE_H[(signed long int)CONFIG_GFX_MENU]);
  str[(signed long int)(sizeof(char [30l]) /*30ul*/  - (unsigned long int)1)] = (char)0;
  return str;
}

// get_mono_texture_color
// file palette.c line 191
static void get_mono_texture_color(struct RGB *rgb, signed int num)
{
  signed int h1;
  signed int s1;
  signed int v1;
  signed int r;
  signed int g;
  signed int b;
  float h2;
  float s2;
  float v2;
  float h[12l] = { (float)0, (float)20, (float)40, (float)70, (float)110, (float)150, (float)180, (float)210, (float)240, (float)270, (float)300, (float)330 };
  float s[10l] = { (float)1, (float)0.7, (float)0.4, (float)1, (float)0.5, (float)1, (float)0.5, (float)1, (float)0.5, (float)1 };
  float v[10l] = { (float)1, (float)1, (float)1, (float)0.8, (float)0.8, (float)0.6, (float)0.6, (float)0.3, (float)0.3, (float)0.1 };
  h1 = num / 10;
  s1 = num % 10;
  v1 = s1;
  if(!(h1 >= 12))
  {
    h2 = h[(signed long int)h1];
    s2 = s[(signed long int)s1];
    v2 = v[(signed long int)v1];
  }

  else
  {
    h2 = (float)0;
    s2 = (float)0;
    v2 = (float)(127 - num);
    v2 = v2 / (float)7.;
  }
  hsv_to_rgb(h2, s2, v2, &r, &g, &b);
  rgb->r = (unsigned char)(r / 4);
  rgb->g = (unsigned char)(g / 4);
  rgb->b = (unsigned char)(b / 4);
}

// get_page_flip_str
// file graphics.c line 119
static char * get_page_flip_str(void)
{
  char *return_value_lw_lang_string_1;
  char *return_value_lw_lang_string_2;
  if(!(CONFIG_PAGE_FLIP == 0))
  {
    return_value_lw_lang_string_1=lw_lang_string(41);
    return return_value_lw_lang_string_1;
  }

  else
  {
    return_value_lw_lang_string_2=lw_lang_string(42);
    return return_value_lw_lang_string_2;
  }
}

// get_profile
// file profile.h line 74
signed int get_profile(signed int indice)
{
  if(PROFILE_DATA[(signed long int)indice].record_number >= 1)
    return PROFILE_DATA[(signed long int)indice].total_time / PROFILE_DATA[(signed long int)indice].record_number;

  else
    return 0;
}

// get_raw_texture
// file texture.c line 360
static void * get_raw_texture(signed int num)
{
  void *texture = (void *)0;
  if(!(128 + RAW_MAPTEX_NUMBER + RAW_TEXTURE_NUMBER + -1 >= num))
    num = (RAW_TEXTURE_NUMBER + RAW_MAPTEX_NUMBER + 128) - 1;

  if(num >= 128 && !(LOADED_TEXTURE == 0) && !(num >= 128 + RAW_TEXTURE_NUMBER))
    texture = RAW_TEXTURE[(signed long int)(num - 128)];

  if(num >= 128 + RAW_TEXTURE_NUMBER && !(LOADED_MAPTEX == 0) && !(num >= 128 + RAW_MAPTEX_NUMBER + RAW_TEXTURE_NUMBER))
    texture = RAW_MAPTEX[(signed long int)(num - (128 + RAW_TEXTURE_NUMBER))];

  return texture;
}

// get_ticker
// file ticker.h line 64
signed int get_ticker(void)
{
  return TICKER_VALUE;
}

// get_wave_mode_str
// file graphics.c line 109
static char * get_wave_mode_str(void)
{
  char *return_value_lw_lang_string_1;
  char *return_value_lw_lang_string_2;
  if(!(CONFIG_WAVE_ON == 0))
  {
    return_value_lw_lang_string_1=lw_lang_string(41);
    return return_value_lw_lang_string_1;
  }

  else
  {
    return_value_lw_lang_string_2=lw_lang_string(42);
    return return_value_lw_lang_string_2;
  }
}

// getpixel
// file /usr/include/allegro/inline/draw.inl line 30
static inline signed int getpixel(struct BITMAP *bmp, signed int x, signed int y)
{
  signed int return_value;
  return_value=bmp->vtable->getpixel(bmp, x, y);
  return return_value;
}

// getpixel_link1
// file /usr/include/allegro/inline/draw.inl line 30
static inline signed int getpixel_link1(struct BITMAP *bmp_link1, signed int x_link1, signed int y_link1)
{
  signed int return_value_link1;
  return_value_link1=bmp_link1->vtable->getpixel(bmp_link1, x_link1, y_link1);
  return return_value_link1;
}

// getpixel_link2
// file /usr/include/allegro/inline/draw.inl line 30
static inline signed int getpixel_link2(struct BITMAP *bmp_link2, signed int x_link2, signed int y_link2)
{
  signed int return_value_link2;
  return_value_link2=bmp_link2->vtable->getpixel(bmp_link2, x_link2, y_link2);
  return return_value_link2;
}

// getpixel_link3
// file /usr/include/allegro/inline/draw.inl line 30
static inline signed int getpixel_link3(struct BITMAP *bmp_link3, signed int x_link3, signed int y_link3)
{
  signed int return_value_link3;
  return_value_link3=bmp_link3->vtable->getpixel(bmp_link3, x_link3, y_link3);
  return return_value_link3;
}

// getpixel_link4
// file /usr/include/allegro/inline/draw.inl line 30
static inline signed int getpixel_link4(struct BITMAP *bmp_link4, signed int x_link4, signed int y_link4)
{
  signed int return_value_link4;
  return_value_link4=bmp_link4->vtable->getpixel(bmp_link4, x_link4, y_link4);
  return return_value_link4;
}

// getpixel_link5
// file /usr/include/allegro/inline/draw.inl line 30
static inline signed int getpixel_link5(struct BITMAP *bmp_link5, signed int x_link5, signed int y_link5)
{
  signed int return_value_link5;
  return_value_link5=bmp_link5->vtable->getpixel(bmp_link5, x_link5, y_link5);
  return return_value_link5;
}

// getpixel_link6
// file /usr/include/allegro/inline/draw.inl line 30
static inline signed int getpixel_link6(struct BITMAP *bmp_link6, signed int x_link6, signed int y_link6)
{
  signed int return_value_link6;
  return_value_link6=bmp_link6->vtable->getpixel(bmp_link6, x_link6, y_link6);
  return return_value_link6;
}

// graphic_options
// file graphics.c line 187
signed int graphic_options(void)
{
  signed int menu_res_changed = 0;
  signed int fullscreen_changed = 0;
  signed int game_res_changed = 0;
  struct DIALOG_PLAYER *dp;
  struct DIALOG d[20l];
  signed int i;
  signed int choix = 4;
  signed int retour = 0;
  signed int *temp;
  memset((void *)d, 0, sizeof(struct DIALOG [20l]) /*1440ul*/ );
  display_back_image();
  signed int return_value_my_update_dialog_12;
  while(retour == 0)
  {
    i = 0;
    static signed int y_pos[7l] = { 0, 1, 3, 4, 5, 6, 8 };
    for( ; !(i >= 7); i = i + 1)
    {
      standard_button(d + (signed long int)i + (signed long int)4, 0, y_pos[(signed long int)i], 2, 10);
      d[(signed long int)(i + 4)].proc = my_textbox_proc;
    }
    i = 0;
    for( ; !(i >= 7); i = i + 1)
    {
      standard_button(d + (signed long int)i + (signed long int)11, 1, y_pos[(signed long int)i], 2, 10);
      d[(signed long int)(i + 11)].proc = my_slider_proc;
    }
    standard_button(d + (signed long int)18, 0, 9, 1, 10);
    char *return_value_lw_lang_string_1;
    return_value_lw_lang_string_1=lw_lang_string(45);
    d[(signed long int)18].dp = (void *)return_value_lw_lang_string_1;
    quick_buttons(d);
    char *return_value_lw_lang_string_2;
    return_value_lw_lang_string_2=lw_lang_string(46);
    d[(signed long int)4].dp = (void *)return_value_lw_lang_string_2;
    char *return_value_lw_lang_string_3;
    return_value_lw_lang_string_3=lw_lang_string(47);
    d[(signed long int)5].dp = (void *)return_value_lw_lang_string_3;
    char *return_value_get_menu_res_str_4;
    return_value_get_menu_res_str_4=get_menu_res_str();
    d[(signed long int)6].dp = (void *)return_value_get_menu_res_str_4;
    char *return_value_get_game_res_str_5;
    return_value_get_game_res_str_5=get_game_res_str();
    d[(signed long int)7].dp = (void *)return_value_get_game_res_str_5;
    char *return_value_lw_lang_string_6;
    return_value_lw_lang_string_6=lw_lang_string(48);
    d[(signed long int)8].dp = (void *)return_value_lw_lang_string_6;
    char *return_value_lw_lang_string_7;
    return_value_lw_lang_string_7=lw_lang_string(49);
    d[(signed long int)9].dp = (void *)return_value_lw_lang_string_7;
    char *return_value_lw_lang_string_8;
    return_value_lw_lang_string_8=lw_lang_string(50);
    d[(signed long int)10].dp = (void *)return_value_lw_lang_string_8;
    d[(signed long int)17].dp = (void *)0;
    d[(signed long int)16].dp = d[(signed long int)17].dp;
    d[(signed long int)15].dp = d[(signed long int)16].dp;
    d[(signed long int)14].dp = d[(signed long int)15].dp;
    d[(signed long int)13].dp = d[(signed long int)14].dp;
    d[(signed long int)12].dp = d[(signed long int)13].dp;
    d[(signed long int)11].dp = d[(signed long int)12].dp;
    d[(signed long int)12].d1 = 18;
    d[(signed long int)14].d1 = 4;
    d[(signed long int)13].d1 = d[(signed long int)14].d1;
    d[(signed long int)15].d1 = 8;
    d[(signed long int)16].d1 = 8;
    d[(signed long int)15].dp3 = (void *)&CONFIG_VIEWPORT_SIZE;
    i = 15;
    for( ; !(i >= 16); i = i + 1)
    {
      d[(signed long int)i].dp = (void *)0;
      d[(signed long int)i].dp2 = (void *)slider_int;
      temp = (signed int *)d[(signed long int)i].dp3;
      d[(signed long int)i].d2 = *temp;
    }
    d[(signed long int)14].dp = (void *)0;
    d[(signed long int)13].dp = d[(signed long int)14].dp;
    d[(signed long int)12].dp = d[(signed long int)13].dp;
    d[(signed long int)12].d2 = CONFIG_BRIGHTNESS;
    d[(signed long int)13].d2 = CONFIG_GFX_MENU;
    d[(signed long int)14].d2 = CONFIG_GFX_GAME;
    d[(signed long int)12].dp2 = (void *)slider_brightness;
    d[(signed long int)13].dp2 = (void *)slider_menu_res;
    d[(signed long int)14].dp2 = (void *)slider_game_res;
    d[(signed long int)13].dp3 = (void *)&menu_res_changed;
    d[(signed long int)14].dp3 = (void *)&game_res_changed;
    d[(signed long int)11].proc = my_button_proc;
    char *return_value_get_fullscreen_str_9;
    return_value_get_fullscreen_str_9=get_fullscreen_str();
    d[(signed long int)11].dp = (void *)return_value_get_fullscreen_str_9;
    d[(signed long int)11].flags = 1;
    d[(signed long int)16].proc = my_button_proc;
    char *return_value_get_page_flip_str_10;
    return_value_get_page_flip_str_10=get_page_flip_str();
    d[(signed long int)16].dp = (void *)return_value_get_page_flip_str_10;
    d[(signed long int)16].flags = 1;
    d[(signed long int)17].proc = my_button_proc;
    char *return_value_get_wave_mode_str_11;
    return_value_get_wave_mode_str_11=get_wave_mode_str();
    d[(signed long int)17].dp = (void *)return_value_get_wave_mode_str_11;
    d[(signed long int)17].flags = 1;
    d[(signed long int)19].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
    game_res_changed = 0;
    if(!(fullscreen_changed == 0) || !(menu_res_changed == 0))
    {
      menu_res_changed = 0;
      fullscreen_changed = 0;
      display_back_image();
      dp=my_init_dialog(d, choix);
      my_fade_in();
    }

    else
      dp=my_init_dialog(d, choix);
    show_mouse(screen);
    while(menu_res_changed == 0)
    {
      if(!(game_res_changed == 0))
        break;

      return_value_my_update_dialog_12=my_update_dialog(dp);
      if(return_value_my_update_dialog_12 == 0)
        break;

    }
    choix=shutdown_dialog(dp);
    if(!(menu_res_changed == 0))
    {
      if(!(d[13l].d2 == CONFIG_GFX_MENU))
      {
        my_fade_out();
        signed int return_value_set_resolution_13;
        return_value_set_resolution_13=set_resolution(d[(signed long int)13].d2, 0, CONFIG_FULLSCREEN, (signed int *)(void *)0);
        if(!(return_value_set_resolution_13 == 0))
          CONFIG_GFX_MENU = 0;

        else
          CONFIG_GFX_MENU = d[(signed long int)13].d2;
      }

      char *return_value_get_menu_res_str_14;
      return_value_get_menu_res_str_14=get_menu_res_str();
      d[(signed long int)13].dp = (void *)return_value_get_menu_res_str_14;
    }

    else
      if(!(game_res_changed == 0))
      {
        CONFIG_GFX_GAME = d[(signed long int)14].d2;
        char *return_value_get_game_res_str_15;
        return_value_get_game_res_str_15=get_game_res_str();
        d[(signed long int)14].dp = (void *)return_value_get_game_res_str_15;
        retour = 0;
      }

      else
      {
        play_click();
        if(!(choix == 3) && !(choix == -1))
        {
          if(choix == 2)
            goto __CPROVER_DUMP_L18;

          if(choix == 0)
            goto __CPROVER_DUMP_L19;

          if(choix == 1)
            goto __CPROVER_DUMP_L22;

          if(choix == 11)
            goto __CPROVER_DUMP_L23;

          if(choix == 16)
            goto __CPROVER_DUMP_L24;

          if(choix == 17)
            goto __CPROVER_DUMP_L25;

          if(choix == 18)
            goto __CPROVER_DUMP_L26;

        }

        else
        {
          retour = 1;
          goto __CPROVER_DUMP_L27;

        __CPROVER_DUMP_L18:
          ;
          retour = -1;
          goto __CPROVER_DUMP_L27;

        __CPROVER_DUMP_L19:
          ;
          signed int return_value_confirm_quit_16;
          return_value_confirm_quit_16=confirm_quit();
          if(!(return_value_confirm_quit_16 == 0))
            retour = -2;

          else
            display_back_image();
          goto __CPROVER_DUMP_L27;

        __CPROVER_DUMP_L22:
          ;
          retour = -3;
          goto __CPROVER_DUMP_L27;

        __CPROVER_DUMP_L23:
          ;
          CONFIG_FULLSCREEN = CONFIG_FULLSCREEN != 0 ? 0 : 1;
          char *return_value_get_fullscreen_str_17;
          return_value_get_fullscreen_str_17=get_fullscreen_str();
          d[(signed long int)11].dp = (void *)return_value_get_fullscreen_str_17;
          scare_mouse();
          my_button_proc(3, d + (signed long int)11, 0);
          unscare_mouse();
          fullscreen_changed = 1;
          my_fade_out();
          set_resolution(d[(signed long int)13].d2, 0, CONFIG_FULLSCREEN, (signed int *)(void *)0);
          goto __CPROVER_DUMP_L27;

        __CPROVER_DUMP_L24:
          ;
          CONFIG_PAGE_FLIP = CONFIG_PAGE_FLIP != 0 ? 0 : 1;
          char *return_value_get_page_flip_str_18;
          return_value_get_page_flip_str_18=get_page_flip_str();
          d[(signed long int)16].dp = (void *)return_value_get_page_flip_str_18;
          scare_mouse();
          my_button_proc(3, d + (signed long int)16, 0);
          unscare_mouse();
          goto __CPROVER_DUMP_L27;

        __CPROVER_DUMP_L25:
          ;
          CONFIG_WAVE_ON = CONFIG_WAVE_ON != 0 ? 0 : 1;
          char *return_value_get_wave_mode_str_19;
          return_value_get_wave_mode_str_19=get_wave_mode_str();
          d[(signed long int)17].dp = (void *)return_value_get_wave_mode_str_19;
          scare_mouse();
          my_button_proc(3, d + (signed long int)17, 0);
          unscare_mouse();
          goto __CPROVER_DUMP_L27;

        __CPROVER_DUMP_L26:
          ;
          retour=wave_options();
          display_back_image();
        }
      }

  __CPROVER_DUMP_L27:
    ;
  }
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// group_mesher
// file mesh.c line 166
static signed int group_mesher(struct anonymous *mesher, struct BITMAP *map, signed int step)
{
  signed int found = 0;
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  signed int size;
  signed int i;
  signed int j;
  signed int k;
  struct anonymous *ne;
  struct anonymous *se;
  struct anonymous *sw;
  struct anonymous *nw;
  struct anonymous *test;
  w = map->w;
  h = map->h;
  size = h * w;
  y = 0;
  for( ; !(y >= h + -step); y = y + step * 2)
  {
    x = 0;
    for( ; !(x >= w + -step); x = x + step * 2)
    {
      i = y * w + x;
      ne = mesher + (signed long int)i + (signed long int)step;
      se = mesher + (signed long int)i + (signed long int)((w + 1) * step);
      sw = mesher + (signed long int)i + (signed long int)(w * step);
      nw = mesher + (signed long int)i;
      if(!(ne->used == 0))
      {
        if((signed int)ne->size == step)
        {
          if(!(se->used == 0))
          {
            if((signed int)se->size == step)
            {
              if(!(sw->used == 0))
              {
                if((signed int)sw->size == step)
                {
                  if(!(nw->used == 0))
                  {
                    if((signed int)nw->size == step)
                    {
                      if(ne->link[11l] == ne->link[0l])
                      {
                        if(ne->link[2l] == ne->link[3l])
                        {
                          if(se->link[2l] == se->link[3l])
                          {
                            if(se->link[5l] == se->link[6l])
                            {
                              if(sw->link[5l] == sw->link[6l])
                              {
                                if(sw->link[8l] == sw->link[9l])
                                {
                                  if(nw->link[8l] == nw->link[9l])
                                  {
                                    if(nw->link[11l] == nw->link[0l])
                                    {
                                      if(!(ne->link[1l] == NULL))
                                      {
                                        if(!(se->link[4l] == NULL))
                                        {
                                          if(!(sw->link[7l] == NULL))
                                          {
                                            if(!(nw->link[10l] == NULL))
                                            {
                                              ne->used = (char)0;
                                              se->used = (char)0;
                                              sw->used = (char)0;
                                              nw->size = (signed short int)(step * 2);
                                              nw->link[(signed long int)0] = ne->link[(signed long int)0];
                                              nw->link[(signed long int)1] = ne->link[(signed long int)1];
                                              nw->link[(signed long int)2] = ne->link[(signed long int)2];
                                              nw->link[(signed long int)3] = se->link[(signed long int)3];
                                              nw->link[(signed long int)4] = se->link[(signed long int)4];
                                              nw->link[(signed long int)5] = se->link[(signed long int)5];
                                              nw->link[(signed long int)6] = sw->link[(signed long int)6];
                                              nw->link[(signed long int)7] = sw->link[(signed long int)7];
                                              nw->link[(signed long int)8] = sw->link[(signed long int)8];
                                              j = 0;
                                              for( ; !(j >= 12); j = j + 1)
                                              {
                                                k = 0;
                                                for( ; !(k >= 12); k = k + 1)
                                                  if(!(nw->link[(signed long int)j] == NULL))
                                                  {
                                                    test = (struct anonymous *)((struct anonymous *)nw->link[(signed long int)j])->link[(signed long int)k];
                                                    if(test == ne || test == se || test == sw)
                                                      ((struct anonymous *)nw->link[(signed long int)j])->link[(signed long int)k] = (void *)nw;

                                                  }

                                              }
                                              found = found + 1;
                                            }

                                          }

                                        }

                                      }

                                    }

                                  }

                                }

                              }

                            }

                          }

                        }

                      }

                    }

                  }

                }

              }

            }

          }

        }

      }

    }
  }
  return found;
}

// hline
// file /usr/include/allegro/inline/draw.inl line 68
static inline void hline(struct BITMAP *bmp, signed int x1, signed int y, signed int x2, signed int color)
{
  _allegro_hline(bmp, x1, y, x2, color);
}

// hline_link1
// file /usr/include/allegro/inline/draw.inl line 68
static inline void hline_link1(struct BITMAP *bmp_link1, signed int x1_link1, signed int y_link1, signed int x2_link1, signed int color_link1)
{
  _allegro_hline_link1(bmp_link1, x1_link1, y_link1, x2_link1, color_link1);
}

// hline_link2
// file /usr/include/allegro/inline/draw.inl line 68
static inline void hline_link2(struct BITMAP *bmp_link2, signed int x1_link2, signed int y_link2, signed int x2_link2, signed int color_link2)
{
  _allegro_hline_link2(bmp_link2, x1_link2, y_link2, x2_link2, color_link2);
}

// init_all
// file init.c line 113
signed int init_all()
{
  signed int result = 0;
  signed int graphics = 1;
  signed int assembly = 1;
  signed int config = 1;
  signed int timer = 1;
  signed int keyboard = 1;
  signed int mouse = 1;
  signed int sound = 1;
  signed int joystick = 1;
  signed int network = 1;
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  srandom((unsigned int)return_value_time_1);
  set_startup();
  log_init();
  lw_lang_init();
  set_uformat(65 << 24 | 83 << 16 | 67 << 8 | 56);
  log_print_str("Starting Allegro (http://www.talula.demon.co.uk/allegro)");
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  signed int return_value__install_allegro_version_check_3;
  return_value__install_allegro_version_check_3=_install_allegro_version_check(0, &(*return_value___errno_location_2), (signed int (*)(void (*)(void)))atexit, 4 << 16 | 4 << 8 | 2);
  graphics = (signed int)!(return_value__install_allegro_version_check_3 != 0);
  display_success(graphics);
  log_println();
  signed int return_value_my_initialise_joystick_9;
  if(!(graphics == 0))
  {
    LW_INIT_ALLEGRO_OK = 1;
    log_print_str("Allegro ID : ");
    log_println_str(allegro_id);
    log_println();
    set_color_depth(8);
    set_color_conversion(0x10 | 0x100 | 0x1000 | 0x10000 | 0x100000);
    assembly=lw_asm_check_struct_align();
    log_print_str("Loading config options from \"");
    log_print_str(STARTUP_CFG_PATH);
    log_print_str("\"");
    set_close_button_callback(my_exit_close_button);
    config=load_config_options();
    display_success(config);
    log_print_str("Installing timer");
    signed int return_value_install_timer_4;
    return_value_install_timer_4=install_timer();
    timer = (signed int)!(return_value_install_timer_4 != 0);
    if(!(timer == 0))
      display_success_driver((char *)timer_driver->ascii_name);

    else
      display_success(0);
    start_ticker();
    log_print_str("Installing keyboard");
    signed int return_value_install_keyboard_5;
    return_value_install_keyboard_5=install_keyboard();
    keyboard = (signed int)!(return_value_install_keyboard_5 != 0);
    if(!(keyboard == 0))
      display_success_driver((char *)keyboard_driver->ascii_name);

    else
      display_success(0);
    log_print_str("Installing mouse");
    signed int return_value_install_mouse_6;
    return_value_install_mouse_6=install_mouse();
    mouse = (signed int)(return_value_install_mouse_6 != -1);
    if(!(mouse == 0))
      display_success_driver((char *)mouse_driver->ascii_name);

    else
      display_success(0);
    if(!(STARTUP_DIGI_CARD == 0) || !(STARTUP_MIDI_CARD == 0))
    {
      log_print_str("Installing sound");
      signed int return_value_install_sound_7;
      return_value_install_sound_7=install_sound(STARTUP_DIGI_CARD, STARTUP_MIDI_CARD, "");
      sound = (signed int)!(return_value_install_sound_7 != 0);
      if(sound == 0)
      {
        signed int return_value_install_sound_8;
        return_value_install_sound_8=install_sound(STARTUP_DIGI_CARD, 0, "");
        sound = (signed int)!(return_value_install_sound_8 != 0);
      }

      if(!(sound == 0))
      {
        log_print_str(" (digi=\"");
        log_print_str((char *)digi_driver->ascii_name);
        log_print_str("\", midi=\"");
        log_print_str((char *)midi_driver->ascii_name);
        log_print_str("\")");
      }

      display_success(sound);
    }

    if(!(STARTUP_JOYSTICK_ON == 0))
    {
      log_print_str("Installing joystick");
      if(!(STARTUP_JOYSTICK_ON == 0))
      {
        return_value_my_initialise_joystick_9=my_initialise_joystick();
        joystick = (signed int)!(return_value_my_initialise_joystick_9 != 0);
      }

      if(!(joystick == 0))
        display_success_driver((char *)joystick_driver->ascii_name);

      else
        display_success(0);
    }

    log_print_str("Setting up network");
    network=lw_sock_init();
    display_success(network);
    lw_capture_set_mode(STARTUP_CAPTURE);
  }

  result = (signed int)(graphics != 0 && (assembly != 0 || !(STARTUP_CHECK != 0)) && timer != 0 && keyboard != 0 && mouse != 0 && (sound != 0 || !(STARTUP_CHECK != 0)) && (joystick != 0 || !(STARTUP_CHECK != 0)));
  return result;
}

// init_cursor
// file cursor.c line 101
static void init_cursor(signed int index, signed int team, signed int x, signed int y, char *name)
{
  CURRENT_CURSOR[(signed long int)index].active = 1;
  CURRENT_CURSOR[(signed long int)index].team = team;
  CURRENT_CURSOR[(signed long int)index].x = x;
  CURRENT_CURSOR[(signed long int)index].y = y;
  CURRENT_CURSOR[(signed long int)index].val = 2000000 / 2;
  CURRENT_CURSOR[(signed long int)index].loose_time = -1;
  CURRENT_CURSOR[(signed long int)index].score_order = 0;
  CURRENT_CURSOR[(signed long int)index].color_entry = 128 + team * COLORS_PER_TEAM;
  __builtin_strncpy(CURRENT_CURSOR[(signed long int)index].name, name, (unsigned long int)10);
  CURRENT_CURSOR[(signed long int)index].name[(signed long int)10] = (char)0;
}

// init_cursor_control_method
// file game.c line 167
static void init_cursor_control_method(void)
{
  signed int i = 0;
  for( ; !(i >= 6); i = i + 1)
    if(!(LW_NETWORK_ON == 0))
    {
      CURRENT_CURSOR[(signed long int)i].from_network = LW_NETWORK_INFO[(signed long int)i].network;
      CURRENT_CURSOR[(signed long int)i].control_type = LW_NETWORK_INFO[(signed long int)i].control_type;
    }

    else
    {
      CURRENT_CURSOR[(signed long int)i].from_network = 0;
      CURRENT_CURSOR[(signed long int)i].control_type = CONFIG_CONTROL_TYPE[(signed long int)i];
    }
}

// init_disp_cursor
// file pion.h line 62
void init_disp_cursor(void)
{
  signed int i;
  signed int x;
  signed int y;
  signed int color_back;
  i = 0;
  for( ; !(i >= 32); i = i + 1)
  {
    color_back = 0;
    while(color_back >= 32 || !(color_back >= 64))
    {
      signed long int return_value_random_1;
      return_value_random_1=random();
      x = (signed int)(return_value_random_1 % (signed long int)CURRENT_AREA_W);
      signed long int return_value_random_2;
      return_value_random_2=random();
      y = (signed int)(return_value_random_2 % (signed long int)CURRENT_AREA_H);
      color_back=getpixel_link5(CURRENT_AREA_BACK, x, y);
    }
    CURSOR_COLOR_BACK[(signed long int)i] = (char)color_back;
  }
}

// init_distorsion_displayer
// file distor.c line 119
void init_distorsion_displayer(void)
{
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  init_distorsion_target();
  w = DISTORSION_TARGET->w;
  h = DISTORSION_TARGET->h;
  DISTORSION_W = (CONFIG_WAVE_AMPLI[(signed long int)0] + CONFIG_WAVE_AMPLI[(signed long int)3]) / 4 + 1;
  DISTORSION_H = (CONFIG_WAVE_AMPLI[(signed long int)1] + CONFIG_WAVE_AMPLI[(signed long int)2]) / 4 + 1;
  x = 0;
  for( ; !(x >= 1 + DISTORSION_W); x = x + 1)
    WAVE_SHAPE_X_CORRES[(signed long int)x] = WAVE_SHAPE_HX[(signed long int)x];
  x = DISTORSION_W;
  for( ; !(x >= w + -DISTORSION_W + -2); x = x + 1)
    WAVE_SHAPE_X_CORRES[(signed long int)x] = WAVE_SHAPE_HX[(signed long int)(DISTORSION_W + 1)];
  x = (w - DISTORSION_W) - 2;
  for( ; !(x >= w + -1); x = x + 1)
    WAVE_SHAPE_X_CORRES[(signed long int)x] = WAVE_SHAPE_HX[(signed long int)((w - x) - 2)];
  WAVE_SHAPE_X_CORRES[(signed long int)(w - 1)] = WAVE_SHAPE_HX[(signed long int)0];
  y = 0;
  for( ; !(y >= 1 + DISTORSION_H); y = y + 1)
    WAVE_SHAPE_Y_CORRES[(signed long int)y] = WAVE_SHAPE_WY[(signed long int)y];
  y = DISTORSION_H;
  for( ; !(y >= h + -DISTORSION_H + -2); y = y + 1)
    WAVE_SHAPE_Y_CORRES[(signed long int)y] = WAVE_SHAPE_WY[(signed long int)(DISTORSION_H + 1)];
  y = (h - DISTORSION_H) - 2;
  for( ; !(y >= h + -1); y = y + 1)
    WAVE_SHAPE_Y_CORRES[(signed long int)y] = WAVE_SHAPE_WY[(signed long int)((h - y) - 2)];
  WAVE_SHAPE_Y_CORRES[(signed long int)(h - 1)] = WAVE_SHAPE_WY[(signed long int)0];
}

// init_distorsion_target
// file distor.c line 99
static void init_distorsion_target(void)
{
  _Bool tmp_if_expr_1;
  if(DISTORSION_TARGET == ((struct BITMAP *)NULL))
    DISTORSION_TARGET=my_create_bitmap(NEXT_SCREEN->w, NEXT_SCREEN->h);

  else
  {
    if(!(DISTORSION_TARGET->w == NEXT_SCREEN->w))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = DISTORSION_TARGET->h != NEXT_SCREEN->h ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      destroy_bitmap(DISTORSION_TARGET);
      DISTORSION_TARGET=my_create_bitmap(NEXT_SCREEN->w, NEXT_SCREEN->h);
    }

  }
}

// init_game
// file game.c line 255
char * init_game(void)
{
  signed int i;
  signed int big_data;
  signed int max_mem_reached = 0;
  signed int last_try = 0;
  signed int ok = 0;
  char *message = (char *)(void *)0;
  if(message == ((char *)NULL))
  {
    CURRENT_AREA_BACK=lw_maptex_create_map(CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, CONFIG_LEVEL_BG, LW_NETWORK_ON, LW_RANDOM_ON, MIN_MAP_RES_W[(signed long int)LW_CONFIG_CURRENT_RULES.min_map_res], MIN_MAP_RES_H[(signed long int)LW_CONFIG_CURRENT_RULES.min_map_res], CONFIG_USE_DEFAULT_TEXTURE);
    if(CURRENT_AREA_BACK == ((struct BITMAP *)NULL))
      message=lw_lang_string(161);

  }

  if(message == ((char *)NULL))
  {
    CURRENT_AREA_DISP=lw_maptex_create_map(CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, CONFIG_LEVEL_BG, LW_NETWORK_ON, LW_RANDOM_ON, MIN_MAP_RES_W[(signed long int)LW_CONFIG_CURRENT_RULES.min_map_res], MIN_MAP_RES_H[(signed long int)LW_CONFIG_CURRENT_RULES.min_map_res], CONFIG_USE_DEFAULT_TEXTURE);
    if(CURRENT_AREA_DISP == ((struct BITMAP *)NULL))
      message=lw_lang_string(162);

  }

  signed int return_value_create_mesh_1;
  signed int return_value_create_game_area_2;
  signed int return_value_create_army_3;
  if(message == ((char *)NULL))
  {
    i = 0;
    for( ; max_mem_reached == 0 && ok == 0; i = i + 1)
    {
      message = (char *)(void *)0;
      reset_big_data();
      if(message == ((char *)NULL))
      {
        return_value_create_mesh_1=create_mesh();
        if(!(return_value_create_mesh_1 == 0))
          message=lw_lang_string(163);

      }

      if(message == ((char *)NULL))
      {
        return_value_create_game_area_2=create_game_area();
        if(!(return_value_create_game_area_2 == 0))
          message=lw_lang_string(164);

      }

      if(message == ((char *)NULL))
      {
        return_value_create_army_3=create_army();
        if(!(return_value_create_army_3 == 0))
          message=lw_lang_string(165);

      }

      if(!(message == ((char *)NULL)))
      {
        if(!(last_try == 0))
          max_mem_reached = 0;

        else
        {
          STARTUP_BIG_DATA = STARTUP_BIG_DATA + 8;
          if(STARTUP_BIG_DATA >= 129)
          {
            last_try = 1;
            STARTUP_BIG_DATA = 128;
          }

          big_data = STARTUP_BIG_DATA;
          void *return_value_malloc_big_data_4;
          return_value_malloc_big_data_4=malloc_big_data();
          if(!(return_value_malloc_big_data_4 == NULL))
          {
            if(!(STARTUP_BIG_DATA == big_data))
              last_try = 1;

          }

          else
            max_mem_reached = 1;
        }
      }

      else
        ok = 1;
    }
  }

  if(message == ((char *)NULL))
  {
    reset_mesh();
    reset_game_area();
    reset_all_cursor();
    init_cursor_control_method();
    place_all_team();
    init_move_fighters();
    init_disp_cursor();
  }

  LW_NETWORK_ERROR_DETECTED = 0;
  return message;
}

// init_info_bar
// file info.c line 97
signed int init_info_bar(signed int w, signed int h, signed int epaisseur)
{
  signed int i;
  signed int x;
  signed int y;
  struct BITMAP *front;
  struct BITMAP *back;
  if(!(INFO_BAR == ((struct BITMAP *)NULL)))
    destroy_bitmap(INFO_BAR);

  INFO_BAR=my_create_bitmap(w, h);
  INFO_BAR_BACK=my_create_bitmap(w, h);
  signed int return_value_getpixel_1;
  signed int return_value_getpixel_2;
  if(!(INFO_BAR == ((struct BITMAP *)NULL)) && !(INFO_BAR_BACK == ((struct BITMAP *)NULL)))
  {
    if(!(h >= w))
    {
      rectfill_link1(INFO_BAR, 0, 0, epaisseur - 1, h - 1, 16);
      vline_link1(INFO_BAR, epaisseur, 0, h - 1, 17);
      front=lw_maptex_create_fg(CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, LW_NETWORK_ON, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
      back=lw_maptex_create_bg(CONFIG_LEVEL_MAP, CONFIG_LEVEL_BG, LW_NETWORK_ON, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
      y = 0;
      for( ; !(y >= h); y = y + front->h)
      {
        x = epaisseur + 1;
        for( ; !(x >= w); x = x + front->w)
          draw_sprite_link1(INFO_BAR, front, x, y);
      }
      INFO_BAR_POS_W = (w - epaisseur) - 5;
      INFO_BAR_POS_H = (h - 1) / PLAYING_TEAMS - 1;
      i = 0;
      for( ; !(i >= PLAYING_TEAMS); i = i + 1)
      {
        INFO_BAR_POS_X[(signed long int)i] = epaisseur + 3;
        INFO_BAR_POS_Y[(signed long int)i] = ((h + 1) - PLAYING_TEAMS * (INFO_BAR_POS_H + 1)) / 2 + i * (INFO_BAR_POS_H + 1);
        y = INFO_BAR_POS_Y[(signed long int)i];
        for( ; !(y >= INFO_BAR_POS_Y[(signed long int)i] + INFO_BAR_POS_H); y = y + 1)
        {
          x = INFO_BAR_POS_X[(signed long int)i];
          for( ; !(x >= INFO_BAR_POS_X[(signed long int)i] + INFO_BAR_POS_W); x = x + 1)
          {
            return_value_getpixel_1=getpixel_link2(back, ((x - epaisseur) - 1) % back->w, y % back->h);
            putpixel_link5(INFO_BAR, x, y, return_value_getpixel_1);
          }
        }
      }
      destroy_bitmap(back);
      destroy_bitmap(front);
    }

    else
    {
      rectfill_link1(INFO_BAR, 0, 0, w - 1, epaisseur - 1, 16);
      hline_link1(INFO_BAR, 0, epaisseur, w - 1, 17);
      front=lw_maptex_create_fg(CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, LW_NETWORK_ON, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
      back=lw_maptex_create_bg(CONFIG_LEVEL_MAP, CONFIG_LEVEL_BG, LW_NETWORK_ON, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
      y = epaisseur + 1;
      for( ; !(y >= h); y = y + front->h)
      {
        x = 0;
        for( ; !(x >= w); x = x + front->w)
          draw_sprite_link1(INFO_BAR, front, x, y);
      }
      INFO_BAR_POS_W = (w - 1) / PLAYING_TEAMS - 1;
      INFO_BAR_POS_H = (h - epaisseur) - 5;
      i = 0;
      for( ; !(i >= PLAYING_TEAMS); i = i + 1)
      {
        INFO_BAR_POS_X[(signed long int)i] = ((w + 1) - PLAYING_TEAMS * (INFO_BAR_POS_W + 1)) / 2 + i * (INFO_BAR_POS_W + 1);
        INFO_BAR_POS_Y[(signed long int)i] = epaisseur + 3;
        y = INFO_BAR_POS_Y[(signed long int)i];
        for( ; !(y >= INFO_BAR_POS_Y[(signed long int)i] + INFO_BAR_POS_H); y = y + 1)
        {
          x = INFO_BAR_POS_X[(signed long int)i];
          for( ; !(x >= INFO_BAR_POS_X[(signed long int)i] + INFO_BAR_POS_W); x = x + 1)
          {
            return_value_getpixel_2=getpixel_link2(back, x % back->w, ((y - epaisseur) - 1) % back->h);
            putpixel_link5(INFO_BAR, x, y, return_value_getpixel_2);
          }
        }
      }
      destroy_bitmap(back);
      destroy_bitmap(front);
    }
    draw_sprite_link1(INFO_BAR_BACK, INFO_BAR, 0, 0);
  }

  return (signed int)(INFO_BAR != ((struct BITMAP *)NULL) && INFO_BAR_BACK != ((struct BITMAP *)NULL));
}

// init_move_fighters
// file fighter.c line 146
void init_move_fighters(void)
{
  signed int i;
  signed int j;
  signed int k;
  signed int dir;
  k = 0;
  for( ; !(k >= 2); k = k + 1)
  {
    i = 0;
    for( ; !(i >= 12); i = i + 1)
    {
      j = 0;
      for( ; !(j >= 5); j = j + 1)
      {
        dir = FIGHTER_MOVE_DIR[(signed long int)k][(signed long int)i][(signed long int)j];
        FIGHTER_MOVE_X[(signed long int)k][(signed long int)i][(signed long int)j] = FIGHTER_MOVE_X_REF[(signed long int)dir];
        FIGHTER_MOVE_Y[(signed long int)k][(signed long int)i][(signed long int)j] = FIGHTER_MOVE_Y_REF[(signed long int)dir];
        FIGHTER_MOVE_OFFSET[(signed long int)k][(signed long int)i][(signed long int)j] = 0;
        if(FIGHTER_MOVE_X[(signed long int)k][(signed long int)i][(signed long int)j] == 1)
          FIGHTER_MOVE_OFFSET[(signed long int)k][(signed long int)i][(signed long int)j] = FIGHTER_MOVE_OFFSET[(signed long int)k][(signed long int)i][(signed long int)j] + 1;

        if(FIGHTER_MOVE_X[(signed long int)k][(signed long int)i][(signed long int)j] == -1)
          FIGHTER_MOVE_OFFSET[(signed long int)k][(signed long int)i][(signed long int)j] = FIGHTER_MOVE_OFFSET[(signed long int)k][(signed long int)i][(signed long int)j] - 1;

        if(FIGHTER_MOVE_Y[(signed long int)k][(signed long int)i][(signed long int)j] == 1)
          FIGHTER_MOVE_OFFSET[(signed long int)k][(signed long int)i][(signed long int)j] = FIGHTER_MOVE_OFFSET[(signed long int)k][(signed long int)i][(signed long int)j] + CURRENT_AREA_W;

        if(FIGHTER_MOVE_Y[(signed long int)k][(signed long int)i][(signed long int)j] == -1)
          FIGHTER_MOVE_OFFSET[(signed long int)k][(signed long int)i][(signed long int)j] = FIGHTER_MOVE_OFFSET[(signed long int)k][(signed long int)i][(signed long int)j] - CURRENT_AREA_W;

        FIGHTER_MOVE_OFFSET_ASM[(signed long int)k][(signed long int)(i * 5 + j)] = FIGHTER_MOVE_OFFSET[(signed long int)k][(signed long int)i][(signed long int)j];
        FIGHTER_MOVE_XY_ASM[(signed long int)k][(signed long int)(i * 5 + j)] = FIGHTER_MOVE_Y[(signed long int)k][(signed long int)i][(signed long int)j] * 65536 + FIGHTER_MOVE_X[(signed long int)k][(signed long int)i][(signed long int)j];
      }
    }
  }
  i = 0;
  for( ; !(i >= CURRENT_ARMY_SIZE); i = i + 1)
    disp_fighter(CURRENT_ARMY + (signed long int)i);
  i = 1;
  for( ; !(i >= 17); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 2); j = j + 1)
    {
      k = -1;
      switch(i)
      {
        case 1:
        {
          k = j != 0 ? 11 : 0;
          break;
        }
        case 3:
        {
          k = 1;
          break;
        }
        case 2:
        {
          k = j != 0 ? 2 : 3;
          break;
        }
        case 6:
        {
          k = 4;
          break;
        }
        case 4:
        {
          k = j != 0 ? 5 : 6;
          break;
        }
        case 12:
        {
          k = 7;
          break;
        }
        case 8:
        {
          k = j != 0 ? 8 : 9;
          break;
        }
        case 9:
          k = 10;
      }
      LOCAL_DIR[(signed long int)((i - 1) * 2 + j)] = k;
    }
  }
}

// init_tombola
// file score.c line 195
static void init_tombola()
{
  signed int i = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    signed long int return_value_random_1;
    return_value_random_1=random();
    LW_SCORE_TOMBOLA_RESULT[(signed long int)i] = (signed int)(return_value_random_1 % (signed long int)500 + (signed long int)1);
  }
}

// init_viewport_size
// file viewport.c line 96
static void init_viewport_size(signed int x, signed int y, signed int w, signed int h)
{
  signed int scale_w;
  signed int scale_h;
  scale_w = 10 * w;
  scale_h = 10 * h;
  if(CONFIG_VIEWPORT_SIZE >= 8)
  {
    VIEWPORT_W = scale_w;
    VIEWPORT_H = scale_h;
  }

  if(CONFIG_VIEWPORT_SIZE >= 1 && !(CONFIG_VIEWPORT_SIZE >= 8))
  {
    static signed int viewport_sizes[7l] = { 18, 24, 27, 30, 33, 35, 36 };
    if(!(CURRENT_AREA_H * scale_w >= CURRENT_AREA_W * scale_h))
    {
      VIEWPORT_W = (scale_w * viewport_sizes[(signed long int)(CONFIG_VIEWPORT_SIZE - 1)]) / viewport_sizes[(signed long int)6];
      VIEWPORT_H = (VIEWPORT_W * CURRENT_AREA_H) / CURRENT_AREA_W;
    }

    else
    {
      VIEWPORT_H = (scale_h * viewport_sizes[(signed long int)(CONFIG_VIEWPORT_SIZE - 1)]) / viewport_sizes[(signed long int)6];
      VIEWPORT_W = (VIEWPORT_H * CURRENT_AREA_W) / CURRENT_AREA_H;
    }
  }

  if(!(CONFIG_VIEWPORT_SIZE >= 1))
  {
    VIEWPORT_W = CURRENT_AREA_W;
    VIEWPORT_H = CURRENT_AREA_H;
    for( ; !(h >= VIEWPORT_H) || !(w >= VIEWPORT_W); VIEWPORT_H = VIEWPORT_H / 2)
      VIEWPORT_W = VIEWPORT_W / 2;
  }

  else
  {
    VIEWPORT_W = VIEWPORT_W * w;
    VIEWPORT_H = VIEWPORT_H * h;
    VIEWPORT_W = VIEWPORT_W / scale_w;
    VIEWPORT_H = VIEWPORT_H / scale_h;
  }
  VIEWPORT_X = x + ((w - VIEWPORT_W) / 8) * 4;
  VIEWPORT_Y = y + (h - VIEWPORT_H) / 2;
}

// int_to_ascii_hexa
// file netkey.c line 115
static char int_to_ascii_hexa(signed int src)
{
  char dst = (char)48;
  if(src >= 1 && !(src >= 10))
    dst = (char)(48 + src);

  if(src >= 10 && !(src >= 16))
    dst = (char)((65 - 10) + src);

  return dst;
}

// internet_find
// file internet.c line 122
signed int internet_find(void)
{
  struct DIALOG d[13l];
  signed int choix = 4;
  signed int retour = 0;
  struct anonymous_15 data[1000l];
  signed int size;
  signed int cur;
  signed int i;
  memset((void *)d, 0, sizeof(struct DIALOG [13l]) /*936ul*/ );
  size = 1000;
  lw_wwwcli_get_games(data, &size);
  list_data = data;
  list_size = &size;
  while(retour == 0)
  {
    position_list(d + (signed long int)4);
    standard_button(d + (signed long int)5, 1, 0, 2, 10);
    standard_button(d + (signed long int)6, 1, 1, 2, 10);
    standard_button(d + (signed long int)7, 1, 3, 2, 10);
    standard_button(d + (signed long int)8, 1, 4, 2, 10);
    standard_button(d + (signed long int)9, 1, 5, 2, 10);
    standard_button(d + (signed long int)10, 1, 6, 2, 10);
    i = 0;
    for( ; !(i >= 6); i = i + 1)
      d[(signed long int)(5 + i)].w=menu_real_x((150 + 100) / 2);
    position_comment(d + (signed long int)11);
    quick_buttons(d);
    d[(signed long int)4].dp = (void *)list_callback;
    d[(signed long int)4].d2 = 0;
    d[(signed long int)4].d1 = d[(signed long int)4].d2;
    d[(signed long int)4].dp3 = (void *)0;
    d[(signed long int)4].dp2 = d[(signed long int)4].dp3;
    d[(signed long int)4].proc = my_list_proc;
    char *return_value_lw_lang_string_1;
    return_value_lw_lang_string_1=lw_lang_string(91);
    d[(signed long int)5].dp = (void *)return_value_lw_lang_string_1;
    char *return_value_lw_lang_string_2;
    return_value_lw_lang_string_2=lw_lang_string(92);
    d[(signed long int)6].dp = (void *)return_value_lw_lang_string_2;
    d[(signed long int)7].dp = (void *)buffer_ping;
    d[(signed long int)8].dp = (void *)buffer_port;
    d[(signed long int)9].dp = (void *)buffer_password;
    d[(signed long int)10].dp = (void *)buffer_uptime;
    d[(signed long int)11].dp = (void *)buffer_comment;
    d[(signed long int)11].proc = my_textbox_proc;
    d[(signed long int)10].proc = d[(signed long int)11].proc;
    d[(signed long int)9].proc = d[(signed long int)10].proc;
    d[(signed long int)8].proc = d[(signed long int)9].proc;
    d[(signed long int)7].proc = d[(signed long int)8].proc;
    d[(signed long int)12].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
    dialog_list = d + (signed long int)4;
    dialog_ping = d + (signed long int)7;
    dialog_port = d + (signed long int)8;
    dialog_password = d + (signed long int)9;
    dialog_uptime = d + (signed long int)10;
    dialog_comment = d + (signed long int)11;
    update_text_ping(0);
    update_text_port(0);
    update_text_password(0);
    update_text_uptime(0);
    update_text_comment(0);
    choix=my_do_dialog(d, choix);
    cur = d[(signed long int)4].d1;
    if(choix == 1 || choix == 4 || choix == 6)
    {
      if(cur >= 0 && !(cur >= size))
      {
        __builtin_strncpy(CONFIG_SERVER_ADDRESS, data[(signed long int)cur].ip, (unsigned long int)50);
        CONFIG_SERVER_ADDRESS[(signed long int)50] = (char)0;
        CONFIG_SERVER_PORT = data[(signed long int)cur].port;
      }

    }

    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 2)
        goto __CPROVER_DUMP_L6;

      if(choix == 0)
        goto __CPROVER_DUMP_L7;

      if(choix == 1)
        goto __CPROVER_DUMP_L10;

      if(choix == 5)
        goto __CPROVER_DUMP_L11;

      if(choix == 4 || choix == 6)
        goto __CPROVER_DUMP_L12;

    }

    else
    {
      retour = 1;
      goto __CPROVER_DUMP_L14;

    __CPROVER_DUMP_L6:
      ;
      retour = -1;
      goto __CPROVER_DUMP_L14;

    __CPROVER_DUMP_L7:
      ;
      signed int return_value_confirm_quit_3;
      return_value_confirm_quit_3=confirm_quit();
      if(!(return_value_confirm_quit_3 == 0))
        retour = -2;

      else
        display_back_image();
      goto __CPROVER_DUMP_L14;

    __CPROVER_DUMP_L10:
      ;
      retour=netplay_sequence();
      goto __CPROVER_DUMP_L14;

    __CPROVER_DUMP_L11:
      ;
      size = 1000;
      lw_wwwcli_get_games(data, &size);
      goto __CPROVER_DUMP_L14;

    __CPROVER_DUMP_L12:
      ;
      if(cur >= 0 && !(cur >= size))
        retour=netplay_sequence();

    }

  __CPROVER_DUMP_L14:
    ;
  }
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// is_arg_marker
// file parser.c line 75
static signed int is_arg_marker(char c)
{
  return (signed int)((signed int)c == 45);
}

// is_linear_bitmap
// file /usr/include/allegro/inline/gfx.inl line 138
static inline signed int is_linear_bitmap(struct BITMAP *bmp)
{
  return (signed int)((bmp->id & (unsigned long int)0x10000000) == (unsigned long int)0);
}

// is_memory_bitmap
// file /usr/include/allegro/inline/gfx.inl line 154
static inline signed int is_memory_bitmap(struct BITMAP *bmp)
{
  return (signed int)((bmp->id & (unsigned long int)(0x80000000 | (unsigned int)0x40000000)) == (unsigned long int)0);
}

// is_touched_key
// file keyboard.c line 99
signed int is_touched_key(signed int i)
{
  signed int retval = 0;
  signed int found = 0;
  if(!(CONFIG_JOYSTICK_ON == 0))
    switch(i)
    {
      case 110:
      {
        found = 1;
        retval = JOYSTICK_CONTROL_JOY1_UP;
        break;
      }
      case 111:
      {
        found = 1;
        retval = JOYSTICK_CONTROL_JOY1_RIGHT;
        break;
      }
      case 112:
      {
        found = 1;
        retval = JOYSTICK_CONTROL_JOY1_DOWN;
        break;
      }
      case 113:
      {
        found = 1;
        retval = JOYSTICK_CONTROL_JOY1_LEFT;
        break;
      }
      case 114:
      {
        found = 1;
        retval = JOYSTICK_CONTROL_JOY1_B1;
        break;
      }
      case 115:
      {
        found = 1;
        retval = JOYSTICK_CONTROL_JOY1_B2;
        break;
      }
      case 116:
      {
        found = 1;
        retval = JOYSTICK_CONTROL_JOY1_B3;
        break;
      }
      case 117:
      {
        found = 1;
        retval = JOYSTICK_CONTROL_JOY1_B4;
        break;
      }
      case 118:
      {
        found = 1;
        retval = JOYSTICK_CONTROL_JOY2_UP;
        break;
      }
      case 119:
      {
        found = 1;
        retval = JOYSTICK_CONTROL_JOY2_RIGHT;
        break;
      }
      case 120:
      {
        found = 1;
        retval = JOYSTICK_CONTROL_JOY2_DOWN;
        break;
      }
      case 121:
      {
        found = 1;
        retval = JOYSTICK_CONTROL_JOY2_LEFT;
        break;
      }
      case 122:
      {
        found = 1;
        retval = JOYSTICK_CONTROL_JOY2_B1;
        break;
      }
      case 123:
      {
        found = 1;
        retval = JOYSTICK_CONTROL_JOY2_B2;
      }
    }

  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(found == 0)
    switch(i)
    {
      case 124:
      {
        retval = MOUSE_CONTROL_UP;
        break;
      }
      case 125:
      {
        retval = MOUSE_CONTROL_RIGHT;
        break;
      }
      case 126:
      {
        retval = MOUSE_CONTROL_DOWN;
        break;
      }
      case 127:
      {
        retval = MOUSE_CONTROL_LEFT;
        break;
      }
      default:
        if(i >= 128)
        {
          i = i - 128;
          if(!((2 & (signed int)key[(signed long int)i]) == 0))
            tmp_if_expr_1 = ALLOWED_KEYBOARD_KEY[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          retval = (signed int)tmp_if_expr_1;
        }

        else
        {
          if(!((1 & (signed int)key[(signed long int)i]) == 0))
            tmp_if_expr_2 = ALLOWED_KEYBOARD_KEY[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_2 = (_Bool)0;
          retval = (signed int)tmp_if_expr_2;
        }
    }

  return retval != 0 ? 1 : 0;
}

// itofix
// file /usr/include/allegro/inline/fmaths.inl line 181
static inline signed int itofix(signed int x)
{
  return x << 16;
}

// itofix_link1
// file /usr/include/allegro/inline/fmaths.inl line 181
static inline signed int itofix_link1(signed int x_link1)
{
  return x_link1 << 16;
}

// language_options
// file language.c line 89
signed int language_options(void)
{
  struct DIALOG d[10l];
  signed int i;
  signed int choix = 4;
  signed int retour = 0;
  memset((void *)d, 0, sizeof(struct DIALOG [10l]) /*720ul*/ );
  standard_button(d + (signed long int)4, 0, 0, 1, 2 + 4);
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    standard_button(d + (signed long int)i + (signed long int)5, 0, 2 + i, 1, 2 + 4);
  update_language(d);
  d[(signed long int)(5 + 4)].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
  signed int return_value_confirm_quit_1;
  while(retour == 0)
  {
    choix=my_do_dialog(d, choix);
    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 2)
        goto __CPROVER_DUMP_L5;

      if(choix == 0)
        goto __CPROVER_DUMP_L6;

      if(choix == 1)
        goto __CPROVER_DUMP_L8;

      if(choix == 4)
        goto __CPROVER_DUMP_L9;

    }

    else
    {
      retour = 1;
      continue;

    __CPROVER_DUMP_L5:
      ;
      retour = -1;
      continue;

    __CPROVER_DUMP_L6:
      ;
      return_value_confirm_quit_1=confirm_quit();
      if(!(return_value_confirm_quit_1 == 0))
        retour = -2;

      continue;

    __CPROVER_DUMP_L8:
      ;
      retour = -3;
      continue;

    __CPROVER_DUMP_L9:
      ;
      CONFIG_LANGUAGE = -1;
      update_language(d);
      continue;
    }
    if(choix >= 5 && !(choix >= 4))
    {
      CONFIG_LANGUAGE = choix - 5;
      update_language(d);
    }

  }
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// last_flip
// file viewport.h line 77
void last_flip(void)
{
  signed int tmp_if_expr_6;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_5;
  if(!(NEXT_SCREEN == ((struct BITMAP *)NULL)))
  {
    if(!(CONFIG_PAGE_FLIP == 0))
    {
      if(!(screen == ((struct BITMAP *)NULL)))
        tmp_if_expr_6 = screen->h;

      else
        tmp_if_expr_6 = 0;
      if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
        tmp_if_expr_7 = gfx_driver->h;

      else
        tmp_if_expr_7 = 0;
      if(tmp_if_expr_6 >= 2 * tmp_if_expr_7)
      {
        if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
          tmp_if_expr_1 = gfx_driver->w;

        else
          tmp_if_expr_1 = 0;
        if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
          tmp_if_expr_2 = gfx_driver->h;

        else
          tmp_if_expr_2 = 0;
        set_clip_rect(screen, 0, 0, tmp_if_expr_1 - 1, tmp_if_expr_2 - 1);
        if(PAGE_FLIP_H == 0)
        {
          if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
            tmp_if_expr_3 = gfx_driver->h;

          else
            tmp_if_expr_3 = 0;
          if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
            tmp_if_expr_4 = gfx_driver->w;

          else
            tmp_if_expr_4 = 0;
          if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
            tmp_if_expr_5 = gfx_driver->h;

          else
            tmp_if_expr_5 = 0;
          blit(screen, screen, 0, tmp_if_expr_3, 0, 0, tmp_if_expr_4, tmp_if_expr_5);
          scroll_screen(0, 0);
        }

        else
          PAGE_FLIP_H = 0;
      }

    }

    destroy_bitmap(NEXT_SCREEN);
    NEXT_SCREEN = (struct BITMAP *)(void *)0;
  }

}

// list_callback
// file internet.c line 286
static char * list_callback(signed int index, signed int *size)
{
  char *result = (char *)(void *)0;
  if(index >= 0)
  {
    if(!(index >= *list_size))
    {
      result = (list_data + (signed long int)index)->label;
      if(index == dialog_list->d1)
      {
        update_text_ping(dialog_list->d1);
        update_text_port(dialog_list->d1);
        update_text_password(dialog_list->d1);
        update_text_uptime(dialog_list->d1);
        update_text_comment(dialog_list->d1);
        scare_mouse();
        my_textbox_proc(3, dialog_ping, 0);
        my_textbox_proc(3, dialog_port, 0);
        my_textbox_proc(3, dialog_password, 0);
        my_textbox_proc(3, dialog_uptime, 0);
        my_textbox_proc(3, dialog_comment, 0);
        unscare_mouse();
      }

    }

    else
      result = "";
  }

  else
    *size = *list_size;
  return result;
}

// load_config_options
// file config.c line 502
signed int load_config_options(void)
{
  signed int result;
  result=load_disk_options();
  lw_config_set_current_rules_to_default();
  return result;
}

// load_custom
// file disk.c line 566
signed int load_custom(void)
{
  signed int success;
  signed int result = 1;
  if(!(STARTUP_CUSTOM_STATE == 0) && !(STARTUP_TEXTURE_STATE == 0))
  {
    log_print_str("Loading custom textures from \"");
    log_print_str(STARTUP_TEX_PATH);
    log_print_str("\" ");
    log_flush();
    success=load_custom_texture();
    if(success == 0)
      result = result & (signed int)!(STARTUP_CHECK != 0);

    display_success(success);
  }

  if(!(STARTUP_CUSTOM_STATE == 0))
  {
    log_print_str("Loading custom maps from \"");
    log_print_str(STARTUP_MAP_PATH);
    log_print_str("\" ");
    log_flush();
    success=load_custom_map();
    if(success == 0)
      result = result & (signed int)!(STARTUP_CHECK != 0);

    display_success(success);
  }

  if(!(STARTUP_CUSTOM_STATE == 0) && !(STARTUP_MUSIC_STATE == 0))
  {
    log_print_str("Loading custom musics from \"");
    log_print_str(STARTUP_MID_PATH);
    log_print_str("\" ");
    log_flush();
    success=load_custom_music();
    if(success == 0)
      result = result & (signed int)!(STARTUP_CHECK != 0);

    display_success(success);
  }

  return result;
}

// load_custom_map
// file disk.c line 504
static signed int load_custom_map(void)
{
  signed int result = 1;
  char buf[512l];
  memset((void *)buf, 0, sizeof(char [512l]) /*512ul*/ );
  snprintf(buf, sizeof(char [512l]) /*512ul*/  - (unsigned long int)1, "%s\\*.*", (const void *)STARTUP_MAP_PATH);
  buf[(signed long int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1)] = (char)0;
  fix_filename_case(buf);
  fix_filename_slashes(buf);
  CUSTOM_MAP_OK = 0;
  for_each_file_ex(buf, 0, 16, load_custom_map_callback, (void *)0);
  result = CUSTOM_MAP_OK;
  return result;
}

// load_custom_map_callback
// file disk.c line 481
static signed int load_custom_map_callback(const char *file, signed int mode, void *unused)
{
  void *pointeur;
  mode = mode;
  unused = unused;
  pointeur=lw_map_archive_raw(file);
  signed int tmp_post_1;
  if(!(pointeur == NULL))
  {
    tmp_post_1 = RAW_MAP_NUMBER;
    RAW_MAP_NUMBER = RAW_MAP_NUMBER + 1;
    RAW_MAP[(signed long int)tmp_post_1] = pointeur;
    log_print_str("+");
    CUSTOM_MAP_OK = 1;
  }

  else
    log_print_str("-");
  return 0;
}

// load_custom_music
// file disk.c line 547
static signed int load_custom_music(void)
{
  signed int result = 1;
  char buf[512l];
  memset((void *)buf, 0, sizeof(char [512l]) /*512ul*/ );
  snprintf(buf, sizeof(char [512l]) /*512ul*/  - (unsigned long int)1, "%s\\*.*", (const void *)STARTUP_MID_PATH);
  buf[(signed long int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1)] = (char)0;
  fix_filename_case(buf);
  fix_filename_slashes(buf);
  CUSTOM_MUSIC_OK = 0;
  for_each_file_ex(buf, 0, 16, load_custom_music_callback, (void *)0);
  result = CUSTOM_MUSIC_OK;
  return result;
}

// load_custom_music_callback
// file disk.c line 523
static signed int load_custom_music_callback(const char *file, signed int mode, void *unused)
{
  void *pointeur;
  mode = mode;
  unused = unused;
  struct MIDI *return_value_load_midi_2;
  return_value_load_midi_2=load_midi(file);
  pointeur = (void *)return_value_load_midi_2;
  signed int tmp_post_1;
  if(!(pointeur == NULL))
  {
    tmp_post_1 = MIDI_MUSIC_NUMBER;
    MIDI_MUSIC_NUMBER = MIDI_MUSIC_NUMBER + 1;
    MIDI_MUSIC[(signed long int)tmp_post_1] = (struct MIDI *)pointeur;
    log_print_str("+");
    CUSTOM_MUSIC_OK = 1;
  }

  else
    log_print_str("-");
  log_flush();
  return 0;
}

// load_custom_texture
// file disk.c line 462
static signed int load_custom_texture(void)
{
  signed int result = 1;
  char buf[512l];
  memset((void *)buf, 0, sizeof(char [512l]) /*512ul*/ );
  snprintf(buf, sizeof(char [512l]) /*512ul*/  - (unsigned long int)1, "%s\\*.*", (const void *)STARTUP_TEX_PATH);
  buf[(signed long int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1)] = (char)0;
  fix_filename_case(buf);
  fix_filename_slashes(buf);
  CUSTOM_TEXTURE_OK = 0;
  for_each_file_ex(buf, 0, 16, load_custom_texture_callback, (void *)0);
  result = CUSTOM_TEXTURE_OK;
  return result;
}

// load_custom_texture_callback
// file disk.c line 438
static signed int load_custom_texture_callback(const char *file, signed int mode, void *unused)
{
  void *pointeur;
  mode = mode;
  unused = unused;
  pointeur=lw_texture_archive_raw(file);
  signed int tmp_post_1;
  if(!(pointeur == NULL))
  {
    tmp_post_1 = RAW_TEXTURE_NUMBER;
    RAW_TEXTURE_NUMBER = RAW_TEXTURE_NUMBER + 1;
    RAW_TEXTURE[(signed long int)tmp_post_1] = pointeur;
    log_print_str("+");
    CUSTOM_TEXTURE_OK = 1;
  }

  else
    log_print_str("-");
  log_flush();
  return 0;
}

// load_dat
// file disk.c line 306
signed int load_dat(void)
{
  signed int result = 1;
  signed int loadable;
  struct DATAFILE *df;
  log_print_str("Loading data from \"");
  log_print_str(STARTUP_DAT_PATH);
  log_print_str("\"");
  loadable=exists(STARTUP_DAT_PATH);
  display_success(loadable);
  if(!(loadable == 0))
  {
    log_print_str("Loading fonts");
    log_flush();
    df=load_datafile_object(STARTUP_DAT_PATH, "font_dat");
    result = result & (signed int)(df != (struct DATAFILE *)(void *)0);
    if(!(result == 0))
      read_font_dat((struct DATAFILE *)(df + (signed long int)0)->dat);

    display_success((signed int)(df != (struct DATAFILE *)(void *)0));
  }

  if(!(loadable == 0))
  {
    log_print_str("Loading maps");
    log_flush();
    df=load_datafile_object(STARTUP_DAT_PATH, "map_dat");
    result = result & (signed int)(df != (struct DATAFILE *)(void *)0);
    if(!(result == 0))
      read_map_dat((struct DATAFILE *)(df + (signed long int)0)->dat);

    display_success((signed int)(df != (struct DATAFILE *)(void *)0));
  }

  if(!(STARTUP_BACK_STATE == 0) && !(loadable == 0))
  {
    log_print_str("Loading background bitmap");
    log_flush();
    df=load_datafile_object(STARTUP_DAT_PATH, "back_dat");
    if(!(df == ((struct DATAFILE *)NULL)))
    {
      read_back_dat((struct DATAFILE *)(df + (signed long int)0)->dat);
      LOADED_BACK = 1;
    }

    else
    {
      create_default_back();
      result = result & (signed int)!(STARTUP_CHECK != 0);
    }
    display_success((signed int)(df != (struct DATAFILE *)(void *)0));
  }

  else
    create_default_back();
  if(!(STARTUP_SFX_STATE == 0) && !(loadable == 0))
  {
    log_print_str("Loading sound fx");
    log_flush();
    df=load_datafile_object(STARTUP_DAT_PATH, "sfx_dat");
    if(!(df == ((struct DATAFILE *)NULL)))
    {
      read_sfx_dat((struct DATAFILE *)(df + (signed long int)0)->dat);
      LOADED_SFX = 1;
    }

    else
      result = result & (signed int)!(STARTUP_CHECK != 0);
    display_success((signed int)(df != (struct DATAFILE *)(void *)0));
  }

  if(!(STARTUP_TEXTURE_STATE == 0) && !(loadable == 0))
  {
    log_print_str("Loading textures");
    log_flush();
    df=load_datafile_object(STARTUP_DAT_PATH, "texture_dat");
    if(!(df == ((struct DATAFILE *)NULL)))
    {
      read_texture_dat((struct DATAFILE *)(df + (signed long int)0)->dat);
      LOADED_TEXTURE = 1;
    }

    else
      result = result & (signed int)!(STARTUP_CHECK != 0);
    display_success((signed int)(df != (struct DATAFILE *)(void *)0));
    log_print_str("Loading map textures");
    log_flush();
    df=load_datafile_object(STARTUP_DAT_PATH, "maptex_dat");
    if(!(df == ((struct DATAFILE *)NULL)))
    {
      read_maptex_dat((struct DATAFILE *)(df + (signed long int)0)->dat);
      LOADED_MAPTEX = 1;
    }

    else
      result = result & (signed int)!(STARTUP_CHECK != 0);
    display_success((signed int)(df != (struct DATAFILE *)(void *)0));
  }

  if(!(STARTUP_WATER_STATE == 0) && !(loadable == 0))
  {
    log_print_str("Loading water sounds");
    log_flush();
    df=load_datafile_object(STARTUP_DAT_PATH, "water_dat");
    if(!(df == ((struct DATAFILE *)NULL)))
    {
      read_water_dat((struct DATAFILE *)(df + (signed long int)0)->dat);
      LOADED_WATER = 1;
    }

    else
      result = result & (signed int)!(STARTUP_CHECK != 0);
    display_success((signed int)(df != (struct DATAFILE *)(void *)0));
  }

  if(!(STARTUP_MUSIC_STATE == 0) && !(loadable == 0))
  {
    log_print_str("Loading midi music");
    log_flush();
    df=load_datafile_object(STARTUP_DAT_PATH, "music_dat");
    if(!(df == ((struct DATAFILE *)NULL)))
    {
      read_music_dat((struct DATAFILE *)(df + (signed long int)0)->dat);
      LOADED_MUSIC = 1;
    }

    else
      result = result & (signed int)!(STARTUP_CHECK != 0);
    display_success((signed int)(df != (struct DATAFILE *)(void *)0));
  }

  return (signed int)(loadable != 0 && result != 0);
}

// load_default_options
// file config.c line 194
void load_default_options(void)
{
  CONFIG_GFX_GAME = 2;
  CONFIG_GFX_MENU = 2;
  CONFIG_FULLSCREEN = 0;
  CONFIG_VIEWPORT_SIZE = 6;
  CONFIG_WAVE_NUMBER[(signed long int)0] = 2;
  CONFIG_WAVE_NUMBER[(signed long int)1] = 2;
  CONFIG_WAVE_NUMBER[(signed long int)2] = 2;
  CONFIG_WAVE_NUMBER[(signed long int)3] = 2;
  CONFIG_WAVE_AMPLI[(signed long int)0] = 8;
  CONFIG_WAVE_AMPLI[(signed long int)1] = 8;
  CONFIG_WAVE_AMPLI[(signed long int)2] = 8;
  CONFIG_WAVE_AMPLI[(signed long int)3] = 8;
  CONFIG_WAVE_SPEED[(signed long int)0] = 6;
  CONFIG_WAVE_SPEED[(signed long int)1] = 7;
  CONFIG_WAVE_SPEED[(signed long int)2] = 8;
  CONFIG_WAVE_SPEED[(signed long int)3] = 9;
  CONFIG_BRIGHTNESS = 8;
  CONFIG_SFX_VOLUME = 12;
  CONFIG_CLICK_VOLUME = 8;
  CONFIG_WATER_VOLUME_MENU = 6;
  CONFIG_WATER_VOLUME_GAME = 10;
  CONFIG_MUSIC_VOLUME = 12;
  CONFIG_LEVEL_MAP = 0;
  CONFIG_LEVEL_FG = 135;
  CONFIG_LEVEL_BG = 131;
  CONFIG_KEY_UP[(signed long int)0] = 84;
  CONFIG_KEY_DOWN[(signed long int)0] = 85;
  CONFIG_KEY_LEFT[(signed long int)0] = 82;
  CONFIG_KEY_RIGHT[(signed long int)0] = 83;
  CONFIG_TEAM_COLOR[(signed long int)0] = 0;
  CONFIG_CONTROL_TYPE[(signed long int)0] = 1;
  memset((void *)CONFIG_PLAYER_NAME[(signed long int)0], 0, sizeof(char [11l]) /*11ul*/ );
  __builtin_strncpy(CONFIG_PLAYER_NAME[(signed long int)0], "Napoleon", sizeof(char [11l]) /*11ul*/  - (unsigned long int)1);
  CONFIG_PLAYER_NAME[(signed long int)0][(signed long int)(sizeof(char [11l]) /*11ul*/  - (unsigned long int)1)] = (char)0;
  CONFIG_KEY_UP[(signed long int)1] = 9;
  CONFIG_KEY_DOWN[(signed long int)1] = 11;
  CONFIG_KEY_LEFT[(signed long int)1] = 10;
  CONFIG_KEY_RIGHT[(signed long int)1] = 12;
  CONFIG_TEAM_COLOR[(signed long int)1] = 4;
  CONFIG_CONTROL_TYPE[(signed long int)1] = 0;
  memset((void *)CONFIG_PLAYER_NAME[(signed long int)1], 0, sizeof(char [11l]) /*11ul*/ );
  __builtin_strncpy(CONFIG_PLAYER_NAME[(signed long int)1], "Clovis", sizeof(char [11l]) /*11ul*/  - (unsigned long int)1);
  CONFIG_PLAYER_NAME[(signed long int)1][(signed long int)(sizeof(char [11l]) /*11ul*/  - (unsigned long int)1)] = (char)0;
  CONFIG_KEY_UP[(signed long int)2] = 84;
  CONFIG_KEY_DOWN[(signed long int)2] = 85;
  CONFIG_KEY_LEFT[(signed long int)2] = 82;
  CONFIG_KEY_RIGHT[(signed long int)2] = 83;
  CONFIG_TEAM_COLOR[(signed long int)2] = 8;
  CONFIG_CONTROL_TYPE[(signed long int)2] = 0;
  memset((void *)CONFIG_PLAYER_NAME[(signed long int)2], 0, sizeof(char [11l]) /*11ul*/ );
  __builtin_strncpy(CONFIG_PLAYER_NAME[(signed long int)2], "Henri IV", sizeof(char [11l]) /*11ul*/  - (unsigned long int)1);
  CONFIG_PLAYER_NAME[(signed long int)2][(signed long int)(sizeof(char [11l]) /*11ul*/  - (unsigned long int)1)] = (char)0;
  CONFIG_KEY_UP[(signed long int)3] = 17;
  CONFIG_KEY_DOWN[(signed long int)3] = 1;
  CONFIG_KEY_LEFT[(signed long int)3] = 26;
  CONFIG_KEY_RIGHT[(signed long int)3] = 24;
  CONFIG_TEAM_COLOR[(signed long int)3] = 6;
  CONFIG_CONTROL_TYPE[(signed long int)3] = 0;
  memset((void *)CONFIG_PLAYER_NAME[(signed long int)3], 0, sizeof(char [11l]) /*11ul*/ );
  __builtin_strncpy(CONFIG_PLAYER_NAME[(signed long int)3], "Cesar", sizeof(char [11l]) /*11ul*/  - (unsigned long int)1);
  CONFIG_PLAYER_NAME[(signed long int)3][(signed long int)(sizeof(char [11l]) /*11ul*/  - (unsigned long int)1)] = (char)0;
  CONFIG_KEY_UP[(signed long int)4] = 45;
  CONFIG_KEY_DOWN[(signed long int)4] = 42;
  CONFIG_KEY_LEFT[(signed long int)4] = 41;
  CONFIG_KEY_RIGHT[(signed long int)4] = 43;
  CONFIG_TEAM_COLOR[(signed long int)4] = 10;
  CONFIG_CONTROL_TYPE[(signed long int)4] = 0;
  memset((void *)CONFIG_PLAYER_NAME[(signed long int)4], 0, sizeof(char [11l]) /*11ul*/ );
  __builtin_strncpy(CONFIG_PLAYER_NAME[(signed long int)4], "Geronimo", sizeof(char [11l]) /*11ul*/  - (unsigned long int)1);
  CONFIG_PLAYER_NAME[(signed long int)4][(signed long int)(sizeof(char [11l]) /*11ul*/  - (unsigned long int)1)] = (char)0;
  CONFIG_KEY_UP[(signed long int)5] = 124;
  CONFIG_KEY_DOWN[(signed long int)5] = 126;
  CONFIG_KEY_LEFT[(signed long int)5] = 127;
  CONFIG_KEY_RIGHT[(signed long int)5] = 125;
  CONFIG_TEAM_COLOR[(signed long int)5] = 3;
  CONFIG_CONTROL_TYPE[(signed long int)5] = 2;
  memset((void *)CONFIG_PLAYER_NAME[(signed long int)5], 0, sizeof(char [11l]) /*11ul*/ );
  __builtin_strncpy(CONFIG_PLAYER_NAME[(signed long int)5], "Attila", sizeof(char [11l]) /*11ul*/  - (unsigned long int)1);
  CONFIG_PLAYER_NAME[(signed long int)5][(signed long int)(sizeof(char [11l]) /*11ul*/  - (unsigned long int)1)] = (char)0;
  CONFIG_INFO_BAR = 1;
  CONFIG_MOUSE_GAP = 4;
  CONFIG_JOYSTICK_ON = 1;
  CONFIG_PAGE_FLIP = 0;
  CONFIG_LANGUAGE = -1;
  CONFIG_WAVE_ON = 0;
  CONFIG_FRAMES_PER_SEC_LIMIT = 6;
  CONFIG_ROUNDS_PER_SEC_LIMIT = 4;
  memset((void *)CONFIG_SERVER_ADDRESS, 0, sizeof(char [51l]) /*51ul*/ );
  __builtin_strncpy(CONFIG_SERVER_ADDRESS, "127.0.0.1", sizeof(char [51l]) /*51ul*/  - (unsigned long int)1);
  CONFIG_SERVER_ADDRESS[(signed long int)(sizeof(char [51l]) /*51ul*/  - (unsigned long int)1)] = (char)0;
  CONFIG_SERVER_PORT = 8035;
  memset((void *)CONFIG_PASSWORD, 0, sizeof(char [21l]) /*21ul*/ );
  __builtin_strncpy(CONFIG_PASSWORD, "toto", sizeof(char [21l]) /*21ul*/  - (unsigned long int)1);
  CONFIG_PASSWORD[(signed long int)(sizeof(char [21l]) /*21ul*/  - (unsigned long int)1)] = (char)0;
  CONFIG_USE_DEFAULT_TEXTURE = 1;
  load_default_rules();
}

// load_default_rules
// file config.c line 318
void load_default_rules(void)
{
  CONFIG_CURSOR_INCREASE_SPEED = 0;
  CONFIG_FIGHTER_ATTACK = 8;
  CONFIG_FIGHTER_DEFENSE = 8;
  CONFIG_FIGHTER_NEW_HEALTH = 8;
  CONFIG_NUMBER_INFLUENCE = 8;
  CONFIG_FIGHTER_NUMBER = 16;
  CONFIG_GAME_TIME = 8;
  CONFIG_CPU_ADVANTAGE = 0;
  CONFIG_CPU_VS_HUMAN = 1;
  CONFIG_ASM_ALGORITHM = 1;
  CONFIG_MIN_MAP_RES = 4;
  CONFIG_ALLOW_NETWORK_BOTS = 0;
}

// load_disk_options
// file config.c line 336
static signed int load_disk_options(void)
{
  char number_string[2l] = { (char)48, (char)0 };
  signed int i;
  load_default_options();
  set_config_file(STARTUP_CFG_PATH);
  signed int return_value_get_config_int_4;
  return_value_get_config_int_4=get_config_int("MAIN", "DUMMY", 0);
  if(return_value_get_config_int_4 == 5003000)
  {
    CONFIG_GFX_GAME=get_config_int("MAIN", "GFX_GAME", CONFIG_GFX_GAME);
    CONFIG_GFX_MENU=get_config_int("MAIN", "GFX_MENU", CONFIG_GFX_MENU);
    CONFIG_FULLSCREEN=get_config_int("MAIN", "FULLSCREEN", CONFIG_FULLSCREEN);
    CONFIG_VIEWPORT_SIZE=get_config_int("MAIN", "VIEWPORT_SIZE", CONFIG_VIEWPORT_SIZE);
    i = 0;
    for( ; !(i >= 4); i = i + 1)
    {
      number_string[(signed long int)0] = (char)(48 + i);
      CONFIG_WAVE_NUMBER[(signed long int)i]=get_config_int("WAVE_NUMBER", number_string, CONFIG_WAVE_NUMBER[(signed long int)i]);
      CONFIG_WAVE_AMPLI[(signed long int)i]=get_config_int("WAVE_AMPLI", number_string, CONFIG_WAVE_AMPLI[(signed long int)i]);
      CONFIG_WAVE_SPEED[(signed long int)i]=get_config_int("WAVE_SPEED", number_string, CONFIG_WAVE_SPEED[(signed long int)i]);
    }
    CONFIG_BRIGHTNESS=get_config_int("MAIN", "BRIGHTNESS", CONFIG_BRIGHTNESS);
    CONFIG_CURSOR_INCREASE_SPEED=get_config_int("MAIN", "CURSOR_INCREASE_SPEED", CONFIG_CURSOR_INCREASE_SPEED);
    CONFIG_FIGHTER_ATTACK=get_config_int("MAIN", "FIGHTER_ATTACK", CONFIG_FIGHTER_ATTACK);
    CONFIG_FIGHTER_DEFENSE=get_config_int("MAIN", "FIGHTER_DEFENSE", CONFIG_FIGHTER_DEFENSE);
    CONFIG_FIGHTER_NEW_HEALTH=get_config_int("MAIN", "FIGHTER_NEW_HEALTH", CONFIG_FIGHTER_NEW_HEALTH);
    CONFIG_NUMBER_INFLUENCE=get_config_int("MAIN", "NUMBER_INFLUENCE", CONFIG_NUMBER_INFLUENCE);
    CONFIG_SFX_VOLUME=get_config_int("MAIN", "SFX_VOLUME", CONFIG_SFX_VOLUME);
    CONFIG_CLICK_VOLUME=get_config_int("MAIN", "CLICK_VOLUME", CONFIG_CLICK_VOLUME);
    CONFIG_WATER_VOLUME_MENU=get_config_int("MAIN", "WATER_VOLUME_MENU", CONFIG_WATER_VOLUME_MENU);
    CONFIG_WATER_VOLUME_GAME=get_config_int("MAIN", "WATER_VOLUME_GAME", CONFIG_WATER_VOLUME_GAME);
    CONFIG_MUSIC_VOLUME=get_config_int("MAIN", "MUSIC_VOLUME", CONFIG_MUSIC_VOLUME);
    CONFIG_LEVEL_MAP=get_config_int("MAIN", "LEVEL_MAP", CONFIG_LEVEL_MAP);
    CONFIG_LEVEL_FG=get_config_int("MAIN", "LEVEL_FG", CONFIG_LEVEL_FG);
    CONFIG_LEVEL_BG=get_config_int("MAIN", "LEVEL_BG", CONFIG_LEVEL_BG);
    CONFIG_FIGHTER_NUMBER=get_config_int("MAIN", "FIGHTER_NUMBER", CONFIG_FIGHTER_NUMBER);
    i = 0;
    for( ; !(i >= 6); i = i + 1)
    {
      number_string[(signed long int)0] = (char)(48 + i);
      CONFIG_KEY_UP[(signed long int)i]=get_config_int("KEY_UP", number_string, CONFIG_KEY_UP[(signed long int)i]);
      CONFIG_KEY_LEFT[(signed long int)i]=get_config_int("KEY_LEFT", number_string, CONFIG_KEY_LEFT[(signed long int)i]);
      CONFIG_KEY_DOWN[(signed long int)i]=get_config_int("KEY_DOWN", number_string, CONFIG_KEY_DOWN[(signed long int)i]);
      CONFIG_KEY_RIGHT[(signed long int)i]=get_config_int("KEY_RIGHT", number_string, CONFIG_KEY_RIGHT[(signed long int)i]);
      CONFIG_TEAM_COLOR[(signed long int)i]=get_config_int("TEAM_COLOR", number_string, CONFIG_TEAM_COLOR[(signed long int)i]);
      CONFIG_CONTROL_TYPE[(signed long int)i]=get_config_int("CONTROL_TYPE", number_string, CONFIG_CONTROL_TYPE[(signed long int)i]);
      const char *return_value_get_config_string_1;
      return_value_get_config_string_1=get_config_string("PLAYER_NAME", number_string, CONFIG_PLAYER_NAME[(signed long int)i]);
      __builtin_strncpy(CONFIG_PLAYER_NAME[(signed long int)i], return_value_get_config_string_1, (unsigned long int)10);
      CONFIG_PLAYER_NAME[(signed long int)i][(signed long int)10] = (char)0;
    }
    CONFIG_GAME_TIME=get_config_int("MAIN", "GAME_TIME", CONFIG_GAME_TIME);
    CONFIG_INFO_BAR=get_config_int("MAIN", "INFO_BAR", CONFIG_INFO_BAR);
    CONFIG_MOUSE_GAP=get_config_int("MAIN", "MOUSE_GAP", CONFIG_MOUSE_GAP);
    CONFIG_JOYSTICK_ON=get_config_int("MAIN", "JOYSTICK_ON", CONFIG_JOYSTICK_ON);
    CONFIG_CPU_ADVANTAGE=get_config_int("MAIN", "CPU_ADVANTAGE", CONFIG_CPU_ADVANTAGE);
    CONFIG_CPU_VS_HUMAN=get_config_int("MAIN", "CPU_VS_HUMAN", CONFIG_CPU_VS_HUMAN);
    CONFIG_PAGE_FLIP=get_config_int("MAIN", "PAGE_FLIP", CONFIG_PAGE_FLIP);
    CONFIG_LANGUAGE=get_config_int("MAIN", "LANGUAGE", CONFIG_LANGUAGE);
    CONFIG_WAVE_ON=get_config_int("MAIN", "WAVE_ON", CONFIG_WAVE_ON);
    CONFIG_FRAMES_PER_SEC_LIMIT=get_config_int("MAIN", "FRAMES_PER_SEC_LIMIT", CONFIG_FRAMES_PER_SEC_LIMIT);
    CONFIG_ROUNDS_PER_SEC_LIMIT=get_config_int("MAIN", "ROUNDS_PER_SEC_LIMIT", CONFIG_ROUNDS_PER_SEC_LIMIT);
    const char *return_value_get_config_string_2;
    return_value_get_config_string_2=get_config_string("MAIN", "SERVER_ADDRESS", CONFIG_SERVER_ADDRESS);
    __builtin_strncpy(CONFIG_SERVER_ADDRESS, return_value_get_config_string_2, sizeof(char [51l]) /*51ul*/ );
    CONFIG_SERVER_ADDRESS[(signed long int)(sizeof(char [51l]) /*51ul*/  - (unsigned long int)1)] = (char)0;
    CONFIG_SERVER_PORT=get_config_int("MAIN", "SERVER_PORT", CONFIG_SERVER_PORT);
    CONFIG_ASM_ALGORITHM=get_config_int("MAIN", "ASM_ALGORITHM", CONFIG_ASM_ALGORITHM);
    const char *return_value_get_config_string_3;
    return_value_get_config_string_3=get_config_string("MAIN", "PASSWORD", CONFIG_PASSWORD);
    __builtin_strncpy(CONFIG_PASSWORD, return_value_get_config_string_3, sizeof(char [21l]) /*21ul*/ );
    CONFIG_PASSWORD[(signed long int)(sizeof(char [21l]) /*21ul*/  - (unsigned long int)1)] = (char)0;
    CONFIG_MIN_MAP_RES=get_config_int("MAIN", "MIN_MAP_RES", CONFIG_MIN_MAP_RES);
    CONFIG_USE_DEFAULT_TEXTURE=get_config_int("MAIN", "USE_DEFAULT_TEXTURE", CONFIG_USE_DEFAULT_TEXTURE);
    CONFIG_ALLOW_NETWORK_BOTS=get_config_int("MAIN", "ALLOW_NETWORK_BOTS", CONFIG_ALLOW_NETWORK_BOTS);
    return 1;
  }

  else
    return 0;
}

// lock_sound
// file disk.c line 126
static void lock_sound(struct SAMPLE *smp)
{
  smp = smp;
}

// log_beep
// file logcli.c line 253
void log_beep()
{
  lw_mutex_lock(&LOG_MUTEX);
  if(!(LW_LOG_BEEP == 0))
    fprintf(stderr, "\a");

  lw_mutex_unlock(&LOG_MUTEX);
}

// log_exit
// file log.h line 69
void log_exit(void)
{
  lw_mutex_lock(&LOG_MUTEX);
  lw_mutex_unlock(&LOG_MUTEX);
}

// log_flush
// file log.h line 75
void log_flush()
{
  lw_mutex_lock(&LOG_MUTEX);
  fflush(stdout);
  lw_mutex_unlock(&LOG_MUTEX);
}

// log_init
// file log.h line 68
void log_init(void)
{
  lw_mutex_lock(&LOG_MUTEX);
  lw_mutex_unlock(&LOG_MUTEX);
}

// log_print_int
// file log.h line 71
void log_print_int(signed int i)
{
  lw_mutex_lock(&LOG_MUTEX);
  printf("%d", i);
  lw_mutex_unlock(&LOG_MUTEX);
}

// log_print_str
// file log.h line 70
void log_print_str(char *str)
{
  lw_mutex_lock(&LOG_MUTEX);
  printf("%s", str);
  lw_mutex_unlock(&LOG_MUTEX);
}

// log_println
// file log.h line 72
void log_println()
{
  lw_mutex_lock(&LOG_MUTEX);
  printf("\n");
  lw_mutex_unlock(&LOG_MUTEX);
}

// log_println_int
// file logcli.c line 214
void log_println_int(signed int i)
{
  lw_mutex_lock(&LOG_MUTEX);
  printf("%d\n", i);
  lw_mutex_unlock(&LOG_MUTEX);
}

// log_println_str
// file log.h line 73
void log_println_str(char *str)
{
  lw_mutex_lock(&LOG_MUTEX);
  printf("%s\n", str);
  lw_mutex_unlock(&LOG_MUTEX);
}

// log_set_server_mode
// file logcli.c line 277
void log_set_server_mode(signed int mode)
{
  mode = mode;
}

// logic
// file game.c line 557
static void logic(void)
{
  if(PAUSE_ON == 0)
  {
    move_all_cursors();
    apply_all_cursor();
  }

  start_profile(0);
  if(PAUSE_ON == 0)
    spread_single_gradient();

  stop_profile(0);
  start_profile(1);
  if(PAUSE_ON == 0)
    move_fighters();

  stop_profile(1);
  if(PAUSE_ON == 0)
    check_loose_team();

  GLOBAL_CLOCK = GLOBAL_CLOCK + 1;
}

// lw_about
// file about.c line 79
signed int lw_about(void)
{
  struct DIALOG d[9l];
  signed int i;
  signed int choix = 4;
  signed int retour = 0;
  memset((void *)d, 0, sizeof(struct DIALOG [9l]) /*648ul*/ );
  while(retour == 0)
  {
    i = 0;
    for( ; !(i >= 4); i = i + 1)
      standard_button(d + (signed long int)i + (signed long int)4, 0, i, 1, 4);
    quick_buttons(d);
    char *return_value_lw_lang_string_1;
    return_value_lw_lang_string_1=lw_lang_string(87);
    d[(signed long int)4].dp = (void *)return_value_lw_lang_string_1;
    char *return_value_lw_lang_string_2;
    return_value_lw_lang_string_2=lw_lang_string(88);
    d[(signed long int)5].dp = (void *)return_value_lw_lang_string_2;
    char *return_value_lw_lang_string_3;
    return_value_lw_lang_string_3=lw_lang_string(89);
    d[(signed long int)6].dp = (void *)return_value_lw_lang_string_3;
    char *return_value_lw_lang_string_4;
    return_value_lw_lang_string_4=lw_lang_string(90);
    d[(signed long int)7].dp = (void *)return_value_lw_lang_string_4;
    d[(signed long int)8].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
    choix=my_do_dialog(d, choix);
    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 2)
        goto __CPROVER_DUMP_L5;

      if(choix == 0)
        goto __CPROVER_DUMP_L6;

      if(choix == 1)
        goto __CPROVER_DUMP_L9;

      if(choix == 4)
        goto __CPROVER_DUMP_L10;

      if(choix == 5)
        goto __CPROVER_DUMP_L11;

      if(choix == 6)
        goto __CPROVER_DUMP_L12;

      if(choix == 7)
        goto __CPROVER_DUMP_L13;

    }

    else
    {
      retour = 1;
      goto __CPROVER_DUMP_L14;

    __CPROVER_DUMP_L5:
      ;
      retour = -1;
      goto __CPROVER_DUMP_L14;

    __CPROVER_DUMP_L6:
      ;
      signed int return_value_confirm_quit_5;
      return_value_confirm_quit_5=confirm_quit();
      if(!(return_value_confirm_quit_5 == 0))
        retour = -2;

      else
        display_back_image();
      goto __CPROVER_DUMP_L14;

    __CPROVER_DUMP_L9:
      ;
      retour = -3;
      goto __CPROVER_DUMP_L14;

    __CPROVER_DUMP_L10:
      ;
      char *return_value_lw_lang_string_6;
      return_value_lw_lang_string_6=lw_lang_string(2);
      retour=display_help(return_value_lw_lang_string_6);
      goto __CPROVER_DUMP_L14;

    __CPROVER_DUMP_L11:
      ;
      char *return_value_lw_lang_string_7;
      return_value_lw_lang_string_7=lw_lang_string(3);
      retour=display_help(return_value_lw_lang_string_7);
      goto __CPROVER_DUMP_L14;

    __CPROVER_DUMP_L12:
      ;
      char *return_value_lw_lang_string_8;
      return_value_lw_lang_string_8=lw_lang_string(4);
      retour=display_help(return_value_lw_lang_string_8);
      goto __CPROVER_DUMP_L14;

    __CPROVER_DUMP_L13:
      ;
      char *return_value_lw_lang_string_9;
      return_value_lw_lang_string_9=lw_lang_string(5);
      retour=display_help(return_value_lw_lang_string_9);
    }

  __CPROVER_DUMP_L14:
    ;
  }
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// lw_asm_check_struct_align
// file asm.c line 97
extern signed int lw_asm_check_struct_align(void)
{
  signed int result = 1;
  if(result == 0)
  {
    log_println_str("WARNING!!!");
    log_println_str("Liquid War might crash unexpectedly... Please read previous error messages.");
    log_println();
  }

  return result;
}

// lw_basicopt_legal_info
// file basicopt.c line 121
void lw_basicopt_legal_info(char *name)
{
  log_println();
  log_println_str(name);
  log_println();
  log_println_str("v5.6.4 compiled on Jan 25 2016 at 05:34:18");
  log_println_str("Copyright (C) 1998-2007 Christian Mauduit");
  log_println();
  log_println_str("This program is free software; you can redistribute it and/or modify");
  log_println_str("it under the terms of the GNU General Public License as published by");
  log_println_str("the Free Software Foundation; either version 2 of the License, or");
  log_println_str("(at your option) any later version.");
  log_println();
  log_println_str("This program is distributed in the hope that it will be useful,");
  log_println_str("but WITHOUT ANY WARRANTY; without even the implied warranty of");
  log_println_str("MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the");
  log_println_str("GNU General Public License for more details.");
  log_println();
  log_println_str("You should have received a copy of the GNU General Public License");
  log_println_str("along with this program; if not, write to the Free Software");
  log_println_str("Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA");
  log_println();
  log_println_str("Liquid War homepage : http://www.ufoot.org/liquidwar/v5");
  log_println_str("Contact author      : ufoot@ufoot.org");
}

// lw_basicopt_process
// file basicopt.c line 74
signed int lw_basicopt_process(char *name)
{
  signed int result = 1;
  signed int return_value_exist_argument_1;
  return_value_exist_argument_1=exist_argument("v");
  _Bool tmp_if_expr_3;
  signed int return_value_exist_argument_2;
  if(!(return_value_exist_argument_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_exist_argument_2=exist_argument("-version");
    tmp_if_expr_3 = return_value_exist_argument_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    result = 0;
    log_println_str("5.6.4");
  }

  signed int return_value_exist_argument_4;
  return_value_exist_argument_4=exist_argument("h");
  _Bool tmp_if_expr_6;
  signed int return_value_exist_argument_5;
  if(!(return_value_exist_argument_4 == 0))
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_exist_argument_5=exist_argument("-help");
    tmp_if_expr_6 = return_value_exist_argument_5 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_8;
  signed int return_value_exist_argument_7;
  if(tmp_if_expr_6)
    tmp_if_expr_8 = (_Bool)1;

  else
  {
    return_value_exist_argument_7=exist_argument("?");
    tmp_if_expr_8 = return_value_exist_argument_7 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_8)
  {
    result = 0;
    lw_basicopt_legal_info(name);
    log_println();
    log_println_str("Documentation is available in HTML, ascii text, PostScript, PDF... Read it 8-)");
  }

  signed int return_value_exist_argument_9;
  return_value_exist_argument_9=exist_argument("netlog");
  if(!(return_value_exist_argument_9 == 0))
    LW_SOCK_LOG = 1;

  signed int return_value_exist_argument_10;
  return_value_exist_argument_10=exist_argument("nobeep");
  if(!(return_value_exist_argument_10 == 0))
    LW_LOG_BEEP = 0;

  return result;
}

// lw_capture_dump_game
// file capture.c line 163
extern signed int lw_capture_dump_game()
{
  signed int result = 1;
  char buffer[100l];
  struct BITMAP *screenshot;
  signed int tmp_post_1;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_3;
  if(!(LW_CAPTURE_MODE == 0))
  {
    memset((void *)buffer, 0, sizeof(char [100l]) /*100ul*/ );
    static signed int frame_number = 0;
    tmp_post_1 = frame_number;
    frame_number = frame_number + 1;
    snprintf(buffer, sizeof(char [100l]) /*100ul*/  - (unsigned long int)1, "lw%06d.bmp", tmp_post_1);
    buffer[(signed long int)(sizeof(char [100l]) /*100ul*/  - (unsigned long int)1)] = (char)0;
    log_print_str("Dumping video output to \"");
    log_print_str(buffer);
    log_print_str("\"");
    if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
      tmp_if_expr_2 = gfx_driver->w;

    else
      tmp_if_expr_2 = 0;
    if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
      tmp_if_expr_3 = gfx_driver->h;

    else
      tmp_if_expr_3 = 0;
    screenshot=create_sub_bitmap(screen, 0, PAGE_FLIP_H, tmp_if_expr_2, tmp_if_expr_3);
    if(!(screenshot == ((struct BITMAP *)NULL)))
    {
      signed int return_value_save_bitmap_4;
      return_value_save_bitmap_4=save_bitmap(buffer, screenshot, GLOBAL_PALETTE);
      result = (signed int)!(return_value_save_bitmap_4 != 0);
      destroy_bitmap(screenshot);
    }

    else
      result = 0;
    display_success(result);
  }

  return result;
}

// lw_capture_dump_menu
// file capture.c line 112
extern signed int lw_capture_dump_menu()
{
  signed int result = 1;
  signed int dummy;
  signed int return_value_get_ticker_1;
  return_value_get_ticker_1=get_ticker();
  static signed int last_dump_time = 0;
  if(return_value_get_ticker_1 >= DISPLAY_DELAY_MIN[(signed long int)CONFIG_FRAMES_PER_SEC_LIMIT] + last_dump_time)
  {
    last_dump_time=get_ticker();
    if(!(LW_CAPTURE_MODE == 0))
      lw_capture_dump_game();

  }

  if(!(key[55l] == 0))
  {
    while(!(key[55l] == 0))
    {
      dummy=keypressed();
      rest((unsigned int)10);
    }
    LW_CAPTURE_MODE = (signed int)!(LW_CAPTURE_MODE != 0);
  }

  return result;
}

// lw_capture_get_mode
// file capture.c line 90
extern signed int lw_capture_get_mode()
{
  return LW_CAPTURE_MODE;
}

// lw_capture_set_mode
// file capture.c line 100
extern void lw_capture_set_mode(signed int mode)
{
  LW_CAPTURE_MODE = mode;
}

// lw_chat_get
// file chat.c line 135
signed int lw_chat_get(struct anonymous_13 *history, struct anonymous_24 *message, signed int i)
{
  signed int result = 0;
  memset((void *)message, 0, sizeof(struct anonymous_24) /*92ul*/ );
  if(i >= 0)
  {
    if(!(i >= history->n))
    {
      memcpy((void *)message, (const void *)&history->messages[(signed long int)i], sizeof(struct anonymous_24) /*92ul*/ );
      result = 1;
    }

  }

  return result;
}

// lw_chat_pop
// file chat.c line 105
signed int lw_chat_pop(struct anonymous_13 *history, struct anonymous_24 *message)
{
  signed int result = 0;
  signed int i;
  memset((void *)message, 0, sizeof(struct anonymous_24) /*92ul*/ );
  if(history->n >= 1)
  {
    memcpy((void *)message, (const void *)&history->messages[(signed long int)0], sizeof(struct anonymous_24) /*92ul*/ );
    i = 1;
    for( ; !(i >= history->n); i = i + 1)
      memcpy((void *)&history->messages[(signed long int)(i - 1)], (const void *)&history->messages[(signed long int)i], sizeof(struct anonymous_24) /*92ul*/ );
    history->n = history->n - 1;
    result = 1;
  }

  return result;
}

// lw_chat_push
// file chat.c line 79
void lw_chat_push(struct anonymous_13 *history, char *author, char *content)
{
  struct anonymous_24 temp;
  while(history->n >= 20)
    lw_chat_pop(history, &temp);
  __builtin_strncpy(history->messages[(signed long int)history->n].author, author, (unsigned long int)10);
  history->messages[(signed long int)history->n].author[(signed long int)10] = (char)0;
  __builtin_strncpy(history->messages[(signed long int)history->n].content, content, (unsigned long int)80);
  history->messages[(signed long int)history->n].content[(signed long int)80] = (char)0;
  history->n = history->n + 1;
}

// lw_chat_reset
// file chat.c line 69
void lw_chat_reset(struct anonymous_13 *history)
{
  memset((void *)history, 0, sizeof(struct anonymous_13) /*1844ul*/ );
}

// lw_checksum_calc
// file checksum.c line 81
signed int lw_checksum_calc(struct anonymous_21 *army, signed int army_size)
{
  unsigned int checksum = (unsigned int)0;
  signed int i;
  unsigned short int rval = (unsigned short int)55665;
  unsigned short int cst1 = (unsigned short int)52845;
  unsigned short int cst2 = (unsigned short int)22719;
  unsigned char cipher;
  unsigned char value;
  struct anonymous_21 *f;
  if(GLOBAL_CLOCK % 100 == 0)
  {
    i = 0;
    for( ; !(i >= army_size); i = i + 1)
    {
      f = army + (signed long int)i;
      value = (unsigned char)((unsigned int)0xFF & (unsigned int)f->x + (unsigned int)f->y + (unsigned int)f->health + (unsigned int)f->team + (unsigned int)f->last_dir);
      cipher = (unsigned char)((signed int)value ^ (signed int)rval >> 8);
      rval = (unsigned short int)(((signed int)cipher + (signed int)rval) * (signed int)cst1 + (signed int)cst2);
      checksum = checksum + (unsigned int)cipher;
    }
  }

  return (signed int)checksum;
}

// lw_config_set_current_rules_to_default
// file config.c line 627
void lw_config_set_current_rules_to_default(void)
{
  struct anonymous_4 *config = &LW_CONFIG_CURRENT_RULES;
  config->cursor_increase_speed = CONFIG_CURSOR_INCREASE_SPEED;
  config->fighter_attack = CONFIG_FIGHTER_ATTACK;
  config->fighter_defense = CONFIG_FIGHTER_DEFENSE;
  config->fighter_new_health = CONFIG_FIGHTER_NEW_HEALTH;
  config->number_influence = CONFIG_NUMBER_INFLUENCE;
  config->fighter_number = CONFIG_FIGHTER_NUMBER;
  config->game_time = CONFIG_GAME_TIME;
  config->cpu_advantage = CONFIG_CPU_ADVANTAGE;
  config->cpu_vs_human = CONFIG_CPU_VS_HUMAN;
  config->asm_algorithm = (signed int)(CONFIG_ASM_ALGORITHM != 0 && STARTUP_ASM != 0);
  config->min_map_res = CONFIG_MIN_MAP_RES;
}

// lw_connect_menu
// file connect.c line 125
signed int lw_connect_menu(signed int sock)
{
  struct DIALOG d[12l];
  struct DIALOG_PLAYER *dp;
  signed int choix = 4;
  signed int retour = 0;
  char buf_waited_teams[200l];
  char buf_connected_players[1200l];
  char buf_chat_history[4000l];
  char buf_chat_message[81l];
  signed int first_display = 1;
  signed int first_getinfo = 1;
  struct anonymous_25 *data;
  signed int network_error = 0;
  signed int hide_start_button = 0;
  signed int connected_teams_prev = -1;
  memset((void *)d, 0, sizeof(struct DIALOG [12l]) /*864ul*/ );
  buf_waited_teams[(signed long int)0] = (char)0;
  buf_connected_players[(signed long int)0] = (char)0;
  buf_chat_history[(signed long int)0] = (char)0;
  buf_chat_message[(signed long int)0] = (char)0;
  data = &GLOBAL_CONNECT_DATA;
  memset((void *)data, 0, sizeof(struct anonymous_25) /*2080ul*/ );
  data->sock = sock;
  data->waited_teams = 6;
  LW_NETWORK_ON = 1;
  signed int return_value_my_update_dialog_4;
  while(retour == 0)
  {
    standard_button(d + (signed long int)4, 1, 0, 2, 10);
    standard_button(d + (signed long int)6, 1, 5, 2, 10);
    standard_button(d + (signed long int)8, 1, 7, 2, 10);
    standard_button(d + (signed long int)9, 1, 7, 2, 10);
    standard_button(d + (signed long int)10, 1, 8, 2, 10);
    quick_buttons(d);
    d[(signed long int)4].proc = my_textbox_proc;
    d[(signed long int)5].proc = my_textbox_proc;
    d[(signed long int)7].proc = my_textbox_proc;
    d[(signed long int)8].proc = d_box_proc;
    d[(signed long int)9].proc = my_edit_proc;
    position_players_list(d + (signed long int)5);
    position_chat_history(d + (signed long int)7);
    d[(signed long int)4].w = d[(signed long int)7].w;
    d[(signed long int)8].w = d[(signed long int)7].w;
    d[(signed long int)9].w = d[(signed long int)7].w;
    d[(signed long int)9].x = d[(signed long int)9].x + 1;
    d[(signed long int)9].y = d[(signed long int)9].y + 1;
    d[(signed long int)9].w = d[(signed long int)9].w - 2;
    d[(signed long int)9].h = d[(signed long int)9].h - 2;
    d[(signed long int)4].dp = (void *)buf_waited_teams;
    d[(signed long int)5].dp = (void *)buf_connected_players;
    char *return_value_lw_lang_string_1;
    return_value_lw_lang_string_1=lw_lang_string(113);
    d[(signed long int)6].dp = (void *)return_value_lw_lang_string_1;
    d[(signed long int)7].dp = (void *)buf_chat_history;
    d[(signed long int)9].dp = (void *)buf_chat_message;
    d[(signed long int)9].d1 = 80;
    d[(signed long int)9].flags = 1;
    char *return_value_lw_lang_string_2;
    return_value_lw_lang_string_2=lw_lang_string(117);
    d[(signed long int)10].dp = (void *)return_value_lw_lang_string_2;
    if(!(hide_start_button == 0))
    {
      d[(signed long int)6].proc = my_textbox_proc;
      char *return_value_lw_lang_string_3;
      return_value_lw_lang_string_3=lw_lang_string(114);
      d[(signed long int)6].dp = (void *)return_value_lw_lang_string_3;
      d[(signed long int)1].flags = 16;
    }

    d[(signed long int)11].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
    if(!(first_display == 0))
    {
      display_back_image();
      first_display = 0;
    }

    dp=my_init_dialog(d, choix);
    do
    {
      return_value_my_update_dialog_4=my_update_dialog(dp);
      if(return_value_my_update_dialog_4 == 0)
        break;

      if(!(data->finished == 0))
        break;

      show_mouse(screen);
      if(data->thread_running == 0)
      {
        if(data->finished == 0)
        {
          if(first_getinfo == 0)
          {
            if(data->result == 0)
              network_error = 1;

            else
              update_connect_menu(d, data->waited_teams, data->team_start_info, &data->chat_history, &connected_teams_prev);
          }

          data->thread_running = 1;
          signed int return_value_lw_thread_start_5;
          return_value_lw_thread_start_5=lw_thread_start(connect_on_server_keepalive, (void *)data);
          if(!(return_value_lw_thread_start_5 == 0))
            first_getinfo = 0;

          else
            data->thread_running = 0;
        }

      }

      rest((unsigned int)10);
    }
    while((_Bool)1);
    choix=shutdown_dialog(dp);
    if(!(network_error == 0))
    {
      error_network_problem();
      lw_sock_close(&data->sock);
      retour = 1;
    }

    else
      if(data->waited_teams == 0)
        retour = -4;

      else
        if(!(choix == 3) && !(choix == -1))
        {
          if(choix == 2)
            goto __CPROVER_DUMP_L14;

          if(choix == 0)
            goto __CPROVER_DUMP_L15;

          if(choix == 1 || choix == 6)
            goto __CPROVER_DUMP_L18;

          if(choix == 9 || choix == 10)
            goto __CPROVER_DUMP_L20;

        }

        else
        {
          lw_sock_close(&data->sock);
          retour = 1;
          goto __CPROVER_DUMP_L22;

        __CPROVER_DUMP_L14:
          ;
          lw_sock_close(&data->sock);
          retour = -1;
          goto __CPROVER_DUMP_L22;

        __CPROVER_DUMP_L15:
          ;
          lw_sock_close(&data->sock);
          signed int return_value_confirm_quit_6;
          return_value_confirm_quit_6=confirm_quit();
          if(!(return_value_confirm_quit_6 == 0))
            retour = -2;

          else
            display_back_image();
          goto __CPROVER_DUMP_L22;

        __CPROVER_DUMP_L18:
          ;
          if(data->waited_teams >= 1)
          {
            data->force_start = 1;
            hide_start_button = 1;
            display_back_image();
          }

          goto __CPROVER_DUMP_L22;

        __CPROVER_DUMP_L20:
          ;
          unsigned long int return_value_strlen_7;
          return_value_strlen_7=strlen((const char *)d[(signed long int)9].dp);
          if(!(return_value_strlen_7 == 0ul))
          {
            if(data->chat_send == 0)
            {
              data->chat_send = 1;
              __builtin_strncpy(data->chat_buffer, (const char *)d[(signed long int)9].dp, (unsigned long int)80);
              data->chat_buffer[(signed long int)80] = (char)0;
              ((char *)d[(signed long int)9].dp)[(signed long int)0] = (char)0;
              d[(signed long int)9].d2 = 0;
              d[(signed long int)9].proc(3, d + (signed long int)9, 0);
            }

          }

        }

  __CPROVER_DUMP_L22:
    ;
  }
  while(!(data->thread_running == 0))
    rest((unsigned int)100);
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// lw_dnsutil_name_to_ip
// file dnsutil.c line 84
signed int lw_dnsutil_name_to_ip(char *ip, char *name)
{
  signed int result = 0;
  struct hostent *h;
  struct in_addr addr;
  memset((void *)ip, 0, (unsigned long int)16);
  h=gethostbyname(name);
  if(!(h == ((struct hostent *)NULL)))
  {
    if(h->h_addrtype == 2)
    {
      if(h->h_length >= 4)
      {
        if(!(*h->h_addr_list == ((char *)NULL)))
        {
          addr = *((struct in_addr *)h->h_addr_list[(signed long int)0]);
          char *return_value_inet_ntoa_1;
          return_value_inet_ntoa_1=inet_ntoa(addr);
          __builtin_strncpy(ip, return_value_inet_ntoa_1, (unsigned long int)(16 - 1));
          ip[(signed long int)(16 - 1)] = (char)0;
          result = 1;
        }

      }

    }

  }

  return result;
}

// lw_exec2_run
// file exec2.c line 69
signed int lw_exec2_run(char *file, char *commandline)
{
  signed int result = 0;
  file = file;
  commandline = commandline;
  signed int exit_code;
  exit_code=system(commandline);
  result = (signed int)(exit_code == 0);
  return result;
}

// lw_httputil_get_page
// file httputil.c line 104
signed int lw_httputil_get_page(char *content, char *url, signed int size)
{
  signed int result = 0;
  char ip[16l];
  char host[201l];
  char request[1001l];
  char data[1000l];
  signed int data_len;
  char *search;
  signed int sock;
  signed int empty_lines = 0;
  memset((void *)content, 0, (unsigned long int)size);
  memset((void *)host, 0, sizeof(char [201l]) /*201ul*/ );
  __builtin_strncpy(host, url, sizeof(char [201l]) /*201ul*/  - (unsigned long int)1);
  host[(signed long int)(sizeof(char [201l]) /*201ul*/  - (unsigned long int)1)] = (char)0;
  char *return_value___builtin_strchr_1;
  return_value___builtin_strchr_1=__builtin_strchr(host, 47);
  search = return_value___builtin_strchr_1;
  if(!(search == ((char *)NULL)))
    *search = (char)0;

  memset((void *)request, 0, sizeof(char [1001l]) /*1001ul*/ );
  snprintf(request, sizeof(char [1001l]) /*1001ul*/  - (unsigned long int)1, "GET http://%s HTTP/1.1\r\nHost: %s\r\nConnection: close\r\n", url, (const void *)host);
  request[(signed long int)(sizeof(char [1001l]) /*1001ul*/  - (unsigned long int)1)] = (char)0;
  signed int return_value_lw_dnsutil_name_to_ip_16;
  return_value_lw_dnsutil_name_to_ip_16=lw_dnsutil_name_to_ip(ip, host);
  signed int return_value_lw_sock_recv_str_2;
  char *return_value___builtin_strchr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_6;
  signed int return_value_lw_sock_recv_str_5;
  signed int return_value_lw_sock_recv_str_7;
  if(!(return_value_lw_dnsutil_name_to_ip_16 == 0))
  {
    signed int return_value_lw_sock_connect_15;
    return_value_lw_sock_connect_15=lw_sock_connect(&sock, ip, 80);
    if(!(return_value_lw_sock_connect_15 == 0))
    {
      signed int return_value_lw_sock_send_str_14;
      return_value_lw_sock_send_str_14=lw_sock_send_str(&sock, request);
      if(!(return_value_lw_sock_send_str_14 == 0))
      {
        result = 1;
        if(!(result == 0))
        {
          return_value_lw_sock_recv_str_2=lw_sock_recv_str(&sock, data);
          if(!(return_value_lw_sock_recv_str_2 == 1))
          {
            result = 0;
            memset((void *)content, 0, (unsigned long int)size);
            __builtin_strncpy(content, "Failed to read status line", (unsigned long int)(size - 1));
            content[(signed long int)(size - 1)] = (char)0;
          }

        }

        if(!(result == 0))
        {
          return_value___builtin_strchr_3=__builtin_strchr(data, 32);
          search = return_value___builtin_strchr_3;
          if(!(search == ((char *)NULL)))
            tmp_if_expr_4 = (signed int)search[(signed long int)1] == 50 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(!tmp_if_expr_4)
          {
            result = 0;
            memset((void *)content, 0, (unsigned long int)size);
            snprintf(content, (unsigned long int)(size - 1), "Failure from web server \"%s\": \"%s\"", (const void *)host, (const void *)data);
            content[(signed long int)(size - 1)] = (char)0;
          }

        }

        if(!(result == 0))
        {
          do
          {
            if(!(result == 0))
            {
              return_value_lw_sock_recv_str_5=lw_sock_recv_str(&sock, data);
              tmp_if_expr_6 = return_value_lw_sock_recv_str_5 == 1 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_6 = (_Bool)0;
            result = (signed int)tmp_if_expr_6;
            if(result == 0)
              break;

            if(data[0l] == 0)
              break;

          }
          while((_Bool)1);
          if(!(result == 0))
            do
            {
              return_value_lw_sock_recv_str_7=lw_sock_recv_str(&sock, data);
              if(!(return_value_lw_sock_recv_str_7 == 1))
                break;

              if(empty_lines >= 10)
                break;

              unsigned long int return_value_strlen_8;
              return_value_strlen_8=strlen(data);
              data_len = (signed int)return_value_strlen_8;
              if(data_len >= 2)
              {
                unsigned long int return_value_strlen_13;
                return_value_strlen_13=strlen(content);
                if(!((signed int)return_value_strlen_13 + (signed int)(unsigned long int)data_len >= size + -2))
                {
                  signed int len;
                  signed int pos;
                  unsigned long int return_value_strlen_9;
                  return_value_strlen_9=strlen(content);
                  pos = (signed int)return_value_strlen_9;
                  len = (size - 1) - pos;
                  if(len >= 1)
                  {
                    signed int end;
                    __builtin_strncat(content, data, (unsigned long int)len);
                    unsigned long int return_value_strlen_10;
                    return_value_strlen_10=strlen(data);
                    end = (signed int)((unsigned long int)pos + return_value_strlen_10);
                    if(!(end >= size + -1))
                      content[(signed long int)end] = (char)0;

                  }

                  content[(signed long int)(size - 1)] = (char)0;
                  signed int lw_httputil_get_page__1__4__1__1__3__2__1__1__1__2__len;
                  signed int lw_httputil_get_page__1__4__1__1__3__2__1__1__1__2__pos;
                  unsigned long int return_value_strlen_11;
                  return_value_strlen_11=strlen(content);
                  lw_httputil_get_page__1__4__1__1__3__2__1__1__1__2__pos = (signed int)return_value_strlen_11;
                  lw_httputil_get_page__1__4__1__1__3__2__1__1__1__2__len = (size - 1) - lw_httputil_get_page__1__4__1__1__3__2__1__1__1__2__pos;
                  if(lw_httputil_get_page__1__4__1__1__3__2__1__1__1__2__len >= 1)
                  {
                    signed int lw_httputil_get_page__1__4__1__1__3__2__1__1__1__2__1__end;
                    __builtin_strncat(content, "\n", (unsigned long int)lw_httputil_get_page__1__4__1__1__3__2__1__1__1__2__len);
                    unsigned long int return_value_strlen_12;
                    return_value_strlen_12=strlen("\n");
                    lw_httputil_get_page__1__4__1__1__3__2__1__1__1__2__1__end = (signed int)((unsigned long int)lw_httputil_get_page__1__4__1__1__3__2__1__1__1__2__pos + return_value_strlen_12);
                    if(!(lw_httputil_get_page__1__4__1__1__3__2__1__1__1__2__1__end >= size + -1))
                      content[(signed long int)lw_httputil_get_page__1__4__1__1__3__2__1__1__1__2__1__end] = (char)0;

                  }

                  content[(signed long int)(size - 1)] = (char)0;
                }

              }

              if(data_len == 0)
                empty_lines = empty_lines + 1;

            }
            while((_Bool)1);

          else
          {
            memset((void *)content, 0, (unsigned long int)size);
            __builtin_strncpy(content, "Failed to read headers", (unsigned long int)(size - 1));
            content[(signed long int)(size - 1)] = (char)0;
          }
        }

      }

      else
      {
        memset((void *)content, 0, (unsigned long int)size);
        snprintf(content, (unsigned long int)(size - 1), "Request \"%s\" failed!", (const void *)request);
        content[(signed long int)(size - 1)] = (char)0;
      }
      lw_sock_close(&sock);
    }

    else
    {
      memset((void *)content, 0, (unsigned long int)size);
      snprintf(content, (unsigned long int)(size - 1), "Can't connect to \"%s\"!", (const void *)ip);
      content[(signed long int)(size - 1)] = (char)0;
    }
  }

  else
  {
    memset((void *)content, 0, (unsigned long int)size);
    snprintf(content, (unsigned long int)(size - 1), "Unable to find host \"%s\"!", (const void *)host);
    content[(signed long int)(size - 1)] = (char)0;
  }
  return result;
}

// lw_httputil_text_to_urlparam
// file httputil.c line 229
void lw_httputil_text_to_urlparam(char *urlparam, char *text, signed int size)
{
  signed int i;
  signed int j;
  char buffer[33l];
  unsigned char c;
  memset((void *)urlparam, 0, (unsigned long int)(size + 1));
  j = 0;
  i = 0;
  for( ; !(text[(signed long int)i] == 0) && !(j >= size); i = i + 1)
  {
    if((signed int)text[(signed long int)i] == 95)
      c = (unsigned char)32;

    else
      c = (unsigned char)text[(signed long int)i];
    const unsigned short int **return_value___ctype_b_loc_1;
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if(!((8 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)c]) == 0))
    {
      urlparam[(signed long int)j] = (char)c;
      j = j + 1;
    }

    else
    {
      if(!(j >= size + -2))
      {
        memset((void *)buffer, 0, sizeof(char [33l]) /*33ul*/ );
        snprintf(buffer, sizeof(char [33l]) /*33ul*/  - (unsigned long int)1, "%X", c);
        buffer[(signed long int)(sizeof(char [33l]) /*33ul*/  - (unsigned long int)1)] = (char)0;
        urlparam[(signed long int)j] = (char)37;
        urlparam[(signed long int)(j + 1)] = buffer[(signed long int)0];
        urlparam[(signed long int)(j + 2)] = buffer[(signed long int)1];
      }

      j = j + 3;
    }
  }
}

// lw_info_get_room_for_viewport
// file info.c line 364
void lw_info_get_room_for_viewport(signed int *x, signed int *y, signed int *w, signed int *h)
{
  signed int temp_h;
  signed int temp_w;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_5;
  signed int tmp_if_expr_6;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_8;
  signed int tmp_if_expr_9;
  signed int tmp_if_expr_10;
  signed int tmp_if_expr_11;
  signed int tmp_if_expr_12;
  if((4 & CONFIG_INFO_BAR) == 0)
  {
    signed int return_value_text_length_1;
    return_value_text_length_1=text_length(font, "00:00");
    temp_w = return_value_text_length_1 + 2;
    signed int return_value_text_height_2;
    return_value_text_height_2=text_height(font);
    temp_h = return_value_text_height_2 + 2;
    if(!(temp_h >= 13))
      temp_h = 13;

    if(!(temp_w >= 13))
      temp_w = 13;

    switch(CONFIG_INFO_BAR)
    {
      case 0:
      {
        *x = 0;
        *y = temp_h + 1;
        if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
          tmp_if_expr_3 = gfx_driver->w;

        else
          tmp_if_expr_3 = 0;
        *w = tmp_if_expr_3;
        if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
          tmp_if_expr_4 = gfx_driver->h;

        else
          tmp_if_expr_4 = 0;
        *h = (tmp_if_expr_4 - temp_h) - 1;
        break;
      }
      case 1:
      {
        *x = 0;
        *y = 0;
        if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
          tmp_if_expr_5 = gfx_driver->w;

        else
          tmp_if_expr_5 = 0;
        *w = (tmp_if_expr_5 - temp_w) - 1;
        if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
          tmp_if_expr_6 = gfx_driver->h;

        else
          tmp_if_expr_6 = 0;
        *h = tmp_if_expr_6;
        break;
      }
      case 2:
      {
        *x = 0;
        *y = 0;
        if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
          tmp_if_expr_7 = gfx_driver->w;

        else
          tmp_if_expr_7 = 0;
        *w = tmp_if_expr_7;
        if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
          tmp_if_expr_8 = gfx_driver->h;

        else
          tmp_if_expr_8 = 0;
        *h = (tmp_if_expr_8 - temp_h) - 1;
        break;
      }
      default:
      {
        *x = temp_w + 1;
        *y = 0;
        if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
          tmp_if_expr_9 = gfx_driver->w;

        else
          tmp_if_expr_9 = 0;
        *w = (tmp_if_expr_9 - temp_w) - 1;
        if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
          tmp_if_expr_10 = gfx_driver->h;

        else
          tmp_if_expr_10 = 0;
        *h = tmp_if_expr_10;
      }
    }
  }

  else
  {
    *x = 0;
    *y = 0;
    if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
      tmp_if_expr_11 = gfx_driver->w;

    else
      tmp_if_expr_11 = 0;
    *w = tmp_if_expr_11;
    if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
      tmp_if_expr_12 = gfx_driver->h;

    else
      tmp_if_expr_12 = 0;
    *h = tmp_if_expr_12;
  }
}

// lw_keyboard_reset_hack
// file keyboard.h line 69
void lw_keyboard_reset_hack(void)
{
  signed int keyboard_state = 0;
  clear_keybuf();
  remove_keyboard();
  keyboard_state=install_keyboard();
  if(!(keyboard_state == 0))
    log_println_str("Error: unable to reinstall keyboard");

}

// lw_keyexch_flush
// file keyexch.c line 173
signed int lw_keyexch_flush(struct anonymous_23 *cursors, unsigned int checksum)
{
  signed int result = 1;
  _Bool tmp_if_expr_2;
  signed int return_value_send_keys_1;
  if(!(result == 0))
  {
    return_value_send_keys_1=send_keys(&LW_KEYEXCH_SOCK, cursors, checksum);
    tmp_if_expr_2 = return_value_send_keys_1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  result = (signed int)tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  signed int return_value_recv_keys_3;
  if(!(result == 0))
  {
    return_value_recv_keys_3=recv_keys(&LW_KEYEXCH_SOCK, cursors);
    tmp_if_expr_4 = return_value_recv_keys_3 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_4 = (_Bool)0;
  result = (signed int)tmp_if_expr_4;
  return result;
}

// lw_lang_auto
// file lang.c line 156
extern signed int lw_lang_auto()
{
  signed int language = 0;
  char *env_lang;
  env_lang=getenv("LANG");
  _Bool tmp_if_expr_3;
  signed int return_value_strncmp_2;
  _Bool tmp_if_expr_6;
  signed int return_value_strncmp_5;
  _Bool tmp_if_expr_9;
  signed int return_value_strncmp_8;
  if(!(env_lang == ((char *)NULL)))
  {
    signed int return_value_strncmp_1;
    return_value_strncmp_1=strncmp(env_lang, "DE", (unsigned long int)2);
    if(return_value_strncmp_1 == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_strncmp_2=strncmp(env_lang, "de", (unsigned long int)2);
      tmp_if_expr_3 = return_value_strncmp_2 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      language = 2;

    signed int return_value_strncmp_4;
    return_value_strncmp_4=strncmp(env_lang, "DK", (unsigned long int)2);
    if(return_value_strncmp_4 == 0)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_strncmp_5=strncmp(env_lang, "dk", (unsigned long int)2);
      tmp_if_expr_6 = return_value_strncmp_5 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      language = 3;

    signed int return_value_strncmp_7;
    return_value_strncmp_7=strncmp(env_lang, "FR", (unsigned long int)2);
    if(return_value_strncmp_7 == 0)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_strncmp_8=strncmp(env_lang, "fr", (unsigned long int)2);
      tmp_if_expr_9 = return_value_strncmp_8 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
      language = 1;

  }

  return language;
}

// lw_lang_init
// file lang.h line 298
extern void lw_lang_init()
{
  lw_langde_init();
  lw_langdk_init();
  lw_langen_init();
  lw_langfr_init();
}

// lw_lang_language
// file lang.c line 124
extern char * lw_lang_language(signed int lang)
{
  char *result = (char *)(void *)0;
  switch(lang)
  {
    case 2:
    {
      result=lw_langde_string(0);
      break;
    }
    case 3:
    {
      result=lw_langdk_string(0);
      break;
    }
    case 0:
    {
      result=lw_langen_string(0);
      break;
    }
    case 1:
      result=lw_langfr_string(0);
  }
  if(result == ((char *)NULL))
    result = "???";

  return result;
}

// lw_lang_string
// file lang.h line 299
extern char * lw_lang_string(signed int id)
{
  char *result = (char *)(void *)0;
  signed int language;
  signed int tmp_if_expr_2;
  signed int return_value_lw_lang_auto_1;
  if(CONFIG_LANGUAGE == -1)
  {
    return_value_lw_lang_auto_1=lw_lang_auto();
    tmp_if_expr_2 = return_value_lw_lang_auto_1;
  }

  else
    tmp_if_expr_2 = CONFIG_LANGUAGE;
  language = tmp_if_expr_2;
  switch(language)
  {
    case 2:
    {
      result=lw_langde_string(id);
      break;
    }
    case 3:
    {
      result=lw_langdk_string(id);
      break;
    }
    case 0:
    {
      result=lw_langen_string(id);
      break;
    }
    case 1:
      result=lw_langfr_string(id);
  }
  if(result == ((char *)NULL))
    result = "???";

  return result;
}

// lw_langde_init
// file langde.h line 69
extern void lw_langde_init()
{
  memset((void *)LW_LANGDE_DATA, 0, sizeof(char *[185l]) /*1480ul*/ );
  LW_LANGDE_DATA[(signed long int)0] = "Deutsch";
  LW_LANGDE_DATA[(signed long int)1] = "Liquid War 5.6.4";
  LW_LANGDE_DATA[(signed long int)2] = "Idee: \n* Thomas Colcombet\n\nProgrammation: \n* Christian Mauduit\n\nMusik: \n* Tim Chadburn\n\nAndere Mitwirkende:\n* Alstar\n* Peter Wang\n* Cort Danger Stratton\n* Jan Gretschuskin (www.game-factor.de)\n* Mouse\n* Rene Stach\n* Roderick Schertler\n* Ryan D. Brown\n* Eduard Bloch\n* Michael Terry\n* Kasper Hviid\n* David Redick\n* Alexandre Pineau\n* Michael Wagner\n* Peter Williams\n* Jan Samohyl\n* Gavin\n* Dave Vasilevsky\n* 2 of Omega\n* 666-REFIZUL-666\n* Thomas Klausner\n* Joan Dolc\n\nFuer weitere Informationen, siehe www.ufoot.org/liquidwar/v5\n";
  LW_LANGDE_DATA[(signed long int)3] = "Liquid War ist ein Kriegspiel fuer mehrere Teilnehmer.\nCopyright (C) 1998-2007 Christian Mauduit (ufoot@ufoot.org)\n\nDieses Programm ist freie Software. Sie koennen es unter den Bedingungen der GNU General Public License, wie von der Free Software Foundation veroeffentlicht, weitergeben und/oder modifizieren, entweder gemaess Version 2 der Lizenz oder (nach Ihrer Option) jeder spaeteren Version.\n\nDie Veroeffentlichung dieses Programms erfolgt in der Hoffnung, dass es Ihnen von Nutzen sein wird, aber OHNE IRGENDEINE GARANTIE, sogar ohne die implizite Garantie der MARKTREIFE oder der VERWENDBARKEIT FUER EINEN BESTIMMTEN ZWECK. Details finden Sie in der GNU General Public License.\n\nSie sollten eine Kopie der GNU General Public License zusammen mit diesem Programm erhalten haben. Falls nicht, schreiben Sie an die Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.\n\nFuer weitere Informationen, siehe www.ufoot.org/liquidwar/v5\n";
  LW_LANGDE_DATA[(signed long int)4] = "Deutsche Uebersetzung der\nGNU General Public License\n\nErstellt im Auftrag der S.u.S.E. GmbH http://www.suse.de\nvon Katja Lachmann Uebersetzungen,\nueberarbeitet von Peter Gerwinski, G-N-U GmbH http://www.g-n-u.de\n(31. Oktober 1996, 4. Juni 2000)\n\nDiese Uebersetzung wird mit der Absicht angeboten, das Verstaendnis der GNU General Public License (GNU-GPL) zu erleichtern. Es handelt sich jedoch nicht um eine offizielle oder im rechtlichen Sinne anerkannte Uebersetzung.\n\nDie Free Software Foundation (FSF) ist nicht der Herausgeber dieser Uebersetzung, und sie hat diese Uebersetzung auch nicht als rechtskraeftigen Ersatz fuer die Original-GNU-GPL anerkannt. Da die Uebersetzung nicht sorgfaeltig von Anwaelten ueberprueft wurde, koennen die Uebersetzer nicht garantieren, dass die Uebersetzung die rechtlichen Aussagen der GNU-GPL exakt wiedergibt. Wenn Sie sichergehen wollen, dass von Ihnen geplante Aktivitaeten im Sinne der GNU-GPL gestattet sind, halten Sie sich bitte an die englischsprachige Originalversion.\n\nDie Free Software Foundation moechte Sie darum bitten, diese Uebersetzung nicht als offizielle Lizenzbedingungen fuer von Ihnen geschriebene Programme zu verwenden. Bitte benutzen Sie hierfuer stattdessen die von der Free Software Foundation herausgegebene englischsprachige Originalversion.\n\nThis is a translation of the GNU General Public License into German. This translation is distributed in the hope that it will facilitate understanding, but it is not an official or legally approved translation.\n\nThe Free Software Foundation is not the publisher of this translation and has not approved it as a legal substitute for the authentic GNU General Public License. The translation has not been reviewed carefully by lawyers, and therefore the translator cannot be sure that it exactly represents the legal meaning of the GNU General Public License. If you wish to be sure whether your planned activities are permitted by the GNU General Public License, please refer to the authentic English version.\n\nThe Free Software Foundation strongly urges you not to use this translation as the official distribution terms for your programs; instead, please use the authentic English version published by the Free Software Foundation.\n\nGNU General Public License\n\nDeutsche Uebersetzung der Version 2, Juni 1991\n\nCopyright (c) 1989, 1991 Free Software Foundation, Inc.\n\n51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA\n\npeter@gerwinski.de\n\nEs ist jedermann gestattet, diese Lizenzurkunde zu vervielfaeltigen und unveraenderte Kopien zu verbreiten; Aenderungen sind jedoch nicht erlaubt.\n\nDiese Uebersetzung ist kein rechtskraeftiger Ersatz fuer die englischsprachige Originalversion!\n\nVorwort\n\nDie meisten Softwarelizenzen sind daraufhin entworfen worden, Ihnen die Freiheit zu nehmen, die Software weiterzugeben und zu veraendern. Im Gegensatz dazu soll Ihnen die GNU General Public License , die Allgemeine Oeffentliche GNU-Lizenz, ebendiese Freiheit garantieren. Sie soll sicherstellen, dass die Software fuer alle Benutzer frei ist. Diese Lizenz gilt fuer den Grossteil der von der Free Software Foundation herausgegebenen Software und fuer alle anderen Programme, deren Autoren ihr Datenwerk dieser Lizenz unterstellt haben. Auch Sie koennen diese Moeglichkeit der Lizenzierung fuer Ihre Programme anwenden. (Ein anderer Teil der Software der Free Software Foundation unterliegt stattdessen der GNU Library General Public License , der Allgemeinen Oeffentlichen GNU-Lizenz fuer Bibliotheken.) [Mittlerweile wurde die GNU Library Public License von der GNU Lesser Public License abgeloest - Anmerkung des Uebersetzers.]\n\nDie Bezeichnung ,,freie`` Software bezieht sich auf Freiheit, nicht auf den Preis. Unsere Lizenzen sollen Ihnen die Freiheit garantieren, Kopien freier Software zu verbreiten (und etwas fuer diesen Service zu berechnen, wenn Sie moechten), die Moeglichkeit, die Software im Quelltext zu erhalten oder den Quelltext auf Wunsch zu bekommen. Die Lizenzen sollen garantieren, dass Sie die Software aendern oder Teile davon in neuen freien Programmen verwenden duerfen - und dass Sie wissen, dass Sie dies alles tun duerfen.\n\nUm Ihre Rechte zu schuetzen, muessen wir Einschraenkungen machen, die es jedem verbieten, Ihnen diese Rechte zu verweigern oder Sie aufzufordern, auf diese Rechte zu verzichten. Aus diesen Einschraenkungen folgen bestimmte Verantwortlichkeiten fuer Sie, wenn Sie Kopien der Software verbreiten oder sie veraendern.\n\nBeispielsweise muessen Sie den Empfaengern alle Rechte gewaehren, die Sie selbst haben, wenn Sie - kostenlos oder gegen Bezahlung - Kopien eines solchen Programms verbreiten. Sie muessen sicherstellen, dass auch die Empfaenger den Quelltext erhalten bzw. erhalten koennen. Und Sie muessen ihnen diese Bedingungen zeigen, damit sie ihre Rechte kennen.\n\nWir schuetzen Ihre Rechte in zwei Schritten: (1) Wir stellen die Software unter ein Urheberrecht (Copyright), und (2) wir bieten Ihnen diese Lizenz an, die Ihnen das Recht gibt, die Software zu vervielfaeltigen, zu verbreiten und/oder zu veraendern.\n\nUm die Autoren und uns zu schuetzen, wollen wir darueberhinaus sicherstellen, dass jeder erfaehrt, dass fuer diese freie Software keinerlei Garantie besteht. Wenn die Software von jemand anderem modifiziert und weitergegeben wird, moechten wir, dass die Empfaenger wissen, dass sie nicht das Original erhalten haben, damit irgendwelche von anderen verursachte Probleme nicht den Ruf des urspruenglichen Autors schaedigen.\n\nSchliesslich und endlich ist jedes freie Programm permanent durch Software-Patente bedroht. Wir moechten die Gefahr ausschliessen, dass Distributoren eines freien Programms individuell Patente lizensieren - mit dem Ergebnis, dass das Programm proprietaer wuerde. Um dies zu verhindern, haben wir klargestellt, dass jedes Patent entweder fuer freie Benutzung durch jedermann lizenziert werden muss oder ueberhaupt nicht lizenziert werden darf.\n\nEs folgen die genauen Bedingungen fuer die Vervielfaeltigung, Verbreitung und Bearbeitung:\n\nAllgemeine Oeffentliche GNU-Lizenz\nBedingungen fuer die Vervielfaeltigung,\nVerbreitung und Bearbeitung\n\n0. Diese Lizenz gilt fuer jedes Programm und jedes andere Datenwerk, in dem ein entsprechender Vermerk des Copyright-Inhabers darauf hinweist, dass das Datenwerk unter den Bestimmungen dieser General Public License verbreitet werden darf. Im folgenden wird jedes derartige Programm oder Datenwerk als ,,das Programm`` bezeichnet; die Formulierung ,,auf dem Programm basierendes Datenwerk`` bezeichnet das Programm sowie jegliche Bearbeitung des Programms im urheberrechtlichen Sinne, also ein Datenwerk, welches das Programm, auch auszugsweise, sei es unveraendert oder veraendert und/oder in eine andere Sprache uebersetzt, enthaelt. (Im folgenden wird die Uebersetzung ohne Einschraenkung als ,,Bearbeitung`` eingestuft.) Jeder Lizenznehmer wird im folgenden als ,,Sie`` angesprochen.\n\nAndere Handlungen als Vervielfaeltigung, Verbreitung und Bearbeitung werden von dieser Lizenz nicht beruehrt; sie fallen nicht in ihren Anwendungsbereich. Der Vorgang der Ausfuehrung des Programms wird nicht eingeschraenkt, und die Ausgaben des Programms unterliegen dieser Lizenz nur, wenn der Inhalt ein auf dem Programm basierendes Datenwerk darstellt (unabhaengig davon, dass die Ausgabe durch die Ausfuehrung des Programmes erfolgte). Ob dies zutrifft, haengt von den Funktionen des Programms ab.\n\n1. Sie duerfen auf beliebigen Medien unveraenderte Kopien des Quelltextes des Programms, wie sie ihn erhalten haben, anfertigen und verbreiten. Voraussetzung hierfuer ist, dass Sie mit jeder Kopie einen entsprechenden Copyright-Vermerk sowie einen Haftungsausschluss veroeffentlichen, alle Vermerke, die sich auf diese Lizenz und das Fehlen einer Garantie beziehen, unveraendert lassen und desweiteren allen anderen Empfaengern des Programms zusammen mit dem Programm eine Kopie dieser Lizenz zukommen lassen.\n\nSie duerfen fuer den eigentlichen Kopiervorgang eine Gebuehr verlangen. Wenn Sie es wuenschen, duerfen Sie auch gegen Entgeld eine Garantie fuer das Programm anbieten.\n\n2. Sie duerfen Ihre Kopie(n) des Programms oder eines Teils davon veraendern, wodurch ein auf dem Programm basierendes Datenwerk entsteht; Sie duerfen derartige Bearbeitungen unter den Bestimmungen von Paragraph 1 vervielfaeltigen und verbreiten, vorausgesetzt, dass zusaetzlich alle im folgenden genannten Bedingungen erfuellt werden:\n\n1.\nSie muessen die veraenderten Dateien mit einem auffaelligen Vermerk versehen, der auf die von Ihnen vorgenommene Modifizierung und das Datum jeder Aenderung hinweist.\n2.\nSie muessen dafuer sorgen, dass jede von Ihnen verbreitete oder veroeffentlichte Arbeit, die ganz oder teilweise von dem Programm oder Teilen davon abgeleitet ist, Dritten gegenueber als Ganzes unter den Bedingungen dieser Lizenz ohne Lizenzgebuehren zur Verfuegung gestellt wird.\n3.\nWenn das veraenderte Programm normalerweise bei der Ausfuehrung interaktiv Kommandos einliest, muessen Sie dafuer sorgen, dass es, wenn es auf dem ueblichsten Wege fuer solche interaktive Nutzung gestartet wird, eine Meldung ausgibt oder ausdruckt, die einen geeigneten Copyright-Vermerk enthaelt sowie einen Hinweis, dass es keine Gewaehrleistung gibt (oder anderenfalls, dass Sie Garantie leisten), und dass die Benutzer das Programm unter diesen Bedingungen weiter verbreiten duerfen. Auch muss der Benutzer darauf hingewiesen werden, wie er eine Kopie dieser Lizenz ansehen kann. (Ausnahme: Wenn das Programm selbst interaktiv arbeitet, aber normalerweise keine derartige Meldung ausgibt, muss Ihr auf dem Programm basierendes Datenwerk auch keine solche Meldung ausgeben).\n\nDiese Anforderungen gelten fuer das bearbeitete Datenwerk als Ganzes. Wenn identifizierbare Teile des Datenwerkes nicht von dem Programm abgeleitet sind und vernuenftigerweise als unabhaengige und eigenstaendige Datenwerke fuer sich selbst zu betrachten sind, dann gelten diese Lizenz und ihre Bedingungen nicht fuer die betroffenen Teile, wenn Sie diese als eigenstaendige Datenwerke weitergeben. Wenn Sie jedoch dieselben Abschnitte als Teil eines Ganzen weitergeben, das ein auf dem Programm basierendes Datenwerk darstellt, dann muss die Weitergabe des Ganzen nach den Bedingungen dieser Lizenz erfolgen, deren Bedingungen fuer weitere Lizenznehmer somit auf das gesamte Ganze ausgedehnt werden - und somit auf jeden einzelnen Teil, unabhaengig vom jeweiligen Autor.\n\nSomit ist es nicht die Absicht dieses Abschnittes, Rechte fuer Datenwerke in Anspruch zu nehmen oder Ihnen die Rechte fuer Datenwerke streitig zu machen, die komplett von Ihnen geschrieben wurden; vielmehr ist es die Absicht, die Rechte zur Kontrolle der Verbreitung von Datenwerken, die auf dem Programm basieren oder unter seiner auszugsweisen Verwendung zusammengestellt worden sind, auszuueben.\n\nFerner bringt auch das einfache Zusammenlegen eines anderen Datenwerkes, das nicht auf dem Programm basiert, mit dem Programm oder einem auf dem Programm basierenden Datenwerk auf ein- und demselben Speicher- oder Vertriebsmedium dieses andere Datenwerk nicht in den Anwendungsbereich dieser Lizenz.\n\n3. Sie duerfen das Programm (oder ein darauf basierendes Datenwerk gemaess Paragraph 2) als Objectcode oder in ausfuehrbarer Form unter den Bedingungen der Paragraphen 1 und 2 kopieren und weitergeben - vorausgesetzt, dass Sie ausserdem eine der folgenden Leistungen erbringen:\n\n1.\nLiefern Sie das Programm zusammen mit dem vollstaendigen zugehoerigen maschinenlesbaren Quelltext auf einem fuer den Datenaustausch ueblichen Medium aus, wobei die Verteilung unter den Bedingungen der Paragraphen 1 und 2 erfolgen muss. Oder:\n2.\nLiefern Sie das Programm zusammen mit einem mindestens drei Jahre lang gueltigen schriftlichen Angebot aus, jedem Dritten eine vollstaendige maschinenlesbare Kopie des Quelltextes zur Verfuegung zu stellen - zu nicht hoeheren Kosten als denen, die durch den physikalischen Kopiervorgang anfallen -, wobei der Quelltext unter den Bedingungen der Paragraphen 1 und 2 auf einem fuer den Datenaustausch ueblichen Medium weitergegeben wird. Oder:\n3.\nLiefern Sie das Programm zusammen mit dem schriftlichen Angebot der Zurverfuegungstellung des Quelltextes aus, das Sie selbst erhalten haben. (Diese Alternative ist nur fuer nicht-kommerzielle Verbreitung zulaessig und nur, wenn Sie das Programm als Objectcode oder in ausfuehrbarer Form mit einem entsprechenden Angebot gemaess Absatz b erhalten haben.)\n\nUnter dem Quelltext eines Datenwerkes wird diejenige Form des Datenwerkes verstanden, die fuer Bearbeitungen vorzugsweise verwendet wird. Fuer ein ausfuehrbares Programm bedeutet ,,der komplette Quelltext``: Der Quelltext aller im Programm enthaltenen Module einschliesslich aller zugehoerigen Modulschnittstellen-Definitionsdateien sowie der zur Compilation und Installation verwendeten Skripte. Als besondere Ausnahme jedoch braucht der verteilte Quelltext nichts von dem zu enthalten, was ueblicherweise (entweder als Quelltext oder in binaerer Form) zusammen mit den Hauptkomponenten des Betriebssystems (Kernel, Compiler usw.) geliefert wird, unter dem das Programm laeuft - es sei denn, diese Komponente selbst gehoert zum ausfuehrbaren Programm.\n\nWenn die Verbreitung eines ausfuehrbaren Programms oder von Objectcode dadurch erfolgt, dass der Kopierzugriff auf eine dafuer vorgesehene Stelle gewaehrt wird, so gilt die Gewaehrung eines gleichwertigen Zugriffs auf den Quelltext als Verbreitung des Quelltextes, auch wenn Dritte nicht dazu gezwungen sind, den Quelltext zusammen mit dem Objectcode zu kopieren.\n\n4. Sie duerfen das Programm nicht vervielfaeltigen, veraendern, weiter lizenzieren oder verbreiten, sofern es nicht durch diese Lizenz ausdruecklich gestattet ist. Jeder anderweitige Versuch der Vervielfaeltigung, Modifizierung, Weiterlizenzierung und Verbreitung ist nichtig und beendet automatisch Ihre Rechte unter dieser Lizenz. Jedoch werden die Lizenzen Dritter, die von Ihnen Kopien oder Rechte unter dieser Lizenz erhalten haben, nicht beendet, solange diese die Lizenz voll anerkennen und befolgen.\n\n5. Sie sind nicht verpflichtet, diese Lizenz anzunehmen, da Sie sie nicht unterzeichnet haben. Jedoch gibt Ihnen nichts anderes die Erlaubnis, das Programm oder von ihm abgeleitete Datenwerke zu veraendern oder zu verbreiten. Diese Handlungen sind gesetzlich verboten, wenn Sie diese Lizenz nicht anerkennen. Indem Sie das Programm (oder ein darauf basierendes Datenwerk) veraendern oder verbreiten, erklaeren Sie Ihr Einverstaendnis mit dieser Lizenz und mit allen ihren Bedingungen bezueglich der Vervielfaeltigung, Verbreitung und Veraenderung des Programms oder eines darauf basierenden Datenwerks.\n\n6. Jedesmal, wenn Sie das Programm (oder ein auf dem Programm basierendes Datenwerk) weitergeben, erhaelt der Empfaenger automatisch vom urspruenglichen Lizenzgeber die Lizenz, das Programm entsprechend den hier festgelegten Bestimmungen zu vervielfaeltigen, zu verbreiten und zu veraendern. Sie duerfen keine weiteren Einschraenkungen der Durchsetzung der hierin zugestandenen Rechte des Empfaengers vornehmen. Sie sind nicht dafuer verantwortlich, die Einhaltung dieser Lizenz durch Dritte durchzusetzen.\n\n7. Sollten Ihnen infolge eines Gerichtsurteils, des Vorwurfs einer Patentverletzung oder aus einem anderen Grunde (nicht auf Patentfragen begrenzt) Bedingungen (durch Gerichtsbeschluss, Vergleich oder anderweitig) auferlegt werden, die den Bedingungen dieser Lizenz widersprechen, so befreien Sie diese Umstaende nicht von den Bestimmungen dieser Lizenz. Wenn es Ihnen nicht moeglich ist, das Programm unter gleichzeitiger Beachtung der Bedingungen in dieser Lizenz und Ihrer anderweitigen Verpflichtungen zu verbreiten, dann duerfen Sie als Folge das Programm ueberhaupt nicht verbreiten. Wenn zum Beispiel ein Patent nicht die gebuehrenfreie Weiterverbreitung des Programms durch diejenigen erlaubt, die das Programm direkt oder indirekt von Ihnen erhalten haben, dann besteht der einzige Weg, sowohl das Patentrecht als auch diese Lizenz zu befolgen, darin, ganz auf die Verbreitung des Programms zu verzichten.\n\nSollte sich ein Teil dieses Paragraphen als ungueltig oder unter bestimmten Umstaenden nicht durchsetzbar erweisen, so soll dieser Paragraph seinem Sinne nach angewandt werden; im uebrigen soll dieser Paragraph als Ganzes gelten.\n\nZweck dieses Paragraphen ist nicht, Sie dazu zu bringen, irgendwelche Patente oder andere Eigentumsansprueche zu verletzen oder die Gueltigkeit solcher Ansprueche zu bestreiten; dieser Paragraph hat einzig den Zweck, die Integritaet des Verbreitungssystems der freien Software zu schuetzen, das durch die Praxis oeffentlicher Lizenzen verwirklicht wird. Viele Leute haben grosszuegige Beitraege zu dem grossen Angebot der mit diesem System verbreiteten Software im Vertrauen auf die konsistente Anwendung dieses Systems geleistet; es liegt am Autor/Geber, zu entscheiden, ob er die Software mittels irgendeines anderen Systems verbreiten will; ein Lizenznehmer hat auf diese Entscheidung keinen Einfluss.\n\nDieser Paragraph ist dazu gedacht, deutlich klarzustellen, was als Konsequenz aus dem Rest dieser Lizenz betrachtet wird.\n\n8. Wenn die Verbreitung und/oder die Benutzung des Programms in bestimmten Staaten entweder durch Patente oder durch urheberrechtlich geschuetzte Schnittstellen eingeschraenkt ist, kann der Urheberrechtsinhaber, der das Programm unter diese Lizenz gestellt hat, eine explizite geographische Begrenzung der Verbreitung angeben, in der diese Staaten ausgeschlossen werden, so dass die Verbreitung nur innerhalb und zwischen den Staaten erlaubt ist, die nicht ausgeschlossen sind. In einem solchen Fall beinhaltet diese Lizenz die Beschraenkung, als waere sie in diesem Text niedergeschrieben.\n\n9. Die Free Software Foundation kann von Zeit zu Zeit ueberarbeitete und/oder neue Versionen der General Public License veroeffentlichen. Solche neuen Versionen werden vom Grundprinzip her der gegenwaertigen entsprechen, koennen aber im Detail abweichen, um neuen Problemen und Anforderungen gerecht zu werden.\n\nJede Version dieser Lizenz hat eine eindeutige Versionsnummer. Wenn in einem Programm angegeben wird, dass es dieser Lizenz in einer bestimmten Versionsnummer oder ,,jeder spaeteren Version`` (``any later version'') unterliegt, so haben Sie die Wahl, entweder den Bestimmungen der genannten Version zu folgen oder denen jeder beliebigen spaeteren Version, die von der Free Software Foundation veroeffentlicht wurde. Wenn das Programm keine Versionsnummer angibt, koennen Sie eine beliebige Version waehlen, die je von der Free Software Foundation veroeffentlicht wurde.\n\n10. Wenn Sie den Wunsch haben, Teile des Programms in anderen freien Programmen zu verwenden, deren Bedingungen fuer die Verbreitung anders sind, schreiben Sie an den Autor, um ihn um die Erlaubnis zu bitten. Fuer Software, die unter dem Copyright der Free Software Foundation steht, schreiben Sie an die Free Software Foundation ; wir machen zu diesem Zweck gelegentlich Ausnahmen. Unsere Entscheidung wird von den beiden Zielen geleitet werden, zum einen den freien Status aller von unserer freien Software abgeleiteten Datenwerke zu erhalten und zum anderen das gemeinschaftliche Nutzen und Wiederverwenden von Software im allgemeinen zu foerdern.\n\nKeine Gewaehrleistung\n\n11. Da das Programm ohne jegliche Kosten lizenziert wird, besteht keinerlei Gewaehrleistung fuer das Programm, soweit dies gesetzlich zulaessig ist. Sofern nicht anderweitig schriftlich bestaetigt, stellen die Copyright-Inhaber und/oder Dritte das Programm so zur Verfuegung, ,,wie es ist``, ohne irgendeine Gewaehrleistung, weder ausdruecklich noch implizit, einschliesslich - aber nicht begrenzt auf - Marktreife oder Verwendbarkeit fuer einen bestimmten Zweck. Das volle Risiko bezueglich Qualitaet und Leistungsfaehigkeit des Programms liegt bei Ihnen. Sollte sich das Programm als fehlerhaft herausstellen, liegen die Kosten fuer notwendigen Service, Reparatur oder Korrektur bei Ihnen.\n\n12. In keinem Fall, ausser wenn durch geltendes Recht gefordert oder schriftlich zugesichert, ist irgendein Copyright-Inhaber oder irgendein Dritter, der das Programm wie oben erlaubt modifiziert oder verbreitet hat, Ihnen gegenueber fuer irgendwelche Schaeden haftbar, einschliesslich jeglicher allgemeiner oder spezieller Schaeden, Schaeden durch Seiteneffekte (Nebenwirkungen) oder Folgeschaeden, die aus der Benutzung des Programms oder der Unbenutzbarkeit des Programms folgen (einschliesslich - aber nicht beschraenkt auf - Datenverluste, fehlerhafte Verarbeitung von Daten, Verluste, die von Ihnen oder anderen getragen werden muessen, oder dem Unvermoegen des Programms, mit irgendeinem anderen Programm zusammenzuarbeiten), selbst wenn ein Copyright-Inhaber oder Dritter ueber die Moeglichkeit solcher Schaeden unterrichtet worden war.\n\nEnde der Bedingungen\n\nAnhang: Wie Sie diese Bedingungen auf Ihre eigenen,\nneuen Programme anwenden koennen\n\nWenn Sie ein neues Programm entwickeln und wollen, dass es vom groesstmoeglichen Nutzen fuer die Allgemeinheit ist, dann erreichen Sie das am besten, indem Sie es zu freier Software machen, die jeder unter diesen Bestimmungen weiterverbreiten und veraendern kann.\n\nUm dies zu erreichen, fuegen Sie die folgenden Vermerke zu Ihrem Programm hinzu. Am sichersten ist es, sie an den Anfang einer jeden Quelldatei zu stellen, um den Gewaehrleistungsausschluss moeglichst deutlich darzustellen; zumindest aber sollte jede Datei eine Copyright-Zeile besitzen sowie einen kurzen Hinweis darauf, wo die vollstaendigen Vermerke zu finden sind.\n\n[eine Zeile mit dem Programmnamen und einer kurzen Beschreibung]\nCopyright (C) [Jahr]  [Name des Autors]\n\nThis program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.\n\nAuf Deutsch:\n\n[eine Zeile mit dem Programmnamen und einer kurzen Beschreibung]\nCopyright (C) [Jahr]  [Name des Autors]\n\nDieses Programm ist freie Software. Sie koennen es unter den Bedingungen der GNU General Public License, wie von der Free Software Foundation veroeffentlicht, weitergeben und/oder modifizieren, entweder gemaess Version 2 der Lizenz oder (nach Ihrer Option) jeder spaeteren Version.\n\nDie Veroeffentlichung dieses Programms erfolgt in der Hoffnung, dass es Ihnen von Nutzen sein wird, aber OHNE IRGENDEINE GARANTIE, sogar ohne die implizite Garantie der MARKTREIFE oder der VERWENDBARKEIT FUER EINEN BESTIMMTEN ZWECK. Details finden Sie in der GNU General Public License.\n\nSie sollten eine Kopie der GNU General Public License zusammen mit diesem Programm erhalten haben. Falls nicht, schreiben Sie an die Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.\n\nFuegen Sie auch einen kurzen Hinweis hinzu, wie Sie elektronisch und per Brief erreichbar sind.\n\nWenn Ihr Programm interaktiv ist, sorgen Sie dafuer, dass es nach dem Start einen kurzen Vermerk ausgibt:\n\nversion 69, Copyright (C) [Jahr]  [Name des Autors] Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details.\n\nAuf Deutsch:\n\nVersion 69, Copyright (C) [Jahr]  [Name des Autors] Fuer Gnomovision besteht KEINERLEI GARANTIE; geben Sie `show w' fuer Details ein. Gnonovision ist freie Software, die Sie unter bestimmten Bedingungen weitergeben duerfen; geben Sie `show c' fuer Details ein.\n\nDie hypothetischen Kommandos `show w' und `show c' sollten die entsprechenden Teile der GNU-GPL anzeigen. Natuerlich koennen die von Ihnen verwendeten Kommandos anders heissen als `show w' und `show c'; es koennten auch Mausklicks oder Menuepunkte sein - was immer am besten in Ihr Programm passt.\n\nSoweit vorhanden, sollten Sie auch Ihren Arbeitgeber (wenn Sie als Programmierer arbeiten) oder Ihre Schule einen Copyright-Verzicht fuer das Programm unterschreiben lassen. Hier ein Beispiel. Die Namen muessen Sie natuerlich aendern.\n\nYoyodyne, Inc., hereby disclaims all copyright interest in the program `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n[Unterschrift von Ty Coon], 1 April 1989\nTy Coon, President of Vice\n\nAuf Deutsch:\n\nDie Yoyodyne GmbH erhebt keinen urheberrechtlichen Anspruch auf das von James Hacker geschriebene Programm ,Gnomovision` (einem Schrittmacher fuer Compiler).\n\n[Unterschrift von Ty Coon], 1. April 1989\nTy Coon, Vizepraesident\n\nDiese General Public License gestattet nicht die Einbindung des Programms in proprietaere Programme. Ist Ihr Programm eine Funktionsbibliothek, so kann es sinnvoller sein, das Binden proprietaerer Programme mit dieser Bibliothek zu gestatten. Wenn Sie dies tun wollen, sollten Sie die GNU Library General Public License anstelle dieser Lizenz verwenden.";
  LW_LANGDE_DATA[(signed long int)5] = "Liquid War von U-Foot\n\nv5.6.4 \n\ncompiled am Jan 25 2016 um 05:34:53\n\nWeitere Informationen auf www.ufoot.org/liquidwar/v5\n";
  LW_LANGDE_DATA[(signed long int)6] = "Spielen";
  LW_LANGDE_DATA[(signed long int)7] = "Netzwerk";
  LW_LANGDE_DATA[(signed long int)8] = "Karte";
  LW_LANGDE_DATA[(signed long int)9] = "Teams";
  LW_LANGDE_DATA[(signed long int)10] = "Optionen";
  LW_LANGDE_DATA[(signed long int)11] = "Informationen";
  LW_LANGDE_DATA[(signed long int)12] = "Quit";
  LW_LANGDE_DATA[(signed long int)13] = "Exit";
  LW_LANGDE_DATA[(signed long int)14] = "Quit";
  LW_LANGDE_DATA[(signed long int)15] = "Quit";
  LW_LANGDE_DATA[(signed long int)16] = "Zurueck zu LW";
  LW_LANGDE_DATA[(signed long int)17] = "Quit";
  LW_LANGDE_DATA[(signed long int)18] = "Zurueck";
  LW_LANGDE_DATA[(signed long int)19] = "Spielen";
  LW_LANGDE_DATA[(signed long int)20] = "Menue";
  LW_LANGDE_DATA[(signed long int)21] = "Macht euch bereit!";
  LW_LANGDE_DATA[(signed long int)22] = "Starten";
  LW_LANGDE_DATA[(signed long int)23] = "Server Addr.";
  LW_LANGDE_DATA[(signed long int)24] = "Server Port";
  LW_LANGDE_DATA[(signed long int)25] = "Suche Internetspiele";
  LW_LANGDE_DATA[(signed long int)26] = "Password";
  LW_LANGDE_DATA[(signed long int)27] = "*) Achtung! Waehle ein schwaches Wort wie \"hallo\", welches auf deiner Festplatte gespecihert ist und sende es zum Server..";
  LW_LANGDE_DATA[(signed long int)28] = "Automatisch";
  LW_LANGDE_DATA[(signed long int)29] = "Inaktiv";
  LW_LANGDE_DATA[(signed long int)30] = "Mensch";
  LW_LANGDE_DATA[(signed long int)31] = "CPU";
  LW_LANGDE_DATA[(signed long int)32] = "Grafik";
  LW_LANGDE_DATA[(signed long int)33] = "Sound";
  LW_LANGDE_DATA[(signed long int)34] = "Regeln";
  LW_LANGDE_DATA[(signed long int)35] = "Geschwindigkeit";
  LW_LANGDE_DATA[(signed long int)36] = "Steuerung";
  LW_LANGDE_DATA[(signed long int)37] = "Sprache";
  LW_LANGDE_DATA[(signed long int)38] = "Standard";
  LW_LANGDE_DATA[(signed long int)39] = "Spiel";
  LW_LANGDE_DATA[(signed long int)40] = "Menue";
  LW_LANGDE_DATA[(signed long int)41] = "Ja";
  LW_LANGDE_DATA[(signed long int)42] = "Nein";
  LW_LANGDE_DATA[(signed long int)43] = "Vollbild";
  LW_LANGDE_DATA[(signed long int)44] = "Fenster";
  LW_LANGDE_DATA[(signed long int)45] = "erw. Optionen";
  LW_LANGDE_DATA[(signed long int)46] = "Videomodus";
  LW_LANGDE_DATA[(signed long int)47] = "Brightness";
  LW_LANGDE_DATA[(signed long int)48] = "Portgroesse";
  LW_LANGDE_DATA[(signed long int)49] = "\"Page flipping\"";
  LW_LANGDE_DATA[(signed long int)50] = "Wellen (F4)";
  LW_LANGDE_DATA[(signed long int)51] = "FX Sound";
  LW_LANGDE_DATA[(signed long int)52] = "Click";
  LW_LANGDE_DATA[(signed long int)53] = "Spielwasser";
  LW_LANGDE_DATA[(signed long int)54] = "Wassermenue";
  LW_LANGDE_DATA[(signed long int)55] = "Musik";
  LW_LANGDE_DATA[(signed long int)56] = "Zeit";
  LW_LANGDE_DATA[(signed long int)57] = "erw. Optionen";
  LW_LANGDE_DATA[(signed long int)58] = "Armeegroesse";
  LW_LANGDE_DATA[(signed long int)59] = "Cursor";
  LW_LANGDE_DATA[(signed long int)60] = "Standard";
  LW_LANGDE_DATA[(signed long int)61] = "Min ";
  LW_LANGDE_DATA[(signed long int)62] = "Angriff";
  LW_LANGDE_DATA[(signed long int)63] = "Abwehr";
  LW_LANGDE_DATA[(signed long int)64] = "Gesundheit";
  LW_LANGDE_DATA[(signed long int)65] = "Siegerhilfe";
  LW_LANGDE_DATA[(signed long int)66] = "CPU Staerke";
  LW_LANGDE_DATA[(signed long int)67] = "CPU vs Mensch";
  LW_LANGDE_DATA[(signed long int)68] = "Immer";
  LW_LANGDE_DATA[(signed long int)69] = "Normal";
  LW_LANGDE_DATA[(signed long int)70] = "Nie";
  LW_LANGDE_DATA[(signed long int)71] = "Algorithmus";
  LW_LANGDE_DATA[(signed long int)72] = "Assembly";
  LW_LANGDE_DATA[(signed long int)73] = "C-Standard";
  LW_LANGDE_DATA[(signed long int)74] = "Netzbots";
  LW_LANGDE_DATA[(signed long int)75] = "An";
  LW_LANGDE_DATA[(signed long int)76] = "Aus";
  LW_LANGDE_DATA[(signed long int)77] = "frames/s";
  LW_LANGDE_DATA[(signed long int)78] = "Kein FPS Limit";
  LW_LANGDE_DATA[(signed long int)79] = "Runden/s";
  LW_LANGDE_DATA[(signed long int)80] = "Kein Rundenlimit";
  LW_LANGDE_DATA[(signed long int)81] = "Joystick";
  LW_LANGDE_DATA[(signed long int)82] = "Aus";
  LW_LANGDE_DATA[(signed long int)83] = "2 Joysticks";
  LW_LANGDE_DATA[(signed long int)84] = "4 Tasten";
  LW_LANGDE_DATA[(signed long int)85] = "Standard";
  LW_LANGDE_DATA[(signed long int)86] = "Maussensibilitaet";
  LW_LANGDE_DATA[(signed long int)87] = "\"Credits\"";
  LW_LANGDE_DATA[(signed long int)88] = "Copyright";
  LW_LANGDE_DATA[(signed long int)89] = "Lizenz";
  LW_LANGDE_DATA[(signed long int)90] = "Version";
  LW_LANGDE_DATA[(signed long int)91] = "Refresh";
  LW_LANGDE_DATA[(signed long int)92] = "Jetzt teilnehmen";
  LW_LANGDE_DATA[(signed long int)93] = "Port";
  LW_LANGDE_DATA[(signed long int)94] = "Passwort";
  LW_LANGDE_DATA[(signed long int)95] = "Ja";
  LW_LANGDE_DATA[(signed long int)96] = "Nein";
  LW_LANGDE_DATA[(signed long int)97] = "Alter";
  LW_LANGDE_DATA[(signed long int)98] = "d";
  LW_LANGDE_DATA[(signed long int)99] = "d";
  LW_LANGDE_DATA[(signed long int)100] = "h";
  LW_LANGDE_DATA[(signed long int)101] = "min";
  LW_LANGDE_DATA[(signed long int)102] = "sec";
  LW_LANGDE_DATA[(signed long int)103] = "Zu weit / tot";
  LW_LANGDE_DATA[(signed long int)104] = "Ping";
  LW_LANGDE_DATA[(signed long int)105] = "ms";
  LW_LANGDE_DATA[(signed long int)106] = "Wellen";
  LW_LANGDE_DATA[(signed long int)107] = "Nummer";
  LW_LANGDE_DATA[(signed long int)108] = "Speed";
  LW_LANGDE_DATA[(signed long int)109] = "WX";
  LW_LANGDE_DATA[(signed long int)110] = "HY";
  LW_LANGDE_DATA[(signed long int)111] = "WY";
  LW_LANGDE_DATA[(signed long int)112] = "HX";
  LW_LANGDE_DATA[(signed long int)113] = "Starten";
  LW_LANGDE_DATA[(signed long int)114] = "Warte...";
  LW_LANGDE_DATA[(signed long int)115] = "Warte auf ";
  LW_LANGDE_DATA[(signed long int)116] = " Team(s)";
  LW_LANGDE_DATA[(signed long int)117] = "Nachricht schreiben";
  LW_LANGDE_DATA[(signed long int)118] = "Verbinden";
  LW_LANGDE_DATA[(signed long int)119] = "\"Ping\"";
  LW_LANGDE_DATA[(signed long int)120] = "Programmcheck";
  LW_LANGDE_DATA[(signed long int)121] = "Versionscheck";
  LW_LANGDE_DATA[(signed long int)122] = "Password";
  LW_LANGDE_DATA[(signed long int)123] = "Freie Teams?";
  LW_LANGDE_DATA[(signed long int)124] = "Reservierung";
  LW_LANGDE_DATA[(signed long int)125] = "Sende Konfig";
  LW_LANGDE_DATA[(signed long int)126] = "Sende Karte";
  LW_LANGDE_DATA[(signed long int)127] = "Warte...";
  LW_LANGDE_DATA[(signed long int)128] = "Wer spielt?";
  LW_LANGDE_DATA[(signed long int)129] = "Empfange Konfig";
  LW_LANGDE_DATA[(signed long int)130] = "Empfange Karte";
  LW_LANGDE_DATA[(signed long int)131] = "Benutze Standardtextur";
  LW_LANGDE_DATA[(signed long int)132] = "An";
  LW_LANGDE_DATA[(signed long int)133] = "Aus";
  LW_LANGDE_DATA[(signed long int)134] = "Zufallskarte";
  LW_LANGDE_DATA[(signed long int)135] = "FP/s ";
  LW_LANGDE_DATA[(signed long int)136] = "Runden/s ";
  LW_LANGDE_DATA[(signed long int)137] = "% calcul ";
  LW_LANGDE_DATA[(signed long int)138] = "% rechne ";
  LW_LANGDE_DATA[(signed long int)139] = "Spread gate time ";
  LW_LANGDE_DATA[(signed long int)140] = "Bewegungszeit";
  LW_LANGDE_DATA[(signed long int)141] = "Zeitanzeige ";
  LW_LANGDE_DATA[(signed long int)142] = "Fliptime";
  LW_LANGDE_DATA[(signed long int)143] = "Andere Zeit ";
  LW_LANGDE_DATA[(signed long int)144] = "Gesamtzeit ";
  LW_LANGDE_DATA[(signed long int)145] = "Standardanzeige";
  LW_LANGDE_DATA[(signed long int)146] = "Gradient 1";
  LW_LANGDE_DATA[(signed long int)147] = "Gradient 2";
  LW_LANGDE_DATA[(signed long int)148] = "Gradient 3";
  LW_LANGDE_DATA[(signed long int)149] = "Gradient 4";
  LW_LANGDE_DATA[(signed long int)150] = "Gradient 5";
  LW_LANGDE_DATA[(signed long int)151] = "Gradient 6";
  LW_LANGDE_DATA[(signed long int)152] = "Meshgroesse";
  LW_LANGDE_DATA[(signed long int)153] = "Meshaufbau";
  LW_LANGDE_DATA[(signed long int)154] = "Pause aus";
  LW_LANGDE_DATA[(signed long int)155] = "Pause";
  LW_LANGDE_DATA[(signed long int)156] = "Wellen aus";
  LW_LANGDE_DATA[(signed long int)157] = "Wellen an";
  LW_LANGDE_DATA[(signed long int)158] = "Fangvideo aus";
  LW_LANGDE_DATA[(signed long int)159] = "Fangvideo an";
  LW_LANGDE_DATA[(signed long int)160] = "Spitze!";
  LW_LANGDE_DATA[(signed long int)161] = "Keine Einheiten ueberlebten";
  LW_LANGDE_DATA[(signed long int)162] = "Kein Meshniederlage";
  LW_LANGDE_DATA[(signed long int)163] = "Meshniederlage";
  LW_LANGDE_DATA[(signed long int)164] = "Kein Gebiet mehr";
  LW_LANGDE_DATA[(signed long int)165] = "Keine Armee mehr";
  LW_LANGDE_DATA[(signed long int)166] = "Zu wenig Teams vorhanden. Es muessen mindestens 2 Teams da sein.";
  LW_LANGDE_DATA[(signed long int)167] = "Nicht genug Speicher vorhanden.";
  LW_LANGDE_DATA[(signed long int)168] = "Graphikmodus kann nicht gestartet werden.";
  LW_LANGDE_DATA[(signed long int)169] = "Keine Unterstuetzung fuer Netzwerk auf ihrem PC vorhanden.";
  LW_LANGDE_DATA[(signed long int)170] = "Verbindung nicht moeglich.\nMoeglicherweise sind ihre Einstellungen nicht korrekt oder sie benutzen eine Firewall, die den Datenverkehr blockiert.";
  LW_LANGDE_DATA[(signed long int)171] = "Keine Kommunikation mit dem Server moeglich\nWahrscheinlich ist der server kein LiquidWar Server";
  LW_LANGDE_DATA[(signed long int)172] = "Falsche Programmversion.\nServer und Programm muessen die gleiche Version haben (Programmversion ist: \"5.6.4\").";
  LW_LANGDE_DATA[(signed long int)173] = "Ein Netzwerkfehler trat auf.\nDies passiert meistens wenn die Verbindung mit demServer zu langsam oder gar nicht mehr vorhanden ist.";
  LW_LANGDE_DATA[(signed long int)174] = "Kann die Karte nicht zum Server senden.";
  LW_LANGDE_DATA[(signed long int)175] = "Kann die Map nicht vom Server empfangen.";
  LW_LANGDE_DATA[(signed long int)176] = "Dieser Server ist voll und kann derzeit keine weiteren Teams aufnehmen.";
  LW_LANGDE_DATA[(signed long int)177] = "Falsches Passwort.";
  LW_LANGDE_DATA[(signed long int)178] = "Eines der Configparameter ist falsch. Eventuell cheatet oder hackt jemand.";
  LW_LANGDE_DATA[(signed long int)179] = "Initalisierung fehlgeschlagen.";
  LW_LANGDE_DATA[(signed long int)180] = "Fr Bilder ist nicht genug Speicher vorhanden.";
  LW_LANGDE_DATA[(signed long int)181] = "Nicht genug Speicher vorhanden.";
  LW_LANGDE_DATA[(signed long int)182] = "Die Daten konnten nicht geladen werden. Sind sie sich sicher, dass Liquid Wars richtig installiert ist?";
  LW_LANGDE_DATA[(signed long int)183] = "Die selbsterstellten Daten konnten nicht geladen werden.";
  LW_LANGDE_DATA[(signed long int)184] = "Graphiken konnten nicht geladen werden.";
}

// lw_langde_string
// file langde.h line 70
extern char * lw_langde_string(signed int id)
{
  char *result = (char *)(void *)0;
  if(id >= 0 && !(id >= 185))
    result = LW_LANGDE_DATA[(signed long int)id];

  if(result == ((char *)NULL))
    result = "??? de";

  return result;
}

// lw_langdk_init
// file langdk.h line 69
extern void lw_langdk_init()
{
  memset((void *)LW_LANGDK_DATA, 0, sizeof(char *[185l]) /*1480ul*/ );
  LW_LANGDK_DATA[(signed long int)0] = "Danish";
  LW_LANGDK_DATA[(signed long int)1] = "Liquid War 5.6.4";
  LW_LANGDK_DATA[(signed long int)2] = "Idea: \n* Thomas Colcombet\n\nCoding: \n* Christian Mauduit\n\nMusic:\n* Tim Chadburn\n\nOther contributors:\n* Alstar\n* Peter Wang\n* Cort Danger Stratton\n* Jan Gretschuskin (www.game-factor.de)\n* Mouse\n* Rene Stach\n* Roderick Schertler\n* Ryan D. Brown\n* Eduard Bloch\n* Michael Terry\n* Kasper Hviid\n* David Redick\n* Alexandre Pineau\n* Michael Wagner\n* Peter Williams\n* Jan Samohyl\n* Gavin\n* Dave Vasilevsky\n* 2 of Omega\n* 666-REFIZUL-666\n* Thomas Klausner\n* Joan Dolc\n\nMore informations on www.ufoot.org/liquidwar/v5\n";
  LW_LANGDK_DATA[(signed long int)3] = "Liquid War er et flerpersoners krigsspil.\nCopyright (C) 1998-2007 Christian Mauduit (ufoot@ufoot.org)\n\nDette program er frit software; Du kan kopiere og aendre det under betingelserne i GNU General Public License, udgivet af Free Software Foundation; enten version 2 af Licensen, eller (dit valg) hvilken som helst senere version.\n\nDette program er udgivet i haabet om at det er brugbart, men UDEN NOGEN SOM HELST GARANTI; ikke engang nogen indforstaaet garanti for BRUGBARHED eller BRUGBARHED TIL ET SPECIFIKT FORMAAL. Laes GNU General Public License for flere detaljer.\n\nDu skulle have modtaget en kopi af GNU General Public License sammen med dette program; hvis ikke, skriv til Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\nMere information paa www.ufoot.org/liquidwar/v5\n";
  LW_LANGDK_DATA[(signed long int)4] = "GNU GENERAL PUBLIC LICENSE\n2. version, juni 1991 \n\nCopyright (C) 1989, 1991 Free Software Foundation, Inc. 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA \n\nEnhver har tilladelse til at kopiere og distribuere ordrette eksemplarer af dette licensdokument, men det er ikke tilladt at aendre det. \n\nForord \n\nDe fleste licenser paa software har til formaal at fjerne Deres ret til at dele softwaren med andre og aendre i det. I modsaetning hertil har GNU General Public License til formaal at garantere Deres ret til at dele og aendre frit software - for at sikre, at det paagaeldende software er tilgaengeligt for alle brugere. Denne licens, General Public License, er gaeldende for stoerstedelen af Free Software Foundations software samt for ethvert andet program, hvis ophavsmaend oensker at anvende licensen. (En del af Free Software Foundations programmer er i stedet omfattet af \"The GNU Library General Public License\".) De kan ogsaa anvende licensen til Deres programmer. \n\nVi taler om frit software - ikke gratis software. Dvs. vi taler om frihedsgraden, og ikke om prisen. Vores licenser, General Public Licenses, er udarbejdet med henblik paa at sikre Deres frihed til at distribuere kopier af frit software (og evt. tage betaling for denne ydelse) og at soerge for, at De modtager den paagaeldende kildetekst eller kan faa den, hvis De vil; at De kan aendre softwaren eller bruge dele af det til nye programmer; og at De er klar over, at De har disse rettigheder. \n\nFor at beskytte Deres rettigheder er vi noedt til at lave restriktioner, der forbyder andre at naegte Dem disse rettigheder eller kraeve, at De afstaar disse rettigheder. Disse restriktioner indebaerer visse forpligtelser for Dem, hvis De distribuerer kopier af softwaren eller aendrer det. \n\nHvis De f.eks. distribuerer kopier af et saadant program, enten gratis eller mod gebyr, er De forpligtet til at give modtagere alle de rettigheder, som De selv har. De skal sikre, at ogsaa modtagerne faar eller kan faa fat paa kildeteksten. Desuden er De forpligtet til, at vise modtagerne disse betingelser, saa de ogsaa er bekendt med deres rettigheder. \n\nVi beskytter Deres rettigheder med en totrinsmodel: (1) vi tager ophavsret paa softwaren og (2) vi tilbyder Dem denne licens, der giver Dem juridisk ret til at kopiere, distribuere og/eller aendre softwaren. \n\nDesuden vil vi med henblik paa at beskytte os selv og de enkelte softwareproducenter sikre os, at alle er bekendte med, at der ikke ydes nogen garanti paa dette frie software. Hvis programmet er aendret af en anden og givet videre, vil vi have, at modtagerne skal vide, at deres version ikke er det originale program. Saaledes undgaar vi, at eventuelle problemer indarbejdet af andre ikke skader de oprindelige softwareproducenters ry. \n\nEndelig er ethvert frit program under konstant trussel fra softwarepatenter. Vi oensker at undgaa faren for, at de, der videregiver et frit program, personligt udtager patentlicens, hvorved programmet faktisk bliver beskyttet af ophavsret. For at undgaa dette har vi gjort det klart, at ethvert patent skal registreres til alles frie afbenyttelse eller slet ikke registreres. \n\nNedenfor foelger de betingelser og vilkaar, der gaelder i forhold til at kopiere, distribuere og aendre software under General Public License. \n\nBETINGELSER OG VILKAAR FOR KOPIERING, DISTRIBUTION OG AENDRING AF SOFTWARE UNDER GENERAL PUBLIC LICENSE \n\n0. Denne licens gaelder for ethvert program eller andet vaerk, som ved siden af navnet paa ophavsretindehaveren har en meddelelse om, at det paagaeldende produkt maa distribueres under de gaeldende betingelser for denne General Public License. I det foelgende henviser ordet \"Program\" til ethvert saadant program eller vaerk, og et \"Vaerk baseret paa Programmet\" betegner enten Programmet eller ethvert afledt vaerk i henhold til lovgivningen om ophavsret. Det betyder med andre ord et vaerk, der indeholder Programmet eller en del af det, enten ordret eller aendret og/eller oversat til et andet sprog. (I det foelgende omfattes oversaettelser, uden begraensninger, af termen \"aendring\".) Enhver licenstager tiltales som \"De\". \n\nAktiviteter ud over kopiering, distribution og aendring er ikke daekket af denne licens men falder uden for dens omraade. Der er ingen restriktioner paa at koere Programmet, og outputtet fra Programmet er kun omfattet, hvis indholdet heraf udgoer et Vaerk baseret paa Programmet (uafhaengigt af at vaere blevet lavet ved at koere Programmet). Om dette er tilfaeldet, afhaenger af, hvad Programmet goer. \n\n1. De har ret til at kopiere og distribuere ordrette kopier af Programmets kildetekst, saaledes som De har modtaget den, i ethvert medium, under forudsaetning af, at alle kopier tydeligt og paa behoerig vis forsynes med en passende ophavsretmeddelelse og garantifraskrivelse; at alle meddelelser, der refererer til denne licens og den manglende garanti, bibeholdes; og at en kopi af denne licens vedlaegges, naar De distribuerer Programmet. \n\nDe har ret til at tage et gebyr for den fysiske handling at overfoere en kopi, og De kan eventuelt tilbyde garantibeskyttelse mod et gebyr. \n\n2. De har ret til at aendre Deres kopi eller kopier, eller en hvilken som helst del deraf, hvorved der skabes et Vaerk baseret paa Programmet, samt ret til at kopiere og distribuere saadanne aendringer eller vaerk i henhold til paragraf 1 ovenfor, forudsat De ogsaa opfylder foelgende betingelser: \nDe er forpligtet til at sikre, at de aendrede filer har en tydelig meddelelse om, at De har foretaget aendringer i filerne samt datoen herfor. \nDe er forpligtet til at sikre, at ethvert vaerk, som De distribuerer eller offentliggoer, der helt eller delvis indeholder Programmet, eller som er afledt af Programmet eller dele heraf, skal registreres til alles frie afbenyttelse i henhold til denne licens. \nHvis det aendrede program normalt laeser kommandoer interaktivt, naar det koeres, skal De sikre, at der ved starten paa programkoerslen for interaktiv brug paa den mest normale vis udskrives eller vises en meddelelse, som indeholder behoerig ophavsretmeddelelse og garantifraskrivelse (eller alternativt tilkendegive, at De oensker at tilbyde garanti) samt fortaeller, at brugere har ret til videredistribuere Programmet under disse betingelser. Desuden skal meddelelsen orientere brugeren om, hvordan en kopi af denne licens kan vises. (Undtagelse: Hvis selve Programmet er interaktivt, men ikke normalt printer en saadan besked, kraeves det ikke, at Deres Vaerk baseret paa Programmet printer den omtalte besked.) \nDisse krav er gaeldende for det aendrede vaerk i sin helhed. Hvis identificerbare sektioner af vaerket ikke er afledt af Programmet, og hvis disse i sig selv med rimelighed kan anses for at vaere selvstaendige og separate vaerker, saa gaelder denne licens og dens betingelser ikke for de sektioner, naar De distribuerer dem som separate vaerker. Hvis De derimod distribuerer de samme sektioner som en del af et hele, der udgoer et Vaerk baseret paa Programmet, skal denne distribution vaere i overensstemmelse med licensens betingelser. De rettigheder, som licensen yder alle, udvides til det paagaeldende vaerk i sin helhed og gaelder saaledes for enhver del af vaerket, uanset ophavsmanden. \n\nDet er saaledes ikke vores hensigt med denne paragraf at paaberaabe os rettigheder eller bestride Deres rettigheder til vaerker skrevet af Dem alene. Hensigten er derimod at udoeve vores ret til at kontrollere distributionen af afledte vaerker eller kollektive vaerker baseret paa Programmet. \n\nHertil kommer, at forekomsten af et andet vaerk paa et lagrings- eller distributionsmedium, der indeholder Programmet eller et Vaerk baseret paa Programmet, medfoerer ikke, at det andet vaerk omfattes af betingelserne for denne licens. \n\n3. De har ret til at kopiere og distribuere Programmet (eller et Vaerk baseret paa Programmet i henhold til paragraf 2) i objektkode eller i eksekverbar form i henhold til betingelserne i paragraf 1 og 2 under forudsaetning af, at De ogsaa foelger n af disse retningslinjer: \nProgrammet ledsages af den fuldstaendige maskinlaesbare kildetekst, der skal distribueres under de anfoerte betingelser i paragraf 1 og 2 ovenfor i et medium, der saedvanligvis bruges til udveksling af software; eller \nProgrammet ledsages af et skriftligt tilbud - gaeldende i mindst tre aar - om at give tredjemand den fuldstaendige maskinlaesbare kildetekst, der skal distribueres under de anfoerte betingelser i paragraf 1 og 2 ovenfor i et medium, der saedvanligvis bruges til udveksling af software, mod et gebyr, der maksimalt daekker Deres omkostninger ved rent fysisk at udfoere distributionen,; eller \nProgrammet ledsages af den information, som De modtog vedroerende tilbuddet om at distribuere kildeteksten. (Dette alternativ gaelder udelukkende for ukommerciel distribution, og kun hvis De har modtaget Programmet i objektkode eller i eksekverbar form med et saadant tilbud i henhold til stykke b ovenfor.) \nKildeteksten for et vaerk betyder den form af et givet vaerk, der foretraekkes som grundlag for at aendre det. For et eksekverbart vaerk betyder den fuldstaendige kildetekst hele kildeteksten for alle de moduler, det indeholder, plus eventuelle tilhoerende graenseflade-definitionsfiler plus de skripter, der anvendes til at kontrollere kompileringen og installeringen af det eksekverbare software. Helt undtagelsesvis behoever den kildetekst, der distribueres, dog ikke at indeholde noget, der normalt distribueres (enten i kildeform eller i binaer form) sammen med de stoerre komponenter i operativsystemet (compiler, kerneprogram, osv.), som det eksekverbare program koeres paa, medmindre den komponent selv ledsager det eksekverbare program. \n\nHvis distributionen af det eksekverbare program eller objektkoden foretages ved tilbud om adgang til at kopiere fra et angivet sted, regnes tilbud om tilsvarende adgang til at kopiere kildeteksten fra det samme sted som distribution af kildeteksten, ogsaa selv om tredjemand ikke er tvunget til at kopiere kildeteksten sammen med objektkoden. \n\n4. De har kun ret til at kopiere, aendre, udstede underlicenser for eller distribuere Programmet som udtrykkeligt anfoert i de specifikke betingelser for licensen. Herudover er ethvert forsoeg paa at kopiere, aendre, udstede underlicenser for eller distribuere Programmet ugyldigt og medfoerer automatisk ophoer af Deres rettigheder i henhold til denne licens. Paa den anden side vil tredjemand, der maatte have modtaget kopier eller rettigheder fra Dem i henhold til denne licens, ikke miste sin licens saa laenge alle betingelser for licensen overholdes. \n\n5. De er ikke forpligtet til at acceptere denne licens, eftersom De ikke har skrevet under paa den. De har dog ingen anden mulighed for at faa tilladelse til at aendre eller distribuere Programmet eller dets afledte vaerker, og de handlinger er forbudt ved lov, hvis De ikke accepterer denne licens. Ved at aendre eller distribuere Programmet (eller et Vaerk baseret paa Programmet) tilkendegiver De derfor Deres accept af licensen samt alle dens betingelser og vilkaar for at kopiere, distribuere eller aendre Programmet eller Vaerker baseret paa Programmet. \n\n6. Hver gang De distribuerer Programmet (eller et Vaerk baseret paa Programmet), faar modtageren automatisk licens fra den oprindelige licensgiver til at kopiere, distribuere eller aendre Programmet i henhold til disse betingelser og vilkaar. De har ikke ret til at paalaegge modtagerne yderligere restriktioner i deres brug af de rettigheder, der herved ydes. De er ikke ansvarlig for at haandhaeve tredjemands overholdelse af denne licens. \n\n7. Hvis De som foelge af en retsafgoerelse eller paastand om kraenkelse af patentret eller af en hvilken som helst anden grund (ikke begraenset til patentudstedelse) paatvinges vilkaar (det vaere sig ved retskendelse, kontrakt eller andet), der strider mod vilkaarene for denne licens, er De ikke dermed fritaget for vilkaarene for denne licens. Hvis De ikke kan distribuere Programmet, saaledes at De paa samme tid opfylder Deres forpligtelser i henhold til denne licens og i overensstemmelse med andre relevante forpligtelser, foelger det, at De ikke har tilladelse til at distribuere Programmet overhovedet. Hvis f.eks. en patentlicens ikke ville tillade afgiftsfri videredistribution af Programmet via alle dem, der modtager kopier direkte eller indirekte igennem Dem, ville den eneste maade, hvorpaa De kunne overholde baade patentlicensen og denne licens, at De fuldstaendigt afholder Dem fra at distribuere Programmet. \n\nDersom en del af denne paragraf erklaeres ugyldig eller bliver umulig at haandhaeve i en bestemt situation, er det hensigten, at resten af paragraffen skal finde anvendelse, ligesom det er hensigten, at paragraffen som helhed skal gaelde i andre situationer.  \nDet er saaledes ikke formaalet med denne paragraf at tilskynde Dem til at kraenke andre patenter eller ejendomskrav eller at bestride gyldigheden af saadanne krav. Denne paragraf har udelukkende til formaal at beskytte integriteten af distributionssystemet for frit software, som er implementeret gennem offentlig licenspraksis. Der er mange mennesker, der har ydet store bidrag til det brede udvalg af software, der distribueres via dette system i tiltro til, at systemet anvendes konsekvent. Det er op til softwareproducenten/donoren at beslutte, om han eller hun er villig til at distribuere software via et andet system, og en licenstager har ikke ret til at paatvinge nogen et saadant valg. \n\nFormaalet med denne paragraf er at goere det fuldstaendigt klart, hvad konsekvensen af resten af denne licens menes at vaere. \n\n8. Hvis distributionen og/eller brugen af Programmet er underlagt restriktioner i visse lande pga. enten patenter eller graenseflader, der er belagt med ophavsret, kan den oprindelige ophavsretindehaver, der har placeret Programmet under denne licens, tilfoeje en udtrykkelig geografisk distributionsbegraensning, der udelukker de paagaeldende lande, saaledes at distribution kun er tilladt i eller imellem lande, der ikke paa denne vis er udelukket. I tilfaelde heraf inkorporerer denne licens en saadan begraensning som om den var indarbejdet i selve licenstekstens ordlyd. \n\n9. The Free Software Foundation offentliggoer formodentligt reviderede og/eller nye versioner af sin General Public License fra tid til anden. Saadanne nye versioner vil udtrykke den samme grundlaeggende tankegang som den nuvaerende version, men visse detaljer vil sikkert aendres for at tage hoejde for nye vinkler eller problemer. \n\nDet er let at kende forskel paa de forskellige versioner, idet de alle er tydeligt forsynet med et nummer. Hvis Programmet specificerer et versionsnummer for denne licens som gaeldende for Programmet, tillige med ordene \"alle senere versioner\", har De mulighed for at vaelge, om De vil foelge vilkaar og betingelser for enten den version eller en anden senere version udgivet af The Free Software Foundation. Hvis Programmet ikke specificerer et versionsnummer for denne licens, kan De vaelge blandt samtlige versioner, der nogensinde er udgivet af The Free Software Foundation. \n\n10. Hvis De oensker at inkorporere dele af Programmet i andre frie programmer, der er underlagt andre distributionsbetingelser, foreslaar vi, at De skriver til ophavsmanden og anmoder om tilladelse. Hvis det drejer sig om software, hvor ophavsretten tilhoerer The Free Software Foundation, bedes De skrive til The Free Software Foundation. Der er visse undtagelser. Vores afgoerelse vil vaere baseret paa to maal - at bevare den frie status for alle afledte vaerker af vores frie software og at fremme udvekslingen og genbrugen af software generelt. \n\n\nINGEN GARANTI \n\n11. IDET LICENSEN GIVER GRATIS BRUGSTILLADELSE PAA PROGRAMMET, YDES DER INGEN GARANTI PAA PROGRAMMET I DET OMFANG, DET ER TILLADT EFTER GAELDENDE LOV. MEDMINDRE DET UDTRYKKELIGT MEDDELES SKRIFTLIGT, YDER OPHAVSRETINDEHAVERNE OG/ELLER ANDRE PARTER PROGRAMMET \"SOM BESET\" UDEN GARANTI AF NOGEN ART, DET VAERE SIG UDTRYKTE ELLER UNDERFORSTAAEDE GARANTIER, HERUNDER, MEN IKKE BEGRAENSET TIL, DE UNDERFORSTAAEDE GARANTIER VEDROERENDE SALGBARHED OG SPECIFIK BRUGSEGNETHED. DEN FULDE RISIKO, HVAD ANGAAR PROGRAMMETS KVALITET OG FUNKTION, PAAHVILER DEM. SKULLE DET VISE SIG, AT PROGRAMMET ER DEFEKT, SKAL DE ERHOLDE UDGIFTERNE TIL AL NOEDVENDIG SERVICE, REPARATION ELLER JUSTERING. \n\n12. UNDER INGEN OMSTAENDIGHEDER - MEDMINDRE DET KRAEVES AF GAELDENDE LOV ELLER ER SKRIFTLIGT AFTALT - SKAL EN OPHAVSRETINDEHAVER ELLER EN ANDEN PART, DER HAR TILLADELSE TIL AT AENDRE OG/ELLER DISTRIBUERE PROGRAMMET SAALEDES SOM BESKREVET OVENFOR, VAERE ERSTATNINGSANSVARLIG OVER FOR DEM VEDROERENDE SKADER, HERUNDER GENERELLE, SPECIFIKKE OG TILFAELDIGE SKADER SAMT FOELGESKADER I FORBINDELSE MED BRUG AF ELLER MANGLENDE BRUG AF PROGRAMMET (HERUNDER MEN IKKE BEGRAENSET TIL TAB AF DATA ELLER DATA, DER ER BLEVET UNOEJAGTIGE, ELLER TAB, DER ER PAAFOERT DEM ELLER TREDJEMAND, ELLER PROGRAMMETS MANGLENDE EVNE TIL AT KOERE SAMMEN MED ANDRE PROGRAMMER) SELV OM DEN PAAGAELDENDE OPHAVSRETINDEHAVER ELLER ANDEN PART ER BLEVET OPLYST OM MULIGHEDEN FOR, AT SAADANNE TAB KUNNE OPSTAA. \n\nHER SLUTTER BETINGELSER OG VILKAAR FOR GENERAL PUBLIC LICENSE\n\nMore informations on www.ufoot.org/liquidwar/v5\n";
  LW_LANGDK_DATA[(signed long int)5] = "Liquid War by U-Foot\n\nv5.6.4 \n\ncompiled on Jan 25 2016 at 05:34:54\n\nMere information paa www.ufoot.org/liquidwar/v5\n";
  LW_LANGDK_DATA[(signed long int)6] = "Start";
  LW_LANGDK_DATA[(signed long int)7] = "Netspil";
  LW_LANGDK_DATA[(signed long int)8] = "Baner";
  LW_LANGDK_DATA[(signed long int)9] = "Hold";
  LW_LANGDK_DATA[(signed long int)10] = "Indstillinger";
  LW_LANGDK_DATA[(signed long int)11] = "Om spillet";
  LW_LANGDK_DATA[(signed long int)12] = "Afslut";
  LW_LANGDK_DATA[(signed long int)13] = "Ud til DOS";
  LW_LANGDK_DATA[(signed long int)14] = "Afslut";
  LW_LANGDK_DATA[(signed long int)15] = "Afslut";
  LW_LANGDK_DATA[(signed long int)16] = "Tilbage til LW";
  LW_LANGDK_DATA[(signed long int)17] = "Afslut";
  LW_LANGDK_DATA[(signed long int)18] = "Tilbage";
  LW_LANGDK_DATA[(signed long int)19] = "Start";
  LW_LANGDK_DATA[(signed long int)20] = "Menu";
  LW_LANGDK_DATA[(signed long int)21] = "Lad kampen begynde!";
  LW_LANGDK_DATA[(signed long int)22] = "Start spil";
  LW_LANGDK_DATA[(signed long int)23] = "Server addr";
  LW_LANGDK_DATA[(signed long int)24] = "Server port";
  LW_LANGDK_DATA[(signed long int)25] = "Find internet-spil";
  LW_LANGDK_DATA[(signed long int)26] = "kodeord (*)";
  LW_LANGDK_DATA[(signed long int)27] = "(*) ADVARSEL! Benyt et svagt kodeord som \"hallo\", da det opbevares paa din harddisk og sendes til serveren som ren tekst.";
  LW_LANGDK_DATA[(signed long int)28] = "Automatisk";
  LW_LANGDK_DATA[(signed long int)29] = "Inaktiv";
  LW_LANGDK_DATA[(signed long int)30] = "Spiller";
  LW_LANGDK_DATA[(signed long int)31] = "CPU";
  LW_LANGDK_DATA[(signed long int)32] = "Grafik";
  LW_LANGDK_DATA[(signed long int)33] = "Lyd";
  LW_LANGDK_DATA[(signed long int)34] = "Regler";
  LW_LANGDK_DATA[(signed long int)35] = "Fart";
  LW_LANGDK_DATA[(signed long int)36] = "Kontrol";
  LW_LANGDK_DATA[(signed long int)37] = "Sprog";
  LW_LANGDK_DATA[(signed long int)38] = "Standard";
  LW_LANGDK_DATA[(signed long int)39] = "Spil";
  LW_LANGDK_DATA[(signed long int)40] = "Menu";
  LW_LANGDK_DATA[(signed long int)41] = "Til";
  LW_LANGDK_DATA[(signed long int)42] = "Fra";
  LW_LANGDK_DATA[(signed long int)43] = "Fuldskaerm";
  LW_LANGDK_DATA[(signed long int)44] = "Windowed";
  LW_LANGDK_DATA[(signed long int)45] = "Advanceret";
  LW_LANGDK_DATA[(signed long int)46] = "Video tilstand";
  LW_LANGDK_DATA[(signed long int)47] = "Lysstyrke";
  LW_LANGDK_DATA[(signed long int)48] = "Rammebredte";
  LW_LANGDK_DATA[(signed long int)49] = "Page flipping";
  LW_LANGDK_DATA[(signed long int)50] = "Waves (F4)";
  LW_LANGDK_DATA[(signed long int)51] = "Lydeffekter";
  LW_LANGDK_DATA[(signed long int)52] = "Klik";
  LW_LANGDK_DATA[(signed long int)53] = "Vand i spil";
  LW_LANGDK_DATA[(signed long int)54] = "Vand i menu";
  LW_LANGDK_DATA[(signed long int)55] = "MusiK";
  LW_LANGDK_DATA[(signed long int)56] = "Tid";
  LW_LANGDK_DATA[(signed long int)57] = "Advanceret";
  LW_LANGDK_DATA[(signed long int)58] = "Antal soldat";
  LW_LANGDK_DATA[(signed long int)59] = "Curser";
  LW_LANGDK_DATA[(signed long int)60] = "Standard";
  LW_LANGDK_DATA[(signed long int)61] = "Min ";
  LW_LANGDK_DATA[(signed long int)62] = "Angrib";
  LW_LANGDK_DATA[(signed long int)63] = "Forsvar";
  LW_LANGDK_DATA[(signed long int)64] = "Basalt helbred";
  LW_LANGDK_DATA[(signed long int)65] = "Vinderhjaelp";
  LW_LANGDK_DATA[(signed long int)66] = "CPU styrke";
  LW_LANGDK_DATA[(signed long int)67] = "CPU vs spiller";
  LW_LANGDK_DATA[(signed long int)68] = "Altid";
  LW_LANGDK_DATA[(signed long int)69] = "Tilfaeldigt";
  LW_LANGDK_DATA[(signed long int)70] = "Aldrig";
  LW_LANGDK_DATA[(signed long int)71] = "Algoritme";
  LW_LANGDK_DATA[(signed long int)72] = "Assembly";
  LW_LANGDK_DATA[(signed long int)73] = "Standard C";
  LW_LANGDK_DATA[(signed long int)74] = "Bots i netspil";
  LW_LANGDK_DATA[(signed long int)75] = "Ja";
  LW_LANGDK_DATA[(signed long int)76] = "Nej";
  LW_LANGDK_DATA[(signed long int)77] = "frames/s";
  LW_LANGDK_DATA[(signed long int)78] = "Ingen fps-graense";
  LW_LANGDK_DATA[(signed long int)79] = "Omgange/s";
  LW_LANGDK_DATA[(signed long int)80] = "Ingen rps-graense";
  LW_LANGDK_DATA[(signed long int)81] = "Joystick";
  LW_LANGDK_DATA[(signed long int)82] = "Fra";
  LW_LANGDK_DATA[(signed long int)83] = "2 joysticks";
  LW_LANGDK_DATA[(signed long int)84] = "4 knapper";
  LW_LANGDK_DATA[(signed long int)85] = "Standard";
  LW_LANGDK_DATA[(signed long int)86] = "In-game mouse sensibility";
  LW_LANGDK_DATA[(signed long int)87] = "Credits";
  LW_LANGDK_DATA[(signed long int)88] = "Copyright";
  LW_LANGDK_DATA[(signed long int)89] = "Licens";
  LW_LANGDK_DATA[(signed long int)90] = "Version";
  LW_LANGDK_DATA[(signed long int)91] = "Opdater";
  LW_LANGDK_DATA[(signed long int)92] = "Log ind";
  LW_LANGDK_DATA[(signed long int)93] = "Port";
  LW_LANGDK_DATA[(signed long int)94] = "Kodeord";
  LW_LANGDK_DATA[(signed long int)95] = "Ja";
  LW_LANGDK_DATA[(signed long int)96] = "Nej";
  LW_LANGDK_DATA[(signed long int)97] = "Uptime";
  LW_LANGDK_DATA[(signed long int)98] = "dage";
  LW_LANGDK_DATA[(signed long int)99] = "dage";
  LW_LANGDK_DATA[(signed long int)100] = "t";
  LW_LANGDK_DATA[(signed long int)101] = "min";
  LW_LANGDK_DATA[(signed long int)102] = "sek";
  LW_LANGDK_DATA[(signed long int)103] = "Unreachable";
  LW_LANGDK_DATA[(signed long int)104] = "Ping";
  LW_LANGDK_DATA[(signed long int)105] = "ms";
  LW_LANGDK_DATA[(signed long int)106] = "Ampli";
  LW_LANGDK_DATA[(signed long int)107] = "Antal";
  LW_LANGDK_DATA[(signed long int)108] = "Fart";
  LW_LANGDK_DATA[(signed long int)109] = "WX";
  LW_LANGDK_DATA[(signed long int)110] = "HY";
  LW_LANGDK_DATA[(signed long int)111] = "WY";
  LW_LANGDK_DATA[(signed long int)112] = "HX";
  LW_LANGDK_DATA[(signed long int)113] = "Start nu";
  LW_LANGDK_DATA[(signed long int)114] = "Vent...";
  LW_LANGDK_DATA[(signed long int)115] = "Venter paa ";
  LW_LANGDK_DATA[(signed long int)116] = " hold";
  LW_LANGDK_DATA[(signed long int)117] = "Send besked";
  LW_LANGDK_DATA[(signed long int)118] = "Connect";
  LW_LANGDK_DATA[(signed long int)119] = "Ping";
  LW_LANGDK_DATA[(signed long int)120] = "Check program";
  LW_LANGDK_DATA[(signed long int)121] = "Check version";
  LW_LANGDK_DATA[(signed long int)122] = "Kodeord";
  LW_LANGDK_DATA[(signed long int)123] = "Frie hold?";
  LW_LANGDK_DATA[(signed long int)124] = "Reserver hold";
  LW_LANGDK_DATA[(signed long int)125] = "Send config";
  LW_LANGDK_DATA[(signed long int)126] = "Send bane";
  LW_LANGDK_DATA[(signed long int)127] = "venter...";
  LW_LANGDK_DATA[(signed long int)128] = "Hvem spiller?";
  LW_LANGDK_DATA[(signed long int)129] = "Modtag konfig";
  LW_LANGDK_DATA[(signed long int)130] = "Modtag bane";
  LW_LANGDK_DATA[(signed long int)131] = "Brug standard-texture";
  LW_LANGDK_DATA[(signed long int)132] = "Til";
  LW_LANGDK_DATA[(signed long int)133] = "Fra";
  LW_LANGDK_DATA[(signed long int)134] = "Tilfaeldig bane";
  LW_LANGDK_DATA[(signed long int)135] = "frames/s ";
  LW_LANGDK_DATA[(signed long int)136] = "rounds/s ";
  LW_LANGDK_DATA[(signed long int)137] = "% calc ";
  LW_LANGDK_DATA[(signed long int)138] = "% display ";
  LW_LANGDK_DATA[(signed long int)139] = "Spread grad time ";
  LW_LANGDK_DATA[(signed long int)140] = "Move army time ";
  LW_LANGDK_DATA[(signed long int)141] = "Vis tid ";
  LW_LANGDK_DATA[(signed long int)142] = "Flip tid ";
  LW_LANGDK_DATA[(signed long int)143] = "Other calc time ";
  LW_LANGDK_DATA[(signed long int)144] = "Global tid ";
  LW_LANGDK_DATA[(signed long int)145] = "Standard display";
  LW_LANGDK_DATA[(signed long int)146] = "Gradient 1";
  LW_LANGDK_DATA[(signed long int)147] = "Gradient 2";
  LW_LANGDK_DATA[(signed long int)148] = "Gradient 3";
  LW_LANGDK_DATA[(signed long int)149] = "Gradient 4";
  LW_LANGDK_DATA[(signed long int)150] = "Gradient 5";
  LW_LANGDK_DATA[(signed long int)151] = "Gradient 6";
  LW_LANGDK_DATA[(signed long int)152] = "Gitter-stoerrelse";
  LW_LANGDK_DATA[(signed long int)153] = "gitterstruktur";
  LW_LANGDK_DATA[(signed long int)154] = "Pause Fra";
  LW_LANGDK_DATA[(signed long int)155] = "Pause til";
  LW_LANGDK_DATA[(signed long int)156] = "Wave-effekter fra";
  LW_LANGDK_DATA[(signed long int)157] = "Wave-effekter til";
  LW_LANGDK_DATA[(signed long int)158] = "Video capture fra";
  LW_LANGDK_DATA[(signed long int)159] = "Video capture til";
  LW_LANGDK_DATA[(signed long int)160] = "Vinder";
  LW_LANGDK_DATA[(signed long int)161] = "Back mem fail";
  LW_LANGDK_DATA[(signed long int)162] = "Disp mem fail";
  LW_LANGDK_DATA[(signed long int)163] = "Mesh mem fail";
  LW_LANGDK_DATA[(signed long int)164] = "Area mem fail";
  LW_LANGDK_DATA[(signed long int)165] = "Army mem fail";
  LW_LANGDK_DATA[(signed long int)166] = "Ikke nok hold.\nDu skal mindst vaelge 2 hold fra \"Hold\" menuen.";
  LW_LANGDK_DATA[(signed long int)167] = "Ikke nok hukommelse til at udvide level.\nBrug et mindre level eller laes dokumentationen og brug kommandolinie-parametre som \"-mem n\".";
  LW_LANGDK_DATA[(signed long int)168] = "Kan ikke starte grafisk tilstand";
  LW_LANGDK_DATA[(signed long int)169] = "Intet netvaerkssupport paa denne platform.\nKun Windows og UNIX har det.";
  LW_LANGDK_DATA[(signed long int)170] = "Kan ikke faa forbindelse med serveren.\nMaaske er det ikke korrekt sat op, eller du er bag en firewall der forbyder forbindelsen.";
  LW_LANGDK_DATA[(signed long int)171] = "Kan ikke kommunikere med serveren.\nDet er nok ikke nogen Liquid War server.";
  LW_LANGDK_DATA[(signed long int)172] = "Forkert client/server version.\nServer og client skal have samme version (Denne klient's version er \"5.6.4\").";
  LW_LANGDK_DATA[(signed long int)173] = "Der er sket en netvaerksfejl.\nDette sker ofte hvis serveren er for langsom eller mistet.";
  LW_LANGDK_DATA[(signed long int)174] = "Kan ikke sende banen til serveren.";
  LW_LANGDK_DATA[(signed long int)175] = "Kan ikke modtage banen fra serveren.";
  LW_LANGDK_DATA[(signed long int)176] = "Serveren er fuld og accepterer ikke flere hold.";
  LW_LANGDK_DATA[(signed long int)177] = "Forkert kodeord.";
  LW_LANGDK_DATA[(signed long int)178] = "En af konfigurationsparametrene er is \"out of range\". Der en enten en fejl i spillet, nogen snyder og/eller proever at hacke noget.";
  LW_LANGDK_DATA[(signed long int)179] = "Init failed.";
  LW_LANGDK_DATA[(signed long int)180] = "Der er ikke nok hukommelse til bitmaps.";
  LW_LANGDK_DATA[(signed long int)181] = "Der er ikke nok hukommelse.";
  LW_LANGDK_DATA[(signed long int)182] = "Kan ikke loade datafil. Er du sikker paa at Liquid War er korrekt installeret?";
  LW_LANGDK_DATA[(signed long int)183] = "Kan ikke loade custom data.";
  LW_LANGDK_DATA[(signed long int)184] = "Kan ikke initialisere grafik.";
}

// lw_langdk_string
// file langdk.h line 70
extern char * lw_langdk_string(signed int id)
{
  char *result = (char *)(void *)0;
  if(id >= 0 && !(id >= 185))
    result = LW_LANGDK_DATA[(signed long int)id];

  if(result == ((char *)NULL))
    result = "??? en";

  return result;
}

// lw_langen_init
// file langen.h line 69
extern void lw_langen_init()
{
  memset((void *)LW_LANGEN_DATA, 0, sizeof(char *[185l]) /*1480ul*/ );
  LW_LANGEN_DATA[(signed long int)0] = "English";
  LW_LANGEN_DATA[(signed long int)1] = "Liquid War 5.6.4";
  LW_LANGEN_DATA[(signed long int)2] = "Idea: \n* Thomas Colcombet\n\nCoding: \n* Christian Mauduit\n\nMusic:\n* Tim Chadburn\n\nOther contributors:\n* Alstar\n* Peter Wang\n* Cort Danger Stratton\n* Jan Gretschuskin (www.game-factor.de)\n* Mouse\n* Rene Stach\n* Roderick Schertler\n* Ryan D. Brown\n* Eduard Bloch\n* Michael Terry\n* Kasper Hviid\n* David Redick\n* Alexandre Pineau\n* Michael Wagner\n* Peter Williams\n* Jan Samohyl\n* Gavin\n* Dave Vasilevsky\n* 2 of Omega\n* 666-REFIZUL-666\n* Thomas Klausner\n* Joan Dolc\n\nMore informations on www.ufoot.org/liquidwar/v5\n";
  LW_LANGEN_DATA[(signed long int)3] = "Liquid War is a multiplayer wargame.\nCopyright (C) 1998-2007 Christian Mauduit (ufoot@ufoot.org)\n\nThis program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\nMore informations on www.ufoot.org/liquidwar/v5\n";
  LW_LANGEN_DATA[(signed long int)4] = "GNU GENERAL PUBLIC LICENSE\nVersion 2, June 1991\n\nCopyright (C) 1989, 1991 Free Software Foundation, Inc. 675 Mass Ave, Cambridge, MA 02139, USA\n\nEveryone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.\n\nPreamble\n\nThe licenses for most software are designed to take away your freedom to share and change it.  By contrast, the GNU General Public License is intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users.  This General Public License applies to most of the Free Software Foundation's software and to any other program whose authors commit to using it.  (Some other Free Software Foundation software is covered by the GNU Library General Public License instead.)  You can apply it to your programs, too.\n\nWhen we speak of free software, we are referring to freedom, not price.  Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things. \n\nTo protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it. \n\nFor example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have.  You must make sure that they, too, receive or can get the source code.  And you must show them these terms so they know their rights.\n\nWe protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the software.\n\nAlso, for each author's protection and ours, we want to make certain that everyone understands that there is no warranty for this free software.  If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors' reputations.\n\nFinally, any free program is threatened constantly by software patents.  We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary.  To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all.\n\nThe precise terms and conditions for copying, distribution and modification follow.\n\nGNU GENERAL PUBLIC LICENSE\nTERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n0. This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License.  The \"Program\", below, refers to any such program or work, and a \"work based on the Program\" means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language.  (Hereinafter, translation is included without limitation in the term \"modification\".)  Each licensee is addressed as \"you\".\nActivities other than copying, distribution and modification are not covered by this License; they are outside its scope.  The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program). Whether that is true depends on what the Program does. \n\n1. You may copy and distribute verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and give any other recipients of the Program a copy of this License along with the Program. \nYou may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.\n\n2. You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions: \na) You must cause the modified files to carry prominent notices stating that you changed the files and the date of any change.\nb) You must cause any work that you distribute or publish, that in whole or in part contains or is derived from the Program or any part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License.\nc) If the modified program normally reads commands interactively when run, you must cause it, when started running for such interactive use in the most ordinary way, to print or display an announcement including an appropriate copyright notice and a notice that there is no warranty (or else, saying that you provide a warranty) and that users may redistribute the program under these conditions, and telling the user how to view a copy of this License.  (Exception: if the Program itself is interactive but does not normally print such an announcement, your work based on the Program is not required to print an announcement.)\nThese requirements apply to the modified work as a whole.  If identifiable sections of that work are not derived from the Program, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works.  But when you distribute the same sections as part of a whole which is a work based on the Program, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.\nThus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Program. \nIn addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a storage or distribution medium does not bring the other work under the scope of this License. \n\n3. You may copy and distribute the Program (or a work based on it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you also do one of the following:\na) Accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,\nb) Accompany it with a written offer, valid for at least three years, to give any third party, for a charge no more than your cost of physically performing source distribution, a complete machine-readable copy of the corresponding source code, to be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,\nc) Accompany it with the information you received as to the offer to distribute corresponding source code.  (This alternative is allowed only for noncommercial distribution and only if you received the program in object code or executable form with such an offer, in accord with Subsection b above.)\nThe source code for a work means the preferred form of the work for making modifications to it.  For an executable work, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the executable.  However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.\nIf distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the source along with the object code.\f\n\n4. You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License.  Any attempt otherwise to copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.\n\n5. You are not required to accept this License, since you have not signed it.  However, nothing else grants you permission to modify or distribute the Program or its derivative works.  These actions are prohibited by law if you do not accept this License.  Therefore, by modifying or distributing the Program (or any work based on the Program), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Program or works based on it.\n\n6. Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the original licensor to copy, distribute or modify the Program subject to these terms and conditions.  You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties to this License.\n\n7. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License.  If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Program at all.  For example, if a patent license would not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Program.\nIf any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply and the section as a whole is intended to apply in other circumstances.\nIt is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public license practices.  Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.\nThis section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.\n\n8. If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded.  In such case, this License incorporates the limitation as if written in the body of this License.\n\n9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.\nEach version is given a distinguishing version number.  If the Program specifies a version number of this License which applies to it and \"any later version\", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation.  If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation. \n\n10. If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the author to ask for permission.  For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this.  Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.\n\nNO WARRANTY\n\n11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. \n\n12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n\nEND OF TERMS AND CONDITIONS\n\nMore informations on www.ufoot.org/liquidwar/v5\n";
  LW_LANGEN_DATA[(signed long int)5] = "Liquid War by U-Foot\n\nv5.6.4 \n\ncompiled on Jan 25 2016 at 05:34:55\n\nMore informations on www.ufoot.org/liquidwar/v5\n";
  LW_LANGEN_DATA[(signed long int)6] = "Play";
  LW_LANGEN_DATA[(signed long int)7] = "Net game";
  LW_LANGEN_DATA[(signed long int)8] = "Map";
  LW_LANGEN_DATA[(signed long int)9] = "Teams";
  LW_LANGEN_DATA[(signed long int)10] = "Options";
  LW_LANGEN_DATA[(signed long int)11] = "About";
  LW_LANGEN_DATA[(signed long int)12] = "Exit";
  LW_LANGEN_DATA[(signed long int)13] = "Exit to DOS";
  LW_LANGEN_DATA[(signed long int)14] = "Exit";
  LW_LANGEN_DATA[(signed long int)15] = "Exit";
  LW_LANGEN_DATA[(signed long int)16] = "Back to LW";
  LW_LANGEN_DATA[(signed long int)17] = "Quit";
  LW_LANGEN_DATA[(signed long int)18] = "Back";
  LW_LANGEN_DATA[(signed long int)19] = "Play";
  LW_LANGEN_DATA[(signed long int)20] = "Main";
  LW_LANGEN_DATA[(signed long int)21] = "Get ready!";
  LW_LANGEN_DATA[(signed long int)22] = "Start game";
  LW_LANGEN_DATA[(signed long int)23] = "Server addr";
  LW_LANGEN_DATA[(signed long int)24] = "Server port";
  LW_LANGEN_DATA[(signed long int)25] = "Search for internet games";
  LW_LANGEN_DATA[(signed long int)26] = "Password (*)";
  LW_LANGEN_DATA[(signed long int)27] = "(*) WARNING! Choose a weak password like \"hello\", for it is stored on your hard drive and sent to the server as plain text.";
  LW_LANGEN_DATA[(signed long int)28] = "Automatic";
  LW_LANGEN_DATA[(signed long int)29] = "Off";
  LW_LANGEN_DATA[(signed long int)30] = "Human";
  LW_LANGEN_DATA[(signed long int)31] = "Cpu";
  LW_LANGEN_DATA[(signed long int)32] = "Graphics";
  LW_LANGEN_DATA[(signed long int)33] = "Sound";
  LW_LANGEN_DATA[(signed long int)34] = "Rules";
  LW_LANGEN_DATA[(signed long int)35] = "Speeds";
  LW_LANGEN_DATA[(signed long int)36] = "Controls";
  LW_LANGEN_DATA[(signed long int)37] = "Language";
  LW_LANGEN_DATA[(signed long int)38] = "Defaults";
  LW_LANGEN_DATA[(signed long int)39] = "Game";
  LW_LANGEN_DATA[(signed long int)40] = "Menu";
  LW_LANGEN_DATA[(signed long int)41] = "On";
  LW_LANGEN_DATA[(signed long int)42] = "Off";
  LW_LANGEN_DATA[(signed long int)43] = "Fullscreen";
  LW_LANGEN_DATA[(signed long int)44] = "Windowed";
  LW_LANGEN_DATA[(signed long int)45] = "Advanced";
  LW_LANGEN_DATA[(signed long int)46] = "Video mode";
  LW_LANGEN_DATA[(signed long int)47] = "Brightness";
  LW_LANGEN_DATA[(signed long int)48] = "Viewport size";
  LW_LANGEN_DATA[(signed long int)49] = "Page flipping";
  LW_LANGEN_DATA[(signed long int)50] = "Waves (F4)";
  LW_LANGEN_DATA[(signed long int)51] = "Sound fx";
  LW_LANGEN_DATA[(signed long int)52] = "Click";
  LW_LANGEN_DATA[(signed long int)53] = "Game water";
  LW_LANGEN_DATA[(signed long int)54] = "Menu water";
  LW_LANGEN_DATA[(signed long int)55] = "Music";
  LW_LANGEN_DATA[(signed long int)56] = "Time";
  LW_LANGEN_DATA[(signed long int)57] = "Advanced";
  LW_LANGEN_DATA[(signed long int)58] = "Army size";
  LW_LANGEN_DATA[(signed long int)59] = "Cursor";
  LW_LANGEN_DATA[(signed long int)60] = "Defaults";
  LW_LANGEN_DATA[(signed long int)61] = "Min ";
  LW_LANGEN_DATA[(signed long int)62] = "Attack";
  LW_LANGEN_DATA[(signed long int)63] = "Defense";
  LW_LANGEN_DATA[(signed long int)64] = "Base health";
  LW_LANGEN_DATA[(signed long int)65] = "Winner help";
  LW_LANGEN_DATA[(signed long int)66] = "CPU strength";
  LW_LANGEN_DATA[(signed long int)67] = "CPU vs human";
  LW_LANGEN_DATA[(signed long int)68] = "Always";
  LW_LANGEN_DATA[(signed long int)69] = "Random";
  LW_LANGEN_DATA[(signed long int)70] = "Never";
  LW_LANGEN_DATA[(signed long int)71] = "Algorithm";
  LW_LANGEN_DATA[(signed long int)72] = "Assembly";
  LW_LANGEN_DATA[(signed long int)73] = "Standard C";
  LW_LANGEN_DATA[(signed long int)74] = "Allow net bots";
  LW_LANGEN_DATA[(signed long int)75] = "Yes";
  LW_LANGEN_DATA[(signed long int)76] = "No";
  LW_LANGEN_DATA[(signed long int)77] = "frames/s";
  LW_LANGEN_DATA[(signed long int)78] = "No fps limit";
  LW_LANGEN_DATA[(signed long int)79] = "rounds/s";
  LW_LANGEN_DATA[(signed long int)80] = "No rps limit";
  LW_LANGEN_DATA[(signed long int)81] = "Joystick";
  LW_LANGEN_DATA[(signed long int)82] = "Off";
  LW_LANGEN_DATA[(signed long int)83] = "2 joysticks";
  LW_LANGEN_DATA[(signed long int)84] = "4 buttons";
  LW_LANGEN_DATA[(signed long int)85] = "Standard";
  LW_LANGEN_DATA[(signed long int)86] = "In-game mouse sensibility";
  LW_LANGEN_DATA[(signed long int)87] = "Credits";
  LW_LANGEN_DATA[(signed long int)88] = "Copyright";
  LW_LANGEN_DATA[(signed long int)89] = "License";
  LW_LANGEN_DATA[(signed long int)90] = "Version";
  LW_LANGEN_DATA[(signed long int)91] = "Refresh";
  LW_LANGEN_DATA[(signed long int)92] = "Join now";
  LW_LANGEN_DATA[(signed long int)93] = "Port";
  LW_LANGEN_DATA[(signed long int)94] = "Password";
  LW_LANGEN_DATA[(signed long int)95] = "yes";
  LW_LANGEN_DATA[(signed long int)96] = "no";
  LW_LANGEN_DATA[(signed long int)97] = "Uptime";
  LW_LANGEN_DATA[(signed long int)98] = "days";
  LW_LANGEN_DATA[(signed long int)99] = "day";
  LW_LANGEN_DATA[(signed long int)100] = "h";
  LW_LANGEN_DATA[(signed long int)101] = "min";
  LW_LANGEN_DATA[(signed long int)102] = "sec";
  LW_LANGEN_DATA[(signed long int)103] = "Unreachable";
  LW_LANGEN_DATA[(signed long int)104] = "Ping";
  LW_LANGEN_DATA[(signed long int)105] = "ms";
  LW_LANGEN_DATA[(signed long int)106] = "Ampli";
  LW_LANGEN_DATA[(signed long int)107] = "Number";
  LW_LANGEN_DATA[(signed long int)108] = "Speed";
  LW_LANGEN_DATA[(signed long int)109] = "WX";
  LW_LANGEN_DATA[(signed long int)110] = "HY";
  LW_LANGEN_DATA[(signed long int)111] = "WY";
  LW_LANGEN_DATA[(signed long int)112] = "HX";
  LW_LANGEN_DATA[(signed long int)113] = "Start now";
  LW_LANGEN_DATA[(signed long int)114] = "Waiting...";
  LW_LANGEN_DATA[(signed long int)115] = "Waiting for ";
  LW_LANGEN_DATA[(signed long int)116] = " team(s)";
  LW_LANGEN_DATA[(signed long int)117] = "Send message";
  LW_LANGEN_DATA[(signed long int)118] = "Connect";
  LW_LANGEN_DATA[(signed long int)119] = "Ping";
  LW_LANGEN_DATA[(signed long int)120] = "Check program";
  LW_LANGEN_DATA[(signed long int)121] = "Check version";
  LW_LANGEN_DATA[(signed long int)122] = "Password";
  LW_LANGEN_DATA[(signed long int)123] = "Free teams?";
  LW_LANGEN_DATA[(signed long int)124] = "Reserve teams";
  LW_LANGEN_DATA[(signed long int)125] = "Send config";
  LW_LANGEN_DATA[(signed long int)126] = "Send map";
  LW_LANGEN_DATA[(signed long int)127] = "Waiting...";
  LW_LANGEN_DATA[(signed long int)128] = "Who plays?";
  LW_LANGEN_DATA[(signed long int)129] = "Receive config";
  LW_LANGEN_DATA[(signed long int)130] = "Receive map";
  LW_LANGEN_DATA[(signed long int)131] = "Use default texture";
  LW_LANGEN_DATA[(signed long int)132] = "On";
  LW_LANGEN_DATA[(signed long int)133] = "Off";
  LW_LANGEN_DATA[(signed long int)134] = "Random map";
  LW_LANGEN_DATA[(signed long int)135] = "frames/s ";
  LW_LANGEN_DATA[(signed long int)136] = "rounds/s ";
  LW_LANGEN_DATA[(signed long int)137] = "% calc ";
  LW_LANGEN_DATA[(signed long int)138] = "% display ";
  LW_LANGEN_DATA[(signed long int)139] = "Spread grad time ";
  LW_LANGEN_DATA[(signed long int)140] = "Move army time ";
  LW_LANGEN_DATA[(signed long int)141] = "Display time ";
  LW_LANGEN_DATA[(signed long int)142] = "Flip time ";
  LW_LANGEN_DATA[(signed long int)143] = "Other calc time ";
  LW_LANGEN_DATA[(signed long int)144] = "Global time ";
  LW_LANGEN_DATA[(signed long int)145] = "Standard display";
  LW_LANGEN_DATA[(signed long int)146] = "Gradient 1";
  LW_LANGEN_DATA[(signed long int)147] = "Gradient 2";
  LW_LANGEN_DATA[(signed long int)148] = "Gradient 3";
  LW_LANGEN_DATA[(signed long int)149] = "Gradient 4";
  LW_LANGEN_DATA[(signed long int)150] = "Gradient 5";
  LW_LANGEN_DATA[(signed long int)151] = "Gradient 6";
  LW_LANGEN_DATA[(signed long int)152] = "Mesh size";
  LW_LANGEN_DATA[(signed long int)153] = "Mesh structure";
  LW_LANGEN_DATA[(signed long int)154] = "Pause off";
  LW_LANGEN_DATA[(signed long int)155] = "Pause on";
  LW_LANGEN_DATA[(signed long int)156] = "Wave effects off";
  LW_LANGEN_DATA[(signed long int)157] = "Wave effects on";
  LW_LANGEN_DATA[(signed long int)158] = "Video capture off";
  LW_LANGEN_DATA[(signed long int)159] = "Video capture on";
  LW_LANGEN_DATA[(signed long int)160] = "Winner";
  LW_LANGEN_DATA[(signed long int)161] = "Back mem fail";
  LW_LANGEN_DATA[(signed long int)162] = "Disp mem fail";
  LW_LANGEN_DATA[(signed long int)163] = "Mesh mem fail";
  LW_LANGEN_DATA[(signed long int)164] = "Area mem fail";
  LW_LANGEN_DATA[(signed long int)165] = "Army mem fail";
  LW_LANGEN_DATA[(signed long int)166] = "Not enough teams.\nYou must select at least 2 teams from the \"Teams\" menu.";
  LW_LANGEN_DATA[(signed long int)167] = "Not enough memory to expand level.\nChoose a smaller level or look at the documentation and try command line options such as \"-mem n\".";
  LW_LANGEN_DATA[(signed long int)168] = "Unable to start graphic mode";
  LW_LANGEN_DATA[(signed long int)169] = "No network support for this platform.\nOnly Windows and UNIX have it.";
  LW_LANGEN_DATA[(signed long int)170] = "Unable to connect to the server.\nMaybe it's not correctly set up, or you are behind a firewall which forbids the connection.";
  LW_LANGEN_DATA[(signed long int)171] = "Unable to communicate with the server.\nIt doesn't seem to be a Liquid War server.";
  LW_LANGEN_DATA[(signed long int)172] = "Wrong client/server versions.\nServer and client must have the same version (this client's version is \"5.6.4\").";
  LW_LANGEN_DATA[(signed long int)173] = "A network error has occured.\nThis often happens when the connection with the server is too slow or simply lost.";
  LW_LANGEN_DATA[(signed long int)174] = "Unable to send the map to the server.";
  LW_LANGEN_DATA[(signed long int)175] = "Unable to receive the map from the server.";
  LW_LANGEN_DATA[(signed long int)176] = "This server is full and doesn't accept new teams for now.";
  LW_LANGEN_DATA[(signed long int)177] = "Incorrect password.";
  LW_LANGEN_DATA[(signed long int)178] = "One of the config parameters is out of range. Either there's a bug in the game, or someone is cheating and/or trying to hack something.";
  LW_LANGEN_DATA[(signed long int)179] = "Init failed.";
  LW_LANGEN_DATA[(signed long int)180] = "Not enough memory for bitmaps.";
  LW_LANGEN_DATA[(signed long int)181] = "Not enough memory.";
  LW_LANGEN_DATA[(signed long int)182] = "Unable to load datafile. Are you sure Liquid War is correctly installed?";
  LW_LANGEN_DATA[(signed long int)183] = "Unable to load custom data.";
  LW_LANGEN_DATA[(signed long int)184] = "Unable to initialize graphics.";
}

// lw_langen_string
// file langen.h line 70
extern char * lw_langen_string(signed int id)
{
  char *result = (char *)(void *)0;
  if(id >= 0 && !(id >= 185))
    result = LW_LANGEN_DATA[(signed long int)id];

  if(result == ((char *)NULL))
    result = "??? en";

  return result;
}

// lw_langfr_init
// file langfr.h line 69
extern void lw_langfr_init()
{
  memset((void *)LW_LANGFR_DATA, 0, sizeof(char *[185l]) /*1480ul*/ );
  LW_LANGFR_DATA[(signed long int)0] = "Francais";
  LW_LANGFR_DATA[(signed long int)1] = "Liquid War 5.6.4";
  LW_LANGFR_DATA[(signed long int)2] = "Idee: \n* Thomas Colcombet\n\nProgrammation: \n* Christian Mauduit\n\nMusique: \n* Tim Chadburn\n\nAutres contributeurs:\n* Alstar\n* Peter Wang\n* Cort Danger Stratton\n* Jan Gretschuskin (www.game-factor.de)\n* Mouse\n* Rene Stach\n* Roderick Schertler\n* Ryan D. Brown\n* Eduard Bloch\n* Michael Terry\n* Kasper Hviid\n* David Redick\n* Alexandre Pineau\n* Michael Wagner\n* Peter Williams\n* Jan Samohyl\n* Gavin\n* Dave Vasilevsky\n* 2 of Omega\n* 666-REFIZUL-666\n* Thomas Klausner\n* Joan Dolc\n\nPlus d'informations sur www.ufoot.org/liquidwar/v5\n";
  LW_LANGFR_DATA[(signed long int)3] = "Liquid War est un \"wargame\" multijoueur.\nCopyright (C) 1998-2007 Christian Mauduit (ufoot@ufoot.org)\n\nCe programme est un logiciel libre ; vous pouvez le redistribuer et/ou le modifier conformement aux dispositions de la Licence Publique Generale GNU, telle que publiee par la Free Software Foundation ; version 2 de la licence, ou encore (a votre choix) toute version ulterieure.\n\nCe programme est distribue dans l'espoir qu'il sera utile, mais SANS AUCUNE GARANTIE ; sans meme la garantie implicite de COMMERCIALISATION ou D'ADAPTATION A UN OBJET PARTICULIER. Pour plus de detail, voir la Licence Publique Generale GNU .\n\nVous devez avoir recu un exemplaire de la Licence Publique Generale GNU en meme temps que ce programme ; si ce n'est pas le cas, ecrivez a la Free Software Foundation Inc., 675 Mass Ave, Cambridge, MA 02139, Etats-Unis.\n\nPlus d'informations sur www.ufoot.org/liquidwar/v5\n";
  LW_LANGFR_DATA[(signed long int)4] = "Traduction de la GPL\n\nNotice d'accompagnement de la traduction non officielle a conserver dans toute reproduction de cette traduction\n\nThis is an unofficial translation of the GNU General Public License into french. It was not published by the Free Software Foundation, and does not legally state the distribution terms for software that uses the GNU GPL--only the original English text of the GNU GPL does that. However, we hope that this translation will help french speakers understand the GNU GPL better.\n\nCeci est une traduction non officielle de la GNU General Public License en francais. Elle n'a pas ete publiee par la Free Software Foundation, et ne determine pas les termes de distribution pour les logiciels qui utilisent la GNU GPL--seul le texte anglais original de la GNU GPL en a le droit. Cependant, nous esperons que cette traduction aidera les francophones a mieux comprendre la GPL.\n\nCette traduction est sous Copyright 2001 APRIL (http://www.april.org). \nLa version la plus a jour de ce document est disponible sur http://www.april.org/gnu/gpl_french.html\n\nIl est permis a tout le monde de reproduire et distribuer des copies conformes de cette traduction, mais aucune modification ne doit y etre apportee, et la presente notice doit etre preservee.\n\nNous autorisons la FSF a apporter toute modification qu'elle jugera necessaire pour rendre la traduction plus claire.\n\nGNU GENERAL PUBLIC LICENSE (TRADUCTION NON OFFICIELLE)\n\nVersion 2, juin 1991\n\nCopyright (C) 1989, 1991, Free Software Foundation Inc. 675 Mass Ave, Cambridge, MA02139, Etats-Unis.\n\nIl est permis a tout le monde de reproduire et distribuer des copies conformes de ce document de licence, mais aucune modification ne doit y etre apportee.\n\nPreambule\n\nLes licences relatives a la plupart des logiciels sont destinees a supprimer votre liberte de les partager et de les modifier. Par contraste, la licence publique generale GNU General Public License veut garantir votre liberte de partager et de modifier les logiciels libres, pour qu'ils soient vraiment libres pour tous leurs utilisateurs. La presente licence publique generale s'applique a la plupart des logiciels de la Free Software Foundation, ainsi qu'a tout autre programme dont les auteurs s'engagent a l'utiliser. (Certains autres logiciels sont couverts par la Licence Publique Generale pour Bibliotheques GNU a la place). Vous pouvez aussi l'appliquer a vos programmes.\n\nQuand nous parlons de logiciels libres, nous parlons de liberte, non de gratuite. Nos licences publiques generales veulent vous garantir :\n\n* que vous avez toute liberte de distribuer des copies des logiciels libres (et de facturer ce service, si vous le souhaitez) ;\n\n* que vous recevez les codes sources ou pouvez les obtenir si vous le souhaitez ;\n\n* que vous pouvez modifier les logiciels ou en utiliser des elements dans de nouveaux programmes libres ;\n\n* et que vous savez que vous pouvez le faire.\n\nPour proteger vos droits, nous devons apporter des restrictions, qui vont interdire a quiconque de vous denier ces droits, ou de vous demander de vous en desister. Ces restrictions se traduisent par certaines responsabilites pour ce qui vous concerne, si vous distribuez des copies de logiciels, ou si vous les modifiez.\n\nPar exemple, si vous distribuez des copies d'un tel programme, gratuitement ou contre une remuneration, vous devez transferer aux destinataires tous les droits dont vous disposez. Vous devez vous garantir qu'eux-memes, par ailleurs, recoivent ou peuvent recevoir le code source. Et vous devez leur montrer les presentes dispositions, de facon qu'ils connaissent leurs droits.\n\nNous protegeons vos droits en deux etapes :\n\n1. Nous assurons le droit d'auteur (copyright) du logiciel, et\n\n2. Nous vous proposons cette licence, qui vous donne l'autorisation legale de dupliquer, distribuer et/ou modifier le logiciel.\n\nDe meme, pour la protection de chacun des auteurs, et pour notre propre protection, nous souhaitons nous assurer que tout le monde comprenne qu'il n'y a aucune garantie portant sur ce logiciel libre. Si le logiciel est modifie par quelqu'un d'autre puis transmis a des tiers, nous souhaitons que les destinataires sachent que ce qu'ils possedent n'est pas l'original, de facon que tous problemes introduits par d'autres ne se traduisent pas par une repercussion negative sur la reputation de l'auteur original.\n\nEnfin, tout programme libre est en permanence menace par des brevets de logiciels. Nous souhaitons eviter le danger que des sous-distributeurs d'un programme libre obtiennent a titre individuel des licences de brevets, avec comme consequence qu'ils ont un droit de propriete sur le programme. Pour eviter cette situation, nous avons fait tout ce qui est necessaire pour que tous brevets doivent faire l'objet d'une concession de licence qui en permette l'utilisation libre par quiconque, ou bien qu'il ne soit pas concede du tout.\n\nNous presentons ci-dessous les clauses et dispositions concernant la duplication, la distribution et la modification.\n\nCONDITIONS D'EXPLOITATION PORTANT SUR LA DUPLICATION, LA DISTRIBUTION ET LA MODIFICATION\n\n1. Le present contrat de licence s'applique a tout programme ou autre ouvrage contenant un avis, appose par le detenteur du droit de propriete, disant qu'il peut etre distribue au titre des dispositions de la presente Licence Publique Generale. Ci-apres, le \"Programme\" designe l'un quelconque de ces programmes ou ouvrages, et un \"ouvrage fonde sur le programme\" designe soit le programme, soit un ouvrage qui en derive au titre de la loi sur le droit d'auteur ; plus precisement, il s'agira d'un ouvrage contenant le programme ou une version de ce dernier, soit mot a mot, soit avec des modifications et/ou traduit en une autre langue (ci-apres, le terme \"modification\" englobe, sans aucune limitation, les traductions qui en sont faites). Chaque titulaire de licence sera appele \"concessionnaire\".\nLes activites autres que la duplication, la distribution et la modification ne sont pas couvertes par la presente licence ; elles n'entrent pas dans le cadre de cette derniere. L'execution du programme n'est soumise a aucune restriction, et les resultats du programme ne sont couverts que si son contenu constitue un ouvrage fonde sur le programme (independamment du fait qu'il a ete realise par execution du programme). La veracite de ce qui precede depend de ce que fait le programme.\n\n2. Le concessionnaire peut dupliquer et distribuer des copies mot a mot du code source du programme tel qu'il les recoit, et ce sur un support quelconque, du moment qu'il appose, d'une maniere parfaitement visible et appropriee, sur chaque exemplaire, un avis approprie de droits d'auteur (Copyright) et de renonciation a garantie ; qu'il maintient intacts tous les avis qui se rapportent a la presente licence et a l'absence de toute garantie ; et qu'il transmet a tout destinataire du programme un exemplaire de la presente licence en meme temps que le programme.\nLe concessionnaire peut facturer l'acte physique de transfert d'un exemplaire, et il peut, a sa discretion, proposer en echange d'une remuneration une protection en garantie.\n\n3. Le concessionnaire peut modifier son ou ses exemplaires du programme ou de toute portion de ce dernier, en formant ainsi un ouvrage fonde sur le programme, et dupliquer et distribuer ces modifications ou cet ouvrage selon les dispositions de la section 1 ci-dessus, du moment que le concessionnaire satisfait aussi a toutes ces conditions :\na. Le concessionnaire doit faire en sorte que les fichiers modifies portent un avis, parfaitement visible, disant que le concessionnaire a modifie les fichiers, avec la date de tout changement.\nb. Le concessionnaire doit faire en sorte que tout ouvrage qu'il distribue ou publie, et qui, en totalite ou en partie, contient le programme ou une partie quelconque de ce dernier ou en derive, soit concede en bloc, a titre gracieux, a tous tiers au titre des dispositions de la presente licence.\nc. Si le programme modifie lit normalement des instructions interactives lors de son execution, le concessionnaire doit, quand il commence l'execution du programme pour une telle utilisation interactive de la maniere la plus usuelle, faire en sorte que ce programme imprime ou affiche une annonce, comprenant un avis approprie de droits d'auteur, et un avis selon lequel il n'y a aucune garantie (ou autrement, que le concessionnaire fournit une garantie), et que les utilisateurs peuvent redistribuer le programme au titre de ces dispositions, et disant a l'utilisateur comment visualiser une copie de cette licence (exception : si le programme par lui-meme est interactif mais n'imprime normalement pas une telle annonce, l'ouvrage du concessionnaire se fondant sur le programme n'a pas besoin d'imprimer une annonce).\nLes exigences ci-dessus s'appliquent a l'ouvrage modifie pris en bloc. Si des sections identifiables de cet ouvrage ne derivent pas du programme et peuvent etre considerees raisonnablement comme representant des ouvrages independants et distincts par eux-memes, alors la presente licence, et ses dispositions, ne s'appliquent pas a ces sections quand le concessionnaire les distribue sous forme d'ouvrages distincts. Mais quand le concessionnaire distribue ces memes sections en tant qu'element d'un tout qui represente un ouvrage se fondant sur le programme, la distribution de ce tout doit se faire conformement aux dispositions de la presente licence, dont les autorisations, portant sur d'autres concessionnaires, s'etendent a la totalite dont il est question, et ainsi a chacune de ces parties, independamment de celui qu'il a ecrite.\nAinsi, cette section n'a pas pour but de revendiquer des droits ou de contester vos droits sur un ouvrage entierement ecrit par le concessionnaire ; bien plus, l'intention est d'exercer le droit de surveiller la distribution d'ouvrages derivee ou collective se fondant sur le programme.\nDe plus, un simple assemblage d'un autre ouvrage ne se fondant pas sur le programme, avec le programme (ou avec un ouvrage se fondant sur le programme) sur un volume d'un support de stockage ou distribution, ne fait pas entrer l'autre ouvrage dans le cadre de la presente licence.\n\n4. Le concessionnaire peut dupliquer et distribuer le programme (ou un ouvrage se fondant sur ce dernier, au titre de la Section 2), en code objet ou sous une forme executable, au titre des dispositions des Sections 1 et 2 ci-dessus, du moment que le concessionnaire effectue aussi l'une des operations suivantes :\na. Lui joindre le code source complet correspondant, exploitable par une machine, code qui doit etre distribue au titre des Sections 1 et 2 ci-dessus sur un support couramment utilise pour l'echange de logiciels ; ou bien\nb. Lui joindre une offre ecrite, dont la validite se prolonge pendant au moins 3 ans, de transmettre a un tiers quelconque, pour un montant non superieur au cout pour le concessionnaire, de realisation physique de la distribution de la source, un exemplaire complet, exploitable par une machine, du code source correspondant, qui devra etre distribue au titre des dispositions des Sections 1 et 2 ci-dessus sur un support couramment utilise pour l'echange des logiciels ; ou bien\nc. Lui joindre les informations que le concessionnaire a recues, pour proposer une distribution du code source correspondant (cette variante n'est autorisee que pour la distribution non commerciale, et seulement si le concessionnaire a recu le programme sous forme executable ou sous forme d'un code objet, avec une telle offre, conformement a l'alinea b) ci-dessus).\nLe code source d'un ouvrage represente la forme preferee de l'ouvrage pour y effectuer des modifications. Pour un ouvrage executable, le code source complet represente la totalite du code source pour tous les modules qu'il contient, plus tous fichiers de definitions d'interface associes, plus les informations en code machine pour commander la compilation et l'installation du programme executable. Cependant, a titre d'exceptions speciales, le code source distribue n'a pas besoin de comprendre quoi que ce soit qui est normalement distribue (sous forme source ou sous forme binaire) avec les composants principaux (compilateur, noyau de systeme d'exploitation, etc.) du systeme d'exploitation sur lequel est execute le programme executable, a moins que le composant, par lui-meme, soit joint au programme executable.\nSi la distribution de l*executable ou du code objet est realisee de telle sorte qu'elle offre d'acceder a une copie a partir d'un lieu designe, alors le fait d'offrir un acces equivalent a la duplication du code source a partir de ce meme lieu s'entend comme distribution du code source, meme si des tiers ne sont pas contraints de dupliquer la source en meme temps que le code objet.\n\n5. Le concessionnaire ne peut dupliquer, modifier, conceder en sous-licence ou distribuer le programme, sauf si cela est expressement prevu par les dispositions de la presente licence. Toute tentative pour autrement dupliquer, modifier, conceder en sous-licence ou distribuer le programme est repetee nulle, et met automatiquement fin aux droits du concessionnaire au titre de la presente licence. Cependant, les parties qui ont recu des copies, ou des droits, de la part du concessionnaire au titre de la presente licence, ne verront pas expirer leur contrat de licence, tant que ces parties agissent d'une maniere parfaitement conforme.\n\n6. Il n'est pas exige du concessionnaire qu'il accepte la presente licence, car il ne l'a pas signee. Cependant, rien d'autre n'octroie au concessionnaire l'autorisation de modifier ou de distribuer le programme ou ses ouvrages derives. Ces actions sont interdites par la loi si le concessionnaire n'accepte pas la presente licence. En consequence, par le fait de modifier ou de distribuer le programme (ou un ouvrage quelconque se fondant sur le programme), le concessionnaire indique qu'il accepte la presente licence, et qu'il a la volonte de se conformer a toutes les clauses et dispositions concernant la duplication, la distribution ou la modification du programme ou d'ouvrages se fondant sur ce dernier.\n\n7. Chaque fois que le concessionnaire redistribue le programme (ou tout ouvrage se fondant sur le programme), le destinataire recoit automatiquement une licence de l'emetteur initial de la licence, pour dupliquer, distribuer ou modifier le programme, sous reserve des presentes clauses et dispositions. Le concessionnaire ne peut imposer aucune restriction plus poussee sur l'exercice, par le destinataire, des droits octroyes au titre des presentes. Le concessionnaire n'a pas pour responsabilite d'exiger que des tiers se conforment a la presente licence.\n\n8. Si, en consequence une decision de justice ou une allegation d'infraction au droit des brevets, ou pour toute autre raison (qui n'est pas limitee a des problemes de proprietes industrielles), des conditions sont imposees au concessionnaire (par autorite de justice, par convention ou autrement), qui entrent en contradiction avec les dispositions de la presente licence, elles n'exemptent pas le concessionnaire de respecter les dispositions de la presente licence. Si le concessionnaire ne peut proceder a la distribution de facon a satisfaire simultanement a ces obligations au titre de la presente licence et a toutes autres obligations pertinentes, alors, en consequence de ce qui precede, le concessionnaire peut ne pas proceder du tout a la distribution du programme. Par exemple, si une licence de brevet ne permettait pas une redistribution du programme, sans redevances, par tous ceux qui recoivent des copies directement ou indirectement par l'intermediaire du concessionnaire, alors le seul moyen par lequel le concessionnaire pourrait satisfaire tant a cette licence de brevet qu'a la presente licence, consisterait a s'abstenir completement de distribuer le programme.\nSi une partie quelconque de cette section est consideree comme nulle ou non executoire dans certaines circonstances particulieres, le reste de cette section est repute s'appliquer, et la section dans son ensemble est consideree comme s'appliquant dans les autres circonstances.\nLa presente section n'a pas pour objet de pousser le concessionnaire a enfreindre tous brevets ou autres revendications a droit de propriete, ou encore a contester la validite de une ou plusieurs quelconques de ces revendications ; la presente section a pour objet unique de proteger l'integrite du systeme de distribution des logiciels libres, systeme qui est mis en oeuvre par les pratiques liees aux licences publiques. De nombreuses personnes ont apporte une forte contribution a la gamme etendue des logiciels distribues par ce systeme, en comptant sur l'application systematique de ce systeme ; c'est a l'auteur/donateur de decider s'il a la volonte de distribuer le logiciel par un quelconque autre systeme, et un concessionnaire ne peut imposer ce choix.\nLa presente section veut rendre parfaitement claire ce que l'on pense etre une consequence du reste de la presente licence.\n\n9. Si la distribution et/ou l'utilisation du Programme est restreinte dans certains pays, sous l'effet de brevets ou d'interfaces presentant un droit d'auteur, le detenteur du droit d'auteur original, qui soumet le Programme aux dispositions de la presente licence, pourra ajouter une limitation expresse de distribution geographique excluant ces pays, de facon que la distribution ne soit autorisee que dans les pays ou parmi les pays qui ne sont pas ainsi exclus. Dans ce cas, la limitation fait partie integrante de la presente licence, comme si elle etait ecrite dans le corps de la presente licence.\nLa Free Software Foundation peut, de temps a autre, publier des versions revisees et/ou nouvelles du General Public License. Ces nouvelles versions seront analogues, du point de vue de leur esprit, a la presente version, mais pourront en differer dans le detail, pour resoudre de nouveaux problemes ou de nouvelles situations.\nChaque version recoit un numero de version qui lui est propre. Si le programme specifie un numero de version de la presente licence, qui s'applique a cette dernier et \"a toute autre version ulterieure\", le concessionnaire a le choix de respecter les clauses et dispositions de cette version, ou une quelconque version ulterieure publiee par la Free Software Foundation. Si le programme ne specifie pas de numero de version de la presente licence, le concessionnaire pourra choisir une version quelconque publiee a tout moment par la Free Software Foundation.\n\n10. Si le concessionnaire souhaite incorporer des parties du programme dans d'autres programmes libres dont les conditions de distribution sont differentes, il devrait ecrire a l'auteur pour demander son autorisation. Pour un logiciel soumis a droit d'auteur par la Free Software Foundation, il devra ecrire a la Free Software Foundation ; nous faisons quelquefois des exceptions a cette regle. Notre decision va etre guidee par le double objectif de proteger le statut libre de tous les derives de nos logiciels libres, et de favoriser le partage et la reutilisation des logiciels en general.\n\nABSENCE DE GARANTIE\n\n11. COMME LA LICENCE DU PROGRAMME EST CONCEDEE A TITRE GRATUIT, IL N'Y A AUCUNE GARANTIE S'APPLIQUANT AU PROGRAMME, DANS LA MESURE AUTORISEE PAR LA LOI EN VIGUEUR. SAUF MENTION CONTRAIRE ECRITE, LES DETENTEURS DU DROIT D'AUTEUR ET/OU LES AUTRES PARTIES METTENT LE PROGRAMME A DISPOSITON \"EN L'ETAT\", SANS AUCUNE GARANTIE DE QUELQUE NATURE QUE CE SOIT, EXPRESSE OU IMPLICITE, Y COMPRIS, MAIS SANS LIMITATION, LES GARANTIES IMPLICITES DE COMMERCIALISATION ET DE L'APTITUDE A UN OBJET PARTICULIER. C'EST LE CONCESSIONNAIRE QUI PREND LA TOTALITE DU RISQUE QUANT A LA QUALITE ET AUX PERFORMANCES DU PROGRAMME. SI LE PROGRAMME SE REVELAIT DEFECTUEUX, C'EST LE CONCESSIONNAIRE QUI PRENDRAIT A SA CHARGE LE COUT DE L'ENSEMBLE DES OPERATIONS NECESSAIRES D'ENTRETIEN, REPARATION OU CORRECTION.\n\n12. EN AUCUN CAS, SAUF SI LA LOI EN VIGUEUR L'EXIGE OU SI UNE CONVENTION ECRITE EXISTE A CE SUJET, AUCUN DETENTEUR DE DROITS D'AUTEUR, OU AUCUNE PARTIE AYANT LE POUVOIR DE MODIFIER ET/OU DE REDISTRIBUER LE PROGRAMME CONFORMEMENT AUX AUTORISATIONS CI-DESSUS, N'EST RESPONSABLE VIS-A-VIS DU CONCESSIONNAIRE POUR CE QUI EST DES DOMMAGES, Y COMPRIS TOUS DOMMAGES GENERAUX, SPECIAUX, ACCIDENTELS OU INDIRECTS, RESULTANT DE L'UTILISATION OU DU PROGRAMME OU DE L'IMPOSSIBILITE D'UTILISER LE PROGRAMME (Y COMPRIS, MAIS SANS LIMITATION, LA PERTE DE DONNEES, OU LE FAIT QUE DES DONNEES SONT RENDUES IMPRECISES, OU ENCORE LES PERTES EPROUVEES PAR LE CONCESSIONNAIRE OU PAR DES TIERS, OU ENCORE UN MANQUEMENT DU PROGRAMME A FONCTIONNER AVEC TOUS AUTRES PROGRAMMES), MEME SI CE DETENTEUR OU CETTE AUTRE PARTIE A ETE AVISE DE LA POSSIBILITE DE TELS DOMMAGES.\n\nFIN DES CONDITIONS D'EXPLOITATION\n\nPlus d'informations sur www.ufoot.org/liquidwar/v5\n";
  LW_LANGFR_DATA[(signed long int)5] = "Liquid War par U-Foot\n\nv5.6.4 \n\ncompilee le Jan 25 2016 a 05:34:55\n\nPlus d'informations sur www.ufoot.org/liquidwar/v5\n";
  LW_LANGFR_DATA[(signed long int)6] = "Jouer";
  LW_LANGFR_DATA[(signed long int)7] = "Jeu reseau";
  LW_LANGFR_DATA[(signed long int)8] = "Tableau";
  LW_LANGFR_DATA[(signed long int)9] = "Equipes";
  LW_LANGFR_DATA[(signed long int)10] = "Options";
  LW_LANGFR_DATA[(signed long int)11] = "A propos";
  LW_LANGFR_DATA[(signed long int)12] = "Quitter";
  LW_LANGFR_DATA[(signed long int)13] = "Revenir a DOS";
  LW_LANGFR_DATA[(signed long int)14] = "Quitter";
  LW_LANGFR_DATA[(signed long int)15] = "Quitter";
  LW_LANGFR_DATA[(signed long int)16] = "Retour a LW";
  LW_LANGFR_DATA[(signed long int)17] = "Quitter";
  LW_LANGFR_DATA[(signed long int)18] = "Retour";
  LW_LANGFR_DATA[(signed long int)19] = "Jouer";
  LW_LANGFR_DATA[(signed long int)20] = "Accueil";
  LW_LANGFR_DATA[(signed long int)21] = "C'est parti!";
  LW_LANGFR_DATA[(signed long int)22] = "Demarrer";
  LW_LANGFR_DATA[(signed long int)23] = "Addr serveur";
  LW_LANGFR_DATA[(signed long int)24] = "Port serveur";
  LW_LANGFR_DATA[(signed long int)25] = "Trouver un serveur sur le Net";
  LW_LANGFR_DATA[(signed long int)26] = "Mot de passe";
  LW_LANGFR_DATA[(signed long int)27] = "ATTENTION! Choisir un mot de passe simple genre \"bonjour\", car il est stocke sur le disque dur et envoye au serveur en clair.";
  LW_LANGFR_DATA[(signed long int)28] = "Automatique";
  LW_LANGFR_DATA[(signed long int)29] = "Inactif";
  LW_LANGFR_DATA[(signed long int)30] = "Joueur";
  LW_LANGFR_DATA[(signed long int)31] = "Ordi";
  LW_LANGFR_DATA[(signed long int)32] = "Affichage";
  LW_LANGFR_DATA[(signed long int)33] = "Son";
  LW_LANGFR_DATA[(signed long int)34] = "Regles";
  LW_LANGFR_DATA[(signed long int)35] = "Vitesses";
  LW_LANGFR_DATA[(signed long int)36] = "Controles";
  LW_LANGFR_DATA[(signed long int)37] = "Langue";
  LW_LANGFR_DATA[(signed long int)38] = "Remise a zero";
  LW_LANGFR_DATA[(signed long int)39] = "Jeu";
  LW_LANGFR_DATA[(signed long int)40] = "Menu";
  LW_LANGFR_DATA[(signed long int)41] = "Oui";
  LW_LANGFR_DATA[(signed long int)42] = "Non";
  LW_LANGFR_DATA[(signed long int)43] = "Plein ecran";
  LW_LANGFR_DATA[(signed long int)44] = "Fenetre";
  LW_LANGFR_DATA[(signed long int)45] = "Opt avancees";
  LW_LANGFR_DATA[(signed long int)46] = "Mode video";
  LW_LANGFR_DATA[(signed long int)47] = "Luminosite";
  LW_LANGFR_DATA[(signed long int)48] = "Surface";
  LW_LANGFR_DATA[(signed long int)49] = "\"Page flipping\"";
  LW_LANGFR_DATA[(signed long int)50] = "Vagues (F4)";
  LW_LANGFR_DATA[(signed long int)51] = "Bruits";
  LW_LANGFR_DATA[(signed long int)52] = "Clics";
  LW_LANGFR_DATA[(signed long int)53] = "Eau (jeu)";
  LW_LANGFR_DATA[(signed long int)54] = "Eau (menu)";
  LW_LANGFR_DATA[(signed long int)55] = "Musique";
  LW_LANGFR_DATA[(signed long int)56] = "Temps";
  LW_LANGFR_DATA[(signed long int)57] = "Opt avancees";
  LW_LANGFR_DATA[(signed long int)58] = "Taille armees";
  LW_LANGFR_DATA[(signed long int)59] = "Curseur";
  LW_LANGFR_DATA[(signed long int)60] = "Remise a zero";
  LW_LANGFR_DATA[(signed long int)61] = "Mini ";
  LW_LANGFR_DATA[(signed long int)62] = "Attaque";
  LW_LANGFR_DATA[(signed long int)63] = "Defense";
  LW_LANGFR_DATA[(signed long int)64] = "Force depart";
  LW_LANGFR_DATA[(signed long int)65] = "Aide vainqueur";
  LW_LANGFR_DATA[(signed long int)66] = "Force ordi";
  LW_LANGFR_DATA[(signed long int)67] = "Ordi vs joueur";
  LW_LANGFR_DATA[(signed long int)68] = "Toujours";
  LW_LANGFR_DATA[(signed long int)69] = "Au hasard";
  LW_LANGFR_DATA[(signed long int)70] = "Jamais";
  LW_LANGFR_DATA[(signed long int)71] = "Algorithme";
  LW_LANGFR_DATA[(signed long int)72] = "Assembleur";
  LW_LANGFR_DATA[(signed long int)73] = "C standard";
  LW_LANGFR_DATA[(signed long int)74] = "Bots reseau";
  LW_LANGFR_DATA[(signed long int)75] = "Oui";
  LW_LANGFR_DATA[(signed long int)76] = "Non";
  LW_LANGFR_DATA[(signed long int)77] = "affich/s";
  LW_LANGFR_DATA[(signed long int)78] = "Pas de limite";
  LW_LANGFR_DATA[(signed long int)79] = "tours/s";
  LW_LANGFR_DATA[(signed long int)80] = "Pas de limite";
  LW_LANGFR_DATA[(signed long int)81] = "Joystick";
  LW_LANGFR_DATA[(signed long int)82] = "Aucun";
  LW_LANGFR_DATA[(signed long int)83] = "2 joysticks";
  LW_LANGFR_DATA[(signed long int)84] = "4 boutons";
  LW_LANGFR_DATA[(signed long int)85] = "Standard";
  LW_LANGFR_DATA[(signed long int)86] = "Sensibilite de la souris (jeu)";
  LW_LANGFR_DATA[(signed long int)87] = "\"Credits\"";
  LW_LANGFR_DATA[(signed long int)88] = "Copyright";
  LW_LANGFR_DATA[(signed long int)89] = "Licence";
  LW_LANGFR_DATA[(signed long int)90] = "Version";
  LW_LANGFR_DATA[(signed long int)91] = "Rafraichir";
  LW_LANGFR_DATA[(signed long int)92] = "Se connecter";
  LW_LANGFR_DATA[(signed long int)93] = "Port";
  LW_LANGFR_DATA[(signed long int)94] = "Mot de passe";
  LW_LANGFR_DATA[(signed long int)95] = "oui";
  LW_LANGFR_DATA[(signed long int)96] = "non";
  LW_LANGFR_DATA[(signed long int)97] = "Age";
  LW_LANGFR_DATA[(signed long int)98] = "j";
  LW_LANGFR_DATA[(signed long int)99] = "j";
  LW_LANGFR_DATA[(signed long int)100] = "h";
  LW_LANGFR_DATA[(signed long int)101] = "min";
  LW_LANGFR_DATA[(signed long int)102] = "sec";
  LW_LANGFR_DATA[(signed long int)103] = "Pas joignable";
  LW_LANGFR_DATA[(signed long int)104] = "Ping";
  LW_LANGFR_DATA[(signed long int)105] = "ms";
  LW_LANGFR_DATA[(signed long int)106] = "Taille";
  LW_LANGFR_DATA[(signed long int)107] = "Nombre";
  LW_LANGFR_DATA[(signed long int)108] = "Rapid";
  LW_LANGFR_DATA[(signed long int)109] = "WX";
  LW_LANGFR_DATA[(signed long int)110] = "HY";
  LW_LANGFR_DATA[(signed long int)111] = "WY";
  LW_LANGFR_DATA[(signed long int)112] = "HX";
  LW_LANGFR_DATA[(signed long int)113] = "Commencer";
  LW_LANGFR_DATA[(signed long int)114] = "En attente...";
  LW_LANGFR_DATA[(signed long int)115] = "Il manque ";
  LW_LANGFR_DATA[(signed long int)116] = " equipe(s)";
  LW_LANGFR_DATA[(signed long int)117] = "Envoyer";
  LW_LANGFR_DATA[(signed long int)118] = "Connexion";
  LW_LANGFR_DATA[(signed long int)119] = "\"Ping\"";
  LW_LANGFR_DATA[(signed long int)120] = "Verif prog";
  LW_LANGFR_DATA[(signed long int)121] = "Verif version";
  LW_LANGFR_DATA[(signed long int)122] = "Mot de passe";
  LW_LANGFR_DATA[(signed long int)123] = "Place libre?";
  LW_LANGFR_DATA[(signed long int)124] = "Reservation";
  LW_LANGFR_DATA[(signed long int)125] = "Envoi conf";
  LW_LANGFR_DATA[(signed long int)126] = "Envoi tab";
  LW_LANGFR_DATA[(signed long int)127] = "En attente...";
  LW_LANGFR_DATA[(signed long int)128] = "Qui joue?";
  LW_LANGFR_DATA[(signed long int)129] = "Lecture conf";
  LW_LANGFR_DATA[(signed long int)130] = "Lecture tab";
  LW_LANGFR_DATA[(signed long int)131] = "Texture par defaut";
  LW_LANGFR_DATA[(signed long int)132] = "Oui";
  LW_LANGFR_DATA[(signed long int)133] = "Non";
  LW_LANGFR_DATA[(signed long int)134] = "Tableau au hasard";
  LW_LANGFR_DATA[(signed long int)135] = "affich/s ";
  LW_LANGFR_DATA[(signed long int)136] = "tours/s ";
  LW_LANGFR_DATA[(signed long int)137] = "% calcul ";
  LW_LANGFR_DATA[(signed long int)138] = "% affichage ";
  LW_LANGFR_DATA[(signed long int)139] = "Temps calc gradient ";
  LW_LANGFR_DATA[(signed long int)140] = "Temps deplac armees ";
  LW_LANGFR_DATA[(signed long int)141] = "Temps affichage ";
  LW_LANGFR_DATA[(signed long int)142] = "Temps \"page flip\" ";
  LW_LANGFR_DATA[(signed long int)143] = "Temps restant ";
  LW_LANGFR_DATA[(signed long int)144] = "Temps total ";
  LW_LANGFR_DATA[(signed long int)145] = "Affichage standard";
  LW_LANGFR_DATA[(signed long int)146] = "Gradient 1";
  LW_LANGFR_DATA[(signed long int)147] = "Gradient 2";
  LW_LANGFR_DATA[(signed long int)148] = "Gradient 3";
  LW_LANGFR_DATA[(signed long int)149] = "Gradient 4";
  LW_LANGFR_DATA[(signed long int)150] = "Gradient 5";
  LW_LANGFR_DATA[(signed long int)151] = "Gradient 6";
  LW_LANGFR_DATA[(signed long int)152] = "Forme du maillage";
  LW_LANGFR_DATA[(signed long int)153] = "Structure du maillage";
  LW_LANGFR_DATA[(signed long int)154] = "Pause terminee";
  LW_LANGFR_DATA[(signed long int)155] = "Pause";
  LW_LANGFR_DATA[(signed long int)156] = "Pas d'effets de vague";
  LW_LANGFR_DATA[(signed long int)157] = "Effets de vague";
  LW_LANGFR_DATA[(signed long int)158] = "Capture video desactivee";
  LW_LANGFR_DATA[(signed long int)159] = "Capture video activee";
  LW_LANGFR_DATA[(signed long int)160] = "Bravo!";
  LW_LANGFR_DATA[(signed long int)161] = "Pb mem \"back\"";
  LW_LANGFR_DATA[(signed long int)162] = "Pb mem \"disp\"";
  LW_LANGFR_DATA[(signed long int)163] = "Pb mem \"mesh\"";
  LW_LANGFR_DATA[(signed long int)164] = "Pb mem \"area\"";
  LW_LANGFR_DATA[(signed long int)165] = "Pb mem \"army\"";
  LW_LANGFR_DATA[(signed long int)166] = "Pas assez d'equipes.\nIl faut selectionner au moins 2 equipes dans le menu \"Equipes\"";
  LW_LANGFR_DATA[(signed long int)167] = "Pas assez de memoire.\nIl faut choisir un plus petit tableau ou bien lire la documentation et essayer des options du type \"-mem n\".";
  LW_LANGFR_DATA[(signed long int)168] = "Impossible d'initialiser le mode video.";
  LW_LANGFR_DATA[(signed long int)169] = "Pas de support reseau pour cette plate-forme.\nLe reseau est disponiblre sous Windows et UNIX uniquement.";
  LW_LANGFR_DATA[(signed long int)170] = "Impossible de joindre le serveur.\nIl est peut-etre mal configure, ou bien vous etes derriere un pare-feu (firewall) qui vous empeche de vous connecter.";
  LW_LANGFR_DATA[(signed long int)171] = "Impossible de communiquer avec le serveur.\nIl semble que ce ne soit pas un serveur Liquid War.";
  LW_LANGFR_DATA[(signed long int)172] = "Probleme de version client/serveur.\nLe client et le serveur doivent avoir la meme version (la version de ce client est \"5.6.4\").";
  LW_LANGFR_DATA[(signed long int)173] = "Il y a eu une erreur reseau.\nCela peut arriver si la connexion est trop lente ou bien si elle a ete coupee.";
  LW_LANGFR_DATA[(signed long int)174] = "Impossible d'envoyer le tableau au serveur.";
  LW_LANGFR_DATA[(signed long int)175] = "Impossible de recevoir le tableau du serveur.";
  LW_LANGFR_DATA[(signed long int)176] = "Ce serveur est plein, il n'accepte plus de nouvelles equipes.";
  LW_LANGFR_DATA[(signed long int)177] = "Mot de passe incorrect.";
  LW_LANGFR_DATA[(signed long int)178] = "Un des parametres de configuration est en dehors des valeurs admises. Soit il y a un bug dans le jeu, soit quelqu'un est en train d'essayer de tricher et/ou de hacker quelque chose.";
  LW_LANGFR_DATA[(signed long int)179] = "Echec lors de l'initialisation.";
  LW_LANGFR_DATA[(signed long int)180] = "Pas assez de mmoire pour les bitmaps.";
  LW_LANGFR_DATA[(signed long int)181] = "Pas assez de mmoire.";
  LW_LANGFR_DATA[(signed long int)182] = "Impossible de charger le fichier de donnes. Etes-vous sr que Liquid War est correctement install?";
  LW_LANGFR_DATA[(signed long int)183] = "Impossible de charger les fichiers de donnes utilisateur.";
  LW_LANGFR_DATA[(signed long int)184] = "Impossible de passer en mode graphique.";
}

// lw_langfr_string
// file langfr.h line 70
extern char * lw_langfr_string(signed int id)
{
  char *result = (char *)(void *)0;
  if(id >= 0 && !(id >= 185))
    result = LW_LANGFR_DATA[(signed long int)id];

  if(result == ((char *)NULL))
    result = "??? fr";

  return result;
}

// lw_map_archive_raw
// file map.h line 71
void * lw_map_archive_raw(const char *filename)
{
  struct BITMAP *bmp;
  struct RGB pal[256l];
  void *result = (void *)0;
  bmp=load_bitmap(filename, pal);
  if(!(bmp == ((struct BITMAP *)NULL)))
    result=lw_map_archive_raw_bmp(bmp, pal, filename);

  return result;
}

// lw_map_archive_raw_bmp
// file map.c line 371
void * lw_map_archive_raw_bmp(struct BITMAP *bmp, struct RGB *pal, const char *filename)
{
  signed int w = 0;
  signed int h = 0;
  signed int size = 0;
  signed int bg_size = 0;
  struct BITMAP *sub_bmp;
  char *temp = (char *)(void *)0;
  char *result = (char *)(void *)0;
  char readable_name_buffer[33l];
  char system_name_buffer[17l];
  if(!(bmp == ((struct BITMAP *)NULL)))
  {
    sort_light_and_dark(bmp, pal);
    sub_bmp=extract_significant_part(bmp);
    if(!(sub_bmp == ((struct BITMAP *)NULL)))
    {
      w = sub_bmp->w;
      h = sub_bmp->h;
      signed int return_value_check_if_playable_2;
      return_value_check_if_playable_2=check_if_playable(sub_bmp);
      if(!(return_value_check_if_playable_2 == 0))
      {
        void *return_value_malloc_in_big_data_bottom_1;
        return_value_malloc_in_big_data_bottom_1=malloc_in_big_data_bottom(w * h + 1);
        temp = (char *)return_value_malloc_in_big_data_bottom_1;
        if(!(temp == ((char *)NULL)))
          convert_to_buffer(sub_bmp, temp, &size, &bg_size);

      }

      destroy_bitmap(sub_bmp);
    }

    destroy_bitmap(bmp);
  }

  signed int tmp_statement_expression_6;
  signed int tmp_post_5;
  if(!(temp == ((char *)NULL)))
  {
    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)(size + 8 + 16 + 32));
    result = (char *)return_value_malloc_3;
    if(!(result == ((char *)NULL)))
    {
      lw_serial_set_map_header((void *)result, size, (signed short int)w, (signed short int)h);
      memset((void *)system_name_buffer, 0, sizeof(char [17l]) /*17ul*/ );
      memset((void *)system_name_buffer, 0, sizeof(char [17l]) /*17ul*/ );
      char *return_value_lw_path_get_system_name_4;
      return_value_lw_path_get_system_name_4=lw_path_get_system_name(filename);
      __builtin_strncpy(system_name_buffer, return_value_lw_path_get_system_name_4, sizeof(char [17l]) /*17ul*/  - (unsigned long int)1);
      system_name_buffer[(signed long int)(sizeof(char [17l]) /*17ul*/  - (unsigned long int)1)] = (char)0;
      memcpy((void *)(result + (signed long int)8), (const void *)system_name_buffer, (unsigned long int)16);
      memset((void *)readable_name_buffer, 0, sizeof(char [33l]) /*33ul*/ );
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_7;
      return_value___builtin_strcmp_7=__builtin_strcmp(filename, "lwmapgen");
      tmp_statement_expression_6 = return_value___builtin_strcmp_7;
      if(tmp_statement_expression_6 == 0)
      {
        memset((void *)readable_name_buffer, 0, sizeof(char [33l]) /*33ul*/ );
        __builtin_strncpy(readable_name_buffer, "Random map", sizeof(char [33l]) /*33ul*/  - (unsigned long int)1);
        readable_name_buffer[(signed long int)(sizeof(char [33l]) /*33ul*/  - (unsigned long int)1)] = (char)0;
      }

      else
      {
        memset((void *)readable_name_buffer, 0, sizeof(char [33l]) /*33ul*/ );
        static signed int index = 1;
        tmp_post_5 = index;
        index = index + 1;
        snprintf(readable_name_buffer, sizeof(char [33l]) /*33ul*/  - (unsigned long int)1, "Custom map %d", tmp_post_5);
        readable_name_buffer[(signed long int)(sizeof(char [33l]) /*33ul*/  - (unsigned long int)1)] = (char)0;
      }
      memcpy((void *)(result + (signed long int)8 + (signed long int)16), (const void *)readable_name_buffer, (unsigned long int)32);
      memcpy((void *)(result + (signed long int)8 + (signed long int)16 + (signed long int)32), (const void *)temp, (unsigned long int)size);
    }

    free_last_big_data_bottom();
  }

  return (void *)result;
}

// lw_map_create_bicolor
// file map.c line 502
struct BITMAP * lw_map_create_bicolor(signed int num, signed int fg, signed int bg, signed int network, signed int random, signed int min_w, signed int min_h, signed int *zoom_factor)
{
  signed int pos_dst;
  signed int pos_src;
  signed int i;
  signed int j;
  signed int l;
  signed int color;
  signed short int w;
  signed short int h;
  signed char *data_dst;
  signed char *data_src;
  struct BITMAP *result = (struct BITMAP *)(void *)0;
  struct BITMAP *temp;
  void *raw_map;
  signed int size;
  signed int surface;
  signed int x;
  signed int y;
  raw_map=lw_map_get_safe(num, network, random);
  data_src = (signed char *)raw_map;
  data_src = data_src + (signed long int)(8 + 16 + 32);
  lw_serial_get_map_header(raw_map, &size, &w, &h);
  surface = (signed int)w * (signed int)h;
  *zoom_factor=calc_zoom_factor((signed int)w, (signed int)h, min_w, min_h);
  pos_dst = 0;
  pos_src = pos_dst;
  temp=my_create_bitmap((signed int)w, (signed int)h);
  signed int tmp_post_1;
  signed int tmp_post_2;
  if(!(temp == ((struct BITMAP *)NULL)))
  {
    data_dst = (signed char *)temp->dat;
    while(!(pos_src >= size))
    {
      tmp_post_1 = pos_src;
      pos_src = pos_src + 1;
      l = (signed int)data_src[(signed long int)tmp_post_1];
      if(l == 0)
        break;

      if(l >= 1)
        color = 0;

      else
      {
        l = -l;
        color = 2;
      }
      i = 0;
      for( ; !(i >= l) && !(pos_dst >= surface); i = i + 1)
      {
        tmp_post_2 = pos_dst;
        pos_dst = pos_dst + 1;
        data_dst[(signed long int)tmp_post_2] = (signed char)color;
      }
    }
    signed int return_value_check_if_playable_3;
    return_value_check_if_playable_3=check_if_playable(temp);
    if(!(return_value_check_if_playable_3 == 0))
    {
      fill_with_fg_and_bg(temp, fg, bg);
      result=my_create_bitmap((signed int)w * *zoom_factor, (signed int)h * *zoom_factor);
      if(!(result == ((struct BITMAP *)NULL)))
      {
        y = 0;
        for( ; !(y >= (signed int)h); y = y + 1)
        {
          x = 0;
          for( ; !(x >= (signed int)w); x = x + 1)
          {
            color=getpixel_link3(temp, x, y);
            i = 0;
            for( ; !(i >= *zoom_factor); i = i + 1)
            {
              j = 0;
              for( ; !(j >= *zoom_factor); j = j + 1)
                putpixel_link6(result, x * *zoom_factor + j, y * *zoom_factor + i, color);
            }
          }
        }
      }

    }

    else
      log_println_str("Error: unplayable map!");
    destroy_bitmap(temp);
  }

  return result;
}

// lw_map_create_textured
// file map.c line 590
struct BITMAP * lw_map_create_textured(signed int num, signed int fg, signed int bg, signed int network, signed int random, signed int min_w, signed int min_h)
{
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  signed int color;
  struct BITMAP *result = (struct BITMAP *)(void *)0;
  struct BITMAP *bg_tex;
  struct BITMAP *fg_tex;
  signed int fg_w;
  signed int fg_h;
  signed int bg_w;
  signed int bg_h;
  signed int zoom_factor;
  signed int zoom_factor_fg;
  signed int zoom_factor_bg;
  bg_tex=lw_texture_create_bg(bg);
  fg_tex=lw_texture_create_fg(fg);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!(bg_tex == ((struct BITMAP *)NULL)) && !(fg_tex == ((struct BITMAP *)NULL)))
  {
    bg_w = bg_tex->w;
    bg_h = bg_tex->h;
    fg_w = fg_tex->w;
    fg_h = fg_tex->h;
    result=lw_map_create_bicolor(num, 1, 0, network, random, min_w, min_h, &zoom_factor);
    if(!(result == ((struct BITMAP *)NULL)))
    {
      w = result->w;
      h = result->h;
      zoom_factor_bg = zoom_factor;
      zoom_factor_fg = zoom_factor_bg;
      if(!(w == fg_tex->w * zoom_factor))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = h != zoom_factor * fg_tex->h ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        zoom_factor_fg = 1;

      if(!(w == bg_tex->w * zoom_factor))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = h != zoom_factor * bg_tex->h ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        zoom_factor_bg = 1;

      y = 0;
      for( ; !(y >= h); y = y + 1)
      {
        x = 0;
        for( ; !(x >= w); x = x + 1)
        {
          signed int return_value_getpixel_3;
          return_value_getpixel_3=getpixel_link3(result, x, y);
          if(!(return_value_getpixel_3 == 0))
            color=getpixel_link3(fg_tex, (x / zoom_factor_fg) % fg_w, (y / zoom_factor_bg) % fg_h);

          else
            color=getpixel_link3(bg_tex, (x / zoom_factor_bg) % bg_w, (y / zoom_factor_bg) % bg_h);
          putpixel_link6(result, x, y, color);
        }
      }
    }

  }

  if(!(bg_tex == ((struct BITMAP *)NULL)))
    destroy_bitmap(bg_tex);

  if(!(fg_tex == ((struct BITMAP *)NULL)))
    destroy_bitmap(fg_tex);

  return result;
}

// lw_map_get_readable_name
// file map.h line 81
char * lw_map_get_readable_name(signed int num, signed int network, signed int random)
{
  void *raw_map;
  char *char_ptr;
  raw_map=lw_map_get_safe(num, network, random);
  char_ptr = (char *)raw_map;
  static char result[33l];
  memset((void *)result, 0, sizeof(char [33l]) /*33ul*/ );
  memcpy((void *)result, (const void *)(char_ptr + (signed long int)8 + (signed long int)16), (unsigned long int)32);
  result[(signed long int)(sizeof(char [33l]) /*33ul*/  - (unsigned long int)1)] = (char)0;
  return result;
}

// lw_map_get_res
// file map.h line 82
void lw_map_get_res(signed int num, signed int *w, signed int *h, signed int network, signed int random, signed int min_w, signed int min_h)
{
  void *raw_map;
  signed short int res_w;
  signed short int res_h;
  signed int zoom_factor;
  raw_map=lw_map_get_safe(num, network, random);
  lw_serial_get_map_header(raw_map, (signed int *)(void *)0, &res_w, &res_h);
  zoom_factor=calc_zoom_factor((signed int)res_w, (signed int)res_h, min_w, min_h);
  *w = (signed int)res_w * zoom_factor;
  *h = (signed int)res_h * zoom_factor;
}

// lw_map_get_safe
// file map.c line 471
static void * lw_map_get_safe(signed int num, signed int network, signed int random)
{
  void *raw_map = (void *)0;
  if(!(RAW_MAP_NUMBER + -1 >= num))
    num = RAW_MAP_NUMBER - 1;

  if(!(num >= 0))
    num = 0;

  if(!(LW_NETWORK_RAW_MAP == NULL) && !(network == 0))
    raw_map = LW_NETWORK_RAW_MAP;

  else
    if(!(LW_RANDOM_RAW_MAP == NULL) && !(random == 0))
      raw_map = LW_RANDOM_RAW_MAP;

    else
      raw_map = RAW_MAP_ORDERED[(signed long int)num];
  return raw_map;
}

// lw_map_get_system_name
// file map.c line 656
char * lw_map_get_system_name(signed int num, signed int network, signed int random)
{
  void *raw_map;
  char *char_ptr;
  raw_map=lw_map_get_safe(num, network, random);
  char_ptr = (char *)raw_map;
  static char result[17l];
  memset((void *)result, 0, sizeof(char [17l]) /*17ul*/ );
  memcpy((void *)result, (const void *)(char_ptr + (signed long int)8), (unsigned long int)16);
  result[(signed long int)(sizeof(char [17l]) /*17ul*/  - (unsigned long int)1)] = (char)0;
  return result;
}

// lw_maptex_create_bg
// file maptex.h line 77
struct BITMAP * lw_maptex_create_bg(signed int num, signed int bg, signed int network, signed int random, signed int use_default_texture)
{
  struct BITMAP *result;
  signed int found;
  signed int return_value_calc_real_texture_number_1;
  return_value_calc_real_texture_number_1=calc_real_texture_number(num, bg, network, random, use_default_texture, &found);
  result=lw_texture_create_bg(return_value_calc_real_texture_number_1);
  return result;
}

// lw_maptex_create_fg
// file maptex.h line 75
struct BITMAP * lw_maptex_create_fg(signed int num, signed int fg, signed int network, signed int random, signed int use_default_texture)
{
  struct BITMAP *result;
  signed int found;
  signed int return_value_calc_real_texture_number_1;
  return_value_calc_real_texture_number_1=calc_real_texture_number(num, fg, network, random, use_default_texture, &found);
  result=lw_texture_create_fg(return_value_calc_real_texture_number_1);
  return result;
}

// lw_maptex_create_map
// file maptex.h line 72
struct BITMAP * lw_maptex_create_map(signed int num, signed int fg, signed int bg, signed int network, signed int random, signed int min_w, signed int min_h, signed int use_default_texture)
{
  struct BITMAP *result;
  signed int found;
  signed int return_value_calc_real_texture_number_1;
  return_value_calc_real_texture_number_1=calc_real_texture_number(num, fg, network, random, use_default_texture, &found);
  signed int return_value_calc_real_texture_number_2;
  return_value_calc_real_texture_number_2=calc_real_texture_number(num, bg, network, random, use_default_texture, &found);
  result=lw_map_create_textured(num, return_value_calc_real_texture_number_1, return_value_calc_real_texture_number_2, network, random, min_w, min_h);
  return result;
}

// lw_maptex_is_custom_texture_used
// file maptex.h line 68
signed int lw_maptex_is_custom_texture_used(signed int num, signed int texture, signed int network, signed int random, signed int use_default_texture)
{
  signed int result = 0;
  calc_real_texture_number(num, texture, network, random, use_default_texture, &result);
  return result;
}

// lw_maptex_set_bg_palette
// file maptex.h line 81
void lw_maptex_set_bg_palette(signed int num, signed int bg, signed int network, signed int random, signed int use_default_texture)
{
  signed int found;
  signed int return_value_calc_real_texture_number_1;
  return_value_calc_real_texture_number_1=calc_real_texture_number(num, bg, network, random, use_default_texture, &found);
  set_bg_texture_palette(return_value_calc_real_texture_number_1);
}

// lw_maptex_set_fg_palette
// file maptex.h line 79
void lw_maptex_set_fg_palette(signed int num, signed int fg, signed int network, signed int random, signed int use_default_texture)
{
  signed int found;
  signed int return_value_calc_real_texture_number_1;
  return_value_calc_real_texture_number_1=calc_real_texture_number(num, fg, network, random, use_default_texture, &found);
  set_fg_texture_palette(return_value_calc_real_texture_number_1);
}

// lw_mouse_hide
// file mouse.c line 169
void lw_mouse_hide(void)
{
  MOUSE_ON = 0;
  lw_mouse_update_show_hide();
}

// lw_mouse_reset_control
// file mouse.h line 79
void lw_mouse_reset_control(void)
{
  MOUSE_CONTROL_REF_X = mouse_x;
  MOUSE_CONTROL_REF_Y = mouse_y;
  MOUSE_CONTROL_GAP = 2 + (8 - CONFIG_MOUSE_GAP) * (8 - CONFIG_MOUSE_GAP);
  if(!(MOUSE_CONTROL_REF_X >= MOUSE_CONTROL_GAP))
    MOUSE_CONTROL_REF_X = MOUSE_CONTROL_GAP;

  if(!(MOUSE_CONTROL_REF_Y >= MOUSE_CONTROL_GAP))
    MOUSE_CONTROL_REF_Y = MOUSE_CONTROL_GAP;

  signed int tmp_if_expr_2;
  if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
    tmp_if_expr_2 = gfx_driver->w;

  else
    tmp_if_expr_2 = 0;
  signed int tmp_if_expr_1;
  if(!(tmp_if_expr_2 + -MOUSE_CONTROL_GAP + -1 >= MOUSE_CONTROL_REF_X))
  {
    if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
      tmp_if_expr_1 = gfx_driver->w;

    else
      tmp_if_expr_1 = 0;
    MOUSE_CONTROL_REF_X = (tmp_if_expr_1 - MOUSE_CONTROL_GAP) - 1;
  }

  signed int tmp_if_expr_4;
  if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
    tmp_if_expr_4 = gfx_driver->h;

  else
    tmp_if_expr_4 = 0;
  signed int tmp_if_expr_3;
  if(!(tmp_if_expr_4 + -MOUSE_CONTROL_GAP + -1 >= MOUSE_CONTROL_REF_Y))
  {
    if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
      tmp_if_expr_3 = gfx_driver->h;

    else
      tmp_if_expr_3 = 0;
    MOUSE_CONTROL_REF_Y = (tmp_if_expr_3 - MOUSE_CONTROL_GAP) - 1;
  }

  position_mouse(MOUSE_CONTROL_REF_X, MOUSE_CONTROL_REF_Y);
  lw_mouse_update_control();
}

// lw_mouse_show
// file mouse.h line 81
void lw_mouse_show(void)
{
  MOUSE_ON = 1;
  lw_mouse_update_show_hide();
}

// lw_mouse_update_control
// file mouse.h line 78
void lw_mouse_update_control(void)
{
  if(MOUSE_CONTROL_REF_Y + -MOUSE_CONTROL_GAP >= mouse_y)
  {
    MOUSE_CONTROL_UP = 1;
    MOUSE_CONTROL_REF_Y = mouse_y + MOUSE_CONTROL_GAP;
  }

  else
    MOUSE_CONTROL_UP = 0;
  if(mouse_x >= MOUSE_CONTROL_GAP + MOUSE_CONTROL_REF_X)
  {
    MOUSE_CONTROL_RIGHT = 1;
    MOUSE_CONTROL_REF_X = mouse_x - MOUSE_CONTROL_GAP;
  }

  else
    MOUSE_CONTROL_RIGHT = 0;
  if(mouse_y >= MOUSE_CONTROL_GAP + MOUSE_CONTROL_REF_Y)
  {
    MOUSE_CONTROL_DOWN = 1;
    MOUSE_CONTROL_REF_Y = mouse_y - MOUSE_CONTROL_GAP;
  }

  else
    MOUSE_CONTROL_DOWN = 0;
  if(MOUSE_CONTROL_REF_X + -MOUSE_CONTROL_GAP >= mouse_x)
  {
    MOUSE_CONTROL_LEFT = 1;
    MOUSE_CONTROL_REF_X = mouse_x + MOUSE_CONTROL_GAP;
  }

  else
    MOUSE_CONTROL_LEFT = 0;
}

// lw_mouse_update_show_hide
// file mouse.c line 139
void lw_mouse_update_show_hide(void)
{
  if(!(MOUSE_ON == 0))
  {
    if(font == BIG_FONT)
      set_mouse_sprite(BIG_MOUSE_CURSOR);

    if(font == SMALL_FONT)
      set_mouse_sprite(SMALL_MOUSE_CURSOR);

    show_mouse(screen);
  }

  else
    set_mouse_sprite(INVISIBLE_MOUSE_CURSOR);
}

// lw_mutex_init
// file mutxunix.c line 78
signed int lw_mutex_init(struct anonymous_1 *mutex)
{
  signed int result = 0;
  union anonymous_2 *m;
  mutex->data=malloc(sizeof(union anonymous_2) /*40ul*/ );
  if(!(mutex->data == NULL))
  {
    m = (union anonymous_2 *)mutex->data;
    pthread_mutex_init(m, (const union anonymous_3 *)(void *)0);
    result = 1;
  }

  return result;
}

// lw_mutex_lock
// file mutxgen.h line 68
signed int lw_mutex_lock(struct anonymous_1 *mutex)
{
  signed int result = 0;
  union anonymous_2 *m = (union anonymous_2 *)mutex->data;
  if(m == ((union anonymous_2 *)NULL))
    lw_mutex_init(mutex);

  m = (union anonymous_2 *)mutex->data;
  if(!(m == ((union anonymous_2 *)NULL)))
  {
    pthread_mutex_lock(m);
    result = 1;
  }

  return result;
}

// lw_mutex_trylock
// file mutxgen.h line 69
signed int lw_mutex_trylock(struct anonymous_1 *mutex)
{
  signed int result = 0;
  union anonymous_2 *m = (union anonymous_2 *)mutex->data;
  if(m == ((union anonymous_2 *)NULL))
    lw_mutex_init(mutex);

  m = (union anonymous_2 *)mutex->data;
  if(!(m == ((union anonymous_2 *)NULL)))
  {
    signed int return_value_pthread_mutex_trylock_1;
    return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(m);
    if(!(return_value_pthread_mutex_trylock_1 == 16))
      result = 1;

  }

  return result;
}

// lw_mutex_unlock
// file mutxgen.h line 70
signed int lw_mutex_unlock(struct anonymous_1 *mutex)
{
  signed int result = 0;
  union anonymous_2 *m = (union anonymous_2 *)mutex->data;
  if(!(m == ((union anonymous_2 *)NULL)))
  {
    pthread_mutex_unlock(m);
    result = 1;
  }

  return result;
}

// lw_netconf_check
// file netconf.h line 86
signed int lw_netconf_check(struct anonymous_4 *config)
{
  signed int result = 1;
  if(!(config->cursor_increase_speed >= 0))
  {
    result = 0;
    log_print_str("Error: cursor_increase_speed is ");
    log_print_int(config->cursor_increase_speed);
    log_println_str(", and should be >= 0");
    config->cursor_increase_speed = 0;
  }

  if(config->cursor_increase_speed >= 3)
  {
    result = 0;
    log_print_str("Error: cursor_increase_speed is > ");
    log_print_int(config->cursor_increase_speed);
    log_print_str(", and should be <= ");
    log_println_int(2);
    config->cursor_increase_speed = 2;
  }

  if(!(config->fighter_attack >= 0))
  {
    result = 0;
    log_print_str("Error: fighter_attack is ");
    log_print_int(config->fighter_attack);
    log_println_str(", and should be >= 0");
    config->fighter_attack = 0;
  }

  if(config->fighter_attack >= 17)
  {
    result = 0;
    log_print_str("Error: fighter_attack is > ");
    log_print_int(config->fighter_attack);
    log_print_str(", and should be <= ");
    log_println_int(16);
    config->fighter_attack = 16;
  }

  if(!(config->fighter_defense >= 0))
  {
    result = 0;
    log_print_str("Error: fighter_defense is ");
    log_print_int(config->fighter_defense);
    log_println_str(", and should be >= 0");
    config->fighter_defense = 0;
  }

  if(config->fighter_defense >= 17)
  {
    result = 0;
    log_print_str("Error: fighter_defense is > ");
    log_print_int(config->fighter_defense);
    log_print_str(", and should be <= ");
    log_println_int(16);
    config->fighter_defense = 16;
  }

  if(!(config->fighter_new_health >= 0))
  {
    result = 0;
    log_print_str("Error: fighter_new_health is ");
    log_print_int(config->fighter_new_health);
    log_println_str(", and should be >= 0");
    config->fighter_new_health = 0;
  }

  if(config->fighter_new_health >= 17)
  {
    result = 0;
    log_print_str("Error: fighter_new_health is > ");
    log_print_int(config->fighter_new_health);
    log_print_str(", and should be <= ");
    log_println_int(16);
    config->fighter_new_health = 16;
  }

  if(!(config->number_influence >= 0))
  {
    result = 0;
    log_print_str("Error: number_influence is ");
    log_print_int(config->number_influence);
    log_println_str(", and should be >= 0");
    config->number_influence = 0;
  }

  if(config->number_influence >= 17)
  {
    result = 0;
    log_print_str("Error: number_influence is > ");
    log_print_int(config->number_influence);
    log_print_str(", and should be <= ");
    log_println_int(16);
    config->number_influence = 16;
  }

  if(!(config->fighter_number >= 0))
  {
    result = 0;
    log_print_str("Error: fighter_number is ");
    log_print_int(config->fighter_number);
    log_println_str(", and should be >= 0");
    config->fighter_number = 0;
  }

  if(config->fighter_number >= 33)
  {
    result = 0;
    log_print_str("Error: fighter_number is > ");
    log_print_int(config->fighter_number);
    log_print_str(", and should be <= ");
    log_println_int(32);
    config->fighter_number = 32;
  }

  if(!(config->game_time >= 0))
  {
    result = 0;
    log_print_str("Error: game_time is ");
    log_print_int(config->game_time);
    log_println_str(", and should be >= 0");
    config->game_time = 0;
  }

  if(config->game_time >= 17)
  {
    result = 0;
    log_print_str("Error: game_time is > ");
    log_print_int(config->game_time);
    log_print_str(", and should be <= ");
    log_println_int(16);
    config->game_time = 16;
  }

  if(!(config->cpu_advantage >= 0))
  {
    result = 0;
    log_print_str("Error: cpu_advantage is ");
    log_print_int(config->cpu_advantage);
    log_println_str(", and should be >= 0");
    config->cpu_advantage = 0;
  }

  if(config->cpu_advantage >= 5)
  {
    result = 0;
    log_print_str("Error: cpu_advantage is > ");
    log_print_int(config->cpu_advantage);
    log_print_str(", and should be <= ");
    log_println_int(4);
    config->cpu_advantage = 4;
  }

  if(!(config->cpu_vs_human >= 0))
  {
    result = 0;
    log_print_str("Error: cpu_vs_human is ");
    log_print_int(config->cpu_vs_human);
    log_println_str(", and should be >= 0");
    config->cpu_vs_human = 0;
  }

  if(config->cpu_vs_human >= 3)
  {
    result = 0;
    log_print_str("Error: cpu_vs_human is > ");
    log_print_int(config->cpu_vs_human);
    log_print_str(", and should be <= ");
    log_println_int(2);
    config->cpu_vs_human = 2;
  }

  if(!(config->asm_algorithm >= 0))
  {
    result = 0;
    log_print_str("Error: asm_algorithm is ");
    log_print_int(config->asm_algorithm);
    log_println_str(", and should be >= 0");
    config->asm_algorithm = 0;
  }

  if(config->asm_algorithm >= 2)
  {
    result = 0;
    log_print_str("Error: asm_algorithm is > ");
    log_print_int(config->asm_algorithm);
    log_print_str(", and should be <= ");
    log_println_int(1);
    config->asm_algorithm = 1;
  }

  if(!(config->min_map_res >= 0))
  {
    result = 0;
    log_print_str("Error: min_map_res is ");
    log_print_int(config->min_map_res);
    log_println_str(", and should be >= 0");
    config->min_map_res = 0;
  }

  if(config->min_map_res >= 9)
  {
    result = 0;
    log_print_str("Error: min_map_res is > ");
    log_print_int(config->min_map_res);
    log_print_str(", and should be <= ");
    log_println_int(8);
    config->min_map_res = 8;
  }

  return result;
}

// lw_netconf_print
// file netconf.c line 266
void lw_netconf_print(struct anonymous_4 *config)
{
  log_print_str("cursor_increase_speed = ");
  log_println_int(config->cursor_increase_speed);
  log_print_str("fighter_attack = ");
  log_println_int(config->fighter_attack);
  log_print_str("fighter_defense = ");
  log_println_int(config->fighter_defense);
  log_print_str("fighter_new_health = ");
  log_println_int(config->fighter_new_health);
  log_print_str("number_influence = ");
  log_println_int(config->number_influence);
  log_print_str("fighter_number = ");
  log_println_int(config->fighter_number);
  log_print_str("game_time = ");
  log_println_int(config->game_time);
  log_print_str("cpu_advantage = ");
  log_println_int(config->cpu_advantage);
  log_print_str("cpu_vs_human = ");
  log_println_int(config->cpu_vs_human);
  log_print_str("asm_algorithm = ");
  log_println_int(config->asm_algorithm);
  log_print_str("min_map_res = ");
  log_println_int(config->min_map_res);
}

// lw_netconf_recv
// file netconf.c line 178
signed int lw_netconf_recv(signed int *sock, struct anonymous_4 *config)
{
  signed int result = 0;
  char buffer[1000l];
  memset((void *)config, 0, sizeof(struct anonymous_4) /*44ul*/ );
  signed int return_value_lw_sock_recv_str_11;
  return_value_lw_sock_recv_str_11=lw_sock_recv_str(sock, buffer);
  if(!(return_value_lw_sock_recv_str_11 == 0))
  {
    config->cursor_increase_speed=atoi_link1(buffer);
    signed int return_value_lw_sock_recv_str_10;
    return_value_lw_sock_recv_str_10=lw_sock_recv_str(sock, buffer);
    if(!(return_value_lw_sock_recv_str_10 == 0))
    {
      config->fighter_attack=atoi_link1(buffer);
      signed int return_value_lw_sock_recv_str_9;
      return_value_lw_sock_recv_str_9=lw_sock_recv_str(sock, buffer);
      if(!(return_value_lw_sock_recv_str_9 == 0))
      {
        config->fighter_defense=atoi_link1(buffer);
        signed int return_value_lw_sock_recv_str_8;
        return_value_lw_sock_recv_str_8=lw_sock_recv_str(sock, buffer);
        if(!(return_value_lw_sock_recv_str_8 == 0))
        {
          config->fighter_new_health=atoi_link1(buffer);
          signed int return_value_lw_sock_recv_str_7;
          return_value_lw_sock_recv_str_7=lw_sock_recv_str(sock, buffer);
          if(!(return_value_lw_sock_recv_str_7 == 0))
          {
            config->number_influence=atoi_link1(buffer);
            signed int return_value_lw_sock_recv_str_6;
            return_value_lw_sock_recv_str_6=lw_sock_recv_str(sock, buffer);
            if(!(return_value_lw_sock_recv_str_6 == 0))
            {
              config->fighter_number=atoi_link1(buffer);
              signed int return_value_lw_sock_recv_str_5;
              return_value_lw_sock_recv_str_5=lw_sock_recv_str(sock, buffer);
              if(!(return_value_lw_sock_recv_str_5 == 0))
              {
                config->game_time=atoi_link1(buffer);
                signed int return_value_lw_sock_recv_str_4;
                return_value_lw_sock_recv_str_4=lw_sock_recv_str(sock, buffer);
                if(!(return_value_lw_sock_recv_str_4 == 0))
                {
                  config->cpu_advantage=atoi_link1(buffer);
                  signed int return_value_lw_sock_recv_str_3;
                  return_value_lw_sock_recv_str_3=lw_sock_recv_str(sock, buffer);
                  if(!(return_value_lw_sock_recv_str_3 == 0))
                  {
                    config->cpu_vs_human=atoi_link1(buffer);
                    signed int return_value_lw_sock_recv_str_2;
                    return_value_lw_sock_recv_str_2=lw_sock_recv_str(sock, buffer);
                    if(!(return_value_lw_sock_recv_str_2 == 0))
                    {
                      config->asm_algorithm=atoi_link1(buffer);
                      signed int return_value_lw_sock_recv_str_1;
                      return_value_lw_sock_recv_str_1=lw_sock_recv_str(sock, buffer);
                      if(!(return_value_lw_sock_recv_str_1 == 0))
                      {
                        config->min_map_res=atoi_link1(buffer);
                        result = 1;
                      }

                    }

                  }

                }

              }

            }

          }

        }

      }

    }

  }

  return result;
}

// lw_netconf_send
// file netconf.c line 112
signed int lw_netconf_send(signed int *sock, struct anonymous_4 *config)
{
  signed int result = 0;
  char buffer[1000l];
  memset((void *)buffer, 0, sizeof(char [1000l]) /*1000ul*/ );
  snprintf(buffer, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%d", config->cursor_increase_speed);
  buffer[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  signed int return_value_lw_sock_send_str_11;
  return_value_lw_sock_send_str_11=lw_sock_send_str(sock, buffer);
  if(!(return_value_lw_sock_send_str_11 == 0))
  {
    memset((void *)buffer, 0, sizeof(char [1000l]) /*1000ul*/ );
    snprintf(buffer, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%d", config->fighter_attack);
    buffer[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
    signed int return_value_lw_sock_send_str_10;
    return_value_lw_sock_send_str_10=lw_sock_send_str(sock, buffer);
    if(!(return_value_lw_sock_send_str_10 == 0))
    {
      memset((void *)buffer, 0, sizeof(char [1000l]) /*1000ul*/ );
      snprintf(buffer, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%d", config->fighter_defense);
      buffer[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
      signed int return_value_lw_sock_send_str_9;
      return_value_lw_sock_send_str_9=lw_sock_send_str(sock, buffer);
      if(!(return_value_lw_sock_send_str_9 == 0))
      {
        memset((void *)buffer, 0, sizeof(char [1000l]) /*1000ul*/ );
        snprintf(buffer, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%d", config->fighter_new_health);
        buffer[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
        signed int return_value_lw_sock_send_str_8;
        return_value_lw_sock_send_str_8=lw_sock_send_str(sock, buffer);
        if(!(return_value_lw_sock_send_str_8 == 0))
        {
          memset((void *)buffer, 0, sizeof(char [1000l]) /*1000ul*/ );
          snprintf(buffer, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%d", config->number_influence);
          buffer[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
          signed int return_value_lw_sock_send_str_7;
          return_value_lw_sock_send_str_7=lw_sock_send_str(sock, buffer);
          if(!(return_value_lw_sock_send_str_7 == 0))
          {
            memset((void *)buffer, 0, sizeof(char [1000l]) /*1000ul*/ );
            snprintf(buffer, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%d", config->fighter_number);
            buffer[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
            signed int return_value_lw_sock_send_str_6;
            return_value_lw_sock_send_str_6=lw_sock_send_str(sock, buffer);
            if(!(return_value_lw_sock_send_str_6 == 0))
            {
              memset((void *)buffer, 0, sizeof(char [1000l]) /*1000ul*/ );
              snprintf(buffer, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%d", config->game_time);
              buffer[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
              signed int return_value_lw_sock_send_str_5;
              return_value_lw_sock_send_str_5=lw_sock_send_str(sock, buffer);
              if(!(return_value_lw_sock_send_str_5 == 0))
              {
                memset((void *)buffer, 0, sizeof(char [1000l]) /*1000ul*/ );
                snprintf(buffer, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%d", config->cpu_advantage);
                buffer[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
                signed int return_value_lw_sock_send_str_4;
                return_value_lw_sock_send_str_4=lw_sock_send_str(sock, buffer);
                if(!(return_value_lw_sock_send_str_4 == 0))
                {
                  memset((void *)buffer, 0, sizeof(char [1000l]) /*1000ul*/ );
                  snprintf(buffer, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%d", config->cpu_vs_human);
                  buffer[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
                  signed int return_value_lw_sock_send_str_3;
                  return_value_lw_sock_send_str_3=lw_sock_send_str(sock, buffer);
                  if(!(return_value_lw_sock_send_str_3 == 0))
                  {
                    memset((void *)buffer, 0, sizeof(char [1000l]) /*1000ul*/ );
                    snprintf(buffer, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%d", config->asm_algorithm);
                    buffer[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
                    signed int return_value_lw_sock_send_str_2;
                    return_value_lw_sock_send_str_2=lw_sock_send_str(sock, buffer);
                    if(!(return_value_lw_sock_send_str_2 == 0))
                    {
                      memset((void *)buffer, 0, sizeof(char [1000l]) /*1000ul*/ );
                      snprintf(buffer, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%d", config->min_map_res);
                      buffer[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
                      signed int return_value_lw_sock_send_str_1;
                      return_value_lw_sock_send_str_1=lw_sock_send_str(sock, buffer);
                      if(!(return_value_lw_sock_send_str_1 == 0))
                        result = 1;

                    }

                  }

                }

              }

            }

          }

        }

      }

    }

  }

  return result;
}

// lw_netkey_peek
// file netkey.h line 90
signed int lw_netkey_peek(signed int *sock, signed int num)
{
  signed int result;
  result=lw_sock_peek(sock, num * (6 + 2 + 4));
  return result;
}

// lw_netkey_recv
// file netkey.h line 89
signed int lw_netkey_recv(signed int *sock, struct anonymous_5 *netkey)
{
  signed int result;
  unsigned char netkey_serialized[12l];
  result=lw_sock_recv_buffer(sock, (char *)netkey_serialized, 6 + 2 + 4);
  decode(netkey, netkey_serialized);
  return result;
}

// lw_netkey_reset
// file netkey.h line 87
void lw_netkey_reset(struct anonymous_5 *netkey)
{
  signed int i = 0;
  for( ; !(i >= 6); i = i + 1)
    netkey->key_states[(signed long int)i] = 0;
  netkey->cmd = 110;
  netkey->arg = 0;
}

// lw_netkey_send
// file netkey.h line 88
signed int lw_netkey_send(signed int *sock, struct anonymous_5 *netkey)
{
  signed int result;
  unsigned char netkey_serialized[12l];
  encode(netkey_serialized, netkey);
  result=lw_sock_send_buffer(sock, (char *)netkey_serialized, 6 + 2 + 4);
  return result;
}

// lw_netmap_recv
// file netmap.c line 140
signed int lw_netmap_recv(signed int *sock, void **netmap)
{
  signed int result = 0;
  char buffer[56l];
  signed int size;
  signed short int w;
  signed short int h;
  char *ptr;
  signed int received;
  signed int to_receive;
  ptr = (char *)*netmap;
  if(!(ptr == ((char *)NULL)))
    free((void *)ptr);

  ptr = (char *)(void *)0;
  signed int return_value_lw_sock_recv_buffer_5;
  return_value_lw_sock_recv_buffer_5=lw_sock_recv_buffer(sock, buffer, 8);
  if(!(return_value_lw_sock_recv_buffer_5 == 0))
  {
    signed int return_value_lw_sock_recv_buffer_4;
    return_value_lw_sock_recv_buffer_4=lw_sock_recv_buffer(sock, buffer + (signed long int)8, 16);
    if(!(return_value_lw_sock_recv_buffer_4 == 0))
    {
      signed int return_value_lw_sock_recv_buffer_3;
      return_value_lw_sock_recv_buffer_3=lw_sock_recv_buffer(sock, buffer + (signed long int)8 + (signed long int)16, 32);
      if(!(return_value_lw_sock_recv_buffer_3 == 0))
      {
        lw_serial_get_map_header((void *)buffer, &size, &w, &h);
        if(size >= 10)
        {
          void *return_value_malloc_1;
          return_value_malloc_1=malloc((unsigned long int)(size + 8 + 16 + 32));
          ptr = (char *)return_value_malloc_1;
          if(!(ptr == ((char *)NULL)))
          {
            memcpy((void *)ptr, (const void *)buffer, (unsigned long int)(8 + 16 + 32));
            result = 1;
            received = 0;
            while(!(result == 0) && !(received >= size))
            {
              to_receive = size - received;
              if(to_receive >= 65)
                to_receive = 64;

              signed int return_value_lw_sock_recv_buffer_2;
              return_value_lw_sock_recv_buffer_2=lw_sock_recv_buffer(sock, ptr + (signed long int)8 + (signed long int)16 + (signed long int)32 + (signed long int)received, to_receive);
              if(!(return_value_lw_sock_recv_buffer_2 == 0))
                received = received + to_receive;

              else
                result = 0;
            }
          }

        }

      }

    }

  }

  *netmap = (void *)ptr;
  return result;
}

// lw_netmap_send
// file netmap.c line 86
signed int lw_netmap_send(signed int *sock, void *netmap)
{
  signed int result = 0;
  char *ptr;
  unsigned char *header;
  signed int size;
  signed int sent;
  signed int to_send;
  ptr = (char *)netmap;
  header = (unsigned char *)netmap;
  signed int return_value_lw_sock_send_buffer_4;
  return_value_lw_sock_send_buffer_4=lw_sock_send_buffer(sock, ptr, 8);
  if(!(return_value_lw_sock_send_buffer_4 == 0))
  {
    signed int return_value_lw_sock_send_buffer_3;
    return_value_lw_sock_send_buffer_3=lw_sock_send_buffer(sock, ptr + (signed long int)8, 16);
    if(!(return_value_lw_sock_send_buffer_3 == 0))
    {
      signed int return_value_lw_sock_send_buffer_2;
      return_value_lw_sock_send_buffer_2=lw_sock_send_buffer(sock, ptr + (signed long int)8 + (signed long int)16, 32);
      if(!(return_value_lw_sock_send_buffer_2 == 0))
      {
        lw_serial_get_map_header(netmap, &size, (signed short int *)(void *)0, (signed short int *)(void *)0);
        result = 1;
        sent = 0;
        while(!(result == 0) && !(sent >= size))
        {
          to_send = size - sent;
          if(to_send >= 65)
            to_send = 64;

          signed int return_value_lw_sock_send_buffer_1;
          return_value_lw_sock_send_buffer_1=lw_sock_send_buffer(sock, ptr + (signed long int)8 + (signed long int)16 + (signed long int)32 + (signed long int)sent, to_send);
          if(!(return_value_lw_sock_send_buffer_1 == 0))
            sent = sent + to_send;

          else
            result = 0;
        }
      }

    }

  }

  return result;
}

// lw_netmess_cleanup_arg
// file netmess.h line 137
extern void lw_netmess_cleanup_arg(char *string)
{
  char *pos;
  unsigned char c;
  pos = string;
  _Bool tmp_if_expr_2;
  char *return_value___builtin_strchr_1;
  do
  {
    c = (unsigned char)*pos;
    if((signed int)c == 0)
      break;

    if((signed int)c >= 128 || !((signed int)c >= 32))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value___builtin_strchr_1=__builtin_strchr("'\",", (signed int)c);
      tmp_if_expr_2 = return_value___builtin_strchr_1 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      *pos = (char)32;

    pos = pos + 1l;
  }
  while((_Bool)1);
}

// lw_netmess_free
// file netmess.c line 432
extern void lw_netmess_free(struct anonymous_6 *ptr)
{
  signed int i;
  if(!(ptr == ((struct anonymous_6 *)NULL)))
  {
    if(!(ptr->argv == ((char **)NULL)))
    {
      i = 0;
      for( ; !(i >= ptr->argc); i = i + 1)
        free((void *)ptr->argv[(signed long int)i]);
      if(ptr->argc >= 1)
        free((void *)ptr->argv);

    }

  }

}

// lw_netmess_read
// file netmess.c line 411
extern struct anonymous_6 * lw_netmess_read(char *message)
{
  struct anonymous_6 *result = (struct anonymous_6 *)(void *)0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_6) /*16ul*/ );
  result = (struct anonymous_6 *)return_value_malloc_1;
  if(!(result == ((struct anonymous_6 *)NULL)))
  {
    result->code=get_code(&message);
    result->argc=get_argc(message);
    result->argv=get_argv(message, result->argc);
  }

  return result;
}

// lw_network_attribute_colors
// file network.h line 89
extern void lw_network_attribute_colors()
{
  signed int i;
  signed int color;
  i = 0;
  for( ; !(i >= 6); i = i + 1)
    if(!(LW_NETWORK_INFO[(signed long int)i].active == 0))
    {
      if(!(LW_NETWORK_INFO[(signed long int)i].network == 0))
        LW_NETWORK_INFO[(signed long int)i].color = -1;

      else
        LW_NETWORK_INFO[(signed long int)i].color = CONFIG_TEAM_COLOR[(signed long int)i];
    }

  i = 0;
  for( ; !(i >= 6); i = i + 1)
    if(!(LW_NETWORK_INFO[(signed long int)i].active == 0))
    {
      if(!(LW_NETWORK_INFO[(signed long int)i].network == 0))
      {
        color=choose_different_color();
        LW_NETWORK_INFO[(signed long int)i].color = color;
      }

    }

}

// lw_network_attribute_parts
// file network.h line 90
extern void lw_network_attribute_parts()
{
  signed int i = 0;
  static signed int order[6l] = { 0, 5, 2, 3, 1, 4 };
  for( ; !(i >= 6); i = i + 1)
    if(!(LW_NETWORK_INFO[(signed long int)i].active == 0))
      LW_NETWORK_INFO[(signed long int)i].part = order[(signed long int)LW_NETWORK_INFO[(signed long int)i].server_id];

}

// lw_path_get_system_name
// file path.h line 69
char * lw_path_get_system_name(const char *filename)
{
  char buf1[1000l];
  char *start;
  char *end;
  char *search;
  memset((void *)buf1, 0, sizeof(char [1000l]) /*1000ul*/ );
  __builtin_strncpy(buf1, filename, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
  buf1[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  search=strrchr(buf1, 47);
  _Bool tmp_if_expr_1;
  if(!(search == ((char *)NULL)))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    search=strrchr(buf1, 92);
    tmp_if_expr_1 = search != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1)
    start = search + (signed long int)1;

  else
    start = buf1;
  static char buf2[1000l];
  memset((void *)buf2, 0, sizeof(char [1000l]) /*1000ul*/ );
  __builtin_strncpy(buf2, start, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
  buf2[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  char *return_value___builtin_strchr_3;
  return_value___builtin_strchr_3=__builtin_strchr(buf2, 46);
  search = return_value___builtin_strchr_3;
  if(!(search == ((char *)NULL)))
    end = search;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(buf2);
    end = buf2 + (signed long int)return_value_strlen_2;
  }
  if(search == ((char *)NULL))
  {
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(buf2);
    search = buf2 + (signed long int)return_value_strlen_4;
  }

  memset((void *)search, 0, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)(search - buf2));
  return buf2;
}

// lw_ping_try_server
// file ping.c line 117
signed int lw_ping_try_server(char *address, signed int port)
{
  signed int result = -1;
  struct anonymous_9 *try_data;
  signed int start_time = 0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_9) /*36ul*/ );
  try_data = (struct anonymous_9 *)return_value_malloc_1;
  signed int return_value_get_ticker_2;
  if(!(try_data == ((struct anonymous_9 *)NULL)))
  {
    memset((void *)try_data, 0, sizeof(struct anonymous_9) /*36ul*/ );
    try_data->sock = -1;
    memset((void *)try_data->address, 0, sizeof(char [16l]) /*16ul*/ );
    __builtin_strncpy(try_data->address, address, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
    try_data->address[(signed long int)(sizeof(char [16l]) /*16ul*/  - (unsigned long int)1)] = (char)0;
    try_data->port = port;
    try_data->allow_exit = 0;
    try_data->result = -1;
    signed int return_value_lw_thread_start_3;
    return_value_lw_thread_start_3=lw_thread_start(try_server_callback, (void *)try_data);
    if(!(return_value_lw_thread_start_3 == 0))
    {
      start_time=get_ticker();
      while(try_data->done == 0)
      {
        return_value_get_ticker_2=get_ticker();
        if(return_value_get_ticker_2 >= 750 + start_time)
          break;

        rest((unsigned int)10);
      }
      result = try_data->result;
      try_data->allow_exit = 1;
    }

    else
      free((void *)try_data);
  }

  return result;
}

// lw_protocol_ask_free_teams
// file protocol.h line 84
signed int lw_protocol_ask_free_teams(signed int *sock, signed int *nb)
{
  signed int result = 0;
  char message[1000l];
  signed int ret = 0;
  struct anonymous_6 *netmess;
  *nb = 0;
  signed int return_value_lw_sock_send_str_1;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_1=lw_sock_send_str(sock, "FREE");
    if(!(return_value_lw_sock_send_str_1 == 0))
    {
      while(*sock >= 0)
      {
        ret=lw_sock_recv_str(sock, message);
        if(!(ret == 0))
          break;

      }
      if(*sock >= 0)
      {
        if(ret >= 1)
        {
          netmess=lw_netmess_read(message);
          if(!(netmess == ((struct anonymous_6 *)NULL)))
          {
            if(netmess->code == 1)
            {
              if(netmess->argc == 1)
              {
                *nb=atoi_link4(netmess->argv[(signed long int)0]);
                result = 1;
              }

            }

            lw_netmess_free(netmess);
          }

        }

      }

    }

  }

  return result;
}

// lw_protocol_ask_teamstartinfo
// file protocol.h line 96
signed int lw_protocol_ask_teamstartinfo(signed int *sock, signed int team, struct anonymous_12 *team_start_info)
{
  signed int result = 0;
  char message[1000l];
  signed int ret = 0;
  struct anonymous_6 *netmess;
  lw_teamstartinfo_reset(team_start_info);
  memset((void *)message, 0, sizeof(char [1000l]) /*1000ul*/ );
  snprintf(message, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%s %d", (const void *)"TEAMSTARTINFO", team);
  message[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  signed int return_value_lw_sock_send_str_1;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_1=lw_sock_send_str(sock, message);
    if(!(return_value_lw_sock_send_str_1 == 0))
    {
      while(*sock >= 0)
      {
        ret=lw_sock_recv_str(sock, message);
        if(!(ret == 0))
          break;

      }
      if(*sock >= 0)
      {
        if(ret >= 1)
        {
          netmess=lw_netmess_read(message);
          if(!(netmess == ((struct anonymous_6 *)NULL)))
          {
            if(netmess->code == 1)
            {
              if(netmess->argc == 3)
              {
                team_start_info->active=atoi_link4(netmess->argv[(signed long int)0]);
                team_start_info->start=atoi_link4(netmess->argv[(signed long int)1]);
                __builtin_strncpy(team_start_info->name, netmess->argv[(signed long int)2], (unsigned long int)10);
                team_start_info->name[(signed long int)10] = (char)0;
                result = 1;
              }

            }

            lw_netmess_free(netmess);
          }

        }

      }

    }

  }

  return result;
}

// lw_protocol_ask_who
// file protocol.h line 87
signed int lw_protocol_ask_who(signed int *sock, signed int num, struct anonymous_8 *who)
{
  signed int result = 0;
  char message[1000l];
  signed int ret = 0;
  struct anonymous_6 *netmess;
  who->active = 0;
  who->network = 0;
  who->server_id = -1;
  who->name[(signed long int)0] = (char)0;
  memset((void *)message, 0, sizeof(char [1000l]) /*1000ul*/ );
  snprintf(message, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%s %d", (const void *)"WHO", num);
  message[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  signed int return_value_lw_sock_send_str_1;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_1=lw_sock_send_str(sock, message);
    if(!(return_value_lw_sock_send_str_1 == 0))
    {
      while(*sock >= 0)
      {
        ret=lw_sock_recv_str(sock, message);
        if(!(ret == 0))
          break;

      }
      if(*sock >= 0)
      {
        if(ret >= 1)
        {
          netmess=lw_netmess_read(message);
          if(!(netmess == ((struct anonymous_6 *)NULL)))
          {
            switch(netmess->code)
            {
              case 18:
              {
                if(netmess->argc == 0)
                  result = 1;

                break;
              }
              case 17:
                who->network = 1;
              case 16:
                if(netmess->argc == 3)
                {
                  who->active = 1;
                  who->server_id=atoi_link4(netmess->argv[(signed long int)0]);
                  who->control_type=atoi_link4(netmess->argv[(signed long int)1]);
                  __builtin_strncpy(who->name, netmess->argv[(signed long int)2], (unsigned long int)10);
                  who->name[(signed long int)10] = (char)0;
                  result = 1;
                }

            }
            lw_netmess_free(netmess);
          }

        }

      }

    }

  }

  return result;
}

// lw_protocol_chat_listen
// file protocol.h line 99
signed int lw_protocol_chat_listen(signed int *sock, struct anonymous_13 *chat_history)
{
  signed int result = 0;
  char message[1000l];
  signed int ret = 0;
  struct anonymous_6 *netmess;
  signed int return_value_lw_sock_send_str_1;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_1=lw_sock_send_str(sock, "CHATLISTEN");
    if(!(return_value_lw_sock_send_str_1 == 0))
    {
      while(*sock >= 0)
      {
        ret=lw_sock_recv_str(sock, message);
        if(!(ret == 0))
          break;

      }
      if(*sock >= 0)
      {
        if(ret >= 1)
        {
          netmess=lw_netmess_read(message);
          if(!(netmess == ((struct anonymous_6 *)NULL)))
          {
            if(netmess->code == 1)
              switch(netmess->argc)
              {
                case 0:
                {
                  result = 1;
                  break;
                }
                case 2:
                {
                  lw_chat_push(chat_history, netmess->argv[(signed long int)0], netmess->argv[(signed long int)1]);
                  result = 1;
                }
              }

            lw_netmess_free(netmess);
          }

        }

      }

    }

  }

  return result;
}

// lw_protocol_chat_talk
// file protocol.h line 98
signed int lw_protocol_chat_talk(signed int *sock, char *text)
{
  signed int result = 0;
  char message[1000l];
  memset((void *)message, 0, sizeof(char [1000l]) /*1000ul*/ );
  snprintf(message, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%s '%s'", (const void *)"CHATTALK", text);
  message[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  signed int return_value_lw_sock_send_str_2;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_2=lw_sock_send_str(sock, message);
    if(!(return_value_lw_sock_send_str_2 == 0))
    {
      signed int return_value_recv_ok_1;
      return_value_recv_ok_1=recv_ok(sock);
      if(!(return_value_recv_ok_1 == 0))
        result = 1;

    }

  }

  return result;
}

// lw_protocol_do_ping
// file protocol.h line 80
signed int lw_protocol_do_ping(signed int *sock)
{
  signed int result = 0;
  signed int return_value_lw_sock_send_str_2;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_2=lw_sock_send_str(sock, "PING");
    if(!(return_value_lw_sock_send_str_2 == 0))
    {
      signed int return_value_recv_ok_1;
      return_value_recv_ok_1=recv_ok(sock);
      if(!(return_value_recv_ok_1 == 0))
        result = 1;

    }

  }

  return result;
}

// lw_protocol_force_start
// file protocol.h line 94
signed int lw_protocol_force_start(signed int *sock)
{
  signed int result = 0;
  signed int return_value_lw_sock_send_str_2;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_2=lw_sock_send_str(sock, "START");
    if(!(return_value_lw_sock_send_str_2 == 0))
    {
      signed int return_value_recv_ok_1;
      return_value_recv_ok_1=recv_ok(sock);
      if(!(return_value_recv_ok_1 == 0))
        result = 1;

    }

  }

  return result;
}

// lw_protocol_i_am_ready
// file protocol.h line 92
signed int lw_protocol_i_am_ready(signed int *sock)
{
  signed int result = 0;
  signed int return_value_lw_sock_send_str_2;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_2=lw_sock_send_str(sock, "READY");
    if(!(return_value_lw_sock_send_str_2 == 0))
    {
      signed int return_value_recv_ok_1;
      return_value_recv_ok_1=recv_ok(sock);
      if(!(return_value_recv_ok_1 == 0))
        result = 1;

    }

  }

  return result;
}

// lw_protocol_next
// file protocol.h line 95
signed int lw_protocol_next(signed int *sock)
{
  signed int result = 0;
  signed int return_value_lw_sock_send_str_2;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_2=lw_sock_send_str(sock, "NEXT");
    if(!(return_value_lw_sock_send_str_2 == 0))
    {
      signed int return_value_recv_ok_1;
      return_value_recv_ok_1=recv_ok(sock);
      if(!(return_value_recv_ok_1 == 0))
        result = 1;

    }

  }

  return result;
}

// lw_protocol_quit
// file protocol.h line 100
signed int lw_protocol_quit(signed int *sock)
{
  signed int result = 0;
  lw_sock_send_str(sock, "QUIT");
  return result;
}

// lw_protocol_recv_config
// file protocol.h line 91
signed int lw_protocol_recv_config(signed int *sock)
{
  signed int result = 0;
  struct anonymous_4 config;
  signed int return_value_lw_sock_send_str_3;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_3=lw_sock_send_str(sock, "RECVCONFIG");
    if(!(return_value_lw_sock_send_str_3 == 0))
    {
      signed int return_value_lw_netconf_recv_2;
      return_value_lw_netconf_recv_2=lw_netconf_recv(sock, &config);
      if(!(return_value_lw_netconf_recv_2 == 0))
      {
        signed int return_value_recv_ok_1;
        return_value_recv_ok_1=recv_ok(sock);
        if(!(return_value_recv_ok_1 == 0))
        {
          memcpy((void *)&LW_CONFIG_CURRENT_RULES, (const void *)&config, sizeof(struct anonymous_4) /*44ul*/ );
          result = 1;
        }

      }

    }

  }

  return result;
}

// lw_protocol_recv_map
// file protocol.h line 89
signed int lw_protocol_recv_map(signed int *sock, void **map)
{
  signed int result = 0;
  signed int return_value_lw_sock_send_str_3;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_3=lw_sock_send_str(sock, "RECVMAP");
    if(!(return_value_lw_sock_send_str_3 == 0))
    {
      signed int return_value_lw_netmap_recv_2;
      return_value_lw_netmap_recv_2=lw_netmap_recv(sock, map);
      if(!(return_value_lw_netmap_recv_2 == 0))
      {
        signed int return_value_recv_ok_1;
        return_value_recv_ok_1=recv_ok(sock);
        if(!(return_value_recv_ok_1 == 0))
          result = 1;

      }

    }

  }

  return result;
}

// lw_protocol_reserve_team
// file protocol.h line 85
signed int lw_protocol_reserve_team(signed int *sock, signed int num, signed int control_type, char *name)
{
  signed int result = 0;
  char message[1000l];
  memset((void *)message, 0, sizeof(char [1000l]) /*1000ul*/ );
  snprintf(message, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%s %d,%d,'%s'", (const void *)"TEAM", num, control_type, name);
  message[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  signed int return_value_lw_sock_send_str_2;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_2=lw_sock_send_str(sock, message);
    if(!(return_value_lw_sock_send_str_2 == 0))
    {
      signed int return_value_recv_ok_1;
      return_value_recv_ok_1=recv_ok(sock);
      if(!(return_value_recv_ok_1 == 0))
        result = 1;

    }

  }

  return result;
}

// lw_protocol_send_config
// file protocol.h line 90
signed int lw_protocol_send_config(signed int *sock)
{
  signed int result = 0;
  struct anonymous_4 config;
  signed int return_value_lw_sock_send_str_3;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_3=lw_sock_send_str(sock, "SENDCONFIG");
    if(!(return_value_lw_sock_send_str_3 == 0))
    {
      memcpy((void *)&config, (const void *)&LW_CONFIG_CURRENT_RULES, sizeof(struct anonymous_4) /*44ul*/ );
      signed int return_value_lw_netconf_send_2;
      return_value_lw_netconf_send_2=lw_netconf_send(sock, &config);
      if(!(return_value_lw_netconf_send_2 == 0))
      {
        signed int return_value_recv_ok_1;
        return_value_recv_ok_1=recv_ok(sock);
        if(!(return_value_recv_ok_1 == 0))
          result = 1;

      }

    }

  }

  return result;
}

// lw_protocol_send_map
// file protocol.h line 88
signed int lw_protocol_send_map(signed int *sock, void *map)
{
  signed int result = 0;
  signed int return_value_lw_sock_send_str_3;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_3=lw_sock_send_str(sock, "SENDMAP");
    if(!(return_value_lw_sock_send_str_3 == 0))
    {
      signed int return_value_lw_netmap_send_2;
      return_value_lw_netmap_send_2=lw_netmap_send(sock, map);
      if(!(return_value_lw_netmap_send_2 == 0))
      {
        signed int return_value_recv_ok_1;
        return_value_recv_ok_1=recv_ok(sock);
        if(!(return_value_recv_ok_1 == 0))
          result = 1;

      }

    }

  }

  return result;
}

// lw_protocol_tell_password
// file protocol.h line 83
signed int lw_protocol_tell_password(signed int *sock, char *password)
{
  signed int result = 0;
  char message[1000l];
  memset((void *)message, 0, sizeof(char [1000l]) /*1000ul*/ );
  snprintf(message, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%s '%s'", (const void *)"PASSWORD", password);
  message[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  signed int return_value_lw_sock_send_str_2;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_2=lw_sock_send_str(sock, message);
    if(!(return_value_lw_sock_send_str_2 == 0))
    {
      signed int return_value_recv_ok_1;
      return_value_recv_ok_1=recv_ok(sock);
      if(!(return_value_recv_ok_1 == 0))
        result = 1;

    }

  }

  return result;
}

// lw_protocol_tell_program
// file protocol.h line 82
signed int lw_protocol_tell_program(signed int *sock, char *program)
{
  signed int result = 0;
  char message[1000l];
  memset((void *)message, 0, sizeof(char [1000l]) /*1000ul*/ );
  snprintf(message, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%s '%s'", (const void *)"PROGRAM", program);
  message[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  signed int return_value_lw_sock_send_str_2;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_2=lw_sock_send_str(sock, message);
    if(!(return_value_lw_sock_send_str_2 == 0))
    {
      signed int return_value_recv_ok_1;
      return_value_recv_ok_1=recv_ok(sock);
      if(!(return_value_recv_ok_1 == 0))
        result = 1;

    }

  }

  return result;
}

// lw_protocol_tell_version
// file protocol.h line 81
signed int lw_protocol_tell_version(signed int *sock, char *version)
{
  signed int result = 0;
  char message[1000l];
  memset((void *)message, 0, sizeof(char [1000l]) /*1000ul*/ );
  snprintf(message, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%s '%s'", (const void *)"VERSION", version);
  message[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  signed int return_value_lw_sock_send_str_2;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_2=lw_sock_send_str(sock, message);
    if(!(return_value_lw_sock_send_str_2 == 0))
    {
      signed int return_value_recv_ok_1;
      return_value_recv_ok_1=recv_ok(sock);
      if(!(return_value_recv_ok_1 == 0))
        result = 1;

    }

  }

  return result;
}

// lw_protocol_waiting
// file protocol.h line 93
signed int lw_protocol_waiting(signed int *sock, signed int *waited_teams)
{
  signed int result = 0;
  char message[1000l];
  signed int ret = 0;
  struct anonymous_6 *netmess;
  signed int return_value_lw_sock_send_str_1;
  if(*sock >= 0)
  {
    return_value_lw_sock_send_str_1=lw_sock_send_str(sock, "WAITING");
    if(!(return_value_lw_sock_send_str_1 == 0))
    {
      while(*sock >= 0)
      {
        ret=lw_sock_recv_str(sock, message);
        if(!(ret == 0))
          break;

      }
      if(*sock >= 0)
      {
        if(ret >= 1)
        {
          netmess=lw_netmess_read(message);
          if(!(netmess == ((struct anonymous_6 *)NULL)))
          {
            if(netmess->code == 1)
            {
              if(netmess->argc == 1)
              {
                *waited_teams=atoi_link4(netmess->argv[(signed long int)0]);
                result = 1;
              }

            }

            lw_netmess_free(netmess);
          }

        }

      }

    }

  }

  return result;
}

// lw_random_generate_map
// file random.h line 76
signed int lw_random_generate_map()
{
  struct BITMAP *bmp;
  struct RGB pal[256l];
  void *raw_map = (void *)0;
  signed int result = 0;
  bmp=generate_bitmap();
  generate_bw_palette(pal);
  if(!(bmp == ((struct BITMAP *)NULL)))
    raw_map=lw_map_archive_raw_bmp(bmp, pal, "lwmapgen");

  if(!(raw_map == NULL))
  {
    if(!(LW_RANDOM_RAW_MAP == NULL))
      free(LW_RANDOM_RAW_MAP);

    LW_RANDOM_RAW_MAP = raw_map;
    result = 1;
  }

  return result;
}

// lw_serial_get_int
// file serial.c line 83
signed int lw_serial_get_int(void *raw)
{
  signed int i = 0;
  unsigned char *ptr = (unsigned char *)raw;
  i = (signed int)((unsigned int)ptr[(signed long int)3] << 24 | (unsigned int)ptr[(signed long int)2] << 16 | (unsigned int)ptr[(signed long int)1] << 8 | (unsigned int)ptr[(signed long int)0]);
  return i;
}

// lw_serial_get_map_header
// file serial.h line 76
void lw_serial_get_map_header(void *raw_map, signed int *size, signed short int *w, signed short int *h)
{
  char *header = (char *)raw_map;
  if(!(size == ((signed int *)NULL)))
    *size=lw_serial_get_int((void *)header);

  if(!(w == ((signed short int *)NULL)))
    *w=lw_serial_get_short((void *)(header + (signed long int)4));

  if(!(h == ((signed short int *)NULL)))
    *h=lw_serial_get_short((void *)(header + (signed long int)6));

}

// lw_serial_get_short
// file serial.c line 126
signed short int lw_serial_get_short(void *raw)
{
  signed short int s = (signed short int)0;
  unsigned char *ptr = (unsigned char *)raw;
  s = (signed short int)((unsigned int)ptr[(signed long int)1] << 8 | (unsigned int)ptr[(signed long int)0]);
  return s;
}

// lw_serial_get_texture_header
// file serial.c line 196
void lw_serial_get_texture_header(void *raw_texture, signed short int *w, signed short int *h)
{
  char *header = (char *)raw_texture;
  if(!(w == ((signed short int *)NULL)))
    *w=lw_serial_get_short((void *)(header + (signed long int)0));

  if(!(h == ((signed short int *)NULL)))
    *h=lw_serial_get_short((void *)(header + (signed long int)2));

}

// lw_serial_set_int
// file serial.c line 105
void lw_serial_set_int(void *raw, signed int i)
{
  unsigned char *ptr = (unsigned char *)raw;
  ptr[(signed long int)0] = (unsigned char)(0xFF & i);
  ptr[(signed long int)1] = (unsigned char)(0xFF & i >> 8);
  ptr[(signed long int)2] = (unsigned char)(0xFF & i >> 16);
  ptr[(signed long int)3] = (unsigned char)(i >> 24);
}

// lw_serial_set_map_header
// file serial.h line 77
void lw_serial_set_map_header(void *raw_map, signed int size, signed short int w, signed short int h)
{
  char *header = (char *)raw_map;
  lw_serial_set_int((void *)header, size);
  lw_serial_set_short((void *)(header + (signed long int)4), (signed int)w);
  lw_serial_set_short((void *)(header + (signed long int)6), (signed int)h);
}

// lw_serial_set_short
// file serial.c line 144
void lw_serial_set_short(void *raw, signed int s)
{
  unsigned char *ptr = (unsigned char *)raw;
  ptr[(signed long int)0] = (unsigned char)(0xFF & s);
  ptr[(signed long int)1] = (unsigned char)(0xFF & s >> 8);
}

// lw_serial_set_texture_header
// file serial.c line 214
void lw_serial_set_texture_header(void *raw_texture, signed short int w, signed short int h)
{
  char *header = (char *)raw_texture;
  lw_serial_set_short((void *)(header + (signed long int)0), (signed int)w);
  lw_serial_set_short((void *)(header + (signed long int)2), (signed int)h);
}

// lw_sock_accept
// file sockunix.c line 175
signed int lw_sock_accept(signed int *new_sock, char *ip, signed int *port, signed int listening_sock, signed int wait)
{
  signed int result = 0;
  struct sockaddr_in name;
  unsigned int namelen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  struct anonymous_14 read;
  struct timeval tv;
  signed int res;
  signed int enable = 1;
  signed int disable = 0;
  struct linger li;
  *new_sock = -1;
  ip[(signed long int)0] = (char)0;
  *port = 0;
  unsigned short int tmp_statement_expression_2;
  if(listening_sock >= 0)
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_14) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&read)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&read)->__fds_bits[(signed long int)(listening_sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&read)->__fds_bits[(signed long int)(listening_sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << listening_sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    if(!(wait == 0))
    {
      tv.tv_sec = (signed long int)1;
      tv.tv_usec = (signed long int)0;
    }

    else
    {
      tv.tv_sec = (signed long int)0;
      tv.tv_usec = (signed long int)0;
    }
    res=select(listening_sock + 1, &read, (struct anonymous_14 *)(void *)0, (struct anonymous_14 *)(void *)0, &tv);
    if(res >= 1)
    {
      *new_sock=accept(listening_sock, (struct sockaddr *)&name, &namelen);
      if(*new_sock >= 0)
      {
        li.l_onoff = 0;
        li.l_linger = 0;
        setsockopt(*new_sock, 1, 9, (const void *)(char *)&enable, (unsigned int)sizeof(signed int) /*4ul*/ );
        setsockopt(*new_sock, 1, 10, (const void *)(char *)&disable, (unsigned int)sizeof(signed int) /*4ul*/ );
        setsockopt(*new_sock, 1, 13, (const void *)(char *)&li, (unsigned int)sizeof(struct linger) /*8ul*/ );
        fcntl(*new_sock, 4, 04000, 0);
        char *return_value_inet_ntoa_1;
        return_value_inet_ntoa_1=inet_ntoa(name.sin_addr);
        __builtin_strncpy(ip, return_value_inet_ntoa_1, (unsigned long int)(16 - 1));
        ip[(signed long int)(16 - 1)] = (char)0;
        unsigned short int __v;
        unsigned short int __x = (unsigned short int)name.sin_port;
        asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
        tmp_statement_expression_2 = __v;
        *port = (signed int)tmp_statement_expression_2;
        result = 1;
      }

    }

  }

  return result;
}

// lw_sock_close
// file sockgen.h line 68
signed int lw_sock_close(signed int *sock)
{
  signed int result = 0;
  signed int sock_to_close = *sock;
  *sock = -1;
  signed int return_value_shutdown_1;
  return_value_shutdown_1=shutdown(sock_to_close, 2);
  signed int return_value_close_2;
  return_value_close_2=close(sock_to_close);
  if(return_value_close_2 == 0)
    result = 1;

  return result;
}

// lw_sock_connect
// file sockgen.h line 62
signed int lw_sock_connect(signed int *sock, char *ip, signed int port)
{
  signed int result = 0;
  struct sockaddr_in name;
  signed int enable = 1;
  signed int disable = 0;
  struct linger li;
  *sock=socket(2, 1, 0);
  unsigned short int tmp_statement_expression_1;
  if(*sock >= 0)
  {
    name.sin_family = (unsigned short int)2;
    name.sin_addr.s_addr = (unsigned int)0x00000000;
    name.sin_port = (unsigned short int)0;
    signed int return_value_bind_4;
    return_value_bind_4=bind(*sock, (struct sockaddr *)&name, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(return_value_bind_4 >= 0)
    {
      name.sin_family = (unsigned short int)2;
      signed int return_value_inet_aton_3;
      return_value_inet_aton_3=inet_aton(ip, &name.sin_addr);
      if(!(return_value_inet_aton_3 == 0))
      {
        unsigned short int __v;
        unsigned short int __x = (unsigned short int)port;
        asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
        tmp_statement_expression_1 = __v;
        name.sin_port = tmp_statement_expression_1;
        signed int return_value_connect_2;
        return_value_connect_2=connect(*sock, (struct sockaddr *)&name, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
        if(return_value_connect_2 >= 0)
        {
          li.l_onoff = 0;
          li.l_linger = 0;
          setsockopt(*sock, 1, 9, (const void *)(char *)&enable, (unsigned int)sizeof(signed int) /*4ul*/ );
          setsockopt(*sock, 1, 10, (const void *)(char *)&disable, (unsigned int)sizeof(signed int) /*4ul*/ );
          setsockopt(*sock, 1, 13, (const void *)(char *)&li, (unsigned int)sizeof(struct linger) /*8ul*/ );
          fcntl(*sock, 4, 04000, 0);
          result = 1;
        }

      }

    }

  }

  return result;
}

// lw_sock_exit
// file sockgen.h line 58
signed int lw_sock_exit()
{
  signed int result = 1;
  return result;
}

// lw_sock_init
// file sockgen.h line 57
signed int lw_sock_init()
{
  signed int result = 1;
  void (*return_value_signal_1)(signed int);
  return_value_signal_1=signal(13, (void (*)(signed int))1);
  if(return_value_signal_1 == (void (*)(signed int))-1)
    result = 0;

  return result;
}

// lw_sock_listen
// file sockunix.c line 142
signed int lw_sock_listen(signed int *sock, signed int port)
{
  signed int result = 0;
  struct sockaddr_in name;
  signed int enable = 1;
  *sock=socket(2, 1, 0);
  unsigned short int tmp_statement_expression_1;
  if(*sock >= 0)
  {
    setsockopt(*sock, 1, 2, (const void *)(char *)&enable, (unsigned int)sizeof(signed int) /*4ul*/ );
    name.sin_family = (unsigned short int)2;
    name.sin_addr.s_addr = (unsigned int)0x00000000;
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)port;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression_1 = __v;
    name.sin_port = tmp_statement_expression_1;
    signed int return_value_bind_3;
    return_value_bind_3=bind(*sock, (struct sockaddr *)&name, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(return_value_bind_3 >= 0)
    {
      signed int return_value_listen_2;
      return_value_listen_2=listen(*sock, 10);
      if(return_value_listen_2 >= 0)
        result = 1;

    }

  }

  return result;
}

// lw_sock_peek
// file sock2gen.h line 72
signed int lw_sock_peek(signed int *sock, signed int len)
{
  signed int result = 0;
  if(*sock >= 0)
    result=lw_sock_peek_ex(sock, len);

  return result;
}

// lw_sock_peek_ex
// file sockgen.h line 63
signed int lw_sock_peek_ex(signed int *sock, signed int len)
{
  signed int result = 0;
  signed int res;
  struct anonymous_14 read;
  struct timeval tv;
  char buffer[1000l];
  signed int sock_copy = *sock;
  if(sock_copy >= 0)
  {
    if(!(len >= 1000))
    {
      do
      {
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_14) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&read)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      (&read)->__fds_bits[(signed long int)(sock_copy / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&read)->__fds_bits[(signed long int)(sock_copy / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock_copy % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      tv.tv_sec = (signed long int)0;
      tv.tv_usec = (signed long int)0;
      res=select(sock_copy + 1, &read, (struct anonymous_14 *)(void *)0, (struct anonymous_14 *)(void *)0, &tv);
      if(res >= 1)
      {
        if(!((read.__fds_bits[(signed long int)(sock_copy / 8)] & (signed long int)(1UL << sock_copy % 8)) == 0l))
        {
          signed long int return_value_recv_1;
          return_value_recv_1=recv(sock_copy, (void *)buffer, (unsigned long int)len, 2);
          if(return_value_recv_1 == (signed long int)len)
            result = 1;

        }

      }

    }

  }

  return result;
}

// lw_sock_recv_buffer
// file sock2gen.h line 76
signed int lw_sock_recv_buffer(signed int *sock, char *buffer, signed int len)
{
  signed int result = 0;
  signed int limit_ticker;
  signed int return_value_get_ticker_1;
  return_value_get_ticker_1=get_ticker();
  limit_ticker = return_value_get_ticker_1 + 15000;
  signed int return_value_get_ticker_2;
  do
  {
    return_value_get_ticker_2=get_ticker();
    if(return_value_get_ticker_2 >= limit_ticker)
      break;

    if(!(result == 0))
      break;

    if(!(*sock >= 0))
      break;

    signed int return_value_lw_sock_peek_ex_4;
    return_value_lw_sock_peek_ex_4=lw_sock_peek_ex(sock, len);
    if(!(return_value_lw_sock_peek_ex_4 == 0))
    {
      signed int return_value_lw_sock_recv_buffer_ex_3;
      return_value_lw_sock_recv_buffer_ex_3=lw_sock_recv_buffer_ex(sock, buffer, len);
      if(!(return_value_lw_sock_recv_buffer_ex_3 == 0))
        result = 1;

    }

  }
  while((_Bool)1);
  return result;
}

// lw_sock_recv_buffer_ex
// file sockgen.h line 67
signed int lw_sock_recv_buffer_ex(signed int *sock, char *buffer, signed int len)
{
  signed int result = 0;
  char trace[1000l];
  signed int res;
  struct anonymous_14 read;
  struct timeval tv;
  signed int sock_copy;
  signed int total_received;
  signed int received;
  memset((void *)buffer, 0, (unsigned long int)len);
  sock_copy = *sock;
  signed int *return_value___errno_location_2;
  if(sock_copy >= 0)
  {
    result = 1;
    if(!(len >= 1000))
    {
      total_received = 0;
      while(!(total_received >= len))
      {
        if(result == 0)
          break;

        sock_copy = *sock;
        if(!(sock_copy >= 0))
          break;

        do
        {
          signed int __d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_14) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&read)->__fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        (&read)->__fds_bits[(signed long int)(sock_copy / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&read)->__fds_bits[(signed long int)(sock_copy / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock_copy % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        tv.tv_sec = (signed long int)8;
        tv.tv_usec = (signed long int)0;
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = 0;
        res=select(sock_copy + 1, &read, (struct anonymous_14 *)(void *)0, (struct anonymous_14 *)(void *)0, &tv);
        if(!(res == -1))
        {
          if(res == 1)
            goto __CPROVER_DUMP_L5;

        }

        else
        {
          return_value___errno_location_2=__errno_location();
          if(!(*return_value___errno_location_2 == 4))
            result = 0;

          goto __CPROVER_DUMP_L10;

        __CPROVER_DUMP_L5:
          ;
          if(!((read.__fds_bits[(signed long int)(sock_copy / 8)] & (signed long int)(1UL << sock_copy % 8)) == 0l))
          {
            signed long int return_value_recv_3;
            return_value_recv_3=recv(sock_copy, (void *)(buffer + (signed long int)total_received), (unsigned long int)(len - total_received < 200 ? len - total_received : 200), 0);
            received = (signed int)return_value_recv_3;
            if(len + -total_received >= received && received >= 1)
              total_received = total_received + received;

            else
              result = 0;
          }

          goto __CPROVER_DUMP_L10;
        }
        result = 0;

      __CPROVER_DUMP_L10:
        ;
      }
      if(!(LW_SOCK_LOG == 0))
      {
        if(!(result == 0))
        {
          __builtin_strncpy(trace, buffer, (unsigned long int)len);
          trace[(signed long int)len] = (char)0;
          log_print_int(sock_copy);
          log_print_str(" < [");
          clean_buffer(trace, len);
          log_print_str(trace);
          log_print_str("]");
          log_println();
          log_flush();
        }

        else
        {
          log_print_int(sock_copy);
          log_print_str(" < timeout!");
          log_println();
        }
      }

    }

    else
    {
      result = 0;
      if(!(LW_SOCK_LOG == 0))
      {
        log_print_int(sock_copy);
        log_print_str(" < message too large!");
        log_println();
      }

    }
  }

  return result;
}

// lw_sock_recv_str
// file sock2gen.h line 74
signed int lw_sock_recv_str(signed int *sock, char *str)
{
  signed int result = 0;
  signed int limit_ticker;
  signed int return_value_get_ticker_1;
  return_value_get_ticker_1=get_ticker();
  limit_ticker = return_value_get_ticker_1 + 15000;
  signed int return_value_get_ticker_2;
  do
  {
    return_value_get_ticker_2=get_ticker();
    if(return_value_get_ticker_2 >= limit_ticker)
      break;

    if(!(result == 0))
      break;

    if(!(*sock >= 0))
      break;

    signed int return_value_lw_sock_recv_str_ex_3;
    return_value_lw_sock_recv_str_ex_3=lw_sock_recv_str_ex(sock, str);
    if(!(return_value_lw_sock_recv_str_ex_3 == 0))
      result = 1;

  }
  while((_Bool)1);
  return result;
}

// lw_sock_recv_str_ex
// file sockgen.h line 65
signed int lw_sock_recv_str_ex(signed int *sock, char *str)
{
  signed int result = 0;
  signed int pos;
  signed int l;
  signed int cr_found;
  char *cr;
  struct anonymous_14 read;
  signed int sock_copy;
  struct timeval tv;
  signed int res;
  str[(signed long int)0] = (char)0;
  sock_copy = *sock;
  signed int *return_value___errno_location_2;
  _Bool tmp_if_expr_3;
  if(sock_copy >= 0)
  {
    result = 1;
    cr_found = 0;
    pos = 0;
    while(cr_found == 0)
    {
      if(pos >= 1000)
        break;

      if(!(result >= 1))
        break;

      sock_copy = *sock;
      if(!(sock_copy >= 0))
        break;

      do
      {
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_14) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&read)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      (&read)->__fds_bits[(signed long int)(sock_copy / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&read)->__fds_bits[(signed long int)(sock_copy / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock_copy % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      tv.tv_sec = (signed long int)8;
      tv.tv_usec = (signed long int)0;
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 0;
      res=select(sock_copy + 1, &read, (struct anonymous_14 *)(void *)0, (struct anonymous_14 *)(void *)0, &tv);
      if(!(res == -1))
      {
        if(res == 1)
          goto __CPROVER_DUMP_L5;

      }

      else
      {
        return_value___errno_location_2=__errno_location();
        if(!(*return_value___errno_location_2 == 4))
          result = 0;

        goto __CPROVER_DUMP_L15;

      __CPROVER_DUMP_L5:
        ;
        if((read.__fds_bits[(signed long int)(sock_copy / 8)] & (signed long int)(1UL << sock_copy % 8)) == 0l)
          result = 1;

        else
        {
          signed long int return_value_recv_5;
          return_value_recv_5=recv(sock_copy, (void *)(str + (signed long int)pos), (unsigned long int)1, 0);
          l = (signed int)return_value_recv_5;
          if(!(l >= 1))
            result = -1;

          else
          {
            pos = pos + l;
            str[(signed long int)pos] = (char)0;
            char *return_value___builtin_strchr_4;
            return_value___builtin_strchr_4=__builtin_strchr(str, 10);
            cr = return_value___builtin_strchr_4;
            if(!(cr == ((char *)NULL)))
            {
              cr_found = 1;
              if(cr - str >= 1l)
                tmp_if_expr_3 = (signed int)*(cr - (signed long int)1) == 13 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_3 = (_Bool)0;
              if(tmp_if_expr_3)
                *(cr - (signed long int)1) = (char)0;

              else
                *cr = (char)0;
            }

            result = 1;
          }
        }
        goto __CPROVER_DUMP_L15;
      }
      result = 0;

    __CPROVER_DUMP_L15:
      ;
    }
    if(!(LW_SOCK_LOG == 0))
    {
      if(!(result == 1))
      {
        if(result == 0)
          goto __CPROVER_DUMP_L18;

        if(result == -1)
          goto __CPROVER_DUMP_L19;

      }

      else
      {
        log_print_int(sock_copy);
        log_print_str(" < \"");
        log_print_str(str);
        log_print_str("\"");
        log_println();
        log_flush();
        goto __CPROVER_DUMP_L21;

      __CPROVER_DUMP_L18:
        ;
        log_print_int(sock_copy);
        log_print_str(" < timeout!");
        log_println();
        goto __CPROVER_DUMP_L21;

      __CPROVER_DUMP_L19:
        ;
        log_print_int(sock_copy);
        log_print_str(" < closed!");
        log_println();
        goto __CPROVER_DUMP_L21;
      }
      log_print_int(sock_copy);
      log_print_str(" < unexpected error!");
      log_println();
    }

  }


__CPROVER_DUMP_L21:
  ;
  return result;
}

// lw_sock_send_buffer
// file sock2gen.h line 75
signed int lw_sock_send_buffer(signed int *sock, char *buffer, signed int len)
{
  signed int result = 0;
  signed int limit_ticker;
  signed int return_value_get_ticker_1;
  return_value_get_ticker_1=get_ticker();
  limit_ticker = return_value_get_ticker_1 + 15000;
  signed int return_value_get_ticker_2;
  do
  {
    return_value_get_ticker_2=get_ticker();
    if(return_value_get_ticker_2 >= limit_ticker)
      break;

    if(!(result == 0))
      break;

    if(!(*sock >= 0))
      break;

    signed int return_value_lw_sock_send_buffer_ex_3;
    return_value_lw_sock_send_buffer_ex_3=lw_sock_send_buffer_ex(sock, buffer, len);
    if(!(return_value_lw_sock_send_buffer_ex_3 == 0))
      result = 1;

  }
  while((_Bool)1);
  return result;
}

// lw_sock_send_buffer_ex
// file sockgen.h line 66
signed int lw_sock_send_buffer_ex(signed int *sock, char *buffer, signed int len)
{
  signed int result = 0;
  char trace[1000l];
  struct anonymous_14 write;
  struct timeval tv;
  signed int sock_copy;
  signed int res;
  signed int total_sent;
  signed int sent;
  sock_copy = *sock;
  signed int *return_value___errno_location_3;
  signed int *return_value___errno_location_2;
  if(sock_copy >= 0)
  {
    result = 1;
    if(!(len >= 1000))
    {
      total_sent = 0;
      while(!(total_sent >= len))
      {
        if(result == 0)
          break;

        sock_copy = *sock;
        if(!(sock_copy >= 0))
          break;

        do
        {
          signed int __d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_14) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&write)->__fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        (&write)->__fds_bits[(signed long int)(sock_copy / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&write)->__fds_bits[(signed long int)(sock_copy / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock_copy % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        tv.tv_sec = (signed long int)8;
        tv.tv_usec = (signed long int)0;
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = 0;
        res=select(sock_copy + 1, (struct anonymous_14 *)(void *)0, &write, (struct anonymous_14 *)(void *)0, &tv);
        if(!(res == -1))
        {
          if(res == 1)
            goto __CPROVER_DUMP_L5;

        }

        else
        {
          return_value___errno_location_3=__errno_location();
          if(!(*return_value___errno_location_3 == 4))
          {
            return_value___errno_location_2=__errno_location();
            if(!(*return_value___errno_location_2 == 105))
              result = 0;

          }

          goto __CPROVER_DUMP_L10;

        __CPROVER_DUMP_L5:
          ;
          if(!((write.__fds_bits[(signed long int)(sock_copy / 8)] & (signed long int)(1UL << sock_copy % 8)) == 0l))
          {
            signed long int return_value_send_4;
            return_value_send_4=send(sock_copy, (const void *)(buffer + (signed long int)total_sent), (unsigned long int)(len - total_sent < 100 ? len - total_sent : 100), 0);
            sent = (signed int)return_value_send_4;
            if(len + -total_sent >= sent && sent >= 1)
              total_sent = total_sent + sent;

            else
              result = 0;
          }

          goto __CPROVER_DUMP_L10;
        }
        result = 0;

      __CPROVER_DUMP_L10:
        ;
      }
      if(!(LW_SOCK_LOG == 0))
      {
        if(!(result == 0))
        {
          __builtin_strncpy(trace, buffer, (unsigned long int)len);
          trace[(signed long int)len] = (char)0;
          log_print_int(sock_copy);
          log_print_str(" > [");
          clean_buffer(trace, len);
          log_print_str(trace);
          log_print_str("]");
          log_println();
          log_flush();
        }

        else
        {
          log_print_int(sock_copy);
          log_print_str(" > timeout!");
          log_println();
        }
      }

    }

    else
    {
      result = 0;
      if(!(LW_SOCK_LOG == 0))
      {
        log_print_int(sock_copy);
        log_print_str(" > message too large!");
        log_println();
      }

    }
  }

  return result;
}

// lw_sock_send_str
// file sock2gen.h line 73
signed int lw_sock_send_str(signed int *sock, char *str)
{
  signed int result = 0;
  signed int limit_ticker;
  signed int return_value_get_ticker_1;
  return_value_get_ticker_1=get_ticker();
  limit_ticker = return_value_get_ticker_1 + 15000;
  signed int return_value_get_ticker_2;
  do
  {
    return_value_get_ticker_2=get_ticker();
    if(return_value_get_ticker_2 >= limit_ticker)
      break;

    if(!(result == 0))
      break;

    if(!(*sock >= 0))
      break;

    signed int return_value_lw_sock_send_str_ex_3;
    return_value_lw_sock_send_str_ex_3=lw_sock_send_str_ex(sock, str);
    if(!(return_value_lw_sock_send_str_ex_3 == 0))
      result = 1;

  }
  while((_Bool)1);
  return result;
}

// lw_sock_send_str_ex
// file sockgen.h line 64
signed int lw_sock_send_str_ex(signed int *sock, char *str)
{
  signed int result = 0;
  signed int len;
  char buffer[1000l];
  signed int sock_copy;
  struct anonymous_14 write;
  struct timeval tv;
  signed int res;
  signed int total_sent;
  signed int sent;
  sock_copy = *sock;
  signed int *return_value___errno_location_4;
  signed int *return_value___errno_location_3;
  if(sock_copy >= 0)
  {
    result = 1;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(str);
    len = (signed int)return_value_strlen_1;
    len = len < 1000 - 3 ? len : 1000 - 3;
    __builtin_strncpy(buffer, str, (unsigned long int)len);
    buffer[(signed long int)len] = (char)13;
    len = len + 1;
    buffer[(signed long int)len] = (char)10;
    len = len + 1;
    buffer[(signed long int)len] = (char)0;
    total_sent = 0;
    while(!(total_sent >= len))
    {
      if(result == 0)
        break;

      sock_copy = *sock;
      if(!(sock_copy >= 0))
        break;

      do
      {
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_14) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&write)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      (&write)->__fds_bits[(signed long int)(sock_copy / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&write)->__fds_bits[(signed long int)(sock_copy / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock_copy % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      tv.tv_sec = (signed long int)8;
      tv.tv_usec = (signed long int)0;
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 0;
      res=select(sock_copy + 1, (struct anonymous_14 *)(void *)0, &write, (struct anonymous_14 *)(void *)0, &tv);
      if(!(res == -1))
      {
        if(res == 1)
          goto __CPROVER_DUMP_L5;

      }

      else
      {
        return_value___errno_location_4=__errno_location();
        if(!(*return_value___errno_location_4 == 4))
        {
          return_value___errno_location_3=__errno_location();
          if(!(*return_value___errno_location_3 == 105))
            result = 0;

        }

        goto __CPROVER_DUMP_L10;

      __CPROVER_DUMP_L5:
        ;
        if(!((write.__fds_bits[(signed long int)(sock_copy / 8)] & (signed long int)(1UL << sock_copy % 8)) == 0l))
        {
          signed long int return_value_send_5;
          return_value_send_5=send(sock_copy, (const void *)(buffer + (signed long int)total_sent), (unsigned long int)(len - total_sent), 0);
          sent = (signed int)return_value_send_5;
          if(len + -total_sent >= sent && sent >= 1)
            total_sent = total_sent + sent;

          else
            result = 0;
        }

        goto __CPROVER_DUMP_L10;
      }
      result = 0;

    __CPROVER_DUMP_L10:
      ;
    }
    if(!(LW_SOCK_LOG == 0))
      switch(result)
      {
        case 1:
        {
          log_print_int(sock_copy);
          log_print_str(" > \"");
          log_print_str(str);
          log_print_str("\"");
          log_println();
          log_flush();
          break;
        }
        case 0:
        {
          log_print_int(sock_copy);
          log_print_str(" > timeout!");
          log_println();
          break;
        }
        default:
        {
          log_print_int(sock_copy);
          log_print_str(" > unexpected error!");
          log_println();
        }
      }

  }

  return result;
}

// lw_teamstartinfo_reset
// file startinf.h line 71
void lw_teamstartinfo_reset(struct anonymous_12 *teamstartinfo)
{
  memset((void *)teamstartinfo, 0, sizeof(struct anonymous_12) /*20ul*/ );
}

// lw_texture_archive_raw
// file texture.h line 71
void * lw_texture_archive_raw(const char *filename)
{
  signed int i;
  signed int w;
  signed int h;
  signed int size = 0;
  struct BITMAP *bmp;
  struct RGB pal[256l];
  char *result = (char *)(void *)0;
  char *temp = (char *)(void *)0;
  bmp=load_bitmap(filename, pal);
  if(!(bmp == ((struct BITMAP *)NULL)))
  {
    w = bmp->w;
    h = bmp->h;
    if(h >= 1 && w >= 1)
    {
      size = (signed int)((unsigned long int)2 * sizeof(signed short int) /*2ul*/  + (unsigned long int)16 + (unsigned long int)(3 * 32) + (unsigned long int)(((w * h + 7) / 8) * 5));
      void *return_value_malloc_1;
      return_value_malloc_1=malloc((unsigned long int)size);
      temp = (char *)return_value_malloc_1;
      if(!(temp == ((char *)NULL)))
      {
        red8col(bmp, pal, 0, 32);
        texture_8to5(bmp, pal, (void *)temp, 0, 32, (char *)filename);
      }

    }

    destroy_bitmap(bmp);
  }

  if(!(temp == ((char *)NULL)))
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)size);
    result = (char *)return_value_malloc_2;
    if(!(result == ((char *)NULL)))
    {
      i = 0;
      for( ; !(i >= size); i = i + 1)
        result[(signed long int)i] = temp[(signed long int)i];
    }

    free((void *)temp);
  }

  return (void *)result;
}

// lw_texture_create_bg
// file texture.h line 72
struct BITMAP * lw_texture_create_bg(signed int num)
{
  struct BITMAP *return_value_create_texture_1;
  return_value_create_texture_1=create_texture(num, 96);
  return return_value_create_texture_1;
}

// lw_texture_create_fg
// file texture.h line 73
struct BITMAP * lw_texture_create_fg(signed int num)
{
  struct BITMAP *return_value_create_texture_1;
  return_value_create_texture_1=create_texture(num, 64);
  return return_value_create_texture_1;
}

// lw_texture_get_system_name
// file texture.h line 74
char * lw_texture_get_system_name(signed int num)
{
  void *raw_texture;
  char *char_ptr;
  raw_texture=get_raw_texture(num);
  static char result[17l];
  memset((void *)result, 0, sizeof(char [17l]) /*17ul*/ );
  if(!(raw_texture == NULL))
  {
    char_ptr = (char *)raw_texture;
    memcpy((void *)result, (const void *)(char_ptr + (signed long int)4), (unsigned long int)16);
  }

  else
  {
    memset((void *)result, 0, sizeof(char [17l]) /*17ul*/ );
    snprintf(result, sizeof(char [17l]) /*17ul*/  - (unsigned long int)1, "Color %d", num);
    result[(signed long int)(sizeof(char [17l]) /*17ul*/  - (unsigned long int)1)] = (char)0;
  }
  result[(signed long int)(sizeof(char [17l]) /*17ul*/  - (unsigned long int)1)] = (char)0;
  return result;
}

// lw_thread_start
// file thrdgen.h line 53
signed int lw_thread_start(void (*func)(void *), void *args)
{
  unsigned long int thread;
  signed int result = 0;
  signed int return_value_pthread_create_2;
  return_value_pthread_create_2=pthread_create(&thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))func, args);
  if(return_value_pthread_create_2 == 0)
  {
    signed int return_value_pthread_detach_1;
    return_value_pthread_detach_1=pthread_detach(thread);
    if(return_value_pthread_detach_1 == 0)
      result = 1;

  }

  return result;
}

// lw_viewport_register_change
// file viewport.h line 78
void lw_viewport_register_change(signed int count)
{
  VIEWPORT_CHANGE_REGISTERED = count;
}

// lw_wwwcli_get_games
// file wwwcli.h line 86
signed int lw_wwwcli_get_games(struct anonymous_15 *buffer, signed int *size)
{
  signed int result = 0;
  char buffer_content[100000l];
  char buffer_url[500l];
  char *pos;
  char *pos_tmp;
  signed int i = 0;
  log_print_str("Getting server list from \"");
  log_print_str(STARTUP_METASERVER);
  log_print_str("\" ");
  memset((void *)&buffer_url, 0, sizeof(char [500l]) /*500ul*/ );
  memset((void *)buffer_url, 0, sizeof(char [500l]) /*500ul*/ );
  snprintf(buffer_url, sizeof(char [500l]) /*500ul*/  - (unsigned long int)1, "%s%s?protocol=%s&game=liquidwar&version=5.6.4", (const void *)STARTUP_METASERVER, (const void *)"list.php3", (const void *)"1.0");
  buffer_url[(signed long int)(sizeof(char [500l]) /*500ul*/  - (unsigned long int)1)] = (char)0;
  signed int return_value_lw_httputil_get_page_5;
  return_value_lw_httputil_get_page_5=lw_httputil_get_page(buffer_content, buffer_url, (signed int)sizeof(char [100000l]) /*100000ul*/ );
  signed int return_value_read_eol_1;
  unsigned long int return_value_strlen_2;
  if(!(return_value_lw_httputil_get_page_5 == 0))
  {
    pos = buffer_content;
    do
    {
      return_value_read_eol_1=read_eol(&pos);
      if(return_value_read_eol_1 == 0)
        break;

    }
    while((_Bool)1);
    while(!(i >= *size))
    {
      return_value_strlen_2=strlen(pos);
      if(!(return_value_strlen_2 >= 1ul))
        break;

      pos_tmp = pos;
      signed int return_value_read_eol_n_4;
      return_value_read_eol_n_4=read_eol_n(&pos_tmp, 20);
      if(!(return_value_read_eol_n_4 == 0))
        pos = pos_tmp;

      else
      {
        signed int return_value_parse_line_3;
        return_value_parse_line_3=parse_line(buffer + (signed long int)i, &pos);
        if(!(return_value_parse_line_3 == 0))
        {
          if(!((buffer + (signed long int)i)->busy_players >= (buffer + (signed long int)i)->max_players))
          {
            i = i + 1;
            log_print_str("+");
          }

          else
            log_print_str("=");
        }

        else
          log_print_str("-");
      }
    }
    result = 1;
  }

  if(result == 1)
    *size = i;

  else
    *size = 0;
  display_success(result);
  if(result == 0)
  {
    log_print_str("Error: ");
    log_println_str(buffer_content);
  }

  return result;
}

// main
// file main.c line 103
signed int main(signed int argc, char **argv)
{
  signed int init_success = 0;
  signed int big_data_success = 0;
  signed int load_dat_success = 0;
  signed int load_custom_success = 0;
  read_command_line(argc, argv);
  signed int return_value_lw_basicopt_process_2;
  return_value_lw_basicopt_process_2=lw_basicopt_process("Liquid War - a unique multiplayer wargame");
  if(!(return_value_lw_basicopt_process_2 == 0))
  {
    init_success=init_all();
    if(!(init_success == 0))
    {
      void *return_value_malloc_big_data_1;
      return_value_malloc_big_data_1=malloc_big_data();
      big_data_success = (signed int)(return_value_malloc_big_data_1 != (void *)0);
      log_println();
      load_dat_success=load_dat();
      log_println();
      load_custom_success=load_custom();
      log_println();
    }

    if(init_success == 0)
      my_exit(1);

    if(big_data_success == 0)
      my_exit(3);

    if(load_dat_success == 0)
      my_exit(4);

    if(load_custom_success == 0)
      my_exit(5);

    order_map();
    check_config_range();
    check_free_memory();
    start_graphic();
    start_water();
    main_menu();
    my_exit(0);
  }

  return 0;
}

// main_info
// file dialog.c line 249
void main_info(struct DIALOG *d, char *str)
{
  color_one_dialog(d);
  d->proc = my_textbox_proc;
  d->dp = (void *)str;
  d->key = 0;
  d->flags = 0;
}

// main_menu
// file menu.h line 67
void main_menu(void)
{
  struct DIALOG d[11l];
  signed int i;
  signed int choix = 4;
  signed int retour = 0;
  memset((void *)d, 0, sizeof(struct DIALOG [11l]) /*792ul*/ );
  display_back_image();
  my_fade_in();
  while(!(retour == -2))
  {
    i = 0;
    for( ; !(i >= 6); i = i + 1)
      standard_button(d + (signed long int)i + (signed long int)4, 0, i, 1, 6);
    quick_buttons(d);
    d[(signed long int)3].flags = 16;
    d[(signed long int)2].flags = 16;
    char *return_value_lw_lang_string_1;
    return_value_lw_lang_string_1=lw_lang_string(6);
    d[(signed long int)4].dp = (void *)return_value_lw_lang_string_1;
    char *return_value_lw_lang_string_2;
    return_value_lw_lang_string_2=lw_lang_string(7);
    d[(signed long int)5].dp = (void *)return_value_lw_lang_string_2;
    char *return_value_lw_lang_string_3;
    return_value_lw_lang_string_3=lw_lang_string(8);
    d[(signed long int)6].dp = (void *)return_value_lw_lang_string_3;
    char *return_value_lw_lang_string_4;
    return_value_lw_lang_string_4=lw_lang_string(9);
    d[(signed long int)7].dp = (void *)return_value_lw_lang_string_4;
    char *return_value_lw_lang_string_5;
    return_value_lw_lang_string_5=lw_lang_string(10);
    d[(signed long int)8].dp = (void *)return_value_lw_lang_string_5;
    char *return_value_lw_lang_string_6;
    return_value_lw_lang_string_6=lw_lang_string(11);
    d[(signed long int)9].dp = (void *)return_value_lw_lang_string_6;
    d[(signed long int)10].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
    choix=my_do_dialog(d, choix);
    if(!(choix == 0) && !(choix == -1))
    {
      if(choix == 1)
        goto __CPROVER_DUMP_L6;

      if(choix == 4)
        goto __CPROVER_DUMP_L7;

      if(choix == 5)
        goto __CPROVER_DUMP_L8;

      if(choix == 6)
        goto __CPROVER_DUMP_L9;

      if(choix == 7)
        goto __CPROVER_DUMP_L10;

      if(choix == 8)
        goto __CPROVER_DUMP_L11;

      if(choix == 9)
        goto __CPROVER_DUMP_L12;

    }

    else
    {
      signed int return_value_confirm_quit_7;
      return_value_confirm_quit_7=confirm_quit();
      if(!(return_value_confirm_quit_7 == 0))
        retour = -2;

      goto __CPROVER_DUMP_L13;

    __CPROVER_DUMP_L6:
      ;
      retour = -3;
      goto __CPROVER_DUMP_L13;

    __CPROVER_DUMP_L7:
      ;
      LW_NETWORK_ON = 0;
      retour=play_sequence();
      goto __CPROVER_DUMP_L13;

    __CPROVER_DUMP_L8:
      ;
      retour=network_game();
      goto __CPROVER_DUMP_L13;

    __CPROVER_DUMP_L9:
      ;
      retour=choose_map();
      goto __CPROVER_DUMP_L13;

    __CPROVER_DUMP_L10:
      ;
      retour=choose_teams();
      goto __CPROVER_DUMP_L13;

    __CPROVER_DUMP_L11:
      ;
      retour=options();
      goto __CPROVER_DUMP_L13;

    __CPROVER_DUMP_L12:
      ;
      retour=lw_about();
    }

  __CPROVER_DUMP_L13:
    ;
    if(retour == -3)
    {
      if(!(LW_NETWORK_ON == 0))
        retour=netplay_sequence();

      else
        retour=play_sequence();
    }

  }
}

// main_message
// file dialog.c line 237
void main_message(struct DIALOG *d, char *str)
{
  standard_big_button(d, 0, 0, 1, 1);
  d->dp = (void *)str;
  d->key = 0;
  d->proc = my_textbox_proc;
  d->flags = 0;
}

// malloc_big_data
// file bigdata.c line 104
void * malloc_big_data(void)
{
  signed int nb_try = 0;
  log_print_str("Allocating ");
  log_print_int(STARTUP_BIG_DATA);
  log_print_str(" Mb");
  log_flush();
  if(!(BIG_DATA_PTR == NULL))
  {
    free(BIG_DATA_PTR);
    BIG_DATA_PTR = (void *)0;
  }

  STARTUP_BIG_DATA = STARTUP_BIG_DATA + 1;
  while(BIG_DATA_PTR == NULL && STARTUP_BIG_DATA >= 2 && (nb_try == 0 || !(STARTUP_AUTO == 0)))
  {
    nb_try = nb_try + 1;
    STARTUP_BIG_DATA = STARTUP_BIG_DATA - 1;
    BIG_DATA_SIZE = STARTUP_BIG_DATA * 1024 * 1024;
    BIG_DATA_PTR=malloc((unsigned long int)BIG_DATA_SIZE);
  }
  if(nb_try >= 2)
  {
    log_print_str("Last try with ");
    log_print_int(STARTUP_BIG_DATA);
    log_print_str(" Mb");
  }

  if(BIG_DATA_PTR == NULL)
    BIG_DATA_SIZE = 0;

  display_success(BIG_DATA_SIZE);
  reset_big_data();
  return BIG_DATA_PTR;
}

// malloc_in_big_data_bottom
// file bigdata.h line 70
void * malloc_in_big_data_bottom(signed int size)
{
  char *ptr;
  signed int bottom;
  signed int top;
  signed int new_offset;
  bottom = BIG_DATA_TABLE[(signed long int)BIG_DATA_BOTTOM];
  top = BIG_DATA_TABLE[(signed long int)BIG_DATA_TOP];
  new_offset = ((bottom + size + 15) / 16) * 16;
  if(!(BIG_DATA_BOTTOM >= BIG_DATA_TOP + -1) && !(new_offset >= top))
  {
    ptr = (char *)BIG_DATA_PTR;
    ptr = ptr + (signed long int)bottom;
    BIG_DATA_BOTTOM = BIG_DATA_BOTTOM + 1;
    BIG_DATA_TABLE[(signed long int)BIG_DATA_BOTTOM] = new_offset;
    memset((void *)ptr, 0, (unsigned long int)size);
  }

  else
    ptr = (char *)(void *)0;
  return (void *)ptr;
}

// malloc_in_big_data_top
// file bigdata.c line 177
void * malloc_in_big_data_top(signed int size)
{
  char *ptr;
  signed int bottom;
  signed int top;
  signed int new_offset;
  bottom = BIG_DATA_TABLE[(signed long int)BIG_DATA_BOTTOM];
  top = BIG_DATA_TABLE[(signed long int)BIG_DATA_TOP];
  new_offset = ((top - size) / 16) * 16;
  if(new_offset >= bottom && !(BIG_DATA_BOTTOM >= BIG_DATA_TOP + -1))
  {
    ptr = (char *)BIG_DATA_PTR;
    ptr = ptr + (signed long int)new_offset;
    BIG_DATA_TOP = BIG_DATA_TOP - 1;
    BIG_DATA_TABLE[(signed long int)BIG_DATA_TOP] = new_offset;
    memset((void *)ptr, 0, (unsigned long int)size);
  }

  else
    ptr = (char *)(void *)0;
  return (void *)ptr;
}

// menu_real_coord
// file dialog.h line 103
void menu_real_coord(struct DIALOG *d)
{
  d->x=menu_real_x(d->x);
  d->y=menu_real_y(d->y);
  d->w=menu_real_x(d->w);
  d->h=menu_real_y(d->h);
}

// menu_real_x
// file dialog.c line 79
signed int menu_real_x(signed int x)
{
  signed int tmp_if_expr_1;
  if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
    tmp_if_expr_1 = gfx_driver->w;

  else
    tmp_if_expr_1 = 0;
  return (x * tmp_if_expr_1) / 320;
}

// menu_real_y
// file dialog.c line 86
signed int menu_real_y(signed int y)
{
  signed int tmp_if_expr_1;
  if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
    tmp_if_expr_1 = gfx_driver->h;

  else
    tmp_if_expr_1 = 0;
  return (y * tmp_if_expr_1) / 240;
}

// mesher_to_mesh
// file mesh.c line 240
static struct anonymous_0 * mesher_to_mesh(struct anonymous *mesher, struct BITMAP *map, signed int *size, signed int *w, signed int *h)
{
  struct anonymous_0 *result;
  struct anonymous *temp;
  signed int mesher_size;
  signed int i;
  signed int j;
  signed int k;
  *w = map->w;
  *h = map->h;
  mesher_size = *h * *w;
  *size = 0;
  i = 0;
  for( ; !(i >= mesher_size); i = i + 1)
    if(!((mesher + (signed long int)i)->used == 0))
      *size = *size + 1;

  void *return_value_malloc_in_big_data_bottom_1;
  return_value_malloc_in_big_data_bottom_1=malloc_in_big_data_bottom((signed int)((unsigned long int)*size * sizeof(struct anonymous_0) /*152ul*/ ));
  result = (struct anonymous_0 *)return_value_malloc_in_big_data_bottom_1;
  if(!(result == ((struct anonymous_0 *)NULL)))
  {
    j = 0;
    i = 0;
    for( ; !(i >= mesher_size); i = i + 1)
      if(!((mesher + (signed long int)i)->used == 0))
      {
        (result + (signed long int)j)->x = (signed short int)(i % *w);
        (result + (signed long int)j)->y = (signed short int)(i / *w);
        (result + (signed long int)j)->side.decal_for_dir = 0;
        (result + (signed long int)j)->side.size = (signed int)(mesher + (signed long int)i)->size;
        k = 0;
        for( ; !(k >= 12); k = k + 1)
          (result + (signed long int)j)->link[(signed long int)k] = (mesher + (signed long int)i)->link[(signed long int)k];
        (mesher + (signed long int)i)->corres = j;
        j = j + 1;
      }

    j = 0;
    for( ; !(j >= *size); j = j + 1)
    {
      k = 0;
      for( ; !(k >= 12); k = k + 1)
      {
        temp = (struct anonymous *)(result + (signed long int)j)->link[(signed long int)k];
        if(!(temp == ((struct anonymous *)NULL)))
          (result + (signed long int)j)->link[(signed long int)k] = (void *)(result + (signed long int)temp->corres);

      }
    }
  }

  return result;
}

// message_int
// file message.c line 146
void message_int(signed int val)
{
  static char buffer[34l];
  memset((void *)buffer, 0, sizeof(char [34l]) /*34ul*/ );
  snprintf(buffer, sizeof(char [34l]) /*34ul*/  - (unsigned long int)1, "%d", val);
  buffer[(signed long int)(sizeof(char [34l]) /*34ul*/  - (unsigned long int)1)] = (char)0;
  message_str(buffer);
}

// message_str
// file message.h line 60
void message_str(char *str)
{
  signed int i;
  for( ; MESSAGE_NB >= 12; MESSAGE_NB = MESSAGE_NB - 1)
  {
    i = 0;
    for( ; !(i >= MESSAGE_NB + -1); i = i + 1)
    {
      memset((void *)MESSAGE[(signed long int)i], 0, sizeof(char [65l]) /*65ul*/ );
      __builtin_strncpy(MESSAGE[(signed long int)i], MESSAGE[(signed long int)(i + 1)], sizeof(char [65l]) /*65ul*/  - (unsigned long int)1);
      MESSAGE[(signed long int)i][(signed long int)(sizeof(char [65l]) /*65ul*/  - (unsigned long int)1)] = (char)0;
      MESSAGE_TICKER[(signed long int)i] = MESSAGE_TICKER[(signed long int)(i + 1)] - MESSAGE_DELAY;
    }
  }
  MESSAGE_DISPLAYED[(signed long int)MESSAGE_NB] = 0;
  memset((void *)MESSAGE[(signed long int)MESSAGE_NB], 0, sizeof(char [65l]) /*65ul*/ );
  __builtin_strncpy(MESSAGE[(signed long int)MESSAGE_NB], str, sizeof(char [65l]) /*65ul*/  - (unsigned long int)1);
  MESSAGE[(signed long int)MESSAGE_NB][(signed long int)(sizeof(char [65l]) /*65ul*/  - (unsigned long int)1)] = (char)0;
  MESSAGE_NB = MESSAGE_NB + 1;
}

// message_str_int
// file message.h line 62
void message_str_int(char *str, signed int val)
{
  static char buffer[98l];
  memset((void *)buffer, 0, sizeof(char [98l]) /*98ul*/ );
  snprintf(buffer, sizeof(char [98l]) /*98ul*/  - (unsigned long int)1, "%s%d", str, val);
  buffer[(signed long int)(sizeof(char [98l]) /*98ul*/  - (unsigned long int)1)] = (char)0;
  message_str(buffer);
}

// move_all_cursors
// file move.h line 71
void move_all_cursors(void)
{
  signed int i;
  signed int j;
  signed int checksum;
  lw_mouse_update_control();
  my_poll_joystick();
  j = 0;
  for( ; LW_CONFIG_CURRENT_RULES.cursor_increase_speed >= j; j = j + 1)
  {
    i = 0;
    for( ; !(i >= 6); i = i + 1)
      if(!(CURRENT_CURSOR[(signed long int)i].active == 0))
      {
        if(CURRENT_CURSOR[(signed long int)i].from_network == 0)
        {
          if(CURRENT_CURSOR[(signed long int)i].control_type == 2)
            update_key_cpu_cursor(i);

          else
            update_key_local_cursor(i);
        }

      }

    if(!(LW_NETWORK_ON == 0))
    {
      checksum=lw_checksum_calc(CURRENT_ARMY, CURRENT_ARMY_SIZE);
      signed int return_value_lw_keyexch_flush_1;
      return_value_lw_keyexch_flush_1=lw_keyexch_flush(CURRENT_CURSOR, (unsigned int)checksum);
      if(return_value_lw_keyexch_flush_1 == 0)
        LW_NETWORK_ERROR_DETECTED = 1;

    }

    i = 0;
    for( ; !(i >= 6); i = i + 1)
      if(!(CURRENT_CURSOR[(signed long int)i].active == 0))
        move_cursor(i);

  }
}

// move_cursor
// file move.c line 206
static void move_cursor(signed int indice)
{
  signed int dir = 0;
  signed int up;
  signed int down;
  signed int right;
  signed int left;
  signed int horiz = 0;
  signed int vert = 0;
  signed int moved = 0;
  signed int team;
  char key_state;
  struct anonymous_0 *mesh;
  team = CURRENT_CURSOR[(signed long int)indice].team;
  mesh = (CURRENT_AREA + (signed long int)(CURRENT_CURSOR[(signed long int)indice].y * CURRENT_AREA_W + CURRENT_CURSOR[(signed long int)indice].x))->mesh;
  mesh->info[(signed long int)team].update.time = -1;
  key_state = (char)CURRENT_CURSOR[(signed long int)indice].key_state;
  up = (signed int)key_state & 1;
  right = (signed int)key_state & 2;
  down = (signed int)key_state & 4;
  left = (signed int)key_state & 8;
  if(left == 0 && right == 0 || !(left == 0) && !(right == 0))
    horiz = 0;

  if(left == 0 && !(right == 0))
    horiz = 1;

  if(right == 0 && !(left == 0))
    horiz = -1;

  if(down == 0 && up == 0 || !(down == 0) && !(up == 0))
    vert = 0;

  if(down == 0 && !(up == 0))
    vert = -1;

  if(up == 0 && !(down == 0))
    vert = 1;

  if(horiz == 0 && vert == 0)
    dir = 0;

  if(horiz == 0 && vert == -1)
    dir = 1;

  if(horiz == 1 && vert == -1)
    dir = 2;

  if(horiz == 1 && vert == 0)
    dir = 3;

  if(horiz == 1 && vert == 1)
    dir = 4;

  if(horiz == 0 && vert == 1)
    dir = 5;

  if(horiz == -1 && vert == 1)
    dir = 6;

  if(horiz == -1 && vert == 0)
    dir = 7;

  if(horiz == -1 && vert == -1)
    dir = 8;

  if(!(dir == 0))
  {
    moved=move_if_free(&CURRENT_CURSOR[(signed long int)indice].x, &CURRENT_CURSOR[(signed long int)indice].y, dir);
    if(moved == 0)
      moved=move_if_free(&CURRENT_CURSOR[(signed long int)indice].x, &CURRENT_CURSOR[(signed long int)indice].y, dir - 1);

    if(moved == 0)
      moved=move_if_free(&CURRENT_CURSOR[(signed long int)indice].x, &CURRENT_CURSOR[(signed long int)indice].y, dir + 1);

    if(moved == 0)
    {
      signed int xa1;
      signed int ya1;
      signed int xb1;
      signed int yb1;
      signed int xa2;
      signed int ya2;
      signed int xb2;
      signed int yb2;
      signed int i = 0;
      xb1 = CURRENT_CURSOR[(signed long int)indice].x;
      xa1 = xb1;
      yb1 = CURRENT_CURSOR[(signed long int)indice].y;
      ya1 = yb1;
      while(moved == 0 && !(i >= 10))
      {
        signed int return_value_move_if_free_2;
        return_value_move_if_free_2=move_if_free(&xa1, &ya1, dir - 2);
        if(!(return_value_move_if_free_2 == 0))
        {
          xa2 = xa1;
          ya2 = ya1;
          signed int return_value_move_if_free_1;
          return_value_move_if_free_1=move_if_free(&xa2, &ya2, dir - 1);
          if(!(return_value_move_if_free_1 == 0))
            moved=move_if_free(&CURRENT_CURSOR[(signed long int)indice].x, &CURRENT_CURSOR[(signed long int)indice].y, dir - 2);

        }

        signed int return_value_move_if_free_4;
        return_value_move_if_free_4=move_if_free(&xb1, &yb1, dir + 2);
        if(!(return_value_move_if_free_4 == 0))
        {
          xb2 = xb1;
          yb2 = yb1;
          signed int return_value_move_if_free_3;
          return_value_move_if_free_3=move_if_free(&xb2, &yb2, dir + 1);
          if(!(return_value_move_if_free_3 == 0))
            moved=move_if_free(&CURRENT_CURSOR[(signed long int)indice].x, &CURRENT_CURSOR[(signed long int)indice].y, dir + 2);

        }

        i = i + 1;
      }
    }

  }

  if(GLOBAL_CLOCK % 1 == 0 || !(moved == 0))
    CURRENT_CURSOR[(signed long int)indice].val = CURRENT_CURSOR[(signed long int)indice].val - 1;

  mesh = (CURRENT_AREA + (signed long int)(CURRENT_CURSOR[(signed long int)indice].y * CURRENT_AREA_W + CURRENT_CURSOR[(signed long int)indice].x))->mesh;
  mesh->info[(signed long int)team].update.cursor.x = (signed short int)CURRENT_CURSOR[(signed long int)indice].x;
  mesh->info[(signed long int)team].update.cursor.y = (signed short int)CURRENT_CURSOR[(signed long int)indice].y;
}

// move_fighters
// file fighter.c line 300
void move_fighters(void)
{
  signed int attack[6l];
  signed int defense[6l];
  signed int new_health[6l];
  signed int i;
  signed int dir;
  signed int team;
  signed int coef;
  struct anonymous_21 *f;
  struct anonymous_22 *p;
  struct anonymous_22 *p0;
  struct anonymous_22 *p1;
  struct anonymous_22 *p2;
  struct anonymous_22 *p3;
  struct anonymous_22 *p4;
  signed int *move_offset;
  signed int *move_x;
  signed int *move_y;
  signed int sens;
  signed int start;
  signed int table;
  signed int cpu_influence[6l] = { 0, 0, 0, 0, 0, 0 };
  signed int temp = 0;
  sens = 0;
  i = 0;
  for( ; !(i >= 6); i = i + 1)
    if(CURRENT_CURSOR[(signed long int)i].control_type == 2)
    {
      if(!(CURRENT_CURSOR[(signed long int)i].active == 0))
        cpu_influence[(signed long int)CURRENT_CURSOR[(signed long int)i].team] = LW_CONFIG_CURRENT_RULES.cpu_advantage;

    }

  i = 0;
  for( ; !(i >= PLAYING_TEAMS); i = i + 1)
  {
    coef = ACTIVE_FIGHTERS[(signed long int)i] * PLAYING_TEAMS - CURRENT_ARMY_SIZE;
    coef = coef * 256;
    coef = coef / CURRENT_ARMY_SIZE;
    if(coef >= 257)
      coef = 256;

    coef = coef * (LW_CONFIG_CURRENT_RULES.number_influence - 8) * (LW_CONFIG_CURRENT_RULES.number_influence - 8);
    coef = coef / 64;
    if(!(LW_CONFIG_CURRENT_RULES.number_influence >= 8))
      coef = -coef;

    if(!(coef >= 0))
      coef = coef / 2;

    coef = coef + 256;
    signed int return_value_fsqrt_1;
    return_value_fsqrt_1=fsqrt_link1(1 << LW_CONFIG_CURRENT_RULES.fighter_attack + cpu_influence[(signed long int)i]);
    signed int return_value_fsqrt_2;
    return_value_fsqrt_2=fsqrt_link1(return_value_fsqrt_1);
    attack[(signed long int)i] = (coef * return_value_fsqrt_2) / (256 * 8);
    if(attack[(signed long int)i] >= 16384)
      attack[(signed long int)i] = 16384 - 1;

    if(!(attack[(signed long int)i] >= 1))
      attack[(signed long int)i] = 1;

    signed int return_value_fsqrt_3;
    return_value_fsqrt_3=fsqrt_link1(1 << LW_CONFIG_CURRENT_RULES.fighter_defense + cpu_influence[(signed long int)i]);
    signed int return_value_fsqrt_4;
    return_value_fsqrt_4=fsqrt_link1(return_value_fsqrt_3);
    defense[(signed long int)i] = (coef * return_value_fsqrt_4) / (256 * 256);
    if(defense[(signed long int)i] >= 16384)
      defense[(signed long int)i] = 16384 - 1;

    if(!(defense[(signed long int)i] >= 1))
      defense[(signed long int)i] = 1;

    signed int return_value_fsqrt_5;
    return_value_fsqrt_5=fsqrt_link1(1 << LW_CONFIG_CURRENT_RULES.fighter_new_health + cpu_influence[(signed long int)i]);
    signed int return_value_fsqrt_6;
    return_value_fsqrt_6=fsqrt_link1(return_value_fsqrt_5);
    new_health[(signed long int)i] = (coef * return_value_fsqrt_6) / (256 * 4);
    if(new_health[(signed long int)i] >= 16384)
      new_health[(signed long int)i] = 16384 - 1;

    if(!(new_health[(signed long int)i] >= 1))
      new_health[(signed long int)i] = 1;

    ACTIVE_FIGHTERS[(signed long int)i] = 0;
  }
  start = (GLOBAL_CLOCK / 6) % 12;
  table = (GLOBAL_CLOCK / 3) % 2;
  f = CURRENT_ARMY;
  temp = 0;
  i = 0;
  signed int tmp_post_7;
  signed int tmp_post_8;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_10;
  for( ; !(i >= CURRENT_ARMY_SIZE); i = i + 1)
  {
    team = (signed int)f->team;
    ACTIVE_FIGHTERS[(signed long int)team] = ACTIVE_FIGHTERS[(signed long int)team] + 1;
    start = start < 12 - 1 ? start + 1 : 0;
    p = CURRENT_AREA + (signed long int)((signed int)f->y * CURRENT_AREA_W + (signed int)f->x);
    if(p->mesh->info[(signed long int)team].update.time >= 0)
    {
      tmp_post_7 = sens;
      sens = sens + 1;
      p->mesh->info[(signed long int)team].state.dir=get_close_dir(p->mesh, f, team, tmp_post_7 % 2, start);
    }

    else
      if(!(-p->mesh->info[(signed long int)team].update.time >= GLOBAL_CLOCK))
      {
        tmp_post_8 = sens;
        sens = sens + 1;
        p->mesh->info[(signed long int)team].state.dir=get_main_dir(p->mesh, team, tmp_post_8 % 2, start);
        p->mesh->info[(signed long int)team].update.time = -GLOBAL_CLOCK;
      }

    dir = (signed int)p->mesh->info[(signed long int)team].state.dir;
    move_offset = FIGHTER_MOVE_OFFSET[(signed long int)table][(signed long int)dir];
    move_x = FIGHTER_MOVE_X[(signed long int)table][(signed long int)dir];
    move_y = FIGHTER_MOVE_Y[(signed long int)table][(signed long int)dir];
    p0 = p + (signed long int)move_offset[(signed long int)0];
    if(!(p0->mesh == ((struct anonymous_0 *)NULL)))
      tmp_if_expr_19 = !(p0->fighter != ((struct anonymous_21 *)NULL)) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_19 = (_Bool)0;
    if(tmp_if_expr_19)
    {
      erase_fighter(f);
      p0->fighter = f;
      p->fighter = (struct anonymous_21 *)(void *)0;
      f->x = f->x + (signed short int)move_x[(signed long int)0];
      f->y = f->y + (signed short int)move_y[(signed long int)0];
      disp_fighter(f);
    }

    else
    {
      p1 = p + (signed long int)move_offset[(signed long int)1];
      if(!(p1->mesh == ((struct anonymous_0 *)NULL)))
        tmp_if_expr_18 = !(p1->fighter != ((struct anonymous_21 *)NULL)) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_18 = (_Bool)0;
      if(tmp_if_expr_18)
      {
        erase_fighter(f);
        p1->fighter = f;
        p->fighter = (struct anonymous_21 *)(void *)0;
        f->x = f->x + (signed short int)move_x[(signed long int)1];
        f->y = f->y + (signed short int)move_y[(signed long int)1];
        disp_fighter(f);
      }

      else
      {
        p2 = p + (signed long int)move_offset[(signed long int)2];
        if(!(p2->mesh == ((struct anonymous_0 *)NULL)))
          tmp_if_expr_17 = !(p2->fighter != ((struct anonymous_21 *)NULL)) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_17 = (_Bool)0;
        if(tmp_if_expr_17)
        {
          erase_fighter(f);
          p2->fighter = f;
          p->fighter = (struct anonymous_21 *)(void *)0;
          f->x = f->x + (signed short int)move_x[(signed long int)2];
          f->y = f->y + (signed short int)move_y[(signed long int)2];
          disp_fighter(f);
        }

        else
        {
          p3 = p + (signed long int)move_offset[(signed long int)3];
          if(!(p3->mesh == ((struct anonymous_0 *)NULL)))
            tmp_if_expr_16 = !(p3->fighter != ((struct anonymous_21 *)NULL)) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_16 = (_Bool)0;
          if(tmp_if_expr_16)
          {
            erase_fighter(f);
            p3->fighter = f;
            p->fighter = (struct anonymous_21 *)(void *)0;
            f->x = f->x + (signed short int)move_x[(signed long int)3];
            f->y = f->y + (signed short int)move_y[(signed long int)3];
            disp_fighter(f);
          }

          else
          {
            p4 = p + (signed long int)move_offset[(signed long int)4];
            if(!(p4->mesh == ((struct anonymous_0 *)NULL)))
              tmp_if_expr_15 = !(p4->fighter != ((struct anonymous_21 *)NULL)) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_15 = (_Bool)0;
            if(tmp_if_expr_15)
            {
              erase_fighter(f);
              p4->fighter = f;
              p->fighter = (struct anonymous_21 *)(void *)0;
              f->x = f->x + (signed short int)move_x[(signed long int)4];
              f->y = f->y + (signed short int)move_y[(signed long int)4];
              disp_fighter(f);
            }

            else
            {
              if(!(p0->mesh == ((struct anonymous_0 *)NULL)))
                tmp_if_expr_13 = p0->fighter != ((struct anonymous_21 *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_13 = (_Bool)0;
              if(tmp_if_expr_13)
                tmp_if_expr_14 = (signed int)p0->fighter->team != team ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_14 = (_Bool)0;
              if(tmp_if_expr_14)
              {
                p0->fighter->health = p0->fighter->health - (signed short int)attack[(signed long int)team];
                if(!((signed int)p0->fighter->health >= 0))
                {
                  for( ; !((signed int)p0->fighter->health >= 0); p0->fighter->health = p0->fighter->health + (signed short int)new_health[(signed long int)team])
                    ;
                  p0->fighter->team = (char)team;
                }

                disp_fighter(p0->fighter);
              }

              else
              {
                if(!(p1->mesh == ((struct anonymous_0 *)NULL)))
                  tmp_if_expr_11 = p1->fighter != ((struct anonymous_21 *)NULL) ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_11 = (_Bool)0;
                if(tmp_if_expr_11)
                  tmp_if_expr_12 = (signed int)p1->fighter->team != team ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_12 = (_Bool)0;
                if(tmp_if_expr_12)
                {
                  p1->fighter->health = p1->fighter->health - (signed short int)(attack[(signed long int)team] >> 4);
                  if(!((signed int)p1->fighter->health >= 0))
                  {
                    for( ; !((signed int)p1->fighter->health >= 0); p1->fighter->health = p1->fighter->health + (signed short int)new_health[(signed long int)team])
                      ;
                    p1->fighter->team = (char)team;
                  }

                  disp_fighter(p1->fighter);
                }

                else
                {
                  if(!(p2->mesh == ((struct anonymous_0 *)NULL)))
                    tmp_if_expr_9 = p2->fighter != ((struct anonymous_21 *)NULL) ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_9 = (_Bool)0;
                  if(tmp_if_expr_9)
                    tmp_if_expr_10 = (signed int)p2->fighter->team != team ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_10 = (_Bool)0;
                  if(tmp_if_expr_10)
                  {
                    p2->fighter->health = p2->fighter->health - (signed short int)(attack[(signed long int)team] >> 4);
                    if(!((signed int)p2->fighter->health >= 0))
                    {
                      for( ; !((signed int)p2->fighter->health >= 0); p2->fighter->health = p2->fighter->health + (signed short int)new_health[(signed long int)team])
                        ;
                      p2->fighter->team = (char)team;
                    }

                    disp_fighter(p2->fighter);
                  }

                  else
                    if(!(p0->mesh == ((struct anonymous_0 *)NULL)))
                    {
                      if(!(p0->fighter == ((struct anonymous_21 *)NULL)))
                      {
                        if((signed int)p0->fighter->team == team)
                        {
                          p0->fighter->health = p0->fighter->health + (signed short int)defense[(signed long int)team];
                          if((signed int)p0->fighter->health >= 16384)
                            p0->fighter->health = (signed short int)(16384 - 1);

                          disp_fighter(p0->fighter);
                        }

                      }

                    }

                }
              }
            }
          }
        }
      }
    }
    f = f + 1l;
  }
}

// move_if_free
// file move.c line 87
static signed int move_if_free(signed int *x, signed int *y, signed int dir)
{
  signed int moved = 0;
  for( ; dir >= 9; dir = dir - 8)
    ;
  for( ; !(dir >= 1); dir = dir + 8)
    ;
  switch(dir)
  {
    case 1:
    {
      if(!((CURRENT_AREA + (signed long int)((*y + -1) * CURRENT_AREA_W + *x))->mesh == ((struct anonymous_0 *)NULL)))
      {
        *y = *y - 1;
        moved = 1;
      }

      break;
    }
    case 2:
    {
      if(!((CURRENT_AREA + (signed long int)((*y + -1) * CURRENT_AREA_W + 1 + *x))->mesh == ((struct anonymous_0 *)NULL)))
      {
        *y = *y - 1;
        *x = *x + 1;
        moved = 1;
      }

      break;
    }
    case 3:
    {
      if(!((CURRENT_AREA + (signed long int)(*y * CURRENT_AREA_W + 1 + *x))->mesh == ((struct anonymous_0 *)NULL)))
      {
        *x = *x + 1;
        moved = 1;
      }

      break;
    }
    case 4:
    {
      if(!((CURRENT_AREA + (signed long int)((1 + *y) * CURRENT_AREA_W + 1 + *x))->mesh == ((struct anonymous_0 *)NULL)))
      {
        *x = *x + 1;
        *y = *y + 1;
        moved = 1;
      }

      break;
    }
    case 5:
    {
      if(!((CURRENT_AREA + (signed long int)((1 + *y) * CURRENT_AREA_W + *x))->mesh == ((struct anonymous_0 *)NULL)))
      {
        *y = *y + 1;
        moved = 1;
      }

      break;
    }
    case 6:
    {
      if(!((CURRENT_AREA + (signed long int)((1 + *y) * CURRENT_AREA_W + *x + -1))->mesh == ((struct anonymous_0 *)NULL)))
      {
        *y = *y + 1;
        *x = *x - 1;
        moved = 1;
      }

      break;
    }
    case 7:
    {
      if(!((CURRENT_AREA + (signed long int)(*y * CURRENT_AREA_W + *x + -1))->mesh == ((struct anonymous_0 *)NULL)))
      {
        *x = *x - 1;
        moved = 1;
      }

      break;
    }
    case 8:
      if(!((CURRENT_AREA + (signed long int)((*y + -1) * CURRENT_AREA_W + *x + -1))->mesh == ((struct anonymous_0 *)NULL)))
      {
        *x = *x - 1;
        *y = *y - 1;
        moved = 1;
      }

  }
  return moved;
}

// my_button_proc
// file alleg2.h line 69
signed int my_button_proc(signed int msg, struct DIALOG *d, signed int c)
{
  struct BITMAP *gui_bmp;
  signed int state1;
  signed int state2;
  signed int black;
  signed int swap;
  signed int g;
  c = c;
  gui_bmp=gui_get_screen();
  signed int tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_text_height_3;
  _Bool tmp_if_expr_4;
  signed int return_value;
  switch(msg)
  {
    case 3:
    {
      if(!((2 & d->flags) == 0))
      {
        g = 1;
        state1 = d->bg;
        if(!((32 & d->flags) == 0))
          tmp_if_expr_1 = gui_mg_color;

        else
          tmp_if_expr_1 = d->fg;
        state2 = tmp_if_expr_1;
      }

      else
      {
        g = 0;
        if(!((32 & d->flags) == 0))
          tmp_if_expr_2 = gui_mg_color;

        else
          tmp_if_expr_2 = d->fg;
        state1 = tmp_if_expr_2;
        state2 = d->bg;
      }
      rectfill(gui_bmp, d->x + 1 + g, d->y + 1 + g, ((d->x + d->w) - 3) + g, ((d->y + d->h) - 3) + g, state2);
      rect(gui_bmp, d->x + g, d->y + g, ((d->x + d->w) - 2) + g, ((d->y + d->h) - 2) + g, state1);
      return_value_text_height_3=text_height(font);
      gui_textout_ex(gui_bmp, (const char *)d->dp, d->x + d->w / 2 + g, ((d->y + d->h / 2) - return_value_text_height_3 / 2) + g, -1, -1, -1);
      if(!((2 & d->flags) == 0))
      {
        vline(gui_bmp, d->x, d->y, (d->y + d->h) - 2, d->bg);
        hline(gui_bmp, d->x, d->y, (d->x + d->w) - 2, d->bg);
      }

      else
      {
        black=makecol(0, 0, 0);
        vline(gui_bmp, (d->x + d->w) - 1, d->y + 1, (d->y + d->h) - 2, black);
        hline(gui_bmp, d->x + 1, (d->y + d->h) - 1, (d->x + d->w) - 1, black);
      }
      if(!((4 & d->flags) == 0))
      {
        if((2 & d->flags) == 0)
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = !((d->flags & 1) != 0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_4)
          my_dotted_rect(d->x + 1 + g, d->y + 1 + g, ((d->x + d->w) - 3) + g, ((d->y + d->h) - 3) + g, state1, state2);

      }

      goto __CPROVER_DUMP_L29;
    }
    case 10:
      return 8;
    case 6:
    {
      if(!((1 & d->flags) == 0))
        return 1;

      d->flags = d->flags ^ 2;
      object_message(d, 3, 0);
      goto __CPROVER_DUMP_L29;
    }
    case 4:
    {
      state1 = d->flags & 2;
      if(!((1 & d->flags) == 0))
        swap = 0;

      else
        swap = state1;
      return_value=gui_mouse_b();
    }
    default:
    {

    __CPROVER_DUMP_L29:
      ;
      return 0;
    }
  }
}

// my_create_bitmap
// file alleg2.c line 1647
struct BITMAP * my_create_bitmap(signed int w, signed int h)
{
  struct BITMAP *bmp;
  bmp=create_bitmap(w, h);
  if(bmp == ((struct BITMAP *)NULL))
    my_exit(2);

  return bmp;
}

// my_ctext_proc
// file alleg2.c line 644
signed int my_ctext_proc(signed int msg, struct DIALOG *d, signed int c)
{
  c = c;
  if(msg == 3)
  {
    struct FONT *oldfont = font;
    if(!(d->dp2 == NULL))
      font = (struct FONT *)d->dp2;

    struct BITMAP *return_value_gui_get_screen_1;
    return_value_gui_get_screen_1=gui_get_screen();
    gui_textout_ex(return_value_gui_get_screen_1, (const char *)d->dp, d->x + d->w / 2, d->y, -1, d->bg, -1);
    font = oldfont;
  }

  return 0;
}

// my_do_dialog
// file dialog.h line 117
signed int my_do_dialog(struct DIALOG *d, signed int f)
{
  signed int result;
  display_back_image();
  result=my_do_dialog_no_clear(d, f);
  return result;
}

// my_do_dialog_no_clear
// file dialog.c line 273
signed int my_do_dialog_no_clear(struct DIALOG *d, signed int f)
{
  signed int result;
  void *player;
  struct DIALOG_PLAYER *return_value_my_init_dialog_1;
  return_value_my_init_dialog_1=my_init_dialog(d, f);
  player = (void *)return_value_my_init_dialog_1;
  signed int return_value_my_update_dialog_2;
  do
  {
    return_value_my_update_dialog_2=my_update_dialog((struct DIALOG_PLAYER *)player);
    if(return_value_my_update_dialog_2 == 0)
      break;

  }
  while((_Bool)1);
  result=shutdown_dialog((struct DIALOG_PLAYER *)player);
  play_click();
  return result;
}

// my_dotted_rect
// file alleg2.c line 95
static void my_dotted_rect(signed int x1, signed int y1, signed int x2, signed int y2, signed int fg, signed int bg)
{
  struct BITMAP *gui_bmp;
  gui_bmp=gui_get_screen();
  signed int x = (x1 + y1 & 1) != 0 ? 1 : 0;
  signed int c = x1;
  for( ; x2 >= c; c = c + 1)
    putpixel(gui_bmp, c, y1, (c + y1 & 1) == x ? fg : bg);
  c = x1;
  for( ; x2 >= c; c = c + 1)
    putpixel(gui_bmp, c, y2, (c + y2 & 1) == x ? fg : bg);
  c = y1 + 1;
  for( ; !(c >= y2); c = c + 1)
  {
    putpixel(gui_bmp, x1, c, (c + x1 & 1) == x ? fg : bg);
    putpixel(gui_bmp, x2, c, (c + x2 & 1) == x ? fg : bg);
  }
}

// my_draw_listbox
// file alleg2.c line 1378
static void my_draw_listbox(struct DIALOG *d)
{
  struct BITMAP *gui_bmp;
  gui_bmp=gui_get_screen();
  signed int height;
  signed int listsize;
  signed int i;
  signed int len;
  signed int bar;
  signed int x;
  signed int y;
  signed int w;
  signed int fg_color;
  signed int fg;
  signed int bg;
  char *sel = (char *)d->dp2;
  char s[1024l];
  ((char * (*)(signed int, signed int *))d->dp)(-1, &listsize);
  signed int return_value_text_height_1;
  return_value_text_height_1=text_height(font);
  height = (d->h - 4) / return_value_text_height_1;
  bar = (signed int)(listsize > height);
  signed int tmp_if_expr_2;
  if(!(bar == 0))
    tmp_if_expr_2 = d->w - 15;

  else
    tmp_if_expr_2 = d->w - 3;
  w = tmp_if_expr_2;
  signed int tmp_if_expr_3;
  if(!((32 & d->flags) == 0))
    tmp_if_expr_3 = gui_mg_color;

  else
    tmp_if_expr_3 = d->fg;
  fg_color = tmp_if_expr_3;
  i = 0;
  _Bool tmp_if_expr_4;
  signed int tmp_if_expr_8;
  signed int return_value_text_height_10;
  signed int return_value_text_height_11;
  if(!(i >= height))
  {
    if(!(d->d2 + i >= listsize))
    {
      if(!(sel == ((char *)NULL)))
      {
        if(!(sel[(signed long int)(d->d2 + i)] == 0))
          tmp_if_expr_4 = d->d2 + i == d->d1 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
        {
          fg = d->bg;
          bg = fg_color;
        }

        else
          if(!(sel[(signed long int)(d->d2 + i)] == 0))
          {
            fg = d->bg;
            bg = gui_mg_color;
          }

          else
          {
            fg = fg_color;
            bg = d->bg;
          }
      }

      else
        if(d->d2 + i == d->d1)
        {
          fg = d->bg;
          bg = fg_color;
        }

        else
        {
          fg = fg_color;
          bg = d->bg;
        }
      char *return_value;
      return_value=((char * (*)(signed int, signed int *))d->dp)(i + d->d2, (signed int *)(void *)0);
      ustrzcpy(s, (signed int)sizeof(char [1024l]) /*1024ul*/ , return_value);
      x = d->x + 2;
      signed int return_value_text_height_5;
      return_value_text_height_5=text_height(font);
      y = d->y + 2 + i * return_value_text_height_5;
      signed int return_value_text_height_6;
      return_value_text_height_6=text_height(font);
      rectfill(gui_bmp, x, y, x + 7, (y + return_value_text_height_6) - 1, bg);
      x = x + 8;
      len=ustrlen(s);
      signed int return_value_text_length_7;
      return_value_text_length_7=text_length(font, s);
      if(d->w + -1 + -(bar == 0 ? 10 : 22) >= 2)
        tmp_if_expr_8 = (d->w - 1) - (bar != 0 ? 22 : 10);

      else
        tmp_if_expr_8 = 1;
      if(return_value_text_length_7 >= tmp_if_expr_8)
      {
        len = len - 1;
        usetat(s, len, 0);
      }

      textout_ex(gui_bmp, font, s, x, y, -1, bg);
      signed int return_value_text_length_9;
      return_value_text_length_9=text_length(font, s);
      x = x + return_value_text_length_9;
      if(d->x + w >= x)
      {
        return_value_text_height_10=text_height(font);
        rectfill(gui_bmp, x, y, d->x + w, (y + return_value_text_height_10) - 1, bg);
      }

      if(d->d2 + i == d->d1)
      {
        return_value_text_height_11=text_height(font);
        my_dotted_rect(d->x + 1, y, (d->x + d->w) - (bar != 0 ? 12 : 0), (y + return_value_text_height_11) - 1, d->fg, d->bg);
      }

    }

    else
    {
      signed int return_value_text_height_12;
      return_value_text_height_12=text_height(font);
      signed int return_value_text_height_13;
      return_value_text_height_13=text_height(font);
      rectfill(gui_bmp, d->x + 2, d->y + 2 + i * return_value_text_height_12, d->x + w, d->y + 1 + (i + 1) * return_value_text_height_13, d->bg);
    }
    i = i + 1;
  }

  signed int return_value_text_height_15;
  return_value_text_height_15=text_height(font);
  signed int return_value_text_height_14;
  if(d->h + d->y + -3 >= return_value_text_height_15 * i + 2 + d->y)
  {
    return_value_text_height_14=text_height(font);
    rectfill(gui_bmp, d->x + 2, d->y + 2 + i * return_value_text_height_14, d->x + w, (d->y + d->h) - 3, d->bg);
  }

  _draw_scrollable_frame(d, listsize, d->d2, height, fg_color, d->bg);
}

// my_draw_textbox
// file alleg2.c line 118
static void my_draw_textbox(char *thetext, signed int *listsize, signed int draw, signed int offset, signed int wword, signed int tabsize, signed int x, signed int y, signed int w, signed int h, signed int disabled, signed int fore, signed int deselect, signed int disable)
{
  struct BITMAP *gui_bmp;
  gui_bmp=gui_get_screen();
  signed int fg = fore;
  signed int y1 = y + 4;
  signed int x1;
  signed int len;
  signed int ww = w - 6;
  char s[16l];
  char text[16l];
  char space[16l];
  char *printed = text;
  char *scanned = text;
  char *oldscan = text;
  char *ignore = (char *)(void *)0;
  char *tmp;
  char *ptmp;
  signed int width;
  signed int line = 0;
  signed int i = 0;
  signed int noignore;
  signed int return_value;
  return_value=usetc(s, 46);
  usetc(s + (signed long int)return_value, 0);
  signed int return_value_1;
  return_value_1=usetc(text, 32);
  usetc(text + (signed long int)return_value_1, 0);
  signed int return_value_2;
  return_value_2=usetc(space, 32);
  usetc(space + (signed long int)return_value_2, 0);
  if(!(thetext == ((char *)NULL)))
  {
    printed = thetext;
    scanned = thetext;
  }

  if(!(draw == 0))
    rectfill(gui_bmp, x + 2, y + 2, (x + w) - 3, y1 - 1, deselect);

  if(!(disabled == 0))
    fg = disable;

  signed int return_value_text_length_1;
  signed int return_value_13;
  signed int return_value_text_height_8;
  signed int return_value_text_height_6;
  {
    width = 0;
    signed int return_value_3;
    return_value_3=ugetc(scanned);
    if(!(return_value_3 == 0))
    {
      signed int return_value_5;
      return_value_5=ugetc(scanned);
      if(return_value_5 == 10)
      {
        signed int return_value_4;
        return_value_4=uwidth(scanned);
        scanned = scanned + (signed long int)return_value_4;
      }

      signed int return_value_6;
      return_value_6=ugetc(scanned);
      signed int return_value_7;
      return_value_7=usetc(s, return_value_6);
      usetc(s + (signed long int)return_value_7, 0);
      len=text_length(font, s);
      signed int return_value_8;
      return_value_8=ugetc(s);
      if(return_value_8 == 9)
      {
        return_value_text_length_1=text_length(font, space);
        len = tabsize * return_value_text_length_1;
      }

      if(len + width >= ww)
      {
        if(!(wword == 0))
        {
          oldscan = scanned;
          noignore = 0;
          signed int return_value_9;
          return_value_9=ugetc(scanned);
          signed int return_value_uisspace_2;
          return_value_uisspace_2=uisspace(return_value_9);
          if(return_value_uisspace_2 == 0)
          {
            if(scanned == printed)
            {
              ptmp = scanned;
              tmp = ptmp;
              if(!(ptmp == oldscan))
              {
                ptmp = tmp;
                signed int return_value_10;
                return_value_10=uwidth(tmp);
                tmp = tmp + (signed long int)return_value_10;
              }

              scanned = ptmp;
              noignore = -1;
            }

            else
            {
              ptmp = printed;
              tmp = ptmp;
              if(!(tmp >= scanned))
              {
                ptmp = tmp;
                signed int return_value_11;
                return_value_11=uwidth(tmp);
                tmp = tmp + (signed long int)return_value_11;
              }

              scanned = ptmp;
            }
          }

          if(noignore == 0)
          {
            ignore = scanned;
            signed int return_value_12;
            return_value_12=uwidth(scanned);
            scanned = scanned + (signed long int)return_value_12;
          }

          else
            ignore = (char *)(void *)0;
          signed int return_value_14;
          return_value_14=ugetc(scanned);
          if(return_value_14 == 10)
          {
            return_value_13=uwidth(scanned);
            scanned = scanned + (signed long int)return_value_13;
          }

        }

      }

      else
      {
        signed int return_value_15;
        return_value_15=uwidth(scanned);
        scanned = scanned + (signed long int)return_value_15;
        width = width + len;
      }
    }

    if(line >= offset && !(draw == 0))
    {
      return_value_text_height_8=text_height(font);
      if(line == 0 || !(return_value_text_height_8 + y1 >= h + y + -3))
      {
        x1 = x + 4;
        signed int return_value_text_height_3;
        return_value_text_height_3=text_height(font);
        rectfill(gui_bmp, x + 2, y1, x1 - 1, y1 + return_value_text_height_3, deselect);
        if(!(printed == scanned))
        {
          signed int return_value_16;
          return_value_16=ugetc(printed);
          if(return_value_16 == 10 || return_value_16 == 13)
          {
            i = 0;
            if(!(i >= tabsize))
            {
              signed int return_value_17;
              return_value_17=usetc(s, 32);
              usetc(s + (signed long int)return_value_17, 0);
              textout_ex(gui_bmp, font, s, x1, y1, -1, deselect);
              signed int return_value_text_length_4;
              return_value_text_length_4=text_length(font, s);
              x1 = x1 + return_value_text_length_4;
              i = i + 1;
            }

          }

          if(!(printed == ignore))
          {
            signed int return_value_18;
            return_value_18=ugetc(printed);
            signed int return_value_19;
            return_value_19=usetc(s, return_value_18);
            usetc(s + (signed long int)return_value_19, 0);
            textout_ex(gui_bmp, font, s, x1, y1, -1, deselect);
            signed int return_value_text_length_5;
            return_value_text_length_5=text_length(font, s);
            x1 = x1 + return_value_text_length_5;
          }

          signed int return_value_20;
          return_value_20=uwidth(printed);
          printed = printed + (signed long int)return_value_20;
        }

        if(w + x + -3 >= x1)
        {
          return_value_text_height_6=text_height(font);
          rectfill(gui_bmp, x1, y1, (x + w) - 3, (y1 + return_value_text_height_6) - 1, deselect);
        }

        signed int return_value_text_height_7;
        return_value_text_height_7=text_height(font);
        y1 = y1 + return_value_text_height_7;
      }

    }

    printed = scanned;
    line = line + 1;
    signed int return_value_21;
    return_value_21=ugetc(printed);
    if(return_value_21 == 0)
    {
      if(!(draw == 0))
        rectfill(gui_bmp, x + 1, y1, (x + w) - 3, (y + h) - 1, deselect);

      *listsize = line;
    }

  }
}

// my_edit_proc
// file alleg2.c line 956
signed int my_edit_proc(signed int msg, struct DIALOG *d, signed int c)
{
  struct BITMAP *gui_bmp;
  signed int last_was_space;
  signed int new_pos;
  signed int i;
  signed int k;
  signed int f;
  signed int l;
  signed int p;
  signed int w;
  signed int x;
  signed int fg;
  signed int b;
  signed int scroll;
  char buf[16l];
  char *s;
  char *t;
  gui_bmp=gui_get_screen();
  s = (char *)d->dp;
  l=ustrlen(s);
  if(!(l >= d->d2))
    d->d2 = l;

  if(d->d2 == l)
  {
    signed int return_value;
    return_value=usetc(buf, 32);
    usetc(buf + (signed long int)return_value, 0);
    x=text_length(font, buf);
  }

  else
    x = 0;
  b = 0;
  p = d->d2;
  if(p >= 0)
  {
    signed int return_value_ugetat_1;
    return_value_ugetat_1=ugetat(s, p);
    signed int return_value_1;
    return_value_1=usetc(buf, return_value_ugetat_1);
    usetc(buf + (signed long int)return_value_1, 0);
    signed int return_value_text_length_2;
    return_value_text_length_2=text_length(font, buf);
    x = x + return_value_text_length_2;
    b = b + 1;
    if(d->w >= x)
      p = p - 1;

  }

  if(d->w >= x)
  {
    b = l;
    scroll = 0;
  }

  else
  {
    b = b - 1;
    scroll = -1;
  }
  signed int tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  signed int tmp_if_expr_5;
  signed int return_value_text_height_6;
  _Bool tmp_if_expr_13;
  signed int return_value_uisspace_12;
  signed int return_value_5;
  switch(msg)
  {
    case 1:
    {
      d->d2 = l;
      goto __CPROVER_DUMP_L59;
    }
    case 3:
    {
      if(!((32 & d->flags) == 0))
        tmp_if_expr_3 = gui_mg_color;

      else
        tmp_if_expr_3 = d->fg;
      fg = tmp_if_expr_3;
      x = 0;
      if(!(scroll == 0))
      {
        p = (d->d2 - b) + 1;
        b = d->d2;
      }

      else
        p = 0;
      if(b >= p)
      {
        f=ugetat(s, p);
        signed int return_value_2;
        return_value_2=usetc(buf, f != 0 ? f : 32);
        usetc(buf + (signed long int)return_value_2, 0);
        w=text_length(font, buf);
        if(d->w >= w + x)
        {
          if(p == d->d2)
            tmp_if_expr_4 = (d->flags & 4) != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          f = (signed int)tmp_if_expr_4;
          if(!(f == 0))
            tmp_if_expr_5 = d->fg;

          else
            tmp_if_expr_5 = d->bg;
          textout_ex(gui_bmp, font, buf, d->x + x, d->y, -1, tmp_if_expr_5);
          x = x + w;
          p = p + 1;
        }

      }

      if(!(x >= d->w))
      {
        return_value_text_height_6=text_height(font);
        rectfill(gui_bmp, d->x + x, d->y, (d->x + d->w) - 1, (d->y + return_value_text_height_6) - 1, d->bg);
      }

      goto __CPROVER_DUMP_L59;
    }
    case 4:
    {
      x = d->x;
      if(!(scroll == 0))
      {
        p = (d->d2 - b) + 1;
        b = d->d2;
      }

      else
        p = 0;
      if(!(p >= b))
      {
        signed int return_value_ugetat_7;
        return_value_ugetat_7=ugetat(s, p);
        signed int return_value_3;
        return_value_3=usetc(buf, return_value_ugetat_7);
        usetc(buf + (signed long int)return_value_3, 0);
        signed int return_value_text_length_8;
        return_value_text_length_8=text_length(font, buf);
        x = x + return_value_text_length_8;
        signed int return_value_4;
        return_value_4=gui_mouse_x();
        if(return_value_4 >= x)
          p = p + 1;

      }

      d->d2 = 0 > p ? (p > l ? p : (0 > l ? l : 0)) : (p > l ? (l > 0 ? l : 0) : p);
      object_message(d, 3, 0);
      goto __CPROVER_DUMP_L59;
    }
    case 10:

    case 12:

    case 6:
      return 8;    static signed int ignore_next_uchar = 0;
    case 7:
    {
      ignore_next_uchar = 0;
      if(c >> 8 == 82)
      {
        if(d->d2 >= 1)
        {
          if(!((2 & key_shifts) == 0))
          {
            last_was_space = -1;
            new_pos = 0;
            t = s;
            i = 0;
            if(!(i >= d->d2))
            {
              k=ugetx(&t);
              signed int return_value_uisspace_9;
              return_value_uisspace_9=uisspace(k);
              if(!(return_value_uisspace_9 == 0))
                last_was_space = -1;

              else
                if(!(last_was_space == 0))
                {
                  last_was_space = 0;
                  new_pos = i;
                }

              i = i + 1;
            }

            d->d2 = new_pos;
          }

          else
            d->d2 = d->d2 - 1;
        }

      }

      else
        if(c >> 8 == 83)
        {
          if(!(d->d2 >= l))
          {
            if(!((2 & key_shifts) == 0))
            {
              signed int return_value_uoffset_10;
              return_value_uoffset_10=uoffset(s, d->d2);
              t = s + (signed long int)return_value_uoffset_10;
              k=ugetx(&t);
              signed int return_value_uisspace_11;
              return_value_uisspace_11=uisspace(k);
              if(!(return_value_uisspace_11 == 0))
              {
                d->d2 = d->d2 + 1;
                k=ugetx(&t);
              }

              if(!(k == 0))
              {
                return_value_uisspace_12=uisspace(k);
                tmp_if_expr_13 = !(return_value_uisspace_12 != 0) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_13 = (_Bool)0;
              if(tmp_if_expr_13)
              {
                d->d2 = d->d2 + 1;
                k=ugetx(&t);
              }

            }

            else
              d->d2 = d->d2 + 1;
          }

        }

        else
          if(c >> 8 == 78)
            d->d2 = 0;

          else
            if(c >> 8 == 79)
              d->d2 = l;

            else
              if(c >> 8 == 77)
              {
                if(!(d->d2 >= l))
                  uremove(s, d->d2);

              }

              else
                if(c >> 8 == 63)
                {
                  if(d->d2 >= 1)
                  {
                    d->d2 = d->d2 - 1;
                    uremove(s, d->d2);
                  }

                }

                else
                  if(c >> 8 == 67)
                  {
                    if(!((1 & d->flags) == 0))
                    {
                      object_message(d, 3, 0);
                      return 1;
                    }

                    else
                      return 0;
                  }

                  else
                    if(c >> 8 == 64)
                    {
                      ignore_next_uchar = -1;
                      return 0;
                    }

                    else
                      goto __CPROVER_DUMP_L59;
      object_message(d, 3, 0);
      return 16;
    }
    case 8:
      if(c >= 32 && !(c >= 128))
      {
        return_value_5=uisok(c);
        if(!(return_value_5 == 0))
        {
          if(ignore_next_uchar == 0)
          {
            if(!(l >= d->d1))
            {
              uinsert(s, d->d2, c);
              d->d2 = d->d2 + 1;
              object_message(d, 3, 0);
            }

            return 16;
          }

        }

      }

    default:
    {

    __CPROVER_DUMP_L59:
      ;
      return 0;
    }
  }
}

// my_exit
// file exit.h line 76
void my_exit(signed int code)
{
  exit_all();
  if(code == 0)
  {
    disp_base_message();
    log_println();
    disp_ok_message();
  }

  else
  {
    log_println();
    log_flush();
    switch(code)
    {
      case 1:
      {
        disp_init_fail_message();
        break;
      }
      case 2:
      {
        disp_mem_trouble_message();
        break;
      }
      case 3:
      {
        disp_big_data_message();
        break;
      }
      case 4:
      {
        disp_load_fail_message();
        break;
      }
      case 5:
      {
        disp_custom_fail_message();
        break;
      }
      case 6:
        disp_graphics_fail_message();
    }
    log_println();
    log_println();
    log_println();
    disp_base_message();
    log_println();
    disp_error_message();
  }
  log_exit();
  exit(code);
}

// my_exit_close_button
// file exit.c line 266
void my_exit_close_button(void)
{
  LW_EXIT_FORCE_SHUTDOWN = 1;
}

// my_exit_poll
// file exit.h line 75
void my_exit_poll()
{
  _Bool tmp_if_expr_1;
  if(!(LW_EXIT_FORCE_SHUTDOWN == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = key[(signed long int)56] != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    my_exit(0);

}

// my_fade_in
// file palette.h line 91
void my_fade_in(void)
{
  struct RGB pal[256l];
  change_palette_brightness(GLOBAL_PALETTE, pal);
  fade_in(pal, 48);
  lw_mouse_update_show_hide();
}

// my_fade_out
// file palette.h line 90
void my_fade_out(void)
{
  fade_out(48);
}

// my_handle_listbox_click
// file alleg2.c line 1297
static void my_handle_listbox_click(struct DIALOG *d)
{
  char *sel = (char *)d->dp2;
  signed int listsize;
  signed int height;
  signed int i;
  signed int j;
  ((char * (*)(signed int, signed int *))d->dp)(-1, &listsize);
  signed int tmp_if_expr_17;
  signed int return_value_1;
  signed int return_value_text_height_3;
  signed int return_value_text_height_4;
  signed int tmp_if_expr_9;
  signed int return_value_2;
  signed int return_value_text_height_5;
  signed int return_value_text_height_6;
  signed int tmp_if_expr_8;
  signed int return_value_text_height_7;
  signed int return_value_3;
  signed int return_value_text_height_10;
  signed int return_value_text_height_11;
  signed int tmp_if_expr_16;
  signed int return_value_text_height_12;
  signed int tmp_if_expr_14;
  signed int return_value_text_height_13;
  signed int return_value_4;
  signed int return_value_text_height_15;
  signed int return_value_5;
  _Bool tmp_if_expr_20;
  signed int tmp_if_expr_18;
  signed int tmp_if_expr_19;
  signed int return_value_text_height_21;
  signed int tmp_if_expr_28;
  signed int return_value_text_height_22;
  signed int tmp_if_expr_24;
  signed int return_value_text_height_23;
  signed int return_value_text_height_25;
  signed int tmp_if_expr_27;
  signed int return_value_text_height_26;
  if(!(listsize == 0))
  {
    signed int return_value_text_height_1;
    return_value_text_height_1=text_height(font);
    height = (d->h - 4) / return_value_text_height_1;
    signed int return_value;
    return_value=gui_mouse_y();
    signed int return_value_text_height_2;
    return_value_text_height_2=text_height(font);
    if(!((return_value + -d->y + -2) / return_value_text_height_2 >= 0))
    {
      return_value_1=gui_mouse_y();
      return_value_text_height_3=text_height(font);
      return_value_text_height_4=text_height(font);
      if(!((d->h + -4) / return_value_text_height_4 + -1 >= (return_value_1 + -d->y + -2) / return_value_text_height_3))
      {
        return_value_2=gui_mouse_y();
        return_value_text_height_5=text_height(font);
        tmp_if_expr_9 = ((return_value_2 - d->y) - 2) / return_value_text_height_5;
      }

      else
      {
        return_value_text_height_6=text_height(font);
        if(!((d->h + -4) / return_value_text_height_6 + -1 >= 0))
        {
          return_value_text_height_7=text_height(font);
          tmp_if_expr_8 = (d->h - 4) / return_value_text_height_7 - 1;
        }

        else
          tmp_if_expr_8 = 0;
        tmp_if_expr_9 = tmp_if_expr_8;
      }
      tmp_if_expr_17 = tmp_if_expr_9;
    }

    else
    {
      return_value_3=gui_mouse_y();
      return_value_text_height_10=text_height(font);
      return_value_text_height_11=text_height(font);
      if(!((d->h + -4) / return_value_text_height_11 + -1 >= (return_value_3 + -d->y + -2) / return_value_text_height_10))
      {
        return_value_text_height_12=text_height(font);
        if((d->h + -4) / return_value_text_height_12 + -1 >= 1)
        {
          return_value_text_height_13=text_height(font);
          tmp_if_expr_14 = (d->h - 4) / return_value_text_height_13 - 1;
        }

        else
          tmp_if_expr_14 = 0;
        tmp_if_expr_16 = tmp_if_expr_14;
      }

      else
      {
        return_value_4=gui_mouse_y();
        return_value_text_height_15=text_height(font);
        tmp_if_expr_16 = ((return_value_4 - d->y) - 2) / return_value_text_height_15;
      }
      tmp_if_expr_17 = tmp_if_expr_16;
    }
    i = tmp_if_expr_17;
    i = i + d->d2;
    if(!(i >= d->d2))
      i = d->d2;

    else
    {
      if(!(d->d2 + height + -1 >= i))
        i = (d->d2 + height) - 1;

      if(i >= listsize)
        i = listsize - 1;

    }
    signed int return_value_6;
    return_value_6=gui_mouse_y();
    if(d->y >= return_value_6)
      i = i - 1 > 0 ? i - 1 : 0;

    else
    {
      return_value_5=gui_mouse_y();
      if(return_value_5 >= d->h + d->y + -1)
        i = i + 1 < listsize - 1 ? i + 1 : listsize - 1;

    }
    if(!(i == d->d1))
    {
      if(!(sel == ((char *)NULL)))
      {
        if(!((3 & key_shifts) == 0))
        {
          if(!((1 & key_shifts) == 0))
            tmp_if_expr_20 = (_Bool)1;

          else
            tmp_if_expr_20 = (d->flags & 128) != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_20)
          {
            if(!(i >= d->d1))
              tmp_if_expr_18 = i;

            else
              tmp_if_expr_18 = d->d1;
            j = tmp_if_expr_18;
            if(!(d->d1 >= i))
              tmp_if_expr_19 = i;

            else
              tmp_if_expr_19 = d->d1;
            if(tmp_if_expr_19 >= j)
            {
              sel[(signed long int)j] = (char)-1;
              j = j + 1;
            }

          }

          else
            sel[(signed long int)i] = (char)!(sel[(signed long int)i] != 0);
        }

        else
          sel[(signed long int)i] = (char)-1;
      }

      d->d1 = i;
      i = d->d2;
      my_handle_scrollable_scroll(d, listsize, &d->d1, &d->d2);
      d->flags = d->flags | 64;
      if(!(i == d->d2))
      {
        return_value_text_height_21=text_height(font);
        if(!(16 * return_value_text_height_21 + -d->h + -1 >= 10))
        {
          return_value_text_height_22=text_height(font);
          if(16 * return_value_text_height_22 + -d->h + -1 >= 101)
          {
            return_value_text_height_23=text_height(font);
            tmp_if_expr_24 = (return_value_text_height_23 * 16 - d->h) - 1;
          }

          else
            tmp_if_expr_24 = 10 > 100 ? 100 : 10;
          tmp_if_expr_28 = tmp_if_expr_24;
        }

        else
        {
          return_value_text_height_25=text_height(font);
          if(16 * return_value_text_height_25 + -d->h + -1 >= 101)
            tmp_if_expr_27 = 100 > 10 ? 100 : 10;

          else
          {
            return_value_text_height_26=text_height(font);
            tmp_if_expr_27 = (return_value_text_height_26 * 16 - d->h) - 1;
          }
          tmp_if_expr_28 = tmp_if_expr_27;
        }
        rest_callback((unsigned int)tmp_if_expr_28, my_idle_cb);
      }

    }

    else
      if((128 & d->flags) == 0)
      {
        if(!(sel == ((char *)NULL)))
        {
          if(!((2 & key_shifts) == 0))
            sel[(signed long int)i] = (char)!(sel[(signed long int)i] != 0);

          else
            sel[(signed long int)i] = (char)-1;
          d->flags = d->flags | 64;
        }

      }

  }

}

// my_handle_scrollable_scroll
// file alleg2.c line 1245
static void my_handle_scrollable_scroll(struct DIALOG *d, signed int listsize, signed int *index, signed int *offset)
{
  signed int height;
  signed int return_value_text_height_1;
  return_value_text_height_1=text_height(font);
  height = (d->h - 4) / return_value_text_height_1;
  if(!(listsize >= 1))
  {
    *offset = 0;
    *index = *offset;
  }

  else
  {
    if(!(*index >= 0))
      *index = 0;

    else
      if(*index >= listsize)
        *index = listsize - 1;

    for( ; *offset >= 1; *offset = *offset - 1)
      if(listsize >= *offset + height)
        break;

    if(*offset >= *index)
    {
      if(!(*index >= 0))
        *offset = 0;

      else
        *offset = *index;
    }

    else
      for( ; !(*offset + height + -1 >= *index); *offset = *offset + 1)
        ;
  }
}

// my_handle_scrollable_scroll_click
// file alleg2.c line 1181
static void my_handle_scrollable_scroll_click(struct DIALOG *d, signed int listsize, signed int *offset, signed int height)
{
  signed int xx;
  signed int yy;
  signed int hh = d->h - 5;
  signed int return_value;
  return_value=gui_mouse_b();
  _Bool tmp_if_expr_1;
  signed int return_value_6;
  if(!(return_value == 0))
  {
    signed int i = (hh * height + listsize / 2) / listsize;
    signed int len = (hh * *offset + listsize / 2) / listsize + 2;
    signed int return_value_5;
    return_value_5=gui_mouse_y();
    if(return_value_5 >= d->y + len)
    {
      return_value_6=gui_mouse_y();
      tmp_if_expr_1 = return_value_6 <= d->y + len + i ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
    {
      signed int return_value_1;
      return_value_1=gui_mouse_y();
      xx = (return_value_1 - len) + 2;
      signed int return_value_2;
      return_value_2=gui_mouse_b();
      if(!(return_value_2 == 0))
      {
        signed int return_value_3;
        return_value_3=gui_mouse_y();
        yy = (listsize * (return_value_3 - xx) + hh / 2) / hh;
        if(!(listsize + -height >= yy))
          yy = listsize - height;

        if(!(yy >= 0))
          yy = 0;

        if(!(yy == *offset))
        {
          *offset = yy;
          object_message(d, 3, 0);
        }

        broadcast_dialog_message(15, 0);
      }

    }

    else
    {
      signed int return_value_4;
      return_value_4=gui_mouse_y();
      if(d->y + len >= return_value_4)
        yy = *offset - height;

      else
        yy = *offset + height;
      if(!(listsize + -height >= yy))
        yy = listsize - height;

      if(!(yy >= 0))
        yy = 0;

      if(!(yy == *offset))
      {
        *offset = yy;
        object_message(d, 3, 0);
      }

    }
    broadcast_dialog_message(15, 0);
  }

}

// my_idle_cb
// file alleg2.c line 1286
static void my_idle_cb(void)
{
  broadcast_dialog_message(15, 0);
}

// my_init_dialog
// file dialog.h line 115
struct DIALOG_PLAYER * my_init_dialog(struct DIALOG *d, signed int f)
{
  struct DIALOG_PLAYER *dp;
  lw_keyboard_reset_hack();
  dp=init_dialog(d, f);
  return dp;
}

// my_initialise_joystick
// file joystick.h line 98
signed int my_initialise_joystick(void)
{
  signed int result;
  if(!(STARTUP_JOYSTICK_ON == 0))
  {
    signed int type = -1;
    switch(CONFIG_JOYSTICK_ON)
    {
      case 1:
      {
        type = -1;
        break;
      }
      case 2:
      {
        type = -1;
        break;
      }
      case 3:
        type = -1;
    }
    result=install_joystick(type);
  }

  else
    result = -1;
  if(num_joysticks >= 1)
  {
    if(joy[0l].num_sticks >= 1)
    {
      if(joy[0l].stick[0l].num_axis >= 2)
      {
        JOY1_MIN_X = joy[(signed long int)0].stick[(signed long int)0].axis[(signed long int)0].pos;
        JOY1_MID_X = joy[(signed long int)0].stick[(signed long int)0].axis[(signed long int)0].pos;
        JOY1_MAX_X = joy[(signed long int)0].stick[(signed long int)0].axis[(signed long int)0].pos;
        JOY1_MIN_Y = joy[(signed long int)0].stick[(signed long int)0].axis[(signed long int)1].pos;
        JOY1_MID_Y = joy[(signed long int)0].stick[(signed long int)0].axis[(signed long int)1].pos;
        JOY1_MAX_Y = joy[(signed long int)0].stick[(signed long int)0].axis[(signed long int)1].pos;
      }

    }

  }

  if(num_joysticks >= 2)
  {
    if(joy[1l].num_sticks >= 1)
    {
      if(joy[1l].stick[0l].num_axis >= 2)
      {
        JOY2_MIN_X = joy[(signed long int)1].stick[(signed long int)0].axis[(signed long int)0].pos;
        JOY2_MID_X = joy[(signed long int)1].stick[(signed long int)0].axis[(signed long int)0].pos;
        JOY2_MAX_X = joy[(signed long int)1].stick[(signed long int)0].axis[(signed long int)0].pos;
        JOY2_MIN_Y = joy[(signed long int)1].stick[(signed long int)0].axis[(signed long int)1].pos;
        JOY2_MID_Y = joy[(signed long int)1].stick[(signed long int)0].axis[(signed long int)1].pos;
        JOY2_MAX_Y = joy[(signed long int)1].stick[(signed long int)0].axis[(signed long int)1].pos;
      }

    }

  }

  my_poll_joystick();
  return result;
}

// my_list_proc
// file alleg2.c line 1478
signed int my_list_proc(signed int msg, struct DIALOG *d, signed int c)
{
  signed int listsize;
  signed int i;
  signed int bottom;
  signed int height;
  signed int bar;
  signed int orig;
  char *sel = (char *)d->dp2;
  signed int redraw = 0;
  switch(msg)
  {
    case 1:
      ((char * (*)(signed int, signed int *))d->dp)(-1, &listsize);
    case 3:
    {
      my_draw_listbox(d);
      goto __CPROVER_DUMP_L59;
    }
    case 4:
      ((char * (*)(signed int, signed int *))d->dp)(-1, &listsize);
    case 5:
      ((char * (*)(signed int, signed int *))d->dp)(-1, &listsize);
    case 17:
      ((char * (*)(signed int, signed int *))d->dp)(-1, &listsize);
    case 6:
      ((char * (*)(signed int, signed int *))d->dp)(-1, &listsize);
    case 10:
      return 8;
    case 7:
      ((char * (*)(signed int, signed int *))d->dp)(-1, &listsize);
    default:
    {

    __CPROVER_DUMP_L59:
      ;
      return 0;
    }
  }
}

// my_play_sample
// file sound.c line 153
static void my_play_sample(struct SAMPLE *s, signed int vol)
{
  if(vol >= 1)
    play_sample(s, SOUND_VOLUME_VALUES[(signed long int)(vol - 1)], 128, 1000, 0);

}

// my_poll_joystick
// file joystick.h line 99
void my_poll_joystick(void)
{
  signed int tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_5;
  signed int tmp_if_expr_6;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_8;
  if(!(CONFIG_JOYSTICK_ON == 0) && !(STARTUP_JOYSTICK_ON == 0))
  {
    poll_joystick();
    if(num_joysticks >= 1)
    {
      if(joy[0l].num_sticks >= 1)
      {
        if(joy[0l].stick[0l].num_axis >= 2)
        {
          if(!(joy[0l].stick[0l].axis[0l].pos >= JOY1_MIN_X))
            tmp_if_expr_1 = joy[(signed long int)0].stick[(signed long int)0].axis[(signed long int)0].pos;

          else
            tmp_if_expr_1 = JOY1_MIN_X;
          JOY1_MIN_X = tmp_if_expr_1;
          if(!(JOY1_MAX_X >= joy[0l].stick[0l].axis[0l].pos))
            tmp_if_expr_2 = joy[(signed long int)0].stick[(signed long int)0].axis[(signed long int)0].pos;

          else
            tmp_if_expr_2 = JOY1_MAX_X;
          JOY1_MAX_X = tmp_if_expr_2;
          JOY1_MID_X = (JOY1_MIN_X + JOY1_MAX_X) / 2;
          if(!(joy[0l].stick[0l].axis[1l].pos >= JOY1_MIN_Y))
            tmp_if_expr_3 = joy[(signed long int)0].stick[(signed long int)0].axis[(signed long int)1].pos;

          else
            tmp_if_expr_3 = JOY1_MIN_Y;
          JOY1_MIN_Y = tmp_if_expr_3;
          if(!(JOY1_MAX_Y >= joy[0l].stick[0l].axis[1l].pos))
            tmp_if_expr_4 = joy[(signed long int)0].stick[(signed long int)0].axis[(signed long int)1].pos;

          else
            tmp_if_expr_4 = JOY1_MAX_Y;
          JOY1_MAX_Y = tmp_if_expr_4;
          JOY1_MID_Y = (JOY1_MIN_Y + JOY1_MAX_Y) / 2;
          JOYSTICK_CONTROL_JOY1_UP = joy[(signed long int)0].stick[(signed long int)0].axis[(signed long int)1].pos < (JOY1_MIN_Y + 2 * JOY1_MID_Y) / 3 ? 1 : 0;
          JOYSTICK_CONTROL_JOY1_RIGHT = joy[(signed long int)0].stick[(signed long int)0].axis[(signed long int)0].pos > (JOY1_MAX_X + 2 * JOY1_MID_X) / 3 ? 1 : 0;
          JOYSTICK_CONTROL_JOY1_DOWN = joy[(signed long int)0].stick[(signed long int)0].axis[(signed long int)1].pos > (JOY1_MAX_Y + 2 * JOY1_MID_Y) / 3 ? 1 : 0;
          JOYSTICK_CONTROL_JOY1_LEFT = joy[(signed long int)0].stick[(signed long int)0].axis[(signed long int)0].pos < (JOY1_MIN_X + 2 * JOY1_MID_X) / 3 ? 1 : 0;
        }

      }

      if(joy[0l].num_buttons >= 2)
      {
        JOYSTICK_CONTROL_JOY1_B1 = joy[(signed long int)0].button[(signed long int)0].b;
        JOYSTICK_CONTROL_JOY1_B2 = joy[(signed long int)0].button[(signed long int)1].b;
      }

      if(joy[0l].num_buttons >= 4)
      {
        JOYSTICK_CONTROL_JOY1_B3 = joy[(signed long int)0].button[(signed long int)2].b;
        JOYSTICK_CONTROL_JOY1_B4 = joy[(signed long int)0].button[(signed long int)3].b;
      }

    }

    if(num_joysticks >= 2)
    {
      if(joy[1l].num_sticks >= 1)
      {
        if(joy[1l].stick[0l].num_axis >= 2)
        {
          if(!(joy[1l].stick[0l].axis[0l].pos >= JOY2_MIN_X))
            tmp_if_expr_5 = joy[(signed long int)1].stick[(signed long int)0].axis[(signed long int)0].pos;

          else
            tmp_if_expr_5 = JOY2_MIN_X;
          JOY2_MIN_X = tmp_if_expr_5;
          if(!(JOY2_MAX_X >= joy[1l].stick[0l].axis[0l].pos))
            tmp_if_expr_6 = joy[(signed long int)1].stick[(signed long int)0].axis[(signed long int)0].pos;

          else
            tmp_if_expr_6 = JOY2_MAX_X;
          JOY2_MAX_X = tmp_if_expr_6;
          JOY2_MID_Y = (JOY2_MIN_X + JOY2_MAX_X) / 2;
          if(!(joy[1l].stick[0l].axis[1l].pos >= JOY2_MIN_Y))
            tmp_if_expr_7 = joy[(signed long int)1].stick[(signed long int)0].axis[(signed long int)1].pos;

          else
            tmp_if_expr_7 = JOY2_MIN_Y;
          JOY2_MIN_Y = tmp_if_expr_7;
          if(!(JOY2_MAX_Y >= joy[1l].stick[0l].axis[1l].pos))
            tmp_if_expr_8 = joy[(signed long int)1].stick[(signed long int)0].axis[(signed long int)1].pos;

          else
            tmp_if_expr_8 = JOY2_MAX_Y;
          JOY2_MAX_Y = tmp_if_expr_8;
          JOY2_MID_Y = (JOY2_MIN_Y + JOY2_MAX_Y) / 2;
          JOYSTICK_CONTROL_JOY2_UP = joy[(signed long int)1].stick[(signed long int)0].axis[(signed long int)1].pos < (JOY2_MIN_Y + 2 * JOY2_MID_Y) / 3 ? 1 : 0;
          JOYSTICK_CONTROL_JOY2_RIGHT = joy[(signed long int)1].stick[(signed long int)0].axis[(signed long int)0].pos > (JOY2_MAX_X + 2 * JOY2_MID_X) / 3 ? 1 : 0;
          JOYSTICK_CONTROL_JOY2_DOWN = joy[(signed long int)1].stick[(signed long int)0].axis[(signed long int)1].pos > (JOY2_MAX_Y + 2 * JOY2_MID_Y) / 3 ? 1 : 0;
          JOYSTICK_CONTROL_JOY2_LEFT = joy[(signed long int)1].stick[(signed long int)0].axis[(signed long int)0].pos < (JOY2_MIN_X + 2 * JOY2_MID_X) / 3 ? 1 : 0;
        }

      }

      if(joy[0l].num_buttons >= 2)
      {
        JOYSTICK_CONTROL_JOY2_B1 = joy[(signed long int)1].button[(signed long int)0].b;
        JOYSTICK_CONTROL_JOY2_B2 = joy[(signed long int)1].button[(signed long int)1].b;
      }

    }

  }

}

// my_set_palette
// file palette.h line 85
void my_set_palette(void)
{
  struct RGB old_pal[256l];
  struct RGB corrected_pal[256l];
  signed int i;
  signed int equal = 1;
  change_palette_brightness(GLOBAL_PALETTE, corrected_pal);
  get_palette(old_pal);
  i = 0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  for( ; !(equal == 0) && !(i >= 256); i = i + 1)
  {
    if(!(equal == 0))
      tmp_if_expr_1 = corrected_pal[(signed long int)i].r == old_pal[(signed long int)i].r ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    equal = (signed int)tmp_if_expr_1;
    if(!(equal == 0))
      tmp_if_expr_2 = corrected_pal[(signed long int)i].g == old_pal[(signed long int)i].g ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    equal = (signed int)tmp_if_expr_2;
    if(!(equal == 0))
      tmp_if_expr_3 = corrected_pal[(signed long int)i].b == old_pal[(signed long int)i].b ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    equal = (signed int)tmp_if_expr_3;
  }
  if(equal == 0)
    set_palette(corrected_pal);

}

// my_slider_proc
// file alleg2.h line 72
signed int my_slider_proc(signed int msg, struct DIALOG *d, signed int c)
{
  struct BITMAP *gui_bmp;
  gui_bmp=gui_get_screen();
  struct BITMAP *slhan = (struct BITMAP *)(void *)0;
  signed int oldpos;
  signed int newpos;
  signed int sfg;
  signed int vert = -1;
  signed int hh = 7;
  signed int hmar;
  signed int slp;
  signed int mp;
  signed int irange;
  signed int slx;
  signed int sly;
  signed int slh;
  signed int slw;
  signed int msx;
  signed int msy;
  signed int retval = 0;
  signed int upkey;
  signed int downkey;
  signed int pgupkey;
  signed int pgdnkey;
  signed int homekey;
  signed int endkey;
  signed int delta;
  signed int slratio;
  signed int slmax;
  signed int slpos;
  signed int (*proc)(void *, signed int);
  signed int oldval;
  if(!(d->h >= d->w))
    vert = 0;

  if(!(d->dp == NULL))
  {
    slhan = (struct BITMAP *)d->dp;
    if(!(vert == 0))
      hh = slhan->h;

    else
      hh = slhan->w;
  }

  hmar = hh / 2;
  signed int tmp_if_expr_1;
  if(!(vert == 0))
    tmp_if_expr_1 = d->h;

  else
    tmp_if_expr_1 = d->w;
  irange = tmp_if_expr_1;
  slmax=itofix(irange - hh);
  slratio = slmax / d->d1;
  slpos = slratio * d->d2;
  slp=fixtoi(slpos);
  signed int tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  signed int tmp_if_expr_9;
  signed int tmp_if_expr_6;
  signed int tmp_if_expr_5;
  signed int tmp_if_expr_8;
  signed int tmp_if_expr_7;
  signed int return_value_2;
  switch(msg)
  {
    case 3:
    {
      if(!((32 & d->flags) == 0))
        tmp_if_expr_2 = gui_mg_color;

      else
        tmp_if_expr_2 = d->fg;
      sfg = tmp_if_expr_2;
      if(!(vert == 0))
      {
        rectfill(gui_bmp, d->x, d->y, (d->x + d->w / 2) - 2, (d->y + d->h) - 1, d->bg);
        rectfill(gui_bmp, (d->x + d->w / 2) - 1, d->y, d->x + d->w / 2 + 1, (d->y + d->h) - 1, sfg);
        rectfill(gui_bmp, d->x + d->w / 2 + 2, d->y, (d->x + d->w) - 1, (d->y + d->h) - 1, d->bg);
      }

      else
      {
        rectfill(gui_bmp, d->x, d->y, (d->x + d->w) - 1, (d->y + d->h / 2) - 2, d->bg);
        rectfill(gui_bmp, d->x, (d->y + d->h / 2) - 1, (d->x + d->w) - 1, d->y + d->h / 2 + 1, sfg);
        rectfill(gui_bmp, d->x, d->y + d->h / 2 + 2, (d->x + d->w) - 1, (d->y + d->h) - 1, d->bg);
      }
      rect(screen, d->x, d->y, d->x + d->w, d->y + d->h, sfg);
      if(!(slhan == ((struct BITMAP *)NULL)))
      {
        if(!(vert == 0))
        {
          slx = (d->x + d->w / 2) - slhan->w / 2;
          sly = (d->y + (d->h - 1)) - (hh + slp);
        }

        else
        {
          slx = d->x + slp;
          sly = (d->y + d->h / 2) - slhan->h / 2;
        }
        draw_sprite(gui_bmp, slhan, slx, sly);
      }

      else
      {
        if(!(vert == 0))
        {
          slx = d->x;
          sly = (d->y + d->h) - (hh + slp);
          slw = d->w - 1;
          slh = hh - 1;
        }

        else
        {
          slx = d->x + slp;
          sly = d->y;
          slw = hh - 1;
          slh = d->h - 1;
        }
        rectfill(gui_bmp, slx + 2, sly, slx + (slw - 2), sly + slh, sfg);
        vline(gui_bmp, slx + 1, sly + 1, (sly + slh) - 1, sfg);
        vline(gui_bmp, (slx + slw) - 1, sly + 1, (sly + slh) - 1, sfg);
        vline(gui_bmp, slx, sly + 2, (sly + slh) - 2, sfg);
        vline(gui_bmp, slx + slw, sly + 2, (sly + slh) - 2, sfg);
        vline(gui_bmp, slx + 1, sly + 2, (sly + slh) - 2, d->bg);
        hline(gui_bmp, slx + 2, sly + 1, (slx + slw) - 2, d->bg);
        putpixel(gui_bmp, slx + 2, sly + 2, d->bg);
      }
      if(!((4 & d->flags) == 0))
        my_dotted_rect(d->x + 1, d->y + 1, (d->x + d->w) - 1, (d->y + d->h) - 1, sfg, d->bg);

      goto __CPROVER_DUMP_L63;
    }
    case 10:

    case 12:
      return 8;
    case 6:
      if((4 & d->flags) == 0)
        return 8;

      else
        return 0;
    case 7:
    {
      c = c >> 8;
      if(!(vert == 0))
      {
        upkey = 84;
        downkey = 85;
        pgupkey = 80;
        pgdnkey = 81;
        homekey = 79;
        endkey = 78;
      }

      else
      {
        upkey = 83;
        downkey = 82;
        pgupkey = 81;
        pgdnkey = 80;
        homekey = 78;
        endkey = 79;
      }
      if(c == upkey)
        delta = 1;

      else
        if(c == downkey)
          delta = -1;

        else
          if(c == pgdnkey)
            delta = -d->d1 / 16;

          else
            if(c == pgupkey)
              delta = d->d1 / 16;

            else
              if(c == homekey)
                delta = -d->d2;

              else
                if(c == endkey)
                  delta = d->d1 - d->d2;

                else
                  delta = 0;
      if(!(delta == 0))
      {
        oldpos = slp;
        oldval = d->d2;
        while((_Bool)1)
        {
          d->d2 = d->d2 + delta;
          slpos = slratio * d->d2;
          slp=fixtoi(slpos);
          if(!(slp == oldpos))
            tmp_if_expr_3 = (_Bool)1;

          else
            tmp_if_expr_3 = d->d2 <= 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_3)
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = d->d2 >= d->d1 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_4)
            break;

        }
        if(!(d->d2 >= 0))
          d->d2 = 0;

        if(!(d->d1 >= d->d2))
          d->d2 = d->d1;

        retval = 16;
        if(!(d->d2 == oldval))
        {
          if(!(d->dp2 == NULL))
          {
            proc = (signed int (*)(void *, signed int))d->dp2;
            signed int return_value;
            return_value=proc(d->dp3, d->d2);
            retval = retval | return_value;
          }

          object_message(d, 3, 0);
        }

      }

      goto __CPROVER_DUMP_L63;
    }
    case 17:
    {
      oldval = d->d2;
      if(!(d->d2 + c >= 0))
      {
        if(!(d->d1 >= d->d2 + c))
          tmp_if_expr_6 = d->d2 + c;

        else
        {
          if(!(d->d1 >= 0))
            tmp_if_expr_5 = d->d1;

          else
            tmp_if_expr_5 = 0;
          tmp_if_expr_6 = tmp_if_expr_5;
        }
        tmp_if_expr_9 = tmp_if_expr_6;
      }

      else
      {
        if(!(d->d1 >= d->d2 + c))
        {
          if(d->d1 >= 1)
            tmp_if_expr_7 = d->d1;

          else
            tmp_if_expr_7 = 0;
          tmp_if_expr_8 = tmp_if_expr_7;
        }

        else
          tmp_if_expr_8 = d->d2 + c;
        tmp_if_expr_9 = tmp_if_expr_8;
      }
      d->d2 = tmp_if_expr_9;
      if(!(d->d2 == oldval))
      {
        if(!(d->dp2 == NULL))
        {
          proc = (signed int (*)(void *, signed int))d->dp2;
          signed int return_value_1;
          return_value_1=proc(d->dp3, d->d2);
          retval = retval | return_value_1;
        }

        object_message(d, 3, 0);
      }

      goto __CPROVER_DUMP_L63;
    }
    case 4:
    {
      mp = slp;
      return_value_2=gui_mouse_b();
    }
    default:
    {

    __CPROVER_DUMP_L63:
      ;
      return retval;
    }
  }
}

// my_text_proc
// file alleg2.c line 617
signed int my_text_proc(signed int msg, struct DIALOG *d, signed int c)
{
  c = c;
  if(msg == 3)
  {
    struct FONT *oldfont = font;
    if(!(d->dp2 == NULL))
      font = (struct FONT *)d->dp2;

    struct BITMAP *return_value_gui_get_screen_1;
    return_value_gui_get_screen_1=gui_get_screen();
    gui_textout_ex(return_value_gui_get_screen_1, (const char *)d->dp, d->x, d->y, -1, d->bg, 0);
    font = oldfont;
  }

  return 0;
}

// my_textbox_proc
// file alleg2.h line 68
signed int my_textbox_proc(signed int msg, struct DIALOG *d, signed int c)
{
  signed int height;
  signed int bar;
  signed int ret = 0;
  signed int start;
  signed int top;
  signed int bottom;
  signed int l;
  signed int used;
  signed int delta;
  signed int fg_color;
  signed int tmp_if_expr_1;
  if(!((32 & d->flags) == 0))
    tmp_if_expr_1 = gui_mg_color;

  else
    tmp_if_expr_1 = d->fg;
  fg_color = tmp_if_expr_1;
  signed int return_value_text_height_2;
  return_value_text_height_2=text_height(font);
  height = (d->h - 8) / return_value_text_height_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  signed int return_value;
  signed int return_value_text_height_6;
  signed int tmp_if_expr_9;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_8;
  switch(msg)
  {
    case 1:
    {
      my_draw_textbox((char *)d->dp, &d->d1, 0, d->d2, (signed int)!((d->flags & 2) != 0), 8, d->x, d->y, d->w, d->h, d->flags & 32, 0, 0, 0);
      break;
    }
    case 3:
    {
      my_draw_textbox((char *)d->dp, &d->d1, 0, d->d2, (signed int)!((d->flags & 2) != 0), 8, d->x, d->y, d->w, d->h, d->flags & 32, 0, 0, 0);
      if(!(height >= d->d1))
        tmp_if_expr_3 = d->d1 > 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
        bar = 12;

      else
      {
        bar = 0;
        d->d2 = 0;
      }
      if(!(d->d1 >= 2))
        rectfill(screen, d->x, d->y, d->x + d->w, d->y + d->h, d->bg);

      my_draw_textbox((char *)d->dp, &d->d1, 1, d->d2, (signed int)!((d->flags & 2) != 0), 8, d->x, d->y, d->w - bar, d->h, d->flags & 32, fg_color, d->bg, gui_mg_color);
      if(!(d->d1 >= 2))
        rect(screen, d->x, d->y, d->x + d->w, d->y + d->h, fg_color);

      else
        _draw_scrollable_frame(d, d->d1, d->d2, height, fg_color, d->bg);
      break;
    }
    case 4:
    {
      bar = (signed int)(d->d1 > height);
      if(bar == 0)
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value=gui_mouse_x();
        tmp_if_expr_4 = return_value < (d->x + d->w) - 13 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
        ret = 0;

      else
        my_handle_scrollable_scroll_click(d, d->d1, &d->d2, height);
      break;
    }
    case 7:
    {
      start = d->d2;
      used = 16;
      if(d->d1 >= 1)
      {
        if(d->d2 >= 1)
          top = d->d2 + 1;

        else
          top = 0;
        signed int return_value_text_height_5;
        return_value_text_height_5=text_height(font);
        l = (d->h - 8) / return_value_text_height_5;
        bottom = (d->d2 + l) - 1;
        if(bottom >= d->d1 + -1)
          bottom = d->d1 - 1;

        else
          bottom = bottom - 1;
        if(c >> 8 == 84)
          d->d2 = d->d2 - 1;

        else
          if(c >> 8 == 85)
            d->d2 = d->d2 + 1;

          else
            if(c >> 8 == 78)
              d->d2 = 0;

            else
              if(c >> 8 == 79)
                d->d2 = d->d1 - l;

              else
                if(c >> 8 == 80)
                  d->d2 = d->d2 - (bottom - top != 0 ? bottom - top : 1);

                else
                  if(c >> 8 == 81)
                    d->d2 = d->d2 + (bottom - top != 0 ? bottom - top : 1);

                  else
                    used = 0;
        if(!(d->d1 + -l >= d->d2))
          d->d2 = d->d1 - l;

        if(!(d->d2 >= 0))
          d->d2 = 0;

      }

      else
        used = 0;
      if(!(d->d2 == start))
        d->flags = d->flags | 64;

      ret = used;
      break;
    }
    case 17:
    {
      return_value_text_height_6=text_height(font);
      l = (d->h - 8) / return_value_text_height_6;
      delta = l > 3 ? 3 : 1;
      start = d->d2;
      if(c >= 1)
      {
        if(!(d->d2 + -delta >= 0))
          tmp_if_expr_7 = 0;

        else
          tmp_if_expr_7 = d->d2 - delta;
        tmp_if_expr_9 = tmp_if_expr_7;
      }

      else
      {
        if(!(d->d1 + -l >= d->d2 + delta))
          tmp_if_expr_8 = d->d1 - l;

        else
          tmp_if_expr_8 = d->d2 + delta;
        tmp_if_expr_9 = tmp_if_expr_8;
      }
      d->d2 = tmp_if_expr_9;
      if(!(d->d2 == start))
        d->flags = d->flags | 64;

      ret = 0;
      break;
    }
    case 10:
    {
      if(!(height >= d->d1))
        ret = 8;

      break;
    }
    default:
      ret = 0;
  }
  return ret;
}

// my_update_dialog
// file dialog.h line 118
signed int my_update_dialog(struct DIALOG_PLAYER *player)
{
  signed int result;
  result=update_dialog(player);
  lw_capture_dump_menu();
  my_poll_joystick();
  my_exit_poll();
  usleep((unsigned int)100);
  rest((unsigned int)0);
  return result;
}

// need_to_change_mode
// file gfxmode.c line 137
signed int need_to_change_mode(signed int res1, signed int res2, signed int flip)
{
  if(flip == 0 && res1 == res2)
    return 0;

  else
    return (signed int)!(0 != 0);
}

// netplay_sequence
// file netplay.h line 65
signed int netplay_sequence(void)
{
  signed int sock = -1;
  signed int result = 0;
  lw_config_set_current_rules_to_default();
  signed int return_value_connect_on_server_start_3;
  return_value_connect_on_server_start_3=connect_on_server_start(&sock, CONFIG_SERVER_ADDRESS, CONFIG_SERVER_PORT);
  if(!(return_value_connect_on_server_start_3 == 0))
  {
    signed int return_value_connect_on_server_continue_2;
    return_value_connect_on_server_continue_2=connect_on_server_continue(sock);
    if(!(return_value_connect_on_server_continue_2 == 0))
    {
      result=lw_connect_menu(sock);
      if(result == -4)
      {
        signed int return_value_connect_on_server_finish_1;
        return_value_connect_on_server_finish_1=connect_on_server_finish(sock);
        if(!(return_value_connect_on_server_finish_1 == 0))
        {
          LW_NETWORK_ON = 1;
          lw_network_attribute_colors();
          lw_network_attribute_parts();
          result=play_sequence_ex();
        }

      }

    }

  }

  LW_KEYEXCH_SOCK = -1;
  lw_sock_close(&sock);
  return result;
}

// network_game
// file netgame.h line 61
signed int network_game(void)
{
  struct DIALOG d[17l];
  signed int choix = 4;
  signed int retour = 0;
  char bufport[34l];
  signed int y0;
  memset((void *)d, 0, sizeof(struct DIALOG [17l]) /*1224ul*/ );
  LW_NETWORK_ON = 1;
  while(retour == 0)
  {
    memset((void *)bufport, 0, sizeof(char [34l]) /*34ul*/ );
    snprintf(bufport, sizeof(char [34l]) /*34ul*/  - (unsigned long int)1, "%d", CONFIG_SERVER_PORT);
    bufport[(signed long int)(sizeof(char [34l]) /*34ul*/  - (unsigned long int)1)] = (char)0;
    standard_button(d + (signed long int)4, 0, 0, 1, 10);
    standard_button(d + (signed long int)5, 0, 2, 2, 10);
    standard_button(d + (signed long int)6, 0, 3, 2, 10);
    standard_button(d + (signed long int)7, 0, 4, 2, 10);
    standard_button(d + (signed long int)8, 1, 2, 2, 10);
    standard_button(d + (signed long int)9, 1, 3, 2, 10);
    standard_button(d + (signed long int)10, 1, 4, 2, 10);
    standard_button(d + (signed long int)11, 1, 2, 2, 10);
    standard_button(d + (signed long int)12, 1, 3, 2, 10);
    standard_button(d + (signed long int)13, 1, 4, 2, 10);
    standard_big_button(d + (signed long int)14, 0, 7, 1, 10);
    y0 = d[(signed long int)14].y + d[(signed long int)14].h;
    standard_big_button(d + (signed long int)14, 0, 5, 1, 10);
    d[(signed long int)14].h = y0 - d[(signed long int)14].y;
    standard_big_button(d + (signed long int)15, 0, 9, 1, 10);
    quick_buttons(d);
    char *return_value_lw_lang_string_1;
    return_value_lw_lang_string_1=lw_lang_string(22);
    d[(signed long int)4].dp = (void *)return_value_lw_lang_string_1;
    char *return_value_lw_lang_string_2;
    return_value_lw_lang_string_2=lw_lang_string(23);
    d[(signed long int)5].dp = (void *)return_value_lw_lang_string_2;
    d[(signed long int)5].proc = my_textbox_proc;
    char *return_value_lw_lang_string_3;
    return_value_lw_lang_string_3=lw_lang_string(24);
    d[(signed long int)6].dp = (void *)return_value_lw_lang_string_3;
    d[(signed long int)6].proc = my_textbox_proc;
    char *return_value_lw_lang_string_4;
    return_value_lw_lang_string_4=lw_lang_string(26);
    d[(signed long int)7].dp = (void *)return_value_lw_lang_string_4;
    d[(signed long int)7].proc = my_textbox_proc;
    d[(signed long int)8].proc = d_box_proc;
    d[(signed long int)9].proc = d_box_proc;
    d[(signed long int)10].proc = d_box_proc;
    d[(signed long int)11].dp = (void *)CONFIG_SERVER_ADDRESS;
    d[(signed long int)11].d1 = 50;
    d[(signed long int)11].proc = my_edit_proc;
    d[(signed long int)11].flags = 0;
    d[(signed long int)11].x = d[(signed long int)11].x + 1;
    d[(signed long int)11].y = d[(signed long int)11].y + 1;
    d[(signed long int)11].w = d[(signed long int)11].w - 2;
    d[(signed long int)11].h = d[(signed long int)11].h - 2;
    d[(signed long int)12].dp = (void *)bufport;
    d[(signed long int)12].d1 = 33;
    d[(signed long int)12].proc = my_edit_proc;
    d[(signed long int)12].flags = 0;
    d[(signed long int)12].x = d[(signed long int)12].x + 1;
    d[(signed long int)12].y = d[(signed long int)12].y + 1;
    d[(signed long int)12].w = d[(signed long int)12].w - 2;
    d[(signed long int)12].h = d[(signed long int)12].h - 2;
    d[(signed long int)9].d2 = 0;
    d[(signed long int)12].d2 = d[(signed long int)9].d2;
    d[(signed long int)13].dp = (void *)CONFIG_PASSWORD;
    d[(signed long int)13].d1 = 20;
    d[(signed long int)13].proc = my_edit_proc;
    d[(signed long int)13].flags = 0;
    d[(signed long int)13].x = d[(signed long int)13].x + 1;
    d[(signed long int)13].y = d[(signed long int)13].y + 1;
    d[(signed long int)13].w = d[(signed long int)13].w - 2;
    d[(signed long int)13].h = d[(signed long int)13].h - 2;
    d[(signed long int)14].proc = my_textbox_proc;
    char *return_value_lw_lang_string_5;
    return_value_lw_lang_string_5=lw_lang_string(27);
    d[(signed long int)14].dp = (void *)return_value_lw_lang_string_5;
    char *return_value_lw_lang_string_6;
    return_value_lw_lang_string_6=lw_lang_string(25);
    d[(signed long int)15].dp = (void *)return_value_lw_lang_string_6;
    d[(signed long int)16].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
    choix=my_do_dialog(d, choix);
    CONFIG_SERVER_PORT=atoi_link2(bufport);
    lw_netmess_cleanup_arg(CONFIG_PASSWORD);
    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 2)
        goto __CPROVER_DUMP_L3;

      if(choix == 0)
        goto __CPROVER_DUMP_L4;

      if(choix == 1 || choix == 4)
        goto __CPROVER_DUMP_L7;

      if(choix == 15)
        goto __CPROVER_DUMP_L8;

    }

    else
    {
      retour = 1;
      goto __CPROVER_DUMP_L9;

    __CPROVER_DUMP_L3:
      ;
      retour = -1;
      goto __CPROVER_DUMP_L9;

    __CPROVER_DUMP_L4:
      ;
      signed int return_value_confirm_quit_7;
      return_value_confirm_quit_7=confirm_quit();
      if(!(return_value_confirm_quit_7 == 0))
        retour = -2;

      else
        display_back_image();
      goto __CPROVER_DUMP_L9;

    __CPROVER_DUMP_L7:
      ;
      retour=netplay_sequence();
      goto __CPROVER_DUMP_L9;

    __CPROVER_DUMP_L8:
      ;
      retour=internet_find();
    }

  __CPROVER_DUMP_L9:
    ;
  }
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// next_line
// file wwwcli.c line 416
static void next_line(char **str)
{
  char *pos;
  signed int len;
  skip_space(str);
  char *return_value___builtin_strchr_1;
  return_value___builtin_strchr_1=__builtin_strchr(*str, 10);
  pos = return_value___builtin_strchr_1;
  if(!(pos == ((char *)NULL)))
    *str = pos + (signed long int)1;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(*str);
    len = (signed int)return_value_strlen_2;
    *str = *str + (signed long int)len;
  }
  skip_space(str);
}

// options
// file options.h line 66
signed int options(void)
{
  struct DIALOG d[12l];
  struct DIALOG_PLAYER *dp;
  signed int i;
  signed int choix = 4;
  signed int retour = 0;
  signed int old_gfx_menu;
  signed int old_fullscreen;
  signed int gfxmode_change = 0;
  memset((void *)d, 0, sizeof(struct DIALOG [12l]) /*864ul*/ );
  signed int return_value_my_update_dialog_8;
  while(retour == 0)
  {
    i = 0;
    for( ; !(i >= 6); i = i + 1)
      standard_button(d + (signed long int)i + (signed long int)4, 0, i, 1, 8);
    standard_button(d + (signed long int)10, 0, 7, 1, 8);
    quick_buttons(d);
    char *return_value_lw_lang_string_1;
    return_value_lw_lang_string_1=lw_lang_string(32);
    d[(signed long int)4].dp = (void *)return_value_lw_lang_string_1;
    char *return_value_lw_lang_string_2;
    return_value_lw_lang_string_2=lw_lang_string(33);
    d[(signed long int)5].dp = (void *)return_value_lw_lang_string_2;
    char *return_value_lw_lang_string_3;
    return_value_lw_lang_string_3=lw_lang_string(34);
    d[(signed long int)6].dp = (void *)return_value_lw_lang_string_3;
    char *return_value_lw_lang_string_4;
    return_value_lw_lang_string_4=lw_lang_string(35);
    d[(signed long int)7].dp = (void *)return_value_lw_lang_string_4;
    char *return_value_lw_lang_string_5;
    return_value_lw_lang_string_5=lw_lang_string(36);
    d[(signed long int)8].dp = (void *)return_value_lw_lang_string_5;
    char *return_value_lw_lang_string_6;
    return_value_lw_lang_string_6=lw_lang_string(37);
    d[(signed long int)9].dp = (void *)return_value_lw_lang_string_6;
    char *return_value_lw_lang_string_7;
    return_value_lw_lang_string_7=lw_lang_string(38);
    d[(signed long int)10].dp = (void *)return_value_lw_lang_string_7;
    d[(signed long int)11].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
    old_gfx_menu = CONFIG_GFX_MENU;
    old_fullscreen = CONFIG_FULLSCREEN;
    display_back_image();
    if(!(gfxmode_change == 0))
    {
      gfxmode_change = 0;
      display_back_image();
      dp=my_init_dialog(d, choix);
      my_fade_in();
    }

    else
      dp=my_init_dialog(d, choix);
    show_mouse(screen);
    do
    {
      return_value_my_update_dialog_8=my_update_dialog(dp);
      if(return_value_my_update_dialog_8 == 0)
        break;

    }
    while((_Bool)1);
    choix=shutdown_dialog(dp);
    play_click();
    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 2)
        goto __CPROVER_DUMP_L9;

      if(choix == 0)
        goto __CPROVER_DUMP_L10;

      if(choix == 1)
        goto __CPROVER_DUMP_L13;

      if(choix == 4)
        goto __CPROVER_DUMP_L14;

      if(choix == 5)
        goto __CPROVER_DUMP_L15;

      if(choix == 6)
        goto __CPROVER_DUMP_L16;

      if(choix == 7)
        goto __CPROVER_DUMP_L17;

      if(choix == 8)
        goto __CPROVER_DUMP_L18;

      if(choix == 9)
        goto __CPROVER_DUMP_L19;

      if(choix == 10)
        goto __CPROVER_DUMP_L20;

    }

    else
    {
      retour = 1;
      goto __CPROVER_DUMP_L22;

    __CPROVER_DUMP_L9:
      ;
      retour = -1;
      goto __CPROVER_DUMP_L22;

    __CPROVER_DUMP_L10:
      ;
      signed int return_value_confirm_quit_9;
      return_value_confirm_quit_9=confirm_quit();
      if(!(return_value_confirm_quit_9 == 0))
        retour = -2;

      else
        display_back_image();
      goto __CPROVER_DUMP_L22;

    __CPROVER_DUMP_L13:
      ;
      retour = -3;
      goto __CPROVER_DUMP_L22;

    __CPROVER_DUMP_L14:
      ;
      retour=graphic_options();
      goto __CPROVER_DUMP_L22;

    __CPROVER_DUMP_L15:
      ;
      retour=sound_options();
      goto __CPROVER_DUMP_L22;

    __CPROVER_DUMP_L16:
      ;
      retour=rules_options();
      goto __CPROVER_DUMP_L22;

    __CPROVER_DUMP_L17:
      ;
      retour=speeds_options();
      goto __CPROVER_DUMP_L22;

    __CPROVER_DUMP_L18:
      ;
      retour=controls_options();
      goto __CPROVER_DUMP_L22;

    __CPROVER_DUMP_L19:
      ;
      retour=language_options();
      goto __CPROVER_DUMP_L22;

    __CPROVER_DUMP_L20:
      ;
      load_default_options();
      WATER_VOLUME = CONFIG_WATER_VOLUME_MENU;
      if(!(old_fullscreen == CONFIG_FULLSCREEN) || !(old_gfx_menu == CONFIG_GFX_MENU))
      {
        gfxmode_change = 1;
        set_resolution(CONFIG_GFX_MENU, 0, CONFIG_FULLSCREEN, (signed int *)(void *)0);
      }

      retour = 0;
    }

  __CPROVER_DUMP_L22:
    ;
  }
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// order_map
// file disk.c line 611
void order_map(void)
{
  signed int incorrect_order = 1;
  signed int i;
  char name1[33l];
  char name2[33l];
  void *temp;
  i = 0;
  for( ; !(i >= RAW_MAP_NUMBER); i = i + 1)
    RAW_MAP_ORDERED[(signed long int)i] = RAW_MAP[(signed long int)i];
  signed int tmp_statement_expression_3;
  while(!(incorrect_order == 0))
  {
    incorrect_order = 0;
    i = 0;
    for( ; !(i >= RAW_MAP_NUMBER + -1); i = i + 1)
    {
      memset((void *)name1, 0, sizeof(char [33l]) /*33ul*/ );
      char *return_value_lw_map_get_readable_name_1;
      return_value_lw_map_get_readable_name_1=lw_map_get_readable_name(i, 0, 0);
      __builtin_strncpy(name1, return_value_lw_map_get_readable_name_1, sizeof(char [33l]) /*33ul*/  - (unsigned long int)1);
      name1[(signed long int)(sizeof(char [33l]) /*33ul*/  - (unsigned long int)1)] = (char)0;
      memset((void *)name2, 0, sizeof(char [33l]) /*33ul*/ );
      char *return_value_lw_map_get_readable_name_2;
      return_value_lw_map_get_readable_name_2=lw_map_get_readable_name(i + 1, 0, 0);
      __builtin_strncpy(name2, return_value_lw_map_get_readable_name_2, sizeof(char [33l]) /*33ul*/  - (unsigned long int)1);
      name2[(signed long int)(sizeof(char [33l]) /*33ul*/  - (unsigned long int)1)] = (char)0;
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_4;
      return_value___builtin_strcmp_4=__builtin_strcmp(name1, name2);
      tmp_statement_expression_3 = return_value___builtin_strcmp_4;
      if(tmp_statement_expression_3 >= 1)
      {
        incorrect_order = 1;
        temp = RAW_MAP_ORDERED[(signed long int)i];
        RAW_MAP_ORDERED[(signed long int)i] = RAW_MAP_ORDERED[(signed long int)(i + 1)];
        RAW_MAP_ORDERED[(signed long int)(i + 1)] = temp;
      }

    }
  }
}

// page_flip
// file viewport.h line 76
struct BITMAP * page_flip(void)
{
  signed int old_h;
  signed int new_h;
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  _Bool tmp_if_expr_9;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_8;
  if(!(CONFIG_PAGE_FLIP == 0))
  {
    if(!(screen == ((struct BITMAP *)NULL)))
      tmp_if_expr_7 = screen->h;

    else
      tmp_if_expr_7 = 0;
    if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
      tmp_if_expr_8 = gfx_driver->h;

    else
      tmp_if_expr_8 = 0;
    tmp_if_expr_9 = tmp_if_expr_7 >= 2 * tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_9 = (_Bool)0;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_5;
  signed int tmp_if_expr_6;
  if(tmp_if_expr_9)
  {
    if(!(NEXT_SCREEN == ((struct BITMAP *)NULL)))
      destroy_bitmap(NEXT_SCREEN);

    lw_info_get_room_for_viewport(&x, &y, &w, &h);
    init_viewport_size(x, y, w, h);
    old_h = PAGE_FLIP_H;
    if(!(old_h == 0))
      tmp_if_expr_2 = 0;

    else
    {
      if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
        tmp_if_expr_1 = gfx_driver->h;

      else
        tmp_if_expr_1 = 0;
      tmp_if_expr_2 = tmp_if_expr_1;
    }
    new_h = tmp_if_expr_2;
    scroll_screen(0, old_h);
    if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
      tmp_if_expr_3 = gfx_driver->w;

    else
      tmp_if_expr_3 = 0;
    if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
      tmp_if_expr_4 = gfx_driver->h;

    else
      tmp_if_expr_4 = 0;
    set_clip_rect(screen, 0, new_h, tmp_if_expr_3 - 1, (new_h + tmp_if_expr_4) - 1);
    PAGE_FLIP_H = new_h;
    NEXT_SCREEN=create_sub_bitmap(screen, VIEWPORT_X, VIEWPORT_Y + new_h, VIEWPORT_W, VIEWPORT_H);
  }

  else
  {
    PAGE_FLIP_H = 0;
    if(NEXT_SCREEN == ((struct BITMAP *)NULL) || !(VIEWPORT_CHANGE_REGISTERED == 0))
    {
      scroll_screen(0, 0);
      if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
        tmp_if_expr_5 = gfx_driver->w;

      else
        tmp_if_expr_5 = 0;
      if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
        tmp_if_expr_6 = gfx_driver->h;

      else
        tmp_if_expr_6 = 0;
      set_clip_rect(screen, 0, 0, tmp_if_expr_5 - 1, tmp_if_expr_6 - 1);
      lw_info_get_room_for_viewport(&x, &y, &w, &h);
      init_viewport_size(x, y, w, h);
      NEXT_SCREEN=create_sub_bitmap(screen, VIEWPORT_X, VIEWPORT_Y, VIEWPORT_W, VIEWPORT_H);
    }

  }
  if(VIEWPORT_CHANGE_REGISTERED >= 1)
  {
    rect_for_viewport();
    init_distorsion_displayer();
    VIEWPORT_CHANGE_REGISTERED = VIEWPORT_CHANGE_REGISTERED - 1;
  }

  return NEXT_SCREEN;
}

// palette_128
// file level.c line 86
static void palette_128(struct DIALOG *d, signed int x, signed int y, signed int w, signed int h)
{
  signed int w1;
  signed int h1;
  signed int w2;
  signed int h2;
  signed int i;
  signed int j;
  signed int k;
  w = w + 2;
  h = h + 2;
  w1 = w / 10;
  h1 = h / 13;
  w2 = w1 - 2;
  h2 = h1 - 2;
  k = 0;
  for( ; !(k >= 128); k = k + 1)
  {
    (d + (signed long int)k)->proc = d_button_proc;
    (d + (signed long int)k)->key = 0;
    (d + (signed long int)k)->dp = (void *)"";
    (d + (signed long int)k)->w = w2;
    (d + (signed long int)k)->h = h2;
    (d + (signed long int)k)->fg = 17;
    (d + (signed long int)k)->flags = 1;
    (d + (signed long int)k)->bg = k + 128;
  }
  k = 0;
  i = 0;
  for( ; !(i >= 12); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 10); j = j + 1)
    {
      (d + (signed long int)k)->x = x + j * w1;
      (d + (signed long int)k)->y = y + i * h1;
      k = k + 1;
    }
  }
  (d + (signed long int)k)->x = x;
  (d + (signed long int)k)->y = y + 12 * h1;
  (d + (signed long int)k)->w = 2 * w2 + 2;
  k = k + 1;
  j = 0;
  for( ; !(j >= 6); j = j + 1)
  {
    (d + (signed long int)k)->x = x + (j + 2) * w1;
    (d + (signed long int)k)->y = y + 12 * h1;
    k = k + 1;
  }
  (d + (signed long int)k)->x = x + 8 * w1;
  (d + (signed long int)k)->y = y + 12 * h1;
  (d + (signed long int)k)->w = 2 * w2 + 2;
}

// parse_line
// file wwwcli.c line 199
static signed int parse_line(struct anonymous_15 *result, char **str)
{
  signed int ok = 0;
  char temp[100l];
  memset((void *)result, 0, sizeof(struct anonymous_15) /*196ul*/ );
  signed int return_value_read_string_17;
  return_value_read_string_17=read_string(result->ip, str, (signed int)sizeof(char [16l]) /*16ul*/ );
  signed int return_value_read_separator_16;
  signed int return_value_read_int_15;
  signed int return_value_read_separator_14;
  signed int return_value_read_string_13;
  signed int return_value_read_separator_12;
  signed int return_value_read_string_11;
  signed int return_value_read_separator_10;
  signed int return_value_read_int_9;
  signed int return_value_read_separator_8;
  signed int return_value_read_int_7;
  signed int return_value_read_separator_6;
  signed int return_value_read_int_5;
  signed int return_value_read_separator_4;
  signed int return_value_read_int_3;
  signed int return_value_read_separator_2;
  signed int return_value_read_string_1;
  if(!(return_value_read_string_17 == 0))
  {
    return_value_read_separator_16=read_separator_link1(str);
    if(!(return_value_read_separator_16 == 0))
    {
      return_value_read_int_15=read_int(&result->port, str);
      if(!(return_value_read_int_15 == 0))
      {
        return_value_read_separator_14=read_separator_link1(str);
        if(!(return_value_read_separator_14 == 0))
        {
          return_value_read_string_13=read_string(temp, str, (signed int)sizeof(char [100l]) /*100ul*/ );
          if(!(return_value_read_string_13 == 0))
          {
            return_value_read_separator_12=read_separator_link1(str);
            if(!(return_value_read_separator_12 == 0))
            {
              return_value_read_string_11=read_string(temp, str, (signed int)sizeof(char [100l]) /*100ul*/ );
              if(!(return_value_read_string_11 == 0))
              {
                return_value_read_separator_10=read_separator_link1(str);
                if(!(return_value_read_separator_10 == 0))
                {
                  return_value_read_int_9=read_int(&result->uptime, str);
                  if(!(return_value_read_int_9 == 0))
                  {
                    return_value_read_separator_8=read_separator_link1(str);
                    if(!(return_value_read_separator_8 == 0))
                    {
                      return_value_read_int_7=read_int(&result->busy_players, str);
                      if(!(return_value_read_int_7 == 0))
                      {
                        return_value_read_separator_6=read_separator_link1(str);
                        if(!(return_value_read_separator_6 == 0))
                        {
                          return_value_read_int_5=read_int(&result->max_players, str);
                          if(!(return_value_read_int_5 == 0))
                          {
                            return_value_read_separator_4=read_separator_link1(str);
                            if(!(return_value_read_separator_4 == 0))
                            {
                              return_value_read_int_3=read_int(&result->password, str);
                              if(!(return_value_read_int_3 == 0))
                              {
                                return_value_read_separator_2=read_separator_link1(str);
                                if(!(return_value_read_separator_2 == 0))
                                {
                                  return_value_read_string_1=read_string(result->comment, str, (signed int)sizeof(char [101l]) /*101ul*/ );
                                  if(!(return_value_read_string_1 == 0))
                                  {
                                    memset((void *)result->label, 0, sizeof(char [50l]) /*50ul*/ );
                                    snprintf(result->label, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "%s (%d/%d)", (const void *)result->ip, result->busy_players, result->max_players);
                                    result->label[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
                                    result->ping_delay=lw_ping_try_server(result->ip, result->port);
                                    ok = 1;
                                  }

                                }

                              }

                            }

                          }

                        }

                      }

                    }

                  }

                }

              }

            }

          }

        }

      }

    }

  }

  next_line(str);
  return ok;
}

// place_all_team
// file army.c line 192
void place_all_team(void)
{
  signed int i;
  signed int j;
  signed int n;
  i = 0;
  for( ; !(i >= 6); i = i + 1)
    ACTIVE_FIGHTERS[(signed long int)i] = 0;
  n = 0;
  if(!(LW_NETWORK_ON == 0))
  {
    j = 0;
    for( ; !(j >= 6) && !(n >= 6); j = j + 1)
    {
      i = 0;
      for( ; !(i >= 6) && !(n >= 6); i = i + 1)
        if(!(LW_NETWORK_INFO[(signed long int)i].active == 0))
        {
          if(LW_NETWORK_INFO[(signed long int)i].part == j)
          {
            place_team(LW_NETWORK_INFO[(signed long int)i].part, LW_NETWORK_INFO[(signed long int)i].server_id);
            auto_cursor(i, LW_NETWORK_INFO[(signed long int)i].server_id, LW_NETWORK_INFO[(signed long int)i].name);
            n = n + 1;
          }

        }

    }
  }

  else
  {
    i = 0;
    for( ; !(i >= 6) && !(n >= 6); i = i + 1)
      if(!(CONFIG_CONTROL_TYPE[(signed long int)i] == 0))
      {
        place_team(i, n);
        auto_cursor(i, n, CONFIG_PLAYER_NAME[(signed long int)i]);
        n = n + 1;
      }

  }
}

// place_team
// file army.c line 119
static void place_team(signed int part, signed int team)
{
  signed int placed;
  signed int x;
  signed int y;
  signed int x_min;
  signed int y_min;
  signed int x_max;
  signed int y_max;
  signed int fighters;
  signed int health;
  struct anonymous_21 *pos;
  fighters = CURRENT_ARMY_SIZE / PLAYING_TEAMS;
  ACTIVE_FIGHTERS[(signed long int)team] = 0;
  health = 16384 - 1;
  switch(part)
  {
    case 0:
    {
      x = CURRENT_AREA_W / 6;
      y = CURRENT_AREA_H / 4;
      break;
    }
    case 1:
    {
      x = CURRENT_AREA_W / 2;
      y = CURRENT_AREA_H / 4;
      break;
    }
    case 2:
    {
      x = (5 * CURRENT_AREA_W) / 6;
      y = CURRENT_AREA_H / 4;
      break;
    }
    case 3:
    {
      x = CURRENT_AREA_W / 6;
      y = (3 * CURRENT_AREA_H) / 4;
      break;
    }
    case 4:
    {
      x = CURRENT_AREA_W / 2;
      y = (3 * CURRENT_AREA_H) / 4;
      break;
    }
    default:
    {
      x = (5 * CURRENT_AREA_W) / 6;
      y = (3 * CURRENT_AREA_H) / 4;
    }
  }
  x_max = x;
  x_min = x_max;
  y_max = y;
  y_min = y_max;
  pos = CURRENT_ARMY + (signed long int)team;
  placed = 0;
  signed int return_value_add_fighter_1;
  signed int return_value_add_fighter_2;
  signed int return_value_add_fighter_3;
  signed int return_value_add_fighter_4;
  while(!(placed >= fighters))
  {
    x = x_min;
    for( ; x_max >= x && !(placed >= fighters); x = x + 1)
    {
      return_value_add_fighter_1=add_fighter(pos + (signed long int)(placed * PLAYING_TEAMS), team, x, y_min, health);
      placed = placed + return_value_add_fighter_1;
    }
    if(!(x_max >= CURRENT_AREA_W + -2))
      x_max = x_max + 1;

    y = y_min;
    for( ; y_max >= y && !(placed >= fighters); y = y + 1)
    {
      return_value_add_fighter_2=add_fighter(pos + (signed long int)(placed * PLAYING_TEAMS), team, x_max, y, health);
      placed = placed + return_value_add_fighter_2;
    }
    if(!(y_max >= CURRENT_AREA_H + -2))
      y_max = y_max + 1;

    x = x_max;
    for( ; x >= x_min && !(placed >= fighters); x = x - 1)
    {
      return_value_add_fighter_3=add_fighter(pos + (signed long int)(placed * PLAYING_TEAMS), team, x, y_max, health);
      placed = placed + return_value_add_fighter_3;
    }
    if(x_min >= 2)
      x_min = x_min - 1;

    y = y_max;
    for( ; y >= y_min && !(placed >= fighters); y = y - 1)
    {
      return_value_add_fighter_4=add_fighter(pos + (signed long int)(placed * PLAYING_TEAMS), team, x_min, y, health);
      placed = placed + return_value_add_fighter_4;
    }
    if(y_min >= 2)
      y_min = y_min - 1;

  }
}

// play_click
// file sound.h line 66
void play_click(void)
{
  if(!(LOADED_SFX == 0))
  {
    signed int return_value_lw_mutex_trylock_1;
    static struct anonymous_1 mutex = { .data=(void *)0 };
    return_value_lw_mutex_trylock_1=lw_mutex_trylock(&mutex);
    if(!(return_value_lw_mutex_trylock_1 == 0))
    {
      my_play_sample(SAMPLE_SFX_CLICK, CONFIG_CLICK_VOLUME);
      lw_mutex_unlock(&mutex);
    }

    else
      log_println_str("Warning: too many calls to \"play_click\"...");
  }

}

// play_connect
// file sound.h line 71
void play_connect(void)
{
  if(!(LOADED_SFX == 0))
    my_play_sample(SAMPLE_SFX_CONNECT, CONFIG_SFX_VOLUME);

}

// play_go
// file sound.h line 67
void play_go(void)
{
  if(!(LOADED_SFX == 0))
    my_play_sample(SAMPLE_SFX_GO, CONFIG_SFX_VOLUME);

}

// play_loose
// file sound.h line 70
void play_loose(void)
{
  if(!(LOADED_SFX == 0))
    my_play_sample(SAMPLE_SFX_LOOSE, CONFIG_SFX_VOLUME);

}

// play_sequence
// file play.h line 66
signed int play_sequence(void)
{
  signed int result;
  lw_config_set_current_rules_to_default();
  result=play_sequence_ex();
  return result;
}

// play_sequence_ex
// file play.h line 67
signed int play_sequence_ex(void)
{
  char *message;
  signed int result;
  signed int retour = 0;
  struct DIALOG d[2l];
  struct DIALOG_PLAYER *dp;
  signed int flip_enabled = 0;
  memset((void *)d, 0, sizeof(struct DIALOG [2l]) /*144ul*/ );
  d[(signed long int)1].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
  display_back_image();
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(21);
  main_message(d, return_value_lw_lang_string_1);
  dp=my_init_dialog(d, 0);
  my_update_dialog(dp);
  shutdown_dialog(dp);
  lw_maptex_set_fg_palette(CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, LW_NETWORK_ON, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
  lw_maptex_set_bg_palette(CONFIG_LEVEL_MAP, CONFIG_LEVEL_BG, LW_NETWORK_ON, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
  calc_playing_teams();
  set_playing_teams_palette();
  if(!(PLAYING_TEAMS >= 2))
  {
    free_game_memory();
    error_not_enough_teams();
  }

  else
  {
    message=init_game();
    if(message == ((char *)NULL))
    {
      WATER_VOLUME = CONFIG_WATER_VOLUME_GAME;
      my_fade_out();
      signed int return_value_need_to_change_mode_2;
      return_value_need_to_change_mode_2=need_to_change_mode(CONFIG_GFX_GAME, CONFIG_GFX_MENU, CONFIG_PAGE_FLIP);
      if(!(return_value_need_to_change_mode_2 == 0))
        result=set_resolution(CONFIG_GFX_GAME, CONFIG_PAGE_FLIP, CONFIG_FULLSCREEN, &flip_enabled);

      lw_mouse_hide();
      signed int return_value_blank_round_3;
      return_value_blank_round_3=blank_round();
      if(return_value_blank_round_3 == 0)
      {
        my_fade_in();
        start_music();
        game();
        stop_music();
      }

      free_game_memory();
      lw_sock_close(&LW_KEYEXCH_SOCK);
      WATER_VOLUME = CONFIG_WATER_VOLUME_MENU;
      my_fade_out();
      signed int return_value_need_to_change_mode_4;
      return_value_need_to_change_mode_4=need_to_change_mode(CONFIG_GFX_GAME, CONFIG_GFX_MENU, (signed int)(CONFIG_PAGE_FLIP != 0 && flip_enabled != 0));
      if(!(return_value_need_to_change_mode_4 == 0))
        result=set_resolution(CONFIG_GFX_MENU, 0, CONFIG_FULLSCREEN, (signed int *)(void *)0);

      lw_mouse_show();
      retour=display_scores();
    }

    else
    {
      free_game_memory();
      lw_sock_close(&LW_KEYEXCH_SOCK);
      error_not_enough_big_data();
    }
  }
  return retour;
}

// play_time
// file sound.c line 204
void play_time(void)
{
  if(!(LOADED_SFX == 0))
    my_play_sample(SAMPLE_SFX_TIME, CONFIG_SFX_VOLUME);

}

// play_win
// file sound.h line 68
void play_win(void)
{
  if(!(LOADED_SFX == 0))
    my_play_sample(SAMPLE_SFX_WIN, CONFIG_SFX_VOLUME);

}

// position_chat_history
// file connect.c line 567
static void position_chat_history(struct DIALOG *d)
{
  d->x = (320 - 3) / 2 - 150;
  d->y = (240 - 175) / 2;
  d->w = 150;
  d->h = 175;
  color_one_dialog(d);
  menu_real_coord(d);
  d->key = 0;
  d->dp = (void *)"";
  d->flags = 1;
}

// position_comment
// file internet.c line 266
static void position_comment(struct DIALOG *d)
{
  d->x = (320 + 3) / 2;
  d->y = (240 - 175) / 2 + 7 * 15 + 7 * 3;
  d->w = 150;
  d->h = 3 * 15 + (3 * 3) / 2;
  color_one_dialog(d);
  menu_real_coord(d);
  d->key = 0;
  d->dp = (void *)"";
  d->flags = 1;
}

// position_list
// file internet.c line 250
static void position_list(struct DIALOG *d)
{
  d->x = (320 - 3) / 2 - 150;
  d->y = (240 - 175) / 2;
  d->w = 150;
  d->h = 175;
  color_one_dialog(d);
  menu_real_coord(d);
  d->key = 0;
  d->dp = (void *)"";
  d->flags = 1;
}

// position_players_list
// file connect.c line 552
static void position_players_list(struct DIALOG *d)
{
  d->x = (320 + 3) / 2;
  d->y = (240 - 175) / 2 + 15 + 3;
  d->w = (100 + 150) / 2;
  d->h = 4 * 15 + 3 * 3;
  color_one_dialog(d);
  menu_real_coord(d);
}

// prepare_help
// file help.c line 74
void prepare_help(struct DIALOG *d, char *str)
{
  quick_buttons(d);
  color_one_dialog(d + (signed long int)4);
  (d + (signed long int)4)->proc = my_textbox_proc;
  (d + (signed long int)4)->d2 = 0;
  (d + (signed long int)4)->dp = (void *)str;
  (d + (signed long int)4)->key = 0;
  (d + (signed long int)4)->flags = 0;
  (d + (signed long int)4)->x = (3 * 3) / 2 + 60;
  (d + (signed long int)4)->y = (3 * 3) / 2 + 15;
  (d + (signed long int)4)->w = (320 - 3 * 3) - 60 * 2;
  (d + (signed long int)4)->h = (240 - 3 * 3) - 15 * 2;
  menu_real_coord(d + (signed long int)4);
  (d + (signed long int)5)->proc = (signed int (*)(signed int, struct DIALOG *, signed int))(void *)0;
}

// prepare_wave_shapes
// file distor.c line 243
void prepare_wave_shapes(void)
{
  signed int w;
  signed int h;
  signed int x;
  signed int y;
  signed int i;
  w = DISTORSION_TARGET->w;
  h = DISTORSION_TARGET->h;
  create_wave_line(WAVE_SHAPE_WX, w, CONFIG_WAVE_NUMBER[(signed long int)0], CONFIG_WAVE_AMPLI[(signed long int)0] * CURRENT_AREA_W, CONFIG_WAVE_SPEED[(signed long int)0], +1);
  create_wave_line(WAVE_SHAPE_HY, h, CONFIG_WAVE_NUMBER[(signed long int)1], CONFIG_WAVE_AMPLI[(signed long int)1] * CURRENT_AREA_H, CONFIG_WAVE_SPEED[(signed long int)1], +1);
  create_wave_line(WAVE_SHAPE_WY[(signed long int)(DISTORSION_H + 1)], w, CONFIG_WAVE_NUMBER[(signed long int)2], CONFIG_WAVE_AMPLI[(signed long int)2] * CURRENT_AREA_H, CONFIG_WAVE_SPEED[(signed long int)2], +1);
  create_wave_line(WAVE_SHAPE_HX[(signed long int)(DISTORSION_W + 1)], h, CONFIG_WAVE_NUMBER[(signed long int)3], CONFIG_WAVE_AMPLI[(signed long int)3] * CURRENT_AREA_W, CONFIG_WAVE_SPEED[(signed long int)3], +1);
  x = 0;
  for( ; !(x >= w); x = x + 1)
  {
    WAVE_SHAPE_WX[(signed long int)x] = WAVE_SHAPE_WX[(signed long int)x] + CURRENT_AREA_W * 4096;
    WAVE_SHAPE_WY[(signed long int)0][(signed long int)x] = 0;
    WAVE_SHAPE_WY[(signed long int)1][(signed long int)x] = WAVE_SHAPE_WY[(signed long int)(DISTORSION_H + 1)][(signed long int)x] / DISTORSION_H;
    i = 1;
    for( ; !(i >= DISTORSION_H); i = i + 1)
      WAVE_SHAPE_WY[(signed long int)(i + 1)][(signed long int)x] = WAVE_SHAPE_WY[(signed long int)i][(signed long int)x] + WAVE_SHAPE_WY[(signed long int)1][(signed long int)x];
  }
  y = 0;
  for( ; !(y >= h); y = y + 1)
  {
    WAVE_SHAPE_HY[(signed long int)y] = WAVE_SHAPE_HY[(signed long int)y] + CURRENT_AREA_H * 4096;
    WAVE_SHAPE_HX[(signed long int)0][(signed long int)y] = 0;
    WAVE_SHAPE_HX[(signed long int)1][(signed long int)y] = WAVE_SHAPE_HX[(signed long int)(DISTORSION_W + 1)][(signed long int)y] / DISTORSION_W;
    i = 1;
    for( ; !(i >= DISTORSION_W); i = i + 1)
      WAVE_SHAPE_HX[(signed long int)(i + 1)][(signed long int)y] = WAVE_SHAPE_HX[(signed long int)i][(signed long int)y] + WAVE_SHAPE_HX[(signed long int)1][(signed long int)y];
  }
}

// putpixel
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel(struct BITMAP *bmp, signed int x, signed int y, signed int color)
{
  bmp->vtable->putpixel(bmp, x, y, color);
}

// putpixel_link1
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link1(struct BITMAP *bmp_link1, signed int x_link1, signed int y_link1, signed int color_link1)
{
  bmp_link1->vtable->putpixel(bmp_link1, x_link1, y_link1, color_link1);
}

// putpixel_link2
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link2(struct BITMAP *bmp_link2, signed int x_link2, signed int y_link2, signed int color_link2)
{
  bmp_link2->vtable->putpixel(bmp_link2, x_link2, y_link2, color_link2);
}

// putpixel_link3
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link3(struct BITMAP *bmp_link3, signed int x_link3, signed int y_link3, signed int color_link3)
{
  bmp_link3->vtable->putpixel(bmp_link3, x_link3, y_link3, color_link3);
}

// putpixel_link4
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link4(struct BITMAP *bmp_link4, signed int x_link4, signed int y_link4, signed int color_link4)
{
  bmp_link4->vtable->putpixel(bmp_link4, x_link4, y_link4, color_link4);
}

// putpixel_link5
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link5(struct BITMAP *bmp_link5, signed int x_link5, signed int y_link5, signed int color_link5)
{
  bmp_link5->vtable->putpixel(bmp_link5, x_link5, y_link5, color_link5);
}

// putpixel_link6
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link6(struct BITMAP *bmp_link6, signed int x_link6, signed int y_link6, signed int color_link6)
{
  bmp_link6->vtable->putpixel(bmp_link6, x_link6, y_link6, color_link6);
}

// putpixel_link7
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link7(struct BITMAP *bmp_link7, signed int x_link7, signed int y_link7, signed int color_link7)
{
  bmp_link7->vtable->putpixel(bmp_link7, x_link7, y_link7, color_link7);
}

// putpixel_link8
// file /usr/include/allegro/inline/draw.inl line 38
static inline void putpixel_link8(struct BITMAP *bmp_link8, signed int x_link8, signed int y_link8, signed int color_link8)
{
  bmp_link8->vtable->putpixel(bmp_link8, x_link8, y_link8, color_link8);
}

// quick_buttons
// file dialog.h line 107
void quick_buttons(struct DIALOG *d)
{
  signed int i;
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(17);
  (d + (signed long int)0)->dp = (void *)return_value_lw_lang_string_1;
  char *return_value_lw_lang_string_2;
  return_value_lw_lang_string_2=lw_lang_string(18);
  (d + (signed long int)3)->dp = (void *)return_value_lw_lang_string_2;
  char *return_value_lw_lang_string_3;
  return_value_lw_lang_string_3=lw_lang_string(19);
  (d + (signed long int)1)->dp = (void *)return_value_lw_lang_string_3;
  char *return_value_lw_lang_string_4;
  return_value_lw_lang_string_4=lw_lang_string(20);
  (d + (signed long int)2)->dp = (void *)return_value_lw_lang_string_4;
  (d + (signed long int)0)->key = 113;
  (d + (signed long int)3)->key = 98;
  (d + (signed long int)1)->key = 104;
  (d + (signed long int)2)->key = 109;
  (d + (signed long int)0)->x = 3 / 2;
  (d + (signed long int)3)->x = (d + (signed long int)0)->x;
  (d + (signed long int)2)->x = ((320 - 1) - 3 / 2) - 60;
  (d + (signed long int)1)->x = (d + (signed long int)2)->x;
  (d + (signed long int)1)->y = 3 / 2;
  (d + (signed long int)3)->y = (d + (signed long int)1)->y;
  (d + (signed long int)2)->y = ((240 - 1) - 3 / 2) - 15;
  (d + (signed long int)0)->y = (d + (signed long int)2)->y;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    (d + (signed long int)i)->proc = my_button_proc;
    (d + (signed long int)i)->flags = 1;
    (d + (signed long int)i)->h = 15;
    (d + (signed long int)i)->w = 60;
    color_one_dialog(d + (signed long int)i);
    menu_real_coord(d + (signed long int)i);
  }
}

// random_free_xy_by_control_type
// file autoplay.c line 185
static signed int random_free_xy_by_control_type(signed int *x, signed int *y, signed int team, signed int control_type)
{
  signed int i;
  signed int found = 0;
  signed int foundable = 0;
  signed int control_type_array[6l];
  signed int random_limit;
  i = 0;
  for( ; !(i >= 6); i = i + 1)
    control_type_array[(signed long int)i] = 0;
  i = 0;
  for( ; !(i >= 6); i = i + 1)
    if(CURRENT_CURSOR[(signed long int)i].control_type == control_type || control_type == 0)
    {
      if(!(CURRENT_CURSOR[(signed long int)i].active == 0))
        control_type_array[(signed long int)CURRENT_CURSOR[(signed long int)i].team] = control_type;

    }

  i = 0;
  _Bool tmp_if_expr_1;
  for( ; foundable == 0 && !(i >= CURRENT_ARMY_SIZE); i = i + 1)
  {
    if(!((signed int)(CURRENT_ARMY + (signed long int)i)->team == team))
      tmp_if_expr_1 = (control_type_array[(signed long int)(signed int)(CURRENT_ARMY + (signed long int)i)->team] == control_type ? (_Bool)1 : (control_type == 0 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    foundable = foundable | (signed int)tmp_if_expr_1;
  }
  _Bool tmp_if_expr_3;
  if(!(foundable == 0))
  {
    random_limit = 0;
    while(found == 0 && !(random_limit >= 10000))
    {
      signed long int return_value_random_2;
      return_value_random_2=random();
      i = (signed int)(return_value_random_2 % (signed long int)CURRENT_ARMY_SIZE);
      if(!((signed int)(CURRENT_ARMY + (signed long int)i)->team == team))
        tmp_if_expr_3 = (control_type_array[(signed long int)(signed int)(CURRENT_ARMY + (signed long int)i)->team] == control_type ? (_Bool)1 : (control_type == 0 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      found = (signed int)tmp_if_expr_3;
      random_limit = random_limit + 1;
    }
  }

  if(found == 0)
  {
    signed long int return_value_random_4;
    return_value_random_4=random();
    i = (signed int)(return_value_random_4 % (signed long int)CURRENT_ARMY_SIZE);
  }

  *x = (signed int)(CURRENT_ARMY + (signed long int)i)->x;
  *y = (signed int)(CURRENT_ARMY + (signed long int)i)->y;
  return found;
}

// random_free_xy_different_team
// file autoplay.c line 244
static void random_free_xy_different_team(signed int *x, signed int *y, signed int team)
{
  signed int control_type = 0;
  switch(LW_CONFIG_CURRENT_RULES.cpu_vs_human)
  {
    case 0:
    {
      control_type = 1;
      break;
    }
    case 2:
    {
      control_type = 2;
      break;
    }
    default:
      control_type = 0;
  }
  signed int return_value_random_free_xy_by_control_type_1;
  return_value_random_free_xy_by_control_type_1=random_free_xy_by_control_type(x, y, team, control_type);
  if(return_value_random_free_xy_by_control_type_1 == 0)
    random_free_xy_by_control_type(x, y, team, 0);

}

// read_back_dat
// file disk.c line 233
static void read_back_dat(struct DATAFILE *df)
{
  signed int i;
  signed int x;
  signed int y;
  BACK_PALETTE = (struct RGB *)(df + (signed long int)1)->dat;
  BACK_IMAGE = (struct BITMAP *)(df + (signed long int)0)->dat;
  i = 0;
  for( ; !(i >= 46); i = i + 1)
    GLOBAL_PALETTE[(signed long int)(i + 18)] = BACK_PALETTE[(signed long int)i];
  x = 0;
  for( ; !(x >= BACK_IMAGE->w); x = x + 1)
  {
    y = 0;
    for( ; !(y >= BACK_IMAGE->w); y = y + 1)
    {
      signed int return_value_getpixel_1;
      return_value_getpixel_1=getpixel(BACK_IMAGE, x, y);
      putpixel_link1(BACK_IMAGE, x, y, return_value_getpixel_1 + 18);
    }
  }
}

// read_command_line
// file parser.h line 68
void read_command_line(signed int argc, char **argv)
{
  signed int i;
  signed int j;
  char *str;
  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    ARGUMENT_VALUE[(signed long int)i] = "";
    ARGUMENT_NAME[(signed long int)i] = ARGUMENT_VALUE[(signed long int)i];
  }
  EXECUTABLE_NAME = argv[(signed long int)0];
  str = EXECUTABLE_NAME;
  _Bool tmp_if_expr_1;
  for( ; !(*str == 0); str = str + 1l)
  {
    if((signed int)*str == 47)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)*str == 92 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      EXECUTABLE_NAME = str + (signed long int)1;

  }
  i = 1;
  j = 0;
  for( ; !(i >= argc) && !(j >= 256); i = i + 1)
  {
    str = argv[(signed long int)i];
    signed int return_value_is_arg_marker_3;
    return_value_is_arg_marker_3=is_arg_marker(str[(signed long int)0]);
    if(!(return_value_is_arg_marker_3 == 0))
    {
      ARGUMENT_NAME[(signed long int)j] = str + (signed long int)1;
      if(!(i >= argc + -1))
      {
        str = argv[(signed long int)(i + 1)];
        signed int return_value_is_arg_marker_2;
        return_value_is_arg_marker_2=is_arg_marker(str[(signed long int)0]);
        if(return_value_is_arg_marker_2 == 0)
        {
          ARGUMENT_VALUE[(signed long int)j] = str;
          i = i + 1;
        }

      }

      j = j + 1;
    }

  }
}

// read_eol
// file wwwcli.c line 365
static signed int read_eol(char **str)
{
  signed int ok = 0;
  char c;
  skip_space(str);
  c = *(*str);
  if((signed int)c == 10)
  {
    *str = *str + 1l;
    ok = 1;
  }

  skip_space(str);
  return ok;
}

// read_eol_n
// file wwwcli.c line 390
static signed int read_eol_n(char **str, signed int n)
{
  signed int ok = 0;
  char *tmp;
  skip_space(str);
  char *return_value___builtin_strchr_1;
  return_value___builtin_strchr_1=__builtin_strchr(*str, 10);
  tmp = return_value___builtin_strchr_1;
  if(!(tmp == ((char *)NULL)))
  {
    if(!(tmp - *str >= (signed long int)n))
    {
      ok = 1;
      *str = tmp + (signed long int)1;
      skip_space(str);
    }

  }

  return ok;
}

// read_font_dat
// file disk.c line 275
static void read_font_dat(struct DATAFILE *df)
{
  signed int i;
  FONT_PALETTE = (struct RGB *)(df + (signed long int)4)->dat;
  SMALL_FONT = (struct FONT *)(df + (signed long int)0)->dat;
  BIG_FONT = (struct FONT *)(df + (signed long int)1)->dat;
  SMALL_MOUSE_CURSOR = (struct BITMAP *)(df + (signed long int)2)->dat;
  BIG_MOUSE_CURSOR = (struct BITMAP *)(df + (signed long int)3)->dat;
  INVISIBLE_MOUSE_CURSOR = (struct BITMAP *)(df + (signed long int)5)->dat;
  i = 1;
  for( ; !(i >= 18); i = i + 1)
    GLOBAL_PALETTE[(signed long int)i] = FONT_PALETTE[(signed long int)i];
}

// read_int
// file wwwcli.c line 311
static signed int read_int(signed int *result, char **str)
{
  signed int ok = 0;
  char c;
  *result = 0;
  skip_space(str);
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    c = *(*str);
    if((2048 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)c]) == 0)
      break;

    *str = *str + 1l;
    *result = *result * 10;
    *result = *result + ((signed int)c - 48);
    ok = 1;
  }
  while((_Bool)1);
  skip_space(str);
  return ok;
}

// read_map_dat
// file disk.c line 219
static void read_map_dat(struct DATAFILE *df)
{
  signed int i;
  RAW_MAP_NUMBER = 0;
  i = 0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(i >= 512))
      tmp_if_expr_1 = (df + (signed long int)i)->type != -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    RAW_MAP[(signed long int)i] = (df + (signed long int)i)->dat;
    RAW_MAP_NUMBER = RAW_MAP_NUMBER + 1;
    i = i + 1;
  }
  while((_Bool)1);
}

// read_maptex_dat
// file disk.c line 205
static void read_maptex_dat(struct DATAFILE *df)
{
  signed int i;
  RAW_MAPTEX_NUMBER = 0;
  i = 0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(i >= 512))
      tmp_if_expr_1 = (df + (signed long int)i)->type != -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    RAW_MAPTEX[(signed long int)i] = (df + (signed long int)i)->dat;
    RAW_MAPTEX_NUMBER = RAW_MAPTEX_NUMBER + 1;
    i = i + 1;
  }
  while((_Bool)1);
}

// read_music_dat
// file disk.c line 292
static void read_music_dat(struct DATAFILE *df)
{
  signed int i;
  MIDI_MUSIC_NUMBER = 0;
  i = 0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(i >= 128))
      tmp_if_expr_1 = (df + (signed long int)i)->type != -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    MIDI_MUSIC[(signed long int)i] = (struct MIDI *)(df + (signed long int)i)->dat;
    MIDI_MUSIC_NUMBER = MIDI_MUSIC_NUMBER + 1;
    i = i + 1;
  }
  while((_Bool)1);
}

// read_separator
// file netmess.c line 109
static signed int read_separator(char **message)
{
  signed int result = 0;
  eat_space(message);
  if((signed int)*(*message) == 44)
  {
    result = result + 1;
    *message = *message + 1l;
  }

  eat_space(message);
  return result;
}

// read_separator_link1
// file wwwcli.c line 340
static signed int read_separator_link1(char **str)
{
  signed int ok = 0;
  char c;
  skip_space(str);
  c = *(*str);
  if((signed int)c == 44)
  {
    *str = *str + 1l;
    ok = 1;
  }

  skip_space(str);
  return ok;
}

// read_sfx_dat
// file disk.c line 138
static void read_sfx_dat(struct DATAFILE *df)
{
  struct SAMPLE *list[6l];
  signed int i = 0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(i >= 6))
      tmp_if_expr_1 = (df + (signed long int)i)->type != -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    list[(signed long int)i] = (struct SAMPLE *)(df + (signed long int)0)->dat;
    i = i + 1;
  }
  while((_Bool)1);
  i = 0;
  _Bool tmp_if_expr_2;
  do
  {
    if(!(i >= 6))
      tmp_if_expr_2 = (df + (signed long int)i)->type != -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    list[(signed long int)i] = (struct SAMPLE *)(df + (signed long int)i)->dat;
    lock_sound(list[(signed long int)i]);
    i = i + 1;
  }
  while((_Bool)1);
  SAMPLE_SFX_TIME = list[(signed long int)0];
  SAMPLE_SFX_WIN = list[(signed long int)1];
  SAMPLE_SFX_CONNECT = list[(signed long int)2];
  SAMPLE_SFX_GO = list[(signed long int)3];
  SAMPLE_SFX_CLICK = list[(signed long int)4];
  SAMPLE_SFX_LOOSE = list[(signed long int)5];
}

// read_string
// file wwwcli.c line 259
static signed int read_string(char *result, char **str, signed int size)
{
  signed int i = 0;
  signed int done = 0;
  char c;
  skip_space(str);
  c = *(*str);
  signed int tmp_post_1;
  signed int tmp_post_2;
  if((signed int)c == 39)
  {
    *str = *str + 1l;
    do
    {
      c = *(*str);
      if((signed int)c == 0)
        break;

      if((signed int)c == 10)
        break;

      if(!(done == 0))
        break;

      *str = *str + 1l;
      if((signed int)c == 39)
      {
        if((signed int)*(*str) == 39)
        {
          *str = *str + 1l;
          if(!(i >= size + -1))
          {
            tmp_post_1 = i;
            i = i + 1;
            result[(signed long int)tmp_post_1] = (char)39;
          }

        }

        else
          done = 1;
      }

      else
        if(!(i >= size + -1))
        {
          tmp_post_2 = i;
          i = i + 1;
          result[(signed long int)tmp_post_2] = c;
        }

    }
    while((_Bool)1);
  }

  signed int tmp_post_3 = i;
  i = i + 1;
  result[(signed long int)tmp_post_3] = (char)0;
  skip_space(str);
  return done;
}

// read_texture_dat
// file disk.c line 191
static void read_texture_dat(struct DATAFILE *df)
{
  signed int i;
  RAW_TEXTURE_NUMBER = 0;
  i = 0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(i >= 512))
      tmp_if_expr_1 = (df + (signed long int)i)->type != -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    RAW_TEXTURE[(signed long int)i] = (df + (signed long int)i)->dat;
    RAW_TEXTURE_NUMBER = RAW_TEXTURE_NUMBER + 1;
    i = i + 1;
  }
  while((_Bool)1);
}

// read_water_dat
// file disk.c line 173
static void read_water_dat(struct DATAFILE *df)
{
  signed int i = 0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(i >= 32))
      tmp_if_expr_1 = (df + (signed long int)i)->type != -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    SAMPLE_WATER[(signed long int)i] = (struct SAMPLE *)(df + (signed long int)i)->dat;
    lock_sound(SAMPLE_WATER[(signed long int)i]);
    SAMPLE_WATER_NUMBER = SAMPLE_WATER_NUMBER + 1;
    i = i + 1;
  }
  while((_Bool)1);
}

// read_word
// file netmess.c line 130
static char * read_word(char **message)
{
  char *begin = (char *)(void *)0;
  char *result = (char *)(void *)0;
  signed int len;
  char quote_char;
  eat_space(message);
  quote_char = *(*message);
  const unsigned short int **return_value___ctype_b_loc_1;
  if((signed int)quote_char == 34 || (signed int)quote_char == 39)
  {
    *message = *message + 1l;
    begin = *message;
    for( ; !(*(*message) == quote_char); *message = *message + 1l)
      if((signed int)*(*message) == 0)
        break;

    len = (signed int)(*message - begin);
    *message = *message + 1l;
  }

  else
  {
    begin = *message;
    do
    {
      return_value___ctype_b_loc_1=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*(*message)]) == 0))
        break;

      if((signed int)*(*message) == 44)
        break;

      if((signed int)*(*message) == 0)
        break;

      *message = *message + 1l;
    }
    while((_Bool)1);
    len = (signed int)(*message - begin);
  }
  if(len >= 0)
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)(len + 1));
    result = (char *)return_value_malloc_2;
    if(!(result == ((char *)NULL)))
    {
      if(len >= 1)
        __builtin_strncpy(result, begin, (unsigned long int)len);

      result[(signed long int)len] = (char)0;
      lw_netmess_cleanup_arg(result);
    }

  }

  eat_space(message);
  return result;
}

// recalculate_number_of_colors
// file texture.c line 104
static signed int recalculate_number_of_colors(signed int max_number, struct BITMAP *bmp, struct RGB *pal)
{
  signed int i;
  signed int x;
  signed int y;
  signed int n = 1;
  struct RGB color;
  struct RGB pal2[256l];
  signed int return_value_getpixel_1;
  return_value_getpixel_1=getpixel_link6(bmp, 0, 0);
  color = pal[(signed long int)return_value_getpixel_1];
  i = 0;
  for( ; !(i >= 256); i = i + 1)
    pal2[(signed long int)i] = color;
  y = 0;
  signed int tmp_post_3;
  for( ; !(n >= max_number) && !(y >= bmp->h); y = y + 1)
  {
    x = 0;
    for( ; !(n >= max_number) && !(x >= bmp->w); x = x + 1)
    {
      signed int return_value_getpixel_2;
      return_value_getpixel_2=getpixel_link6(bmp, x, y);
      color = pal[(signed long int)return_value_getpixel_2];
      signed int return_value_exist_color_4;
      return_value_exist_color_4=exist_color(pal2, color);
      if(return_value_exist_color_4 == 0)
      {
        tmp_post_3 = n;
        n = n + 1;
        pal2[(signed long int)tmp_post_3] = color;
      }

    }
  }
  return n;
}

// rect
// file /usr/include/allegro/inline/draw.inl line 112
static inline void rect(struct BITMAP *bmp, signed int x1, signed int y_1, signed int x2, signed int y2, signed int color)
{
  bmp->vtable->rect(bmp, x1, y_1, x2, y2, color);
}

// rect_link1
// file /usr/include/allegro/inline/draw.inl line 112
static inline void rect_link1(struct BITMAP *bmp_link1, signed int x1_link1, signed int y_1_link1, signed int x2_link1, signed int y2_link1, signed int color_link1)
{
  bmp_link1->vtable->rect(bmp_link1, x1_link1, y_1_link1, x2_link1, y2_link1, color_link1);
}

// rect_for_viewport
// file viewport.h line 75
void rect_for_viewport(void)
{
  rect_link1(screen, VIEWPORT_X - 1, (VIEWPORT_Y - 1) + PAGE_FLIP_H, VIEWPORT_X + VIEWPORT_W, VIEWPORT_Y + VIEWPORT_H + PAGE_FLIP_H, 17);
}

// rectfill
// file /usr/include/allegro/inline/draw.inl line 88
static inline void rectfill(struct BITMAP *bmp, signed int x1, signed int y_1, signed int x2, signed int y2, signed int color)
{
  bmp->vtable->rectfill(bmp, x1, y_1, x2, y2, color);
}

// rectfill_link1
// file /usr/include/allegro/inline/draw.inl line 88
static inline void rectfill_link1(struct BITMAP *bmp_link1, signed int x1_link1, signed int y_1_link1, signed int x2_link1, signed int y2_link1, signed int color_link1)
{
  bmp_link1->vtable->rectfill(bmp_link1, x1_link1, y_1_link1, x2_link1, y2_link1, color_link1);
}

// rectfill_link2
// file /usr/include/allegro/inline/draw.inl line 88
static inline void rectfill_link2(struct BITMAP *bmp_link2, signed int x1_link2, signed int y_1_link2, signed int x2_link2, signed int y2_link2, signed int color_link2)
{
  bmp_link2->vtable->rectfill(bmp_link2, x1_link2, y_1_link2, x2_link2, y2_link2, color_link2);
}

// rectfill_link3
// file /usr/include/allegro/inline/draw.inl line 88
static inline void rectfill_link3(struct BITMAP *bmp_link3, signed int x1_link3, signed int y_1_link3, signed int x2_link3, signed int y2_link3, signed int color_link3)
{
  bmp_link3->vtable->rectfill(bmp_link3, x1_link3, y_1_link3, x2_link3, y2_link3, color_link3);
}

// rectfill_link4
// file /usr/include/allegro/inline/draw.inl line 88
static inline void rectfill_link4(struct BITMAP *bmp_link4, signed int x1_link4, signed int y_1_link4, signed int x2_link4, signed int y2_link4, signed int color_link4)
{
  bmp_link4->vtable->rectfill(bmp_link4, x1_link4, y_1_link4, x2_link4, y2_link4, color_link4);
}

// recv_keys
// file keyexch.c line 136
static signed int recv_keys(signed int *sock, struct anonymous_23 *cursors)
{
  signed int result = 0;
  signed int i;
  struct anonymous_5 netkey;
  result=lw_netkey_recv(sock, &netkey);
  i = 0;
  for( ; !(i >= 6); i = i + 1)
    (cursors + (signed long int)i)->key_state = netkey.key_states[(signed long int)i];
  if(!(result == 0))
  {
    if(netkey.checksum == 0u)
      log_println_str("Error: incorrect checksum, the game is broken, or someone is cheating");

  }

  return result;
}

// recv_ok
// file protocol.c line 79
static signed int recv_ok(signed int *sock)
{
  signed int result = 0;
  char message[1000l];
  signed int ret = 0;
  struct anonymous_6 *netmess;
  while(*sock >= 0)
  {
    ret=lw_sock_recv_str(sock, message);
    if(!(ret == 0))
      break;

  }
  if(*sock >= 0)
  {
    if(ret >= 1)
    {
      netmess=lw_netmess_read(message);
      if(!(netmess == ((struct anonymous_6 *)NULL)))
      {
        if(netmess->code == 1)
        {
          if(netmess->argc == 0)
            result = 1;

        }

        lw_netmess_free(netmess);
      }

    }

  }

  return result;
}

// red8col
// file texture.c line 205
static void red8col(struct BITMAP *bmp, struct RGB *pal, signed int first_color, signed int number_of_colors)
{
  struct RGB pal2[256l];
  signed int i = 0;
  for( ; !(i >= 256); i = i + 1)
    pal2[(signed long int)i] = pal[(signed long int)i];
  number_of_colors=recalculate_number_of_colors(number_of_colors, bmp, pal);
  create_new_palette(pal, pal2, bmp, first_color, number_of_colors);
  create_converted_bitmap(bmp, pal, pal2, first_color, number_of_colors);
  correct_palette(pal, first_color, number_of_colors);
}

// redraw_team_box
// file team.c line 292
static void redraw_team_box(struct DIALOG *d, signed int number)
{
  signed int i;
  update_team_box(d, number);
  scare_mouse();
  i = 0;
  if(!(i >= 20))
  {
    (d + (signed long int)i)->proc(3, d + (signed long int)i, 0);
    i = i + 1;
  }

  unscare_mouse();
}

// reset_all_cursor
// file cursor.c line 86
void reset_all_cursor(void)
{
  signed int i = 0;
  for( ; !(i >= 6); i = i + 1)
    memset((void *)&CURRENT_CURSOR[(signed long int)i], 0, sizeof(struct anonymous_23) /*56ul*/ );
}

// reset_all_profile
// file profile.h line 70
void reset_all_profile(void)
{
  signed int i = 0;
  for( ; !(i >= 256); i = i + 1)
    reset_profile(i);
}

// reset_big_data
// file bigdata.c line 89
void reset_big_data(void)
{
  BIG_DATA_BOTTOM = 0;
  BIG_DATA_TOP = 64 - 1;
  BIG_DATA_TABLE[(signed long int)BIG_DATA_BOTTOM] = 0;
  BIG_DATA_TABLE[(signed long int)BIG_DATA_TOP] = BIG_DATA_SIZE;
  if(!(BIG_DATA_PTR == NULL))
    memset(BIG_DATA_PTR, 0, (unsigned long int)BIG_DATA_SIZE);

}

// reset_code
// file code.c line 257
void reset_code(void)
{
  GRAD_TO_DISP = 0;
  PAUSE_ON = 0;
}

// reset_computer_path
// file autoplay.c line 172
void reset_computer_path(void)
{
  signed int i = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    COMPUTER_PATH_SIZE[(signed long int)i] = 0;
    COMPUTER_PATH_WAIT[(signed long int)i] = 0;
  }
}

// reset_game_area
// file area.c line 72
void reset_game_area(void)
{
  signed int i;
  signed int k;
  i = 0;
  for( ; !(i >= CURRENT_MESH_SIZE); i = i + 1)
  {
    k = 0;
    for( ; !(k >= 6); k = k + 1)
      (CURRENT_MESH + (signed long int)i)->info[(signed long int)k].state.grad = 2000000;
  }
  i = 0;
  for( ; !(i >= CURRENT_AREA_H * CURRENT_AREA_W); i = i + 1)
    (CURRENT_AREA + (signed long int)i)->fighter = (struct anonymous_21 *)(void *)0;
}

// reset_mesh
// file mesh.h line 132
void reset_mesh(void)
{
  signed int i;
  signed int j;
  i = 0;
  for( ; !(i >= CURRENT_MESH_SIZE); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 6); j = j + 1)
    {
      (CURRENT_MESH + (signed long int)i)->info[(signed long int)j].state.dir = (i + j) % 12;
      (CURRENT_MESH + (signed long int)i)->info[(signed long int)j].update.time = -1;
    }
  }
}

// reset_profile
// file profile.c line 98
void reset_profile(signed int indice)
{
  LOGIC_NUMBER = 0;
  DISPLAY_NUMBER = LOGIC_NUMBER;
  PROFILE_DATA[(signed long int)indice].total_time = 0;
  PROFILE_DATA[(signed long int)indice].record_number = PROFILE_DATA[(signed long int)indice].total_time;
}

// retrieve_choose_level_xy
// file level.c line 135
static void retrieve_choose_level_xy(signed int *x1, signed int *x2, signed int *x3, signed int *x4, signed int *x5, signed int *x6, signed int *x7, signed int *x8, signed int *y1, signed int *y2, signed int *y3, signed int *y4, signed int *y5, signed int *y6, signed int *y7, signed int *y8)
{
  *x1 = (((((320 - 40 * 2) - 15 * 2) - 3 * 2) - 3 * 2) - 160) / 2;
  *x2 = *x1 + 3 + 15;
  *x3 = *x1 + 3 + 40;
  *x4 = *x3 + 15 + 3;
  *x5 = *x4 + 3 + 15;
  *x7 = *x4 + 160 + 3;
  *x6 = (*x7 - 3) - 15;
  *x8 = *x7 + 15 + 3;
  *y1 = (((240 - 15 * 4) - 3 * 4) - 120) / 2;
  *y2 = *y1 + 15 + 3;
  *y3 = *y1 + 40 + 3;
  *y4 = (*y1 + 120) - 15;
  *y5 = *y4 + 15 + 3;
  *y6 = *y5 + 15 + 3;
  *y7 = *y6 + 15 + 3;
  *y8 = *y7 + 15 + 3;
}

// return_d_close
// file error.c line 73
static signed int return_d_close(void)
{
  return 1;
}

// rules_options
// file rules.h line 65
signed int rules_options(void)
{
  signed int *temp;
  struct DIALOG d[15l];
  signed int i;
  signed int choix = 4;
  signed int retour = 0;
  char cis_buffer[30l];
  char time_str[14l];
  char mmr_buffer[50l];
  memset((void *)d, 0, sizeof(struct DIALOG [15l]) /*1080ul*/ );
  memset((void *)time_str, 0, sizeof(char [14l]) /*14ul*/ );
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(56);
  snprintf(time_str, sizeof(char [14l]) /*14ul*/  - (unsigned long int)1, "%-8s00:00", return_value_lw_lang_string_1);
  time_str[(signed long int)(sizeof(char [14l]) /*14ul*/  - (unsigned long int)1)] = (char)0;
  i = 0;
  static signed int y_pos[4l] = { 0, 1, 2, 3 };
  for( ; !(i >= 4); i = i + 1)
  {
    standard_button(d + (signed long int)i + (signed long int)4, 0, y_pos[(signed long int)i], 2, 8);
    d[(signed long int)(i + 4)].proc = my_textbox_proc;
  }
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    standard_button(d + (signed long int)i + (signed long int)8, 1, y_pos[(signed long int)i], 2, 8);
    d[(signed long int)(i + 8)].proc = my_slider_proc;
  }
  standard_button(d + (signed long int)12, 0, 5, 1, 8);
  char *return_value_lw_lang_string_2;
  return_value_lw_lang_string_2=lw_lang_string(57);
  d[(signed long int)12].dp = (void *)return_value_lw_lang_string_2;
  standard_button(d + (signed long int)13, 0, 7, 1, 8);
  char *return_value_lw_lang_string_3;
  return_value_lw_lang_string_3=lw_lang_string(60);
  d[(signed long int)13].dp = (void *)return_value_lw_lang_string_3;
  quick_buttons(d);
  d[(signed long int)4].dp = (void *)time_str;
  char *return_value_lw_lang_string_4;
  return_value_lw_lang_string_4=lw_lang_string(58);
  d[(signed long int)5].dp = (void *)return_value_lw_lang_string_4;
  d[(signed long int)6].dp = (void *)cis_buffer;
  d[(signed long int)7].dp = (void *)mmr_buffer;
  d[(signed long int)8].d1 = 16;
  d[(signed long int)9].d1 = 32;
  d[(signed long int)10].d1 = 2;
  d[(signed long int)11].d1 = 8;
  d[(signed long int)8].dp3 = (void *)&CONFIG_GAME_TIME;
  d[(signed long int)9].dp3 = (void *)&CONFIG_FIGHTER_NUMBER;
  d[(signed long int)10].dp3 = (void *)&CONFIG_CURSOR_INCREASE_SPEED;
  d[(signed long int)11].dp3 = (void *)&CONFIG_MIN_MAP_RES;
  i = 8;
  for( ; !(i >= 12); i = i + 1)
  {
    d[(signed long int)i].dp = (void *)0;
    d[(signed long int)i].dp2 = (void *)slider_int;
    temp = (signed int *)d[(signed long int)i].dp3;
    d[(signed long int)i].d2 = *temp;
  }
  d[(signed long int)8].dp2 = (void *)slider_time;
  d[(signed long int)8].dp3 = (void *)(d + (signed long int)4);
  d[(signed long int)10].dp2 = (void *)slider_cis;
  d[(signed long int)10].dp3 = (void *)(d + (signed long int)6);
  d[(signed long int)11].dp2 = (void *)slider_mmr;
  d[(signed long int)11].dp3 = (void *)(d + (signed long int)7);
  write_time_setting(d + (signed long int)4);
  write_cis_setting(d + (signed long int)6);
  write_mmr_setting(d + (signed long int)7);
  d[(signed long int)14].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
  while(retour == 0)
  {
    choix=my_do_dialog(d, choix);
    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 2)
        goto __CPROVER_DUMP_L9;

      if(choix == 0)
        goto __CPROVER_DUMP_L10;

      if(choix == 1)
        goto __CPROVER_DUMP_L12;

      if(choix == 12)
        goto __CPROVER_DUMP_L13;

      if(choix == 13)
        goto __CPROVER_DUMP_L14;

    }

    else
    {
      retour = 1;
      continue;

    __CPROVER_DUMP_L9:
      ;
      retour = -1;
      continue;

    __CPROVER_DUMP_L10:
      ;
      signed int return_value_confirm_quit_5;
      return_value_confirm_quit_5=confirm_quit();
      if(!(return_value_confirm_quit_5 == 0))
        retour = -2;

      continue;

    __CPROVER_DUMP_L12:
      ;
      retour = -3;
      continue;

    __CPROVER_DUMP_L13:
      ;
      retour=advanced_options();
      continue;

    __CPROVER_DUMP_L14:
      ;
      load_default_rules();
      LW_CONFIG_CURRENT_RULES.game_time = CONFIG_GAME_TIME;
      d[(signed long int)8].d2 = CONFIG_GAME_TIME;
      d[(signed long int)9].d2 = CONFIG_FIGHTER_NUMBER;
      d[(signed long int)10].d2 = CONFIG_CURSOR_INCREASE_SPEED;
      d[(signed long int)11].d2 = CONFIG_MIN_MAP_RES;
      write_time_setting(d + (signed long int)4);
      write_cis_setting(d + (signed long int)6);
      write_mmr_setting(d + (signed long int)7);
    }
  }
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// save_config_options
// file config.c line 518
signed int save_config_options(void)
{
  char number_string[2l] = { (char)48, (char)0 };
  signed int i;
  set_config_file(STARTUP_CFG_PATH);
  set_config_int("MAIN", "DUMMY", 5003000);
  set_config_int("MAIN", "GFX_GAME", CONFIG_GFX_GAME);
  set_config_int("MAIN", "GFX_MENU", CONFIG_GFX_MENU);
  set_config_int("MAIN", "FULLSCREEN", CONFIG_FULLSCREEN);
  set_config_int("MAIN", "VIEWPORT_SIZE", CONFIG_VIEWPORT_SIZE);
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    number_string[(signed long int)0] = (char)(48 + i);
    set_config_int("WAVE_NUMBER", number_string, CONFIG_WAVE_NUMBER[(signed long int)i]);
    set_config_int("WAVE_AMPLI", number_string, CONFIG_WAVE_AMPLI[(signed long int)i]);
    set_config_int("WAVE_SPEED", number_string, CONFIG_WAVE_SPEED[(signed long int)i]);
  }
  set_config_int("MAIN", "BRIGHTNESS", CONFIG_BRIGHTNESS);
  set_config_int("MAIN", "CURSOR_INCREASE_SPEED", CONFIG_CURSOR_INCREASE_SPEED);
  set_config_int("MAIN", "FIGHTER_ATTACK", CONFIG_FIGHTER_ATTACK);
  set_config_int("MAIN", "FIGHTER_DEFENSE", CONFIG_FIGHTER_DEFENSE);
  set_config_int("MAIN", "FIGHTER_NEW_HEALTH", CONFIG_FIGHTER_NEW_HEALTH);
  set_config_int("MAIN", "NUMBER_INFLUENCE", CONFIG_NUMBER_INFLUENCE);
  set_config_int("MAIN", "SFX_VOLUME", CONFIG_SFX_VOLUME);
  set_config_int("MAIN", "CLICK_VOLUME", CONFIG_CLICK_VOLUME);
  set_config_int("MAIN", "WATER_VOLUME_MENU", CONFIG_WATER_VOLUME_MENU);
  set_config_int("MAIN", "WATER_VOLUME_GAME", CONFIG_WATER_VOLUME_GAME);
  set_config_int("MAIN", "MUSIC_VOLUME", CONFIG_MUSIC_VOLUME);
  set_config_int("MAIN", "LEVEL_MAP", CONFIG_LEVEL_MAP);
  set_config_int("MAIN", "LEVEL_FG", CONFIG_LEVEL_FG);
  set_config_int("MAIN", "LEVEL_BG", CONFIG_LEVEL_BG);
  set_config_int("MAIN", "FIGHTER_NUMBER", CONFIG_FIGHTER_NUMBER);
  i = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    number_string[(signed long int)0] = (char)(48 + i);
    set_config_int("KEY_UP", number_string, CONFIG_KEY_UP[(signed long int)i]);
    set_config_int("KEY_LEFT", number_string, CONFIG_KEY_LEFT[(signed long int)i]);
    set_config_int("KEY_DOWN", number_string, CONFIG_KEY_DOWN[(signed long int)i]);
    set_config_int("KEY_RIGHT", number_string, CONFIG_KEY_RIGHT[(signed long int)i]);
    set_config_int("TEAM_COLOR", number_string, CONFIG_TEAM_COLOR[(signed long int)i]);
    set_config_int("CONTROL_TYPE", number_string, CONFIG_CONTROL_TYPE[(signed long int)i]);
    set_config_string("PLAYER_NAME", number_string, CONFIG_PLAYER_NAME[(signed long int)i]);
  }
  set_config_int("MAIN", "GAME_TIME", CONFIG_GAME_TIME);
  set_config_int("MAIN", "INFO_BAR", CONFIG_INFO_BAR);
  set_config_int("MAIN", "MOUSE_GAP", CONFIG_MOUSE_GAP);
  set_config_int("MAIN", "JOYSTICK_ON", CONFIG_JOYSTICK_ON);
  set_config_int("MAIN", "CPU_ADVANTAGE", CONFIG_CPU_ADVANTAGE);
  set_config_int("MAIN", "CPU_VS_HUMAN", CONFIG_CPU_VS_HUMAN);
  set_config_int("MAIN", "PAGE_FLIP", CONFIG_PAGE_FLIP);
  set_config_int("MAIN", "LANGUAGE", CONFIG_LANGUAGE);
  set_config_int("MAIN", "WAVE_ON", CONFIG_WAVE_ON);
  set_config_int("MAIN", "FRAMES_PER_SEC_LIMIT", CONFIG_FRAMES_PER_SEC_LIMIT);
  set_config_int("MAIN", "ROUNDS_PER_SEC_LIMIT", CONFIG_ROUNDS_PER_SEC_LIMIT);
  set_config_string("MAIN", "SERVER_ADDRESS", CONFIG_SERVER_ADDRESS);
  set_config_int("MAIN", "SERVER_PORT", CONFIG_SERVER_PORT);
  set_config_int("MAIN", "ASM_ALGORITHM", CONFIG_ASM_ALGORITHM);
  set_config_string("MAIN", "PASSWORD", CONFIG_PASSWORD);
  set_config_int("MAIN", "MIN_MAP_RES", CONFIG_MIN_MAP_RES);
  set_config_int("MAIN", "USE_DEFAULT_TEXTURE", CONFIG_USE_DEFAULT_TEXTURE);
  set_config_int("MAIN", "ALLOW_NETWORK_BOTS", CONFIG_ALLOW_NETWORK_BOTS);
  return 0;
}

// send_keys
// file keyexch.c line 85
static signed int send_keys(signed int *sock, struct anonymous_23 *cursors, unsigned int checksum)
{
  signed int result = 0;
  signed int i;
  struct anonymous_5 netkey;
  lw_netkey_reset(&netkey);
  i = 0;
  for( ; !(i >= 6); i = i + 1)
    if((cursors + (signed long int)i)->from_network == 0)
      netkey.key_states[(signed long int)i] = (cursors + (signed long int)i)->key_state;

  signed int return_value_lw_netkey_peek_1;
  return_value_lw_netkey_peek_1=lw_netkey_peek(sock, 2);
  if(return_value_lw_netkey_peek_1 == 0)
    netkey.cmd = 43;

  signed int return_value_lw_netkey_peek_2;
  return_value_lw_netkey_peek_2=lw_netkey_peek(sock, 5);
  if(!(return_value_lw_netkey_peek_2 == 0))
    netkey.cmd = 45;

  netkey.checksum = checksum;
  result=lw_netkey_send(sock, &netkey);
  return result;
}

// set_auto_check
// file startup.c line 243
static void set_auto_check(void)
{
  signed int return_value_exist_argument_1;
  return_value_exist_argument_1=exist_argument("auto");
  if(!(return_value_exist_argument_1 == 0))
  {
    STARTUP_AUTO = 1;
    STARTUP_CHECK = 0;
  }

  signed int return_value_exist_argument_2;
  return_value_exist_argument_2=exist_argument("check");
  if(!(return_value_exist_argument_2 == 0))
  {
    STARTUP_AUTO = 0;
    STARTUP_CHECK = 1;
    STARTUP_STOP = 1;
  }

}

// set_bg_dialogs_visibility
// file level.c line 310
static void set_bg_dialogs_visibility(struct DIALOG *d, signed int *just_hidden)
{
  signed int state;
  signed int i;
  signed int return_value_lw_maptex_is_custom_texture_used_1;
  return_value_lw_maptex_is_custom_texture_used_1=lw_maptex_is_custom_texture_used(CONFIG_LEVEL_MAP, CONFIG_LEVEL_BG, 0, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
  state = (signed int)!(return_value_lw_maptex_is_custom_texture_used_1 != 0);
  static signed int last_state = 1;
  if(state == 0 && !(last_state == 0))
    *just_hidden = 1;

  last_state = state;
  set_dialog_visibility(d + (signed long int)6, state);
  set_dialog_visibility(d + (signed long int)11, state);
  set_dialog_visibility(d + (signed long int)12, state);
  set_dialog_visibility(d + (signed long int)15, state);
  i = 149;
  for( ; !(i >= 277); i = i + 1)
    set_dialog_visibility(d + (signed long int)i, state);
}

// set_bg_texture_palette
// file palette.h line 86
void set_bg_texture_palette(signed int num)
{
  if(!(num >= 128))
    set_mono_texture_palette(num, 96);

  else
  {
    if(num >= 128 && !(num >= 128 + RAW_TEXTURE_NUMBER))
    {
      if(!(LOADED_TEXTURE == 0))
        set_raw_texture_palette(RAW_TEXTURE[(signed long int)(num - 128)], 96);

      else
        set_mono_texture_palette(120, 96);
    }

    if(num >= 128 + RAW_TEXTURE_NUMBER && !(num >= 128 + RAW_MAPTEX_NUMBER + RAW_TEXTURE_NUMBER))
    {
      if(!(LOADED_MAPTEX == 0))
        set_raw_texture_palette(RAW_MAPTEX[(signed long int)(num - (128 + RAW_TEXTURE_NUMBER))], 96);

      else
        set_mono_texture_palette(120, 96);
    }

  }
}

// set_bigdata_size
// file startup.c line 166
static void set_bigdata_size(void)
{
  signed int bigd;
  signed int return_value_exist_argument_value_1;
  return_value_exist_argument_value_1=exist_argument_value("mem");
  if(!(return_value_exist_argument_value_1 == 0))
  {
    bigd=get_argument_int("mem");
    if(!(bigd >= 1))
      bigd = 1;

    if(bigd >= 129)
      bigd = 128;

    STARTUP_BIG_DATA = bigd;
  }

}

// set_c_or_asm
// file startup.c line 227
static void set_c_or_asm(void)
{
  signed int return_value_exist_argument_1;
  return_value_exist_argument_1=exist_argument("c");
  if(!(return_value_exist_argument_1 == 0))
    STARTUP_ASM = 0;

}

// set_dialog_visibility
// file level.c line 258
static void set_dialog_visibility(struct DIALOG *d, signed int state)
{
  if(!(state == 0))
    d->flags = d->flags & ~16;

  else
    d->flags = d->flags | 16;
  if((16 & d->flags) == 0)
    d->proc(3, d, 0);

}

// set_fg_dialogs_visibility
// file level.c line 281
static void set_fg_dialogs_visibility(struct DIALOG *d, signed int *just_hidden)
{
  signed int state;
  signed int i;
  signed int return_value_lw_maptex_is_custom_texture_used_1;
  return_value_lw_maptex_is_custom_texture_used_1=lw_maptex_is_custom_texture_used(CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, 0, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
  state = (signed int)!(return_value_lw_maptex_is_custom_texture_used_1 != 0);
  static signed int last_state = 1;
  if(state == 0 && !(last_state == 0))
    *just_hidden = 1;

  last_state = state;
  set_dialog_visibility(d + (signed long int)5, state);
  set_dialog_visibility(d + (signed long int)9, state);
  set_dialog_visibility(d + (signed long int)10, state);
  set_dialog_visibility(d + (signed long int)14, state);
  i = 21;
  for( ; !(i >= 149); i = i + 1)
    set_dialog_visibility(d + (signed long int)i, state);
}

// set_fg_texture_palette
// file palette.h line 87
void set_fg_texture_palette(signed int num)
{
  if(!(num >= 128))
    set_mono_texture_palette(num, 64);

  else
  {
    if(num >= 128 && !(num >= 128 + RAW_TEXTURE_NUMBER))
    {
      if(!(LOADED_TEXTURE == 0))
        set_raw_texture_palette(RAW_TEXTURE[(signed long int)(num - 128)], 64);

      else
        set_mono_texture_palette(127, 64);
    }

    if(num >= 128 + RAW_TEXTURE_NUMBER && !(num >= 128 + RAW_MAPTEX_NUMBER + RAW_TEXTURE_NUMBER))
    {
      if(!(LOADED_MAPTEX == 0))
        set_raw_texture_palette(RAW_MAPTEX[(signed long int)(num - (128 + RAW_TEXTURE_NUMBER))], 64);

      else
        set_mono_texture_palette(127, 64);
    }

  }
}

// set_graphic_possibilities
// file startup.c line 219
static void set_graphic_possibilities(void)
{
  signed int return_value_exist_argument_1;
  return_value_exist_argument_1=exist_argument("vga");
  if(!(return_value_exist_argument_1 == 0))
    STARTUP_SVGA = 0;

}

// set_joystick
// file startup.c line 183
static void set_joystick(void)
{
  signed int return_value_exist_argument_1;
  return_value_exist_argument_1=exist_argument("nojoy");
  if(!(return_value_exist_argument_1 == 0))
    STARTUP_JOYSTICK_ON = 0;

}

// set_load_states
// file startup.c line 191
static void set_load_states(void)
{
  signed int return_value_exist_argument_1;
  return_value_exist_argument_1=exist_argument("noback");
  if(!(return_value_exist_argument_1 == 0))
    STARTUP_BACK_STATE = 0;

  signed int return_value_exist_argument_2;
  return_value_exist_argument_2=exist_argument("notex");
  if(!(return_value_exist_argument_2 == 0))
    STARTUP_TEXTURE_STATE = 0;

  signed int return_value_exist_argument_3;
  return_value_exist_argument_3=exist_argument("nowater");
  _Bool tmp_if_expr_5;
  signed int return_value_exist_argument_4;
  if(!(return_value_exist_argument_3 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_exist_argument_4=exist_argument("silent");
    tmp_if_expr_5 = return_value_exist_argument_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    STARTUP_WATER_STATE = 0;

  signed int return_value_exist_argument_6;
  return_value_exist_argument_6=exist_argument("nosfx");
  _Bool tmp_if_expr_8;
  signed int return_value_exist_argument_7;
  if(!(return_value_exist_argument_6 == 0))
    tmp_if_expr_8 = (_Bool)1;

  else
  {
    return_value_exist_argument_7=exist_argument("silent");
    tmp_if_expr_8 = return_value_exist_argument_7 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_8)
    STARTUP_SFX_STATE = 0;

  signed int return_value_exist_argument_9;
  return_value_exist_argument_9=exist_argument("silent");
  _Bool tmp_if_expr_13;
  signed int return_value_exist_argument_10;
  _Bool tmp_if_expr_12;
  signed int return_value_exist_argument_11;
  if(!(return_value_exist_argument_9 == 0))
    tmp_if_expr_13 = (_Bool)1;

  else
  {
    return_value_exist_argument_10=exist_argument("nosfx");
    if(!(return_value_exist_argument_10 == 0))
    {
      return_value_exist_argument_11=exist_argument("nowater");
      tmp_if_expr_12 = return_value_exist_argument_11 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_12 = (_Bool)0;
    tmp_if_expr_13 = tmp_if_expr_12 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_13)
    STARTUP_DIGI_CARD = 0;

  signed int return_value_exist_argument_14;
  return_value_exist_argument_14=exist_argument("nomusic");
  _Bool tmp_if_expr_16;
  signed int return_value_exist_argument_15;
  if(!(return_value_exist_argument_14 == 0))
    tmp_if_expr_16 = (_Bool)1;

  else
  {
    return_value_exist_argument_15=exist_argument("silent");
    tmp_if_expr_16 = return_value_exist_argument_15 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_16)
  {
    STARTUP_MUSIC_STATE = 0;
    STARTUP_MIDI_CARD = 0;
  }

  signed int return_value_exist_argument_17;
  return_value_exist_argument_17=exist_argument("nocustom");
  if(!(return_value_exist_argument_17 == 0))
    STARTUP_CUSTOM_STATE = 0;

}

// set_metaserver
// file startup.c line 411
static void set_metaserver(void)
{
  signed int return_value_exist_argument_value_2;
  return_value_exist_argument_value_2=exist_argument_value("metaserver");
  if(!(return_value_exist_argument_value_2 == 0))
  {
    memset((void *)STARTUP_METASERVER, 0, sizeof(char [200l]) /*200ul*/ );
    char *return_value_get_argument_str_1;
    return_value_get_argument_str_1=get_argument_str("metaserver");
    __builtin_strncpy(STARTUP_METASERVER, return_value_get_argument_str_1, sizeof(char [200l]) /*200ul*/  - (unsigned long int)1);
    STARTUP_METASERVER[(signed long int)(sizeof(char [200l]) /*200ul*/  - (unsigned long int)1)] = (char)0;
  }

  else
  {
    memset((void *)STARTUP_METASERVER, 0, sizeof(char [200l]) /*200ul*/ );
    __builtin_strncpy(STARTUP_METASERVER, DEFAULT_METASERVER, sizeof(char [200l]) /*200ul*/  - (unsigned long int)1);
    STARTUP_METASERVER[(signed long int)(sizeof(char [200l]) /*200ul*/  - (unsigned long int)1)] = (char)0;
  }
}

// set_misc
// file startup.c line 426
static void set_misc(void)
{
  signed int return_value_exist_argument_1;
  return_value_exist_argument_1=exist_argument("capture");
  if(!(return_value_exist_argument_1 == 0))
    STARTUP_CAPTURE = 1;

  signed int return_value_exist_argument_2;
  return_value_exist_argument_2=exist_argument("tombola");
  if(!(return_value_exist_argument_2 == 0))
    STARTUP_TOMBOLA = 1;

}

// set_mono_texture_palette
// file palette.c line 227
static void set_mono_texture_palette(signed int num, signed int first)
{
  get_mono_texture_color(GLOBAL_PALETTE + (signed long int)first, num);
}

// set_palette_for_choose_color
// file palette.h line 88
void set_palette_for_choose_color(void)
{
  signed int i = 0;
  for( ; !(i >= 128); i = i + 1)
    get_mono_texture_color(GLOBAL_PALETTE + (signed long int)128 + (signed long int)i, i);
}

// set_path
// file startup.c line 314
static void set_path(void)
{
  char home_path[512l];
  char *home_env = (char *)(void *)0;
  signed int return_value_exist_argument_value_2;
  return_value_exist_argument_value_2=exist_argument_value("cfg");
  if(!(return_value_exist_argument_value_2 == 0))
  {
    memset((void *)STARTUP_CFG_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
    char *return_value_get_argument_str_1;
    return_value_get_argument_str_1=get_argument_str("cfg");
    __builtin_strncpy(STARTUP_CFG_PATH, return_value_get_argument_str_1, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
    STARTUP_CFG_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  }

  else
  {
    home_env=getenv("HOME");
    if(!(home_env == ((char *)NULL)))
    {
      memset((void *)home_path, 0, sizeof(char [512l]) /*512ul*/ );
      snprintf(home_path, sizeof(char [512l]) /*512ul*/  - (unsigned long int)1, "%s/", home_env);
      home_path[(signed long int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1)] = (char)0;
    }

    else
    {
      home_env = "";
      memset((void *)home_path, 0, sizeof(char [512l]) /*512ul*/ );
      __builtin_strncpy(home_path, home_env, sizeof(char [512l]) /*512ul*/  - (unsigned long int)1);
      home_path[(signed long int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1)] = (char)0;
    }
    memset((void *)STARTUP_CFG_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
    snprintf(STARTUP_CFG_PATH, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1, "%s%s", (const void *)home_path, DEFAULT_CFG_PATH);
    STARTUP_CFG_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  }
  memset((void *)STARTUP_LOG_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
  __builtin_strncpy(STARTUP_LOG_PATH, DEFAULT_LOG_PATH, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
  STARTUP_LOG_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  signed int return_value_exist_argument_value_4;
  return_value_exist_argument_value_4=exist_argument_value("dat");
  if(!(return_value_exist_argument_value_4 == 0))
  {
    memset((void *)STARTUP_DAT_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
    char *return_value_get_argument_str_3;
    return_value_get_argument_str_3=get_argument_str("dat");
    __builtin_strncpy(STARTUP_DAT_PATH, return_value_get_argument_str_3, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
    STARTUP_DAT_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  }

  else
  {
    memset((void *)STARTUP_DAT_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
    __builtin_strncpy(STARTUP_DAT_PATH, DEFAULT_DAT_PATH, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
    STARTUP_DAT_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  }
  signed int return_value_exist_argument_value_6;
  return_value_exist_argument_value_6=exist_argument_value("tex");
  if(!(return_value_exist_argument_value_6 == 0))
  {
    memset((void *)STARTUP_TEX_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
    char *return_value_get_argument_str_5;
    return_value_get_argument_str_5=get_argument_str("tex");
    __builtin_strncpy(STARTUP_TEX_PATH, return_value_get_argument_str_5, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
    STARTUP_TEX_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  }

  else
  {
    memset((void *)STARTUP_TEX_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
    __builtin_strncpy(STARTUP_TEX_PATH, DEFAULT_TEX_PATH, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
    STARTUP_TEX_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  }
  signed int return_value_exist_argument_value_8;
  return_value_exist_argument_value_8=exist_argument_value("map");
  if(!(return_value_exist_argument_value_8 == 0))
  {
    memset((void *)STARTUP_MAP_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
    char *return_value_get_argument_str_7;
    return_value_get_argument_str_7=get_argument_str("map");
    __builtin_strncpy(STARTUP_MAP_PATH, return_value_get_argument_str_7, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
    STARTUP_MAP_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  }

  else
  {
    memset((void *)STARTUP_MAP_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
    __builtin_strncpy(STARTUP_MAP_PATH, DEFAULT_MAP_PATH, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
    STARTUP_MAP_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  }
  signed int return_value_exist_argument_value_10;
  return_value_exist_argument_value_10=exist_argument_value("mid");
  if(!(return_value_exist_argument_value_10 == 0))
  {
    memset((void *)STARTUP_MID_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
    char *return_value_get_argument_str_9;
    return_value_get_argument_str_9=get_argument_str("mid");
    __builtin_strncpy(STARTUP_MID_PATH, return_value_get_argument_str_9, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
    STARTUP_MID_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  }

  else
  {
    memset((void *)STARTUP_MID_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
    __builtin_strncpy(STARTUP_MID_PATH, DEFAULT_MID_PATH, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
    STARTUP_MID_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  }
  signed int return_value_exist_argument_value_12;
  return_value_exist_argument_value_12=exist_argument_value("server");
  if(!(return_value_exist_argument_value_12 == 0))
  {
    memset((void *)STARTUP_SRV_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
    char *return_value_get_argument_str_11;
    return_value_get_argument_str_11=get_argument_str("server");
    __builtin_strncpy(STARTUP_SRV_PATH, return_value_get_argument_str_11, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
    STARTUP_SRV_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  }

  else
  {
    memset((void *)STARTUP_SRV_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
    __builtin_strncpy(STARTUP_SRV_PATH, DEFAULT_SRV_PATH, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
    STARTUP_SRV_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  }
  signed int return_value_exist_argument_value_14;
  return_value_exist_argument_value_14=exist_argument_value("mapgen");
  if(!(return_value_exist_argument_value_14 == 0))
  {
    memset((void *)STARTUP_GEN_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
    char *return_value_get_argument_str_13;
    return_value_get_argument_str_13=get_argument_str("mapgen");
    __builtin_strncpy(STARTUP_GEN_PATH, return_value_get_argument_str_13, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
    STARTUP_GEN_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  }

  else
  {
    memset((void *)STARTUP_GEN_PATH, 0, sizeof(char [1000l]) /*1000ul*/ );
    __builtin_strncpy(STARTUP_GEN_PATH, DEFAULT_GEN_PATH, sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1);
    STARTUP_GEN_PATH[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  }
  correct_path_file(STARTUP_CFG_PATH);
  correct_path_file(STARTUP_LOG_PATH);
  correct_path_file(STARTUP_DAT_PATH);
  correct_path_dir(STARTUP_TEX_PATH);
  correct_path_dir(STARTUP_MAP_PATH);
  correct_path_dir(STARTUP_MID_PATH);
  correct_path_file(STARTUP_SRV_PATH);
  correct_path_file(STARTUP_GEN_PATH);
}

// set_playing_teams_palette
// file palette.c line 365
void set_playing_teams_palette(void)
{
  signed int i;
  signed int j;
  signed int n;
  signed int color;
  signed int active;
  COLORS_PER_TEAM = 128 / PLAYING_TEAMS;
  i = 0;
  n = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    color = 0;
    active = 0;
    if(!(LW_NETWORK_ON == 0))
    {
      j = 0;
      for( ; !(j >= 6); j = j + 1)
        if(!(LW_NETWORK_INFO[(signed long int)j].active == 0))
        {
          if(LW_NETWORK_INFO[(signed long int)j].server_id == i)
          {
            active = 1;
            color = LW_NETWORK_INFO[(signed long int)j].color;
          }

        }

    }

    else
      if(!(CONFIG_CONTROL_TYPE[(signed long int)i] == 0))
      {
        active = 1;
        color = CONFIG_TEAM_COLOR[(signed long int)i];
      }

    if(!(active == 0))
    {
      COLOR_FIRST_ENTRY[(signed long int)n] = 128 + n * COLORS_PER_TEAM;
      set_team_color(color, COLOR_FIRST_ENTRY[(signed long int)n], COLORS_PER_TEAM);
      n = n + 1;
    }

  }
}

// set_raw_texture_palette
// file palette.c line 174
static void set_raw_texture_palette(void *ptr, signed int first)
{
  signed int i;
  char *data = (char *)ptr;
  data = data + (signed long int)(4 + 16);
  i = first;
  char *tmp_post_1;
  char *tmp_post_2;
  char *tmp_post_3;
  for( ; !(i >= 32 + first); i = i + 1)
  {
    tmp_post_1 = data;
    data = data + 1l;
    GLOBAL_PALETTE[(signed long int)i].r = (unsigned char)*tmp_post_1;
    tmp_post_2 = data;
    data = data + 1l;
    GLOBAL_PALETTE[(signed long int)i].g = (unsigned char)*tmp_post_2;
    tmp_post_3 = data;
    data = data + 1l;
    GLOBAL_PALETTE[(signed long int)i].b = (unsigned char)*tmp_post_3;
  }
}

// set_resolution
// file gfxmode.c line 187
signed int set_resolution(signed int res, signed int flip, signed int fullscreen, signed int *flip_enabled)
{
  signed int ret = -1;
  signed int toggle;
  signed int i;
  if(!(flip_enabled == ((signed int *)NULL)))
    *flip_enabled = 0;

  toggle = 0;
  for( ; !(toggle >= 2); fullscreen = (signed int)!(fullscreen != 0))
  {
    i = res;
    for( ; i >= 0 && !(ret == 0); i = i - 1)
    {
      if(!(flip == 0))
      {
        ret=try_one_mode(i, 1, fullscreen);
        if(ret == 0 && !(flip_enabled == ((signed int *)NULL)))
          *flip_enabled = 1;

      }

      if(!(ret == 0))
        ret=try_one_mode(i, 0, fullscreen);

    }
    i = res + 1;
    for( ; !(ret == 0) && !(i >= 5); i = i + 1)
    {
      if(!(flip == 0))
      {
        ret=try_one_mode(i, 1, fullscreen);
        if(ret == 0 && !(flip_enabled == ((signed int *)NULL)))
          *flip_enabled = 1;

      }

      if(!(ret == 0))
        ret=try_one_mode(i, 0, fullscreen);

    }
    toggle = toggle + 1;
  }
  signed int tmp_if_expr_1;
  if(ret == 0)
  {
    set_palette(black_palette);
    if(!(gfx_driver == ((struct GFX_DRIVER *)NULL)))
      tmp_if_expr_1 = gfx_driver->w;

    else
      tmp_if_expr_1 = 0;
    if(tmp_if_expr_1 >= 640)
      font = BIG_FONT;

    else
      font = SMALL_FONT;
    lw_mouse_show();
    char *return_value_lw_lang_string_2;
    return_value_lw_lang_string_2=lw_lang_string(1);
    set_window_title(return_value_lw_lang_string_2);
  }

  else
    my_exit(6);
  return ret;
}

// set_safe
// file startup.c line 260
static void set_safe(void)
{
  signed int return_value_exist_argument_1;
  return_value_exist_argument_1=exist_argument("nice");
  if(!(return_value_exist_argument_1 == 0))
  {
    STARTUP_BIG_DATA = 4096;
    STARTUP_SVGA = 0;
  }

  signed int return_value_exist_argument_2;
  return_value_exist_argument_2=exist_argument("safe");
  if(!(return_value_exist_argument_2 == 0))
  {
    STARTUP_JOYSTICK_ON = 0;
    STARTUP_BIG_DATA = 1024;
    STARTUP_DIGI_CARD = 0;
    STARTUP_BACK_STATE = 0;
    STARTUP_TEXTURE_STATE = 0;
    STARTUP_WATER_STATE = 0;
    STARTUP_SFX_STATE = 0;
    STARTUP_MUSIC_STATE = 0;
    STARTUP_CUSTOM_STATE = 0;
    STARTUP_SVGA = 0;
  }

}

// set_startup
// file startup.h line 104
void set_startup(void)
{
  set_joystick();
  set_load_states();
  set_graphic_possibilities();
  set_c_or_asm();
  set_path();
  set_stop();
  set_safe();
  set_auto_check();
  set_bigdata_size();
  set_metaserver();
  set_misc();
  set_various_hacks();
}

// set_stop
// file startup.c line 235
static void set_stop(void)
{
  signed int return_value_exist_argument_1;
  return_value_exist_argument_1=exist_argument("stop");
  if(!(return_value_exist_argument_1 == 0))
    STARTUP_STOP = 1;

}

// set_team_color
// file palette.c line 339
static void set_team_color(signed int teinte, signed int first, signed int num)
{
  signed int i;
  signed int col;
  signed int col_r;
  signed int col_g;
  signed int col_b;
  signed int coeff;
  signed int tot;
  signed int last = (first + num) - 1;
  get_mono_texture_color(GLOBAL_PALETTE + (signed long int)last, teinte * 10);
  col_r = (signed int)GLOBAL_PALETTE[(signed long int)last].r;
  col_g = (signed int)GLOBAL_PALETTE[(signed long int)last].g;
  col_b = (signed int)GLOBAL_PALETTE[(signed long int)last].b;
  tot = 8 * num - 7;
  i = 0;
  for( ; !(i >= num + -1); i = i + 1)
  {
    coeff = num + 7 * i;
    col = (col_r * coeff) / tot;
    GLOBAL_PALETTE[(signed long int)(first + i)].r = (unsigned char)col;
    col = (col_g * coeff) / tot;
    GLOBAL_PALETTE[(signed long int)(first + i)].g = (unsigned char)col;
    col = (col_b * coeff) / tot;
    GLOBAL_PALETTE[(signed long int)(first + i)].b = (unsigned char)col;
  }
}

// set_various_hacks
// file startup.c line 440
static void set_various_hacks(void)
{
  STARTUP_ASM = 0;
}

// set_window_title
// file /usr/include/allegro/inline/system.inl line 29
static inline void set_window_title(const char *name)
{
  if(!(system_driver->set_window_title == ((void (*)(const char *))NULL)))
    system_driver->set_window_title(name);

}

// skip_space
// file wwwcli.c line 245
static void skip_space(char **str)
{
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*(*str)]) == 0)
    {
      if(!((signed int)*(*str) == 13))
        break;

    }

    if((signed int)*(*str) == 10)
      break;

    *str = *str + 1l;
  }
  while((_Bool)1);
}

// slider_bg
// file level.c line 562
static signed int slider_bg(void *dp3, signed int d2)
{
  struct DIALOG *d;
  signed int bg;
  play_click();
  d = (struct DIALOG *)dp3;
  bg = d2 + 128;
  update_choose_map(d, CONFIG_LEVEL_MAP, CONFIG_LEVEL_FG, bg, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
  return 0;
}

// slider_brightness
// file graphics.c line 173
static signed int slider_brightness(void *dp3, signed int d2)
{
  dp3 = dp3;
  d2 = d2;
  play_click();
  CONFIG_BRIGHTNESS = d2;
  my_set_palette();
  return 0;
}

// slider_cis
// file rules.c line 98
static signed int slider_cis(void *dp3, signed int d2)
{
  struct DIALOG *d = (struct DIALOG *)dp3;
  CONFIG_CURSOR_INCREASE_SPEED = d2;
  write_cis_setting(d);
  scare_mouse();
  my_textbox_proc(3, d, 0);
  unscare_mouse();
  play_click();
  return 0;
}

// slider_fg
// file level.c line 547
static signed int slider_fg(void *dp3, signed int d2)
{
  struct DIALOG *d;
  signed int fg;
  play_click();
  d = (struct DIALOG *)dp3;
  fg = d2 + 128;
  update_choose_map(d, CONFIG_LEVEL_MAP, fg, CONFIG_LEVEL_BG, LW_RANDOM_ON, CONFIG_USE_DEFAULT_TEXTURE);
  return 0;
}

// slider_fps
// file speeds.c line 106
static signed int slider_fps(void *dp3, signed int d2)
{
  struct DIALOG *d = (struct DIALOG *)dp3;
  CONFIG_FRAMES_PER_SEC_LIMIT = d2;
  write_fps_setting(d);
  scare_mouse();
  my_textbox_proc(3, d, 0);
  unscare_mouse();
  play_click();
  return 0;
}

// slider_game_res
// file graphics.c line 139
static signed int slider_game_res(void *dp3, signed int d2)
{
  signed int *changed;
  d2 = d2;
  play_click();
  changed = (signed int *)dp3;
  *changed = 1;
  return 0;
}

// slider_int
// file dialog.h line 120
signed int slider_int(void *dp3, signed int d2)
{
  signed int *val = (signed int *)dp3;
  *val = d2;
  play_click();
  return 0;
}

// slider_map
// file level.c line 532
static signed int slider_map(void *dp3, signed int d2)
{
  struct DIALOG *d;
  signed int map;
  play_click();
  d = (struct DIALOG *)dp3;
  map = d2;
  update_choose_map(d, map, CONFIG_LEVEL_FG, CONFIG_LEVEL_BG, 0, CONFIG_USE_DEFAULT_TEXTURE);
  return 0;
}

// slider_menu_res
// file graphics.c line 155
static signed int slider_menu_res(void *dp3, signed int d2)
{
  signed int *changed;
  d2 = d2;
  play_click();
  changed = (signed int *)dp3;
  *changed = 1;
  my_set_palette();
  return 0;
}

// slider_mmr
// file rules.c line 170
static signed int slider_mmr(void *dp3, signed int d2)
{
  struct DIALOG *d = (struct DIALOG *)dp3;
  CONFIG_MIN_MAP_RES = d2;
  write_mmr_setting(d);
  scare_mouse();
  my_textbox_proc(3, d, 0);
  unscare_mouse();
  play_click();
  return 0;
}

// slider_mouse
// file controls.c line 75
static signed int slider_mouse(void *dp3, signed int d2)
{
  signed int *val = (signed int *)dp3;
  *val = d2;
  lw_mouse_reset_control();
  play_click();
  return 0;
}

// slider_rps
// file speeds.c line 150
static signed int slider_rps(void *dp3, signed int d2)
{
  struct DIALOG *d = (struct DIALOG *)dp3;
  CONFIG_ROUNDS_PER_SEC_LIMIT = d2;
  write_rps_setting(d);
  scare_mouse();
  my_textbox_proc(3, d, 0);
  unscare_mouse();
  play_click();
  return 0;
}

// slider_time
// file rules.c line 129
static signed int slider_time(void *dp3, signed int d2)
{
  struct DIALOG *d = (struct DIALOG *)dp3;
  CONFIG_GAME_TIME = d2;
  LW_CONFIG_CURRENT_RULES.game_time = CONFIG_GAME_TIME;
  write_time_setting(d);
  scare_mouse();
  my_textbox_proc(3, d, 0);
  unscare_mouse();
  play_click();
  return 0;
}

// sort_light_and_dark
// file map.c line 107
static void sort_light_and_dark(struct BITMAP *bmp, struct RGB *pal)
{
  char table[256l];
  signed int i;
  signed int x;
  signed int y;
  i = 0;
  for( ; !(i >= 256); i = i + 1)
    if(3 * (signed int)(pal + (signed long int)i)->g + 6 * (signed int)(pal + (signed long int)i)->r + (signed int)(pal + (signed long int)i)->b >= 316)
      table[(signed long int)i] = (char)2;

    else
      table[(signed long int)i] = (char)0;
  y = 0;
  signed int return_value_getpixel_1;
  for( ; !(y >= bmp->h); y = y + 1)
  {
    x = 0;
    for( ; !(x >= bmp->w); x = x + 1)
    {
      return_value_getpixel_1=getpixel_link3(bmp, x, y);
      putpixel_link6(bmp, x, y, (signed int)table[(signed long int)return_value_getpixel_1]);
    }
  }
}

// sound_options
// file volume.h line 66
signed int sound_options(void)
{
  signed int *temp;
  struct DIALOG d[15l];
  signed int i;
  signed int choix = 4;
  signed int retour = 0;
  memset((void *)d, 0, sizeof(struct DIALOG [15l]) /*1080ul*/ );
  i = 0;
  static signed int y_pos[5l] = { 0, 2, 4, 5, 7 };
  for( ; !(i >= 5); i = i + 1)
  {
    standard_button(d + (signed long int)i + (signed long int)4, 0, y_pos[(signed long int)i], 2, 8);
    d[(signed long int)(i + 4)].proc = my_textbox_proc;
  }
  i = 0;
  for( ; !(i >= 5); i = i + 1)
  {
    standard_button(d + (signed long int)i + (signed long int)9, 1, y_pos[(signed long int)i], 2, 8);
    d[(signed long int)(i + 9)].proc = my_slider_proc;
  }
  quick_buttons(d);
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(51);
  d[(signed long int)4].dp = (void *)return_value_lw_lang_string_1;
  char *return_value_lw_lang_string_2;
  return_value_lw_lang_string_2=lw_lang_string(52);
  d[(signed long int)5].dp = (void *)return_value_lw_lang_string_2;
  char *return_value_lw_lang_string_3;
  return_value_lw_lang_string_3=lw_lang_string(53);
  d[(signed long int)6].dp = (void *)return_value_lw_lang_string_3;
  char *return_value_lw_lang_string_4;
  return_value_lw_lang_string_4=lw_lang_string(54);
  d[(signed long int)7].dp = (void *)return_value_lw_lang_string_4;
  char *return_value_lw_lang_string_5;
  return_value_lw_lang_string_5=lw_lang_string(55);
  d[(signed long int)8].dp = (void *)return_value_lw_lang_string_5;
  d[(signed long int)9].dp3 = (void *)&CONFIG_SFX_VOLUME;
  d[(signed long int)10].dp3 = (void *)&CONFIG_CLICK_VOLUME;
  d[(signed long int)11].dp3 = (void *)&CONFIG_WATER_VOLUME_GAME;
  d[(signed long int)12].dp3 = (void *)&WATER_VOLUME;
  d[(signed long int)13].dp3 = (void *)&CONFIG_MUSIC_VOLUME;
  i = 9;
  for( ; !(i >= 14); i = i + 1)
  {
    d[(signed long int)i].d1 = 16;
    d[(signed long int)i].dp = (void *)0;
    d[(signed long int)i].dp2 = (void *)slider_int;
    temp = (signed int *)d[(signed long int)i].dp3;
    d[(signed long int)i].d2 = *temp;
  }
  d[(signed long int)14].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
  while(retour == 0)
  {
    choix=my_do_dialog(d, choix);
    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 2)
        goto __CPROVER_DUMP_L9;

      if(choix == 0)
        goto __CPROVER_DUMP_L10;

      if(choix == 1)
        goto __CPROVER_DUMP_L13;

    }

    else
    {
      retour = 1;
      continue;

    __CPROVER_DUMP_L9:
      ;
      retour = -1;
      continue;

    __CPROVER_DUMP_L10:
      ;
      signed int return_value_confirm_quit_6;
      return_value_confirm_quit_6=confirm_quit();
      if(!(return_value_confirm_quit_6 == 0))
        retour = -2;

      else
        display_back_image();
      continue;

    __CPROVER_DUMP_L13:
      ;
      retour = -3;
    }
  }
  CONFIG_WATER_VOLUME_MENU = WATER_VOLUME;
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// speeds_options
// file speeds.h line 65
signed int speeds_options(void)
{
  signed int *temp;
  struct DIALOG d[9l];
  signed int i;
  signed int choix = 4;
  signed int retour = 0;
  char fps_buffer[33l];
  char rps_buffer[33l];
  memset((void *)d, 0, sizeof(struct DIALOG [9l]) /*648ul*/ );
  i = 0;
  for( ; !(i >= 2); i = i + 1)
  {
    standard_button(d + (signed long int)i + (signed long int)4, 0, i, 2, 2);
    d[(signed long int)(i + 4)].proc = my_textbox_proc;
  }
  i = 0;
  for( ; !(i >= 2); i = i + 1)
  {
    standard_button(d + (signed long int)i + (signed long int)6, 1, i, 2, 2);
    d[(signed long int)(i + 6)].proc = my_slider_proc;
  }
  quick_buttons(d);
  d[(signed long int)4].dp = (void *)fps_buffer;
  d[(signed long int)5].dp = (void *)rps_buffer;
  d[(signed long int)6].d1 = 8;
  d[(signed long int)7].d1 = 8;
  d[(signed long int)6].dp3 = (void *)&CONFIG_FRAMES_PER_SEC_LIMIT;
  d[(signed long int)7].dp3 = (void *)&CONFIG_ROUNDS_PER_SEC_LIMIT;
  i = 0;
  for( ; !(i >= 2); i = i + 1)
  {
    d[(signed long int)(i + 6)].dp = (void *)0;
    d[(signed long int)(i + 6)].dp2 = (void *)slider_int;
    temp = (signed int *)d[(signed long int)(i + 6)].dp3;
    d[(signed long int)(i + 6)].d2 = *temp;
    d[(signed long int)(i + 6)].dp3 = (void *)(d + (signed long int)i + (signed long int)4);
  }
  d[(signed long int)6].dp2 = (void *)slider_fps;
  d[(signed long int)7].dp2 = (void *)slider_rps;
  write_fps_setting(d + (signed long int)4);
  write_rps_setting(d + (signed long int)5);
  d[(signed long int)8].proc = ((signed int (*)(signed int, struct DIALOG *, signed int))NULL);
  while(retour == 0)
  {
    choix=my_do_dialog(d, choix);
    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 2)
        goto __CPROVER_DUMP_L9;

      if(choix == 0)
        goto __CPROVER_DUMP_L10;

      if(choix == 1)
        goto __CPROVER_DUMP_L12;

    }

    else
    {
      retour = 1;
      continue;

    __CPROVER_DUMP_L9:
      ;
      retour = -1;
      continue;

    __CPROVER_DUMP_L10:
      ;
      signed int return_value_confirm_quit_1;
      return_value_confirm_quit_1=confirm_quit();
      if(!(return_value_confirm_quit_1 == 0))
        retour = -2;

      continue;

    __CPROVER_DUMP_L12:
      ;
      retour = -3;
    }
  }
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// spread_color_down
// file map.c line 169
static signed int spread_color_down(struct BITMAP *bmp, signed int color1, signed int color2)
{
  signed int x;
  signed int y;
  signed int x1;
  signed int y1;
  signed int x2;
  signed int y2;
  signed int found = 0;
  y = 0;
  signed int return_value_getpixel_5;
  for( ; !(y >= bmp->h); y = y + 1)
  {
    x = 0;
    for( ; !(x >= bmp->w); x = x + 1)
    {
      return_value_getpixel_5=getpixel_link3(bmp, x, y);
      if(return_value_getpixel_5 == color2)
      {
        x1 = x - 1;
        if(!(x1 >= 0))
          x1 = 0;

        x2 = x + 1;
        if(!(bmp->w + -1 >= x2))
          x2 = bmp->w - 1;

        y1 = y - 1;
        if(!(y1 >= 0))
          y1 = 0;

        y2 = y + 1;
        if(!(bmp->h + -1 >= y2))
          y2 = bmp->h - 1;

        signed int return_value_getpixel_1;
        return_value_getpixel_1=getpixel_link3(bmp, x2, y);
        if(return_value_getpixel_1 == color1)
        {
          putpixel_link6(bmp, x2, y, color2);
          found = found + 1;
        }

        signed int return_value_getpixel_2;
        return_value_getpixel_2=getpixel_link3(bmp, x2, y2);
        if(return_value_getpixel_2 == color1)
        {
          putpixel_link6(bmp, x2, y2, color2);
          found = found + 1;
        }

        signed int return_value_getpixel_3;
        return_value_getpixel_3=getpixel_link3(bmp, x, y2);
        if(return_value_getpixel_3 == color1)
        {
          putpixel_link6(bmp, x, y2, color2);
          found = found + 1;
        }

        signed int return_value_getpixel_4;
        return_value_getpixel_4=getpixel_link3(bmp, x1, y2);
        if(return_value_getpixel_4 == color1)
        {
          putpixel_link6(bmp, x1, y2, color2);
          found = found + 1;
        }

      }

    }
  }
  return found;
}

// spread_color_up
// file map.c line 217
static signed int spread_color_up(struct BITMAP *bmp, signed int color1, signed int color2)
{
  signed int x;
  signed int y;
  signed int x1;
  signed int y1;
  signed int x2;
  signed int y2;
  signed int found = 0;
  y = bmp->h - 1;
  signed int return_value_getpixel_5;
  for( ; y >= 0; y = y - 1)
  {
    x = bmp->w - 1;
    for( ; x >= 0; x = x - 1)
    {
      return_value_getpixel_5=getpixel_link3(bmp, x, y);
      if(return_value_getpixel_5 == color2)
      {
        x1 = x - 1;
        if(!(x1 >= 0))
          x1 = 0;

        x2 = x + 1;
        if(!(bmp->w + -1 >= x2))
          x2 = bmp->w - 1;

        y1 = y - 1;
        if(!(y1 >= 0))
          y1 = 0;

        y2 = y + 1;
        if(!(bmp->h + -1 >= y2))
          y2 = bmp->h - 1;

        signed int return_value_getpixel_1;
        return_value_getpixel_1=getpixel_link3(bmp, x1, y);
        if(return_value_getpixel_1 == color1)
        {
          putpixel_link6(bmp, x1, y, color2);
          found = found + 1;
        }

        signed int return_value_getpixel_2;
        return_value_getpixel_2=getpixel_link3(bmp, x1, y1);
        if(return_value_getpixel_2 == color1)
        {
          putpixel_link6(bmp, x1, y1, color2);
          found = found + 1;
        }

        signed int return_value_getpixel_3;
        return_value_getpixel_3=getpixel_link3(bmp, x, y1);
        if(return_value_getpixel_3 == color1)
        {
          putpixel_link6(bmp, x, y1, color2);
          found = found + 1;
        }

        signed int return_value_getpixel_4;
        return_value_getpixel_4=getpixel_link3(bmp, x2, y1);
        if(return_value_getpixel_4 == color1)
        {
          putpixel_link6(bmp, x2, y1, color2);
          found = found + 1;
        }

      }

    }
  }
  return found;
}

// spread_single_gradient
// file grad.h line 73
void spread_single_gradient(void)
{
  signed int i;
  signed int new_grad;
  signed int dir;
  struct anonymous_0 *pos;
  struct anonymous_0 *last;
  struct anonymous_0 *temp;
  dir = (GLOBAL_CLOCK * 7) % 12;
  switch(dir)
  {
    case 2:

    case 3:

    case 4:

    case 5:

    case 6:

    case 7:
    {
      pos = CURRENT_MESH;
      last = CURRENT_MESH + (signed long int)CURRENT_MESH_SIZE;
      for( ; !(pos == last); pos = pos + 1l)
      {
        i = 0;
        for( ; !(i >= PLAYING_TEAMS); i = i + 1)
        {
          temp = (struct anonymous_0 *)pos->link[(signed long int)dir];
          if(!(temp == ((struct anonymous_0 *)NULL)))
          {
            new_grad = (signed int)pos->info[(signed long int)i].state.grad + (signed int)pos->side.size;
            if(!(new_grad >= (signed int)temp->info[(signed long int)i].state.grad))
              temp->info[(signed long int)i].state.grad = new_grad;

          }

        }
      }
      goto __CPROVER_DUMP_L12;
    }
    case 8:

    case 9:

    case 10:

    case 11:

    case 0:

    case 1:
    {
      pos = (CURRENT_MESH + (signed long int)CURRENT_MESH_SIZE) - (signed long int)1;
      last = CURRENT_MESH - (signed long int)1;
      for( ; !(pos == last); pos = pos - 1l)
      {
        i = 0;
        for( ; !(i >= PLAYING_TEAMS); i = i + 1)
        {
          temp = (struct anonymous_0 *)pos->link[(signed long int)dir];
          if(!(temp == ((struct anonymous_0 *)NULL)))
          {
            new_grad = (signed int)pos->info[(signed long int)i].state.grad + (signed int)pos->side.size;
            if(!(new_grad >= (signed int)temp->info[(signed long int)i].state.grad))
              temp->info[(signed long int)i].state.grad = new_grad;

          }

        }
      }
    }
    default:

      __CPROVER_DUMP_L12:
        ;
  }
}

// sqr255
// file palette.c line 100
static signed int sqr255(signed int i)
{
  signed int result = (i * i) / 256;
  if(result >= 256)
    result = 255;

  return result;
}

// sqrt255
// file palette.c line 87
static signed int sqrt255(signed int i)
{
  signed int result;
  signed int return_value_fsqrt_1;
  return_value_fsqrt_1=fsqrt_link2(i * 256);
  result = return_value_fsqrt_1 / 256;
  if(result >= 256)
    result = 255;

  return result;
}

// standard_big_button
// file dialog.h line 111
void standard_big_button(struct DIALOG *d, signed int x_pos, signed int y_pos, signed int x_num, signed int y_num)
{
  d->proc = my_button_proc;
  signed int return_value_find_center_1;
  return_value_find_center_1=find_center(x_pos, x_num, 100 * 2 + 3, 320);
  signed int return_value_find_center_2;
  return_value_find_center_2=find_center(y_pos, y_num, 15 + 3, 240);
  center_one_dialog(d, return_value_find_center_1, return_value_find_center_2, 100 * 2, 15);
  color_one_dialog(d);
  menu_real_coord(d);
  d->key = 0;
  d->dp = (void *)"";
  d->flags = 1;
}

// standard_button
// file dialog.h line 108
void standard_button(struct DIALOG *d, signed int x_pos, signed int y_pos, signed int x_num, signed int y_num)
{
  d->proc = my_button_proc;
  signed int return_value_find_center_1;
  return_value_find_center_1=find_center(x_pos, x_num, 100 + 3, 320);
  signed int return_value_find_center_2;
  return_value_find_center_2=find_center(y_pos, y_num, 15 + 3, 240);
  center_one_dialog(d, return_value_find_center_1, return_value_find_center_2, 100, 15);
  color_one_dialog(d);
  menu_real_coord(d);
  d->key = 0;
  d->dp = (void *)"";
  d->flags = 1;
}

// standard_error
// file error.c line 80
static signed int standard_error(char *str)
{
  struct DIALOG d[3l];
  memset((void *)d, 0, sizeof(struct DIALOG [3l]) /*216ul*/ );
  color_one_dialog(d);
  d[(signed long int)0].proc = my_textbox_proc;
  d[(signed long int)0].d2 = 0;
  d[(signed long int)0].dp = (void *)str;
  d[(signed long int)0].key = 0;
  d[(signed long int)0].flags = 0;
  d[(signed long int)0].x = 320 / 4;
  d[(signed long int)0].y = (3 * 240) / 8;
  d[(signed long int)0].w = 320 / 2;
  d[(signed long int)0].h = 240 / 4;
  menu_real_coord(d);
  d[(signed long int)1].proc = d_keyboard_proc;
  d[(signed long int)1].dp = (void *)return_d_close;
  d[(signed long int)1].key = 32;
  d[(signed long int)1].d1 = 67;
  d[(signed long int)1].d2 = 59;
  d[(signed long int)2].proc = (signed int (*)(signed int, struct DIALOG *, signed int))(void *)0;
  my_do_dialog(d, 0);
  return 0;
}

// standard_small_button
// file dialog.c line 193
void standard_small_button(struct DIALOG *d, signed int x_pos, signed int y_pos, signed int x_num, signed int y_num)
{
  d->proc = my_button_proc;
  signed int return_value_find_center_1;
  return_value_find_center_1=find_center(x_pos, x_num, 100 / 2 + 3, 320);
  signed int return_value_find_center_2;
  return_value_find_center_2=find_center(y_pos, y_num, 15 + 3, 240);
  center_one_dialog(d, return_value_find_center_1, return_value_find_center_2, 100 / 2, 15);
  color_one_dialog(d);
  menu_real_coord(d);
  d->key = 0;
  d->dp = (void *)"";
  d->flags = 1;
}

// start_graphic
// file init.c line 260
signed int start_graphic(void)
{
  signed int retour;
  signed int return_value_set_resolution_1;
  return_value_set_resolution_1=set_resolution(CONFIG_GFX_MENU, 0, CONFIG_FULLSCREEN, (signed int *)(void *)0);
  retour = (signed int)!(return_value_set_resolution_1 != 0);
  return retour;
}

// start_music
// file music.c line 80
extern signed int start_music(void)
{
  signed int result = 1;
  signed int i;
  if(MIDI_MUSIC_NUMBER >= 0 && !(STARTUP_MUSIC_STATE == 0))
  {
    static signed int last_file = -1;
    if(MIDI_MUSIC_NUMBER >= 2)
      do
      {
        signed long int return_value_random_1;
        return_value_random_1=random();
        i = (signed int)(return_value_random_1 % (signed long int)MIDI_MUSIC_NUMBER);
      }
      while(i == last_file);

    else
      i = 0;
    last_file = i;
    static signed int last_volume = -1;
    if(!(CONFIG_MUSIC_VOLUME == last_volume))
    {
      set_volume(-1, MUSIC_VOLUME_VALUES[(signed long int)CONFIG_MUSIC_VOLUME]);
      last_volume = CONFIG_MUSIC_VOLUME;
    }

    result=play_midi(MIDI_MUSIC[(signed long int)i], -1);
  }

  return result;
}

// start_play_time
// file time.h line 76
void start_play_time(void)
{
  GLOBAL_CLOCK = 2;
  TICKER_START=get_ticker();
  TICKER_PAUSED = 0;
  TICKER_PAUSE_START = 0;
  TIME_ELAPSED = 0;
  TIME_LEFT = TIME_TABLE[(signed long int)LW_CONFIG_CURRENT_RULES.game_time] + 1;
  BELL_RINGING = 0;
  update_play_time();
}

// start_profile
// file profile.h line 72
void start_profile(signed int indice)
{
  PROFILE_DATA[(signed long int)indice].start=get_ticker();
}

// start_ticker
// file ticker.h line 62
signed int start_ticker(void)
{
  signed int result = 0;
  result=install_int_ex(ticker_handler, (signed long int)10 * (1193181L / (signed long int)1000));
  return result;
}

// start_water
// file sound.h line 63
signed int start_water(void)
{
  signed int result = 1;
  signed int i = 0;
  signed long int return_value_random_1;
  for( ; !(i >= 1024); i = i + 1)
  {
    return_value_random_1=random();
    HASARD_VALUE[(signed long int)i] = (signed int)(return_value_random_1 + (signed long int)i);
  }
  if(!(LOADED_WATER == 0))
  {
    WATER_VOLUME = CONFIG_WATER_VOLUME_MENU;
    result=install_int_ex(water_handler, (signed long int)WATER_DELAY * (1193181L / (signed long int)1000));
    water_handler();
  }

  return result;
}

// stop_music
// file music.c line 128
extern void stop_music(void)
{
  if(!(STARTUP_MUSIC_STATE == 0))
    play_midi((struct MIDI *)(void *)0, 0);

}

// stop_profile
// file profile.h line 73
void stop_profile(signed int indice)
{
  PROFILE_DATA[(signed long int)indice].record_number = PROFILE_DATA[(signed long int)indice].record_number + 1;
  signed int return_value_get_ticker_1;
  return_value_get_ticker_1=get_ticker();
  PROFILE_DATA[(signed long int)indice].total_time = PROFILE_DATA[(signed long int)indice].total_time + (return_value_get_ticker_1 - PROFILE_DATA[(signed long int)indice].start);
  if(PROFILE_DATA[(signed long int)indice].record_number >= 20)
  {
    PROFILE_DATA[(signed long int)indice].record_number = PROFILE_DATA[(signed long int)indice].record_number / 2;
    PROFILE_DATA[(signed long int)indice].total_time = PROFILE_DATA[(signed long int)indice].total_time / 2;
  }

}

// stop_ticker
// file ticker.h line 63
void stop_ticker(void)
{
  remove_int(ticker_handler);
}

// stop_water
// file sound.h line 64
void stop_water(void)
{
  remove_int(water_handler);
}

// suppress_conflicting_color
// file team.c line 225
static signed int suppress_conflicting_color(signed int color, signed int replacement_color)
{
  signed int i;
  signed int n = -1;
  i = 0;
  for( ; !(i >= 6); i = i + 1)
    if(CONFIG_TEAM_COLOR[(signed long int)i] == color)
    {
      n = i;
      CONFIG_TEAM_COLOR[(signed long int)n] = replacement_color;
    }

  return n;
}

// team_param
// file team.c line 308
static void team_param(struct DIALOG *d, signed int x, signed int y, signed int number)
{
  signed int w1;
  signed int w2;
  signed int w3;
  signed int h;
  signed int i;
  (d + (signed long int)0)->x = x;
  (d + (signed long int)0)->y = y;
  signed int return_value_menu_real_x_1;
  return_value_menu_real_x_1=menu_real_x(75 - 2 * 3);
  w1 = (return_value_menu_real_x_1 + 2) / 12;
  signed int return_value_menu_real_x_2;
  return_value_menu_real_x_2=menu_real_x(75 - 2 * 3);
  w2 = (return_value_menu_real_x_2 + 2) / 2;
  signed int return_value_menu_real_x_3;
  return_value_menu_real_x_3=menu_real_x(75 - 2 * 3);
  w3 = return_value_menu_real_x_3 + 2;
  signed int return_value_menu_real_y_4;
  return_value_menu_real_y_4=menu_real_y(90 - 2 * 3);
  h = (return_value_menu_real_y_4 + 2) / 6;
  signed int return_value_menu_real_x_5;
  return_value_menu_real_x_5=menu_real_x(3);
  x = x + 2 + return_value_menu_real_x_5;
  signed int return_value_menu_real_y_6;
  return_value_menu_real_y_6=menu_real_y(3);
  y = y + 2 + return_value_menu_real_y_6;
  i = 0;
  for( ; !(i >= 20); i = i + 1)
  {
    (d + (signed long int)i)->proc = my_button_proc;
    (d + (signed long int)i)->key = 0;
    (d + (signed long int)i)->dp = (void *)"";
    (d + (signed long int)i)->flags = 1;
    (d + (signed long int)i)->h = h - 2;
    color_one_dialog(d + (signed long int)i);
  }
  (d + (signed long int)0)->proc = d_box_proc;
  (d + (signed long int)0)->w=menu_real_x(75);
  (d + (signed long int)0)->h=menu_real_y(90);
  (d + (signed long int)1)->proc = d_box_proc;
  (d + (signed long int)2)->x = x;
  (d + (signed long int)1)->x = (d + (signed long int)2)->x;
  (d + (signed long int)2)->y = y;
  (d + (signed long int)1)->y = (d + (signed long int)2)->y;
  (d + (signed long int)2)->w = w3 - 2;
  (d + (signed long int)1)->w = (d + (signed long int)2)->w;
  i = 2;
  for( ; !(i >= 14); i = i + 1)
  {
    (d + (signed long int)i)->x = x + (i - 2) * w1;
    (d + (signed long int)i)->y = y + 2 * h;
    (d + (signed long int)i)->w = w1 - 2;
    (d + (signed long int)i)->bg = 128 + (i - 2) * 10;
  }
  i = 16;
  for( ; !(i >= 20); i = i + 1)
    (d + (signed long int)i)->w = w2 - 2;
  (d + (signed long int)14)->x = (d + (signed long int)1)->x + 1;
  (d + (signed long int)14)->y = (d + (signed long int)1)->y + 1;
  (d + (signed long int)14)->w = (d + (signed long int)1)->w - 2;
  (d + (signed long int)15)->x = x + w2 / 4;
  (d + (signed long int)15)->y = y + h;
  (d + (signed long int)15)->w = (3 * w2) / 2 - 2;
  (d + (signed long int)14)->proc = my_edit_proc;
  (d + (signed long int)14)->dp = (void *)CONFIG_PLAYER_NAME[(signed long int)number];
  (d + (signed long int)14)->d1 = 10;
  (d + (signed long int)14)->flags = 0;
  (d + (signed long int)19)->x = x + w2 / 2;
  (d + (signed long int)16)->x = (d + (signed long int)19)->x;
  (d + (signed long int)17)->x = x;
  (d + (signed long int)18)->x = x + w2;
  (d + (signed long int)16)->y = y + 3 * h;
  (d + (signed long int)18)->y = y + 4 * h;
  (d + (signed long int)17)->y = (d + (signed long int)18)->y;
  (d + (signed long int)19)->y = y + 5 * h;
  char *return_value_get_key_name_7;
  return_value_get_key_name_7=get_key_name(CONFIG_KEY_UP[(signed long int)number]);
  (d + (signed long int)16)->dp = (void *)return_value_get_key_name_7;
  char *return_value_get_key_name_8;
  return_value_get_key_name_8=get_key_name(CONFIG_KEY_LEFT[(signed long int)number]);
  (d + (signed long int)17)->dp = (void *)return_value_get_key_name_8;
  char *return_value_get_key_name_9;
  return_value_get_key_name_9=get_key_name(CONFIG_KEY_RIGHT[(signed long int)number]);
  (d + (signed long int)18)->dp = (void *)return_value_get_key_name_9;
  char *return_value_get_key_name_10;
  return_value_get_key_name_10=get_key_name(CONFIG_KEY_DOWN[(signed long int)number]);
  (d + (signed long int)19)->dp = (void *)return_value_get_key_name_10;
  update_team_box(d, number);
}

// test_army
// file army.c line 240
void test_army(void)
{
  signed int i;
  signed int k;
  signed int test;
  signed int x;
  signed int y;
  struct anonymous_21 f;
  struct anonymous_21 *fp;
  struct anonymous_0 *m;
  i = 0;
  for( ; !(i >= CURRENT_ARMY_SIZE); i = i + 1)
  {
    f.team = (CURRENT_ARMY + (signed long int)i)->team;
    test = (signed int)f.team;
    f.x = (CURRENT_ARMY + (signed long int)i)->x;
    x = (signed int)f.x;
    f.y = (CURRENT_ARMY + (signed long int)i)->y;
    y = (signed int)f.y;
    f.health = (CURRENT_ARMY + (signed long int)i)->health;
    test = (signed int)f.health;
    k = y * CURRENT_AREA_W + x;
    fp = (CURRENT_AREA + (signed long int)k)->fighter;
    m = (CURRENT_AREA + (signed long int)k)->mesh;
    if(!(m == ((struct anonymous_0 *)NULL)))
      test = (signed int)m->info[(signed long int)0].state.grad;

  }
}

// test_mesh
// file mesh.c line 322
void test_mesh(void)
{
  signed int i;
  signed int k;
  i = 0;
  for( ; !(i >= CURRENT_MESH_SIZE); i = i + 1)
  {
    test_one_mesh(CURRENT_MESH + (signed long int)i);
    k = 0;
    for( ; !(k >= 12); k = k + 1)
      if(!((CURRENT_MESH + (signed long int)i)->link[(signed long int)k] == NULL))
        test_one_mesh((struct anonymous_0 *)(CURRENT_MESH + (signed long int)i)->link[(signed long int)k]);

  }
}

// test_one_mesh
// file mesh.c line 306
static void test_one_mesh(struct anonymous_0 *test)
{
  struct anonymous_0 m;
  struct anonymous_0 *bof;
  signed int i;
  m.x = test->x;
  i = (signed int)m.x;
  m.y = test->y;
  i = (signed int)m.y;
  m.side = test->side;
  m.info[(signed long int)(6 - 1)] = test->info[(signed long int)(6 - 1)];
  m.link[(signed long int)(12 - 1)] = test->link[(signed long int)(12 - 1)];
  bof = (struct anonymous_0 *)m.link[(signed long int)(12 - 1)];
}

// texture_8to5
// file texture.c line 222
static void texture_8to5(struct BITMAP *bmp, struct RGB *pal, void *result, signed int first_color, signed int number_of_colors, char *filename)
{
  char *buffer;
  signed int pos = 0;
  signed int pos8 = 0;
  signed int x;
  signed int y;
  signed int i;
  char octet[5l];
  char toadd;
  signed int coul;
  char system_name_buffer[17l];
  lw_serial_set_texture_header(result, (signed short int)bmp->w, (signed short int)bmp->h);
  buffer = (char *)result + (signed long int)((unsigned long int)2 * sizeof(signed short int) /*2ul*/ );
  memset((void *)system_name_buffer, 0, sizeof(char [17l]) /*17ul*/ );
  memset((void *)system_name_buffer, 0, sizeof(char [17l]) /*17ul*/ );
  char *return_value_lw_path_get_system_name_1;
  return_value_lw_path_get_system_name_1=lw_path_get_system_name(filename);
  __builtin_strncpy(system_name_buffer, return_value_lw_path_get_system_name_1, sizeof(char [17l]) /*17ul*/  - (unsigned long int)1);
  system_name_buffer[(signed long int)(sizeof(char [17l]) /*17ul*/  - (unsigned long int)1)] = (char)0;
  memcpy((void *)buffer, (const void *)system_name_buffer, (unsigned long int)16);
  buffer = buffer + (signed long int)16;
  i = 0;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  for( ; !(i >= number_of_colors); i = i + 1)
  {
    tmp_post_2 = pos;
    pos = pos + 1;
    buffer[(signed long int)tmp_post_2] = (char)(pal + (signed long int)(first_color + i))->r;
    tmp_post_3 = pos;
    pos = pos + 1;
    buffer[(signed long int)tmp_post_3] = (char)(pal + (signed long int)(first_color + i))->g;
    tmp_post_4 = pos;
    pos = pos + 1;
    buffer[(signed long int)tmp_post_4] = (char)(pal + (signed long int)(first_color + i))->b;
  }
  i = 0;
  for( ; !(i >= 5); i = i + 1)
    octet[(signed long int)i] = (char)0;
  y = 0;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  signed int tmp_post_6;
  for( ; !(y >= bmp->h); y = y + 1)
  {
    x = 0;
    for( ; !(x >= bmp->w); x = x + 1)
    {
      signed int return_value_getpixel_5;
      return_value_getpixel_5=getpixel_link6(bmp, x, y);
      coul = return_value_getpixel_5 - first_color;
      toadd = (char)(1 << pos8);
      octet[(signed long int)0] = octet[(signed long int)0] | (char)((coul & 1) != 0 ? (signed int)toadd : 0);
      octet[(signed long int)1] = octet[(signed long int)1] | (char)((coul & 2) != 0 ? (signed int)toadd : 0);
      octet[(signed long int)2] = octet[(signed long int)2] | (char)((coul & 4) != 0 ? (signed int)toadd : 0);
      octet[(signed long int)3] = octet[(signed long int)3] | (char)((coul & 8) != 0 ? (signed int)toadd : 0);
      octet[(signed long int)4] = octet[(signed long int)4] | (char)((coul & 16) != 0 ? (signed int)toadd : 0);
      if(pos8 == 7)
        tmp_if_expr_8 = (_Bool)1;

      else
      {
        if(y == bmp->h + -1)
          tmp_if_expr_7 = x == bmp->w - 1 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_8)
      {
        i = 0;
        for( ; !(i >= 5); i = i + 1)
        {
          tmp_post_6 = pos;
          pos = pos + 1;
          buffer[(signed long int)tmp_post_6] = octet[(signed long int)i];
          octet[(signed long int)i] = (char)0;
        }
        pos8 = 0;
      }

      else
        pos8 = pos8 + 1;
    }
  }
}

// ticker_handler
// file ticker.c line 81
static void ticker_handler(void)
{
  TICKER_VALUE = TICKER_VALUE + 10;
}

// try_one_mode
// file gfxmode.c line 147
static signed int try_one_mode(signed int res, signed int flip, signed int fullscreen)
{
  signed int ret;
  signed int w1;
  signed int h1;
  signed int w2;
  signed int h2;
  w1 = GFX_MODE_W[(signed long int)res];
  h1 = GFX_MODE_H[(signed long int)res];
  w2 = GFX_MODE_W[(signed long int)res];
  signed int tmp_if_expr_1;
  if(!(flip == 0))
    tmp_if_expr_1 = GFX_MODE_H[(signed long int)res] * 2;

  else
    tmp_if_expr_1 = GFX_MODE_H[(signed long int)res];
  h2 = tmp_if_expr_1;
  log_print_str("Changing video mode to ");
  log_print_int(w1);
  log_print_str("x");
  log_print_int(h1);
  if(!(fullscreen == 0))
    log_print_str(", fullscreen");

  else
    log_print_str(", windowed");
  if(!(flip == 0))
    log_print_str(", page flipping enabled");

  if(!(fullscreen == 0))
    ret=set_gfx_mode(GFX_MODE_TYPE_FULLSCREEN[(signed long int)res], w1, h1, w2, h2);

  else
    ret=set_gfx_mode(GFX_MODE_TYPE_WINDOWED[(signed long int)res], w1, h1, w2, h2);
  if(ret == 0)
    display_success_driver((char *)gfx_driver->ascii_name);

  else
    display_success(0);
  return ret;
}

// try_server_callback
// file ping.c line 164
static void try_server_callback(void *arg)
{
  signed int result = 0;
  struct anonymous_9 *try_data;
  signed int start_time;
  signed int global_start_time;
  signed int delay[3l];
  signed int i;
  signed int n;
  signed int sum;
  try_data = (struct anonymous_9 *)arg;
  i = 0;
  for( ; !(i >= 3); i = i + 1)
    delay[(signed long int)i] = 0;
  result=lw_sock_connect(&try_data->sock, try_data->address, try_data->port);
  _Bool tmp_if_expr_2;
  signed int return_value_get_ticker_1;
  if(result == 1)
  {
    n = 0;
    global_start_time=get_ticker();
    i = 0;
    do
    {
      if(result == 1 && !(i >= 3))
      {
        return_value_get_ticker_1=get_ticker();
        tmp_if_expr_2 = return_value_get_ticker_1 < global_start_time + 750 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        break;

      start_time=get_ticker();
      result=lw_protocol_do_ping(&try_data->sock);
      if(result == 1)
      {
        signed int return_value_get_ticker_3;
        return_value_get_ticker_3=get_ticker();
        delay[(signed long int)i] = return_value_get_ticker_3 - start_time;
        n = i + 1;
      }

      sum = 0;
      i = 0;
      for( ; !(i >= n); i = i + 1)
        sum = sum + delay[(signed long int)i];
      if(n >= 1)
        try_data->result = sum / n;

      i = i + 1;
    }
    while((_Bool)1);
    try_data->done = 1;
    if(!(result == 0))
      lw_protocol_quit(&try_data->sock);

    lw_sock_close(&try_data->sock);
  }

  while(try_data->allow_exit == 0)
    rest((unsigned int)10);
  free((void *)try_data);
}

// undisp_all_cursors
// file pion.h line 64
void undisp_all_cursors(void)
{
  signed int i = 6 - 1;
  for( ; i >= 0; i = i - 1)
    if(!(CURRENT_CURSOR[(signed long int)i].active == 0))
      undisp_cursor(i);

}

// undisp_cursor
// file pion.c line 198
static void undisp_cursor(signed int number)
{
  signed int i;
  signed int x0;
  signed int y0;
  x0 = CURRENT_CURSOR[(signed long int)number].x;
  y0 = CURRENT_CURSOR[(signed long int)number].y;
  i = 0;
  for( ; !(i >= 68); i = i + 1)
    putpixel_link7(CURRENT_AREA_DISP, x0 + CURSOR_LAYOUT[(signed long int)i].x, y0 + CURSOR_LAYOUT[(signed long int)i].y, (signed int)CURSOR_GRAPHIC_MEMORY[(signed long int)number][(signed long int)i]);
}

// update_choose_map
// file level.c line 410
static void update_choose_map(struct DIALOG *d, signed int map, signed int fg, signed int bg, signed int random, signed int use_default_texture)
{
  signed int res_w;
  signed int res_h;
  signed int just_hidden = 0;
  signed int i;
  signed int return_value_lw_mutex_trylock_2;
  static struct anonymous_1 mutex = { .data=(void *)0 };
  return_value_lw_mutex_trylock_2=lw_mutex_trylock(&mutex);
  if(!(return_value_lw_mutex_trylock_2 == 0))
  {
    CONFIG_LEVEL_MAP = map;
    CONFIG_LEVEL_FG = fg;
    CONFIG_LEVEL_BG = bg;
    LW_RANDOM_ON = random;
    CONFIG_USE_DEFAULT_TEXTURE = use_default_texture;
    scare_mouse();
    set_fg_dialogs_visibility(d, &just_hidden);
    set_bg_dialogs_visibility(d, &just_hidden);
    if(!(just_hidden == 0))
    {
      display_back_image();
      i = 0;
      for( ; !((d + (signed long int)i)->proc == ((signed int (*)(signed int, struct DIALOG *, signed int))NULL)); i = i + 1)
        if((16 & (d + (signed long int)i)->flags) == 0)
          (d + (signed long int)i)->proc(3, d + (signed long int)i, 0);

    }

    box_for_choose_map();
    memset((void *)(char *)(d + (signed long int)13)->dp, 0, (unsigned long int)33);
    snprintf((char *)(d + (signed long int)13)->dp, (unsigned long int)(33 - 1), "%d", CONFIG_LEVEL_MAP + 1);
    ((char *)(d + (signed long int)13)->dp)[(signed long int)(33 - 1)] = (char)0;
    if((16 & (d + 13l)->flags) == 0)
      my_edit_proc(3, d + (signed long int)13, 0);

    memset((void *)(char *)(d + (signed long int)14)->dp, 0, (unsigned long int)33);
    snprintf((char *)(d + (signed long int)14)->dp, (unsigned long int)(33 - 1), "%d", CONFIG_LEVEL_FG + 1);
    ((char *)(d + (signed long int)14)->dp)[(signed long int)(33 - 1)] = (char)0;
    if((16 & (d + 14l)->flags) == 0)
      my_edit_proc(3, d + (signed long int)14, 0);

    memset((void *)(char *)(d + (signed long int)15)->dp, 0, (unsigned long int)33);
    snprintf((char *)(d + (signed long int)15)->dp, (unsigned long int)(33 - 1), "%d", CONFIG_LEVEL_BG + 1);
    ((char *)(d + (signed long int)15)->dp)[(signed long int)(33 - 1)] = (char)0;
    if((16 & (d + 15l)->flags) == 0)
      my_edit_proc(3, d + (signed long int)15, 0);

    (d + (signed long int)4)->d2 = CONFIG_LEVEL_MAP;
    if(CONFIG_LEVEL_FG >= 128)
      (d + (signed long int)5)->d2 = CONFIG_LEVEL_FG - 128;

    if(CONFIG_LEVEL_BG >= 128)
      (d + (signed long int)6)->d2 = CONFIG_LEVEL_BG - 128;

    if(!((d + 4l)->d2 >= 0))
      (d + (signed long int)4)->d2 = (d + (signed long int)4)->d1;

    if(!((d + 4l)->d1 >= (d + 4l)->d2))
      (d + (signed long int)4)->d2 = 0;

    if((16 & (d + 4l)->flags) == 0)
      my_slider_proc(3, d + (signed long int)4, 0);

    if(!((d + 5l)->d2 >= 0))
      (d + (signed long int)5)->d2 = (d + (signed long int)5)->d1;

    if(!((d + 5l)->d1 >= (d + 5l)->d2))
      (d + (signed long int)5)->d2 = 0;

    if((16 & (d + 5l)->flags) == 0)
      my_slider_proc(3, d + (signed long int)5, 0);

    if(!((d + 6l)->d2 >= 0))
      (d + (signed long int)6)->d2 = (d + (signed long int)6)->d1;

    if(!((d + 6l)->d1 >= (d + 6l)->d2))
      (d + (signed long int)6)->d2 = 0;

    if((16 & (d + 6l)->flags) == 0)
      my_slider_proc(3, d + (signed long int)6, 0);

    lw_map_get_res(CONFIG_LEVEL_MAP, &res_w, &res_h, 0, LW_RANDOM_ON, MIN_MAP_RES_W[(signed long int)CONFIG_MIN_MAP_RES], MIN_MAP_RES_H[(signed long int)CONFIG_MIN_MAP_RES]);
    static char res_buffer[30l];
    memset((void *)res_buffer, 0, sizeof(char [30l]) /*30ul*/ );
    snprintf(res_buffer, sizeof(char [30l]) /*30ul*/  - (unsigned long int)1, "%dx%d", res_w, res_h);
    res_buffer[(signed long int)(sizeof(char [30l]) /*30ul*/  - (unsigned long int)1)] = (char)0;
    (d + (signed long int)16)->dp = (void *)res_buffer;
    my_textbox_proc(3, d + (signed long int)16, 0);
    char *return_value_lw_map_get_readable_name_1;
    return_value_lw_map_get_readable_name_1=lw_map_get_readable_name(CONFIG_LEVEL_MAP, 0, LW_RANDOM_ON);
    (d + (signed long int)17)->dp = (void *)return_value_lw_map_get_readable_name_1;
    my_textbox_proc(3, d + (signed long int)17, 0);
    display_chosen_level();
    unscare_mouse();
    lw_mutex_unlock(&mutex);
  }

  else
    log_println_str("Warning: too many calls to \"update_choose_map\"...");
}

// update_connect_menu
// file connect.c line 331
static signed int update_connect_menu(struct DIALOG *d, signed int waited_teams, struct anonymous_12 *team_start_info, struct anonymous_13 *chat_history, signed int *connected_teams_prev)
{
  signed int result = 0;
  signed int i;
  char *sep;
  char buf[200l];
  struct anonymous_24 chat_mess;
  signed int chat_length;
  signed int l;
  signed int connected_teams = 0;
  memset((void *)(char *)(d + (signed long int)4)->dp, 0, (unsigned long int)200);
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(115);
  char *return_value_lw_lang_string_2;
  return_value_lw_lang_string_2=lw_lang_string(116);
  snprintf((char *)(d + (signed long int)4)->dp, (unsigned long int)(200 - 1), "%s%d%s", return_value_lw_lang_string_1, waited_teams, return_value_lw_lang_string_2);
  ((char *)(d + (signed long int)4)->dp)[(signed long int)(200 - 1)] = (char)0;
  ((char *)(d + (signed long int)5)->dp)[(signed long int)0] = (char)0;
  i = 0;
  for( ; !(i >= 6); i = i + 1)
    if(!((team_start_info + (signed long int)i)->active == 0))
    {
      if(!((team_start_info + (signed long int)i)->start == 0))
        sep = "*";

      else
        sep = "-";
      memset((void *)buf, 0, sizeof(char [200l]) /*200ul*/ );
      snprintf(buf, sizeof(char [200l]) /*200ul*/  - (unsigned long int)1, "%d %s %s\n", i + 1, sep, (const void *)(team_start_info + (signed long int)i)->name);
      buf[(signed long int)(sizeof(char [200l]) /*200ul*/  - (unsigned long int)1)] = (char)0;
      signed int len;
      signed int pos;
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen((char *)(d + (signed long int)5)->dp);
      pos = (signed int)return_value_strlen_3;
      len = (6 * 200 - 1) - pos;
      if(len >= 1)
      {
        signed int end;
        __builtin_strncat((char *)(d + (signed long int)5)->dp, buf, (unsigned long int)len);
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(buf);
        end = (signed int)((unsigned long int)pos + return_value_strlen_4);
        if(!(end >= 6))
          ((char *)(d + (signed long int)5)->dp)[(signed long int)end] = (char)0;

      }

      ((char *)(d + (signed long int)5)->dp)[(signed long int)(6 * 200 - 1)] = (char)0;
      connected_teams = connected_teams + 1;
    }

  ((char *)(d + (signed long int)7)->dp)[(signed long int)0] = (char)0;
  i = 0;
  signed int return_value_lw_chat_get_5;
  do
  {
    return_value_lw_chat_get_5=lw_chat_get(chat_history, &chat_mess, i);
    if(return_value_lw_chat_get_5 == 0)
      break;

    memset((void *)buf, 0, sizeof(char [200l]) /*200ul*/ );
    snprintf(buf, sizeof(char [200l]) /*200ul*/  - (unsigned long int)1, "%s: %s\n", (const void *)chat_mess.author, (const void *)chat_mess.content);
    buf[(signed long int)(sizeof(char [200l]) /*200ul*/  - (unsigned long int)1)] = (char)0;
    signed int update_connect_menu__1__3__1__2__len;
    signed int update_connect_menu__1__3__1__2__pos;
    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen((char *)(d + (signed long int)7)->dp);
    update_connect_menu__1__3__1__2__pos = (signed int)return_value_strlen_6;
    update_connect_menu__1__3__1__2__len = (20 * 200 - 1) - update_connect_menu__1__3__1__2__pos;
    if(update_connect_menu__1__3__1__2__len >= 1)
    {
      signed int update_connect_menu__1__3__1__2__1__end;
      __builtin_strncat((char *)(d + (signed long int)7)->dp, buf, (unsigned long int)update_connect_menu__1__3__1__2__len);
      unsigned long int return_value_strlen_7;
      return_value_strlen_7=strlen(buf);
      update_connect_menu__1__3__1__2__1__end = (signed int)((unsigned long int)update_connect_menu__1__3__1__2__pos + return_value_strlen_7);
      if(!(update_connect_menu__1__3__1__2__1__end >= 20))
        ((char *)(d + (signed long int)7)->dp)[(signed long int)update_connect_menu__1__3__1__2__1__end] = (char)0;

    }

    ((char *)(d + (signed long int)7)->dp)[(signed long int)(20 * 200 - 1)] = (char)0;
    i = i + 1;
  }
  while((_Bool)1);
  unsigned long int return_value_strlen_8;
  return_value_strlen_8=strlen((const char *)(d + (signed long int)7)->dp);
  chat_length = (signed int)return_value_strlen_8;
  signed int tmp_if_expr_10;
  static signed int old_chat_length = 0;
  if(!(chat_length == old_chat_length))
  {
    old_chat_length = chat_length;
    signed int return_value_text_height_9;
    return_value_text_height_9=text_height(font);
    l = ((d + (signed long int)7)->h - 8) / return_value_text_height_9;
    if(!((d + 7l)->d1 + -l >= 0))
      tmp_if_expr_10 = 0;

    else
      tmp_if_expr_10 = (d + (signed long int)7)->d1 - l;
    (d + (signed long int)7)->d2 = tmp_if_expr_10;
  }

  scare_mouse();
  (d + (signed long int)4)->proc(3, d + (signed long int)4, 0);
  (d + (signed long int)5)->proc(3, d + (signed long int)5, 0);
  (d + (signed long int)7)->proc(3, d + (signed long int)7, 0);
  unscare_mouse();
  show_mouse(screen);
  _Bool tmp_if_expr_11;
  if(connected_teams >= 1)
    tmp_if_expr_11 = connected_teams > *connected_teams_prev ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_11 = (_Bool)0;
  if(tmp_if_expr_11)
  {
    if(*connected_teams_prev >= 0)
      play_connect();

    *connected_teams_prev = connected_teams;
  }

  else
    if(*connected_teams_prev >= 0)
      *connected_teams_prev = connected_teams;

  return result;
}

// update_key_cpu_cursor
// file move.c line 452
static void update_key_cpu_cursor(signed int indice)
{
  char return_value_get_computer_next_move_1;
  return_value_get_computer_next_move_1=get_computer_next_move(indice);
  CURRENT_CURSOR[(signed long int)indice].key_state = (signed int)return_value_get_computer_next_move_1;
}

// update_key_local_cursor
// file move.c line 429
static void update_key_local_cursor(signed int indice)
{
  signed int return_value_is_touched_key_1;
  return_value_is_touched_key_1=is_touched_key(CONFIG_KEY_UP[(signed long int)indice]);
  CURRENT_CURSOR[(signed long int)indice].key_state = return_value_is_touched_key_1 != 0 ? 1 : 0;
  signed int return_value_is_touched_key_2;
  return_value_is_touched_key_2=is_touched_key(CONFIG_KEY_RIGHT[(signed long int)indice]);
  CURRENT_CURSOR[(signed long int)indice].key_state = CURRENT_CURSOR[(signed long int)indice].key_state + (return_value_is_touched_key_2 != 0 ? 2 : 0);
  signed int return_value_is_touched_key_3;
  return_value_is_touched_key_3=is_touched_key(CONFIG_KEY_DOWN[(signed long int)indice]);
  CURRENT_CURSOR[(signed long int)indice].key_state = CURRENT_CURSOR[(signed long int)indice].key_state + (return_value_is_touched_key_3 != 0 ? 4 : 0);
  signed int return_value_is_touched_key_4;
  return_value_is_touched_key_4=is_touched_key(CONFIG_KEY_LEFT[(signed long int)indice]);
  CURRENT_CURSOR[(signed long int)indice].key_state = CURRENT_CURSOR[(signed long int)indice].key_state + (return_value_is_touched_key_4 != 0 ? 8 : 0);
}

// update_language
// file language.c line 74
static void update_language(struct DIALOG *d)
{
  signed int i;
  quick_buttons(d);
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(28);
  (d + (signed long int)4)->dp = (void *)return_value_lw_lang_string_1;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    char *return_value_lw_lang_language_2;
    return_value_lw_lang_language_2=lw_lang_language(i);
    (d + (signed long int)(i + 5))->dp = (void *)return_value_lw_lang_language_2;
  }
}

// update_logic_rate
// file profile.h line 75
void update_logic_rate(signed int logic_number)
{
  DISPLAY_NUMBER = DISPLAY_NUMBER + 1;
  LOGIC_NUMBER = LOGIC_NUMBER + logic_number;
  if(DISPLAY_NUMBER >= 21)
  {
    DISPLAY_NUMBER = DISPLAY_NUMBER / 2;
    LOGIC_NUMBER = LOGIC_NUMBER / 2;
  }

}

// update_play_time
// file time.h line 75
void update_play_time(void)
{
  signed int return_value_get_ticker_1;
  return_value_get_ticker_1=get_ticker();
  GLOBAL_TICKER = return_value_get_ticker_1 - TICKER_START;
  signed int return_value_get_ticker_3;
  if(!(PAUSE_ON == 0))
  {
    if(TICKER_PAUSE_START == 0)
      TICKER_PAUSE_START=get_ticker();

  }

  else
    if(!(TICKER_PAUSE_START == 0))
    {
      signed int return_value_get_ticker_2;
      return_value_get_ticker_2=get_ticker();
      TICKER_PAUSED = TICKER_PAUSED + (return_value_get_ticker_2 - TICKER_PAUSE_START);
      TICKER_PAUSE_START = 0;
    }

    else
    {
      return_value_get_ticker_3=get_ticker();
      TIME_ELAPSED = ((return_value_get_ticker_3 - TICKER_START) - TICKER_PAUSED) / 1000;
    }
  TIME_LEFT = TIME_TABLE[(signed long int)LW_CONFIG_CURRENT_RULES.game_time] - TIME_ELAPSED;
  if(!(TIME_LEFT >= 0))
    TIME_LEFT = 0;

  if(BELL_RINGING == 0 && !(TIME_LEFT >= 6))
  {
    BELL_RINGING = 1;
    play_time();
  }

}

// update_team_box
// file team.c line 264
static void update_team_box(struct DIALOG *d, signed int number)
{
  char *return_value_lw_lang_string_1;
  char *return_value_lw_lang_string_2;
  char *return_value_lw_lang_string_3;
  switch(CONFIG_CONTROL_TYPE[(signed long int)number])
  {
    case 0:
    {
      return_value_lw_lang_string_1=lw_lang_string(29);
      (d + (signed long int)15)->dp = (void *)return_value_lw_lang_string_1;
      break;
    }
    case 1:
    {
      return_value_lw_lang_string_2=lw_lang_string(30);
      (d + (signed long int)15)->dp = (void *)return_value_lw_lang_string_2;
      break;
    }
    case 2:
    {
      return_value_lw_lang_string_3=lw_lang_string(31);
      (d + (signed long int)15)->dp = (void *)return_value_lw_lang_string_3;
      break;
    }
    default:
      (d + (signed long int)15)->dp = (void *)"???";
  }
  if(CONFIG_CONTROL_TYPE[(signed long int)number] == 0)
    (d + (signed long int)0)->bg = 16;

  else
    (d + (signed long int)0)->bg = 128 + CONFIG_TEAM_COLOR[(signed long int)number] * 10;
}

// update_text_comment
// file internet.c line 507
static void update_text_comment(signed int i)
{
  if(i >= 0)
  {
    if(!(i >= *list_size))
    {
      memset((void *)buffer_comment, 0, sizeof(char [101l]) /*101ul*/ );
      snprintf(buffer_comment, sizeof(char [101l]) /*101ul*/  - (unsigned long int)1, "%s", (const void *)(list_data + (signed long int)i)->comment);
      buffer_comment[(signed long int)(sizeof(char [101l]) /*101ul*/  - (unsigned long int)1)] = (char)0;
    }

    else
    {
      memset((void *)buffer_comment, 0, sizeof(char [101l]) /*101ul*/ );
      __builtin_strncpy(buffer_comment, "", sizeof(char [101l]) /*101ul*/  - (unsigned long int)1);
      buffer_comment[(signed long int)(sizeof(char [101l]) /*101ul*/  - (unsigned long int)1)] = (char)0;
    }
  }

}

// update_text_password
// file internet.c line 396
static void update_text_password(signed int i)
{
  if(i >= 0)
  {
    if(!(i >= *list_size))
    {
      if(!((list_data + (signed long int)i)->password == 0))
      {
        memset((void *)buffer_password, 0, sizeof(char [50l]) /*50ul*/ );
        char *return_value_lw_lang_string_1;
        return_value_lw_lang_string_1=lw_lang_string(94);
        char *return_value_lw_lang_string_2;
        return_value_lw_lang_string_2=lw_lang_string(95);
        snprintf(buffer_password, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "%s: %s", return_value_lw_lang_string_1, return_value_lw_lang_string_2);
        buffer_password[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
      }

      else
      {
        memset((void *)buffer_password, 0, sizeof(char [50l]) /*50ul*/ );
        char *return_value_lw_lang_string_3;
        return_value_lw_lang_string_3=lw_lang_string(94);
        char *return_value_lw_lang_string_4;
        return_value_lw_lang_string_4=lw_lang_string(96);
        snprintf(buffer_password, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "%s: %s", return_value_lw_lang_string_3, return_value_lw_lang_string_4);
        buffer_password[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
      }
    }

    else
    {
      memset((void *)buffer_password, 0, sizeof(char [50l]) /*50ul*/ );
      char *return_value_lw_lang_string_5;
      return_value_lw_lang_string_5=lw_lang_string(94);
      snprintf(buffer_password, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "%s:", return_value_lw_lang_string_5);
      buffer_password[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
    }
  }

}

// update_text_ping
// file internet.c line 340
static void update_text_ping(signed int i)
{
  if(i >= 0)
  {
    if(!(i >= *list_size))
    {
      if((list_data + (signed long int)i)->ping_delay >= 0)
      {
        memset((void *)buffer_ping, 0, sizeof(char [50l]) /*50ul*/ );
        char *return_value_lw_lang_string_1;
        return_value_lw_lang_string_1=lw_lang_string(104);
        char *return_value_lw_lang_string_2;
        return_value_lw_lang_string_2=lw_lang_string(105);
        snprintf(buffer_ping, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "%s: %d %s", return_value_lw_lang_string_1, (list_data + (signed long int)i)->ping_delay, return_value_lw_lang_string_2);
        buffer_ping[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
      }

      else
      {
        memset((void *)buffer_ping, 0, sizeof(char [50l]) /*50ul*/ );
        char *return_value_lw_lang_string_3;
        return_value_lw_lang_string_3=lw_lang_string(103);
        __builtin_strncpy(buffer_ping, return_value_lw_lang_string_3, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1);
        buffer_ping[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
      }
    }

    else
    {
      memset((void *)buffer_ping, 0, sizeof(char [50l]) /*50ul*/ );
      char *return_value_lw_lang_string_4;
      return_value_lw_lang_string_4=lw_lang_string(104);
      snprintf(buffer_ping, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "%s:", return_value_lw_lang_string_4);
      buffer_ping[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
    }
  }

}

// update_text_port
// file internet.c line 373
static void update_text_port(signed int i)
{
  if(i >= 0)
  {
    if(!(i >= *list_size))
    {
      memset((void *)buffer_port, 0, sizeof(char [50l]) /*50ul*/ );
      char *return_value_lw_lang_string_1;
      return_value_lw_lang_string_1=lw_lang_string(93);
      snprintf(buffer_port, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "%s: %d", return_value_lw_lang_string_1, (list_data + (signed long int)i)->port);
      buffer_port[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
    }

    else
    {
      memset((void *)buffer_port, 0, sizeof(char [50l]) /*50ul*/ );
      char *return_value_lw_lang_string_2;
      return_value_lw_lang_string_2=lw_lang_string(93);
      snprintf(buffer_port, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "%s:", return_value_lw_lang_string_2);
      buffer_port[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
    }
  }

}

// update_text_uptime
// file internet.c line 432
static void update_text_uptime(signed int i)
{
  signed int days;
  signed int hours;
  signed int minutes;
  signed int seconds;
  if(i >= 0)
  {
    if(!(i >= *list_size))
    {
      seconds = (list_data + (signed long int)i)->uptime % 60;
      minutes = ((list_data + (signed long int)i)->uptime / 60) % 60;
      hours = ((list_data + (signed long int)i)->uptime / 3600) % 24;
      days = (list_data + (signed long int)i)->uptime / (24 * 3600);
      if(days >= 1)
      {
        if(days >= 2)
        {
          memset((void *)buffer_uptime, 0, sizeof(char [50l]) /*50ul*/ );
          char *return_value_lw_lang_string_1;
          return_value_lw_lang_string_1=lw_lang_string(97);
          char *return_value_lw_lang_string_2;
          return_value_lw_lang_string_2=lw_lang_string(98);
          snprintf(buffer_uptime, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "%s: %d %s", return_value_lw_lang_string_1, days, return_value_lw_lang_string_2);
          buffer_uptime[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
        }

        else
        {
          memset((void *)buffer_uptime, 0, sizeof(char [50l]) /*50ul*/ );
          char *return_value_lw_lang_string_3;
          return_value_lw_lang_string_3=lw_lang_string(97);
          char *return_value_lw_lang_string_4;
          return_value_lw_lang_string_4=lw_lang_string(99);
          snprintf(buffer_uptime, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "%s: 1 %s", return_value_lw_lang_string_3, return_value_lw_lang_string_4);
          buffer_uptime[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
        }
      }

      else
        if(hours >= 1)
        {
          memset((void *)buffer_uptime, 0, sizeof(char [50l]) /*50ul*/ );
          char *return_value_lw_lang_string_5;
          return_value_lw_lang_string_5=lw_lang_string(97);
          char *return_value_lw_lang_string_6;
          return_value_lw_lang_string_6=lw_lang_string(100);
          snprintf(buffer_uptime, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "%s: %d %s", return_value_lw_lang_string_5, hours, return_value_lw_lang_string_6);
          buffer_uptime[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
        }

        else
          if(minutes >= 1)
          {
            memset((void *)buffer_uptime, 0, sizeof(char [50l]) /*50ul*/ );
            char *return_value_lw_lang_string_7;
            return_value_lw_lang_string_7=lw_lang_string(97);
            char *return_value_lw_lang_string_8;
            return_value_lw_lang_string_8=lw_lang_string(101);
            snprintf(buffer_uptime, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "%s: %d %s", return_value_lw_lang_string_7, minutes, return_value_lw_lang_string_8);
            buffer_uptime[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
          }

          else
          {
            memset((void *)buffer_uptime, 0, sizeof(char [50l]) /*50ul*/ );
            char *return_value_lw_lang_string_9;
            return_value_lw_lang_string_9=lw_lang_string(97);
            char *return_value_lw_lang_string_10;
            return_value_lw_lang_string_10=lw_lang_string(102);
            snprintf(buffer_uptime, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "%s: %d %s", return_value_lw_lang_string_9, seconds, return_value_lw_lang_string_10);
            buffer_uptime[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
          }
    }

    else
    {
      memset((void *)buffer_uptime, 0, sizeof(char [50l]) /*50ul*/ );
      char *return_value_lw_lang_string_11;
      return_value_lw_lang_string_11=lw_lang_string(97);
      snprintf(buffer_uptime, sizeof(char [50l]) /*50ul*/  - (unsigned long int)1, "%s:", return_value_lw_lang_string_11);
      buffer_uptime[(signed long int)(sizeof(char [50l]) /*50ul*/  - (unsigned long int)1)] = (char)0;
    }
  }

}

// update_use_default_texture_state
// file level.c line 577
static void update_use_default_texture_state(struct DIALOG *d)
{
  scare_mouse();
  static char state_buffer[30l];
  memset((void *)state_buffer, 0, sizeof(char [30l]) /*30ul*/ );
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(CONFIG_USE_DEFAULT_TEXTURE != 0 ? 132 : 133);
  __builtin_strncpy(state_buffer, return_value_lw_lang_string_1, sizeof(char [30l]) /*30ul*/  - (unsigned long int)1);
  state_buffer[(signed long int)(sizeof(char [30l]) /*30ul*/  - (unsigned long int)1)] = (char)0;
  (d + (signed long int)19)->dp = (void *)state_buffer;
  my_button_proc(3, d + (signed long int)19, 0);
  unscare_mouse();
}

// vline
// file /usr/include/allegro/inline/draw.inl line 67
static inline void vline(struct BITMAP *bmp, signed int x, signed int y_1, signed int y2, signed int color)
{
  _allegro_vline(bmp, x, y_1, y2, color);
}

// vline_link1
// file /usr/include/allegro/inline/draw.inl line 67
static inline void vline_link1(struct BITMAP *bmp_link1, signed int x_link1, signed int y_1_link1, signed int y2_link1, signed int color_link1)
{
  _allegro_vline_link1(bmp_link1, x_link1, y_1_link1, y2_link1, color_link1);
}

// vline_link2
// file /usr/include/allegro/inline/draw.inl line 67
static inline void vline_link2(struct BITMAP *bmp_link2, signed int x_link2, signed int y_1_link2, signed int y2_link2, signed int color_link2)
{
  _allegro_vline_link2(bmp_link2, x_link2, y_1_link2, y2_link2, color_link2);
}

// vline_link3
// file /usr/include/allegro/inline/draw.inl line 67
static inline void vline_link3(struct BITMAP *bmp_link3, signed int x_link3, signed int y_1_link3, signed int y2_link3, signed int color_link3)
{
  _allegro_vline_link3(bmp_link3, x_link3, y_1_link3, y2_link3, color_link3);
}

// wait_key_pressed
// file keyboard.c line 231
signed int wait_key_pressed(void)
{
  signed int touched = 0;
  signed int i;
  signed int result = 0;
  signed int start_tick;
  signed int dummy;
  start_tick=get_ticker();
  lw_mouse_reset_control();
  signed int return_value_get_ticker_1;
  signed int return_value_is_touched_key_2;
  while(touched == 0)
  {
    return_value_get_ticker_1=get_ticker();
    if(return_value_get_ticker_1 >= 10000 + start_tick)
      break;

    dummy=keypressed();
    lw_mouse_update_control();
    my_poll_joystick();
    i = 0;
    for( ; touched == 0 && !(i >= 256); i = i + 1)
    {
      return_value_is_touched_key_2=is_touched_key(i);
      if(!(return_value_is_touched_key_2 == 0))
      {
        touched = 1;
        result = i;
      }

    }
  }
  if(result >= 128)
    result = result - 128;

  return result;
}

// wait_no_key
// file keyboard.c line 202
void wait_no_key(void)
{
  signed int touched;
  signed int i;
  signed int start_tick;
  signed int dummy;
  start_tick=get_ticker();
  lw_mouse_reset_control();
  signed int return_value_is_touched_key_3;
  _Bool tmp_if_expr_2;
  signed int return_value_get_ticker_1;
  do
  {
    dummy=keypressed();
    touched = 0;
    lw_mouse_update_control();
    my_poll_joystick();
    i = 0;
    for( ; !(i >= 256); i = i + 1)
    {
      return_value_is_touched_key_3=is_touched_key(i);
      if(!(return_value_is_touched_key_3 == 0))
        touched = 1;

    }
    if(!(touched == 0))
    {
      return_value_get_ticker_1=get_ticker();
      tmp_if_expr_2 = return_value_get_ticker_1 < start_tick + 1000 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
}

// watchdog_is_keyword
// file watchdog.h line 71
signed int watchdog_is_keyword(char *keyword)
{
  signed int i;
  signed int j;
  signed int l;
  signed int n;
  signed int found = 0;
  char pattern[65l];
  memset((void *)pattern, 0, sizeof(char [65l]) /*65ul*/ );
  snprintf(pattern, sizeof(char [65l]) /*65ul*/  - (unsigned long int)1, "%s%s", (const void *)"ufoot", keyword);
  pattern[(signed long int)(sizeof(char [65l]) /*65ul*/  - (unsigned long int)1)] = (char)0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(pattern);
  l = (signed int)return_value_strlen_1;
  n = (WATCHDOG_KEYS_IN_BUFFER - l) + 1;
  i = 0;
  for( ; found == 0 && !(i >= n); i = i + 1)
  {
    j = 0;
    for( ; !(pattern[(signed long int)j] == 0); j = j + 1)
      if(!((signed int)pattern[(signed long int)j] == (0xFF & (signed int)(char)WATCHDOG_BUFFER[(signed long int)(i + j)])))
        break;

    found = (signed int)!(pattern[(signed long int)j] != 0);
  }
  if(!(found == 0))
    WATCHDOG_BUFFER[(signed long int)i] = WATCHDOG_BUFFER[(signed long int)i] | 0xFF;

  return found;
}

// watchdog_reset
// file watchdog.h line 70
void watchdog_reset()
{
  WATCHDOG_KEYS_IN_BUFFER = 0;
  watchdog_update();
}

// watchdog_update
// file watchdog.h line 69
void watchdog_update()
{
  signed int i;
  signed int n;
  signed int old_pos = WATCHDOG_KEYS_IN_BUFFER;
  i = 0;
  for( ; !(i >= 256); i = i + 1)
    WATCHDOG_ASCII[(signed long int)i] = (char)0;
  i = 0;
  for( ; !(i >= 128); i = i + 1)
    WATCHDOG_SCANCODE[(signed long int)i] = (char)0;
  n = WATCHDOG_KEYS_IN_BUFFER - 64;
  if(n >= 65)
  {
    i = n;
    for( ; !(i >= WATCHDOG_KEYS_IN_BUFFER); i = i + 1)
      WATCHDOG_BUFFER[(signed long int)(i - n)] = WATCHDOG_BUFFER[(signed long int)i];
    WATCHDOG_KEYS_IN_BUFFER = WATCHDOG_KEYS_IN_BUFFER - n;
    old_pos = old_pos - n;
  }

  signed int return_value_keypressed_1;
  signed int tmp_post_2;
  do
  {
    return_value_keypressed_1=keypressed();
    if(return_value_keypressed_1 == 0)
      break;

    if(WATCHDOG_KEYS_IN_BUFFER >= 1024)
      break;

    tmp_post_2 = WATCHDOG_KEYS_IN_BUFFER;
    WATCHDOG_KEYS_IN_BUFFER = WATCHDOG_KEYS_IN_BUFFER + 1;
    WATCHDOG_BUFFER[(signed long int)tmp_post_2]=readkey();
  }
  while((_Bool)1);
  i = old_pos;
  for( ; !(i >= WATCHDOG_KEYS_IN_BUFFER); i = i + 1)
  {
    WATCHDOG_ASCII[(signed long int)(WATCHDOG_BUFFER[(signed long int)i] & 0xFF)] = (char)1;
    WATCHDOG_SCANCODE[(signed long int)(WATCHDOG_BUFFER[(signed long int)i] >> 8)] = (char)1;
  }
}

// water_handler
// file sound.c line 89
static void water_handler(void)
{
  signed int pan;
  signed int hasard;
  HASARD_INDEX = HASARD_INDEX + 1;
  HASARD_INDEX = HASARD_INDEX % 1024;
  if(WATER_VOLUME >= 1)
  {
    if(!(HASARD_INDEX % 2 == 0))
      pan = 192;

    else
      pan = 64;
    hasard = HASARD_VALUE[(signed long int)HASARD_INDEX] % SAMPLE_WATER_NUMBER;
    play_sample(SAMPLE_WATER[(signed long int)hasard], SOUND_VOLUME_VALUES[(signed long int)WATER_VOLUME], pan, 1000, 0);
  }

}

// wave_options
// file wave.h line 66
signed int wave_options(void)
{
  signed int *temp;
  struct DIALOG d[24l];
  struct DIALOG_PLAYER *dp;
  signed int i;
  signed int j;
  signed int k;
  signed int choix = 4;
  signed int retour = 0;
  memset((void *)d, 0, sizeof(struct DIALOG [24l]) /*1728ul*/ );
  display_back_image();
  i = 0;
  for( ; !(i >= 5); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 4); j = j + 1)
      if(i >= 1 || j >= 1)
      {
        k = i * 4 + j + 3;
        standard_small_button(d + (signed long int)k, j, i, 4, 5);
        if(i >= 1 && j >= 1)
        {
          d[(signed long int)k].proc = my_slider_proc;
          d[(signed long int)k].dp = (void *)0;
          d[(signed long int)k].dp2 = (void *)slider_int;
          switch(j)
          {
            case 1:
            {
              d[(signed long int)k].d1 = 16;
              d[(signed long int)k].dp3 = (void *)&CONFIG_WAVE_AMPLI[(signed long int)(i - 1)];
              break;
            }
            case 2:
            {
              d[(signed long int)k].d1 = 4;
              d[(signed long int)k].dp3 = (void *)&CONFIG_WAVE_NUMBER[(signed long int)(i - 1)];
              break;
            }
            case 3:
            {
              d[(signed long int)k].d1 = 16;
              d[(signed long int)k].dp3 = (void *)&CONFIG_WAVE_SPEED[(signed long int)(i - 1)];
            }
          }
          temp = (signed int *)d[(signed long int)k].dp3;
          d[(signed long int)k].d2 = *temp;
        }

        else
          d[(signed long int)k].proc = my_textbox_proc;
      }

  }
  d[(signed long int)23].proc = (signed int (*)(signed int, struct DIALOG *, signed int))(void *)0;
  quick_buttons(d);
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(106);
  d[(signed long int)4].dp = (void *)return_value_lw_lang_string_1;
  char *return_value_lw_lang_string_2;
  return_value_lw_lang_string_2=lw_lang_string(107);
  d[(signed long int)5].dp = (void *)return_value_lw_lang_string_2;
  char *return_value_lw_lang_string_3;
  return_value_lw_lang_string_3=lw_lang_string(108);
  d[(signed long int)6].dp = (void *)return_value_lw_lang_string_3;
  char *return_value_lw_lang_string_4;
  return_value_lw_lang_string_4=lw_lang_string(109);
  d[(signed long int)7].dp = (void *)return_value_lw_lang_string_4;
  char *return_value_lw_lang_string_5;
  return_value_lw_lang_string_5=lw_lang_string(110);
  d[(signed long int)11].dp = (void *)return_value_lw_lang_string_5;
  char *return_value_lw_lang_string_6;
  return_value_lw_lang_string_6=lw_lang_string(111);
  d[(signed long int)15].dp = (void *)return_value_lw_lang_string_6;
  char *return_value_lw_lang_string_7;
  return_value_lw_lang_string_7=lw_lang_string(112);
  d[(signed long int)19].dp = (void *)return_value_lw_lang_string_7;
  display_back_image();
  signed int return_value_my_update_dialog_8;
  while(retour == 0)
  {
    dp=my_init_dialog(d, choix);
    do
    {
      return_value_my_update_dialog_8=my_update_dialog(dp);
      if(return_value_my_update_dialog_8 == 0)
        break;

    }
    while((_Bool)1);
    choix=shutdown_dialog(dp);
    if(!(choix == 3) && !(choix == -1))
    {
      if(choix == 2)
        goto __CPROVER_DUMP_L15;

      if(choix == 0)
        goto __CPROVER_DUMP_L16;

      if(choix == 1)
        goto __CPROVER_DUMP_L19;

    }

    else
    {
      retour = 1;
      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L15:
      ;
      retour = -1;
      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L16:
      ;
      signed int return_value_confirm_quit_9;
      return_value_confirm_quit_9=confirm_quit();
      if(!(return_value_confirm_quit_9 == 0))
        retour = -2;

      else
        display_back_image();
      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L19:
      ;
      retour = -3;
    }

  __CPROVER_DUMP_L20:
    ;
  }
  if(retour >= 1)
    retour = retour - 1;

  return retour;
}

// write_cis_setting
// file rules.c line 84
static void write_cis_setting(struct DIALOG *d)
{
  char *str = (char *)d->dp;
  memset((void *)str, 0, (unsigned long int)30);
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(59);
  snprintf(str, (unsigned long int)(30 - 1), "%s x%d", return_value_lw_lang_string_1, CONFIG_CURSOR_INCREASE_SPEED + 1);
  str[(signed long int)(30 - 1)] = (char)0;
}

// write_fps_setting
// file speeds.c line 82
static void write_fps_setting(struct DIALOG *d)
{
  char *str = (char *)d->dp;
  if(!(DISPLAY_DELAY_MIN[(signed long int)CONFIG_FRAMES_PER_SEC_LIMIT] == 0))
  {
    memset((void *)str, 0, (unsigned long int)33);
    char *return_value_lw_lang_string_1;
    return_value_lw_lang_string_1=lw_lang_string(77);
    snprintf(str, (unsigned long int)(33 - 1), "%d %s", 1000 / DISPLAY_DELAY_MIN[(signed long int)CONFIG_FRAMES_PER_SEC_LIMIT], return_value_lw_lang_string_1);
    str[(signed long int)(33 - 1)] = (char)0;
  }

  else
  {
    memset((void *)str, 0, (unsigned long int)33);
    char *return_value_lw_lang_string_2;
    return_value_lw_lang_string_2=lw_lang_string(78);
    __builtin_strncpy(str, return_value_lw_lang_string_2, (unsigned long int)(33 - 1));
    str[(signed long int)(33 - 1)] = (char)0;
  }
}

// write_mmr_setting
// file rules.c line 155
static void write_mmr_setting(struct DIALOG *d)
{
  char *str = (char *)d->dp;
  memset((void *)str, 0, (unsigned long int)50);
  char *return_value_lw_lang_string_1;
  return_value_lw_lang_string_1=lw_lang_string(61);
  snprintf(str, (unsigned long int)(50 - 1), "%s%dx%d", return_value_lw_lang_string_1, MIN_MAP_RES_W[(signed long int)CONFIG_MIN_MAP_RES], MIN_MAP_RES_H[(signed long int)CONFIG_MIN_MAP_RES]);
  str[(signed long int)(50 - 1)] = (char)0;
}

// write_rps_setting
// file speeds.c line 126
static void write_rps_setting(struct DIALOG *d)
{
  char *str = (char *)d->dp;
  if(!(LOGIC_DELAY_MIN[(signed long int)CONFIG_ROUNDS_PER_SEC_LIMIT] == 0))
  {
    memset((void *)str, 0, (unsigned long int)33);
    char *return_value_lw_lang_string_1;
    return_value_lw_lang_string_1=lw_lang_string(79);
    snprintf(str, (unsigned long int)(33 - 1), "%d %s", 1000 / LOGIC_DELAY_MIN[(signed long int)CONFIG_ROUNDS_PER_SEC_LIMIT], return_value_lw_lang_string_1);
    str[(signed long int)(33 - 1)] = (char)0;
  }

  else
  {
    memset((void *)str, 0, (unsigned long int)33);
    char *return_value_lw_lang_string_2;
    return_value_lw_lang_string_2=lw_lang_string(80);
    __builtin_strncpy(str, return_value_lw_lang_string_2, (unsigned long int)(33 - 1));
    str[(signed long int)(33 - 1)] = (char)0;
  }
}

// write_score
// file score.c line 130
static void write_score(signed int indice, char *buffer, signed int fill_level)
{
  signed int write_score__1__time;
  signed int min;
  signed int sec;
  signed int pourmille;
  signed int pourcent;
  signed int decimale;
  signed int tombola;
  if(indice >= 0)
  {
    if(!(fill_level >= 0))
      fill_level = 0;

    if(fill_level >= 1001)
      fill_level = 1000;

    if(STARTUP_TOMBOLA == 0)
    {
      if(CURRENT_CURSOR[(signed long int)indice].score_order == 1 && PLAYING_TEAMS == 1)
      {
        memset((void *)buffer, 0, (unsigned long int)33);
        char *return_value_lw_lang_string_1;
        return_value_lw_lang_string_1=lw_lang_string(160);
        __builtin_strncpy(buffer, return_value_lw_lang_string_1, (unsigned long int)(33 - 1));
        buffer[(signed long int)(33 - 1)] = (char)0;
      }

      else
        if(!(CURRENT_CURSOR[(signed long int)indice].loose_time >= 1))
        {
          pourmille = (ACTIVE_FIGHTERS[(signed long int)CURRENT_CURSOR[(signed long int)indice].team] * fill_level) / CURRENT_ARMY_SIZE;
          pourcent = pourmille / 10;
          decimale = pourmille % 10;
          memset((void *)buffer, 0, (unsigned long int)33);
          snprintf(buffer, (unsigned long int)(33 - 1), "%d.%01d%%", pourcent, decimale);
          buffer[(signed long int)(33 - 1)] = (char)0;
        }

        else
        {
          write_score__1__time = (CURRENT_CURSOR[(signed long int)indice].loose_time * fill_level) / 1000;
          min = write_score__1__time / 60;
          sec = write_score__1__time % 60;
          memset((void *)buffer, 0, (unsigned long int)33);
          snprintf(buffer, (unsigned long int)(33 - 1), "%02d:%02d", min, sec);
          buffer[(signed long int)(33 - 1)] = (char)0;
        }
    }

    else
    {
      tombola = (LW_SCORE_TOMBOLA_RESULT[(signed long int)indice] * fill_level) / 1000;
      memset((void *)buffer, 0, (unsigned long int)33);
      snprintf(buffer, (unsigned long int)(33 - 1), "%03d", tombola);
      buffer[(signed long int)(33 - 1)] = (char)0;
    }
  }

  else
  {
    memset((void *)buffer, 0, (unsigned long int)33);
    __builtin_strncpy(buffer, "", (unsigned long int)(33 - 1));
    buffer[(signed long int)(33 - 1)] = (char)0;
  }
}

// write_time
// file time.h line 77
void write_time(signed int time, char *buffer)
{
  signed int min;
  signed int sec;
  min = time / 60;
  sec = time % 60;
  buffer[(signed long int)0] = (char)(48 + min / 10);
  buffer[(signed long int)1] = (char)(48 + min % 10);
  buffer[(signed long int)2] = (char)58;
  buffer[(signed long int)3] = (char)(48 + sec / 10);
  buffer[(signed long int)4] = (char)(48 + sec % 10);
  buffer[(signed long int)5] = (char)0;
}

// write_time_setting
// file rules.c line 118
static void write_time_setting(struct DIALOG *d)
{
  char *str = (char *)d->dp;
  start_play_time();
  write_time(TIME_LEFT, str + (signed long int)8);
}

