// #anon_enum_AV_CLASS_CATEGORY_NA=0_AV_CLASS_CATEGORY_INPUT=1_AV_CLASS_CATEGORY_OUTPUT=2_AV_CLASS_CATEGORY_MUXER=3_AV_CLASS_CATEGORY_DEMUXER=4_AV_CLASS_CATEGORY_ENCODER=5_AV_CLASS_CATEGORY_DECODER=6_AV_CLASS_CATEGORY_FILTER=7_AV_CLASS_CATEGORY_BITSTREAM_FILTER=8_AV_CLASS_CATEGORY_SWSCALER=9_AV_CLASS_CATEGORY_SWRESAMPLER=10_AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT=40_AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT=41_AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT=42_AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT=43_AV_CLASS_CATEGORY_DEVICE_OUTPUT=44_AV_CLASS_CATEGORY_DEVICE_INPUT=45_AV_CLASS_CATEGORY_NB=46
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 29
enum anonymous_26 { AV_CLASS_CATEGORY_NA=0, AV_CLASS_CATEGORY_INPUT=1, AV_CLASS_CATEGORY_OUTPUT=2, AV_CLASS_CATEGORY_MUXER=3, AV_CLASS_CATEGORY_DEMUXER=4, AV_CLASS_CATEGORY_ENCODER=5, AV_CLASS_CATEGORY_DECODER=6, AV_CLASS_CATEGORY_FILTER=7, AV_CLASS_CATEGORY_BITSTREAM_FILTER=8, AV_CLASS_CATEGORY_SWSCALER=9, AV_CLASS_CATEGORY_SWRESAMPLER=10, AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT=40, AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT=41, AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT=42, AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT=43, AV_CLASS_CATEGORY_DEVICE_OUTPUT=44, AV_CLASS_CATEGORY_DEVICE_INPUT=45, AV_CLASS_CATEGORY_NB=46 };

// #anon_enum_DECODE_STOPPED=0_DECODE_READY=1_DECODE_RUNNING=2_DECODE_COMPLETE=3_DECODE_ERROR=4
// file squeezelite.h line 460
enum anonymous_23 { DECODE_STOPPED=0, DECODE_READY=1, DECODE_RUNNING=2, DECODE_COMPLETE=3, DECODE_ERROR=4 };

// #anon_enum_DISCONNECT_OK=0_LOCAL_DISCONNECT=1_REMOTE_DISCONNECT=2_UNREACHABLE=3_TIMEOUT=4
// file squeezelite.h line 436
enum anonymous_0 { DISCONNECT_OK=0, LOCAL_DISCONNECT=1, REMOTE_DISCONNECT=2, UNREACHABLE=3, TIMEOUT=4 };

// #anon_enum_EVENT_TIMEOUT=0_EVENT_READ=1_EVENT_WAKE=2
// file squeezelite.h line 373
enum anonymous_9 { EVENT_TIMEOUT=0, EVENT_READ=1, EVENT_WAKE=2 };

// #anon_enum_FADE_INACTIVE=0_FADE_DUE=1_FADE_ACTIVE=2
// file squeezelite.h line 522
enum anonymous_3 { FADE_INACTIVE=0, FADE_DUE=1, FADE_ACTIVE=2 };

// #anon_enum_FADE_NONE=0_FADE_CROSSFADE=1_FADE_IN=2_FADE_OUT=3_FADE_INOUT=4
// file squeezelite.h line 524
enum anonymous_5 { FADE_NONE=0, FADE_CROSSFADE=1, FADE_IN=2, FADE_OUT=3, FADE_INOUT=4 };

// #anon_enum_FADE_UP=1_FADE_DOWN=2_FADE_CROSS=3
// file squeezelite.h line 523
enum anonymous_4 { FADE_UP=1, FADE_DOWN=2, FADE_CROSS=3 };

// #anon_enum_FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT=0_FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE=1_FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE=2_FLAC__CHANNEL_ASSIGNMENT_MID_SIDE=3
// file /usr/include/FLAC/format.h line 381
enum anonymous_38 { FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT=0, FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE=1, FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE=2, FLAC__CHANNEL_ASSIGNMENT_MID_SIDE=3 };

// #anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1
// file /usr/include/FLAC/format.h line 194
enum anonymous_30 { FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0, FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1 };

// #anon_enum_FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER=0_FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER=1
// file /usr/include/FLAC/format.h line 396
enum anonymous_39 { FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER=0, FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER=1 };

// #anon_enum_FLAC__METADATA_TYPE_STREAMINFO=0_FLAC__METADATA_TYPE_PADDING=1_FLAC__METADATA_TYPE_APPLICATION=2_FLAC__METADATA_TYPE_SEEKTABLE=3_FLAC__METADATA_TYPE_VORBIS_COMMENT=4_FLAC__METADATA_TYPE_CUESHEET=5_FLAC__METADATA_TYPE_PICTURE=6_FLAC__METADATA_TYPE_UNDEFINED=7_FLAC__MAX_METADATA_TYPE=126
// file /usr/include/FLAC/format.h line 489
enum anonymous_46 { FLAC__METADATA_TYPE_STREAMINFO=0, FLAC__METADATA_TYPE_PADDING=1, FLAC__METADATA_TYPE_APPLICATION=2, FLAC__METADATA_TYPE_SEEKTABLE=3, FLAC__METADATA_TYPE_VORBIS_COMMENT=4, FLAC__METADATA_TYPE_CUESHEET=5, FLAC__METADATA_TYPE_PICTURE=6, FLAC__METADATA_TYPE_UNDEFINED=7, FLAC__MAX_METADATA_TYPE=126 };

// #anon_enum_FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC=0_FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER=1_FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH=2_FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM=3
// file /usr/include/FLAC/stream_decoder.h line 427
enum anonymous_68 { FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC=0, FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER=1, FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH=2, FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM=3 };

// #anon_enum_FLAC__STREAM_DECODER_INIT_STATUS_OK=0_FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER=1_FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS=2_FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR=3_FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE=4_FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED=5
// file /usr/include/FLAC/stream_decoder.h line 256
enum anonymous_63 { FLAC__STREAM_DECODER_INIT_STATUS_OK=0, FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER=1, FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS=2, FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR=3, FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE=4, FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED=5 };

// #anon_enum_FLAC__STREAM_DECODER_LENGTH_STATUS_OK=0_FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR=1_FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED=2
// file /usr/include/FLAC/stream_decoder.h line 371
enum anonymous_67 { FLAC__STREAM_DECODER_LENGTH_STATUS_OK=0, FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR=1, FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED=2 };

// #anon_enum_FLAC__STREAM_DECODER_READ_STATUS_CONTINUE=0_FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM=1_FLAC__STREAM_DECODER_READ_STATUS_ABORT=2
// file /usr/include/FLAC/stream_decoder.h line 294
enum anonymous_64 { FLAC__STREAM_DECODER_READ_STATUS_CONTINUE=0, FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM=1, FLAC__STREAM_DECODER_READ_STATUS_ABORT=2 };

// #anon_enum_FLAC__STREAM_DECODER_SEARCH_FOR_METADATA=0_FLAC__STREAM_DECODER_READ_METADATA=1_FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC=2_FLAC__STREAM_DECODER_READ_FRAME=3_FLAC__STREAM_DECODER_END_OF_STREAM=4_FLAC__STREAM_DECODER_OGG_ERROR=5_FLAC__STREAM_DECODER_SEEK_ERROR=6_FLAC__STREAM_DECODER_ABORTED=7_FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR=8_FLAC__STREAM_DECODER_UNINITIALIZED=9
// file /usr/include/FLAC/stream_decoder.h line 202
enum anonymous_62 { FLAC__STREAM_DECODER_SEARCH_FOR_METADATA=0, FLAC__STREAM_DECODER_READ_METADATA=1, FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC=2, FLAC__STREAM_DECODER_READ_FRAME=3, FLAC__STREAM_DECODER_END_OF_STREAM=4, FLAC__STREAM_DECODER_OGG_ERROR=5, FLAC__STREAM_DECODER_SEEK_ERROR=6, FLAC__STREAM_DECODER_ABORTED=7, FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR=8, FLAC__STREAM_DECODER_UNINITIALIZED=9 };

// #anon_enum_FLAC__STREAM_DECODER_SEEK_STATUS_OK=0_FLAC__STREAM_DECODER_SEEK_STATUS_ERROR=1_FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED=2
// file /usr/include/FLAC/stream_decoder.h line 325
enum anonymous_65 { FLAC__STREAM_DECODER_SEEK_STATUS_OK=0, FLAC__STREAM_DECODER_SEEK_STATUS_ERROR=1, FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED=2 };

// #anon_enum_FLAC__STREAM_DECODER_TELL_STATUS_OK=0_FLAC__STREAM_DECODER_TELL_STATUS_ERROR=1_FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED=2
// file /usr/include/FLAC/stream_decoder.h line 348
enum anonymous_66 { FLAC__STREAM_DECODER_TELL_STATUS_OK=0, FLAC__STREAM_DECODER_TELL_STATUS_ERROR=1, FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED=2 };

// #anon_enum_FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE=0_FLAC__STREAM_DECODER_WRITE_STATUS_ABORT=1
// file /usr/include/FLAC/stream_decoder.h line 394
enum anonymous_42 { FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE=0, FLAC__STREAM_DECODER_WRITE_STATUS_ABORT=1 };

// #anon_enum_FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2_FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3_FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5_FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7_FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8_FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10_FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11_FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12_FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15_FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16_FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17_FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19_FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20_FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21
// file /usr/include/FLAC/format.h line 732
enum anonymous_57 { FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0, FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1, FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2, FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3, FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4, FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5, FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6, FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7, FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8, FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9, FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10, FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11, FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12, FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13, FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14, FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15, FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16, FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17, FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18, FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19, FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20, FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21 };

// #anon_enum_FLAC__SUBFRAME_TYPE_CONSTANT=0_FLAC__SUBFRAME_TYPE_VERBATIM=1_FLAC__SUBFRAME_TYPE_FIXED=2_FLAC__SUBFRAME_TYPE_LPC=3
// file /usr/include/FLAC/format.h line 267
enum anonymous_36 { FLAC__SUBFRAME_TYPE_CONSTANT=0, FLAC__SUBFRAME_TYPE_VERBATIM=1, FLAC__SUBFRAME_TYPE_FIXED=2, FLAC__SUBFRAME_TYPE_LPC=3 };

// #anon_enum_OUTPUT_OFF=-1_OUTPUT_STOPPED=0_OUTPUT_BUFFER=1_OUTPUT_RUNNING=2_OUTPUT_PAUSE_FRAMES=3_OUTPUT_SKIP_FRAMES=4_OUTPUT_START_AT=5
// file squeezelite.h line 517
enum anonymous_1 { OUTPUT_OFF=-1, OUTPUT_STOPPED=0, OUTPUT_BUFFER=1, OUTPUT_RUNNING=2, OUTPUT_PAUSE_FRAMES=3, OUTPUT_SKIP_FRAMES=4, OUTPUT_START_AT=5 };

// #anon_enum_S32_LE=0_S24_LE=1_S24_3LE=2_S16_LE=3
// file squeezelite.h line 520
enum anonymous_22 { S32_LE=0, S24_LE=1, S24_3LE=2, S16_LE=3 };

// #anon_enum_SOXR_FLOAT32=0_SOXR_FLOAT64=1_SOXR_INT32=2_SOXR_INT16=3_SOXR_SPLIT=4_SOXR_FLOAT32_I=0_SOXR_FLOAT64_I=1_SOXR_INT32_I=2_SOXR_INT16_I=3_SOXR_FLOAT32_S=4_SOXR_FLOAT64_S=5_SOXR_INT32_S=6_SOXR_INT16_S=7
// file /usr/include/soxr.h line 209
enum anonymous_10 { SOXR_FLOAT32=0, SOXR_FLOAT64=1, SOXR_INT32=2, SOXR_INT16=3, SOXR_SPLIT=4, SOXR_FLOAT32_I=0, SOXR_FLOAT64_I=1, SOXR_INT32_I=2, SOXR_INT16_I=3, SOXR_FLOAT32_S=4, SOXR_FLOAT64_S=5, SOXR_INT32_S=6, SOXR_INT16_S=7 };

// #anon_enum_STOPPED=0_DISCONNECT=1_STREAMING_WAIT=2_STREAMING_BUFFERING=3_STREAMING_FILE=4_STREAMING_HTTP=5_SEND_HEADERS=6_RECV_HEADERS=7
// file squeezelite.h line 434
enum anonymous_14 { STOPPED=0, DISCONNECT=1, STREAMING_WAIT=2, STREAMING_BUFFERING=3, STREAMING_FILE=4, STREAMING_HTTP=5, SEND_HEADERS=6, RECV_HEADERS=7 };

// #anon_enum_UNKNOWN=0_DSF=1_DSDIFF=2
// file dsd.c line 63
enum anonymous_20 { UNKNOWN=0, DSF=1, DSDIFF=2 };

// #anon_enum_UNKNOWN=0_WAVE=1_AIFF=2
// file pcm.c line 66
enum anonymous_71 { anonymous_71__UNKNOWN=0, WAVE=1, AIFF=2 };

// #anon_enum_lERROR=0_lWARN=1_lINFO=2_lDEBUG=3_lSDEBUG=4
// file squeezelite.h line 361
enum anonymous_8 { lERROR=0, lWARN=1, lINFO=2, lDEBUG=3, lSDEBUG=4 };

// tag-#anon#ST[*{S8}_S8_'cmd'|U32'code'|U32'_pad0']
// file ir.c line 65
struct anonymous_24;

// tag-#anon#ST[*{S8}_S8_'lirc'|U32'code'|B'repeat'|U24'_pad0']
// file ir.c line 83
struct anonymous_25;

// tag-#anon#ST[*{SYM#tag-FLAC__StreamDecoderProtected#}_SYM#tag-FLAC__StreamDecoderProtected#_'protected_'|*{SYM#tag-FLAC__StreamDecoderPrivate#}_SYM#tag-FLAC__StreamDecoderPrivate#_'private_']
// file /usr/include/FLAC/stream_decoder.h line 463
struct anonymous_43;

// tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']
// file /usr/include/FLAC/format.h line 214
struct anonymous_69;

// tag-#anon#ST[*{U64(*{V}_V_|U64|U64|*{V}_V_)->U64}_U64(*{V}_V_|U64|U64|*{V}_V_)->U64_'read_func'|*{S32(*{V}_V_|S64|S32)->S32}_S32(*{V}_V_|S64|S32)->S32_'seek_func'|*{S32(*{V}_V_)->S32}_S32(*{V}_V_)->S32_'close_func'|*{S64(*{V}_V_)->S64}_S64(*{V}_V_)->S64_'tell_func']
// file /usr/include/vorbis/vorbisfile.h line 39
struct anonymous_75;

// tag-#anon#ST[*{U8}_U8_'body_data'|S64'body_storage'|S64'body_fill'|S64'body_returned'|*{S32}_S32_'lacing_vals'|*{S64}_S64_'granule_vals'|S64'lacing_storage'|S64'lacing_fill'|S64'lacing_packet'|S64'lacing_returned'|ARR282{U8}_U8_'header'|U16'_pad0'|S32'header_fill'|S32'e_o_s'|S32'b_o_s'|S64'serialno'|S64'pageno'|S64'packetno'|S64'granulepos']
// file /usr/include/ogg/ogg.h line 53
struct anonymous_74;

// tag-#anon#ST[*{U8}_U8_'data']
// file /usr/include/FLAC/format.h line 827
struct anonymous_59;

// tag-#anon#ST[*{U8}_U8_'data'|S32'storage'|S32'fill'|S32'returned'|S32'unsynced'|S32'headerbytes'|S32'bodybytes']
// file /usr/include/ogg/ogg.h line 105
struct anonymous_73;

// tag-#anon#ST[*{cS32}_cS32_'data']
// file /usr/include/FLAC/format.h line 291
struct anonymous_29;

// tag-#anon#ST[ARR129{S8}_S8_'media_catalog_number'|U56'_pad0'|U64'lead_in'|S32'is_cd'|U32'num_tracks'|*{SYM#tag-#anon#ST[U64'offset'|U8'number'|ARR13{S8}_S8_'isrc'|BF{U32}_U32_'type'|BF{U32}_U32_'pre_emphasis'|BF{U6}_U6_'_bit_field_pad0'|U8'num_indices'|*{SYM#tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']#}_SYM#tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']#_'indices']#}_SYM#tag-#anon#ST[U64'offset'|U8'number'|ARR13{S8}_S8_'isrc'|BF{U32}_U32_'type'|BF{U32}_U32_'pre_emphasis'|BF{U6}_U6_'_bit_field_pad0'|U8'num_indices'|*{SYM#tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']#}_SYM#tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']#_'indices']#_'tracks']
// file /usr/include/FLAC/format.h line 703
struct anonymous_56;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_12;

// tag-#anon#ST[ARR4{U8}_U8_'id'|U32'_pad0'|*{U8}_U8_'data']
// file /usr/include/FLAC/format.h line 565
struct anonymous_49;

// tag-#anon#ST[S32'__lock'|U32'__nr_readers'|U32'__readers_wakeup'|U32'__writer_wakeup'|U32'__nr_readers_queued'|U32'__nr_writers_queued'|S32'__writer'|S32'__shared'|S8'__rwelision'|ARR7{U8}_U8_'__pad1'|U64'__pad2'|U32'__flags'|U32'_pad0']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous_17;

// tag-#anon#ST[S32'dummy']
// file /usr/include/FLAC/format.h line 554
struct anonymous_48;

// tag-#anon#ST[S32'value']
// file /usr/include/FLAC/format.h line 284
struct anonymous_28;

// tag-#anon#ST[S64'endbyte'|S32'endbit'|U32'_pad0'|*{U8}_U8_'buffer'|*{U8}_U8_'ptr'|S64'storage']
// file /usr/include/ogg/ogg.h line 32
struct anonymous;

// tag-#anon#ST[S64'last_dts'|S64'duration_gcd'|S32'duration_count'|U32'_pad0'|S64'rfps_duration_sum'|*{ARR2{ARR399{F64}_F64_}_ARR399{F64}_F64__}_ARR2{ARR399{F64}_F64_}_ARR399{F64}_F64___'duration_error'|S64'codec_info_duration'|S64'codec_info_duration_fields'|S32'found_decoder'|U32'_pad1'|S64'last_duration'|S64'fps_first_dts'|S32'fps_first_dts_idx'|U32'_pad2'|S64'fps_last_dts'|S32'fps_last_dts_idx'|U32'_pad3']
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 984
struct anonymous_19;

// tag-#anon#ST[S64'seconds'|U64'fraction']
// file /usr/include/mad.h line 601
struct anonymous_72;

// tag-#anon#ST[SYM##anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#'type'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'|U32'_pad0'|*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#_'contents']#'partitioned_rice']#'data']
// file /usr/include/FLAC/format.h line 255
struct anonymous_32;

// tag-#anon#ST[SYM##anon_enum_FLAC__METADATA_TYPE_STREAMINFO=0_FLAC__METADATA_TYPE_PADDING=1_FLAC__METADATA_TYPE_APPLICATION=2_FLAC__METADATA_TYPE_SEEKTABLE=3_FLAC__METADATA_TYPE_VORBIS_COMMENT=4_FLAC__METADATA_TYPE_CUESHEET=5_FLAC__METADATA_TYPE_PICTURE=6_FLAC__METADATA_TYPE_UNDEFINED=7_FLAC__MAX_METADATA_TYPE=126#'type'|S32'is_last'|U32'length'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'min_blocksize'|U32'max_blocksize'|U32'min_framesize'|U32'max_framesize'|U32'sample_rate'|U32'channels'|U32'bits_per_sample'|U32'_pad0'|U64'total_samples'|ARR16{U8}_U8_'md5sum']#'stream_info'|SYM#tag-#anon#ST[S32'dummy']#'padding'|SYM#tag-#anon#ST[ARR4{U8}_U8_'id'|U32'_pad0'|*{U8}_U8_'data']#'application'|SYM#tag-#anon#ST[U32'num_points'|U32'_pad0'|*{SYM#tag-#anon#ST[U64'sample_number'|U64'stream_offset'|U32'frame_samples'|U32'_pad0']#}_SYM#tag-#anon#ST[U64'sample_number'|U64'stream_offset'|U32'frame_samples'|U32'_pad0']#_'points']#'seek_table'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[U32'length'|U32'_pad0'|*{U8}_U8_'entry']#'vendor_string'|U32'num_comments'|U32'_pad0'|*{SYM#tag-#anon#ST[U32'length'|U32'_pad0'|*{U8}_U8_'entry']#}_SYM#tag-#anon#ST[U32'length'|U32'_pad0'|*{U8}_U8_'entry']#_'comments']#'vorbis_comment'|SYM#tag-#anon#ST[ARR129{S8}_S8_'media_catalog_number'|U56'_pad0'|U64'lead_in'|S32'is_cd'|U32'num_tracks'|*{SYM#tag-#anon#ST[U64'offset'|U8'number'|ARR13{S8}_S8_'isrc'|BF{U32}_U32_'type'|BF{U32}_U32_'pre_emphasis'|BF{U6}_U6_'_bit_field_pad0'|U8'num_indices'|*{SYM#tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']#}_SYM#tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']#_'indices']#}_SYM#tag-#anon#ST[U64'offset'|U8'number'|ARR13{S8}_S8_'isrc'|BF{U32}_U32_'type'|BF{U32}_U32_'pre_emphasis'|BF{U6}_U6_'_bit_field_pad0'|U8'num_indices'|*{SYM#tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']#}_SYM#tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']#_'indices']#_'tracks']#'cue_sheet'|SYM#tag-#anon#ST[SYM##anon_enum_FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2_FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3_FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5_FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7_FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8_FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10_FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11_FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12_FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15_FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16_FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17_FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19_FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20_FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21#'type'|U32'_pad0'|*{S8}_S8_'mime_type'|*{U8}_U8_'description'|U32'width'|U32'height'|U32'depth'|U32'colors'|U32'data_length'|U32'_pad1'|*{U8}_U8_'data']#'picture'|SYM#tag-#anon#ST[*{U8}_U8_'data']#'unknown']#'data']
// file /usr/include/FLAC/format.h line 834
struct anonymous_61;

// tag-#anon#ST[SYM##anon_enum_FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2_FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3_FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5_FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7_FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8_FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10_FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11_FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12_FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15_FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16_FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17_FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19_FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20_FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21#'type'|U32'_pad0'|*{S8}_S8_'mime_type'|*{U8}_U8_'description'|U32'width'|U32'height'|U32'depth'|U32'colors'|U32'data_length'|U32'_pad1'|*{U8}_U8_'data']
// file /usr/include/FLAC/format.h line 769
struct anonymous_58;

// tag-#anon#ST[SYM##anon_enum_FLAC__SUBFRAME_TYPE_CONSTANT=0_FLAC__SUBFRAME_TYPE_VERBATIM=1_FLAC__SUBFRAME_TYPE_FIXED=2_FLAC__SUBFRAME_TYPE_LPC=3#'type'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'value']#'constant'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM##anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#'type'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'|U32'_pad0'|*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#_'contents']#'partitioned_rice']#'data']#'entropy_coding_method'|U32'order'|ARR4{S32}_S32_'warmup'|U32'_pad0'|*{cS32}_cS32_'residual']#'fixed'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM##anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#'type'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'|U32'_pad0'|*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#_'contents']#'partitioned_rice']#'data']#'entropy_coding_method'|U32'order'|U32'qlp_coeff_precision'|S32'quantization_level'|ARR32{S32}_S32_'qlp_coeff'|ARR32{S32}_S32_'warmup'|U32'_pad0'|*{cS32}_cS32_'residual']#'lpc'|SYM#tag-#anon#ST[*{cS32}_cS32_'data']#'verbatim']#'data'|U32'wasted_bits'|U32'_pad1']
// file /usr/include/FLAC/format.h line 344
struct anonymous_37;

// tag-#anon#ST[SYM#tag-#anon#ST[SYM##anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#'type'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'|U32'_pad0'|*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#_'contents']#'partitioned_rice']#'data']#'entropy_coding_method'|U32'order'|ARR4{S32}_S32_'warmup'|U32'_pad0'|*{cS32}_cS32_'residual']
// file /usr/include/FLAC/format.h line 298
struct anonymous_33;

// tag-#anon#ST[SYM#tag-#anon#ST[SYM##anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#'type'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'|U32'_pad0'|*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#_'contents']#'partitioned_rice']#'data']#'entropy_coding_method'|U32'order'|U32'qlp_coeff_precision'|S32'quantization_level'|ARR32{S32}_S32_'qlp_coeff'|ARR32{S32}_S32_'warmup'|U32'_pad0'|*{cS32}_cS32_'residual']
// file /usr/include/FLAC/format.h line 315
struct anonymous_34;

// tag-#anon#ST[SYM#tag-#anon#ST[U32'blocksize'|U32'sample_rate'|U32'channels'|SYM##anon_enum_FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT=0_FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE=1_FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE=2_FLAC__CHANNEL_ASSIGNMENT_MID_SIDE=3#'channel_assignment'|U32'bits_per_sample'|SYM##anon_enum_FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER=0_FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER=1#'number_type'|SYM#tag-#anon#UN[U32'frame_number'|U64'sample_number']#'number'|U8'crc'|U56'_pad0']#'header'|ARR8{SYM#tag-#anon#ST[SYM##anon_enum_FLAC__SUBFRAME_TYPE_CONSTANT=0_FLAC__SUBFRAME_TYPE_VERBATIM=1_FLAC__SUBFRAME_TYPE_FIXED=2_FLAC__SUBFRAME_TYPE_LPC=3#'type'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'value']#'constant'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM##anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#'type'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'|U32'_pad0'|*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#_'contents']#'partitioned_rice']#'data']#'entropy_coding_method'|U32'order'|ARR4{S32}_S32_'warmup'|U32'_pad0'|*{cS32}_cS32_'residual']#'fixed'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM##anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#'type'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'|U32'_pad0'|*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#_'contents']#'partitioned_rice']#'data']#'entropy_coding_method'|U32'order'|U32'qlp_coeff_precision'|S32'quantization_level'|ARR32{S32}_S32_'qlp_coeff'|ARR32{S32}_S32_'warmup'|U32'_pad0'|*{cS32}_cS32_'residual']#'lpc'|SYM#tag-#anon#ST[*{cS32}_cS32_'data']#'verbatim']#'data'|U32'wasted_bits'|U32'_pad1']#}_SYM#tag-#anon#ST[SYM##anon_enum_FLAC__SUBFRAME_TYPE_CONSTANT=0_FLAC__SUBFRAME_TYPE_VERBATIM=1_FLAC__SUBFRAME_TYPE_FIXED=2_FLAC__SUBFRAME_TYPE_LPC=3#'type'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'value']#'constant'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM##anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#'type'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'|U32'_pad0'|*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#_'contents']#'partitioned_rice']#'data']#'entropy_coding_method'|U32'order'|ARR4{S32}_S32_'warmup'|U32'_pad0'|*{cS32}_cS32_'residual']#'fixed'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM##anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#'type'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'|U32'_pad0'|*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#_'contents']#'partitioned_rice']#'data']#'entropy_coding_method'|U32'order'|U32'qlp_coeff_precision'|S32'quantization_level'|ARR32{S32}_S32_'qlp_coeff'|ARR32{S32}_S32_'warmup'|U32'_pad0'|*{cS32}_cS32_'residual']#'lpc'|SYM#tag-#anon#ST[*{cS32}_cS32_'data']#'verbatim']#'data'|U32'wasted_bits'|U32'_pad1']#_'subframes'|SYM#tag-#anon#ST[U16'crc']#'footer'|U48'_pad0']
// file /usr/include/FLAC/format.h line 473
struct anonymous_45;

// tag-#anon#ST[SYM#tag-#anon#ST[U32'length'|U32'_pad0'|*{U8}_U8_'entry']#'vendor_string'|U32'num_comments'|U32'_pad0'|*{SYM#tag-#anon#ST[U32'length'|U32'_pad0'|*{U8}_U8_'entry']#}_SYM#tag-#anon#ST[U32'length'|U32'_pad0'|*{U8}_U8_'entry']#_'comments']
// file /usr/include/FLAC/format.h line 634
struct anonymous_53;

// tag-#anon#ST[U16'crc']
// file /usr/include/FLAC/format.h line 460
struct anonymous_44;

// tag-#anon#ST[U32'blocksize'|U32'sample_rate'|U32'channels'|SYM##anon_enum_FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT=0_FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE=1_FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE=2_FLAC__CHANNEL_ASSIGNMENT_MID_SIDE=3#'channel_assignment'|U32'bits_per_sample'|SYM##anon_enum_FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER=0_FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER=1#'number_type'|SYM#tag-#anon#UN[U32'frame_number'|U64'sample_number']#'number'|U8'crc'|U56'_pad0']
// file /usr/include/FLAC/format.h line 411
struct anonymous_41;

// tag-#anon#ST[U32'length'|U32'_pad0'|*{U8}_U8_'entry']
// file /usr/include/FLAC/format.h line 624
struct anonymous_52;

// tag-#anon#ST[U32'min_blocksize'|U32'max_blocksize'|U32'min_framesize'|U32'max_framesize'|U32'sample_rate'|U32'channels'|U32'bits_per_sample'|U32'_pad0'|U64'total_samples'|ARR16{U8}_U8_'md5sum']
// file /usr/include/FLAC/format.h line 529
struct anonymous_47;

// tag-#anon#ST[U32'num_points'|U32'_pad0'|*{SYM#tag-#anon#ST[U64'sample_number'|U64'stream_offset'|U32'frame_samples'|U32'_pad0']#}_SYM#tag-#anon#ST[U64'sample_number'|U64'stream_offset'|U32'frame_samples'|U32'_pad0']#_'points']
// file /usr/include/FLAC/format.h line 612
struct anonymous_51;

// tag-#anon#ST[U32'order'|U32'_pad0'|*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#_'contents']
// file /usr/include/FLAC/format.h line 233
struct anonymous_70;

// tag-#anon#ST[U32'rate'|U32'_pad0'|*{V}_V_'stream']
// file output_pa.c line 33
struct anonymous_11;

// tag-#anon#ST[U32'updated'|U32'stream_start'|U32'stream_full'|U32'stream_size'|U64'stream_bytes'|U32'output_full'|U32'output_size'|U32'frames_played'|U32'device_frames'|U32'current_sample_rate'|U32'last'|SYM##anon_enum_STOPPED=0_DISCONNECT=1_STREAMING_WAIT=2_STREAMING_BUFFERING=3_STREAMING_FILE=4_STREAMING_HTTP=5_SEND_HEADERS=6_RECV_HEADERS=7#'stream_state'|U32'_pad0']
// file slimproto.c line 66
struct anonymous_27;

// tag-#anon#ST[U64'offset'|U8'number'|ARR13{S8}_S8_'isrc'|BF{U32}_U32_'type'|BF{U32}_U32_'pre_emphasis'|BF{U6}_U6_'_bit_field_pad0'|U8'num_indices'|*{SYM#tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']#}_SYM#tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']#_'indices']
// file /usr/include/FLAC/format.h line 666
struct anonymous_55;

// tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']
// file /usr/include/FLAC/format.h line 647
struct anonymous_54;

// tag-#anon#ST[U64'sample_number'|U64'stream_offset'|U32'frame_samples'|U32'_pad0']
// file /usr/include/FLAC/format.h line 574
struct anonymous_50;

// tag-#anon#UN[*{S8}_S8_'ifcu_buf'|*{SYM#tag-ifreq#}_SYM#tag-ifreq#_'ifcu_req']
// file /usr/include/net/if.h line 179
union anonymous_16;

// tag-#anon#UN[ARR16{S8}_S8_'ifrn_name']
// file /usr/include/net/if.h line 130
union anonymous_13;

// tag-#anon#UN[ARR4{S8}_S8_'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_7;

// tag-#anon#UN[ARR8{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 224
union anonymous_21;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__nr_readers'|U32'__readers_wakeup'|U32'__writer_wakeup'|U32'__nr_readers_queued'|U32'__nr_writers_queued'|S32'__writer'|S32'__shared'|S8'__rwelision'|ARR7{U8}_U8_'__pad1'|U64'__pad2'|U32'__flags'|U32'_pad0']#'__data'|ARR56{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous_18;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'value']#'constant'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM##anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#'type'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'|U32'_pad0'|*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#_'contents']#'partitioned_rice']#'data']#'entropy_coding_method'|U32'order'|ARR4{S32}_S32_'warmup'|U32'_pad0'|*{cS32}_cS32_'residual']#'fixed'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM##anon_enum_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE=0_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2=1#'type'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'order'|U32'_pad0'|*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#_'contents']#'partitioned_rice']#'data']#'entropy_coding_method'|U32'order'|U32'qlp_coeff_precision'|S32'quantization_level'|ARR32{S32}_S32_'qlp_coeff'|ARR32{S32}_S32_'warmup'|U32'_pad0'|*{cS32}_cS32_'residual']#'lpc'|SYM#tag-#anon#ST[*{cS32}_cS32_'data']#'verbatim']
// file /usr/include/FLAC/format.h line 346
union anonymous_35;

// tag-#anon#UN[SYM#tag-#anon#ST[U32'min_blocksize'|U32'max_blocksize'|U32'min_framesize'|U32'max_framesize'|U32'sample_rate'|U32'channels'|U32'bits_per_sample'|U32'_pad0'|U64'total_samples'|ARR16{U8}_U8_'md5sum']#'stream_info'|SYM#tag-#anon#ST[S32'dummy']#'padding'|SYM#tag-#anon#ST[ARR4{U8}_U8_'id'|U32'_pad0'|*{U8}_U8_'data']#'application'|SYM#tag-#anon#ST[U32'num_points'|U32'_pad0'|*{SYM#tag-#anon#ST[U64'sample_number'|U64'stream_offset'|U32'frame_samples'|U32'_pad0']#}_SYM#tag-#anon#ST[U64'sample_number'|U64'stream_offset'|U32'frame_samples'|U32'_pad0']#_'points']#'seek_table'|SYM#tag-#anon#ST[SYM#tag-#anon#ST[U32'length'|U32'_pad0'|*{U8}_U8_'entry']#'vendor_string'|U32'num_comments'|U32'_pad0'|*{SYM#tag-#anon#ST[U32'length'|U32'_pad0'|*{U8}_U8_'entry']#}_SYM#tag-#anon#ST[U32'length'|U32'_pad0'|*{U8}_U8_'entry']#_'comments']#'vorbis_comment'|SYM#tag-#anon#ST[ARR129{S8}_S8_'media_catalog_number'|U56'_pad0'|U64'lead_in'|S32'is_cd'|U32'num_tracks'|*{SYM#tag-#anon#ST[U64'offset'|U8'number'|ARR13{S8}_S8_'isrc'|BF{U32}_U32_'type'|BF{U32}_U32_'pre_emphasis'|BF{U6}_U6_'_bit_field_pad0'|U8'num_indices'|*{SYM#tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']#}_SYM#tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']#_'indices']#}_SYM#tag-#anon#ST[U64'offset'|U8'number'|ARR13{S8}_S8_'isrc'|BF{U32}_U32_'type'|BF{U32}_U32_'pre_emphasis'|BF{U6}_U6_'_bit_field_pad0'|U8'num_indices'|*{SYM#tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']#}_SYM#tag-#anon#ST[U64'offset'|U8'number'|U56'_pad0']#_'indices']#_'tracks']#'cue_sheet'|SYM#tag-#anon#ST[SYM##anon_enum_FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER=0_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD=1_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON=2_FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER=3_FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER=4_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE=5_FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA=6_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST=7_FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST=8_FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR=9_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND=10_FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER=11_FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST=12_FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION=13_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING=14_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE=15_FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE=16_FLAC__STREAM_METADATA_PICTURE_TYPE_FISH=17_FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION=18_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE=19_FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE=20_FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED=21#'type'|U32'_pad0'|*{S8}_S8_'mime_type'|*{U8}_U8_'description'|U32'width'|U32'height'|U32'depth'|U32'colors'|U32'data_length'|U32'_pad1'|*{U8}_U8_'data']#'picture'|SYM#tag-#anon#ST[*{U8}_U8_'data']#'unknown']
// file /usr/include/FLAC/format.h line 846
union anonymous_60;

// tag-#anon#UN[SYM#tag-#anon#ST[U32'order'|U32'_pad0'|*{cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#}_cSYM#tag-#anon#ST[*{U32}_U32_'parameters'|*{U32}_U32_'raw_bits'|U32'capacity_by_order'|U32'_pad0']#_'contents']#'partitioned_rice']
// file /usr/include/FLAC/format.h line 257
union anonymous_31;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_6;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'|SYM#tag-sockaddr#'ifru_dstaddr'|SYM#tag-sockaddr#'ifru_broadaddr'|SYM#tag-sockaddr#'ifru_netmask'|SYM#tag-sockaddr#'ifru_hwaddr'|S16'ifru_flags'|S32'ifru_ivalue'|S32'ifru_mtu'|SYM#tag-ifmap#'ifru_map'|ARR16{S8}_S8_'ifru_slave'|ARR16{S8}_S8_'ifru_newname'|*{S8}_S8_'ifru_data']
// file /usr/include/net/if.h line 135
union anonymous_15;

// tag-#anon#UN[U32'frame_number'|U64'sample_number']
// file /usr/include/FLAC/format.h line 432
union anonymous_40;

// tag-#anon#UN[U32'pause_frames'|U32'skip_frames'|U32'start_at']
// file squeezelite.h line 555
union anonymous_2;

// tag-AVAudioServiceType
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 692
enum AVAudioServiceType { AV_AUDIO_SERVICE_TYPE_MAIN=0, AV_AUDIO_SERVICE_TYPE_EFFECTS=1, AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED=2, AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED=3, AV_AUDIO_SERVICE_TYPE_DIALOGUE=4, AV_AUDIO_SERVICE_TYPE_COMMENTARY=5, AV_AUDIO_SERVICE_TYPE_EMERGENCY=6, AV_AUDIO_SERVICE_TYPE_VOICE_OVER=7, AV_AUDIO_SERVICE_TYPE_KARAOKE=8, AV_AUDIO_SERVICE_TYPE_NB=9 };

// tag-AVBuffer
// file /usr/include/x86_64-linux-gnu/libavutil/buffer.h line 73
struct AVBuffer;

// tag-AVBufferRef
// file /usr/include/x86_64-linux-gnu/libavutil/buffer.h line 81
struct AVBufferRef;

// tag-AVChapter
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1239
struct AVChapter;

// tag-AVChromaLocation
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 559
enum AVChromaLocation { AVCHROMA_LOC_UNSPECIFIED=0, AVCHROMA_LOC_LEFT=1, AVCHROMA_LOC_CENTER=2, AVCHROMA_LOC_TOPLEFT=3, AVCHROMA_LOC_TOP=4, AVCHROMA_LOC_BOTTOMLEFT=5, AVCHROMA_LOC_BOTTOM=6, AVCHROMA_LOC_NB=7 };

// tag-AVClass
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 67
struct AVClass;

// tag-AVCodec
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1511
struct AVCodec;

// tag-AVCodecContext
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 408
struct AVCodecContext;

// tag-AVCodecDefault
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3465
struct AVCodecDefault;

// tag-AVCodecDescriptor
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 566
struct AVCodecDescriptor;

// tag-AVCodecID
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 102
enum AVCodecID { AV_CODEC_ID_NONE=0, AV_CODEC_ID_MPEG1VIDEO=1, AV_CODEC_ID_MPEG2VIDEO=2, AV_CODEC_ID_MPEG2VIDEO_XVMC=3, AV_CODEC_ID_H261=4, AV_CODEC_ID_H263=5, AV_CODEC_ID_RV10=6, AV_CODEC_ID_RV20=7, AV_CODEC_ID_MJPEG=8, AV_CODEC_ID_MJPEGB=9, AV_CODEC_ID_LJPEG=10, AV_CODEC_ID_SP5X=11, AV_CODEC_ID_JPEGLS=12, AV_CODEC_ID_MPEG4=13, AV_CODEC_ID_RAWVIDEO=14, AV_CODEC_ID_MSMPEG4V1=15, AV_CODEC_ID_MSMPEG4V2=16, AV_CODEC_ID_MSMPEG4V3=17, AV_CODEC_ID_WMV1=18, AV_CODEC_ID_WMV2=19, AV_CODEC_ID_H263P=20, AV_CODEC_ID_H263I=21, AV_CODEC_ID_FLV1=22, AV_CODEC_ID_SVQ1=23, AV_CODEC_ID_SVQ3=24, AV_CODEC_ID_DVVIDEO=25, AV_CODEC_ID_HUFFYUV=26, AV_CODEC_ID_CYUV=27, AV_CODEC_ID_H264=28, AV_CODEC_ID_INDEO3=29, AV_CODEC_ID_VP3=30, AV_CODEC_ID_THEORA=31, AV_CODEC_ID_ASV1=32, AV_CODEC_ID_ASV2=33, AV_CODEC_ID_FFV1=34, AV_CODEC_ID_4XM=35, AV_CODEC_ID_VCR1=36, AV_CODEC_ID_CLJR=37, AV_CODEC_ID_MDEC=38, AV_CODEC_ID_ROQ=39, AV_CODEC_ID_INTERPLAY_VIDEO=40, AV_CODEC_ID_XAN_WC3=41, AV_CODEC_ID_XAN_WC4=42, AV_CODEC_ID_RPZA=43, AV_CODEC_ID_CINEPAK=44, AV_CODEC_ID_WS_VQA=45, AV_CODEC_ID_MSRLE=46, AV_CODEC_ID_MSVIDEO1=47, AV_CODEC_ID_IDCIN=48, AV_CODEC_ID_8BPS=49, AV_CODEC_ID_SMC=50, AV_CODEC_ID_FLIC=51, AV_CODEC_ID_TRUEMOTION1=52, AV_CODEC_ID_VMDVIDEO=53, AV_CODEC_ID_MSZH=54, AV_CODEC_ID_ZLIB=55, AV_CODEC_ID_QTRLE=56, AV_CODEC_ID_TSCC=57, AV_CODEC_ID_ULTI=58, AV_CODEC_ID_QDRAW=59, AV_CODEC_ID_VIXL=60, AV_CODEC_ID_QPEG=61, AV_CODEC_ID_PNG=62, AV_CODEC_ID_PPM=63, AV_CODEC_ID_PBM=64, AV_CODEC_ID_PGM=65, AV_CODEC_ID_PGMYUV=66, AV_CODEC_ID_PAM=67, AV_CODEC_ID_FFVHUFF=68, AV_CODEC_ID_RV30=69, AV_CODEC_ID_RV40=70, AV_CODEC_ID_VC1=71, AV_CODEC_ID_WMV3=72, AV_CODEC_ID_LOCO=73, AV_CODEC_ID_WNV1=74, AV_CODEC_ID_AASC=75, AV_CODEC_ID_INDEO2=76, AV_CODEC_ID_FRAPS=77, AV_CODEC_ID_TRUEMOTION2=78, AV_CODEC_ID_BMP=79, AV_CODEC_ID_CSCD=80, AV_CODEC_ID_MMVIDEO=81, AV_CODEC_ID_ZMBV=82, AV_CODEC_ID_AVS=83, AV_CODEC_ID_SMACKVIDEO=84, AV_CODEC_ID_NUV=85, AV_CODEC_ID_KMVC=86, AV_CODEC_ID_FLASHSV=87, AV_CODEC_ID_CAVS=88, AV_CODEC_ID_JPEG2000=89, AV_CODEC_ID_VMNC=90, AV_CODEC_ID_VP5=91, AV_CODEC_ID_VP6=92, AV_CODEC_ID_VP6F=93, AV_CODEC_ID_TARGA=94, AV_CODEC_ID_DSICINVIDEO=95, AV_CODEC_ID_TIERTEXSEQVIDEO=96, AV_CODEC_ID_TIFF=97, AV_CODEC_ID_GIF=98, AV_CODEC_ID_DXA=99, AV_CODEC_ID_DNXHD=100, AV_CODEC_ID_THP=101, AV_CODEC_ID_SGI=102, AV_CODEC_ID_C93=103, AV_CODEC_ID_BETHSOFTVID=104, AV_CODEC_ID_PTX=105, AV_CODEC_ID_TXD=106, AV_CODEC_ID_VP6A=107, AV_CODEC_ID_AMV=108, AV_CODEC_ID_VB=109, AV_CODEC_ID_PCX=110, AV_CODEC_ID_SUNRAST=111, AV_CODEC_ID_INDEO4=112, AV_CODEC_ID_INDEO5=113, AV_CODEC_ID_MIMIC=114, AV_CODEC_ID_RL2=115, AV_CODEC_ID_ESCAPE124=116, AV_CODEC_ID_DIRAC=117, AV_CODEC_ID_BFI=118, AV_CODEC_ID_CMV=119, AV_CODEC_ID_MOTIONPIXELS=120, AV_CODEC_ID_TGV=121, AV_CODEC_ID_TGQ=122, AV_CODEC_ID_TQI=123, AV_CODEC_ID_AURA=124, AV_CODEC_ID_AURA2=125, AV_CODEC_ID_V210X=126, AV_CODEC_ID_TMV=127, AV_CODEC_ID_V210=128, AV_CODEC_ID_DPX=129, AV_CODEC_ID_MAD=130, AV_CODEC_ID_FRWU=131, AV_CODEC_ID_FLASHSV2=132, AV_CODEC_ID_CDGRAPHICS=133, AV_CODEC_ID_R210=134, AV_CODEC_ID_ANM=135, AV_CODEC_ID_BINKVIDEO=136, AV_CODEC_ID_IFF_ILBM=137, AV_CODEC_ID_IFF_BYTERUN1=138, AV_CODEC_ID_KGV1=139, AV_CODEC_ID_YOP=140, AV_CODEC_ID_VP8=141, AV_CODEC_ID_PICTOR=142, AV_CODEC_ID_ANSI=143, AV_CODEC_ID_A64_MULTI=144, AV_CODEC_ID_A64_MULTI5=145, AV_CODEC_ID_R10K=146, AV_CODEC_ID_MXPEG=147, AV_CODEC_ID_LAGARITH=148, AV_CODEC_ID_PRORES=149, AV_CODEC_ID_JV=150, AV_CODEC_ID_DFA=151, AV_CODEC_ID_WMV3IMAGE=152, AV_CODEC_ID_VC1IMAGE=153, AV_CODEC_ID_UTVIDEO=154, AV_CODEC_ID_BMV_VIDEO=155, AV_CODEC_ID_VBLE=156, AV_CODEC_ID_DXTORY=157, AV_CODEC_ID_V410=158, AV_CODEC_ID_XWD=159, AV_CODEC_ID_CDXL=160, AV_CODEC_ID_XBM=161, AV_CODEC_ID_ZEROCODEC=162, AV_CODEC_ID_MSS1=163, AV_CODEC_ID_MSA1=164, AV_CODEC_ID_TSCC2=165, AV_CODEC_ID_MTS2=166, AV_CODEC_ID_CLLC=167, AV_CODEC_ID_MSS2=168, AV_CODEC_ID_VP9=169, AV_CODEC_ID_AIC=170, AV_CODEC_ID_ESCAPE130_DEPRECATED=171, AV_CODEC_ID_G2M_DEPRECATED=172, AV_CODEC_ID_WEBP_DEPRECATED=173, AV_CODEC_ID_HNM4_VIDEO=174, AV_CODEC_ID_HEVC_DEPRECATED=175, AV_CODEC_ID_FIC=176, AV_CODEC_ID_ALIAS_PIX=177, AV_CODEC_ID_BRENDER_PIX_DEPRECATED=178, AV_CODEC_ID_PAF_VIDEO_DEPRECATED=179, AV_CODEC_ID_EXR_DEPRECATED=180, AV_CODEC_ID_VP7_DEPRECATED=181, AV_CODEC_ID_SANM_DEPRECATED=182, AV_CODEC_ID_SGIRLE_DEPRECATED=183, AV_CODEC_ID_MVC1_DEPRECATED=184, AV_CODEC_ID_MVC2_DEPRECATED=185, AV_CODEC_ID_HQX=186, AV_CODEC_ID_TDSC=187, AV_CODEC_ID_HQ_HQA=188, AV_CODEC_ID_HAP=189, AV_CODEC_ID_DDS=190, AV_CODEC_ID_BRENDER_PIX=1112557912, AV_CODEC_ID_Y41P=1496592720, AV_CODEC_ID_ESCAPE130=1160852272, AV_CODEC_ID_EXR=809850962, AV_CODEC_ID_AVRP=1096176208, AV_CODEC_ID_012V=808530518, AV_CODEC_ID_G2M=4665933, AV_CODEC_ID_AVUI=1096176969, AV_CODEC_ID_AYUV=1096373590, AV_CODEC_ID_TARGA_Y216=1412575542, AV_CODEC_ID_V308=1446195256, AV_CODEC_ID_V408=1446260792, AV_CODEC_ID_YUV4=1498764852, AV_CODEC_ID_SANM=1396788813, AV_CODEC_ID_PAF_VIDEO=1346455126, AV_CODEC_ID_AVRN=1096176238, AV_CODEC_ID_CPIA=1129335105, AV_CODEC_ID_XFACE=1480999235, AV_CODEC_ID_SGIRLE=1397180754, AV_CODEC_ID_MVC1=1297498929, AV_CODEC_ID_MVC2=1297498930, AV_CODEC_ID_SNOW=1397641047, AV_CODEC_ID_WEBP=1464156752, AV_CODEC_ID_SMVJPEG=1397577290, AV_CODEC_ID_HEVC=1211250229, AV_CODEC_ID_VP7=1448097584, AV_CODEC_ID_APNG=1095781959, AV_CODEC_ID_FIRST_AUDIO=65536, AV_CODEC_ID_PCM_S16LE=65536, AV_CODEC_ID_PCM_S16BE=65537, AV_CODEC_ID_PCM_U16LE=65538, AV_CODEC_ID_PCM_U16BE=65539, AV_CODEC_ID_PCM_S8=65540, AV_CODEC_ID_PCM_U8=65541, AV_CODEC_ID_PCM_MULAW=65542, AV_CODEC_ID_PCM_ALAW=65543, AV_CODEC_ID_PCM_S32LE=65544, AV_CODEC_ID_PCM_S32BE=65545, AV_CODEC_ID_PCM_U32LE=65546, AV_CODEC_ID_PCM_U32BE=65547, AV_CODEC_ID_PCM_S24LE=65548, AV_CODEC_ID_PCM_S24BE=65549, AV_CODEC_ID_PCM_U24LE=65550, AV_CODEC_ID_PCM_U24BE=65551, AV_CODEC_ID_PCM_S24DAUD=65552, AV_CODEC_ID_PCM_ZORK=65553, AV_CODEC_ID_PCM_S16LE_PLANAR=65554, AV_CODEC_ID_PCM_DVD=65555, AV_CODEC_ID_PCM_F32BE=65556, AV_CODEC_ID_PCM_F32LE=65557, AV_CODEC_ID_PCM_F64BE=65558, AV_CODEC_ID_PCM_F64LE=65559, AV_CODEC_ID_PCM_BLURAY=65560, AV_CODEC_ID_PCM_LXF=65561, AV_CODEC_ID_S302M=65562, AV_CODEC_ID_PCM_S8_PLANAR=65563, AV_CODEC_ID_PCM_S24LE_PLANAR_DEPRECATED=65564, AV_CODEC_ID_PCM_S32LE_PLANAR_DEPRECATED=65565, AV_CODEC_ID_PCM_S16BE_PLANAR_DEPRECATED=65566, AV_CODEC_ID_PCM_S24LE_PLANAR=407917392, AV_CODEC_ID_PCM_S32LE_PLANAR=542135120, AV_CODEC_ID_PCM_S16BE_PLANAR=1347637264, AV_CODEC_ID_ADPCM_IMA_QT=69632, AV_CODEC_ID_ADPCM_IMA_WAV=69633, AV_CODEC_ID_ADPCM_IMA_DK3=69634, AV_CODEC_ID_ADPCM_IMA_DK4=69635, AV_CODEC_ID_ADPCM_IMA_WS=69636, AV_CODEC_ID_ADPCM_IMA_SMJPEG=69637, AV_CODEC_ID_ADPCM_MS=69638, AV_CODEC_ID_ADPCM_4XM=69639, AV_CODEC_ID_ADPCM_XA=69640, AV_CODEC_ID_ADPCM_ADX=69641, AV_CODEC_ID_ADPCM_EA=69642, AV_CODEC_ID_ADPCM_G726=69643, AV_CODEC_ID_ADPCM_CT=69644, AV_CODEC_ID_ADPCM_SWF=69645, AV_CODEC_ID_ADPCM_YAMAHA=69646, AV_CODEC_ID_ADPCM_SBPRO_4=69647, AV_CODEC_ID_ADPCM_SBPRO_3=69648, AV_CODEC_ID_ADPCM_SBPRO_2=69649, AV_CODEC_ID_ADPCM_THP=69650, AV_CODEC_ID_ADPCM_IMA_AMV=69651, AV_CODEC_ID_ADPCM_EA_R1=69652, AV_CODEC_ID_ADPCM_EA_R3=69653, AV_CODEC_ID_ADPCM_EA_R2=69654, AV_CODEC_ID_ADPCM_IMA_EA_SEAD=69655, AV_CODEC_ID_ADPCM_IMA_EA_EACS=69656, AV_CODEC_ID_ADPCM_EA_XAS=69657, AV_CODEC_ID_ADPCM_EA_MAXIS_XA=69658, AV_CODEC_ID_ADPCM_IMA_ISS=69659, AV_CODEC_ID_ADPCM_G722=69660, AV_CODEC_ID_ADPCM_IMA_APC=69661, AV_CODEC_ID_ADPCM_VIMA_DEPRECATED=69662, AV_CODEC_ID_ADPCM_VIMA=1447644481, AV_CODEC_ID_VIMA=1447644481, AV_CODEC_ID_ADPCM_AFC=1095123744, AV_CODEC_ID_ADPCM_IMA_OKI=1330333984, AV_CODEC_ID_ADPCM_DTK=1146374944, AV_CODEC_ID_ADPCM_IMA_RAD=1380008992, AV_CODEC_ID_ADPCM_G726LE=909260615, AV_CODEC_ID_ADPCM_THP_LE=1414025292, AV_CODEC_ID_AMR_NB=73728, AV_CODEC_ID_AMR_WB=73729, AV_CODEC_ID_RA_144=77824, AV_CODEC_ID_RA_288=77825, AV_CODEC_ID_ROQ_DPCM=81920, AV_CODEC_ID_INTERPLAY_DPCM=81921, AV_CODEC_ID_XAN_DPCM=81922, AV_CODEC_ID_SOL_DPCM=81923, AV_CODEC_ID_MP2=86016, AV_CODEC_ID_MP3=86017, AV_CODEC_ID_AAC=86018, AV_CODEC_ID_AC3=86019, AV_CODEC_ID_DTS=86020, AV_CODEC_ID_VORBIS=86021, AV_CODEC_ID_DVAUDIO=86022, AV_CODEC_ID_WMAV1=86023, AV_CODEC_ID_WMAV2=86024, AV_CODEC_ID_MACE3=86025, AV_CODEC_ID_MACE6=86026, AV_CODEC_ID_VMDAUDIO=86027, AV_CODEC_ID_FLAC=86028, AV_CODEC_ID_MP3ADU=86029, AV_CODEC_ID_MP3ON4=86030, AV_CODEC_ID_SHORTEN=86031, AV_CODEC_ID_ALAC=86032, AV_CODEC_ID_WESTWOOD_SND1=86033, AV_CODEC_ID_GSM=86034, AV_CODEC_ID_QDM2=86035, AV_CODEC_ID_COOK=86036, AV_CODEC_ID_TRUESPEECH=86037, AV_CODEC_ID_TTA=86038, AV_CODEC_ID_SMACKAUDIO=86039, AV_CODEC_ID_QCELP=86040, AV_CODEC_ID_WAVPACK=86041, AV_CODEC_ID_DSICINAUDIO=86042, AV_CODEC_ID_IMC=86043, AV_CODEC_ID_MUSEPACK7=86044, AV_CODEC_ID_MLP=86045, AV_CODEC_ID_GSM_MS=86046, AV_CODEC_ID_ATRAC3=86047, AV_CODEC_ID_VOXWARE=86048, AV_CODEC_ID_APE=86049, AV_CODEC_ID_NELLYMOSER=86050, AV_CODEC_ID_MUSEPACK8=86051, AV_CODEC_ID_SPEEX=86052, AV_CODEC_ID_WMAVOICE=86053, AV_CODEC_ID_WMAPRO=86054, AV_CODEC_ID_WMALOSSLESS=86055, AV_CODEC_ID_ATRAC3P=86056, AV_CODEC_ID_EAC3=86057, AV_CODEC_ID_SIPR=86058, AV_CODEC_ID_MP1=86059, AV_CODEC_ID_TWINVQ=86060, AV_CODEC_ID_TRUEHD=86061, AV_CODEC_ID_MP4ALS=86062, AV_CODEC_ID_ATRAC1=86063, AV_CODEC_ID_BINKAUDIO_RDFT=86064, AV_CODEC_ID_BINKAUDIO_DCT=86065, AV_CODEC_ID_AAC_LATM=86066, AV_CODEC_ID_QDMC=86067, AV_CODEC_ID_CELT=86068, AV_CODEC_ID_G723_1=86069, AV_CODEC_ID_G729=86070, AV_CODEC_ID_8SVX_EXP=86071, AV_CODEC_ID_8SVX_FIB=86072, AV_CODEC_ID_BMV_AUDIO=86073, AV_CODEC_ID_RALF=86074, AV_CODEC_ID_IAC=86075, AV_CODEC_ID_ILBC=86076, AV_CODEC_ID_OPUS_DEPRECATED=86077, AV_CODEC_ID_COMFORT_NOISE=86078, AV_CODEC_ID_TAK_DEPRECATED=86079, AV_CODEC_ID_METASOUND=86080, AV_CODEC_ID_PAF_AUDIO_DEPRECATED=86081, AV_CODEC_ID_ON2AVC=86082, AV_CODEC_ID_DSS_SP=86083, AV_CODEC_ID_FFWAVESYNTH=1179014995, AV_CODEC_ID_SONIC=1397706307, AV_CODEC_ID_SONIC_LS=1397706316, AV_CODEC_ID_PAF_AUDIO=1346455105, AV_CODEC_ID_OPUS=1330664787, AV_CODEC_ID_TAK=1950507339, AV_CODEC_ID_EVRC=1936029283, AV_CODEC_ID_SMV=1936944502, AV_CODEC_ID_DSD_LSBF=1146307660, AV_CODEC_ID_DSD_MSBF=1146307661, AV_CODEC_ID_DSD_LSBF_PLANAR=1146307633, AV_CODEC_ID_DSD_MSBF_PLANAR=1146307640, AV_CODEC_ID_4GV=1932814198, AV_CODEC_ID_FIRST_SUBTITLE=94208, AV_CODEC_ID_DVD_SUBTITLE=94208, AV_CODEC_ID_DVB_SUBTITLE=94209, AV_CODEC_ID_TEXT=94210, AV_CODEC_ID_XSUB=94211, AV_CODEC_ID_SSA=94212, AV_CODEC_ID_MOV_TEXT=94213, AV_CODEC_ID_HDMV_PGS_SUBTITLE=94214, AV_CODEC_ID_DVB_TELETEXT=94215, AV_CODEC_ID_SRT=94216, AV_CODEC_ID_MICRODVD=1833195076, AV_CODEC_ID_EIA_608=1664495672, AV_CODEC_ID_JACOSUB=1246975298, AV_CODEC_ID_SAMI=1396788553, AV_CODEC_ID_REALTEXT=1381259348, AV_CODEC_ID_STL=1399870540, AV_CODEC_ID_SUBVIEWER1=1398953521, AV_CODEC_ID_SUBVIEWER=1400201814, AV_CODEC_ID_SUBRIP=1397909872, AV_CODEC_ID_WEBVTT=1465275476, AV_CODEC_ID_MPL2=1297108018, AV_CODEC_ID_VPLAYER=1448111218, AV_CODEC_ID_PJS=1349012051, AV_CODEC_ID_ASS=1095979808, AV_CODEC_ID_HDMV_TEXT_SUBTITLE=1111774296, AV_CODEC_ID_FIRST_UNKNOWN=98304, AV_CODEC_ID_TTF=98304, AV_CODEC_ID_BINTEXT=1112823892, AV_CODEC_ID_XBIN=1480739150, AV_CODEC_ID_IDF=4801606, AV_CODEC_ID_OTF=5198918, AV_CODEC_ID_SMPTE_KLV=1263294017, AV_CODEC_ID_DVD_NAV=1145979222, AV_CODEC_ID_TIMED_ID3=1414087731, AV_CODEC_ID_BIN_DATA=1145132097, AV_CODEC_ID_PROBE=102400, AV_CODEC_ID_MPEG2TS=131072, AV_CODEC_ID_MPEG4SYSTEMS=131073, AV_CODEC_ID_FFMETADATA=135168, CODEC_ID_NONE=0, CODEC_ID_MPEG1VIDEO=1, CODEC_ID_MPEG2VIDEO=2, CODEC_ID_MPEG2VIDEO_XVMC=3, CODEC_ID_H261=4, CODEC_ID_H263=5, CODEC_ID_RV10=6, CODEC_ID_RV20=7, CODEC_ID_MJPEG=8, CODEC_ID_MJPEGB=9, CODEC_ID_LJPEG=10, CODEC_ID_SP5X=11, CODEC_ID_JPEGLS=12, CODEC_ID_MPEG4=13, CODEC_ID_RAWVIDEO=14, CODEC_ID_MSMPEG4V1=15, CODEC_ID_MSMPEG4V2=16, CODEC_ID_MSMPEG4V3=17, CODEC_ID_WMV1=18, CODEC_ID_WMV2=19, CODEC_ID_H263P=20, CODEC_ID_H263I=21, CODEC_ID_FLV1=22, CODEC_ID_SVQ1=23, CODEC_ID_SVQ3=24, CODEC_ID_DVVIDEO=25, CODEC_ID_HUFFYUV=26, CODEC_ID_CYUV=27, CODEC_ID_H264=28, CODEC_ID_INDEO3=29, CODEC_ID_VP3=30, CODEC_ID_THEORA=31, CODEC_ID_ASV1=32, CODEC_ID_ASV2=33, CODEC_ID_FFV1=34, CODEC_ID_4XM=35, CODEC_ID_VCR1=36, CODEC_ID_CLJR=37, CODEC_ID_MDEC=38, CODEC_ID_ROQ=39, CODEC_ID_INTERPLAY_VIDEO=40, CODEC_ID_XAN_WC3=41, CODEC_ID_XAN_WC4=42, CODEC_ID_RPZA=43, CODEC_ID_CINEPAK=44, CODEC_ID_WS_VQA=45, CODEC_ID_MSRLE=46, CODEC_ID_MSVIDEO1=47, CODEC_ID_IDCIN=48, CODEC_ID_8BPS=49, CODEC_ID_SMC=50, CODEC_ID_FLIC=51, CODEC_ID_TRUEMOTION1=52, CODEC_ID_VMDVIDEO=53, CODEC_ID_MSZH=54, CODEC_ID_ZLIB=55, CODEC_ID_QTRLE=56, CODEC_ID_TSCC=57, CODEC_ID_ULTI=58, CODEC_ID_QDRAW=59, CODEC_ID_VIXL=60, CODEC_ID_QPEG=61, CODEC_ID_PNG=62, CODEC_ID_PPM=63, CODEC_ID_PBM=64, CODEC_ID_PGM=65, CODEC_ID_PGMYUV=66, CODEC_ID_PAM=67, CODEC_ID_FFVHUFF=68, CODEC_ID_RV30=69, CODEC_ID_RV40=70, CODEC_ID_VC1=71, CODEC_ID_WMV3=72, CODEC_ID_LOCO=73, CODEC_ID_WNV1=74, CODEC_ID_AASC=75, CODEC_ID_INDEO2=76, CODEC_ID_FRAPS=77, CODEC_ID_TRUEMOTION2=78, CODEC_ID_BMP=79, CODEC_ID_CSCD=80, CODEC_ID_MMVIDEO=81, CODEC_ID_ZMBV=82, CODEC_ID_AVS=83, CODEC_ID_SMACKVIDEO=84, CODEC_ID_NUV=85, CODEC_ID_KMVC=86, CODEC_ID_FLASHSV=87, CODEC_ID_CAVS=88, CODEC_ID_JPEG2000=89, CODEC_ID_VMNC=90, CODEC_ID_VP5=91, CODEC_ID_VP6=92, CODEC_ID_VP6F=93, CODEC_ID_TARGA=94, CODEC_ID_DSICINVIDEO=95, CODEC_ID_TIERTEXSEQVIDEO=96, CODEC_ID_TIFF=97, CODEC_ID_GIF=98, CODEC_ID_DXA=99, CODEC_ID_DNXHD=100, CODEC_ID_THP=101, CODEC_ID_SGI=102, CODEC_ID_C93=103, CODEC_ID_BETHSOFTVID=104, CODEC_ID_PTX=105, CODEC_ID_TXD=106, CODEC_ID_VP6A=107, CODEC_ID_AMV=108, CODEC_ID_VB=109, CODEC_ID_PCX=110, CODEC_ID_SUNRAST=111, CODEC_ID_INDEO4=112, CODEC_ID_INDEO5=113, CODEC_ID_MIMIC=114, CODEC_ID_RL2=115, CODEC_ID_ESCAPE124=116, CODEC_ID_DIRAC=117, CODEC_ID_BFI=118, CODEC_ID_CMV=119, CODEC_ID_MOTIONPIXELS=120, CODEC_ID_TGV=121, CODEC_ID_TGQ=122, CODEC_ID_TQI=123, CODEC_ID_AURA=124, CODEC_ID_AURA2=125, CODEC_ID_V210X=126, CODEC_ID_TMV=127, CODEC_ID_V210=128, CODEC_ID_DPX=129, CODEC_ID_MAD=130, CODEC_ID_FRWU=131, CODEC_ID_FLASHSV2=132, CODEC_ID_CDGRAPHICS=133, CODEC_ID_R210=134, CODEC_ID_ANM=135, CODEC_ID_BINKVIDEO=136, CODEC_ID_IFF_ILBM=137, CODEC_ID_IFF_BYTERUN1=138, CODEC_ID_KGV1=139, CODEC_ID_YOP=140, CODEC_ID_VP8=141, CODEC_ID_PICTOR=142, CODEC_ID_ANSI=143, CODEC_ID_A64_MULTI=144, CODEC_ID_A64_MULTI5=145, CODEC_ID_R10K=146, CODEC_ID_MXPEG=147, CODEC_ID_LAGARITH=148, CODEC_ID_PRORES=149, CODEC_ID_JV=150, CODEC_ID_DFA=151, CODEC_ID_WMV3IMAGE=152, CODEC_ID_VC1IMAGE=153, CODEC_ID_UTVIDEO=154, CODEC_ID_BMV_VIDEO=155, CODEC_ID_VBLE=156, CODEC_ID_DXTORY=157, CODEC_ID_V410=158, CODEC_ID_XWD=159, CODEC_ID_CDXL=160, CODEC_ID_XBM=161, CODEC_ID_ZEROCODEC=162, CODEC_ID_MSS1=163, CODEC_ID_MSA1=164, CODEC_ID_TSCC2=165, CODEC_ID_MTS2=166, CODEC_ID_CLLC=167, CODEC_ID_Y41P=1496592720, CODEC_ID_ESCAPE130=1160852272, CODEC_ID_EXR=809850962, CODEC_ID_AVRP=1096176208, CODEC_ID_G2M=4665933, CODEC_ID_AVUI=1096176969, CODEC_ID_AYUV=1096373590, CODEC_ID_V308=1446195256, CODEC_ID_V408=1446260792, CODEC_ID_YUV4=1498764852, CODEC_ID_SANM=1396788813, CODEC_ID_PAF_VIDEO=1346455126, CODEC_ID_SNOW=1397641047, CODEC_ID_FIRST_AUDIO=65536, CODEC_ID_PCM_S16LE=65536, CODEC_ID_PCM_S16BE=65537, CODEC_ID_PCM_U16LE=65538, CODEC_ID_PCM_U16BE=65539, CODEC_ID_PCM_S8=65540, CODEC_ID_PCM_U8=65541, CODEC_ID_PCM_MULAW=65542, CODEC_ID_PCM_ALAW=65543, CODEC_ID_PCM_S32LE=65544, CODEC_ID_PCM_S32BE=65545, CODEC_ID_PCM_U32LE=65546, CODEC_ID_PCM_U32BE=65547, CODEC_ID_PCM_S24LE=65548, CODEC_ID_PCM_S24BE=65549, CODEC_ID_PCM_U24LE=65550, CODEC_ID_PCM_U24BE=65551, CODEC_ID_PCM_S24DAUD=65552, CODEC_ID_PCM_ZORK=65553, CODEC_ID_PCM_S16LE_PLANAR=65554, CODEC_ID_PCM_DVD=65555, CODEC_ID_PCM_F32BE=65556, CODEC_ID_PCM_F32LE=65557, CODEC_ID_PCM_F64BE=65558, CODEC_ID_PCM_F64LE=65559, CODEC_ID_PCM_BLURAY=65560, CODEC_ID_PCM_LXF=65561, CODEC_ID_S302M=65562, CODEC_ID_PCM_S8_PLANAR=65563, CODEC_ID_ADPCM_IMA_QT=69632, CODEC_ID_ADPCM_IMA_WAV=69633, CODEC_ID_ADPCM_IMA_DK3=69634, CODEC_ID_ADPCM_IMA_DK4=69635, CODEC_ID_ADPCM_IMA_WS=69636, CODEC_ID_ADPCM_IMA_SMJPEG=69637, CODEC_ID_ADPCM_MS=69638, CODEC_ID_ADPCM_4XM=69639, CODEC_ID_ADPCM_XA=69640, CODEC_ID_ADPCM_ADX=69641, CODEC_ID_ADPCM_EA=69642, CODEC_ID_ADPCM_G726=69643, CODEC_ID_ADPCM_CT=69644, CODEC_ID_ADPCM_SWF=69645, CODEC_ID_ADPCM_YAMAHA=69646, CODEC_ID_ADPCM_SBPRO_4=69647, CODEC_ID_ADPCM_SBPRO_3=69648, CODEC_ID_ADPCM_SBPRO_2=69649, CODEC_ID_ADPCM_THP=69650, CODEC_ID_ADPCM_IMA_AMV=69651, CODEC_ID_ADPCM_EA_R1=69652, CODEC_ID_ADPCM_EA_R3=69653, CODEC_ID_ADPCM_EA_R2=69654, CODEC_ID_ADPCM_IMA_EA_SEAD=69655, CODEC_ID_ADPCM_IMA_EA_EACS=69656, CODEC_ID_ADPCM_EA_XAS=69657, CODEC_ID_ADPCM_EA_MAXIS_XA=69658, CODEC_ID_ADPCM_IMA_ISS=69659, CODEC_ID_ADPCM_G722=69660, CODEC_ID_ADPCM_IMA_APC=69661, CODEC_ID_VIMA=1447644481, CODEC_ID_AMR_NB=73728, CODEC_ID_AMR_WB=73729, CODEC_ID_RA_144=77824, CODEC_ID_RA_288=77825, CODEC_ID_ROQ_DPCM=81920, CODEC_ID_INTERPLAY_DPCM=81921, CODEC_ID_XAN_DPCM=81922, CODEC_ID_SOL_DPCM=81923, CODEC_ID_MP2=86016, CODEC_ID_MP3=86017, CODEC_ID_AAC=86018, CODEC_ID_AC3=86019, CODEC_ID_DTS=86020, CODEC_ID_VORBIS=86021, CODEC_ID_DVAUDIO=86022, CODEC_ID_WMAV1=86023, CODEC_ID_WMAV2=86024, CODEC_ID_MACE3=86025, CODEC_ID_MACE6=86026, CODEC_ID_VMDAUDIO=86027, CODEC_ID_FLAC=86028, CODEC_ID_MP3ADU=86029, CODEC_ID_MP3ON4=86030, CODEC_ID_SHORTEN=86031, CODEC_ID_ALAC=86032, CODEC_ID_WESTWOOD_SND1=86033, CODEC_ID_GSM=86034, CODEC_ID_QDM2=86035, CODEC_ID_COOK=86036, CODEC_ID_TRUESPEECH=86037, CODEC_ID_TTA=86038, CODEC_ID_SMACKAUDIO=86039, CODEC_ID_QCELP=86040, CODEC_ID_WAVPACK=86041, CODEC_ID_DSICINAUDIO=86042, CODEC_ID_IMC=86043, CODEC_ID_MUSEPACK7=86044, CODEC_ID_MLP=86045, CODEC_ID_GSM_MS=86046, CODEC_ID_ATRAC3=86047, CODEC_ID_VOXWARE=86048, CODEC_ID_APE=86049, CODEC_ID_NELLYMOSER=86050, CODEC_ID_MUSEPACK8=86051, CODEC_ID_SPEEX=86052, CODEC_ID_WMAVOICE=86053, CODEC_ID_WMAPRO=86054, CODEC_ID_WMALOSSLESS=86055, CODEC_ID_ATRAC3P=86056, CODEC_ID_EAC3=86057, CODEC_ID_SIPR=86058, CODEC_ID_MP1=86059, CODEC_ID_TWINVQ=86060, CODEC_ID_TRUEHD=86061, CODEC_ID_MP4ALS=86062, CODEC_ID_ATRAC1=86063, CODEC_ID_BINKAUDIO_RDFT=86064, CODEC_ID_BINKAUDIO_DCT=86065, CODEC_ID_AAC_LATM=86066, CODEC_ID_QDMC=86067, CODEC_ID_CELT=86068, CODEC_ID_G723_1=86069, CODEC_ID_G729=86070, CODEC_ID_8SVX_EXP=86071, CODEC_ID_8SVX_FIB=86072, CODEC_ID_BMV_AUDIO=86073, CODEC_ID_RALF=86074, CODEC_ID_IAC=86075, CODEC_ID_ILBC=86076, CODEC_ID_FFWAVESYNTH=1179014995, CODEC_ID_SONIC=1397706307, CODEC_ID_SONIC_LS=1397706316, CODEC_ID_PAF_AUDIO=1346455105, CODEC_ID_OPUS=1330664787, CODEC_ID_FIRST_SUBTITLE=94208, CODEC_ID_DVD_SUBTITLE=94208, CODEC_ID_DVB_SUBTITLE=94209, CODEC_ID_TEXT=94210, CODEC_ID_XSUB=94211, CODEC_ID_SSA=94212, CODEC_ID_MOV_TEXT=94213, CODEC_ID_HDMV_PGS_SUBTITLE=94214, CODEC_ID_DVB_TELETEXT=94215, CODEC_ID_SRT=94216, CODEC_ID_MICRODVD=1833195076, CODEC_ID_EIA_608=1664495672, CODEC_ID_JACOSUB=1246975298, CODEC_ID_SAMI=1396788553, CODEC_ID_REALTEXT=1381259348, CODEC_ID_SUBVIEWER=1400201814, CODEC_ID_FIRST_UNKNOWN=98304, CODEC_ID_TTF=98304, CODEC_ID_BINTEXT=1112823892, CODEC_ID_XBIN=1480739150, CODEC_ID_IDF=4801606, CODEC_ID_OTF=5198918, CODEC_ID_PROBE=102400, CODEC_ID_MPEG2TS=131072, CODEC_ID_MPEG4SYSTEMS=131073, CODEC_ID_FFMETADATA=135168 };

// tag-AVCodecInternal
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1482
struct AVCodecInternal;

// tag-AVCodecParser
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4541
struct AVCodecParser;

// tag-AVCodecParserContext
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4539
struct AVCodecParserContext;

// tag-AVCodecTag
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 455
struct AVCodecTag;

// tag-AVColorPrimaries
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 476
enum AVColorPrimaries { AVCOL_PRI_RESERVED0=0, AVCOL_PRI_BT709=1, AVCOL_PRI_UNSPECIFIED=2, AVCOL_PRI_RESERVED=3, AVCOL_PRI_BT470M=4, AVCOL_PRI_BT470BG=5, AVCOL_PRI_SMPTE170M=6, AVCOL_PRI_SMPTE240M=7, AVCOL_PRI_FILM=8, AVCOL_PRI_BT2020=9, AVCOL_PRI_NB=10 };

// tag-AVColorRange
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 537
enum AVColorRange { AVCOL_RANGE_UNSPECIFIED=0, AVCOL_RANGE_MPEG=1, AVCOL_RANGE_JPEG=2, AVCOL_RANGE_NB=3 };

// tag-AVColorSpace
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 517
enum AVColorSpace { AVCOL_SPC_RGB=0, AVCOL_SPC_BT709=1, AVCOL_SPC_UNSPECIFIED=2, AVCOL_SPC_RESERVED=3, AVCOL_SPC_FCC=4, AVCOL_SPC_BT470BG=5, AVCOL_SPC_SMPTE170M=6, AVCOL_SPC_SMPTE240M=7, AVCOL_SPC_YCOCG=8, AVCOL_SPC_BT2020_NCL=9, AVCOL_SPC_BT2020_CL=10, AVCOL_SPC_NB=11 };

// tag-AVColorTransferCharacteristic
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 494
enum AVColorTransferCharacteristic { AVCOL_TRC_RESERVED0=0, AVCOL_TRC_BT709=1, AVCOL_TRC_UNSPECIFIED=2, AVCOL_TRC_RESERVED=3, AVCOL_TRC_GAMMA22=4, AVCOL_TRC_GAMMA28=5, AVCOL_TRC_SMPTE170M=6, AVCOL_TRC_SMPTE240M=7, AVCOL_TRC_LINEAR=8, AVCOL_TRC_LOG=9, AVCOL_TRC_LOG_SQRT=10, AVCOL_TRC_IEC61966_2_4=11, AVCOL_TRC_BT1361_ECG=12, AVCOL_TRC_IEC61966_2_1=13, AVCOL_TRC_BT2020_10=14, AVCOL_TRC_BT2020_12=15, AVCOL_TRC_NB=16 };

// tag-AVDeviceCapabilitiesQuery
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 328
struct AVDeviceCapabilitiesQuery;

// tag-AVDeviceInfoList
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 327
struct AVDeviceInfoList;

// tag-AVDictionary
// file /usr/include/x86_64-linux-gnu/libavutil/dict.h line 87
struct AVDictionary;

// tag-AVDiscard
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 680
enum AVDiscard { AVDISCARD_NONE=-16, AVDISCARD_DEFAULT=0, AVDISCARD_NONREF=8, AVDISCARD_BIDIR=16, AVDISCARD_NONINTRA=24, AVDISCARD_NONKEY=32, AVDISCARD_ALL=48 };

// tag-AVDurationEstimationMethod
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1260
enum AVDurationEstimationMethod { AVFMT_DURATION_FROM_PTS=0, AVFMT_DURATION_FROM_STREAM=1, AVFMT_DURATION_FROM_BITRATE=2 };

// tag-AVFieldOrder
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1484
enum AVFieldOrder { AV_FIELD_UNKNOWN=0, AV_FIELD_PROGRESSIVE=1, AV_FIELD_TT=2, AV_FIELD_BB=3, AV_FIELD_TB=4, AV_FIELD_BT=5 };

// tag-AVFormatContext
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 325
struct AVFormatContext;

// tag-AVFormatInternal
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1266
struct AVFormatInternal;

// tag-AVFrac
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 447
struct AVFrac;

// tag-AVFrame
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 171
struct AVFrame;

// tag-AVFrameSideData
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 134
struct AVFrameSideData;

// tag-AVFrameSideDataType
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 48
enum AVFrameSideDataType { AV_FRAME_DATA_PANSCAN=0, AV_FRAME_DATA_A53_CC=1, AV_FRAME_DATA_STEREO3D=2, AV_FRAME_DATA_MATRIXENCODING=3, AV_FRAME_DATA_DOWNMIX_INFO=4, AV_FRAME_DATA_REPLAYGAIN=5, AV_FRAME_DATA_DISPLAYMATRIX=6, AV_FRAME_DATA_AFD=7, AV_FRAME_DATA_MOTION_VECTORS=8, AV_FRAME_DATA_SKIP_SAMPLES=9, AV_FRAME_DATA_AUDIO_SERVICE_TYPE=10 };

// tag-AVHWAccel
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 2922
struct AVHWAccel;

// tag-AVIOContext
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 111
struct AVIOContext;

// tag-AVIOInterruptCB
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 50
struct AVIOInterruptCB;

// tag-AVIndexEntry
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 787
struct AVIndexEntry;

// tag-AVInputFormat
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 627
struct AVInputFormat;

// tag-AVMediaType
// file /usr/include/x86_64-linux-gnu/libavutil/avutil.h line 191
enum AVMediaType { AVMEDIA_TYPE_UNKNOWN=-1, AVMEDIA_TYPE_VIDEO=0, AVMEDIA_TYPE_AUDIO=1, AVMEDIA_TYPE_DATA=2, AVMEDIA_TYPE_SUBTITLE=3, AVMEDIA_TYPE_ATTACHMENT=4, AVMEDIA_TYPE_NB=5 };

// tag-AVOption
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 85
const struct AVOption;

// tag-AVOptionRanges
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 60
struct AVOptionRanges;

// tag-AVOutputFormat
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 516
struct AVOutputFormat;

// tag-AVPacket
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1400
struct AVPacket;

// tag-AVPacketList
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1044
struct AVPacketList;

// tag-AVPacketSideData
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1372
struct AVPacketSideData;

// tag-AVPacketSideDataType
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1224
enum AVPacketSideDataType { AV_PKT_DATA_PALETTE=0, AV_PKT_DATA_NEW_EXTRADATA=1, AV_PKT_DATA_PARAM_CHANGE=2, AV_PKT_DATA_H263_MB_INFO=3, AV_PKT_DATA_REPLAYGAIN=4, AV_PKT_DATA_DISPLAYMATRIX=5, AV_PKT_DATA_STEREO3D=6, AV_PKT_DATA_AUDIO_SERVICE_TYPE=7, AV_PKT_DATA_QUALITY_STATS=8, AV_PKT_DATA_SKIP_SAMPLES=70, AV_PKT_DATA_JP_DUALMONO=71, AV_PKT_DATA_STRINGS_METADATA=72, AV_PKT_DATA_SUBTITLE_POSITION=73, AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL=74, AV_PKT_DATA_WEBVTT_IDENTIFIER=75, AV_PKT_DATA_WEBVTT_SETTINGS=76, AV_PKT_DATA_METADATA_UPDATE=77 };

// tag-AVPanScan
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 387
struct AVPanScan;

// tag-AVPicture
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3744
struct AVPicture;

// tag-AVPictureStructure
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4532
enum AVPictureStructure { AV_PICTURE_STRUCTURE_UNKNOWN=0, AV_PICTURE_STRUCTURE_TOP_FIELD=1, AV_PICTURE_STRUCTURE_BOTTOM_FIELD=2, AV_PICTURE_STRUCTURE_FRAME=3 };

// tag-AVPictureType
// file /usr/include/x86_64-linux-gnu/libavutil/avutil.h line 264
enum AVPictureType { AV_PICTURE_TYPE_NONE=0, AV_PICTURE_TYPE_I=1, AV_PICTURE_TYPE_P=2, AV_PICTURE_TYPE_B=3, AV_PICTURE_TYPE_S=4, AV_PICTURE_TYPE_SI=5, AV_PICTURE_TYPE_SP=6, AV_PICTURE_TYPE_BI=7 };

// tag-AVPixelFormat
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 61
enum AVPixelFormat { AV_PIX_FMT_NONE=-1, AV_PIX_FMT_YUV420P=0, AV_PIX_FMT_YUYV422=1, AV_PIX_FMT_RGB24=2, AV_PIX_FMT_BGR24=3, AV_PIX_FMT_YUV422P=4, AV_PIX_FMT_YUV444P=5, AV_PIX_FMT_YUV410P=6, AV_PIX_FMT_YUV411P=7, AV_PIX_FMT_GRAY8=8, AV_PIX_FMT_MONOWHITE=9, AV_PIX_FMT_MONOBLACK=10, AV_PIX_FMT_PAL8=11, AV_PIX_FMT_YUVJ420P=12, AV_PIX_FMT_YUVJ422P=13, AV_PIX_FMT_YUVJ444P=14, AV_PIX_FMT_XVMC_MPEG2_MC=15, AV_PIX_FMT_XVMC_MPEG2_IDCT=16, AV_PIX_FMT_UYVY422=17, AV_PIX_FMT_UYYVYY411=18, AV_PIX_FMT_BGR8=19, AV_PIX_FMT_BGR4=20, AV_PIX_FMT_BGR4_BYTE=21, AV_PIX_FMT_RGB8=22, AV_PIX_FMT_RGB4=23, AV_PIX_FMT_RGB4_BYTE=24, AV_PIX_FMT_NV12=25, AV_PIX_FMT_NV21=26, AV_PIX_FMT_ARGB=27, AV_PIX_FMT_RGBA=28, AV_PIX_FMT_ABGR=29, AV_PIX_FMT_BGRA=30, AV_PIX_FMT_GRAY16BE=31, AV_PIX_FMT_GRAY16LE=32, AV_PIX_FMT_YUV440P=33, AV_PIX_FMT_YUVJ440P=34, AV_PIX_FMT_YUVA420P=35, AV_PIX_FMT_VDPAU_H264=36, AV_PIX_FMT_VDPAU_MPEG1=37, AV_PIX_FMT_VDPAU_MPEG2=38, AV_PIX_FMT_VDPAU_WMV3=39, AV_PIX_FMT_VDPAU_VC1=40, AV_PIX_FMT_RGB48BE=41, AV_PIX_FMT_RGB48LE=42, AV_PIX_FMT_RGB565BE=43, AV_PIX_FMT_RGB565LE=44, AV_PIX_FMT_RGB555BE=45, AV_PIX_FMT_RGB555LE=46, AV_PIX_FMT_BGR565BE=47, AV_PIX_FMT_BGR565LE=48, AV_PIX_FMT_BGR555BE=49, AV_PIX_FMT_BGR555LE=50, AV_PIX_FMT_VAAPI_MOCO=51, AV_PIX_FMT_VAAPI_IDCT=52, AV_PIX_FMT_VAAPI_VLD=53, AV_PIX_FMT_VAAPI=53, AV_PIX_FMT_YUV420P16LE=54, AV_PIX_FMT_YUV420P16BE=55, AV_PIX_FMT_YUV422P16LE=56, AV_PIX_FMT_YUV422P16BE=57, AV_PIX_FMT_YUV444P16LE=58, AV_PIX_FMT_YUV444P16BE=59, AV_PIX_FMT_VDPAU_MPEG4=60, AV_PIX_FMT_DXVA2_VLD=61, AV_PIX_FMT_RGB444LE=62, AV_PIX_FMT_RGB444BE=63, AV_PIX_FMT_BGR444LE=64, AV_PIX_FMT_BGR444BE=65, AV_PIX_FMT_YA8=66, AV_PIX_FMT_Y400A=66, AV_PIX_FMT_GRAY8A=66, AV_PIX_FMT_BGR48BE=67, AV_PIX_FMT_BGR48LE=68, AV_PIX_FMT_YUV420P9BE=69, AV_PIX_FMT_YUV420P9LE=70, AV_PIX_FMT_YUV420P10BE=71, AV_PIX_FMT_YUV420P10LE=72, AV_PIX_FMT_YUV422P10BE=73, AV_PIX_FMT_YUV422P10LE=74, AV_PIX_FMT_YUV444P9BE=75, AV_PIX_FMT_YUV444P9LE=76, AV_PIX_FMT_YUV444P10BE=77, AV_PIX_FMT_YUV444P10LE=78, AV_PIX_FMT_YUV422P9BE=79, AV_PIX_FMT_YUV422P9LE=80, AV_PIX_FMT_VDA_VLD=81, AV_PIX_FMT_GBRP=82, AV_PIX_FMT_GBRP9BE=83, AV_PIX_FMT_GBRP9LE=84, AV_PIX_FMT_GBRP10BE=85, AV_PIX_FMT_GBRP10LE=86, AV_PIX_FMT_GBRP16BE=87, AV_PIX_FMT_GBRP16LE=88, AV_PIX_FMT_YUVA422P_LIBAV=89, AV_PIX_FMT_YUVA444P_LIBAV=90, AV_PIX_FMT_YUVA420P9BE=91, AV_PIX_FMT_YUVA420P9LE=92, AV_PIX_FMT_YUVA422P9BE=93, AV_PIX_FMT_YUVA422P9LE=94, AV_PIX_FMT_YUVA444P9BE=95, AV_PIX_FMT_YUVA444P9LE=96, AV_PIX_FMT_YUVA420P10BE=97, AV_PIX_FMT_YUVA420P10LE=98, AV_PIX_FMT_YUVA422P10BE=99, AV_PIX_FMT_YUVA422P10LE=100, AV_PIX_FMT_YUVA444P10BE=101, AV_PIX_FMT_YUVA444P10LE=102, AV_PIX_FMT_YUVA420P16BE=103, AV_PIX_FMT_YUVA420P16LE=104, AV_PIX_FMT_YUVA422P16BE=105, AV_PIX_FMT_YUVA422P16LE=106, AV_PIX_FMT_YUVA444P16BE=107, AV_PIX_FMT_YUVA444P16LE=108, AV_PIX_FMT_VDPAU=109, AV_PIX_FMT_XYZ12LE=110, AV_PIX_FMT_XYZ12BE=111, AV_PIX_FMT_NV16=112, AV_PIX_FMT_NV20LE=113, AV_PIX_FMT_NV20BE=114, AV_PIX_FMT_RGBA64BE_LIBAV=115, AV_PIX_FMT_RGBA64LE_LIBAV=116, AV_PIX_FMT_BGRA64BE_LIBAV=117, AV_PIX_FMT_BGRA64LE_LIBAV=118, AV_PIX_FMT_YVYU422=119, AV_PIX_FMT_VDA=120, AV_PIX_FMT_YA16BE=121, AV_PIX_FMT_YA16LE=122, AV_PIX_FMT_GBRAP_LIBAV=123, AV_PIX_FMT_GBRAP16BE_LIBAV=124, AV_PIX_FMT_GBRAP16LE_LIBAV=125, AV_PIX_FMT_QSV=126, AV_PIX_FMT_MMAL=127, AV_PIX_FMT_D3D11VA_VLD=128, AV_PIX_FMT_RGBA64BE=291, AV_PIX_FMT_RGBA64LE=292, AV_PIX_FMT_BGRA64BE=293, AV_PIX_FMT_BGRA64LE=294, AV_PIX_FMT_0RGB=295, AV_PIX_FMT_RGB0=296, AV_PIX_FMT_0BGR=297, AV_PIX_FMT_BGR0=298, AV_PIX_FMT_YUVA444P=299, AV_PIX_FMT_YUVA422P=300, AV_PIX_FMT_YUV420P12BE=301, AV_PIX_FMT_YUV420P12LE=302, AV_PIX_FMT_YUV420P14BE=303, AV_PIX_FMT_YUV420P14LE=304, AV_PIX_FMT_YUV422P12BE=305, AV_PIX_FMT_YUV422P12LE=306, AV_PIX_FMT_YUV422P14BE=307, AV_PIX_FMT_YUV422P14LE=308, AV_PIX_FMT_YUV444P12BE=309, AV_PIX_FMT_YUV444P12LE=310, AV_PIX_FMT_YUV444P14BE=311, AV_PIX_FMT_YUV444P14LE=312, AV_PIX_FMT_GBRP12BE=313, AV_PIX_FMT_GBRP12LE=314, AV_PIX_FMT_GBRP14BE=315, AV_PIX_FMT_GBRP14LE=316, AV_PIX_FMT_GBRAP=317, AV_PIX_FMT_GBRAP16BE=318, AV_PIX_FMT_GBRAP16LE=319, AV_PIX_FMT_YUVJ411P=320, AV_PIX_FMT_BAYER_BGGR8=321, AV_PIX_FMT_BAYER_RGGB8=322, AV_PIX_FMT_BAYER_GBRG8=323, AV_PIX_FMT_BAYER_GRBG8=324, AV_PIX_FMT_BAYER_BGGR16LE=325, AV_PIX_FMT_BAYER_BGGR16BE=326, AV_PIX_FMT_BAYER_RGGB16LE=327, AV_PIX_FMT_BAYER_RGGB16BE=328, AV_PIX_FMT_BAYER_GBRG16LE=329, AV_PIX_FMT_BAYER_GBRG16BE=330, AV_PIX_FMT_BAYER_GRBG16LE=331, AV_PIX_FMT_BAYER_GRBG16BE=332, AV_PIX_FMT_YUV440P10LE=333, AV_PIX_FMT_YUV440P10BE=334, AV_PIX_FMT_YUV440P12LE=335, AV_PIX_FMT_YUV440P12BE=336, AV_PIX_FMT_AYUV64LE=337, AV_PIX_FMT_AYUV64BE=338, AV_PIX_FMT_VIDEOTOOLBOX=339, AV_PIX_FMT_NB=340, PIX_FMT_NONE=-1, PIX_FMT_YUV420P=0, PIX_FMT_YUYV422=1, PIX_FMT_RGB24=2, PIX_FMT_BGR24=3, PIX_FMT_YUV422P=4, PIX_FMT_YUV444P=5, PIX_FMT_YUV410P=6, PIX_FMT_YUV411P=7, PIX_FMT_GRAY8=8, PIX_FMT_MONOWHITE=9, PIX_FMT_MONOBLACK=10, PIX_FMT_PAL8=11, PIX_FMT_YUVJ420P=12, PIX_FMT_YUVJ422P=13, PIX_FMT_YUVJ444P=14, PIX_FMT_XVMC_MPEG2_MC=15, PIX_FMT_XVMC_MPEG2_IDCT=16, PIX_FMT_UYVY422=17, PIX_FMT_UYYVYY411=18, PIX_FMT_BGR8=19, PIX_FMT_BGR4=20, PIX_FMT_BGR4_BYTE=21, PIX_FMT_RGB8=22, PIX_FMT_RGB4=23, PIX_FMT_RGB4_BYTE=24, PIX_FMT_NV12=25, PIX_FMT_NV21=26, PIX_FMT_ARGB=27, PIX_FMT_RGBA=28, PIX_FMT_ABGR=29, PIX_FMT_BGRA=30, PIX_FMT_GRAY16BE=31, PIX_FMT_GRAY16LE=32, PIX_FMT_YUV440P=33, PIX_FMT_YUVJ440P=34, PIX_FMT_YUVA420P=35, PIX_FMT_VDPAU_H264=36, PIX_FMT_VDPAU_MPEG1=37, PIX_FMT_VDPAU_MPEG2=38, PIX_FMT_VDPAU_WMV3=39, PIX_FMT_VDPAU_VC1=40, PIX_FMT_RGB48BE=41, PIX_FMT_RGB48LE=42, PIX_FMT_RGB565BE=43, PIX_FMT_RGB565LE=44, PIX_FMT_RGB555BE=45, PIX_FMT_RGB555LE=46, PIX_FMT_BGR565BE=47, PIX_FMT_BGR565LE=48, PIX_FMT_BGR555BE=49, PIX_FMT_BGR555LE=50, PIX_FMT_VAAPI_MOCO=51, PIX_FMT_VAAPI_IDCT=52, PIX_FMT_VAAPI_VLD=53, PIX_FMT_YUV420P16LE=54, PIX_FMT_YUV420P16BE=55, PIX_FMT_YUV422P16LE=56, PIX_FMT_YUV422P16BE=57, PIX_FMT_YUV444P16LE=58, PIX_FMT_YUV444P16BE=59, PIX_FMT_VDPAU_MPEG4=60, PIX_FMT_DXVA2_VLD=61, PIX_FMT_RGB444LE=62, PIX_FMT_RGB444BE=63, PIX_FMT_BGR444LE=64, PIX_FMT_BGR444BE=65, PIX_FMT_GRAY8A=66, PIX_FMT_BGR48BE=67, PIX_FMT_BGR48LE=68, PIX_FMT_YUV420P9BE=69, PIX_FMT_YUV420P9LE=70, PIX_FMT_YUV420P10BE=71, PIX_FMT_YUV420P10LE=72, PIX_FMT_YUV422P10BE=73, PIX_FMT_YUV422P10LE=74, PIX_FMT_YUV444P9BE=75, PIX_FMT_YUV444P9LE=76, PIX_FMT_YUV444P10BE=77, PIX_FMT_YUV444P10LE=78, PIX_FMT_YUV422P9BE=79, PIX_FMT_YUV422P9LE=80, PIX_FMT_VDA_VLD=81, PIX_FMT_GBRP=82, PIX_FMT_GBRP9BE=83, PIX_FMT_GBRP9LE=84, PIX_FMT_GBRP10BE=85, PIX_FMT_GBRP10LE=86, PIX_FMT_GBRP16BE=87, PIX_FMT_GBRP16LE=88, PIX_FMT_RGBA64BE=291, PIX_FMT_RGBA64LE=292, PIX_FMT_BGRA64BE=293, PIX_FMT_BGRA64LE=294, PIX_FMT_0RGB=295, PIX_FMT_RGB0=296, PIX_FMT_0BGR=297, PIX_FMT_BGR0=298, PIX_FMT_YUVA444P=299, PIX_FMT_YUVA422P=300, PIX_FMT_YUV420P12BE=301, PIX_FMT_YUV420P12LE=302, PIX_FMT_YUV420P14BE=303, PIX_FMT_YUV420P14LE=304, PIX_FMT_YUV422P12BE=305, PIX_FMT_YUV422P12LE=306, PIX_FMT_YUV422P14BE=307, PIX_FMT_YUV422P14LE=308, PIX_FMT_YUV444P12BE=309, PIX_FMT_YUV444P12LE=310, PIX_FMT_YUV444P14BE=311, PIX_FMT_YUV444P14LE=312, PIX_FMT_GBRP12BE=313, PIX_FMT_GBRP12LE=314, PIX_FMT_GBRP14BE=315, PIX_FMT_GBRP14LE=316, PIX_FMT_NB=317 };

// tag-AVProbeData
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 460
struct AVProbeData;

// tag-AVProfile
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3460
struct AVProfile;

// tag-AVProgram
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1210
struct AVProgram;

// tag-AVRational
// file /usr/include/x86_64-linux-gnu/libavutil/rational.h line 43
struct AVRational;

// tag-AVSampleFormat
// file /usr/include/x86_64-linux-gnu/libavutil/samplefmt.h line 59
enum AVSampleFormat { AV_SAMPLE_FMT_NONE=-1, AV_SAMPLE_FMT_U8=0, AV_SAMPLE_FMT_S16=1, AV_SAMPLE_FMT_S32=2, AV_SAMPLE_FMT_FLT=3, AV_SAMPLE_FMT_DBL=4, AV_SAMPLE_FMT_U8P=5, AV_SAMPLE_FMT_S16P=6, AV_SAMPLE_FMT_S32P=7, AV_SAMPLE_FMT_FLTP=8, AV_SAMPLE_FMT_DBLP=9, AV_SAMPLE_FMT_NB=10 };

// tag-AVStream
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 846
struct AVStream;

// tag-AVStreamParseType
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 776
enum AVStreamParseType { AVSTREAM_PARSE_NONE=0, AVSTREAM_PARSE_FULL=1, AVSTREAM_PARSE_HEADERS=2, AVSTREAM_PARSE_TIMESTAMPS=3, AVSTREAM_PARSE_FULL_ONCE=4, AVSTREAM_PARSE_FULL_RAW=1463898624 };

// tag-AVSubtitle
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3467
struct AVSubtitle;

// tag-AVSubtitleRect
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3773
struct AVSubtitleRect;

// tag-AVSubtitleType
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3753
enum AVSubtitleType { SUBTITLE_NONE=0, SUBTITLE_BITMAP=1, SUBTITLE_TEXT=2, SUBTITLE_ASS=3 };

// tag-DSCO_packet
// file slimproto.h line 63
struct DSCO_packet;

// tag-FFFrac
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1186
struct FFFrac;

// tag-FLAC__StreamDecoderPrivate
// file /usr/include/FLAC/stream_decoder.h line 458
struct FLAC__StreamDecoderPrivate;

// tag-FLAC__StreamDecoderProtected
// file /usr/include/FLAC/stream_decoder.h line 457
struct FLAC__StreamDecoderProtected;

// tag-HELO_packet
// file slimproto.h line 26
struct HELO_packet;

// tag-IR_packet
// file slimproto.h line 92
struct IR_packet;

// tag-META_header
// file slimproto.h line 77
struct META_header;

// tag-MpegEncContext
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3571
struct MpegEncContext;

// tag-NeAACDecConfiguration
// file /usr/include/neaacdec.h line 167
struct NeAACDecConfiguration;

// tag-NeAACDecFrameInfo
// file /usr/include/neaacdec.h line 177
struct NeAACDecFrameInfo;

// tag-OggVorbis_File
// file /usr/include/vorbis/vorbisfile.h line 111
struct OggVorbis_File;

// tag-PaDeviceInfo
// file /usr/include/portaudio.h line 449
struct PaDeviceInfo;

// tag-PaHostApiInfo
// file /usr/include/portaudio.h line 245
struct PaHostApiInfo;

// tag-PaHostApiTypeId
// file /usr/include/portaudio.h line 224
enum PaHostApiTypeId { paInDevelopment=0, paDirectSound=1, paMME=2, paASIO=3, paSoundManager=4, paCoreAudio=5, paOSS=7, paALSA=8, paAL=9, paBeOS=10, paWDMKS=11, paJACK=12, paWASAPI=13, paAudioScienceHPI=14 };

// tag-PaStreamCallbackTimeInfo
// file /usr/include/portaudio.h line 648
struct PaStreamCallbackTimeInfo;

// tag-PaStreamInfo
// file /usr/include/portaudio.h line 988
struct PaStreamInfo;

// tag-PaStreamParameters
// file /usr/include/portaudio.h line 487
struct PaStreamParameters;

// tag-RESP_header
// file slimproto.h line 70
struct RESP_header;

// tag-RcOverride
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 708
struct RcOverride;

// tag-SETD_header
// file slimproto.h line 84
struct SETD_header;

// tag-STAT_packet
// file slimproto.h line 40
struct STAT_packet;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-alloc_chain
// file /usr/include/vorbis/codec.h line 110
struct alloc_chain;

// tag-aude_packet
// file slimproto.h line 126
struct aude_packet;

// tag-audg_packet
// file slimproto.h line 133
struct audg_packet;

// tag-buffer
// file squeezelite.h line 405
struct buffer;

// tag-chunk_table
// file faad.c line 27
struct chunk_table;

// tag-codc_packet
// file slimproto.h line 167
struct codc_packet;

// tag-codec
// file squeezelite.h line 482
struct codec;

// tag-cont_packet
// file slimproto.h line 145
struct cont_packet;

// tag-decodestate
// file squeezelite.h line 462
struct decodestate;

// tag-dsd
// file dsd.c line 67
struct dsd;

// tag-dsd2pcm_ctx_s
// file dsd2pcm/dsd2pcm.h line 45
struct dsd2pcm_ctx_s;

// tag-faad
// file faad.c line 31
struct faad;

// tag-ff_s
// file ffmpeg.c line 34
struct ff_s;

// tag-flac
// file flac.c line 25
struct flac;

// tag-handler
// file slimproto.c line 473
struct handler;

// tag-ifconf
// file /usr/include/net/if.h line 176
struct ifconf;

// tag-ifmap
// file /usr/include/net/if.h line 111
struct ifmap;

// tag-ifreq
// file /usr/include/net/if.h line 126
struct ifreq;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-irstate
// file squeezelite.h line 656
struct irstate;

// tag-lirc_code
// file /usr/include/lirc/lirc_client.h line 47
struct lirc_code;

// tag-lirc_config
// file /usr/include/lirc/lirc_client.h line 53
struct lirc_config;

// tag-lirc_config_entry
// file /usr/include/lirc/lirc_client.h line 55
struct lirc_config_entry;

// tag-lirc_list
// file /usr/include/lirc/lirc_client.h line 42
struct lirc_list;

// tag-mad
// file mad.c line 29
struct mad;

// tag-mad_bitptr
// file /usr/include/mad.h line 572
struct mad_bitptr;

// tag-mad_emphasis
// file /usr/include/mad.h line 786
enum mad_emphasis { MAD_EMPHASIS_NONE=0, MAD_EMPHASIS_50_15_US=1, MAD_EMPHASIS_CCITT_J_17=3, MAD_EMPHASIS_RESERVED=2 };

// tag-mad_error
// file /usr/include/mad.h line 687
enum mad_error { MAD_ERROR_NONE=0, MAD_ERROR_BUFLEN=1, MAD_ERROR_BUFPTR=2, MAD_ERROR_NOMEM=49, MAD_ERROR_LOSTSYNC=257, MAD_ERROR_BADLAYER=258, MAD_ERROR_BADBITRATE=259, MAD_ERROR_BADSAMPLERATE=260, MAD_ERROR_BADEMPHASIS=261, MAD_ERROR_BADCRC=513, MAD_ERROR_BADBITALLOC=529, MAD_ERROR_BADSCALEFACTOR=545, MAD_ERROR_BADMODE=546, MAD_ERROR_BADFRAMELEN=561, MAD_ERROR_BADBIGVALUES=562, MAD_ERROR_BADBLOCKTYPE=563, MAD_ERROR_BADSCFSI=564, MAD_ERROR_BADDATAPTR=565, MAD_ERROR_BADPART3LEN=566, MAD_ERROR_BADHUFFTABLE=567, MAD_ERROR_BADHUFFDATA=568, MAD_ERROR_BADSTEREO=569 };

// tag-mad_frame
// file /usr/include/mad.h line 811
struct mad_frame;

// tag-mad_header
// file /usr/include/mad.h line 793
struct mad_header;

// tag-mad_layer
// file /usr/include/mad.h line 773
enum mad_layer { MAD_LAYER_I=1, MAD_LAYER_II=2, MAD_LAYER_III=3 };

// tag-mad_mode
// file /usr/include/mad.h line 779
enum mad_mode { MAD_MODE_SINGLE_CHANNEL=0, MAD_MODE_DUAL_CHANNEL=1, MAD_MODE_JOINT_STEREO=2, MAD_MODE_STEREO=3 };

// tag-mad_pcm
// file /usr/include/mad.h line 870
struct mad_pcm;

// tag-mad_stream
// file /usr/include/mad.h line 718
struct mad_stream;

// tag-mad_synth
// file /usr/include/mad.h line 877
struct mad_synth;

// tag-mpg
// file mpg.c line 28
struct mpg;

// tag-mpg123_feature_set
// file /usr/include/mpg123.h line 205
enum mpg123_feature_set { MPG123_FEATURE_ABI_UTF8OPEN=0, MPG123_FEATURE_OUTPUT_8BIT=1, MPG123_FEATURE_OUTPUT_16BIT=2, MPG123_FEATURE_OUTPUT_32BIT=3, MPG123_FEATURE_INDEX=4, MPG123_FEATURE_PARSE_ID3V2=5, MPG123_FEATURE_DECODE_LAYER1=6, MPG123_FEATURE_DECODE_LAYER2=7, MPG123_FEATURE_DECODE_LAYER3=8, MPG123_FEATURE_DECODE_ACCURATE=9, MPG123_FEATURE_DECODE_DOWNSAMPLE=10, MPG123_FEATURE_DECODE_NTOM=11, MPG123_FEATURE_PARSE_ICY=12, MPG123_FEATURE_TIMEOUT_READ=13 };

// tag-mpg123_handle_struct
// file /usr/include/mpg123.h line 105
struct mpg123_handle_struct;

// tag-outputstate
// file squeezelite.h line 529
struct outputstate;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-processstate
// file squeezelite.h line 473
struct processstate;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-serv_packet
// file slimproto.h line 153
struct serv_packet;

// tag-setd_packet
// file slimproto.h line 160
struct setd_packet;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-soxr
// file /usr/include/soxr.h line 75
struct soxr;

// tag-soxr_io_spec
// file /usr/include/soxr.h line 45
struct soxr_io_spec;

// tag-soxr_quality_spec
// file /usr/include/soxr.h line 46
struct soxr_quality_spec;

// tag-soxr_runtime_spec
// file /usr/include/soxr.h line 47
struct soxr_runtime_spec;

// tag-streamstate
// file squeezelite.h line 438
struct streamstate;

// tag-strm_packet
// file slimproto.h line 103
struct strm_packet;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-vis_t
// file output_vis.c line 34
struct vis_t;

// tag-vorbis
// file vorbis.c line 32
struct vorbis;

// tag-vorbis_block
// file /usr/include/vorbis/codec.h line 88
struct vorbis_block;

// tag-vorbis_comment
// file /usr/include/vorbis/codec.h line 140
struct vorbis_comment;

// tag-vorbis_dsp_state
// file /usr/include/vorbis/codec.h line 59
struct vorbis_dsp_state;

// tag-vorbis_info
// file /usr/include/vorbis/codec.h line 28
struct vorbis_info;

#ifndef NULL
#define NULL ((void*)0)
#endif

// FLAC__stream_decoder_delete
// file /usr/include/FLAC/stream_decoder.h line 751
void FLAC__stream_decoder_delete(struct anonymous_43 *);
// FLAC__stream_decoder_get_state
// file /usr/include/FLAC/stream_decoder.h line 890
enum anonymous_62 FLAC__stream_decoder_get_state(const struct anonymous_43 *);
// FLAC__stream_decoder_init_stream
// file /usr/include/FLAC/stream_decoder.h line 1073
enum anonymous_63 FLAC__stream_decoder_init_stream(struct anonymous_43 *, enum anonymous_64 (*)(const struct anonymous_43 *, unsigned char *, unsigned long int *, void *), enum anonymous_65 (*)(const struct anonymous_43 *, unsigned long int, void *), enum anonymous_66 (*)(const struct anonymous_43 *, unsigned long int *, void *), enum anonymous_67 (*)(const struct anonymous_43 *, unsigned long int *, void *), signed int (*)(const struct anonymous_43 *, void *), enum anonymous_42 (*)(const struct anonymous_43 *, const struct anonymous_45 *, const signed int * const *, void *), void (*)(const struct anonymous_43 *, const struct anonymous_61 *, void *), void (*)(const struct anonymous_43 *, enum anonymous_68, void *), void *);
// FLAC__stream_decoder_new
// file /usr/include/FLAC/stream_decoder.h line 743
struct anonymous_43 * FLAC__stream_decoder_new(void);
// FLAC__stream_decoder_process_single
// file /usr/include/FLAC/stream_decoder.h line 1451
signed int FLAC__stream_decoder_process_single(struct anonymous_43 *);
// FLAC__stream_decoder_reset
// file /usr/include/FLAC/stream_decoder.h line 1418
signed int FLAC__stream_decoder_reset(struct anonymous_43 *);
// NeAACDecClose
// file /usr/include/neaacdec.h line 236
void NeAACDecClose(void *);
// NeAACDecDecode
// file /usr/include/neaacdec.h line 238
void * NeAACDecDecode(void *, struct NeAACDecFrameInfo *, unsigned char *, unsigned long int);
// NeAACDecGetCurrentConfiguration
// file /usr/include/neaacdec.h line 211
struct NeAACDecConfiguration * NeAACDecGetCurrentConfiguration(void *);
// NeAACDecGetErrorMessage
// file /usr/include/neaacdec.h line 205
char * NeAACDecGetErrorMessage(unsigned char);
// NeAACDecInit
// file /usr/include/neaacdec.h line 217
signed long int NeAACDecInit(void *, unsigned char *, unsigned long int, unsigned long int *, unsigned char *);
// NeAACDecInit2
// file /usr/include/neaacdec.h line 224
char NeAACDecInit2(void *, unsigned char *, unsigned long int, unsigned long int *, unsigned char *);
// NeAACDecOpen
// file /usr/include/neaacdec.h line 209
void * NeAACDecOpen(void);
// NeAACDecSetConfiguration
// file /usr/include/neaacdec.h line 213
unsigned char NeAACDecSetConfiguration(void *, struct NeAACDecConfiguration *);
// Pa_AbortStream
// file /usr/include/portaudio.h line 949
signed int Pa_AbortStream(void *);
// Pa_CloseStream
// file /usr/include/portaudio.h line 894
signed int Pa_CloseStream(void *);
// Pa_GetDefaultOutputDevice
// file /usr/include/portaudio.h line 398
signed int Pa_GetDefaultOutputDevice(void);
// Pa_GetDeviceCount
// file /usr/include/portaudio.h line 371
signed int Pa_GetDeviceCount(void);
// Pa_GetDeviceInfo
// file /usr/include/portaudio.h line 482
const struct PaDeviceInfo * Pa_GetDeviceInfo(signed int);
// Pa_GetErrorText
// file /usr/include/portaudio.h line 110
const char * Pa_GetErrorText(signed int);
// Pa_GetHostApiInfo
// file /usr/include/portaudio.h line 289
const struct PaHostApiInfo * Pa_GetHostApiInfo(signed int);
// Pa_GetStreamInfo
// file /usr/include/portaudio.h line 1034
const struct PaStreamInfo * Pa_GetStreamInfo(void *);
// Pa_GetStreamTime
// file /usr/include/portaudio.h line 1052
double Pa_GetStreamTime(void *);
// Pa_Initialize
// file /usr/include/portaudio.h line 132
signed int Pa_Initialize(void);
// Pa_OpenStream
// file /usr/include/portaudio.h line 841
signed int Pa_OpenStream(void **, const struct PaStreamParameters *, const struct PaStreamParameters *, double, unsigned long int, unsigned long int, signed int (*)(const void *, void *, unsigned long int, const struct PaStreamCallbackTimeInfo *, unsigned long int, void *), void *);
// Pa_SetStreamFinishedCallback
// file /usr/include/portaudio.h line 932
signed int Pa_SetStreamFinishedCallback(void *, void (*)(void *));
// Pa_StartStream
// file /usr/include/portaudio.h line 937
signed int Pa_StartStream(void *);
// Pa_Terminate
// file /usr/include/portaudio.h line 151
signed int Pa_Terminate(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _apply_cross
// file squeezelite.h line 619
inline void _apply_cross(struct buffer *outputbuf, unsigned int out_frames, signed int cross_gain_in, signed int cross_gain_out, signed int **cross_ptr);
// _apply_gain
// file squeezelite.h line 620
inline void _apply_gain(struct buffer *outputbuf, unsigned int count, signed int gainL, signed int gainR);
// _buf_cont_read
// file buffer.c line 37
unsigned int _buf_cont_read(struct buffer *buf);
// _buf_cont_write
// file buffer.c line 41
unsigned int _buf_cont_write(struct buffer *buf);
// _buf_inc_readp
// file buffer.c line 45
void _buf_inc_readp(struct buffer *buf, unsigned int by);
// _buf_inc_writep
// file buffer.c line 52
void _buf_inc_writep(struct buffer *buf, unsigned int by);
// _buf_resize
// file buffer.c line 79
void _buf_resize(struct buffer *buf, unsigned long int size);
// _buf_space
// file buffer.c line 33
unsigned int _buf_space(struct buffer *buf);
// _buf_used
// file squeezelite.h line 416
inline unsigned int _buf_used(struct buffer *buf);
// _check_header
// file pcm.c line 68
static void _check_header(void);
// _check_id3_tag
// file mad.c line 102
static unsigned int _check_id3_tag(unsigned long int bytes);
// _check_lame_header
// file mad.c line 118
static void _check_lame_header(unsigned long int bytes);
// _checkfade
// file output.c line 278
void _checkfade(_Bool start);
// _close_cb
// file vorbis.c line 100
static signed int _close_cb(void *datasource);
// _decode_dsdiff
// file dsd.c line 368
static enum anonymous_23 _decode_dsdiff(void);
// _decode_dsf
// file dsd.c line 207
static enum anonymous_23 _decode_dsf(void);
// _disconnect
// file stream.c line 69
static void _disconnect(enum anonymous_14 state, enum anonymous_0 disconnect);
// _free_ff_data
// file ffmpeg.c line 513
static void _free_ff_data(void);
// _output_frames
// file output.c line 43
unsigned int _output_frames(unsigned int avail);
// _pa_open
// file squeezelite.h line 610
void _pa_open(void);
// _parse_packlen
// file ffmpeg.c line 132
static signed int _parse_packlen(void);
// _read_cb
// file vorbis.c line 86
static unsigned long int _read_cb(void *ptr, unsigned long int size, unsigned long int nmemb, void *datasource);
// _read_data
// file ffmpeg.c line 159
static signed int _read_data(void *opaque, unsigned char *buffer, signed int buf_size);
// _read_header
// file dsd.c line 98
static signed int _read_header(void);
// _scale_and_pack_frames
// file squeezelite.h line 618
void _scale_and_pack_frames(void *outputptr, signed int *inputptr, unsigned int cnt, signed int gainL, signed int gainR, enum anonymous_22 format);
// _seek_cb
// file vorbis.c line 99
static signed int _seek_cb(void *datasource, signed long int offset, signed int whence);
// _stdout_write_frames
// file output_stdout.c line 47
static signed int _stdout_write_frames(unsigned int out_frames, _Bool silence, signed int gainL, signed int gainR, signed int cross_gain_in, signed int cross_gain_out, signed int **cross_ptr);
// _tell_cb
// file vorbis.c line 101
static signed long int _tell_cb(void *datasource);
// _vis_export
// file squeezelite.h line 626
void _vis_export(struct buffer *outputbuf, struct outputstate *output, unsigned int out_frames, _Bool silence);
// _write_frames
// file output_pa.c line 302
static signed int _write_frames(unsigned int out_frames, _Bool silence, signed int gainL, signed int gainR, signed int cross_gain_in, signed int cross_gain_out, signed int **cross_ptr);
// _write_samples
// file process.c line 51
static void _write_samples(void);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// av__err2str
// file ffmpeg.c line 122
static char * av__err2str(signed int errnum);
// av_err_callback
// file ffmpeg.c line 661
void av_err_callback(void *avcl, signed int level, const char *fmt, void **vl);
// av_find_input_format
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2017
struct AVInputFormat * av_find_input_format(const char *);
// av_frame_alloc
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 630
struct AVFrame * av_frame_alloc(void);
// av_frame_free
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 639
void av_frame_free(struct AVFrame **);
// av_free_packet
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4108
void av_free_packet(struct AVPacket *);
// av_freep
// file /usr/include/x86_64-linux-gnu/libavutil/mem.h line 269
void av_freep(void *);
// av_init_packet
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4040
void av_init_packet(struct AVPacket *);
// av_log_set_callback
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 282
void av_log_set_callback(void (*)(void *, signed int, const char *, void **));
// av_malloc
// file /usr/include/x86_64-linux-gnu/libavutil/mem.h line 83
void * av_malloc(unsigned long int);
// av_read_frame
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2192
signed int av_read_frame(struct AVFormatContext *, struct AVPacket *);
// av_register_all
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1896
void av_register_all(void);
// av_strerror
// file /usr/include/x86_64-linux-gnu/libavutil/error.h line 97
signed int av_strerror(signed int, char *, unsigned long int);
// avcodec_decode_audio4
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4446
signed int avcodec_decode_audio4(struct AVCodecContext *, struct AVFrame *, signed int *, const struct AVPacket *);
// avcodec_find_decoder
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4256
struct AVCodec * avcodec_find_decoder(enum AVCodecID);
// avcodec_open2
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3994
signed int avcodec_open2(struct AVCodecContext *, const struct AVCodec *, struct AVDictionary **);
// avformat_alloc_context
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1935
struct AVFormatContext * avformat_alloc_context(void);
// avformat_find_stream_info
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2123
signed int avformat_find_stream_info(struct AVFormatContext *, struct AVDictionary **);
// avformat_free_context
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1941
void avformat_free_context(struct AVFormatContext *);
// avformat_open_input
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2097
signed int avformat_open_input(struct AVFormatContext **, const char *, struct AVInputFormat *, struct AVDictionary **);
// avio_alloc_context
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 315
struct AVIOContext * avio_alloc_context(unsigned char *, signed int, signed int, void *, signed int (*)(void *, unsigned char *, signed int), signed int (*)(void *, unsigned char *, signed int), signed long int (*)(void *, signed long int, signed int));
// buf_adjust
// file buffer.c line 67
void buf_adjust(struct buffer *buf, unsigned long int mod);
// buf_destroy
// file buffer.c line 106
void buf_destroy(struct buffer *buf);
// buf_flush
// file squeezelite.h line 422
void buf_flush(struct buffer *buf);
// buf_init
// file buffer.c line 96
void buf_init(struct buffer *buf, unsigned long int size);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// codec_open
// file squeezelite.h line 496
void codec_open(unsigned char format, unsigned char sample_size, unsigned char sample_rate, unsigned char channels, unsigned char endianness);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// connect_timeout
// file squeezelite.h line 379
signed int connect_timeout(signed int sock, struct sockaddr *addr, unsigned int addrlen, signed int timeout);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// decode_close
// file squeezelite.h line 493
void decode_close(void);
// decode_flush
// file squeezelite.h line 494
void decode_flush(void);
// decode_init
// file squeezelite.h line 492
void decode_init(enum anonymous_8 level, const char *include_codecs, const char *exclude_codecs);
// decode_newstream
// file decode.c line 199
unsigned int decode_newstream(unsigned int sample_rate, unsigned int *supported_rates);
// decode_thread
// file decode.c line 55
static void * decode_thread();
// discover_server
// file slimproto.c line 733
unsigned int discover_server(void);
// dop_init
// file squeezelite.h line 639
void dop_init(_Bool enable, unsigned int delay);
// dop_silence_frames
// file squeezelite.h line 638
void dop_silence_frames(unsigned int *ptr, unsigned int frames);
// dsd2pcm_clone
// file dsd2pcm/dsd2pcm.c line 170
extern struct dsd2pcm_ctx_s * dsd2pcm_clone(struct dsd2pcm_ctx_s *ptr);
// dsd2pcm_destroy
// file ./dsd2pcm/dsd2pcm.h line 63
extern void dsd2pcm_destroy(struct dsd2pcm_ctx_s *ptr);
// dsd2pcm_init
// file ./dsd2pcm/dsd2pcm.h line 57
extern struct dsd2pcm_ctx_s * dsd2pcm_init(void);
// dsd2pcm_precalc
// file ./dsd2pcm/dsd2pcm.h line 98
extern void dsd2pcm_precalc(void);
// dsd2pcm_reset
// file ./dsd2pcm/dsd2pcm.h line 74
extern void dsd2pcm_reset(struct dsd2pcm_ctx_s *ptr);
// dsd2pcm_translate
// file ./dsd2pcm/dsd2pcm.h line 87
extern void dsd2pcm_translate(struct dsd2pcm_ctx_s *ptr, unsigned long int samples, const unsigned char *src, signed long int src_stride, signed int lsbf, float *dst, signed long int dst_stride);
// dsd_close
// file dsd.c line 589
static void dsd_close(void);
// dsd_decode
// file dsd.c line 492
static enum anonymous_23 dsd_decode(void);
// dsd_open
// file dsd.c line 573
static void dsd_open(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness);
// error_cb
// file flac.c line 199
static void error_cb(const struct anonymous_43 *decoder, enum anonymous_68 status, void *client_data);
// eventfd
// file /usr/include/x86_64-linux-gnu/sys/eventfd.h line 34
extern signed int eventfd(unsigned int, signed int);
// eventfd_read
// file /usr/include/x86_64-linux-gnu/sys/eventfd.h line 37
extern signed int eventfd_read(signed int, unsigned long int *);
// eventfd_write
// file /usr/include/x86_64-linux-gnu/sys/eventfd.h line 40
extern signed int eventfd_write(signed int, unsigned long int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// faad_close
// file faad.c line 573
static void faad_close(void);
// faad_decode
// file faad.c line 313
static enum anonymous_23 faad_decode(void);
// faad_open
// file faad.c line 537
static void faad_open(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// ff_close
// file ffmpeg.c line 569
static void ff_close(void);
// ff_decode
// file ffmpeg.c line 251
static enum anonymous_23 ff_decode(void);
// ff_open_alac
// file ffmpeg.c line 555
static void ff_open_alac(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness);
// ff_open_wma
// file ffmpeg.c line 539
static void ff_open_wma(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// flac_close
// file flac.c line 212
static void flac_close(void);
// flac_decode
// file flac.c line 217
static enum anonymous_23 flac_decode(void);
// flac_open
// file flac.c line 203
static void flac_open(unsigned char sample_size, unsigned char sample_rate, unsigned char channels, unsigned char endianness);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// freopen
// file /usr/include/stdio.h line 278
extern struct _IO_FILE * freopen(const char *, const char *, struct _IO_FILE *);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// gain
// file squeezelite.h line 621
inline signed int gain(signed int gain, signed int sample);
// get_mac
// file squeezelite.h line 377
void get_mac(unsigned char *mac);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettime_ms
// file squeezelite.h line 376
unsigned int gettime_ms(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inet_ntoa
// file /usr/include/arpa/inet.h line 53
extern char * inet_ntoa(struct in_addr);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// ir_close
// file squeezelite.h line 663
void ir_close(void);
// ir_cmd_map
// file ir.c line 101
static unsigned int ir_cmd_map(const char *c);
// ir_init
// file squeezelite.h line 662
void ir_init(enum anonymous_8 level, char *lircrc);
// ir_key_map
// file ir.c line 111
static unsigned int ir_key_map(const char *c, const char *r);
// ir_thread
// file ir.c line 125
static void * ir_thread();
// is_flac_dop
// file squeezelite.h line 636
_Bool is_flac_dop(unsigned int *lptr, unsigned int *rptr, unsigned int frames);
// license
// file main.c line 164
static void license(void);
// lirc_code2char
// file /usr/include/lirc/lirc_client.h line 89
signed int lirc_code2char(struct lirc_config *, char *, char **);
// lirc_deinit
// file /usr/include/lirc/lirc_client.h line 78
signed int lirc_deinit(void);
// lirc_freeconfig
// file /usr/include/lirc/lirc_client.h line 81
void lirc_freeconfig(struct lirc_config *);
// lirc_init
// file /usr/include/lirc/lirc_client.h line 77
signed int lirc_init(char *, signed int);
// lirc_nextcode
// file /usr/include/lirc/lirc_client.h line 88
signed int lirc_nextcode(char **);
// lirc_readconfig
// file /usr/include/lirc/lirc_client.h line 80
signed int lirc_readconfig(char *, struct lirc_config **, signed int (*)(char *));
// list_devices
// file squeezelite.h line 605
void list_devices(void);
// load_faad
// file faad.c line 586
static _Bool load_faad();
// load_ff
// file ffmpeg.c line 578
static _Bool load_ff();
// load_flac
// file flac.c line 234
static _Bool load_flac();
// load_mad
// file mad.c line 358
static _Bool load_mad();
// load_mpg
// file mpg.c line 215
static _Bool load_mpg();
// load_soxr
// file resample.c line 243
static _Bool load_soxr(void);
// load_vorbis
// file vorbis.c line 273
static _Bool load_vorbis();
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// logprint
// file squeezelite.h line 364
void logprint(const char *fmt, ...);
// logtime
// file squeezelite.h line 363
const char * logtime(void);
// mad_close
// file mad.c line 350
static void mad_close(void);
// mad_decode
// file mad.c line 163
static enum anonymous_23 mad_decode(void);
// mad_frame_decode
// file /usr/include/mad.h line 858
signed int mad_frame_decode(struct mad_frame *, struct mad_stream *);
// mad_frame_finish
// file /usr/include/mad.h line 856
void mad_frame_finish(struct mad_frame *);
// mad_frame_init
// file /usr/include/mad.h line 855
void mad_frame_init(struct mad_frame *);
// mad_open
// file mad.c line 335
static void mad_open(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness);
// mad_stream_buffer
// file /usr/include/mad.h line 757
void mad_stream_buffer(struct mad_stream *, const unsigned char *, unsigned long int);
// mad_stream_errorstr
// file /usr/include/mad.h line 763
const char * mad_stream_errorstr(struct mad_stream *);
// mad_stream_finish
// file /usr/include/mad.h line 752
void mad_stream_finish(struct mad_stream *);
// mad_stream_init
// file /usr/include/mad.h line 751
void mad_stream_init(struct mad_stream *);
// mad_synth_frame
// file /usr/include/mad.h line 909
void mad_synth_frame(struct mad_synth *, struct mad_frame *);
// mad_synth_init
// file /usr/include/mad.h line 903
void mad_synth_init(struct mad_synth *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// mp4_desc_length
// file faad.c line 94
unsigned int mp4_desc_length(unsigned char **buf);
// mpg123_decode
// file /usr/include/mpg123.h line 548
signed int mpg123_decode(struct mpg123_handle_struct *, const unsigned char *, unsigned long int, unsigned char *, unsigned long int, unsigned long int *);
// mpg123_delete
// file /usr/include/mpg123.h line 132
void mpg123_delete(struct mpg123_handle_struct *);
// mpg123_feature
// file /usr/include/mpg123.h line 224
signed int mpg123_feature(const enum mpg123_feature_set);
// mpg123_format
// file /usr/include/mpg123.h line 461
signed int mpg123_format(struct mpg123_handle_struct *, signed long int, signed int, signed int);
// mpg123_format_none
// file /usr/include/mpg123.h line 447
signed int mpg123_format_none(struct mpg123_handle_struct *);
// mpg123_getformat
// file /usr/include/mpg123.h line 472
signed int mpg123_getformat(struct mpg123_handle_struct *, signed long int *, signed int *, signed int *);
// mpg123_init
// file /usr/include/mpg123.h line 117
signed int mpg123_init(void);
// mpg123_new
// file /usr/include/mpg123.h line 129
struct mpg123_handle_struct * mpg123_new(const char *, signed int *);
// mpg123_open_feed
// file /usr/include/mpg123.h line 511
signed int mpg123_open_feed(struct mpg123_handle_struct *);
// mpg123_plain_strerror
// file /usr/include/mpg123.h line 314
const char * mpg123_plain_strerror(signed int);
// mpg123_rates
// file /usr/include/mpg123.h line 430
void mpg123_rates(const signed long int **, unsigned long int *);
// mpg_close
// file mpg.c line 210
static void mpg_close(void);
// mpg_decode
// file mpg.c line 84
static enum anonymous_23 mpg_decode(void);
// mpg_open
// file mpg.c line 181
static void mpg_open(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness);
// next_param
// file squeezelite.h line 375
char * next_param(char *src, char c);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// output_close_common
// file output.c line 414
void output_close_common(void);
// output_close_pa
// file squeezelite.h line 609
void output_close_pa(void);
// output_close_stdout
// file squeezelite.h line 615
void output_close_stdout(void);
// output_flush
// file squeezelite.h line 587
void output_flush(void);
// output_init_common
// file output.c line 340
void output_init_common(enum anonymous_8 level, const char *device, unsigned int output_buf_size, unsigned int *rates, unsigned int idle);
// output_init_pa
// file squeezelite.h line 608
void output_init_pa(enum anonymous_8 level, const char *device, unsigned int output_buf_size, char *params, unsigned int *rates, unsigned int rate_delay, unsigned int idle);
// output_init_stdout
// file squeezelite.h line 614
void output_init_stdout(enum anonymous_8 level, unsigned int output_buf_size, char *params, unsigned int *rates, unsigned int rate_delay);
// output_thread
// file output_stdout.c line 81
static void * output_thread();
// output_vis_init
// file squeezelite.h line 627
void output_vis_init(enum anonymous_8 level, unsigned char *mac);
// ov_clear
// file /usr/include/vorbis/vorbisfile.h line 149
extern signed int ov_clear(struct OggVorbis_File *);
// ov_info
// file /usr/include/vorbis/vorbisfile.h line 186
extern struct vorbis_info * ov_info(struct OggVorbis_File *, signed int);
// ov_open_callbacks
// file /usr/include/vorbis/vorbisfile.h line 152
extern signed int ov_open_callbacks(void *, struct OggVorbis_File *, const char *, signed long int, struct anonymous_75);
// ov_read
// file /usr/include/vorbis/vorbisfile.h line 194
extern signed long int ov_read(struct OggVorbis_File *, char *, signed int, signed int, signed int, signed int, signed int *);
// ov_read_tremor
// file vorbis.c line 79
extern signed int ov_read_tremor();
// pa_callback
// file output_pa.c line 342
static signed int pa_callback(const void *pa_input, void *pa_output, unsigned long int pa_frames_wanted, const struct PaStreamCallbackTimeInfo *time_info, unsigned long int statusFlags, void *userData);
// pa_device_id
// file output_pa.c line 83
static signed int pa_device_id(const char *device);
// pa_monitor
// file output_pa.c line 160
static void * pa_monitor();
// pa_stream_finished
// file output_pa.c line 147
static void pa_stream_finished(void *userdata);
// packN
// file squeezelite.h line 383
void packN(unsigned int *dest, unsigned int val);
// packn
// file squeezelite.h line 384
void packn(unsigned short int *dest, unsigned short int val);
// pcm_close
// file pcm.c line 369
static void pcm_close(void);
// pcm_decode
// file pcm.c line 161
static enum anonymous_23 pcm_decode(void);
// pcm_open
// file pcm.c line 358
static void pcm_open(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process
// file slimproto.c line 489
static void process(unsigned char *pack, signed int len);
// process_aude
// file slimproto.c line 392
static void process_aude(unsigned char *pkt, signed int len);
// process_audg
// file slimproto.c line 408
static void process_audg(unsigned char *pkt, signed int len);
// process_codc
// file slimproto.c line 385
static void process_codc(unsigned char *pkt, signed int len);
// process_cont
// file slimproto.c line 367
static void process_cont(unsigned char *pkt, signed int len);
// process_drain
// file squeezelite.h line 501
void process_drain(void);
// process_flush
// file squeezelite.h line 502
void process_flush(void);
// process_init
// file squeezelite.h line 504
void process_init(char *opt);
// process_newstream
// file squeezelite.h line 503
unsigned int process_newstream(_Bool *direct, unsigned int raw_sample_rate, unsigned int *supported_rates);
// process_samples
// file squeezelite.h line 500
void process_samples(void);
// process_serv
// file slimproto.c line 451
static void process_serv(unsigned char *pkt, signed int len);
// process_setd
// file slimproto.c line 418
static void process_setd(unsigned char *pkt, signed int len);
// process_strm
// file slimproto.c line 253
static void process_strm(unsigned char *pkt, signed int len);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 377
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_6 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_6 *, const union anonymous_7 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_6 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_6 *);
// pthread_mutexattr_destroy
// file /usr/include/pthread.h line 812
extern signed int pthread_mutexattr_destroy(union anonymous_7 *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 808
extern signed int pthread_mutexattr_init(union anonymous_7 *);
// pthread_mutexattr_setprotocol
// file /usr/include/pthread.h line 847
extern signed int pthread_mutexattr_setprotocol(union anonymous_7 *, signed int);
// pthread_rwlock_init
// file /usr/include/pthread.h line 890
extern signed int pthread_rwlock_init(union anonymous_18 *, const union anonymous_21 *);
// pthread_rwlock_timedwrlock
// file /usr/include/pthread.h line 923
extern signed int pthread_rwlock_timedwrlock(union anonymous_18 *, struct timespec *);
// pthread_rwlock_trywrlock
// file /usr/include/pthread.h line 918
extern signed int pthread_rwlock_trywrlock(union anonymous_18 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 929
extern signed int pthread_rwlock_unlock(union anonymous_18 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 914
extern signed int pthread_rwlock_wrlock(union anonymous_18 *);
// pthread_rwlockattr_destroy
// file /usr/include/pthread.h line 940
extern signed int pthread_rwlockattr_destroy(union anonymous_21 *);
// pthread_rwlockattr_init
// file /usr/include/pthread.h line 936
extern signed int pthread_rwlockattr_init(union anonymous_21 *);
// pthread_rwlockattr_setpshared
// file /usr/include/pthread.h line 950
extern signed int pthread_rwlockattr_setpshared(union anonymous_21 *, signed int);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_cb
// file flac.c line 86
static enum anonymous_64 read_cb(const struct anonymous_43 *decoder, unsigned char *buffer, unsigned long int *want, void *client_data);
// read_mp4_header
// file faad.c line 110
static signed int read_mp4_header(unsigned long int *samplerate_p, unsigned char *channels_p);
// realpath
// file /usr/include/stdlib.h line 733
extern char * realpath(const char *, char *);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, struct sockaddr *, unsigned int *);
// register_dsd
// file squeezelite.h line 651
struct codec * register_dsd(void);
// register_faad
// file squeezelite.h line 650
struct codec * register_faad(void);
// register_ff
// file squeezelite.h line 652
struct codec * register_ff(const char *codec);
// register_flac
// file squeezelite.h line 645
struct codec * register_flac(void);
// register_mad
// file squeezelite.h line 647
struct codec * register_mad(void);
// register_mpg
// file squeezelite.h line 648
struct codec * register_mpg(void);
// register_pcm
// file squeezelite.h line 646
struct codec * register_pcm(void);
// register_vorbis
// file squeezelite.h line 649
struct codec * register_vorbis(void);
// resample_drain
// file squeezelite.h line 510
_Bool resample_drain(struct processstate *process);
// resample_flush
// file squeezelite.h line 512
void resample_flush(void);
// resample_init
// file squeezelite.h line 513
_Bool resample_init(char *opt);
// resample_newstream
// file squeezelite.h line 511
_Bool resample_newstream(struct processstate *process, unsigned int raw_sample_rate, unsigned int *supported_rates);
// resample_samples
// file squeezelite.h line 509
void resample_samples(struct processstate *process);
// scale
// file mad.c line 90
static inline unsigned int scale(signed int sample);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_12 *, struct anonymous_12 *, struct anonymous_12 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendDSCO
// file slimproto.c line 182
static void sendDSCO(enum anonymous_0 disconnect);
// sendHELO
// file slimproto.c line 110
static void sendHELO(_Bool reconnect, const char *fixed_cap, const char *var_cap, unsigned char *mac);
// sendIR
// file slimproto.c line 237
void sendIR(unsigned int code, unsigned int ts);
// sendMETA
// file slimproto.c line 208
static void sendMETA(const char *meta, unsigned long int len);
// sendRESP
// file slimproto.c line 195
static void sendRESP(const char *header, unsigned long int len);
// sendSETDName
// file slimproto.c line 221
static void sendSETDName(const char *name);
// sendSTAT
// file slimproto.c line 134
static void sendSTAT(const char *event, unsigned int server_timestamp);
// send_header
// file stream.c line 39
static void send_header(void);
// send_packet
// file slimproto.c line 89
void send_packet(unsigned char *packet, unsigned long int len);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, struct sockaddr *, unsigned int);
// server_addr
// file squeezelite.h line 380
void server_addr(char *server, unsigned int *ip_ptr, unsigned int *port_ptr);
// set_nonblock
// file squeezelite.h line 378
void set_nonblock(signed int s);
// set_readwake_handles
// file squeezelite.h line 381
void set_readwake_handles(struct pollfd *handles, signed int s, signed int e);
// set_volume
// file squeezelite.h line 606
void set_volume(unsigned int left, unsigned int right);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shm_open
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 144
extern signed int shm_open(const char *, signed int, unsigned int);
// sighandler
// file main.c line 183
static void sighandler(signed int signum);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// slimproto
// file squeezelite.h line 429
void slimproto(enum anonymous_8 level, char *server, unsigned char *mac, const char *name, const char *namefile, const char *modelname);
// slimproto_run
// file slimproto.c line 504
static void slimproto_run();
// slimproto_stop
// file squeezelite.h line 430
void slimproto_stop(void);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// soxr_create
// file /usr/include/soxr.h line 101
struct soxr * soxr_create(double, double, unsigned int, const char **, const struct soxr_io_spec *, const struct soxr_quality_spec *, const struct soxr_runtime_spec *);
// soxr_delete
// file /usr/include/soxr.h line 179
void soxr_delete(struct soxr *);
// soxr_io_spec
// file /usr/include/soxr.h line 317
struct soxr_io_spec soxr_io_spec(enum anonymous_10, enum anonymous_10);
// soxr_num_clips
// file /usr/include/soxr.h line 174
unsigned long int * soxr_num_clips(struct soxr *);
// soxr_process
// file /usr/include/soxr.h line 120
const char * soxr_process(struct soxr *, const void *, unsigned long int, unsigned long int *, void *, unsigned long int, unsigned long int *);
// soxr_quality_spec
// file /usr/include/soxr.h line 283
struct soxr_quality_spec soxr_quality_spec(unsigned long int, unsigned long int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// stream_close
// file squeezelite.h line 454
void stream_close(void);
// stream_disconnect
// file squeezelite.h line 457
_Bool stream_disconnect(void);
// stream_file
// file squeezelite.h line 455
void stream_file(const char *header, unsigned long int header_len, unsigned int threshold);
// stream_init
// file squeezelite.h line 453
void stream_init(enum anonymous_8 level, unsigned int stream_buf_size);
// stream_sock
// file squeezelite.h line 456
void stream_sock(unsigned int ip, unsigned short int port, const char *header, unsigned long int header_len, unsigned int threshold, _Bool cont_wait);
// stream_thread
// file stream.c line 77
static void * stream_thread();
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// test_open
// file squeezelite.h line 607
_Bool test_open(const char *device, unsigned int *rates);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// to_gain
// file squeezelite.h line 622
inline signed int to_gain(float f);
// touch_memory
// file squeezelite.h line 401
void touch_memory(unsigned char *buf, unsigned long int size);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unpack32le
// file dsd.c line 93
static unsigned int unpack32le(const unsigned char *p);
// unpack64be
// file dsd.c line 81
static unsigned long int unpack64be(const unsigned char *p);
// unpack64le
// file dsd.c line 87
static unsigned long int unpack64le(const unsigned char *p);
// unpackN
// file squeezelite.h line 385
unsigned int unpackN(unsigned int *src);
// unpackn
// file utils.c line 305
unsigned short int unpackn(unsigned short int *src);
// update_dop
// file squeezelite.h line 637
void update_dop(unsigned int *ptr, unsigned int frames, _Bool invert);
// usage
// file main.c line 42
static void usage(const char *argv0);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vis_stop
// file squeezelite.h line 628
void vis_stop(void);
// vorbis_close
// file vorbis.c line 264
static void vorbis_close(void);
// vorbis_decode
// file vorbis.c line 103
static enum anonymous_23 vorbis_decode(void);
// vorbis_open
// file vorbis.c line 252
static void vorbis_open(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness);
// wait_readwake
// file squeezelite.h line 382
enum anonymous_9 wait_readwake(struct pollfd *handles, signed int timeout);
// wake_controller
// file slimproto.c line 729
void wake_controller(void);
// write_cb
// file flac.c line 104
static enum anonymous_42 write_cb(const struct anonymous_43 *decoder, const struct anonymous_45 *frame, const signed int * const *buffer, void *client_data);

struct anonymous_24
{
  // cmd
  char *cmd;
  // code
  unsigned int code;
};

struct anonymous_25
{
  // lirc
  char *lirc;
  // code
  unsigned int code;
  // repeat
  _Bool repeat;
};

struct anonymous_43
{
  // protected_
  struct FLAC__StreamDecoderProtected *protected_;
  // private_
  struct FLAC__StreamDecoderPrivate *private_;
};

struct anonymous_69
{
  // parameters
  unsigned int *parameters;
  // raw_bits
  unsigned int *raw_bits;
  // capacity_by_order
  unsigned int capacity_by_order;
};

struct anonymous_75
{
  // read_func
  unsigned long int (*read_func)(void *, unsigned long int, unsigned long int, void *);
  // seek_func
  signed int (*seek_func)(void *, signed long int, signed int);
  // close_func
  signed int (*close_func)(void *);
  // tell_func
  signed long int (*tell_func)(void *);
};

struct anonymous_74
{
  // body_data
  unsigned char *body_data;
  // body_storage
  signed long int body_storage;
  // body_fill
  signed long int body_fill;
  // body_returned
  signed long int body_returned;
  // lacing_vals
  signed int *lacing_vals;
  // granule_vals
  signed long int *granule_vals;
  // lacing_storage
  signed long int lacing_storage;
  // lacing_fill
  signed long int lacing_fill;
  // lacing_packet
  signed long int lacing_packet;
  // lacing_returned
  signed long int lacing_returned;
  // header
  unsigned char header[282l];
  // header_fill
  signed int header_fill;
  // e_o_s
  signed int e_o_s;
  // b_o_s
  signed int b_o_s;
  // serialno
  signed long int serialno;
  // pageno
  signed long int pageno;
  // packetno
  signed long int packetno;
  // granulepos
  signed long int granulepos;
};

struct anonymous_59
{
  // data
  unsigned char *data;
};

struct anonymous_73
{
  // data
  unsigned char *data;
  // storage
  signed int storage;
  // fill
  signed int fill;
  // returned
  signed int returned;
  // unsynced
  signed int unsynced;
  // headerbytes
  signed int headerbytes;
  // bodybytes
  signed int bodybytes;
};

struct anonymous_29
{
  // data
  const signed int *data;
};

struct anonymous_56
{
  // media_catalog_number
  char media_catalog_number[129l];
  // lead_in
  unsigned long int lead_in;
  // is_cd
  signed int is_cd;
  // num_tracks
  unsigned int num_tracks;
  // tracks
  struct anonymous_55 *tracks;
};

struct anonymous_12
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_49
{
  // id
  unsigned char id[4l];
  // data
  unsigned char *data;
};

struct anonymous_17
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

struct anonymous_48
{
  // dummy
  signed int dummy;
};

struct anonymous_28
{
  // value
  signed int value;
};

struct anonymous
{
  // endbyte
  signed long int endbyte;
  // endbit
  signed int endbit;
  // buffer
  unsigned char *buffer;
  // ptr
  unsigned char *ptr;
  // storage
  signed long int storage;
};

struct anonymous_19
{
  // last_dts
  signed long int last_dts;
  // duration_gcd
  signed long int duration_gcd;
  // duration_count
  signed int duration_count;
  // rfps_duration_sum
  signed long int rfps_duration_sum;
  // duration_error
  double (*duration_error)[2l][399l];
  // codec_info_duration
  signed long int codec_info_duration;
  // codec_info_duration_fields
  signed long int codec_info_duration_fields;
  // found_decoder
  signed int found_decoder;
  // last_duration
  signed long int last_duration;
  // fps_first_dts
  signed long int fps_first_dts;
  // fps_first_dts_idx
  signed int fps_first_dts_idx;
  // fps_last_dts
  signed long int fps_last_dts;
  // fps_last_dts_idx
  signed int fps_last_dts_idx;
};

struct anonymous_72
{
  // seconds
  signed long int seconds;
  // fraction
  unsigned long int fraction;
};

struct anonymous_70
{
  // order
  unsigned int order;
  // contents
  const struct anonymous_69 *contents;
};

union anonymous_31
{
  // partitioned_rice
  struct anonymous_70 partitioned_rice;
};

struct anonymous_32
{
  // type
  enum anonymous_30 type;
  // data
  union anonymous_31 data;
};

struct anonymous_47
{
  // min_blocksize
  unsigned int min_blocksize;
  // max_blocksize
  unsigned int max_blocksize;
  // min_framesize
  unsigned int min_framesize;
  // max_framesize
  unsigned int max_framesize;
  // sample_rate
  unsigned int sample_rate;
  // channels
  unsigned int channels;
  // bits_per_sample
  unsigned int bits_per_sample;
  // total_samples
  unsigned long int total_samples;
  // md5sum
  unsigned char md5sum[16l];
};

struct anonymous_51
{
  // num_points
  unsigned int num_points;
  // points
  struct anonymous_50 *points;
};

struct anonymous_52
{
  // length
  unsigned int length;
  // entry
  unsigned char *entry;
};

struct anonymous_53
{
  // vendor_string
  struct anonymous_52 vendor_string;
  // num_comments
  unsigned int num_comments;
  // comments
  struct anonymous_52 *comments;
};

struct anonymous_58
{
  // type
  enum anonymous_57 type;
  // mime_type
  char *mime_type;
  // description
  unsigned char *description;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // depth
  unsigned int depth;
  // colors
  unsigned int colors;
  // data_length
  unsigned int data_length;
  // data
  unsigned char *data;
};

union anonymous_60
{
  // stream_info
  struct anonymous_47 stream_info;
  // padding
  struct anonymous_48 padding;
  // application
  struct anonymous_49 application;
  // seek_table
  struct anonymous_51 seek_table;
  // vorbis_comment
  struct anonymous_53 vorbis_comment;
  // cue_sheet
  struct anonymous_56 cue_sheet;
  // picture
  struct anonymous_58 picture;
  // unknown
  struct anonymous_59 unknown;
};

struct anonymous_61
{
  // type
  enum anonymous_46 type;
  // is_last
  signed int is_last;
  // length
  unsigned int length;
  // data
  union anonymous_60 data;
};

struct anonymous_33
{
  // entropy_coding_method
  struct anonymous_32 entropy_coding_method;
  // order
  unsigned int order;
  // warmup
  signed int warmup[4l];
  // residual
  const signed int *residual;
};

struct anonymous_34
{
  // entropy_coding_method
  struct anonymous_32 entropy_coding_method;
  // order
  unsigned int order;
  // qlp_coeff_precision
  unsigned int qlp_coeff_precision;
  // quantization_level
  signed int quantization_level;
  // qlp_coeff
  signed int qlp_coeff[32l];
  // warmup
  signed int warmup[32l];
  // residual
  const signed int *residual;
};

union anonymous_35
{
  // constant
  struct anonymous_28 constant;
  // fixed
  struct anonymous_33 fixed;
  // lpc
  struct anonymous_34 lpc;
  // verbatim
  struct anonymous_29 verbatim;
};

struct anonymous_37
{
  // type
  enum anonymous_36 type;
  // data
  union anonymous_35 data;
  // wasted_bits
  unsigned int wasted_bits;
};

union anonymous_40
{
  // frame_number
  unsigned int frame_number;
  // sample_number
  unsigned long int sample_number;
};

struct anonymous_41
{
  // blocksize
  unsigned int blocksize;
  // sample_rate
  unsigned int sample_rate;
  // channels
  unsigned int channels;
  // channel_assignment
  enum anonymous_38 channel_assignment;
  // bits_per_sample
  unsigned int bits_per_sample;
  // number_type
  enum anonymous_39 number_type;
  // number
  union anonymous_40 number;
  // crc
  unsigned char crc;
};

struct anonymous_44
{
  // crc
  unsigned short int crc;
};

struct anonymous_45
{
  // header
  struct anonymous_41 header;
  // subframes
  struct anonymous_37 subframes[8l];
  // footer
  struct anonymous_44 footer;
};

struct anonymous_11
{
  // rate
  unsigned int rate;
  // stream
  void *stream;
};

struct anonymous_27
{
  // updated
  unsigned int updated;
  // stream_start
  unsigned int stream_start;
  // stream_full
  unsigned int stream_full;
  // stream_size
  unsigned int stream_size;
  // stream_bytes
  unsigned long int stream_bytes;
  // output_full
  unsigned int output_full;
  // output_size
  unsigned int output_size;
  // frames_played
  unsigned int frames_played;
  // device_frames
  unsigned int device_frames;
  // current_sample_rate
  unsigned int current_sample_rate;
  // last
  unsigned int last;
  // stream_state
  enum anonymous_14 stream_state;
};

struct anonymous_55
{
  // offset
  unsigned long int offset;
  // number
  unsigned char number;
  // isrc
  char isrc[13l];
  // type
  unsigned int type : 1;
  // pre_emphasis
  unsigned int pre_emphasis : 1;
  // num_indices
  unsigned char num_indices;
  // indices
  struct anonymous_54 *indices;
};

struct anonymous_54
{
  // offset
  unsigned long int offset;
  // number
  unsigned char number;
};

struct anonymous_50
{
  // sample_number
  unsigned long int sample_number;
  // stream_offset
  unsigned long int stream_offset;
  // frame_samples
  unsigned int frame_samples;
};

union anonymous_16
{
  // ifcu_buf
  char *ifcu_buf;
  // ifcu_req
  struct ifreq *ifcu_req;
};

union anonymous_13
{
  // ifrn_name
  char ifrn_name[16l];
};

union anonymous_7
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_21
{
  // __size
  char __size[8l];
  // __align
  signed long int __align;
};

union anonymous_18
{
  // __data
  struct anonymous_17 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_6
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct ifmap
{
  // mem_start
  unsigned long int mem_start;
  // mem_end
  unsigned long int mem_end;
  // base_addr
  unsigned short int base_addr;
  // irq
  unsigned char irq;
  // dma
  unsigned char dma;
  // port
  unsigned char port;
};

union anonymous_15
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  char *ifru_data;
};

union anonymous_2
{
  // pause_frames
  unsigned int pause_frames;
  // skip_frames
  unsigned int skip_frames;
  // start_at
  unsigned int start_at;
};

struct AVBufferRef
{
  // buffer
  struct AVBuffer *buffer;
  // data
  unsigned char *data;
  // size
  signed int size;
};

struct AVRational
{
  // num
  signed int num;
  // den
  signed int den;
};

struct AVChapter
{
  // id
  signed int id;
  // time_base
  struct AVRational time_base;
  // start
  signed long int start;
  // end
  signed long int end;
  // metadata
  struct AVDictionary *metadata;
};

struct AVClass
{
  // class_name
  const char *class_name;
  // item_name
  const char * (*item_name)(void *);
  // option
  const struct AVOption *option;
  // version
  signed int version;
  // log_level_offset_offset
  signed int log_level_offset_offset;
  // parent_log_context_offset
  signed int parent_log_context_offset;
  // child_next
  void * (*child_next)(void *, void *);
  // child_class_next
  struct AVClass * (*child_class_next)(struct AVClass *);
  // category
  enum anonymous_26 category;
  // get_category
  enum anonymous_26 (*get_category)(void *);
  // query_ranges
  signed int (*query_ranges)(struct AVOptionRanges **, void *, const char *, signed int);
};

struct AVCodec
{
  // name
  const char *name;
  // long_name
  const char *long_name;
  // type
  enum AVMediaType type;
  // id
  enum AVCodecID id;
  // capabilities
  signed int capabilities;
  // supported_framerates
  const struct AVRational *supported_framerates;
  // pix_fmts
  const enum AVPixelFormat *pix_fmts;
  // supported_samplerates
  const signed int *supported_samplerates;
  // sample_fmts
  const enum AVSampleFormat *sample_fmts;
  // channel_layouts
  const unsigned long int *channel_layouts;
  // max_lowres
  unsigned char max_lowres;
  // priv_class
  const struct AVClass *priv_class;
  // profiles
  const struct AVProfile *profiles;
  // priv_data_size
  signed int priv_data_size;
  // next
  struct AVCodec *next;
  // init_thread_copy
  signed int (*init_thread_copy)(struct AVCodecContext *);
  // update_thread_context
  signed int (*update_thread_context)(struct AVCodecContext *, const struct AVCodecContext *);
  // defaults
  const struct AVCodecDefault *defaults;
  // init_static_data
  void (*init_static_data)(struct AVCodec *);
  // init
  signed int (*init)(struct AVCodecContext *);
  // encode_sub
  signed int (*encode_sub)(struct AVCodecContext *, unsigned char *, signed int, struct AVSubtitle *);
  // encode2
  signed int (*encode2)(struct AVCodecContext *, struct AVPacket *, const struct AVFrame *, signed int *);
  // decode
  signed int (*decode)(struct AVCodecContext *, void *, signed int *, struct AVPacket *);
  // close
  signed int (*close)(struct AVCodecContext *);
  // flush
  void (*flush)(struct AVCodecContext *);
  // caps_internal
  signed int caps_internal;
};

struct AVCodecContext
{
  // av_class
  const struct AVClass *av_class;
  // log_level_offset
  signed int log_level_offset;
  // codec_type
  enum AVMediaType codec_type;
  // codec
  struct AVCodec *codec;
  // codec_name
  char codec_name[32l];
  // codec_id
  enum AVCodecID codec_id;
  // codec_tag
  unsigned int codec_tag;
  // stream_codec_tag
  unsigned int stream_codec_tag;
  // priv_data
  void *priv_data;
  // internal
  struct AVCodecInternal *internal;
  // opaque
  void *opaque;
  // bit_rate
  signed int bit_rate;
  // bit_rate_tolerance
  signed int bit_rate_tolerance;
  // global_quality
  signed int global_quality;
  // compression_level
  signed int compression_level;
  // flags
  signed int flags;
  // flags2
  signed int flags2;
  // extradata
  unsigned char *extradata;
  // extradata_size
  signed int extradata_size;
  // time_base
  struct AVRational time_base;
  // ticks_per_frame
  signed int ticks_per_frame;
  // delay
  signed int delay;
  // width
  signed int width;
  // height
  signed int height;
  // coded_width
  signed int coded_width;
  // coded_height
  signed int coded_height;
  // gop_size
  signed int gop_size;
  // pix_fmt
  enum AVPixelFormat pix_fmt;
  // me_method
  signed int me_method;
  // draw_horiz_band
  void (*draw_horiz_band)(struct AVCodecContext *, const struct AVFrame *, signed int *, signed int, signed int, signed int);
  // get_format
  enum AVPixelFormat (*get_format)(struct AVCodecContext *, const enum AVPixelFormat *);
  // max_b_frames
  signed int max_b_frames;
  // b_quant_factor
  float b_quant_factor;
  // rc_strategy
  signed int rc_strategy;
  // b_frame_strategy
  signed int b_frame_strategy;
  // b_quant_offset
  float b_quant_offset;
  // has_b_frames
  signed int has_b_frames;
  // mpeg_quant
  signed int mpeg_quant;
  // i_quant_factor
  float i_quant_factor;
  // i_quant_offset
  float i_quant_offset;
  // lumi_masking
  float lumi_masking;
  // temporal_cplx_masking
  float temporal_cplx_masking;
  // spatial_cplx_masking
  float spatial_cplx_masking;
  // p_masking
  float p_masking;
  // dark_masking
  float dark_masking;
  // slice_count
  signed int slice_count;
  // prediction_method
  signed int prediction_method;
  // slice_offset
  signed int *slice_offset;
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // me_cmp
  signed int me_cmp;
  // me_sub_cmp
  signed int me_sub_cmp;
  // mb_cmp
  signed int mb_cmp;
  // ildct_cmp
  signed int ildct_cmp;
  // dia_size
  signed int dia_size;
  // last_predictor_count
  signed int last_predictor_count;
  // pre_me
  signed int pre_me;
  // me_pre_cmp
  signed int me_pre_cmp;
  // pre_dia_size
  signed int pre_dia_size;
  // me_subpel_quality
  signed int me_subpel_quality;
  // dtg_active_format
  signed int dtg_active_format;
  // me_range
  signed int me_range;
  // intra_quant_bias
  signed int intra_quant_bias;
  // inter_quant_bias
  signed int inter_quant_bias;
  // slice_flags
  signed int slice_flags;
  // xvmc_acceleration
  signed int xvmc_acceleration;
  // mb_decision
  signed int mb_decision;
  // intra_matrix
  unsigned short int *intra_matrix;
  // inter_matrix
  unsigned short int *inter_matrix;
  // scenechange_threshold
  signed int scenechange_threshold;
  // noise_reduction
  signed int noise_reduction;
  // me_threshold
  signed int me_threshold;
  // mb_threshold
  signed int mb_threshold;
  // intra_dc_precision
  signed int intra_dc_precision;
  // skip_top
  signed int skip_top;
  // skip_bottom
  signed int skip_bottom;
  // border_masking
  float border_masking;
  // mb_lmin
  signed int mb_lmin;
  // mb_lmax
  signed int mb_lmax;
  // me_penalty_compensation
  signed int me_penalty_compensation;
  // bidir_refine
  signed int bidir_refine;
  // brd_scale
  signed int brd_scale;
  // keyint_min
  signed int keyint_min;
  // refs
  signed int refs;
  // chromaoffset
  signed int chromaoffset;
  // scenechange_factor
  signed int scenechange_factor;
  // mv0_threshold
  signed int mv0_threshold;
  // b_sensitivity
  signed int b_sensitivity;
  // color_primaries
  enum AVColorPrimaries color_primaries;
  // color_trc
  enum AVColorTransferCharacteristic color_trc;
  // colorspace
  enum AVColorSpace colorspace;
  // color_range
  enum AVColorRange color_range;
  // chroma_sample_location
  enum AVChromaLocation chroma_sample_location;
  // slices
  signed int slices;
  // field_order
  enum AVFieldOrder field_order;
  // sample_rate
  signed int sample_rate;
  // channels
  signed int channels;
  // sample_fmt
  enum AVSampleFormat sample_fmt;
  // frame_size
  signed int frame_size;
  // frame_number
  signed int frame_number;
  // block_align
  signed int block_align;
  // cutoff
  signed int cutoff;
  // request_channels
  signed int request_channels;
  // channel_layout
  unsigned long int channel_layout;
  // request_channel_layout
  unsigned long int request_channel_layout;
  // audio_service_type
  enum AVAudioServiceType audio_service_type;
  // request_sample_fmt
  enum AVSampleFormat request_sample_fmt;
  // get_buffer
  signed int (*get_buffer)(struct AVCodecContext *, struct AVFrame *);
  // release_buffer
  void (*release_buffer)(struct AVCodecContext *, struct AVFrame *);
  // reget_buffer
  signed int (*reget_buffer)(struct AVCodecContext *, struct AVFrame *);
  // get_buffer2
  signed int (*get_buffer2)(struct AVCodecContext *, struct AVFrame *, signed int);
  // refcounted_frames
  signed int refcounted_frames;
  // qcompress
  float qcompress;
  // qblur
  float qblur;
  // qmin
  signed int qmin;
  // qmax
  signed int qmax;
  // max_qdiff
  signed int max_qdiff;
  // rc_qsquish
  float rc_qsquish;
  // rc_qmod_amp
  float rc_qmod_amp;
  // rc_qmod_freq
  signed int rc_qmod_freq;
  // rc_buffer_size
  signed int rc_buffer_size;
  // rc_override_count
  signed int rc_override_count;
  // rc_override
  struct RcOverride *rc_override;
  // rc_eq
  const char *rc_eq;
  // rc_max_rate
  signed int rc_max_rate;
  // rc_min_rate
  signed int rc_min_rate;
  // rc_buffer_aggressivity
  float rc_buffer_aggressivity;
  // rc_initial_cplx
  float rc_initial_cplx;
  // rc_max_available_vbv_use
  float rc_max_available_vbv_use;
  // rc_min_vbv_overflow_use
  float rc_min_vbv_overflow_use;
  // rc_initial_buffer_occupancy
  signed int rc_initial_buffer_occupancy;
  // coder_type
  signed int coder_type;
  // context_model
  signed int context_model;
  // lmin
  signed int lmin;
  // lmax
  signed int lmax;
  // frame_skip_threshold
  signed int frame_skip_threshold;
  // frame_skip_factor
  signed int frame_skip_factor;
  // frame_skip_exp
  signed int frame_skip_exp;
  // frame_skip_cmp
  signed int frame_skip_cmp;
  // trellis
  signed int trellis;
  // min_prediction_order
  signed int min_prediction_order;
  // max_prediction_order
  signed int max_prediction_order;
  // timecode_frame_start
  signed long int timecode_frame_start;
  // rtp_callback
  void (*rtp_callback)(struct AVCodecContext *, void *, signed int, signed int);
  // rtp_payload_size
  signed int rtp_payload_size;
  // mv_bits
  signed int mv_bits;
  // header_bits
  signed int header_bits;
  // i_tex_bits
  signed int i_tex_bits;
  // p_tex_bits
  signed int p_tex_bits;
  // i_count
  signed int i_count;
  // p_count
  signed int p_count;
  // skip_count
  signed int skip_count;
  // misc_bits
  signed int misc_bits;
  // frame_bits
  signed int frame_bits;
  // stats_out
  char *stats_out;
  // stats_in
  char *stats_in;
  // workaround_bugs
  signed int workaround_bugs;
  // strict_std_compliance
  signed int strict_std_compliance;
  // error_concealment
  signed int error_concealment;
  // debug
  signed int debug;
  // debug_mv
  signed int debug_mv;
  // err_recognition
  signed int err_recognition;
  // reordered_opaque
  signed long int reordered_opaque;
  // hwaccel
  struct AVHWAccel *hwaccel;
  // hwaccel_context
  void *hwaccel_context;
  // error
  unsigned long int error[8l];
  // dct_algo
  signed int dct_algo;
  // idct_algo
  signed int idct_algo;
  // bits_per_coded_sample
  signed int bits_per_coded_sample;
  // bits_per_raw_sample
  signed int bits_per_raw_sample;
  // lowres
  signed int lowres;
  // coded_frame
  struct AVFrame *coded_frame;
  // thread_count
  signed int thread_count;
  // pthread_t
  signed int pthread_t;
  // active_thread_type
  signed int active_thread_type;
  // thread_safe_callbacks
  signed int thread_safe_callbacks;
  // execute
  signed int (*execute)(struct AVCodecContext *, signed int (*)(struct AVCodecContext *, void *), void *, signed int *, signed int, signed int);
  // execute2
  signed int (*execute2)(struct AVCodecContext *, signed int (*)(struct AVCodecContext *, void *, signed int, signed int), void *, signed int *, signed int);
  // thread_opaque
  void *thread_opaque;
  // nsse_weight
  signed int nsse_weight;
  // profile
  signed int profile;
  // level
  signed int level;
  // skip_loop_filter
  enum AVDiscard skip_loop_filter;
  // skip_idct
  enum AVDiscard skip_idct;
  // skip_frame
  enum AVDiscard skip_frame;
  // subtitle_header
  unsigned char *subtitle_header;
  // subtitle_header_size
  signed int subtitle_header_size;
  // error_rate
  signed int error_rate;
  // pkt
  struct AVPacket *pkt;
  // vbv_delay
  unsigned long int vbv_delay;
  // side_data_only_packets
  signed int side_data_only_packets;
  // initial_padding
  signed int initial_padding;
  // framerate
  struct AVRational framerate;
  // sw_pix_fmt
  enum AVPixelFormat sw_pix_fmt;
  // pkt_timebase
  struct AVRational pkt_timebase;
  // codec_descriptor
  const struct AVCodecDescriptor *codec_descriptor;
  // pts_correction_num_faulty_pts
  signed long int pts_correction_num_faulty_pts;
  // pts_correction_num_faulty_dts
  signed long int pts_correction_num_faulty_dts;
  // pts_correction_last_pts
  signed long int pts_correction_last_pts;
  // pts_correction_last_dts
  signed long int pts_correction_last_dts;
  // sub_charenc
  char *sub_charenc;
  // sub_charenc_mode
  signed int sub_charenc_mode;
  // skip_alpha
  signed int skip_alpha;
  // seek_preroll
  signed int seek_preroll;
  // chroma_intra_matrix
  unsigned short int *chroma_intra_matrix;
  // dump_separator
  unsigned char *dump_separator;
  // codec_whitelist
  char *codec_whitelist;
  // properties
  unsigned int properties;
};

struct AVCodecDescriptor
{
  // id
  enum AVCodecID id;
  // type
  enum AVMediaType type;
  // name
  const char *name;
  // long_name
  const char *long_name;
  // props
  signed int props;
  // mime_types
  const char * const *mime_types;
};

struct AVCodecParser
{
  // codec_ids
  signed int codec_ids[5l];
  // priv_data_size
  signed int priv_data_size;
  // parser_init
  signed int (*parser_init)(struct AVCodecParserContext *);
  // parser_parse
  signed int (*parser_parse)(struct AVCodecParserContext *, struct AVCodecContext *, const unsigned char **, signed int *, const unsigned char *, signed int);
  // parser_close
  void (*parser_close)(struct AVCodecParserContext *);
  // split
  signed int (*split)(struct AVCodecContext *, const unsigned char *, signed int);
  // next
  struct AVCodecParser *next;
};

struct AVCodecParserContext
{
  // priv_data
  void *priv_data;
  // parser
  struct AVCodecParser *parser;
  // frame_offset
  signed long int frame_offset;
  // cur_offset
  signed long int cur_offset;
  // next_frame_offset
  signed long int next_frame_offset;
  // pict_type
  signed int pict_type;
  // repeat_pict
  signed int repeat_pict;
  // pts
  signed long int pts;
  // dts
  signed long int dts;
  // last_pts
  signed long int last_pts;
  // last_dts
  signed long int last_dts;
  // fetch_timestamp
  signed int fetch_timestamp;
  // cur_frame_start_index
  signed int cur_frame_start_index;
  // cur_frame_offset
  signed long int cur_frame_offset[4l];
  // cur_frame_pts
  signed long int cur_frame_pts[4l];
  // cur_frame_dts
  signed long int cur_frame_dts[4l];
  // flags
  signed int flags;
  // offset
  signed long int offset;
  // cur_frame_end
  signed long int cur_frame_end[4l];
  // key_frame
  signed int key_frame;
  // convergence_duration
  signed long int convergence_duration;
  // dts_sync_point
  signed int dts_sync_point;
  // dts_ref_dts_delta
  signed int dts_ref_dts_delta;
  // pts_dts_delta
  signed int pts_dts_delta;
  // cur_frame_pos
  signed long int cur_frame_pos[4l];
  // pos
  signed long int pos;
  // last_pos
  signed long int last_pos;
  // duration
  signed int duration;
  // field_order
  enum AVFieldOrder field_order;
  // picture_structure
  enum AVPictureStructure picture_structure;
  // output_picture_number
  signed int output_picture_number;
  // width
  signed int width;
  // height
  signed int height;
  // coded_width
  signed int coded_width;
  // coded_height
  signed int coded_height;
  // format
  signed int format;
};

struct AVIOInterruptCB
{
  // callback
  signed int (*callback)(void *);
  // opaque
  void *opaque;
};

struct AVFormatContext
{
  // av_class
  const struct AVClass *av_class;
  // iformat
  struct AVInputFormat *iformat;
  // oformat
  struct AVOutputFormat *oformat;
  // priv_data
  void *priv_data;
  // pb
  struct AVIOContext *pb;
  // ctx_flags
  signed int ctx_flags;
  // nb_streams
  unsigned int nb_streams;
  // streams
  struct AVStream **streams;
  // filename
  char filename[1024l];
  // start_time
  signed long int start_time;
  // duration
  signed long int duration;
  // bit_rate
  signed int bit_rate;
  // packet_size
  unsigned int packet_size;
  // max_delay
  signed int max_delay;
  // flags
  signed int flags;
  // probesize
  unsigned int probesize;
  // max_analyze_duration
  signed int max_analyze_duration;
  // key
  const unsigned char *key;
  // keylen
  signed int keylen;
  // nb_programs
  unsigned int nb_programs;
  // programs
  struct AVProgram **programs;
  // video_codec_id
  enum AVCodecID video_codec_id;
  // audio_codec_id
  enum AVCodecID audio_codec_id;
  // subtitle_codec_id
  enum AVCodecID subtitle_codec_id;
  // max_index_size
  unsigned int max_index_size;
  // max_picture_buffer
  unsigned int max_picture_buffer;
  // nb_chapters
  unsigned int nb_chapters;
  // chapters
  struct AVChapter **chapters;
  // metadata
  struct AVDictionary *metadata;
  // start_time_realtime
  signed long int start_time_realtime;
  // fps_probe_size
  signed int fps_probe_size;
  // error_recognition
  signed int error_recognition;
  // interrupt_callback
  struct AVIOInterruptCB interrupt_callback;
  // debug
  signed int debug;
  // max_interleave_delta
  signed long int max_interleave_delta;
  // strict_std_compliance
  signed int strict_std_compliance;
  // event_flags
  signed int event_flags;
  // max_ts_probe
  signed int max_ts_probe;
  // avoid_negative_ts
  signed int avoid_negative_ts;
  // ts_id
  signed int ts_id;
  // audio_preload
  signed int audio_preload;
  // max_chunk_duration
  signed int max_chunk_duration;
  // max_chunk_size
  signed int max_chunk_size;
  // use_wallclock_as_timestamps
  signed int use_wallclock_as_timestamps;
  // avio_flags
  signed int avio_flags;
  // duration_estimation_method
  enum AVDurationEstimationMethod duration_estimation_method;
  // skip_initial_bytes
  signed long int skip_initial_bytes;
  // correct_ts_overflow
  unsigned int correct_ts_overflow;
  // seek2any
  signed int seek2any;
  // flush_packets
  signed int flush_packets;
  // probe_score
  signed int probe_score;
  // format_probesize
  signed int format_probesize;
  // codec_whitelist
  char *codec_whitelist;
  // format_whitelist
  char *format_whitelist;
  // internal
  struct AVFormatInternal *internal;
  // io_repositioned
  signed int io_repositioned;
  // video_codec
  struct AVCodec *video_codec;
  // audio_codec
  struct AVCodec *audio_codec;
  // subtitle_codec
  struct AVCodec *subtitle_codec;
  // data_codec
  struct AVCodec *data_codec;
  // metadata_header_padding
  signed int metadata_header_padding;
  // opaque
  void *opaque;
  // control_message_cb
  signed int (*control_message_cb)(struct AVFormatContext *, signed int, void *, unsigned long int);
  // output_ts_offset
  signed long int output_ts_offset;
  // max_analyze_duration2
  signed long int max_analyze_duration2;
  // probesize2
  signed long int probesize2;
  // dump_separator
  unsigned char *dump_separator;
  // data_codec_id
  enum AVCodecID data_codec_id;
  // open_cb
  signed int (*open_cb)(struct AVFormatContext *, struct AVIOContext **, const char *, signed int, const struct AVIOInterruptCB *, struct AVDictionary **);
};

struct AVFrac
{
  // val
  signed long int val;
  // num
  signed long int num;
  // den
  signed long int den;
};

struct AVFrame
{
  // data
  unsigned char *data[8l];
  // linesize
  signed int linesize[8l];
  // extended_data
  unsigned char **extended_data;
  // width
  signed int width;
  // height
  signed int height;
  // nb_samples
  signed int nb_samples;
  // format
  signed int format;
  // key_frame
  signed int key_frame;
  // pict_type
  enum AVPictureType pict_type;
  // base
  unsigned char *base[8l];
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // pts
  signed long int pts;
  // pkt_pts
  signed long int pkt_pts;
  // pkt_dts
  signed long int pkt_dts;
  // coded_picture_number
  signed int coded_picture_number;
  // display_picture_number
  signed int display_picture_number;
  // quality
  signed int quality;
  // reference
  signed int reference;
  // qscale_table
  signed char *qscale_table;
  // qstride
  signed int qstride;
  // qscale_type
  signed int qscale_type;
  // mbskip_table
  unsigned char *mbskip_table;
  // motion_val
  signed short int (*motion_val[2l])[2l];
  // mb_type
  unsigned int *mb_type;
  // dct_coeff
  signed short int *dct_coeff;
  // ref_index
  signed char *ref_index[2l];
  // opaque
  void *opaque;
  // error
  unsigned long int error[8l];
  // type
  signed int type;
  // repeat_pict
  signed int repeat_pict;
  // interlaced_frame
  signed int interlaced_frame;
  // top_field_first
  signed int top_field_first;
  // palette_has_changed
  signed int palette_has_changed;
  // buffer_hints
  signed int buffer_hints;
  // pan_scan
  struct AVPanScan *pan_scan;
  // reordered_opaque
  signed long int reordered_opaque;
  // hwaccel_picture_private
  void *hwaccel_picture_private;
  // owner
  struct AVCodecContext *owner;
  // thread_opaque
  void *thread_opaque;
  // motion_subsample_log2
  unsigned char motion_subsample_log2;
  // sample_rate
  signed int sample_rate;
  // channel_layout
  unsigned long int channel_layout;
  // buf
  struct AVBufferRef *buf[8l];
  // extended_buf
  struct AVBufferRef **extended_buf;
  // nb_extended_buf
  signed int nb_extended_buf;
  // side_data
  struct AVFrameSideData **side_data;
  // nb_side_data
  signed int nb_side_data;
  // flags
  signed int flags;
  // color_range
  enum AVColorRange color_range;
  // color_primaries
  enum AVColorPrimaries color_primaries;
  // color_trc
  enum AVColorTransferCharacteristic color_trc;
  // colorspace
  enum AVColorSpace colorspace;
  // chroma_location
  enum AVChromaLocation chroma_location;
  // best_effort_timestamp
  signed long int best_effort_timestamp;
  // pkt_pos
  signed long int pkt_pos;
  // pkt_duration
  signed long int pkt_duration;
  // metadata
  struct AVDictionary *metadata;
  // decode_error_flags
  signed int decode_error_flags;
  // channels
  signed int channels;
  // pkt_size
  signed int pkt_size;
  // qp_table_buf
  struct AVBufferRef *qp_table_buf;
};

struct AVFrameSideData
{
  // type
  enum AVFrameSideDataType type;
  // data
  unsigned char *data;
  // size
  signed int size;
  // metadata
  struct AVDictionary *metadata;
  // buf
  struct AVBufferRef *buf;
};

struct AVHWAccel
{
  // name
  const char *name;
  // type
  enum AVMediaType type;
  // id
  enum AVCodecID id;
  // pix_fmt
  enum AVPixelFormat pix_fmt;
  // capabilities
  signed int capabilities;
  // next
  struct AVHWAccel *next;
  // alloc_frame
  signed int (*alloc_frame)(struct AVCodecContext *, struct AVFrame *);
  // start_frame
  signed int (*start_frame)(struct AVCodecContext *, const unsigned char *, unsigned int);
  // decode_slice
  signed int (*decode_slice)(struct AVCodecContext *, const unsigned char *, unsigned int);
  // end_frame
  signed int (*end_frame)(struct AVCodecContext *);
  // frame_priv_data_size
  signed int frame_priv_data_size;
  // decode_mb
  void (*decode_mb)(struct MpegEncContext *);
  // init
  signed int (*init)(struct AVCodecContext *);
  // uninit
  signed int (*uninit)(struct AVCodecContext *);
  // priv_data_size
  signed int priv_data_size;
};

struct AVIOContext
{
  // av_class
  const struct AVClass *av_class;
  // buffer
  unsigned char *buffer;
  // buffer_size
  signed int buffer_size;
  // buf_ptr
  unsigned char *buf_ptr;
  // buf_end
  unsigned char *buf_end;
  // opaque
  void *opaque;
  // read_packet
  signed int (*read_packet)(void *, unsigned char *, signed int);
  // write_packet
  signed int (*write_packet)(void *, unsigned char *, signed int);
  // seek
  signed long int (*seek)(void *, signed long int, signed int);
  // pos
  signed long int pos;
  // must_flush
  signed int must_flush;
  // eof_reached
  signed int eof_reached;
  // write_flag
  signed int write_flag;
  // max_packet_size
  signed int max_packet_size;
  // checksum
  unsigned long int checksum;
  // checksum_ptr
  unsigned char *checksum_ptr;
  // update_checksum
  unsigned long int (*update_checksum)(unsigned long int, const unsigned char *, unsigned int);
  // error
  signed int error;
  // read_pause
  signed int (*read_pause)(void *, signed int);
  // read_seek
  signed long int (*read_seek)(void *, signed int, signed long int, signed int);
  // seekable
  signed int seekable;
  // maxsize
  signed long int maxsize;
  // direct
  signed int direct;
  // bytes_read
  signed long int bytes_read;
  // seek_count
  signed int seek_count;
  // writeout_count
  signed int writeout_count;
  // orig_buffer_size
  signed int orig_buffer_size;
  // short_seek_threshold
  signed int short_seek_threshold;
};

struct AVIndexEntry
{
  // pos
  signed long int pos;
  // timestamp
  signed long int timestamp;
  // flags
  signed int flags : 2;
  // size
  signed int size : 30;
  // min_distance
  signed int min_distance;
};

struct AVInputFormat
{
  // name
  const char *name;
  // long_name
  const char *long_name;
  // flags
  signed int flags;
  // extensions
  const char *extensions;
  // codec_tag
  struct AVCodecTag * const *codec_tag;
  // priv_class
  const struct AVClass *priv_class;
  // mime_type
  const char *mime_type;
  // next
  struct AVInputFormat *next;
  // raw_codec_id
  signed int raw_codec_id;
  // priv_data_size
  signed int priv_data_size;
  // read_probe
  signed int (*read_probe)(struct AVProbeData *);
  // read_header
  signed int (*read_header)(struct AVFormatContext *);
  // read_packet
  signed int (*read_packet)(struct AVFormatContext *, struct AVPacket *);
  // read_close
  signed int (*read_close)(struct AVFormatContext *);
  // read_seek
  signed int (*read_seek)(struct AVFormatContext *, signed int, signed long int, signed int);
  // read_timestamp
  signed long int (*read_timestamp)(struct AVFormatContext *, signed int, signed long int *, signed long int);
  // read_play
  signed int (*read_play)(struct AVFormatContext *);
  // read_pause
  signed int (*read_pause)(struct AVFormatContext *);
  // read_seek2
  signed int (*read_seek2)(struct AVFormatContext *, signed int, signed long int, signed long int, signed long int, signed int);
  // get_device_list
  signed int (*get_device_list)(struct AVFormatContext *, struct AVDeviceInfoList *);
  // create_device_capabilities
  signed int (*create_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
  // free_device_capabilities
  signed int (*free_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
};

struct AVOutputFormat
{
  // name
  const char *name;
  // long_name
  const char *long_name;
  // mime_type
  const char *mime_type;
  // extensions
  const char *extensions;
  // audio_codec
  enum AVCodecID audio_codec;
  // video_codec
  enum AVCodecID video_codec;
  // subtitle_codec
  enum AVCodecID subtitle_codec;
  // flags
  signed int flags;
  // codec_tag
  struct AVCodecTag * const *codec_tag;
  // priv_class
  const struct AVClass *priv_class;
  // next
  struct AVOutputFormat *next;
  // priv_data_size
  signed int priv_data_size;
  // write_header
  signed int (*write_header)(struct AVFormatContext *);
  // write_packet
  signed int (*write_packet)(struct AVFormatContext *, struct AVPacket *);
  // write_trailer
  signed int (*write_trailer)(struct AVFormatContext *);
  // interleave_packet
  signed int (*interleave_packet)(struct AVFormatContext *, struct AVPacket *, struct AVPacket *, signed int);
  // query_codec
  signed int (*query_codec)(enum AVCodecID, signed int);
  // get_output_timestamp
  void (*get_output_timestamp)(struct AVFormatContext *, signed int, signed long int *, signed long int *);
  // control_message
  signed int (*control_message)(struct AVFormatContext *, signed int, void *, unsigned long int);
  // write_uncoded_frame
  signed int (*write_uncoded_frame)(struct AVFormatContext *, signed int, struct AVFrame **, unsigned int);
  // get_device_list
  signed int (*get_device_list)(struct AVFormatContext *, struct AVDeviceInfoList *);
  // create_device_capabilities
  signed int (*create_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
  // free_device_capabilities
  signed int (*free_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
  // data_codec
  enum AVCodecID data_codec;
};

struct AVPacket
{
  // buf
  struct AVBufferRef *buf;
  // pts
  signed long int pts;
  // dts
  signed long int dts;
  // data
  unsigned char *data;
  // size
  signed int size;
  // stream_index
  signed int stream_index;
  // flags
  signed int flags;
  // side_data
  struct AVPacketSideData *side_data;
  // side_data_elems
  signed int side_data_elems;
  // duration
  signed int duration;
  // destruct
  void (*destruct)(struct AVPacket *);
  // priv
  void *priv;
  // pos
  signed long int pos;
  // convergence_duration
  signed long int convergence_duration;
};

struct AVPacketList
{
  // pkt
  struct AVPacket pkt;
  // next
  struct AVPacketList *next;
};

struct AVPacketSideData
{
  // data
  unsigned char *data;
  // size
  signed int size;
  // type
  enum AVPacketSideDataType type;
};

struct AVPanScan
{
  // id
  signed int id;
  // width
  signed int width;
  // height
  signed int height;
  // position
  signed short int position[3l][2l];
};

struct AVPicture
{
  // data
  unsigned char *data[8l];
  // linesize
  signed int linesize[8l];
};

struct AVProbeData
{
  // filename
  const char *filename;
  // buf
  unsigned char *buf;
  // buf_size
  signed int buf_size;
  // mime_type
  const char *mime_type;
};

struct AVProfile
{
  // profile
  signed int profile;
  // name
  const char *name;
};

struct AVProgram
{
  // id
  signed int id;
  // flags
  signed int flags;
  // discard
  enum AVDiscard discard;
  // stream_index
  unsigned int *stream_index;
  // nb_stream_indexes
  unsigned int nb_stream_indexes;
  // metadata
  struct AVDictionary *metadata;
  // program_num
  signed int program_num;
  // pmt_pid
  signed int pmt_pid;
  // pcr_pid
  signed int pcr_pid;
  // start_time
  signed long int start_time;
  // end_time
  signed long int end_time;
  // pts_wrap_reference
  signed long int pts_wrap_reference;
  // pts_wrap_behavior
  signed int pts_wrap_behavior;
};

struct AVStream
{
  // index
  signed int index;
  // id
  signed int id;
  // codec
  struct AVCodecContext *codec;
  // priv_data
  void *priv_data;
  // pts
  struct AVFrac pts;
  // time_base
  struct AVRational time_base;
  // start_time
  signed long int start_time;
  // duration
  signed long int duration;
  // nb_frames
  signed long int nb_frames;
  // disposition
  signed int disposition;
  // discard
  enum AVDiscard discard;
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // metadata
  struct AVDictionary *metadata;
  // avg_frame_rate
  struct AVRational avg_frame_rate;
  // attached_pic
  struct AVPacket attached_pic;
  // side_data
  struct AVPacketSideData *side_data;
  // nb_side_data
  signed int nb_side_data;
  // event_flags
  signed int event_flags;
  // info
  struct anonymous_19 *info;
  // pts_wrap_bits
  signed int pts_wrap_bits;
  // first_dts
  signed long int first_dts;
  // cur_dts
  signed long int cur_dts;
  // last_IP_pts
  signed long int last_IP_pts;
  // last_IP_duration
  signed int last_IP_duration;
  // probe_packets
  signed int probe_packets;
  // codec_info_nb_frames
  signed int codec_info_nb_frames;
  // need_parsing
  enum AVStreamParseType need_parsing;
  // parser
  struct AVCodecParserContext *parser;
  // last_in_packet_buffer
  struct AVPacketList *last_in_packet_buffer;
  // probe_data
  struct AVProbeData probe_data;
  // pts_buffer
  signed long int pts_buffer[17l];
  // index_entries
  struct AVIndexEntry *index_entries;
  // nb_index_entries
  signed int nb_index_entries;
  // index_entries_allocated_size
  unsigned int index_entries_allocated_size;
  // r_frame_rate
  struct AVRational r_frame_rate;
  // stream_identifier
  signed int stream_identifier;
  // interleaver_chunk_size
  signed long int interleaver_chunk_size;
  // interleaver_chunk_duration
  signed long int interleaver_chunk_duration;
  // request_probe
  signed int request_probe;
  // skip_to_keyframe
  signed int skip_to_keyframe;
  // skip_samples
  signed int skip_samples;
  // start_skip_samples
  signed long int start_skip_samples;
  // first_discard_sample
  signed long int first_discard_sample;
  // last_discard_sample
  signed long int last_discard_sample;
  // nb_decoded_frames
  signed int nb_decoded_frames;
  // mux_ts_offset
  signed long int mux_ts_offset;
  // pts_wrap_reference
  signed long int pts_wrap_reference;
  // pts_wrap_behavior
  signed int pts_wrap_behavior;
  // update_initial_durations_done
  signed int update_initial_durations_done;
  // pts_reorder_error
  signed long int pts_reorder_error[17l];
  // pts_reorder_error_count
  unsigned char pts_reorder_error_count[17l];
  // last_dts_for_order_check
  signed long int last_dts_for_order_check;
  // dts_ordered
  unsigned char dts_ordered;
  // dts_misordered
  unsigned char dts_misordered;
  // inject_global_side_data
  signed int inject_global_side_data;
  // recommended_encoder_configuration
  char *recommended_encoder_configuration;
  // display_aspect_ratio
  struct AVRational display_aspect_ratio;
  // priv_pts
  struct FFFrac *priv_pts;
};

struct AVSubtitle
{
  // format
  unsigned short int format;
  // start_display_time
  unsigned int start_display_time;
  // end_display_time
  unsigned int end_display_time;
  // num_rects
  unsigned int num_rects;
  // rects
  struct AVSubtitleRect **rects;
  // pts
  signed long int pts;
};

struct AVSubtitleRect
{
  // x
  signed int x;
  // y
  signed int y;
  // w
  signed int w;
  // h
  signed int h;
  // nb_colors
  signed int nb_colors;
  // pict
  struct AVPicture pict;
  // type
  enum AVSubtitleType type;
  // text
  char *text;
  // ass
  char *ass;
  // flags
  signed int flags;
};

struct DSCO_packet
{
  // opcode
  char opcode[4l];
  // length
  unsigned int length;
  // reason
  unsigned char reason;
} __attribute__ ((__packed__));

struct HELO_packet
{
  // opcode
  char opcode[4l];
  // length
  unsigned int length;
  // deviceid
  unsigned char deviceid;
  // revision
  unsigned char revision;
  // mac
  unsigned char mac[6l];
  // uuid
  unsigned char uuid[16l];
  // wlan_channellist
  unsigned short int wlan_channellist;
  // bytes_received_H
  unsigned int bytes_received_H;
  // bytes_received_L
  unsigned int bytes_received_L;
  // lang
  char lang[2l];
} __attribute__ ((__packed__));

struct IR_packet
{
  // opcode
  char opcode[4l];
  // length
  unsigned int length;
  // jiffies
  unsigned int jiffies;
  // format
  unsigned char format;
  // bits
  unsigned char bits;
  // ir_code
  unsigned int ir_code;
} __attribute__ ((__packed__));

struct META_header
{
  // opcode
  char opcode[4l];
  // length
  unsigned int length;
} __attribute__ ((__packed__));

struct NeAACDecConfiguration
{
  // defObjectType
  unsigned char defObjectType;
  // defSampleRate
  unsigned long int defSampleRate;
  // outputFormat
  unsigned char outputFormat;
  // downMatrix
  unsigned char downMatrix;
  // useOldADTSFormat
  unsigned char useOldADTSFormat;
  // dontUpSampleImplicitSBR
  unsigned char dontUpSampleImplicitSBR;
};

struct NeAACDecFrameInfo
{
  // bytesconsumed
  unsigned long int bytesconsumed;
  // samples
  unsigned long int samples;
  // channels
  unsigned char channels;
  // error
  unsigned char error;
  // samplerate
  unsigned long int samplerate;
  // sbr
  unsigned char sbr;
  // object_type
  unsigned char object_type;
  // header_type
  unsigned char header_type;
  // num_front_channels
  unsigned char num_front_channels;
  // num_side_channels
  unsigned char num_side_channels;
  // num_back_channels
  unsigned char num_back_channels;
  // num_lfe_channels
  unsigned char num_lfe_channels;
  // channel_position
  unsigned char channel_position[64l];
  // ps
  unsigned char ps;
};

struct vorbis_dsp_state
{
  // analysisp
  signed int analysisp;
  // vi
  struct vorbis_info *vi;
  // pcm
  float **pcm;
  // pcmret
  float **pcmret;
  // pcm_storage
  signed int pcm_storage;
  // pcm_current
  signed int pcm_current;
  // pcm_returned
  signed int pcm_returned;
  // preextrapolate
  signed int preextrapolate;
  // eofflag
  signed int eofflag;
  // lW
  signed long int lW;
  // W
  signed long int W;
  // nW
  signed long int nW;
  // centerW
  signed long int centerW;
  // granulepos
  signed long int granulepos;
  // sequence
  signed long int sequence;
  // glue_bits
  signed long int glue_bits;
  // time_bits
  signed long int time_bits;
  // floor_bits
  signed long int floor_bits;
  // res_bits
  signed long int res_bits;
  // backend_state
  void *backend_state;
};

struct vorbis_block
{
  // pcm
  float **pcm;
  // opb
  struct anonymous opb;
  // lW
  signed long int lW;
  // W
  signed long int W;
  // nW
  signed long int nW;
  // pcmend
  signed int pcmend;
  // mode
  signed int mode;
  // eofflag
  signed int eofflag;
  // granulepos
  signed long int granulepos;
  // sequence
  signed long int sequence;
  // vd
  struct vorbis_dsp_state *vd;
  // localstore
  void *localstore;
  // localtop
  signed long int localtop;
  // localalloc
  signed long int localalloc;
  // totaluse
  signed long int totaluse;
  // reap
  struct alloc_chain *reap;
  // glue_bits
  signed long int glue_bits;
  // time_bits
  signed long int time_bits;
  // floor_bits
  signed long int floor_bits;
  // res_bits
  signed long int res_bits;
  // internal
  void *internal;
};

struct OggVorbis_File
{
  // datasource
  void *datasource;
  // seekable
  signed int seekable;
  // offset
  signed long int offset;
  // end
  signed long int end;
  // oy
  struct anonymous_73 oy;
  // links
  signed int links;
  // offsets
  signed long int *offsets;
  // dataoffsets
  signed long int *dataoffsets;
  // serialnos
  signed long int *serialnos;
  // pcmlengths
  signed long int *pcmlengths;
  // vi
  struct vorbis_info *vi;
  // vc
  struct vorbis_comment *vc;
  // pcm_offset
  signed long int pcm_offset;
  // ready_state
  signed int ready_state;
  // current_serialno
  signed long int current_serialno;
  // current_link
  signed int current_link;
  // bittrack
  double bittrack;
  // samptrack
  double samptrack;
  // os
  struct anonymous_74 os;
  // vd
  struct vorbis_dsp_state vd;
  // vb
  struct vorbis_block vb;
  // callbacks
  struct anonymous_75 callbacks;
};

struct PaDeviceInfo
{
  // structVersion
  signed int structVersion;
  // name
  const char *name;
  // hostApi
  signed int hostApi;
  // maxInputChannels
  signed int maxInputChannels;
  // maxOutputChannels
  signed int maxOutputChannels;
  // defaultLowInputLatency
  double defaultLowInputLatency;
  // defaultLowOutputLatency
  double defaultLowOutputLatency;
  // defaultHighInputLatency
  double defaultHighInputLatency;
  // defaultHighOutputLatency
  double defaultHighOutputLatency;
  // defaultSampleRate
  double defaultSampleRate;
};

struct PaHostApiInfo
{
  // structVersion
  signed int structVersion;
  // type
  enum PaHostApiTypeId type;
  // name
  const char *name;
  // deviceCount
  signed int deviceCount;
  // defaultInputDevice
  signed int defaultInputDevice;
  // defaultOutputDevice
  signed int defaultOutputDevice;
};

struct PaStreamCallbackTimeInfo
{
  // inputBufferAdcTime
  double inputBufferAdcTime;
  // currentTime
  double currentTime;
  // outputBufferDacTime
  double outputBufferDacTime;
};

struct PaStreamInfo
{
  // structVersion
  signed int structVersion;
  // inputLatency
  double inputLatency;
  // outputLatency
  double outputLatency;
  // sampleRate
  double sampleRate;
};

struct PaStreamParameters
{
  // device
  signed int device;
  // channelCount
  signed int channelCount;
  // sampleFormat
  unsigned long int sampleFormat;
  // suggestedLatency
  double suggestedLatency;
  // hostApiSpecificStreamInfo
  void *hostApiSpecificStreamInfo;
};

struct RESP_header
{
  // opcode
  char opcode[4l];
  // length
  unsigned int length;
} __attribute__ ((__packed__));

struct RcOverride
{
  // start_frame
  signed int start_frame;
  // end_frame
  signed int end_frame;
  // qscale
  signed int qscale;
  // quality_factor
  float quality_factor;
};

struct SETD_header
{
  // opcode
  char opcode[4l];
  // length
  unsigned int length;
  // id
  unsigned char id;
} __attribute__ ((__packed__));

struct STAT_packet
{
  // opcode
  char opcode[4l];
  // length
  unsigned int length;
  // event
  unsigned int event;
  // num_crlf
  unsigned char num_crlf;
  // mas_initialized
  unsigned char mas_initialized;
  // mas_mode
  unsigned char mas_mode;
  // stream_buffer_size
  unsigned int stream_buffer_size;
  // stream_buffer_fullness
  unsigned int stream_buffer_fullness;
  // bytes_received_H
  unsigned int bytes_received_H;
  // bytes_received_L
  unsigned int bytes_received_L;
  // signal_strength
  unsigned short int signal_strength;
  // jiffies
  unsigned int jiffies;
  // output_buffer_size
  unsigned int output_buffer_size;
  // output_buffer_fullness
  unsigned int output_buffer_fullness;
  // elapsed_seconds
  unsigned int elapsed_seconds;
  // voltage
  unsigned short int voltage;
  // elapsed_milliseconds
  unsigned int elapsed_milliseconds;
  // server_timestamp
  unsigned int server_timestamp;
  // error_code
  unsigned short int error_code;
} __attribute__ ((__packed__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct alloc_chain
{
  // ptr
  void *ptr;
  // next
  struct alloc_chain *next;
};

struct aude_packet
{
  // opcode
  char opcode[4l];
  // enable_spdif
  unsigned char enable_spdif;
  // enable_dac
  unsigned char enable_dac;
} __attribute__ ((__packed__));

struct audg_packet
{
  // opcode
  char opcode[4l];
  // old_gainL
  unsigned int old_gainL;
  // old_gainR
  unsigned int old_gainR;
  // adjust
  unsigned char adjust;
  // preamp
  unsigned char preamp;
  // gainL
  unsigned int gainL;
  // gainR
  unsigned int gainR;
} __attribute__ ((__packed__));

struct buffer
{
  // buf
  unsigned char *buf;
  // readp
  unsigned char *readp;
  // writep
  unsigned char *writep;
  // wrap
  unsigned char *wrap;
  // size
  unsigned long int size;
  // base_size
  unsigned long int base_size;
  // mutex
  union anonymous_6 mutex;
};

struct chunk_table
{
  // sample
  unsigned int sample;
  // offset
  unsigned int offset;
};

struct codc_packet
{
  // opcode
  char opcode[4l];
  // format
  unsigned char format;
  // pcm_sample_size
  unsigned char pcm_sample_size;
  // pcm_sample_rate
  unsigned char pcm_sample_rate;
  // pcm_channels
  unsigned char pcm_channels;
  // pcm_endianness
  unsigned char pcm_endianness;
} __attribute__ ((__packed__));

struct codec
{
  // id
  char id;
  // types
  char *types;
  // min_read_bytes
  unsigned int min_read_bytes;
  // min_space
  unsigned int min_space;
  // open
  void (*open)(unsigned char, unsigned char, unsigned char, unsigned char);
  // close
  void (*close)(void);
  // decode
  enum anonymous_23 (*decode)(void);
};

struct cont_packet
{
  // opcode
  char opcode[4l];
  // metaint
  unsigned int metaint;
  // loop
  unsigned char loop;
} __attribute__ ((__packed__));

struct decodestate
{
  // state
  enum anonymous_23 state;
  // new_stream
  _Bool new_stream;
  // mutex
  union anonymous_6 mutex;
  // direct
  _Bool direct;
  // process
  _Bool process;
};

struct dsd2pcm_ctx_s
{
  // fifo
  unsigned char fifo[16l];
  // fifopos
  unsigned int fifopos;
};

struct dsd
{
  // type
  enum anonymous_20 type;
  // consume
  unsigned int consume;
  // sample_rate
  unsigned int sample_rate;
  // channels
  unsigned int channels;
  // sample_bytes
  unsigned long int sample_bytes;
  // block_size
  unsigned int block_size;
  // lsb_first
  _Bool lsb_first;
  // dsd2pcm_ctx
  struct dsd2pcm_ctx_s *dsd2pcm_ctx[2l];
  // transfer
  float *transfer[2l];
};

struct faad
{
  // hAac
  void *hAac;
  // type
  unsigned char type;
  // consume
  unsigned int consume;
  // pos
  unsigned int pos;
  // sample
  unsigned int sample;
  // nextchunk
  unsigned int nextchunk;
  // stsc
  void *stsc;
  // skip
  unsigned int skip;
  // samples
  unsigned long int samples;
  // sttssamples
  unsigned long int sttssamples;
  // empty
  _Bool empty;
  // chunkinfo
  struct chunk_table *chunkinfo;
};

struct ff_s
{
  // wma
  _Bool wma;
  // wma_mmsh
  unsigned char wma_mmsh;
  // wma_playstream
  unsigned char wma_playstream;
  // wma_metadatastream
  unsigned char wma_metadatastream;
  // readbuf
  unsigned char *readbuf;
  // end_of_stream
  _Bool end_of_stream;
  // input_format
  struct AVInputFormat *input_format;
  // formatC
  struct AVFormatContext *formatC;
  // codecC
  struct AVCodecContext *codecC;
  // frame
  struct AVFrame *frame;
  // avpkt
  struct AVPacket *avpkt;
  // mmsh_bytes_left
  unsigned int mmsh_bytes_left;
  // mmsh_bytes_pad
  unsigned int mmsh_bytes_pad;
  // mmsh_packet_len
  unsigned int mmsh_packet_len;
};

struct flac
{
  // decoder
  struct anonymous_43 *decoder;
};

struct handler
{
  // opcode
  char opcode[5l];
  // handler
  void (*handler)(unsigned char *, signed int);
};

struct ifconf
{
  // ifc_len
  signed int ifc_len;
  // ifc_ifcu
  union anonymous_16 ifc_ifcu;
};

struct ifreq
{
  // ifr_ifrn
  union anonymous_13 ifr_ifrn;
  // ifr_ifru
  union anonymous_15 ifr_ifru;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct irstate
{
  // mutex
  union anonymous_6 mutex;
  // code
  unsigned int code;
  // ts
  unsigned int ts;
};

struct lirc_code
{
  // remote
  char *remote;
  // button
  char *button;
  // next
  struct lirc_code *next;
};

struct lirc_config
{
  // current_mode
  char *current_mode;
  // next
  struct lirc_config_entry *next;
  // first
  struct lirc_config_entry *first;
  // sockfd
  signed int sockfd;
};

struct lirc_config_entry
{
  // prog
  char *prog;
  // code
  struct lirc_code *code;
  // rep_delay
  unsigned int rep_delay;
  // rep
  unsigned int rep;
  // config
  struct lirc_list *config;
  // change_mode
  char *change_mode;
  // flags
  unsigned int flags;
  // mode
  char *mode;
  // next_config
  struct lirc_list *next_config;
  // next_code
  struct lirc_code *next_code;
  // next
  struct lirc_config_entry *next;
};

struct lirc_list
{
  // string
  char *string;
  // next
  struct lirc_list *next;
};

struct mad_bitptr
{
  // byte
  const unsigned char *byte;
  // cache
  unsigned short int cache;
  // left
  unsigned short int left;
};

struct mad_stream
{
  // buffer
  const unsigned char *buffer;
  // bufend
  const unsigned char *bufend;
  // skiplen
  unsigned long int skiplen;
  // sync
  signed int sync;
  // freerate
  unsigned long int freerate;
  // this_frame
  const unsigned char *this_frame;
  // next_frame
  const unsigned char *next_frame;
  // ptr
  struct mad_bitptr ptr;
  // anc_ptr
  struct mad_bitptr anc_ptr;
  // anc_bitlen
  unsigned int anc_bitlen;
  // main_data
  unsigned char (*main_data)[2567l];
  // md_len
  unsigned int md_len;
  // options
  signed int options;
  // error
  enum mad_error error;
};

struct mad_header
{
  // layer
  enum mad_layer layer;
  // mode
  enum mad_mode mode;
  // mode_extension
  signed int mode_extension;
  // emphasis
  enum mad_emphasis emphasis;
  // bitrate
  unsigned long int bitrate;
  // samplerate
  unsigned int samplerate;
  // crc_check
  unsigned short int crc_check;
  // crc_target
  unsigned short int crc_target;
  // flags
  signed int flags;
  // private_bits
  signed int private_bits;
  // duration
  struct anonymous_72 duration;
};

struct mad_frame
{
  // header
  struct mad_header header;
  // options
  signed int options;
  // sbsample
  signed int sbsample[2l][36l][32l];
  // overlap
  signed int (*overlap)[2l][32l][18l];
};

struct mad_pcm
{
  // samplerate
  unsigned int samplerate;
  // channels
  unsigned short int channels;
  // length
  unsigned short int length;
  // samples
  signed int samples[2l][1152l];
};

struct mad_synth
{
  // filter
  signed int filter[2l][2l][2l][16l][8l];
  // phase
  unsigned int phase;
  // pcm
  struct mad_pcm pcm;
};

struct mad
{
  // readbuf
  unsigned char *readbuf;
  // readbuf_len
  unsigned int readbuf_len;
  // stream
  struct mad_stream stream;
  // frame
  struct mad_frame frame;
  // synth
  struct mad_synth synth;
  // last_error
  enum mad_error last_error;
  // checktags
  signed int checktags;
  // consume
  unsigned int consume;
  // skip
  unsigned int skip;
  // samples
  unsigned long int samples;
  // padding
  unsigned int padding;
};

struct mpg
{
  // h
  struct mpg123_handle_struct *h;
  // use16bit
  _Bool use16bit;
};

struct outputstate
{
  // state
  enum anonymous_1 state;
  // format
  enum anonymous_22 format;
  // device
  const char *device;
  // track_started
  _Bool track_started;
  // pa_reopen
  _Bool pa_reopen;
  // latency
  unsigned int latency;
  // osx_playnice
  signed int osx_playnice;
  // write_cb
  signed int (*write_cb)(unsigned int, _Bool, signed int, signed int, signed int, signed int, signed int **);
  // start_frames
  unsigned int start_frames;
  // frames_played
  unsigned int frames_played;
  // frames_played_dmp
  unsigned int frames_played_dmp;
  // current_sample_rate
  unsigned int current_sample_rate;
  // supported_rates
  unsigned int supported_rates[16l];
  // default_sample_rate
  unsigned int default_sample_rate;
  // error_opening
  _Bool error_opening;
  // device_frames
  unsigned int device_frames;
  // updated
  unsigned int updated;
  // track_start_time
  unsigned int track_start_time;
  // current_replay_gain
  unsigned int current_replay_gain;
  // _anon0
  union anonymous_2 _anon0;
  // next_sample_rate
  unsigned int next_sample_rate;
  // track_start
  unsigned char *track_start;
  // gainL
  unsigned int gainL;
  // gainR
  unsigned int gainR;
  // invert
  _Bool invert;
  // next_replay_gain
  unsigned int next_replay_gain;
  // threshold
  unsigned int threshold;
  // fade
  enum anonymous_3 fade;
  // fade_start
  unsigned char *fade_start;
  // fade_end
  unsigned char *fade_end;
  // fade_dir
  enum anonymous_4 fade_dir;
  // fade_mode
  enum anonymous_5 fade_mode;
  // fade_secs
  unsigned int fade_secs;
  // rate_delay
  unsigned int rate_delay;
  // delay_active
  _Bool delay_active;
  // stop_time
  unsigned int stop_time;
  // idle_to
  unsigned int idle_to;
  // next_dop
  _Bool next_dop;
  // dop
  _Bool dop;
  // has_dop
  _Bool has_dop;
  // dop_delay
  unsigned int dop_delay;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

struct processstate
{
  // inbuf
  unsigned char *inbuf;
  // outbuf
  unsigned char *outbuf;
  // max_in_frames
  unsigned int max_in_frames;
  // max_out_frames
  unsigned int max_out_frames;
  // in_frames
  unsigned int in_frames;
  // out_frames
  unsigned int out_frames;
  // in_sample_rate
  unsigned int in_sample_rate;
  // out_sample_rate
  unsigned int out_sample_rate;
  // total_in
  unsigned long int total_in;
  // total_out
  unsigned long int total_out;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct serv_packet
{
  // opcode
  char opcode[4l];
  // server_ip
  unsigned int server_ip;
} __attribute__ ((__packed__));

struct setd_packet
{
  // opcode
  char opcode[4l];
  // id
  unsigned char id;
  // data
  char data[0l];
} __attribute__ ((__packed__));

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct soxr
{
  // resampler
  struct soxr *resampler;
  // old_clips
  unsigned long int old_clips;
  // q_recipe
  unsigned long int q_recipe;
  // q_flags
  unsigned long int q_flags;
  // q_precision
  double q_precision;
  // q_phase_response
  double q_phase_response;
  // q_passband_end
  double q_passband_end;
  // q_stopband_begin
  double q_stopband_begin;
  // scale
  double scale;
  // max_rate
  _Bool max_rate;
  // exception
  _Bool exception;
};

struct soxr_io_spec
{
  // itype
  enum anonymous_10 itype;
  // otype
  enum anonymous_10 otype;
  // scale
  double scale;
  // e
  void *e;
  // flags
  unsigned long int flags;
};

struct soxr_quality_spec
{
  // precision
  double precision;
  // phase_response
  double phase_response;
  // passband_end
  double passband_end;
  // stopband_begin
  double stopband_begin;
  // e
  void *e;
  // flags
  unsigned long int flags;
};

struct soxr_runtime_spec
{
  // log2_min_dft_size
  unsigned int log2_min_dft_size;
  // log2_large_dft_size
  unsigned int log2_large_dft_size;
  // coef_size_kbytes
  unsigned int coef_size_kbytes;
  // num_threads
  unsigned int num_threads;
  // e
  void *e;
  // flags
  unsigned long int flags;
};

struct streamstate
{
  // state
  enum anonymous_14 state;
  // disconnect
  enum anonymous_0 disconnect;
  // header
  char *header;
  // header_len
  unsigned long int header_len;
  // sent_headers
  _Bool sent_headers;
  // cont_wait
  _Bool cont_wait;
  // bytes
  unsigned long int bytes;
  // threshold
  unsigned int threshold;
  // meta_interval
  unsigned int meta_interval;
  // meta_next
  unsigned int meta_next;
  // meta_left
  unsigned int meta_left;
  // meta_send
  _Bool meta_send;
};

struct strm_packet
{
  // opcode
  char opcode[4l];
  // command
  char command;
  // autostart
  unsigned char autostart;
  // format
  unsigned char format;
  // pcm_sample_size
  unsigned char pcm_sample_size;
  // pcm_sample_rate
  unsigned char pcm_sample_rate;
  // pcm_channels
  unsigned char pcm_channels;
  // pcm_endianness
  unsigned char pcm_endianness;
  // threshold
  unsigned char threshold;
  // spdif_enable
  unsigned char spdif_enable;
  // transition_period
  unsigned char transition_period;
  // transition_type
  unsigned char transition_type;
  // flags
  unsigned char flags;
  // output_threshold
  unsigned char output_threshold;
  // slaves
  unsigned char slaves;
  // replay_gain
  unsigned int replay_gain;
  // server_port
  unsigned short int server_port;
  // server_ip
  unsigned int server_ip;
} __attribute__ ((__packed__));

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct vis_t
{
  // rwlock
  union anonymous_18 rwlock;
  // buf_size
  unsigned int buf_size;
  // buf_index
  unsigned int buf_index;
  // running
  _Bool running;
  // rate
  unsigned int rate;
  // updated
  signed long int updated;
  // buffer
  signed short int buffer[16384l];
};

struct vorbis
{
  // vf
  struct OggVorbis_File *vf;
  // opened
  _Bool opened;
};

struct vorbis_comment
{
  // user_comments
  char **user_comments;
  // comment_lengths
  signed int *comment_lengths;
  // comments
  signed int comments;
  // vendor
  char *vendor;
};

struct vorbis_info
{
  // version
  signed int version;
  // channels
  signed int channels;
  // rate
  signed long int rate;
  // bitrate_upper
  signed long int bitrate_upper;
  // bitrate_nominal
  signed long int bitrate_nominal;
  // bitrate_lower
  signed long int bitrate_lower;
  // bitrate_window
  signed long int bitrate_window;
  // codec_setup
  void *codec_setup;
};


// FLAC__StreamDecoderErrorStatusString
// file /usr/include/FLAC/stream_decoder.h line 448
extern const char * const FLAC__StreamDecoderErrorStatusString[];
// FLAC__StreamDecoderStateString
// file /usr/include/FLAC/stream_decoder.h line 251
extern const char * const FLAC__StreamDecoderStateString[];
// a
// file faad.c line 58
static struct faad *a;
// audio_left
// file pcm.c line 63
static unsigned int audio_left;
// autostart
// file slimproto.c line 81
signed int autostart;
// bigendian
// file pcm.c line 61
static _Bool bigendian;
// buf
// file stream.c line 29
static struct buffer buf;
// buf_link1
// file output.c line 29
static struct buffer buf_link1;
// buf_link2
// file output_stdout.c line 43
static unsigned char *buf_link2;
// buffill
// file output_stdout.c line 44
static unsigned int buffill;
// bytes_per_frame
// file output_stdout.c line 45
static signed int bytes_per_frame;
// bytes_per_frame_link1
// file pcm.c line 64
static unsigned int bytes_per_frame_link1;
// channels
// file pcm.c line 60
static unsigned int channels;
// cmdmap
// file ir.c line 68
static struct anonymous_24 cmdmap[11l] = { { .cmd="voldown", .code=(unsigned int)0x768900ff },
    { .cmd="volup", .code=(unsigned int)0x7689807f },
    { .cmd="rew", .code=(unsigned int)0x7689c03f },
    { .cmd="fwd", .code=(unsigned int)0x7689a05f },
    { .cmd="pause", .code=(unsigned int)0x768920df },
    { .cmd="play", .code=(unsigned int)0x768910ef },
    { .cmd="power", .code=(unsigned int)0x768940bf },
    { .cmd="muting", .code=(unsigned int)0x7689c43b },
    { .cmd="power_on", .code=(unsigned int)0x76898f70 },
    { .cmd="power_off", .code=(unsigned int)0x76898778 },
    { .cmd=(char *)(void *)0, .code=(unsigned int)0 } };
// codec
// file decode.c line 35
struct codec *codec;
// codecs
// file decode.c line 34
struct codec *codecs[9l];
// config
// file ir.c line 35
static struct lirc_config *config = (struct lirc_config *)(void *)0;
// ctables
// file dsd2pcm/dsd2pcm.c line 122
static float ctables[6l][256l];
// d
// file dsd.c line 79
static struct dsd *d;
// decode
// file decode.c line 33
struct decodestate decode;
// dop
// file dsd.c line 65
static _Bool dop = (_Bool)0;
// dsd2pcm_bitreverse
// file dsd2pcm/dsd2pcm.c line 123
unsigned char dsd2pcm_bitreverse[256l];
// f
// file flac.c line 51
static struct flac *f;
// fd
// file stream.c line 35
static signed int fd;
// fd_link1
// file ir.c line 36
static signed int fd_link1 = -1;
// ff
// file ffmpeg.c line 81
static struct ff_s *ff;
// ff_log_level
// file ffmpeg.c line 659
static signed int ff_log_level = 0;
// file_props_guid
// file ffmpeg.c line 130
const unsigned char file_props_guid[16l] = { (const unsigned char)0xA1, (const unsigned char)0xDC, (const unsigned char)0xAB, (const unsigned char)0x8C, (const unsigned char)0x47, (const unsigned char)0xA9, (const unsigned char)0xCF, (const unsigned char)0x11, (const unsigned char)0x8E, (const unsigned char)0xE4, (const unsigned char)0x00, (const unsigned char)0xC0, (const unsigned char)0x0C, (const unsigned char)0x20, (const unsigned char)0x53, (const unsigned char)0x65 };
// handlers
// file slimproto.c line 478
static struct handler handlers[8l];
// handlers
// file slimproto.c line 478
static struct handler handlers[8l] = { { .opcode={ 's', 't', 'r', 'm', 0 }, .handler=process_strm },
    { .opcode={ 'c', 'o', 'n', 't', 0 }, .handler=process_cont },
    { .opcode={ 'c', 'o', 'd', 'c', 0 }, .handler=process_codc },
    { .opcode={ 'a', 'u', 'd', 'e', 0 }, .handler=process_aude },
    { .opcode={ 'a', 'u', 'd', 'g', 0 }, .handler=process_audg },
    { .opcode={ 's', 'e', 't', 'd', 0 }, .handler=process_setd },
    { .opcode={ 's', 'e', 'r', 'v', 0 }, .handler=process_serv },
    { .opcode={ 0, 0, 0, 0, 0 }, .handler=(void (*)(unsigned char *, signed int))(void *)0 } };
// header_guid
// file ffmpeg.c line 129
const unsigned char header_guid[16l] = { (const unsigned char)0x30, (const unsigned char)0x26, (const unsigned char)0xB2, (const unsigned char)0x75, (const unsigned char)0x8E, (const unsigned char)0x66, (const unsigned char)0xCF, (const unsigned char)0x11, (const unsigned char)0xA6, (const unsigned char)0xD9, (const unsigned char)0x00, (const unsigned char)0xAA, (const unsigned char)0x00, (const unsigned char)0x62, (const unsigned char)0xCE, (const unsigned char)0x6C };
// htaps
// file dsd2pcm/dsd2pcm.c line 71
static const double htaps[48l] = { 0.09950731974056658, 0.09562845727714668, 0.08819647126516944, 0.07782552527068175, 0.06534876523171299, 0.05172629311427257, 0.0379429484910187, 0.02490921351762261, 0.0133774746265897, 0.003883043418804416, -0.003284703416210726, -0.008080250212687497, -0.01067241812471033, -0.01139427235000863, -0.0106813877974587, -0.009007905078766049, -0.006828859761015335, -0.004535184322001496, -0.002425035959059578, -0.0006922187080790708, 0.0005700762133516592, 0.001353838005269448, 0.001713709169690937, 0.001742046839472948, 0.001545601648013235, 0.001226696225277855, 0.0008704322683580222, 0.0005381636200535649, 0.000266446345425276, 7.002968738383528e-05, -5.279407053811266e-05, -0.0001140625650874684, -0.0001304796361231895, -0.0001189970287491285, -9.396247155265073e-05, -6.577634378272832e-05, -4.07492895872535e-05, -2.17407957554587e-05, -9.163058931391722e-06, -2.017460145032201e-06, 1.249721855219005e-06, 2.166655190537392e-06, 1.930520892991082e-06, 1.319400334374195e-06, 7.410039764949091e-07, 3.423230509967409e-07, 1.244182214744588e-07, 3.130441005359396e-08 };
// ir
// file ir.c line 33
struct irstate ir;
// keymap
// file ir.c line 87
static struct anonymous_25 keymap[11l] = { { .lirc="KEY_VOLUMEDOWN", .code=(unsigned int)0x768900ff, .repeat=(_Bool)1 },
    { .lirc="KEY_VOLUMEUP", .code=(unsigned int)0x7689807f, .repeat=(_Bool)1 },
    { .lirc="KEY_PREVIOUS", .code=(unsigned int)0x7689c03f, .repeat=(_Bool)0 },
    { .lirc="KEY_REWIND", .code=(unsigned int)0x7689c03f, .repeat=(_Bool)0 },
    { .lirc="KEY_NEXT", .code=(unsigned int)0x7689a05f, .repeat=(_Bool)0 },
    { .lirc="KEY_FORWARD", .code=(unsigned int)0x7689a05f, .repeat=(_Bool)0 },
    { .lirc="KEY_PAUSE", .code=(unsigned int)0x768920df, .repeat=(_Bool)1 },
    { .lirc="KEY_PLAY", .code=(unsigned int)0x768910ef, .repeat=(_Bool)0 },
    { .lirc="KEY_POWER", .code=(unsigned int)0x768940bf, .repeat=(_Bool)0 },
    { .lirc="KEY_MUTE", .code=(unsigned int)0x7689c43b, .repeat=(_Bool)0 },
    { .lirc=(char *)(void *)0, .code=(unsigned int)0, .repeat=(_Bool)0 } };
// limit
// file pcm.c line 62
static _Bool limit;
// loglevel
// file slimproto.c line 24
static enum anonymous_8 loglevel;
// loglevel_link1
// file stream.c line 27
static enum anonymous_8 loglevel_link1;
// loglevel_link10
// file faad.c line 60
extern enum anonymous_8 loglevel_link10;
// loglevel_link11
// file mpg.c line 49
extern enum anonymous_8 loglevel_link11;
// loglevel_link12
// file dsd.c line 30
extern enum anonymous_8 loglevel_link12;
// loglevel_link13
// file ffmpeg.c line 83
extern enum anonymous_8 loglevel_link13;
// loglevel_link14
// file process.c line 27
extern enum anonymous_8 loglevel_link14;
// loglevel_link15
// file resample.c line 30
extern enum anonymous_8 loglevel_link15;
// loglevel_link16
// file output_vis.c line 47
static enum anonymous_8 loglevel_link16;
// loglevel_link17
// file ir.c line 31
static enum anonymous_8 loglevel_link17;
// loglevel_link2
// file output.c line 25
static enum anonymous_8 loglevel_link2;
// loglevel_link3
// file output_pa.c line 38
static enum anonymous_8 loglevel_link3;
// loglevel_link4
// file output_stdout.c line 27
static enum anonymous_8 loglevel_link4;
// loglevel_link5
// file decode.c line 25
enum anonymous_8 loglevel_link5;
// loglevel_link6
// file flac.c line 53
extern enum anonymous_8 loglevel_link6;
// loglevel_link7
// file pcm.c line 23
extern enum anonymous_8 loglevel_link7;
// loglevel_link8
// file mad.c line 58
extern enum anonymous_8 loglevel_link8;
// loglevel_link9
// file vorbis.c line 47
extern enum anonymous_8 loglevel_link9;
// m
// file mad.c line 56
static struct mad *m;
// m_link1
// file mpg.c line 47
static struct mpg *m_link1;
// monitor_thread
// file output_pa.c line 157
static unsigned long int monitor_thread;
// monitor_thread_running
// file output_pa.c line 158
_Bool monitor_thread_running = (_Bool)0;
// name_file
// file slimproto.c line 87
const char *name_file = (const char *)(void *)0;
// new_server
// file slimproto.c line 83
unsigned int new_server;
// new_server_cap
// file slimproto.c line 84
char *new_server_cap;
// optr
// file output_pa.c line 300
static unsigned char *optr;
// output
// file output.c line 27
struct outputstate output;
// outputbuf
// file output.c line 31
struct buffer *outputbuf;
// outputbuf
// file output.c line 31
struct buffer *outputbuf = &buf_link1;
// pa
// file output_pa.c line 36
static struct anonymous_11 pa;
// player_name
// file slimproto.c line 86
char player_name[65l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// precalculated
// file dsd2pcm/dsd2pcm.c line 124
static signed int precalculated = 0;
// process_link1
// file decode.c line 31
extern struct processstate process_link1;
// process_link10
// file process.c line 31
struct processstate process_link10;
// process_link2
// file flac.c line 60
extern struct processstate process_link2;
// process_link3
// file pcm.c line 30
extern struct processstate process_link3;
// process_link4
// file mad.c line 65
extern struct processstate process_link4;
// process_link5
// file vorbis.c line 54
extern struct processstate process_link5;
// process_link6
// file faad.c line 67
extern struct processstate process_link6;
// process_link7
// file mpg.c line 56
extern struct processstate process_link7;
// process_link8
// file dsd.c line 37
extern struct processstate process_link8;
// process_link9
// file ffmpeg.c line 90
extern struct processstate process_link9;
// r
// file resample.c line 60
static struct soxr *r;
// registered
// file ffmpeg.c line 668
static _Bool registered = (_Bool)0;
// running
// file slimproto.c line 502
static _Bool running;
// running_link1
// file stream.c line 67
static _Bool running_link1 = (_Bool)1;
// running_link2
// file output_pa.c line 40
static _Bool running_link2 = (_Bool)1;
// running_link3
// file output_stdout.c line 29
static _Bool running_link3 = (_Bool)1;
// running_link4
// file decode.c line 36
static _Bool running_link4 = (_Bool)1;
// sample_rate
// file pcm.c line 58
static unsigned int sample_rate;
// sample_rates
// file pcm.c line 54
static unsigned int sample_rates[15l] = { (unsigned int)11025, (unsigned int)22050, (unsigned int)32000, (unsigned int)44100, (unsigned int)48000, (unsigned int)8000, (unsigned int)12000, (unsigned int)16000, (unsigned int)24000, (unsigned int)96000, (unsigned int)88200, (unsigned int)176400, (unsigned int)192000, (unsigned int)352800, (unsigned int)384000 };
// sample_size
// file pcm.c line 59
static unsigned int sample_size;
// sentSTMl
// file slimproto.c line 82
_Bool sentSTMl;
// sentSTMo
// file slimproto.c line 82
_Bool sentSTMo;
// sentSTMu
// file slimproto.c line 82
_Bool sentSTMu;
// silencebuf
// file output.c line 33
unsigned char *silencebuf;
// silencebuf_dop
// file output.c line 35
unsigned char *silencebuf_dop;
// slimproto_ip
// file slimproto.c line 39
static unsigned int slimproto_ip = (unsigned int)0;
// sock
// file slimproto.c line 38
static signed int sock = -1;
// status
// file slimproto.c line 79
static struct anonymous_27 status;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// stream
// file stream.c line 37
struct streamstate stream;
// streambuf
// file stream.c line 30
struct buffer *streambuf;
// streambuf
// file stream.c line 30
struct buffer *streambuf = &buf;
// thread
// file stream.c line 285
static unsigned long int thread;
// thread_link1
// file output_stdout.c line 121
static unsigned long int thread_link1;
// thread_link2
// file decode.c line 122
static unsigned long int thread_link2;
// thread_link3
// file ir.c line 38
static unsigned long int thread_link3;
// v
// file vorbis.c line 45
static struct vorbis *v;
// vis_fd
// file output_vis.c line 45
static signed int vis_fd = -1;
// vis_mmap
// file output_vis.c line 42
static struct vis_t *vis_mmap = (struct vis_t *)(void *)0;
// vis_shm_path
// file output_vis.c line 44
static char vis_shm_path[40l];
// wake_e
// file slimproto.c line 53
signed int wake_e;

// _apply_cross
// file squeezelite.h line 619
inline void _apply_cross(struct buffer *outputbuf, unsigned int out_frames, signed int cross_gain_in, signed int cross_gain_out, signed int **cross_ptr)
{
  signed int *ptr = (signed int *)(void *)outputbuf->readp;
  unsigned int count = out_frames * (unsigned int)2;
  unsigned int tmp_post_1;
  do
  {
    tmp_post_1 = count;
    count = count - 1u;
    if(tmp_post_1 == 0u)
      break;

    if(!((signed int *)outputbuf->wrap >= *cross_ptr))
      *cross_ptr = *cross_ptr - (signed long int)((outputbuf->size / (unsigned long int)8) * (unsigned long int)2);

    signed int return_value_gain_2;
    return_value_gain_2=gain(cross_gain_out, *ptr);
    signed int return_value_gain_3;
    return_value_gain_3=gain(cross_gain_in, *(*cross_ptr));
    *ptr = return_value_gain_2 + return_value_gain_3;
    ptr = ptr + 1l;
    *cross_ptr = *cross_ptr + 1l;
  }
  while((_Bool)1);
}

// _apply_gain
// file squeezelite.h line 620
inline void _apply_gain(struct buffer *outputbuf, unsigned int count, signed int gainL, signed int gainR)
{
  signed int *ptrL = (signed int *)(void *)outputbuf->readp;
  signed int *ptrR = (signed int *)(void *)outputbuf->readp + (signed long int)1;
  unsigned int tmp_post_1;
  do
  {
    tmp_post_1 = count;
    count = count - 1u;
    if(tmp_post_1 == 0u)
      break;

    *ptrL=gain(gainL, *ptrL);
    *ptrR=gain(gainR, *ptrR);
    ptrL = ptrL + (signed long int)2;
    ptrR = ptrR + (signed long int)2;
  }
  while((_Bool)1);
}

// _buf_cont_read
// file buffer.c line 37
unsigned int _buf_cont_read(struct buffer *buf)
{
  signed long int tmp_if_expr_1;
  if(buf->writep >= buf->readp)
    tmp_if_expr_1 = buf->writep - buf->readp;

  else
    tmp_if_expr_1 = buf->wrap - buf->readp;
  return (unsigned int)tmp_if_expr_1;
}

// _buf_cont_write
// file buffer.c line 41
unsigned int _buf_cont_write(struct buffer *buf)
{
  signed long int tmp_if_expr_1;
  if(buf->writep >= buf->readp)
    tmp_if_expr_1 = buf->wrap - buf->writep;

  else
    tmp_if_expr_1 = buf->readp - buf->writep;
  return (unsigned int)tmp_if_expr_1;
}

// _buf_inc_readp
// file buffer.c line 45
void _buf_inc_readp(struct buffer *buf, unsigned int by)
{
  buf->readp = buf->readp + (signed long int)by;
  if(buf->readp >= buf->wrap)
    buf->readp = buf->readp - (signed long int)buf->size;

}

// _buf_inc_writep
// file buffer.c line 52
void _buf_inc_writep(struct buffer *buf, unsigned int by)
{
  buf->writep = buf->writep + (signed long int)by;
  if(buf->writep >= buf->wrap)
    buf->writep = buf->writep - (signed long int)buf->size;

}

// _buf_resize
// file buffer.c line 79
void _buf_resize(struct buffer *buf, unsigned long int size)
{
  free((void *)buf->buf);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(size);
  buf->buf = (unsigned char *)return_value_malloc_1;
  if(buf->buf == ((unsigned char *)NULL))
  {
    size = buf->size;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(size);
    buf->buf = (unsigned char *)return_value_malloc_2;
    if(buf->buf == ((unsigned char *)NULL))
      size = (unsigned long int)0;

  }

  buf->readp = buf->buf;
  buf->writep = buf->buf;
  buf->wrap = buf->buf + (signed long int)size;
  buf->size = size;
  buf->base_size = size;
}

// _buf_space
// file buffer.c line 33
unsigned int _buf_space(struct buffer *buf)
{
  unsigned int return_value__buf_used_1;
  return_value__buf_used_1=_buf_used(buf);
  return (unsigned int)((buf->size - (unsigned long int)return_value__buf_used_1) - (unsigned long int)1);
}

// _buf_used
// file squeezelite.h line 416
inline unsigned int _buf_used(struct buffer *buf)
{
  unsigned long int tmp_if_expr_1;
  if(buf->writep >= buf->readp)
    tmp_if_expr_1 = (unsigned long int)(buf->writep - buf->readp);

  else
    tmp_if_expr_1 = buf->size - (unsigned long int)(buf->readp - buf->writep);
  return (unsigned int)tmp_if_expr_1;
}

// _check_header
// file pcm.c line 68
static void _check_header(void)
{
  unsigned char *ptr = streambuf->readp;
  unsigned int bytes;
  unsigned int return_value__buf_used_1;
  return_value__buf_used_1=_buf_used(streambuf);
  unsigned int return_value__buf_cont_read_2;
  return_value__buf_cont_read_2=_buf_cont_read(streambuf);
  unsigned int tmp_if_expr_5;
  unsigned int return_value__buf_used_3;
  unsigned int return_value__buf_cont_read_4;
  if(!(return_value__buf_used_1 >= return_value__buf_cont_read_2))
  {
    return_value__buf_used_3=_buf_used(streambuf);
    tmp_if_expr_5 = return_value__buf_used_3;
  }

  else
  {
    return_value__buf_cont_read_4=_buf_cont_read(streambuf);
    tmp_if_expr_5 = return_value__buf_cont_read_4;
  }
  bytes = tmp_if_expr_5;
  enum anonymous_71 format = (enum anonymous_71)UNKNOWN;
  signed int return_value_memcmp_13;
  const char *return_value_logtime_6;
  signed int return_value_memcmp_11;
  signed int return_value_memcmp_8;
  signed int return_value_memcmp_9;
  const char *return_value_logtime_7;
  if(bytes >= 13u)
  {
    signed int return_value_memcmp_12;
    return_value_memcmp_12=memcmp((const void *)ptr, (const void *)"RIFF", (unsigned long int)4);
    _Bool tmp_if_expr_14;
    if(return_value_memcmp_12 == 0)
    {
      return_value_memcmp_13=memcmp((const void *)(ptr + (signed long int)8), (const void *)"WAVE", (unsigned long int)4);
      tmp_if_expr_14 = !(return_value_memcmp_13 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_14 = (_Bool)0;
    if(tmp_if_expr_14)
    {
      if((signed int)loglevel_link7 >= lINFO)
      {
        return_value_logtime_6=logtime();
        logprint("%s %s:%d WAVE\n", return_value_logtime_6, (const void *)"_check_header", 77);
      }

      format = (enum anonymous_71)WAVE;
    }

    else
    {
      return_value_memcmp_11=memcmp((const void *)ptr, (const void *)"FORM", (unsigned long int)4);
      if(return_value_memcmp_11 == 0)
      {
        return_value_memcmp_8=memcmp((const void *)(ptr + (signed long int)8), (const void *)"AIFF", (unsigned long int)4);
        _Bool tmp_if_expr_10;
        if(return_value_memcmp_8 == 0)
          tmp_if_expr_10 = (_Bool)1;

        else
        {
          return_value_memcmp_9=memcmp((const void *)(ptr + (signed long int)8), (const void *)"AIFC", (unsigned long int)4);
          tmp_if_expr_10 = !(return_value_memcmp_9 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_10)
        {
          if((signed int)loglevel_link7 >= lINFO)
          {
            return_value_logtime_7=logtime();
            logprint("%s %s:%d AIFF\n", return_value_logtime_7, (const void *)"_check_header", 80);
          }

          format = (enum anonymous_71)AIFF;
        }

      }

    }
  }

  const char *return_value_logtime_15;
  signed int return_value_memcmp_17;
  const char *return_value_logtime_16;
  signed int return_value_memcmp_19;
  const char *return_value_logtime_18;
  signed int return_value_memcmp_21;
  const char *return_value_logtime_20;
  signed int return_value_memcmp_23;
  const char *return_value_logtime_22;
  const char *return_value_logtime_24;
  const char *return_value_logtime_25;
  if(!((signed int)format == UNKNOWN))
  {
    ptr = ptr + (signed long int)12;
    bytes = bytes - (unsigned int)12;
    while(bytes >= 8u)
    {
      char id[5l];
      unsigned int len;
      memcpy((void *)id, (const void *)ptr, (unsigned long int)4);
      id[(signed long int)4] = (char)0;
      if((signed int)format == WAVE)
        len = (unsigned int)((signed int)ptr[(signed long int)4] | (signed int)ptr[(signed long int)5] << 8 | (signed int)ptr[(signed long int)6] << 16 | (signed int)ptr[(signed long int)7] << 24);

      else
        len = (unsigned int)((signed int)ptr[(signed long int)4] << 24 | (signed int)ptr[(signed long int)5] << 16 | (signed int)ptr[(signed long int)6] << 8 | (signed int)ptr[(signed long int)7]);
      if((signed int)loglevel_link7 >= lINFO)
      {
        return_value_logtime_15=logtime();
        logprint("%s %s:%d header: %s len: %d\n", return_value_logtime_15, (const void *)"_check_header", 101, (const void *)id, len);
      }

      if((signed int)format == WAVE)
      {
        return_value_memcmp_17=memcmp((const void *)ptr, (const void *)"data", (unsigned long int)4);
        if(return_value_memcmp_17 == 0)
        {
          ptr = ptr + (signed long int)8;
          _buf_inc_readp(streambuf, (unsigned int)(ptr - streambuf->readp));
          audio_left = len;
          if((signed int)loglevel_link7 >= lINFO)
          {
            return_value_logtime_16=logtime();
            logprint("%s %s:%d audio size: %u\n", return_value_logtime_16, (const void *)"_check_header", 107, audio_left);
          }

          limit = (_Bool)1;
          goto __CPROVER_DUMP_L40;
        }

      }

      if((signed int)format == AIFF)
      {
        return_value_memcmp_19=memcmp((const void *)ptr, (const void *)"SSND", (unsigned long int)4);
        if(return_value_memcmp_19 == 0)
        {
          if(bytes >= 16u)
          {
            unsigned int offset = (unsigned int)((signed int)ptr[(signed long int)8] << 24 | (signed int)ptr[(signed long int)9] << 16 | (signed int)ptr[(signed long int)10] << 8 | (signed int)ptr[(signed long int)11]);
            ptr = ptr + (signed long int)(8 + 8);
            _buf_inc_readp(streambuf, (unsigned int)((ptr + (signed long int)offset) - streambuf->readp));
            audio_left = (len - (unsigned int)8) - offset;
            if((signed int)loglevel_link7 >= lINFO)
            {
              return_value_logtime_18=logtime();
              logprint("%s %s:%d audio size: %u\n", return_value_logtime_18, (const void *)"_check_header", 118, audio_left);
            }

            limit = (_Bool)1;
            goto __CPROVER_DUMP_L40;
          }

        }

      }

      if((signed int)format == WAVE)
      {
        return_value_memcmp_21=memcmp((const void *)ptr, (const void *)"fmt ", (unsigned long int)4);
        if(return_value_memcmp_21 == 0)
        {
          if(bytes >= 24u)
          {
            channels = (unsigned int)((signed int)ptr[(signed long int)10] | (signed int)ptr[(signed long int)11] << 8);
            sample_rate = (unsigned int)((signed int)ptr[(signed long int)12] | (signed int)ptr[(signed long int)13] << 8 | (signed int)ptr[(signed long int)14] << 16 | (signed int)ptr[(signed long int)15] << 24);
            sample_size = (unsigned int)(((signed int)ptr[(signed long int)22] | (signed int)ptr[(signed long int)23] << 8) / 8);
            bigendian = (_Bool)0;
            if((signed int)loglevel_link7 >= lINFO)
            {
              return_value_logtime_20=logtime();
              logprint("%s %s:%d pcm size: %u rate: %u chan: %u bigendian: %u\n", return_value_logtime_20, (const void *)"_check_header", 129, sample_size, sample_rate, channels, bigendian);
            }

          }

        }

      }

      if((signed int)format == AIFF)
      {
        return_value_memcmp_23=memcmp((const void *)ptr, (const void *)"COMM", (unsigned long int)4);
        if(return_value_memcmp_23 == 0)
        {
          if(bytes >= 26u)
          {
            signed int exponent;
            channels = (unsigned int)((signed int)ptr[(signed long int)8] << 8 | (signed int)ptr[(signed long int)9]);
            sample_size = (unsigned int)(((signed int)ptr[(signed long int)14] << 8 | (signed int)ptr[(signed long int)15]) / 8);
            bigendian = (_Bool)1;
            exponent = ((((signed int)ptr[(signed long int)16] & 0x7f) << 8 | (signed int)ptr[(signed long int)17]) - 16383) - 31;
            sample_rate = (unsigned int)((signed int)ptr[(signed long int)18] << 24 | (signed int)ptr[(signed long int)19] << 16 | (signed int)ptr[(signed long int)20] << 8 | (signed int)ptr[(signed long int)21]);
            for( ; !(exponent >= 0); exponent = exponent + 1)
              sample_rate = sample_rate >> 1;
            for( ; exponent >= 1; exponent = exponent - 1)
              sample_rate = sample_rate << 1;
            if((signed int)loglevel_link7 >= lINFO)
            {
              return_value_logtime_22=logtime();
              logprint("%s %s:%d pcm size: %u rate: %u chan: %u bigendian: %u\n", return_value_logtime_22, (const void *)"_check_header", 144, sample_size, sample_rate, channels, bigendian);
            }

          }

        }

      }

      if(bytes >= 8u + len)
      {
        ptr = ptr + (signed long int)(len + (unsigned int)8);
        bytes = bytes - (len + (unsigned int)8);
      }

      else
      {
        if((signed int)loglevel_link7 >= lWARN)
        {
          return_value_logtime_24=logtime();
          logprint("%s %s:%d run out of data\n", return_value_logtime_24, (const void *)"_check_header", 151);
        }

        goto __CPROVER_DUMP_L40;
      }
    }
  }

  else
    if((signed int)loglevel_link7 >= lWARN)
    {
      return_value_logtime_25=logtime();
      logprint("%s %s:%d unknown format - can't parse header\n", return_value_logtime_25, (const void *)"_check_header", 157);
    }


__CPROVER_DUMP_L40:
  ;
}

// _check_id3_tag
// file mad.c line 102
static unsigned int _check_id3_tag(unsigned long int bytes)
{
  unsigned char *ptr = streambuf->readp;
  unsigned int size = (unsigned int)0;
  const char *return_value_logtime_1;
  if(bytes >= 11ul)
  {
    if((signed int)*ptr == 73)
    {
      if((signed int)ptr[1l] == 68)
      {
        if((signed int)ptr[2l] == 51)
        {
          if(!((signed int)ptr[6l] >= 0x80))
          {
            if(!((signed int)ptr[7l] >= 0x80))
            {
              if(!((signed int)ptr[8l] >= 0x80))
              {
                if(!((signed int)ptr[9l] >= 0x80))
                {
                  size = (unsigned int)(10 + ((signed int)ptr[(signed long int)6] << 21) + ((signed int)ptr[(signed long int)7] << 14) + ((signed int)ptr[(signed long int)8] << 7) + (signed int)ptr[(signed long int)9] + (((signed int)ptr[(signed long int)5] & 0x10) != 0 ? 10 : 0));
                  if((signed int)loglevel_link8 >= lDEBUG)
                  {
                    return_value_logtime_1=logtime();
                    logprint("%s %s:%d id3.2 tag len: %u\n", return_value_logtime_1, (const void *)"_check_id3_tag", 110, size);
                  }

                }

              }

            }

          }

        }

      }

    }

  }

  return size;
}

// _check_lame_header
// file mad.c line 118
static void _check_lame_header(unsigned long int bytes)
{
  unsigned char *ptr = streambuf->readp;
  signed int return_value_memcmp_5;
  signed int return_value_memcmp_1;
  signed int return_value_memcmp_2;
  const char *return_value_logtime_8;
  if((signed int)*ptr == 0xff)
  {
    if((0xf0 & (signed int)ptr[1l]) == 0xf0)
    {
      if(bytes >= 181ul)
      {
        unsigned int frame_count = (unsigned int)0;
        unsigned int enc_delay = (unsigned int)0;
        unsigned int enc_padding = (unsigned int)0;
        unsigned char flags;
        signed int return_value_memcmp_4;
        return_value_memcmp_4=memcmp((const void *)(ptr + (signed long int)36), (const void *)"Xing", (unsigned long int)4);
        _Bool tmp_if_expr_6;
        if(return_value_memcmp_4 == 0)
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value_memcmp_5=memcmp((const void *)(ptr + (signed long int)36), (const void *)"Info", (unsigned long int)4);
          tmp_if_expr_6 = !(return_value_memcmp_5 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
          ptr = ptr + (signed long int)(36 + 7);

        else
        {
          return_value_memcmp_1=memcmp((const void *)(ptr + (signed long int)21), (const void *)"Xing", (unsigned long int)4);
          _Bool tmp_if_expr_3;
          if(return_value_memcmp_1 == 0)
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value_memcmp_2=memcmp((const void *)(ptr + (signed long int)21), (const void *)"Info", (unsigned long int)4);
            tmp_if_expr_3 = !(return_value_memcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_3)
            ptr = ptr + (signed long int)(21 + 7);

        }
        flags = *ptr;
        if(!((0x01 & (signed int)flags) == 0))
        {
          frame_count=unpackN((unsigned int *)(ptr + (signed long int)1));
          ptr = ptr + (signed long int)4;
        }

        if(!((0x02 & (signed int)flags) == 0))
          ptr = ptr + (signed long int)4;

        if(!((0x04 & (signed int)flags) == 0))
          ptr = ptr + (signed long int)100;

        if(!((0x08 & (signed int)flags) == 0))
          ptr = ptr + (signed long int)4;

        signed int return_value_memcmp_7;
        return_value_memcmp_7=memcmp((const void *)(ptr + (signed long int)1), (const void *)"LAME", (unsigned long int)4);
        if(!(return_value_memcmp_7 == 0))
          goto __CPROVER_DUMP_L15;

        ptr = ptr + (signed long int)22;
        enc_delay = (unsigned int)(((signed int)*ptr << 4 | (signed int)ptr[(signed long int)1] >> 4) + 529);
        enc_padding = (unsigned int)(((signed int)ptr[(signed long int)1] & 0xF) << 8 | (signed int)ptr[(signed long int)2]);
        enc_padding = enc_padding > (unsigned int)529 ? enc_padding - (unsigned int)529 : (unsigned int)0;
        m->skip = enc_delay + (unsigned int)1152;
        m->samples = (unsigned long int)((frame_count * (unsigned int)1152 - enc_delay) - enc_padding);
        m->padding = enc_padding;
        if((signed int)loglevel_link8 >= lINFO)
        {
          return_value_logtime_8=logtime();
          logprint("%s %s:%d gapless: skip: %u samples: %lu delay: %u padding: %u\n", return_value_logtime_8, (const void *)"_check_lame_header", 159, m->skip, m->samples, enc_delay, enc_padding);
        }

      }

    }

  }


__CPROVER_DUMP_L15:
  ;
}

// _checkfade
// file output.c line 278
void _checkfade(_Bool start)
{
  unsigned int bytes;
  const char *return_value_logtime_1;
  if((signed int)loglevel_link2 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d fade mode: %u duration: %u %s\n", return_value_logtime_1, (const void *)"_checkfade", 281, output.fade_mode, output.fade_secs, start != (_Bool)0 ? "track-start" : "track-end");
  }

  bytes = output.next_sample_rate * (unsigned int)8 * output.fade_secs;
  if((signed int)output.fade_mode == FADE_INOUT)
    bytes = bytes / (unsigned int)2;

  _Bool tmp_if_expr_5;
  unsigned int return_value__buf_used_4;
  const char *return_value_logtime_3;
  if(!(start == (_Bool)0))
  {
    _Bool tmp_if_expr_6;
    if((signed int)output.fade_mode == FADE_IN)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      if((signed int)output.fade_mode == FADE_INOUT)
      {
        return_value__buf_used_4=_buf_used(outputbuf);
        tmp_if_expr_5 = return_value__buf_used_4 == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_5 = (_Bool)0;
      tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      unsigned long int tmp_if_expr_2;
      if(!((unsigned long int)bytes >= outputbuf->size + 18446744073709551608ul))
        tmp_if_expr_2 = (unsigned long int)bytes;

      else
        tmp_if_expr_2 = outputbuf->size - (unsigned long int)8;
      bytes = (unsigned int)tmp_if_expr_2;
      if((signed int)loglevel_link2 >= lINFO)
      {
        return_value_logtime_3=logtime();
        logprint("%s %s:%d fade IN: %u frames\n", return_value_logtime_3, (const void *)"_checkfade", 290, bytes / (unsigned int)8);
      }

      output.fade = (enum anonymous_3)FADE_DUE;
      output.fade_dir = (enum anonymous_4)FADE_UP;
      output.fade_start = outputbuf->writep;
      output.fade_end = output.fade_start + (signed long int)bytes;
      if(output.fade_end >= outputbuf->wrap)
        output.fade_end = output.fade_end - (signed long int)outputbuf->size;

    }

  }

  unsigned int return_value__buf_used_8;
  const char *return_value_logtime_10;
  if(start == (_Bool)0 && ((signed int)output.fade_mode == FADE_OUT || (signed int)output.fade_mode == FADE_INOUT))
  {
    unsigned int return_value__buf_used_7;
    return_value__buf_used_7=_buf_used(outputbuf);
    unsigned int tmp_if_expr_9;
    if(!(return_value__buf_used_7 >= bytes))
    {
      return_value__buf_used_8=_buf_used(outputbuf);
      tmp_if_expr_9 = return_value__buf_used_8;
    }

    else
      tmp_if_expr_9 = bytes;
    bytes = tmp_if_expr_9;
    if((signed int)loglevel_link2 >= lINFO)
    {
      return_value_logtime_10=logtime();
      logprint("%s %s:%d fade %s: %u frames\n", return_value_logtime_10, (const void *)"_checkfade", 302, (signed int)output.fade_mode == FADE_INOUT ? "IN-OUT" : "OUT", bytes / (unsigned int)8);
    }

    output.fade = (enum anonymous_3)FADE_DUE;
    output.fade_dir = (enum anonymous_4)FADE_DOWN;
    output.fade_start = outputbuf->writep - (signed long int)bytes;
    if(!(output.fade_start >= outputbuf->buf))
      output.fade_start = output.fade_start + (signed long int)outputbuf->size;

    output.fade_end = outputbuf->writep;
  }

  const char *return_value_logtime_11;
  unsigned int return_value__buf_used_13;
  const char *return_value_logtime_16;
  const char *return_value_logtime_17;
  if((signed int)output.fade_mode == FADE_CROSSFADE && !(start == (_Bool)0))
  {
    unsigned int return_value__buf_used_18;
    return_value__buf_used_18=_buf_used(outputbuf);
    if(!(return_value__buf_used_18 == 0u))
    {
      if(!(output.next_sample_rate == output.current_sample_rate))
      {
        if((signed int)loglevel_link2 >= lINFO)
        {
          return_value_logtime_11=logtime();
          logprint("%s %s:%d crossfade disabled as sample rates differ\n", return_value_logtime_11, (const void *)"_checkfade", 315);
        }

        goto __CPROVER_DUMP_L30;
      }

      unsigned int return_value__buf_used_12;
      return_value__buf_used_12=_buf_used(outputbuf);
      unsigned int tmp_if_expr_14;
      if(!(bytes >= return_value__buf_used_12))
        tmp_if_expr_14 = bytes;

      else
      {
        return_value__buf_used_13=_buf_used(outputbuf);
        tmp_if_expr_14 = return_value__buf_used_13;
      }
      bytes = tmp_if_expr_14;
      unsigned int tmp_if_expr_15;
      if(!(bytes >= (unsigned int)((double)outputbuf->size * 0.9)))
        tmp_if_expr_15 = bytes;

      else
        tmp_if_expr_15 = (unsigned int)((double)outputbuf->size * 0.9);
      bytes = tmp_if_expr_15;
      if((signed int)loglevel_link2 >= lINFO)
      {
        return_value_logtime_16=logtime();
        logprint("%s %s:%d CROSSFADE: %u frames\n", return_value_logtime_16, (const void *)"_checkfade", 320, bytes / (unsigned int)8);
      }

      output.fade = (enum anonymous_3)FADE_DUE;
      output.fade_dir = (enum anonymous_4)FADE_CROSS;
      output.fade_start = outputbuf->writep - (signed long int)bytes;
      if(!(output.fade_start >= outputbuf->buf))
        output.fade_start = output.fade_start + (signed long int)outputbuf->size;

      output.fade_end = outputbuf->writep;
      output.track_start = output.fade_start;
    }

    else
      if(outputbuf->size == 3528000ul)
      {
        if(outputbuf->readp == outputbuf->buf)
        {
          if((signed int)loglevel_link2 >= lINFO)
          {
            return_value_logtime_17=logtime();
            logprint("%s %s:%d resize outputbuf for crossfade\n", return_value_logtime_17, (const void *)"_checkfade", 331);
          }

          _buf_resize(outputbuf, (unsigned long int)((44100 * 8 * 10 * 12) / 10));
          touch_memory(outputbuf->buf, outputbuf->size);
        }

      }

  }


__CPROVER_DUMP_L30:
  ;
}

// _close_cb
// file vorbis.c line 100
static signed int _close_cb(void *datasource)
{
  return 0;
}

// _decode_dsdiff
// file dsd.c line 368
static enum anonymous_23 _decode_dsdiff(void)
{
  unsigned int _decode_dsdiff__1__bytes_per_frame;
  unsigned int bytes_read;
  unsigned int out;
  unsigned int frames;
  unsigned int count;
  unsigned char *iptr;
  unsigned int *_decode_dsdiff__1__optr;
  unsigned char tmp[16l];
  unsigned int bytes;
  unsigned int return_value__buf_used_1;
  return_value__buf_used_1=_buf_used(streambuf);
  unsigned int return_value__buf_cont_read_2;
  return_value__buf_cont_read_2=_buf_cont_read(streambuf);
  unsigned int tmp_if_expr_5;
  unsigned int return_value__buf_used_3;
  unsigned int return_value__buf_cont_read_4;
  if(!(return_value__buf_used_1 >= return_value__buf_cont_read_2))
  {
    return_value__buf_used_3=_buf_used(streambuf);
    tmp_if_expr_5 = return_value__buf_used_3;
  }

  else
  {
    return_value__buf_cont_read_4=_buf_cont_read(streambuf);
    tmp_if_expr_5 = return_value__buf_cont_read_4;
  }
  bytes = tmp_if_expr_5;
  unsigned int return_value__buf_space_8;
  unsigned int return_value__buf_cont_write_9;
  if(!(decode.direct == (_Bool)0))
  {
    unsigned int return_value__buf_space_6;
    return_value__buf_space_6=_buf_space(outputbuf);
    unsigned int return_value__buf_cont_write_7;
    return_value__buf_cont_write_7=_buf_cont_write(outputbuf);
    unsigned int tmp_if_expr_10;
    if(!(return_value__buf_space_6 >= return_value__buf_cont_write_7))
    {
      return_value__buf_space_8=_buf_space(outputbuf);
      tmp_if_expr_10 = return_value__buf_space_8;
    }

    else
    {
      return_value__buf_cont_write_9=_buf_cont_write(outputbuf);
      tmp_if_expr_10 = return_value__buf_cont_write_9;
    }
    out = tmp_if_expr_10 / (unsigned int)8;
  }

  if(decode.direct == (_Bool)0)
    out = process_link8.max_in_frames;

  if(!(dop == (_Bool)0))
    _decode_dsdiff__1__bytes_per_frame = d->channels * (unsigned int)2;

  else
  {
    _decode_dsdiff__1__bytes_per_frame = d->channels;
    out = out < (unsigned int)4096 ? out : (unsigned int)4096;
  }
  unsigned long int tmp_if_expr_11;
  if(!((unsigned long int)bytes >= d->sample_bytes))
    tmp_if_expr_11 = (unsigned long int)bytes;

  else
    tmp_if_expr_11 = d->sample_bytes;
  unsigned long int tmp_if_expr_13;
  unsigned long int tmp_if_expr_12;
  if(!(tmp_if_expr_11 / (unsigned long int)_decode_dsdiff__1__bytes_per_frame >= (unsigned long int)out))
  {
    if(!((unsigned long int)bytes >= d->sample_bytes))
      tmp_if_expr_12 = (unsigned long int)bytes;

    else
      tmp_if_expr_12 = d->sample_bytes;
    tmp_if_expr_13 = tmp_if_expr_12 / (unsigned long int)_decode_dsdiff__1__bytes_per_frame;
  }

  else
    tmp_if_expr_13 = (unsigned long int)out;
  frames = (unsigned int)tmp_if_expr_13;
  bytes_read = frames * _decode_dsdiff__1__bytes_per_frame;
  iptr = (unsigned char *)streambuf->readp;
  if(!(decode.direct == (_Bool)0))
    _decode_dsdiff__1__optr = (unsigned int *)outputbuf->writep;

  if(decode.direct == (_Bool)0)
    _decode_dsdiff__1__optr = (unsigned int *)process_link8.inbuf;

  if(frames == 0u && !(bytes >= _decode_dsdiff__1__bytes_per_frame))
  {
    memset((void *)tmp, 0x69, (unsigned long int)16);
    memcpy((void *)tmp, (const void *)streambuf->readp, (unsigned long int)bytes);
    unsigned int return_value__buf_used_14;
    return_value__buf_used_14=_buf_used(streambuf);
    if(!(_decode_dsdiff__1__bytes_per_frame >= return_value__buf_used_14))
    {
      memcpy((void *)(tmp + (signed long int)bytes), (const void *)streambuf->buf, (unsigned long int)(_decode_dsdiff__1__bytes_per_frame - bytes));
      bytes_read = _decode_dsdiff__1__bytes_per_frame;
    }

    else
      bytes_read = bytes;
    iptr = tmp;
    frames = (unsigned int)1;
  }

  count = frames;
  unsigned int tmp_post_15;
  unsigned int tmp_post_18;
  unsigned int tmp_post_21;
  unsigned int tmp_post_25;
  if(!(dop == (_Bool)0))
  {
    if(d->channels == 1u)
      do
      {
        tmp_post_15 = count;
        count = count - 1u;
        if(tmp_post_15 == 0u)
          break;

        unsigned int *tmp_post_16 = _decode_dsdiff__1__optr;
        _decode_dsdiff__1__optr = _decode_dsdiff__1__optr + 1l;
        *tmp_post_16 = (unsigned int)((signed int)*iptr << 16 | (signed int)iptr[(signed long int)1] << 8);
        unsigned int *tmp_post_17 = _decode_dsdiff__1__optr;
        _decode_dsdiff__1__optr = _decode_dsdiff__1__optr + 1l;
        *tmp_post_17 = (unsigned int)((signed int)*iptr << 16 | (signed int)iptr[(signed long int)1] << 8);
        iptr = iptr + (signed long int)_decode_dsdiff__1__bytes_per_frame;
      }
      while((_Bool)1);

    else
      do
      {
        tmp_post_18 = count;
        count = count - 1u;
        if(tmp_post_18 == 0u)
          break;

        unsigned int *tmp_post_19 = _decode_dsdiff__1__optr;
        _decode_dsdiff__1__optr = _decode_dsdiff__1__optr + 1l;
        *tmp_post_19 = (unsigned int)((signed int)*iptr << 16 | (signed int)iptr[(signed long int)d->channels] << 8);
        unsigned int *tmp_post_20 = _decode_dsdiff__1__optr;
        _decode_dsdiff__1__optr = _decode_dsdiff__1__optr + 1l;
        *tmp_post_20 = (unsigned int)((signed int)iptr[(signed long int)1] << 16 | (signed int)(iptr + (signed long int)d->channels)[(signed long int)1] << 8);
        iptr = iptr + (signed long int)_decode_dsdiff__1__bytes_per_frame;
      }
      while((_Bool)1);
  }

  else
    if(d->channels == 1u)
    {
      float *iptrf = d->transfer[(signed long int)0];
      dsd2pcm_translate(d->dsd2pcm_ctx[(signed long int)0], (unsigned long int)frames, iptr, (signed long int)1, 0, iptrf, (signed long int)1);
      do
      {
        tmp_post_21 = count;
        count = count - 1u;
        if(tmp_post_21 == 0u)
          break;

        double scaled;
        float *tmp_post_22 = iptrf;
        iptrf = iptrf + 1l;
        scaled = (double)(*tmp_post_22 * (float)0x7fffffff);
        if(scaled > 2147483647.0)
          scaled = 2147483647.0;

        if(scaled < -2.147484e+9)
          scaled = -2147483648.0;

        unsigned int *tmp_post_23 = _decode_dsdiff__1__optr;
        _decode_dsdiff__1__optr = _decode_dsdiff__1__optr + 1l;
        *tmp_post_23 = (unsigned int)(signed int)scaled;
        unsigned int *tmp_post_24 = _decode_dsdiff__1__optr;
        _decode_dsdiff__1__optr = _decode_dsdiff__1__optr + 1l;
        *tmp_post_24 = (unsigned int)(signed int)scaled;
      }
      while((_Bool)1);
    }

    else
    {
      float *iptrfl = d->transfer[(signed long int)0];
      float *iptrfr = d->transfer[(signed long int)1];
      dsd2pcm_translate(d->dsd2pcm_ctx[(signed long int)0], (unsigned long int)frames, iptr, (signed long int)d->channels, 0, iptrfl, (signed long int)1);
      dsd2pcm_translate(d->dsd2pcm_ctx[(signed long int)1], (unsigned long int)frames, iptr + (signed long int)1, (signed long int)d->channels, 0, iptrfr, (signed long int)1);
      do
      {
        tmp_post_25 = count;
        count = count - 1u;
        if(tmp_post_25 == 0u)
          break;

        double scaledl;
        float *tmp_post_26 = iptrfl;
        iptrfl = iptrfl + 1l;
        scaledl = (double)(*tmp_post_26 * (float)0x7fffffff);
        double scaledr;
        float *tmp_post_27 = iptrfr;
        iptrfr = iptrfr + 1l;
        scaledr = (double)(*tmp_post_27 * (float)0x7fffffff);
        if(scaledl > 2147483647.0)
          scaledl = 2147483647.0;

        if(scaledl < -2.147484e+9)
          scaledl = -2147483648.0;

        if(scaledr > 2147483647.0)
          scaledr = 2147483647.0;

        if(scaledr < -2.147484e+9)
          scaledr = -2147483648.0;

        unsigned int *tmp_post_28 = _decode_dsdiff__1__optr;
        _decode_dsdiff__1__optr = _decode_dsdiff__1__optr + 1l;
        *tmp_post_28 = (unsigned int)(signed int)scaledl;
        unsigned int *tmp_post_29 = _decode_dsdiff__1__optr;
        _decode_dsdiff__1__optr = _decode_dsdiff__1__optr + 1l;
        *tmp_post_29 = (unsigned int)(signed int)scaledr;
      }
      while((_Bool)1);
    }
  _buf_inc_readp(streambuf, bytes_read);
  const char *return_value_logtime_30;
  if(!((unsigned long int)bytes_read >= d->sample_bytes))
    d->sample_bytes = d->sample_bytes - (unsigned long int)bytes_read;

  else
  {
    if((signed int)loglevel_link12 >= lINFO)
    {
      return_value_logtime_30=logtime();
      logprint("%s %s:%d end of track samples\n", return_value_logtime_30, (const void *)"_decode_dsdiff", 475);
    }

    d->sample_bytes = (unsigned long int)0;
  }
  if(!(decode.direct == (_Bool)0))
    _buf_inc_writep(outputbuf, frames * (unsigned int)8);

  if(decode.direct == (_Bool)0)
    process_link8.in_frames = frames;

  const char *return_value_logtime_31;
  if((signed int)loglevel_link12 >= lSDEBUG)
  {
    return_value_logtime_31=logtime();
    logprint("%s %s:%d write %u frames\n", return_value_logtime_31, (const void *)"_decode_dsdiff", 486, frames);
  }

  return (enum anonymous_23)DECODE_RUNNING;
}

// _decode_dsf
// file dsd.c line 207
static enum anonymous_23 _decode_dsf(void)
{
  unsigned int bytes;
  bytes=_buf_used(streambuf);
  unsigned int block_left = d->block_size;
  unsigned int _decode_dsf__1__bytes_per_frame = (unsigned int)(dop != (_Bool)0 ? 2 : 1);
  const char *return_value_logtime_1;
  if(!(bytes >= d->block_size * d->channels))
  {
    if((signed int)loglevel_link12 >= lINFO)
    {
      return_value_logtime_1=logtime();
      logprint("%s %s:%d stream too short\n", return_value_logtime_1, (const void *)"_decode_dsf", 218);
    }

    return (enum anonymous_23)DECODE_COMPLETE;
  }

  if(decode.direct == (_Bool)0)
    process_link8.in_frames = (unsigned int)0;

  signed long int tmp_if_expr_3;
  unsigned int return_value__buf_space_7;
  unsigned int return_value__buf_cont_write_8;
  const char *return_value_logtime_11;
  unsigned int tmp_post_13;
  unsigned int tmp_post_16;
  unsigned int tmp_post_19;
  unsigned int tmp_post_22;
  unsigned int tmp_post_25;
  unsigned int tmp_post_29;
  const char *return_value_logtime_34;
  const char *return_value_logtime_35;
  while(!(block_left == 0u))
  {
    unsigned int frames;
    unsigned int out;
    unsigned int count;
    unsigned int bytes_read;
    unsigned char *iptrl = (unsigned char *)streambuf->readp;
    unsigned char *iptrr = (unsigned char *)streambuf->readp + (signed long int)d->block_size;
    unsigned int *_decode_dsf__1__3__optr;
    if(iptrr >= streambuf->wrap)
      iptrr = iptrr - (signed long int)streambuf->size;

    signed long int tmp_if_expr_2;
    if(!(streambuf->wrap - iptrl >= streambuf->wrap - iptrr))
      tmp_if_expr_2 = streambuf->wrap - iptrl;

    else
      tmp_if_expr_2 = streambuf->wrap - iptrr;
    signed long int tmp_if_expr_4;
    if(!((signed long int)block_left >= tmp_if_expr_2))
      tmp_if_expr_4 = (signed long int)block_left;

    else
    {
      if(!(streambuf->wrap - iptrl >= streambuf->wrap - iptrr))
        tmp_if_expr_3 = streambuf->wrap - iptrl;

      else
        tmp_if_expr_3 = streambuf->wrap - iptrr;
      tmp_if_expr_4 = tmp_if_expr_3;
    }
    bytes = (unsigned int)tmp_if_expr_4;
    if(!(decode.direct == (_Bool)0))
    {
      unsigned int return_value__buf_space_5;
      return_value__buf_space_5=_buf_space(outputbuf);
      unsigned int return_value__buf_cont_write_6;
      return_value__buf_cont_write_6=_buf_cont_write(outputbuf);
      unsigned int tmp_if_expr_9;
      if(!(return_value__buf_space_5 >= return_value__buf_cont_write_6))
      {
        return_value__buf_space_7=_buf_space(outputbuf);
        tmp_if_expr_9 = return_value__buf_space_7;
      }

      else
      {
        return_value__buf_cont_write_8=_buf_cont_write(outputbuf);
        tmp_if_expr_9 = return_value__buf_cont_write_8;
      }
      out = tmp_if_expr_9 / (unsigned int)8;
      _decode_dsf__1__3__optr = (unsigned int *)outputbuf->writep;
    }

    if(decode.direct == (_Bool)0)
    {
      out = process_link8.max_in_frames - process_link8.in_frames;
      _decode_dsf__1__3__optr = (unsigned int *)(process_link8.inbuf + (signed long int)(process_link8.in_frames * (unsigned int)8));
    }

    unsigned long int tmp_if_expr_10;
    if(!((unsigned long int)bytes >= d->sample_bytes))
      tmp_if_expr_10 = (unsigned long int)bytes;

    else
      tmp_if_expr_10 = d->sample_bytes;
    frames = (unsigned int)(tmp_if_expr_10 / (unsigned long int)_decode_dsf__1__bytes_per_frame);
    if(frames == 0u)
    {
      _Bool tmp_if_expr_12;
      if(!(dop == (_Bool)0))
        tmp_if_expr_12 = d->sample_bytes == (unsigned long int)1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_12 = (_Bool)0;
      if(bytes >= 2u && tmp_if_expr_12)
      {
        iptrr[(signed long int)1] = (unsigned char)0x69;
        iptrl[(signed long int)1] = iptrr[(signed long int)1];
        frames = (unsigned int)1;
      }

      else
      {
        if((signed int)loglevel_link12 >= lINFO)
        {
          return_value_logtime_11=logtime();
          logprint("%s %s:%d frames got to zero\n", return_value_logtime_11, (const void *)"_decode_dsf", 258);
        }

        return (enum anonymous_23)DECODE_COMPLETE;
      }
    }

    frames = frames < out ? frames : out;
    frames = frames < (unsigned int)4096 ? frames : (unsigned int)4096;
    bytes_read = frames * _decode_dsf__1__bytes_per_frame;
    count = frames;
    if(!(dop == (_Bool)0))
    {
      if(d->channels == 1u)
      {
        if(!(d->lsb_first == (_Bool)0))
          do
          {
            tmp_post_13 = count;
            count = count - 1u;
            if(tmp_post_13 == 0u)
              break;

            unsigned int *tmp_post_14 = _decode_dsf__1__3__optr;
            _decode_dsf__1__3__optr = _decode_dsf__1__3__optr + 1l;
            *tmp_post_14 = (unsigned int)((signed int)dsd2pcm_bitreverse[(signed long int)*iptrl] << 16 | (signed int)dsd2pcm_bitreverse[(signed long int)iptrl[(signed long int)1]] << 8);
            unsigned int *tmp_post_15 = _decode_dsf__1__3__optr;
            _decode_dsf__1__3__optr = _decode_dsf__1__3__optr + 1l;
            *tmp_post_15 = (unsigned int)((signed int)dsd2pcm_bitreverse[(signed long int)*iptrl] << 16 | (signed int)dsd2pcm_bitreverse[(signed long int)iptrl[(signed long int)1]] << 8);
            iptrl = iptrl + (signed long int)2;
          }
          while((_Bool)1);

        else
          do
          {
            tmp_post_16 = count;
            count = count - 1u;
            if(tmp_post_16 == 0u)
              break;

            unsigned int *tmp_post_17 = _decode_dsf__1__3__optr;
            _decode_dsf__1__3__optr = _decode_dsf__1__3__optr + 1l;
            *tmp_post_17 = (unsigned int)((signed int)*iptrl << 16 | (signed int)iptrl[(signed long int)1] << 8);
            unsigned int *tmp_post_18 = _decode_dsf__1__3__optr;
            _decode_dsf__1__3__optr = _decode_dsf__1__3__optr + 1l;
            *tmp_post_18 = (unsigned int)((signed int)*iptrl << 16 | (signed int)iptrl[(signed long int)1] << 8);
            iptrl = iptrl + (signed long int)2;
          }
          while((_Bool)1);
      }

      else
        if(!(d->lsb_first == (_Bool)0))
          do
          {
            tmp_post_19 = count;
            count = count - 1u;
            if(tmp_post_19 == 0u)
              break;

            unsigned int *tmp_post_20 = _decode_dsf__1__3__optr;
            _decode_dsf__1__3__optr = _decode_dsf__1__3__optr + 1l;
            *tmp_post_20 = (unsigned int)((signed int)dsd2pcm_bitreverse[(signed long int)*iptrl] << 16 | (signed int)dsd2pcm_bitreverse[(signed long int)iptrl[(signed long int)1]] << 8);
            unsigned int *tmp_post_21 = _decode_dsf__1__3__optr;
            _decode_dsf__1__3__optr = _decode_dsf__1__3__optr + 1l;
            *tmp_post_21 = (unsigned int)((signed int)dsd2pcm_bitreverse[(signed long int)*iptrr] << 16 | (signed int)dsd2pcm_bitreverse[(signed long int)iptrr[(signed long int)1]] << 8);
            iptrl = iptrl + (signed long int)2;
            iptrr = iptrr + (signed long int)2;
          }
          while((_Bool)1);

        else
          do
          {
            tmp_post_22 = count;
            count = count - 1u;
            if(tmp_post_22 == 0u)
              break;

            unsigned int *tmp_post_23 = _decode_dsf__1__3__optr;
            _decode_dsf__1__3__optr = _decode_dsf__1__3__optr + 1l;
            *tmp_post_23 = (unsigned int)((signed int)*iptrl << 16 | (signed int)iptrl[(signed long int)1] << 8);
            unsigned int *tmp_post_24 = _decode_dsf__1__3__optr;
            _decode_dsf__1__3__optr = _decode_dsf__1__3__optr + 1l;
            *tmp_post_24 = (unsigned int)((signed int)*iptrr << 16 | (signed int)iptrr[(signed long int)1] << 8);
            iptrl = iptrl + (signed long int)2;
            iptrr = iptrr + (signed long int)2;
          }
          while((_Bool)1);
    }

    else
      if(d->channels == 1u)
      {
        float *iptrf = d->transfer[(signed long int)0];
        dsd2pcm_translate(d->dsd2pcm_ctx[(signed long int)0], (unsigned long int)frames, iptrl, (signed long int)1, (signed int)d->lsb_first, iptrf, (signed long int)1);
        do
        {
          tmp_post_25 = count;
          count = count - 1u;
          if(tmp_post_25 == 0u)
            break;

          double scaled;
          float *tmp_post_26 = iptrf;
          iptrf = iptrf + 1l;
          scaled = (double)(*tmp_post_26 * (float)0x7fffffff);
          if(scaled > 2147483647.0)
            scaled = 2147483647.0;

          if(scaled < -2.147484e+9)
            scaled = -2147483648.0;

          unsigned int *tmp_post_27 = _decode_dsf__1__3__optr;
          _decode_dsf__1__3__optr = _decode_dsf__1__3__optr + 1l;
          *tmp_post_27 = (unsigned int)(signed int)scaled;
          unsigned int *tmp_post_28 = _decode_dsf__1__3__optr;
          _decode_dsf__1__3__optr = _decode_dsf__1__3__optr + 1l;
          *tmp_post_28 = (unsigned int)(signed int)scaled;
        }
        while((_Bool)1);
      }

      else
      {
        float *iptrfl = d->transfer[(signed long int)0];
        float *iptrfr = d->transfer[(signed long int)1];
        dsd2pcm_translate(d->dsd2pcm_ctx[(signed long int)0], (unsigned long int)frames, iptrl, (signed long int)1, (signed int)d->lsb_first, iptrfl, (signed long int)1);
        dsd2pcm_translate(d->dsd2pcm_ctx[(signed long int)1], (unsigned long int)frames, iptrr, (signed long int)1, (signed int)d->lsb_first, iptrfr, (signed long int)1);
        do
        {
          tmp_post_29 = count;
          count = count - 1u;
          if(tmp_post_29 == 0u)
            break;

          double scaledl;
          float *tmp_post_30 = iptrfl;
          iptrfl = iptrfl + 1l;
          scaledl = (double)(*tmp_post_30 * (float)0x7fffffff);
          double scaledr;
          float *tmp_post_31 = iptrfr;
          iptrfr = iptrfr + 1l;
          scaledr = (double)(*tmp_post_31 * (float)0x7fffffff);
          if(scaledl > 2147483647.0)
            scaledl = 2147483647.0;

          if(scaledl < -2.147484e+9)
            scaledl = -2147483648.0;

          if(scaledr > 2147483647.0)
            scaledr = 2147483647.0;

          if(scaledr < -2.147484e+9)
            scaledr = -2147483648.0;

          unsigned int *tmp_post_32 = _decode_dsf__1__3__optr;
          _decode_dsf__1__3__optr = _decode_dsf__1__3__optr + 1l;
          *tmp_post_32 = (unsigned int)(signed int)scaledl;
          unsigned int *tmp_post_33 = _decode_dsf__1__3__optr;
          _decode_dsf__1__3__optr = _decode_dsf__1__3__optr + 1l;
          *tmp_post_33 = (unsigned int)(signed int)scaledr;
        }
        while((_Bool)1);
      }
    _buf_inc_readp(streambuf, bytes_read);
    block_left = block_left - bytes_read;
    if(!((unsigned long int)bytes_read >= d->sample_bytes))
      d->sample_bytes = d->sample_bytes - (unsigned long int)bytes_read;

    else
    {
      if((signed int)loglevel_link12 >= lINFO)
      {
        return_value_logtime_34=logtime();
        logprint("%s %s:%d end of track samples\n", return_value_logtime_34, (const void *)"_decode_dsf", 341);
      }

      block_left = (unsigned int)0;
      d->sample_bytes = (unsigned long int)0;
    }
    if(!(decode.direct == (_Bool)0))
      _buf_inc_writep(outputbuf, frames * (unsigned int)8);

    if(decode.direct == (_Bool)0)
      process_link8.in_frames = process_link8.in_frames + frames;

    if((signed int)loglevel_link12 >= lSDEBUG)
    {
      return_value_logtime_35=logtime();
      logprint("%s %s:%d write %u frames\n", return_value_logtime_35, (const void *)"_decode_dsf", 353, frames);
    }

  }
  if(d->channels >= 2u)
    _buf_inc_readp(streambuf, d->block_size);

  if(d->channels >= 3u)
    d->consume = d->block_size * (d->channels - (unsigned int)2);

  return (enum anonymous_23)DECODE_RUNNING;
}

// _disconnect
// file stream.c line 69
static void _disconnect(enum anonymous_14 state, enum anonymous_0 disconnect)
{
  stream.state = state;
  stream.disconnect = disconnect;
  close(fd);
  fd = -1;
  wake_controller();
}

// _free_ff_data
// file ffmpeg.c line 513
static void _free_ff_data(void)
{
  if(!(ff->formatC == ((struct AVFormatContext *)NULL)))
  {
    if(!(ff->formatC->pb == ((struct AVIOContext *)NULL)))
      av_freep((void *)&ff->formatC->pb);

    avformat_free_context(ff->formatC);
    ff->formatC = (struct AVFormatContext *)(void *)0;
  }

  if(!(ff->frame == ((struct AVFrame *)NULL)))
  {
    av_frame_free(&ff->frame);
    ff->frame = (struct AVFrame *)(void *)0;
  }

  if(!(ff->avpkt == ((struct AVPacket *)NULL)))
  {
    av_free_packet(ff->avpkt);
    av_freep((void *)&ff->avpkt);
    ff->avpkt = (struct AVPacket *)(void *)0;
  }

}

// _output_frames
// file output.c line 43
unsigned int _output_frames(unsigned int avail)
{
  unsigned int frames;
  unsigned int size;
  _Bool silence;
  signed int cross_gain_in = 0;
  signed int cross_gain_out = 0;
  signed int *cross_ptr = (signed int *)(void *)0;
  signed int gainL;
  unsigned int tmp_if_expr_2;
  signed int return_value_gain_1;
  if(!(output.current_replay_gain == 0u))
  {
    return_value_gain_1=gain((signed int)output.gainL, (signed int)output.current_replay_gain);
    tmp_if_expr_2 = (unsigned int)return_value_gain_1;
  }

  else
    tmp_if_expr_2 = output.gainL;
  gainL = (signed int)tmp_if_expr_2;
  signed int gainR;
  unsigned int tmp_if_expr_4;
  signed int return_value_gain_3;
  if(!(output.current_replay_gain == 0u))
  {
    return_value_gain_3=gain((signed int)output.gainR, (signed int)output.current_replay_gain);
    tmp_if_expr_4 = (unsigned int)return_value_gain_3;
  }

  else
    tmp_if_expr_4 = output.gainR;
  gainR = (signed int)tmp_if_expr_4;
  if(!(output.invert == (_Bool)0))
  {
    gainL = -gainL;
    gainR = -gainR;
  }

  unsigned int return_value__buf_used_5;
  return_value__buf_used_5=_buf_used(outputbuf);
  frames = return_value__buf_used_5 / (unsigned int)8;
  silence = (_Bool)0;
  const char *return_value_logtime_6;
  if((signed int)output.state == OUTPUT_BUFFER && !((output.next_sample_rate * output.threshold) / 100u >= frames) && !(output.start_frames >= frames))
  {
    output.state = (enum anonymous_1)OUTPUT_RUNNING;
    if((signed int)loglevel_link2 >= lINFO)
    {
      return_value_logtime_6=logtime();
      logprint("%s %s:%d start buffer frames: %u\n", return_value_logtime_6, (const void *)"_output_frames", 61, frames);
    }

    wake_controller();
  }

  const char *return_value_logtime_7;
  unsigned int return_value__buf_cont_read_9;
  if((signed int)output.state == OUTPUT_SKIP_FRAMES)
  {
    if(frames >= 1u)
    {
      unsigned int skip = frames < output._anon0.skip_frames ? frames : output._anon0.skip_frames;
      if((signed int)loglevel_link2 >= lINFO)
      {
        return_value_logtime_7=logtime();
        logprint("%s %s:%d skip %u of %u frames\n", return_value_logtime_7, (const void *)"_output_frames", 69, skip, output._anon0.skip_frames);
      }

      frames = frames - skip;
      output.frames_played = output.frames_played + skip;
      while(skip >= 1u)
      {
        unsigned int cont_frames;
        unsigned int return_value__buf_cont_read_8;
        return_value__buf_cont_read_8=_buf_cont_read(outputbuf);
        unsigned int tmp_if_expr_10;
        if(!(skip >= return_value__buf_cont_read_8 / 8u))
          tmp_if_expr_10 = skip;

        else
        {
          return_value__buf_cont_read_9=_buf_cont_read(outputbuf);
          tmp_if_expr_10 = return_value__buf_cont_read_9 / (unsigned int)8;
        }
        cont_frames = tmp_if_expr_10;
        skip = skip - cont_frames;
        _buf_inc_readp(outputbuf, cont_frames * (unsigned int)8);
      }
    }

    output.state = (enum anonymous_1)OUTPUT_RUNNING;
  }

  const char *return_value_logtime_11;
  if((signed int)output.state == OUTPUT_PAUSE_FRAMES)
  {
    if((signed int)loglevel_link2 >= lINFO)
    {
      return_value_logtime_11=logtime();
      logprint("%s %s:%d pause %u frames\n", return_value_logtime_11, (const void *)"_output_frames", 83, output._anon0.pause_frames);
    }

    if(output._anon0.pause_frames == 0u)
      output.state = (enum anonymous_1)OUTPUT_RUNNING;

    else
    {
      silence = (_Bool)1;
      frames = avail < output._anon0.pause_frames ? avail : output._anon0.pause_frames;
      frames = frames < (unsigned int)2048 ? frames : (unsigned int)2048;
      output._anon0.pause_frames = output._anon0.pause_frames - frames;
    }
  }

  if((signed int)output.state == OUTPUT_START_AT)
  {
    unsigned int now;
    now=gettime_ms();
    if(now >= output._anon0.start_at || !(10000u + now >= output._anon0.start_at))
      output.state = (enum anonymous_1)OUTPUT_RUNNING;

    else
    {
      unsigned int delta_frames = ((output._anon0.start_at - now) * output.current_sample_rate) / (unsigned int)1000;
      silence = (_Bool)1;
      frames = avail < delta_frames ? avail : delta_frames;
      frames = frames < (unsigned int)2048 ? frames : (unsigned int)2048;
    }
  }

  if(frames == 0u || !((signed int)output.state >= 2))
  {
    silence = (_Bool)1;
    frames = avail < (unsigned int)2048 ? avail : (unsigned int)2048;
  }

  const char *return_value_logtime_12;
  if((signed int)loglevel_link2 >= lSDEBUG)
  {
    return_value_logtime_12=logtime();
    logprint("%s %s:%d avail: %d frames: %d silence: %d\n", return_value_logtime_12, (const void *)"_output_frames", 113, avail, frames, silence);
  }

  frames = frames < avail ? frames : avail;
  size = frames;
  const char *return_value_logtime_14;
  const char *return_value_logtime_16;
  const char *return_value_logtime_20;
  const char *return_value_logtime_21;
  const char *return_value_logtime_22;
  const char *return_value_logtime_23;
  const char *return_value_logtime_25;
  const char *return_value_logtime_27;
  if(size >= 1u)
  {
    unsigned int out_frames;
    unsigned int _output_frames__1__7__cont_frames;
    unsigned int return_value__buf_cont_read_13;
    return_value__buf_cont_read_13=_buf_cont_read(outputbuf);
    _output_frames__1__7__cont_frames = return_value__buf_cont_read_13 / (unsigned int)8;
    signed int wrote;
    if(silence == (_Bool)0 && !(output.track_start == ((unsigned char *)NULL)))
    {
      if(output.track_start == outputbuf->readp)
      {
        unsigned int delay = (unsigned int)0;
        if(!(output.current_sample_rate == output.next_sample_rate))
          delay = output.rate_delay;

        if(!(output.dop == output.next_dop))
          delay = output.dop_delay;

        frames = frames - size;
        if(!(delay == 0u))
        {
          output.state = (enum anonymous_1)OUTPUT_PAUSE_FRAMES;
          if(output.delay_active == (_Bool)0)
          {
            output._anon0.pause_frames = (output.current_sample_rate * delay) / (unsigned int)2000;
            output.delay_active = (_Bool)1;
            goto __CPROVER_DUMP_L73;
          }

          else
          {
            output._anon0.pause_frames = (output.next_sample_rate * delay) / (unsigned int)2000;
            output.delay_active = (_Bool)0;
          }
        }

        if((signed int)loglevel_link2 >= lINFO)
        {
          return_value_logtime_14=logtime();
          logprint("%s %s:%d track start sample rate: %u replay_gain: %u\n", return_value_logtime_14, (const void *)"_output_frames", 146, output.next_sample_rate, output.next_replay_gain);
        }

        output.frames_played = (unsigned int)0;
        output.track_started = (_Bool)1;
        output.track_start_time=gettime_ms();
        output.current_sample_rate = output.next_sample_rate;
        output.dop = output.next_dop;
        if((signed int)(output.fade == /*enum*/FADE_INACTIVE) == FADE_ACTIVE || (signed int)(output.fade_mode == /*enum*/FADE_NONE) == FADE_CROSSFADE)
          output.current_replay_gain = output.next_replay_gain;

        output.track_start = (unsigned char *)(void *)0;
        goto __CPROVER_DUMP_L73;
      }

      else
        if(!(outputbuf->readp >= output.track_start))
        {
          signed long int tmp_if_expr_15;
          if(!((signed long int)_output_frames__1__7__cont_frames >= (output.track_start - outputbuf->readp) / 8l))
            tmp_if_expr_15 = (signed long int)_output_frames__1__7__cont_frames;

          else
            tmp_if_expr_15 = (output.track_start - outputbuf->readp) / (signed long int)8;
          _output_frames__1__7__cont_frames = (unsigned int)tmp_if_expr_15;
        }

    }

    if(!(output.dop == (_Bool)0))
    {
      gainR = 0x10000;
      gainL = gainR;
    }

    if(silence == (_Bool)0 && !(output.fade == /*enum*/FADE_INACTIVE))
    {
      if((signed int)output.fade == FADE_DUE)
      {
        if(output.fade_start == outputbuf->readp)
        {
          if((signed int)loglevel_link2 >= lINFO)
          {
            return_value_logtime_16=logtime();
            logprint("%s %s:%d fade start reached\n", return_value_logtime_16, (const void *)"_output_frames", 174);
          }

          output.fade = (enum anonymous_3)FADE_ACTIVE;
        }

        else
          if(!(outputbuf->readp >= output.fade_start))
          {
            signed long int tmp_if_expr_17;
            if(!((signed long int)_output_frames__1__7__cont_frames >= (output.fade_start - outputbuf->readp) / 8l))
              tmp_if_expr_17 = (signed long int)_output_frames__1__7__cont_frames;

            else
              tmp_if_expr_17 = (output.fade_start - outputbuf->readp) / (signed long int)8;
            _output_frames__1__7__cont_frames = (unsigned int)tmp_if_expr_17;
          }

      }

      if((signed int)output.fade == FADE_ACTIVE)
      {
        unsigned int cur_f;
        signed long int tmp_if_expr_18;
        if(outputbuf->readp >= output.fade_start)
          tmp_if_expr_18 = (outputbuf->readp - output.fade_start) / (signed long int)8;

        else
          tmp_if_expr_18 = ((outputbuf->readp + (signed long int)outputbuf->size) - output.fade_start) / (signed long int)8;
        cur_f = (unsigned int)tmp_if_expr_18;
        unsigned int dur_f;
        signed long int tmp_if_expr_19;
        if(output.fade_end >= output.fade_start)
          tmp_if_expr_19 = (output.fade_end - output.fade_start) / (signed long int)8;

        else
          tmp_if_expr_19 = ((output.fade_end + (signed long int)outputbuf->size) - output.fade_start) / (signed long int)8;
        dur_f = (unsigned int)tmp_if_expr_19;
        if(cur_f >= dur_f)
        {
          if((signed int)output.fade_mode == FADE_INOUT && (signed int)output.fade_dir == FADE_DOWN)
          {
            if((signed int)loglevel_link2 >= lINFO)
            {
              return_value_logtime_20=logtime();
              logprint("%s %s:%d fade down complete, starting fade up\n", return_value_logtime_20, (const void *)"_output_frames", 188);
            }

            output.fade_dir = (enum anonymous_4)FADE_UP;
            output.fade_start = outputbuf->readp;
            output.fade_end = outputbuf->readp + (signed long int)(dur_f * (unsigned int)8);
            if(output.fade_end >= outputbuf->wrap)
              output.fade_end = output.fade_end - (signed long int)outputbuf->size;

            cur_f = (unsigned int)0;
          }

          else
            if((signed int)output.fade_mode == FADE_CROSSFADE)
            {
              if((signed int)loglevel_link2 >= lINFO)
              {
                return_value_logtime_21=logtime();
                logprint("%s %s:%d crossfade complete\n", return_value_logtime_21, (const void *)"_output_frames", 197);
              }

              unsigned int return_value__buf_used_24;
              return_value__buf_used_24=_buf_used(outputbuf);
              if(return_value__buf_used_24 >= 8u * dur_f)
              {
                _buf_inc_readp(outputbuf, dur_f * (unsigned int)8);
                if((signed int)loglevel_link2 >= lINFO)
                {
                  return_value_logtime_22=logtime();
                  logprint("%s %s:%d skipped crossfaded start\n", return_value_logtime_22, (const void *)"_output_frames", 200);
                }

              }

              else
                if((signed int)loglevel_link2 >= lWARN)
                {
                  return_value_logtime_23=logtime();
                  logprint("%s %s:%d unable to skip crossfaded start\n", return_value_logtime_23, (const void *)"_output_frames", 202);
                }

              output.fade = (enum anonymous_3)FADE_INACTIVE;
              output.current_replay_gain = output.next_replay_gain;
            }

            else
            {
              if((signed int)loglevel_link2 >= lINFO)
              {
                return_value_logtime_25=logtime();
                logprint("%s %s:%d fade complete\n", return_value_logtime_25, (const void *)"_output_frames", 207);
              }

              output.fade = (enum anonymous_3)FADE_INACTIVE;
            }
        }

        if(!(output.fade == /*enum*/FADE_INACTIVE))
        {
          if(!(outputbuf->readp >= output.fade_end))
          {
            signed long int tmp_if_expr_26;
            if(!((signed long int)_output_frames__1__7__cont_frames >= (output.fade_end - outputbuf->readp) / 8l))
              tmp_if_expr_26 = (signed long int)_output_frames__1__7__cont_frames;

            else
              tmp_if_expr_26 = (output.fade_end - outputbuf->readp) / (signed long int)8;
            _output_frames__1__7__cont_frames = (unsigned int)tmp_if_expr_26;
          }

          if((signed int)output.fade_dir == FADE_UP || (signed int)output.fade_dir == FADE_DOWN)
          {
            signed int fade_gain;
            if((signed int)output.fade_dir == FADE_DOWN)
              cur_f = dur_f - cur_f;

            fade_gain=to_gain((float)cur_f / (float)dur_f);
            gainL=gain(gainL, fade_gain);
            gainR=gain(gainR, fade_gain);
            if(!(output.invert == (_Bool)0))
            {
              gainL = -gainL;
              gainR = -gainR;
            }

          }

          if((signed int)output.fade_dir == FADE_CROSS)
          {
            unsigned int return_value__buf_used_28;
            return_value__buf_used_28=_buf_used(outputbuf);
            if(!(dur_f + size >= return_value__buf_used_28 / 8u))
            {
              cross_gain_in=to_gain((float)cur_f / (float)dur_f);
              cross_gain_out = 0x10000 - cross_gain_in;
              if(!(output.current_replay_gain == 0u))
                cross_gain_out=gain(cross_gain_out, (signed int)output.current_replay_gain);

              if(!(output.next_replay_gain == 0u))
                cross_gain_in=gain(cross_gain_in, (signed int)output.next_replay_gain);

              gainL = (signed int)output.gainL;
              gainR = (signed int)output.gainR;
              if(!(output.invert == (_Bool)0))
              {
                gainL = -gainL;
                gainR = -gainR;
              }

              cross_ptr = (signed int *)(output.fade_end + (signed long int)(cur_f * (unsigned int)8));
            }

            else
            {
              if((signed int)loglevel_link2 >= lINFO)
              {
                return_value_logtime_27=logtime();
                logprint("%s %s:%d unable to continue crossfade - too few samples\n", return_value_logtime_27, (const void *)"_output_frames", 244);
              }

              output.fade = (enum anonymous_3)FADE_INACTIVE;
            }
          }

        }

      }

    }

    out_frames = !(silence != (_Bool)0) ? (size < _output_frames__1__7__cont_frames ? size : _output_frames__1__7__cont_frames) : size;
    wrote=output.write_cb(out_frames, silence, gainL, gainR, cross_gain_in, cross_gain_out, &cross_ptr);
    if(!(wrote >= 1))
      frames = frames - size;

    else
      out_frames = (unsigned int)wrote;
    size = size - out_frames;
    _vis_export(outputbuf, &output, out_frames, silence);
    if(silence == (_Bool)0)
    {
      _buf_inc_readp(outputbuf, out_frames * (unsigned int)8);
      output.frames_played = output.frames_played + out_frames;
    }

  }


__CPROVER_DUMP_L73:
  ;
  const char *return_value_logtime_29;
  if((signed int)loglevel_link2 >= lSDEBUG)
  {
    return_value_logtime_29=logtime();
    logprint("%s %s:%d wrote %u frames\n", return_value_logtime_29, (const void *)"_output_frames", 273, frames);
  }

  return frames;
}

// _pa_open
// file squeezelite.h line 610
void _pa_open(void)
{
  struct PaStreamParameters outputParameters;
  signed int err = 0;
  signed int device_id;
  const char *return_value_logtime_1;
  const char *return_value_Pa_GetErrorText_2;
  if(!(pa.stream == NULL))
  {
    err=Pa_CloseStream(pa.stream);
    if(!(err == 0))
    {
      if((signed int)loglevel_link3 >= lWARN)
      {
        return_value_logtime_1=logtime();
        return_value_Pa_GetErrorText_2=Pa_GetErrorText(err);
        logprint("%s %s:%d error closing stream: %s\n", return_value_logtime_1, (const void *)"_pa_open", 219, return_value_Pa_GetErrorText_2);
      }

    }

  }

  const char *return_value_logtime_3;
  const struct PaDeviceInfo *return_value_Pa_GetDeviceInfo_4;
  if((signed int)output.state == OUTPUT_OFF)
    err = 1;

  else
  {
    device_id=pa_device_id(output.device);
    if(device_id == -1)
    {
      if((signed int)loglevel_link3 >= lINFO)
      {
        return_value_logtime_3=logtime();
        logprint("%s %s:%d device %s not found\n", return_value_logtime_3, (const void *)"_pa_open", 229, output.device);
      }

      err = 1;
    }

    else
    {
      outputParameters.device = device_id;
      outputParameters.channelCount = 2;
      outputParameters.sampleFormat = (unsigned long int)0x00000002;
      double tmp_if_expr_5;
      if(!(output.latency == 0u))
        tmp_if_expr_5 = (double)output.latency / (double)1000;

      else
      {
        return_value_Pa_GetDeviceInfo_4=Pa_GetDeviceInfo(outputParameters.device);
        tmp_if_expr_5 = return_value_Pa_GetDeviceInfo_4->defaultHighOutputLatency;
      }
      outputParameters.suggestedLatency = tmp_if_expr_5;
      outputParameters.hostApiSpecificStreamInfo = (void *)0;
    }
  }
  const char *return_value_logtime_6;
  const struct PaDeviceInfo *return_value_Pa_GetDeviceInfo_7;
  const char *return_value_Pa_GetErrorText_8;
  if(err == 0)
  {
    err=Pa_OpenStream(&pa.stream, (const struct PaStreamParameters *)(void *)0, &outputParameters, (double)output.current_sample_rate, (unsigned long int)0, (unsigned long int)0x00000008 | (unsigned long int)0x00000002, pa_callback, (void *)0);
    if(!(err == 0))
    {
      if((signed int)loglevel_link3 >= lWARN)
      {
        return_value_logtime_6=logtime();
        return_value_Pa_GetDeviceInfo_7=Pa_GetDeviceInfo(outputParameters.device);
        return_value_Pa_GetErrorText_8=Pa_GetErrorText(err);
        logprint("%s %s:%d error opening device %i - %s : %s\n", return_value_logtime_6, (const void *)"_pa_open", 263, outputParameters.device, return_value_Pa_GetDeviceInfo_7->name, return_value_Pa_GetErrorText_8);
      }

    }

  }

  const char *return_value_logtime_9;
  const struct PaDeviceInfo *return_value_Pa_GetDeviceInfo_10;
  const struct PaStreamInfo *return_value_Pa_GetStreamInfo_11;
  const struct PaStreamInfo *return_value_Pa_GetStreamInfo_12;
  const char *return_value_logtime_13;
  const char *return_value_Pa_GetErrorText_14;
  const char *return_value_logtime_15;
  const char *return_value_Pa_GetErrorText_16;
  if(err == 0)
  {
    if((signed int)loglevel_link3 >= lINFO)
    {
      return_value_logtime_9=logtime();
      return_value_Pa_GetDeviceInfo_10=Pa_GetDeviceInfo(outputParameters.device);
      return_value_Pa_GetStreamInfo_11=Pa_GetStreamInfo(pa.stream);
      return_value_Pa_GetStreamInfo_12=Pa_GetStreamInfo(pa.stream);
      logprint("%s %s:%d opened device %i - %s at %u latency %u ms\n", return_value_logtime_9, (const void *)"_pa_open", 268, outputParameters.device, return_value_Pa_GetDeviceInfo_10->name, (unsigned int)return_value_Pa_GetStreamInfo_11->sampleRate, (unsigned int)(return_value_Pa_GetStreamInfo_12->outputLatency * (double)1000));
    }

    pa.rate = output.current_sample_rate;
    err=Pa_SetStreamFinishedCallback(pa.stream, pa_stream_finished);
    if(!(err == 0))
    {
      if((signed int)loglevel_link3 >= lWARN)
      {
        return_value_logtime_13=logtime();
        return_value_Pa_GetErrorText_14=Pa_GetErrorText(err);
        logprint("%s %s:%d error setting finish callback: %s\n", return_value_logtime_13, (const void *)"_pa_open", 273, return_value_Pa_GetErrorText_14);
      }

    }

    pthread_mutex_unlock(&outputbuf->mutex);
    err=Pa_StartStream(pa.stream);
    if(!(err == 0))
    {
      if((signed int)loglevel_link3 >= lWARN)
      {
        return_value_logtime_15=logtime();
        return_value_Pa_GetErrorText_16=Pa_GetErrorText(err);
        logprint("%s %s:%d error starting stream: %s\n", return_value_logtime_15, (const void *)"_pa_open", 279, return_value_Pa_GetErrorText_16);
      }

    }

    pthread_mutex_lock(&outputbuf->mutex);
  }

  if(monitor_thread_running == (_Bool)0 && !(err == 0))
  {
    vis_stop();
    pthread_create(&monitor_thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))pa_monitor, (void *)0);
  }

  output.error_opening = !(!(err != 0));
}

// _parse_packlen
// file ffmpeg.c line 132
static signed int _parse_packlen(void)
{
  signed int bytes;
  unsigned int return_value__buf_used_1;
  return_value__buf_used_1=_buf_used(streambuf);
  unsigned int return_value__buf_cont_read_2;
  return_value__buf_cont_read_2=_buf_cont_read(streambuf);
  unsigned int tmp_if_expr_5;
  unsigned int return_value__buf_used_3;
  unsigned int return_value__buf_cont_read_4;
  if(!(return_value__buf_used_1 >= return_value__buf_cont_read_2))
  {
    return_value__buf_used_3=_buf_used(streambuf);
    tmp_if_expr_5 = return_value__buf_used_3;
  }

  else
  {
    return_value__buf_cont_read_4=_buf_cont_read(streambuf);
    tmp_if_expr_5 = return_value__buf_cont_read_4;
  }
  bytes = (signed int)tmp_if_expr_5;
  unsigned char *ptr = streambuf->readp;
  signed int remain = 1;
  const char *return_value_logtime_7;
  while(bytes >= 24 && remain >= 1)
  {
    unsigned int len = (unsigned int)((signed int)ptr[(signed long int)16] | (signed int)ptr[(signed long int)17] << 8 | (signed int)ptr[(signed long int)18] << 16 | (signed int)ptr[(signed long int)19] << 24);
    signed int return_value_memcmp_6;
    return_value_memcmp_6=memcmp((const void *)ptr, (const void *)header_guid, (unsigned long int)16);
    if(return_value_memcmp_6 == 0)
    {
      if(!(bytes >= 30))
        goto __CPROVER_DUMP_L4;

      ptr = ptr + (signed long int)30;
      bytes = bytes - 30;
      remain = (signed int)(len - (unsigned int)30);
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      signed int return_value_memcmp_8;
      return_value_memcmp_8=memcmp((const void *)ptr, (const void *)file_props_guid, (unsigned long int)16);
      if(return_value_memcmp_8 == 0)
      {
        if(len == 104u)
        {
          unsigned int packlen = (unsigned int)((signed int)ptr[(signed long int)92] | (signed int)ptr[(signed long int)93] << 8 | (signed int)ptr[(signed long int)94] << 16 | (signed int)ptr[(signed long int)95] << 24);
          if((signed int)loglevel_link13 >= lINFO)
          {
            return_value_logtime_7=logtime();
            logprint("%s %s:%d asf packet len: %u\n", return_value_logtime_7, (const void *)"_parse_packlen", 147, packlen);
          }

          return (signed int)packlen;
        }

      }

      ptr = ptr + (signed long int)len;
      bytes = bytes - (signed int)len;
      remain = remain - (signed int)len;
    }
  }
  const char *return_value_logtime_9;
  if((signed int)loglevel_link13 >= lWARN)
  {
    return_value_logtime_9=logtime();
    logprint("%s %s:%d could not parse packet length\n", return_value_logtime_9, (const void *)"_parse_packlen", 155);
  }

  return 0;
}

// _read_cb
// file vorbis.c line 86
static unsigned long int _read_cb(void *ptr, unsigned long int size, unsigned long int nmemb, void *datasource)
{
  unsigned long int bytes;
  unsigned int return_value__buf_used_1;
  return_value__buf_used_1=_buf_used(streambuf);
  unsigned int return_value__buf_cont_read_2;
  return_value__buf_cont_read_2=_buf_cont_read(streambuf);
  unsigned int tmp_if_expr_5;
  unsigned int return_value__buf_used_3;
  unsigned int return_value__buf_cont_read_4;
  if(!(return_value__buf_used_1 >= return_value__buf_cont_read_2))
  {
    return_value__buf_used_3=_buf_used(streambuf);
    tmp_if_expr_5 = return_value__buf_used_3;
  }

  else
  {
    return_value__buf_cont_read_4=_buf_cont_read(streambuf);
    tmp_if_expr_5 = return_value__buf_cont_read_4;
  }
  bytes = (unsigned long int)tmp_if_expr_5;
  bytes = bytes < size * nmemb ? bytes : size * nmemb;
  memcpy(ptr, (const void *)streambuf->readp, bytes);
  _buf_inc_readp(streambuf, (unsigned int)bytes);
  return bytes / size;
}

// _read_data
// file ffmpeg.c line 159
static signed int _read_data(void *opaque, unsigned char *buffer, signed int buf_size)
{
  unsigned long int bytes;
  pthread_mutex_lock(&streambuf->mutex);
  unsigned int return_value__buf_used_1;
  return_value__buf_used_1=_buf_used(streambuf);
  unsigned int return_value__buf_cont_read_2;
  return_value__buf_cont_read_2=_buf_cont_read(streambuf);
  unsigned int tmp_if_expr_5;
  unsigned int return_value__buf_used_3;
  unsigned int return_value__buf_cont_read_4;
  if(!(return_value__buf_used_1 >= return_value__buf_cont_read_2))
  {
    return_value__buf_used_3=_buf_used(streambuf);
    tmp_if_expr_5 = return_value__buf_used_3;
  }

  else
  {
    return_value__buf_cont_read_4=_buf_cont_read(streambuf);
    tmp_if_expr_5 = return_value__buf_cont_read_4;
  }
  bytes = (unsigned long int)tmp_if_expr_5;
  ff->end_of_stream = (signed int)stream.state <= DISCONNECT && bytes == (unsigned long int)0;
  bytes = bytes < (unsigned long int)buf_size ? bytes : (unsigned long int)buf_size;
  unsigned int return_value__buf_used_14;
  unsigned int return_value__buf_used_9;
  unsigned int return_value__buf_cont_read_10;
  const char *return_value_logtime_16;
  if(!(ff->wma_mmsh == 0))
  {
    unsigned int chunk_type = (unsigned int)0;
    unsigned int chunk_len = (unsigned int)0;
    if(!(ff->mmsh_bytes_left == 0u))
    {
      if(bytes >= (unsigned long int)ff->mmsh_bytes_left)
      {
        bytes = (unsigned long int)ff->mmsh_bytes_left;
        ff->mmsh_bytes_left = (unsigned int)0;
      }

      else
        ff->mmsh_bytes_left = ff->mmsh_bytes_left - (unsigned int)bytes;
    }

    else
      if(!(ff->mmsh_bytes_pad == 0u))
      {
        unsigned int tmp_if_expr_6;
        if(!(ff->mmsh_bytes_pad >= (unsigned int)buf_size))
          tmp_if_expr_6 = ff->mmsh_bytes_pad;

        else
          tmp_if_expr_6 = (unsigned int)buf_size;
        bytes = (unsigned long int)tmp_if_expr_6;
        memset((void *)buffer, 0, bytes);
        ff->mmsh_bytes_pad = ff->mmsh_bytes_pad - (unsigned int)bytes;
        pthread_mutex_unlock(&streambuf->mutex);
        return (signed int)bytes;
      }

      else
        if(bytes >= 12ul)
        {
          chunk_type = (unsigned int)((signed int)*streambuf->readp & 0x7f | (signed int)streambuf->readp[(signed long int)1] << 8);
          chunk_len = (unsigned int)((signed int)streambuf->readp[(signed long int)2] | (signed int)streambuf->readp[(signed long int)3] << 8);
          _buf_inc_readp(streambuf, (unsigned int)12);
          bytes = bytes - (unsigned long int)12;
        }

        else
        {
          return_value__buf_used_14=_buf_used(streambuf);
          if(return_value__buf_used_14 >= 12u)
          {
            unsigned char header[12l];
            memcpy((void *)header, (const void *)streambuf->readp, bytes);
            _buf_inc_readp(streambuf, (unsigned int)bytes);
            memcpy((void *)(header + (signed long int)bytes), (const void *)streambuf->readp, (unsigned long int)12 - bytes);
            _buf_inc_readp(streambuf, (unsigned int)((unsigned long int)12 - bytes));
            chunk_type = (unsigned int)((signed int)header[(signed long int)0] & 0x7f | (signed int)header[(signed long int)1] << 8);
            chunk_len = (unsigned int)((signed int)header[(signed long int)2] | (signed int)header[(signed long int)3] << 8);
            unsigned int return_value__buf_used_7;
            return_value__buf_used_7=_buf_used(streambuf);
            unsigned int return_value__buf_cont_read_8;
            return_value__buf_cont_read_8=_buf_cont_read(streambuf);
            unsigned int tmp_if_expr_11;
            if(!(return_value__buf_used_7 >= return_value__buf_cont_read_8))
            {
              return_value__buf_used_9=_buf_used(streambuf);
              tmp_if_expr_11 = return_value__buf_used_9;
            }

            else
            {
              return_value__buf_cont_read_10=_buf_cont_read(streambuf);
              tmp_if_expr_11 = return_value__buf_cont_read_10;
            }
            bytes = (unsigned long int)tmp_if_expr_11;
            bytes = bytes < (unsigned long int)buf_size ? bytes : (unsigned long int)buf_size;
          }

          else
          {
            const char *return_value_logtime_12;
            return_value_logtime_12=logtime();
            unsigned int return_value__buf_used_13;
            return_value__buf_used_13=_buf_used(streambuf);
            logprint("%s %s:%d chunk parser stalled bytes: %u %u\n", return_value_logtime_12, (const void *)"_read_data", 207, bytes, return_value__buf_used_13);
            pthread_mutex_unlock(&streambuf->mutex);
            return 0;
          }
        }
    if(!(chunk_len == 0u) && !(chunk_type == 0u))
    {
      if(chunk_type == 18468u)
      {
        signed int return_value__parse_packlen_15;
        return_value__parse_packlen_15=_parse_packlen();
        ff->mmsh_packet_len = (unsigned int)return_value__parse_packlen_15;
        ff->mmsh_bytes_pad = (unsigned int)0;
      }

      else
      {
        _Bool tmp_if_expr_17;
        if(chunk_type == 17444u)
          tmp_if_expr_17 = ff->mmsh_packet_len != 0u ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_17 = (_Bool)0;
        if(tmp_if_expr_17)
          ff->mmsh_bytes_pad = (ff->mmsh_packet_len - chunk_len) + (unsigned int)8;

        else
        {
          if((signed int)loglevel_link13 >= lINFO)
          {
            return_value_logtime_16=logtime();
            logprint("%s %s:%d unknown chunk: %04x\n", return_value_logtime_16, (const void *)"_read_data", 221, chunk_type);
          }

          ff->mmsh_bytes_pad = (unsigned int)0;
        }
      }
      if(bytes >= (unsigned long int)(chunk_len + 4294967288u))
      {
        bytes = (unsigned long int)(chunk_len - (unsigned int)8);
        ff->mmsh_bytes_left = (unsigned int)0;
      }

      else
        ff->mmsh_bytes_left = (unsigned int)((unsigned long int)(chunk_len - (unsigned int)8) - bytes);
    }

  }

  memcpy((void *)buffer, (const void *)streambuf->readp, bytes);
  _buf_inc_readp(streambuf, (unsigned int)bytes);
  if(!(ff->mmsh_bytes_pad == 0u))
  {
    if(!(bytes + (unsigned long int)ff->mmsh_bytes_pad >= (unsigned long int)buf_size))
    {
      memset((void *)(buffer + (signed long int)bytes), 0, (unsigned long int)ff->mmsh_bytes_pad);
      bytes = bytes + (unsigned long int)ff->mmsh_bytes_pad;
      ff->mmsh_bytes_pad = (unsigned int)0;
    }

  }

  pthread_mutex_unlock(&streambuf->mutex);
  return (signed int)bytes;
}

// _read_header
// file dsd.c line 98
static signed int _read_header(void)
{
  unsigned int bytes;
  unsigned int return_value__buf_used_1;
  return_value__buf_used_1=_buf_used(streambuf);
  unsigned int return_value__buf_cont_read_2;
  return_value__buf_cont_read_2=_buf_cont_read(streambuf);
  unsigned int tmp_if_expr_5;
  unsigned int return_value__buf_used_3;
  unsigned int return_value__buf_cont_read_4;
  if(!(return_value__buf_used_1 >= return_value__buf_cont_read_2))
  {
    return_value__buf_used_3=_buf_used(streambuf);
    tmp_if_expr_5 = return_value__buf_used_3;
  }

  else
  {
    return_value__buf_cont_read_4=_buf_cont_read(streambuf);
    tmp_if_expr_5 = return_value__buf_cont_read_4;
  }
  bytes = tmp_if_expr_5;
  signed int consume;
  signed int return_value_memcmp_7;
  const char *return_value_logtime_6;
  if(d->type == /*enum*/UNKNOWN)
  {
    if(bytes >= 4u)
    {
      signed int return_value_memcmp_8;
      return_value_memcmp_8=memcmp((const void *)streambuf->readp, (const void *)"FRM8", (unsigned long int)4);
      if(return_value_memcmp_8 == 0)
        d->type = (enum anonymous_20)DSDIFF;

      else
      {
        return_value_memcmp_7=memcmp((const void *)streambuf->readp, (const void *)"DSD ", (unsigned long int)4);
        if(return_value_memcmp_7 == 0)
          d->type = (enum anonymous_20)DSF;

        else
        {
          if((signed int)loglevel_link12 >= lWARN)
          {
            return_value_logtime_6=logtime();
            logprint("%s %s:%d bad type\n", return_value_logtime_6, (const void *)"_read_header", 108);
          }

          return -1;
        }
      }
    }

  }

  unsigned long int return_value_unpack64be_9;
  unsigned long int return_value_unpack64le_10;
  const char *return_value_logtime_12;
  signed int return_value_memcmp_15;
  const char *return_value_logtime_17;
  const char *return_value_logtime_19;
  const char *return_value_logtime_22;
  const char *return_value_logtime_24;
  const char *return_value_logtime_26;
  const char *return_value_logtime_27;
  const char *return_value_logtime_30;
  const char *return_value_logtime_31;
  const char *return_value_logtime_32;
  const char *return_value_logtime_33;
  const char *return_value_logtime_34;
  const char *return_value_logtime_36;
  const char *return_value_logtime_38;
  const char *return_value_logtime_39;
  while(bytes >= 16u)
  {
    char id[5l];
    unsigned long int len;
    unsigned long int tmp_if_expr_11;
    if((signed int)d->type == DSDIFF)
    {
      return_value_unpack64be_9=unpack64be(streambuf->readp + (signed long int)4);
      tmp_if_expr_11 = return_value_unpack64be_9;
    }

    else
    {
      return_value_unpack64le_10=unpack64le(streambuf->readp + (signed long int)4);
      tmp_if_expr_11 = return_value_unpack64le_10;
    }
    len = tmp_if_expr_11;
    memcpy((void *)id, (const void *)streambuf->readp, (unsigned long int)4);
    id[(signed long int)4] = (char)0;
    consume = 0;
    if((signed int)d->type == DSDIFF)
    {
      signed int return_value_strcmp_14;
      return_value_strcmp_14=strcmp(id, "FRM8");
      if(return_value_strcmp_14 == 0)
      {
        signed int return_value_memcmp_13;
        return_value_memcmp_13=memcmp((const void *)(streambuf->readp + (signed long int)12), (const void *)"DSD ", (unsigned long int)4);
        if(return_value_memcmp_13 == 0)
          consume = 16;

        else
        {
          if((signed int)loglevel_link12 >= lWARN)
          {
            return_value_logtime_12=logtime();
            logprint("%s %s:%d bad dsdiff FRM8\n", return_value_logtime_12, (const void *)"_read_header", 125);
          }

          return -1;
        }
      }

      signed int return_value_strcmp_16;
      return_value_strcmp_16=strcmp(id, "PROP");
      if(return_value_strcmp_16 == 0)
      {
        return_value_memcmp_15=memcmp((const void *)(streambuf->readp + (signed long int)12), (const void *)"SND ", (unsigned long int)4);
        if(return_value_memcmp_15 == 0)
          consume = 16;

      }

      signed int return_value_strcmp_18;
      return_value_strcmp_18=strcmp(id, "FVER");
      if(return_value_strcmp_18 == 0)
      {
        if((signed int)loglevel_link12 >= lINFO)
        {
          return_value_logtime_17=logtime();
          logprint("%s %s:%d DSDIFF version: %u.%u.%u.%u\n", return_value_logtime_17, (const void *)"_read_header", 134, streambuf->readp[(signed long int)12], streambuf->readp[(signed long int)13], streambuf->readp[(signed long int)14], streambuf->readp[(signed long int)15]);
        }

      }

      signed int return_value_strcmp_20;
      return_value_strcmp_20=strcmp(id, "FS  ");
      if(return_value_strcmp_20 == 0)
      {
        d->sample_rate=unpackN((unsigned int *)(void *)(streambuf->readp + (signed long int)12));
        if((signed int)loglevel_link12 >= lINFO)
        {
          return_value_logtime_19=logtime();
          logprint("%s %s:%d sample rate: %u\n", return_value_logtime_19, (const void *)"_read_header", 138, d->sample_rate);
        }

      }

      signed int return_value_strcmp_23;
      return_value_strcmp_23=strcmp(id, "CHNL");
      if(return_value_strcmp_23 == 0)
      {
        unsigned short int return_value_unpackn_21;
        return_value_unpackn_21=unpackn((unsigned short int *)(void *)(streambuf->readp + (signed long int)12));
        d->channels = (unsigned int)return_value_unpackn_21;
        if((signed int)loglevel_link12 >= lINFO)
        {
          return_value_logtime_22=logtime();
          logprint("%s %s:%d channels: %u\n", return_value_logtime_22, (const void *)"_read_header", 142, d->channels);
        }

      }

      signed int return_value_strcmp_25;
      return_value_strcmp_25=strcmp(id, "DSD ");
      if(return_value_strcmp_25 == 0)
      {
        if((signed int)loglevel_link12 >= lINFO)
        {
          return_value_logtime_24=logtime();
          logprint("%s %s:%d found dsd len: %lu\n", return_value_logtime_24, (const void *)"_read_header", 145, len);
        }

        d->sample_bytes = len;
        _buf_inc_readp(streambuf, (unsigned int)12);
        bytes = bytes - (unsigned int)12;
        return 1;
      }

    }

    if((signed int)d->type == DSF)
    {
      signed int return_value_strcmp_35;
      return_value_strcmp_35=strcmp(id, "fmt ");
      if(return_value_strcmp_35 == 0)
      {
        if(bytes >= 52u && (unsigned long int)bytes >= len)
        {
          unsigned int version;
          version=unpack32le((const unsigned char *)(void *)(streambuf->readp + (signed long int)12));
          unsigned int format;
          format=unpack32le((const unsigned char *)(void *)(streambuf->readp + (signed long int)16));
          if((signed int)loglevel_link12 >= lINFO)
          {
            return_value_logtime_26=logtime();
            logprint("%s %s:%d DSF version: %u format: %u\n", return_value_logtime_26, (const void *)"_read_header", 158, version, format);
          }

          if(!(format == 0u))
          {
            if((signed int)loglevel_link12 >= lWARN)
            {
              return_value_logtime_27=logtime();
              logprint("%s %s:%d only support DSD raw format\n", return_value_logtime_27, (const void *)"_read_header", 160);
            }

            return -1;
          }

          d->channels=unpack32le((const unsigned char *)(void *)(streambuf->readp + (signed long int)24));
          d->sample_rate=unpack32le((const unsigned char *)(void *)(streambuf->readp + (signed long int)28));
          unsigned int return_value_unpack32le_28;
          return_value_unpack32le_28=unpack32le((const unsigned char *)(void *)(streambuf->readp + (signed long int)32));
          d->lsb_first = return_value_unpack32le_28 == (unsigned int)1;
          unsigned long int return_value_unpack64le_29;
          return_value_unpack64le_29=unpack64le((const unsigned char *)(void *)(streambuf->readp + (signed long int)36));
          d->sample_bytes = return_value_unpack64le_29 / (unsigned long int)8;
          d->block_size=unpack32le((const unsigned char *)(void *)(streambuf->readp + (signed long int)44));
          if((signed int)loglevel_link12 >= lINFO)
          {
            return_value_logtime_30=logtime();
            logprint("%s %s:%d channels: %u\n", return_value_logtime_30, (const void *)"_read_header", 168, d->channels);
          }

          if((signed int)loglevel_link12 >= lINFO)
          {
            return_value_logtime_31=logtime();
            logprint("%s %s:%d sample rate: %u\n", return_value_logtime_31, (const void *)"_read_header", 169, d->sample_rate);
          }

          if((signed int)loglevel_link12 >= lINFO)
          {
            return_value_logtime_32=logtime();
            logprint("%s %s:%d lsb first: %u\n", return_value_logtime_32, (const void *)"_read_header", 170, d->lsb_first);
          }

          if((signed int)loglevel_link12 >= lINFO)
          {
            return_value_logtime_33=logtime();
            logprint("%s %s:%d sample bytes: %lu\n", return_value_logtime_33, (const void *)"_read_header", 171, d->sample_bytes);
          }

          if((signed int)loglevel_link12 >= lINFO)
          {
            return_value_logtime_34=logtime();
            logprint("%s %s:%d block size: %u\n", return_value_logtime_34, (const void *)"_read_header", 172, d->block_size);
          }

        }

        else
          consume = -1;
      }

      signed int return_value_strcmp_37;
      return_value_strcmp_37=strcmp(id, "data");
      if(return_value_strcmp_37 == 0)
      {
        if((signed int)loglevel_link12 >= lINFO)
        {
          return_value_logtime_36=logtime();
          logprint("%s %s:%d found dsd len: %lu\n", return_value_logtime_36, (const void *)"_read_header", 178, len);
        }

        _buf_inc_readp(streambuf, (unsigned int)12);
        bytes = bytes - (unsigned int)12;
        return 1;
      }

    }

    if(consume == 0)
      consume = (signed int)((signed int)d->type == DSDIFF ? len + (unsigned long int)12 : len);

    if(bytes >= (unsigned int)consume)
    {
      if((signed int)loglevel_link12 >= lDEBUG)
      {
        return_value_logtime_38=logtime();
        logprint("%s %s:%d id: %s len: %lu consume: %d\n", return_value_logtime_38, (const void *)"_read_header", 191, (const void *)id, len, consume);
      }

      _buf_inc_readp(streambuf, (unsigned int)consume);
      bytes = bytes - (unsigned int)consume;
    }

    else
      if(consume >= 1)
      {
        if((signed int)loglevel_link12 >= lDEBUG)
        {
          return_value_logtime_39=logtime();
          logprint("%s %s:%d id: %s len: %lu consume: %d - partial consume: %u\n", return_value_logtime_39, (const void *)"_read_header", 195, (const void *)id, len, consume, bytes);
        }

        _buf_inc_readp(streambuf, bytes);
        d->consume = (unsigned int)consume - bytes;
        break;
      }

      else
        break;
  }
  return 0;
}

// _scale_and_pack_frames
// file squeezelite.h line 618
void _scale_and_pack_frames(void *outputptr, signed int *inputptr, unsigned int cnt, signed int gainL, signed int gainR, enum anonymous_22 format)
{
  unsigned int tmp_post_1;
  unsigned int tmp_post_3;
  unsigned int tmp_post_7;
  unsigned int tmp_post_12;
  unsigned int tmp_post_49;
  switch((signed int)format)
  {
    case S16_LE:
    {
      unsigned int *_scale_and_pack_frames__1__1__1__optr = (unsigned int *)(void *)outputptr;
      if(gainL == 0x10000 && gainR == 0x10000)
        do
        {
          tmp_post_1 = cnt;
          cnt = cnt - 1u;
          if(tmp_post_1 == 0u)
            break;

          unsigned int *tmp_post_2 = _scale_and_pack_frames__1__1__1__optr;
          _scale_and_pack_frames__1__1__1__optr = _scale_and_pack_frames__1__1__1__optr + 1l;
          *tmp_post_2 = (unsigned int)(*inputptr >> 16 & 0x0000ffff) | (unsigned int)inputptr[(signed long int)1] & 0xffff0000;
          inputptr = inputptr + (signed long int)2;
        }
        while((_Bool)1);

      else
        do
        {
          tmp_post_3 = cnt;
          cnt = cnt - 1u;
          if(tmp_post_3 == 0u)
            break;

          unsigned int *tmp_post_4 = _scale_and_pack_frames__1__1__1__optr;
          _scale_and_pack_frames__1__1__1__optr = _scale_and_pack_frames__1__1__1__optr + 1l;
          signed int return_value_gain_5;
          return_value_gain_5=gain(gainL, *inputptr);
          signed int return_value_gain_6;
          return_value_gain_6=gain(gainR, inputptr[(signed long int)1]);
          *tmp_post_4 = (unsigned int)(return_value_gain_5 >> 16 & 0x0000ffff) | (unsigned int)return_value_gain_6 & 0xffff0000;
          inputptr = inputptr + (signed long int)2;
        }
        while((_Bool)1);
      break;
    }
    case S24_LE:
    {
      unsigned int *_scale_and_pack_frames__1__1__2__optr = (unsigned int *)(void *)outputptr;
      if(gainL == 0x10000 && gainR == 0x10000)
        do
        {
          tmp_post_7 = cnt;
          cnt = cnt - 1u;
          if(tmp_post_7 == 0u)
            break;

          unsigned int *tmp_post_8 = _scale_and_pack_frames__1__1__2__optr;
          _scale_and_pack_frames__1__1__2__optr = _scale_and_pack_frames__1__1__2__optr + 1l;
          signed int *tmp_post_9 = inputptr;
          inputptr = inputptr + 1l;
          *tmp_post_8 = (unsigned int)(*tmp_post_9 >> 8);
          unsigned int *tmp_post_10 = _scale_and_pack_frames__1__1__2__optr;
          _scale_and_pack_frames__1__1__2__optr = _scale_and_pack_frames__1__1__2__optr + 1l;
          signed int *tmp_post_11 = inputptr;
          inputptr = inputptr + 1l;
          *tmp_post_10 = (unsigned int)(*tmp_post_11 >> 8);
        }
        while((_Bool)1);

      else
        do
        {
          tmp_post_12 = cnt;
          cnt = cnt - 1u;
          if(tmp_post_12 == 0u)
            break;

          unsigned int *tmp_post_13 = _scale_and_pack_frames__1__1__2__optr;
          _scale_and_pack_frames__1__1__2__optr = _scale_and_pack_frames__1__1__2__optr + 1l;
          signed int *tmp_post_14 = inputptr;
          inputptr = inputptr + 1l;
          signed int return_value_gain_15;
          return_value_gain_15=gain(gainL, *tmp_post_14);
          *tmp_post_13 = (unsigned int)(return_value_gain_15 >> 8);
          unsigned int *tmp_post_16 = _scale_and_pack_frames__1__1__2__optr;
          _scale_and_pack_frames__1__1__2__optr = _scale_and_pack_frames__1__1__2__optr + 1l;
          signed int *tmp_post_17 = inputptr;
          inputptr = inputptr + 1l;
          signed int return_value_gain_18;
          return_value_gain_18=gain(gainR, *tmp_post_17);
          *tmp_post_16 = (unsigned int)(return_value_gain_18 >> 8);
        }
        while((_Bool)1);
      break;
    }
    case S24_3LE:
    {
      unsigned char *_scale_and_pack_frames__1__1__3__optr = (unsigned char *)(void *)outputptr;
      if(gainL == 0x10000 && gainR == 0x10000)
        while(!(cnt == 0u))
          if((3ul & (unsigned long int)_scale_and_pack_frames__1__1__3__optr) == 0ul && cnt >= 2u)
          {
            unsigned int *_scale_and_pack_frames__1__1__3__1__1__1__o_ptr = (unsigned int *)(void *)_scale_and_pack_frames__1__1__3__optr;
            while(cnt >= 2u)
            {
              signed int _scale_and_pack_frames__1__1__3__1__1__1__1__l1;
              signed int *tmp_post_19 = inputptr;
              inputptr = inputptr + 1l;
              _scale_and_pack_frames__1__1__3__1__1__1__1__l1 = *tmp_post_19;
              signed int _scale_and_pack_frames__1__1__3__1__1__1__1__r1;
              signed int *tmp_post_20 = inputptr;
              inputptr = inputptr + 1l;
              _scale_and_pack_frames__1__1__3__1__1__1__1__r1 = *tmp_post_20;
              signed int _scale_and_pack_frames__1__1__3__1__1__1__1__l2;
              signed int *tmp_post_21 = inputptr;
              inputptr = inputptr + 1l;
              _scale_and_pack_frames__1__1__3__1__1__1__1__l2 = *tmp_post_21;
              signed int r2;
              signed int *tmp_post_22 = inputptr;
              inputptr = inputptr + 1l;
              r2 = *tmp_post_22;
              unsigned int *tmp_post_23 = _scale_and_pack_frames__1__1__3__1__1__1__o_ptr;
              _scale_and_pack_frames__1__1__3__1__1__1__o_ptr = _scale_and_pack_frames__1__1__3__1__1__1__o_ptr + 1l;
              *tmp_post_23 = ((unsigned int)_scale_and_pack_frames__1__1__3__1__1__1__1__l1 & 0xffffff00) >> 8 | (unsigned int)((_scale_and_pack_frames__1__1__3__1__1__1__1__r1 & 0x0000ff00) << 16);
              unsigned int *tmp_post_24 = _scale_and_pack_frames__1__1__3__1__1__1__o_ptr;
              _scale_and_pack_frames__1__1__3__1__1__1__o_ptr = _scale_and_pack_frames__1__1__3__1__1__1__o_ptr + 1l;
              *tmp_post_24 = ((unsigned int)_scale_and_pack_frames__1__1__3__1__1__1__1__r1 & 0xffff0000) >> 16 | (unsigned int)((_scale_and_pack_frames__1__1__3__1__1__1__1__l2 & 0x00ffff00) << 8);
              unsigned int *tmp_post_25 = _scale_and_pack_frames__1__1__3__1__1__1__o_ptr;
              _scale_and_pack_frames__1__1__3__1__1__1__o_ptr = _scale_and_pack_frames__1__1__3__1__1__1__o_ptr + 1l;
              *tmp_post_25 = ((unsigned int)_scale_and_pack_frames__1__1__3__1__1__1__1__l2 & 0xff000000) >> 24 | (unsigned int)r2 & 0xffffff00;
              _scale_and_pack_frames__1__1__3__optr = _scale_and_pack_frames__1__1__3__optr + (signed long int)12;
              cnt = cnt - (unsigned int)2;
            }
          }

          else
          {
            signed int lsample;
            signed int *tmp_post_26 = inputptr;
            inputptr = inputptr + 1l;
            lsample = *tmp_post_26;
            signed int rsample;
            signed int *tmp_post_27 = inputptr;
            inputptr = inputptr + 1l;
            rsample = *tmp_post_27;
            unsigned char *tmp_post_28 = _scale_and_pack_frames__1__1__3__optr;
            _scale_and_pack_frames__1__1__3__optr = _scale_and_pack_frames__1__1__3__optr + 1l;
            *tmp_post_28 = (unsigned char)((lsample & 0x0000ff00) >> 8);
            unsigned char *tmp_post_29 = _scale_and_pack_frames__1__1__3__optr;
            _scale_and_pack_frames__1__1__3__optr = _scale_and_pack_frames__1__1__3__optr + 1l;
            *tmp_post_29 = (unsigned char)((lsample & 0x00ff0000) >> 16);
            unsigned char *tmp_post_30 = _scale_and_pack_frames__1__1__3__optr;
            _scale_and_pack_frames__1__1__3__optr = _scale_and_pack_frames__1__1__3__optr + 1l;
            *tmp_post_30 = (unsigned char)(((unsigned int)lsample & 0xff000000) >> 24);
            unsigned char *tmp_post_31 = _scale_and_pack_frames__1__1__3__optr;
            _scale_and_pack_frames__1__1__3__optr = _scale_and_pack_frames__1__1__3__optr + 1l;
            *tmp_post_31 = (unsigned char)((rsample & 0x0000ff00) >> 8);
            unsigned char *tmp_post_32 = _scale_and_pack_frames__1__1__3__optr;
            _scale_and_pack_frames__1__1__3__optr = _scale_and_pack_frames__1__1__3__optr + 1l;
            *tmp_post_32 = (unsigned char)((rsample & 0x00ff0000) >> 16);
            unsigned char *tmp_post_33 = _scale_and_pack_frames__1__1__3__optr;
            _scale_and_pack_frames__1__1__3__optr = _scale_and_pack_frames__1__1__3__optr + 1l;
            *tmp_post_33 = (unsigned char)(((unsigned int)rsample & 0xff000000) >> 24);
            cnt = cnt - 1u;
          }

      else
        while(!(cnt == 0u))
          if((3ul & (unsigned long int)_scale_and_pack_frames__1__1__3__optr) == 0ul && cnt >= 2u)
          {
            unsigned int *o_ptr = (unsigned int *)(void *)_scale_and_pack_frames__1__1__3__optr;
            while(cnt >= 2u)
            {
              signed int l1;
              signed int *tmp_post_34 = inputptr;
              inputptr = inputptr + 1l;
              l1=gain(gainL, *tmp_post_34);
              signed int r1;
              signed int *tmp_post_35 = inputptr;
              inputptr = inputptr + 1l;
              r1=gain(gainR, *tmp_post_35);
              signed int l2;
              signed int *tmp_post_36 = inputptr;
              inputptr = inputptr + 1l;
              l2=gain(gainL, *tmp_post_36);
              signed int _scale_and_pack_frames__1__1__3__2__1__1__1__r2;
              signed int *tmp_post_37 = inputptr;
              inputptr = inputptr + 1l;
              _scale_and_pack_frames__1__1__3__2__1__1__1__r2=gain(gainR, *tmp_post_37);
              unsigned int *tmp_post_38 = o_ptr;
              o_ptr = o_ptr + 1l;
              *tmp_post_38 = ((unsigned int)l1 & 0xffffff00) >> 8 | (unsigned int)((r1 & 0x0000ff00) << 16);
              unsigned int *tmp_post_39 = o_ptr;
              o_ptr = o_ptr + 1l;
              *tmp_post_39 = ((unsigned int)r1 & 0xffff0000) >> 16 | (unsigned int)((l2 & 0x00ffff00) << 8);
              unsigned int *tmp_post_40 = o_ptr;
              o_ptr = o_ptr + 1l;
              *tmp_post_40 = ((unsigned int)l2 & 0xff000000) >> 24 | (unsigned int)_scale_and_pack_frames__1__1__3__2__1__1__1__r2 & 0xffffff00;
              _scale_and_pack_frames__1__1__3__optr = _scale_and_pack_frames__1__1__3__optr + (signed long int)12;
              cnt = cnt - (unsigned int)2;
            }
          }

          else
          {
            signed int _scale_and_pack_frames__1__1__3__2__1__2__lsample;
            signed int *tmp_post_41 = inputptr;
            inputptr = inputptr + 1l;
            _scale_and_pack_frames__1__1__3__2__1__2__lsample=gain(gainL, *tmp_post_41);
            signed int _scale_and_pack_frames__1__1__3__2__1__2__rsample;
            signed int *tmp_post_42 = inputptr;
            inputptr = inputptr + 1l;
            _scale_and_pack_frames__1__1__3__2__1__2__rsample=gain(gainR, *tmp_post_42);
            unsigned char *tmp_post_43 = _scale_and_pack_frames__1__1__3__optr;
            _scale_and_pack_frames__1__1__3__optr = _scale_and_pack_frames__1__1__3__optr + 1l;
            *tmp_post_43 = (unsigned char)((_scale_and_pack_frames__1__1__3__2__1__2__lsample & 0x0000ff00) >> 8);
            unsigned char *tmp_post_44 = _scale_and_pack_frames__1__1__3__optr;
            _scale_and_pack_frames__1__1__3__optr = _scale_and_pack_frames__1__1__3__optr + 1l;
            *tmp_post_44 = (unsigned char)((_scale_and_pack_frames__1__1__3__2__1__2__lsample & 0x00ff0000) >> 16);
            unsigned char *tmp_post_45 = _scale_and_pack_frames__1__1__3__optr;
            _scale_and_pack_frames__1__1__3__optr = _scale_and_pack_frames__1__1__3__optr + 1l;
            *tmp_post_45 = (unsigned char)(((unsigned int)_scale_and_pack_frames__1__1__3__2__1__2__lsample & 0xff000000) >> 24);
            unsigned char *tmp_post_46 = _scale_and_pack_frames__1__1__3__optr;
            _scale_and_pack_frames__1__1__3__optr = _scale_and_pack_frames__1__1__3__optr + 1l;
            *tmp_post_46 = (unsigned char)((_scale_and_pack_frames__1__1__3__2__1__2__rsample & 0x0000ff00) >> 8);
            unsigned char *tmp_post_47 = _scale_and_pack_frames__1__1__3__optr;
            _scale_and_pack_frames__1__1__3__optr = _scale_and_pack_frames__1__1__3__optr + 1l;
            *tmp_post_47 = (unsigned char)((_scale_and_pack_frames__1__1__3__2__1__2__rsample & 0x00ff0000) >> 16);
            unsigned char *tmp_post_48 = _scale_and_pack_frames__1__1__3__optr;
            _scale_and_pack_frames__1__1__3__optr = _scale_and_pack_frames__1__1__3__optr + 1l;
            *tmp_post_48 = (unsigned char)(((unsigned int)_scale_and_pack_frames__1__1__3__2__1__2__rsample & 0xff000000) >> 24);
            cnt = cnt - 1u;
          }
      break;
    }
    case S32_LE:
    {
      unsigned int *_scale_and_pack_frames__1__1__4__optr = (unsigned int *)(void *)outputptr;
      if(gainL == 0x10000 && gainR == 0x10000)
        memcpy(outputptr, (const void *)inputptr, (unsigned long int)(cnt * (unsigned int)8));

      else
        do
        {
          tmp_post_49 = cnt;
          cnt = cnt - 1u;
          if(tmp_post_49 == 0u)
            break;

          unsigned int *tmp_post_50 = _scale_and_pack_frames__1__1__4__optr;
          _scale_and_pack_frames__1__1__4__optr = _scale_and_pack_frames__1__1__4__optr + 1l;
          signed int *tmp_post_51 = inputptr;
          inputptr = inputptr + 1l;
          signed int return_value_gain_52;
          return_value_gain_52=gain(gainL, *tmp_post_51);
          *tmp_post_50 = (unsigned int)return_value_gain_52;
          unsigned int *tmp_post_53 = _scale_and_pack_frames__1__1__4__optr;
          _scale_and_pack_frames__1__1__4__optr = _scale_and_pack_frames__1__1__4__optr + 1l;
          signed int *tmp_post_54 = inputptr;
          inputptr = inputptr + 1l;
          signed int return_value_gain_55;
          return_value_gain_55=gain(gainR, *tmp_post_54);
          *tmp_post_53 = (unsigned int)return_value_gain_55;
        }
        while((_Bool)1);
    }
  }
}

// _seek_cb
// file vorbis.c line 99
static signed int _seek_cb(void *datasource, signed long int offset, signed int whence)
{
  return -1;
}

// _stdout_write_frames
// file output_stdout.c line 47
static signed int _stdout_write_frames(unsigned int out_frames, _Bool silence, signed int gainL, signed int gainR, signed int cross_gain_in, signed int cross_gain_out, signed int **cross_ptr)
{
  unsigned char *obuf;
  if(silence == (_Bool)0)
  {
    if((signed int)output.fade == FADE_ACTIVE && (signed int)output.fade_dir == FADE_CROSS)
    {
      if(!(*cross_ptr == ((signed int *)NULL)))
        _apply_cross(outputbuf, out_frames, cross_gain_in, cross_gain_out, cross_ptr);

    }

    obuf = outputbuf->readp;
  }

  else
    obuf = silencebuf;
  if(!(output.dop == (_Bool)0))
  {
    if(!(silence == (_Bool)0))
      obuf = silencebuf_dop;

    update_dop((unsigned int *)obuf, out_frames, output.invert != (_Bool)0 && !(silence != (_Bool)0));
  }

  _scale_and_pack_frames((void *)(buf_link2 + (signed long int)(buffill * (unsigned int)bytes_per_frame)), (signed int *)(void *)obuf, out_frames, gainL, gainR, output.format);
  buffill = buffill + out_frames;
  return (signed int)out_frames;
}

// _tell_cb
// file vorbis.c line 101
static signed long int _tell_cb(void *datasource)
{
  return (signed long int)0;
}

// _vis_export
// file squeezelite.h line 626
void _vis_export(struct buffer *outputbuf, struct outputstate *output, unsigned int out_frames, _Bool silence)
{
  const char *return_value_logtime_1;
  unsigned int tmp_post_2;
  unsigned int tmp_post_7;
  if(!(vis_mmap == ((struct vis_t *)NULL)))
  {
    signed int err;
    err=pthread_rwlock_trywrlock(&vis_mmap->rwlock);
    if(!(err == 0))
    {
      struct timespec ts;
      clock_gettime(0, &ts);
      ts.tv_nsec = ts.tv_nsec + (signed long int)1000000;
      if(ts.tv_nsec >= 1000000001l)
      {
        ts.tv_sec = ts.tv_sec + (signed long int)1;
        ts.tv_nsec = ts.tv_nsec - (signed long int)1000000000;
      }

      err=pthread_rwlock_timedwrlock(&vis_mmap->rwlock, &ts);
    }

    if(!(err == 0))
    {
      if((signed int)loglevel_link16 >= lDEBUG)
      {
        return_value_logtime_1=logtime();
        logprint("%s %s:%d failed to get wrlock - skipping visulizer export\n", return_value_logtime_1, (const void *)"_vis_export", 68);
      }

    }

    else
    {
      if(!(silence == (_Bool)0))
        vis_mmap->running = (_Bool)0;

      else
      {
        unsigned int vis_cnt = out_frames;
        signed int *ptr = (signed int *)outputbuf->readp;
        unsigned int i = vis_mmap->buf_index;
        if(output->current_replay_gain == 0u)
          do
          {
            tmp_post_2 = vis_cnt;
            vis_cnt = vis_cnt - 1u;
            if(tmp_post_2 == 0u)
              break;

            unsigned int tmp_post_3 = i;
            i = i + 1u;
            signed int *tmp_post_4 = ptr;
            ptr = ptr + 1l;
            vis_mmap->buffer[(signed long int)tmp_post_3] = (signed short int)(*tmp_post_4 >> 16);
            unsigned int tmp_post_5 = i;
            i = i + 1u;
            signed int *tmp_post_6 = ptr;
            ptr = ptr + 1l;
            vis_mmap->buffer[(signed long int)tmp_post_5] = (signed short int)(*tmp_post_6 >> 16);
            if(i == 16384u)
              i = (unsigned int)0;

          }
          while((_Bool)1);

        else
          do
          {
            tmp_post_7 = vis_cnt;
            vis_cnt = vis_cnt - 1u;
            if(tmp_post_7 == 0u)
              break;

            unsigned int tmp_post_8 = i;
            i = i + 1u;
            signed int *tmp_post_9 = ptr;
            ptr = ptr + 1l;
            signed int return_value_gain_10;
            return_value_gain_10=gain(*tmp_post_9, (signed int)output->current_replay_gain);
            vis_mmap->buffer[(signed long int)tmp_post_8] = (signed short int)(return_value_gain_10 >> 16);
            unsigned int tmp_post_11 = i;
            i = i + 1u;
            signed int *tmp_post_12 = ptr;
            ptr = ptr + 1l;
            signed int return_value_gain_13;
            return_value_gain_13=gain(*tmp_post_12, (signed int)output->current_replay_gain);
            vis_mmap->buffer[(signed long int)tmp_post_11] = (signed short int)(return_value_gain_13 >> 16);
            if(i == 16384u)
              i = (unsigned int)0;

          }
          while((_Bool)1);
        vis_mmap->updated=time((signed long int *)(void *)0);
        vis_mmap->running = (_Bool)1;
        vis_mmap->buf_index = i;
        vis_mmap->rate = output->current_sample_rate;
      }
      pthread_rwlock_unlock(&vis_mmap->rwlock);
    }
  }

}

// _write_frames
// file output_pa.c line 302
static signed int _write_frames(unsigned int out_frames, _Bool silence, signed int gainL, signed int gainR, signed int cross_gain_in, signed int cross_gain_out, signed int **cross_ptr)
{
  if(silence == (_Bool)0)
  {
    if((signed int)output.fade == FADE_ACTIVE && (signed int)output.fade_dir == FADE_CROSS)
    {
      if(!(*cross_ptr == ((signed int *)NULL)))
        _apply_cross(outputbuf, out_frames, cross_gain_in, cross_gain_out, cross_ptr);

    }

    if(!(gainL == 0x10000) || !(gainR == 0x10000))
      _apply_gain(outputbuf, out_frames, gainL, gainR);

    if(!(output.dop == (_Bool)0))
      update_dop((unsigned int *)outputbuf->readp, out_frames, output.invert);

    memcpy((void *)optr, (const void *)outputbuf->readp, (unsigned long int)(out_frames * (unsigned int)8));
  }

  else
  {
    unsigned char *_write_frames__1__2__buf = silencebuf;
    if(!(output.dop == (_Bool)0))
    {
      _write_frames__1__2__buf = silencebuf_dop;
      update_dop((unsigned int *)_write_frames__1__2__buf, out_frames, (_Bool)0);
    }

    memcpy((void *)optr, (const void *)_write_frames__1__2__buf, (unsigned long int)(out_frames * (unsigned int)8));
  }
  optr = optr + (signed long int)(out_frames * (unsigned int)8);
  return (signed int)out_frames;
}

// _write_samples
// file process.c line 51
static void _write_samples(void)
{
  unsigned long int frames = (unsigned long int)process_link10.out_frames;
  unsigned int *iptr = (unsigned int *)process_link10.outbuf;
  unsigned int cnt = (unsigned int)10;
  pthread_mutex_lock(&outputbuf->mutex);
  unsigned int return_value__buf_space_3;
  unsigned int return_value__buf_cont_write_4;
  while(frames >= 1ul)
  {
    unsigned int _write_samples__1__1__f;
    unsigned int return_value__buf_space_1;
    return_value__buf_space_1=_buf_space(outputbuf);
    unsigned int return_value__buf_cont_write_2;
    return_value__buf_cont_write_2=_buf_cont_write(outputbuf);
    unsigned int tmp_if_expr_5;
    if(!(return_value__buf_space_1 >= return_value__buf_cont_write_2))
    {
      return_value__buf_space_3=_buf_space(outputbuf);
      tmp_if_expr_5 = return_value__buf_space_3;
    }

    else
    {
      return_value__buf_cont_write_4=_buf_cont_write(outputbuf);
      tmp_if_expr_5 = return_value__buf_cont_write_4;
    }
    _write_samples__1__1__f = tmp_if_expr_5 / (unsigned int)8;
    unsigned int *_write_samples__1__1__optr = (unsigned int *)outputbuf->writep;
    if(_write_samples__1__1__f >= 1u)
    {
      _write_samples__1__1__f = (unsigned int)((unsigned long int)_write_samples__1__1__f < frames ? (unsigned long int)_write_samples__1__1__f : frames);
      memcpy((void *)_write_samples__1__1__optr, (const void *)iptr, (unsigned long int)(_write_samples__1__1__f * (unsigned int)8));
      frames = frames - (unsigned long int)_write_samples__1__1__f;
      _buf_inc_writep(outputbuf, _write_samples__1__1__f * (unsigned int)8);
      iptr = iptr + (signed long int)((unsigned long int)(_write_samples__1__1__f * (unsigned int)8) / sizeof(unsigned int) /*4ul*/ );
    }

    else
    {
      unsigned int tmp_post_7 = cnt;
      cnt = cnt - 1u;
      if(!(tmp_post_7 == 0u))
      {
        pthread_mutex_unlock(&outputbuf->mutex);
        usleep((unsigned int)10000);
        pthread_mutex_lock(&outputbuf->mutex);
      }

      else
      {
        const char *return_value_logtime_6;
        return_value_logtime_6=logtime();
        logprint("%s %s:%d unable to get space in output buffer\n", return_value_logtime_6, (const void *)"_write_samples", 84);
        pthread_mutex_unlock(&outputbuf->mutex);
        goto __CPROVER_DUMP_L9;
      }
    }
  }
  pthread_mutex_unlock(&outputbuf->mutex);

__CPROVER_DUMP_L9:
  ;
}

// av__err2str
// file ffmpeg.c line 122
static char * av__err2str(signed int errnum)
{
  static char av__err2str__1__buf[64l];
  av_strerror(errnum, av__err2str__1__buf, (unsigned long int)64);
  return av__err2str__1__buf;
}

// av_err_callback
// file ffmpeg.c line 661
void av_err_callback(void *avcl, signed int level, const char *fmt, void **vl)
{
  if(ff_log_level >= level)
  {
    const char *return_value_logtime_1;
    return_value_logtime_1=logtime();
    fprintf(stderr, "%s ffmpeg: ", return_value_logtime_1);
    vfprintf(stderr, fmt, vl);
    fflush(stderr);
  }

}

// buf_adjust
// file buffer.c line 67
void buf_adjust(struct buffer *buf, unsigned long int mod)
{
  unsigned long int size;
  pthread_mutex_lock(&buf->mutex);
  size = (unsigned long int)(unsigned int)(buf->base_size / mod) * mod;
  buf->readp = buf->buf;
  buf->writep = buf->buf;
  buf->wrap = buf->buf + (signed long int)size;
  buf->size = size;
  pthread_mutex_unlock(&buf->mutex);
}

// buf_destroy
// file buffer.c line 106
void buf_destroy(struct buffer *buf)
{
  if(!(buf->buf == ((unsigned char *)NULL)))
  {
    free((void *)buf->buf);
    buf->buf = (unsigned char *)(void *)0;
    buf->size = (unsigned long int)0;
    buf->base_size = (unsigned long int)0;
    pthread_mutex_destroy(&buf->mutex);
  }

}

// buf_flush
// file squeezelite.h line 422
void buf_flush(struct buffer *buf)
{
  pthread_mutex_lock(&buf->mutex);
  buf->readp = buf->buf;
  buf->writep = buf->buf;
  pthread_mutex_unlock(&buf->mutex);
}

// buf_init
// file buffer.c line 96
void buf_init(struct buffer *buf, unsigned long int size)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(size);
  buf->buf = (unsigned char *)return_value_malloc_1;
  buf->readp = buf->buf;
  buf->writep = buf->buf;
  buf->wrap = buf->buf + (signed long int)size;
  buf->size = size;
  buf->base_size = size;
  union anonymous_7 attr;
  pthread_mutexattr_init(&attr);
  pthread_mutexattr_setprotocol(&attr, 1);
  pthread_mutex_init(&buf->mutex, &attr);
  pthread_mutexattr_destroy(&attr);
}

// codec_open
// file squeezelite.h line 496
void codec_open(unsigned char format, unsigned char sample_size, unsigned char sample_rate, unsigned char channels, unsigned char endianness)
{
  signed int i;
  const char *return_value_logtime_1;
  if((signed int)loglevel_link5 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d codec open: '%c'\n", return_value_logtime_1, (const void *)"codec_open", 218, format);
  }

  pthread_mutex_lock(&decode.mutex);
  decode.new_stream = (_Bool)1;
  decode.state = (enum anonymous_23)DECODE_STOPPED;
  decode.direct = (_Bool)1;
  i = 0;
  const char *return_value_logtime_2;
  for( ; !(i >= 9); i = i + 1)
    if(!(codecs[(signed long int)i] == ((struct codec *)NULL)))
    {
      if((signed int)codecs[(signed long int)i]->id == (signed int)format)
      {
        if(!(codec == ((struct codec *)NULL)))
        {
          if(!(codec == codecs[(signed long int)i]))
          {
            if((signed int)loglevel_link5 >= lINFO)
            {
              return_value_logtime_2=logtime();
              logprint("%s %s:%d closing codec: '%c'\n", return_value_logtime_2, (const void *)"codec_open", 235, codec->id);
            }

            codec->close();
          }

        }

        codec = codecs[(signed long int)i];
        codec->open(sample_size, sample_rate, channels, endianness);
        decode.state = (enum anonymous_23)DECODE_READY;
        pthread_mutex_unlock(&decode.mutex);
      }

    }

  pthread_mutex_unlock(&decode.mutex);
  const char *return_value_logtime_3;
  return_value_logtime_3=logtime();
  logprint("%s %s:%d codec not found\n", return_value_logtime_3, (const void *)"codec_open", 252);
}

// connect_timeout
// file squeezelite.h line 379
signed int connect_timeout(signed int sock, struct sockaddr *addr, unsigned int addrlen, signed int timeout)
{
  struct anonymous_12 w;
  struct anonymous_12 e;
  struct timeval tval;
  signed int return_value_connect_2;
  return_value_connect_2=connect(sock, addr, addrlen);
  if(!(return_value_connect_2 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 115))
      return -1;

  }

  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_12) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&w)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&w)->__fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&w)->__fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  e = w;
  tval.tv_sec = (signed long int)timeout;
  tval.tv_usec = (signed long int)0;
  signed int return_value_select_3;
  return_value_select_3=select(sock + 1, (struct anonymous_12 *)(void *)0, &w, &e, timeout != 0 ? &tval : (struct timeval *)(void *)0);
  if(return_value_select_3 == 1)
  {
    if(!((w.__fds_bits[(signed long int)(sock / 8)] & (signed long int)(1UL << sock % 8)) == 0l))
    {
      signed int error = 0;
      unsigned int len = (unsigned int)sizeof(signed int) /*4ul*/ ;
      getsockopt(sock, 1, 4, (void *)&error, &len);
      return error;
    }

  }

  return -1;
}

// decode_close
// file squeezelite.h line 493
void decode_close(void)
{
  const char *return_value_logtime_1;
  if((signed int)loglevel_link5 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d close decode\n", return_value_logtime_1, (const void *)"decode_close", 175);
  }

  pthread_mutex_lock(&decode.mutex);
  if(!(codec == ((struct codec *)NULL)))
  {
    codec->close();
    codec = (struct codec *)(void *)0;
  }

  running_link4 = (_Bool)0;
  pthread_mutex_unlock(&decode.mutex);
  pthread_join(thread_link2, (void **)(void *)0);
  pthread_mutex_destroy(&decode.mutex);
}

// decode_flush
// file squeezelite.h line 494
void decode_flush(void)
{
  const char *return_value_logtime_1;
  if((signed int)loglevel_link5 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d decode flush\n", return_value_logtime_1, (const void *)"decode_flush", 190);
  }

  pthread_mutex_lock(&decode.mutex);
  decode.state = (enum anonymous_23)DECODE_STOPPED;
  if(decode.direct == (_Bool)0)
    process_flush();

  pthread_mutex_unlock(&decode.mutex);
}

// decode_init
// file squeezelite.h line 492
void decode_init(enum anonymous_8 level, const char *include_codecs, const char *exclude_codecs)
{
  signed int i;
  loglevel_link5 = level;
  const char *return_value_logtime_1;
  if((signed int)loglevel_link5 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d init decode, include codecs: %s exclude codecs: %s\n", return_value_logtime_1, (const void *)"decode_init", 129, include_codecs != ((const char *)NULL) ? include_codecs : "", exclude_codecs);
  }

  i = 0;
  char *return_value_strstr_5;
  return_value_strstr_5=strstr(exclude_codecs, "dsd");
  char *return_value_strstr_3;
  if(return_value_strstr_5 == ((char *)NULL))
  {
    _Bool tmp_if_expr_4;
    if(include_codecs == ((const char *)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_strstr_3=strstr(include_codecs, "dsd");
      tmp_if_expr_4 = return_value_strstr_3 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      signed int tmp_post_2 = i;
      i = i + 1;
      codecs[(signed long int)tmp_post_2]=register_dsd();
    }

  }

  char *return_value_strstr_9;
  return_value_strstr_9=strstr(exclude_codecs, "alac");
  char *return_value_strstr_7;
  if(return_value_strstr_9 == ((char *)NULL))
  {
    _Bool tmp_if_expr_8;
    if(include_codecs == ((const char *)NULL))
      tmp_if_expr_8 = (_Bool)1;

    else
    {
      return_value_strstr_7=strstr(include_codecs, "alac");
      tmp_if_expr_8 = return_value_strstr_7 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_8)
    {
      signed int tmp_post_6 = i;
      i = i + 1;
      codecs[(signed long int)tmp_post_6]=register_ff("alc");
    }

  }

  char *return_value_strstr_13;
  return_value_strstr_13=strstr(exclude_codecs, "wma");
  char *return_value_strstr_11;
  if(return_value_strstr_13 == ((char *)NULL))
  {
    _Bool tmp_if_expr_12;
    if(include_codecs == ((const char *)NULL))
      tmp_if_expr_12 = (_Bool)1;

    else
    {
      return_value_strstr_11=strstr(include_codecs, "wma");
      tmp_if_expr_12 = return_value_strstr_11 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_12)
    {
      signed int tmp_post_10 = i;
      i = i + 1;
      codecs[(signed long int)tmp_post_10]=register_ff("wma");
    }

  }

  char *return_value_strstr_17;
  return_value_strstr_17=strstr(exclude_codecs, "aac");
  char *return_value_strstr_15;
  if(return_value_strstr_17 == ((char *)NULL))
  {
    _Bool tmp_if_expr_16;
    if(include_codecs == ((const char *)NULL))
      tmp_if_expr_16 = (_Bool)1;

    else
    {
      return_value_strstr_15=strstr(include_codecs, "aac");
      tmp_if_expr_16 = return_value_strstr_15 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_16)
    {
      signed int tmp_post_14 = i;
      i = i + 1;
      codecs[(signed long int)tmp_post_14]=register_faad();
    }

  }

  char *return_value_strstr_21;
  return_value_strstr_21=strstr(exclude_codecs, "ogg");
  char *return_value_strstr_19;
  if(return_value_strstr_21 == ((char *)NULL))
  {
    _Bool tmp_if_expr_20;
    if(include_codecs == ((const char *)NULL))
      tmp_if_expr_20 = (_Bool)1;

    else
    {
      return_value_strstr_19=strstr(include_codecs, "ogg");
      tmp_if_expr_20 = return_value_strstr_19 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_20)
    {
      signed int tmp_post_18 = i;
      i = i + 1;
      codecs[(signed long int)tmp_post_18]=register_vorbis();
    }

  }

  char *return_value_strstr_25;
  return_value_strstr_25=strstr(exclude_codecs, "flac");
  char *return_value_strstr_23;
  if(return_value_strstr_25 == ((char *)NULL))
  {
    _Bool tmp_if_expr_24;
    if(include_codecs == ((const char *)NULL))
      tmp_if_expr_24 = (_Bool)1;

    else
    {
      return_value_strstr_23=strstr(include_codecs, "flac");
      tmp_if_expr_24 = return_value_strstr_23 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_24)
    {
      signed int tmp_post_22 = i;
      i = i + 1;
      codecs[(signed long int)tmp_post_22]=register_flac();
    }

  }

  char *return_value_strstr_29;
  return_value_strstr_29=strstr(exclude_codecs, "pcm");
  char *return_value_strstr_27;
  if(return_value_strstr_29 == ((char *)NULL))
  {
    _Bool tmp_if_expr_28;
    if(include_codecs == ((const char *)NULL))
      tmp_if_expr_28 = (_Bool)1;

    else
    {
      return_value_strstr_27=strstr(include_codecs, "pcm");
      tmp_if_expr_28 = return_value_strstr_27 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_28)
    {
      signed int tmp_post_26 = i;
      i = i + 1;
      codecs[(signed long int)tmp_post_26]=register_pcm();
    }

  }

  char *return_value_strstr_34;
  return_value_strstr_34=strstr(exclude_codecs, "mp3");
  _Bool tmp_if_expr_36;
  char *return_value_strstr_35;
  if(!(return_value_strstr_34 == ((char *)NULL)))
    tmp_if_expr_36 = (_Bool)1;

  else
  {
    return_value_strstr_35=strstr(exclude_codecs, "mad");
    tmp_if_expr_36 = return_value_strstr_35 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  char *return_value_strstr_30;
  char *return_value_strstr_32;
  if(!tmp_if_expr_36)
  {
    _Bool tmp_if_expr_31;
    if(include_codecs == ((const char *)NULL))
      tmp_if_expr_31 = (_Bool)1;

    else
    {
      return_value_strstr_30=strstr(include_codecs, "mp3");
      tmp_if_expr_31 = return_value_strstr_30 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_33;
    if(tmp_if_expr_31)
      tmp_if_expr_33 = (_Bool)1;

    else
    {
      return_value_strstr_32=strstr(include_codecs, "mad");
      tmp_if_expr_33 = return_value_strstr_32 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_33)
      codecs[(signed long int)i]=register_mad();

  }

  char *return_value_strstr_41;
  return_value_strstr_41=strstr(exclude_codecs, "mp3");
  _Bool tmp_if_expr_43;
  char *return_value_strstr_42;
  if(!(return_value_strstr_41 == ((char *)NULL)))
    tmp_if_expr_43 = (_Bool)1;

  else
  {
    return_value_strstr_42=strstr(exclude_codecs, "mpg");
    tmp_if_expr_43 = return_value_strstr_42 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  char *return_value_strstr_37;
  char *return_value_strstr_39;
  if(!tmp_if_expr_43)
  {
    if(codecs[(signed long int)i] == ((struct codec *)NULL))
    {
      _Bool tmp_if_expr_38;
      if(include_codecs == ((const char *)NULL))
        tmp_if_expr_38 = (_Bool)1;

      else
      {
        return_value_strstr_37=strstr(include_codecs, "mp3");
        tmp_if_expr_38 = return_value_strstr_37 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_40;
      if(tmp_if_expr_38)
        tmp_if_expr_40 = (_Bool)1;

      else
      {
        return_value_strstr_39=strstr(include_codecs, "mpg");
        tmp_if_expr_40 = return_value_strstr_39 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_40)
        codecs[(signed long int)i]=register_mpg();

    }

  }

  pthread_mutex_init(&decode.mutex, (const union anonymous_7 *)(void *)0);
  union pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, (unsigned long int)(16384 + 128 * 1024));
  pthread_create(&thread_link2, &attr, (void * (*)(void *))decode_thread, (void *)0);
  pthread_attr_destroy(&attr);
  decode.new_stream = (_Bool)1;
  decode.state = (enum anonymous_23)DECODE_STOPPED;
  decode.direct = (_Bool)1;
  decode.process = (_Bool)0;
}

// decode_newstream
// file decode.c line 199
unsigned int decode_newstream(unsigned int sample_rate, unsigned int *supported_rates)
{
  if(!(decode.process == (_Bool)0))
  {
    pthread_mutex_unlock(&outputbuf->mutex);
    sample_rate=process_newstream(&decode.direct, sample_rate, supported_rates);
    pthread_mutex_lock(&outputbuf->mutex);
  }

  return sample_rate;
}

// decode_thread
// file decode.c line 55
static void * decode_thread()
{
  const char *return_value_logtime_3;
  const char *return_value_logtime_4;
  while(!(running_link4 == (_Bool)0))
  {
    unsigned long int bytes;
    unsigned long int space;
    unsigned long int min_space;
    _Bool toend;
    _Bool ran = (_Bool)0;
    pthread_mutex_lock(&streambuf->mutex);
    unsigned int return_value__buf_used_1;
    return_value__buf_used_1=_buf_used(streambuf);
    bytes = (unsigned long int)return_value__buf_used_1;
    toend = (signed int)stream.state <= DISCONNECT;
    pthread_mutex_unlock(&streambuf->mutex);
    pthread_mutex_lock(&outputbuf->mutex);
    unsigned int return_value__buf_space_2;
    return_value__buf_space_2=_buf_space(outputbuf);
    space = (unsigned long int)return_value__buf_space_2;
    pthread_mutex_unlock(&outputbuf->mutex);
    pthread_mutex_lock(&decode.mutex);
    if((signed int)decode.state == DECODE_RUNNING && !(codec == ((struct codec *)NULL)))
    {
      if((signed int)loglevel_link5 >= lSDEBUG)
      {
        return_value_logtime_3=logtime();
        logprint("%s %s:%d streambuf bytes: %u outputbuf space: %u\n", return_value_logtime_3, (const void *)"decode_thread", 74, bytes, space);
      }

      if(!(decode.direct == (_Bool)0))
        min_space = (unsigned long int)codec->min_space;

      if(decode.direct == (_Bool)0)
        min_space = (unsigned long int)(process_link1.max_out_frames * (unsigned int)8);

      if(!(min_space >= space))
      {
        if(!((unsigned long int)codec->min_read_bytes >= bytes) || !(toend == (_Bool)0))
        {
          decode.state=codec->decode();
          if(decode.direct == (_Bool)0)
          {
            if(!(process_link1.in_frames == 0u))
              process_samples();

            if((signed int)decode.state == DECODE_COMPLETE)
              process_drain();

          }

          if(!((signed int)decode.state == DECODE_RUNNING))
          {
            if((signed int)loglevel_link5 >= lINFO)
            {
              return_value_logtime_4=logtime();
              logprint("%s %s:%d decode %s\n", return_value_logtime_4, (const void *)"decode_thread", 99, (signed int)decode.state == DECODE_COMPLETE ? "complete" : "error");
            }

            pthread_mutex_lock(&outputbuf->mutex);
            if(!(output.fade_mode == /*enum*/FADE_NONE))
              _checkfade((_Bool)0);

            pthread_mutex_unlock(&outputbuf->mutex);
            wake_controller();
          }

          ran = (_Bool)1;
        }

      }

    }

    pthread_mutex_unlock(&decode.mutex);
    if(ran == (_Bool)0)
      usleep((unsigned int)100000);

  }
  return NULL;
}

// discover_server
// file slimproto.c line 733
unsigned int discover_server(void)
{
  struct sockaddr_in discover_server__1__d;
  struct sockaddr_in s;
  char *discover_server__1__buf;
  struct pollfd pollinfo;
  signed int disc_sock;
  disc_sock=socket(2, 2, 0);
  unsigned int enable = (unsigned int)1;
  setsockopt(disc_sock, 1, 6, (const void *)&enable, (unsigned int)sizeof(unsigned int) /*4ul*/ );
  discover_server__1__buf = "e";
  memset((void *)&discover_server__1__d, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  discover_server__1__d.sin_family = (unsigned short int)2;
  discover_server__1__d.sin_port=htons((unsigned short int)3483);
  discover_server__1__d.sin_addr.s_addr=htonl((unsigned int)0xffffffff);
  pollinfo.fd = disc_sock;
  pollinfo.events = (signed short int)0x001;
  const char *return_value_logtime_1;
  const char *return_value_logtime_2;
  const char *return_value_logtime_4;
  char *return_value_inet_ntoa_5;
  unsigned short int return_value_ntohs_6;
  while((_Bool)1)
  {
    if((signed int)loglevel >= lINFO)
    {
      return_value_logtime_1=logtime();
      logprint("%s %s:%d sending discovery\n", return_value_logtime_1, (const void *)"discover_server", 756);
    }

    memset((void *)&s, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    signed long int return_value_sendto_3;
    return_value_sendto_3=sendto(disc_sock, (const void *)discover_server__1__buf, (unsigned long int)1, 0, (struct sockaddr *)&discover_server__1__d, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_sendto_3 >= 0l))
    {
      if((signed int)loglevel >= lINFO)
      {
        return_value_logtime_2=logtime();
        logprint("%s %s:%d error sending disovery\n", return_value_logtime_2, (const void *)"discover_server", 760);
      }

    }

    signed int return_value_poll_7;
    return_value_poll_7=poll(&pollinfo, (unsigned long int)1, 5000);
    if(return_value_poll_7 == 1)
    {
      char readbuf[10l];
      unsigned int slen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
      recvfrom(disc_sock, (void *)readbuf, (unsigned long int)10, 0, (struct sockaddr *)&s, &slen);
      if((signed int)loglevel >= lINFO)
      {
        return_value_logtime_4=logtime();
        return_value_inet_ntoa_5=inet_ntoa(s.sin_addr);
        return_value_ntohs_6=ntohs(s.sin_port);
        logprint("%s %s:%d got response from: %s:%d\n", return_value_logtime_4, (const void *)"discover_server", 767, return_value_inet_ntoa_5, return_value_ntohs_6);
      }

    }

    if(!(s.sin_addr.s_addr == 0u) || running == (_Bool)0)
      break;

  }
  close(disc_sock);
  return s.sin_addr.s_addr;
}

// dop_init
// file squeezelite.h line 639
void dop_init(_Bool enable, unsigned int delay)
{
  pthread_mutex_lock(&outputbuf->mutex);
  output.has_dop = enable;
  output.dop_delay = delay;
  pthread_mutex_unlock(&outputbuf->mutex);
}

// dop_silence_frames
// file squeezelite.h line 638
void dop_silence_frames(unsigned int *ptr, unsigned int frames)
{
  unsigned int tmp_post_1;
  do
  {
    tmp_post_1 = frames;
    frames = frames - 1u;
    if(tmp_post_1 == 0u)
      break;

    unsigned int *tmp_post_2 = ptr;
    ptr = ptr + 1l;
    *tmp_post_2 = (unsigned int)0x00ACAC00;
    unsigned int *tmp_post_3 = ptr;
    ptr = ptr + 1l;
    *tmp_post_3 = (unsigned int)0x00ACAC00;
  }
  while((_Bool)1);
}

// dsd2pcm_clone
// file dsd2pcm/dsd2pcm.c line 170
extern struct dsd2pcm_ctx_s * dsd2pcm_clone(struct dsd2pcm_ctx_s *ptr)
{
  struct dsd2pcm_ctx_s *p2;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct dsd2pcm_ctx_s) /*20ul*/ );
  p2 = (struct dsd2pcm_ctx_s *)return_value_malloc_1;
  if(!(p2 == ((struct dsd2pcm_ctx_s *)NULL)))
    memcpy((void *)p2, (const void *)ptr, sizeof(struct dsd2pcm_ctx_s) /*20ul*/ );

  return p2;
}

// dsd2pcm_destroy
// file ./dsd2pcm/dsd2pcm.h line 63
extern void dsd2pcm_destroy(struct dsd2pcm_ctx_s *ptr)
{
  free((void *)ptr);
}

// dsd2pcm_init
// file ./dsd2pcm/dsd2pcm.h line 57
extern struct dsd2pcm_ctx_s * dsd2pcm_init(void)
{
  struct dsd2pcm_ctx_s *ptr;
  if(precalculated == 0)
    dsd2pcm_precalc();

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct dsd2pcm_ctx_s) /*20ul*/ );
  ptr = (struct dsd2pcm_ctx_s *)return_value_malloc_1;
  if(!(ptr == ((struct dsd2pcm_ctx_s *)NULL)))
    dsd2pcm_reset(ptr);

  return ptr;
}

// dsd2pcm_precalc
// file ./dsd2pcm/dsd2pcm.h line 98
extern void dsd2pcm_precalc(void)
{
  signed int t;
  signed int e;
  signed int dsd2pcm_precalc__1__m;
  signed int k;
  double acc;
  _Bool tmp_if_expr_1;
  if(precalculated == 0)
  {
    t = 0;
    e = 0;
    for( ; !(t >= 256); t = t + 1)
    {
      dsd2pcm_bitreverse[(signed long int)t] = (unsigned char)e;
      dsd2pcm_precalc__1__m = 128;
      do
      {
        if(!(dsd2pcm_precalc__1__m == 0))
        {
          e = e ^ dsd2pcm_precalc__1__m;
          tmp_if_expr_1 = !((e & dsd2pcm_precalc__1__m) != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_1 = (_Bool)0;
        if(!tmp_if_expr_1)
          break;

        dsd2pcm_precalc__1__m = dsd2pcm_precalc__1__m >> 1;
      }
      while((_Bool)1);
    }
    t = 0;
    for( ; !(t >= 6); t = t + 1)
    {
      k = 48 - t * 8;
      if(k >= 9)
        k = 8;

      e = 0;
      for( ; !(e >= 256); e = e + 1)
      {
        acc = 0.0;
        dsd2pcm_precalc__1__m = 0;
        for( ; !(dsd2pcm_precalc__1__m >= k); dsd2pcm_precalc__1__m = dsd2pcm_precalc__1__m + 1)
          acc = acc + (double)((e >> 7 - dsd2pcm_precalc__1__m & 1) * 2 - 1) * htaps[(signed long int)(t * 8 + dsd2pcm_precalc__1__m)];
        ctables[(signed long int)(((48 + 7) / 8 - 1) - t)][(signed long int)e] = (float)acc;
      }
    }
    precalculated = 1;
  }

}

// dsd2pcm_reset
// file ./dsd2pcm/dsd2pcm.h line 74
extern void dsd2pcm_reset(struct dsd2pcm_ctx_s *ptr)
{
  signed int i = 0;
  for( ; !(i >= 16); i = i + 1)
    ptr->fifo[(signed long int)i] = (unsigned char)0x69;
  ptr->fifopos = (unsigned int)0;
}

// dsd2pcm_translate
// file ./dsd2pcm/dsd2pcm.h line 87
extern void dsd2pcm_translate(struct dsd2pcm_ctx_s *ptr, unsigned long int samples, const unsigned char *src, signed long int src_stride, signed int lsbf, float *dst, signed long int dst_stride)
{
  unsigned int ffp;
  unsigned int i;
  unsigned int bite1;
  unsigned int bite2;
  unsigned char *p;
  double acc;
  ffp = ptr->fifopos;
  lsbf = lsbf != 0 ? 1 : 0;
  unsigned long int tmp_post_1;
  do
  {
    tmp_post_1 = samples;
    samples = samples - 1ul;
    if(!(tmp_post_1 >= 1ul))
      break;

    bite1 = (unsigned int)*src & 0xFFu;
    if(!(lsbf == 0))
      bite1 = (unsigned int)dsd2pcm_bitreverse[(signed long int)bite1];

    ptr->fifo[(signed long int)ffp] = (unsigned char)bite1;
    src = src + src_stride;
    p = ptr->fifo + (signed long int)(ffp - (unsigned int)((48 + 7) / 8) & (unsigned int)(16 - 1));
    *p = dsd2pcm_bitreverse[(signed long int)((signed int)*p & 0xFF)];
    acc = (double)0;
    i = (unsigned int)0;
    for( ; !(i >= 6u); i = i + 1u)
    {
      bite1 = (unsigned int)((signed int)ptr->fifo[(signed long int)(ffp - i & (unsigned int)(16 - 1))] & 0xFF);
      bite2 = (unsigned int)((signed int)ptr->fifo[(signed long int)((ffp - (unsigned int)(((48 + 7) / 8) * 2 - 1)) + i & (unsigned int)(16 - 1))] & 0xFF);
      acc = acc + (double)(ctables[(signed long int)i][(signed long int)bite1] + ctables[(signed long int)i][(signed long int)bite2]);
    }
    *dst = (float)acc;
    dst = dst + dst_stride;
    ffp = ffp + (unsigned int)1 & (unsigned int)(16 - 1);
  }
  while((_Bool)1);
  ptr->fifopos = ffp;
}

// dsd_close
// file dsd.c line 589
static void dsd_close(void)
{
  if(!(d->dsd2pcm_ctx[0l] == ((struct dsd2pcm_ctx_s *)NULL)))
  {
    dsd2pcm_destroy(d->dsd2pcm_ctx[(signed long int)0]);
    dsd2pcm_destroy(d->dsd2pcm_ctx[(signed long int)1]);
    d->dsd2pcm_ctx[(signed long int)0] = (struct dsd2pcm_ctx_s *)(void *)0;
    d->dsd2pcm_ctx[(signed long int)1] = (struct dsd2pcm_ctx_s *)(void *)0;
  }

  if(!(d->transfer[0l] == ((float *)NULL)))
  {
    free((void *)d->transfer[(signed long int)0]);
    free((void *)d->transfer[(signed long int)1]);
    d->transfer[(signed long int)0] = (float *)(void *)0;
    d->transfer[(signed long int)1] = (float *)(void *)0;
  }

}

// dsd_decode
// file dsd.c line 492
static enum anonymous_23 dsd_decode(void)
{
  enum anonymous_23 ret;
  pthread_mutex_lock(&streambuf->mutex);
  _Bool tmp_if_expr_2;
  unsigned int return_value__buf_used_1;
  if(!((signed int)stream.state >= 2))
  {
    return_value__buf_used_1=_buf_used(streambuf);
    tmp_if_expr_2 = !(return_value__buf_used_1 != 0u) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    if(decode.new_stream == (_Bool)0)
      tmp_if_expr_3 = d->sample_bytes == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
  }
  unsigned int return_value__buf_used_7;
  unsigned int return_value__buf_cont_read_8;
  unsigned int return_value__buf_used_10;
  unsigned int return_value__buf_cont_read_11;
  unsigned int tmp_if_expr_14;
  unsigned int return_value__buf_used_12;
  unsigned int return_value__buf_cont_read_13;
  const char *return_value_logtime_16;
  const char *return_value_logtime_17;
  const char *return_value_logtime_18;
  const char *return_value_logtime_19;
  const char *return_value_logtime_20;
  if(tmp_if_expr_4)
  {
    pthread_mutex_unlock(&streambuf->mutex);
    return (enum anonymous_23)DECODE_COMPLETE;
  }

  else
  {
    if(!(d->consume == 0u))
    {
      unsigned int consume;
      unsigned int return_value__buf_used_5;
      return_value__buf_used_5=_buf_used(streambuf);
      unsigned int return_value__buf_cont_read_6;
      return_value__buf_cont_read_6=_buf_cont_read(streambuf);
      unsigned int tmp_if_expr_9;
      if(!(return_value__buf_used_5 >= return_value__buf_cont_read_6))
      {
        return_value__buf_used_7=_buf_used(streambuf);
        tmp_if_expr_9 = return_value__buf_used_7;
      }

      else
      {
        return_value__buf_cont_read_8=_buf_cont_read(streambuf);
        tmp_if_expr_9 = return_value__buf_cont_read_8;
      }
      unsigned int tmp_if_expr_15;
      if(!(d->consume >= tmp_if_expr_9))
        tmp_if_expr_15 = d->consume;

      else
      {
        return_value__buf_used_10=_buf_used(streambuf);
        return_value__buf_cont_read_11=_buf_cont_read(streambuf);
        if(!(return_value__buf_used_10 >= return_value__buf_cont_read_11))
        {
          return_value__buf_used_12=_buf_used(streambuf);
          tmp_if_expr_14 = return_value__buf_used_12;
        }

        else
        {
          return_value__buf_cont_read_13=_buf_cont_read(streambuf);
          tmp_if_expr_14 = return_value__buf_cont_read_13;
        }
        tmp_if_expr_15 = tmp_if_expr_14;
      }
      consume = tmp_if_expr_15;
      if((signed int)loglevel_link12 >= lDEBUG)
      {
        return_value_logtime_16=logtime();
        logprint("%s %s:%d consume: %u of %u\n", return_value_logtime_16, (const void *)"dsd_decode", 504, consume, d->consume);
      }

      _buf_inc_readp(streambuf, consume);
      d->consume = d->consume - consume;
      if(!(d->consume == 0u))
      {
        pthread_mutex_unlock(&streambuf->mutex);
        return (enum anonymous_23)DECODE_RUNNING;
      }

    }

    if(!(decode.new_stream == (_Bool)0))
    {
      signed int dsd_decode__1__3__r;
      dsd_decode__1__3__r=_read_header();
      if(!(dsd_decode__1__3__r >= 1))
      {
        pthread_mutex_unlock(&streambuf->mutex);
        return (enum anonymous_23)DECODE_ERROR;
      }

      if(dsd_decode__1__3__r == 0)
      {
        pthread_mutex_unlock(&streambuf->mutex);
        return (enum anonymous_23)DECODE_RUNNING;
      }

      pthread_mutex_lock(&outputbuf->mutex);
      if((signed int)loglevel_link12 >= lINFO)
      {
        return_value_logtime_17=logtime();
        logprint("%s %s:%d setting track_start\n", return_value_logtime_17, (const void *)"dsd_decode", 527);
      }

      output.track_start = outputbuf->writep;
      dop = output.has_dop;
      if(!(dop == (_Bool)0))
      {
        if(!(output.supported_rates[0l] >= d->sample_rate / 16u))
        {
          if((signed int)loglevel_link12 >= lINFO)
          {
            return_value_logtime_18=logtime();
            logprint("%s %s:%d DOP sample rate too high for device - converting to PCM\n", return_value_logtime_18, (const void *)"dsd_decode", 533);
          }

          dop = (_Bool)0;
        }

      }

      if(!(dop == (_Bool)0))
      {
        if((signed int)loglevel_link12 >= lINFO)
        {
          return_value_logtime_19=logtime();
          logprint("%s %s:%d DOP output\n", return_value_logtime_19, (const void *)"dsd_decode", 538);
        }

        output.next_dop = (_Bool)1;
        output.next_sample_rate = d->sample_rate / (unsigned int)16;
        output.fade = (enum anonymous_3)FADE_INACTIVE;
      }

      else
      {
        if((signed int)loglevel_link12 >= lINFO)
        {
          return_value_logtime_20=logtime();
          logprint("%s %s:%d DSD to PCM output\n", return_value_logtime_20, (const void *)"dsd_decode", 543);
        }

        output.next_dop = (_Bool)0;
        output.next_sample_rate=decode_newstream(d->sample_rate / (unsigned int)8, output.supported_rates);
        if(!(output.fade_mode == /*enum*/FADE_NONE))
          _checkfade((_Bool)1);

      }
      decode.new_stream = (_Bool)0;
      pthread_mutex_unlock(&outputbuf->mutex);
    }

    if(!(decode.direct == (_Bool)0))
      pthread_mutex_lock(&outputbuf->mutex);

    switch((signed int)d->type)
    {
      case DSF:
      {
        ret=_decode_dsf();
        break;
      }
      case DSDIFF:
      {
        ret=_decode_dsdiff();
        break;
      }
      default:
        ret = (enum anonymous_23)DECODE_ERROR;
    }
    if(!(decode.direct == (_Bool)0))
      pthread_mutex_unlock(&outputbuf->mutex);

    pthread_mutex_unlock(&streambuf->mutex);
    return ret;
  }
}

// dsd_open
// file dsd.c line 573
static void dsd_open(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness)
{
  d->type = (enum anonymous_20)UNKNOWN;
  if(d->dsd2pcm_ctx[0l] == ((struct dsd2pcm_ctx_s *)NULL))
  {
    d->dsd2pcm_ctx[(signed long int)0]=dsd2pcm_init();
    d->dsd2pcm_ctx[(signed long int)1]=dsd2pcm_init();
  }

  else
  {
    dsd2pcm_reset(d->dsd2pcm_ctx[(signed long int)0]);
    dsd2pcm_reset(d->dsd2pcm_ctx[(signed long int)1]);
  }
  if(d->transfer[1l] == ((float *)NULL))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(float) /*4ul*/  * (unsigned long int)4096);
    d->transfer[(signed long int)0] = (float *)return_value_malloc_1;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(float) /*4ul*/  * (unsigned long int)4096);
    d->transfer[(signed long int)1] = (float *)return_value_malloc_2;
  }

}

// error_cb
// file flac.c line 199
static void error_cb(const struct anonymous_43 *decoder, enum anonymous_68 status, void *client_data)
{
  const char *return_value_logtime_1;
  if((signed int)loglevel_link6 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d flac error: %s\n", return_value_logtime_1, (const void *)"error_cb", 200, FLAC__StreamDecoderErrorStatusString[(signed long int)status]);
  }

}

// faad_close
// file faad.c line 573
static void faad_close(void)
{
  NeAACDecClose(a->hAac);
  a->hAac = (void *)0;
  if(!(a->chunkinfo == ((struct chunk_table *)NULL)))
  {
    free((void *)a->chunkinfo);
    a->chunkinfo = (struct chunk_table *)(void *)0;
  }

  if(!(a->stsc == NULL))
  {
    free(a->stsc);
    a->stsc = (void *)0;
  }

}

// faad_decode
// file faad.c line 313
static enum anonymous_23 faad_decode(void)
{
  unsigned long int bytes_total;
  unsigned long int bytes_wrap;
  struct NeAACDecFrameInfo info;
  signed int *iptr;
  _Bool endstream;
  unsigned int frames;
  pthread_mutex_lock(&streambuf->mutex);
  unsigned int return_value__buf_used_1;
  return_value__buf_used_1=_buf_used(streambuf);
  bytes_total = (unsigned long int)return_value__buf_used_1;
  unsigned int return_value__buf_cont_read_2;
  return_value__buf_cont_read_2=_buf_cont_read(streambuf);
  unsigned long int tmp_if_expr_4;
  unsigned int return_value__buf_cont_read_3;
  if(!(bytes_total >= (unsigned long int)return_value__buf_cont_read_2))
    tmp_if_expr_4 = bytes_total;

  else
  {
    return_value__buf_cont_read_3=_buf_cont_read(streambuf);
    tmp_if_expr_4 = (unsigned long int)return_value__buf_cont_read_3;
  }
  bytes_wrap = tmp_if_expr_4;
  const char *return_value_logtime_6;
  const char *return_value_logtime_7;
  unsigned int return_value__buf_cont_read_10;
  const char *return_value_logtime_12;
  const char *return_value_logtime_13;
  const char *return_value_logtime_16;
  char *return_value_NeAACDecGetErrorMessage_17;
  unsigned int tmp_post_21;
  const char *return_value_logtime_18;
  const char *return_value_logtime_23;
  const char *return_value_logtime_24;
  const char *return_value_logtime_26;
  const char *return_value_logtime_27;
  const char *return_value_logtime_28;
  unsigned int tmp_post_30;
  unsigned int tmp_post_35;
  const char *return_value_logtime_39;
  const char *return_value_logtime_40;
  if(bytes_total == 0ul && !((signed int)stream.state >= 2))
  {
    pthread_mutex_unlock(&streambuf->mutex);
    return (enum anonymous_23)DECODE_COMPLETE;
  }

  else
  {
    if(!(a->consume == 0u))
    {
      unsigned int consume;
      unsigned long int tmp_if_expr_5;
      if(!((unsigned long int)a->consume >= bytes_wrap))
        tmp_if_expr_5 = (unsigned long int)a->consume;

      else
        tmp_if_expr_5 = bytes_wrap;
      consume = (unsigned int)tmp_if_expr_5;
      if((signed int)loglevel_link10 >= lDEBUG)
      {
        return_value_logtime_6=logtime();
        logprint("%s %s:%d consume: %u of %u\n", return_value_logtime_6, (const void *)"faad_decode", 332, consume, a->consume);
      }

      _buf_inc_readp(streambuf, consume);
      a->pos = a->pos + consume;
      a->consume = a->consume - consume;
      pthread_mutex_unlock(&streambuf->mutex);
      return (enum anonymous_23)DECODE_RUNNING;
    }

    if(!(decode.new_stream == (_Bool)0))
    {
      signed int found = 0;
      static unsigned char faad_decode__1__3__channels;
      static unsigned long int samplerate;
      if((signed int)a->type == 50)
      {
        for( ; bytes_wrap >= 2ul; bytes_wrap = bytes_wrap - 1ul)
        {
          if((signed int)*streambuf->readp == 0xFF)
          {
            if((0xF6 & (signed int)streambuf->readp[1l]) == 0xF0)
              break;

          }

          _buf_inc_readp(streambuf, (unsigned int)1);
          bytes_total = bytes_total - 1ul;
        }
        if(bytes_wrap >= 2ul)
        {
          signed long int n;
          n=NeAACDecInit(a->hAac, streambuf->readp, bytes_wrap, &samplerate, &faad_decode__1__3__channels);
          if(!(n >= 0l))
            found = -1;

          else
          {
            _buf_inc_readp(streambuf, (unsigned int)n);
            found = 1;
          }
        }

      }

      else
        found=read_mp4_header(&samplerate, &faad_decode__1__3__channels);
      if(found == 1)
      {
        if((signed int)loglevel_link10 >= lINFO)
        {
          return_value_logtime_7=logtime();
          logprint("%s %s:%d samplerate: %u channels: %u\n", return_value_logtime_7, (const void *)"faad_decode", 372, samplerate, faad_decode__1__3__channels);
        }

        unsigned int return_value__buf_used_8;
        return_value__buf_used_8=_buf_used(streambuf);
        bytes_total = (unsigned long int)return_value__buf_used_8;
        unsigned int return_value__buf_cont_read_9;
        return_value__buf_cont_read_9=_buf_cont_read(streambuf);
        unsigned long int tmp_if_expr_11;
        if(!(bytes_total >= (unsigned long int)return_value__buf_cont_read_9))
          tmp_if_expr_11 = bytes_total;

        else
        {
          return_value__buf_cont_read_10=_buf_cont_read(streambuf);
          tmp_if_expr_11 = (unsigned long int)return_value__buf_cont_read_10;
        }
        bytes_wrap = tmp_if_expr_11;
        pthread_mutex_lock(&outputbuf->mutex);
        if((signed int)loglevel_link10 >= lINFO)
        {
          return_value_logtime_12=logtime();
          logprint("%s %s:%d setting track_start\n", return_value_logtime_12, (const void *)"faad_decode", 377);
        }

        output.next_sample_rate=decode_newstream((unsigned int)samplerate, output.supported_rates);
        output.next_dop = (_Bool)0;
        output.track_start = outputbuf->writep;
        if(!(output.fade_mode == /*enum*/FADE_NONE))
          _checkfade((_Bool)1);

        decode.new_stream = (_Bool)0;
        pthread_mutex_unlock(&outputbuf->mutex);
      }

      else
        if(found == -1)
        {
          if((signed int)loglevel_link10 >= lWARN)
          {
            return_value_logtime_13=logtime();
            logprint("%s %s:%d error reading stream header\n", return_value_logtime_13, (const void *)"faad_decode", 387);
          }

          pthread_mutex_unlock(&streambuf->mutex);
          return (enum anonymous_23)DECODE_ERROR;
        }

        else
        {
          pthread_mutex_unlock(&streambuf->mutex);
          return (enum anonymous_23)DECODE_RUNNING;
        }
    }

    if(bytes_total >= 2049ul && !(bytes_wrap >= 2048ul))
    {
      unsigned char faad_decode__1__4__buf[2048l];
      memcpy((void *)faad_decode__1__4__buf, (const void *)streambuf->readp, bytes_wrap);
      memcpy((void *)(faad_decode__1__4__buf + (signed long int)bytes_wrap), (const void *)streambuf->buf, (unsigned long int)2048 - bytes_wrap);
      void *return_value_NeAACDecDecode_14;
      return_value_NeAACDecDecode_14=NeAACDecDecode(a->hAac, &info, faad_decode__1__4__buf, (unsigned long int)2048);
      iptr = (signed int *)return_value_NeAACDecDecode_14;
    }

    else
    {
      void *return_value_NeAACDecDecode_15;
      return_value_NeAACDecDecode_15=NeAACDecDecode(a->hAac, &info, streambuf->readp, bytes_wrap);
      iptr = (signed int *)return_value_NeAACDecDecode_15;
    }
    if(!(info.error == 0))
    {
      if((signed int)loglevel_link10 >= lWARN)
      {
        return_value_logtime_16=logtime();
        return_value_NeAACDecGetErrorMessage_17=NeAACDecGetErrorMessage(info.error);
        logprint("%s %s:%d error: %u %s\n", return_value_logtime_16, (const void *)"faad_decode", 414, info.error, return_value_NeAACDecGetErrorMessage_17);
      }

    }

    endstream = (_Bool)0;
    _Bool tmp_if_expr_20;
    if(!(a->chunkinfo == ((struct chunk_table *)NULL)))
      tmp_if_expr_20 = (a->chunkinfo + (signed long int)a->nextchunk)->offset != 0u ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_20 = (_Bool)0;
    _Bool tmp_if_expr_22;
    if(tmp_if_expr_20)
    {
      tmp_post_21 = a->sample;
      a->sample = a->sample + 1u;
      tmp_if_expr_22 = tmp_post_21 == (a->chunkinfo + (signed long int)a->nextchunk)->sample ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_22 = (_Bool)0;
    if(tmp_if_expr_22)
    {
      if(!(a->pos >= (a->chunkinfo + (signed long int)a->nextchunk)->offset))
      {
        unsigned int skip = (a->chunkinfo + (signed long int)a->nextchunk)->offset - a->pos;
        if(!((unsigned long int)skip == info.bytesconsumed))
        {
          if((signed int)loglevel_link10 >= lDEBUG)
          {
            return_value_logtime_18=logtime();
            logprint("%s %s:%d skipping to next chunk pos: %u consumed: %u != skip: %u\n", return_value_logtime_18, (const void *)"faad_decode", 425, a->pos, info.bytesconsumed, skip);
          }

        }

        if(bytes_total >= (unsigned long int)skip)
        {
          _buf_inc_readp(streambuf, skip);
          a->pos = a->pos + skip;
        }

        else
          a->consume = skip;
        a->nextchunk = a->nextchunk + 1u;
      }

      else
      {
        const char *return_value_logtime_19;
        return_value_logtime_19=logtime();
        logprint("%s %s:%d error: need to skip backwards!\n", return_value_logtime_19, (const void *)"faad_decode", 435);
        endstream = (_Bool)1;
      }
    }

    else
      if(!(info.bytesconsumed == 0ul))
      {
        _buf_inc_readp(streambuf, (unsigned int)info.bytesconsumed);
        a->pos = a->pos + (unsigned int)info.bytesconsumed;
      }

      else
        endstream = (_Bool)1;
    pthread_mutex_unlock(&streambuf->mutex);
    if(!(endstream == (_Bool)0))
    {
      if((signed int)loglevel_link10 >= lWARN)
      {
        return_value_logtime_23=logtime();
        logprint("%s %s:%d unable to decode further\n", return_value_logtime_23, (const void *)"faad_decode", 453);
      }

      return (enum anonymous_23)DECODE_ERROR;
    }

    if(info.samples == 0ul)
    {
      a->empty = (_Bool)1;
      return (enum anonymous_23)DECODE_RUNNING;
    }

    else
    {
      frames = (unsigned int)(info.samples / (unsigned long int)info.channels);
      if(!(a->skip == 0u))
      {
        unsigned int faad_decode__1__12__skip;
        if(!(a->empty == (_Bool)0))
        {
          a->empty = (_Bool)0;
          a->skip = a->skip - frames;
          if((signed int)loglevel_link10 >= lDEBUG)
          {
            return_value_logtime_24=logtime();
            logprint("%s %s:%d gapless: first frame empty, skipped %u frames at start\n", return_value_logtime_24, (const void *)"faad_decode", 469, frames);
          }

        }

        unsigned int tmp_if_expr_25;
        if(!(frames >= a->skip))
          tmp_if_expr_25 = frames;

        else
          tmp_if_expr_25 = a->skip;
        faad_decode__1__12__skip = tmp_if_expr_25;
        if((signed int)loglevel_link10 >= lDEBUG)
        {
          return_value_logtime_26=logtime();
          logprint("%s %s:%d gapless: skipping %u frames at start\n", return_value_logtime_26, (const void *)"faad_decode", 472, faad_decode__1__12__skip);
        }

        frames = frames - faad_decode__1__12__skip;
        a->skip = a->skip - faad_decode__1__12__skip;
        iptr = iptr + (signed long int)(faad_decode__1__12__skip * (unsigned int)info.channels);
      }

      if(!(a->samples == 0ul))
      {
        if(!(a->samples >= (unsigned long int)frames))
        {
          if((signed int)loglevel_link10 >= lDEBUG)
          {
            return_value_logtime_27=logtime();
            logprint("%s %s:%d gapless: trimming %u frames from end\n", return_value_logtime_27, (const void *)"faad_decode", 480, (unsigned long int)frames - a->samples);
          }

          frames = (unsigned int)a->samples;
        }

        a->samples = a->samples - (unsigned long int)frames;
      }

      if((signed int)loglevel_link10 >= lSDEBUG)
      {
        return_value_logtime_28=logtime();
        logprint("%s %s:%d write %u frames\n", return_value_logtime_28, (const void *)"faad_decode", 486, frames);
      }

      if(!(decode.direct == (_Bool)0))
        pthread_mutex_lock(&outputbuf->mutex);

      while(frames >= 1u)
      {
        unsigned int faad_decode__1__14__f;
        unsigned int count;
        signed int *faad_decode__1__14__optr;
        if(!(decode.direct == (_Bool)0))
        {
          unsigned int return_value__buf_cont_write_29;
          return_value__buf_cont_write_29=_buf_cont_write(outputbuf);
          faad_decode__1__14__f = return_value__buf_cont_write_29 / (unsigned int)8;
          faad_decode__1__14__optr = (signed int *)outputbuf->writep;
        }

        if(decode.direct == (_Bool)0)
        {
          faad_decode__1__14__f = process_link6.max_in_frames;
          faad_decode__1__14__optr = (signed int *)process_link6.inbuf;
        }

        faad_decode__1__14__f = faad_decode__1__14__f < frames ? faad_decode__1__14__f : frames;
        count = faad_decode__1__14__f;
        if((signed int)info.channels == 2)
          do
          {
            tmp_post_30 = count;
            count = count - 1u;
            if(tmp_post_30 == 0u)
              break;

            signed int *tmp_post_31 = faad_decode__1__14__optr;
            faad_decode__1__14__optr = faad_decode__1__14__optr + 1l;
            signed int *tmp_post_32 = iptr;
            iptr = iptr + 1l;
            *tmp_post_31 = *tmp_post_32 << 8;
            signed int *tmp_post_33 = faad_decode__1__14__optr;
            faad_decode__1__14__optr = faad_decode__1__14__optr + 1l;
            signed int *tmp_post_34 = iptr;
            iptr = iptr + 1l;
            *tmp_post_33 = *tmp_post_34 << 8;
          }
          while((_Bool)1);

        else
          if((signed int)info.channels == 1)
            do
            {
              tmp_post_35 = count;
              count = count - 1u;
              if(tmp_post_35 == 0u)
                break;

              signed int *tmp_post_36 = faad_decode__1__14__optr;
              faad_decode__1__14__optr = faad_decode__1__14__optr + 1l;
              *tmp_post_36 = *iptr << 8;
              signed int *tmp_post_37 = faad_decode__1__14__optr;
              faad_decode__1__14__optr = faad_decode__1__14__optr + 1l;
              signed int *tmp_post_38 = iptr;
              iptr = iptr + 1l;
              *tmp_post_37 = *tmp_post_38 << 8;
            }
            while((_Bool)1);

          else
            if((signed int)loglevel_link10 >= lWARN)
            {
              return_value_logtime_39=logtime();
              logprint("%s %s:%d unsupported number of channels\n", return_value_logtime_39, (const void *)"faad_decode", 518);
            }

        frames = frames - faad_decode__1__14__f;
        if(!(decode.direct == (_Bool)0))
          _buf_inc_writep(outputbuf, faad_decode__1__14__f * (unsigned int)8);

        if(decode.direct == (_Bool)0)
        {
          process_link6.in_frames = faad_decode__1__14__f;
          if(!(frames == 0u))
          {
            return_value_logtime_40=logtime();
            logprint("%s %s:%d unhandled case\n", return_value_logtime_40, (const void *)"faad_decode", 529);
          }

        }

      }
      if(!(decode.direct == (_Bool)0))
        pthread_mutex_unlock(&outputbuf->mutex);

      return (enum anonymous_23)DECODE_RUNNING;
    }
  }
}

// faad_open
// file faad.c line 537
static void faad_open(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness)
{
  struct NeAACDecConfiguration *conf;
  const char *return_value_logtime_1;
  if((signed int)loglevel_link10 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d opening %s stream\n", return_value_logtime_1, (const void *)"faad_open", 540, (signed int)size == 50 ? "adts" : "mp4");
  }

  a->type = size;
  a->nextchunk = (unsigned int)0;
  a->sample = a->nextchunk;
  a->consume = a->sample;
  a->pos = a->consume;
  if(!(a->chunkinfo == ((struct chunk_table *)NULL)))
    free((void *)a->chunkinfo);

  if(!(a->stsc == NULL))
    free(a->stsc);

  a->chunkinfo = (struct chunk_table *)(void *)0;
  a->stsc = (void *)0;
  a->skip = (unsigned int)0;
  a->samples = (unsigned long int)0;
  a->sttssamples = (unsigned long int)0;
  a->empty = (_Bool)0;
  if(!(a->hAac == NULL))
    NeAACDecClose(a->hAac);

  a->hAac=NeAACDecOpen();
  conf=NeAACDecGetCurrentConfiguration(a->hAac);
  conf->outputFormat = (unsigned char)2;
  conf->downMatrix = (unsigned char)1;
  unsigned char return_value_NeAACDecSetConfiguration_3;
  return_value_NeAACDecSetConfiguration_3=NeAACDecSetConfiguration(a->hAac, conf);
  const char *return_value_logtime_2;
  if(return_value_NeAACDecSetConfiguration_3 == 0)
  {
    if((signed int)loglevel_link10 >= lWARN)
    {
      return_value_logtime_2=logtime();
      logprint("%s %s:%d error setting config\n", return_value_logtime_2, (const void *)"faad_open", 569);
    }

  }

}

// ff_close
// file ffmpeg.c line 569
static void ff_close(void)
{
  _free_ff_data();
  if(!(ff->readbuf == ((unsigned char *)NULL)))
  {
    av_freep((void *)&ff->readbuf);
    ff->readbuf = (unsigned char *)(void *)0;
  }

}

// ff_decode
// file ffmpeg.c line 251
static enum anonymous_23 ff_decode(void)
{
  signed int ff_decode__1__r;
  signed int len;
  signed int got_frame;
  struct AVPacket pkt_c;
  signed int *ff_decode__1__optr = (signed int *)(void *)0;
  const char *return_value_logtime_3;
  char *return_value_av__err2str_4;
  const char *return_value_logtime_5;
  const char *return_value_logtime_6;
  char *return_value_av__err2str_7;
  const char *return_value_logtime_8;
  const char *return_value_logtime_9;
  const char *return_value_logtime_10;
  const char *return_value_logtime_13;
  if(!(decode.new_stream == (_Bool)0))
  {
    struct AVIOContext *avio;
    struct AVStream *av_stream;
    struct AVCodec *ff_decode__1__1__codec;
    signed int o;
    signed int audio_stream = -1;
    ff->mmsh_packet_len = (unsigned int)0;
    ff->mmsh_bytes_pad = ff->mmsh_packet_len;
    ff->mmsh_bytes_left = ff->mmsh_bytes_pad;
    if(ff->readbuf == ((unsigned char *)NULL))
    {
      void *return_value_av_malloc_1;
      return_value_av_malloc_1=av_malloc((unsigned long int)(4096 * 4 + 32));
      ff->readbuf = (unsigned char *)return_value_av_malloc_1;
    }

    avio=avio_alloc_context(ff->readbuf, 4096 * 4, 0, (void *)0, _read_data, (signed int (*)(void *, unsigned char *, signed int))(void *)0, (signed long int (*)(void *, signed long int, signed int))(void *)0);
    avio->seekable = 0;
    ff->formatC=avformat_alloc_context();
    if(ff->formatC == ((struct AVFormatContext *)NULL))
    {
      const char *return_value_logtime_2;
      return_value_logtime_2=logtime();
      logprint("%s %s:%d null context\n", return_value_logtime_2, (const void *)"ff_decode", 275);
      return (enum anonymous_23)DECODE_ERROR;
    }

    ff->formatC->pb = avio;
    ff->formatC->flags = ff->formatC->flags | 0x0080 | 0x0020;
    o=avformat_open_input(&ff->formatC, "", ff->input_format, (struct AVDictionary **)(void *)0);
    if(!(o >= 0))
    {
      if((signed int)loglevel_link13 >= lWARN)
      {
        return_value_logtime_3=logtime();
        return_value_av__err2str_4=av__err2str(o);
        logprint("%s %s:%d avformat_open_input: %d %s\n", return_value_logtime_3, (const void *)"ff_decode", 284, o, return_value_av__err2str_4);
      }

      return (enum anonymous_23)DECODE_ERROR;
    }

    if((signed int)loglevel_link13 >= lINFO)
    {
      return_value_logtime_5=logtime();
      logprint("%s %s:%d format: name:%s lname:%s\n", return_value_logtime_5, (const void *)"ff_decode", 288, ff->formatC->iformat->name, ff->formatC->iformat->long_name);
    }

    o=avformat_find_stream_info(ff->formatC, (struct AVDictionary **)(void *)0);
    if(!(o >= 0))
    {
      if((signed int)loglevel_link13 >= lWARN)
      {
        return_value_logtime_6=logtime();
        return_value_av__err2str_7=av__err2str(o);
        logprint("%s %s:%d avformat_find_stream_info: %d %s\n", return_value_logtime_6, (const void *)"ff_decode", 292, o, return_value_av__err2str_7);
      }

      return (enum anonymous_23)DECODE_ERROR;
    }

    if(!(ff->wma == (_Bool)0))
    {
      if(!((unsigned int)ff->wma_playstream >= ff->formatC->nb_streams))
      {
        if((signed int)ff->formatC->streams[(signed long int)ff->wma_playstream]->codec->codec_type == AVMEDIA_TYPE_AUDIO)
        {
          if((signed int)loglevel_link13 >= lINFO)
          {
            return_value_logtime_8=logtime();
            logprint("%s %s:%d using wma stream sent from server: %i\n", return_value_logtime_8, (const void *)"ff_decode", 298, ff->wma_playstream);
          }

          audio_stream = (signed int)ff->wma_playstream;
        }

      }

    }

    if(audio_stream == -1)
    {
      signed int i = 0;
      for( ; !((unsigned int)i >= ff->formatC->nb_streams); i = i + 1)
        if((signed int)ff->formatC->streams[(signed long int)i]->codec->codec_type == AVMEDIA_TYPE_AUDIO)
        {
          audio_stream = i;
          if((signed int)loglevel_link13 >= lINFO)
          {
            return_value_logtime_9=logtime();
            logprint("%s %s:%d found stream: %i\n", return_value_logtime_9, (const void *)"ff_decode", 308, i);
          }

          break;
        }

    }

    if(audio_stream == -1)
    {
      if((signed int)loglevel_link13 >= lWARN)
      {
        return_value_logtime_10=logtime();
        logprint("%s %s:%d no audio stream found\n", return_value_logtime_10, (const void *)"ff_decode", 315);
      }

      return (enum anonymous_23)DECODE_ERROR;
    }

    av_stream = ff->formatC->streams[(signed long int)audio_stream];
    ff->codecC = av_stream->codec;
    ff_decode__1__1__codec=avcodec_find_decoder(ff->codecC->codec_id);
    avcodec_open2(ff->codecC, ff_decode__1__1__codec, (struct AVDictionary **)(void *)0);
    ff->frame=av_frame_alloc();
    void *return_value_av_malloc_11;
    return_value_av_malloc_11=av_malloc(sizeof(struct AVPacket) /*96ul*/ );
    ff->avpkt = (struct AVPacket *)return_value_av_malloc_11;
    if(ff->avpkt == ((struct AVPacket *)NULL))
    {
      const char *return_value_logtime_12;
      return_value_logtime_12=logtime();
      logprint("%s %s:%d can't allocate avpkt\n", return_value_logtime_12, (const void *)"ff_decode", 331);
      return (enum anonymous_23)DECODE_ERROR;
    }

    av_init_packet(ff->avpkt);
    ff->avpkt->data = (unsigned char *)(void *)0;
    ff->avpkt->size = 0;
    pthread_mutex_lock(&outputbuf->mutex);
    if((signed int)loglevel_link13 >= lINFO)
    {
      return_value_logtime_13=logtime();
      logprint("%s %s:%d setting track_start\n", return_value_logtime_13, (const void *)"ff_decode", 340);
    }

    output.next_sample_rate=decode_newstream((unsigned int)ff->codecC->sample_rate, output.supported_rates);
    output.next_dop = (_Bool)0;
    output.track_start = outputbuf->writep;
    if(!(output.fade_mode == /*enum*/FADE_NONE))
      _checkfade((_Bool)1);

    decode.new_stream = (_Bool)0;
    pthread_mutex_unlock(&outputbuf->mutex);
  }

  got_frame = 0;
  ff_decode__1__r=av_read_frame(ff->formatC, ff->avpkt);
  const char *return_value_logtime_14;
  const char *return_value_logtime_15;
  const char *return_value_logtime_20;
  unsigned int return_value__buf_space_23;
  unsigned int return_value__buf_cont_write_24;
  const char *return_value_logtime_26;
  unsigned int tmp_post_27;
  unsigned int tmp_post_32;
  unsigned int tmp_post_37;
  unsigned int tmp_post_42;
  unsigned int tmp_post_47;
  const char *return_value_logtime_52;
  unsigned int tmp_post_53;
  unsigned int tmp_post_57;
  unsigned int tmp_post_61;
  unsigned int tmp_post_65;
  unsigned int tmp_post_69;
  const char *return_value_logtime_73;
  const char *return_value_logtime_74;
  if(!(ff_decode__1__r >= 0))
  {
    if(ff_decode__1__r == -541478725)
    {
      if(!(ff->end_of_stream == (_Bool)0))
      {
        if((signed int)loglevel_link13 >= lINFO)
        {
          return_value_logtime_14=logtime();
          logprint("%s %s:%d decode complete\n", return_value_logtime_14, (const void *)"ff_decode", 354);
        }

        return (enum anonymous_23)DECODE_COMPLETE;
      }

      else
        if((signed int)loglevel_link13 >= lINFO)
        {
          return_value_logtime_15=logtime();
          logprint("%s %s:%d codec end of file\n", return_value_logtime_15, (const void *)"ff_decode", 357);
        }

    }

    else
    {
      const char *return_value_logtime_16;
      return_value_logtime_16=logtime();
      char *return_value_av__err2str_17;
      return_value_av__err2str_17=av__err2str(ff_decode__1__r);
      logprint("%s %s:%d av_read_frame error: %i %s\n", return_value_logtime_16, (const void *)"ff_decode", 360, ff_decode__1__r, return_value_av__err2str_17);
    }
    return (enum anonymous_23)DECODE_RUNNING;
  }

  else
  {
    pkt_c = *ff->avpkt;
    if(decode.direct == (_Bool)0)
    {
      ff_decode__1__optr = (signed int *)process_link9.inbuf;
      process_link9.in_frames = (unsigned int)0;
    }

    while(pkt_c.size >= 1 || !(got_frame == 0))
    {
      len=avcodec_decode_audio4(ff->codecC, ff->frame, &got_frame, &pkt_c);
      if(!(len >= 0))
      {
        const char *return_value_logtime_18;
        return_value_logtime_18=logtime();
        char *return_value_av__err2str_19;
        return_value_av__err2str_19=av__err2str(len);
        logprint("%s %s:%d avcodec_decode_audio4 error: %i %s\n", return_value_logtime_18, (const void *)"ff_decode", 377, len, return_value_av__err2str_19);
        return (enum anonymous_23)DECODE_RUNNING;
      }

      pkt_c.data = pkt_c.data + (signed long int)len;
      pkt_c.size = pkt_c.size - len;
      if(!(got_frame == 0))
      {
        signed short int *iptr16 = (signed short int *)ff->frame->data[(signed long int)0];
        signed int *iptr32 = (signed int *)ff->frame->data[(signed long int)0];
        signed short int *iptr16l = (signed short int *)ff->frame->data[(signed long int)0];
        signed short int *iptr16r = (signed short int *)ff->frame->data[(signed long int)1];
        signed int *iptr32l = (signed int *)ff->frame->data[(signed long int)0];
        signed int *iptr32r = (signed int *)ff->frame->data[(signed long int)1];
        float *iptrfl = (float *)ff->frame->data[(signed long int)0];
        float *iptrfr = (float *)ff->frame->data[(signed long int)1];
        unsigned int frames = (unsigned int)ff->frame->nb_samples;
        if((signed int)loglevel_link13 >= lSDEBUG)
        {
          return_value_logtime_20=logtime();
          logprint("%s %s:%d got audio channels: %u samples: %u format: %u\n", return_value_logtime_20, (const void *)"ff_decode", 398, ff->codecC->channels, ff->frame->nb_samples, ff->codecC->sample_fmt);
        }

        if(!(decode.direct == (_Bool)0))
          pthread_mutex_lock(&outputbuf->mutex);

        while(frames >= 1u)
        {
          unsigned int count;
          unsigned int ff_decode__1__4__2__1__f;
          if(!(decode.direct == (_Bool)0))
          {
            ff_decode__1__optr = (signed int *)outputbuf->writep;
            unsigned int return_value__buf_space_21;
            return_value__buf_space_21=_buf_space(outputbuf);
            unsigned int return_value__buf_cont_write_22;
            return_value__buf_cont_write_22=_buf_cont_write(outputbuf);
            unsigned int tmp_if_expr_25;
            if(!(return_value__buf_space_21 >= return_value__buf_cont_write_22))
            {
              return_value__buf_space_23=_buf_space(outputbuf);
              tmp_if_expr_25 = return_value__buf_space_23;
            }

            else
            {
              return_value__buf_cont_write_24=_buf_cont_write(outputbuf);
              tmp_if_expr_25 = return_value__buf_cont_write_24;
            }
            ff_decode__1__4__2__1__f = tmp_if_expr_25 / (unsigned int)8;
            ff_decode__1__4__2__1__f = ff_decode__1__4__2__1__f < frames ? ff_decode__1__4__2__1__f : frames;
          }

          if(decode.direct == (_Bool)0)
          {
            if(!(process_link9.max_in_frames >= process_link9.in_frames + frames))
            {
              if((signed int)loglevel_link13 >= lWARN)
              {
                return_value_logtime_26=logtime();
                logprint("%s %s:%d exceeded process buffer size - dropping frames\n", return_value_logtime_26, (const void *)"ff_decode", 418);
              }

              break;
            }

            ff_decode__1__4__2__1__f = frames;
          }

          count = ff_decode__1__4__2__1__f;
          if(ff->codecC->channels == 2)
          {
            if((signed int)ff->codecC->sample_fmt == AV_SAMPLE_FMT_S16)
              do
              {
                tmp_post_27 = count;
                count = count - 1u;
                if(tmp_post_27 == 0u)
                  break;

                signed int *tmp_post_28 = ff_decode__1__optr;
                ff_decode__1__optr = ff_decode__1__optr + 1l;
                signed short int *tmp_post_29 = iptr16;
                iptr16 = iptr16 + 1l;
                *tmp_post_28 = (signed int)*tmp_post_29 << 16;
                signed int *tmp_post_30 = ff_decode__1__optr;
                ff_decode__1__optr = ff_decode__1__optr + 1l;
                signed short int *tmp_post_31 = iptr16;
                iptr16 = iptr16 + 1l;
                *tmp_post_30 = (signed int)*tmp_post_31 << 16;
              }
              while((_Bool)1);

            else
              if((signed int)ff->codecC->sample_fmt == AV_SAMPLE_FMT_S32)
                do
                {
                  tmp_post_32 = count;
                  count = count - 1u;
                  if(tmp_post_32 == 0u)
                    break;

                  signed int *tmp_post_33 = ff_decode__1__optr;
                  ff_decode__1__optr = ff_decode__1__optr + 1l;
                  signed int *tmp_post_34 = iptr32;
                  iptr32 = iptr32 + 1l;
                  *tmp_post_33 = *tmp_post_34;
                  signed int *tmp_post_35 = ff_decode__1__optr;
                  ff_decode__1__optr = ff_decode__1__optr + 1l;
                  signed int *tmp_post_36 = iptr32;
                  iptr32 = iptr32 + 1l;
                  *tmp_post_35 = *tmp_post_36;
                }
                while((_Bool)1);

              else
                if((signed int)ff->codecC->sample_fmt == AV_SAMPLE_FMT_S16P)
                  do
                  {
                    tmp_post_37 = count;
                    count = count - 1u;
                    if(tmp_post_37 == 0u)
                      break;

                    signed int *tmp_post_38 = ff_decode__1__optr;
                    ff_decode__1__optr = ff_decode__1__optr + 1l;
                    signed short int *tmp_post_39 = iptr16l;
                    iptr16l = iptr16l + 1l;
                    *tmp_post_38 = (signed int)*tmp_post_39 << 16;
                    signed int *tmp_post_40 = ff_decode__1__optr;
                    ff_decode__1__optr = ff_decode__1__optr + 1l;
                    signed short int *tmp_post_41 = iptr16r;
                    iptr16r = iptr16r + 1l;
                    *tmp_post_40 = (signed int)*tmp_post_41 << 16;
                  }
                  while((_Bool)1);

                else
                  if((signed int)ff->codecC->sample_fmt == AV_SAMPLE_FMT_S32P)
                    do
                    {
                      tmp_post_42 = count;
                      count = count - 1u;
                      if(tmp_post_42 == 0u)
                        break;

                      signed int *tmp_post_43 = ff_decode__1__optr;
                      ff_decode__1__optr = ff_decode__1__optr + 1l;
                      signed int *tmp_post_44 = iptr32l;
                      iptr32l = iptr32l + 1l;
                      *tmp_post_43 = *tmp_post_44;
                      signed int *tmp_post_45 = ff_decode__1__optr;
                      ff_decode__1__optr = ff_decode__1__optr + 1l;
                      signed int *tmp_post_46 = iptr32r;
                      iptr32r = iptr32r + 1l;
                      *tmp_post_45 = *tmp_post_46;
                    }
                    while((_Bool)1);

                  else
                    if((signed int)ff->codecC->sample_fmt == AV_SAMPLE_FMT_FLTP)
                      do
                      {
                        tmp_post_47 = count;
                        count = count - 1u;
                        if(tmp_post_47 == 0u)
                          break;

                        double scaledl;
                        float *tmp_post_48 = iptrfl;
                        iptrfl = iptrfl + 1l;
                        scaledl = (double)(*tmp_post_48 * (float)0x7fffffff);
                        double scaledr;
                        float *tmp_post_49 = iptrfr;
                        iptrfr = iptrfr + 1l;
                        scaledr = (double)(*tmp_post_49 * (float)0x7fffffff);
                        if(scaledl > 2147483647.0)
                          scaledl = 2147483647.0;

                        if(scaledl < -2.147484e+9)
                          scaledl = -2147483648.0;

                        if(scaledr > 2147483647.0)
                          scaledr = 2147483647.0;

                        if(scaledr < -2.147484e+9)
                          scaledr = -2147483648.0;

                        signed int *tmp_post_50 = ff_decode__1__optr;
                        ff_decode__1__optr = ff_decode__1__optr + 1l;
                        *tmp_post_50 = (signed int)scaledl;
                        signed int *tmp_post_51 = ff_decode__1__optr;
                        ff_decode__1__optr = ff_decode__1__optr + 1l;
                        *tmp_post_51 = (signed int)scaledr;
                      }
                      while((_Bool)1);

                    else
                      if((signed int)loglevel_link13 >= lWARN)
                      {
                        return_value_logtime_52=logtime();
                        logprint("%s %s:%d unsupported sample format: %u\n", return_value_logtime_52, (const void *)"ff_decode", 455, ff->codecC->sample_fmt);
                      }

          }

          else
            if(ff->codecC->channels == 1)
            {
              if((signed int)ff->codecC->sample_fmt == AV_SAMPLE_FMT_S16)
                do
                {
                  tmp_post_53 = count;
                  count = count - 1u;
                  if(tmp_post_53 == 0u)
                    break;

                  signed int *tmp_post_54 = ff_decode__1__optr;
                  ff_decode__1__optr = ff_decode__1__optr + 1l;
                  *tmp_post_54 = (signed int)*iptr16 << 16;
                  signed int *tmp_post_55 = ff_decode__1__optr;
                  ff_decode__1__optr = ff_decode__1__optr + 1l;
                  signed short int *tmp_post_56 = iptr16;
                  iptr16 = iptr16 + 1l;
                  *tmp_post_55 = (signed int)*tmp_post_56 << 16;
                }
                while((_Bool)1);

              else
                if((signed int)ff->codecC->sample_fmt == AV_SAMPLE_FMT_S32)
                  do
                  {
                    tmp_post_57 = count;
                    count = count - 1u;
                    if(tmp_post_57 == 0u)
                      break;

                    signed int *tmp_post_58 = ff_decode__1__optr;
                    ff_decode__1__optr = ff_decode__1__optr + 1l;
                    *tmp_post_58 = *iptr32;
                    signed int *tmp_post_59 = ff_decode__1__optr;
                    ff_decode__1__optr = ff_decode__1__optr + 1l;
                    signed int *tmp_post_60 = iptr32;
                    iptr32 = iptr32 + 1l;
                    *tmp_post_59 = *tmp_post_60;
                  }
                  while((_Bool)1);

                else
                  if((signed int)ff->codecC->sample_fmt == AV_SAMPLE_FMT_S16P)
                    do
                    {
                      tmp_post_61 = count;
                      count = count - 1u;
                      if(tmp_post_61 == 0u)
                        break;

                      signed int *tmp_post_62 = ff_decode__1__optr;
                      ff_decode__1__optr = ff_decode__1__optr + 1l;
                      *tmp_post_62 = (signed int)*iptr16l << 16;
                      signed int *tmp_post_63 = ff_decode__1__optr;
                      ff_decode__1__optr = ff_decode__1__optr + 1l;
                      signed short int *tmp_post_64 = iptr16l;
                      iptr16l = iptr16l + 1l;
                      *tmp_post_63 = (signed int)*tmp_post_64 << 16;
                    }
                    while((_Bool)1);

                  else
                    if((signed int)ff->codecC->sample_fmt == AV_SAMPLE_FMT_S32P)
                      do
                      {
                        tmp_post_65 = count;
                        count = count - 1u;
                        if(tmp_post_65 == 0u)
                          break;

                        signed int *tmp_post_66 = ff_decode__1__optr;
                        ff_decode__1__optr = ff_decode__1__optr + 1l;
                        *tmp_post_66 = *iptr32l;
                        signed int *tmp_post_67 = ff_decode__1__optr;
                        ff_decode__1__optr = ff_decode__1__optr + 1l;
                        signed int *tmp_post_68 = iptr32l;
                        iptr32l = iptr32l + 1l;
                        *tmp_post_67 = *tmp_post_68;
                      }
                      while((_Bool)1);

                    else
                      if((signed int)ff->codecC->sample_fmt == AV_SAMPLE_FMT_FLTP)
                        do
                        {
                          tmp_post_69 = count;
                          count = count - 1u;
                          if(tmp_post_69 == 0u)
                            break;

                          double scaled;
                          float *tmp_post_70 = iptrfl;
                          iptrfl = iptrfl + 1l;
                          scaled = (double)(*tmp_post_70 * (float)0x7fffffff);
                          if(scaled > 2147483647.0)
                            scaled = 2147483647.0;

                          if(scaled < -2.147484e+9)
                            scaled = -2147483648.0;

                          signed int *tmp_post_71 = ff_decode__1__optr;
                          ff_decode__1__optr = ff_decode__1__optr + 1l;
                          *tmp_post_71 = (signed int)scaled;
                          signed int *tmp_post_72 = ff_decode__1__optr;
                          ff_decode__1__optr = ff_decode__1__optr + 1l;
                          *tmp_post_72 = (signed int)scaled;
                        }
                        while((_Bool)1);

                      else
                        if((signed int)loglevel_link13 >= lWARN)
                        {
                          return_value_logtime_73=logtime();
                          logprint("%s %s:%d unsupported sample format: %u\n", return_value_logtime_73, (const void *)"ff_decode", 487, ff->codecC->sample_fmt);
                        }

            }

            else
              if((signed int)loglevel_link13 >= lWARN)
              {
                return_value_logtime_74=logtime();
                logprint("%s %s:%d unsupported number of channels\n", return_value_logtime_74, (const void *)"ff_decode", 490);
              }

          frames = frames - ff_decode__1__4__2__1__f;
          if(!(decode.direct == (_Bool)0))
            _buf_inc_writep(outputbuf, ff_decode__1__4__2__1__f * (unsigned int)8);

          if(decode.direct == (_Bool)0)
            process_link9.in_frames = process_link9.in_frames + ff_decode__1__4__2__1__f;

        }
        if(!(decode.direct == (_Bool)0))
          pthread_mutex_unlock(&outputbuf->mutex);

      }

    }
    av_free_packet(ff->avpkt);
    return (enum anonymous_23)DECODE_RUNNING;
  }
}

// ff_open_alac
// file ffmpeg.c line 555
static void ff_open_alac(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness)
{
  _free_ff_data();
  ff->input_format=av_find_input_format("mp4");
  if(ff->input_format == ((struct AVInputFormat *)NULL))
  {
    const char *return_value_logtime_1;
    return_value_logtime_1=logtime();
    logprint("%s %s:%d mp4 format not supported by ffmpeg library\n", return_value_logtime_1, (const void *)"ff_open_alac", 560);
  }

  ff->wma = (_Bool)0;
  ff->wma_mmsh = (unsigned char)0;
  const char *return_value_logtime_2;
  if((signed int)loglevel_link13 >= lINFO)
  {
    return_value_logtime_2=logtime();
    logprint("%s %s:%d open alac\n", return_value_logtime_2, (const void *)"ff_open_alac", 566);
  }

}

// ff_open_wma
// file ffmpeg.c line 539
static void ff_open_wma(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness)
{
  _free_ff_data();
  ff->input_format=av_find_input_format("asf");
  if(ff->input_format == ((struct AVInputFormat *)NULL))
  {
    const char *return_value_logtime_1;
    return_value_logtime_1=logtime();
    logprint("%s %s:%d asf format not supported by ffmpeg library\n", return_value_logtime_1, (const void *)"ff_open_wma", 544);
  }

  ff->wma = (_Bool)1;
  ff->wma_mmsh = (unsigned char)((signed int)size - 48);
  ff->wma_playstream = (unsigned char)((signed int)rate - 1);
  ff->wma_metadatastream = (unsigned char)((signed int)chan != 63 ? (signed int)chan : 0);
  const char *return_value_logtime_2;
  if((signed int)loglevel_link13 >= lINFO)
  {
    return_value_logtime_2=logtime();
    logprint("%s %s:%d open wma chunking: %u playstream: %u metadatastream: %u\n", return_value_logtime_2, (const void *)"ff_open_wma", 552, ff->wma_mmsh, ff->wma_playstream, ff->wma_metadatastream);
  }

}

// flac_close
// file flac.c line 212
static void flac_close(void)
{
  FLAC__stream_decoder_delete(f->decoder);
  f->decoder = (struct anonymous_43 *)(void *)0;
}

// flac_decode
// file flac.c line 217
static enum anonymous_23 flac_decode(void)
{
  _Bool ok;
  signed int return_value_FLAC__stream_decoder_process_single_1;
  return_value_FLAC__stream_decoder_process_single_1=FLAC__stream_decoder_process_single(f->decoder);
  ok = (_Bool)return_value_FLAC__stream_decoder_process_single_1;
  enum anonymous_62 state;
  state=FLAC__stream_decoder_get_state(f->decoder);
  const char *return_value_logtime_2;
  if(ok == (_Bool)0 && !((signed int)state == FLAC__STREAM_DECODER_END_OF_STREAM))
  {
    if((signed int)loglevel_link6 >= lINFO)
    {
      return_value_logtime_2=logtime();
      logprint("%s %s:%d flac error: %s\n", return_value_logtime_2, (const void *)"flac_decode", 222, FLAC__StreamDecoderStateString[(signed long int)state]);
    }

  }

  if((signed int)state == FLAC__STREAM_DECODER_END_OF_STREAM)
    return (enum anonymous_23)DECODE_COMPLETE;

  else
    if((signed int)state >= 5)
      return (enum anonymous_23)DECODE_ERROR;

    else
      return (enum anonymous_23)DECODE_RUNNING;
}

// flac_open
// file flac.c line 203
static void flac_open(unsigned char sample_size, unsigned char sample_rate, unsigned char channels, unsigned char endianness)
{
  if(!(f->decoder == ((struct anonymous_43 *)NULL)))
    FLAC__stream_decoder_reset(f->decoder);

  else
    f->decoder=FLAC__stream_decoder_new();
  FLAC__stream_decoder_init_stream(f->decoder, read_cb, (enum anonymous_65 (*)(const struct anonymous_43 *, unsigned long int, void *))(void *)0, (enum anonymous_66 (*)(const struct anonymous_43 *, unsigned long int *, void *))(void *)0, (enum anonymous_67 (*)(const struct anonymous_43 *, unsigned long int *, void *))(void *)0, (signed int (*)(const struct anonymous_43 *, void *))(void *)0, write_cb, (void (*)(const struct anonymous_43 *, const struct anonymous_61 *, void *))(void *)0, error_cb, (void *)0);
}

// gain
// file squeezelite.h line 621
inline signed int gain(signed int gain, signed int sample)
{
  signed long int res = (signed long int)gain * (signed long int)sample;
  if(res >= 140737488355328ll)
    res = 0x7fffffffffffLL;

  if(!(res >= -140737488355327ll))
    res = -0x7fffffffffffLL;

  return (signed int)(res >> 16);
}

// get_mac
// file squeezelite.h line 377
void get_mac(unsigned char *mac)
{
  struct ifconf ifc;
  struct ifreq *ifr;
  struct ifreq *ifend;
  struct ifreq ifreq;
  struct ifreq ifs[4l];
  mac[(signed long int)5] = (unsigned char)0;
  mac[(signed long int)4] = mac[(signed long int)5];
  mac[(signed long int)3] = mac[(signed long int)4];
  mac[(signed long int)2] = mac[(signed long int)3];
  mac[(signed long int)1] = mac[(signed long int)2];
  mac[(signed long int)0] = mac[(signed long int)1];
  signed int s;
  s=socket(2, 2, 0);
  ifc.ifc_len = (signed int)sizeof(struct ifreq [4l]) /*160ul*/ ;
  ifc.ifc_ifcu.ifcu_req = ifs;
  signed int return_value_ioctl_2;
  return_value_ioctl_2=ioctl(s, (unsigned long int)0x8912, &ifc);
  if(return_value_ioctl_2 == 0)
  {
    ifend = ifs + (signed long int)((unsigned long int)ifc.ifc_len / sizeof(struct ifreq) /*40ul*/ );
    ifr = ifc.ifc_ifcu.ifcu_req;
    for( ; !(ifr >= ifend); ifr = ifr + 1l)
      if((signed int)ifr->ifr_ifru.ifru_addr.sa_family == 2)
      {
        strncpy(ifreq.ifr_ifrn.ifrn_name, ifr->ifr_ifrn.ifrn_name, sizeof(char [16l]) /*16ul*/ );
        signed int return_value_ioctl_1;
        return_value_ioctl_1=ioctl(s, (unsigned long int)0x8927, &ifreq);
        if(return_value_ioctl_1 == 0)
        {
          memcpy((void *)mac, (const void *)ifreq.ifr_ifru.ifru_hwaddr.sa_data, (unsigned long int)6);
          if(!((signed int)mac[1l] + (signed int)mac[2l] + (signed int)*mac == 0))
            break;

        }

      }

  }

  close(s);
}

// gettime_ms
// file squeezelite.h line 376
unsigned int gettime_ms(void)
{
  struct timespec ts;
  signed int return_value_clock_gettime_1;
  return_value_clock_gettime_1=clock_gettime(1, &ts);
  if(return_value_clock_gettime_1 == 0)
    return (unsigned int)(ts.tv_sec * (signed long int)1000 + ts.tv_nsec / (signed long int)1000000);

  else
  {
    struct timeval tv;
    gettimeofday(&tv, (struct timezone *)(void *)0);
    return (unsigned int)(tv.tv_sec * (signed long int)1000 + tv.tv_usec / (signed long int)1000);
  }
}

// ir_close
// file squeezelite.h line 663
void ir_close(void)
{
  if(fd_link1 >= 1)
  {
    fd_link1 = -1;
    if(!(config == ((struct lirc_config *)NULL)))
      lirc_freeconfig(config);

    lirc_deinit();
    pthread_cancel(thread_link3);
    pthread_join(thread_link3, (void **)(void *)0);
    pthread_mutex_destroy(&ir.mutex);
  }

}

// ir_cmd_map
// file ir.c line 101
static unsigned int ir_cmd_map(const char *c)
{
  signed int i = 0;
  for( ; !(cmdmap[(signed long int)i].cmd == ((char *)NULL)); i = i + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(c, cmdmap[(signed long int)i].cmd);
    if(return_value_strcmp_1 == 0)
      return cmdmap[(signed long int)i].code;

  }
  return (unsigned int)0;
}

// ir_init
// file squeezelite.h line 662
void ir_init(enum anonymous_8 level, char *lircrc)
{
  loglevel_link17 = level;
  fd_link1=lirc_init("squeezelite", 0);
  const char *return_value_logtime_1;
  const char *return_value_logtime_3;
  if(fd_link1 >= 1)
  {
    signed int return_value_lirc_readconfig_2;
    return_value_lirc_readconfig_2=lirc_readconfig(lircrc, &config, (signed int (*)(char *))(void *)0);
    if(!(return_value_lirc_readconfig_2 == 0))
    {
      if((signed int)loglevel_link17 >= lWARN)
      {
        return_value_logtime_1=logtime();
        logprint("%s %s:%d error reading config: %s\n", return_value_logtime_1, (const void *)"ir_init", 218, lircrc);
      }

    }

    pthread_mutex_init(&ir.mutex, (const union anonymous_7 *)(void *)0);
    union pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, (unsigned long int)(16384 + 64 * 1024));
    pthread_create(&thread_link3, &attr, (void * (*)(void *))ir_thread, (void *)0);
    pthread_attr_destroy(&attr);
  }

  else
    if((signed int)loglevel_link17 >= lWARN)
    {
      return_value_logtime_3=logtime();
      logprint("%s %s:%d failed to connect to lircd - ir processing disabled\n", return_value_logtime_3, (const void *)"ir_init", 230);
    }

}

// ir_key_map
// file ir.c line 111
static unsigned int ir_key_map(const char *c, const char *r)
{
  signed int i = 0;
  signed int return_value_strcmp_1;
  const char *return_value_logtime_3;
  for( ; !(keymap[(signed long int)i].lirc == ((char *)NULL)); i = i + 1)
  {
    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(c, keymap[(signed long int)i].lirc);
    if(return_value_strcmp_4 == 0)
    {
      _Bool tmp_if_expr_2;
      if(!(keymap[(signed long int)i].repeat == (_Bool)0))
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        return_value_strcmp_1=strcmp(r, "00");
        tmp_if_expr_2 = !(return_value_strcmp_1 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
        return keymap[(signed long int)i].code;

      if((signed int)loglevel_link17 >= lDEBUG)
      {
        return_value_logtime_3=logtime();
        logprint("%s %s:%d repeat suppressed\n", return_value_logtime_3, (const void *)"ir_key_map", 118);
      }

      break;
    }

  }
  return (unsigned int)0;
}

// ir_thread
// file ir.c line 125
static void * ir_thread()
{
  char *code;
  signed int return_value_lirc_nextcode_1;
  signed int return_value_lirc_code2char_2;
  const char *return_value_logtime_3;
  const char *return_value_logtime_4;
  const char *return_value_logtime_5;
  while(fd_link1 >= 1)
  {
    return_value_lirc_nextcode_1=lirc_nextcode(&code);
    if(!(return_value_lirc_nextcode_1 == 0))
      break;

    unsigned int now;
    now=gettime_ms();
    unsigned int ir_code = (unsigned int)0;
    if(!(code == ((char *)NULL)))
    {
      if(!(config == ((struct lirc_config *)NULL)))
      {
        char *c;
        do
        {
          return_value_lirc_code2char_2=lirc_code2char(config, code, &c);
          if(!(return_value_lirc_code2char_2 == 0))
            break;

          if(c == ((char *)NULL))
            break;

          ir_code=ir_cmd_map(c);
          if(!(ir_code == 0u))
          {
            if((signed int)loglevel_link17 >= lDEBUG)
            {
              return_value_logtime_3=logtime();
              logprint("%s %s:%d ir cmd: %s -> %x\n", return_value_logtime_3, (const void *)"ir_thread", 142, c, ir_code);
            }

          }

        }
        while((_Bool)1);
      }

      if(ir_code == 0u)
      {
        char *b;
        char *ir_thread__1__1__2__r;
        strtok(code, " \n");
        ir_thread__1__1__2__r=strtok((char *)(void *)0, " \n");
        b=strtok((char *)(void *)0, " \n");
        if(!(b == ((char *)NULL)) && !(ir_thread__1__1__2__r == ((char *)NULL)))
        {
          ir_code=ir_key_map(b, ir_thread__1__1__2__r);
          if((signed int)loglevel_link17 >= lDEBUG)
          {
            return_value_logtime_4=logtime();
            logprint("%s %s:%d ir lirc: %s [%s] -> %x\n", return_value_logtime_4, (const void *)"ir_thread", 156, b, ir_thread__1__1__2__r, ir_code);
          }

        }

      }

      if(!(ir_code == 0u))
      {
        pthread_mutex_lock(&ir.mutex);
        if(!(ir.code == 0u))
        {
          if((signed int)loglevel_link17 >= lDEBUG)
          {
            return_value_logtime_5=logtime();
            logprint("%s %s:%d code dropped\n", return_value_logtime_5, (const void *)"ir_thread", 163);
          }

        }

        ir.code = ir_code;
        ir.ts = now;
        pthread_mutex_unlock(&ir.mutex);
        wake_controller();
      }

      free((void *)code);
    }

  }
  return NULL;
}

// is_flac_dop
// file squeezelite.h line 636
_Bool is_flac_dop(unsigned int *lptr, unsigned int *rptr, unsigned int frames)
{
  signed int matched = 0;
  unsigned int next = (unsigned int)0;
  unsigned int tmp_post_1;
  _Bool tmp_if_expr_3;
  do
  {
    tmp_post_1 = frames;
    frames = frames - 1u;
    if(tmp_post_1 == 0u)
      break;

    _Bool tmp_if_expr_2;
    if((16711680u & *lptr) == 327680u)
      tmp_if_expr_2 = (*rptr & (unsigned int)0x00FF0000) == (unsigned int)0x00050000 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    _Bool tmp_if_expr_4;
    if(tmp_if_expr_2)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      if((16711680u & *lptr) == 16384000u)
        tmp_if_expr_3 = (*rptr & (unsigned int)0x00FF0000) == (unsigned int)0x00FA0000 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      if(*lptr >> 24 == next)
      {
        matched = matched + 1;
        next = (unsigned int)(0x05 + 0xFA) - next;
      }

      else
      {
        next = *lptr >> 24;
        matched = 1;
      }
    }

    else
      return (_Bool)0;
    if(matched == 32)
      return (_Bool)1;

    lptr = lptr + 1l;
    rptr = rptr + 1l;
  }
  while((_Bool)1);
  return (_Bool)0;
}

// license
// file main.c line 164
static void license(void)
{
  printf("Squeezelite v1.8, Copyright 2012-2015 Adrian Smith.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nContains dsd2pcm library Copyright 2009, 2011 Sebastian Gesemann which\nis subject to its own license.\n\n");
}

// list_devices
// file squeezelite.h line 605
void list_devices(void)
{
  signed int err;
  signed int i;
  err=Pa_Initialize();
  const char *return_value_logtime_1;
  const char *return_value_Pa_GetErrorText_2;
  if(!(err == 0))
  {
    if((signed int)loglevel_link3 >= lWARN)
    {
      return_value_logtime_1=logtime();
      return_value_Pa_GetErrorText_2=Pa_GetErrorText(err);
      logprint("%s %s:%d error initialising port audio: %s\n", return_value_logtime_1, (const void *)"list_devices", 58, return_value_Pa_GetErrorText_2);
    }

    goto __CPROVER_DUMP_L8;
  }

  printf("Output devices:\n");
  i = 0;
  signed int return_value_Pa_GetDeviceCount_3;
  do
  {
    return_value_Pa_GetDeviceCount_3=Pa_GetDeviceCount();
    if(i >= return_value_Pa_GetDeviceCount_3)
      break;

    const struct PaDeviceInfo *return_value_Pa_GetDeviceInfo_7;
    return_value_Pa_GetDeviceInfo_7=Pa_GetDeviceInfo(i);
    if(!(return_value_Pa_GetDeviceInfo_7->maxOutputChannels == 0))
    {
      const struct PaDeviceInfo *return_value_Pa_GetDeviceInfo_4;
      return_value_Pa_GetDeviceInfo_4=Pa_GetDeviceInfo(i);
      const struct PaDeviceInfo *return_value_Pa_GetDeviceInfo_5;
      return_value_Pa_GetDeviceInfo_5=Pa_GetDeviceInfo(i);
      const struct PaHostApiInfo *return_value_Pa_GetHostApiInfo_6;
      return_value_Pa_GetHostApiInfo_6=Pa_GetHostApiInfo(return_value_Pa_GetDeviceInfo_5->hostApi);
      printf("  %i - %s [%s]\n", i, return_value_Pa_GetDeviceInfo_4->name, return_value_Pa_GetHostApiInfo_6->name);
    }

    i = i + 1;
  }
  while((_Bool)1);
  printf("\n");
  err=Pa_Terminate();
  const char *return_value_logtime_8;
  const char *return_value_Pa_GetErrorText_9;
  if(!(err == 0))
  {
    if((signed int)loglevel_link3 >= lWARN)
    {
      return_value_logtime_8=logtime();
      return_value_Pa_GetErrorText_9=Pa_GetErrorText(err);
      logprint("%s %s:%d error closing port audio: %s\n", return_value_logtime_8, (const void *)"list_devices", 71, return_value_Pa_GetErrorText_9);
    }

  }


__CPROVER_DUMP_L8:
  ;
}

// load_faad
// file faad.c line 586
static _Bool load_faad()
{
  return (_Bool)1;
}

// load_ff
// file ffmpeg.c line 578
static _Bool load_ff()
{
  return (_Bool)1;
}

// load_flac
// file flac.c line 234
static _Bool load_flac()
{
  return (_Bool)1;
}

// load_mad
// file mad.c line 358
static _Bool load_mad()
{
  return (_Bool)1;
}

// load_mpg
// file mpg.c line 215
static _Bool load_mpg()
{
  return (_Bool)1;
}

// load_soxr
// file resample.c line 243
static _Bool load_soxr(void)
{
  return (_Bool)1;
}

// load_vorbis
// file vorbis.c line 273
static _Bool load_vorbis()
{
  return (_Bool)1;
}

// logprint
// file squeezelite.h line 364
void logprint(const char *fmt, ...)
{
  void **args = (void **)&fmt;
  vfprintf(stderr, fmt, args);
  fflush(stderr);
}

// logtime
// file squeezelite.h line 363
const char * logtime(void)
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  struct tm *return_value_localtime_1;
  return_value_localtime_1=localtime(&tv.tv_sec);
  static char logtime__1__buf[100l];
  strftime(logtime__1__buf, sizeof(char [100l]) /*100ul*/ , "[%T.", return_value_localtime_1);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(logtime__1__buf);
  sprintf(logtime__1__buf + (signed long int)return_value_strlen_2, "%06ld]", (signed long int)tv.tv_usec);
  return logtime__1__buf;
}

// mad_close
// file mad.c line 350
static void mad_close(void)
{
  mad_frame_finish(&m->frame);
  mad_stream_finish(&m->stream);
  free((void *)m->readbuf);
  m->readbuf = (unsigned char *)(void *)0;
}

// mad_decode
// file mad.c line 163
static enum anonymous_23 mad_decode(void)
{
  unsigned long int bytes;
  _Bool eos = (_Bool)0;
  pthread_mutex_lock(&streambuf->mutex);
  unsigned int return_value__buf_used_1;
  return_value__buf_used_1=_buf_used(streambuf);
  unsigned int return_value__buf_cont_read_2;
  return_value__buf_cont_read_2=_buf_cont_read(streambuf);
  unsigned int tmp_if_expr_5;
  unsigned int return_value__buf_used_3;
  unsigned int return_value__buf_cont_read_4;
  if(!(return_value__buf_used_1 >= return_value__buf_cont_read_2))
  {
    return_value__buf_used_3=_buf_used(streambuf);
    tmp_if_expr_5 = return_value__buf_used_3;
  }

  else
  {
    return_value__buf_cont_read_4=_buf_cont_read(streambuf);
    tmp_if_expr_5 = return_value__buf_cont_read_4;
  }
  bytes = (unsigned long int)tmp_if_expr_5;
  const char *return_value_logtime_7;
  if(!(m->checktags == 0))
  {
    if(m->checktags == 1)
    {
      m->consume=_check_id3_tag(bytes);
      m->checktags = 2;
    }

    if(!(m->consume == 0u))
    {
      unsigned int consume;
      unsigned long int tmp_if_expr_6;
      if(!((unsigned long int)m->consume >= bytes))
        tmp_if_expr_6 = (unsigned long int)m->consume;

      else
        tmp_if_expr_6 = bytes;
      consume = (unsigned int)tmp_if_expr_6;
      if((signed int)loglevel_link8 >= lDEBUG)
      {
        return_value_logtime_7=logtime();
        logprint("%s %s:%d consume: %u of %u\n", return_value_logtime_7, (const void *)"mad_decode", 177, consume, m->consume);
      }

      _buf_inc_readp(streambuf, consume);
      m->consume = m->consume - consume;
      pthread_mutex_unlock(&streambuf->mutex);
      return (enum anonymous_23)DECODE_RUNNING;
    }

    if(m->checktags == 2)
    {
      if(stream.meta_interval == 0u)
        _check_lame_header(bytes);

      m->checktags = 0;
    }

  }

  if(!(m->stream.next_frame == ((const unsigned char *)NULL)))
  {
    if(!(m->readbuf_len == 0u))
    {
      m->readbuf_len = m->readbuf_len - (unsigned int)(m->stream.next_frame - m->readbuf);
      memmove((void *)m->readbuf, (const void *)m->stream.next_frame, (unsigned long int)m->readbuf_len);
    }

  }

  unsigned long int tmp_if_expr_8;
  if(!(bytes >= (unsigned long int)(2048u + -m->readbuf_len)))
    tmp_if_expr_8 = bytes;

  else
    tmp_if_expr_8 = (unsigned long int)((unsigned int)2048 - m->readbuf_len);
  bytes = tmp_if_expr_8;
  memcpy((void *)(m->readbuf + (signed long int)m->readbuf_len), (const void *)streambuf->readp, bytes);
  m->readbuf_len = m->readbuf_len + (unsigned int)bytes;
  _buf_inc_readp(streambuf, (unsigned int)bytes);
  unsigned int return_value__buf_used_10;
  const char *return_value_logtime_9;
  if(!((signed int)stream.state >= 2))
  {
    return_value__buf_used_10=_buf_used(streambuf);
    if(return_value__buf_used_10 == 0u)
    {
      eos = (_Bool)1;
      if((signed int)loglevel_link8 >= lDEBUG)
      {
        return_value_logtime_9=logtime();
        logprint("%s %s:%d end of stream\n", return_value_logtime_9, (const void *)"mad_decode", 203);
      }

      memset((void *)(m->readbuf + (signed long int)m->readbuf_len), 0, (unsigned long int)8);
      m->readbuf_len = m->readbuf_len + (unsigned int)8;
    }

  }

  pthread_mutex_unlock(&streambuf->mutex);
  mad_stream_buffer(&m->stream, m->readbuf, (unsigned long int)m->readbuf_len);
  _Bool tmp_if_expr_15;
  const char *return_value_logtime_11;
  const char *return_value_mad_stream_errorstr_12;
  const char *return_value_logtime_13;
  const char *return_value_mad_stream_errorstr_14;
  const char *return_value_logtime_19;
  const char *return_value_logtime_21;
  const char *return_value_logtime_23;
  const char *return_value_logtime_24;
  const char *return_value_logtime_25;
  const char *return_value_logtime_27;
  unsigned int return_value__buf_cont_write_29;
  unsigned long int tmp_post_31;
  while((_Bool)1)
  {
    unsigned long int frames;
    signed int *iptrl;
    signed int *iptrr;
    unsigned int max_frames;
    signed int return_value_mad_frame_decode_18;
    return_value_mad_frame_decode_18=mad_frame_decode(&m->frame, &m->stream);
    if(return_value_mad_frame_decode_18 == -1)
    {
      enum anonymous_23 ret;
      _Bool tmp_if_expr_17;
      if(eos == (_Bool)0)
        tmp_if_expr_17 = (signed int)m->stream.error == MAD_ERROR_BUFLEN ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_17 = (_Bool)0;
      if(tmp_if_expr_17)
        ret = (enum anonymous_23)DECODE_RUNNING;

      else
      {
        _Bool tmp_if_expr_16;
        if(!(eos == (_Bool)0))
        {
          if((signed int)m->stream.error == MAD_ERROR_BUFLEN)
            tmp_if_expr_15 = (_Bool)1;

          else
            tmp_if_expr_15 = (signed int)m->stream.error == MAD_ERROR_LOSTSYNC ? (_Bool)1 : (_Bool)0;
          tmp_if_expr_16 = tmp_if_expr_15 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_16 = (_Bool)0;
        if(tmp_if_expr_16)
          ret = (enum anonymous_23)DECODE_COMPLETE;

        else
          if((0xff00 & (signed int)m->stream.error) == 0)
          {
            if((signed int)loglevel_link8 >= lINFO)
            {
              return_value_logtime_11=logtime();
              return_value_mad_stream_errorstr_12=mad_stream_errorstr(&m->stream);
              logprint("%s %s:%d mad_frame_decode error: %s - stopping decoder\n", return_value_logtime_11, (const void *)"mad_decode", 225, return_value_mad_stream_errorstr_12);
            }

            ret = (enum anonymous_23)DECODE_COMPLETE;
          }

          else
          {
            if(!(m->stream.error == m->last_error))
            {
              if((signed int)loglevel_link8 >= lDEBUG)
              {
                return_value_logtime_13=logtime();
                return_value_mad_stream_errorstr_14=mad_stream_errorstr(&m->stream);
                logprint("%s %s:%d mad_frame_decode error: %s\n", return_value_logtime_13, (const void *)"mad_decode", 230, return_value_mad_stream_errorstr_14);
              }

            }

            ret = (enum anonymous_23)DECODE_RUNNING;
          }
      }
      m->last_error = m->stream.error;
      return ret;
    }

    mad_synth_frame(&m->synth, &m->frame);
    if(!(decode.new_stream == (_Bool)0))
    {
      pthread_mutex_lock(&outputbuf->mutex);
      if((signed int)loglevel_link8 >= lINFO)
      {
        return_value_logtime_19=logtime();
        logprint("%s %s:%d setting track_start\n", return_value_logtime_19, (const void *)"mad_decode", 242);
      }

      output.next_sample_rate=decode_newstream(m->synth.pcm.samplerate, output.supported_rates);
      output.next_dop = (_Bool)0;
      output.track_start = outputbuf->writep;
      if(!(output.fade_mode == /*enum*/FADE_NONE))
        _checkfade((_Bool)1);

      decode.new_stream = (_Bool)0;
      pthread_mutex_unlock(&outputbuf->mutex);
    }

    if(!(decode.direct == (_Bool)0))
      pthread_mutex_lock(&outputbuf->mutex);

    if(!(decode.direct == (_Bool)0))
    {
      unsigned int return_value__buf_space_20;
      return_value__buf_space_20=_buf_space(outputbuf);
      max_frames = return_value__buf_space_20 / (unsigned int)8;
    }

    if(decode.direct == (_Bool)0)
      max_frames = process_link4.max_in_frames - process_link4.in_frames;

    if(!(max_frames >= (unsigned int)m->synth.pcm.length))
    {
      if((signed int)loglevel_link8 >= lWARN)
      {
        return_value_logtime_21=logtime();
        logprint("%s %s:%d too many samples - dropping samples\n", return_value_logtime_21, (const void *)"mad_decode", 261);
      }

      m->synth.pcm.length = (unsigned short int)max_frames;
    }

    frames = (unsigned long int)m->synth.pcm.length;
    iptrl = m->synth.pcm.samples[(signed long int)0];
    iptrr = m->synth.pcm.samples[(signed long int)((signed int)m->synth.pcm.channels - 1)];
    if(!(m->skip == 0u))
    {
      unsigned int skip;
      unsigned long int tmp_if_expr_22;
      if(!((unsigned long int)m->skip >= frames))
        tmp_if_expr_22 = (unsigned long int)m->skip;

      else
        tmp_if_expr_22 = frames;
      skip = (unsigned int)tmp_if_expr_22;
      if((signed int)loglevel_link8 >= lDEBUG)
      {
        return_value_logtime_23=logtime();
        logprint("%s %s:%d gapless: skipping %u frames at start\n", return_value_logtime_23, (const void *)"mad_decode", 271, skip);
      }

      frames = frames - (unsigned long int)skip;
      m->skip = m->skip - skip;
      iptrl = iptrl + (signed long int)skip;
      iptrr = iptrr + (signed long int)skip;
    }

    if(!(m->samples == 0ul))
    {
      if(!(m->samples >= frames))
      {
        if((signed int)loglevel_link8 >= lDEBUG)
        {
          return_value_logtime_24=logtime();
          logprint("%s %s:%d gapless: trimming %u frames from end\n", return_value_logtime_24, (const void *)"mad_decode", 280, frames - m->samples);
        }

        frames = (unsigned long int)m->samples;
      }

      m->samples = m->samples - frames;
      if(m->samples >= 1ul)
      {
        if(!(eos == (_Bool)0))
        {
          _Bool tmp_if_expr_26;
          if((signed int)*m->stream.next_frame == 0xff)
            tmp_if_expr_26 = ((signed int)m->stream.next_frame[(signed long int)1] & 0xf0) == 0xf0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_26 = (_Bool)0;
          if(!tmp_if_expr_26)
          {
            if((signed int)loglevel_link8 >= lDEBUG)
            {
              return_value_logtime_25=logtime();
              logprint("%s %s:%d gapless: early end - trimming padding from end\n", return_value_logtime_25, (const void *)"mad_decode", 287);
            }

            if(frames >= (unsigned long int)m->padding)
              frames = frames - (unsigned long int)m->padding;

            else
              frames = (unsigned long int)0;
            m->samples = (unsigned long int)0;
          }

        }

      }

    }

    if((signed int)loglevel_link8 >= lSDEBUG)
    {
      return_value_logtime_27=logtime();
      logprint("%s %s:%d write %u frames\n", return_value_logtime_27, (const void *)"mad_decode", 297, frames);
    }

    while(frames >= 1ul)
    {
      unsigned long int mad_decode__1__4__8__f;
      unsigned long int count;
      signed int *mad_decode__1__4__8__optr;
      if(!(decode.direct == (_Bool)0))
      {
        unsigned int return_value__buf_cont_write_28;
        return_value__buf_cont_write_28=_buf_cont_write(outputbuf);
        unsigned long int tmp_if_expr_30;
        if(!(frames >= (unsigned long int)(return_value__buf_cont_write_28 / 8u)))
          tmp_if_expr_30 = frames;

        else
        {
          return_value__buf_cont_write_29=_buf_cont_write(outputbuf);
          tmp_if_expr_30 = (unsigned long int)(return_value__buf_cont_write_29 / (unsigned int)8);
        }
        mad_decode__1__4__8__f = tmp_if_expr_30;
        mad_decode__1__4__8__optr = (signed int *)outputbuf->writep;
      }

      if(decode.direct == (_Bool)0)
      {
        mad_decode__1__4__8__f = frames < (unsigned long int)(process_link4.max_in_frames - process_link4.in_frames) ? frames : (unsigned long int)(process_link4.max_in_frames - process_link4.in_frames);
        mad_decode__1__4__8__optr = (signed int *)((unsigned char *)process_link4.inbuf + (signed long int)(process_link4.in_frames * (unsigned int)8));
      }

      count = mad_decode__1__4__8__f;
      do
      {
        tmp_post_31 = count;
        count = count - 1ul;
        if(tmp_post_31 == 0ul)
          break;

        signed int *tmp_post_32 = mad_decode__1__4__8__optr;
        mad_decode__1__4__8__optr = mad_decode__1__4__8__optr + 1l;
        signed int *tmp_post_33 = iptrl;
        iptrl = iptrl + 1l;
        unsigned int return_value_scale_34;
        return_value_scale_34=scale(*tmp_post_33);
        *tmp_post_32 = (signed int)return_value_scale_34;
        signed int *tmp_post_35 = mad_decode__1__4__8__optr;
        mad_decode__1__4__8__optr = mad_decode__1__4__8__optr + 1l;
        signed int *tmp_post_36 = iptrr;
        iptrr = iptrr + 1l;
        unsigned int return_value_scale_37;
        return_value_scale_37=scale(*tmp_post_36);
        *tmp_post_35 = (signed int)return_value_scale_37;
      }
      while((_Bool)1);
      frames = frames - mad_decode__1__4__8__f;
      if(!(decode.direct == (_Bool)0))
        _buf_inc_writep(outputbuf, (unsigned int)(mad_decode__1__4__8__f * (unsigned long int)8));

      if(decode.direct == (_Bool)0)
        process_link4.in_frames = process_link4.in_frames + (unsigned int)mad_decode__1__4__8__f;

    }
    if(!(decode.direct == (_Bool)0))
      pthread_mutex_unlock(&outputbuf->mutex);

  }
  return (enum anonymous_23)(eos != (_Bool)0 ? DECODE_COMPLETE : DECODE_RUNNING);
}

// mad_open
// file mad.c line 335
static void mad_open(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness)
{
  if(m->readbuf == ((unsigned char *)NULL))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(2048 + 8));
    m->readbuf = (unsigned char *)return_value_malloc_1;
  }

  m->checktags = 1;
  m->consume = (unsigned int)0;
  m->skip = (unsigned int)529;
  m->samples = (unsigned long int)0;
  m->readbuf_len = (unsigned int)0;
  m->last_error = (enum mad_error)MAD_ERROR_NONE;
  mad_stream_init(&m->stream);
  mad_frame_init(&m->frame);
  mad_synth_init(&m->synth);
}

// main
// file main.c line 190
signed int main(signed int argc, char **argv)
{
  char *server = (char *)(void *)0;
  char *output_device = "default";
  char *include_codecs = (char *)(void *)0;
  char *exclude_codecs = "";
  char *name = (char *)(void *)0;
  char *namefile = (char *)(void *)0;
  char *modelname = (char *)(void *)0;
  char *logfile = (char *)(void *)0;
  unsigned char mac[6l];
  unsigned int stream_buf_size = (unsigned int)(2 * 1024 * 1024);
  unsigned int output_buf_size = (unsigned int)0;
  unsigned int rates[16l] = { (unsigned int)0, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u };
  unsigned int rate_delay = (unsigned int)0;
  char *resample = (char *)(void *)0;
  char *output_params = (char *)(void *)0;
  unsigned int idle = (unsigned int)0;
  _Bool daemonize = (_Bool)0;
  char *pidfile = (char *)(void *)0;
  struct _IO_FILE *pidfp = (struct _IO_FILE *)(void *)0;
  _Bool main__1__dop = (_Bool)0;
  unsigned int dop_delay = (unsigned int)0;
  _Bool visexport = (_Bool)0;
  char *lircrc = (char *)(void *)0;
  enum anonymous_8 log_output = (enum anonymous_8)lWARN;
  enum anonymous_8 log_stream = (enum anonymous_8)lWARN;
  enum anonymous_8 log_decode = (enum anonymous_8)lWARN;
  enum anonymous_8 log_slimproto = (enum anonymous_8)lWARN;
  enum anonymous_8 log_ir = (enum anonymous_8)lWARN;
  char *optarg = (char *)(void *)0;
  signed int optind = 1;
  signed int main__1__i;
  char cmdline[512l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  get_mac(mac);
  main__1__i = 0;
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_1;
  unsigned long int return_value_strlen_2;
  do
  {
    if(!(main__1__i >= argc))
    {
      return_value_strlen_1=strlen(argv[(signed long int)main__1__i]);
      return_value_strlen_2=strlen(cmdline);
      tmp_if_expr_3 = return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)2 < (unsigned long int)512 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
      break;

    strcat(cmdline, argv[(signed long int)main__1__i]);
    strcat(cmdline, " ");
    main__1__i = main__1__i + 1;
  }
  while((_Bool)1);
  unsigned long int return_value_strlen_4;
  char *return_value_strstr_5;
  signed int return_value_atoi_7;
  signed int return_value_atoi_8;
  signed int return_value_atoi_10;
  signed int return_value_strcmp_15;
  signed int return_value_strcmp_18;
  signed int return_value_strcmp_21;
  signed int return_value_strcmp_24;
  signed int return_value_strcmp_27;
  char *return_value_strstr_41;
  signed int return_value_atoi_34;
  unsigned int tmp_if_expr_36;
  signed int return_value_atoi_35;
  signed int return_value_atoi_38;
  while(!(optind >= argc))
  {
    return_value_strlen_4=strlen(argv[(signed long int)optind]);
    if(!(return_value_strlen_4 >= 2ul))
      break;

    if(!((signed int)*argv[(signed long int)optind] == 45))
      break;

    char *opt = argv[(signed long int)optind] + (signed long int)1;
    char *return_value_strstr_6;
    return_value_strstr_6=strstr("oabcCdefmMnNpPrs", opt);
    if(!(return_value_strstr_6 == ((char *)NULL)) && !(optind >= argc + -1))
    {
      optarg = argv[(signed long int)(optind + 1)];
      optind = optind + 2;
    }

    else
    {
      return_value_strstr_5=strstr("ltz?uRDvi", opt);
      if(!(return_value_strstr_5 == ((char *)NULL)))
      {
        optarg = (char *)(void *)0;
        optind = optind + 1;
      }

      else
      {
        fprintf(stderr, "\nOption error: -%s\n\n", opt);
        usage(argv[(signed long int)0]);
        exit(1);
      }
    }
    switch((signed int)opt[(signed long int)0])
    {
      case 111:
      {
        output_device = optarg;
        break;
      }
      case 97:
      {
        output_params = optarg;
        break;
      }
      case 98:
      {
        char *s;
        s=next_param(optarg, (char)58);
        char *o;
        o=next_param((char *)(void *)0, (char)58);
        if(!(s == ((char *)NULL)))
        {
          return_value_atoi_7=atoi(s);
          stream_buf_size = (unsigned int)(return_value_atoi_7 * 1024);
        }

        if(!(o == ((char *)NULL)))
        {
          return_value_atoi_8=atoi(o);
          output_buf_size = (unsigned int)(return_value_atoi_8 * 1024);
        }

        break;
      }
      case 99:
      {
        include_codecs = optarg;
        break;
      }
      case 67:
      {
        return_value_atoi_10=atoi(optarg);
        if(return_value_atoi_10 >= 1)
        {
          signed int return_value_atoi_9;
          return_value_atoi_9=atoi(optarg);
          idle = (unsigned int)(return_value_atoi_9 * 1000);
        }

        break;
      }
      case 101:
      {
        exclude_codecs = optarg;
        break;
      }
      case 100:
      {
        char *l;
        l=strtok(optarg, "=");
        char *main__1__2__4__3__v;
        main__1__2__4__3__v=strtok((char *)(void *)0, "=");
        enum anonymous_8 new = (enum anonymous_8)lWARN;
        if(!(l == ((char *)NULL)) && !(main__1__2__4__3__v == ((char *)NULL)))
        {
          signed int return_value_strcmp_11;
          return_value_strcmp_11=strcmp(main__1__2__4__3__v, "info");
          if(return_value_strcmp_11 == 0)
            new = (enum anonymous_8)lINFO;

          signed int return_value_strcmp_12;
          return_value_strcmp_12=strcmp(main__1__2__4__3__v, "debug");
          if(return_value_strcmp_12 == 0)
            new = (enum anonymous_8)lDEBUG;

          signed int return_value_strcmp_13;
          return_value_strcmp_13=strcmp(main__1__2__4__3__v, "sdebug");
          if(return_value_strcmp_13 == 0)
            new = (enum anonymous_8)lSDEBUG;

          signed int return_value_strcmp_14;
          return_value_strcmp_14=strcmp(l, "all");
          _Bool tmp_if_expr_16;
          if(return_value_strcmp_14 == 0)
            tmp_if_expr_16 = (_Bool)1;

          else
          {
            return_value_strcmp_15=strcmp(l, "slimproto");
            tmp_if_expr_16 = !(return_value_strcmp_15 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_16)
            log_slimproto = new;

          signed int return_value_strcmp_17;
          return_value_strcmp_17=strcmp(l, "all");
          _Bool tmp_if_expr_19;
          if(return_value_strcmp_17 == 0)
            tmp_if_expr_19 = (_Bool)1;

          else
          {
            return_value_strcmp_18=strcmp(l, "stream");
            tmp_if_expr_19 = !(return_value_strcmp_18 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_19)
            log_stream = new;

          signed int return_value_strcmp_20;
          return_value_strcmp_20=strcmp(l, "all");
          _Bool tmp_if_expr_22;
          if(return_value_strcmp_20 == 0)
            tmp_if_expr_22 = (_Bool)1;

          else
          {
            return_value_strcmp_21=strcmp(l, "decode");
            tmp_if_expr_22 = !(return_value_strcmp_21 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_22)
            log_decode = new;

          signed int return_value_strcmp_23;
          return_value_strcmp_23=strcmp(l, "all");
          _Bool tmp_if_expr_25;
          if(return_value_strcmp_23 == 0)
            tmp_if_expr_25 = (_Bool)1;

          else
          {
            return_value_strcmp_24=strcmp(l, "output");
            tmp_if_expr_25 = !(return_value_strcmp_24 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_25)
            log_output = new;

          signed int return_value_strcmp_26;
          return_value_strcmp_26=strcmp(l, "all");
          _Bool tmp_if_expr_28;
          if(return_value_strcmp_26 == 0)
            tmp_if_expr_28 = (_Bool)1;

          else
          {
            return_value_strcmp_27=strcmp(l, "ir");
            tmp_if_expr_28 = !(return_value_strcmp_27 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_28)
            log_ir = new;

        }

        else
        {
          fprintf(stderr, "\nDebug settings error: -d %s\n\n", optarg);
          usage(argv[(signed long int)0]);
          exit(1);
        }
        break;
      }
      case 102:
      {
        logfile = optarg;
        break;
      }
      case 109:
      {
        signed int byte = 0;
        char *tmp;
        signed int return_value_strncmp_32;
        return_value_strncmp_32=strncmp(optarg, "00:04:20", (unsigned long int)8);
        if(return_value_strncmp_32 == 0)
        {
          const char *return_value_logtime_29;
          return_value_logtime_29=logtime();
          logprint("%s %s:%d ignoring mac address from hardware player range 00:04:20:**:**:**\n", return_value_logtime_29, (const void *)"main", 342);
        }

        else
        {
          char *t;
          t=strtok(optarg, ":");
          while(!(t == ((char *)NULL)) && !(byte >= 6))
          {
            signed int tmp_post_30 = byte;
            byte = byte + 1;
            unsigned long int return_value_strtoul_31;
            return_value_strtoul_31=strtoul(t, &tmp, 16);
            mac[(signed long int)tmp_post_30] = (unsigned char)return_value_strtoul_31;
            t=strtok((char *)(void *)0, ":");
          }
        }
        break;
      }
      case 77:
      {
        modelname = optarg;
        break;
      }
      case 114:
      {
        char *rstr;
        rstr=next_param(optarg, (char)58);
        char *dstr;
        dstr=next_param((char *)(void *)0, (char)58);
        _Bool tmp_if_expr_42;
        if(!(rstr == ((char *)NULL)))
        {
          return_value_strstr_41=strstr(rstr, ",");
          tmp_if_expr_42 = return_value_strstr_41 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_42 = (_Bool)0;
        if(tmp_if_expr_42)
        {
          char *main__1__2__4__5__1__r;
          main__1__2__4__5__1__r=next_param(rstr, (char)44);
          unsigned int main__1__2__4__5__1__tmp[16l] = { (unsigned int)0, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u };
          signed int i;
          signed int j;
          signed int last = 999999;
          i = 0;
          for( ; !(main__1__2__4__5__1__r == ((char *)NULL)) && !(i >= 16); i = i + 1)
          {
            signed int return_value_atoi_33;
            return_value_atoi_33=atoi(main__1__2__4__5__1__r);
            main__1__2__4__5__1__tmp[(signed long int)i] = (unsigned int)return_value_atoi_33;
            main__1__2__4__5__1__r=next_param((char *)(void *)0, (char)44);
          }
          i = 0;
          for( ; !(i >= 16); i = i + 1)
          {
            signed int largest = 0;
            j = 0;
            for( ; !(j >= 16); j = j + 1)
              if(!((unsigned int)largest >= main__1__2__4__5__1__tmp[(signed long int)j]))
              {
                if(!(main__1__2__4__5__1__tmp[(signed long int)j] >= (unsigned int)last))
                  largest = (signed int)main__1__2__4__5__1__tmp[(signed long int)j];

              }

            last = largest;
            rates[(signed long int)i] = (unsigned int)last;
          }
        }

        else
          if(!(rstr == ((char *)NULL)))
          {
            unsigned int ref[16l] = { (unsigned int)384000, (unsigned int)352800, (unsigned int)192000, (unsigned int)176400, (unsigned int)96000, (unsigned int)88200, (unsigned int)48000, (unsigned int)44100, (unsigned int)32000, (unsigned int)24000, (unsigned int)22500, (unsigned int)16000, (unsigned int)12000, (unsigned int)11025, (unsigned int)8000, (unsigned int)0 };
            char *str1;
            str1=next_param(rstr, (char)45);
            char *str2;
            str2=next_param((char *)(void *)0, (char)45);
            unsigned int max;
            unsigned int tmp_if_expr_37;
            if(!(str2 == ((char *)NULL)))
            {
              return_value_atoi_34=atoi(str2);
              tmp_if_expr_37 = (unsigned int)return_value_atoi_34;
            }

            else
            {
              if(!(str1 == ((char *)NULL)))
              {
                return_value_atoi_35=atoi(str1);
                tmp_if_expr_36 = (unsigned int)return_value_atoi_35;
              }

              else
                tmp_if_expr_36 = ref[(signed long int)0];
              tmp_if_expr_37 = tmp_if_expr_36;
            }
            max = tmp_if_expr_37;
            unsigned int min;
            signed int tmp_if_expr_39;
            if(!(str1 == ((char *)NULL)) && !(str2 == ((char *)NULL)))
            {
              return_value_atoi_38=atoi(str1);
              tmp_if_expr_39 = return_value_atoi_38;
            }

            else
              tmp_if_expr_39 = 0;
            min = (unsigned int)tmp_if_expr_39;
            unsigned int main__1__2__4__5__2__tmp;
            signed int main__1__2__4__5__2__i;
            signed int main__1__2__4__5__2__j;
            if(!(max >= min))
            {
              main__1__2__4__5__2__tmp = max;
              max = min;
              min = main__1__2__4__5__2__tmp;
            }

            rates[(signed long int)0] = max;
            main__1__2__4__5__2__i = 0;
            main__1__2__4__5__2__j = 1;
            for( ; !(main__1__2__4__5__2__i >= 16); main__1__2__4__5__2__i = main__1__2__4__5__2__i + 1)
              if(!(ref[(signed long int)main__1__2__4__5__2__i] >= rates[(signed long int)(main__1__2__4__5__2__j + -1)]))
              {
                if(ref[(signed long int)main__1__2__4__5__2__i] >= min)
                {
                  signed int tmp_post_40 = main__1__2__4__5__2__j;
                  main__1__2__4__5__2__j = main__1__2__4__5__2__j + 1;
                  rates[(signed long int)tmp_post_40] = ref[(signed long int)main__1__2__4__5__2__i];
                }

              }

          }

        if(!(dstr == ((char *)NULL)))
        {
          signed int return_value_atoi_43;
          return_value_atoi_43=atoi(dstr);
          rate_delay = (unsigned int)return_value_atoi_43;
        }

        break;
      }
      case 115:
      {
        server = optarg;
        break;
      }
      case 110:
      {
        name = optarg;
        break;
      }
      case 78:
      {
        namefile = optarg;
        break;
      }
      case 80:
      {
        pidfile = optarg;
        break;
      }
      case 108:
      {
        list_devices();
        exit(0);
        break;
      }
      case 117:

      case 82:
      {
        _Bool tmp_if_expr_45;
        if(!(optind >= argc))
          tmp_if_expr_45 = argv[(signed long int)optind] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_45 = (_Bool)0;
        _Bool tmp_if_expr_46;
        if(tmp_if_expr_45)
          tmp_if_expr_46 = (signed int)argv[(signed long int)optind][(signed long int)0] != 45 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_46 = (_Bool)0;
        if(tmp_if_expr_46)
        {
          signed int tmp_post_44 = optind;
          optind = optind + 1;
          resample = argv[(signed long int)tmp_post_44];
        }

        else
          resample = "";
        break;
      }
      case 68:
      {
        main__1__dop = (_Bool)1;
        if(!(optind >= argc))
        {
          if(!(argv[(signed long int)optind] == ((char *)NULL)))
          {
            if(!((signed int)*argv[(signed long int)optind] == 45))
            {
              signed int tmp_post_47 = optind;
              optind = optind + 1;
              signed int return_value_atoi_48;
              return_value_atoi_48=atoi(argv[(signed long int)tmp_post_47]);
              dop_delay = (unsigned int)return_value_atoi_48;
            }

          }

        }

        break;
      }
      case 118:
      {
        visexport = (_Bool)1;
        break;
      }
      case 105:
      {
        _Bool tmp_if_expr_50;
        if(!(optind >= argc))
          tmp_if_expr_50 = argv[(signed long int)optind] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_50 = (_Bool)0;
        _Bool tmp_if_expr_51;
        if(tmp_if_expr_50)
          tmp_if_expr_51 = (signed int)argv[(signed long int)optind][(signed long int)0] != 45 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_51 = (_Bool)0;
        if(tmp_if_expr_51)
        {
          signed int tmp_post_49 = optind;
          optind = optind + 1;
          lircrc = argv[(signed long int)tmp_post_49];
        }

        else
          lircrc = "~/.lircrc";
        break;
      }
      case 122:
      {
        daemonize = (_Bool)1;
        break;
      }
      case 116:
      {
        license();
        exit(0);
      }
      case 63:
      {
        usage(argv[(signed long int)0]);
        exit(0);
      }
      default:
        fprintf(stderr, "Arg error: %s\n", argv[(signed long int)optind]);
    }
  }
  if(!(optind >= argc))
  {
    fprintf(stderr, "\nError: command line argument error\n\n");
    usage(argv[(signed long int)0]);
    exit(1);
  }

  signal(2, sighandler);
  signal(15, sighandler);
  signal(3, sighandler);
  signal(1, sighandler);
  if(output_buf_size == 0u)
  {
    output_buf_size = (unsigned int)(44100 * 8 * 10);
    if(!(resample == ((char *)NULL)))
    {
      unsigned int main__1__4__1__scale = (unsigned int)8;
      if(!(rates[0l] == 0u))
      {
        main__1__4__1__scale = rates[(signed long int)0] / (unsigned int)44100;
        if(main__1__4__1__scale >= 9u)
          main__1__4__1__scale = (unsigned int)8;

        if(!(main__1__4__1__scale >= 1u))
          main__1__4__1__scale = (unsigned int)1;

      }

      output_buf_size = output_buf_size * main__1__4__1__scale;
    }

  }

  if(!(logfile == ((char *)NULL)))
  {
    struct _IO_FILE *return_value_freopen_54;
    return_value_freopen_54=freopen(logfile, "a", stderr);
    if(return_value_freopen_54 == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_52;
      return_value___errno_location_52=__errno_location();
      char *return_value_strerror_53;
      return_value_strerror_53=strerror(*return_value___errno_location_52);
      fprintf(stderr, "error opening logfile %s: %s\n", logfile, return_value_strerror_53);
    }

    else
      if((signed int)log_decode >= lINFO || (signed int)log_output >= lINFO || (signed int)log_slimproto >= lINFO || (signed int)log_stream >= lINFO)
        fprintf(stderr, "\n%s\n", (const void *)cmdline);

  }

  if(!(pidfile == ((char *)NULL)))
  {
    pidfp=fopen(pidfile, "w");
    if(pidfp == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_55;
      return_value___errno_location_55=__errno_location();
      char *return_value_strerror_56;
      return_value_strerror_56=strerror(*return_value___errno_location_55);
      fprintf(stderr, "Error opening pidfile %s: %s\n", pidfile, return_value_strerror_56);
      exit(1);
    }

    pidfile=realpath(pidfile, (char *)(void *)0);
  }

  if(!(daemonize == (_Bool)0))
  {
    signed int return_value_daemon_59;
    return_value_daemon_59=daemon(0, logfile != ((char *)NULL) ? 1 : 0);
    if(!(return_value_daemon_59 == 0))
    {
      signed int *return_value___errno_location_57;
      return_value___errno_location_57=__errno_location();
      char *return_value_strerror_58;
      return_value_strerror_58=strerror(*return_value___errno_location_57);
      fprintf(stderr, "error daemonizing: %s\n", return_value_strerror_58);
    }

  }

  if(!(pidfp == ((struct _IO_FILE *)NULL)))
  {
    signed int return_value_getpid_60;
    return_value_getpid_60=getpid();
    fprintf(pidfp, "%d\n", return_value_getpid_60);
    fclose(pidfp);
  }

  stream_init(log_stream, stream_buf_size);
  signed int return_value_strcmp_61;
  return_value_strcmp_61=strcmp(output_device, "-");
  if(return_value_strcmp_61 == 0)
    output_init_stdout(log_output, output_buf_size, output_params, rates, rate_delay);

  else
    output_init_pa(log_output, output_device, output_buf_size, output_params, rates, rate_delay, idle);
  dop_init(main__1__dop, dop_delay);
  if(!(visexport == (_Bool)0))
    output_vis_init(log_output, mac);

  decode_init(log_decode, include_codecs, exclude_codecs);
  if(!(resample == ((char *)NULL)))
    process_init(resample);

  if(!(lircrc == ((char *)NULL)))
    ir_init(log_ir, lircrc);

  if(!(name == ((char *)NULL)) && !(namefile == ((char *)NULL)))
  {
    fprintf(stderr, "-n and -N option should not be used at same time\n");
    exit(1);
  }

  slimproto(log_slimproto, server, mac, name, namefile, modelname);
  decode_close();
  stream_close();
  signed int return_value_strcmp_62;
  return_value_strcmp_62=strcmp(output_device, "-");
  if(return_value_strcmp_62 == 0)
    output_close_stdout();

  else
    output_close_pa();
  ir_close();
  if(!(pidfile == ((char *)NULL)))
  {
    unlink(pidfile);
    free((void *)pidfile);
  }

  exit(0);
}

// mp4_desc_length
// file faad.c line 94
unsigned int mp4_desc_length(unsigned char **buf)
{
  unsigned char b;
  unsigned char num_bytes = (unsigned char)0;
  unsigned int length = (unsigned int)0;
  do
  {
    b = *(*buf);
    *buf = *buf + (signed long int)1;
    num_bytes = num_bytes + 1;
    length = length << 7 | (unsigned int)((signed int)b & 0x7f);
  }
  while(!((0x80 & (signed int)b) == 0) && !((signed int)num_bytes >= 4));
  return length;
}

// mpg_close
// file mpg.c line 210
static void mpg_close(void)
{
  mpg123_delete(m_link1->h);
  m_link1->h = (struct mpg123_handle_struct *)(void *)0;
}

// mpg_decode
// file mpg.c line 84
static enum anonymous_23 mpg_decode(void)
{
  unsigned long int bytes;
  unsigned long int space;
  unsigned long int size;
  signed int ret;
  unsigned char *write_buf;
  pthread_mutex_lock(&streambuf->mutex);
  if(!(decode.direct == (_Bool)0))
    pthread_mutex_lock(&outputbuf->mutex);

  unsigned int return_value__buf_used_1;
  return_value__buf_used_1=_buf_used(streambuf);
  unsigned int return_value__buf_cont_read_2;
  return_value__buf_cont_read_2=_buf_cont_read(streambuf);
  unsigned int tmp_if_expr_5;
  unsigned int return_value__buf_used_3;
  unsigned int return_value__buf_cont_read_4;
  if(!(return_value__buf_used_1 >= return_value__buf_cont_read_2))
  {
    return_value__buf_used_3=_buf_used(streambuf);
    tmp_if_expr_5 = return_value__buf_used_3;
  }

  else
  {
    return_value__buf_cont_read_4=_buf_cont_read(streambuf);
    tmp_if_expr_5 = return_value__buf_cont_read_4;
  }
  bytes = (unsigned long int)tmp_if_expr_5;
  unsigned int return_value__buf_space_8;
  unsigned int return_value__buf_cont_write_9;
  if(!(decode.direct == (_Bool)0))
  {
    unsigned int return_value__buf_space_6;
    return_value__buf_space_6=_buf_space(outputbuf);
    unsigned int return_value__buf_cont_write_7;
    return_value__buf_cont_write_7=_buf_cont_write(outputbuf);
    unsigned int tmp_if_expr_10;
    if(!(return_value__buf_space_6 >= return_value__buf_cont_write_7))
    {
      return_value__buf_space_8=_buf_space(outputbuf);
      tmp_if_expr_10 = return_value__buf_space_8;
    }

    else
    {
      return_value__buf_cont_write_9=_buf_cont_write(outputbuf);
      tmp_if_expr_10 = return_value__buf_cont_write_9;
    }
    space = (unsigned long int)tmp_if_expr_10;
    write_buf = outputbuf->writep;
  }

  if(decode.direct == (_Bool)0)
  {
    space = (unsigned long int)process_link7.max_in_frames;
    write_buf = process_link7.inbuf;
  }

  bytes = bytes < (unsigned long int)512 ? bytes : (unsigned long int)512;
  space = space < (unsigned long int)(32 * 1024) ? space : (unsigned long int)(32 * 1024);
  if(!(m_link1->use16bit == (_Bool)0))
    space = (space / (unsigned long int)8) * (unsigned long int)4;

  if(!(decode.new_stream == (_Bool)0))
    space = (unsigned long int)0;

  ret=mpg123_decode(m_link1->h, streambuf->readp, bytes, write_buf, space, &size);
  const char *return_value_logtime_11;
  const char *return_value_logtime_12;
  if(ret == -11)
  {
    if(!(decode.new_stream == (_Bool)0))
    {
      signed long int rate;
      signed int mpg_decode__1__5__1__channels;
      signed int enc;
      mpg123_getformat(m_link1->h, &rate, &mpg_decode__1__5__1__channels, &enc);
      if((signed int)loglevel_link11 >= lINFO)
      {
        return_value_logtime_11=logtime();
        logprint("%s %s:%d setting track_start\n", return_value_logtime_11, (const void *)"mpg_decode", 124);
      }

      if(decode.direct == (_Bool)0)
        pthread_mutex_lock(&outputbuf->mutex);

      output.next_sample_rate=decode_newstream((unsigned int)rate, output.supported_rates);
      output.next_dop = (_Bool)0;
      output.track_start = outputbuf->writep;
      if(!(output.fade_mode == /*enum*/FADE_NONE))
        _checkfade((_Bool)1);

      decode.new_stream = (_Bool)0;
      if(decode.direct == (_Bool)0)
        pthread_mutex_unlock(&outputbuf->mutex);

    }

    else
      if((signed int)loglevel_link11 >= lWARN)
      {
        return_value_logtime_12=logtime();
        logprint("%s %s:%d format change mid stream - not supported\n", return_value_logtime_12, (const void *)"mpg_decode", 134);
      }

  }

  unsigned long int tmp_post_13;
  if(!(m_link1->use16bit == (_Bool)0))
  {
    signed short int *iptr;
    signed int *mpg_decode__1__6__optr;
    unsigned long int count = size / (unsigned long int)2;
    size = count * (unsigned long int)4;
    iptr = (signed short int *)write_buf + (signed long int)count;
    mpg_decode__1__6__optr = (signed int *)write_buf + (signed long int)count;
    do
    {
      tmp_post_13 = count;
      count = count - 1ul;
      if(tmp_post_13 == 0ul)
        break;

      mpg_decode__1__6__optr = mpg_decode__1__6__optr - 1l;
      iptr = iptr - 1l;
      *mpg_decode__1__6__optr = (signed int)*iptr << 16;
    }
    while((_Bool)1);
  }

  _buf_inc_readp(streambuf, (unsigned int)bytes);
  if(!(decode.direct == (_Bool)0))
    _buf_inc_writep(outputbuf, (unsigned int)size);

  if(decode.direct == (_Bool)0)
    process_link7.in_frames = (unsigned int)(size / (unsigned long int)8);

  if(!(decode.direct == (_Bool)0))
    pthread_mutex_unlock(&outputbuf->mutex);

  const char *return_value_logtime_14;
  if((signed int)loglevel_link11 >= lSDEBUG)
  {
    return_value_logtime_14=logtime();
    logprint("%s %s:%d write %u frames\n", return_value_logtime_14, (const void *)"mpg_decode", 162, size / (unsigned long int)8);
  }

  const char *return_value_logtime_15;
  if(ret == -12 || bytes == 0ul && size == 0ul && !((signed int)stream.state >= 2))
  {
    pthread_mutex_unlock(&streambuf->mutex);
    if((signed int)loglevel_link11 >= lINFO)
    {
      return_value_logtime_15=logtime();
      logprint("%s %s:%d stream complete\n", return_value_logtime_15, (const void *)"mpg_decode", 166);
    }

    return (enum anonymous_23)DECODE_COMPLETE;
  }

  pthread_mutex_unlock(&streambuf->mutex);
  const char *return_value_logtime_16;
  if(ret == -1)
  {
    if((signed int)loglevel_link11 >= lWARN)
    {
      return_value_logtime_16=logtime();
      logprint("%s %s:%d Error\n", return_value_logtime_16, (const void *)"mpg_decode", 173);
    }

    return (enum anonymous_23)DECODE_COMPLETE;
  }

  return (enum anonymous_23)DECODE_RUNNING;
}

// mpg_open
// file mpg.c line 181
static void mpg_open(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness)
{
  signed int err;
  const signed long int *list;
  unsigned long int count;
  unsigned long int i;
  if(!(m_link1->h == ((struct mpg123_handle_struct *)NULL)))
    mpg123_delete(m_link1->h);

  m_link1->h=mpg123_new((const char *)(void *)0, &err);
  const char *return_value_logtime_1;
  const char *return_value_mpg123_plain_strerror_2;
  if(m_link1->h == ((struct mpg123_handle_struct *)NULL))
  {
    if((signed int)loglevel_link11 >= lWARN)
    {
      return_value_logtime_1=logtime();
      return_value_mpg123_plain_strerror_2=mpg123_plain_strerror(err);
      logprint("%s %s:%d new error: %s\n", return_value_logtime_1, (const void *)"mpg_open", 193, return_value_mpg123_plain_strerror_2);
    }

  }

  mpg123_rates(&list, &count);
  mpg123_format_none(m_link1->h);
  i = (unsigned long int)0;
  for( ; !(i >= count); i = i + 1ul)
    mpg123_format(m_link1->h, list[(signed long int)i], 2, m_link1->use16bit != (_Bool)0 ? 208 : 4480);
  err=mpg123_open_feed(m_link1->h);
  const char *return_value_logtime_3;
  const char *return_value_mpg123_plain_strerror_4;
  if(!(err == 0))
  {
    if((signed int)loglevel_link11 >= lWARN)
    {
      return_value_logtime_3=logtime();
      return_value_mpg123_plain_strerror_4=mpg123_plain_strerror(err);
      logprint("%s %s:%d open feed error: %s\n", return_value_logtime_3, (const void *)"mpg_open", 206, return_value_mpg123_plain_strerror_4);
    }

  }

}

// next_param
// file squeezelite.h line 375
char * next_param(char *src, char c)
{
  char *ptr;
  char *ret;
  static char *str = (char *)(void *)0;
  if(!(src == ((char *)NULL)))
    str = src;

  _Bool tmp_if_expr_1;
  if(!(str == ((char *)NULL)))
  {
    ptr=strchr(str, (signed int)c);
    tmp_if_expr_1 = ptr != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    ret = str;
    *ptr = (char)0;
    str = ptr + (signed long int)1;
  }

  else
  {
    ret = str;
    str = (char *)(void *)0;
  }
  _Bool tmp_if_expr_2;
  if(!(ret == ((char *)NULL)))
    tmp_if_expr_2 = ret[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  return tmp_if_expr_2 ? ret : (char *)(void *)0;
}

// output_close_common
// file output.c line 414
void output_close_common(void)
{
  buf_destroy(outputbuf);
  free((void *)silencebuf);
  free((void *)silencebuf_dop);
}

// output_close_pa
// file squeezelite.h line 609
void output_close_pa(void)
{
  signed int err;
  const char *return_value_logtime_1;
  if((signed int)loglevel_link3 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d close output\n", return_value_logtime_1, (const void *)"output_close_pa", 433);
  }

  pthread_mutex_lock(&outputbuf->mutex);
  running_link2 = (_Bool)0;
  monitor_thread_running = (_Bool)0;
  const char *return_value_logtime_2;
  const char *return_value_Pa_GetErrorText_3;
  if(!(pa.stream == NULL))
  {
    err=Pa_AbortStream(pa.stream);
    if(!(err == 0))
    {
      if((signed int)loglevel_link3 >= lWARN)
      {
        return_value_logtime_2=logtime();
        return_value_Pa_GetErrorText_3=Pa_GetErrorText(err);
        logprint("%s %s:%d error closing stream: %s\n", return_value_logtime_2, (const void *)"output_close_pa", 442, return_value_Pa_GetErrorText_3);
      }

    }

  }

  err=Pa_Terminate();
  const char *return_value_logtime_4;
  const char *return_value_Pa_GetErrorText_5;
  if(!(err == 0))
  {
    if((signed int)loglevel_link3 >= lWARN)
    {
      return_value_logtime_4=logtime();
      return_value_Pa_GetErrorText_5=Pa_GetErrorText(err);
      logprint("%s %s:%d error closing port audio: %s\n", return_value_logtime_4, (const void *)"output_close_pa", 447, return_value_Pa_GetErrorText_5);
    }

  }

  pthread_mutex_unlock(&outputbuf->mutex);
  output_close_common();
}

// output_close_stdout
// file squeezelite.h line 615
void output_close_stdout(void)
{
  const char *return_value_logtime_1;
  if((signed int)loglevel_link4 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d close output\n", return_value_logtime_1, (const void *)"output_close_stdout", 168);
  }

  pthread_mutex_lock(&outputbuf->mutex);
  running_link3 = (_Bool)0;
  pthread_mutex_unlock(&outputbuf->mutex);
  free((void *)buf_link2);
  output_close_common();
}

// output_flush
// file squeezelite.h line 587
void output_flush(void)
{
  const char *return_value_logtime_1;
  if((signed int)loglevel_link2 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d flush output buffer\n", return_value_logtime_1, (const void *)"output_flush", 423);
  }

  buf_flush(outputbuf);
  pthread_mutex_lock(&outputbuf->mutex);
  output.fade = (enum anonymous_3)FADE_INACTIVE;
  if(!((signed int)output.state == OUTPUT_OFF))
  {
    output.state = (enum anonymous_1)OUTPUT_STOPPED;
    if(!(output.error_opening == (_Bool)0))
      output.current_sample_rate = output.default_sample_rate;

    output.delay_active = (_Bool)0;
  }

  output.frames_played = (unsigned int)0;
  pthread_mutex_unlock(&outputbuf->mutex);
}

// output_init_common
// file output.c line 340
void output_init_common(enum anonymous_8 level, const char *device, unsigned int output_buf_size, unsigned int *rates, unsigned int idle)
{
  unsigned int i;
  loglevel_link2 = level;
  output_buf_size = output_buf_size - output_buf_size % (unsigned int)8;
  const char *return_value_logtime_1;
  if((signed int)loglevel_link2 >= lDEBUG)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d outputbuf size: %u\n", return_value_logtime_1, (const void *)"output_init_common", 346, output_buf_size);
  }

  buf_init(outputbuf, (unsigned long int)output_buf_size);
  if(outputbuf->buf == ((unsigned char *)NULL))
  {
    const char *return_value_logtime_2;
    return_value_logtime_2=logtime();
    logprint("%s %s:%d unable to malloc output buffer\n", return_value_logtime_2, (const void *)"output_init_common", 350);
    exit(0);
  }

  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)(2048 * 8));
  silencebuf = (unsigned char *)return_value_malloc_3;
  if(silencebuf == ((unsigned char *)NULL))
  {
    const char *return_value_logtime_4;
    return_value_logtime_4=logtime();
    logprint("%s %s:%d unable to malloc silence buffer\n", return_value_logtime_4, (const void *)"output_init_common", 356);
    exit(0);
  }

  memset((void *)silencebuf, 0, (unsigned long int)(2048 * 8));
  void *return_value_malloc_5;
  return_value_malloc_5=malloc((unsigned long int)(2048 * 8));
  silencebuf_dop = (unsigned char *)return_value_malloc_5;
  if(silencebuf_dop == ((unsigned char *)NULL))
  {
    const char *return_value_logtime_6;
    return_value_logtime_6=logtime();
    logprint("%s %s:%d unable to malloc silence dop buffer\n", return_value_logtime_6, (const void *)"output_init_common", 368);
    exit(0);
  }

  dop_silence_frames((unsigned int *)silencebuf_dop, (unsigned int)2048);
  const char *return_value_logtime_7;
  if((signed int)loglevel_link2 >= lDEBUG)
  {
    return_value_logtime_7=logtime();
    logprint("%s %s:%d idle timeout: %u\n", return_value_logtime_7, (const void *)"output_init_common", 370, idle);
  }

  output.state = (enum anonymous_1)(idle != 0u ? OUTPUT_OFF : OUTPUT_STOPPED);
  output.device = device;
  output.fade = (enum anonymous_3)FADE_INACTIVE;
  output.invert = (_Bool)0;
  output.error_opening = (_Bool)0;
  output.idle_to = (unsigned int)idle;
  if(*rates == 0u)
  {
    _Bool return_value_test_open_9;
    return_value_test_open_9=test_open(output.device, output.supported_rates);
    if(return_value_test_open_9 == (_Bool)0)
    {
      const char *return_value_logtime_8;
      return_value_logtime_8=logtime();
      logprint("%s %s:%d unable to open output device\n", return_value_logtime_8, (const void *)"output_init_common", 381);
      exit(0);
    }

  }

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= 16u); i = i + 1u)
      output.supported_rates[(signed long int)i] = rates[(signed long int)i];
  }
  i = (unsigned int)0;
  for( ; !(i >= 16u); i = i + 1u)
    if(output.supported_rates[(signed long int)i] == 44100u)
    {
      output.default_sample_rate = (unsigned int)44100;
      break;
    }

  if(output.default_sample_rate == 0u)
    output.default_sample_rate = output.supported_rates[(signed long int)0];

  output.current_sample_rate = output.default_sample_rate;
  const char *return_value_logtime_10;
  if((signed int)loglevel_link2 >= lINFO)
  {
    char rates_buf[160l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    i = (unsigned int)0;
    for( ; !(output.supported_rates[(signed long int)i] == 0u); i = i + 1u)
    {
      char s[10l];
      sprintf(s, "%d ", output.supported_rates[(signed long int)i]);
      strcat(rates_buf, s);
    }
    if((signed int)loglevel_link2 >= lINFO)
    {
      return_value_logtime_10=logtime();
      logprint("%s %s:%d supported rates: %s\n", return_value_logtime_10, (const void *)"output_init_common", 410, (const void *)rates_buf);
    }

  }

}

// output_init_pa
// file squeezelite.h line 608
void output_init_pa(enum anonymous_8 level, const char *device, unsigned int output_buf_size, char *params, unsigned int *rates, unsigned int rate_delay, unsigned int idle)
{
  signed int err;
  unsigned int latency = (unsigned int)0;
  signed int osx_playnice = -1;
  char *l;
  l=next_param(params, (char)58);
  char *p;
  p=next_param((char *)(void *)0, (char)58);
  signed int return_value_atoi_1;
  if(!(l == ((char *)NULL)))
  {
    return_value_atoi_1=atoi(l);
    latency = (unsigned int)return_value_atoi_1;
  }

  if(!(p == ((char *)NULL)))
    osx_playnice=atoi(p);

  loglevel_link3 = level;
  const char *return_value_logtime_2;
  if((signed int)loglevel_link3 >= lINFO)
  {
    return_value_logtime_2=logtime();
    logprint("%s %s:%d init output\n", return_value_logtime_2, (const void *)"output_init_pa", 402);
  }

  memset((void *)&output, 0, sizeof(struct outputstate) /*240ul*/ );
  output.latency = latency;
  output.osx_playnice = osx_playnice;
  output.format = (enum anonymous_22)0;
  output.start_frames = (unsigned int)0;
  output.write_cb = _write_frames;
  output.rate_delay = rate_delay;
  pa.stream = (void *)0;
  const char *return_value_logtime_3;
  if((signed int)loglevel_link3 >= lINFO)
  {
    return_value_logtime_3=logtime();
    logprint("%s %s:%d requested latency: %u\n", return_value_logtime_3, (const void *)"output_init_pa", 414, output.latency);
  }

  err=Pa_Initialize();
  const char *return_value_logtime_4;
  const char *return_value_Pa_GetErrorText_5;
  if(!(err == 0))
  {
    if((signed int)loglevel_link3 >= lWARN)
    {
      return_value_logtime_4=logtime();
      return_value_Pa_GetErrorText_5=Pa_GetErrorText(err);
      logprint("%s %s:%d error initialising port audio: %s\n", return_value_logtime_4, (const void *)"output_init_pa", 417, return_value_Pa_GetErrorText_5);
    }

    exit(0);
  }

  output_init_common(level, device, output_buf_size, rates, idle);
  pthread_mutex_lock(&outputbuf->mutex);
  _pa_open();
  pthread_mutex_unlock(&outputbuf->mutex);
}

// output_init_stdout
// file squeezelite.h line 614
void output_init_stdout(enum anonymous_8 level, unsigned int output_buf_size, char *params, unsigned int *rates, unsigned int rate_delay)
{
  loglevel_link4 = level;
  const char *return_value_logtime_1;
  if((signed int)loglevel_link4 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d init output stdout\n", return_value_logtime_1, (const void *)"output_init_stdout", 126);
  }

  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(2048 * 8));
  buf_link2 = (unsigned char *)return_value_malloc_2;
  if(buf_link2 == ((unsigned char *)NULL))
  {
    const char *return_value_logtime_3;
    return_value_logtime_3=logtime();
    logprint("%s %s:%d unable to malloc buf\n", return_value_logtime_3, (const void *)"output_init_stdout", 130);
    goto __CPROVER_DUMP_L8;
  }

  buffill = (unsigned int)0;
  memset((void *)&output, 0, sizeof(struct outputstate) /*240ul*/ );
  output.format = (enum anonymous_22)S32_LE;
  output.start_frames = (unsigned int)(2048 * 2);
  output.write_cb = _stdout_write_frames;
  output.rate_delay = rate_delay;
  if(!(params == ((char *)NULL)))
  {
    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(params, "32");
    if(return_value_strcmp_4 == 0)
      output.format = (enum anonymous_22)S32_LE;

    signed int return_value_strcmp_5;
    return_value_strcmp_5=strcmp(params, "24");
    if(return_value_strcmp_5 == 0)
      output.format = (enum anonymous_22)S24_3LE;

    signed int return_value_strcmp_6;
    return_value_strcmp_6=strcmp(params, "16");
    if(return_value_strcmp_6 == 0)
      output.format = (enum anonymous_22)S16_LE;

  }

  if(*rates == 0u)
    rates[(signed long int)0] = (unsigned int)44100;

  output_init_common(level, "-", output_buf_size, rates, (unsigned int)0);
  union pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, (unsigned long int)(16384 + 64 * 1024));
  pthread_create(&thread_link1, &attr, (void * (*)(void *))output_thread, (void *)0);
  pthread_attr_destroy(&attr);

__CPROVER_DUMP_L8:
  ;
}

// output_thread
// file output_stdout.c line 81
static void * output_thread()
{
  pthread_mutex_lock(&outputbuf->mutex);
  switch((signed int)output.format)
  {
    case S32_LE:
    {
      bytes_per_frame = 4 * 2;
      break;
    }
    case S24_3LE:
    {
      bytes_per_frame = 3 * 2;
      break;
    }
    case S16_LE:
    {
      bytes_per_frame = 2 * 2;
      break;
    }
    default:
      bytes_per_frame = 4 * 2;
  }
  pthread_mutex_unlock(&outputbuf->mutex);
  while(!(running_link3 == (_Bool)0))
  {
    pthread_mutex_lock(&outputbuf->mutex);
    output.device_frames = (unsigned int)0;
    output.updated=gettime_ms();
    output.frames_played_dmp = output.frames_played;
    _output_frames((unsigned int)2048);
    pthread_mutex_unlock(&outputbuf->mutex);
    if(!(buffill == 0u))
    {
      fwrite((const void *)buf_link2, (unsigned long int)bytes_per_frame, (unsigned long int)buffill, stdout);
      buffill = (unsigned int)0;
    }

  }
  return NULL;
}

// output_vis_init
// file squeezelite.h line 627
void output_vis_init(enum anonymous_8 level, unsigned char *mac)
{
  loglevel_link16 = level;
  sprintf(vis_shm_path, "/squeezelite-%02x:%02x:%02x:%02x:%02x:%02x", mac[(signed long int)0], mac[(signed long int)1], mac[(signed long int)2], mac[(signed long int)3], mac[(signed long int)4], mac[(signed long int)5]);
  unsigned int old_mask;
  old_mask=umask((unsigned int)000);
  vis_fd=shm_open(vis_shm_path, 0100 | 02, (unsigned int)0666);
  if(!(vis_fd == -1))
  {
    signed int return_value_ftruncate_2;
    return_value_ftruncate_2=ftruncate(vis_fd, (signed long int)sizeof(struct vis_t) /*32848ul*/ );
    if(return_value_ftruncate_2 == 0)
    {
      void *return_value_mmap_1;
      return_value_mmap_1=mmap((void *)0, sizeof(struct vis_t) /*32848ul*/ , 0x1 | 0x2, 0x01, vis_fd, (signed long int)0);
      vis_mmap = (struct vis_t *)return_value_mmap_1;
    }

  }

  const char *return_value_logtime_3;
  const char *return_value_logtime_4;
  if(vis_mmap > ((struct vis_t *)NULL))
  {
    union anonymous_21 attr;
    pthread_rwlockattr_init(&attr);
    pthread_rwlockattr_setpshared(&attr, 1);
    pthread_rwlock_init(&vis_mmap->rwlock, &attr);
    vis_mmap->buf_size = (unsigned int)16384;
    vis_mmap->running = (_Bool)0;
    vis_mmap->rate = (unsigned int)44100;
    pthread_rwlockattr_destroy(&attr);
    if((signed int)loglevel_link16 >= lINFO)
    {
      return_value_logtime_3=logtime();
      logprint("%s %s:%d opened visulizer shared memory as %s\n", return_value_logtime_3, (const void *)"output_vis_init", 135, (const void *)vis_shm_path);
    }

  }

  else
  {
    if((signed int)loglevel_link16 >= lWARN)
    {
      return_value_logtime_4=logtime();
      logprint("%s %s:%d unable to open visualizer shared memory\n", return_value_logtime_4, (const void *)"output_vis_init", 137);
    }

    vis_mmap = (struct vis_t *)(void *)0;
  }
  umask(old_mask);
}

// pa_callback
// file output_pa.c line 342
static signed int pa_callback(const void *pa_input, void *pa_output, unsigned long int pa_frames_wanted, const struct PaStreamCallbackTimeInfo *time_info, unsigned long int statusFlags, void *userData)
{
  signed int ret;
  double stream_time;
  unsigned int frames;
  optr = (unsigned char *)pa_output;
  pthread_mutex_lock(&outputbuf->mutex);
  stream_time=Pa_GetStreamTime(pa.stream);
  if(time_info->outputBufferDacTime > stream_time)
    output.device_frames = (unsigned int)((time_info->outputBufferDacTime - stream_time) * (double)output.current_sample_rate);

  else
    output.device_frames = (unsigned int)0;
  output.updated=gettime_ms();
  output.frames_played_dmp = output.frames_played;
  do
  {
    frames=_output_frames((unsigned int)pa_frames_wanted);
    pa_frames_wanted = pa_frames_wanted - (unsigned long int)frames;
  }
  while(pa_frames_wanted >= 1ul && !(frames == 0u));
  const char *return_value_logtime_1;
  if(pa_frames_wanted >= 1ul)
  {
    if((signed int)loglevel_link3 >= lDEBUG)
    {
      return_value_logtime_1=logtime();
      logprint("%s %s:%d pad with silence\n", return_value_logtime_1, (const void *)"pa_callback", 370);
    }

    memset((void *)optr, 0, pa_frames_wanted * (unsigned long int)8);
  }

  const char *return_value_logtime_2;
  if((signed int)output.state == OUTPUT_OFF)
  {
    if((signed int)loglevel_link3 >= lINFO)
    {
      return_value_logtime_2=logtime();
      logprint("%s %s:%d output off\n", return_value_logtime_2, (const void *)"pa_callback", 375);
    }

    ret = 1;
  }

  else
    if(!(pa.rate == output.current_sample_rate))
      ret = 1;

    else
      ret = 0;
  pthread_mutex_unlock(&outputbuf->mutex);
  return ret;
}

// pa_device_id
// file output_pa.c line 83
static signed int pa_device_id(const char *device)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(device);
  len = (signed int)return_value_strlen_1;
  signed int i;
  signed int return_value_strncmp_3;
  return_value_strncmp_3=strncmp(device, "default", (unsigned long int)7);
  if(return_value_strncmp_3 == 0)
  {
    signed int return_value_Pa_GetDefaultOutputDevice_2;
    return_value_Pa_GetDefaultOutputDevice_2=Pa_GetDefaultOutputDevice();
    return return_value_Pa_GetDefaultOutputDevice_2;
  }

  if(len >= 1 && !(len >= 3))
  {
    if((signed int)*device >= 48)
    {
      if(!((signed int)*device >= 58))
      {
        signed int return_value_atoi_4;
        return_value_atoi_4=atoi(device);
        return return_value_atoi_4;
      }

    }

  }

  i = 0;
  signed int return_value_Pa_GetDeviceCount_5;
  do
  {
    return_value_Pa_GetDeviceCount_5=Pa_GetDeviceCount();
    if(i >= return_value_Pa_GetDeviceCount_5)
      break;

    char tmp[256l];
    const struct PaDeviceInfo *return_value_Pa_GetDeviceInfo_6;
    return_value_Pa_GetDeviceInfo_6=Pa_GetDeviceInfo(i);
    const struct PaDeviceInfo *return_value_Pa_GetDeviceInfo_7;
    return_value_Pa_GetDeviceInfo_7=Pa_GetDeviceInfo(i);
    const struct PaHostApiInfo *return_value_Pa_GetHostApiInfo_8;
    return_value_Pa_GetHostApiInfo_8=Pa_GetHostApiInfo(return_value_Pa_GetDeviceInfo_7->hostApi);
    snprintf(tmp, (unsigned long int)256, "%s [%s]", return_value_Pa_GetDeviceInfo_6->name, return_value_Pa_GetHostApiInfo_8->name);
    signed int return_value_strncmp_9;
    return_value_strncmp_9=strncmp(tmp, device, (unsigned long int)len);
    if(return_value_strncmp_9 == 0)
      return i;

    i = i + 1;
  }
  while((_Bool)1);
  return -1;
}

// pa_monitor
// file output_pa.c line 160
static void * pa_monitor()
{
  _Bool output_off;
  pthread_mutex_lock(&outputbuf->mutex);
  const char *return_value_logtime_1;
  if(!(monitor_thread_running == (_Bool)0))
  {
    if((signed int)loglevel_link3 >= lDEBUG)
    {
      return_value_logtime_1=logtime();
      logprint("%s %s:%d monitor thread already running\n", return_value_logtime_1, (const void *)"pa_monitor", 166);
    }

    pthread_mutex_unlock(&outputbuf->mutex);
    return NULL;
  }

  const char *return_value_logtime_2;
  if((signed int)loglevel_link3 >= lDEBUG)
  {
    return_value_logtime_2=logtime();
    logprint("%s %s:%d start monitor thread\n", return_value_logtime_2, (const void *)"pa_monitor", 171);
  }

  monitor_thread_running = (_Bool)1;
  output_off = (signed int)output.state == OUTPUT_OFF;
  const char *return_value_logtime_3;
  const char *return_value_logtime_4;
  const char *return_value_logtime_5;
  while(!(monitor_thread_running == (_Bool)0))
  {
    if(!(output_off == (_Bool)0))
    {
      if(!((signed int)output.state == OUTPUT_OFF))
      {
        if((signed int)loglevel_link3 >= lINFO)
        {
          return_value_logtime_3=logtime();
          logprint("%s %s:%d output on\n", return_value_logtime_3, (const void *)"pa_monitor", 179);
        }

        break;
      }

    }

    else
    {
      if((signed int)loglevel_link3 >= lINFO)
      {
        return_value_logtime_4=logtime();
        logprint("%s %s:%d probing device %s\n", return_value_logtime_4, (const void *)"pa_monitor", 185, output.device);
      }

      Pa_Terminate();
      Pa_Initialize();
      pa.stream = (void *)0;
      signed int return_value_pa_device_id_6;
      return_value_pa_device_id_6=pa_device_id(output.device);
      if(!(return_value_pa_device_id_6 == -1))
      {
        if((signed int)loglevel_link3 >= lINFO)
        {
          return_value_logtime_5=logtime();
          logprint("%s %s:%d device reopen\n", return_value_logtime_5, (const void *)"pa_monitor", 190);
        }

        break;
      }

    }
    pthread_mutex_unlock(&outputbuf->mutex);
    sleep((unsigned int)(output_off != (_Bool)0 ? 1 : 5));
    pthread_mutex_lock(&outputbuf->mutex);
  }
  const char *return_value_logtime_7;
  if((signed int)loglevel_link3 >= lDEBUG)
  {
    return_value_logtime_7=logtime();
    logprint("%s %s:%d end monitor thread\n", return_value_logtime_7, (const void *)"pa_monitor", 200);
  }

  monitor_thread_running = (_Bool)0;
  pa.stream = (void *)0;
  _pa_open();
  pthread_mutex_unlock(&outputbuf->mutex);
  return NULL;
}

// pa_stream_finished
// file output_pa.c line 147
static void pa_stream_finished(void *userdata)
{
  const char *return_value_logtime_1;
  if(!(running_link2 == (_Bool)0))
  {
    if((signed int)loglevel_link3 >= lINFO)
    {
      return_value_logtime_1=logtime();
      logprint("%s %s:%d stream finished\n", return_value_logtime_1, (const void *)"pa_stream_finished", 149);
    }

    pthread_mutex_lock(&outputbuf->mutex);
    output.pa_reopen = (_Bool)1;
    wake_controller();
    pthread_mutex_unlock(&outputbuf->mutex);
  }

}

// packN
// file squeezelite.h line 383
void packN(unsigned int *dest, unsigned int val)
{
  unsigned char *ptr = (unsigned char *)dest;
  *ptr = (unsigned char)(val >> 24 & (unsigned int)0xFF);
  ptr[(signed long int)1] = (unsigned char)(val >> 16 & (unsigned int)0xFF);
  ptr[(signed long int)2] = (unsigned char)(val >> 8 & (unsigned int)0xFF);
  ptr[(signed long int)3] = (unsigned char)(val & (unsigned int)0xFF);
}

// packn
// file squeezelite.h line 384
void packn(unsigned short int *dest, unsigned short int val)
{
  unsigned char *ptr = (unsigned char *)dest;
  *ptr = (unsigned char)((signed int)val >> 8 & 0xFF);
  ptr[(signed long int)1] = (unsigned char)((signed int)val & 0xFF);
}

// pcm_close
// file pcm.c line 369
static void pcm_close(void)
{
  buf_adjust(streambuf, (unsigned long int)1);
}

// pcm_decode
// file pcm.c line 161
static enum anonymous_23 pcm_decode(void)
{
  unsigned int bytes;
  unsigned int in;
  unsigned int out;
  unsigned int frames;
  unsigned int count;
  unsigned int *pcm_decode__1__optr;
  unsigned char *iptr;
  unsigned char tmp[16l];
  pthread_mutex_lock(&streambuf->mutex);
  if((signed int)stream.state == STREAMING_FILE && !(decode.new_stream == (_Bool)0))
    _check_header();

  if(!(decode.direct == (_Bool)0))
    pthread_mutex_lock(&outputbuf->mutex);

  unsigned int return_value__buf_used_1;
  return_value__buf_used_1=_buf_used(streambuf);
  unsigned int return_value__buf_cont_read_2;
  return_value__buf_cont_read_2=_buf_cont_read(streambuf);
  unsigned int tmp_if_expr_5;
  unsigned int return_value__buf_used_3;
  unsigned int return_value__buf_cont_read_4;
  if(!(return_value__buf_used_1 >= return_value__buf_cont_read_2))
  {
    return_value__buf_used_3=_buf_used(streambuf);
    tmp_if_expr_5 = return_value__buf_used_3;
  }

  else
  {
    return_value__buf_cont_read_4=_buf_cont_read(streambuf);
    tmp_if_expr_5 = return_value__buf_cont_read_4;
  }
  bytes = tmp_if_expr_5;
  unsigned int return_value__buf_space_8;
  unsigned int return_value__buf_cont_write_9;
  if(!(decode.direct == (_Bool)0))
  {
    unsigned int return_value__buf_space_6;
    return_value__buf_space_6=_buf_space(outputbuf);
    unsigned int return_value__buf_cont_write_7;
    return_value__buf_cont_write_7=_buf_cont_write(outputbuf);
    unsigned int tmp_if_expr_10;
    if(!(return_value__buf_space_6 >= return_value__buf_cont_write_7))
    {
      return_value__buf_space_8=_buf_space(outputbuf);
      tmp_if_expr_10 = return_value__buf_space_8;
    }

    else
    {
      return_value__buf_cont_write_9=_buf_cont_write(outputbuf);
      tmp_if_expr_10 = return_value__buf_cont_write_9;
    }
    out = tmp_if_expr_10 / (unsigned int)8;
  }

  if(decode.direct == (_Bool)0)
    out = process_link3.max_in_frames;

  const char *return_value_logtime_11;
  unsigned int return_value__buf_used_12;
  const char *return_value_logtime_13;
  unsigned int tmp_post_14;
  unsigned int tmp_post_17;
  unsigned int tmp_post_19;
  unsigned int tmp_post_21;
  unsigned int tmp_post_23;
  unsigned int tmp_post_25;
  unsigned int tmp_post_27;
  unsigned int tmp_post_29;
  unsigned int tmp_post_31;
  unsigned int tmp_post_32;
  unsigned int tmp_post_33;
  unsigned int tmp_post_34;
  unsigned int tmp_post_35;
  unsigned int tmp_post_37;
  const char *return_value_logtime_40;
  if(audio_left == 0u && !(limit == (_Bool)0) || bytes == 0u && !((signed int)stream.state >= 2))
  {
    if(!(decode.direct == (_Bool)0))
      pthread_mutex_unlock(&outputbuf->mutex);

    pthread_mutex_unlock(&streambuf->mutex);
    return (enum anonymous_23)DECODE_COMPLETE;
  }

  else
  {
    if(!(decode.new_stream == (_Bool)0))
    {
      if((signed int)loglevel_link7 >= lINFO)
      {
        return_value_logtime_11=logtime();
        logprint("%s %s:%d setting track_start\n", return_value_logtime_11, (const void *)"pcm_decode", 192);
      }

      if(decode.direct == (_Bool)0)
        pthread_mutex_lock(&outputbuf->mutex);

      output.next_sample_rate=decode_newstream(sample_rate, output.supported_rates);
      output.track_start = outputbuf->writep;
      output.next_dop = (_Bool)0;
      if(!(output.fade_mode == /*enum*/FADE_NONE))
        _checkfade((_Bool)1);

      decode.new_stream = (_Bool)0;
      if(decode.direct == (_Bool)0)
        pthread_mutex_unlock(&outputbuf->mutex);

      if(decode.direct == (_Bool)0)
        out = process_link3.max_in_frames;

      bytes_per_frame_link1 = channels * sample_size;
    }

    if(!(decode.direct == (_Bool)0))
      pcm_decode__1__optr = (unsigned int *)outputbuf->writep;

    if(decode.direct == (_Bool)0)
      pcm_decode__1__optr = (unsigned int *)process_link3.inbuf;

    iptr = (unsigned char *)streambuf->readp;
    in = bytes / bytes_per_frame_link1;
    if(in == 0u && bytes >= 1u)
    {
      return_value__buf_used_12=_buf_used(streambuf);
      if(return_value__buf_used_12 >= bytes_per_frame_link1)
      {
        memcpy((void *)tmp, (const void *)iptr, (unsigned long int)bytes);
        memcpy((void *)(tmp + (signed long int)bytes), (const void *)streambuf->buf, (unsigned long int)(bytes_per_frame_link1 - bytes));
        iptr = tmp;
        in = (unsigned int)1;
      }

    }

    frames = in < out ? in : out;
    frames = frames < (unsigned int)4096 ? frames : (unsigned int)4096;
    if(!(audio_left >= bytes_per_frame_link1 * frames) && !(limit == (_Bool)0))
    {
      if((signed int)loglevel_link7 >= lINFO)
      {
        return_value_logtime_13=logtime();
        logprint("%s %s:%d reached end of audio\n", return_value_logtime_13, (const void *)"pcm_decode", 229);
      }

      frames = audio_left / bytes_per_frame_link1;
    }

    count = frames * channels;
    if(channels == 2u)
    {
      if(sample_size == 1u)
        do
        {
          tmp_post_14 = count;
          count = count - 1u;
          if(tmp_post_14 == 0u)
            break;

          unsigned int *tmp_post_15 = pcm_decode__1__optr;
          pcm_decode__1__optr = pcm_decode__1__optr + 1l;
          unsigned char *tmp_post_16 = iptr;
          iptr = iptr + 1l;
          *tmp_post_15 = (unsigned int)((signed int)*tmp_post_16 << 24);
        }
        while((_Bool)1);

      else
        if(sample_size == 2u)
        {
          if(!(bigendian == (_Bool)0))
            do
            {
              tmp_post_17 = count;
              count = count - 1u;
              if(tmp_post_17 == 0u)
                break;

              unsigned int *tmp_post_18 = pcm_decode__1__optr;
              pcm_decode__1__optr = pcm_decode__1__optr + 1l;
              *tmp_post_18 = (unsigned int)((signed int)*iptr << 24 | (signed int)iptr[(signed long int)1] << 16);
              iptr = iptr + (signed long int)2;
            }
            while((_Bool)1);

          else
            do
            {
              tmp_post_19 = count;
              count = count - 1u;
              if(tmp_post_19 == 0u)
                break;

              unsigned int *tmp_post_20 = pcm_decode__1__optr;
              pcm_decode__1__optr = pcm_decode__1__optr + 1l;
              *tmp_post_20 = (unsigned int)((signed int)*iptr << 16 | (signed int)iptr[(signed long int)1] << 24);
              iptr = iptr + (signed long int)2;
            }
            while((_Bool)1);
        }

        else
          if(sample_size == 3u)
          {
            if(!(bigendian == (_Bool)0))
              do
              {
                tmp_post_21 = count;
                count = count - 1u;
                if(tmp_post_21 == 0u)
                  break;

                unsigned int *tmp_post_22 = pcm_decode__1__optr;
                pcm_decode__1__optr = pcm_decode__1__optr + 1l;
                *tmp_post_22 = (unsigned int)((signed int)*iptr << 24 | (signed int)iptr[(signed long int)1] << 16 | (signed int)iptr[(signed long int)2] << 8);
                iptr = iptr + (signed long int)3;
              }
              while((_Bool)1);

            else
              do
              {
                tmp_post_23 = count;
                count = count - 1u;
                if(tmp_post_23 == 0u)
                  break;

                unsigned int *tmp_post_24 = pcm_decode__1__optr;
                pcm_decode__1__optr = pcm_decode__1__optr + 1l;
                *tmp_post_24 = (unsigned int)((signed int)*iptr << 8 | (signed int)iptr[(signed long int)1] << 16 | (signed int)iptr[(signed long int)2] << 24);
                iptr = iptr + (signed long int)3;
              }
              while((_Bool)1);
          }

          else
            if(sample_size == 4u)
            {
              if(!(bigendian == (_Bool)0))
                do
                {
                  tmp_post_25 = count;
                  count = count - 1u;
                  if(tmp_post_25 == 0u)
                    break;

                  unsigned int *tmp_post_26 = pcm_decode__1__optr;
                  pcm_decode__1__optr = pcm_decode__1__optr + 1l;
                  *tmp_post_26 = (unsigned int)((signed int)*iptr << 24 | (signed int)iptr[(signed long int)1] << 16 | (signed int)iptr[(signed long int)2] << 8 | (signed int)iptr[(signed long int)3]);
                  iptr = iptr + (signed long int)4;
                }
                while((_Bool)1);

              else
                do
                {
                  tmp_post_27 = count;
                  count = count - 1u;
                  if(tmp_post_27 == 0u)
                    break;

                  unsigned int *tmp_post_28 = pcm_decode__1__optr;
                  pcm_decode__1__optr = pcm_decode__1__optr + 1l;
                  *tmp_post_28 = (unsigned int)((signed int)*iptr | (signed int)iptr[(signed long int)1] << 8 | (signed int)iptr[(signed long int)2] << 16 | (signed int)iptr[(signed long int)3] << 24);
                  iptr = iptr + (signed long int)4;
                }
                while((_Bool)1);
            }

    }

    else
      if(channels == 1u)
      {
        if(sample_size == 1u)
          do
          {
            tmp_post_29 = count;
            count = count - 1u;
            if(tmp_post_29 == 0u)
              break;

            unsigned char *tmp_post_30 = iptr;
            iptr = iptr + 1l;
            *pcm_decode__1__optr = (unsigned int)((signed int)*tmp_post_30 << 24);
            pcm_decode__1__optr[(signed long int)1] = *pcm_decode__1__optr;
            pcm_decode__1__optr = pcm_decode__1__optr + (signed long int)2;
          }
          while((_Bool)1);

        else
          if(sample_size == 2u)
          {
            if(!(bigendian == (_Bool)0))
              do
              {
                tmp_post_31 = count;
                count = count - 1u;
                if(tmp_post_31 == 0u)
                  break;

                *pcm_decode__1__optr = (unsigned int)((signed int)*iptr << 24 | (signed int)iptr[(signed long int)1] << 16);
                pcm_decode__1__optr[(signed long int)1] = *pcm_decode__1__optr;
                iptr = iptr + (signed long int)2;
                pcm_decode__1__optr = pcm_decode__1__optr + (signed long int)2;
              }
              while((_Bool)1);

            else
              do
              {
                tmp_post_32 = count;
                count = count - 1u;
                if(tmp_post_32 == 0u)
                  break;

                *pcm_decode__1__optr = (unsigned int)((signed int)*iptr << 16 | (signed int)iptr[(signed long int)1] << 24);
                pcm_decode__1__optr[(signed long int)1] = *pcm_decode__1__optr;
                iptr = iptr + (signed long int)2;
                pcm_decode__1__optr = pcm_decode__1__optr + (signed long int)2;
              }
              while((_Bool)1);
          }

          else
            if(sample_size == 3u)
            {
              if(!(bigendian == (_Bool)0))
                do
                {
                  tmp_post_33 = count;
                  count = count - 1u;
                  if(tmp_post_33 == 0u)
                    break;

                  *pcm_decode__1__optr = (unsigned int)((signed int)*iptr << 24 | (signed int)iptr[(signed long int)1] << 16 | (signed int)iptr[(signed long int)2] << 8);
                  pcm_decode__1__optr[(signed long int)1] = *pcm_decode__1__optr;
                  iptr = iptr + (signed long int)3;
                  pcm_decode__1__optr = pcm_decode__1__optr + (signed long int)2;
                }
                while((_Bool)1);

              else
                do
                {
                  tmp_post_34 = count;
                  count = count - 1u;
                  if(tmp_post_34 == 0u)
                    break;

                  *pcm_decode__1__optr = (unsigned int)((signed int)*iptr << 8 | (signed int)iptr[(signed long int)1] << 16 | (signed int)iptr[(signed long int)2] << 24);
                  pcm_decode__1__optr[(signed long int)1] = *pcm_decode__1__optr;
                  iptr = iptr + (signed long int)3;
                  pcm_decode__1__optr = pcm_decode__1__optr + (signed long int)2;
                }
                while((_Bool)1);
            }

            else
              if(sample_size == 4u)
              {
                if(!(bigendian == (_Bool)0))
                  do
                  {
                    tmp_post_35 = count;
                    count = count - 1u;
                    if(tmp_post_35 == 0u)
                      break;

                    unsigned int *tmp_post_36 = pcm_decode__1__optr;
                    pcm_decode__1__optr = pcm_decode__1__optr + 1l;
                    *tmp_post_36 = (unsigned int)((signed int)*iptr << 24 | (signed int)iptr[(signed long int)1] << 16 | (signed int)iptr[(signed long int)2] << 8 | (signed int)iptr[(signed long int)3]);
                    pcm_decode__1__optr[(signed long int)1] = *pcm_decode__1__optr;
                    iptr = iptr + (signed long int)4;
                    pcm_decode__1__optr = pcm_decode__1__optr + (signed long int)2;
                  }
                  while((_Bool)1);

                else
                  do
                  {
                    tmp_post_37 = count;
                    count = count - 1u;
                    if(tmp_post_37 == 0u)
                      break;

                    unsigned int *tmp_post_38 = pcm_decode__1__optr;
                    pcm_decode__1__optr = pcm_decode__1__optr + 1l;
                    *tmp_post_38 = (unsigned int)((signed int)*iptr | (signed int)iptr[(signed long int)1] << 8 | (signed int)iptr[(signed long int)2] << 16 | (signed int)iptr[(signed long int)3] << 24);
                    pcm_decode__1__optr[(signed long int)1] = *pcm_decode__1__optr;
                    iptr = iptr + (signed long int)4;
                    pcm_decode__1__optr = pcm_decode__1__optr + (signed long int)2;
                  }
                  while((_Bool)1);
              }

      }

      else
      {
        const char *return_value_logtime_39;
        return_value_logtime_39=logtime();
        logprint("%s %s:%d unsupported channels\n", return_value_logtime_39, (const void *)"pcm_decode", 334);
      }
    if((signed int)loglevel_link7 >= lSDEBUG)
    {
      return_value_logtime_40=logtime();
      logprint("%s %s:%d decoded %u frames\n", return_value_logtime_40, (const void *)"pcm_decode", 337, frames);
    }

    _buf_inc_readp(streambuf, frames * bytes_per_frame_link1);
    if(!(limit == (_Bool)0))
      audio_left = audio_left - frames * bytes_per_frame_link1;

    if(!(decode.direct == (_Bool)0))
      _buf_inc_writep(outputbuf, frames * (unsigned int)8);

    if(decode.direct == (_Bool)0)
      process_link3.in_frames = frames;

    if(!(decode.direct == (_Bool)0))
      pthread_mutex_unlock(&outputbuf->mutex);

    pthread_mutex_unlock(&streambuf->mutex);
    return (enum anonymous_23)DECODE_RUNNING;
  }
}

// pcm_open
// file pcm.c line 358
static void pcm_open(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness)
{
  sample_size = (unsigned int)(((signed int)size - 48) + 1);
  sample_rate = sample_rates[(signed long int)((signed int)rate - 48)];
  channels = (unsigned int)((signed int)chan - 48);
  bigendian = (signed int)endianness == 48;
  limit = (_Bool)0;
  const char *return_value_logtime_1;
  if((signed int)loglevel_link7 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d pcm size: %u rate: %u chan: %u bigendian: %u\n", return_value_logtime_1, (const void *)"pcm_open", 365, sample_size, sample_rate, channels, bigendian);
  }

  buf_adjust(streambuf, (unsigned long int)(sample_size * channels));
}

// process
// file slimproto.c line 489
static void process(unsigned char *pack, signed int len)
{
  struct handler *h = handlers;
  signed int return_value_strncmp_1;
  for( ; !(h->handler == ((void (*)(unsigned char *, signed int))NULL)); h = h + 1l)
  {
    return_value_strncmp_1=strncmp((char *)pack, h->opcode, (unsigned long int)4);
    if(return_value_strncmp_1 == 0)
      break;

  }
  const char *return_value_logtime_2;
  const char *return_value_logtime_3;
  if(!(h->handler == ((void (*)(unsigned char *, signed int))NULL)))
  {
    if((signed int)loglevel >= lDEBUG)
    {
      return_value_logtime_2=logtime();
      logprint("%s %s:%d %s\n", return_value_logtime_2, (const void *)"process", 494, (const void *)h->opcode);
    }

    h->handler(pack, len);
  }

  else
  {
    pack[(signed long int)4] = (unsigned char)0;
    if((signed int)loglevel >= lWARN)
    {
      return_value_logtime_3=logtime();
      logprint("%s %s:%d unhandled %s\n", return_value_logtime_3, (const void *)"process", 498, (char *)pack);
    }

  }
}

// process_aude
// file slimproto.c line 392
static void process_aude(unsigned char *pkt, signed int len)
{
  struct aude_packet *aude = (struct aude_packet *)pkt;
  const char *return_value_logtime_1;
  if((signed int)loglevel >= lDEBUG)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d enable spdif: %d dac: %d\n", return_value_logtime_1, (const void *)"process_aude", 395, aude->enable_spdif, aude->enable_dac);
  }

  pthread_mutex_lock(&outputbuf->mutex);
  if(aude->enable_spdif == 0)
  {
    if(!((signed int)output.state == OUTPUT_OFF))
      output.state = (enum anonymous_1)OUTPUT_OFF;

  }

  if(!(aude->enable_spdif == 0))
  {
    if((signed int)output.state == OUTPUT_OFF)
    {
      if(output.idle_to == 0u)
      {
        output.state = (enum anonymous_1)OUTPUT_STOPPED;
        output.stop_time=gettime_ms();
      }

    }

  }

  pthread_mutex_unlock(&outputbuf->mutex);
}

// process_audg
// file slimproto.c line 408
static void process_audg(unsigned char *pkt, signed int len)
{
  struct audg_packet *audg = (struct audg_packet *)pkt;
  audg->gainL=unpackN(&audg->gainL);
  audg->gainR=unpackN(&audg->gainR);
  const char *return_value_logtime_1;
  if((signed int)loglevel >= lDEBUG)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d audg gainL: %u gainR: %u adjust: %u\n", return_value_logtime_1, (const void *)"process_audg", 413, audg->gainL, audg->gainR, audg->adjust);
  }

  unsigned int tmp_if_expr_2;
  if(!(audg->adjust == 0))
    tmp_if_expr_2 = audg->gainL;

  else
    tmp_if_expr_2 = (unsigned int)0x10000;
  unsigned int tmp_if_expr_3;
  if(!(audg->adjust == 0))
    tmp_if_expr_3 = audg->gainR;

  else
    tmp_if_expr_3 = (unsigned int)0x10000;
  set_volume(tmp_if_expr_2, tmp_if_expr_3);
}

// process_codc
// file slimproto.c line 385
static void process_codc(unsigned char *pkt, signed int len)
{
  struct codc_packet *codc = (struct codc_packet *)pkt;
  const char *return_value_logtime_1;
  if((signed int)loglevel >= lDEBUG)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d codc: %c\n", return_value_logtime_1, (const void *)"process_codc", 388, codc->format);
  }

  codec_open(codc->format, codc->pcm_sample_size, codc->pcm_sample_rate, codc->pcm_channels, codc->pcm_endianness);
}

// process_cont
// file slimproto.c line 367
static void process_cont(unsigned char *pkt, signed int len)
{
  struct cont_packet *cont = (struct cont_packet *)pkt;
  cont->metaint=unpackN(&cont->metaint);
  const char *return_value_logtime_1;
  if((signed int)loglevel >= lDEBUG)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d cont metaint: %u loop: %u\n", return_value_logtime_1, (const void *)"process_cont", 371, cont->metaint, cont->loop);
  }

  if(autostart >= 2)
  {
    autostart = autostart - 2;
    pthread_mutex_lock(&streambuf->mutex);
    if((signed int)stream.state == STREAMING_WAIT)
    {
      stream.state = (enum anonymous_14)STREAMING_BUFFERING;
      stream.meta_next = cont->metaint;
      stream.meta_interval = stream.meta_next;
    }

    pthread_mutex_unlock(&streambuf->mutex);
    wake_controller();
  }

}

// process_drain
// file squeezelite.h line 501
void process_drain(void)
{
  _Bool done;
  do
  {
    done=resample_drain(&process_link10);
    _write_samples();
  }
  while(done == (_Bool)0);
  const char *return_value_logtime_1;
  if((signed int)loglevel_link14 >= lDEBUG)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d processing track complete - frames in: %lu out: %lu\n", return_value_logtime_1, (const void *)"process_drain", 115, process_link10.total_in, process_link10.total_out);
  }

}

// process_flush
// file squeezelite.h line 502
void process_flush(void)
{
  const char *return_value_logtime_1;
  if((signed int)loglevel_link14 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d process flush\n", return_value_logtime_1, (const void *)"process_flush", 172);
  }

  resample_flush();
  process_link10.in_frames = (unsigned int)0;
}

// process_init
// file squeezelite.h line 504
void process_init(char *opt)
{
  _Bool enabled;
  enabled=resample_init(opt);
  memset((void *)&process_link10, 0, sizeof(struct processstate) /*56ul*/ );
  if(!(enabled == (_Bool)0))
  {
    pthread_mutex_lock(&decode.mutex);
    decode.process = (_Bool)1;
    pthread_mutex_unlock(&decode.mutex);
  }

}

// process_newstream
// file squeezelite.h line 503
unsigned int process_newstream(_Bool *direct, unsigned int raw_sample_rate, unsigned int *supported_rates)
{
  _Bool active;
  active=resample_newstream(&process_link10, raw_sample_rate, supported_rates);
  const char *return_value_logtime_1;
  if((signed int)loglevel_link14 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d processing: %s\n", return_value_logtime_1, (const void *)"process_newstream", 123, active != (_Bool)0 ? "active" : "inactive");
  }

  *direct = !(active != (_Bool)0);
  const char *return_value_logtime_2;
  const char *return_value_logtime_4;
  if(!(active == (_Bool)0))
  {
    unsigned int max_in_frames;
    unsigned int max_out_frames;
    process_link10.out_frames = (unsigned int)0;
    process_link10.in_frames = process_link10.out_frames;
    process_link10.total_out = (unsigned long int)0;
    process_link10.total_in = process_link10.total_out;
    max_in_frames = codec->min_space / (unsigned int)8;
    if(process_link10.out_sample_rate % process_link10.in_sample_rate == 0u)
      max_out_frames = max_in_frames * (process_link10.out_sample_rate / process_link10.in_sample_rate);

    else
      max_out_frames = (unsigned int)(signed int)((1.1 * (double)(float)max_in_frames * (double)(float)process_link10.out_sample_rate) / (double)(float)process_link10.in_sample_rate);
    if(!(process_link10.max_in_frames == max_in_frames))
    {
      if((signed int)loglevel_link14 >= lDEBUG)
      {
        return_value_logtime_2=logtime();
        logprint("%s %s:%d creating process buf in frames: %u\n", return_value_logtime_2, (const void *)"process_newstream", 144, max_in_frames);
      }

      if(!(process_link10.inbuf == ((unsigned char *)NULL)))
        free((void *)process_link10.inbuf);

      void *return_value_malloc_3;
      return_value_malloc_3=malloc((unsigned long int)(max_in_frames * (unsigned int)8));
      process_link10.inbuf = (unsigned char *)return_value_malloc_3;
      process_link10.max_in_frames = max_in_frames;
    }

    if(!(process_link10.max_out_frames == max_out_frames))
    {
      if((signed int)loglevel_link14 >= lDEBUG)
      {
        return_value_logtime_4=logtime();
        logprint("%s %s:%d creating process buf out frames: %u\n", return_value_logtime_4, (const void *)"process_newstream", 151, max_out_frames);
      }

      if(!(process_link10.outbuf == ((unsigned char *)NULL)))
        free((void *)process_link10.outbuf);

      void *return_value_malloc_5;
      return_value_malloc_5=malloc((unsigned long int)(max_out_frames * (unsigned int)8));
      process_link10.outbuf = (unsigned char *)return_value_malloc_5;
      process_link10.max_out_frames = max_out_frames;
    }

    if(process_link10.inbuf == ((unsigned char *)NULL) || process_link10.outbuf == ((unsigned char *)NULL))
    {
      const char *return_value_logtime_6;
      return_value_logtime_6=logtime();
      logprint("%s %s:%d malloc fail creating process buffers\n", return_value_logtime_6, (const void *)"process_newstream", 158);
      *direct = (_Bool)1;
      return raw_sample_rate;
    }

    return process_link10.out_sample_rate;
  }

  return raw_sample_rate;
}

// process_samples
// file squeezelite.h line 500
void process_samples(void)
{
  resample_samples(&process_link10);
  _write_samples();
  process_link10.in_frames = (unsigned int)0;
}

// process_serv
// file slimproto.c line 451
static void process_serv(unsigned char *pkt, signed int len)
{
  struct serv_packet *serv = (struct serv_packet *)pkt;
  const char *return_value_logtime_1;
  if((signed int)loglevel >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d switch server\n", return_value_logtime_1, (const void *)"process_serv", 454);
  }

  new_server = serv->server_ip;
  if((unsigned long int)len == 18ul)
  {
    if(new_server_cap == ((char *)NULL))
    {
      void *return_value_malloc_2;
      return_value_malloc_2=malloc((unsigned long int)(13 + 10 + 1));
      new_server_cap = (char *)return_value_malloc_2;
    }

    new_server_cap[(signed long int)0] = (char)0;
    strcat(new_server_cap, ",SyncgroupID=");
    strncat(new_server_cap, (const char *)(pkt + (signed long int)sizeof(struct serv_packet) /*8ul*/ ), (unsigned long int)10);
  }

  else
    if(!(new_server_cap == ((char *)NULL)))
    {
      free((void *)new_server_cap);
      new_server_cap = (char *)(void *)0;
    }

}

// process_setd
// file slimproto.c line 418
static void process_setd(unsigned char *pkt, signed int len)
{
  struct setd_packet *setd = (struct setd_packet *)pkt;
  const char *return_value_logtime_2;
  const char *return_value_logtime_3;
  const char *return_value_logtime_4;
  if((signed int)setd->id == 0)
  {
    if(len == 5)
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(player_name);
      if(!(return_value_strlen_1 == 0ul))
        sendSETDName(player_name);

    }

    else
      if(len >= 6)
      {
        strncpy(player_name, setd->data, (unsigned long int)64);
        player_name[(signed long int)64] = (char)0;
        if((signed int)loglevel >= lINFO)
        {
          return_value_logtime_2=logtime();
          logprint("%s %s:%d set name: %s\n", return_value_logtime_2, (const void *)"process_setd", 430, (const void *)setd->data);
        }

        sendSETDName(setd->data);
        if(!(name_file == ((const char *)NULL)))
        {
          struct _IO_FILE *fp;
          fp=fopen(name_file, "w");
          if(!(fp == ((struct _IO_FILE *)NULL)))
          {
            if((signed int)loglevel >= lINFO)
            {
              return_value_logtime_3=logtime();
              logprint("%s %s:%d storing name in %s\n", return_value_logtime_3, (const void *)"process_setd", 437, name_file);
            }

            fputs(player_name, fp);
            fclose(fp);
          }

          else
            if((signed int)loglevel >= lWARN)
            {
              return_value_logtime_4=logtime();
              logprint("%s %s:%d unable to store new name in %s\n", return_value_logtime_4, (const void *)"process_setd", 441, name_file);
            }

        }

      }

  }

}

// process_strm
// file slimproto.c line 253
static void process_strm(unsigned char *pkt, signed int len)
{
  struct strm_packet *strm = (struct strm_packet *)pkt;
  const char *return_value_logtime_1;
  if((signed int)loglevel >= lDEBUG)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d strm command %c\n", return_value_logtime_1, (const void *)"process_strm", 256, strm->command);
  }

  _Bool return_value_stream_disconnect_2;
  const char *return_value_logtime_3;
  const char *return_value_logtime_4;
  const char *return_value_logtime_5;
  unsigned int return_value_gettime_ms_6;
  const char *return_value_logtime_7;
  const char *return_value_logtime_8;
  const char *return_value_logtime_9;
  const char *return_value_logtime_10;
  const char *return_value_logtime_11;
  const char *return_value_logtime_12;
  switch((signed int)strm->command)
  {
    case 116:
    {
      sendSTAT("STMt", strm->replay_gain);
      break;
    }
    case 113:
    {
      decode_flush();
      output_flush();
      status.frames_played = (unsigned int)0;
      stream_disconnect();
      sendSTAT("STMf", (unsigned int)0);
      buf_flush(streambuf);
      break;
    }
    case 102:
    {
      decode_flush();
      output_flush();
      status.frames_played = (unsigned int)0;
      return_value_stream_disconnect_2=stream_disconnect();
      if(!(return_value_stream_disconnect_2 == (_Bool)0))
        sendSTAT("STMf", (unsigned int)0);

      buf_flush(streambuf);
      break;
    }
    case 112:
    {
      unsigned int process_strm__1__1__2__interval;
      process_strm__1__1__2__interval=unpackN(&strm->replay_gain);
      pthread_mutex_lock(&outputbuf->mutex);
      output._anon0.pause_frames = (process_strm__1__1__2__interval * status.current_sample_rate) / (unsigned int)1000;
      if(!(process_strm__1__1__2__interval == 0u))
        output.state = (enum anonymous_1)OUTPUT_PAUSE_FRAMES;

      else
      {
        output.state = (enum anonymous_1)OUTPUT_STOPPED;
        output.stop_time=gettime_ms();
      }
      pthread_mutex_unlock(&outputbuf->mutex);
      if(process_strm__1__1__2__interval == 0u)
        sendSTAT("STMp", (unsigned int)0);

      if((signed int)loglevel >= lDEBUG)
      {
        return_value_logtime_3=logtime();
        logprint("%s %s:%d pause interval: %u\n", return_value_logtime_3, (const void *)"process_strm", 292, process_strm__1__1__2__interval);
      }

      break;
    }
    case 97:
    {
      unsigned int interval;
      interval=unpackN(&strm->replay_gain);
      pthread_mutex_lock(&outputbuf->mutex);
      output._anon0.skip_frames = (interval * status.current_sample_rate) / (unsigned int)1000;
      output.state = (enum anonymous_1)OUTPUT_SKIP_FRAMES;
      pthread_mutex_unlock(&outputbuf->mutex);
      if((signed int)loglevel >= lDEBUG)
      {
        return_value_logtime_4=logtime();
        logprint("%s %s:%d skip ahead interval: %u\n", return_value_logtime_4, (const void *)"process_strm", 302, interval);
      }

      break;
    }
    case 117:
    {
      unsigned int jiffies;
      jiffies=unpackN(&strm->replay_gain);
      pthread_mutex_lock(&outputbuf->mutex);
      output.state = (enum anonymous_1)(jiffies != 0u ? OUTPUT_START_AT : OUTPUT_RUNNING);
      output._anon0.start_at = jiffies;
      pthread_mutex_unlock(&outputbuf->mutex);
      if((signed int)loglevel >= lDEBUG)
      {
        return_value_logtime_5=logtime();
        return_value_gettime_ms_6=gettime_ms();
        logprint("%s %s:%d unpause at: %u now: %u\n", return_value_logtime_5, (const void *)"process_strm", 312, jiffies, return_value_gettime_ms_6);
      }

      sendSTAT("STMr", (unsigned int)0);
      break;
    }
    case 115:
    {
      unsigned int header_len = (unsigned int)((unsigned long int)len - sizeof(struct strm_packet) /*28ul*/ );
      char *header = (char *)(pkt + (signed long int)sizeof(struct strm_packet) /*28ul*/ );
      unsigned int ip = (unsigned int)strm->server_ip;
      unsigned short int port = strm->server_port;
      if(ip == 0u)
        ip = slimproto_ip;

      if((signed int)loglevel >= lDEBUG)
      {
        return_value_logtime_7=logtime();
        logprint("%s %s:%d strm s autostart: %c transition period: %u transition type: %u codec: %c\n", return_value_logtime_7, (const void *)"process_strm", 325, strm->autostart, strm->transition_period, (signed int)strm->transition_type - 48, strm->format);
      }

      autostart = (signed int)strm->autostart - 48;
      sendSTAT("STMf", (unsigned int)0);
      if(header_len >= 4096u)
      {
        if((signed int)loglevel >= lWARN)
        {
          return_value_logtime_8=logtime();
          logprint("%s %s:%d header too long: %u\n", return_value_logtime_8, (const void *)"process_strm", 330, header_len);
        }

        break;
      }

      if(!((signed int)strm->format == 63))
        codec_open(strm->format, strm->pcm_sample_size, strm->pcm_sample_rate, strm->pcm_channels, strm->pcm_endianness);

      else
        if(autostart >= 2)
        {
          if((signed int)loglevel >= lDEBUG)
          {
            return_value_logtime_9=logtime();
            logprint("%s %s:%d streaming unknown codec\n", return_value_logtime_9, (const void *)"process_strm", 337);
          }

        }

        else
        {
          if((signed int)loglevel >= lWARN)
          {
            return_value_logtime_10=logtime();
            logprint("%s %s:%d unknown codec requires autostart >= 2\n", return_value_logtime_10, (const void *)"process_strm", 339);
          }

          break;
        }
      if(ip == 16777343u && (signed int)port == 0x9b0d)
      {
        stream_file(header, (unsigned long int)header_len, (unsigned int)((signed int)strm->threshold * 1024));
        autostart = autostart - 2;
      }

      else
        stream_sock(ip, port, header, (unsigned long int)header_len, (unsigned int)((signed int)strm->threshold * 1024), autostart >= 2);
      sendSTAT("STMc", (unsigned int)0);
      sentSTMl = (_Bool)0;
      sentSTMo = sentSTMl;
      sentSTMu = sentSTMo;
      pthread_mutex_lock(&outputbuf->mutex);
      output.threshold = (unsigned int)strm->output_threshold;
      output.next_replay_gain=unpackN(&strm->replay_gain);
      output.fade_mode = (enum anonymous_5)((signed int)strm->transition_type - 48);
      output.fade_secs = (unsigned int)strm->transition_period;
      output.invert = ((signed int)strm->flags & 0x03) == 0x03;
      if((signed int)loglevel >= lDEBUG)
      {
        return_value_logtime_11=logtime();
        logprint("%s %s:%d set fade mode: %u\n", return_value_logtime_11, (const void *)"process_strm", 357, output.fade_mode);
      }

      pthread_mutex_unlock(&outputbuf->mutex);
      break;
    }
    default:
      if((signed int)loglevel >= lWARN)
      {
        return_value_logtime_12=logtime();
        logprint("%s %s:%d unhandled strm %c\n", return_value_logtime_12, (const void *)"process_strm", 362, strm->command);
      }

  }
}

// read_cb
// file flac.c line 86
static enum anonymous_64 read_cb(const struct anonymous_43 *decoder, unsigned char *buffer, unsigned long int *want, void *client_data)
{
  unsigned long int bytes;
  _Bool end;
  pthread_mutex_lock(&streambuf->mutex);
  unsigned int return_value__buf_used_1;
  return_value__buf_used_1=_buf_used(streambuf);
  unsigned int return_value__buf_cont_read_2;
  return_value__buf_cont_read_2=_buf_cont_read(streambuf);
  unsigned int tmp_if_expr_5;
  unsigned int return_value__buf_used_3;
  unsigned int return_value__buf_cont_read_4;
  if(!(return_value__buf_used_1 >= return_value__buf_cont_read_2))
  {
    return_value__buf_used_3=_buf_used(streambuf);
    tmp_if_expr_5 = return_value__buf_used_3;
  }

  else
  {
    return_value__buf_cont_read_4=_buf_cont_read(streambuf);
    tmp_if_expr_5 = return_value__buf_cont_read_4;
  }
  bytes = (unsigned long int)tmp_if_expr_5;
  unsigned long int tmp_if_expr_6;
  if(!(bytes >= *want))
    tmp_if_expr_6 = bytes;

  else
    tmp_if_expr_6 = *want;
  bytes = tmp_if_expr_6;
  end = (signed int)stream.state <= DISCONNECT && bytes == (unsigned long int)0;
  memcpy((void *)buffer, (const void *)streambuf->readp, bytes);
  _buf_inc_readp(streambuf, (unsigned int)bytes);
  pthread_mutex_unlock(&streambuf->mutex);
  *want = bytes;
  return (enum anonymous_64)(end != (_Bool)0 ? FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM : FLAC__STREAM_DECODER_READ_STATUS_CONTINUE);
}

// read_mp4_header
// file faad.c line 110
static signed int read_mp4_header(unsigned long int *samplerate_p, unsigned char *channels_p)
{
  unsigned long int bytes;
  unsigned int return_value__buf_used_1;
  return_value__buf_used_1=_buf_used(streambuf);
  unsigned int return_value__buf_cont_read_2;
  return_value__buf_cont_read_2=_buf_cont_read(streambuf);
  unsigned int tmp_if_expr_5;
  unsigned int return_value__buf_used_3;
  unsigned int return_value__buf_cont_read_4;
  if(!(return_value__buf_used_1 >= return_value__buf_cont_read_2))
  {
    return_value__buf_used_3=_buf_used(streambuf);
    tmp_if_expr_5 = return_value__buf_used_3;
  }

  else
  {
    return_value__buf_cont_read_4=_buf_cont_read(streambuf);
    tmp_if_expr_5 = return_value__buf_cont_read_4;
  }
  bytes = (unsigned long int)tmp_if_expr_5;
  char type[5l];
  unsigned int len;
  const char *return_value_logtime_9;
  const char *return_value_logtime_11;
  const char *return_value_logtime_14;
  const char *return_value_logtime_16;
  const char *return_value_logtime_19;
  unsigned int tmp_post_20;
  const char *return_value_logtime_22;
  const char *return_value_logtime_23;
  const char *return_value_logtime_24;
  signed int return_value_memcmp_27;
  const char *return_value_logtime_29;
  const char *return_value_logtime_30;
  signed int return_value_strcmp_35;
  signed int return_value_strcmp_37;
  signed int return_value_strcmp_39;
  signed int return_value_strcmp_41;
  signed int return_value_strcmp_43;
  signed int return_value_strcmp_45;
  const char *return_value_logtime_50;
  signed int return_value_strcmp_52;
  signed int return_value_strcmp_53;
  signed int return_value_strcmp_55;
  signed int return_value_strcmp_57;
  signed int return_value_strcmp_59;
  const char *return_value_logtime_51;
  while(bytes >= 8ul)
  {
    unsigned int consume;
    len=unpackN((unsigned int *)streambuf->readp);
    memcpy((void *)type, (const void *)(streambuf->readp + (signed long int)4), (unsigned long int)4);
    type[(signed long int)4] = (char)0;
    signed int return_value_strcmp_6;
    return_value_strcmp_6=strcmp(type, "moov");
    static unsigned int play;
    static unsigned int trak;
    if(return_value_strcmp_6 == 0)
    {
      trak = (unsigned int)0;
      play = (unsigned int)0;
    }

    signed int return_value_strcmp_7;
    return_value_strcmp_7=strcmp(type, "trak");
    if(return_value_strcmp_7 == 0)
      trak = trak + 1u;

    signed int return_value_strcmp_13;
    return_value_strcmp_13=strcmp(type, "esds");
    if(return_value_strcmp_13 == 0)
    {
      if(!((unsigned long int)len >= bytes))
      {
        unsigned int config_len;
        unsigned char *read_mp4_header__1__1__3__ptr = streambuf->readp + (signed long int)12;
        unsigned char *tmp_post_8 = read_mp4_header__1__1__3__ptr;
        read_mp4_header__1__1__3__ptr = read_mp4_header__1__1__3__ptr + 1l;
        if((signed int)*tmp_post_8 == 0x03)
        {
          mp4_desc_length(&read_mp4_header__1__1__3__ptr);
          read_mp4_header__1__1__3__ptr = read_mp4_header__1__1__3__ptr + (signed long int)4;
        }

        else
          read_mp4_header__1__1__3__ptr = read_mp4_header__1__1__3__ptr + (signed long int)3;
        mp4_desc_length(&read_mp4_header__1__1__3__ptr);
        read_mp4_header__1__1__3__ptr = read_mp4_header__1__1__3__ptr + (signed long int)13;
        unsigned char *tmp_post_10 = read_mp4_header__1__1__3__ptr;
        read_mp4_header__1__1__3__ptr = read_mp4_header__1__1__3__ptr + 1l;
        if(!((signed int)*tmp_post_10 == 0x05))
        {
          if((signed int)loglevel_link10 >= lWARN)
          {
            return_value_logtime_9=logtime();
            logprint("%s %s:%d error parsing esds\n", return_value_logtime_9, (const void *)"read_mp4_header", 145);
          }

          return -1;
        }

        config_len=mp4_desc_length(&read_mp4_header__1__1__3__ptr);
        char return_value_NeAACDecInit2_12;
        return_value_NeAACDecInit2_12=NeAACDecInit2(a->hAac, read_mp4_header__1__1__3__ptr, (unsigned long int)config_len, samplerate_p, channels_p);
        if((signed int)return_value_NeAACDecInit2_12 == 0)
        {
          if((signed int)loglevel_link10 >= lDEBUG)
          {
            return_value_logtime_11=logtime();
            logprint("%s %s:%d playable aac track: %u\n", return_value_logtime_11, (const void *)"read_mp4_header", 150, trak);
          }

          play = trak;
        }

      }

    }

    signed int return_value_strcmp_15;
    return_value_strcmp_15=strcmp(type, "stts");
    if(return_value_strcmp_15 == 0)
    {
      if(!((unsigned long int)len >= bytes))
      {
        unsigned int i;
        unsigned char *read_mp4_header__1__1__4__ptr = streambuf->readp + (signed long int)12;
        unsigned int entries;
        entries=unpackN((unsigned int *)read_mp4_header__1__1__4__ptr);
        read_mp4_header__1__1__4__ptr = read_mp4_header__1__1__4__ptr + (signed long int)4;
        i = (unsigned int)0;
        for( ; !(i >= entries); i = i + 1u)
        {
          unsigned int count;
          count=unpackN((unsigned int *)read_mp4_header__1__1__4__ptr);
          unsigned int read_mp4_header__1__1__4__1__1__size;
          read_mp4_header__1__1__4__1__1__size=unpackN((unsigned int *)(read_mp4_header__1__1__4__ptr + (signed long int)4));
          a->sttssamples = a->sttssamples + (unsigned long int)(count * read_mp4_header__1__1__4__1__1__size);
          read_mp4_header__1__1__4__ptr = read_mp4_header__1__1__4__ptr + (signed long int)8;
        }
        if((signed int)loglevel_link10 >= lDEBUG)
        {
          return_value_logtime_14=logtime();
          logprint("%s %s:%d total number of samples contained in stts: %lu\n", return_value_logtime_14, (const void *)"read_mp4_header", 167, a->sttssamples);
        }

      }

    }

    signed int return_value_strcmp_17;
    return_value_strcmp_17=strcmp(type, "stsc");
    if(return_value_strcmp_17 == 0)
    {
      if(!((unsigned long int)len >= bytes))
      {
        if(a->chunkinfo == ((struct chunk_table *)NULL))
        {
          a->stsc=malloc((unsigned long int)(len - (unsigned int)12));
          if(a->stsc == NULL)
          {
            if((signed int)loglevel_link10 >= lWARN)
            {
              return_value_logtime_16=logtime();
              logprint("%s %s:%d malloc fail\n", return_value_logtime_16, (const void *)"read_mp4_header", 174);
            }

            return -1;
          }

          memcpy(a->stsc, (const void *)(streambuf->readp + (signed long int)12), (unsigned long int)(len - (unsigned int)12));
        }

      }

    }

    signed int return_value_strcmp_21;
    return_value_strcmp_21=strcmp(type, "stco");
    if(return_value_strcmp_21 == 0)
    {
      if(!((unsigned long int)len >= bytes))
      {
        if(play == trak)
        {
          unsigned int read_mp4_header__1__1__6__i;
          unsigned char *read_mp4_header__1__1__6__ptr = streambuf->readp + (signed long int)12;
          unsigned int read_mp4_header__1__1__6__entries;
          read_mp4_header__1__1__6__entries=unpackN((unsigned int *)read_mp4_header__1__1__6__ptr);
          read_mp4_header__1__1__6__ptr = read_mp4_header__1__1__6__ptr + (signed long int)4;
          void *return_value_malloc_18;
          return_value_malloc_18=malloc(sizeof(struct chunk_table) /*8ul*/  * (unsigned long int)(read_mp4_header__1__1__6__entries + (unsigned int)1));
          a->chunkinfo = (struct chunk_table *)return_value_malloc_18;
          if(a->chunkinfo == ((struct chunk_table *)NULL))
          {
            if((signed int)loglevel_link10 >= lWARN)
            {
              return_value_logtime_19=logtime();
              logprint("%s %s:%d malloc fail\n", return_value_logtime_19, (const void *)"read_mp4_header", 189);
            }

            return -1;
          }

          read_mp4_header__1__1__6__i = (unsigned int)0;
          for( ; !(read_mp4_header__1__1__6__i >= read_mp4_header__1__1__6__entries); read_mp4_header__1__1__6__i = read_mp4_header__1__1__6__i + 1u)
          {
            (a->chunkinfo + (signed long int)read_mp4_header__1__1__6__i)->offset=unpackN((unsigned int *)read_mp4_header__1__1__6__ptr);
            (a->chunkinfo + (signed long int)read_mp4_header__1__1__6__i)->sample = (unsigned int)0;
            read_mp4_header__1__1__6__ptr = read_mp4_header__1__1__6__ptr + (signed long int)4;
          }
          (a->chunkinfo + (signed long int)read_mp4_header__1__1__6__i)->sample = (unsigned int)0;
          (a->chunkinfo + (signed long int)read_mp4_header__1__1__6__i)->offset = (unsigned int)0;
          if(!(a->stsc == NULL))
          {
            unsigned int stsc_entries;
            stsc_entries=unpackN((unsigned int *)a->stsc);
            unsigned int sample = (unsigned int)0;
            unsigned int last = (unsigned int)0;
            unsigned int last_samples = (unsigned int)0;
            unsigned char *read_mp4_header__1__1__6__3__ptr = (unsigned char *)a->stsc + (signed long int)4;
            do
            {
              tmp_post_20 = stsc_entries;
              stsc_entries = stsc_entries - 1u;
              if(tmp_post_20 == 0u)
                break;

              unsigned int first;
              first=unpackN((unsigned int *)read_mp4_header__1__1__6__3__ptr);
              unsigned int samples;
              samples=unpackN((unsigned int *)(read_mp4_header__1__1__6__3__ptr + (signed long int)4));
              if(!(last == 0u))
              {
                read_mp4_header__1__1__6__i = last - (unsigned int)1;
                for( ; !(read_mp4_header__1__1__6__i >= first + 4294967295u); read_mp4_header__1__1__6__i = read_mp4_header__1__1__6__i + 1u)
                {
                  (a->chunkinfo + (signed long int)read_mp4_header__1__1__6__i)->sample = sample;
                  sample = sample + last_samples;
                }
              }

              if(stsc_entries == 0u)
              {
                read_mp4_header__1__1__6__i = first - (unsigned int)1;
                for( ; !(read_mp4_header__1__1__6__i >= read_mp4_header__1__1__6__entries); read_mp4_header__1__1__6__i = read_mp4_header__1__1__6__i + 1u)
                {
                  (a->chunkinfo + (signed long int)read_mp4_header__1__1__6__i)->sample = sample;
                  sample = sample + samples;
                }
              }

              last = first;
              last_samples = samples;
              read_mp4_header__1__1__6__3__ptr = read_mp4_header__1__1__6__3__ptr + (signed long int)12;
            }
            while((_Bool)1);
            free(a->stsc);
            a->stsc = (void *)0;
          }

        }

      }

    }

    signed int return_value_strcmp_25;
    return_value_strcmp_25=strcmp(type, "mdat");
    if(return_value_strcmp_25 == 0)
    {
      _buf_inc_readp(streambuf, (unsigned int)8);
      a->pos = a->pos + (unsigned int)8;
      bytes = bytes - (unsigned long int)8;
      if(!(play == 0u))
      {
        if((signed int)loglevel_link10 >= lDEBUG)
        {
          return_value_logtime_22=logtime();
          logprint("%s %s:%d type: mdat len: %u pos: %u\n", return_value_logtime_22, (const void *)"read_mp4_header", 235, len, a->pos);
        }

        if(!(a->chunkinfo == ((struct chunk_table *)NULL)))
        {
          if(!(a->pos >= a->chunkinfo->offset))
          {
            unsigned int skip = (a->chunkinfo + (signed long int)0)->offset - a->pos;
            if((signed int)loglevel_link10 >= lDEBUG)
            {
              return_value_logtime_23=logtime();
              logprint("%s %s:%d skipping: %u\n", return_value_logtime_23, (const void *)"read_mp4_header", 238, skip);
            }

            if(bytes >= (unsigned long int)skip)
            {
              _buf_inc_readp(streambuf, skip);
              a->pos = a->pos + skip;
            }

            else
              a->consume = skip;
          }

        }

        a->nextchunk = (unsigned int)1;
        a->sample = a->nextchunk;
        return 1;
      }

      else
      {
        if((signed int)loglevel_link10 >= lDEBUG)
        {
          return_value_logtime_24=logtime();
          logprint("%s %s:%d type: mdat len: %u, no playable track found\n", return_value_logtime_24, (const void *)"read_mp4_header", 249, len);
        }

        return -1;
      }
    }

    signed int return_value_strcmp_33;
    return_value_strcmp_33=strcmp(type, "----");
    if(return_value_strcmp_33 == 0)
    {
      if(!((unsigned long int)len >= bytes))
      {
        unsigned char *ptr = streambuf->readp + (signed long int)8;
        unsigned int remain = len - (unsigned int)8;
        unsigned int size;
        signed int return_value_memcmp_26;
        return_value_memcmp_26=memcmp((const void *)(ptr + (signed long int)4), (const void *)"mean", (unsigned long int)4);
        if(return_value_memcmp_26 == 0)
        {
          size=unpackN((unsigned int *)ptr);
          if(!(size >= remain))
          {
            ptr = ptr + (signed long int)size;
            remain = remain - size;
          }

        }

        signed int return_value_memcmp_28;
        return_value_memcmp_28=memcmp((const void *)(ptr + (signed long int)4), (const void *)"name", (unsigned long int)4);
        if(return_value_memcmp_28 == 0)
        {
          size=unpackN((unsigned int *)ptr);
          if(!(size >= remain))
          {
            return_value_memcmp_27=memcmp((const void *)(ptr + (signed long int)12), (const void *)"iTunSMPB", (unsigned long int)8);
            if(return_value_memcmp_27 == 0)
            {
              ptr = ptr + (signed long int)size;
              remain = remain - size;
            }

          }

        }

        signed int return_value_memcmp_32;
        return_value_memcmp_32=memcmp((const void *)(ptr + (signed long int)4), (const void *)"data", (unsigned long int)4);
        if(return_value_memcmp_32 == 0)
        {
          if(remain >= 65u)
          {
            unsigned int b;
            unsigned int c;
            unsigned long int read_mp4_header__1__1__8__3__d;
            signed int return_value_sscanf_31;
            return_value_sscanf_31=sscanf((const char *)(ptr + (signed long int)16), "%x %x %x %lx", &b, &b, &c, &read_mp4_header__1__1__8__3__d);
            if(return_value_sscanf_31 == 4)
            {
              if((signed int)loglevel_link10 >= lDEBUG)
              {
                return_value_logtime_29=logtime();
                logprint("%s %s:%d iTunSMPB start: %u end: %u samples: %lu\n", return_value_logtime_29, (const void *)"read_mp4_header", 268, b, c, read_mp4_header__1__1__8__3__d);
              }

              if(!(a->sttssamples == 0ul))
              {
                if(!(a->sttssamples >= read_mp4_header__1__1__8__3__d + (unsigned long int)(b + c)))
                {
                  if((signed int)loglevel_link10 >= lDEBUG)
                  {
                    return_value_logtime_30=logtime();
                    logprint("%s %s:%d reducing samples as stts count is less\n", return_value_logtime_30, (const void *)"read_mp4_header", 270);
                  }

                  read_mp4_header__1__1__8__3__d = a->sttssamples - (unsigned long int)(b + c);
                }

              }

              a->skip = b;
              a->samples = read_mp4_header__1__1__8__3__d;
            }

          }

        }

      }

    }

    consume = len;
    signed int return_value_strcmp_34;
    return_value_strcmp_34=strcmp(type, "moov");
    _Bool tmp_if_expr_36;
    if(return_value_strcmp_34 == 0)
      tmp_if_expr_36 = (_Bool)1;

    else
    {
      return_value_strcmp_35=strcmp(type, "trak");
      tmp_if_expr_36 = !(return_value_strcmp_35 != 0) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_38;
    if(tmp_if_expr_36)
      tmp_if_expr_38 = (_Bool)1;

    else
    {
      return_value_strcmp_37=strcmp(type, "mdia");
      tmp_if_expr_38 = !(return_value_strcmp_37 != 0) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_40;
    if(tmp_if_expr_38)
      tmp_if_expr_40 = (_Bool)1;

    else
    {
      return_value_strcmp_39=strcmp(type, "minf");
      tmp_if_expr_40 = !(return_value_strcmp_39 != 0) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_42;
    if(tmp_if_expr_40)
      tmp_if_expr_42 = (_Bool)1;

    else
    {
      return_value_strcmp_41=strcmp(type, "stbl");
      tmp_if_expr_42 = !(return_value_strcmp_41 != 0) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_44;
    if(tmp_if_expr_42)
      tmp_if_expr_44 = (_Bool)1;

    else
    {
      return_value_strcmp_43=strcmp(type, "udta");
      tmp_if_expr_44 = !(return_value_strcmp_43 != 0) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_46;
    if(tmp_if_expr_44)
      tmp_if_expr_46 = (_Bool)1;

    else
    {
      return_value_strcmp_45=strcmp(type, "ilst");
      tmp_if_expr_46 = !(return_value_strcmp_45 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_46)
      consume = (unsigned int)8;

    signed int return_value_strcmp_47;
    return_value_strcmp_47=strcmp(type, "stsd");
    if(return_value_strcmp_47 == 0)
      consume = (unsigned int)16;

    signed int return_value_strcmp_48;
    return_value_strcmp_48=strcmp(type, "mp4a");
    if(return_value_strcmp_48 == 0)
      consume = (unsigned int)36;

    signed int return_value_strcmp_49;
    return_value_strcmp_49=strcmp(type, "meta");
    if(return_value_strcmp_49 == 0)
      consume = (unsigned int)12;

    if(bytes >= (unsigned long int)consume)
    {
      if((signed int)loglevel_link10 >= lDEBUG)
      {
        return_value_logtime_50=logtime();
        logprint("%s %s:%d type: %s len: %u consume: %u\n", return_value_logtime_50, (const void *)"read_mp4_header", 294, (const void *)type, len, consume);
      }

      _buf_inc_readp(streambuf, consume);
      a->pos = a->pos + consume;
      bytes = bytes - (unsigned long int)consume;
    }

    else
    {
      return_value_strcmp_52=strcmp(type, "esds");
      _Bool tmp_if_expr_54;
      if(return_value_strcmp_52 == 0)
        tmp_if_expr_54 = (_Bool)1;

      else
      {
        return_value_strcmp_53=strcmp(type, "stts");
        tmp_if_expr_54 = !(return_value_strcmp_53 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_56;
      if(tmp_if_expr_54)
        tmp_if_expr_56 = (_Bool)1;

      else
      {
        return_value_strcmp_55=strcmp(type, "stsc");
        tmp_if_expr_56 = !(return_value_strcmp_55 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_58;
      if(tmp_if_expr_56)
        tmp_if_expr_58 = (_Bool)1;

      else
      {
        return_value_strcmp_57=strcmp(type, "stco");
        tmp_if_expr_58 = !(return_value_strcmp_57 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_60;
      if(tmp_if_expr_58)
        tmp_if_expr_60 = (_Bool)1;

      else
      {
        return_value_strcmp_59=strcmp(type, "----");
        tmp_if_expr_60 = !(return_value_strcmp_59 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_60)
      {
        if((signed int)loglevel_link10 >= lDEBUG)
        {
          return_value_logtime_51=logtime();
          logprint("%s %s:%d type: %s len: %u consume: %u - partial consume: %u\n", return_value_logtime_51, (const void *)"read_mp4_header", 300, (const void *)type, len, consume, bytes);
        }

        _buf_inc_readp(streambuf, (unsigned int)bytes);
        a->pos = a->pos + (unsigned int)bytes;
        a->consume = (unsigned int)((unsigned long int)consume - bytes);
        break;
      }

      else
        break;
    }
  }
  return 0;
}

// register_dsd
// file squeezelite.h line 651
struct codec * register_dsd(void)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct dsd) /*64ul*/ );
  d = (struct dsd *)return_value_malloc_1;
  const char *return_value_logtime_2;
  if(d == ((struct dsd *)NULL))
    return (struct codec *)(void *)0;

  else
  {
    memset((void *)d, 0, sizeof(struct dsd) /*64ul*/ );
    dsd2pcm_precalc();
    if((signed int)loglevel_link12 >= lINFO)
    {
      return_value_logtime_2=logtime();
      logprint("%s %s:%d using dsd to decode dsf,dff\n", return_value_logtime_2, (const void *)"register_dsd", 624);
    }

    static struct codec ret = { .id=(char)100, .types="dsf,dff", .min_read_bytes=(unsigned int)(4096 * 2), .min_space=(unsigned int)(4096 * 8),
    .open=dsd_open,
    .close=dsd_close, .decode=dsd_decode };
    return &ret;
  }
}

// register_faad
// file squeezelite.h line 650
struct codec * register_faad(void)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct faad) /*80ul*/ );
  a = (struct faad *)return_value_malloc_1;
  const char *return_value_logtime_3;
  if(a == ((struct faad *)NULL))
    return (struct codec *)(void *)0;

  else
  {
    a->hAac = (void *)0;
    a->chunkinfo = (struct chunk_table *)(void *)0;
    a->stsc = (void *)0;
    _Bool return_value_load_faad_2;
    return_value_load_faad_2=load_faad();
    if(return_value_load_faad_2 == (_Bool)0)
      return (struct codec *)(void *)0;

    else
    {
      if((signed int)loglevel_link10 >= lINFO)
      {
        return_value_logtime_3=logtime();
        logprint("%s %s:%d using faad to decode aac\n", return_value_logtime_3, (const void *)"register_faad", 640);
      }

      static struct codec ret = { .id=(char)97, .types="aac", .min_read_bytes=(unsigned int)2048, .min_space=(unsigned int)20480,
    .open=faad_open, .close=faad_close,
    .decode=faad_decode };
      return &ret;
    }
  }
}

// register_ff
// file squeezelite.h line 652
struct codec * register_ff(const char *codec)
{
  if(registered == (_Bool)0)
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct ff_s) /*80ul*/ );
    ff = (struct ff_s *)return_value_malloc_1;
    if(ff == ((struct ff_s *)NULL))
      return (struct codec *)(void *)0;

    memset((void *)ff, 0, sizeof(struct ff_s) /*80ul*/ );
    _Bool return_value_load_ff_2;
    return_value_load_ff_2=load_ff();
    if(return_value_load_ff_2 == (_Bool)0)
      return (struct codec *)(void *)0;

    switch((signed int)loglevel_link13)
    {
      case lERROR:
      {
        ff_log_level = 16;
        break;
      }
      case lWARN:
      {
        ff_log_level = 24;
        break;
      }
      case lINFO:
      {
        ff_log_level = 32;
        break;
      }
      case lDEBUG:
        ff_log_level = 40;
    }
    av_log_set_callback(av_err_callback);
    av_register_all();
    registered = (_Bool)1;
  }

  signed int return_value_strcmp_4;
  return_value_strcmp_4=strcmp(codec, "wma");
  const char *return_value_logtime_3;
  if(return_value_strcmp_4 == 0)
  {
    if((signed int)loglevel_link13 >= lINFO)
    {
      return_value_logtime_3=logtime();
      logprint("%s %s:%d using ffmpeg to decode wma,wmap,wmal\n", return_value_logtime_3, (const void *)"register_ff", 715);
    }

    static struct codec register_ff__1__2__ret = { .id=(char)119, .types="wma,wmap,wmal", .min_read_bytes=(unsigned int)(4096 * 4),
    .min_space=(unsigned int)(256 * 1024),
    .open=ff_open_wma,
    .close=ff_close, .decode=ff_decode };
    return &register_ff__1__2__ret;
  }

  signed int return_value_strcmp_6;
  return_value_strcmp_6=strcmp(codec, "alc");
  const char *return_value_logtime_5;
  if(return_value_strcmp_6 == 0)
  {
    if((signed int)loglevel_link13 >= lINFO)
    {
      return_value_logtime_5=logtime();
      logprint("%s %s:%d using ffmpeg to decode alc\n", return_value_logtime_5, (const void *)"register_ff", 731);
    }

    static struct codec ret = { .id=(char)108, .types="alc", .min_read_bytes=(unsigned int)(4096 * 4), .min_space=(unsigned int)(256 * 1024),
    .open=ff_open_alac,
    .close=ff_close, .decode=ff_decode };
    return &ret;
  }

  return (struct codec *)(void *)0;
}

// register_flac
// file squeezelite.h line 645
struct codec * register_flac(void)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct flac) /*8ul*/ );
  f = (struct flac *)return_value_malloc_1;
  const char *return_value_logtime_3;
  if(f == ((struct flac *)NULL))
    return (struct codec *)(void *)0;

  else
  {
    f->decoder = (struct anonymous_43 *)(void *)0;
    _Bool return_value_load_flac_2;
    return_value_load_flac_2=load_flac();
    if(return_value_load_flac_2 == (_Bool)0)
      return (struct codec *)(void *)0;

    else
    {
      if((signed int)loglevel_link6 >= lINFO)
      {
        return_value_logtime_3=logtime();
        logprint("%s %s:%d using flac to decode flc\n", return_value_logtime_3, (const void *)"register_flac", 286);
      }

      static struct codec ret = { .id=(char)102, .types="flc", .min_read_bytes=(unsigned int)8192, .min_space=(unsigned int)102400,
    .open=flac_open, .close=flac_close,
    .decode=flac_decode };
      return &ret;
    }
  }
}

// register_mad
// file squeezelite.h line 647
struct codec * register_mad(void)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct mad) /*22784ul*/ );
  m = (struct mad *)return_value_malloc_1;
  const char *return_value_logtime_3;
  if(m == ((struct mad *)NULL))
    return (struct codec *)(void *)0;

  else
  {
    m->readbuf = (unsigned char *)(void *)0;
    m->readbuf_len = (unsigned int)0;
    _Bool return_value_load_mad_2;
    return_value_load_mad_2=load_mad();
    if(return_value_load_mad_2 == (_Bool)0)
      return (struct codec *)(void *)0;

    else
    {
      if((signed int)loglevel_link8 >= lINFO)
      {
        return_value_logtime_3=logtime();
        logprint("%s %s:%d using mad to decode mp3\n", return_value_logtime_3, (const void *)"register_mad", 412);
      }

      static struct codec ret = { .id=(char)109, .types="mp3", .min_read_bytes=(unsigned int)2048, .min_space=(unsigned int)206800,
    .open=mad_open, .close=mad_close,
    .decode=mad_decode };
      return &ret;
    }
  }
}

// register_mpg
// file squeezelite.h line 648
struct codec * register_mpg(void)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct mpg) /*16ul*/ );
  m_link1 = (struct mpg *)return_value_malloc_1;
  const char *return_value_logtime_4;
  if(m_link1 == ((struct mpg *)NULL))
    return (struct codec *)(void *)0;

  else
  {
    m_link1->h = (struct mpg123_handle_struct *)(void *)0;
    _Bool return_value_load_mpg_2;
    return_value_load_mpg_2=load_mpg();
    if(return_value_load_mpg_2 == (_Bool)0)
      return (struct codec *)(void *)0;

    else
    {
      mpg123_init();
      signed int return_value_mpg123_feature_3;
      return_value_mpg123_feature_3=mpg123_feature((const enum mpg123_feature_set)MPG123_FEATURE_OUTPUT_32BIT);
      m_link1->use16bit = (_Bool)return_value_mpg123_feature_3;
      if((signed int)loglevel_link11 >= lINFO)
      {
        return_value_logtime_4=logtime();
        logprint("%s %s:%d using mpg to decode mp3\n", return_value_logtime_4, (const void *)"register_mpg", 274);
      }

      static struct codec ret = { .id=(char)109, .types="mp3", .min_read_bytes=(unsigned int)512, .min_space=(unsigned int)(32 * 1024),
    .open=mpg_open,
    .close=mpg_close, .decode=mpg_decode };
      return &ret;
    }
  }
}

// register_pcm
// file squeezelite.h line 646
struct codec * register_pcm(void)
{
  const char *return_value_logtime_1;
  if((signed int)loglevel_link7 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d using pcm to decode aif,pcm\n", return_value_logtime_1, (const void *)"register_pcm", 384);
  }

  static struct codec ret = { .id=(char)112, .types="aif,pcm", .min_read_bytes=(unsigned int)4096, .min_space=(unsigned int)102400,
    .open=pcm_open, .close=pcm_close,
    .decode=pcm_decode };
  return &ret;
}

// register_vorbis
// file squeezelite.h line 649
struct codec * register_vorbis(void)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct vorbis) /*16ul*/ );
  v = (struct vorbis *)return_value_malloc_1;
  const char *return_value_logtime_3;
  if(v == ((struct vorbis *)NULL))
    return (struct codec *)(void *)0;

  else
  {
    v->vf = (struct OggVorbis_File *)(void *)0;
    v->opened = (_Bool)0;
    _Bool return_value_load_vorbis_2;
    return_value_load_vorbis_2=load_vorbis();
    if(return_value_load_vorbis_2 == (_Bool)0)
      return (struct codec *)(void *)0;

    else
    {
      if((signed int)loglevel_link9 >= lINFO)
      {
        return_value_logtime_3=logtime();
        logprint("%s %s:%d using vorbis to decode ogg\n", return_value_logtime_3, (const void *)"register_vorbis", 329);
      }

      static struct codec ret = { .id=(char)111, .types="ogg", .min_read_bytes=(unsigned int)2048, .min_space=(unsigned int)20480,
    .open=vorbis_open, .close=vorbis_close,
    .decode=vorbis_decode };
      return &ret;
    }
  }
}

// resample_drain
// file squeezelite.h line 510
_Bool resample_drain(struct processstate *process)
{
  unsigned long int odone;
  unsigned long int clip_cnt;
  const char *error;
  error=soxr_process(r->resampler, (void *)0, (unsigned long int)0, (unsigned long int *)(void *)0, (void *)process->outbuf, (unsigned long int)process->max_out_frames, &odone);
  const char *return_value_logtime_1;
  if(!(error == ((const char *)NULL)))
  {
    if((signed int)loglevel_link15 >= lINFO)
    {
      return_value_logtime_1=logtime();
      logprint("%s %s:%d soxr_process error: %s\n", return_value_logtime_1, (const void *)"resample_drain", 103, error != ((const char *)NULL) ? error : "no error");
    }

    return (_Bool)1;
  }

  process->out_frames = (unsigned int)odone;
  process->total_out = process->total_out + odone;
  unsigned long int *return_value_soxr_num_clips_2;
  return_value_soxr_num_clips_2=soxr_num_clips(r->resampler);
  clip_cnt = *return_value_soxr_num_clips_2;
  const char *return_value_logtime_3;
  if(!(clip_cnt == r->old_clips))
  {
    if((signed int)loglevel_link15 >= lDEBUG)
    {
      return_value_logtime_3=logtime();
      logprint("%s %s:%d resampling clips: %u\n", return_value_logtime_3, (const void *)"resample_drain", 112, (unsigned int)(clip_cnt - r->old_clips));
    }

    r->old_clips = clip_cnt;
  }

  const char *return_value_logtime_4;
  if(odone == 0ul)
  {
    if((signed int)loglevel_link15 >= lINFO)
    {
      return_value_logtime_4=logtime();
      logprint("%s %s:%d resample track complete - total track clips: %u\n", return_value_logtime_4, (const void *)"resample_drain", 118, r->old_clips);
    }

    soxr_delete(r->resampler);
    r->resampler = (struct soxr *)(void *)0;
    return (_Bool)1;
  }

  else
    return (_Bool)0;
}

// resample_flush
// file squeezelite.h line 512
void resample_flush(void)
{
  if(!(r->resampler == ((struct soxr *)NULL)))
  {
    soxr_delete(r->resampler);
    r->resampler = (struct soxr *)(void *)0;
  }

}

// resample_init
// file squeezelite.h line 513
_Bool resample_init(char *opt)
{
  char *recipe = (char *)(void *)0;
  char *flags = (char *)(void *)0;
  char *atten = (char *)(void *)0;
  char *precision = (char *)(void *)0;
  char *passband_end = (char *)(void *)0;
  char *stopband_begin = (char *)(void *)0;
  char *phase_response = (char *)(void *)0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct soxr) /*80ul*/ );
  r = (struct soxr *)return_value_malloc_1;
  const char *return_value_logtime_2;
  if(r == ((struct soxr *)NULL))
  {
    if((signed int)loglevel_link15 >= lWARN)
    {
      return_value_logtime_2=logtime();
      logprint("%s %s:%d resampling disabled\n", return_value_logtime_2, (const void *)"resample_init", 281);
    }

    return (_Bool)0;
  }

  r->resampler = (struct soxr *)(void *)0;
  r->old_clips = (unsigned long int)0;
  r->max_rate = (_Bool)0;
  r->exception = (_Bool)0;
  _Bool return_value_load_soxr_4;
  return_value_load_soxr_4=load_soxr();
  const char *return_value_logtime_3;
  if(return_value_load_soxr_4 == (_Bool)0)
  {
    if((signed int)loglevel_link15 >= lWARN)
    {
      return_value_logtime_3=logtime();
      logprint("%s %s:%d resampling disabled\n", return_value_logtime_3, (const void *)"resample_init", 291);
    }

    return (_Bool)0;
  }

  if(!(opt == ((char *)NULL)))
  {
    recipe=next_param(opt, (char)58);
    flags=next_param((char *)(void *)0, (char)58);
    atten=next_param((char *)(void *)0, (char)58);
    precision=next_param((char *)(void *)0, (char)58);
    passband_end=next_param((char *)(void *)0, (char)58);
    stopband_begin=next_param((char *)(void *)0, (char)58);
    phase_response=next_param((char *)(void *)0, (char)58);
  }

  r->q_recipe = (unsigned long int)4;
  r->q_flags = (unsigned long int)0;
  r->scale=pow((double)10, -1.0 / (double)20);
  r->q_precision = (double)0;
  r->q_passband_end = (double)0;
  r->q_stopband_begin = (double)0;
  r->q_phase_response = (double)-1;
  if(!(recipe == ((char *)NULL)))
  {
    if(!((signed int)*recipe == 0))
    {
      char *return_value_strchr_5;
      return_value_strchr_5=strchr(recipe, 118);
      if(!(return_value_strchr_5 == ((char *)NULL)))
        r->q_recipe = (unsigned long int)6;

      char *return_value_strchr_6;
      return_value_strchr_6=strchr(recipe, 104);
      if(!(return_value_strchr_6 == ((char *)NULL)))
        r->q_recipe = (unsigned long int)4;

      char *return_value_strchr_7;
      return_value_strchr_7=strchr(recipe, 109);
      if(!(return_value_strchr_7 == ((char *)NULL)))
        r->q_recipe = (unsigned long int)2;

      char *return_value_strchr_8;
      return_value_strchr_8=strchr(recipe, 108);
      if(!(return_value_strchr_8 == ((char *)NULL)))
        r->q_recipe = (unsigned long int)1;

      char *return_value_strchr_9;
      return_value_strchr_9=strchr(recipe, 113);
      if(!(return_value_strchr_9 == ((char *)NULL)))
        r->q_recipe = (unsigned long int)0;

      char *return_value_strchr_10;
      return_value_strchr_10=strchr(recipe, 76);
      if(!(return_value_strchr_10 == ((char *)NULL)))
        r->q_recipe = r->q_recipe | (unsigned long int)0x00;

      char *return_value_strchr_11;
      return_value_strchr_11=strchr(recipe, 73);
      if(!(return_value_strchr_11 == ((char *)NULL)))
        r->q_recipe = r->q_recipe | (unsigned long int)0x10;

      char *return_value_strchr_12;
      return_value_strchr_12=strchr(recipe, 77);
      if(!(return_value_strchr_12 == ((char *)NULL)))
        r->q_recipe = r->q_recipe | (unsigned long int)0x30;

      char *return_value_strchr_13;
      return_value_strchr_13=strchr(recipe, 115);
      if(!(return_value_strchr_13 == ((char *)NULL)))
        r->q_recipe = r->q_recipe | (unsigned long int)0x40;

      char *return_value_strchr_14;
      return_value_strchr_14=strchr(recipe, 88);
      if(!(return_value_strchr_14 == ((char *)NULL)))
        r->max_rate = (_Bool)1;

      char *return_value_strchr_15;
      return_value_strchr_15=strchr(recipe, 69);
      if(!(return_value_strchr_15 == ((char *)NULL)))
        r->exception = (_Bool)1;

    }

  }

  if(!(flags == ((char *)NULL)))
    r->q_flags=strtoul(flags, ((char ** restrict )NULL), 16);

  if(!(atten == ((char *)NULL)))
  {
    double resample_init__1__6__scale;
    double return_value_atof_16;
    return_value_atof_16=atof(atten);
    resample_init__1__6__scale=pow((double)10, -return_value_atof_16 / (double)20);
    if(resample_init__1__6__scale <= 1.0 && resample_init__1__6__scale > 0.000000)
      r->scale = resample_init__1__6__scale;

  }

  if(!(precision == ((char *)NULL)))
    r->q_precision=atof(precision);

  if(!(passband_end == ((char *)NULL)))
  {
    double return_value_atof_17;
    return_value_atof_17=atof(passband_end);
    r->q_passband_end = return_value_atof_17 / (double)100;
  }

  if(!(stopband_begin == ((char *)NULL)))
  {
    double return_value_atof_18;
    return_value_atof_18=atof(stopband_begin);
    r->q_stopband_begin = return_value_atof_18 / (double)100;
  }

  if(!(phase_response == ((char *)NULL)))
    r->q_phase_response=atof(phase_response);

  const char *return_value_logtime_19;
  if((signed int)loglevel_link15 >= lINFO)
  {
    return_value_logtime_19=logtime();
    logprint("%s %s:%d resampling %s recipe: 0x%02x, flags: 0x%02x, scale: %03.2f, precision: %03.1f, passband_end: %03.5f, stopband_begin: %03.5f, phase_response: %03.1f\n", return_value_logtime_19, (const void *)"resample_init", 361, r->max_rate != (_Bool)0 ? "async" : "sync", r->q_recipe, r->q_flags, r->scale, r->q_precision, r->q_passband_end, r->q_stopband_begin, r->q_phase_response);
  }

  return (_Bool)1;
}

// resample_newstream
// file squeezelite.h line 511
_Bool resample_newstream(struct processstate *process, unsigned int raw_sample_rate, unsigned int *supported_rates)
{
  unsigned int outrate = (unsigned int)0;
  signed int i;
  if(!(r->exception == (_Bool)0))
  {
    i = 0;
    for( ; !(supported_rates[(signed long int)i] == 0u); i = i + 1)
      if(raw_sample_rate == supported_rates[(signed long int)i])
      {
        outrate = raw_sample_rate;
        break;
      }

    for( ; outrate == 0u && i >= 0; i = i - 1)
      if(!(raw_sample_rate >= supported_rates[(signed long int)i]))
      {
        if(supported_rates[(signed long int)i] % raw_sample_rate == 0u)
        {
          outrate = supported_rates[(signed long int)i];
          break;
        }

      }

  }

  if(outrate == 0u)
  {
    if(!(r->max_rate == (_Bool)0))
      outrate = supported_rates[(signed long int)0];

    else
    {
      i = 0;
      for( ; !(supported_rates[(signed long int)i] == 0u); i = i + 1)
      {
        _Bool tmp_if_expr_1;
        if(supported_rates[(signed long int)i] % raw_sample_rate == 0u)
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = raw_sample_rate % supported_rates[(signed long int)i] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          outrate = supported_rates[(signed long int)i];
          break;
        }

      }
    }
    if(outrate == 0u)
      outrate = supported_rates[(signed long int)0];

  }

  process->in_sample_rate = raw_sample_rate;
  process->out_sample_rate = outrate;
  if(!(r->resampler == ((struct soxr *)NULL)))
  {
    soxr_delete(r->resampler);
    r->resampler = (struct soxr *)(void *)0;
  }

  const char *return_value_logtime_2;
  const char *return_value_logtime_3;
  const char *return_value_logtime_4;
  const char *return_value_logtime_5;
  if(!(raw_sample_rate == outrate))
  {
    struct soxr_io_spec io_spec;
    struct soxr_quality_spec q_spec;
    const char *error;
    if((signed int)loglevel_link15 >= lINFO)
    {
      return_value_logtime_2=logtime();
      logprint("%s %s:%d resampling from %u -> %u\n", return_value_logtime_2, (const void *)"resample_newstream", 188, raw_sample_rate, outrate);
    }

    io_spec=soxr_io_spec((enum anonymous_10)SOXR_INT32_I, (enum anonymous_10)SOXR_INT32_I);
    io_spec.scale = r->scale;
    q_spec=soxr_quality_spec(r->q_recipe, r->q_flags);
    if(r->q_precision > 0.000000)
      q_spec.precision = r->q_precision;

    if(r->q_passband_end > 0.000000)
      q_spec.passband_end = r->q_passband_end;

    if(r->q_stopband_begin > 0.000000)
      q_spec.stopband_begin = r->q_stopband_begin;

    if(r->q_phase_response > -1.000000)
      q_spec.phase_response = r->q_phase_response;

    if((signed int)loglevel_link15 >= lDEBUG)
    {
      return_value_logtime_3=logtime();
      logprint("%s %s:%d resampling with soxr_quality_spec_t[precision: %03.1f, passband_end: %03.6f, stopband_begin: %03.6f, phase_response: %03.1f, flags: 0x%02x], soxr_io_spec_t[scale: %03.2f]\n", return_value_logtime_3, (const void *)"resample_newstream", 213, q_spec.precision, q_spec.passband_end, q_spec.stopband_begin, q_spec.phase_response, q_spec.flags, io_spec.scale);
    }

    r->resampler=soxr_create((double)raw_sample_rate, (double)outrate, (unsigned int)2, &error, &io_spec, &q_spec, (const struct soxr_runtime_spec *)(void *)0);
    if(!(error == ((const char *)NULL)))
    {
      if((signed int)loglevel_link15 >= lINFO)
      {
        return_value_logtime_4=logtime();
        logprint("%s %s:%d soxr_create error: %s\n", return_value_logtime_4, (const void *)"resample_newstream", 222, error != ((const char *)NULL) ? error : "no error");
      }

      return (_Bool)0;
    }

    r->old_clips = (unsigned long int)0;
    return (_Bool)1;
  }

  else
  {
    if((signed int)loglevel_link15 >= lINFO)
    {
      return_value_logtime_5=logtime();
      logprint("%s %s:%d disable resampling - rates match\n", return_value_logtime_5, (const void *)"resample_newstream", 231);
    }

    return (_Bool)0;
  }
}

// resample_samples
// file squeezelite.h line 509
void resample_samples(struct processstate *process)
{
  unsigned long int idone;
  unsigned long int odone;
  unsigned long int clip_cnt;
  const char *error;
  error=soxr_process(r->resampler, (const void *)process->inbuf, (unsigned long int)process->in_frames, &idone, (void *)process->outbuf, (unsigned long int)process->max_out_frames, &odone);
  const char *return_value_logtime_1;
  if(!(error == ((const char *)NULL)))
  {
    if((signed int)loglevel_link15 >= lINFO)
    {
      return_value_logtime_1=logtime();
      logprint("%s %s:%d soxr_process error: %s\n", return_value_logtime_1, (const void *)"resample_samples", 76, error != ((const char *)NULL) ? error : "no error");
    }

    goto __CPROVER_DUMP_L6;
  }

  if(!(idone == (unsigned long int)process->in_frames))
  {
    const char *return_value_logtime_2;
    return_value_logtime_2=logtime();
    logprint("%s %s:%d should not get here - partial sox process: %u of %u processed %u of %u out\n", return_value_logtime_2, (const void *)"resample_samples", 83, (unsigned int)idone, process->in_frames, (unsigned int)odone, process->max_out_frames);
  }

  process->out_frames = (unsigned int)odone;
  process->total_in = process->total_in + idone;
  process->total_out = process->total_out + odone;
  unsigned long int *return_value_soxr_num_clips_3;
  return_value_soxr_num_clips_3=soxr_num_clips(r->resampler);
  clip_cnt = *return_value_soxr_num_clips_3;
  const char *return_value_logtime_4;
  if(!(clip_cnt == r->old_clips))
  {
    if((signed int)loglevel_link15 >= lSDEBUG)
    {
      return_value_logtime_4=logtime();
      logprint("%s %s:%d resampling clips: %u\n", return_value_logtime_4, (const void *)"resample_samples", 92, (unsigned int)(clip_cnt - r->old_clips));
    }

    r->old_clips = clip_cnt;
  }


__CPROVER_DUMP_L6:
  ;
}

// scale
// file mad.c line 90
static inline unsigned int scale(signed int sample)
{
  sample = sample + (signed int)(1L << 28 - 24);
  if(sample >= 268435456)
    sample = (signed int)0x10000000L - 1;

  else
    if(!(sample >= -268435456))
      sample = -((signed int)0x10000000L);

  return (unsigned int)((signed int)(sample >> (28 + 1) - 24) << 8);
}

// sendDSCO
// file slimproto.c line 182
static void sendDSCO(enum anonymous_0 disconnect)
{
  struct DSCO_packet pkt;
  memset((void *)&pkt, 0, sizeof(struct DSCO_packet) /*9ul*/ );
  memcpy((void *)&pkt.opcode, (const void *)"DSCO", (unsigned long int)4);
  pkt.length=htonl((unsigned int)(sizeof(struct DSCO_packet) /*9ul*/  - (unsigned long int)8));
  pkt.reason = (unsigned char)((signed int)disconnect & 0xFF);
  const char *return_value_logtime_1;
  if((signed int)loglevel >= lDEBUG)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d DSCO: %d\n", return_value_logtime_1, (const void *)"sendDSCO", 190, disconnect);
  }

  send_packet((unsigned char *)&pkt, sizeof(struct DSCO_packet) /*9ul*/ );
}

// sendHELO
// file slimproto.c line 110
static void sendHELO(_Bool reconnect, const char *fixed_cap, const char *var_cap, unsigned char *mac)
{
  const char *base_cap = "Model=squeezelite,AccuratePlayPoints=1,HasDigitalOut=1,HasPolarityInversion=1,Firmware=v1.8";
  struct HELO_packet pkt;
  memset((void *)&pkt, 0, sizeof(struct HELO_packet) /*44ul*/ );
  memcpy((void *)&pkt.opcode, (const void *)"HELO", (unsigned long int)4);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(base_cap);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(fixed_cap);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(var_cap);
  pkt.length=htonl((unsigned int)((sizeof(struct HELO_packet) /*44ul*/  - (unsigned long int)8) + return_value_strlen_1 + return_value_strlen_2 + return_value_strlen_3));
  pkt.deviceid = (unsigned char)12;
  pkt.revision = (unsigned char)0;
  packn(&pkt.wlan_channellist, (unsigned short int)(reconnect != (_Bool)0 ? 0x4000 : 0x0000));
  packN(&pkt.bytes_received_H, (unsigned int)((unsigned long int)status.stream_bytes >> 32));
  packN(&pkt.bytes_received_L, (unsigned int)((unsigned long int)status.stream_bytes & (unsigned long int)0xffffffff));
  memcpy((void *)pkt.mac, (const void *)mac, (unsigned long int)6);
  const char *return_value_logtime_4;
  if((signed int)loglevel >= lINFO)
  {
    return_value_logtime_4=logtime();
    logprint("%s %s:%d mac: %02x:%02x:%02x:%02x:%02x:%02x\n", return_value_logtime_4, (const void *)"sendHELO", 124, pkt.mac[(signed long int)0], pkt.mac[(signed long int)1], pkt.mac[(signed long int)2], pkt.mac[(signed long int)3], pkt.mac[(signed long int)4], pkt.mac[(signed long int)5]);
  }

  const char *return_value_logtime_5;
  if((signed int)loglevel >= lINFO)
  {
    return_value_logtime_5=logtime();
    logprint("%s %s:%d cap: %s%s%s\n", return_value_logtime_5, (const void *)"sendHELO", 126, base_cap, fixed_cap, var_cap);
  }

  send_packet((unsigned char *)&pkt, sizeof(struct HELO_packet) /*44ul*/ );
  unsigned long int return_value_strlen_6;
  return_value_strlen_6=strlen(base_cap);
  send_packet((unsigned char *)base_cap, return_value_strlen_6);
  unsigned long int return_value_strlen_7;
  return_value_strlen_7=strlen(fixed_cap);
  send_packet((unsigned char *)fixed_cap, return_value_strlen_7);
  unsigned long int return_value_strlen_8;
  return_value_strlen_8=strlen(var_cap);
  send_packet((unsigned char *)var_cap, return_value_strlen_8);
}

// sendIR
// file slimproto.c line 237
void sendIR(unsigned int code, unsigned int ts)
{
  struct IR_packet pkt;
  memset((void *)&pkt, 0, sizeof(struct IR_packet) /*18ul*/ );
  memcpy((void *)&pkt.opcode, (const void *)"IR  ", (unsigned long int)4);
  pkt.length=htonl((unsigned int)(sizeof(struct IR_packet) /*18ul*/  - (unsigned long int)8));
  packN(&pkt.jiffies, ts);
  pkt.ir_code=htonl(code);
  const char *return_value_logtime_1;
  if((signed int)loglevel >= lDEBUG)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d IR: ir code: 0x%x ts: %u\n", return_value_logtime_1, (const void *)"sendIR", 247, code, ts);
  }

  send_packet((unsigned char *)&pkt, sizeof(struct IR_packet) /*18ul*/ );
}

// sendMETA
// file slimproto.c line 208
static void sendMETA(const char *meta, unsigned long int len)
{
  struct META_header pkt_header;
  memset((void *)&pkt_header, 0, sizeof(struct META_header) /*8ul*/ );
  memcpy((void *)&pkt_header.opcode, (const void *)"META", (unsigned long int)4);
  pkt_header.length=htonl((unsigned int)((sizeof(struct META_header) /*8ul*/  + len) - (unsigned long int)8));
  const char *return_value_logtime_1;
  if((signed int)loglevel >= lDEBUG)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d META\n", return_value_logtime_1, (const void *)"sendMETA", 215);
  }

  send_packet((unsigned char *)&pkt_header, sizeof(struct META_header) /*8ul*/ );
  send_packet((unsigned char *)meta, len);
}

// sendRESP
// file slimproto.c line 195
static void sendRESP(const char *header, unsigned long int len)
{
  struct RESP_header pkt_header;
  memset((void *)&pkt_header, 0, sizeof(struct RESP_header) /*8ul*/ );
  memcpy((void *)&pkt_header.opcode, (const void *)"RESP", (unsigned long int)4);
  pkt_header.length=htonl((unsigned int)((sizeof(struct RESP_header) /*8ul*/  + len) - (unsigned long int)8));
  const char *return_value_logtime_1;
  if((signed int)loglevel >= lDEBUG)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d RESP\n", return_value_logtime_1, (const void *)"sendRESP", 202);
  }

  send_packet((unsigned char *)&pkt_header, sizeof(struct RESP_header) /*8ul*/ );
  send_packet((unsigned char *)header, len);
}

// sendSETDName
// file slimproto.c line 221
static void sendSETDName(const char *name)
{
  struct SETD_header pkt_header;
  memset((void *)&pkt_header, 0, sizeof(struct SETD_header) /*9ul*/ );
  memcpy((void *)&pkt_header.opcode, (const void *)"SETD", (unsigned long int)4);
  pkt_header.id = (unsigned char)0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  pkt_header.length=htonl((unsigned int)((sizeof(struct SETD_header) /*9ul*/  + return_value_strlen_1 + (unsigned long int)1) - (unsigned long int)8));
  const char *return_value_logtime_2;
  if((signed int)loglevel >= lDEBUG)
  {
    return_value_logtime_2=logtime();
    logprint("%s %s:%d set playername: %s\n", return_value_logtime_2, (const void *)"sendSETDName", 230, name);
  }

  send_packet((unsigned char *)&pkt_header, sizeof(struct SETD_header) /*9ul*/ );
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(name);
  send_packet((unsigned char *)name, return_value_strlen_3 + (unsigned long int)1);
}

// sendSTAT
// file slimproto.c line 134
static void sendSTAT(const char *event, unsigned int server_timestamp)
{
  struct STAT_packet pkt;
  unsigned int now;
  now=gettime_ms();
  unsigned int ms_played;
  const char *return_value_logtime_1;
  const char *return_value_logtime_2;
  const char *return_value_logtime_3;
  if(!(status.current_sample_rate == 0u) && !(status.frames_played == 0u) && !(status.device_frames >= status.frames_played))
  {
    ms_played = (unsigned int)(((unsigned long int)(status.frames_played - status.device_frames) * (unsigned long int)1000) / (unsigned long int)status.current_sample_rate);
    if(!(status.updated >= now))
      ms_played = ms_played + (now - status.updated);

    if((signed int)loglevel >= lSDEBUG)
    {
      return_value_logtime_1=logtime();
      logprint("%s %s:%d ms_played: %u (frames_played: %u device_frames: %u)\n", return_value_logtime_1, (const void *)"sendSTAT", 142, ms_played, status.frames_played, status.device_frames);
    }

  }

  else
    if(!(status.frames_played == 0u) && !(status.stream_start >= now))
    {
      ms_played = now - status.stream_start;
      if((signed int)loglevel >= lSDEBUG)
      {
        return_value_logtime_2=logtime();
        logprint("%s %s:%d ms_played: %u using elapsed time (frames_played: %u device_frames: %u)\n", return_value_logtime_2, (const void *)"sendSTAT", 145, ms_played, status.frames_played, status.device_frames);
      }

    }

    else
    {
      if((signed int)loglevel >= lSDEBUG)
      {
        return_value_logtime_3=logtime();
        logprint("%s %s:%d ms_played: 0\n", return_value_logtime_3, (const void *)"sendSTAT", 147);
      }

      ms_played = (unsigned int)0;
    }
  memset((void *)&pkt, 0, sizeof(struct STAT_packet) /*61ul*/ );
  memcpy((void *)&pkt.opcode, (const void *)"STAT", (unsigned long int)4);
  pkt.length=htonl((unsigned int)(sizeof(struct STAT_packet) /*61ul*/  - (unsigned long int)8));
  memcpy((void *)&pkt.event, (const void *)event, (unsigned long int)4);
  packN(&pkt.stream_buffer_fullness, status.stream_full);
  packN(&pkt.stream_buffer_size, status.stream_size);
  packN(&pkt.bytes_received_H, (unsigned int)((unsigned long int)status.stream_bytes >> 32));
  packN(&pkt.bytes_received_L, (unsigned int)((unsigned long int)status.stream_bytes & (unsigned long int)0xffffffff));
  pkt.signal_strength = (unsigned short int)0xffff;
  packN(&pkt.jiffies, now);
  packN(&pkt.output_buffer_size, status.output_size);
  packN(&pkt.output_buffer_fullness, status.output_full);
  packN(&pkt.elapsed_seconds, ms_played / (unsigned int)1000);
  packN(&pkt.elapsed_milliseconds, ms_played);
  pkt.server_timestamp = server_timestamp;
  const char *return_value_logtime_4;
  if((signed int)loglevel >= lDEBUG)
  {
    return_value_logtime_4=logtime();
    logprint("%s %s:%d STAT: %s\n", return_value_logtime_4, (const void *)"sendSTAT", 171, event);
  }

  const char *return_value_logtime_5;
  if((signed int)loglevel == lSDEBUG)
  {
    if((signed int)loglevel >= lSDEBUG)
    {
      return_value_logtime_5=logtime();
      logprint("%s %s:%d received bytesL: %u streambuf: %u outputbuf: %u calc elapsed: %u real elapsed: %u (diff: %d) device: %u delay: %d\n", return_value_logtime_5, (const void *)"sendSTAT", 176, (unsigned int)status.stream_bytes, status.stream_full, status.output_full, ms_played, now - status.stream_start, (ms_played - now) + status.stream_start, (status.device_frames * (unsigned int)1000) / status.current_sample_rate, now - status.updated);
    }

  }

  send_packet((unsigned char *)&pkt, sizeof(struct STAT_packet) /*61ul*/ );
}

// send_header
// file stream.c line 39
static void send_header(void)
{
  char *ptr = stream.header;
  signed int len = (signed int)stream.header_len;
  unsigned int try = (unsigned int)0;
  signed long int n;
  signed int *return_value___errno_location_2;
  const char *return_value_logtime_1;
  const char *return_value_logtime_3;
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  const char *return_value_logtime_6;
  while(!(len == 0))
  {
    n=send(fd, (const void *)ptr, (unsigned long int)len, 16384);
    if(!(n >= 1l))
    {
      if(!(n >= 0l))
      {
        return_value___errno_location_2=__errno_location();
        if(*return_value___errno_location_2 == 11)
        {
          if(!(try >= 10u))
          {
            if((signed int)loglevel_link1 >= lSDEBUG)
            {
              return_value_logtime_1=logtime();
              try = try + 1u;
              logprint("%s %s:%d retrying (%d) writing to socket\n", return_value_logtime_1, (const void *)"send_header", 50, try);
            }

            usleep((unsigned int)1000);
            continue;
          }

        }

      }

      if((signed int)loglevel_link1 >= lINFO)
      {
        return_value_logtime_3=logtime();
        return_value___errno_location_4=__errno_location();
        return_value_strerror_5=strerror(*return_value___errno_location_4);
        logprint("%s %s:%d failed writing to socket: %s\n", return_value_logtime_3, (const void *)"send_header", 54, return_value_strerror_5);
      }

      stream.disconnect = (enum anonymous_0)LOCAL_DISCONNECT;
      stream.state = (enum anonymous_14)DISCONNECT;
      wake_controller();
      goto __CPROVER_DUMP_L11;
    }

    if((signed int)loglevel_link1 >= lSDEBUG)
    {
      return_value_logtime_6=logtime();
      logprint("%s %s:%d wrote %d bytes to socket\n", return_value_logtime_6, (const void *)"send_header", 60, n);
    }

    ptr = ptr + n;
    len = len - (signed int)n;
  }
  const char *return_value_logtime_7;
  if((signed int)loglevel_link1 >= lSDEBUG)
  {
    return_value_logtime_7=logtime();
    logprint("%s %s:%d wrote header\n", return_value_logtime_7, (const void *)"send_header", 64);
  }


__CPROVER_DUMP_L11:
  ;
}

// send_packet
// file slimproto.c line 89
void send_packet(unsigned char *packet, unsigned long int len)
{
  unsigned char *ptr = packet;
  unsigned int try = (unsigned int)0;
  signed long int n;
  signed int *return_value___errno_location_2;
  const char *return_value_logtime_1;
  const char *return_value_logtime_3;
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  while(!(len == 0ul))
  {
    n=send(sock, (const void *)ptr, len, 16384);
    if(!(n >= 1l))
    {
      if(!(n >= 0l))
      {
        return_value___errno_location_2=__errno_location();
        if(*return_value___errno_location_2 == 11)
        {
          if(!(try >= 10u))
          {
            if((signed int)loglevel >= lDEBUG)
            {
              return_value_logtime_1=logtime();
              try = try + 1u;
              logprint("%s %s:%d retrying (%d) writing to socket\n", return_value_logtime_1, (const void *)"send_packet", 98, try);
            }

            usleep((unsigned int)1000);
            continue;
          }

        }

      }

      if((signed int)loglevel >= lINFO)
      {
        return_value_logtime_3=logtime();
        return_value___errno_location_4=__errno_location();
        return_value_strerror_5=strerror(*return_value___errno_location_4);
        logprint("%s %s:%d failed writing to socket: %s\n", return_value_logtime_3, (const void *)"send_packet", 102, return_value_strerror_5);
      }

      goto __CPROVER_DUMP_L9;
    }

    ptr = ptr + n;
    len = len - (unsigned long int)n;
  }

__CPROVER_DUMP_L9:
  ;
}

// server_addr
// file squeezelite.h line 380
void server_addr(char *server, unsigned int *ip_ptr, unsigned int *port_ptr)
{
  struct addrinfo *res = (struct addrinfo *)(void *)0;
  struct addrinfo hints;
  const char *port = (const char *)(void *)0;
  char *return_value_strtok_2;
  return_value_strtok_2=strtok(server, ":");
  if(!(return_value_strtok_2 == ((char *)NULL)))
  {
    port=strtok((char *)(void *)0, ":");
    if(!(port == ((const char *)NULL)))
    {
      signed int return_value_atoi_1;
      return_value_atoi_1=atoi(port);
      *port_ptr = (unsigned int)return_value_atoi_1;
    }

  }

  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 2;
  getaddrinfo(server, (const char *)(void *)0, &hints, &res);
  if(!(res == ((struct addrinfo *)NULL)))
  {
    if(!(res->ai_addr == ((struct sockaddr *)NULL)))
      *ip_ptr = ((struct sockaddr_in *)res->ai_addr)->sin_addr.s_addr;

  }

  if(!(res == ((struct addrinfo *)NULL)))
    freeaddrinfo(res);

}

// set_nonblock
// file squeezelite.h line 378
void set_nonblock(signed int s)
{
  signed int flags;
  flags=fcntl(s, 3, 0);
  fcntl(s, 4, flags | 04000);
}

// set_readwake_handles
// file squeezelite.h line 381
void set_readwake_handles(struct pollfd *handles, signed int s, signed int e)
{
  (handles + (signed long int)0)->fd = s;
  (handles + (signed long int)1)->fd = e;
  (handles + (signed long int)0)->events = (signed short int)0x001;
  (handles + (signed long int)1)->events = (signed short int)0x001;
}

// set_volume
// file squeezelite.h line 606
void set_volume(unsigned int left, unsigned int right)
{
  const char *return_value_logtime_1;
  if((signed int)loglevel_link3 >= lDEBUG)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d setting internal gain left: %u right: %u\n", return_value_logtime_1, (const void *)"set_volume", 76, left, right);
  }

  pthread_mutex_lock(&outputbuf->mutex);
  output.gainL = left;
  output.gainR = right;
  pthread_mutex_unlock(&outputbuf->mutex);
}

// sighandler
// file main.c line 183
static void sighandler(signed int signum)
{
  slimproto_stop();
  signal(signum, (void (*)(signed int))0);
}

// slimproto
// file squeezelite.h line 429
void slimproto(enum anonymous_8 level, char *server, unsigned char *mac, const char *name, const char *namefile, const char *modelname)
{
  struct sockaddr_in serv_addr;
  _Bool reconnect = (_Bool)0;
  unsigned int failed_connect = (unsigned int)0;
  unsigned int slimproto_port = (unsigned int)0;
  signed int i;
  wake_e=eventfd((unsigned int)0, 0);
  loglevel = level;
  running = (_Bool)1;
  if(!(server == ((char *)NULL)))
    server_addr(server, &slimproto_ip, &slimproto_port);

  if(slimproto_ip == 0u)
    slimproto_ip=discover_server();

  if(slimproto_port == 0u)
    slimproto_port = (unsigned int)3483;

  if(!(name == ((const char *)NULL)))
  {
    strncpy(player_name, name, (unsigned long int)64);
    player_name[(signed long int)64] = (char)0;
  }

  const char *return_value_logtime_2;
  if(!(namefile == ((const char *)NULL)))
  {
    struct _IO_FILE *fp;
    name_file = namefile;
    fp=fopen(namefile, "r");
    if(!(fp == ((struct _IO_FILE *)NULL)))
    {
      char *return_value_fgets_3;
      return_value_fgets_3=fgets(player_name, 64, fp);
      if(return_value_fgets_3 == ((char *)NULL))
        player_name[(signed long int)64] = (char)0;

      else
      {
        signed int len;
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(player_name);
        len = (signed int)return_value_strlen_1;
        if(len >= 1)
        {
          if((signed int)player_name[(signed long int)(len + -1)] == 10)
            player_name[(signed long int)(len - 1)] = (char)0;

        }

        if((signed int)loglevel >= lINFO)
        {
          return_value_logtime_2=logtime();
          logprint("%s %s:%d retrieved name %s from %s\n", return_value_logtime_2, (const void *)"slimproto", 823, (const void *)player_name, name_file);
        }

      }
      fclose(fp);
    }

  }

  unsigned long int return_value_strlen_4;
  const char *return_value_logtime_5;
  char *return_value_inet_ntoa_6;
  unsigned short int return_value_ntohs_7;
  const char *return_value_logtime_8;
  char *return_value_inet_ntoa_9;
  unsigned short int return_value_ntohs_10;
  const char *return_value_logtime_11;
  const char *return_value_logtime_12;
  const char *return_value_logtime_13;
  if(!(running == (_Bool)0))
  {
    pthread_mutex_lock(&outputbuf->mutex);
    static char fixed_cap[256l];
    snprintf(fixed_cap, (unsigned long int)256, ",ModelName=%s,MaxSampleRate=%u", modelname != ((const char *)NULL) ? modelname : "SqueezeLite", output.supported_rates[(signed long int)0]);
    i = 0;
    for( ; !(i >= 9); i = i + 1)
      if(!(codecs[(signed long int)i] == ((struct codec *)NULL)))
      {
        if(!(codecs[(signed long int)i]->id == 0))
        {
          return_value_strlen_4=strlen(fixed_cap);
          if(!(return_value_strlen_4 >= 246ul))
          {
            strcat(fixed_cap, ",");
            strcat(fixed_cap, codecs[(signed long int)i]->types);
          }

        }

      }

    pthread_mutex_unlock(&outputbuf->mutex);
    memset((void *)&serv_addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    serv_addr.sin_family = (unsigned short int)2;
    serv_addr.sin_addr.s_addr = slimproto_ip;
    serv_addr.sin_port=htons((unsigned short int)slimproto_port);
    if((signed int)loglevel >= lINFO)
    {
      return_value_logtime_5=logtime();
      return_value_inet_ntoa_6=inet_ntoa(serv_addr.sin_addr);
      return_value_ntohs_7=ntohs(serv_addr.sin_port);
      logprint("%s %s:%d connecting to %s:%d\n", return_value_logtime_5, (const void *)"slimproto", 848, return_value_inet_ntoa_6, return_value_ntohs_7);
    }

    new_server = (unsigned int)0;
    while(!(running == (_Bool)0))
    {
      if(!(new_server == 0u))
      {
        serv_addr.sin_addr.s_addr = new_server;
        slimproto_ip = serv_addr.sin_addr.s_addr;
        if((signed int)loglevel >= lINFO)
        {
          return_value_logtime_8=logtime();
          return_value_inet_ntoa_9=inet_ntoa(serv_addr.sin_addr);
          return_value_ntohs_10=ntohs(serv_addr.sin_port);
          logprint("%s %s:%d switching server to %s:%d\n", return_value_logtime_8, (const void *)"slimproto", 856, return_value_inet_ntoa_9, return_value_ntohs_10);
        }

        new_server = (unsigned int)0;
        reconnect = (_Bool)0;
      }

      sock=socket(2, 1, 0);
      set_nonblock(sock);
      signed int return_value_connect_timeout_14;
      return_value_connect_timeout_14=connect_timeout(sock, (struct sockaddr *)&serv_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ , 5);
      if(!(return_value_connect_timeout_14 == 0))
      {
        if((signed int)loglevel >= lINFO)
        {
          return_value_logtime_11=logtime();
          logprint("%s %s:%d unable to connect to server %u\n", return_value_logtime_11, (const void *)"slimproto", 868, failed_connect);
        }

        sleep((unsigned int)5);
        if(server == ((char *)NULL))
        {
          failed_connect = failed_connect + 1u;
          if(failed_connect >= 6u)
          {
            serv_addr.sin_addr.s_addr=discover_server();
            slimproto_ip = serv_addr.sin_addr.s_addr;
          }

        }

      }

      else
      {
        struct sockaddr_in our_addr;
        unsigned int slimproto__1__7__3__len;
        if((signed int)loglevel >= lINFO)
        {
          return_value_logtime_12=logtime();
          logprint("%s %s:%d connected\n", return_value_logtime_12, (const void *)"slimproto", 881);
        }

        static char var_cap[128l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        var_cap[(signed long int)0] = (char)0;
        failed_connect = (unsigned int)0;
        slimproto__1__7__3__len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        getsockname(sock, (struct sockaddr *)&our_addr, &slimproto__1__7__3__len);
        if(our_addr.sin_addr.s_addr == serv_addr.sin_addr.s_addr)
        {
          if((signed int)loglevel >= lINFO)
          {
            return_value_logtime_13=logtime();
            logprint("%s %s:%d local player\n", return_value_logtime_13, (const void *)"slimproto", 892);
          }

          strcat(var_cap, ",loc");
        }

        if(!(new_server_cap == ((char *)NULL)))
        {
          strcat(var_cap, new_server_cap);
          free((void *)new_server_cap);
          new_server_cap = (char *)(void *)0;
        }

        sendHELO(reconnect, fixed_cap, var_cap, mac);
        slimproto_run();
        if(reconnect == (_Bool)0)
          reconnect = (_Bool)1;

        usleep((unsigned int)100000);
      }
      close(sock);
    }
  }

}

// slimproto_run
// file slimproto.c line 504
static void slimproto_run()
{
  signed int expect = 0;
  signed int got = 0;
  unsigned int now;
  struct pollfd ehandles[2l];
  signed int timeouts = 0;
  set_readwake_handles(ehandles, sock, wake_e);
  signed int *return_value___errno_location_2;
  const char *return_value_logtime_3;
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  signed int *return_value___errno_location_8;
  const char *return_value_logtime_9;
  signed int *return_value___errno_location_10;
  char *return_value_strerror_11;
  const char *return_value_logtime_15;
  const char *return_value_logtime_16;
  const char *return_value_logtime_17;
  while(new_server == 0u && !(running == (_Bool)0))
  {
    _Bool wake = (_Bool)0;
    enum anonymous_9 ev;
    ev=wait_readwake(ehandles, 1000);
    if(!((signed int)ev == EVENT_TIMEOUT))
    {
      if((signed int)ev == EVENT_READ)
      {
        static unsigned char buffer[4096l];
        if(expect >= 1)
        {
          signed int n;
          signed long int return_value_recv_1;
          return_value_recv_1=recv(sock, (void *)(buffer + (signed long int)got), (unsigned long int)expect, 0);
          n = (signed int)return_value_recv_1;
          if(!(n >= 1))
          {
            if(!(n >= 0))
            {
              return_value___errno_location_2=__errno_location();
              if(*return_value___errno_location_2 == 11)
                continue;

            }

            if((signed int)loglevel >= lINFO)
            {
              return_value_logtime_3=logtime();
              char *tmp_if_expr_6;
              if(!(n == 0))
              {
                return_value___errno_location_4=__errno_location();
                return_value_strerror_5=strerror(*return_value___errno_location_4);
                tmp_if_expr_6 = return_value_strerror_5;
              }

              else
                tmp_if_expr_6 = "closed";
              logprint("%s %s:%d error reading from socket: %s\n", return_value_logtime_3, (const void *)"slimproto_run", 530, tmp_if_expr_6);
            }

            goto __CPROVER_DUMP_L56;
          }

          expect = expect - n;
          got = got + n;
          if(expect == 0)
          {
            process(buffer, got);
            got = 0;
          }

        }

        else
          if(expect == 0)
          {
            signed int slimproto_run__1__1__1__1__2__n;
            signed long int return_value_recv_7;
            return_value_recv_7=recv(sock, (void *)(buffer + (signed long int)got), (unsigned long int)(2 - got), 0);
            slimproto_run__1__1__1__1__2__n = (signed int)return_value_recv_7;
            if(!(slimproto_run__1__1__1__1__2__n >= 1))
            {
              if(!(slimproto_run__1__1__1__1__2__n >= 0))
              {
                return_value___errno_location_8=__errno_location();
                if(*return_value___errno_location_8 == 11)
                  continue;

              }

              if((signed int)loglevel >= lINFO)
              {
                return_value_logtime_9=logtime();
                char *tmp_if_expr_12;
                if(!(slimproto_run__1__1__1__1__2__n == 0))
                {
                  return_value___errno_location_10=__errno_location();
                  return_value_strerror_11=strerror(*return_value___errno_location_10);
                  tmp_if_expr_12 = return_value_strerror_11;
                }

                else
                  tmp_if_expr_12 = "closed";
                logprint("%s %s:%d error reading from socket: %s\n", return_value_logtime_9, (const void *)"slimproto_run", 545, tmp_if_expr_12);
              }

              goto __CPROVER_DUMP_L56;
            }

            got = got + slimproto_run__1__1__1__1__2__n;
            if(got == 2)
            {
              expect = (signed int)buffer[(signed long int)0] << 8 | (signed int)buffer[(signed long int)1];
              got = 0;
              if(expect >= 4097)
              {
                const char *return_value_logtime_13;
                return_value_logtime_13=logtime();
                logprint("%s %s:%d FATAL: slimproto packet too big: %d > %d\n", return_value_logtime_13, (const void *)"slimproto_run", 553, expect, 4096);
                goto __CPROVER_DUMP_L56;
              }

            }

          }

          else
          {
            const char *return_value_logtime_14;
            return_value_logtime_14=logtime();
            logprint("%s %s:%d FATAL: negative expect\n", return_value_logtime_14, (const void *)"slimproto_run", 558);
            goto __CPROVER_DUMP_L56;
          }
      }

      if((signed int)ev == EVENT_WAKE)
        wake = (_Bool)1;

      timeouts = 0;
    }

    else
    {
      timeouts = timeouts + 1;
      if(timeouts >= 36)
      {
        if((signed int)loglevel >= lINFO)
        {
          return_value_logtime_15=logtime();
          logprint("%s %s:%d No messages from server - connection dead\n", return_value_logtime_15, (const void *)"slimproto_run", 573);
        }

        goto __CPROVER_DUMP_L56;
      }

    }
    now=gettime_ms();
    static unsigned int last = (unsigned int)0;
    if(now + -last >= 101u || !(now >= last) || !(wake == (_Bool)0))
    {
      _Bool _sendSTMs = (_Bool)0;
      _Bool _sendDSCO = (_Bool)0;
      _Bool _sendRESP = (_Bool)0;
      _Bool _sendMETA = (_Bool)0;
      _Bool _sendSTMd = (_Bool)0;
      _Bool _sendSTMt = (_Bool)0;
      _Bool _sendSTMl = (_Bool)0;
      _Bool _sendSTMu = (_Bool)0;
      _Bool _sendSTMo = (_Bool)0;
      _Bool _sendSTMn = (_Bool)0;
      _Bool _stream_disconnect = (_Bool)0;
      _Bool _start_output = (_Bool)0;
      enum anonymous_23 _decode_state;
      enum anonymous_0 disconnect_code;
      unsigned long int header_len = (unsigned long int)0;
      _Bool _sendIR = (_Bool)0;
      unsigned int ir_code;
      unsigned int ir_ts;
      last = now;
      pthread_mutex_lock(&streambuf->mutex);
      status.stream_full=_buf_used(streambuf);
      status.stream_size = (unsigned int)streambuf->size;
      status.stream_bytes = stream.bytes;
      status.stream_state = stream.state;
      if((signed int)stream.state == DISCONNECT)
      {
        disconnect_code = stream.disconnect;
        stream.state = (enum anonymous_14)STOPPED;
        _sendDSCO = (_Bool)1;
      }

      static char header[4096l];
      if(stream.sent_headers == (_Bool)0 && ((signed int)stream.state == STREAMING_WAIT || (signed int)stream.state == STREAMING_BUFFERING || (signed int)stream.state == STREAMING_HTTP))
      {
        header_len = stream.header_len;
        memcpy((void *)header, (const void *)stream.header, header_len);
        _sendRESP = (_Bool)1;
        stream.sent_headers = (_Bool)1;
      }

      if(!(stream.meta_send == (_Bool)0))
      {
        header_len = stream.header_len;
        memcpy((void *)header, (const void *)stream.header, header_len);
        _sendMETA = (_Bool)1;
        stream.meta_send = (_Bool)0;
      }

      pthread_mutex_unlock(&streambuf->mutex);
      pthread_mutex_lock(&decode.mutex);
      if(sentSTMl == (_Bool)0 && (signed int)decode.state == DECODE_READY && ((signed int)status.stream_state == STREAMING_FILE || (signed int)status.stream_state == STREAMING_HTTP))
      {
        if(autostart == 0)
        {
          decode.state = (enum anonymous_23)DECODE_RUNNING;
          _sendSTMl = (_Bool)1;
          sentSTMl = (_Bool)1;
        }

        else
          if(autostart == 1)
          {
            decode.state = (enum anonymous_23)DECODE_RUNNING;
            _start_output = (_Bool)1;
          }

      }

      if((signed int)decode.state == DECODE_COMPLETE || (signed int)decode.state == DECODE_ERROR)
      {
        if((signed int)decode.state == DECODE_COMPLETE)
          _sendSTMd = (_Bool)1;

        if((signed int)decode.state == DECODE_ERROR)
          _sendSTMn = (_Bool)1;

        decode.state = (enum anonymous_23)DECODE_STOPPED;
        if((signed int)status.stream_state == STREAMING_FILE || (signed int)status.stream_state == STREAMING_HTTP)
          _stream_disconnect = (_Bool)1;

      }

      _decode_state = decode.state;
      pthread_mutex_unlock(&decode.mutex);
      pthread_mutex_lock(&outputbuf->mutex);
      status.output_full=_buf_used(outputbuf);
      status.output_size = (unsigned int)outputbuf->size;
      status.frames_played = output.frames_played_dmp;
      status.current_sample_rate = output.current_sample_rate;
      status.updated = output.updated;
      status.device_frames = output.device_frames;
      if(!(output.track_started == (_Bool)0))
      {
        _sendSTMs = (_Bool)1;
        output.track_started = (_Bool)0;
        status.stream_start = output.track_start_time;
      }

      if(!(output.pa_reopen == (_Bool)0))
      {
        _pa_open();
        output.pa_reopen = (_Bool)0;
      }

      if(!(_start_output == (_Bool)0))
        output.state = (enum anonymous_1)OUTPUT_BUFFER;

      if(status.output_full == 0u && sentSTMu == (_Bool)0 && (signed int)output.state == OUTPUT_RUNNING && (signed int)_decode_state == DECODE_STOPPED && !((signed int)status.stream_state >= 2))
      {
        _sendSTMu = (_Bool)1;
        sentSTMu = (_Bool)1;
        if((signed int)loglevel >= lDEBUG)
        {
          return_value_logtime_16=logtime();
          logprint("%s %s:%d output underrun\n", return_value_logtime_16, (const void *)"slimproto_run", 679);
        }

        output.state = (enum anonymous_1)OUTPUT_STOPPED;
        output.stop_time = now;
      }

      if(status.output_full == 0u && sentSTMo == (_Bool)0 && (signed int)status.stream_state == STREAMING_HTTP && (signed int)output.state == OUTPUT_RUNNING)
      {
        _sendSTMo = (_Bool)1;
        sentSTMo = (_Bool)1;
      }

      if((signed int)output.state == OUTPUT_STOPPED && !(output.idle_to == 0u) && !(output.idle_to >= now + -output.stop_time))
      {
        output.state = (enum anonymous_1)OUTPUT_OFF;
        if((signed int)loglevel >= lDEBUG)
        {
          return_value_logtime_17=logtime();
          logprint("%s %s:%d output timeout\n", return_value_logtime_17, (const void *)"slimproto_run", 689);
        }

      }

      if((signed int)output.state == OUTPUT_RUNNING && now + -status.last >= 1001u)
      {
        _sendSTMt = (_Bool)1;
        status.last = now;
      }

      pthread_mutex_unlock(&outputbuf->mutex);
      pthread_mutex_lock(&ir.mutex);
      if(!(ir.code == 0u))
      {
        _sendIR = (_Bool)1;
        ir_code = ir.code;
        ir_ts = ir.ts;
        ir.code = (unsigned int)0;
      }

      pthread_mutex_unlock(&ir.mutex);
      if(!(_stream_disconnect == (_Bool)0))
        stream_disconnect();

      if(!(_sendDSCO == (_Bool)0))
        sendDSCO(disconnect_code);

      if(!(_sendSTMs == (_Bool)0))
        sendSTAT("STMs", (unsigned int)0);

      if(!(_sendSTMd == (_Bool)0))
        sendSTAT("STMd", (unsigned int)0);

      if(!(_sendSTMt == (_Bool)0))
        sendSTAT("STMt", (unsigned int)0);

      if(!(_sendSTMl == (_Bool)0))
        sendSTAT("STMl", (unsigned int)0);

      if(!(_sendSTMu == (_Bool)0))
        sendSTAT("STMu", (unsigned int)0);

      if(!(_sendSTMo == (_Bool)0))
        sendSTAT("STMo", (unsigned int)0);

      if(!(_sendSTMn == (_Bool)0))
        sendSTAT("STMn", (unsigned int)0);

      if(!(_sendRESP == (_Bool)0))
        sendRESP(header, header_len);

      if(!(_sendMETA == (_Bool)0))
        sendMETA(header, header_len);

      if(!(_sendIR == (_Bool)0))
        sendIR(ir_code, ir_ts);

    }

  }

__CPROVER_DUMP_L56:
  ;
}

// slimproto_stop
// file squeezelite.h line 430
void slimproto_stop(void)
{
  const char *return_value_logtime_1;
  if((signed int)loglevel >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d slimproto stop\n", return_value_logtime_1, (const void *)"slimproto_stop", 919);
  }

  running = (_Bool)0;
}

// stream_close
// file squeezelite.h line 454
void stream_close(void)
{
  const char *return_value_logtime_1;
  if((signed int)loglevel_link1 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d close stream\n", return_value_logtime_1, (const void *)"stream_close", 322);
  }

  pthread_mutex_lock(&streambuf->mutex);
  running_link1 = (_Bool)0;
  pthread_mutex_unlock(&streambuf->mutex);
  pthread_join(thread, (void **)(void *)0);
  free((void *)stream.header);
  buf_destroy(streambuf);
}

// stream_disconnect
// file squeezelite.h line 457
_Bool stream_disconnect(void)
{
  _Bool disc = (_Bool)0;
  pthread_mutex_lock(&streambuf->mutex);
  if(!(fd == -1))
  {
    close(fd);
    fd = -1;
    disc = (_Bool)1;
  }

  stream.state = (enum anonymous_14)STOPPED;
  pthread_mutex_unlock(&streambuf->mutex);
  return disc;
}

// stream_file
// file squeezelite.h line 455
void stream_file(const char *header, unsigned long int header_len, unsigned int threshold)
{
  buf_flush(streambuf);
  pthread_mutex_lock(&streambuf->mutex);
  stream.header_len = header_len;
  memcpy((void *)stream.header, (const void *)header, header_len);
  stream.header[(signed long int)header_len] = (char)0;
  const char *return_value_logtime_1;
  if((signed int)loglevel_link1 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d opening local file: %s\n", return_value_logtime_1, (const void *)"stream_file", 342, stream.header);
  }

  fd=open(stream.header, 00);
  stream.state = (enum anonymous_14)STREAMING_FILE;
  const char *return_value_logtime_2;
  if(!(fd >= 0))
  {
    if((signed int)loglevel_link1 >= lINFO)
    {
      return_value_logtime_2=logtime();
      logprint("%s %s:%d can't open file: %s\n", return_value_logtime_2, (const void *)"stream_file", 352, stream.header);
    }

    stream.state = (enum anonymous_14)DISCONNECT;
  }

  wake_controller();
  stream.cont_wait = (_Bool)0;
  stream.meta_interval = (unsigned int)0;
  stream.meta_next = (unsigned int)0;
  stream.meta_left = (unsigned int)0;
  stream.meta_send = (_Bool)0;
  stream.sent_headers = (_Bool)0;
  stream.bytes = (unsigned long int)0;
  stream.threshold = threshold;
  pthread_mutex_unlock(&streambuf->mutex);
}

// stream_init
// file squeezelite.h line 453
void stream_init(enum anonymous_8 level, unsigned int stream_buf_size)
{
  loglevel_link1 = level;
  const char *return_value_logtime_1;
  if((signed int)loglevel_link1 >= lINFO)
  {
    return_value_logtime_1=logtime();
    logprint("%s %s:%d init stream\n", return_value_logtime_1, (const void *)"stream_init", 290);
  }

  const char *return_value_logtime_2;
  if((signed int)loglevel_link1 >= lDEBUG)
  {
    return_value_logtime_2=logtime();
    logprint("%s %s:%d streambuf size: %u\n", return_value_logtime_2, (const void *)"stream_init", 291, stream_buf_size);
  }

  buf_init(streambuf, (unsigned long int)stream_buf_size);
  if(streambuf->buf == ((unsigned char *)NULL))
  {
    const char *return_value_logtime_3;
    return_value_logtime_3=logtime();
    logprint("%s %s:%d unable to malloc buffer\n", return_value_logtime_3, (const void *)"stream_init", 295);
    exit(0);
  }

  stream.state = (enum anonymous_14)STOPPED;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc((unsigned long int)4096);
  stream.header = (char *)return_value_malloc_4;
  *stream.header = (char)0;
  fd = -1;
  touch_memory(streambuf->buf, streambuf->size);
  union pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, (unsigned long int)(16384 + 64 * 1024));
  pthread_create(&thread, &attr, (void * (*)(void *))stream_thread, (void *)0);
  pthread_attr_destroy(&attr);
}

// stream_sock
// file squeezelite.h line 456
void stream_sock(unsigned int ip, unsigned short int port, const char *header, unsigned long int header_len, unsigned int threshold, _Bool cont_wait)
{
  struct sockaddr_in addr;
  signed int stream_sock__1__sock;
  stream_sock__1__sock=socket(2, 1, 0);
  if(!(stream_sock__1__sock >= 0))
  {
    const char *return_value_logtime_1;
    return_value_logtime_1=logtime();
    logprint("%s %s:%d failed to create socket\n", return_value_logtime_1, (const void *)"stream_sock", 375);
    goto __CPROVER_DUMP_L6;
  }

  memset((void *)&addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  addr.sin_family = (unsigned short int)2;
  addr.sin_addr.s_addr = ip;
  addr.sin_port = port;
  const char *return_value_logtime_2;
  char *return_value_inet_ntoa_3;
  unsigned short int return_value_ntohs_4;
  if((signed int)loglevel_link1 >= lINFO)
  {
    return_value_logtime_2=logtime();
    return_value_inet_ntoa_3=inet_ntoa(addr.sin_addr);
    return_value_ntohs_4=ntohs(addr.sin_port);
    logprint("%s %s:%d connecting to %s:%d\n", return_value_logtime_2, (const void *)"stream_sock", 384, return_value_inet_ntoa_3, return_value_ntohs_4);
  }

  set_nonblock(stream_sock__1__sock);
  signed int return_value_connect_timeout_6;
  return_value_connect_timeout_6=connect_timeout(stream_sock__1__sock, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ , 10);
  const char *return_value_logtime_5;
  if(!(return_value_connect_timeout_6 >= 0))
  {
    if((signed int)loglevel_link1 >= lINFO)
    {
      return_value_logtime_5=logtime();
      logprint("%s %s:%d unable to connect to server\n", return_value_logtime_5, (const void *)"stream_sock", 390);
    }

    pthread_mutex_lock(&streambuf->mutex);
    stream.state = (enum anonymous_14)DISCONNECT;
    stream.disconnect = (enum anonymous_0)UNREACHABLE;
    pthread_mutex_unlock(&streambuf->mutex);
    goto __CPROVER_DUMP_L6;
  }

  buf_flush(streambuf);
  pthread_mutex_lock(&streambuf->mutex);
  fd = stream_sock__1__sock;
  stream.state = (enum anonymous_14)SEND_HEADERS;
  stream.cont_wait = cont_wait;
  stream.meta_interval = (unsigned int)0;
  stream.meta_next = (unsigned int)0;
  stream.meta_left = (unsigned int)0;
  stream.meta_send = (_Bool)0;
  stream.header_len = header_len;
  memcpy((void *)stream.header, (const void *)header, header_len);
  stream.header[(signed long int)header_len] = (char)0;
  const char *return_value_logtime_7;
  if((signed int)loglevel_link1 >= lINFO)
  {
    return_value_logtime_7=logtime();
    logprint("%s %s:%d header: %s\n", return_value_logtime_7, (const void *)"stream_sock", 413, stream.header);
  }

  stream.sent_headers = (_Bool)0;
  stream.bytes = (unsigned long int)0;
  stream.threshold = threshold;
  pthread_mutex_unlock(&streambuf->mutex);

__CPROVER_DUMP_L6:
  ;
}

// stream_thread
// file stream.c line 77
static void * stream_thread()
{
  unsigned int return_value__buf_space_3;
  unsigned int return_value__buf_cont_write_4;
  const char *return_value_logtime_7;
  const char *return_value_logtime_8;
  const char *return_value_logtime_9;
  signed int *return_value___errno_location_10;
  char *return_value_strerror_11;
  signed int *return_value___errno_location_13;
  const char *return_value_logtime_14;
  signed int *return_value___errno_location_15;
  char *return_value_strerror_16;
  const char *return_value_logtime_19;
  signed int *return_value___errno_location_21;
  const char *return_value_logtime_22;
  signed int *return_value___errno_location_23;
  char *return_value_strerror_24;
  signed int *return_value___errno_location_27;
  const char *return_value_logtime_28;
  signed int *return_value___errno_location_29;
  char *return_value_strerror_30;
  const char *return_value_logtime_32;
  unsigned int return_value__buf_space_35;
  unsigned int return_value__buf_cont_write_36;
  const char *return_value_logtime_39;
  signed int *return_value___errno_location_43;
  const char *return_value_logtime_40;
  signed int *return_value___errno_location_41;
  char *return_value_strerror_42;
  const char *return_value_logtime_44;
  const char *return_value_logtime_45;
  while(!(running_link1 == (_Bool)0))
  {
    struct pollfd pollinfo;
    unsigned long int space;
    pthread_mutex_lock(&streambuf->mutex);
    unsigned int return_value__buf_space_1;
    return_value__buf_space_1=_buf_space(streambuf);
    unsigned int return_value__buf_cont_write_2;
    return_value__buf_cont_write_2=_buf_cont_write(streambuf);
    unsigned int tmp_if_expr_5;
    if(!(return_value__buf_space_1 >= return_value__buf_cont_write_2))
    {
      return_value__buf_space_3=_buf_space(streambuf);
      tmp_if_expr_5 = return_value__buf_space_3;
    }

    else
    {
      return_value__buf_cont_write_4=_buf_cont_write(streambuf);
      tmp_if_expr_5 = return_value__buf_cont_write_4;
    }
    space = (unsigned long int)tmp_if_expr_5;
    if(space == 0ul || !(fd >= 0) || !((signed int)stream.state >= 3))
    {
      pthread_mutex_unlock(&streambuf->mutex);
      usleep((unsigned int)100000);
    }

    else
    {
      if((signed int)stream.state == STREAMING_FILE)
      {
        signed int n;
        signed long int return_value_read_6;
        return_value_read_6=read(fd, (void *)streambuf->writep, space);
        n = (signed int)return_value_read_6;
        if(n == 0)
        {
          if((signed int)loglevel_link1 >= lINFO)
          {
            return_value_logtime_7=logtime();
            logprint("%s %s:%d end of stream\n", return_value_logtime_7, (const void *)"stream_thread", 98);
          }

          _disconnect((enum anonymous_14)DISCONNECT, (enum anonymous_0)DISCONNECT_OK);
        }

        if(n >= 1)
        {
          _buf_inc_writep(streambuf, (unsigned int)n);
          stream.bytes = stream.bytes + (unsigned long int)n;
          if((signed int)loglevel_link1 >= lSDEBUG)
          {
            return_value_logtime_8=logtime();
            logprint("%s %s:%d streambuf read %d bytes\n", return_value_logtime_8, (const void *)"stream_thread", 104, n);
          }

        }

        if(!(n >= 0))
        {
          if((signed int)loglevel_link1 >= lWARN)
          {
            return_value_logtime_9=logtime();
            return_value___errno_location_10=__errno_location();
            return_value_strerror_11=strerror(*return_value___errno_location_10);
            logprint("%s %s:%d error reading: %s\n", return_value_logtime_9, (const void *)"stream_thread", 107, return_value_strerror_11);
          }

          _disconnect((enum anonymous_14)DISCONNECT, (enum anonymous_0)REMOTE_DISCONNECT);
        }

        pthread_mutex_unlock(&streambuf->mutex);
        continue;
      }

      else
      {
        pollinfo.fd = fd;
        pollinfo.events = (signed short int)0x001;
        if((signed int)stream.state == SEND_HEADERS)
          pollinfo.events = pollinfo.events | (signed short int)0x004;

      }
      pthread_mutex_unlock(&streambuf->mutex);
      signed int return_value_poll_46;
      return_value_poll_46=poll(&pollinfo, (unsigned long int)1, 100);
      if(!(return_value_poll_46 == 0))
      {
        pthread_mutex_lock(&streambuf->mutex);
        if(!(fd >= 0))
        {
          pthread_mutex_unlock(&streambuf->mutex);
          continue;
        }

        if((signed int)stream.state == SEND_HEADERS && !((0x004 & (signed int)pollinfo.revents) == 0))
        {
          send_header();
          stream.header_len = (unsigned long int)0;
          stream.state = (enum anonymous_14)RECV_HEADERS;
          pthread_mutex_unlock(&streambuf->mutex);
          continue;
        }

        if(!((17 & (signed int)pollinfo.revents) == 0))
        {
          if((signed int)stream.state == RECV_HEADERS)
          {
            char c;
            signed int stream_thread__1__1__4__3__1__n;
            signed long int return_value_recv_12;
            return_value_recv_12=recv(fd, (void *)&c, (unsigned long int)1, 0);
            stream_thread__1__1__4__3__1__n = (signed int)return_value_recv_12;
            if(!(stream_thread__1__1__4__3__1__n >= 1))
            {
              if(!(stream_thread__1__1__4__3__1__n >= 0))
              {
                return_value___errno_location_13=__errno_location();
                if(*return_value___errno_location_13 == 11)
                {
                  pthread_mutex_unlock(&streambuf->mutex);
                  continue;
                }

              }

              if((signed int)loglevel_link1 >= lINFO)
              {
                return_value_logtime_14=logtime();
                char *tmp_if_expr_17;
                if(!(stream_thread__1__1__4__3__1__n == 0))
                {
                  return_value___errno_location_15=__errno_location();
                  return_value_strerror_16=strerror(*return_value___errno_location_15);
                  tmp_if_expr_17 = return_value_strerror_16;
                }

                else
                  tmp_if_expr_17 = "closed";
                logprint("%s %s:%d error reading headers: %s\n", return_value_logtime_14, (const void *)"stream_thread", 158, tmp_if_expr_17);
              }

              _disconnect((enum anonymous_14)STOPPED, (enum anonymous_0)LOCAL_DISCONNECT);
              pthread_mutex_unlock(&streambuf->mutex);
              continue;
            }

            stream.header[(signed long int)stream.header_len] = c;
            stream.header_len = stream.header_len + 1ul;
            if(stream.header_len >= 4096ul)
            {
              const char *return_value_logtime_18;
              return_value_logtime_18=logtime();
              logprint("%s %s:%d received headers too long: %u\n", return_value_logtime_18, (const void *)"stream_thread", 168, stream.header_len);
              _disconnect((enum anonymous_14)DISCONNECT, (enum anonymous_0)LOCAL_DISCONNECT);
            }

            static signed int endtok;
            if(stream.header_len >= 2ul && ((signed int)c == 10 || (signed int)c == 13))
            {
              endtok = endtok + 1;
              if(endtok == 4)
              {
                stream.header[(signed long int)stream.header_len] = (char)0;
                if((signed int)loglevel_link1 >= lINFO)
                {
                  return_value_logtime_19=logtime();
                  logprint("%s %s:%d headers: len: %d\n%s\n", return_value_logtime_19, (const void *)"stream_thread", 176, stream.header_len, stream.header);
                }

                stream.state = (enum anonymous_14)(stream.cont_wait != (_Bool)0 ? STREAMING_WAIT : STREAMING_BUFFERING);
                wake_controller();
              }

            }

            else
              endtok = 0;
            pthread_mutex_unlock(&streambuf->mutex);
            continue;
          }

          if(stream.meta_next == 0u && !(stream.meta_interval == 0u))
          {
            if(stream.meta_left == 0u)
            {
              unsigned char stream_thread__1__1__4__3__2__1__c;
              signed int stream_thread__1__1__4__3__2__1__n;
              signed long int return_value_recv_20;
              return_value_recv_20=recv(fd, (void *)&stream_thread__1__1__4__3__2__1__c, (unsigned long int)1, 0);
              stream_thread__1__1__4__3__2__1__n = (signed int)return_value_recv_20;
              if(!(stream_thread__1__1__4__3__2__1__n >= 1))
              {
                if(!(stream_thread__1__1__4__3__2__1__n >= 0))
                {
                  return_value___errno_location_21=__errno_location();
                  if(*return_value___errno_location_21 == 11)
                  {
                    pthread_mutex_unlock(&streambuf->mutex);
                    continue;
                  }

                }

                if((signed int)loglevel_link1 >= lINFO)
                {
                  return_value_logtime_22=logtime();
                  char *tmp_if_expr_25;
                  if(!(stream_thread__1__1__4__3__2__1__n == 0))
                  {
                    return_value___errno_location_23=__errno_location();
                    return_value_strerror_24=strerror(*return_value___errno_location_23);
                    tmp_if_expr_25 = return_value_strerror_24;
                  }

                  else
                    tmp_if_expr_25 = "closed";
                  logprint("%s %s:%d error reading icy meta: %s\n", return_value_logtime_22, (const void *)"stream_thread", 200, tmp_if_expr_25);
                }

                _disconnect((enum anonymous_14)STOPPED, (enum anonymous_0)LOCAL_DISCONNECT);
                pthread_mutex_unlock(&streambuf->mutex);
                continue;
              }

              stream.meta_left = (unsigned int)(16 * (signed int)stream_thread__1__1__4__3__2__1__c);
              stream.header_len = (unsigned long int)0;
            }

            if(!(stream.meta_left == 0u))
            {
              signed int stream_thread__1__1__4__3__2__2__n;
              signed long int return_value_recv_26;
              return_value_recv_26=recv(fd, (void *)(stream.header + (signed long int)stream.header_len), (unsigned long int)stream.meta_left, 0);
              stream_thread__1__1__4__3__2__2__n = (signed int)return_value_recv_26;
              if(!(stream_thread__1__1__4__3__2__2__n >= 1))
              {
                if(!(stream_thread__1__1__4__3__2__2__n >= 0))
                {
                  return_value___errno_location_27=__errno_location();
                  if(*return_value___errno_location_27 == 11)
                  {
                    pthread_mutex_unlock(&streambuf->mutex);
                    continue;
                  }

                }

                if((signed int)loglevel_link1 >= lINFO)
                {
                  return_value_logtime_28=logtime();
                  char *tmp_if_expr_31;
                  if(!(stream_thread__1__1__4__3__2__2__n == 0))
                  {
                    return_value___errno_location_29=__errno_location();
                    return_value_strerror_30=strerror(*return_value___errno_location_29);
                    tmp_if_expr_31 = return_value_strerror_30;
                  }

                  else
                    tmp_if_expr_31 = "closed";
                  logprint("%s %s:%d error reading icy meta: %s\n", return_value_logtime_28, (const void *)"stream_thread", 217, tmp_if_expr_31);
                }

                _disconnect((enum anonymous_14)STOPPED, (enum anonymous_0)LOCAL_DISCONNECT);
                pthread_mutex_unlock(&streambuf->mutex);
                continue;
              }

              stream.meta_left = stream.meta_left - (unsigned int)stream_thread__1__1__4__3__2__2__n;
              stream.header_len = stream.header_len + (unsigned long int)stream_thread__1__1__4__3__2__2__n;
            }

            if(stream.meta_left == 0u)
            {
              if(!(stream.header_len == 0ul))
              {
                stream.header[(signed long int)stream.header_len] = (char)0;
                if((signed int)loglevel_link1 >= lINFO)
                {
                  return_value_logtime_32=logtime();
                  logprint("%s %s:%d icy meta: len: %u\n%s\n", return_value_logtime_32, (const void *)"stream_thread", 229, stream.header_len, stream.header);
                }

                stream.meta_send = (_Bool)1;
                wake_controller();
              }

              stream.meta_next = stream.meta_interval;
              pthread_mutex_unlock(&streambuf->mutex);
              continue;
            }

          }

          else
          {
            signed int stream_thread__1__1__4__3__3__n;
            unsigned int return_value__buf_space_33;
            return_value__buf_space_33=_buf_space(streambuf);
            unsigned int return_value__buf_cont_write_34;
            return_value__buf_cont_write_34=_buf_cont_write(streambuf);
            unsigned int tmp_if_expr_37;
            if(!(return_value__buf_space_33 >= return_value__buf_cont_write_34))
            {
              return_value__buf_space_35=_buf_space(streambuf);
              tmp_if_expr_37 = return_value__buf_space_35;
            }

            else
            {
              return_value__buf_cont_write_36=_buf_cont_write(streambuf);
              tmp_if_expr_37 = return_value__buf_cont_write_36;
            }
            space = (unsigned long int)tmp_if_expr_37;
            if(!(stream.meta_interval == 0u))
              space = space < (unsigned long int)stream.meta_next ? space : (unsigned long int)stream.meta_next;

            signed long int return_value_recv_38;
            return_value_recv_38=recv(fd, (void *)streambuf->writep, space, 0);
            stream_thread__1__1__4__3__3__n = (signed int)return_value_recv_38;
            if(stream_thread__1__1__4__3__3__n == 0)
            {
              if((signed int)loglevel_link1 >= lINFO)
              {
                return_value_logtime_39=logtime();
                logprint("%s %s:%d end of stream\n", return_value_logtime_39, (const void *)"stream_thread", 249);
              }

              _disconnect((enum anonymous_14)DISCONNECT, (enum anonymous_0)DISCONNECT_OK);
            }

            if(!(stream_thread__1__1__4__3__3__n >= 0))
            {
              return_value___errno_location_43=__errno_location();
              if(!(*return_value___errno_location_43 == 11))
              {
                if((signed int)loglevel_link1 >= lINFO)
                {
                  return_value_logtime_40=logtime();
                  return_value___errno_location_41=__errno_location();
                  return_value_strerror_42=strerror(*return_value___errno_location_41);
                  logprint("%s %s:%d error reading: %s\n", return_value_logtime_40, (const void *)"stream_thread", 253, return_value_strerror_42);
                }

                _disconnect((enum anonymous_14)DISCONNECT, (enum anonymous_0)REMOTE_DISCONNECT);
              }

            }

            if(stream_thread__1__1__4__3__3__n >= 1)
            {
              _buf_inc_writep(streambuf, (unsigned int)stream_thread__1__1__4__3__3__n);
              stream.bytes = stream.bytes + (unsigned long int)stream_thread__1__1__4__3__3__n;
              if(!(stream.meta_interval == 0u))
                stream.meta_next = stream.meta_next - (unsigned int)stream_thread__1__1__4__3__3__n;

            }

            if((signed int)stream.state == STREAMING_BUFFERING && !((unsigned long int)stream.threshold >= stream.bytes))
            {
              stream.state = (enum anonymous_14)STREAMING_HTTP;
              wake_controller();
            }

            if((signed int)loglevel_link1 >= lSDEBUG)
            {
              return_value_logtime_44=logtime();
              logprint("%s %s:%d streambuf read %d bytes\n", return_value_logtime_44, (const void *)"stream_thread", 270, stream_thread__1__1__4__3__3__n);
            }

          }
        }

        pthread_mutex_unlock(&streambuf->mutex);
      }

      else
        if((signed int)loglevel_link1 >= lSDEBUG)
        {
          return_value_logtime_45=logtime();
          logprint("%s %s:%d poll timeout\n", return_value_logtime_45, (const void *)"stream_thread", 278);
        }

    }
  }
  return NULL;
}

// test_open
// file squeezelite.h line 607
_Bool test_open(const char *device, unsigned int *rates)
{
  struct PaStreamParameters outputParameters;
  signed int err;
  unsigned int ref[16l] = { (unsigned int)384000, (unsigned int)352800, (unsigned int)192000, (unsigned int)176400, (unsigned int)96000, (unsigned int)88200, (unsigned int)48000, (unsigned int)44100, (unsigned int)32000, (unsigned int)24000, (unsigned int)22500, (unsigned int)16000, (unsigned int)12000, (unsigned int)11025, (unsigned int)8000, (unsigned int)0 };
  signed int device_id;
  signed int i;
  signed int ind;
  device_id=pa_device_id(device);
  const char *return_value_logtime_1;
  if(device_id == -1)
  {
    if((signed int)loglevel_link3 >= lINFO)
    {
      return_value_logtime_1=logtime();
      logprint("%s %s:%d device %s not found\n", return_value_logtime_1, (const void *)"test_open", 116, device);
    }

    return (_Bool)0;
  }

  outputParameters.device = device_id;
  outputParameters.channelCount = 2;
  outputParameters.sampleFormat = (unsigned long int)0x00000002;
  double tmp_if_expr_3;
  const struct PaDeviceInfo *return_value_Pa_GetDeviceInfo_2;
  if(!(output.latency == 0u))
    tmp_if_expr_3 = (double)output.latency / (double)1000;

  else
  {
    return_value_Pa_GetDeviceInfo_2=Pa_GetDeviceInfo(outputParameters.device);
    tmp_if_expr_3 = return_value_Pa_GetDeviceInfo_2->defaultHighOutputLatency;
  }
  outputParameters.suggestedLatency = tmp_if_expr_3;
  outputParameters.hostApiSpecificStreamInfo = (void *)0;
  i = 0;
  ind = 0;
  for( ; !(ref[(signed long int)i] == 0u); i = i + 1)
  {
    err=Pa_OpenStream(&pa.stream, (const struct PaStreamParameters *)(void *)0, &outputParameters, (double)ref[(signed long int)i], (unsigned long int)0, (unsigned long int)0, pa_callback, (void *)0);
    if(err == 0)
    {
      Pa_CloseStream(pa.stream);
      signed int tmp_post_4 = ind;
      ind = ind + 1;
      rates[(signed long int)tmp_post_4] = ref[(signed long int)i];
    }

  }
  const char *return_value_logtime_5;
  if(*rates == 0u)
  {
    if((signed int)loglevel_link3 >= lWARN)
    {
      return_value_logtime_5=logtime();
      logprint("%s %s:%d no available rate found\n", return_value_logtime_5, (const void *)"test_open", 139);
    }

    return (_Bool)0;
  }

  pa.stream = (void *)0;
  return (_Bool)1;
}

// to_gain
// file squeezelite.h line 622
inline signed int to_gain(float f)
{
  return (signed int)(f * 65536.0F);
}

// touch_memory
// file squeezelite.h line 401
void touch_memory(unsigned char *buf, unsigned long int size)
{
  unsigned char *ptr = buf;
  signed long int return_value_sysconf_1;
  for( ; !(ptr >= buf + (signed long int)size); ptr = ptr + return_value_sysconf_1)
  {
    *ptr = (unsigned char)0;
    return_value_sysconf_1=sysconf(30);
  }
}

// unpack32le
// file dsd.c line 93
static unsigned int unpack32le(const unsigned char *p)
{
  return (unsigned int)p[(signed long int)3] << 24 | (unsigned int)p[(signed long int)2] << 16 | (unsigned int)p[(signed long int)1] << 8 | (unsigned int)p[(signed long int)0];
}

// unpack64be
// file dsd.c line 81
static unsigned long int unpack64be(const unsigned char *p)
{
  return (unsigned long int)p[(signed long int)0] << 56 | (unsigned long int)p[(signed long int)1] << 48 | (unsigned long int)p[(signed long int)2] << 40 | (unsigned long int)p[(signed long int)3] << 32 | (unsigned long int)p[(signed long int)4] << 24 | (unsigned long int)p[(signed long int)5] << 16 | (unsigned long int)p[(signed long int)6] << 8 | (unsigned long int)p[(signed long int)7];
}

// unpack64le
// file dsd.c line 87
static unsigned long int unpack64le(const unsigned char *p)
{
  return (unsigned long int)p[(signed long int)7] << 56 | (unsigned long int)p[(signed long int)6] << 48 | (unsigned long int)p[(signed long int)5] << 40 | (unsigned long int)p[(signed long int)4] << 32 | (unsigned long int)p[(signed long int)3] << 24 | (unsigned long int)p[(signed long int)2] << 16 | (unsigned long int)p[(signed long int)1] << 8 | (unsigned long int)p[(signed long int)0];
}

// unpackN
// file squeezelite.h line 385
unsigned int unpackN(unsigned int *src)
{
  unsigned char *ptr = (unsigned char *)src;
  return (unsigned int)((signed int)*ptr << 24 | (signed int)ptr[(signed long int)1] << 16 | (signed int)ptr[(signed long int)2] << 8 | (signed int)ptr[(signed long int)3]);
}

// unpackn
// file utils.c line 305
unsigned short int unpackn(unsigned short int *src)
{
  unsigned char *ptr = (unsigned char *)src;
  return (unsigned short int)((signed int)*ptr << 8 | (signed int)ptr[(signed long int)1]);
}

// update_dop
// file squeezelite.h line 637
void update_dop(unsigned int *ptr, unsigned int frames, _Bool invert)
{
  unsigned int tmp_post_1;
  unsigned int tmp_post_2;
  static unsigned int marker = (unsigned int)0x05;
  if(invert == (_Bool)0)
    do
    {
      tmp_post_1 = frames;
      frames = frames - 1u;
      if(tmp_post_1 == 0u)
        break;

      unsigned int scaled_marker = marker << 24;
      *ptr = *ptr & (unsigned int)0x00FFFFFF | scaled_marker;
      ptr = ptr + 1l;
      *ptr = *ptr & (unsigned int)0x00FFFFFF | scaled_marker;
      ptr = ptr + 1l;
      marker = (unsigned int)(0x05 + 0xFA) - marker;
    }
    while((_Bool)1);

  else
    do
    {
      tmp_post_2 = frames;
      frames = frames - 1u;
      if(tmp_post_2 == 0u)
        break;

      unsigned int update_dop__1__2__1__scaled_marker = marker << 24;
      *ptr = ~(*ptr) & (unsigned int)0x00FFFFFF | update_dop__1__2__1__scaled_marker;
      ptr = ptr + 1l;
      *ptr = ~(*ptr) & (unsigned int)0x00FFFFFF | update_dop__1__2__1__scaled_marker;
      ptr = ptr + 1l;
      marker = (unsigned int)(0x05 + 0xFA) - marker;
    }
    while((_Bool)1);
}

// usage
// file main.c line 42
static void usage(const char *argv0)
{
  printf("Squeezelite v1.8, Copyright 2012-2015 Adrian Smith. See -t for license terms\nUsage: %s [options]\n  -s <server>[:<port>]\tConnect to specified server, otherwise uses autodiscovery to find server\n  -o <output device>\tSpecify output device, default \"default\", - = output to stdout\n  -l \t\t\tList output devices\n  -a <l>\t\tSpecify Portaudio params to open output device, l = target latency in ms\n  -a <f>\t\tSpecify sample format (16|24|32) of output file when using -o - to output samples to stdout (interleaved little endian only)\n  -b <stream>:<output>\tSpecify internal Stream and Output buffer sizes in Kbytes\n  -c <codec1>,<codec2>\tRestrict codecs to those specified, otherwise load all available codecs; known codecs: flac,pcm,mp3,ogg,aac,wma,alac,dsd (mad,mpg for specific mp3 codec)\n  -C <timeout>\t\tClose output device when idle after timeout seconds, default is to keep it open while player is 'on'\n  -d <log>=<level>\tSet logging level, logs: all|slimproto|stream|decode|output|ir, level: info|debug|sdebug\n  -e <codec1>,<codec2>\tExplicitly exclude native support of one or more codecs; known codecs: flac,pcm,mp3,ogg,aac,wma,alac,dsd (mad,mpg for specific mp3 codec)\n  -f <logfile>\t\tWrite debug to logfile\n  -i [<filename>]\tEnable lirc remote control support (lirc config file ~/.lircrc used if filename not specified)\n  -m <mac addr>\t\tSet mac address, format: ab:cd:ef:12:34:56\n  -M <modelname>\tSet the squeezelite player model name sent to the server (default: SqueezeLite)\n  -n <name>\t\tSet the player name\n  -N <filename>\t\tStore player name in filename to allow server defined name changes to be shared between servers (not supported with -n)\n  -P <filename>\t\tStore the process id (PID) in filename\n  -r <rates>[:<delay>]\tSample rates supported, allows output to be off when squeezelite is started; rates = <maxrate>|<minrate>-<maxrate>|<rate1>,<rate2>,<rate3>; delay = optional delay switching rates in ms\n  -R -u [params]\tResample, params = <recipe>:<flags>:<attenuation>:<precision>:<passband_end>:<stopband_start>:<phase_response>,\n  \t\t\t recipe = (v|h|m|l|q)(L|I|M)(s) [E|X], E = exception - resample only if native rate not supported, X = async - resample to max rate for device, otherwise to max sync rate\n  \t\t\t flags = num in hex,\n  \t\t\t attenuation = attenuation in dB to apply (default is -1db if not explicitly set),\n  \t\t\t precision = number of bits precision (NB. HQ = 20. VHQ = 28),\n  \t\t\t passband_end = number in percent (0dB pt. bandwidth to preserve. nyquist = 100%%),\n  \t\t\t stopband_start = number in percent (Aliasing/imaging control. > passband_end),\n  \t\t\t phase_response = 0-100 (0 = minimum / 50 = linear / 100 = maximum)\n  -D [delay]\t\tOutput device supports DSD over PCM (DoP), delay = optional delay switching between PCM and DoP in ms\n  -v \t\t\tVisualiser support\n  -z \t\t\tDaemonize\n  -t \t\t\tLicense terms\n  -? \t\t\tDisplay this help text\n\nBuild options: LINUX PORTAUDIO EVENTFD RESAMPLE FFMPEG VISEXPORT IR DSD LINKALL\n\n", argv0);
}

// vis_stop
// file squeezelite.h line 628
void vis_stop(void)
{
  if(!(vis_mmap == ((struct vis_t *)NULL)))
  {
    pthread_rwlock_wrlock(&vis_mmap->rwlock);
    vis_mmap->running = (_Bool)0;
    pthread_rwlock_unlock(&vis_mmap->rwlock);
  }

}

// vorbis_close
// file vorbis.c line 264
static void vorbis_close(void)
{
  if(!(v->opened == (_Bool)0))
  {
    ov_clear(v->vf);
    v->opened = (_Bool)0;
  }

  free((void *)v->vf);
  v->vf = (struct OggVorbis_File *)(void *)0;
}

// vorbis_decode
// file vorbis.c line 103
static enum anonymous_23 vorbis_decode(void)
{
  _Bool end;
  unsigned int frames;
  signed int bytes;
  signed int s;
  signed int n;
  unsigned char *write_buf;
  pthread_mutex_lock(&streambuf->mutex);
  if(!(decode.direct == (_Bool)0))
    pthread_mutex_lock(&outputbuf->mutex);

  end = (signed int)stream.state <= DISCONNECT;
  unsigned int return_value__buf_space_3;
  unsigned int return_value__buf_cont_write_4;
  if(!(decode.direct == (_Bool)0))
  {
    unsigned int return_value__buf_space_1;
    return_value__buf_space_1=_buf_space(outputbuf);
    unsigned int return_value__buf_cont_write_2;
    return_value__buf_cont_write_2=_buf_cont_write(outputbuf);
    unsigned int tmp_if_expr_5;
    if(!(return_value__buf_space_1 >= return_value__buf_cont_write_2))
    {
      return_value__buf_space_3=_buf_space(outputbuf);
      tmp_if_expr_5 = return_value__buf_space_3;
    }

    else
    {
      return_value__buf_cont_write_4=_buf_cont_write(outputbuf);
      tmp_if_expr_5 = return_value__buf_cont_write_4;
    }
    frames = tmp_if_expr_5 / (unsigned int)8;
  }

  if(decode.direct == (_Bool)0)
    frames = process_link5.max_in_frames;

  const char *return_value_logtime_6;
  const char *return_value_logtime_7;
  const char *return_value_logtime_8;
  unsigned int tmp_post_10;
  unsigned int tmp_post_11;
  const char *return_value_logtime_12;
  const char *return_value_logtime_13;
  const char *return_value_logtime_14;
  const char *return_value_logtime_15;
  if(frames == 0u && !(end == (_Bool)0))
  {
    if(!(decode.direct == (_Bool)0))
      pthread_mutex_unlock(&outputbuf->mutex);

    pthread_mutex_unlock(&streambuf->mutex);
    return (enum anonymous_23)DECODE_COMPLETE;
  }

  else
  {
    static signed int vorbis_decode__1__channels;
    if(!(decode.new_stream == (_Bool)0))
    {
      struct anonymous_75 cbs;
      signed int err;
      struct vorbis_info *info;
      cbs.read_func = _read_cb;
      cbs.seek_func = (signed int (*)(void *, signed long int, signed int))(void *)0;
      cbs.close_func = (signed int (*)(void *))(void *)0;
      cbs.tell_func = (signed long int (*)(void *))(void *)0;
      err=ov_open_callbacks((void *)streambuf, v->vf, (const char *)(void *)0, (signed long int)0, cbs);
      if(!(err >= 0))
      {
        if((signed int)loglevel_link9 >= lWARN)
        {
          return_value_logtime_6=logtime();
          logprint("%s %s:%d open_callbacks error: %d\n", return_value_logtime_6, (const void *)"vorbis_decode", 141, err);
        }

        if(!(decode.direct == (_Bool)0))
          pthread_mutex_unlock(&outputbuf->mutex);

        pthread_mutex_unlock(&streambuf->mutex);
        return (enum anonymous_23)DECODE_COMPLETE;
      }

      v->opened = (_Bool)1;
      info=ov_info(v->vf, -1);
      if((signed int)loglevel_link9 >= lINFO)
      {
        return_value_logtime_7=logtime();
        logprint("%s %s:%d setting track_start\n", return_value_logtime_7, (const void *)"vorbis_decode", 150);
      }

      if(decode.direct == (_Bool)0)
        pthread_mutex_lock(&outputbuf->mutex);

      output.next_sample_rate=decode_newstream((unsigned int)info->rate, output.supported_rates);
      output.next_dop = (_Bool)0;
      output.track_start = outputbuf->writep;
      if(!(output.fade_mode == /*enum*/FADE_NONE))
        _checkfade((_Bool)1);

      decode.new_stream = (_Bool)0;
      if(decode.direct == (_Bool)0)
        pthread_mutex_unlock(&outputbuf->mutex);

      if(decode.direct == (_Bool)0)
        frames = process_link5.max_in_frames;

      vorbis_decode__1__channels = info->channels;
      if(vorbis_decode__1__channels >= 3)
      {
        if((signed int)loglevel_link9 >= lWARN)
        {
          return_value_logtime_8=logtime();
          logprint("%s %s:%d too many channels: %d\n", return_value_logtime_8, (const void *)"vorbis_decode", 166, vorbis_decode__1__channels);
        }

        if(!(decode.direct == (_Bool)0))
          pthread_mutex_unlock(&outputbuf->mutex);

        pthread_mutex_unlock(&streambuf->mutex);
        return (enum anonymous_23)DECODE_ERROR;
      }

    }

    bytes = (signed int)(frames * (unsigned int)2 * (unsigned int)vorbis_decode__1__channels);
    if(!(decode.direct == (_Bool)0))
      write_buf = outputbuf->writep;

    if(decode.direct == (_Bool)0)
      write_buf = process_link5.inbuf;

    {
      signed long int return_value_ov_read_9;
      return_value_ov_read_9=ov_read(v->vf, (char *)write_buf, bytes, 0, 2, 1, &s);
      n = (signed int)return_value_ov_read_9;
    }
    if(n >= 1)
    {
      unsigned int count;
      signed short int *iptr;
      signed int *vorbis_decode__1__9__optr;
      frames = (unsigned int)((n / 2) / vorbis_decode__1__channels);
      count = frames * (unsigned int)vorbis_decode__1__channels;
      iptr = (signed short int *)write_buf + (signed long int)count;
      vorbis_decode__1__9__optr = (signed int *)write_buf + (signed long int)(frames * (unsigned int)2);
      if(vorbis_decode__1__channels == 2)
        do
        {
          tmp_post_10 = count;
          count = count - 1u;
          if(tmp_post_10 == 0u)
            break;

          vorbis_decode__1__9__optr = vorbis_decode__1__9__optr - 1l;
          iptr = iptr - 1l;
          *vorbis_decode__1__9__optr = (signed int)*iptr << 16;
        }
        while((_Bool)1);

      else
        if(vorbis_decode__1__channels == 1)
          do
          {
            tmp_post_11 = count;
            count = count - 1u;
            if(tmp_post_11 == 0u)
              break;

            vorbis_decode__1__9__optr = vorbis_decode__1__9__optr - 1l;
            iptr = iptr - 1l;
            *vorbis_decode__1__9__optr = (signed int)*iptr << 16;
            vorbis_decode__1__9__optr = vorbis_decode__1__9__optr - 1l;
            *vorbis_decode__1__9__optr = (signed int)*iptr << 16;
          }
          while((_Bool)1);

      if(!(decode.direct == (_Bool)0))
        _buf_inc_writep(outputbuf, frames * (unsigned int)8);

      if(decode.direct == (_Bool)0)
        process_link5.in_frames = frames;

      if((signed int)loglevel_link9 >= lSDEBUG)
      {
        return_value_logtime_12=logtime();
        logprint("%s %s:%d wrote %u frames\n", return_value_logtime_12, (const void *)"vorbis_decode", 224, frames);
      }

    }

    else
      if(n == 0)
      {
        if((signed int)loglevel_link9 >= lINFO)
        {
          return_value_logtime_13=logtime();
          logprint("%s %s:%d end of stream\n", return_value_logtime_13, (const void *)"vorbis_decode", 228);
        }

        if(!(decode.direct == (_Bool)0))
          pthread_mutex_unlock(&outputbuf->mutex);

        pthread_mutex_unlock(&streambuf->mutex);
        return (enum anonymous_23)DECODE_COMPLETE;
      }

      else
        if(n == -3)
        {
          if((signed int)loglevel_link9 >= lDEBUG)
          {
            return_value_logtime_14=logtime();
            logprint("%s %s:%d hole in stream\n", return_value_logtime_14, (const void *)"vorbis_decode", 236);
          }

        }

        else
        {
          if((signed int)loglevel_link9 >= lINFO)
          {
            return_value_logtime_15=logtime();
            logprint("%s %s:%d ov_read error: %d\n", return_value_logtime_15, (const void *)"vorbis_decode", 240, n);
          }

          if(!(decode.direct == (_Bool)0))
            pthread_mutex_unlock(&outputbuf->mutex);

          pthread_mutex_unlock(&streambuf->mutex);
          return (enum anonymous_23)DECODE_COMPLETE;
        }
    if(!(decode.direct == (_Bool)0))
      pthread_mutex_unlock(&outputbuf->mutex);

    pthread_mutex_unlock(&streambuf->mutex);
    return (enum anonymous_23)DECODE_RUNNING;
  }
}

// vorbis_open
// file vorbis.c line 252
static void vorbis_open(unsigned char size, unsigned char rate, unsigned char chan, unsigned char endianness)
{
  if(v->vf == ((struct OggVorbis_File *)NULL))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct OggVorbis_File) /*944ul*/  + (unsigned long int)128);
    v->vf = (struct OggVorbis_File *)return_value_malloc_1;
    memset((void *)v->vf, 0, sizeof(struct OggVorbis_File) /*944ul*/  + (unsigned long int)128);
  }

  else
    if(!(v->opened == (_Bool)0))
    {
      ov_clear(v->vf);
      v->opened = (_Bool)0;
    }

}

// wait_readwake
// file squeezelite.h line 382
enum anonymous_9 wait_readwake(struct pollfd *handles, signed int timeout)
{
  signed int return_value_poll_1;
  return_value_poll_1=poll(handles, (unsigned long int)2, timeout);
  if(return_value_poll_1 >= 1)
  {
    if(!(handles->revents == 0))
      return (enum anonymous_9)EVENT_READ;

    if(!((handles + 1l)->revents == 0))
    {
      unsigned long int val;
      eventfd_read((handles + (signed long int)1)->fd, &val);
      return (enum anonymous_9)EVENT_WAKE;
    }

  }

  return (enum anonymous_9)EVENT_TIMEOUT;
}

// wake_controller
// file slimproto.c line 729
void wake_controller(void)
{
  eventfd_write(wake_e, (unsigned long int)1);
}

// write_cb
// file flac.c line 104
static enum anonymous_42 write_cb(const struct anonymous_43 *decoder, const struct anonymous_45 *frame, const signed int * const *buffer, void *client_data)
{
  unsigned long int frames = (unsigned long int)frame->header.blocksize;
  unsigned int bits_per_sample = frame->header.bits_per_sample;
  unsigned int write_cb__1__channels = frame->header.channels;
  signed int *lptr = (signed int *)buffer[(signed long int)0];
  signed int *rptr = (signed int *)buffer[(signed long int)(write_cb__1__channels > (unsigned int)1 ? 1 : 0)];
  const char *return_value_logtime_1;
  _Bool return_value_is_flac_dop_3;
  const char *return_value_logtime_2;
  if(!(decode.new_stream == (_Bool)0))
  {
    pthread_mutex_lock(&outputbuf->mutex);
    if((signed int)loglevel_link6 >= lINFO)
    {
      return_value_logtime_1=logtime();
      logprint("%s %s:%d setting track_start\n", return_value_logtime_1, (const void *)"write_cb", 116);
    }

    output.track_start = outputbuf->writep;
    decode.new_stream = (_Bool)0;
    _Bool tmp_if_expr_4;
    if(bits_per_sample == 24u && !(output.has_dop == (_Bool)0))
    {
      return_value_is_flac_dop_3=is_flac_dop((unsigned int *)lptr, (unsigned int *)rptr, (unsigned int)frames);
      tmp_if_expr_4 = return_value_is_flac_dop_3 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      if((signed int)loglevel_link6 >= lINFO)
      {
        return_value_logtime_2=logtime();
        logprint("%s %s:%d file contains DOP\n", return_value_logtime_2, (const void *)"write_cb", 122);
      }

      output.next_dop = (_Bool)1;
      output.next_sample_rate = frame->header.sample_rate;
      output.fade = (enum anonymous_3)FADE_INACTIVE;
    }

    else
    {
      output.next_sample_rate=decode_newstream(frame->header.sample_rate, output.supported_rates);
      output.next_dop = (_Bool)0;
      if(!(output.fade_mode == /*enum*/FADE_NONE))
        _checkfade((_Bool)1);

    }
    pthread_mutex_unlock(&outputbuf->mutex);
  }

  if(!(decode.direct == (_Bool)0))
    pthread_mutex_lock(&outputbuf->mutex);

  unsigned int return_value__buf_space_7;
  unsigned int return_value__buf_cont_write_8;
  unsigned int tmp_post_10;
  unsigned int tmp_post_15;
  unsigned int tmp_post_20;
  unsigned int tmp_post_25;
  const char *return_value_logtime_31;
  while(frames >= 1ul)
  {
    unsigned int write_cb__1__2__f;
    unsigned int count;
    signed int *write_cb__1__2__optr;
    if(!(decode.direct == (_Bool)0))
    {
      write_cb__1__2__optr = (signed int *)outputbuf->writep;
      unsigned int return_value__buf_space_5;
      return_value__buf_space_5=_buf_space(outputbuf);
      unsigned int return_value__buf_cont_write_6;
      return_value__buf_cont_write_6=_buf_cont_write(outputbuf);
      unsigned int tmp_if_expr_9;
      if(!(return_value__buf_space_5 >= return_value__buf_cont_write_6))
      {
        return_value__buf_space_7=_buf_space(outputbuf);
        tmp_if_expr_9 = return_value__buf_space_7;
      }

      else
      {
        return_value__buf_cont_write_8=_buf_cont_write(outputbuf);
        tmp_if_expr_9 = return_value__buf_cont_write_8;
      }
      write_cb__1__2__f = tmp_if_expr_9 / (unsigned int)8;
    }

    if(decode.direct == (_Bool)0)
    {
      write_cb__1__2__optr = (signed int *)process_link2.inbuf;
      write_cb__1__2__f = process_link2.max_in_frames;
    }

    write_cb__1__2__f = (unsigned int)((unsigned long int)write_cb__1__2__f < frames ? (unsigned long int)write_cb__1__2__f : frames);
    count = write_cb__1__2__f;
    if(bits_per_sample == 8u)
      do
      {
        tmp_post_10 = count;
        count = count - 1u;
        if(tmp_post_10 == 0u)
          break;

        signed int *tmp_post_11 = write_cb__1__2__optr;
        write_cb__1__2__optr = write_cb__1__2__optr + 1l;
        signed int *tmp_post_12 = lptr;
        lptr = lptr + 1l;
        *tmp_post_11 = *tmp_post_12 << 24;
        signed int *tmp_post_13 = write_cb__1__2__optr;
        write_cb__1__2__optr = write_cb__1__2__optr + 1l;
        signed int *tmp_post_14 = rptr;
        rptr = rptr + 1l;
        *tmp_post_13 = *tmp_post_14 << 24;
      }
      while((_Bool)1);

    else
      if(bits_per_sample == 16u)
        do
        {
          tmp_post_15 = count;
          count = count - 1u;
          if(tmp_post_15 == 0u)
            break;

          signed int *tmp_post_16 = write_cb__1__2__optr;
          write_cb__1__2__optr = write_cb__1__2__optr + 1l;
          signed int *tmp_post_17 = lptr;
          lptr = lptr + 1l;
          *tmp_post_16 = *tmp_post_17 << 16;
          signed int *tmp_post_18 = write_cb__1__2__optr;
          write_cb__1__2__optr = write_cb__1__2__optr + 1l;
          signed int *tmp_post_19 = rptr;
          rptr = rptr + 1l;
          *tmp_post_18 = *tmp_post_19 << 16;
        }
        while((_Bool)1);

      else
        if(bits_per_sample == 24u)
          do
          {
            tmp_post_20 = count;
            count = count - 1u;
            if(tmp_post_20 == 0u)
              break;

            signed int *tmp_post_21 = write_cb__1__2__optr;
            write_cb__1__2__optr = write_cb__1__2__optr + 1l;
            signed int *tmp_post_22 = lptr;
            lptr = lptr + 1l;
            *tmp_post_21 = *tmp_post_22 << 8;
            signed int *tmp_post_23 = write_cb__1__2__optr;
            write_cb__1__2__optr = write_cb__1__2__optr + 1l;
            signed int *tmp_post_24 = rptr;
            rptr = rptr + 1l;
            *tmp_post_23 = *tmp_post_24 << 8;
          }
          while((_Bool)1);

        else
          if(bits_per_sample == 32u)
            do
            {
              tmp_post_25 = count;
              count = count - 1u;
              if(tmp_post_25 == 0u)
                break;

              signed int *tmp_post_26 = write_cb__1__2__optr;
              write_cb__1__2__optr = write_cb__1__2__optr + 1l;
              signed int *tmp_post_27 = lptr;
              lptr = lptr + 1l;
              *tmp_post_26 = *tmp_post_27;
              signed int *tmp_post_28 = write_cb__1__2__optr;
              write_cb__1__2__optr = write_cb__1__2__optr + 1l;
              signed int *tmp_post_29 = rptr;
              rptr = rptr + 1l;
              *tmp_post_28 = *tmp_post_29;
            }
            while((_Bool)1);

          else
          {
            const char *return_value_logtime_30;
            return_value_logtime_30=logtime();
            logprint("%s %s:%d unsupported bits per sample: %u\n", return_value_logtime_30, (const void *)"write_cb", 180, bits_per_sample);
          }
    frames = frames - (unsigned long int)write_cb__1__2__f;
    if(!(decode.direct == (_Bool)0))
      _buf_inc_writep(outputbuf, write_cb__1__2__f * (unsigned int)8);

    if(decode.direct == (_Bool)0)
    {
      process_link2.in_frames = write_cb__1__2__f;
      if(!(frames == 0ul))
      {
        return_value_logtime_31=logtime();
        logprint("%s %s:%d unhandled case\n", return_value_logtime_31, (const void *)"write_cb", 191);
      }

    }

  }
  if(!(decode.direct == (_Bool)0))
    pthread_mutex_unlock(&outputbuf->mutex);

  return (enum anonymous_42)FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
}

