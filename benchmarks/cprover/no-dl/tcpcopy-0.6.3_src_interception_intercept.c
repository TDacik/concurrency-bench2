// tag-#anon#ST[*{S32(*{SYM#tag-tc_event_loop_s#}_SYM#tag-tc_event_loop_s#_)->S32}_S32(*{SYM#tag-tc_event_loop_s#}_SYM#tag-tc_event_loop_s#_)->S32_'create'||*{S32(*{SYM#tag-tc_event_loop_s#}_SYM#tag-tc_event_loop_s#_)->S32}_S32(*{SYM#tag-tc_event_loop_s#}_SYM#tag-tc_event_loop_s#_)->S32_'destroy'||*{S32(*{SYM#tag-tc_event_loop_s#}_SYM#tag-tc_event_loop_s#_|*{SYM#tag-tc_event_s#}_SYM#tag-tc_event_s#_|S32)->S32}_S32(*{SYM#tag-tc_event_loop_s#}_SYM#tag-tc_event_loop_s#_|*{SYM#tag-tc_event_s#}_SYM#tag-tc_event_s#_|S32)->S32_'add'||*{S32(*{SYM#tag-tc_event_loop_s#}_SYM#tag-tc_event_loop_s#_|*{SYM#tag-tc_event_s#}_SYM#tag-tc_event_s#_|S32)->S32}_S32(*{SYM#tag-tc_event_loop_s#}_SYM#tag-tc_event_loop_s#_|*{SYM#tag-tc_event_s#}_SYM#tag-tc_event_s#_|S32)->S32_'del'||*{S32(*{SYM#tag-tc_event_loop_s#}_SYM#tag-tc_event_loop_s#_|S64)->S32}_S32(*{SYM#tag-tc_event_loop_s#}_SYM#tag-tc_event_loop_s#_|S64)->S32_'poll'|]
// file ../event/tc_event.h line 36
struct anonymous_7;

// tag-#anon#ST[*{S8}_S8_'level'||S32'len'||U32'_pad0'|]
// file tc_log.c line 6
struct anonymous_0;

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_20;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_18;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_10;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_9;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous;

// tag-#anon#ST[S32'num'||U32'_pad0'||*{*{SYM#tag-#anon#ST[U32'online_ip'||U32'target_ip'||U16'online_port'||U16'target_port'|]#}_SYM#tag-#anon#ST[U32'online_ip'||U32'target_ip'||U16'online_port'||U16'target_port'|]#_}_*{SYM#tag-#anon#ST[U32'online_ip'||U32'target_ip'||U16'online_port'||U16'target_port'|]#}_SYM#tag-#anon#ST[U32'online_ip'||U32'target_ip'||U16'online_port'||U16'target_port'|]#__'mappings'|]
// file ../tcpcopy/tcpcopy.h line 16
struct anonymous_1;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_14;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_17;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_16;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_13;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_15;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_19;

// tag-#anon#ST[U16'source'||U16'dest'||U32'seq'||U32'ack_seq'||BF{U16}_U16_'res1'||BF{U16}_U16_'doff'||BF{U16}_U16_'fin'||BF{U16}_U16_'syn'||BF{U16}_U16_'rst'||BF{U16}_U16_'psh'||BF{U16}_U16_'ack'||BF{U16}_U16_'urg'||BF{U16}_U16_'res2'||U16'window'||U16'check'||U16'urg_ptr'|]
// file /usr/include/netinet/tcp.h line 103
struct anonymous_6;

// tag-#anon#ST[U16'th_sport'||U16'th_dport'||U32'th_seq'||U32'th_ack'||BF{U8}_U8_'th_x2'||BF{U8}_U8_'th_off'||U8'th_flags'||U16'th_win'||U16'th_sum'||U16'th_urp'|]
// file /usr/include/netinet/tcp.h line 78
struct anonymous_4;

// tag-#anon#ST[U32'online_ip'||U32'target_ip'||U16'online_port'||U16'target_port'|]
// file ../tcpcopy/tcpcopy.h line 7
struct anonymous_3;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_12;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_21;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_11;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_5;

// tag-#anon#UN[SYM#tag-#anon#ST[U16'th_sport'||U16'th_dport'||U32'th_seq'||U32'th_ack'||BF{U8}_U8_'th_x2'||BF{U8}_U8_'th_off'||U8'th_flags'||U16'th_win'||U16'th_sum'||U16'th_urp'|]#'_anon0'||SYM#tag-#anon#ST[U16'source'||U16'dest'||U32'seq'||U32'ack_seq'||BF{U16}_U16_'res1'||BF{U16}_U16_'doff'||BF{U16}_U16_'fin'||BF{U16}_U16_'syn'||BF{U16}_U16_'rst'||BF{U16}_U16_'psh'||BF{U16}_U16_'ack'||BF{U16}_U16_'urg'||BF{U16}_U16_'res2'||U16'window'||U16'check'||U16'urg_ptr'|]#'_anon1'|]
// file /usr/include/netinet/tcp.h line 76
union anonymous_2;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_8;

// tag-#anon#UN[SYM#tag-ipq_verdict_msg#'verdict'||SYM#tag-ipq_mode_msg#'mode'|]
// file /usr/include/linux/netfilter_ipv4/ip_queue.h line 51
union anonymous_22;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-hash_node_s
// file ../../src/core/tc_hash.h line 6
struct hash_node_s;

// tag-hash_table_s
// file ../../src/core/tc_hash.h line 13
struct hash_table_s;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iphdr
// file /usr/include/netinet/ip.h line 44
struct iphdr;

// tag-ipq_mode_msg
// file /usr/include/linux/netfilter_ipv4/ip_queue.h line 38
struct ipq_mode_msg;

// tag-ipq_packet_msg
// file /usr/include/linux/netfilter_ipv4/ip_queue.h line 21
struct ipq_packet_msg;

// tag-ipq_peer_msg
// file /usr/include/linux/netfilter_ipv4/ip_queue.h line 50
struct ipq_peer_msg;

// tag-ipq_verdict_msg
// file /usr/include/linux/netfilter_ipv4/ip_queue.h line 43
struct ipq_verdict_msg;

// tag-itimerval
// file /usr/include/x86_64-linux-gnu/sys/time.h line 107
struct itimerval;

// tag-link_list_s
// file ../../src/core/tc_link_list.h line 14
struct link_list_s;

// tag-link_node_s
// file ../../src/core/tc_link_list.h line 6
struct link_node_s;

// tag-msg_client_s
// file ../communication/tc_msg.h line 6
struct msg_client_s;

// tag-msg_server_s
// file ../communication/tc_msg.h line 7
struct msg_server_s;

// tag-nlmsghdr
// file /usr/include/linux/netlink.h line 42
struct nlmsghdr;

// tag-passed_ip_addr_s
// file ./intercept.h line 4
struct passed_ip_addr_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_nl
// file /usr/include/linux/netlink.h line 35
struct sockaddr_nl;

// tag-tc_event_loop_s
// file ../event/tc_event.h line 21
struct tc_event_loop_s;

// tag-tc_event_s
// file ../event/tc_event.h line 22
struct tc_event_s;

// tag-tc_event_timer_s
// file ../event/tc_event.h line 23
struct tc_event_timer_s;

// tag-tc_select_multiplex_io_s
// file ./tc_select_module.h line 6
struct tc_select_multiplex_io_s;

// tag-tc_verdict_s
// file tc_interception.c line 24
struct tc_verdict_s;

// tag-tcphdr
// file /usr/include/netinet/tcp.h line 74
struct tcphdr;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-xcopy_srv_settings
// file ./intercept.h line 11
struct xcopy_srv_settings;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// check_pack_src
// file tc_util.c line 77
signed int check_pack_src(struct anonymous_1 *transfer, unsigned int ip, unsigned short int port, signed int src_flag);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// copy_ip_packet
// file tc_util.c line 110
unsigned char * copy_ip_packet(struct iphdr *ip_header);
// copy_message
// file tc_delay.c line 11
static struct msg_server_s * copy_message(struct msg_server_s *msg);
// csum
// file tc_util.c line 123
unsigned short int csum(unsigned short int *packet, signed int pack_len);
// daemonize
// file ../../src/core/xcopy.h line 202
signed int daemonize();
// delay_table_add
// file ./tc_delay.h line 9
void delay_table_add(unsigned long int key, struct msg_server_s *msg);
// delay_table_del
// file ./tc_delay.h line 11
void delay_table_del(unsigned long int key);
// delay_table_delete_obsolete
// file ./tc_delay.h line 8
void delay_table_delete_obsolete(signed long int cur_time);
// delay_table_destroy
// file ./tc_delay.h line 12
void delay_table_destroy();
// delay_table_init
// file ./tc_delay.h line 7
void delay_table_init(unsigned long int size);
// delay_table_send
// file ./tc_delay.h line 10
void delay_table_send(unsigned long int key, signed int fd);
// dispose_netlink_packet
// file tc_interception.c line 44
static signed int dispose_netlink_packet(signed int fd, signed int verdict, unsigned long int packet_id);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// get_appropriate_port
// file tc_util.c line 16
unsigned short int get_appropriate_port(unsigned short int orig_port, unsigned short int add);
// get_key
// file ../util/tc_util.h line 13
unsigned long int get_key(unsigned int ip, unsigned short int port);
// get_link_list
// file tc_hash.c line 85
struct link_list_s * get_link_list(struct hash_table_s *table, unsigned long int key);
// get_nl_verdict_from_pool
// file tc_interception.c line 300
static struct tc_verdict_s * get_nl_verdict_from_pool(struct tc_verdict_s *verdict);
// get_port_by_rand_addition
// file tc_util.c line 32
unsigned short int get_port_by_rand_addition(unsigned short int orig_port);
// get_port_from_shift
// file tc_util.c line 48
unsigned short int get_port_from_shift(unsigned short int orig_port, unsigned short int rand_port, signed int shift_factor);
// get_resp_ip_hdr_from_pool
// file tc_interception.c line 238
static struct iphdr * get_resp_ip_hdr_from_pool(char *resp, signed int *len);
// get_slot
// file tc_hash.c line 23
static unsigned int get_slot(unsigned long int key, unsigned int size);
// get_test_pair
// file tc_util.c line 58
struct anonymous_3 * get_test_pair(struct anonymous_1 *transfer, unsigned int ip, unsigned short int port);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// hash_add
// file ../../src/core/tc_hash.h line 26
_Bool hash_add(struct hash_table_s *table, unsigned long int key, void *data);
// hash_create
// file ../../src/core/tc_hash.h line 23
struct hash_table_s * hash_create(unsigned long int size);
// hash_deep_destroy
// file tc_hash.c line 184
void hash_deep_destroy(struct hash_table_s *table);
// hash_del
// file ../../src/core/tc_hash.h line 28
_Bool hash_del(struct hash_table_s *table, unsigned long int key);
// hash_destroy
// file ../../src/core/tc_hash.h line 29
void hash_destroy(struct hash_table_s *table);
// hash_find
// file ../../src/core/tc_hash.h line 27
void * hash_find(struct hash_table_s *table, unsigned long int key);
// hash_find_node
// file tc_hash.c line 31
static struct link_node_s * hash_find_node(struct hash_table_s *table, unsigned long int key);
// hash_node_malloc
// file tc_hash.c line 5
static struct hash_node_s * hash_node_malloc(unsigned long int key, void *data);
// hash_set_timeout
// file ../../src/core/tc_hash.h line 25
void hash_set_timeout(struct hash_table_s *table, signed int t);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// inet_aton
// file /usr/include/arpa/inet.h line 73
extern signed int inet_aton(const char *, struct in_addr *);
// inet_ntoa
// file /usr/include/arpa/inet.h line 53
extern char * inet_ntoa(struct in_addr);
// interception_dispose_nl_verdict
// file tc_interception.c line 387
static void * interception_dispose_nl_verdict(void *tid);
// interception_init
// file tc_interception.c line 427
signed int interception_init(struct tc_event_loop_s *event_loop, char *ip, unsigned short int port);
// interception_over
// file tc_interception.c line 494
void interception_over();
// interception_process_msg
// file tc_interception.c line 402
static void * interception_process_msg(void *tid);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// link_list_append
// file ../../src/core/tc_link_list.h line 25
void link_list_append(struct link_list_s *l, struct link_node_s *p);
// link_list_append_by_order
// file tc_link_list.c line 81
void link_list_append_by_order(struct link_list_s *l, struct link_node_s *p);
// link_list_clear
// file ../../src/core/tc_link_list.h line 24
signed int link_list_clear(struct link_list_s *l);
// link_list_create
// file ../../src/core/tc_link_list.h line 23
struct link_list_s * link_list_create();
// link_list_first
// file ../../src/core/tc_link_list.h line 29
struct link_node_s * link_list_first(struct link_list_s *l);
// link_list_get_next
// file ../../src/core/tc_link_list.h line 33
struct link_node_s * link_list_get_next(struct link_list_s *l, struct link_node_s *p);
// link_list_is_empty
// file ../../src/core/tc_link_list.h line 34
_Bool link_list_is_empty(struct link_list_s *l);
// link_list_pop_first
// file ../../src/core/tc_link_list.h line 31
struct link_node_s * link_list_pop_first(struct link_list_s *l);
// link_list_pop_tail
// file ../../src/core/tc_link_list.h line 32
struct link_node_s * link_list_pop_tail(struct link_list_s *l);
// link_list_push
// file tc_link_list.c line 104
void link_list_push(struct link_list_s *l, struct link_node_s *p);
// link_list_remove
// file tc_link_list.c line 117
struct link_node_s * link_list_remove(struct link_list_s *l, struct link_node_s *node);
// link_list_tail
// file ../../src/core/tc_link_list.h line 30
struct link_node_s * link_list_tail(struct link_list_s *l);
// link_node_internal_free
// file ../../src/core/tc_link_list.h line 21
void link_node_internal_free(struct link_node_s *p);
// link_node_malloc
// file ../../src/core/tc_link_list.h line 20
struct link_node_s * link_node_malloc(void *data);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// output_for_debug
// file main.c line 254
static void output_for_debug();
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_5 *, const union anonymous_11 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_5 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_5 *, union anonymous_8 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_8 *, const union anonymous_11 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_8 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_8 *);
// put_nl_verdict_to_pool
// file tc_interception.c line 267
static void put_nl_verdict_to_pool(signed int fd, signed int verdict, unsigned long int packet_id);
// put_resp_header_to_pool
// file tc_interception.c line 160
static void put_resp_header_to_pool(struct iphdr *ip_header);
// rand_r
// file /usr/include/stdlib.h line 381
extern signed int rand_r(unsigned int *);
// read_args
// file main.c line 149
static signed int read_args(signed int argc, char **argv);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// release_resources
// file main.c line 24
static void release_resources();
// retrieve_ip_addr
// file main.c line 88
static signed int retrieve_ip_addr();
// route_delete_obsolete
// file tc_router.c line 15
void route_delete_obsolete(signed long int cur_time);
// router_add
// file tc_router.c line 105
void router_add(unsigned int ip, unsigned short int port, signed int fd);
// router_del
// file tc_router.c line 86
void router_del(unsigned int ip, unsigned short int port);
// router_destroy
// file tc_router.c line 216
void router_destroy();
// router_init
// file tc_router.c line 72
void router_init(unsigned long int size, signed int timeout);
// router_update
// file tc_router.c line 124
void router_update(struct iphdr *ip_header, signed int len);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_10 *, struct anonymous_10 *, struct anonymous_10 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, struct sockaddr *, unsigned int);
// set_details
// file main.c line 207
static signed int set_details();
// set_signal_handler
// file main.c line 68
static void set_signal_handler();
// setitimer
// file /usr/include/x86_64-linux-gnu/sys/time.h line 131
extern signed int setitimer(signed int, struct itimerval *, struct itimerval *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// settings_init
// file main.c line 245
static void settings_init(void);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_9 *);
// sigignore
// file main.c line 36
static signed int sigignore(signed int sig);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// signal_handler
// file main.c line 51
static void signal_handler(signed int sig);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// tc_event_add
// file ../event/tc_event.h line 74
signed int tc_event_add(struct tc_event_loop_s *loop, struct tc_event_s *ev, signed int events);
// tc_event_create
// file ../event/tc_event.h line 77
struct tc_event_s * tc_event_create(signed int fd, signed int (*reader)(struct tc_event_s *), signed int (*writer)(struct tc_event_s *));
// tc_event_create::reader_object
//
signed int reader_object(struct tc_event_s *);
// tc_event_create::writer_object
//
signed int writer_object(struct tc_event_s *);
// tc_event_del
// file ../event/tc_event.h line 75
signed int tc_event_del(struct tc_event_loop_s *loop, struct tc_event_s *ev, signed int events);
// tc_event_destroy
// file tc_event.c line 193
void tc_event_destroy(struct tc_event_s *ev);
// tc_event_loop_finish
// file ../event/tc_event.h line 72
signed int tc_event_loop_finish(struct tc_event_loop_s *loop);
// tc_event_loop_init
// file ../event/tc_event.h line 71
signed int tc_event_loop_init(struct tc_event_loop_s *loop, signed int size);
// tc_event_process_cycle
// file ../event/tc_event.h line 73
signed int tc_event_process_cycle(struct tc_event_loop_s *loop);
// tc_event_timer_add
// file tc_event.c line 203
signed int tc_event_timer_add(struct tc_event_loop_s *loop, signed long int msec, void (*handler)(struct tc_event_timer_s *));
// tc_event_timer_add::handler_object
//
void handler_object(struct tc_event_timer_s *);
// tc_event_timer_find
// file tc_event.c line 223
static signed long int tc_event_timer_find(struct tc_event_loop_s *loop);
// tc_event_timer_run
// file tc_event.c line 243
static void tc_event_timer_run(struct tc_event_loop_s *loop);
// tc_localtime
// file tc_time.c line 78
void tc_localtime(signed long int sec, struct tm *tm);
// tc_log_end
// file ../../src/core/tc_log.h line 17
void tc_log_end();
// tc_log_info
// file ../../src/core/tc_log.h line 19
void tc_log_info(signed int level, signed int err, const char *fmt, ...);
// tc_log_init
// file tc_log.c line 24
signed int tc_log_init(const char *file);
// tc_log_trace
// file tc_log.c line 97
void tc_log_trace(signed int level, signed int err, signed int flag, struct iphdr *ip_header, struct tcphdr *tcp_header);
// tc_msg_event_accept
// file tc_interception.c line 85
static signed int tc_msg_event_accept(struct tc_event_s *rev);
// tc_msg_event_process
// file tc_interception.c line 114
static signed int tc_msg_event_process(struct tc_event_s *rev);
// tc_nl_check_cleaning
// file tc_interception.c line 142
static void tc_nl_check_cleaning();
// tc_nl_event_process
// file tc_interception.c line 330
static signed int tc_nl_event_process(struct tc_event_s *rev);
// tc_nl_socket_init
// file ../communication/tc_socket.h line 23
signed int tc_nl_socket_init();
// tc_nl_socket_recv
// file ../communication/tc_socket.h line 24
signed int tc_nl_socket_recv(signed int fd, char *buffer, unsigned long int len);
// tc_raw_socket_in_init
// file tc_socket.c line 6
signed int tc_raw_socket_in_init();
// tc_raw_socket_out_init
// file tc_socket.c line 45
signed int tc_raw_socket_out_init();
// tc_raw_socket_send
// file tc_socket.c line 83
signed int tc_raw_socket_send(signed int fd, void *buf, unsigned long int len, unsigned int ip);
// tc_select_add_event
// file ./tc_select_module.h line 19
signed int tc_select_add_event(struct tc_event_loop_s *loop, struct tc_event_s *ev, signed int events);
// tc_select_create
// file ./tc_select_module.h line 17
signed int tc_select_create(struct tc_event_loop_s *loop);
// tc_select_del_event
// file ./tc_select_module.h line 20
signed int tc_select_del_event(struct tc_event_loop_s *loop, struct tc_event_s *ev, signed int events);
// tc_select_destroy
// file ./tc_select_module.h line 18
signed int tc_select_destroy(struct tc_event_loop_s *loop);
// tc_select_polling
// file ./tc_select_module.h line 21
signed int tc_select_polling(struct tc_event_loop_s *loop, signed long int to);
// tc_socket_connect
// file tc_socket.c line 253
signed int tc_socket_connect(signed int fd, unsigned int ip, unsigned short int port);
// tc_socket_init
// file ../communication/tc_socket.h line 26
signed int tc_socket_init();
// tc_socket_listen
// file ../communication/tc_socket.h line 30
signed int tc_socket_listen(signed int fd, const char *bind_ip, unsigned short int port);
// tc_socket_recv
// file ../communication/tc_socket.h line 31
signed int tc_socket_recv(signed int fd, char *buffer, signed long int len);
// tc_socket_send
// file ../communication/tc_socket.h line 32
signed int tc_socket_send(signed int fd, char *buffer, unsigned long int len);
// tc_socket_set_nodelay
// file ../communication/tc_socket.h line 28
signed int tc_socket_set_nodelay(signed int fd);
// tc_socket_set_nonblocking
// file tc_socket.c line 226
signed int tc_socket_set_nonblocking(signed int fd);
// tc_time_init
// file ../../src/core/tc_time.h line 20
void tc_time_init();
// tc_time_remove_timer
// file tc_time.c line 31
signed int tc_time_remove_timer();
// tc_time_set_timer
// file ../../src/core/tc_time.h line 18
signed int tc_time_set_timer(signed long int msec);
// tc_time_sig_alarm
// file ../../src/core/tc_time.h line 23
void tc_time_sig_alarm(signed int sig);
// tc_time_update
// file tc_time.c line 50
void tc_time_update(void);
// tcpcsum
// file tc_util.c line 145
unsigned short int tcpcsum(unsigned char *iphdr, unsigned short int *packet, signed int pack_len);
// usage
// file main.c line 131
static void usage(void);
// vsprintf
// file /usr/include/stdio.h line 379
extern signed int vsprintf(char *, const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_7
{
  // create
  signed int (*create)(struct tc_event_loop_s *);
  // destroy
  signed int (*destroy)(struct tc_event_loop_s *);
  // add
  signed int (*add)(struct tc_event_loop_s *, struct tc_event_s *, signed int);
  // del
  signed int (*del)(struct tc_event_loop_s *, struct tc_event_s *, signed int);
  // poll
  signed int (*poll)(struct tc_event_loop_s *, signed long int);
};

struct anonymous_0
{
  // level
  char *level;
  // len
  signed int len;
};

struct anonymous_20
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_18
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_10
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_9
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_1
{
  // num
  signed int num;
  // mappings
  struct anonymous_3 **mappings;
};

struct anonymous_14
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_17
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_16
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_15
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_19
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_21
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_14 _kill;
  // _timer
  struct anonymous_15 _timer;
  // _rt
  struct anonymous_16 _rt;
  // _sigchld
  struct anonymous_17 _sigchld;
  // _sigfault
  struct anonymous_18 _sigfault;
  // _sigpoll
  struct anonymous_19 _sigpoll;
  // _sigsys
  struct anonymous_20 _sigsys;
};

struct anonymous_13
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_21 _sifields;
};

struct anonymous_6
{
  // source
  unsigned short int source;
  // dest
  unsigned short int dest;
  // seq
  unsigned int seq;
  // ack_seq
  unsigned int ack_seq;
  // res1
  unsigned short int res1 : 4;
  // doff
  unsigned short int doff : 4;
  // fin
  unsigned short int fin : 1;
  // syn
  unsigned short int syn : 1;
  // rst
  unsigned short int rst : 1;
  // psh
  unsigned short int psh : 1;
  // ack
  unsigned short int ack : 1;
  // urg
  unsigned short int urg : 1;
  // res2
  unsigned short int res2 : 2;
  // window
  unsigned short int window;
  // check
  unsigned short int check;
  // urg_ptr
  unsigned short int urg_ptr;
};

struct anonymous_4
{
  // th_sport
  unsigned short int th_sport;
  // th_dport
  unsigned short int th_dport;
  // th_seq
  unsigned int th_seq;
  // th_ack
  unsigned int th_ack;
  // th_x2
  unsigned char th_x2 : 4;
  // th_off
  unsigned char th_off : 4;
  // th_flags
  unsigned char th_flags;
  // th_win
  unsigned short int th_win;
  // th_sum
  unsigned short int th_sum;
  // th_urp
  unsigned short int th_urp;
};

struct anonymous_3
{
  // online_ip
  unsigned int online_ip;
  // target_ip
  unsigned int target_ip;
  // online_port
  unsigned short int online_port;
  // target_port
  unsigned short int target_port;
};

union anonymous_12
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_13 *, void *);
};

union anonymous_11
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_5
{
  // __data
  struct anonymous __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous_2
{
  // _anon0
  struct anonymous_4 _anon0;
  // _anon1
  struct anonymous_6 _anon1;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_8
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ipq_verdict_msg
{
  // value
  unsigned int value;
  // id
  unsigned long int id;
  // data_len
  unsigned long int data_len;
  // payload
  unsigned char payload[0l];
};

struct ipq_mode_msg
{
  // value
  unsigned char value;
  // range
  unsigned long int range;
};

union anonymous_22
{
  // verdict
  struct ipq_verdict_msg verdict;
  // mode
  struct ipq_mode_msg mode;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct hash_node_s
{
  // key
  unsigned long int key;
  // visit_cnt
  unsigned int visit_cnt;
  // access_time
  signed long int access_time;
  // data
  void *data;
};

struct hash_table_s
{
  // total
  unsigned int total;
  // size
  unsigned int size;
  // total_visit
  unsigned long int total_visit;
  // total_key_compared
  unsigned long int total_key_compared;
  // timeout
  signed int timeout;
  // name
  char name[64l];
  // lists
  struct link_list_s **lists;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct iphdr
{
  // ihl
  unsigned int ihl : 4;
  // version
  unsigned int version : 4;
  // tos
  unsigned char tos;
  // tot_len
  unsigned short int tot_len;
  // id
  unsigned short int id;
  // frag_off
  unsigned short int frag_off;
  // ttl
  unsigned char ttl;
  // protocol
  unsigned char protocol;
  // check
  unsigned short int check;
  // saddr
  unsigned int saddr;
  // daddr
  unsigned int daddr;
};

struct ipq_packet_msg
{
  // packet_id
  unsigned long int packet_id;
  // mark
  unsigned long int mark;
  // timestamp_sec
  signed long int timestamp_sec;
  // timestamp_usec
  signed long int timestamp_usec;
  // hook
  unsigned int hook;
  // indev_name
  char indev_name[16l];
  // outdev_name
  char outdev_name[16l];
  // hw_protocol
  unsigned short int hw_protocol;
  // hw_type
  unsigned short int hw_type;
  // hw_addrlen
  unsigned char hw_addrlen;
  // hw_addr
  unsigned char hw_addr[8l];
  // data_len
  unsigned long int data_len;
  // payload
  unsigned char payload[0l];
};

struct ipq_peer_msg
{
  // msg
  union anonymous_22 msg;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct itimerval
{
  // it_interval
  struct timeval it_interval;
  // it_value
  struct timeval it_value;
};

struct link_node_s
{
  // prev
  struct link_node_s *prev;
  // next
  struct link_node_s *next;
  // data
  void *data;
  // key
  unsigned int key;
};

struct link_list_s
{
  // head
  struct link_node_s head;
  // size
  signed int size;
};

struct msg_client_s
{
  // client_ip
  unsigned int client_ip;
  // client_port
  unsigned short int client_port;
  // type
  unsigned short int type;
} __attribute__ ((__packed__));

struct tcphdr
{
  // _anon0
  union anonymous_2 _anon0;
};

struct msg_server_s
{
  // ip_header
  struct iphdr ip_header;
  // tcp_header
  struct tcphdr tcp_header;
} __attribute__ ((__packed__));

struct nlmsghdr
{
  // nlmsg_len
  unsigned int nlmsg_len;
  // nlmsg_type
  unsigned short int nlmsg_type;
  // nlmsg_flags
  unsigned short int nlmsg_flags;
  // nlmsg_seq
  unsigned int nlmsg_seq;
  // nlmsg_pid
  unsigned int nlmsg_pid;
};

struct passed_ip_addr_s
{
  // ips
  unsigned int ips[32l];
  // num
  signed int num;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_12 __sigaction_handler;
  // sa_mask
  struct anonymous_9 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_nl
{
  // nl_family
  unsigned short int nl_family;
  // nl_pad
  unsigned short int nl_pad;
  // nl_pid
  unsigned int nl_pid;
  // nl_groups
  unsigned int nl_groups;
};

struct tc_event_loop_s
{
  // io
  void *io;
  // size
  signed int size;
  // event_over
  signed int event_over;
  // active_events
  struct tc_event_s *active_events;
  // actions
  struct anonymous_7 *actions;
  // timers
  struct tc_event_timer_s *timers;
};

struct tc_event_s
{
  // fd
  signed int fd;
  // events
  signed int events;
  // reg_evs
  signed int reg_evs;
  // index
  signed int index;
  // loop
  struct tc_event_loop_s *loop;
  // read_handler
  signed int (*read_handler)(struct tc_event_s *);
  // write_handler
  signed int (*write_handler)(struct tc_event_s *);
  // next
  struct tc_event_s *next;
};

struct tc_event_timer_s
{
  // msec
  signed long int msec;
  // handler
  void (*handler)(struct tc_event_timer_s *);
  // next
  struct tc_event_timer_s *next;
};

struct tc_select_multiplex_io_s
{
  // max_fd
  signed int max_fd;
  // last
  signed int last;
  // r_set
  struct anonymous_10 r_set;
  // w_set
  struct anonymous_10 w_set;
  // evs
  struct tc_event_s **evs;
};

struct tc_verdict_s
{
  // fd
  signed int fd;
  // verdict
  signed int verdict;
  // packet_id
  unsigned long int packet_id;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct xcopy_srv_settings
{
  // raw_ip_list
  char *raw_ip_list;
  // pid_file
  char *pid_file;
  // binded_ip
  char *binded_ip;
  // log_path
  char *log_path;
  // timeout
  signed int timeout;
  // hash_size
  unsigned long int hash_size;
  // port
  unsigned short int port;
  // do_daemonize
  unsigned int do_daemonize : 1;
  // passed_ips
  struct passed_ip_addr_s passed_ips;
};


// buf
// file tc_util.c line 142
static unsigned short int buf[32768l];
// buffer
// file tc_interception.c line 12
static unsigned char buffer[128l];
// cache_err_log_time
// file tc_time.c line 10
static char cache_err_log_time[24l];
// empty
// file tc_interception.c line 20
static union anonymous_5 empty;
// fd_null_cnt
// file tc_router.c line 8
static unsigned long int fd_null_cnt = (unsigned long int)0;
// full
// file tc_interception.c line 21
static union anonymous_5 full;
// last_clean_time
// file tc_interception.c line 8
static signed long int last_clean_time;
// log_fd
// file tc_log.c line 4
static signed int log_fd = -1;
// msg_item_cnt
// file tc_delay.c line 5
static unsigned long int msg_item_cnt;
// msg_item_destr_cnt
// file tc_delay.c line 5
static unsigned long int msg_item_destr_cnt;
// msg_item_free_cnt
// file tc_delay.c line 5
static unsigned long int msg_item_free_cnt;
// msg_ls_cnt
// file tc_delay.c line 6
static unsigned long int msg_ls_cnt;
// msg_ls_destr_cnt
// file tc_delay.c line 6
static unsigned long int msg_ls_destr_cnt;
// msg_ls_free_cnt
// file tc_delay.c line 6
static unsigned long int msg_ls_free_cnt;
// mutex
// file tc_router.c line 11
static union anonymous_8 mutex;
// mutex_link1
// file tc_interception.c line 19
static union anonymous_8 mutex_link1;
// nl_empty
// file tc_interception.c line 36
static union anonymous_5 nl_empty;
// nl_full
// file tc_interception.c line 37
static union anonymous_5 nl_full;
// nl_mutex
// file tc_interception.c line 35
static union anonymous_8 nl_mutex;
// nl_pool
// file tc_interception.c line 32
static struct tc_verdict_s nl_pool[65536l];
// nl_read_counter
// file tc_interception.c line 33
static unsigned long int nl_read_counter = (unsigned long int)0;
// nl_write_counter
// file tc_interception.c line 34
static unsigned long int nl_write_counter = (unsigned long int)0;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// pid
// file tc_interception.c line 7
static signed int pid;
// pool
// file tc_interception.c line 16
static char pool[16777216l];
// read_counter
// file tc_interception.c line 17
static unsigned long int read_counter = (unsigned long int)0;
// s_event_loop
// file main.c line 21
static struct tc_event_loop_s s_event_loop;
// seed
// file tc_util.c line 29
static unsigned int seed = (unsigned int)0;
// seq
// file tc_interception.c line 10
static unsigned int seq = (unsigned int)1;
// srv_settings
// file main.c line 20
struct xcopy_srv_settings srv_settings;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// table
// file tc_router.c line 7
static struct hash_table_s *table;
// table_link1
// file tc_delay.c line 8
static struct hash_table_s *table_link1;
// tc_current_time_msec
// file tc_time.c line 7
volatile signed long int tc_current_time_msec;
// tc_current_time_sec
// file tc_time.c line 6
volatile signed long int tc_current_time_sec;
// tc_current_tm
// file tc_time.c line 8
struct tm tc_current_tm;
// tc_error_log_time
// file tc_time.c line 5
volatile char *tc_error_log_time;
// tc_event_actions
// file tc_event.c line 7
static struct anonymous_7 tc_event_actions;
// tc_event_actions
// file tc_event.c line 7
static struct anonymous_7 tc_event_actions = { .create=tc_select_create, .destroy=tc_select_destroy, .add=tc_select_add_event,
    .del=tc_select_del_event, .poll=tc_select_polling };
// tc_log_levels
// file tc_log.c line 11
static struct anonymous_0 tc_log_levels[9l] = { { .level="[unknown]", .len=9 }, { .level="[emerg]", .len=7 }, { .level="[alert]", .len=7 }, { .level="[crit]", .len=6 }, { .level="[error]", .len=7 }, { .level="[warn]", .len=6 }, { .level="[notice]", .len=8 }, { .level="[info]", .len=6 }, { .level="[debug]", .len=7 } };
// tc_update_time
// file tc_time.c line 4
volatile signed int tc_update_time;
// tot_resp_packs
// file tc_interception.c line 11
static unsigned long int tot_resp_packs = (unsigned long int)0;
// write_counter
// file tc_interception.c line 18
static unsigned long int write_counter = (unsigned long int)0;

// check_pack_src
// file tc_util.c line 77
signed int check_pack_src(struct anonymous_1 *transfer, unsigned int ip, unsigned short int port, signed int src_flag)
{
  signed int i;
  signed int ret;
  struct anonymous_3 *pair;
  struct anonymous_3 **mappings;
  ret = 0;
  mappings = transfer->mappings;
  i = 0;
  _Bool tmp_if_expr_1;
  for( ; !(i >= transfer->num); i = i + 1)
  {
    pair = mappings[(signed long int)i];
    if(src_flag == 1)
    {
      if(ip == pair->online_ip)
        tmp_if_expr_1 = port == pair->online_port ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
      {
        ret = 2;
        break;
      }

      else
        if(pair->online_ip == 0u)
        {
          if(port == pair->online_port)
          {
            ret = 2;
            break;
          }

        }

    }

    else
      if(src_flag == 2)
      {
        if(ip == pair->target_ip)
        {
          if(port == pair->target_port)
          {
            ret = 1;
            break;
          }

        }

      }

  }
  return ret;
}

// copy_ip_packet
// file tc_util.c line 110
unsigned char * copy_ip_packet(struct iphdr *ip_header)
{
  unsigned short int tot_len;
  tot_len=ntohs(ip_header->tot_len);
  unsigned char *data;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)tot_len);
  data = (unsigned char *)return_value_malloc_1;
  if(!(data == ((unsigned char *)NULL)))
    memcpy((void *)data, (const void *)ip_header, (unsigned long int)tot_len);

  return data;
}

// copy_message
// file tc_delay.c line 11
static struct msg_server_s * copy_message(struct msg_server_s *msg)
{
  struct msg_server_s *cmsg;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct msg_server_s) /*40ul*/ );
  cmsg = (struct msg_server_s *)return_value_malloc_1;
  if(cmsg == ((struct msg_server_s *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    tc_log_info(4, *return_value___errno_location_2, "malloc error");
    return (struct msg_server_s *)(void *)0;
  }

  memcpy((void *)cmsg, (const void *)msg, sizeof(struct msg_server_s) /*40ul*/ );
  return cmsg;
}

// csum
// file tc_util.c line 123
unsigned short int csum(unsigned short int *packet, signed int pack_len)
{
  unsigned long int sum = (unsigned long int)0;
  unsigned short int *tmp_post_1;
  for( ; pack_len >= 2; pack_len = pack_len - 2)
  {
    tmp_post_1 = packet;
    packet = packet + 1l;
    sum = sum + (unsigned long int)*tmp_post_1;
  }
  if(pack_len >= 1)
    sum = sum + (unsigned long int)*((unsigned char *)packet);

  for( ; !(sum >> 16 == 0ul); sum = (sum & (unsigned long int)0xffff) + (sum >> 16))
    ;
  return (unsigned short int)~sum;
}

// daemonize
// file ../../src/core/xcopy.h line 202
signed int daemonize()
{
  signed int fd;
  signed int return_value_fork_1;
  return_value_fork_1=fork();
  if(!(return_value_fork_1 == -1))
  {
    if(return_value_fork_1 == 0)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    return -1;

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L4;
  }
  _exit(0);

__CPROVER_DUMP_L4:
  ;
  signed int return_value_setsid_2;
  return_value_setsid_2=setsid();
  if(return_value_setsid_2 == -1)
    return -1;

  else
  {
    signed int return_value_chdir_3;
    return_value_chdir_3=chdir("/");
    if(!(return_value_chdir_3 == 0))
    {
      perror("chdir");
      return -1;
    }

    else
    {
      fd=open("/dev/null", 02, 0);
      if(!(fd == -1))
      {
        signed int return_value_dup2_4;
        return_value_dup2_4=dup2(fd, 0);
        if(!(return_value_dup2_4 >= 0))
        {
          perror("dup2 stdin");
          return -1;
        }

        signed int return_value_dup2_5;
        return_value_dup2_5=dup2(fd, 1);
        if(!(return_value_dup2_5 >= 0))
        {
          perror("dup2 stdout");
          return -1;
        }

        signed int return_value_dup2_6;
        return_value_dup2_6=dup2(fd, 2);
        if(!(return_value_dup2_6 >= 0))
        {
          perror("dup2 stderr");
          return -1;
        }

        if(fd >= 3)
        {
          signed int return_value_close_7;
          return_value_close_7=close(fd);
          if(!(return_value_close_7 >= 0))
          {
            perror("close");
            return -1;
          }

        }

      }

      return 0;
    }
  }
}

// delay_table_add
// file ./tc_delay.h line 9
void delay_table_add(unsigned long int key, struct msg_server_s *msg)
{
  struct link_list_s *msg_list;
  struct link_node_s *ln;
  struct msg_server_s *cmsg;
  void *return_value_hash_find_1;
  return_value_hash_find_1=hash_find(table_link1, key);
  msg_list = (struct link_list_s *)return_value_hash_find_1;
  if(msg_list == ((struct link_list_s *)NULL))
  {
    msg_ls_cnt = msg_ls_cnt + 1ul;
    msg_list=link_list_create();
    hash_add(table_link1, key, (void *)msg_list);
  }

  cmsg=copy_message(msg);
  if(!(cmsg == ((struct msg_server_s *)NULL)))
  {
    ln=link_node_malloc((void *)cmsg);
    link_list_append(msg_list, ln);
    msg_item_cnt = msg_item_cnt + 1ul;
  }

  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// delay_table_del
// file ./tc_delay.h line 11
void delay_table_del(unsigned long int key)
{
  struct link_list_s *msg_list;
  struct link_node_s *first;
  void *return_value_hash_find_1;
  return_value_hash_find_1=hash_find(table_link1, key);
  msg_list = (struct link_list_s *)return_value_hash_find_1;
  _Bool return_value_link_list_is_empty_2;
  if(!(msg_list == ((struct link_list_s *)NULL)))
  {
    do
    {
      return_value_link_list_is_empty_2=link_list_is_empty(msg_list);
      if(return_value_link_list_is_empty_2 != (_Bool)0)
        break;

      first=link_list_pop_first(msg_list);
      msg_item_free_cnt = msg_item_free_cnt + 1ul;
      link_node_internal_free(first);
      free((void *)first);
    }
    while((_Bool)1);
    hash_del(table_link1, key);
    free((void *)msg_list);
    msg_ls_free_cnt = msg_ls_free_cnt + 1ul;
  }

}

// delay_table_delete_obsolete
// file ./tc_delay.h line 8
void delay_table_delete_obsolete(signed long int cur_time)
{
  signed int i;
  signed int count = 0;
  struct hash_node_s *hn1;
  struct hash_node_s *hn2;
  struct link_list_s *msg_list;
  struct link_list_s *l;
  struct link_node_s *ln;
  struct link_node_s *tail;
  tc_log_info(6, 0, "delay total:%u", table_link1->total);
  i = 0;
  for( ; !((unsigned int)i >= table_link1->size); i = i + 1)
  {
    l = table_link1->lists[(signed long int)i];
    while((_Bool)1)
    {
      ln=link_list_tail(l);
      if(ln == ((struct link_node_s *)NULL))
        break;

      hn1 = (struct hash_node_s *)ln->data;
      if(!(hn1->access_time + (signed long int)table_link1->timeout >= cur_time))
      {
        count = count + 1;
        table_link1->total = table_link1->total - 1u;
        tail=link_list_pop_tail(l);
        hn2 = (struct hash_node_s *)tail->data;
        if(!(hn2 == ((struct hash_node_s *)NULL)))
        {
          if(!(hn2->data == NULL))
          {
            msg_list = (struct link_list_s *)hn2->data;
            signed int return_value_link_list_clear_1;
            return_value_link_list_clear_1=link_list_clear(msg_list);
            msg_item_destr_cnt = msg_item_destr_cnt + (unsigned long int)return_value_link_list_clear_1;
            free((void *)msg_list);
            hn2->data = (void *)0;
            msg_ls_destr_cnt = msg_ls_destr_cnt + 1ul;
          }

          free((void *)hn2);
        }

        tail->data = (void *)0;
        free((void *)tail);
      }

      else
        break;
    }
  }
  tc_log_info(6, 0, "delay delete obsolete :%d", count);
}

// delay_table_destroy
// file ./tc_delay.h line 12
void delay_table_destroy()
{
  unsigned int i;
  struct link_list_s *msg_list;
  struct link_list_s *list;
  struct hash_node_s *hn;
  struct link_node_s *ln;
  if(!(table_link1 == ((struct hash_table_s *)NULL)))
  {
    tc_log_info(6, 0, "destroy delay table,total:%u", table_link1->total);
    i = (unsigned int)0;
    for( ; !(i >= table_link1->size); i = i + 1u)
    {
      list = table_link1->lists[(signed long int)i];
      ln=link_list_first(list);
      while(!(ln == ((struct link_node_s *)NULL)))
      {
        hn = (struct hash_node_s *)ln->data;
        if(!(hn->data == NULL))
        {
          msg_list = (struct link_list_s *)hn->data;
          signed int return_value_link_list_clear_1;
          return_value_link_list_clear_1=link_list_clear(msg_list);
          msg_item_destr_cnt = msg_item_destr_cnt + (unsigned long int)return_value_link_list_clear_1;
          free((void *)msg_list);
          msg_ls_destr_cnt = msg_ls_destr_cnt + 1ul;
        }

        hn->data = (void *)0;
        ln=link_list_get_next(list, ln);
      }
    }
    tc_log_info(6, 0, "destroy items:%llu,free:%llu,total:%llu", msg_item_destr_cnt, msg_item_free_cnt, msg_item_cnt);
    tc_log_info(6, 0, "create msg list:%llu,free:%llu,destr:%llu", msg_ls_cnt, msg_ls_free_cnt, msg_ls_destr_cnt);
    hash_destroy(table_link1);
    free((void *)table_link1);
    table_link1 = (struct hash_table_s *)(void *)0;
  }

}

// delay_table_init
// file ./tc_delay.h line 7
void delay_table_init(unsigned long int size)
{
  table_link1=hash_create(size);
  hash_set_timeout(table_link1, 30);
  strcpy(table_link1->name, "delay-table");
  tc_log_info(6, 0, "create %s,size:%u", (const void *)table_link1->name, table_link1->size);
  msg_item_cnt = (unsigned long int)0;
  msg_item_free_cnt = (unsigned long int)0;
  msg_item_destr_cnt = (unsigned long int)0;
  msg_ls_cnt = (unsigned long int)0;
  msg_ls_destr_cnt = (unsigned long int)0;
}

// delay_table_send
// file ./tc_delay.h line 10
void delay_table_send(unsigned long int key, signed int fd)
{
  struct link_list_s *msg_list;
  struct link_node_s *first;
  struct msg_server_s *msg;
  void *return_value_hash_find_1;
  return_value_hash_find_1=hash_find(table_link1, key);
  msg_list = (struct link_list_s *)return_value_hash_find_1;
  _Bool return_value_link_list_is_empty_2;
  if(!(msg_list == ((struct link_list_s *)NULL)))
    do
    {
      return_value_link_list_is_empty_2=link_list_is_empty(msg_list);
      if(return_value_link_list_is_empty_2 != (_Bool)0)
        break;

      first=link_list_pop_first(msg_list);
      msg = (struct msg_server_s *)first->data;
      tc_socket_send(fd, (char *)msg, sizeof(struct msg_server_s) /*40ul*/ );
      msg_item_free_cnt = msg_item_free_cnt + 1ul;
      link_node_internal_free(first);
      free((void *)first);
    }
    while((_Bool)1);

}

// dispose_netlink_packet
// file tc_interception.c line 44
static signed int dispose_netlink_packet(signed int fd, signed int verdict, unsigned long int packet_id)
{
  struct nlmsghdr *nl_header = (struct nlmsghdr *)buffer;
  struct ipq_verdict_msg *ver_data;
  struct sockaddr_nl addr;
  nl_header->nlmsg_type = (unsigned short int)(0x10 + 2);
  nl_header->nlmsg_len = (unsigned int)(sizeof(struct ipq_verdict_msg) /*24ul*/  + (unsigned long int)(signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)));
  nl_header->nlmsg_flags = (unsigned short int)1;
  nl_header->nlmsg_pid = (unsigned int)pid;
  unsigned int tmp_post_1 = seq;
  seq = seq + 1u;
  nl_header->nlmsg_seq = tmp_post_1;
  ver_data = (struct ipq_verdict_msg *)(void *)((char *)nl_header + (signed long int)(0 + (signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1))));
  ver_data->value = (unsigned int)verdict;
  ver_data->id = packet_id;
  memset((void *)&addr, 0, sizeof(struct sockaddr_nl) /*12ul*/ );
  addr.nl_family = (unsigned short int)16;
  addr.nl_pid = (unsigned int)0;
  addr.nl_groups = (unsigned int)0;
  signed long int return_value_sendto_3;
  return_value_sendto_3=sendto(fd, (void *)nl_header, (unsigned long int)nl_header->nlmsg_len, 0, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_nl) /*12ul*/ );
  if(!(return_value_sendto_3 >= 0l))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    tc_log_info(4, *return_value___errno_location_2, "unable to send mode message");
    return 0;
  }

  return 1;
}

// get_appropriate_port
// file tc_util.c line 16
unsigned short int get_appropriate_port(unsigned short int orig_port, unsigned short int add)
{
  unsigned short int dest_port = orig_port;
  if(!((signed int)dest_port >= 65536 + -((signed int)add)))
    dest_port = dest_port + add;

  else
    dest_port = (unsigned short int)(1024 + (signed int)add);
  return dest_port;
}

// get_key
// file ../util/tc_util.h line 13
unsigned long int get_key(unsigned int ip, unsigned short int port)
{
  unsigned long int value = (unsigned long int)ip << 16;
  value = value + (unsigned long int)port;
  return value;
}

// get_link_list
// file tc_hash.c line 85
struct link_list_s * get_link_list(struct hash_table_s *table, unsigned long int key)
{
  unsigned int slot;
  slot=get_slot(key, table->size);
  return table->lists[(signed long int)slot];
}

// get_nl_verdict_from_pool
// file tc_interception.c line 300
static struct tc_verdict_s * get_nl_verdict_from_pool(struct tc_verdict_s *verdict)
{
  signed int index;
  pthread_mutex_lock(&nl_mutex);
  if(nl_read_counter >= nl_write_counter)
    pthread_cond_wait(&nl_full, &nl_mutex);

  index = (signed int)(nl_read_counter & (unsigned long int)(65536 - 1));
  verdict->fd = nl_pool[(signed long int)index].fd;
  verdict->verdict = nl_pool[(signed long int)index].verdict;
  verdict->packet_id = nl_pool[(signed long int)index].packet_id;
  nl_read_counter = nl_read_counter + 1ul;
  pthread_cond_signal(&nl_empty);
  pthread_mutex_unlock(&nl_mutex);
  return verdict;
}

// get_port_by_rand_addition
// file tc_util.c line 32
unsigned short int get_port_by_rand_addition(unsigned short int orig_port)
{
  struct timeval tp;
  unsigned short int port_add;
  if(seed == 0u)
  {
    gettimeofday(&tp, (struct timezone *)(void *)0);
    seed = (unsigned int)tp.tv_usec;
  }

  signed int return_value_rand_r_1;
  return_value_rand_r_1=rand_r(&seed);
  port_add = (unsigned short int)((double)4096 * ((double)return_value_rand_r_1 / ((double)2147483647 + 1.0)));
  port_add = (unsigned short int)((signed int)port_add + 32768);
  unsigned short int return_value_ntohs_2;
  return_value_ntohs_2=ntohs(orig_port);
  unsigned short int return_value_get_appropriate_port_3;
  return_value_get_appropriate_port_3=get_appropriate_port(return_value_ntohs_2, port_add);
  return return_value_get_appropriate_port_3;
}

// get_port_from_shift
// file tc_util.c line 48
unsigned short int get_port_from_shift(unsigned short int orig_port, unsigned short int rand_port, signed int shift_factor)
{
  unsigned short int port_add = (unsigned short int)((shift_factor << 11) + (signed int)rand_port);
  unsigned short int return_value_ntohs_1;
  return_value_ntohs_1=ntohs(orig_port);
  unsigned short int return_value_get_appropriate_port_2;
  return_value_get_appropriate_port_2=get_appropriate_port(return_value_ntohs_1, port_add);
  return return_value_get_appropriate_port_2;
}

// get_resp_ip_hdr_from_pool
// file tc_interception.c line 238
static struct iphdr * get_resp_ip_hdr_from_pool(char *resp, signed int *len)
{
  signed int read_pos;
  char *pos;
  pthread_mutex_lock(&mutex_link1);
  if(read_counter >= write_counter)
    pthread_cond_wait(&full, &mutex_link1);

  read_pos = (signed int)(read_counter & (unsigned long int)((1 << 24) - 1));
  pos = pool + (signed long int)read_pos;
  *len = *((signed int *)pos);
  pos = pos + (signed long int)sizeof(signed int) /*4ul*/ ;
  memcpy((void *)resp, (const void *)pos, (unsigned long int)*len);
  read_counter = read_counter + (unsigned long int)*len + sizeof(signed int) /*4ul*/ ;
  pthread_cond_signal(&empty);
  pthread_mutex_unlock(&mutex_link1);
  return (struct iphdr *)resp;
}

// get_slot
// file tc_hash.c line 23
static unsigned int get_slot(unsigned long int key, unsigned int size)
{
  unsigned int trim_key = (unsigned int)(key & (unsigned long int)0xFFFFFFFF);
  return trim_key % size;
}

// get_test_pair
// file tc_util.c line 58
struct anonymous_3 * get_test_pair(struct anonymous_1 *transfer, unsigned int ip, unsigned short int port)
{
  signed int i;
  struct anonymous_3 *pair;
  struct anonymous_3 **mappings;
  pair = (struct anonymous_3 *)(void *)0;
  mappings = transfer->mappings;
  i = 0;
  _Bool tmp_if_expr_1;
  for( ; !(i >= transfer->num); i = i + 1)
  {
    pair = mappings[(signed long int)i];
    if(ip == pair->online_ip)
      tmp_if_expr_1 = port == pair->online_port ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      return pair;

    else
      if(pair->online_ip == 0u)
      {
        if(port == pair->online_port)
          return pair;

      }

  }
  return (struct anonymous_3 *)(void *)0;
}

// hash_add
// file ../../src/core/tc_hash.h line 26
_Bool hash_add(struct hash_table_s *table, unsigned long int key, void *data)
{
  struct hash_node_s *hn;
  struct hash_node_s *tmp;
  struct link_list_s *l;
  struct link_node_s *ln;
  ln=hash_find_node(table, key);
  if(!(ln == ((struct link_node_s *)NULL)))
  {
    hn = (struct hash_node_s *)ln->data;
    hn->data = data;
    return (_Bool)0;
  }

  else
  {
    tmp=hash_node_malloc(key, data);
    if(tmp == ((struct hash_node_s *)NULL))
      return (_Bool)0;

    ln=link_node_malloc((void *)tmp);
    if(ln == ((struct link_node_s *)NULL))
      return (_Bool)0;

    l=get_link_list(table, key);
    link_list_push(l, ln);
    table->total = table->total + 1u;
    return (_Bool)1;
  }
}

// hash_create
// file ../../src/core/tc_hash.h line 23
struct hash_table_s * hash_create(unsigned long int size)
{
  unsigned long int i;
  struct hash_table_s *ht;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct hash_table_s) /*104ul*/ );
  ht = (struct hash_table_s *)return_value_calloc_1;
  if(ht == ((struct hash_table_s *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    tc_log_info(4, *return_value___errno_location_2, "can't calloc memory for hash table");
    return (struct hash_table_s *)(void *)0;
  }

  ht->size = (unsigned int)size;
  void *return_value_calloc_3;
  return_value_calloc_3=calloc(size, sizeof(struct link_list_s *) /*8ul*/ );
  ht->lists = (struct link_list_s **)return_value_calloc_3;
  if(ht->lists == ((struct link_list_s **)NULL))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    tc_log_info(4, *return_value___errno_location_4, "can't calloc memory for hash lists");
    return (struct hash_table_s *)(void *)0;
  }

  i = (unsigned long int)0;
  for( ; !(i >= size); i = i + 1ul)
    ht->lists[(signed long int)i]=link_list_create();
  ht->timeout = 120;
  return ht;
}

// hash_deep_destroy
// file tc_hash.c line 184
void hash_deep_destroy(struct hash_table_s *table)
{
  unsigned int index = (unsigned int)0;
  struct hash_node_s *hn;
  struct link_list_s *l;
  struct link_node_s *ln;
  struct link_node_s *tmp_ln;
  for( ; !(index >= table->size); index = index + 1u)
  {
    l = table->lists[(signed long int)index];
    if(!(l == ((struct link_list_s *)NULL)))
    {
      ln=link_list_first(l);
      for( ; !(ln == ((struct link_node_s *)NULL)); ln = tmp_ln)
      {
        tmp_ln=link_list_get_next(l, ln);
        hn = (struct hash_node_s *)ln->data;
        if(!(hn->data == NULL))
        {
          free(hn->data);
          hn->data = (void *)0;
        }

      }
    }

  }
  hash_destroy(table);
}

// hash_del
// file ../../src/core/tc_hash.h line 28
_Bool hash_del(struct hash_table_s *table, unsigned long int key)
{
  struct link_list_s *l;
  l=get_link_list(table, key);
  struct link_node_s *ln;
  ln=hash_find_node(table, key);
  if(!(ln == ((struct link_node_s *)NULL)))
  {
    table->total = table->total - 1u;
    link_list_remove(l, ln);
    link_node_internal_free(ln);
    free((void *)ln);
    return (_Bool)1;
  }

  else
    return (_Bool)0;
}

// hash_destroy
// file ../../src/core/tc_hash.h line 29
void hash_destroy(struct hash_table_s *table)
{
  signed int count = 0;
  unsigned int index = (unsigned int)0;
  struct link_list_s *l;
  for( ; !(index >= table->size); index = index + 1u)
  {
    l = table->lists[(signed long int)index];
    if(!(l == ((struct link_list_s *)NULL)))
    {
      signed int return_value_link_list_clear_1;
      return_value_link_list_clear_1=link_list_clear(l);
      count = count + return_value_link_list_clear_1;
      free((void *)l);
    }

  }
  free((void *)table->lists);
  tc_log_info(6, 0, "total visit hash_find_node:%llu,compared:%llu", table->total_visit, table->total_key_compared);
  tc_log_info(6, 0, "destroy items %d in table name:%s", count, (const void *)table->name);
}

// hash_find
// file ../../src/core/tc_hash.h line 27
void * hash_find(struct hash_table_s *table, unsigned long int key)
{
  struct hash_node_s *hn;
  struct link_node_s *ln;
  ln=hash_find_node(table, key);
  if(!(ln == ((struct link_node_s *)NULL)))
  {
    hn = (struct hash_node_s *)ln->data;
    return hn->data;
  }

  else
    return (void *)0;
}

// hash_find_node
// file tc_hash.c line 31
static struct link_node_s * hash_find_node(struct hash_table_s *table, unsigned long int key)
{
  struct hash_node_s *hn;
  struct link_list_s *l;
  l=get_link_list(table, key);
  struct link_node_s *ln;
  ln=link_list_first(l);
  table->total_visit = table->total_visit + 1ul;
  while(!(ln == ((struct link_node_s *)NULL)))
  {
    hn = (struct hash_node_s *)ln->data;
    table->total_key_compared = table->total_key_compared + 1ul;
    if(hn->key == key)
    {
      hn->access_time = tc_current_time_sec;
      hn->visit_cnt = hn->visit_cnt + 1u;
      link_list_remove(l, ln);
      link_list_push(l, ln);
      return ln;
    }

    ln=link_list_get_next(l, ln);
  }
  return (struct link_node_s *)(void *)0;
}

// hash_node_malloc
// file tc_hash.c line 5
static struct hash_node_s * hash_node_malloc(unsigned long int key, void *data)
{
  struct hash_node_s *hn;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct hash_node_s) /*32ul*/ );
  hn = (struct hash_node_s *)return_value_malloc_1;
  if(hn == ((struct hash_node_s *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    tc_log_info(4, *return_value___errno_location_2, "can't malloc memory for hash node");
    return (struct hash_node_s *)(void *)0;
  }

  hn->key = key;
  hn->data = data;
  hn->access_time = tc_current_time_sec;
  hn->visit_cnt = (unsigned int)0;
  return hn;
}

// hash_set_timeout
// file ../../src/core/tc_hash.h line 25
void hash_set_timeout(struct hash_table_s *table, signed int t)
{
  table->timeout = t;
}

// interception_dispose_nl_verdict
// file tc_interception.c line 387
static void * interception_dispose_nl_verdict(void *tid)
{
  struct tc_verdict_s verdict;
  do
  {
    get_nl_verdict_from_pool(&verdict);
    dispose_netlink_packet(verdict.fd, verdict.verdict, verdict.packet_id);
  }
  while((_Bool)1);
  return (void *)0;
}

// interception_init
// file tc_interception.c line 427
signed int interception_init(struct tc_event_loop_s *event_loop, char *ip, unsigned short int port)
{
  signed int fd;
  unsigned long int thread;
  struct tc_event_s *ev;
  router_init(srv_settings.hash_size, srv_settings.timeout);
  pid=getpid();
  fd=tc_socket_init();
  if(fd == -1)
    return -1;

  else
  {
    signed int return_value_tc_socket_listen_1;
    return_value_tc_socket_listen_1=tc_socket_listen(fd, ip, port);
    if(return_value_tc_socket_listen_1 == -1)
      return -1;

    tc_log_info(6, 0, "msg listen socket:%d", fd);
    ev=tc_event_create(fd, tc_msg_event_accept, (signed int (*)(struct tc_event_s *))(void *)0);
    if(ev == ((struct tc_event_s *)NULL))
      return -1;

    signed int return_value_tc_event_add_2;
    return_value_tc_event_add_2=tc_event_add(event_loop, ev, 1);
    if(return_value_tc_event_add_2 == -1)
      return -1;

  }
  fd=tc_nl_socket_init();
  if(fd == -1)
    return -1;

  else
  {
    tc_log_info(6, 0, "firewall socket:%d", fd);
    ev=tc_event_create(fd, tc_nl_event_process, (signed int (*)(struct tc_event_s *))(void *)0);
    if(ev == ((struct tc_event_s *)NULL))
      return -1;

    signed int return_value_tc_event_add_3;
    return_value_tc_event_add_3=tc_event_add(event_loop, ev, 1);
    if(return_value_tc_event_add_3 == -1)
      return -1;

  }
  pthread_mutex_init(&mutex_link1, (const union anonymous_11 *)(void *)0);
  pthread_cond_init(&full, (const union anonymous_11 *)(void *)0);
  pthread_cond_init(&empty, (const union anonymous_11 *)(void *)0);
  pthread_create(&thread, (const union pthread_attr_t *)(void *)0, interception_process_msg, (void *)0);
  pthread_mutex_init(&nl_mutex, (const union anonymous_11 *)(void *)0);
  pthread_cond_init(&nl_full, (const union anonymous_11 *)(void *)0);
  pthread_cond_init(&nl_empty, (const union anonymous_11 *)(void *)0);
  pthread_create(&thread, (const union pthread_attr_t *)(void *)0, interception_dispose_nl_verdict, (void *)0);
  return 0;
}

// interception_over
// file tc_interception.c line 494
void interception_over()
{
  router_destroy();
}

// interception_process_msg
// file tc_interception.c line 402
static void * interception_process_msg(void *tid)
{
  signed int len;
  char resp[65536l];
  struct iphdr *ip_hdr;
  do
  {
    ip_hdr=get_resp_ip_hdr_from_pool(resp, &len);
    if(ip_hdr == ((struct iphdr *)NULL))
      tc_log_info(5, 0, "ip header is null");

    router_update(ip_hdr, len);
    tc_nl_check_cleaning();
  }
  while((_Bool)1);
  return (void *)0;
}

// link_list_append
// file ../../src/core/tc_link_list.h line 25
void link_list_append(struct link_list_s *l, struct link_node_s *p)
{
  struct link_node_s *node = l->head.prev;
  node->next = p;
  p->prev = node;
  l->head.prev = p;
  p->next = &l->head;
  l->size = l->size + 1;
}

// link_list_append_by_order
// file tc_link_list.c line 81
void link_list_append_by_order(struct link_list_s *l, struct link_node_s *p)
{
  struct link_node_s *node;
  struct link_node_s *next;
  if(l->size >= 1)
  {
    node = l->head.prev;
    next = node->next;
    for( ; !(p->key >= node->key); node = node->prev)
      next = node;
    node->next = p;
    p->prev = node;
    next->prev = p;
    p->next = next;
    l->size = l->size + 1;
  }

  else
    link_list_append(l, p);
}

// link_list_clear
// file ../../src/core/tc_link_list.h line 24
signed int link_list_clear(struct link_list_s *l)
{
  signed int count = 0;
  struct link_node_s *p;
  struct link_node_s *next;
  p = l->head.next;
  for( ; !(p == &l->head); p = next)
  {
    next = p->next;
    count = count + 1;
    link_node_internal_free(p);
    free((void *)p);
  }
  l->head.next = &l->head;
  l->head.prev = &l->head;
  l->size = 0;
  return count;
}

// link_list_create
// file ../../src/core/tc_link_list.h line 23
struct link_list_s * link_list_create()
{
  struct link_list_s *l;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct link_list_s) /*40ul*/ );
  l = (struct link_list_s *)return_value_calloc_1;
  if(l == ((struct link_list_s *)NULL))
  {
    perror("calloc");
    return (struct link_list_s *)(void *)0;
  }

  else
  {
    l->size = 0;
    l->head.next = &l->head;
    l->head.prev = &l->head;
    return l;
  }
}

// link_list_first
// file ../../src/core/tc_link_list.h line 29
struct link_node_s * link_list_first(struct link_list_s *l)
{
  if(l->head.next == &l->head)
    return (struct link_node_s *)(void *)0;

  else
    return l->head.next;
}

// link_list_get_next
// file ../../src/core/tc_link_list.h line 33
struct link_node_s * link_list_get_next(struct link_list_s *l, struct link_node_s *p)
{
  if(p->next == &l->head)
    return (struct link_node_s *)(void *)0;

  else
    return p->next;
}

// link_list_is_empty
// file ../../src/core/tc_link_list.h line 34
_Bool link_list_is_empty(struct link_list_s *l)
{
  if(l->head.next == &l->head)
    return (_Bool)1;

  else
    return (_Bool)0;
}

// link_list_pop_first
// file ../../src/core/tc_link_list.h line 31
struct link_node_s * link_list_pop_first(struct link_list_s *l)
{
  struct link_node_s *first;
  first=link_list_first(l);
  if(first == ((struct link_node_s *)NULL))
    return first;

  else
  {
    struct link_node_s *return_value_link_list_remove_1;
    return_value_link_list_remove_1=link_list_remove(l, first);
    return return_value_link_list_remove_1;
  }
}

// link_list_pop_tail
// file ../../src/core/tc_link_list.h line 32
struct link_node_s * link_list_pop_tail(struct link_list_s *l)
{
  struct link_node_s *tail;
  tail=link_list_tail(l);
  if(tail == ((struct link_node_s *)NULL))
    return tail;

  else
  {
    struct link_node_s *return_value_link_list_remove_1;
    return_value_link_list_remove_1=link_list_remove(l, tail);
    return return_value_link_list_remove_1;
  }
}

// link_list_push
// file tc_link_list.c line 104
void link_list_push(struct link_list_s *l, struct link_node_s *p)
{
  struct link_node_s *node = l->head.next;
  node->prev = p;
  p->next = node;
  l->head.next = p;
  p->prev = &l->head;
  l->size = l->size + 1;
}

// link_list_remove
// file tc_link_list.c line 117
struct link_node_s * link_list_remove(struct link_list_s *l, struct link_node_s *node)
{
  struct link_node_s *next;
  struct link_node_s *prev;
  next = node->next;
  prev = node->prev;
  next->prev = prev;
  prev->next = next;
  l->size = l->size - 1;
  return node;
}

// link_list_tail
// file ../../src/core/tc_link_list.h line 30
struct link_node_s * link_list_tail(struct link_list_s *l)
{
  if(l->head.next == &l->head)
    return (struct link_node_s *)(void *)0;

  else
    return l->head.prev;
}

// link_node_internal_free
// file ../../src/core/tc_link_list.h line 21
void link_node_internal_free(struct link_node_s *p)
{
  if(!(p->data == NULL))
  {
    free(p->data);
    p->data = (void *)0;
  }

}

// link_node_malloc
// file ../../src/core/tc_link_list.h line 20
struct link_node_s * link_node_malloc(void *data)
{
  struct link_node_s *p;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct link_node_s) /*32ul*/ );
  p = (struct link_node_s *)return_value_calloc_1;
  if(p == ((struct link_node_s *)NULL))
    return (struct link_node_s *)(void *)0;

  else
  {
    p->data = data;
    return p;
  }
}

// main
// file main.c line 271
signed int main(signed int argc, char **argv)
{
  signed int ret;
  settings_init();
  tc_time_init();
  signed int return_value_read_args_1;
  return_value_read_args_1=read_args(argc, argv);
  if(return_value_read_args_1 == -1)
    return -1;

  else
  {
    signed int return_value_tc_log_init_2;
    return_value_tc_log_init_2=tc_log_init(srv_settings.log_path);
    if(return_value_tc_log_init_2 == -1)
      return -1;

    else
    {
      ret=tc_event_loop_init(&s_event_loop, 1024);
      if(ret == -1)
      {
        tc_log_info(4, 0, "event loop init failed");
        return -1;
      }

      else
      {
        output_for_debug();
        signed int return_value_set_details_3;
        return_value_set_details_3=set_details();
        if(return_value_set_details_3 == -1)
          return -1;

        else
        {
          signed int return_value_interception_init_4;
          return_value_interception_init_4=interception_init(&s_event_loop, srv_settings.binded_ip, srv_settings.port);
          if(return_value_interception_init_4 == -1)
            return -1;

          else
          {
            tc_event_process_cycle(&s_event_loop);
            return 0;
          }
        }
      }
    }
  }
}

// output_for_debug
// file main.c line 254
static void output_for_debug()
{
  tc_log_info(6, 0, "intercept version:%s", (const void *)"0.6.3");
  tc_log_info(6, 0, "TCPCOPY_MYSQL_SKIP mode for intercept");
  tc_log_info(6, 0, "INTERCEPT_THREAD mode");
}

// put_nl_verdict_to_pool
// file tc_interception.c line 267
static void put_nl_verdict_to_pool(signed int fd, signed int verdict, unsigned long int packet_id)
{
  signed int index;
  signed int diff;
  pthread_mutex_lock(&nl_mutex);
  index = (signed int)(nl_write_counter & (unsigned long int)(65536 - 1));
  diff = (signed int)((nl_write_counter - nl_read_counter) + (unsigned long int)1);
  for( ; (_Bool)1; diff = (signed int)((nl_write_counter - nl_read_counter) + (unsigned long int)1))
    if(diff >= 65537)
    {
      tc_log_info(5, 0, "nl pool is full");
      pthread_cond_wait(&nl_empty, &nl_mutex);
    }

    else
      goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
  nl_pool[(signed long int)index].fd = fd;
  nl_pool[(signed long int)index].verdict = verdict;
  nl_pool[(signed long int)index].packet_id = packet_id;
  nl_write_counter = nl_write_counter + 1ul;
  pthread_cond_signal(&nl_full);
  pthread_mutex_unlock(&nl_mutex);
}

// put_resp_header_to_pool
// file tc_interception.c line 160
static void put_resp_header_to_pool(struct iphdr *ip_header)
{
  signed int *p_len;
  signed int cur_w_pos;
  signed int diff;
  signed int next_w_pos;
  char *p_content;
  unsigned short int size_ip;
  unsigned short int save_len;
  unsigned short int record_len;
  unsigned long int next_w_cnt;
  struct tcphdr *tcp_header;
  if(!((signed int)ip_header->protocol == 6))
    tc_log_info(5, 0, "this is not a tcp packet");

  else
  {
    save_len = (unsigned short int)(sizeof(struct iphdr) /*20ul*/  + sizeof(struct tcphdr) /*20ul*/ );
    size_ip = (unsigned short int)((signed int)ip_header->ihl << 2);
    tcp_header = (struct tcphdr *)((char *)ip_header + (signed long int)size_ip);
    record_len = save_len;
    pthread_mutex_lock(&mutex_link1);
    next_w_cnt = write_counter + (unsigned long int)save_len + sizeof(signed int) /*4ul*/ ;
    next_w_pos = (signed int)(next_w_cnt & (unsigned long int)((1 << 24) - 1));
    if((unsigned long int)next_w_pos >= 16777173ul)
    {
      next_w_cnt = next_w_cnt / (unsigned long int)(1 << 24) + (unsigned long int)1 << 24;
      record_len = record_len + (unsigned short int)((1 << 24) - next_w_pos);
    }

    diff = (signed int)(next_w_cnt - read_counter);
    for( ; (_Bool)1; diff = (signed int)(next_w_cnt - read_counter))
      if(diff >= 16777217)
      {
        tc_log_info(5, 0, "pool is full");
        pthread_cond_wait(&empty, &mutex_link1);
      }

      else
        goto __CPROVER_DUMP_L6;

  __CPROVER_DUMP_L6:
    ;
    cur_w_pos = (signed int)(write_counter & (unsigned long int)((1 << 24) - 1));
    p_len = (signed int *)(pool + (signed long int)cur_w_pos);
    p_content = (char *)((unsigned char *)p_len + (signed long int)sizeof(signed int) /*4ul*/ );
    write_counter = next_w_cnt;
    *p_len = (signed int)record_len;
    ip_header->ihl = (unsigned int)(sizeof(struct iphdr) /*20ul*/  >> 2);
    memcpy((void *)p_content, (const void *)ip_header, sizeof(struct iphdr) /*20ul*/ );
    p_content = p_content + (signed long int)sizeof(struct iphdr) /*20ul*/ ;
    memcpy((void *)p_content, (const void *)tcp_header, sizeof(struct tcphdr) /*20ul*/ );
    pthread_cond_signal(&full);
    pthread_mutex_unlock(&mutex_link1);
  }
}

// read_args
// file main.c line 149
static signed int read_args(signed int argc, char **argv)
{
  signed int c;
  signed int return_value_atoi_1;
  signed int return_value_atoi_2;
  signed int return_value_atoi_3;
  do
  {
    c=getopt(argc, argv, "x:p:t:s:b:hl:P:vd");
    if(c == -1)
      break;

    switch(c)
    {
      case 120:
      {
        srv_settings.raw_ip_list = optarg;
        break;
      }
      case 112:
      {
        return_value_atoi_1=atoi(optarg);
        srv_settings.port = (unsigned short int)return_value_atoi_1;
        break;
      }
      case 116:
      {
        return_value_atoi_2=atoi(optarg);
        srv_settings.timeout = (signed int)(unsigned long int)return_value_atoi_2;
        break;
      }
      case 115:
      {
        return_value_atoi_3=atoi(optarg);
        srv_settings.hash_size = (unsigned long int)return_value_atoi_3;
        break;
      }
      case 98:
      {
        srv_settings.binded_ip = optarg;
        break;
      }
      case 104:
      {
        usage();
        return -1;
      }
      case 108:
      {
        srv_settings.log_path = optarg;
        break;
      }
      case 80:
      {
        srv_settings.pid_file = optarg;
        break;
      }
      case 118:
      {
        printf("intercept version:%s\n", (const void *)"0.6.3");
        return -1;
      }
      case 100:
      {
        srv_settings.do_daemonize = (unsigned int)1;
        break;
      }
      default:
      {
        fprintf(stderr, "Illegal argument \"%c\"\n", c);
        return -1;
      }
    }
  }
  while((_Bool)1);
  return 0;
}

// release_resources
// file main.c line 24
static void release_resources()
{
  tc_log_info(6, 0, "release_resources begin");
  interception_over();
  tc_event_loop_finish(&s_event_loop);
  tc_log_info(6, 0, "release_resources end except log file");
  tc_log_end();
}

// retrieve_ip_addr
// file main.c line 88
static signed int retrieve_ip_addr()
{
  signed int count = 0;
  char tmp[32l];
  unsigned long int len;
  unsigned int address;
  const char *split;
  const char *p;
  memset((void *)tmp, 0, (unsigned long int)32);
  p = srv_settings.raw_ip_list;
  signed int tmp_post_1;
  while((_Bool)1)
  {
    split=strchr(p, 44);
    if(!(split == ((const char *)NULL)))
      len = (unsigned long int)(split - p);

    else
      len=strlen(p);
    strncpy(tmp, p, len);
    address=inet_addr(tmp);
    tmp_post_1 = count;
    count = count + 1;
    srv_settings.passed_ips.ips[(signed long int)tmp_post_1] = address;
    if(count == 32)
    {
      tc_log_info(5, 0, "reach the limit for passing firewall");
      break;
    }

    if(split == ((const char *)NULL))
      break;

    else
      p = split + (signed long int)1;
    memset((void *)tmp, 0, (unsigned long int)32);
  }
  srv_settings.passed_ips.num = count;
  return 1;
}

// route_delete_obsolete
// file tc_router.c line 15
void route_delete_obsolete(signed long int cur_time)
{
  signed int i;
  signed int count = 0;
  signed int timeout;
  struct hash_node_s *hn;
  struct link_list_s *l;
  struct link_node_s *ln;
  tc_log_info(6, 0, "router size:%u", table->total);
  pthread_mutex_lock(&mutex);
  i = 0;
  for( ; !((unsigned int)i >= table->size); i = i + 1)
  {
    l = table->lists[(signed long int)i];
    if(l->size >= 1)
      while((_Bool)1)
      {
        ln=link_list_tail(l);
        if(ln == ((struct link_node_s *)NULL))
          break;

        hn = (struct hash_node_s *)ln->data;
        timeout = table->timeout;
        if(hn->visit_cnt == 0u)
          timeout = 3;

        if(!(hn->access_time + (signed long int)timeout >= cur_time))
        {
          link_list_pop_tail(l);
          free((void *)hn);
          ln->data = (void *)0;
          free((void *)ln);
          table->total = table->total - 1u;
          count = count + 1;
        }

        else
          break;
      }

  }
  tc_log_info(6, 0, "router delete obsolete:%d", count);
  delay_table_delete_obsolete(cur_time);
  pthread_mutex_unlock(&mutex);
}

// router_add
// file tc_router.c line 105
void router_add(unsigned int ip, unsigned short int port, signed int fd)
{
  unsigned long int key;
  key=get_key(ip, port);
  pthread_mutex_lock(&mutex);
  hash_add(table, key, (void *)(signed long int)fd);
  delay_table_send(key, fd);
  pthread_mutex_unlock(&mutex);
}

// router_del
// file tc_router.c line 86
void router_del(unsigned int ip, unsigned short int port)
{
  unsigned long int key;
  key=get_key(ip, port);
  pthread_mutex_lock(&mutex);
  hash_del(table, key);
  delay_table_del(key);
  pthread_mutex_unlock(&mutex);
}

// router_destroy
// file tc_router.c line 216
void router_destroy()
{
  pthread_mutex_lock(&mutex);
  if(!(table == ((struct hash_table_s *)NULL)))
  {
    tc_log_info(6, 0, "destroy router table");
    tc_log_info(6, 0, "fd null counter:%llu", fd_null_cnt);
    hash_destroy(table);
    free((void *)table);
    table = (struct hash_table_s *)(void *)0;
    delay_table_destroy();
  }

  pthread_mutex_unlock(&mutex);
}

// router_init
// file tc_router.c line 72
void router_init(unsigned long int size, signed int timeout)
{
  pthread_mutex_init(&mutex, (const union anonymous_11 *)(void *)0);
  delay_table_init(size);
  table=hash_create(size << 1);
  hash_set_timeout(table, timeout);
  strcpy(table->name, "router-table");
  tc_log_info(6, 0, "create %s, size:%u", (const void *)table->name, table->size);
}

// router_update
// file tc_router.c line 124
void router_update(struct iphdr *ip_header, signed int len)
{
  void *fd;
  unsigned int size_ip;
  unsigned long int key;
  struct msg_server_s msg;
  struct tcphdr *tcp_header;
  size_ip = (unsigned int)((signed int)ip_header->ihl << 2);
  tcp_header = (struct tcphdr *)((char *)ip_header + (signed long int)size_ip);
  unsigned short int return_value_ntohs_1;
  return_value_ntohs_1=ntohs(tcp_header->_anon0._anon1.source);
  tc_log_info(8, 0, (const char *)"router update:%u", return_value_ntohs_1);
  memcpy((void *)&msg, (const void *)ip_header, (unsigned long int)len);
  key=get_key(ip_header->daddr, tcp_header->_anon0._anon1.dest);
  pthread_mutex_lock(&mutex);
  fd=hash_find(table, key);
  if(fd == NULL)
  {
    tc_log_info(8, 0, (const char *)"fd is null");
    fd_null_cnt = fd_null_cnt + 1ul;
    delay_table_add(key, &msg);
    pthread_mutex_unlock(&mutex);
  }

  else
  {
    pthread_mutex_unlock(&mutex);
    tc_socket_send((signed int)(signed long int)fd, (char *)&msg, sizeof(struct msg_server_s) /*40ul*/ );
  }
}

// set_details
// file main.c line 207
static signed int set_details()
{
  signed int return_value_sigignore_1;
  return_value_sigignore_1=sigignore(13);
  if(return_value_sigignore_1 == -1)
  {
    perror("failed to ignore SIGPIPE; sigaction");
    return -1;
  }

  else
  {
    if(!(srv_settings.raw_ip_list == ((char *)NULL)))
    {
      tc_log_info(6, 0, "-x parameter:%s", srv_settings.raw_ip_list);
      retrieve_ip_addr();
    }

    if(srv_settings.timeout == 0)
      srv_settings.timeout = 120;

    if(!(srv_settings.do_daemonize == 0u))
    {
      signed int return_value_sigignore_3;
      return_value_sigignore_3=sigignore(1);
      if(return_value_sigignore_3 == -1)
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        tc_log_info(4, *return_value___errno_location_2, "Failed to ignore SIGHUP");
      }

      signed int return_value_daemonize_4;
      return_value_daemonize_4=daemonize();
      if(return_value_daemonize_4 == -1)
      {
        fprintf(stderr, "failed to daemon() in order to daemonize\n");
        return -1;
      }

    }

    signed int return_value_tc_time_set_timer_5;
    return_value_tc_time_set_timer_5=tc_time_set_timer((signed long int)1000);
    if(return_value_tc_time_set_timer_5 == -1)
    {
      tc_log_info(4, 0, "set timer error");
      return -1;
    }

    else
      return 0;
  }
}

// set_signal_handler
// file main.c line 68
static void set_signal_handler()
{
  signed int i = 1;
  atexit((void (*)(void))release_resources);
  for( ; !(i >= 22); i = i + 1)
    if(!(i == 9) && !(i == 13) && !(i == 19))
    {
      if(!(i == 14))
        signal(i, signal_handler);

      else
        signal(i, tc_time_sig_alarm);
    }

}

// settings_init
// file main.c line 245
static void settings_init(void)
{
  srv_settings.port = (unsigned short int)36524;
  srv_settings.hash_size = (unsigned long int)65536;
  srv_settings.binded_ip = (char *)(void *)0;
  set_signal_handler();
}

// sigignore
// file main.c line 36
static signed int sigignore(signed int sig)
{
  struct sigaction sa;
  sa.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  sa.sa_flags = 0;
  signed int return_value_sigemptyset_1;
  return_value_sigemptyset_1=sigemptyset(&sa.sa_mask);
  _Bool tmp_if_expr_3;
  signed int return_value_sigaction_2;
  if(return_value_sigemptyset_1 == -1)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_sigaction_2=sigaction(sig, &sa, ((struct sigaction *)NULL));
    tmp_if_expr_3 = return_value_sigaction_2 == -1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
    return -1;

  else
    return 0;
}

// signal_handler
// file main.c line 51
static void signal_handler(signed int sig)
{
  tc_log_info(4, 0, "set signal handler:%d", sig);
  printf("set signal handler:%d\n", sig);
  if(sig == 11)
  {
    tc_log_info(4, 0, "SIGSEGV error");
    release_resources();
    signal(11, (void (*)(signed int))0);
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    kill(return_value_getpid_1, sig);
  }

  else
    exit(0);
}

// tc_event_add
// file ../event/tc_event.h line 74
signed int tc_event_add(struct tc_event_loop_s *loop, struct tc_event_s *ev, signed int events)
{
  struct anonymous_7 *actions;
  ev->loop = loop;
  actions = loop->actions;
  if(events == 0)
    return 0;

  else
  {
    signed int return_value;
    return_value=actions->add(loop, ev, events);
    if(return_value == -1)
      return -1;

    else
    {
      if(!((1 & events) == 0))
        ev->reg_evs = ev->reg_evs | 1;

      if(!((2 & events) == 0))
        ev->reg_evs = ev->reg_evs | 2;

      return 0;
    }
  }
}

// tc_event_create
// file ../event/tc_event.h line 77
struct tc_event_s * tc_event_create(signed int fd, signed int (*reader)(struct tc_event_s *), signed int (*writer)(struct tc_event_s *))
{
  struct tc_event_s *ev;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct tc_event_s) /*48ul*/ );
  ev = (struct tc_event_s *)return_value_malloc_1;
  if(ev == ((struct tc_event_s *)NULL))
    return (struct tc_event_s *)(void *)0;

  else
  {
    ev->events = 0;
    ev->reg_evs = 0;
    ev->index = -1;
    ev->fd = fd;
    ev->next = (struct tc_event_s *)(void *)0;
    ev->read_handler = reader;
    ev->write_handler = writer;
    return ev;
  }
}

// tc_event_del
// file ../event/tc_event.h line 75
signed int tc_event_del(struct tc_event_loop_s *loop, struct tc_event_s *ev, signed int events)
{
  struct anonymous_7 *actions = loop->actions;
  if(events == 0)
    return 0;

  else
  {
    signed int return_value;
    return_value=actions->del(loop, ev, events);
    if(return_value == -1)
      return -1;

    else
    {
      if(!((1 & events) == 0))
        ev->reg_evs = ev->reg_evs & ~1;

      if(!((2 & events) == 0))
        ev->reg_evs = ev->reg_evs & ~2;

      return 0;
    }
  }
}

// tc_event_destroy
// file tc_event.c line 193
void tc_event_destroy(struct tc_event_s *ev)
{
  ev->loop = (struct tc_event_loop_s *)(void *)0;
  ev->read_handler = (signed int (*)(struct tc_event_s *))(void *)0;
  ev->write_handler = (signed int (*)(struct tc_event_s *))(void *)0;
  free((void *)ev);
}

// tc_event_loop_finish
// file ../event/tc_event.h line 72
signed int tc_event_loop_finish(struct tc_event_loop_s *loop)
{
  struct tc_event_timer_s *timer;
  struct tc_event_timer_s *curr;
  struct anonymous_7 *actions = loop->actions;
  if(!(actions == ((struct anonymous_7 *)NULL)))
  {
    actions->destroy(loop);
    loop->actions = (struct anonymous_7 *)(void *)0;
  }

  timer = loop->timers;
  while(!(timer == ((struct tc_event_timer_s *)NULL)))
  {
    curr = timer;
    timer = timer->next;
    free((void *)curr);
  }
  loop->timers = (struct tc_event_timer_s *)(void *)0;
  return 0;
}

// tc_event_loop_init
// file ../event/tc_event.h line 71
signed int tc_event_loop_init(struct tc_event_loop_s *loop, signed int size)
{
  struct anonymous_7 *actions = &tc_event_actions;
  loop->size = size;
  loop->actions = actions;
  loop->active_events = (struct tc_event_s *)(void *)0;
  loop->timers = (struct tc_event_timer_s *)(void *)0;
  signed int return_value;
  return_value=actions->create(loop);
  if(return_value == -1)
    return -1;

  else
    return 0;
}

// tc_event_process_cycle
// file ../event/tc_event.h line 73
signed int tc_event_process_cycle(struct tc_event_loop_s *loop)
{
  signed int ret;
  signed long int timeout;
  struct tc_event_s *act_event;
  struct tc_event_s *act_next;
  struct anonymous_7 *actions = loop->actions;
  timeout=tc_event_timer_find(loop);
  if(timeout == 0l || timeout >= 1001l)
    timeout = (signed long int)500;

  loop->active_events = (struct tc_event_s *)(void *)0;
  ret=actions->poll(loop, timeout);
  if(loop->event_over == 0)
  {
    if(!(tc_update_time == 0))
    {
      tc_time_update();
      tc_update_time = 0;
    }

    tc_event_timer_run(loop);
    if(!(ret == 1) && !(ret == -1))
    {
      act_event = loop->active_events;
      if(!(act_event == ((struct tc_event_s *)NULL)))
      {
        act_next = act_event->next;
        if(!((1 & act_event->events) == 0))
        {
          signed int return_value;
          return_value=act_event->read_handler(act_event);
        }

        if(!((2 & act_event->events) == 0))
        {
          signed int return_value_1;
          return_value_1=act_event->write_handler(act_event);
        }

        if(act_event->reg_evs == 0)
          tc_event_destroy(act_event);

        act_event = act_next;
      }

    }

  }


FINISH:
  ;
  return 0;
}

// tc_event_timer_add
// file tc_event.c line 203
signed int tc_event_timer_add(struct tc_event_loop_s *loop, signed long int msec, void (*handler)(struct tc_event_timer_s *))
{
  struct tc_event_timer_s *timer;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct tc_event_timer_s) /*24ul*/ );
  timer = (struct tc_event_timer_s *)return_value_malloc_1;
  if(timer == ((struct tc_event_timer_s *)NULL))
    return -1;

  else
  {
    timer->handler = handler;
    timer->msec = tc_current_time_msec + msec;
    timer->next = loop->timers;
    loop->timers = timer;
    return 0;
  }
}

// tc_event_timer_find
// file tc_event.c line 223
static signed long int tc_event_timer_find(struct tc_event_loop_s *loop)
{
  signed long int min;
  struct tc_event_timer_s *timer;
  min = (signed long int)0;
  timer = loop->timers;
  _Bool tmp_if_expr_1;
  for( ; !(timer == ((struct tc_event_timer_s *)NULL)); timer = timer->next)
  {
    if(min == 0l)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = timer->msec < min ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      min = timer->msec;

  }
  if(min >= 1l)
    min = min - tc_current_time_msec;

  return min < (signed long int)0 ? (signed long int)0 : min;
}

// tc_event_timer_run
// file tc_event.c line 243
static void tc_event_timer_run(struct tc_event_loop_s *loop)
{
  struct tc_event_timer_s *timer;
  struct tc_event_timer_s *prev;
  struct tc_event_timer_s *next;
  prev = (struct tc_event_timer_s *)(void *)0;
  timer = loop->timers;
  while(!(timer == ((struct tc_event_timer_s *)NULL)))
    if(tc_current_time_msec >= timer->msec)
    {
      if(timer->handler == ((void (*)(struct tc_event_timer_s *))NULL))
        goto __CPROVER_DUMP_L4;

      timer->handler(timer);
      if(!(prev == ((struct tc_event_timer_s *)NULL)))
        prev->next = timer->next;

      else
        loop->timers = timer->next;
      next = timer->next;
      free((void *)timer);
      timer = next;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      prev = timer;
      timer = timer->next;
    }
}

// tc_localtime
// file tc_time.c line 78
void tc_localtime(signed long int sec, struct tm *tm)
{
  localtime_r(&sec, tm);
  tm->tm_mon = tm->tm_mon + 1;
  tm->tm_year = tm->tm_year + 1900;
}

// tc_log_end
// file ../../src/core/tc_log.h line 17
void tc_log_end()
{
  if(!(log_fd == -1))
    close(log_fd);

  log_fd = -1;
}

// tc_log_info
// file ../../src/core/tc_log.h line 19
void tc_log_info(signed int level, signed int err, const char *fmt, ...)
{
  char tc_log_info__1__buffer[2048l];
  char *p;
  unsigned long int n;
  void **args;
  struct anonymous_0 *ll;
  char *tmp_post_2;
  char *tmp_post_4;
  char *tmp_post_8;
  if(!(log_fd == -1))
  {
    tc_time_update();
    ll = &tc_log_levels[(signed long int)level];
    p = tc_log_info__1__buffer;
    void *return_value_memcpy_1;
    return_value_memcpy_1=memcpy((void *)p, (void *)tc_error_log_time, sizeof(char [25l]) /*25ul*/  - (unsigned long int)1);
    p = (char *)return_value_memcpy_1 + (signed long int)(sizeof(char [25l]) /*25ul*/  - (unsigned long int)1);
    tmp_post_2 = p;
    p = p + 1l;
    *tmp_post_2 = (char)32;
    void *return_value_memcpy_3;
    return_value_memcpy_3=memcpy((void *)p, (void *)ll->level, (unsigned long int)ll->len);
    p = (char *)return_value_memcpy_3 + (signed long int)ll->len;
    tmp_post_4 = p;
    p = p + 1l;
    *tmp_post_4 = (char)32;
    args = (void **)&fmt;
    signed int return_value_vsprintf_5;
    return_value_vsprintf_5=vsprintf(p, fmt, args);
    n = (unsigned long int)return_value_vsprintf_5;
    args = ((void **)NULL);
    p = p + (signed long int)n;
    if(err >= 1)
    {
      char *return_value_strerror_6;
      return_value_strerror_6=strerror(err);
      signed int return_value_sprintf_7;
      return_value_sprintf_7=sprintf(p, " (%s)", return_value_strerror_6);
      n = (unsigned long int)return_value_sprintf_7;
      p = p + (signed long int)n;
    }

    tmp_post_8 = p;
    p = p + 1l;
    *tmp_post_8 = (char)10;
    write(log_fd, (const void *)tc_log_info__1__buffer, (unsigned long int)(p - tc_log_info__1__buffer));
  }


__CPROVER_DUMP_L5:
  ;
}

// tc_log_init
// file tc_log.c line 24
signed int tc_log_init(const char *file)
{
  log_fd=open(file == (const char *)(void *)0 ? "error.log" : file, 02 | 0100 | 02000, 0644);
  if(log_fd == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "Open log file error: %s\n", return_value_strerror_2);
  }

  return log_fd;
}

// tc_log_trace
// file tc_log.c line 97
void tc_log_trace(signed int level, signed int err, signed int flag, struct iphdr *ip_header, struct tcphdr *tcp_header)
{
  char *tmp_buf;
  char src_ip[1024l];
  char dst_ip[1024l];
  unsigned short int window;
  unsigned int pack_size;
  unsigned int tc_log_trace__1__seq;
  unsigned int ack_seq;
  struct in_addr src_addr;
  struct in_addr dst_addr;
  src_addr.s_addr = ip_header->saddr;
  tmp_buf=inet_ntoa(src_addr);
  strcpy(src_ip, tmp_buf);
  dst_addr.s_addr = ip_header->daddr;
  tmp_buf=inet_ntoa(dst_addr);
  strcpy(dst_ip, tmp_buf);
  unsigned short int return_value_ntohs_1;
  return_value_ntohs_1=ntohs(ip_header->tot_len);
  pack_size = (unsigned int)return_value_ntohs_1;
  tc_log_trace__1__seq=ntohl(tcp_header->_anon0._anon1.seq);
  ack_seq=ntohl(tcp_header->_anon0._anon1.ack_seq);
  window = tcp_header->_anon0._anon1.window;
  if(flag == 1)
  {
    unsigned short int return_value_ntohs_2;
    return_value_ntohs_2=ntohs(tcp_header->_anon0._anon1.source);
    unsigned short int return_value_ntohs_3;
    return_value_ntohs_3=ntohs(tcp_header->_anon0._anon1.dest);
    tc_log_info(level, err, "from bak:%s:%u-->%s:%u,len %u,seq=%u,ack=%u,win:%u", (const void *)src_ip, return_value_ntohs_2, (const void *)dst_ip, return_value_ntohs_3, pack_size, tc_log_trace__1__seq, ack_seq, window);
  }

  else
    if(flag == 0)
    {
      unsigned short int return_value_ntohs_4;
      return_value_ntohs_4=ntohs(tcp_header->_anon0._anon1.source);
      unsigned short int return_value_ntohs_5;
      return_value_ntohs_5=ntohs(tcp_header->_anon0._anon1.dest);
      tc_log_info(level, err, "recv clt:%s:%u-->%s:%u,len %u,seq=%u,ack=%u,win:%u", (const void *)src_ip, return_value_ntohs_4, (const void *)dst_ip, return_value_ntohs_5, pack_size, tc_log_trace__1__seq, ack_seq, window);
    }

    else
      if(flag == 3)
      {
        unsigned short int return_value_ntohs_6;
        return_value_ntohs_6=ntohs(tcp_header->_anon0._anon1.source);
        unsigned short int return_value_ntohs_7;
        return_value_ntohs_7=ntohs(tcp_header->_anon0._anon1.dest);
        tc_log_info(level, err, "to bak:%s:%u-->%s:%u,len %u,seq=%u,ack=%u,win:%u", (const void *)src_ip, return_value_ntohs_6, (const void *)dst_ip, return_value_ntohs_7, pack_size, tc_log_trace__1__seq, ack_seq, window);
      }

      else
        if(flag == 2)
        {
          unsigned short int return_value_ntohs_8;
          return_value_ntohs_8=ntohs(tcp_header->_anon0._anon1.source);
          unsigned short int return_value_ntohs_9;
          return_value_ntohs_9=ntohs(tcp_header->_anon0._anon1.dest);
          tc_log_info(level, err, "fake clt:%s:%u-->%s:%u,len %u,seq=%u,ack=%u,win:%u", (const void *)src_ip, return_value_ntohs_8, (const void *)dst_ip, return_value_ntohs_9, pack_size, tc_log_trace__1__seq, ack_seq, window);
        }

        else
          if(flag == 4)
          {
            unsigned short int return_value_ntohs_10;
            return_value_ntohs_10=ntohs(tcp_header->_anon0._anon1.source);
            unsigned short int return_value_ntohs_11;
            return_value_ntohs_11=ntohs(tcp_header->_anon0._anon1.dest);
            tc_log_info(level, err, "unkown packet:%s:%u-->%s:%u,len %u,seq=%u,ack=%u", (const void *)src_ip, return_value_ntohs_10, (const void *)dst_ip, return_value_ntohs_11, pack_size, tc_log_trace__1__seq, ack_seq);
          }

          else
          {
            unsigned short int return_value_ntohs_12;
            return_value_ntohs_12=ntohs(tcp_header->_anon0._anon1.source);
            unsigned short int return_value_ntohs_13;
            return_value_ntohs_13=ntohs(tcp_header->_anon0._anon1.dest);
            tc_log_info(level, err, "strange %s:%u-->%s:%u,length %u,seq=%u,ack=%u", (const void *)src_ip, return_value_ntohs_12, (const void *)dst_ip, return_value_ntohs_13, pack_size, tc_log_trace__1__seq, ack_seq);
          }
}

// tc_msg_event_accept
// file tc_interception.c line 85
static signed int tc_msg_event_accept(struct tc_event_s *rev)
{
  signed int fd;
  struct tc_event_s *ev;
  fd=accept(rev->fd, (struct sockaddr *)(void *)0, (unsigned int *)(void *)0);
  if(fd == -1)
  {
    tc_log_info(4, 0, "msg accept failed, from listen:%d", rev->fd);
    return -1;
  }

  else
  {
    signed int return_value_tc_socket_set_nodelay_1;
    return_value_tc_socket_set_nodelay_1=tc_socket_set_nodelay(fd);
    if(return_value_tc_socket_set_nodelay_1 == -1)
    {
      tc_log_info(4, 0, "Set no delay to socket(%d) failed.", rev->fd);
      return -1;
    }

    else
    {
      ev=tc_event_create(fd, tc_msg_event_process, (signed int (*)(struct tc_event_s *))(void *)0);
      if(ev == ((struct tc_event_s *)NULL))
      {
        tc_log_info(4, 0, "Msg event create failed.");
        return -1;
      }

      else
      {
        signed int return_value_tc_event_add_2;
        return_value_tc_event_add_2=tc_event_add(rev->loop, ev, 1);
        if(return_value_tc_event_add_2 == -1)
          return -1;

        else
          return 0;
      }
    }
  }
}

// tc_msg_event_process
// file tc_interception.c line 114
static signed int tc_msg_event_process(struct tc_event_s *rev)
{
  struct msg_client_s msg;
  signed int return_value_tc_socket_recv_1;
  return_value_tc_socket_recv_1=tc_socket_recv(rev->fd, (char *)&msg, (signed long int)sizeof(struct msg_client_s) /*8ul*/ );
  unsigned short int return_value_ntohs_2;
  unsigned short int return_value_ntohs_3;
  if(return_value_tc_socket_recv_1 == -1)
  {
    close(rev->fd);
    tc_log_info(6, 0, "close sock:%d", rev->fd);
    tc_event_del(rev->loop, rev, 1);
    return -1;
  }

  else
  {
    switch((signed int)msg.type)
    {
      case 1:
      {
        return_value_ntohs_2=ntohs(msg.client_port);
        tc_log_info(8, 0, (const char *)"add client router:%u", return_value_ntohs_2);
        router_add(msg.client_ip, msg.client_port, rev->fd);
        break;
      }
      case 2:
      {
        return_value_ntohs_3=ntohs(msg.client_port);
        tc_log_info(8, 0, (const char *)"del client router:%u", return_value_ntohs_3);
        router_del(msg.client_ip, msg.client_port);
      }
    }
    return 0;
  }
}

// tc_nl_check_cleaning
// file tc_interception.c line 142
static void tc_nl_check_cleaning()
{
  signed int diff;
  signed long int now = tc_current_time_sec;
  diff = (signed int)(now - last_clean_time);
  if(diff >= 16)
  {
    tc_log_info(6, 0, "total response packets:%llu", tot_resp_packs);
    route_delete_obsolete(now);
    last_clean_time = now;
  }

}

// tc_nl_event_process
// file tc_interception.c line 330
static signed int tc_nl_event_process(struct tc_event_s *rev)
{
  signed int i;
  signed int pass_through_flag = 0;
  char tc_nl_event_process__1__buffer[65535l];
  unsigned long int packet_id;
  struct iphdr *ip_hdr;
  packet_id = (unsigned long int)0;
  signed int return_value_tc_nl_socket_recv_1;
  return_value_tc_nl_socket_recv_1=tc_nl_socket_recv(rev->fd, tc_nl_event_process__1__buffer, (unsigned long int)65535);
  if(return_value_tc_nl_socket_recv_1 == -1)
    return -1;

  else
  {
    ip_hdr = (struct iphdr *)((struct ipq_packet_msg *)(void *)((char *)(struct nlmsghdr *)tc_nl_event_process__1__buffer + (signed long int)(0 + (signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)))))->payload;
    packet_id = ((struct ipq_packet_msg *)(void *)((char *)(struct nlmsghdr *)tc_nl_event_process__1__buffer + (signed long int)(0 + (signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)))))->packet_id;
    if(!(ip_hdr == ((struct iphdr *)NULL)))
    {
      i = 0;
      for( ; !(i >= srv_settings.passed_ips.num); i = i + 1)
        if(srv_settings.passed_ips.ips[(signed long int)i] == ip_hdr->daddr)
        {
          pass_through_flag = 1;
          break;
        }

      if(!(pass_through_flag == 0))
        put_nl_verdict_to_pool(rev->fd, 1, packet_id);

      else
      {
        tot_resp_packs = tot_resp_packs + 1ul;
        put_resp_header_to_pool(ip_hdr);
        put_nl_verdict_to_pool(rev->fd, 0, packet_id);
      }
    }

    return 0;
  }
}

// tc_nl_socket_init
// file ../communication/tc_socket.h line 23
signed int tc_nl_socket_init()
{
  signed int fd;
  signed int rcvbuf;
  unsigned char tc_nl_socket_init__1__buf[128l];
  struct nlmsghdr *nl_header;
  struct sockaddr_nl addr;
  struct ipq_mode_msg *mode_data;
  rcvbuf = 1048576;
  fd=socket(16, 3, 3);
  if(fd == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    tc_log_info(4, *return_value___errno_location_1, "Create netlink socket failed");
    return -1;
  }

  signed int return_value_setsockopt_3;
  return_value_setsockopt_3=setsockopt(fd, 1, 8, (const void *)&rcvbuf, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(return_value_setsockopt_3 == -1)
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    tc_log_info(4, *return_value___errno_location_2, "Set netlink socket(%d) recvbuf to (%d) failed", fd, rcvbuf);
    return -1;
  }

  tc_socket_set_nonblocking(fd);
  memset((void *)&addr, 0, sizeof(struct sockaddr_nl) /*12ul*/ );
  memset((void *)&tc_nl_socket_init__1__buf, 0, (unsigned long int)128);
  addr.nl_family = (unsigned short int)16;
  nl_header = (struct nlmsghdr *)tc_nl_socket_init__1__buf;
  nl_header->nlmsg_len = (unsigned int)(sizeof(struct ipq_peer_msg) /*24ul*/  + (unsigned long int)(signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)));
  nl_header->nlmsg_flags = (unsigned short int)1;
  nl_header->nlmsg_type = (unsigned short int)(0x10 + 1);
  signed int return_value_getpid_4;
  return_value_getpid_4=getpid();
  nl_header->nlmsg_pid = (unsigned int)return_value_getpid_4;
  mode_data = (struct ipq_mode_msg *)(void *)((char *)nl_header + (signed long int)(0 + (signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1))));
  mode_data->value = (unsigned char)2;
  mode_data->range = (unsigned long int)65536;
  signed long int return_value_sendto_6;
  return_value_sendto_6=sendto(fd, (void *)nl_header, (unsigned long int)nl_header->nlmsg_len, 0, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_nl) /*12ul*/ );
  if(return_value_sendto_6 == -1l)
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    tc_log_info(4, *return_value___errno_location_5, "Set netlink socket(%d) mode failed, check if ip queue is run", fd);
    return -1;
  }

  return fd;
}

// tc_nl_socket_recv
// file ../communication/tc_socket.h line 24
signed int tc_nl_socket_recv(signed int fd, char *buffer, unsigned long int len)
{
  signed long int recv_len;
  recv_len=recv(fd, (void *)buffer, len, 0);
  if(recv_len == -1l)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 11)
      return 0;

    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    tc_log_info(4, *return_value___errno_location_2, "nl recvfrom");
    return -1;
  }

  if(recv_len == 0l)
  {
    tc_log_info(4, 0, "recv len is 0");
    return -1;
  }

  else
    if(!((unsigned long int)recv_len >= sizeof(struct nlmsghdr) /*16ul*/ ))
    {
      tc_log_info(4, 0, "recv length not right for netlink");
      return -1;
    }

    else
      if(!((unsigned long int)recv_len >= 112ul))
      {
        tc_log_info(5, 0, "netlink recv msg len:%ld, expect len:%ld.(privilage problems or not the obj of tcpcopy)", recv_len, sizeof(struct ipq_packet_msg) /*96ul*/  + (unsigned long int)(0 + (signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1))));
        return -1;
      }

      else
        return 0;
}

// tc_raw_socket_in_init
// file tc_socket.c line 6
signed int tc_raw_socket_in_init()
{
  signed int fd;
  signed int recv_buf_opt;
  signed int ret;
  unsigned int opt_len;
  fd=socket(2, 3, 6);
  if(fd == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    tc_log_info(4, *return_value___errno_location_1, "Create raw socket to input failed");
    return -1;
  }

  recv_buf_opt = 67108864;
  opt_len = (unsigned int)sizeof(signed int) /*4ul*/ ;
  ret=setsockopt(fd, 1, 8, (const void *)&recv_buf_opt, opt_len);
  if(ret == -1)
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    tc_log_info(4, *return_value___errno_location_2, "Set raw socket(%d)'s recv buffer failed");
    return -1;
  }

  return fd;
}

// tc_raw_socket_out_init
// file tc_socket.c line 45
signed int tc_raw_socket_out_init()
{
  signed int fd;
  signed int n = 1;
  fd=socket(2, 3, 255);
  if(fd == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    tc_log_info(4, *return_value___errno_location_1, "Create raw socket to output failed");
    return -1;
  }

  signed int return_value_setsockopt_3;
  return_value_setsockopt_3=setsockopt(fd, 0, 3, (const void *)&n, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_setsockopt_3 >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    tc_log_info(4, *return_value___errno_location_2, "Set raw socket(%d) option \"IP_HDRINCL\" failed", fd);
    return -1;
  }

  return fd;
}

// tc_raw_socket_send
// file tc_socket.c line 83
signed int tc_raw_socket_send(signed int fd, void *buf, unsigned long int len, unsigned int ip)
{
  signed long int send_len;
  struct sockaddr_in dst_addr;
  if(fd >= 1)
  {
    memset((void *)&dst_addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    dst_addr.sin_family = (unsigned short int)2;
    dst_addr.sin_addr.s_addr = ip;
    send_len=sendto(fd, buf, len, 0, (struct sockaddr *)&dst_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(send_len == -1l)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      tc_log_info(4, *return_value___errno_location_1, "Raw socket(%d) send packet failed, packet len: %d", fd, len);
      return -1;
    }

  }

  return 0;
}

// tc_select_add_event
// file ./tc_select_module.h line 19
signed int tc_select_add_event(struct tc_event_loop_s *loop, struct tc_event_s *ev, signed int events)
{
  struct tc_select_multiplex_io_s *io = (struct tc_select_multiplex_io_s *)loop->io;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  signed int tmp_post_5;
  if(io->last >= loop->size)
    return -1;

  else
  {
    if(events == 1)
      tmp_if_expr_3 = ev->read_handler != ((signed int (*)(struct tc_event_s *))NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = ev->write_handler == (signed int (*)(struct tc_event_s *))(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      (&io->r_set)->__fds_bits[(signed long int)(ev->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&io->r_set)->__fds_bits[(signed long int)(ev->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << ev->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

    else
    {
      if(events == 2)
        tmp_if_expr_1 = ev->write_handler != ((signed int (*)(struct tc_event_s *))NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        tmp_if_expr_2 = ev->read_handler == (signed int (*)(struct tc_event_s *))(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        (&io->w_set)->__fds_bits[(signed long int)(ev->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&io->w_set)->__fds_bits[(signed long int)(ev->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << ev->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

      else
        return -1;
    }
    if(!(io->max_fd == -1))
    {
      if(!(io->max_fd >= ev->fd))
        io->max_fd = ev->fd;

    }

    ev->index = io->last;
    tmp_post_5 = io->last;
    io->last = io->last + 1;
    io->evs[(signed long int)tmp_post_5] = ev;
    return 0;
  }
}

// tc_select_create
// file ./tc_select_module.h line 17
signed int tc_select_create(struct tc_event_loop_s *loop)
{
  struct tc_event_s **evs;
  struct tc_select_multiplex_io_s *io;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)loop->size * sizeof(struct tc_event_s *) /*8ul*/ );
  evs = (struct tc_event_s **)return_value_malloc_1;
  if(evs == ((struct tc_event_s **)NULL))
    return -1;

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct tc_select_multiplex_io_s) /*272ul*/ );
    io = (struct tc_select_multiplex_io_s *)return_value_malloc_2;
    if(io == ((struct tc_select_multiplex_io_s *)NULL))
      return -1;

    else
    {
      do
      {
        signed int __d0;
        signed int tc_select_create__1__3____d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(tc_select_create__1__3____d1) : "a"(0), "0"(sizeof(struct anonymous_10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&io->r_set)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      do
      {
        signed int tc_select_create__1__4____d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(tc_select_create__1__4____d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&io->w_set)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      io->max_fd = -1;
      io->last = 0;
      io->evs = evs;
      loop->io = (void *)io;
      return 0;
    }
  }
}

// tc_select_del_event
// file ./tc_select_module.h line 20
signed int tc_select_del_event(struct tc_event_loop_s *loop, struct tc_event_s *ev, signed int events)
{
  struct tc_event_s *last_ev;
  struct tc_select_multiplex_io_s *io = (struct tc_select_multiplex_io_s *)loop->io;
  _Bool tmp_if_expr_1;
  if(!(ev->index >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ev->index >= io->last ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return -1;

  else
  {
    if(events == 1)
      (&io->r_set)->__fds_bits[(signed long int)(ev->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&io->r_set)->__fds_bits[(signed long int)(ev->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << ev->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));

    else
      if(events == 2)
        (&io->w_set)->__fds_bits[(signed long int)(ev->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&io->w_set)->__fds_bits[(signed long int)(ev->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << ev->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));

      else
        return -1;
    io->last = io->last - 1;
    if(!(ev->index >= io->last))
    {
      last_ev = io->evs[(signed long int)io->last];
      io->evs[(signed long int)ev->index] = last_ev;
      last_ev->index = ev->index;
    }

    ev->index = -1;
    if(io->max_fd == ev->fd)
      io->max_fd = -1;

    return 0;
  }
}

// tc_select_destroy
// file ./tc_select_module.h line 18
signed int tc_select_destroy(struct tc_event_loop_s *loop)
{
  signed int i;
  struct tc_select_multiplex_io_s *io = (struct tc_select_multiplex_io_s *)loop->io;
  i = 0;
  for( ; !(i >= io->last); i = i + 1)
    free((void *)io->evs[(signed long int)i]);
  free((void *)io->evs);
  free(loop->io);
  return 0;
}

// tc_select_polling
// file ./tc_select_module.h line 21
signed int tc_select_polling(struct tc_event_loop_s *loop, signed long int to)
{
  signed int i;
  signed int ret;
  struct anonymous_10 cur_read_set;
  struct anonymous_10 cur_write_set;
  struct tc_event_s **evs;
  struct timeval timeout;
  struct tc_select_multiplex_io_s *io = (struct tc_select_multiplex_io_s *)loop->io;
  evs = io->evs;
  if(io->max_fd == -1)
  {
    i = 0;
    for( ; !(i >= io->last); i = i + 1)
      if(!(io->max_fd >= evs[(signed long int)i]->fd))
        io->max_fd = evs[(signed long int)i]->fd;

  }

  timeout.tv_sec = (signed long int)(to / (signed long int)1000);
  timeout.tv_usec = (signed long int)((to % (signed long int)1000) * (signed long int)1000);
  cur_read_set = io->r_set;
  cur_write_set = io->w_set;
  ret=select(io->max_fd + 1, &cur_read_set, &cur_write_set, (struct anonymous_10 *)(void *)0, &timeout);
  if(ret == -1)
    return -1;

  else
    if(ret == 0)
      return 1;

    else
    {
      i = 0;
      for( ; !(i >= io->last); i = i + 1)
      {
        evs[(signed long int)i]->events = 0;
        if(!(evs[(signed long int)i]->read_handler == ((signed int (*)(struct tc_event_s *))NULL)))
        {
          if(!((cur_read_set.__fds_bits[(signed long int)(evs[(signed long int)i]->fd / 8)] & (signed long int)(1UL << evs[(signed long int)i]->fd % 8)) == 0l))
          {
            evs[(signed long int)i]->events = evs[(signed long int)i]->events | 1;
            evs[(signed long int)i]->next = loop->active_events;
            loop->active_events = evs[(signed long int)i];
          }

        }

        else
          if(!((cur_write_set.__fds_bits[(signed long int)(evs[(signed long int)i]->fd / 8)] & (signed long int)(1UL << evs[(signed long int)i]->fd % 8)) == 0l))
          {
            evs[(signed long int)i]->events = evs[(signed long int)i]->events | 2;
            evs[(signed long int)i]->next = loop->active_events;
            loop->active_events = evs[(signed long int)i];
          }

      }
      return 0;
    }
}

// tc_socket_connect
// file tc_socket.c line 253
signed int tc_socket_connect(signed int fd, unsigned int ip, unsigned short int port)
{
  unsigned int len;
  struct sockaddr_in remote_addr;
  memset((void *)&remote_addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  remote_addr.sin_family = (unsigned short int)2;
  remote_addr.sin_addr.s_addr = ip;
  remote_addr.sin_port=htons(port);
  len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  signed int return_value_connect_2;
  return_value_connect_2=connect(fd, (struct sockaddr *)&remote_addr, len);
  if(return_value_connect_2 == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    tc_log_info(4, *return_value___errno_location_1, "Can not connect to remote server(%d:%d)", ip, port);
    return -1;
  }

  return 0;
}

// tc_socket_init
// file ../communication/tc_socket.h line 26
signed int tc_socket_init()
{
  signed int fd;
  fd=socket(2, 1, 0);
  if(fd == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    tc_log_info(4, *return_value___errno_location_1, "Create socket failed");
    return -1;
  }

  return fd;
}

// tc_socket_listen
// file ../communication/tc_socket.h line 30
signed int tc_socket_listen(signed int fd, const char *bind_ip, unsigned short int port)
{
  unsigned int len;
  struct sockaddr_in local_addr;
  memset((void *)&local_addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  local_addr.sin_port=ntohs(port);
  local_addr.sin_family = (unsigned short int)2;
  if(!(bind_ip == ((const char *)NULL)))
    inet_aton(bind_ip, &local_addr.sin_addr);

  len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  signed int return_value_bind_2;
  return_value_bind_2=bind(fd, (struct sockaddr *)&local_addr, len);
  if(return_value_bind_2 == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    tc_log_info(4, *return_value___errno_location_1, "Bind socket(%d) to port:%d failed", fd, port);
    return -1;
  }

  signed int return_value_listen_4;
  return_value_listen_4=listen(fd, 5);
  if(return_value_listen_4 == -1)
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    tc_log_info(4, *return_value___errno_location_3, "Listen socket(%d) failed", fd);
    return -1;
  }

  return 0;
}

// tc_socket_recv
// file ../communication/tc_socket.h line 31
signed int tc_socket_recv(signed int fd, char *buffer, signed long int len)
{
  unsigned long int last;
  signed long int n;
  last = (unsigned long int)0;
  do
  {
    n=recv(fd, (void *)(buffer + (signed long int)last), (unsigned long int)len, 0);
    if(n == -1l)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 11)
        continue;

      else
        return -1;
    }

    if(n == 0l)
      return -1;

    last = last + (unsigned long int)n;
    len = len - n;
    if(len == 0l)
      break;

  }
  while((_Bool)1);
  return 0;
}

// tc_socket_send
// file ../communication/tc_socket.h line 32
signed int tc_socket_send(signed int fd, char *buffer, unsigned long int len)
{
  signed long int send_len;
  send_len=send(fd, (const void *)buffer, len, 0);
  if(!((unsigned long int)send_len == len))
  {
    tc_log_info(4, 0, "send length:%ld, buffer size:%ld", send_len, len);
    return -1;
  }

  else
    return 0;
}

// tc_socket_set_nodelay
// file ../communication/tc_socket.h line 28
signed int tc_socket_set_nodelay(signed int fd)
{
  signed int flag;
  unsigned int len;
  flag = 1;
  len = (unsigned int)sizeof(signed int) /*4ul*/ ;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 6, 1, (const void *)(char *)&flag, len);
  if(return_value_setsockopt_1 == -1)
    return -1;

  else
    return 0;
}

// tc_socket_set_nonblocking
// file tc_socket.c line 226
signed int tc_socket_set_nonblocking(signed int fd)
{
  signed int flags;
  flags=fcntl(fd, 3, 0);
  fcntl(fd, 4, flags | 04000);
  return 0;
}

// tc_time_init
// file ../../src/core/tc_time.h line 20
void tc_time_init()
{
  tc_update_time = 0;
  tc_time_update();
}

// tc_time_remove_timer
// file tc_time.c line 31
signed int tc_time_remove_timer()
{
  signed int return_value_setitimer_2;
  return_value_setitimer_2=setitimer(0, (struct itimerval *)(void *)0, (struct itimerval *)(void *)0);
  if(return_value_setitimer_2 == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    tc_log_info(4, *return_value___errno_location_1, "setitimer failed");
    return -1;
  }

  return 0;
}

// tc_time_set_timer
// file ../../src/core/tc_time.h line 18
signed int tc_time_set_timer(signed long int msec)
{
  struct itimerval value;
  value.it_value.tv_sec = msec / (signed long int)1000;
  value.it_value.tv_usec = (msec % (signed long int)1000) * (signed long int)1000;
  value.it_interval.tv_sec = msec / (signed long int)1000;
  value.it_interval.tv_usec = (msec % (signed long int)1000) * (signed long int)1000;
  signed int return_value_setitimer_2;
  return_value_setitimer_2=setitimer(0, &value, (struct itimerval *)(void *)0);
  if(return_value_setitimer_2 == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    tc_log_info(4, *return_value___errno_location_1, "setitimer failed");
    return -1;
  }

  return 0;
}

// tc_time_sig_alarm
// file ../../src/core/tc_time.h line 23
void tc_time_sig_alarm(signed int sig)
{
  tc_update_time = 1;
}

// tc_time_update
// file tc_time.c line 50
void tc_time_update(void)
{
  signed long int msec;
  signed long int sec;
  struct tm tm;
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  sec = tv.tv_sec;
  msec = tv.tv_usec / (signed long int)1000;
  tc_current_time_sec = sec;
  tc_current_time_msec = sec * (signed long int)1000 + msec;
  tc_localtime(sec, &tm);
  sprintf(cache_err_log_time, "%4d/%02d/%02d %02d:%02d:%02d +%03d", tm.tm_year, tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, (signed int)msec);
  tc_current_tm = tm;
  tc_error_log_time = cache_err_log_time;
}

// tcpcsum
// file tc_util.c line 145
unsigned short int tcpcsum(unsigned char *iphdr, unsigned short int *packet, signed int pack_len)
{
  unsigned short int res;
  memcpy((void *)buf, (const void *)(iphdr + (signed long int)12), (unsigned long int)8);
  buf[(signed long int)4]=htons((unsigned short int)iphdr[(signed long int)9]);
  buf[(signed long int)5]=htons((unsigned short int)pack_len);
  memcpy((void *)(buf + (signed long int)6), (const void *)packet, (unsigned long int)pack_len);
  res=csum(buf, pack_len + 12);
  return res;
}

// usage
// file main.c line 131
static void usage(void)
{
  printf("intercept 0.6.3\n");
  printf("-x <passlist,> passed ip list through firewall\n               format:\n               ip1, ip2, ...\n-p <num>       set the tcp port number to listen on. The default number is 36524.\n-s <num>       set the hash table size for intercept. The default value is 65536.\n-l <file>      save log information in <file>\n");
  printf("-t <num>       set the router item timeout limit. The default value is 120 sec\n-P <file>      save PID in <file>, only used with -d option\n-b <ip>        server binded ip address for listening\n-v             intercept version\n-h             print this help and exit\n-d             run as a daemon\n");
}

