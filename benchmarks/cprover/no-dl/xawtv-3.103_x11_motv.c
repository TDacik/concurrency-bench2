// #anon_enum_JCS_UNKNOWN=0_JCS_GRAYSCALE=1_JCS_RGB=2_JCS_YCbCr=3_JCS_CMYK=4_JCS_YCCK=5_JCS_EXT_RGB=6_JCS_EXT_RGBX=7_JCS_EXT_BGR=8_JCS_EXT_BGRX=9_JCS_EXT_XBGR=10_JCS_EXT_XRGB=11_JCS_EXT_RGBA=12_JCS_EXT_BGRA=13_JCS_EXT_ABGR=14_JCS_EXT_ARGB=15_JCS_RGB565=16
// file /usr/include/jpeglib.h line 215
enum anonymous_123 { JCS_UNKNOWN=0, JCS_GRAYSCALE=1, JCS_RGB=2, JCS_YCbCr=3, JCS_CMYK=4, JCS_YCCK=5, JCS_EXT_RGB=6, JCS_EXT_RGBX=7, JCS_EXT_BGR=8, JCS_EXT_BGRX=9, JCS_EXT_XBGR=10, JCS_EXT_XRGB=11, JCS_EXT_RGBA=12, JCS_EXT_BGRA=13, JCS_EXT_ABGR=14, JCS_EXT_ARGB=15, JCS_RGB565=16 };

// #anon_enum_JDCT_ISLOW=0_JDCT_IFAST=1_JDCT_FLOAT=2
// file /usr/include/jpeglib.h line 244
enum anonymous_128 { JDCT_ISLOW=0, JDCT_IFAST=1, JDCT_FLOAT=2 };

// #anon_enum_VBI_AUDIO_MODE_NONE=0_VBI_AUDIO_MODE_MONO=1_VBI_AUDIO_MODE_STEREO=2_VBI_AUDIO_MODE_STEREO_SURROUND=3_VBI_AUDIO_MODE_SIMULATED_STEREO=4_VBI_AUDIO_MODE_VIDEO_DESCRIPTIONS=5_VBI_AUDIO_MODE_NON_PROGRAM_AUDIO=6_VBI_AUDIO_MODE_SPECIAL_EFFECTS=7_VBI_AUDIO_MODE_DATA_SERVICE=8_VBI_AUDIO_MODE_UNKNOWN=9
// file /usr/include/libzvbi.h line 534
enum anonymous_89 { VBI_AUDIO_MODE_NONE=0, VBI_AUDIO_MODE_MONO=1, VBI_AUDIO_MODE_STEREO=2, VBI_AUDIO_MODE_STEREO_SURROUND=3, VBI_AUDIO_MODE_SIMULATED_STEREO=4, VBI_AUDIO_MODE_VIDEO_DESCRIPTIONS=5, VBI_AUDIO_MODE_NON_PROGRAM_AUDIO=6, VBI_AUDIO_MODE_SPECIAL_EFFECTS=7, VBI_AUDIO_MODE_DATA_SERVICE=8, VBI_AUDIO_MODE_UNKNOWN=9 };

// #anon_enum_VBI_BLACK=0_VBI_RED=1_VBI_GREEN=2_VBI_YELLOW=3_VBI_BLUE=4_VBI_MAGENTA=5_VBI_CYAN=6_VBI_WHITE=7
// file /usr/include/libzvbi.h line 761
enum anonymous_61 { VBI_BLACK=0, VBI_RED=1, VBI_GREEN=2, VBI_YELLOW=3, VBI_BLUE=4, VBI_MAGENTA=5, VBI_CYAN=6, VBI_WHITE=7 };

// #anon_enum_VBI_CNI_TYPE_NONE=0_VBI_CNI_TYPE_UNKNOWN=0_VBI_CNI_TYPE_VPS=1_VBI_CNI_TYPE_8301=2_VBI_CNI_TYPE_8302=3_VBI_CNI_TYPE_PDC_A=4_VBI_CNI_TYPE_PDC_B=5
// file /usr/include/libzvbi.h line 254
enum anonymous_76 { VBI_CNI_TYPE_NONE=0, VBI_CNI_TYPE_UNKNOWN=0, VBI_CNI_TYPE_VPS=1, VBI_CNI_TYPE_8301=2, VBI_CNI_TYPE_8302=3, VBI_CNI_TYPE_PDC_A=4, VBI_CNI_TYPE_PDC_B=5 };

// #anon_enum_VBI_DST_UNKNOWN=0_VBI_DST_INCLUDED=1_VBI_DST_INACTIVE=2_VBI_DST_ACTIVE=3
// file /usr/include/libzvbi.h line 676
enum anonymous_91 { VBI_DST_UNKNOWN=0, VBI_DST_INCLUDED=1, VBI_DST_INACTIVE=2, VBI_DST_ACTIVE=3 };

// #anon_enum_VBI_LINK_NONE=0_VBI_LINK_MESSAGE=1_VBI_LINK_PAGE=2_VBI_LINK_SUBPAGE=3_VBI_LINK_HTTP=4_VBI_LINK_FTP=5_VBI_LINK_EMAIL=6_VBI_LINK_LID=7_VBI_LINK_TELEWEB=8
// file /usr/include/libzvbi.h line 445
enum anonymous_81 { VBI_LINK_NONE=0, VBI_LINK_MESSAGE=1, VBI_LINK_PAGE=2, VBI_LINK_SUBPAGE=3, VBI_LINK_HTTP=4, VBI_LINK_FTP=5, VBI_LINK_EMAIL=6, VBI_LINK_LID=7, VBI_LINK_TELEWEB=8 };

// #anon_enum_VBI_PCS_AUDIO_UNKNOWN=0_VBI_PCS_AUDIO_MONO=1_VBI_PCS_AUDIO_STEREO=2_VBI_PCS_AUDIO_BILINGUAL=3
// file /usr/include/libzvbi.h line 370
enum anonymous_78 { VBI_PCS_AUDIO_UNKNOWN=0, VBI_PCS_AUDIO_MONO=1, VBI_PCS_AUDIO_STEREO=2, VBI_PCS_AUDIO_BILINGUAL=3 };

// #anon_enum_VBI_PID_CHANNEL_LCI_0=0_VBI_PID_CHANNEL_LCI_1=1_VBI_PID_CHANNEL_LCI_2=2_VBI_PID_CHANNEL_LCI_3=3_VBI_PID_CHANNEL_VPS=4_VBI_PID_CHANNEL_PDC_DESCRIPTOR=5_VBI_PID_CHANNEL_XDS_CURRENT=6_VBI_PID_CHANNEL_XDS_FUTURE=7_VBI_MAX_PID_CHANNELS=8
// file /usr/include/libzvbi.h line 346
enum anonymous_77 { VBI_PID_CHANNEL_LCI_0=0, VBI_PID_CHANNEL_LCI_1=1, VBI_PID_CHANNEL_LCI_2=2, VBI_PID_CHANNEL_LCI_3=3, VBI_PID_CHANNEL_VPS=4, VBI_PID_CHANNEL_PDC_DESCRIPTOR=5, VBI_PID_CHANNEL_XDS_CURRENT=6, VBI_PID_CHANNEL_XDS_FUTURE=7, VBI_MAX_PID_CHANNELS=8 };

// #anon_enum_VBI_PIXFMT_YUV420=1_VBI_PIXFMT_YUYV=2_VBI_PIXFMT_YVYU=3_VBI_PIXFMT_UYVY=4_VBI_PIXFMT_VYUY=5_VBI_PIXFMT_PAL8=6_VBI_PIXFMT_RGBA32_LE=32_VBI_PIXFMT_RGBA32_BE=33_VBI_PIXFMT_BGRA32_LE=34_VBI_PIXFMT_BGRA32_BE=35_VBI_PIXFMT_ABGR32_BE=32_VBI_PIXFMT_ABGR32_LE=33_VBI_PIXFMT_ARGB32_BE=34_VBI_PIXFMT_ARGB32_LE=35_VBI_PIXFMT_RGB24=36_VBI_PIXFMT_BGR24=37_VBI_PIXFMT_RGB16_LE=38_VBI_PIXFMT_RGB16_BE=39_VBI_PIXFMT_BGR16_LE=40_VBI_PIXFMT_BGR16_BE=41_VBI_PIXFMT_RGBA15_LE=42_VBI_PIXFMT_RGBA15_BE=43_VBI_PIXFMT_BGRA15_LE=44_VBI_PIXFMT_BGRA15_BE=45_VBI_PIXFMT_ARGB15_LE=46_VBI_PIXFMT_ARGB15_BE=47_VBI_PIXFMT_ABGR15_LE=48_VBI_PIXFMT_ABGR15_BE=49
// file /usr/include/libzvbi.h line 1069
enum anonymous_97 { VBI_PIXFMT_YUV420=1, VBI_PIXFMT_YUYV=2, VBI_PIXFMT_YVYU=3, VBI_PIXFMT_UYVY=4, VBI_PIXFMT_VYUY=5, VBI_PIXFMT_PAL8=6, VBI_PIXFMT_RGBA32_LE=32, VBI_PIXFMT_RGBA32_BE=33, VBI_PIXFMT_BGRA32_LE=34, VBI_PIXFMT_BGRA32_BE=35, VBI_PIXFMT_ABGR32_BE=32, VBI_PIXFMT_ABGR32_LE=33, VBI_PIXFMT_ARGB32_BE=34, VBI_PIXFMT_ARGB32_LE=35, VBI_PIXFMT_RGB24=36, VBI_PIXFMT_BGR24=37, VBI_PIXFMT_RGB16_LE=38, VBI_PIXFMT_RGB16_BE=39, VBI_PIXFMT_BGR16_LE=40, VBI_PIXFMT_BGR16_BE=41, VBI_PIXFMT_RGBA15_LE=42, VBI_PIXFMT_RGBA15_BE=43, VBI_PIXFMT_BGRA15_LE=44, VBI_PIXFMT_BGRA15_BE=45, VBI_PIXFMT_ARGB15_LE=46, VBI_PIXFMT_ARGB15_BE=47, VBI_PIXFMT_ABGR15_LE=48, VBI_PIXFMT_ABGR15_BE=49 };

// #anon_enum_VBI_PROG_CLASSF_NONE=0_VBI_PROG_CLASSF_EIA_608=1_VBI_PROG_CLASSF_ETS_300231=2
// file /usr/include/libzvbi.h line 524
enum anonymous_88 { VBI_PROG_CLASSF_NONE=0, VBI_PROG_CLASSF_EIA_608=1, VBI_PROG_CLASSF_ETS_300231=2 };

// #anon_enum_VBI_RATING_AUTH_NONE=0_VBI_RATING_AUTH_MPAA=1_VBI_RATING_AUTH_TV_US=2_VBI_RATING_AUTH_TV_CA_EN=3_VBI_RATING_AUTH_TV_CA_FR=4
// file /usr/include/libzvbi.h line 508
enum anonymous_86 { VBI_RATING_AUTH_NONE=0, VBI_RATING_AUTH_MPAA=1, VBI_RATING_AUTH_TV_US=2, VBI_RATING_AUTH_TV_CA_EN=3, VBI_RATING_AUTH_TV_CA_FR=4 };

// #anon_enum_VBI_SUBT_NONE=0_VBI_SUBT_ACTIVE=1_VBI_SUBT_MATTE=2_VBI_SUBT_UNKNOWN=3
// file /usr/include/libzvbi.h line 487
enum anonymous_84 { VBI_SUBT_NONE=0, VBI_SUBT_ACTIVE=1, VBI_SUBT_MATTE=2, VBI_SUBT_UNKNOWN=3 };

// #anon_enum_VBI_TRANSPARENT_SPACE=0_VBI_TRANSPARENT_FULL=1_VBI_SEMI_TRANSPARENT=2_VBI_OPAQUE=3
// file /usr/include/libzvbi.h line 775
enum anonymous_62 { VBI_TRANSPARENT_SPACE=0, VBI_TRANSPARENT_FULL=1, VBI_SEMI_TRANSPARENT=2, VBI_OPAQUE=3 };

// #anon_enum_VBI_WEBLINK_UNKNOWN=0_VBI_WEBLINK_PROGRAM_RELATED=1_VBI_WEBLINK_NETWORK_RELATED=2_VBI_WEBLINK_STATION_RELATED=3_VBI_WEBLINK_SPONSOR_MESSAGE=4_VBI_WEBLINK_OPERATOR=5
// file /usr/include/libzvbi.h line 459
enum anonymous_82 { VBI_WEBLINK_UNKNOWN=0, VBI_WEBLINK_PROGRAM_RELATED=1, VBI_WEBLINK_NETWORK_RELATED=2, VBI_WEBLINK_STATION_RELATED=3, VBI_WEBLINK_SPONSOR_MESSAGE=4, VBI_WEBLINK_OPERATOR=5 };

// #anon_enum_VBI_WST_LEVEL_1=0_VBI_WST_LEVEL_1p5=1_VBI_WST_LEVEL_2p5=2_VBI_WST_LEVEL_3p5=3
// file /usr/include/libzvbi.h line 2017
enum anonymous_23 { VBI_WST_LEVEL_1=0, VBI_WST_LEVEL_1p5=1, VBI_WST_LEVEL_2p5=2, VBI_WST_LEVEL_3p5=3 };

// #anon_enum_XmCHARSET_TEXT=0_XmMULTIBYTE_TEXT=1_XmWIDECHAR_TEXT=2_XmNO_TEXT=3
// file /usr/include/Xm/Xm.h line 215
enum anonymous_67 { XmCHARSET_TEXT=0, XmMULTIBYTE_TEXT=1, XmWIDECHAR_TEXT=2, XmNO_TEXT=3 };

// #anon_enum_XmOUTPUT_ALL=0_XmOUTPUT_BETWEEN=1_XmOUTPUT_BEGINNING=2_XmOUTPUT_END=3_XmOUTPUT_BOTH=4
// file /usr/include/Xm/Xm.h line 220
enum anonymous_68 { XmOUTPUT_ALL=0, XmOUTPUT_BETWEEN=1, XmOUTPUT_BEGINNING=2, XmOUTPUT_END=3, XmOUTPUT_BOTH=4 };

// #anon_enum_XrmoptionNoArg=0_XrmoptionIsArg=1_XrmoptionStickyArg=2_XrmoptionSepArg=3_XrmoptionResArg=4_XrmoptionSkipArg=5_XrmoptionSkipLine=6_XrmoptionSkipNArgs=7
// file /usr/include/X11/Xresource.h line 326
enum anonymous_12 { XrmoptionNoArg=0, XrmoptionIsArg=1, XrmoptionStickyArg=2, XrmoptionSepArg=3, XrmoptionResArg=4, XrmoptionSkipArg=5, XrmoptionSkipLine=6, XrmoptionSkipNArgs=7 };

// #anon_enum_XtGrabNone=0_XtGrabNonexclusive=1_XtGrabExclusive=2
// file /usr/include/X11/Intrinsic.h line 347
enum anonymous_17 { XtGrabNone=0, XtGrabNonexclusive=1, XtGrabExclusive=2 };

// tag-#anon#ST[*{S8}_S8_'name'|*{S8}_S8_'value'|U64'pixel']
// file /usr/include/X11/xpm.h line 100
struct anonymous_130;

// tag-#anon#ST[*{S8}_S8_'name'|S64'value']
// file /usr/include/X11/Intrinsic.h line 316
struct anonymous_11;

// tag-#anon#ST[*{S8}_S8_'name'|U32'nlines'|U32'_pad0'|*{*{S8}_S8_}_*{S8}_S8__'lines']
// file /usr/include/X11/xpm.h line 106
struct anonymous_131;

// tag-#anon#ST[*{S8}_S8_'option'|*{S8}_S8_'specifier'|SYM##anon_enum_XrmoptionNoArg=0_XrmoptionIsArg=1_XrmoptionStickyArg=2_XrmoptionSepArg=3_XrmoptionResArg=4_XrmoptionSkipArg=5_XrmoptionSkipLine=6_XrmoptionSkipNArgs=7#'argKind'|U32'_pad0'|*{S8}_S8_'value']
// file /usr/include/X11/Xresource.h line 338
struct anonymous_13;

// tag-#anon#ST[*{S8}_S8_'res_name'|*{S8}_S8_'res_class']
// file /usr/include/X11/Xutil.h line 189
struct anonymous_116;

// tag-#anon#ST[*{S8}_S8_'string'|*{S8}_S8_'symbolic'|*{S8}_S8_'m_color'|*{S8}_S8_'g4_color'|*{S8}_S8_'g_color'|*{S8}_S8_'c_color']
// file /usr/include/X11/xpm.h line 112
struct anonymous_132;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visual'|U64'visualid'|S32'screen'|S32'depth'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'colormap_size'|S32'bits_per_rgb']
// file /usr/include/X11/Xutil.h line 287
struct anonymous_1;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']
// file /usr/include/X11/Xlib.h line 257
struct anonymous_0;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private1'|S32'fd'|S32'private2'|S32'proto_major_version'|S32'proto_minor_version'|*{S8}_S8_'vendor'|U64'private3'|U64'private4'|U64'private5'|S32'private6'|U32'_pad0'|*{U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64}_U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64_'resource_alloc'|S32'byte_order'|S32'bitmap_unit'|S32'bitmap_pad'|S32'bitmap_bit_order'|S32'nformats'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']#_'pixmap_format'|S32'private8'|S32'release'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private9'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private10'|S32'qlen'|U32'_pad2'|U64'last_request_read'|U64'request'|*{S8}_S8_'private11'|*{S8}_S8_'private12'|*{S8}_S8_'private13'|*{S8}_S8_'private14'|U32'max_request_size'|U32'_pad3'|*{SYM#tag-_XrmHashBucketRec#}_SYM#tag-_XrmHashBucketRec#_'db'|*{S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32}_S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32_'private15'|*{S8}_S8_'display_name'|S32'default_screen'|S32'nscreens'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#_'screens'|U64'motion_buffer'|U64'private16'|S32'min_keycode'|S32'max_keycode'|*{S8}_S8_'private17'|*{S8}_S8_'private18'|S32'private19'|U32'_pad4'|*{S8}_S8_'xdefaults']
// file /usr/include/X11/Xlib.h line 493
struct anonymous_10;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']
// file /usr/include/X11/Xlib.h line 280
struct anonymous_134;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'fid'|U32'direction'|U32'min_char_or_byte2'|U32'max_char_or_byte2'|U32'min_byte1'|U32'max_byte1'|S32'all_chars_exist'|U32'default_char'|S32'n_properties'|*{SYM#tag-#anon#ST[U64'name'|U64'card32']#}_SYM#tag-#anon#ST[U64'name'|U64'card32']#_'properties'|SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#'min_bounds'|SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#'max_bounds'|*{SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#}_SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#_'per_char'|S32'ascent'|S32'descent']
// file /usr/include/X11/Xlib.h line 1035
struct anonymous_14;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']
// file /usr/include/X11/Xlib.h line 227
struct anonymous_8;

// tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_106;

// tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_104;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_115;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_122;

// tag-#anon#ST[ARR16{U64}_U64_'__val']
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_16;

// tag-#anon#ST[ARR17{U8}_U8_'bits'|ARR256{U8}_U8_'huffval'|U24'_pad0'|S32'sent_table']
// file /usr/include/jpeglib.h line 101
struct anonymous_126;

// tag-#anon#ST[ARR64{U16}_U16_'quantval'|S32'sent_table']
// file /usr/include/jpeglib.h line 84
struct anonymous_125;

// tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']
// file /usr/include/X11/Xlib.h line 1017
struct anonymous_120;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_71;

// tag-#anon#ST[S32'component_id'|S32'component_index'|S32'h_samp_factor'|S32'v_samp_factor'|S32'quant_tbl_no'|S32'dc_tbl_no'|S32'ac_tbl_no'|U32'width_in_blocks'|U32'height_in_blocks'|S32'DCT_scaled_size'|U32'downsampled_width'|U32'downsampled_height'|S32'component_needed'|S32'MCU_width'|S32'MCU_height'|S32'MCU_blocks'|S32'MCU_sample_width'|S32'last_col_width'|S32'last_row_height'|U32'_pad0'|*{SYM#tag-#anon#ST[ARR64{U16}_U16_'quantval'|S32'sent_table']#}_SYM#tag-#anon#ST[ARR64{U16}_U16_'quantval'|S32'sent_table']#_'quant_table'|*{V}_V_'dct_table']
// file /usr/include/jpeglib.h line 117
struct anonymous_124;

// tag-#anon#ST[S32'comps_in_scan'|ARR4{S32}_S32_'component_index'|S32'Ss'|S32'Se'|S32'Ah'|S32'Al']
// file /usr/include/jpeglib.h line 190
struct anonymous_127;

// tag-#anon#ST[S32'depth'|S32'bits_per_pixel'|S32'scanline_pad']
// file /usr/include/X11/Xlib.h line 171
struct anonymous_7;

// tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']
// file /usr/include/X11/Xlib.h line 243
struct anonymous_109;

// tag-#anon#ST[S32'first_line'|S32'last_line'|F64'ratio'|S32'film_mode'|SYM##anon_enum_VBI_SUBT_NONE=0_VBI_SUBT_ACTIVE=1_VBI_SUBT_MATTE=2_VBI_SUBT_UNKNOWN=3#'open_subtitles']
// file /usr/include/libzvbi.h line 494
struct anonymous_85;

// tag-#anon#ST[S32'flags'|S32'min_value'|S32'max_value'|U32'_pad0'|*{S8}_S8_'name']
// file /usr/include/X11/extensions/Xvlib.h line 64
struct anonymous_112;

// tag-#anon#ST[S32'fmt'|S32'type'|*{S8}_S8_'ext']
// file x11/blit.c line 504
struct anonymous_9;

// tag-#anon#ST[S32'function'|U32'_pad0'|U64'plane_mask'|U64'foreground'|U64'background'|S32'line_width'|S32'line_style'|S32'cap_style'|S32'join_style'|S32'fill_style'|S32'fill_rule'|S32'arc_mode'|U32'_pad1'|U64'tile'|U64'stipple'|S32'ts_x_origin'|S32'ts_y_origin'|U64'font'|S32'subwindow_mode'|S32'graphics_exposures'|S32'clip_x_origin'|S32'clip_y_origin'|U64'clip_mask'|S32'dash_offset'|S8'dashes'|U24'_pad2']
// file /usr/include/X11/Xlib.h line 181
struct anonymous_75;

// tag-#anon#ST[S32'id'|S32'type'|S32'byte_order'|ARR16{S8}_S8_'guid'|S32'bits_per_pixel'|S32'format'|S32'num_planes'|S32'depth'|U32'red_mask'|U32'green_mask'|U32'blue_mask'|U32'y_sample_bits'|U32'u_sample_bits'|U32'v_sample_bits'|U32'horz_y_period'|U32'horz_u_period'|U32'horz_v_period'|U32'vert_y_period'|U32'vert_u_period'|U32'vert_v_period'|ARR32{S8}_S8_'component_order'|S32'scanline_order']
// file /usr/include/X11/extensions/Xvlib.h line 124
struct anonymous_6;

// tag-#anon#ST[S32'id'|S32'width'|S32'height'|S32'data_size'|S32'num_planes'|U32'_pad0'|*{S32}_S32_'pitches'|*{S32}_S32_'offsets'|*{S8}_S8_'data'|*{S8}_S8_'obdata']
// file /usr/include/X11/extensions/Xvlib.h line 153
struct anonymous_3;

// tag-#anon#ST[S32'numerator'|S32'denominator']
// file /usr/include/X11/extensions/Xvlib.h line 59
struct anonymous_110;

// tag-#anon#ST[S32'pgno']
// file /usr/include/libzvbi.h line 724
struct anonymous_94;

// tag-#anon#ST[S32'pgno'|S32'subno']
// file /usr/include/libzvbi.h line 832
struct anonymous_63;

// tag-#anon#ST[S32'pgno'|S32'subno'|*{U8}_U8_'raw_header'|S32'pn_offset'|BF{U32}_U32_'roll_header'|BF{U32}_U32_'header_update'|BF{U32}_U32_'clock_update'|BF{U5}_U5_'_bit_field_pad0'|U24'_pad0']
// file /usr/include/libzvbi.h line 715
struct anonymous_93;

// tag-#anon#ST[S32'reason'|U32'_pad0'|*{SYM#tag-_XEvent#}_SYM#tag-_XEvent#_'event'|*{SYM#tag-__XmStringRec#}_SYM#tag-__XmStringRec#_'item_or_text'|S32'item_position'|U32'_pad1']
// file /usr/include/Xm/Xm.h line 690
struct anonymous_74;

// tag-#anon#ST[S32'reason'|U32'_pad0'|*{SYM#tag-_XEvent#}_SYM#tag-_XEvent#_'event'|*{SYM#tag-__XmStringRec#}_SYM#tag-__XmStringRec#_'value'|S32'length'|U32'_pad1']
// file /usr/include/Xm/Xm.h line 758
struct anonymous_83;

// tag-#anon#ST[S32'reason'|U32'_pad0'|*{SYM#tag-_XEvent#}_SYM#tag-_XEvent#_'event'|*{SYM#tag-__XmStringRec#}_SYM#tag-__XmStringRec#_'value'|S32'length'|U32'_pad1'|*{SYM#tag-__XmStringRec#}_SYM#tag-__XmStringRec#_'mask'|S32'mask_length'|U32'_pad2'|*{SYM#tag-__XmStringRec#}_SYM#tag-__XmStringRec#_'dir'|S32'dir_length'|U32'_pad3'|*{SYM#tag-__XmStringRec#}_SYM#tag-__XmStringRec#_'pattern'|S32'pattern_length'|U32'_pad4']
// file /usr/include/Xm/Xm.h line 774
struct anonymous_87;

// tag-#anon#ST[S32'reason'|U32'_pad0'|*{SYM#tag-_XEvent#}_SYM#tag-_XEvent#_'event'|S32'set'|U32'_pad1']
// file /usr/include/Xm/Xm.h line 737
struct anonymous_57;

// tag-#anon#ST[S32'reason'|U32'_pad0'|*{SYM#tag-_XEvent#}_SYM#tag-_XEvent#_'event'|U64'selection'|U64'target'|*{V}_V_'source_data'|*{V}_V_'location_data'|S32'flags'|U32'_pad1'|*{V}_V_'parm'|S32'parm_format'|U32'_pad2'|U64'parm_length'|U64'parm_type'|S32'status'|U32'_pad3'|*{V}_V_'value'|U64'type'|S32'format'|U32'_pad4'|U64'length']
// file /usr/include/Xm/Transfer.h line 65
struct anonymous_66;

// tag-#anon#ST[S32'screen_number'|S16'x_org'|S16'y_org'|S16'width'|S16'height']
// file /usr/include/X11/extensions/Xinerama.h line 32
struct anonymous_59;

// tag-#anon#ST[S32'si_pid'|U32'si_uid']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_100;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_103;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_102;

// tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_19;

// tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_101;

// tag-#anon#ST[S32'type'|U32'_pad0'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'resourceid'|U64'serial'|U8'error_code'|U8'request_code'|U8'minor_code'|U40'_pad1']
// file /usr/include/X11/Xlib.h line 924
struct anonymous;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|S32'extension'|S32'evtype']
// file /usr/include/X11/Xlib.h line 948
struct anonymous_54;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|S32'extension'|S32'evtype'|U32'cookie'|U32'_pad2'|*{V}_V_'data']
// file /usr/include/X11/Xlib.h line 958
struct anonymous_55;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'drawable'|S32'major_code'|S32'minor_code']
// file /usr/include/X11/Xlib.h line 686
struct anonymous_32;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'drawable'|S32'x'|S32'y'|S32'width'|S32'height'|S32'count'|S32'major_code'|S32'minor_code'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 673
struct anonymous_31;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window']
// file /usr/include/X11/Xlib.h line 718
struct anonymous_35;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'from_configure'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 727
struct anonymous_36;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'override_redirect'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 737
struct anonymous_37;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'place'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 816
struct anonymous_44;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'x'|S32'y']
// file /usr/include/X11/Xlib.h line 782
struct anonymous_41;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|U32'_pad2'|U64'above'|S32'override_redirect'|U32'_pad3']
// file /usr/include/X11/Xlib.h line 768
struct anonymous_40;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|U64'parent'|S32'x'|S32'y'|S32'override_redirect'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 756
struct anonymous_39;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'owner'|U64'requestor'|U64'selection'|U64'target'|U64'property'|U64'time']
// file /usr/include/X11/Xlib.h line 857
struct anonymous_48;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window']
// file /usr/include/X11/Xlib.h line 747
struct anonymous_38;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'place'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 826
struct anonymous_45;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|S32'override_redirect']
// file /usr/include/X11/Xlib.h line 705
struct anonymous_34;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|U32'_pad2'|U64'above'|S32'detail'|U32'_pad3'|U64'value_mask']
// file /usr/include/X11/Xlib.h line 801
struct anonymous_43;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'requestor'|U64'selection'|U64'target'|U64'property'|U64'time']
// file /usr/include/X11/Xlib.h line 870
struct anonymous_49;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window']
// file /usr/include/X11/Xlib.h line 934
struct anonymous_24;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|ARR32{S8}_S8_'key_vector']
// file /usr/include/X11/Xlib.h line 653
struct anonymous_53;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'mode'|S32'detail']
// file /usr/include/X11/Xlib.h line 634
struct anonymous_29;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'request'|S32'first_keycode'|S32'count'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 912
struct anonymous_52;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 696
struct anonymous_33;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'width'|S32'height']
// file /usr/include/X11/Xlib.h line 792
struct anonymous_42;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'count'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 662
struct anonymous_30;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'atom'|U64'time'|S32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 836
struct anonymous_46;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'colormap'|S32'new'|S32'state']
// file /usr/include/X11/Xlib.h line 882
struct anonymous_50;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'message_type'|S32'format'|U32'_pad2'|SYM#tag-#anon#UN[ARR20{S8}_S8_'b'|ARR10{S16}_S16_'s'|ARR5{S64}_S64_'l']#'data']
// file /usr/include/X11/Xlib.h line 897
struct anonymous_51;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|S32'mode'|S32'detail'|S32'same_screen'|S32'focus'|U32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 610
struct anonymous_28;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|S8'is_hint'|U24'_pad2'|S32'same_screen'|U32'_pad3']
// file /usr/include/X11/Xlib.h line 593
struct anonymous_27;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|U32'button'|S32'same_screen'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 575
struct anonymous_26;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|U32'keycode'|S32'same_screen'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 557
struct anonymous_25;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'selection'|U64'time']
// file /usr/include/X11/Xlib.h line 847
struct anonymous_47;

// tag-#anon#ST[S32'width'|S32'height'|S32'mwidth'|S32'mheight']
// file /usr/include/X11/extensions/Xrandr.h line 44
struct anonymous_20;

// tag-#anon#ST[S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|S32'depth'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visual'|U64'root'|S32'class'|S32'bit_gravity'|S32'win_gravity'|S32'backing_store'|U64'backing_planes'|U64'backing_pixel'|S32'save_under'|U32'_pad0'|U64'colormap'|S32'map_installed'|S32'map_state'|S64'all_event_masks'|S64'your_event_mask'|S64'do_not_propagate_mask'|S32'override_redirect'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#_'screen']
// file /usr/include/X11/Xlib.h line 308
struct anonymous_117;

// tag-#anon#ST[S32'y0'|S32'y1'|S32'roll']
// file /usr/include/libzvbi.h line 819
struct anonymous_60;

// tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_105;

// tag-#anon#ST[S64'time'|S32'seconds_east'|S32'seconds_east_valid'|SYM##anon_enum_VBI_DST_UNKNOWN=0_VBI_DST_INCLUDED=1_VBI_DST_INACTIVE=2_VBI_DST_ACTIVE=3#'dst_state'|U32'_pad0']
// file /usr/include/libzvbi.h line 688
struct anonymous_92;

// tag-#anon#ST[S64'ts']
// file ./libng/grab-ng.h line 183
struct anonymous_73;

// tag-#anon#ST[S64'ts'|S32'seq'|S32'twice']
// file ./libng/grab-ng.h line 142
struct anonymous_69;

// tag-#anon#ST[S8'depth'|U56'_pad0'|U64'visual_id']
// file /usr/include/X11/extensions/Xvlib.h line 80
struct anonymous_4;

// tag-#anon#ST[SYM##anon_enum_VBI_AUDIO_MODE_NONE=0_VBI_AUDIO_MODE_MONO=1_VBI_AUDIO_MODE_STEREO=2_VBI_AUDIO_MODE_STEREO_SURROUND=3_VBI_AUDIO_MODE_SIMULATED_STEREO=4_VBI_AUDIO_MODE_VIDEO_DESCRIPTIONS=5_VBI_AUDIO_MODE_NON_PROGRAM_AUDIO=6_VBI_AUDIO_MODE_SPECIAL_EFFECTS=7_VBI_AUDIO_MODE_DATA_SERVICE=8_VBI_AUDIO_MODE_UNKNOWN=9#'mode'|U32'_pad0'|*{U8}_U8_'language']
// file /usr/include/libzvbi.h line 616
struct anonymous_90;

// tag-#anon#ST[SYM##anon_enum_VBI_PID_CHANNEL_LCI_0=0_VBI_PID_CHANNEL_LCI_1=1_VBI_PID_CHANNEL_LCI_2=2_VBI_PID_CHANNEL_LCI_3=3_VBI_PID_CHANNEL_VPS=4_VBI_PID_CHANNEL_PDC_DESCRIPTOR=5_VBI_PID_CHANNEL_XDS_CURRENT=6_VBI_PID_CHANNEL_XDS_FUTURE=7_VBI_MAX_PID_CHANNELS=8#'channel'|SYM##anon_enum_VBI_CNI_TYPE_NONE=0_VBI_CNI_TYPE_UNKNOWN=0_VBI_CNI_TYPE_VPS=1_VBI_CNI_TYPE_8301=2_VBI_CNI_TYPE_8302=3_VBI_CNI_TYPE_PDC_A=4_VBI_CNI_TYPE_PDC_B=5#'cni_type'|U32'cni'|U32'pil'|S32'luf'|S32'mi'|S32'prf'|SYM##anon_enum_VBI_PCS_AUDIO_UNKNOWN=0_VBI_PCS_AUDIO_MONO=1_VBI_PCS_AUDIO_STEREO=2_VBI_PCS_AUDIO_BILINGUAL=3#'pcs_audio'|U32'pty'|S32'tape_delayed'|ARR2{*{V}_V_}_*{V}_V__'_reserved2'|ARR4{S32}_S32_'_reserved3']
// file /usr/include/libzvbi.h line 384
struct anonymous_79;

// tag-#anon#ST[U16'hdisplay'|U16'hsyncstart'|U16'hsyncend'|U16'htotal'|U16'hskew'|U16'vdisplay'|U16'vsyncstart'|U16'vsyncend'|U16'vtotal'|U16'_pad0'|U32'flags'|S32'privsize'|U32'_pad1'|*{S32}_S32_'private']
// file /usr/include/X11/extensions/xf86vmode.h line 68
struct anonymous_64;

// tag-#anon#ST[U16'red'|U16'green'|U16'blue'|U16'alpha']
// file /usr/include/X11/extensions/Xrender.h line 83
struct anonymous_113;

// tag-#anon#ST[U32'dotclock'|U16'hdisplay'|U16'hsyncstart'|U16'hsyncend'|U16'htotal'|U16'hskew'|U16'vdisplay'|U16'vsyncstart'|U16'vsyncend'|U16'vtotal'|U16'_pad0'|U32'flags'|S32'privsize'|*{S32}_S32_'private']
// file /usr/include/X11/extensions/xf86vmode.h line 88
struct anonymous_15;

// tag-#anon#ST[U32'id'|U32'line'|ARR56{U8}_U8_'data']
// file /usr/include/libzvbi.h line 1048
struct anonymous_98;

// tag-#anon#ST[U32'nuid'|ARR64{S8}_S8_'name'|ARR40{S8}_S8_'call'|S32'tape_delay'|S32'cni_vps'|S32'cni_8301'|S32'cni_8302'|S32'reserved'|S32'cycle']
// file /usr/include/libzvbi.h line 420
struct anonymous_80;

// tag-#anon#ST[U64'background_pixmap'|U64'background_pixel'|U64'border_pixmap'|U64'border_pixel'|S32'bit_gravity'|S32'win_gravity'|S32'backing_store'|U32'_pad0'|U64'backing_planes'|U64'backing_pixel'|S32'save_under'|U32'_pad1'|S64'event_mask'|S64'do_not_propagate_mask'|S32'override_redirect'|U32'_pad2'|U64'colormap'|U64'cursor']
// file /usr/include/X11/Xlib.h line 290
struct anonymous_135;

// tag-#anon#ST[U64'base_id'|U64'num_ports'|S8'type'|U56'_pad0'|*{S8}_S8_'name'|U64'num_formats'|*{SYM#tag-#anon#ST[S8'depth'|U56'_pad0'|U64'visual_id']#}_SYM#tag-#anon#ST[S8'depth'|U56'_pad0'|U64'visual_id']#_'formats'|U64'num_adaptors']
// file /usr/include/X11/extensions/Xvlib.h line 85
struct anonymous_5;

// tag-#anon#ST[U64'encoding_id'|*{S8}_S8_'name'|U64'width'|U64'height'|SYM#tag-#anon#ST[S32'numerator'|S32'denominator']#'rate'|U64'num_encodings']
// file /usr/include/X11/extensions/Xvlib.h line 71
struct anonymous_111;

// tag-#anon#ST[U64'name'|U64'card32']
// file /usr/include/X11/Xlib.h line 1030
struct anonymous_119;

// tag-#anon#ST[U64'pixel'|U16'red'|U16'green'|U16'blue'|S8'flags'|S8'pad']
// file /usr/include/X11/Xlib.h line 410
struct anonymous_22;

// tag-#anon#ST[U64'shmseg'|S32'shmid'|U32'_pad0'|*{S8}_S8_'shmaddr'|S32'readOnly'|U32'_pad1']
// file /usr/include/X11/extensions/XShm.h line 50
struct anonymous_2;

// tag-#anon#ST[U64'valuemask'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visual'|U64'colormap'|U32'depth'|U32'width'|U32'height'|U32'x_hotspot'|U32'y_hotspot'|U32'cpp'|*{U64}_U64_'pixels'|U32'npixels'|U32'_pad0'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|*{S8}_S8_'value'|U64'pixel']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|*{S8}_S8_'value'|U64'pixel']#_'colorsymbols'|U32'numsymbols'|U32'_pad1'|*{S8}_S8_'rgb_fname'|U32'nextensions'|U32'_pad2'|*{SYM#tag-#anon#ST[*{S8}_S8_'name'|U32'nlines'|U32'_pad0'|*{*{S8}_S8_}_*{S8}_S8__'lines']#}_SYM#tag-#anon#ST[*{S8}_S8_'name'|U32'nlines'|U32'_pad0'|*{*{S8}_S8_}_*{S8}_S8__'lines']#_'extensions'|U32'ncolors'|U32'_pad3'|*{SYM#tag-#anon#ST[*{S8}_S8_'string'|*{S8}_S8_'symbolic'|*{S8}_S8_'m_color'|*{S8}_S8_'g4_color'|*{S8}_S8_'g_color'|*{S8}_S8_'c_color']#}_SYM#tag-#anon#ST[*{S8}_S8_'string'|*{S8}_S8_'symbolic'|*{S8}_S8_'m_color'|*{S8}_S8_'g4_color'|*{S8}_S8_'g_color'|*{S8}_S8_'c_color']#_'colorTable'|*{S8}_S8_'hints_cmt'|*{S8}_S8_'colors_cmt'|*{S8}_S8_'pixels_cmt'|U32'mask_pixel'|S32'exactColors'|U32'closeness'|U32'red_closeness'|U32'green_closeness'|U32'blue_closeness'|S32'color_key'|U32'_pad4'|*{U64}_U64_'alloc_pixels'|S32'nalloc_pixels'|S32'alloc_close_colors'|S32'bitmap_format'|U32'_pad5'|*{S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_|U64|*{S8}_S8_|*{SYM#tag-#anon#ST[U64'pixel'|U16'red'|U16'green'|U16'blue'|S8'flags'|S8'pad']#}_SYM#tag-#anon#ST[U64'pixel'|U16'red'|U16'green'|U16'blue'|S8'flags'|S8'pad']#_|*{V}_V_)->S32}_S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_|U64|*{S8}_S8_|*{SYM#tag-#anon#ST[U64'pixel'|U16'red'|U16'green'|U16'blue'|S8'flags'|S8'pad']#}_SYM#tag-#anon#ST[U64'pixel'|U16'red'|U16'green'|U16'blue'|S8'flags'|S8'pad']#_|*{V}_V_)->S32_'alloc_color'|*{S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_|U64|*{U64}_U64_|S32|*{V}_V_)->S32}_S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_|U64|*{U64}_U64_|S32|*{V}_V_)->S32_'free_colors'|*{V}_V_'color_closure']
// file /usr/include/X11/xpm.h line 157
struct anonymous_133;

// tag-#anon#ST[U8'byte1'|U8'byte2']
// file /usr/include/X11/Xlib.h line 1064
struct anonymous_114;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'|*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}_SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}_SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#_|*{V}_V_)->V_'sa_sigaction']
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_18;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'|ARR8{U16}_U16_'__u6_addr16'|ARR4{U32}_U32_'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous_56;

// tag-#anon#UN[ARR20{S8}_S8_'b'|ARR10{S16}_S16_'s'|ARR5{S64}_S64_'l']
// file /usr/include/X11/Xlib.h line 905
union anonymous_118;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_107;

// tag-#anon#UN[ARR4{S8}_S8_'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_121;

// tag-#anon#UN[ARR8{S32}_S32_'i'|ARR80{S8}_S8_'s']
// file /usr/include/jpeglib.h line 736
union anonymous_129;

// tag-#anon#UN[S32'value'|SYM#tag-snd_seq_timestamp#'time'|U32'position'|SYM#tag-snd_seq_queue_skew#'skew'|ARR2{U32}_U32_'d32'|ARR8{U8}_U8_'d8']
// file /usr/include/alsa/seq_event.h line 284
union anonymous_99;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_72;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'pgno'|S32'subno'|*{U8}_U8_'raw_header'|S32'pn_offset'|BF{U32}_U32_'roll_header'|BF{U32}_U32_'header_update'|BF{U32}_U32_'clock_update'|BF{U5}_U5_'_bit_field_pad0'|U24'_pad0']#'ttx_page'|SYM#tag-#anon#ST[S32'pgno']#'caption'|SYM#tag-#anon#ST[U32'nuid'|ARR64{S8}_S8_'name'|ARR40{S8}_S8_'call'|S32'tape_delay'|S32'cni_vps'|S32'cni_8301'|S32'cni_8302'|S32'reserved'|S32'cycle']#'network'|*{SYM#tag-vbi_link#}_SYM#tag-vbi_link#_'trigger'|SYM#tag-#anon#ST[S32'first_line'|S32'last_line'|F64'ratio'|S32'film_mode'|SYM##anon_enum_VBI_SUBT_NONE=0_VBI_SUBT_ACTIVE=1_VBI_SUBT_MATTE=2_VBI_SUBT_UNKNOWN=3#'open_subtitles']#'aspect'|*{SYM#tag-vbi_program_info#}_SYM#tag-vbi_program_info#_'prog_info'|*{SYM#tag-#anon#ST[S64'time'|S32'seconds_east'|S32'seconds_east_valid'|SYM##anon_enum_VBI_DST_UNKNOWN=0_VBI_DST_INCLUDED=1_VBI_DST_INACTIVE=2_VBI_DST_ACTIVE=3#'dst_state'|U32'_pad0']#}_SYM#tag-#anon#ST[S64'time'|S32'seconds_east'|S32'seconds_east_valid'|SYM##anon_enum_VBI_DST_UNKNOWN=0_VBI_DST_INCLUDED=1_VBI_DST_INACTIVE=2_VBI_DST_ACTIVE=3#'dst_state'|U32'_pad0']#_'local_time'|*{SYM#tag-#anon#ST[SYM##anon_enum_VBI_PID_CHANNEL_LCI_0=0_VBI_PID_CHANNEL_LCI_1=1_VBI_PID_CHANNEL_LCI_2=2_VBI_PID_CHANNEL_LCI_3=3_VBI_PID_CHANNEL_VPS=4_VBI_PID_CHANNEL_PDC_DESCRIPTOR=5_VBI_PID_CHANNEL_XDS_CURRENT=6_VBI_PID_CHANNEL_XDS_FUTURE=7_VBI_MAX_PID_CHANNELS=8#'channel'|SYM##anon_enum_VBI_CNI_TYPE_NONE=0_VBI_CNI_TYPE_UNKNOWN=0_VBI_CNI_TYPE_VPS=1_VBI_CNI_TYPE_8301=2_VBI_CNI_TYPE_8302=3_VBI_CNI_TYPE_PDC_A=4_VBI_CNI_TYPE_PDC_B=5#'cni_type'|U32'cni'|U32'pil'|S32'luf'|S32'mi'|S32'prf'|SYM##anon_enum_VBI_PCS_AUDIO_UNKNOWN=0_VBI_PCS_AUDIO_MONO=1_VBI_PCS_AUDIO_STEREO=2_VBI_PCS_AUDIO_BILINGUAL=3#'pcs_audio'|U32'pty'|S32'tape_delayed'|ARR2{*{V}_V_}_*{V}_V__'_reserved2'|ARR4{S32}_S32_'_reserved3']#}_SYM#tag-#anon#ST[SYM##anon_enum_VBI_PID_CHANNEL_LCI_0=0_VBI_PID_CHANNEL_LCI_1=1_VBI_PID_CHANNEL_LCI_2=2_VBI_PID_CHANNEL_LCI_3=3_VBI_PID_CHANNEL_VPS=4_VBI_PID_CHANNEL_PDC_DESCRIPTOR=5_VBI_PID_CHANNEL_XDS_CURRENT=6_VBI_PID_CHANNEL_XDS_FUTURE=7_VBI_MAX_PID_CHANNELS=8#'channel'|SYM##anon_enum_VBI_CNI_TYPE_NONE=0_VBI_CNI_TYPE_UNKNOWN=0_VBI_CNI_TYPE_VPS=1_VBI_CNI_TYPE_8301=2_VBI_CNI_TYPE_8302=3_VBI_CNI_TYPE_PDC_A=4_VBI_CNI_TYPE_PDC_B=5#'cni_type'|U32'cni'|U32'pil'|S32'luf'|S32'mi'|S32'prf'|SYM##anon_enum_VBI_PCS_AUDIO_UNKNOWN=0_VBI_PCS_AUDIO_MONO=1_VBI_PCS_AUDIO_STEREO=2_VBI_PCS_AUDIO_BILINGUAL=3#'pcs_audio'|U32'pty'|S32'tape_delayed'|ARR2{*{V}_V_}_*{V}_V__'_reserved2'|ARR4{S32}_S32_'_reserved3']#_'prog_id'|*{SYM#tag-_vbi_event_cc608_page#}_SYM#tag-_vbi_event_cc608_page#_'_cc608'|*{SYM#tag-_vbi_event_cc608_stream#}_SYM#tag-_vbi_event_cc608_stream#_'_cc608_stream'|U1088'_pad']
// file /usr/include/libzvbi.h line 714
union anonymous_95;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_70;

// tag-#anon#UN[SYM#tag-snd_seq_ev_note#'note'|SYM#tag-snd_seq_ev_ctrl#'control'|SYM#tag-snd_seq_ev_raw8#'raw8'|SYM#tag-snd_seq_ev_raw32#'raw32'|SYM#tag-snd_seq_ev_ext#'ext'|SYM#tag-snd_seq_ev_queue_control#'queue'|SYM#tag-snd_seq_timestamp#'time'|SYM#tag-snd_seq_addr#'addr'|SYM#tag-snd_seq_connect#'connect'|SYM#tag-snd_seq_result#'result'|U128'_pad']
// file /usr/include/alsa/seq_event.h line 307
union anonymous_21;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_58;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_65;

// tag-ARGS
// file x11/xt.h line 31
struct ARGS;

// tag-CFG_ENTRIES
// file common/parseconfig.c line 11
struct CFG_ENTRIES;

// tag-CFG_SECTIONS
// file common/parseconfig.c line 18
struct CFG_SECTIONS;

// tag-CHANLIST
// file ./common/frequencies.h line 82
struct CHANLIST;

// tag-CHANLISTS
// file ./common/frequencies.h line 87
struct CHANLISTS;

// tag-CHANNEL
// file ./common/channel.h line 11
struct CHANNEL;

// tag-CHUNKHDR
// file libng/writefile.c line 201
struct CHUNKHDR;

// tag-COMMANDS
// file common/commands.c line 109
struct COMMANDS;

// tag-DO_CMD
// file x11/xt.h line 162
struct DO_CMD;

// tag-ENC_MAP
// file x11/xv.c line 55
struct ENC_MAP;

// tag-FIFO
// file common/capture.h line 6
struct FIFO;

// tag-FILE_DATA
// file x11/motv.c line 1773
struct FILE_DATA;

// tag-JOYTAB
// file common/joystick.c line 26
struct JOYTAB;

// tag-LAUNCH
// file ./common/channel.h line 82
struct LAUNCH;

// tag-MY_TOPLEVELS
// file x11/motv.c line 153
struct MY_TOPLEVELS;

// tag-OVERLAY_CLIP
// file ./libng/grab-ng.h line 122
struct OVERLAY_CLIP;

// tag-SEARCHFORMAT
// file x11/blit.c line 58
struct SEARCHFORMAT;

// tag-STRTAB
// file ./libng/grab-ng.h line 117
struct STRTAB;

// tag-WAVEHDR
// file libng/writefile.c line 207
struct WAVEHDR;

// tag-WEBCAM
// file common/webcam.c line 22
struct WEBCAM;

// tag-XVATTR
// file x11/xv.c line 80
struct XVATTR;

// tag-_FcCharSet
// file /usr/include/fontconfig/fontconfig.h line 212
struct _FcCharSet;

// tag-_FcPattern
// file /usr/include/fontconfig/fontconfig.h line 230
struct _FcPattern;

// tag-_FcResult
// file /usr/include/fontconfig/fontconfig.h line 225
enum _FcResult { FcResultMatch=0, FcResultNoMatch=1, FcResultTypeMismatch=2, FcResultNoId=3, FcResultOutOfMemory=4 };

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_TranslationData
// file /usr/include/X11/Intrinsic.h line 170
struct _TranslationData;

// tag-_WidgetClassRec
// file /usr/include/X11/Intrinsic.h line 109
struct _WidgetClassRec;

// tag-_WidgetRec
// file /usr/include/X11/Intrinsic.h line 107
struct _WidgetRec;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XImage
// file /usr/include/X11/Xlib.h line 360
struct _XImage;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XRRScreenConfiguration
// file /usr/include/X11/extensions/Xrandr.h line 158
struct _XRRScreenConfiguration;

// tag-_XftColor
// file /usr/include/X11/Xft/Xft.h line 75
struct _XftColor;

// tag-_XftDraw
// file /usr/include/X11/Xft/Xft.h line 73
struct _XftDraw;

// tag-_XftFont
// file /usr/include/X11/Xft/Xft.h line 64
struct _XftFont;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-_XtActionsRec
// file /usr/include/X11/Intrinsic.h line 111
struct _XtActionsRec;

// tag-_XtAppStruct
// file /usr/include/X11/Intrinsic.h line 114
struct _XtAppStruct;

// tag-_XtResource
// file /usr/include/X11/Intrinsic.h line 354
struct _XtResource;

// tag-__GLXcontextRec
// file /usr/include/GL/glx.h line 165
struct __GLXcontextRec;

// tag-__XmParseMappingRec
// file /usr/include/Xm/Xm.h line 251
struct __XmParseMappingRec;

// tag-__XmStringRec
// file /usr/include/Xm/Xm.h line 181
union __XmStringRec;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_snd_output
// file /usr/include/alsa/output.h line 54
struct _snd_output;

// tag-_snd_pcm
// file /usr/include/alsa/pcm.h line 374
struct _snd_pcm;

// tag-_snd_pcm_access
// file /usr/include/alsa/pcm.h line 108
enum _snd_pcm_access { SND_PCM_ACCESS_MMAP_INTERLEAVED=0, SND_PCM_ACCESS_MMAP_NONINTERLEAVED=1, SND_PCM_ACCESS_MMAP_COMPLEX=2, SND_PCM_ACCESS_RW_INTERLEAVED=3, SND_PCM_ACCESS_RW_NONINTERLEAVED=4, SND_PCM_ACCESS_LAST=4 };

// tag-_snd_pcm_format
// file /usr/include/alsa/pcm.h line 123
enum _snd_pcm_format { SND_PCM_FORMAT_UNKNOWN=-1, SND_PCM_FORMAT_S8=0, SND_PCM_FORMAT_U8=1, SND_PCM_FORMAT_S16_LE=2, SND_PCM_FORMAT_S16_BE=3, SND_PCM_FORMAT_U16_LE=4, SND_PCM_FORMAT_U16_BE=5, SND_PCM_FORMAT_S24_LE=6, SND_PCM_FORMAT_S24_BE=7, SND_PCM_FORMAT_U24_LE=8, SND_PCM_FORMAT_U24_BE=9, SND_PCM_FORMAT_S32_LE=10, SND_PCM_FORMAT_S32_BE=11, SND_PCM_FORMAT_U32_LE=12, SND_PCM_FORMAT_U32_BE=13, SND_PCM_FORMAT_FLOAT_LE=14, SND_PCM_FORMAT_FLOAT_BE=15, SND_PCM_FORMAT_FLOAT64_LE=16, SND_PCM_FORMAT_FLOAT64_BE=17, SND_PCM_FORMAT_IEC958_SUBFRAME_LE=18, SND_PCM_FORMAT_IEC958_SUBFRAME_BE=19, SND_PCM_FORMAT_MU_LAW=20, SND_PCM_FORMAT_A_LAW=21, SND_PCM_FORMAT_IMA_ADPCM=22, SND_PCM_FORMAT_MPEG=23, SND_PCM_FORMAT_GSM=24, SND_PCM_FORMAT_SPECIAL=31, SND_PCM_FORMAT_S24_3LE=32, SND_PCM_FORMAT_S24_3BE=33, SND_PCM_FORMAT_U24_3LE=34, SND_PCM_FORMAT_U24_3BE=35, SND_PCM_FORMAT_S20_3LE=36, SND_PCM_FORMAT_S20_3BE=37, SND_PCM_FORMAT_U20_3LE=38, SND_PCM_FORMAT_U20_3BE=39, SND_PCM_FORMAT_S18_3LE=40, SND_PCM_FORMAT_S18_3BE=41, SND_PCM_FORMAT_U18_3LE=42, SND_PCM_FORMAT_U18_3BE=43, SND_PCM_FORMAT_G723_24=44, SND_PCM_FORMAT_G723_24_1B=45, SND_PCM_FORMAT_G723_40=46, SND_PCM_FORMAT_G723_40_1B=47, SND_PCM_FORMAT_DSD_U8=48, SND_PCM_FORMAT_DSD_U16_LE=49, SND_PCM_FORMAT_DSD_U32_LE=50, SND_PCM_FORMAT_DSD_U16_BE=51, SND_PCM_FORMAT_DSD_U32_BE=52, SND_PCM_FORMAT_LAST=52, SND_PCM_FORMAT_S16=2, SND_PCM_FORMAT_U16=4, SND_PCM_FORMAT_S24=6, SND_PCM_FORMAT_U24=8, SND_PCM_FORMAT_S32=10, SND_PCM_FORMAT_U32=12, SND_PCM_FORMAT_FLOAT=14, SND_PCM_FORMAT_FLOAT64=16, SND_PCM_FORMAT_IEC958_SUBFRAME=18 };

// tag-_snd_pcm_hw_params
// file /usr/include/alsa/pcm.h line 62
struct _snd_pcm_hw_params;

// tag-_snd_pcm_stream
// file /usr/include/alsa/pcm.h line 99
enum _snd_pcm_stream { SND_PCM_STREAM_PLAYBACK=0, SND_PCM_STREAM_CAPTURE=1, SND_PCM_STREAM_LAST=1 };

// tag-_snd_pcm_sw_params
// file /usr/include/alsa/pcm.h line 65
struct _snd_pcm_sw_params;

// tag-_snd_seq
// file /usr/include/alsa/seq.h line 47
struct _snd_seq;

// tag-_snd_seq_port_subscribe
// file /usr/include/alsa/seq.h line 317
struct _snd_seq_port_subscribe;

// tag-_vbi_event_cc608_page
// file /usr/include/libzvbi.h line 703
struct _vbi_event_cc608_page;

// tag-_vbi_event_cc608_stream
// file /usr/include/libzvbi.h line 704
struct _vbi_event_cc608_stream;

// tag-_vbi_raw_decoder_job
// file /usr/include/libzvbi.h line 1160
struct _vbi_raw_decoder_job;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-blit_state
// file x11/blit.h line 26
struct blit_state;

// tag-blit_status
// file x11/blit.c line 670
enum blit_status { STATUS_UNKNOWN=0, STATUS_BROKEN=1, STATUS_CONVERT=2, STATUS_XVIDEO=3, STATUS_OPENGL=4 };

// tag-bus_type
// file common/get_media_devices.h line 63
enum bus_type { MEDIA_BUS_UNKNOWN=0, MEDIA_BUS_VIRTUAL=1, MEDIA_BUS_PCI=2, MEDIA_BUS_USB=3 };

// tag-device_type
// file ./common/get_media_devices.h line 32
enum device_type { UNKNOWN=65535, NONE=65534, MEDIA_V4L_VIDEO=0, MEDIA_V4L_VBI=1, MEDIA_V4L_RADIO=2, MEDIA_V4L_SUBDEV=3, MEDIA_DVB_VIDEO=100, MEDIA_DVB_AUDIO=101, MEDIA_DVB_SEC=102, MEDIA_DVB_FRONTEND=103, MEDIA_DVB_DEMUX=104, MEDIA_DVB_DVR=105, MEDIA_DVB_CA=106, MEDIA_DVB_NET=107, MEDIA_DVB_OSD=108, MEDIA_SND_CARD=200, MEDIA_SND_CAP=201, MEDIA_SND_OUT=202, MEDIA_SND_CONTROL=203, MEDIA_SND_HW=204, MEDIA_SND_TIMER=205, MEDIA_SND_SEQ=206 };

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-event_entry
// file common/event.h line 3
struct event_entry;

// tag-files_handle
// file libng/writefile.c line 280
struct files_handle;

// tag-filter_attribute
// file x11/motv.c line 173
struct filter_attribute;

// tag-final_params
// file common/alsa_stream.c line 55
struct final_params;

// tag-funcs
// file /usr/include/X11/Xlib.h line 376
struct funcs;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-input_params
// file common/alsa_stream.c line 570
struct input_params;

// tag-ipc_data
// file x11/motv.c line 2691
struct ipc_data;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-jpeg_c_coef_controller
// file /usr/include/jpeglib.h line 457
struct jpeg_c_coef_controller;

// tag-jpeg_c_main_controller
// file /usr/include/jpeglib.h line 455
struct jpeg_c_main_controller;

// tag-jpeg_c_prep_controller
// file /usr/include/jpeglib.h line 456
struct jpeg_c_prep_controller;

// tag-jpeg_color_converter
// file /usr/include/jpeglib.h line 459
struct jpeg_color_converter;

// tag-jpeg_common_struct
// file /usr/include/jpeglib.h line 280
struct jpeg_common_struct;

// tag-jpeg_comp_master
// file /usr/include/jpeglib.h line 454
struct jpeg_comp_master;

// tag-jpeg_compress_struct
// file /usr/include/jpeglib.h line 289
struct jpeg_compress_struct;

// tag-jpeg_destination_mgr
// file /usr/include/jpeglib.h line 299
struct jpeg_destination_mgr;

// tag-jpeg_downsampler
// file /usr/include/jpeglib.h line 460
struct jpeg_downsampler;

// tag-jpeg_entropy_encoder
// file /usr/include/jpeglib.h line 462
struct jpeg_entropy_encoder;

// tag-jpeg_error_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_error_mgr;

// tag-jpeg_forward_dct
// file /usr/include/jpeglib.h line 461
struct jpeg_forward_dct;

// tag-jpeg_marker_writer
// file /usr/include/jpeglib.h line 458
struct jpeg_marker_writer;

// tag-jpeg_memory_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_memory_mgr;

// tag-jpeg_progress_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_progress_mgr;

// tag-js_event
// file /usr/include/linux/joystick.h line 47
struct js_event;

// tag-jvirt_barray_control
// file /usr/include/jpeglib.h line 828
struct jvirt_barray_control;

// tag-jvirt_sarray_control
// file /usr/include/jpeglib.h line 827
struct jvirt_sarray_control;

// tag-lirc_code
// file /usr/include/lirc/lirc_client.h line 47
struct lirc_code;

// tag-lirc_config
// file /usr/include/lirc/lirc_client.h line 53
struct lirc_config;

// tag-lirc_config_entry
// file /usr/include/lirc/lirc_client.h line 55
struct lirc_config_entry;

// tag-lirc_list
// file /usr/include/lirc/lirc_client.h line 42
struct lirc_list;

// tag-list_head
// file ./libng/list.h line 15
struct list_head;

// tag-media_device_entry
// file common/get_media_devices.c line 43
struct media_device_entry;

// tag-media_devices
// file common/get_media_devices.c line 60
struct media_devices;

// tag-midi_handle
// file ./common/midictrl.h line 9
struct midi_handle;

// tag-motif_attribute
// file x11/motv.c line 166
struct motif_attribute;

// tag-movie_handle
// file common/capture.h line 27
struct movie_handle;

// tag-ng_attribute
// file ./libng/grab-ng.h line 243
struct ng_attribute;

// tag-ng_audio_buf
// file ./libng/grab-ng.h line 177
struct ng_audio_buf;

// tag-ng_audio_conv
// file libng/grab-ng.h line 387
struct ng_audio_conv;

// tag-ng_audio_fmt
// file ./libng/grab-ng.h line 172
struct ng_audio_fmt;

// tag-ng_convert_handle
// file ./libng/grab-ng.h line 364
struct ng_convert_handle;

// tag-ng_convthread_handle
// file common/capture.c line 122
struct ng_convthread_handle;

// tag-ng_device_config
// file ./libng/devices.h line 2
struct ng_device_config;

// tag-ng_devinfo
// file ./libng/grab-ng.h line 275
struct ng_devinfo;

// tag-ng_dsp_driver
// file ./libng/grab-ng.h line 321
struct ng_dsp_driver;

// tag-ng_filter
// file ./libng/grab-ng.h line 402
struct ng_filter;

// tag-ng_format_list
// file ./libng/grab-ng.h line 194
struct ng_format_list;

// tag-ng_mix_driver
// file ./libng/grab-ng.h line 335
struct ng_mix_driver;

// tag-ng_reader
// file libng/grab-ng.h line 220
struct ng_reader;

// tag-ng_vid_driver
// file ./libng/grab-ng.h line 284
struct ng_vid_driver;

// tag-ng_video_buf
// file ./libng/grab-ng.h line 136
struct ng_video_buf;

// tag-ng_video_conv
// file ./libng/grab-ng.h line 350
struct ng_video_conv;

// tag-ng_video_fmt
// file ./libng/grab-ng.h line 129
struct ng_video_fmt;

// tag-ng_writer
// file ./libng/grab-ng.h line 203
struct ng_writer;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-raw_handle
// file libng/writefile.c line 392
struct raw_handle;

// tag-raw_priv
// file libng/writefile.c line 388
struct raw_priv;

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-snd_seq_addr
// file /usr/include/alsa/seq_event.h line 178
struct snd_seq_addr;

// tag-snd_seq_connect
// file /usr/include/alsa/seq_event.h line 184
struct snd_seq_connect;

// tag-snd_seq_ev_ctrl
// file /usr/include/alsa/seq_event.h line 239
struct snd_seq_ev_ctrl;

// tag-snd_seq_ev_ext
// file /usr/include/alsa/seq_event.h line 257
struct snd_seq_ev_ext;

// tag-snd_seq_ev_note
// file /usr/include/alsa/seq_event.h line 230
struct snd_seq_ev_note;

// tag-snd_seq_ev_queue_control
// file /usr/include/alsa/seq_event.h line 281
struct snd_seq_ev_queue_control;

// tag-snd_seq_ev_raw32
// file /usr/include/alsa/seq_event.h line 252
struct snd_seq_ev_raw32;

// tag-snd_seq_ev_raw8
// file /usr/include/alsa/seq_event.h line 247
struct snd_seq_ev_raw8;

// tag-snd_seq_event
// file /usr/include/alsa/seq_event.h line 296
struct snd_seq_event;

// tag-snd_seq_queue_skew
// file /usr/include/alsa/seq_event.h line 275
struct snd_seq_queue_skew;

// tag-snd_seq_real_time
// file /usr/include/alsa/seq_event.h line 191
struct snd_seq_real_time;

// tag-snd_seq_result
// file /usr/include/alsa/seq_event.h line 269
struct snd_seq_result;

// tag-snd_seq_timestamp
// file /usr/include/alsa/seq_event.h line 200
union snd_seq_timestamp;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-stderr_handler
// file x11/motv.c line 3180
struct stderr_handler;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-utsname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 48
struct utsname;

// tag-v4l2_tuner
// file ./libng/videodev2.h line 1988
struct v4l2_tuner;

// tag-vbi_bit_slicer
// file /usr/include/libzvbi.h line 1108
struct vbi_bit_slicer;

// tag-vbi_capture
// file /usr/include/libzvbi.h line 1574
struct vbi_capture;

// tag-vbi_char
// file /usr/include/libzvbi.h line 788
struct vbi_char;

// tag-vbi_decoder
// file /usr/include/libzvbi.h line 39
struct vbi_decoder;

// tag-vbi_event
// file /usr/include/libzvbi.h line 712
struct vbi_event;

// tag-vbi_font
// file x11/vbi-x11.h line 13
struct vbi_font;

// tag-vbi_font_descr
// file /usr/include/libzvbi.h line 805
struct vbi_font_descr;

// tag-vbi_link
// file /usr/include/libzvbi.h line 468
struct vbi_link;

// tag-vbi_page
// file /usr/include/libzvbi.h line 807
struct vbi_page;

// tag-vbi_program_info
// file /usr/include/libzvbi.h line 548
struct vbi_program_info;

// tag-vbi_raw_decoder
// file /usr/include/libzvbi.h line 1139
struct vbi_raw_decoder;

// tag-vbi_rect
// file ./common/vbi-data.h line 21
struct vbi_rect;

// tag-vbi_state
// file ./common/vbi-data.h line 9
struct vbi_state;

// tag-vbi_txt_colors
// file common/vbi-data.h line 25
enum vbi_txt_colors { VBI_NOCOLOR=0, VBI_ANSICOLOR=1 };

// tag-vbi_window
// file x11/vbi-x11.h line 19
struct vbi_window;

// tag-video_handle
// file x11/x11.h line 10
struct video_handle;

// tag-xv_handle
// file x11/xv.c line 61
struct xv_handle;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// BadWindow_ehandler
// file jwz/remote.c line 55
static signed int BadWindow_ehandler(struct _XDisplay *dpy, struct anonymous *error);
// CloseMainAction
// file x11/xt.h line 132
void CloseMainAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// CommandAction
// file x11/xt.h line 171
void CommandAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// CompleteAction
// file x11/complete.h line 2
void CompleteAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// DPMSCapable
// file /usr/include/X11/extensions/dpms.h line 41
extern signed int DPMSCapable(struct _XDisplay *);
// DPMSDisable
// file /usr/include/X11/extensions/dpms.h line 45
extern signed int DPMSDisable(struct _XDisplay *);
// DPMSEnable
// file /usr/include/X11/extensions/dpms.h line 44
extern signed int DPMSEnable(struct _XDisplay *);
// DPMSInfo
// file /usr/include/X11/extensions/dpms.h line 47
extern signed int DPMSInfo(struct _XDisplay *, unsigned short int *, unsigned char *);
// DPMSQueryExtension
// file /usr/include/X11/extensions/dpms.h line 39
extern signed int DPMSQueryExtension(struct _XDisplay *, signed int *, signed int *);
// DebugAction
// file x11/motv.c line 207
static void DebugAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// EventAction
// file x11/xt.h line 140
void EventAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// ExitCB
// file x11/xt.h line 130
void ExitCB(struct _WidgetRec *widget, void *client_data, void *calldata);
// ExitWP
// file x11/xt.c line 344
char ExitWP(void *client_data);
// FcNameParse
// file /usr/include/fontconfig/fontconfig.h line 778
struct _FcPattern * FcNameParse(const unsigned char *);
// FilterAction
// file x11/xt.h line 139
void FilterAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// IpcAction
// file x11/motv.c line 3047
static void IpcAction(struct _WidgetRec *widget, union _XEvent *event, char **argv, unsigned int *argc);
// LaunchAction
// file x11/xt.h line 137
void LaunchAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// MyResize
// file x11/xt.h line 142
char MyResize(void *client_data);
// PopupAction
// file x11/motv.c line 341
static void PopupAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// RatioAction
// file x11/xt.h line 136
void RatioAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// RemoteAction
// file x11/xt.h line 172
void RemoteAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// ScanAction
// file x11/xt.h line 135
void ScanAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// VtxAction
// file x11/xt.h line 138
void VtxAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// XAllocColor
// file /usr/include/X11/Xlib.h line 1958
extern signed int XAllocColor(struct _XDisplay *, unsigned long int, struct anonymous_22 *);
// XAllocNamedColor
// file /usr/include/X11/Xlib.h line 1988
extern signed int XAllocNamedColor(struct _XDisplay *, unsigned long int, const char *, struct anonymous_22 *, struct anonymous_22 *);
// XBell
// file /usr/include/X11/Xlib.h line 2010
extern signed int XBell(struct _XDisplay *, signed int);
// XChangeGC
// file /usr/include/X11/Xlib.h line 2038
extern signed int XChangeGC(struct _XDisplay *, struct _XGC *, unsigned long int, struct anonymous_75 *);
// XChangeProperty
// file /usr/include/X11/Xlib.h line 2068
extern signed int XChangeProperty(struct _XDisplay *, unsigned long int, unsigned long int, unsigned long int, signed int, signed int, const unsigned char *, signed int);
// XCheckMaskEvent
// file /usr/include/X11/Xlib.h line 2103
extern signed int XCheckMaskEvent(struct _XDisplay *, signed long int, union _XEvent *);
// XClearArea
// file /usr/include/X11/Xlib.h line 2145
extern signed int XClearArea(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, signed int);
// XClearWindow
// file /usr/include/X11/Xlib.h line 2155
extern signed int XClearWindow(struct _XDisplay *, unsigned long int);
// XCreateBitmapFromData
// file /usr/include/X11/Xlib.h line 1604
extern unsigned long int XCreateBitmapFromData(struct _XDisplay *, unsigned long int, const char *, unsigned int, unsigned int);
// XCreateColormap
// file /usr/include/X11/Xlib.h line 1552
extern unsigned long int XCreateColormap(struct _XDisplay *, unsigned long int, struct anonymous_8 *, signed int);
// XCreateFontCursor
// file /usr/include/X11/Xlib.h line 1576
extern unsigned long int XCreateFontCursor(struct _XDisplay *, unsigned int);
// XCreateGC
// file /usr/include/X11/Xlib.h line 1584
extern struct _XGC * XCreateGC(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous_75 *);
// XCreateImage
// file /usr/include/X11/Xlib.h line 1441
extern struct _XImage * XCreateImage(struct _XDisplay *, struct anonymous_8 *, unsigned int, signed int, signed int, char *, unsigned int, unsigned int, signed int, signed int);
// XCreatePixmap
// file /usr/include/X11/Xlib.h line 1597
extern unsigned long int XCreatePixmap(struct _XDisplay *, unsigned long int, unsigned int, unsigned int, unsigned int);
// XCreatePixmapCursor
// file /usr/include/X11/Xlib.h line 1558
extern unsigned long int XCreatePixmapCursor(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous_22 *, struct anonymous_22 *, unsigned int, unsigned int);
// XCreateWindow
// file /usr/include/X11/Xlib.h line 1636
extern unsigned long int XCreateWindow(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, unsigned int, signed int, unsigned int, struct anonymous_8 *, unsigned long int, struct anonymous_135 *);
// XDefaultScreen
// file /usr/include/X11/Xlib.h line 2227
extern signed int XDefaultScreen(struct _XDisplay *);
// XDefineCursor
// file /usr/include/X11/Xlib.h line 2231
extern signed int XDefineCursor(struct _XDisplay *, unsigned long int, unsigned long int);
// XDestroyWindow
// file /usr/include/X11/Xlib.h line 2243
extern signed int XDestroyWindow(struct _XDisplay *, unsigned long int);
// XDrawString
// file /usr/include/X11/Xlib.h line 2404
extern signed int XDrawString(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, const char *, signed int);
// XDrawString16
// file /usr/include/X11/Xlib.h line 2414
extern signed int XDrawString16(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, const struct anonymous_114 *, signed int);
// XF86DGAGetVideoLL
// file /usr/include/X11/extensions/xf86dga1.h line 34
signed int XF86DGAGetVideoLL(struct _XDisplay *, signed int, unsigned int *, signed int *, signed int *, signed int *);
// XF86DGAQueryDirectVideo
// file /usr/include/X11/extensions/xf86dga1.h line 100
signed int XF86DGAQueryDirectVideo(struct _XDisplay *, signed int, signed int *);
// XF86DGAQueryExtension
// file /usr/include/X11/extensions/xf86dga1.h line 28
signed int XF86DGAQueryExtension(struct _XDisplay *, signed int *, signed int *);
// XF86DGAQueryVersion
// file /usr/include/X11/extensions/xf86dga1.h line 22
signed int XF86DGAQueryVersion(struct _XDisplay *, signed int *, signed int *);
// XF86VidModeGetAllModeLines
// file /usr/include/X11/extensions/xf86vmode.h line 173
signed int XF86VidModeGetAllModeLines(struct _XDisplay *, signed int, signed int *, struct anonymous_15 ***);
// XF86VidModeGetModeLine
// file /usr/include/X11/extensions/xf86vmode.h line 166
signed int XF86VidModeGetModeLine(struct _XDisplay *, signed int, signed int *, struct anonymous_64 *);
// XF86VidModeQueryExtension
// file /usr/include/X11/extensions/xf86vmode.h line 156
signed int XF86VidModeQueryExtension(struct _XDisplay *, signed int *, signed int *);
// XF86VidModeQueryVersion
// file /usr/include/X11/extensions/xf86vmode.h line 150
signed int XF86VidModeQueryVersion(struct _XDisplay *, signed int *, signed int *);
// XF86VidModeSetViewPort
// file /usr/include/X11/extensions/xf86vmode.h line 236
signed int XF86VidModeSetViewPort(struct _XDisplay *, signed int, signed int, signed int);
// XF86VidModeSwitchToMode
// file /usr/include/X11/extensions/xf86vmode.h line 211
signed int XF86VidModeSwitchToMode(struct _XDisplay *, signed int, struct anonymous_15 *);
// XFillRectangle
// file /usr/include/X11/Xlib.h line 2489
extern signed int XFillRectangle(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int);
// XFlush
// file /usr/include/X11/Xlib.h line 2507
extern signed int XFlush(struct _XDisplay *);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XFreeFont
// file /usr/include/X11/Xlib.h line 2542
extern signed int XFreeFont(struct _XDisplay *, struct anonymous_14 *);
// XFreeGC
// file /usr/include/X11/Xlib.h line 2561
extern signed int XFreeGC(struct _XDisplay *, struct _XGC *);
// XFreePixmap
// file /usr/include/X11/Xlib.h line 2570
extern signed int XFreePixmap(struct _XDisplay *, unsigned long int);
// XGetAtomName
// file /usr/include/X11/Xlib.h line 1500
extern char * XGetAtomName(struct _XDisplay *, unsigned long int);
// XGetClassHint
// file /usr/include/X11/Xutil.h line 423
extern signed int XGetClassHint(struct _XDisplay *, unsigned long int, struct anonymous_116 *);
// XGetScreenSaver
// file /usr/include/X11/Xlib.h line 2662
extern signed int XGetScreenSaver(struct _XDisplay *, signed int *, signed int *, signed int *, signed int *);
// XGetVisualInfo
// file /usr/include/X11/Xutil.h line 471
extern struct anonymous_1 * XGetVisualInfo(struct _XDisplay *, signed long int, struct anonymous_1 *, signed int *);
// XGetWindowAttributes
// file /usr/include/X11/Xlib.h line 2691
extern signed int XGetWindowAttributes(struct _XDisplay *, unsigned long int, struct anonymous_117 *);
// XGetWindowProperty
// file /usr/include/X11/Xlib.h line 2676
extern signed int XGetWindowProperty(struct _XDisplay *, unsigned long int, unsigned long int, signed long int, signed long int, signed int, unsigned long int, unsigned long int *, signed int *, unsigned long int *, unsigned long int *, unsigned char **);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XKeycodeToKeysym
// file /usr/include/X11/Xlib.h line 1687
extern unsigned long int XKeycodeToKeysym(struct _XDisplay *, unsigned char, signed int);
// XKeysymToString
// file /usr/include/X11/Xlib.h line 1518
extern char * XKeysymToString(unsigned long int);
// XListPixmapFormats
// file /usr/include/X11/Xlib.h line 1862
extern struct anonymous_7 * XListPixmapFormats(struct _XDisplay *, signed int *);
// XLoadQueryFont
// file /usr/include/X11/Xlib.h line 1394
extern struct anonymous_14 * XLoadQueryFont(struct _XDisplay *, const char *);
// XMapWindow
// file /usr/include/X11/Xlib.h line 2806
extern signed int XMapWindow(struct _XDisplay *, unsigned long int);
// XPutImage
// file /usr/include/X11/Xlib.h line 2903
extern signed int XPutImage(struct _XDisplay *, unsigned long int, struct _XGC *, struct _XImage *, signed int, signed int, signed int, signed int, unsigned int, unsigned int);
// XQueryPointer
// file /usr/include/X11/Xlib.h line 2983
extern signed int XQueryPointer(struct _XDisplay *, unsigned long int, unsigned long int *, unsigned long int *, signed int *, signed int *, signed int *, signed int *, unsigned int *);
// XQueryTree
// file /usr/include/X11/Xlib.h line 3017
extern signed int XQueryTree(struct _XDisplay *, unsigned long int, unsigned long int *, unsigned long int *, unsigned long int **, unsigned int *);
// XRRConfigCurrentConfiguration
// file /usr/include/X11/extensions/Xrandr.h line 204
unsigned short int XRRConfigCurrentConfiguration(struct _XRRScreenConfiguration *, unsigned short int *);
// XRRFreeScreenConfigInfo
// file /usr/include/X11/extensions/Xrandr.h line 170
void XRRFreeScreenConfigInfo(struct _XRRScreenConfiguration *);
// XRRGetScreenInfo
// file /usr/include/X11/extensions/Xrandr.h line 167
struct _XRRScreenConfiguration * XRRGetScreenInfo(struct _XDisplay *, unsigned long int);
// XRRQueryExtension
// file /usr/include/X11/extensions/Xrandr.h line 160
signed int XRRQueryExtension(struct _XDisplay *, signed int *, signed int *);
// XRRSetScreenConfig
// file /usr/include/X11/extensions/Xrandr.h line 179
signed int XRRSetScreenConfig(struct _XDisplay *, struct _XRRScreenConfiguration *, unsigned long int, signed int, unsigned short int, unsigned long int);
// XRRSizes
// file /usr/include/X11/extensions/Xrandr.h line 229
struct anonymous_20 * XRRSizes(struct _XDisplay *, signed int, signed int *);
// XRaiseWindow
// file /usr/include/X11/Xlib.h line 3026
extern signed int XRaiseWindow(struct _XDisplay *, unsigned long int);
// XRecolorCursor
// file /usr/include/X11/Xlib.h line 3060
extern signed int XRecolorCursor(struct _XDisplay *, unsigned long int, struct anonymous_22 *, struct anonymous_22 *);
// XScreenNumberOfScreen
// file /usr/include/X11/Xlib.h line 1839
extern signed int XScreenNumberOfScreen(struct anonymous_0 *);
// XSelectInput
// file /usr/include/X11/Xlib.h line 3129
extern signed int XSelectInput(struct _XDisplay *, unsigned long int, signed long int);
// XSendEvent
// file /usr/include/X11/Xlib.h line 3135
extern signed int XSendEvent(struct _XDisplay *, unsigned long int, signed int, signed long int, union _XEvent *);
// XSetErrorHandler
// file /usr/include/X11/Xlib.h line 1848
extern signed int (*XSetErrorHandler(signed int (*)(struct _XDisplay *, struct anonymous *)))(struct _XDisplay *, struct anonymous *);
// XSetIOErrorHandler
// file /usr/include/X11/Xlib.h line 1857
extern signed int (*XSetIOErrorHandler(signed int (*)(struct _XDisplay *)))(struct _XDisplay *);
// XSetScreenSaver
// file /usr/include/X11/Xlib.h line 3284
extern signed int XSetScreenSaver(struct _XDisplay *, signed int, signed int, signed int, signed int);
// XShmAttach
// file /usr/include/X11/extensions/XShm.h line 78
signed int XShmAttach(struct _XDisplay *, struct anonymous_2 *);
// XShmCreateImage
// file /usr/include/X11/extensions/XShm.h line 111
struct _XImage * XShmCreateImage(struct _XDisplay *, struct anonymous_8 *, unsigned int, signed int, char *, struct anonymous_2 *, unsigned int, unsigned int);
// XShmDetach
// file /usr/include/X11/extensions/XShm.h line 83
signed int XShmDetach(struct _XDisplay *, struct anonymous_2 *);
// XShmPutImage
// file /usr/include/X11/extensions/XShm.h line 88
signed int XShmPutImage(struct _XDisplay *, unsigned long int, struct _XGC *, struct _XImage *, signed int, signed int, signed int, signed int, unsigned int, unsigned int, signed int);
// XShmQueryExtension
// file /usr/include/X11/extensions/XShm.h line 59
signed int XShmQueryExtension(struct _XDisplay *);
// XSync
// file /usr/include/X11/Xlib.h line 3409
extern signed int XSync(struct _XDisplay *, signed int);
// XUnmapWindow
// file /usr/include/X11/Xlib.h line 3505
extern signed int XUnmapWindow(struct _XDisplay *, unsigned long int);
// XVisualIDFromVisual
// file /usr/include/X11/Xlib.h line 1728
extern unsigned long int XVisualIDFromVisual(struct anonymous_8 *);
// XWarpPointer
// file /usr/include/X11/Xlib.h line 3514
extern signed int XWarpPointer(struct _XDisplay *, unsigned long int, unsigned long int, signed int, signed int, unsigned int, unsigned int, signed int, signed int);
// XftColorAllocName
// file /usr/include/X11/Xft/Xft.h line 111
signed int XftColorAllocName(struct _XDisplay *, const struct anonymous_8 *, unsigned long int, const char *, struct _XftColor *);
// XftDrawCreate
// file /usr/include/X11/Xft/Xft.h line 143
struct _XftDraw * XftDrawCreate(struct _XDisplay *, unsigned long int, struct anonymous_8 *, unsigned long int);
// XftDrawDestroy
// file /usr/include/X11/Xft/Xft.h line 174
void XftDrawDestroy(struct _XftDraw *);
// XftDrawString32
// file /usr/include/X11/Xft/Xft.h line 210
void XftDrawString32(struct _XftDraw *, const struct _XftColor *, struct _XftFont *, signed int, signed int, const unsigned int *, signed int);
// XftFontClose
// file /usr/include/X11/Xft/Xft.h line 381
void XftFontClose(struct _XDisplay *, struct _XftFont *);
// XftFontMatch
// file /usr/include/X11/Xft/Xft.h line 335
struct _FcPattern * XftFontMatch(struct _XDisplay *, signed int, const struct _FcPattern *, enum _FcResult *);
// XftFontOpenPattern
// file /usr/include/X11/Xft/Xft.h line 375
struct _XftFont * XftFontOpenPattern(struct _XDisplay *, struct _FcPattern *);
// XineramaIsActive
// file /usr/include/X11/extensions/Xinerama.h line 54
signed int XineramaIsActive(struct _XDisplay *);
// XineramaQueryExtension
// file /usr/include/X11/extensions/Xinerama.h line 42
signed int XineramaQueryExtension(struct _XDisplay *, signed int *, signed int *);
// XineramaQueryScreens
// file /usr/include/X11/extensions/Xinerama.h line 66
struct anonymous_59 * XineramaQueryScreens(struct _XDisplay *, signed int *);
// XmAddProtocolCallback
// file /usr/include/Xm/Protocols.h line 93
extern void XmAddProtocolCallback(struct _WidgetRec *, unsigned long int, unsigned long int, void (*)(struct _WidgetRec *, void *, void *), void *);
// XmCreateDragIcon
// file /usr/include/Xm/DragIcon.h line 61
extern struct _WidgetRec * XmCreateDragIcon(struct _WidgetRec *, char *, struct anonymous_11 *, unsigned int);
// XmCreateErrorDialog
// file /usr/include/Xm/MessageB.h line 65
extern struct _WidgetRec * XmCreateErrorDialog(struct _WidgetRec *, char *, struct anonymous_11 *, unsigned int);
// XmCreateFileSelectionDialog
// file /usr/include/Xm/FileSB.h line 79
extern struct _WidgetRec * XmCreateFileSelectionDialog(struct _WidgetRec *, char *, struct anonymous_11 *, unsigned int);
// XmCreateInformationDialog
// file /usr/include/Xm/MessageB.h line 70
extern struct _WidgetRec * XmCreateInformationDialog(struct _WidgetRec *, char *, struct anonymous_11 *, unsigned int);
// XmCreateMenuBar
// file /usr/include/Xm/RowColumn.h line 77
extern struct _WidgetRec * XmCreateMenuBar(struct _WidgetRec *, char *, struct anonymous_11 *, unsigned int);
// XmCreateOptionMenu
// file /usr/include/Xm/RowColumn.h line 68
extern struct _WidgetRec * XmCreateOptionMenu(struct _WidgetRec *, char *, struct anonymous_11 *, unsigned int);
// XmCreatePopupMenu
// file /usr/include/Xm/RowColumn.h line 82
extern struct _WidgetRec * XmCreatePopupMenu(struct _WidgetRec *, char *, struct anonymous_11 *, unsigned int);
// XmCreatePromptDialog
// file /usr/include/Xm/SelectioB.h line 73
extern struct _WidgetRec * XmCreatePromptDialog(struct _WidgetRec *, char *, struct anonymous_11 *, unsigned int);
// XmCreatePulldownMenu
// file /usr/include/Xm/RowColumn.h line 87
extern struct _WidgetRec * XmCreatePulldownMenu(struct _WidgetRec *, char *, struct anonymous_11 *, unsigned int);
// XmCreateScrolledWindow
// file /usr/include/Xm/ScrolledW.h line 57
extern struct _WidgetRec * XmCreateScrolledWindow(struct _WidgetRec *, char *, struct anonymous_11 *, unsigned int);
// XmFileSelectionBoxGetChild
// file /usr/include/Xm/FileSB.h line 64
extern struct _WidgetRec * XmFileSelectionBoxGetChild(struct _WidgetRec *, unsigned char);
// XmInstallImage
// file /usr/include/Xm/Xm.h line 1395
extern char XmInstallImage(struct _XImage *, char *);
// XmMenuPosition
// file /usr/include/Xm/RowColumn.h line 50
extern void XmMenuPosition(struct _WidgetRec *, struct anonymous_26 *);
// XmMessageBoxGetChild
// file /usr/include/Xm/MessageB.h line 95
extern struct _WidgetRec * XmMessageBoxGetChild(struct _WidgetRec *, unsigned char);
// XmOptionButtonGadget
// file /usr/include/Xm/RowColumn.h line 75
extern struct _WidgetRec * XmOptionButtonGadget(struct _WidgetRec *);
// XmOptionLabelGadget
// file /usr/include/Xm/RowColumn.h line 73
extern struct _WidgetRec * XmOptionLabelGadget(struct _WidgetRec *);
// XmScaleGetValue
// file /usr/include/Xm/Scale.h line 59
void XmScaleGetValue(struct _WidgetRec *, signed int *);
// XmScaleSetValue
// file /usr/include/Xm/Scale.h line 56
void XmScaleSetValue(struct _WidgetRec *, signed int);
// XmSelectionBoxGetChild
// file /usr/include/Xm/SelectioB.h line 56
extern struct _WidgetRec * XmSelectionBoxGetChild(struct _WidgetRec *, unsigned char);
// XmStringConcatAndFree
// file /usr/include/Xm/Xm.h line 1790
extern union __XmStringRec * XmStringConcatAndFree(union __XmStringRec *, union __XmStringRec *);
// XmStringFree
// file /usr/include/Xm/Xm.h line 1816
extern void XmStringFree(union __XmStringRec *);
// XmStringGenerate
// file /usr/include/Xm/Xm.h line 1947
extern union __XmStringRec * XmStringGenerate(void *, char *, enum anonymous_67, char *);
// XmStringUnparse
// file /usr/include/Xm/Xm.h line 1908
extern void * XmStringUnparse(union __XmStringRec *, char *, enum anonymous_67, enum anonymous_67, struct __XmParseMappingRec **, unsigned int, enum anonymous_68);
// XmTextGetInsertionPosition
// file /usr/include/Xm/Text.h line 170
extern signed long int XmTextGetInsertionPosition(struct _WidgetRec *);
// XmTextGetString
// file /usr/include/Xm/Text.h line 110
extern char * XmTextGetString(struct _WidgetRec *);
// XmTextSetInsertionPosition
// file /usr/include/Xm/Text.h line 172
extern void XmTextSetInsertionPosition(struct _WidgetRec *, signed long int);
// XmTextSetString
// file /usr/include/Xm/Text.h line 116
extern void XmTextSetString(struct _WidgetRec *, char *);
// XmToggleButtonGetState
// file /usr/include/Xm/ToggleB.h line 58
char XmToggleButtonGetState(struct _WidgetRec *);
// XmToggleButtonSetState
// file /usr/include/Xm/ToggleB.h line 60
void XmToggleButtonSetState(struct _WidgetRec *, char, char);
// XmeClipboardSource
// file /usr/include/Xm/TransferP.h line 42
extern char XmeClipboardSource(struct _WidgetRec *, unsigned char, unsigned long int);
// XmeDragSource
// file /usr/include/Xm/TransferP.h line 43
extern struct _WidgetRec * XmeDragSource(struct _WidgetRec *, void *, union _XEvent *, struct anonymous_11 *, unsigned int);
// XpmCreateImageFromData
// file /usr/include/X11/xpm.h line 319
extern signed int XpmCreateImageFromData(struct _XDisplay *, char **, struct _XImage **, struct _XImage **, struct anonymous_133 *);
// XtAddCallback
// file /usr/include/X11/Intrinsic.h line 1235
extern void XtAddCallback(struct _WidgetRec *, const char *, void (*)(struct _WidgetRec *, void *, void *), void *);
// XtAddEventHandler
// file /usr/include/X11/Intrinsic.h line 827
extern void XtAddEventHandler(struct _WidgetRec *, unsigned long int, char, void (*)(struct _WidgetRec *, void *, union _XEvent *, char *), void *);
// XtAppAddActions
// file /usr/include/X11/Intrinsic.h line 718
extern void XtAppAddActions(struct _XtAppStruct *, struct _XtActionsRec *, unsigned int);
// XtAppAddInput
// file /usr/include/X11/Intrinsic.h line 996
extern unsigned long int XtAppAddInput(struct _XtAppStruct *, signed int, void *, void (*)(void *, signed int *, unsigned long int *), void *);
// XtAppAddSignal
// file /usr/include/X11/Intrinsic.h line 1012
extern unsigned long int XtAppAddSignal(struct _XtAppStruct *, void (*)(void *, unsigned long int *), void *);
// XtAppAddTimeOut
// file /usr/include/X11/Intrinsic.h line 978
extern unsigned long int XtAppAddTimeOut(struct _XtAppStruct *, unsigned long int, void (*)(void *, unsigned long int *), void *);
// XtAppAddWorkProc
// file /usr/include/X11/Intrinsic.h line 1908
extern unsigned long int XtAppAddWorkProc(struct _XtAppStruct *, char (*)(void *), void *);
// XtAppGetExitFlag
// file /usr/include/X11/Intrinsic.h line 2251
extern char XtAppGetExitFlag(struct _XtAppStruct *);
// XtAppNextEvent
// file /usr/include/X11/Intrinsic.h line 1030
extern void XtAppNextEvent(struct _XtAppStruct *, union _XEvent *);
// XtCallActionProc
// file /usr/include/X11/Intrinsic.h line 745
extern void XtCallActionProc(struct _WidgetRec *, const char *, union _XEvent *, char **, unsigned int);
// XtCreateManagedWidget
// file /usr/include/X11/Intrinsic.h line 1370
extern struct _WidgetRec * XtCreateManagedWidget(const char *, struct _WidgetClassRec *, struct _WidgetRec *, struct anonymous_11 *, unsigned int);
// XtDestroyWidget
// file /usr/include/X11/Intrinsic.h line 1112
extern void XtDestroyWidget(struct _WidgetRec *);
// XtDispatchEvent
// file /usr/include/X11/Intrinsic.h line 512
extern char XtDispatchEvent(union _XEvent *);
// XtDisplay
// file /usr/include/X11/Intrinsic.h line 1184
extern struct _XDisplay * XtDisplay(struct _WidgetRec *);
// XtGetApplicationResources
// file /usr/include/X11/Intrinsic.h line 1548
extern void XtGetApplicationResources(struct _WidgetRec *, void *, struct _XtResource *, unsigned int, struct anonymous_11 *, unsigned int);
// XtLastTimestampProcessed
// file /usr/include/X11/Intrinsic.h line 962
extern unsigned long int XtLastTimestampProcessed(struct _XDisplay *);
// XtMalloc
// file /usr/include/X11/Intrinsic.h line 1830
extern char * XtMalloc(unsigned int);
// XtManageChild
// file /usr/include/X11/Composite.h line 64
extern void XtManageChild(struct _WidgetRec *);
// XtName
// file /usr/include/X11/Intrinsic.h line 1208
extern char * XtName(struct _WidgetRec *);
// XtNoticeSignal
// file /usr/include/X11/Intrinsic.h line 1022
extern void XtNoticeSignal(unsigned long int);
// XtOverrideTranslations
// file /usr/include/X11/Intrinsic.h line 694
extern void XtOverrideTranslations(struct _WidgetRec *, struct _TranslationData *);
// XtParent
// file /usr/include/X11/Intrinsic.h line 1220
extern struct _WidgetRec * XtParent(struct _WidgetRec *);
// XtParseTranslationTable
// file /usr/include/X11/Intrinsic.h line 686
extern struct _TranslationData * XtParseTranslationTable(const char *);
// XtPopdown
// file /usr/include/X11/Intrinsic.h line 1345
extern void XtPopdown(struct _WidgetRec *);
// XtPopup
// file /usr/include/X11/Intrinsic.h line 1318
extern void XtPopup(struct _WidgetRec *, enum anonymous_17);
// XtRealizeWidget
// file /usr/include/X11/Intrinsic.h line 1104
extern void XtRealizeWidget(struct _WidgetRec *);
// XtRegisterDrawable
// file /usr/include/X11/Intrinsic.h line 2182
extern void XtRegisterDrawable(struct _XDisplay *, unsigned long int, struct _WidgetRec *);
// XtRemoveAllCallbacks
// file /usr/include/X11/Intrinsic.h line 1261
extern void XtRemoveAllCallbacks(struct _WidgetRec *, const char *);
// XtRemoveInput
// file /usr/include/X11/Intrinsic.h line 1004
extern void XtRemoveInput(unsigned long int);
// XtRemoveTimeOut
// file /usr/include/X11/Intrinsic.h line 985
extern void XtRemoveTimeOut(unsigned long int);
// XtRemoveWorkProc
// file /usr/include/X11/Intrinsic.h line 1914
extern void XtRemoveWorkProc(unsigned long int);
// XtScreen
// file /usr/include/X11/Intrinsic.h line 1192
extern struct anonymous_0 * XtScreen(struct _WidgetRec *);
// XtSetLanguageProc
// file /usr/include/X11/Intrinsic.h line 1426
extern char * (*XtSetLanguageProc(struct _XtAppStruct *, char * (*)(struct _XDisplay *, char *, void *), void *))(struct _XDisplay *, char *, void *);
// XtUnmanageChild
// file /usr/include/X11/Composite.h line 73
extern void XtUnmanageChild(struct _WidgetRec *);
// XtUnregisterDrawable
// file /usr/include/X11/Intrinsic.h line 2188
extern void XtUnregisterDrawable(struct _XDisplay *, unsigned long int);
// XtVaAppCreateShell
// file /usr/include/X11/Intrinsic.h line 1408
extern struct _WidgetRec * XtVaAppCreateShell(const char *, const char *, struct _WidgetClassRec *, struct _XDisplay *, ...);
// XtVaAppInitialize
// file /usr/include/X11/Intrinsic.h line 1480
extern struct _WidgetRec * XtVaAppInitialize(struct _XtAppStruct **, const char *, struct anonymous_13 *, unsigned int, signed int *, char **, char **, ...);
// XtVaCreateManagedWidget
// file /usr/include/X11/Intrinsic.h line 1385
extern struct _WidgetRec * XtVaCreateManagedWidget(const char *, struct _WidgetClassRec *, struct _WidgetRec *, ...);
// XtVaCreateWidget
// file /usr/include/X11/Intrinsic.h line 1378
extern struct _WidgetRec * XtVaCreateWidget(const char *, struct _WidgetClassRec *, struct _WidgetRec *, ...);
// XtVaGetValues
// file /usr/include/X11/Intrinsic.h line 1603
extern void XtVaGetValues(struct _WidgetRec *, ...);
// XtVaSetValues
// file /usr/include/X11/Intrinsic.h line 1592
extern void XtVaSetValues(struct _WidgetRec *, ...);
// XtWindow
// file /usr/include/X11/Intrinsic.h line 1200
extern unsigned long int XtWindow(struct _WidgetRec *);
// XvCreateImage
// file /usr/include/X11/extensions/Xvlib.h line 327
extern struct anonymous_3 * XvCreateImage(struct _XDisplay *, unsigned long int, signed int, char *, signed int, signed int);
// XvGetPortAttribute
// file /usr/include/X11/extensions/Xvlib.h line 286
extern signed int XvGetPortAttribute(struct _XDisplay *, unsigned long int, unsigned long int, signed int *);
// XvGrabPort
// file /usr/include/X11/extensions/Xvlib.h line 255
extern signed int XvGrabPort(struct _XDisplay *, unsigned long int, unsigned long int);
// XvListImageFormats
// file /usr/include/X11/extensions/Xvlib.h line 321
extern struct anonymous_6 * XvListImageFormats(struct _XDisplay *, unsigned long int, signed int *);
// XvPutImage
// file /usr/include/X11/extensions/Xvlib.h line 336
extern signed int XvPutImage(struct _XDisplay *, unsigned long int, unsigned long int, struct _XGC *, struct anonymous_3 *, signed int, signed int, unsigned int, unsigned int, signed int, signed int, unsigned int, unsigned int);
// XvPutVideo
// file /usr/include/X11/extensions/Xvlib.h line 189
extern signed int XvPutVideo(struct _XDisplay *, unsigned long int, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int, signed int, signed int, unsigned int, unsigned int);
// XvQueryAdaptors
// file /usr/include/X11/extensions/Xvlib.h line 175
extern signed int XvQueryAdaptors(struct _XDisplay *, unsigned long int, unsigned int *, struct anonymous_5 **);
// XvQueryEncodings
// file /usr/include/X11/extensions/Xvlib.h line 182
extern signed int XvQueryEncodings(struct _XDisplay *, unsigned long int, unsigned int *, struct anonymous_111 **);
// XvQueryExtension
// file /usr/include/X11/extensions/Xvlib.h line 166
extern signed int XvQueryExtension(struct _XDisplay *, unsigned int *, unsigned int *, unsigned int *, unsigned int *, unsigned int *);
// XvQueryPortAttributes
// file /usr/include/X11/extensions/Xvlib.h line 305
extern struct anonymous_112 * XvQueryPortAttributes(struct _XDisplay *, unsigned long int, signed int *);
// XvSetPortAttribute
// file /usr/include/X11/extensions/Xvlib.h line 279
extern signed int XvSetPortAttribute(struct _XDisplay *, unsigned long int, unsigned long int, signed int);
// XvShmCreateImage
// file /usr/include/X11/extensions/Xvlib.h line 369
extern struct anonymous_3 * XvShmCreateImage(struct _XDisplay *, unsigned long int, signed int, char *, signed int, signed int, struct anonymous_2 *);
// XvShmPutImage
// file /usr/include/X11/extensions/Xvlib.h line 352
extern signed int XvShmPutImage(struct _XDisplay *, unsigned long int, unsigned long int, struct _XGC *, struct anonymous_3 *, signed int, signed int, unsigned int, unsigned int, signed int, signed int, unsigned int, unsigned int, signed int);
// XvStopVideo
// file /usr/include/X11/extensions/Xvlib.h line 249
extern signed int XvStopVideo(struct _XDisplay *, unsigned long int, unsigned long int);
// XvUngrabPort
// file /usr/include/X11/extensions/Xvlib.h line 261
extern signed int XvUngrabPort(struct _XDisplay *, unsigned long int, unsigned long int);
// ZapAction
// file x11/xt.h line 134
void ZapAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// _XEditResCheckMessages
// file /usr/include/X11/Xmu/Editres.h line 31
void _XEditResCheckMessages(struct _WidgetRec *, void *, union _XEvent *, char *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __list_add
// file ./libng/list.h line 34
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next);
// __list_add_link1
// file libng/list.h line 34
static inline void __list_add_link1(struct list_head *new_link1, struct list_head *prev_link1, struct list_head *next_link1);
// __list_del
// file ./libng/list.h line 77
static inline void __list_del(struct list_head *prev, struct list_head *next);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// about_cb
// file x11/motv.c line 410
static void about_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// action_cb
// file x11/motv.c line 422
static void action_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// add_attr_option
// file x11/motv.c line 1052
static void add_attr_option(struct _WidgetRec *menu, struct ng_attribute *attr);
// add_attrs
// file ./common/commands.h line 74
void add_attrs(struct ng_attribute *new);
// add_channel
// file ./common/channel.h line 70
struct CHANNEL * add_channel(char *name);
// add_clip
// file x11/x11.c line 381
static void add_clip(signed int x1, signed int y1, signed int x2, signed int y2);
// add_cmd_callback
// file x11/motv.c line 991
static void add_cmd_callback(struct _WidgetRec *widget, char *callback, char *command, const char *arg1, const char *arg2);
// add_cmd_menuitem
// file x11/motv.c line 1012
static struct _WidgetRec * add_cmd_menuitem(const char *n, signed int nr, struct _WidgetRec *parent, const char *l, char *k, char *a, signed int toggle, char *c, const char *arg1, const char *arg2);
// add_dvb_class
// file common/get_media_devices.c line 275
static signed int add_dvb_class(struct media_device_entry *md);
// add_dvb_class_link1
// file common/get_media_devices.c line 275
static signed int add_dvb_class_link1(struct media_device_entry *md_link1);
// add_pixmap
// file x11/icons.c line 22
static void add_pixmap(struct _XDisplay *dpy, unsigned long int bg, char *imgname, char *maskname, char **data);
// add_snd_class
// file common/get_media_devices.c line 232
static signed int add_snd_class(struct media_device_entry *md);
// add_snd_class_link1
// file common/get_media_devices.c line 232
static signed int add_snd_class_link1(struct media_device_entry *md_link1);
// add_v4l_class
// file common/get_media_devices.c line 218
static signed int add_v4l_class(struct media_device_entry *md);
// add_v4l_class_link1
// file common/get_media_devices.c line 218
static signed int add_v4l_class_link1(struct media_device_entry *md_link1);
// alphasort
// file /usr/include/dirent.h line 329
extern signed int alphasort(struct dirent **, struct dirent **);
// alsa_stream
// file common/alsa_stream.c line 470
static signed int alsa_stream(const char *pdevice, const char *cdevice, signed int latency);
// alsa_thread_entry
// file common/alsa_stream.c line 576
static void * alsa_thread_entry(void *whatever);
// alsa_thread_is_running
// file ./common/alsa_stream.h line 5
signed int alsa_thread_is_running(void);
// alsa_thread_startup
// file ./common/alsa_stream.h line 1
signed int alsa_thread_startup(const char *pdevice, const char *cdevice, signed int latency, struct _IO_FILE *__error_fp, signed int __verbose);
// alsa_thread_stop
// file ./common/alsa_stream.h line 4
void alsa_thread_stop(void);
// alsa_try_rate
// file common/alsa_stream.c line 222
static signed int alsa_try_rate(struct _snd_pcm *phandle, struct _snd_pcm *chandle, struct _snd_pcm_hw_params *p_hwparams, struct _snd_pcm_hw_params *c_hwparams, signed int allow_resample, unsigned int *ratep, unsigned int *ratec);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// attr_handler
// file common/commands.c line 833
static signed int attr_handler(char *name, signed int argc, char **argv);
// attr_init
// file ./common/commands.h line 68
void attr_init(void);
// attr_notify_object
//
void attr_notify_object(struct ng_attribute *, signed int);
// audio_init
// file ./common/commands.h line 69
void audio_init(void);
// audio_off
// file ./common/commands.h line 71
void audio_off(void);
// audio_on
// file ./common/commands.h line 70
void audio_on(void);
// bgr24_to_bgr32
// file libng/color_packed.c line 39
static void bgr24_to_bgr32(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr24_to_lut2
// file libng/color_lut.c line 43
static void bgr24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr24_to_lut4
// file libng/color_lut.c line 109
static void bgr24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr24_to_rgb32
// file libng/color_packed.c line 54
static void bgr24_to_rgb32(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr32_to_lut2
// file libng/color_lut.c line 69
static void bgr32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr32_to_lut4
// file libng/color_lut.c line 135
static void bgr32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// blit_fini
// file x11/blit.c line 906
void blit_fini(struct blit_state *st);
// blit_fini_frame
// file x11/blit.h line 31
void blit_fini_frame(struct blit_state *st);
// blit_get_formats
// file x11/blit.h line 28
void blit_get_formats(struct blit_state *st, signed int *fmtids, signed int max);
// blit_init
// file x11/blit.h line 27
struct blit_state * blit_init(struct _WidgetRec *widget, struct anonymous_1 *vinfo, signed int use_gl);
// blit_init_frame
// file x11/blit.c line 785
void blit_init_frame(struct blit_state *st, struct ng_video_fmt *fmt);
// blit_putframe
// file x11/blit.h line 33
void blit_putframe(struct blit_state *st, struct ng_video_buf *buf);
// blit_resize
// file x11/blit.h line 29
void blit_resize(struct blit_state *st, unsigned short int width, unsigned short int height);
// byteswap_short
// file libng/color_packed.c line 102
static void byteswap_short(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// calc_frequencies
// file ./common/channel.h line 74
void calc_frequencies(void);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// capture_get_hook_object
//
void capture_get_hook_object(void);
// capture_handler
// file common/commands.c line 778
static signed int capture_handler(char *name, signed int argc, char **argv);
// capture_rel_hook_object
//
void capture_rel_hook_object(void);
// catch_gl_error
// file x11/blit.c line 94
static signed int catch_gl_error(struct _XDisplay *dpy, struct anonymous *event);
// catch_no_mitshm
// file x11/blit.c line 87
static signed int catch_no_mitshm(struct _XDisplay *dpy, struct anonymous *event);
// cc_sim
// file common/vbi-sim.c line 22
static inline double cc_sim(double t, double F, unsigned char b1, unsigned char b2);
// cf2freq
// file common/channel.c line 159
signed int cf2freq(char *name, signed int fine);
// cfg_find_section
// file common/parseconfig.c line 61
static struct CFG_ENTRIES * cfg_find_section(struct CFG_SECTIONS *c, char *name);
// cfg_get_float
// file common/parseconfig.c line 245
float cfg_get_float(char *sec, char *ent);
// cfg_get_int
// file ./common/parseconfig.h line 8
signed int cfg_get_int(char *sec, char *ent);
// cfg_get_signed_int
// file common/parseconfig.h line 9
signed int cfg_get_signed_int(char *sec, char *ent);
// cfg_get_str
// file common/parseconfig.h line 7
char * cfg_get_str(char *sec, char *ent);
// cfg_init_entries
// file common/parseconfig.c line 46
static struct CFG_ENTRIES * cfg_init_entries(void);
// cfg_init_sections
// file common/parseconfig.c line 33
static struct CFG_SECTIONS * cfg_init_sections(void);
// cfg_list_entries
// file ./common/parseconfig.h line 6
char ** cfg_list_entries(char *name);
// cfg_list_sections
// file common/parseconfig.h line 5
char ** cfg_list_sections(void);
// cfg_parse_file
// file common/parseconfig.h line 1
signed int cfg_parse_file(char *filename);
// cfg_parse_option
// file common/parseconfig.c line 153
void cfg_parse_option(char *section, char *tag, char *value);
// cfg_parse_options
// file common/parseconfig.h line 3
void cfg_parse_options(signed int *argc, char **argv);
// cfg_set_entry
// file common/parseconfig.c line 85
static void cfg_set_entry(struct CFG_ENTRIES *e, char *name, char *value);
// chan_add_cb
// file x11/motv.c line 679
static void chan_add_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// chan_apply_cb
// file x11/motv.c line 724
static void chan_apply_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// chan_del_cb
// file x11/motv.c line 1193
static void chan_del_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// chan_edit_cb
// file x11/motv.c line 698
static void chan_edit_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// chan_key_eh
// file x11/motv.c line 657
static void chan_key_eh(struct _WidgetRec *widget, void *client_data, union _XEvent *event, char *cont);
// chan_makebutton
// file x11/motv.c line 1213
static void chan_makebutton(struct CHANNEL *channel);
// chan_resize_eh
// file x11/motv.c line 1182
static void chan_resize_eh(struct _WidgetRec *widget, void *client_data, union _XEvent *event, char *d);
// chan_save_cb
// file x11/motv.c line 794
static void chan_save_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// chan_tune_cb
// file x11/motv.c line 800
static void chan_tune_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// change_audio
// file x11/xt.h line 156
void change_audio(signed int mode);
// channel_menu
// file x11/motv.c line 1102
static void channel_menu(void);
// channel_switch_hook_object
//
void channel_switch_hook_object(void);
// chscan_cancel_cb
// file x11/motv.c line 2296
static void chscan_cancel_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// chscan_cb
// file x11/motv.c line 2307
static void chscan_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// chscan_start_cb
// file x11/motv.c line 2264
static void chscan_start_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// chscan_timeout
// file x11/motv.c line 2196
static void chscan_timeout(void *client_data, unsigned long int *id);
// clip_drop
// file libng/grab-ng.c line 841
static void clip_drop(struct OVERLAY_CLIP *oc, signed int n, signed int *count);
// clip_dump
// file libng/grab-ng.c line 829
static void clip_dump(char *state, struct OVERLAY_CLIP *oc, signed int count);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// command_cb
// file x11/xt.h line 167
void command_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// configure_delayed
// file x11/x11.c line 496
static char configure_delayed(void *data);
// configure_overlay
// file x11/x11.c line 535
static void configure_overlay(void);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// convert_buffer
// file x11/motv.c line 2634
static struct ng_video_buf * convert_buffer(struct ng_video_buf *in, signed int out_fmt);
// create_attr_widgets
// file x11/motv.c line 1513
static void create_attr_widgets(void);
// create_bitmaps
// file x11/xt.h line 214
void create_bitmaps(struct _WidgetRec *app_shell);
// create_control
// file x11/motv.c line 1235
static void create_control(void);
// create_filter_prop
// file x11/motv.c line 933
static void create_filter_prop(void);
// create_levels
// file x11/motv.c line 3146
static void create_levels(void);
// create_onscreen
// file x11/xt.h line 145
void create_onscreen(struct _WidgetClassRec *class);
// create_pointers
// file x11/xt.h line 213
void create_pointers(struct _WidgetRec *app_shell);
// create_pref
// file x11/motv.c line 2553
static void create_pref(void);
// create_prop
// file x11/motv.c line 812
static void create_prop(void);
// create_scale
// file x11/motv.c line 1599
static void create_scale(void);
// create_strwin
// file x11/motv.c line 1828
static void create_strwin(void);
// create_vtx
// file x11/motv.c line 469
static void create_vtx(void);
// ctime
// file /usr/include/time.h line 264
extern char * ctime(const signed long int *);
// dattr_handler
// file common/commands.c line 980
static signed int dattr_handler(char *name, signed int argc, char **argv);
// del_channel
// file ./common/channel.h line 73
void del_channel(signed int i);
// delete_children
// file x11/motv.c line 224
static void delete_children(struct _WidgetRec *widget);
// destroy_cb
// file x11/motv.c line 398
static void destroy_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// discover_media_devices
// file ./common/get_media_devices.h line 81
void * discover_media_devices(void);
// display_media_devices
// file common/get_media_devices.c line 418
void display_media_devices(void *opaque);
// display_message_object
//
void display_message_object(char *);
// display_onscreen
// file x11/xt.c line 556
static void display_onscreen(char *title);
// display_subtitle
// file x11/motv.c line 544
static void display_subtitle(struct vbi_page *pg, struct vbi_rect *rect);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// do_capture
// file x11/motv.c line 1728
static void do_capture(signed int from, signed int to, signed int tmp_switch);
// do_command
// file ./common/commands.h line 78
signed int do_command(signed int argc, char **argv);
// do_exit
// file x11/xt.h line 131
void do_exit(void);
// do_fullscreen
// file x11/xt.h line 143
void do_fullscreen(void);
// do_modeswitch
// file x11/xt.c line 948
static void do_modeswitch(signed int fs_state, signed int *vp_width, signed int *vp_height);
// do_motif_fullscreen
// file x11/motv.c line 1765
static void do_motif_fullscreen(void);
// do_movie_record
// file x11/motv.c line 2036
static void do_movie_record(signed int argc, char **argv);
// do_ontop
// file x11/motv.c line 284
static void do_ontop(char state);
// do_randr_modeswitch
// file x11/xt.c line 905
static void do_randr_modeswitch(signed int fs_state, signed int *vp_width, signed int *vp_height);
// do_rec_status
// file x11/motv.c line 2181
static void do_rec_status(char *message);
// do_screensaver
// file x11/xt.c line 974
static void do_screensaver(signed int fs_state);
// do_va_cmd
// file ./common/commands.h line 77
signed int do_va_cmd(signed int argc, ...);
// do_vidmode_modeswitch
// file x11/xt.c line 850
static void do_vidmode_modeswitch(signed int fs_state, signed int *vp_width, signed int *vp_height);
// do_write_jpeg
// file libng/writefile.c line 87
static signed int do_write_jpeg(struct _IO_FILE *fp, struct ng_video_buf *buf, signed int quality, signed int gray);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// endpwent
// file /usr/include/pwd.h line 78
extern void endpwent(void);
// event_dispatch
// file ./common/event.h line 23
signed int event_dispatch(char *event);
// event_readconfig
// file common/event.h line 20
void event_readconfig(void);
// event_register
// file common/event.c line 54
signed int event_register(char *event, char *action);
// event_register_list
// file common/event.h line 18
signed int event_register_list(struct event_entry *entry);
// event_writeconfig
// file common/event.h line 21
void event_writeconfig(struct _IO_FILE *fp);
// exec_done
// file x11/xt.c line 605
void exec_done(signed int signal);
// exec_output
// file x11/xt.c line 628
static void exec_output(void *data, signed int *fd, unsigned long int *iproc);
// exec_player
// file x11/xt.h line 151
void exec_player(char *moviefile);
// exec_player_cb
// file x11/motv.c line 1819
static void exec_player_cb(struct _WidgetRec *widget, void *client_data, void *calldata);
// exec_x11
// file x11/xt.c line 649
signed int exec_x11(char **argv);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_handler
// file common/commands.c line 1189
static signed int exit_handler(char *name, signed int argc, char **argv);
// exit_hook_object
//
void exit_hook_object(void);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fget_associated_device
// file common/get_media_devices.c line 501
const char * fget_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const signed int fd_seek_device, const enum device_type seek_type);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fifo_get
// file common/capture.c line 81
void * fifo_get(struct FIFO *fifo);
// fifo_init
// file common/capture.c line 31
void fifo_init(struct FIFO *fifo, char *name, signed int slots, signed int writers);
// fifo_put
// file common/capture.c line 45
signed int fifo_put(struct FIFO *fifo, void *data);
// file_browse_cb
// file x11/motv.c line 1796
static void file_browse_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// file_done_cb
// file x11/motv.c line 1780
static void file_done_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// files_audio
// file libng/writefile.c line 364
static signed int files_audio(void *handle, struct ng_audio_buf *buf);
// files_close
// file libng/writefile.c line 374
static signed int files_close(void *handle);
// files_open
// file libng/writefile.c line 298
static void * files_open(char *filesname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio);
// files_video
// file libng/writefile.c line 330
static signed int files_video(void *handle, struct ng_video_buf *buf);
// filter_add_ctrls
// file x11/motv.c line 875
static void filter_add_ctrls(struct _WidgetRec *rc, struct ng_filter *filter, struct ng_attribute *attr);
// filter_cb
// file x11/motv.c line 853
static void filter_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// find_screensaver_window
// file jwz/remote.c line 73
static unsigned long int find_screensaver_window(struct _XDisplay *dpy, char **version);
// flushit
// file common/capture.c line 106
static void * flushit(void *arg);
// fnmatch
// file /usr/include/fnmatch.h line 56
extern signed int fnmatch(const char *, const char *, signed int);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_cb
// file x11/motv.c line 404
static void free_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// free_media_devices
// file ./common/get_media_devices.h line 92
void free_media_devices(void *opaque);
// freq_init
// file ./common/frequencies.h line 105
void freq_init(void);
// freq_newtab
// file common/frequencies.h line 106
void freq_newtab(signed int n);
// freq_readlist
// file common/frequencies.c line 78
static signed int freq_readlist(struct CHANLIST **list, signed int n, char *name);
// freqtab_notify_object
//
void freqtab_notify_object(void);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 219
extern signed int fstat(signed int, struct stat *);
// fullscreen_handler
// file common/commands.c line 1158
static signed int fullscreen_handler(char *name, signed int argc, char **argv);
// fullscreen_hook_object
//
void fullscreen_hook_object(void);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_associated_device
// file ./common/get_media_devices.h line 124
const char * get_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const char *seek_device, const enum device_type seek_type);
// get_bus
// file common/get_media_devices.c line 96
static enum bus_type get_bus(char *device);
// get_bus_link1
// file common/get_media_devices.c line 96
static enum bus_type get_bus_link1(char *device_link1);
// get_class
// file common/get_media_devices.c line 121
static signed int get_class(char *class, struct media_device_entry **md, unsigned int *md_size, signed int (*fill)(struct media_device_entry *));
// get_class_link1
// file common/get_media_devices.c line 121
static signed int get_class_link1(char *class_link1, struct media_device_entry **md_link1, unsigned int *md_size_link1, signed int (*fill_link1)(struct media_device_entry *));
// get_class::fill_link1_object
//
signed int fill_link1_object(struct media_device_entry *);
// get_class::fill_object
//
signed int fill_object(struct media_device_entry *);
// get_clips
// file x11/x11.c line 395
static void get_clips(void);
// get_clips::_tmp::return_value_XSetErrorHandler_1_object
//
signed int return_value_XSetErrorHandler_1_object(struct _XDisplay *, struct anonymous *);
// get_freq
// file common/channel.c line 152
signed int get_freq(signed int i);
// get_not_associated_device
// file common/get_media_devices.c line 561
const char * get_not_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const enum device_type not_desired_type);
// get_uevent_info
// file common/get_media_devices.c line 69
static void get_uevent_info(struct media_device_entry *md_ptr, char *dname);
// get_uevent_info_link1
// file common/get_media_devices.c line 69
static void get_uevent_info_link1(struct media_device_entry *md_ptr_link1, char *dname_link1);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getparams_periods
// file common/alsa_stream.c line 108
static void getparams_periods(struct _snd_pcm *handle, struct _snd_pcm_hw_params *params, unsigned int *usecs, unsigned int *count, signed int allow_adjust, const char *id);
// getpeername
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 141
extern signed int getpeername(signed int, struct sockaddr *, unsigned int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwent
// file /usr/include/pwd.h line 84
extern struct passwd * getpwent(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// glBegin
// file /usr/include/GL/gl.h line 929
void glBegin(unsigned int);
// glBindTexture
// file /usr/include/GL/gl.h line 1311
void glBindTexture(unsigned int, unsigned int);
// glClearColor
// file /usr/include/GL/gl.h line 750
void glClearColor(float, float, float, float);
// glDisable
// file /usr/include/GL/gl.h line 798
void glDisable(unsigned int);
// glEnable
// file /usr/include/GL/gl.h line 796
void glEnable(unsigned int);
// glEnd
// file /usr/include/GL/gl.h line 931
void glEnd(void);
// glGenTextures
// file /usr/include/GL/gl.h line 1307
void glGenTextures(signed int, unsigned int *);
// glGetIntegerv
// file /usr/include/GL/gl.h line 814
void glGetIntegerv(unsigned int, signed int *);
// glGetString
// file /usr/include/GL/gl.h line 831
const unsigned char * glGetString(unsigned int);
// glLoadIdentity
// file /usr/include/GL/gl.h line 883
void glLoadIdentity(void);
// glMatrixMode
// file /usr/include/GL/gl.h line 866
void glMatrixMode(unsigned int);
// glOrtho
// file /usr/include/GL/gl.h line 868
void glOrtho(double, double, double, double, double, double);
// glPixelStorei
// file /usr/include/GL/gl.h line 1194
void glPixelStorei(unsigned int, signed int);
// glShadeModel
// file /usr/include/GL/gl.h line 1157
void glShadeModel(unsigned int);
// glTexCoord2f
// file /usr/include/GL/gl.h line 1042
void glTexCoord2f(float, float);
// glTexEnvf
// file /usr/include/GL/gl.h line 1259
void glTexEnvf(unsigned int, unsigned int, float);
// glTexImage2D
// file /usr/include/GL/gl.h line 1294
void glTexImage2D(unsigned int, signed int, signed int, signed int, signed int, signed int, unsigned int, unsigned int, const void *);
// glTexParameteri
// file /usr/include/GL/gl.h line 1270
void glTexParameteri(unsigned int, unsigned int, signed int);
// glTexSubImage2D
// file /usr/include/GL/gl.h line 1330
void glTexSubImage2D(unsigned int, signed int, signed int, signed int, signed int, signed int, unsigned int, unsigned int, const void *);
// glVertex3f
// file /usr/include/GL/gl.h line 940
void glVertex3f(float, float, float);
// glViewport
// file /usr/include/GL/gl.h line 876
void glViewport(signed int, signed int, signed int, signed int);
// glXChooseVisual
// file /usr/include/GL/glx.h line 187
extern struct anonymous_1 * glXChooseVisual(struct _XDisplay *, signed int, signed int *);
// glXCreateContext
// file /usr/include/GL/glx.h line 190
extern struct __GLXcontextRec * glXCreateContext(struct _XDisplay *, struct anonymous_1 *, struct __GLXcontextRec *, signed int);
// glXIsDirect
// file /usr/include/GL/glx.h line 212
extern signed int glXIsDirect(struct _XDisplay *, struct __GLXcontextRec *);
// glXMakeCurrent
// file /usr/include/GL/glx.h line 195
extern signed int glXMakeCurrent(struct _XDisplay *, unsigned long int, struct __GLXcontextRec *);
// glXSwapBuffers
// file /usr/include/GL/glx.h line 201
extern void glXSwapBuffers(struct _XDisplay *, unsigned long int);
// gl_blit
// file x11/blit.c line 644
static void gl_blit(struct _WidgetRec *widget, char *rgbbuf, signed int iw, signed int ih, signed int ww, signed int wh, signed int tex, signed int tw, signed int th, signed int fmt, signed int type);
// gl_cleanup
// file x11/blit.c line 639
static void gl_cleanup(signed int tex);
// gl_ext
// file x11/blit.c line 572
static signed int gl_ext(unsigned char *find);
// gl_init
// file x11/blit.c line 527
static signed int gl_init(struct _WidgetRec *widget);
// gl_init::_tmp::return_value_XSetErrorHandler_9_object
//
signed int return_value_XSetErrorHandler_9_object(struct _XDisplay *, struct anonymous *);
// gl_resize
// file x11/blit.c line 592
static signed int gl_resize(signed int iw, signed int ih, signed int ww, signed int wh, signed int *tex, signed int *tw, signed int *th, signed int fmt, signed int type);
// gnome_stay_on_top
// file x11/wmhooks.c line 75
static void gnome_stay_on_top(struct _XDisplay *dpy, unsigned long int win, signed int state);
// gnu_dev_major
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 27
extern unsigned int gnu_dev_major(unsigned long long int);
// gnu_dev_minor
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 30
extern unsigned int gnu_dev_minor(unsigned long long int);
// grabber_init
// file x11/xt.h line 183
void grabber_init(void);
// grabber_scan
// file x11/xt.h line 184
void grabber_scan(void);
// gray_to_lut2
// file libng/color_lut.c line 82
static void gray_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// gray_to_lut4
// file libng/color_lut.c line 148
static void gray_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// handle_cmdline_args
// file x11/xt.h line 188
void handle_cmdline_args(void);
// hello_world
// file x11/xt.h line 187
void hello_world(char *name);
// iconv
// file /usr/include/iconv.h line 42
extern unsigned long int iconv(void *, char ** restrict , unsigned long int *, char ** restrict , unsigned long int *);
// iconv_open
// file /usr/include/iconv.h line 37
extern void * iconv_open(const char *, const char *);
// init_atoms
// file x11/atoms.h line 2
void init_atoms(struct _XDisplay *dpy);
// init_channel
// file common/channel.c line 318
static void init_channel(char *name, struct CHANNEL *c);
// init_movie_menus
// file x11/motv.c line 2025
static void init_movie_menus(void);
// init_overlay
// file ./common/commands.h line 75
void init_overlay(void);
// init_sim
// file common/vbi-sim.c line 429
static struct vbi_raw_decoder * init_sim(signed int scanning, unsigned int services);
// int_to_str
// file common/channel.c line 752
const char * int_to_str(signed int n, struct STRTAB *tab);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// ipc_convert
// file x11/motv.c line 2858
static void ipc_convert(struct _WidgetRec *widget, void *ignore, void *call_data);
// ipc_find
// file x11/motv.c line 2735
static struct ipc_data * ipc_find(unsigned long int selection);
// ipc_fini
// file x11/motv.c line 2816
static void ipc_fini(unsigned long int selection);
// ipc_finish
// file x11/motv.c line 3040
static void ipc_finish(struct _WidgetRec *widget, void *ignore, void *call_data);
// ipc_iconify
// file x11/motv.c line 2703
static void ipc_iconify(struct _WidgetRec *widget, struct ipc_data *ipc);
// ipc_init
// file x11/motv.c line 2749
static struct ipc_data * ipc_init(unsigned long int selection);
// ipc_pixmap
// file x11/motv.c line 2801
static void ipc_pixmap(struct ipc_data *ipc);
// ipc_tmpfile
// file x11/motv.c line 2777
static void ipc_tmpfile(struct ipc_data *ipc);
// ipc_unique_atom
// file x11/motv.c line 2842
static unsigned long int ipc_unique_atom(struct _WidgetRec *widget);
// joystick_tv_havedata
// file ./common/joystick.h line 2
void joystick_tv_havedata(signed int js);
// joystick_tv_init
// file ./common/joystick.h line 1
signed int joystick_tv_init(char *dev);
// jpeg_CreateCompress
// file /usr/include/jpeglib.h line 904
extern void jpeg_CreateCompress(struct jpeg_compress_struct *, signed int, unsigned long int);
// jpeg_destroy_compress
// file /usr/include/jpeglib.h line 909
extern void jpeg_destroy_compress(struct jpeg_compress_struct *);
// jpeg_finish_compress
// file /usr/include/jpeglib.h line 954
extern void jpeg_finish_compress(struct jpeg_compress_struct *);
// jpeg_set_defaults
// file /usr/include/jpeglib.h line 926
extern void jpeg_set_defaults(struct jpeg_compress_struct *);
// jpeg_set_quality
// file /usr/include/jpeglib.h line 931
extern void jpeg_set_quality(struct jpeg_compress_struct *, signed int, signed int);
// jpeg_start_compress
// file /usr/include/jpeglib.h line 949
extern void jpeg_start_compress(struct jpeg_compress_struct *, signed int);
// jpeg_std_error
// file /usr/include/jpeglib.h line 889
extern struct jpeg_error_mgr * jpeg_std_error(struct jpeg_error_mgr *);
// jpeg_stdio_dest
// file /usr/include/jpeglib.h line 914
extern void jpeg_stdio_dest(struct jpeg_compress_struct *, struct _IO_FILE *);
// jpeg_write_scanlines
// file /usr/include/jpeglib.h line 951
extern unsigned int jpeg_write_scanlines(struct jpeg_compress_struct *, unsigned char **, unsigned int);
// keypad_handler
// file common/commands.c line 1484
static signed int keypad_handler(char *name, signed int argc, char **argv);
// keypad_timeout
// file ./common/commands.h line 80
void keypad_timeout(void);
// levels_input
// file x11/motv.c line 3096
static void levels_input(void *clientdata, signed int *src, unsigned long int *id);
// levels_toggle_cb
// file x11/motv.c line 3110
static void levels_toggle_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// link
// file /usr/include/unistd.h line 790
extern signed int link(const char *, const char *);
// lirc_code2char
// file /usr/include/lirc/lirc_client.h line 89
signed int lirc_code2char(struct lirc_config *, char *, char **);
// lirc_init
// file /usr/include/lirc/lirc_client.h line 77
signed int lirc_init(char *, signed int);
// lirc_nextcode
// file /usr/include/lirc/lirc_client.h line 88
signed int lirc_nextcode(char **);
// lirc_readconfig
// file /usr/include/lirc/lirc_client.h line 80
signed int lirc_readconfig(char *, struct lirc_config **, signed int (*)(char *));
// lirc_tv_havedata
// file ./common/lirc.h line 2
signed int lirc_tv_havedata(void);
// lirc_tv_init
// file ./common/lirc.h line 1
signed int lirc_tv_init(void);
// list_add_tail
// file ./libng/list.h line 65
static inline void list_add_tail(struct list_head *new, struct list_head *head);
// list_add_tail_link1
// file libng/list.h line 65
static inline void list_add_tail_link1(struct list_head *new_link1, struct list_head *head_link1);
// list_del
// file ./libng/list.h line 89
static inline void list_del(struct list_head *entry);
// list_empty
// file ./libng/list.h line 108
static inline signed int list_empty(struct list_head *head);
// list_handler
// file common/commands.c line 943
static signed int list_handler(char *name, signed int argc, char **argv);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// lookup_channel
// file ./common/channel.h line 66
signed int lookup_channel(char *channel);
// lseek
// file /usr/include/unistd.h line 337
extern signed long int lseek(signed int, signed long int, signed int);
// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 266
extern signed int lstat(const char *, struct stat *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// man
// file x11/man.c line 45
void man(char *page);
// man_action
// file x11/man.h line 3
void man_action(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// man_cb
// file x11/man.h line 2
void man_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// man_destroy
// file x11/man.c line 39
static void man_destroy(struct _WidgetRec *widget, void *clientdata, void *call_data);
// media_device_type
// file common/get_media_devices.c line 364
const char * media_device_type(enum device_type type);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// menu_cols_cb
// file x11/motv.c line 1085
static void menu_cols_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// midi_close
// file common/midictrl.c line 182
signed int midi_close(struct midi_handle *h);
// midi_connect
// file ./common/midictrl.h line 18
signed int midi_connect(struct midi_handle *h, char *arg);
// midi_dump_ev
// file common/midictrl.c line 68
static void midi_dump_ev(struct _IO_FILE *out, struct snd_seq_event *ev);
// midi_open
// file ./common/midictrl.h line 16
signed int midi_open(struct midi_handle *h, char *name);
// midi_read
// file ./common/midictrl.h line 19
signed int midi_read(struct midi_handle *h);
// midi_translate
// file ./common/midictrl.h line 21
void midi_translate(struct midi_handle *h);
// mkstemp
// file /usr/include/stdlib.h line 622
extern signed int mkstemp(char *);
// mouse_event
// file x11/xt.h line 192
void mouse_event(struct _WidgetRec *widget, void *client_data, union _XEvent *event, char *d);
// mouse_timeout
// file x11/xt.c line 1800
static void mouse_timeout(void *clientData, unsigned long int *id);
// movie_grab_put_video
// file ./common/capture.h line 36
signed int movie_grab_put_video(struct movie_handle *h, struct ng_video_buf **ret);
// movie_handler
// file common/commands.c line 1149
static signed int movie_handler(char *name, signed int argc, char **argv);
// movie_hook_object
//
void movie_hook_object(signed int, char **);
// movie_print_timestamps
// file common/capture.c line 583
static void movie_print_timestamps(struct movie_handle *h);
// movie_writer_init
// file ./common/capture.h line 28
struct movie_handle * movie_writer_init(char *moviename, char *audioname, struct ng_writer *writer, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio, char *dsp, signed int slots, signed int threads);
// movie_writer_start
// file ./common/capture.h line 33
signed int movie_writer_start(struct movie_handle *h);
// movie_writer_stop
// file ./common/capture.h line 34
signed int movie_writer_stop(struct movie_handle *h);
// msg_handler
// file common/commands.c line 1166
static signed int msg_handler(char *name, signed int argc, char **argv);
// mute_notify_object
//
void mute_notify_object(signed int);
// my_cmp
// file x11/complete.c line 34
static signed int my_cmp(const void *a, const void *b);
// my_scandir
// file x11/complete.c line 44
static signed int my_scandir(char *dir, char *match, char ***namelist);
// netwm_fullscreen
// file x11/wmhooks.c line 62
static void netwm_fullscreen(struct _XDisplay *dpy, unsigned long int win, signed int state);
// netwm_old_stay_on_top
// file x11/wmhooks.c line 55
static void netwm_old_stay_on_top(struct _XDisplay *dpy, unsigned long int win, signed int state);
// netwm_set_state
// file x11/wmhooks.c line 30
static void netwm_set_state(struct _XDisplay *dpy, unsigned long int win, signed int operation, unsigned long int state);
// netwm_stay_on_top
// file x11/wmhooks.c line 48
static void netwm_stay_on_top(struct _XDisplay *dpy, unsigned long int win, signed int state);
// new_attr
// file x11/motv.c line 578
static void new_attr(struct ng_attribute *attr, signed int val);
// new_channel
// file x11/motv.c line 250
static void new_channel(void);
// new_freqtab
// file x11/motv.c line 625
static void new_freqtab(void);
// new_message
// file x11/xt.h line 155
void new_message(char *txt);
// new_title
// file x11/xt.h line 154
void new_title(char *txt);
// new_volume
// file x11/motv.c line 612
static void new_volume(void);
// ng_aconv_register
// file libng/grab-ng.c line 409
signed int ng_aconv_register(signed int magic, char *plugname, struct ng_audio_conv *list, signed int count);
// ng_attr_byid
// file ./libng/grab-ng.h line 257
struct ng_attribute * ng_attr_byid(struct ng_attribute *attrs, signed int id);
// ng_attr_byname
// file ./libng/grab-ng.h line 258
struct ng_attribute * ng_attr_byname(struct ng_attribute *attrs, char *name);
// ng_attr_getint
// file ./libng/grab-ng.h line 260
signed int ng_attr_getint(struct ng_attribute *attr, char *value);
// ng_attr_getstr
// file ./libng/grab-ng.h line 259
const char * ng_attr_getstr(struct ng_attribute *attr, signed int value);
// ng_attr_int2percent
// file ./libng/grab-ng.h line 262
signed int ng_attr_int2percent(struct ng_attribute *attr, signed int value);
// ng_attr_listchoices
// file ./libng/grab-ng.h line 261
void ng_attr_listchoices(struct ng_attribute *attr);
// ng_attr_parse_int
// file ./libng/grab-ng.h line 264
signed int ng_attr_parse_int(struct ng_attribute *attr, char *str);
// ng_attr_percent2int
// file libng/grab-ng.c line 297
signed int ng_attr_percent2int(struct ng_attribute *attr, signed int percent);
// ng_check_clipping
// file libng/grab-ng.c line 847
void ng_check_clipping(signed int width, signed int height, signed int xadjust, signed int yadjust, struct OVERLAY_CLIP *oc, signed int *count);
// ng_check_magic
// file libng/grab-ng.c line 381
static signed int ng_check_magic(signed int magic, char *plugname, char *type);
// ng_color_packed_init
// file libng/grab-ng.h line 479
void ng_color_packed_init(void);
// ng_color_yuv2rgb_init
// file libng/grab-ng.h line 480
void ng_color_yuv2rgb_init(void);
// ng_conv_find_from
// file libng/grab-ng.c line 504
struct ng_video_conv * ng_conv_find_from(unsigned int in, signed int *i);
// ng_conv_find_match
// file libng/grab-ng.c line 531
struct ng_video_conv * ng_conv_find_match(unsigned int in, unsigned int out);
// ng_conv_find_to
// file ./libng/grab-ng.h line 445
struct ng_video_conv * ng_conv_find_to(unsigned int out, signed int *i);
// ng_conv_nop_fini
// file libng/color_common.c line 56
void ng_conv_nop_fini(void *handle);
// ng_conv_nop_init
// file libng/color_common.c line 49
void * ng_conv_nop_init(struct ng_video_fmt *out, void *priv);
// ng_conv_register
// file libng/grab-ng.c line 396
signed int ng_conv_register(signed int magic, char *plugname, struct ng_video_conv *list, signed int count);
// ng_convert_alloc
// file ./libng/grab-ng.h line 373
struct ng_convert_handle * ng_convert_alloc(struct ng_video_conv *conv, struct ng_video_fmt *i, struct ng_video_fmt *o);
// ng_convert_copyframe
// file libng/convert.c line 69
static void ng_convert_copyframe(struct ng_video_buf *dest, struct ng_video_buf *src);
// ng_convert_fini
// file ./libng/grab-ng.h line 380
void ng_convert_fini(struct ng_convert_handle *h);
// ng_convert_frame
// file ./libng/grab-ng.h line 377
struct ng_video_buf * ng_convert_frame(struct ng_convert_handle *h, struct ng_video_buf *dest, struct ng_video_buf *buf);
// ng_convert_init
// file ./libng/grab-ng.h line 376
void ng_convert_init(struct ng_convert_handle *h);
// ng_convert_single
// file ./libng/grab-ng.h line 381
struct ng_video_buf * ng_convert_single(struct ng_convert_handle *h, struct ng_video_buf *in);
// ng_convert_thread
// file common/capture.c line 132
void * ng_convert_thread(void *arg);
// ng_device_init
// file libng/devices.h line 14
void ng_device_init(void);
// ng_dsp_driver_register
// file libng/grab-ng.c line 458
signed int ng_dsp_driver_register(signed int magic, char *plugname, struct ng_dsp_driver *driver);
// ng_dsp_open
// file ./libng/grab-ng.h line 452
struct ng_dsp_driver * ng_dsp_open(char *device, struct ng_audio_fmt *fmt, signed int record, void **handle);
// ng_filter_register
// file libng/grab-ng.c line 422
signed int ng_filter_register(signed int magic, char *plugname, struct ng_filter *filter);
// ng_filter_single
// file ./libng/grab-ng.h line 461
struct ng_video_buf * ng_filter_single(struct ng_filter *filter, struct ng_video_buf *in);
// ng_find_reader
// file libng/grab-ng.c line 763
struct ng_reader * ng_find_reader(char *filename);
// ng_free_video_buf
// file libng/grab-ng.c line 154
static void ng_free_video_buf(struct ng_video_buf *buf);
// ng_get_timestamp
// file ./libng/grab-ng.h line 458
signed long int ng_get_timestamp(void);
// ng_grabber_findconv
// file common/capture.c line 199
struct ng_video_conv * ng_grabber_findconv(struct ng_video_fmt *fmt, signed int fix_ratio);
// ng_grabber_get_image
// file ./common/capture.h line 24
struct ng_video_buf * ng_grabber_get_image(struct ng_video_fmt *fmt);
// ng_grabber_grab_image
// file ./common/capture.h line 23
struct ng_video_buf * ng_grabber_grab_image(signed int single);
// ng_grabber_setformat
// file ./common/capture.h line 20
signed int ng_grabber_setformat(struct ng_video_fmt *fmt, signed int fix_ratio);
// ng_init
// file ./libng/grab-ng.h line 466
void ng_init(void);
// ng_init_video_buf
// file libng/grab-ng.c line 122
void ng_init_video_buf(struct ng_video_buf *buf);
// ng_lut_init
// file ./libng/grab-ng.h line 467
void ng_lut_init(unsigned long int red_mask, unsigned long int green_mask, unsigned long int blue_mask, unsigned int fmtid, signed int swap);
// ng_malloc_audio_buf
// file libng/grab-ng.c line 184
struct ng_audio_buf * ng_malloc_audio_buf(struct ng_audio_fmt *fmt, signed int size);
// ng_malloc_video_buf
// file ./libng/grab-ng.h line 163
struct ng_video_buf * ng_malloc_video_buf(struct ng_video_fmt *fmt, signed int size);
// ng_mix_driver_register
// file libng/grab-ng.c line 467
signed int ng_mix_driver_register(signed int magic, char *plugname, struct ng_mix_driver *driver);
// ng_mix_init
// file ./libng/grab-ng.h line 454
struct ng_attribute * ng_mix_init(char *device, char *channel);
// ng_packed_frame
// file libng/color_common.c line 22
void ng_packed_frame(void *handle, struct ng_video_buf *out, struct ng_video_buf *in);

//

// ng_packed_init
// file libng/color_common.c line 16
void * ng_packed_init(struct ng_video_fmt *out, void *priv);
// ng_plugins
// file libng/grab-ng.c line 940
static signed int ng_plugins(char *dirname);
// ng_plugins::1::initcall_object
//
void initcall_object(void);
// ng_ratio_fixup
// file ./libng/grab-ng.h line 268
void ng_ratio_fixup(signed int *width, signed int *height, signed int *xoff, signed int *yoff);
// ng_ratio_fixup2
// file libng/grab-ng.c line 349
void ng_ratio_fixup2(signed int *width, signed int *height, signed int *xoff, signed int *yoff, signed int ratio_x, signed int ratio_y, signed int up);
// ng_reader_register
// file libng/grab-ng.c line 440
signed int ng_reader_register(signed int magic, char *plugname, struct ng_reader *reader);
// ng_release_video_buf
// file ./libng/grab-ng.h line 162
void ng_release_video_buf(struct ng_video_buf *buf);
// ng_rgb24_to_lut2
// file libng/color_lut.c line 30
void ng_rgb24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// ng_rgb24_to_lut4
// file libng/color_lut.c line 96
void ng_rgb24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// ng_tofday_to_timestamp
// file libng/grab-ng.c line 793
signed long int ng_tofday_to_timestamp(struct timeval *tv);
// ng_vid_driver_register
// file libng/grab-ng.c line 449
signed int ng_vid_driver_register(signed int magic, char *plugname, struct ng_vid_driver *driver);
// ng_vid_open
// file ./libng/grab-ng.h line 449
struct ng_vid_driver * ng_vid_open(char **device, char *driver, struct ng_video_fmt *screen, void *base, void **handle);
// ng_vid_open_auto
// file libng/grab-ng.c line 547
static void * ng_vid_open_auto(struct ng_vid_driver *drv, char *devpath, signed int allow_grabber);
// ng_waiton_video_buf
// file libng/grab-ng.c line 146
void ng_waiton_video_buf(struct ng_video_buf *buf);
// ng_wakeup_video_buf
// file libng/grab-ng.c line 141
void ng_wakeup_video_buf(struct ng_video_buf *buf);
// ng_writefile_init
// file libng/grab-ng.h line 481
void ng_writefile_init(void);
// ng_writer_register
// file libng/grab-ng.c line 431
signed int ng_writer_register(signed int magic, char *plugname, struct ng_writer *writer);
// ng_yuv420p_to_lut2
// file libng/grab-ng.h line 489
void ng_yuv420p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// ng_yuv420p_to_lut4
// file libng/grab-ng.h line 491
void ng_yuv420p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// ng_yuv422_to_lut2
// file libng/grab-ng.h line 487
void ng_yuv422_to_lut2(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// ng_yuv422_to_lut4
// file libng/grab-ng.h line 488
void ng_yuv422_to_lut4(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// ng_yuv422p_to_lut2
// file libng/grab-ng.h line 493
void ng_yuv422p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// ng_yuv422p_to_lut4
// file libng/grab-ng.h line 495
void ng_yuv422p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// nice
// file /usr/include/unistd.h line 598
extern signed int nice(signed int);
// odd
// file common/vbi-sim.c line 194
static inline signed int odd(signed int c);

//

// ontop_ac
// file x11/motv.c line 311
static void ontop_ac(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// ontop_cb
// file x11/motv.c line 301
static void ontop_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);

//

// oss_levels
// file ./common/sound.h line 4
void oss_levels(struct ng_audio_buf *buf, signed int *left, signed int *right);
// parse_action
// file common/event.c line 21
static void parse_action(struct event_entry *entry);
// parse_config
// file ./common/channel.h line 77
void parse_config(signed int parse_channels);
// patch_up
// file libng/writefile.c line 36
signed int patch_up(char *name);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// pixit
// file x11/motv.c line 1676
static void pixit(void);
// popdown_onscreen
// file x11/xt.c line 547
static void popdown_onscreen(void *client_data, unsigned long int *id);
// popen
// file /usr/include/stdio.h line 872
extern struct _IO_FILE * popen(const char *, const char *);
// popup_eh
// file x11/motv.c line 382
static void popup_eh(struct _WidgetRec *widget, void *clientdata, union _XEvent *event, char *cont);
// popupdown_cb
// file x11/motv.c line 391
static void popupdown_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// pref_done_cb
// file x11/motv.c line 2486
static void pref_done_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// pref_fs
// file x11/motv.c line 2345
static void pref_fs(void);
// pref_fst_cb
// file x11/motv.c line 2402
static void pref_fst_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// pref_manage_cb
// file x11/motv.c line 2533
static void pref_manage_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// pref_menu
// file x11/motv.c line 2333
static void pref_menu(struct _WidgetRec *option, struct _WidgetRec *menu, signed int enable);
// pref_mix1
// file x11/motv.c line 2449
static void pref_mix1(void);
// pref_mix1_cb
// file x11/motv.c line 2479
static void pref_mix1_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// pref_mix2
// file x11/motv.c line 2409
static void pref_mix2(void);
// pref_mix2_cb
// file x11/motv.c line 2443
static void pref_mix2_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// print_choices
// file common/commands.c line 753
static void print_choices(char *name, char *value, struct STRTAB *tab);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_72 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_72 *, const union anonymous_121 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_72 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_72 *, union anonymous_70 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_70 *, const union anonymous_121 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_70 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous_70 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_70 *);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_setcanceltype
// file /usr/include/pthread.h line 512
extern signed int pthread_setcanceltype(signed int, signed int *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// raw_audio
// file libng/writefile.c line 519
static signed int raw_audio(void *handle, struct ng_audio_buf *buf);
// raw_close
// file libng/writefile.c line 529
static signed int raw_close(void *handle);
// raw_open
// file libng/writefile.c line 408
static void * raw_open(char *videoname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio);
// raw_video
// file libng/writefile.c line 497
static signed int raw_video(void *handle, struct ng_video_buf *buf);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_config
// file ./common/channel.h line 76
void read_config(char *conffile, signed int *argc, char **argv);
// read_sim
// file common/vbi-sim.c line 301
static void read_sim(unsigned char *raw_data, struct anonymous_98 *sliced_data, signed int *lines, double *timestamp);
// readbuf
// file common/alsa_stream.c line 434
static signed long int readbuf(struct _snd_pcm *handle, char *buf, signed long int len);
// readdir
// file /usr/include/dirent.h line 165
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realpath
// file /usr/include/stdlib.h line 733
extern char * realpath(const char *, char *);
// rec_status_object
//
void rec_status_object(char *);
// rec_work
// file x11/xt.h line 146
char rec_work(void *client_data);
// record_audio_thread
// file common/capture.c line 371
static void * record_audio_thread(void *arg);
// redblue_swap
// file libng/color_packed.c line 25
static void redblue_swap(unsigned char *dest, unsigned char *src, signed int p);
// refresh_timer
// file x11/x11.c line 462
static void refresh_timer(void *clientData, unsigned long int *id);
// resize_event
// file x11/motv.c line 319
static void resize_event(struct _WidgetRec *widget, void *client_data, union _XEvent *event, char *d);
// rgb15_be_gray
// file libng/color_packed.c line 137
static void rgb15_be_gray(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb15_native_gray
// file libng/color_packed.c line 119
static void rgb15_native_gray(unsigned char * restrict dest, unsigned char *s, signed int p);
// rgb32_to_bgr24
// file libng/color_packed.c line 85
static void rgb32_to_bgr24(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb32_to_lut2
// file libng/color_lut.c line 56
static void rgb32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb32_to_lut4
// file libng/color_lut.c line 122
static void rgb32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb32_to_rgb24
// file libng/color_packed.c line 70
static void rgb32_to_rgb24(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// round
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 309
extern double round(double);
// save_config
// file ./common/channel.h line 78
void save_config(void);
// scale_rgb_buffer
// file x11/motv.c line 2661
static struct ng_video_buf * scale_rgb_buffer(struct ng_video_buf *in, signed int scale);
// scan_timeout
// file x11/xt.c line 486
static void scan_timeout(void *client_data, unsigned long int *id);
// scandir
// file /usr/include/dirent.h line 262
extern signed int scandir(const char *, struct dirent *** restrict , signed int (*)(struct dirent *), signed int (*)(struct dirent **, struct dirent **));
// scroll_cb
// file x11/motv.c line 978
static void scroll_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// segfault
// file x11/xt.c line 757
static void segfault(signed int signal);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_115 *, struct anonymous_115 *, struct anonymous_115 *, struct timeval *);
// send_xscreensaver_command
// file jwz/remote.c line 135
static signed int send_xscreensaver_command(struct _XDisplay *dpy, unsigned long int command, signed long int arg, unsigned long int *window_ret, char **error_ret);
// server_xscreensaver_version
// file jwz/remote.c line 492
extern void server_xscreensaver_version(struct _XDisplay *dpy, char **version_ret, char **user_ret, char **host_ret);
// set_attr
// file common/commands.c line 331
static void set_attr(struct ng_attribute *attr, signed int val);
// set_capture
// file common/commands.c line 304
static void set_capture(signed int capture, signed int tmp_switch);
// set_capture_hook_object
//
void set_capture_hook_object(signed int, signed int, signed int);
// set_defaults
// file ./common/commands.h line 72
void set_defaults(void);
// set_freqtab
// file common/commands.c line 364
static void set_freqtab(signed int j);
// set_msg_bool
// file common/commands.c line 418
static void set_msg_bool(const char *name, signed int val);
// set_msg_int
// file common/commands.c line 406
static void set_msg_int(struct ng_attribute *attr, signed int val);
// set_msg_str
// file common/commands.c line 429
static void set_msg_str(const char *name, const char *val);
// set_mute
// file common/commands.c line 351
static void set_mute(signed int val);
// set_property
// file x11/xt.h line 173
void set_property(signed int freq, char *channel, char *name);
// set_title
// file common/commands.c line 381
static void set_title(void);
// set_vidmode
// file x11/xt.c line 826
static void set_vidmode(struct anonymous_15 *mode);
// set_volume
// file common/commands.c line 342
static void set_volume(signed int val);
// setchannel_handler
// file common/commands.c line 667
static signed int setchannel_handler(char *name, signed int argc, char **argv);
// setfreqtab_handler
// file common/commands.c line 763
static signed int setfreqtab_handler(char *name, signed int argc, char **argv);
// setfreqtab_notify_object
//
void setfreqtab_notify_object(void);
// setparams
// file common/alsa_stream.c line 249
static signed int setparams(struct _snd_pcm *phandle, struct _snd_pcm *chandle, enum _snd_pcm_format format, signed int latency, signed int allow_resample, struct final_params *negotiated);
// setparams_periods
// file common/alsa_stream.c line 150
static signed int setparams_periods(struct _snd_pcm *handle, struct _snd_pcm_hw_params *params, unsigned int *usecs, unsigned int *count, const char *id);
// setparams_set
// file common/alsa_stream.c line 179
static signed int setparams_set(struct _snd_pcm *handle, struct _snd_pcm_hw_params *params, struct _snd_pcm_sw_params *swparams, unsigned long int start_treshold, const char *id);
// setparams_stream
// file common/alsa_stream.c line 62
static signed int setparams_stream(struct _snd_pcm *handle, struct _snd_pcm_hw_params *params, enum _snd_pcm_format format, signed int *channels, const char *id);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setstation_handler
// file common/commands.c line 567
static signed int setstation_handler(char *name, signed int argc, char **argv);
// setstation_notify_object
//
void setstation_notify_object(void);
// shape
// file common/vbi-sim.c line 10
static inline double shape(double ph);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// show_handler
// file common/commands.c line 909
static signed int show_handler(char *name, signed int argc, char **argv);
// showtime_handler
// file common/commands.c line 1174
static signed int showtime_handler(char *name, signed int argc, char **argv);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_16 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
extern double sin(double);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snap_filename
// file ./libng/writefile.h line 2
char * snap_filename(char *base, char *channel, char *ext);
// snap_handler
// file common/commands.c line 1006
static signed int snap_handler(char *hname, signed int argc, char **argv);
// snd_output_stdio_attach
// file /usr/include/alsa/output.h line 65
signed int snd_output_stdio_attach(struct _snd_output **, struct _IO_FILE *, signed int);
// snd_pcm_close
// file /usr/include/alsa/pcm.h line 479
signed int snd_pcm_close(struct _snd_pcm *);
// snd_pcm_drop
// file /usr/include/alsa/pcm.h line 501
signed int snd_pcm_drop(struct _snd_pcm *);
// snd_pcm_dump_setup
// file /usr/include/alsa/pcm.h line 1065
signed int snd_pcm_dump_setup(struct _snd_pcm *, struct _snd_output *);
// snd_pcm_format_name
// file /usr/include/alsa/pcm.h line 1045
const char * snd_pcm_format_name(const enum _snd_pcm_format);
// snd_pcm_format_width
// file /usr/include/alsa/pcm.h line 1107
signed int snd_pcm_format_width(enum _snd_pcm_format);
// snd_pcm_hw_free
// file /usr/include/alsa/pcm.h line 494
signed int snd_pcm_hw_free(struct _snd_pcm *);
// snd_pcm_hw_params
// file /usr/include/alsa/pcm.h line 493
signed int snd_pcm_hw_params(struct _snd_pcm *, struct _snd_pcm_hw_params *);
// snd_pcm_hw_params_any
// file /usr/include/alsa/pcm.h line 677
signed int snd_pcm_hw_params_any(struct _snd_pcm *, struct _snd_pcm_hw_params *);
// snd_pcm_hw_params_get_buffer_size
// file /usr/include/alsa/pcm.h line 841
signed int snd_pcm_hw_params_get_buffer_size(const struct _snd_pcm_hw_params *, unsigned long int *);
// snd_pcm_hw_params_get_period_size
// file /usr/include/alsa/pcm.h line 803
signed int snd_pcm_hw_params_get_period_size(const struct _snd_pcm_hw_params *, unsigned long int *, signed int *);
// snd_pcm_hw_params_get_period_time_max
// file /usr/include/alsa/pcm.h line 793
signed int snd_pcm_hw_params_get_period_time_max(const struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_get_period_time_min
// file /usr/include/alsa/pcm.h line 792
signed int snd_pcm_hw_params_get_period_time_min(const struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_get_periods_max
// file /usr/include/alsa/pcm.h line 818
signed int snd_pcm_hw_params_get_periods_max(const struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_get_periods_min
// file /usr/include/alsa/pcm.h line 817
signed int snd_pcm_hw_params_get_periods_min(const struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_get_rate_max
// file /usr/include/alsa/pcm.h line 775
signed int snd_pcm_hw_params_get_rate_max(const struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_get_rate_min
// file /usr/include/alsa/pcm.h line 774
signed int snd_pcm_hw_params_get_rate_min(const struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_set_access
// file /usr/include/alsa/pcm.h line 739
signed int snd_pcm_hw_params_set_access(struct _snd_pcm *, struct _snd_pcm_hw_params *, enum _snd_pcm_access);
// snd_pcm_hw_params_set_channels
// file /usr/include/alsa/pcm.h line 765
signed int snd_pcm_hw_params_set_channels(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int);
// snd_pcm_hw_params_set_format
// file /usr/include/alsa/pcm.h line 747
signed int snd_pcm_hw_params_set_format(struct _snd_pcm *, struct _snd_pcm_hw_params *, enum _snd_pcm_format);
// snd_pcm_hw_params_set_period_time_near
// file /usr/include/alsa/pcm.h line 799
signed int snd_pcm_hw_params_set_period_time_near(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_set_periods_near
// file /usr/include/alsa/pcm.h line 824
signed int snd_pcm_hw_params_set_periods_near(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_set_rate_near
// file /usr/include/alsa/pcm.h line 781
signed int snd_pcm_hw_params_set_rate_near(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_set_rate_resample
// file /usr/include/alsa/pcm.h line 784
signed int snd_pcm_hw_params_set_rate_resample(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int);
// snd_pcm_hw_params_sizeof
// file /usr/include/alsa/pcm.h line 725
unsigned long int snd_pcm_hw_params_sizeof(void);
// snd_pcm_open
// file /usr/include/alsa/pcm.h line 470
signed int snd_pcm_open(struct _snd_pcm **, const char *, enum _snd_pcm_stream, signed int);
// snd_pcm_prepare
// file /usr/include/alsa/pcm.h line 497
signed int snd_pcm_prepare(struct _snd_pcm *);
// snd_pcm_readi
// file /usr/include/alsa/pcm.h line 517
signed long int snd_pcm_readi(struct _snd_pcm *, void *, unsigned long int);
// snd_pcm_recover
// file /usr/include/alsa/pcm.h line 622
signed int snd_pcm_recover(struct _snd_pcm *, signed int, signed int);
// snd_pcm_sw_params
// file /usr/include/alsa/pcm.h line 496
signed int snd_pcm_sw_params(struct _snd_pcm *, struct _snd_pcm_sw_params *);
// snd_pcm_sw_params_current
// file /usr/include/alsa/pcm.h line 495
signed int snd_pcm_sw_params_current(struct _snd_pcm *, struct _snd_pcm_sw_params *);
// snd_pcm_sw_params_set_avail_min
// file /usr/include/alsa/pcm.h line 883
signed int snd_pcm_sw_params_set_avail_min(struct _snd_pcm *, struct _snd_pcm_sw_params *, unsigned long int);
// snd_pcm_sw_params_set_start_threshold
// file /usr/include/alsa/pcm.h line 887
signed int snd_pcm_sw_params_set_start_threshold(struct _snd_pcm *, struct _snd_pcm_sw_params *, unsigned long int);
// snd_pcm_sw_params_sizeof
// file /usr/include/alsa/pcm.h line 866
unsigned long int snd_pcm_sw_params_sizeof(void);
// snd_pcm_unlink
// file /usr/include/alsa/pcm.h line 523
signed int snd_pcm_unlink(struct _snd_pcm *);
// snd_pcm_wait
// file /usr/include/alsa/pcm.h line 520
signed int snd_pcm_wait(struct _snd_pcm *, signed int);
// snd_pcm_writei
// file /usr/include/alsa/pcm.h line 516
signed long int snd_pcm_writei(struct _snd_pcm *, const void *, unsigned long int);
// snd_seq_client_id
// file /usr/include/alsa/seq.h line 87
signed int snd_seq_client_id(struct _snd_seq *);
// snd_seq_close
// file /usr/include/alsa/seq.h line 82
signed int snd_seq_close(struct _snd_seq *);
// snd_seq_create_simple_port
// file /usr/include/alsa/seqmid.h line 328
signed int snd_seq_create_simple_port(struct _snd_seq *, const char *, unsigned int, unsigned int);
// snd_seq_event_input
// file /usr/include/alsa/seq.h line 522
signed int snd_seq_event_input(struct _snd_seq *, struct snd_seq_event **);
// snd_seq_free_event
// file /usr/include/alsa/seq.h line 517
signed int snd_seq_free_event(struct snd_seq_event *);
// snd_seq_open
// file /usr/include/alsa/seq.h line 78
signed int snd_seq_open(struct _snd_seq **, const char *, signed int, signed int);
// snd_seq_poll_descriptors
// file /usr/include/alsa/seq.h line 84
signed int snd_seq_poll_descriptors(struct _snd_seq *, struct pollfd *, unsigned int, signed short int);
// snd_seq_port_subscribe_free
// file /usr/include/alsa/seq.h line 324
void snd_seq_port_subscribe_free(struct _snd_seq_port_subscribe *);
// snd_seq_port_subscribe_malloc
// file /usr/include/alsa/seq.h line 323
signed int snd_seq_port_subscribe_malloc(struct _snd_seq_port_subscribe **);
// snd_seq_port_subscribe_set_dest
// file /usr/include/alsa/seq.h line 335
void snd_seq_port_subscribe_set_dest(struct _snd_seq_port_subscribe *, const struct snd_seq_addr *);
// snd_seq_port_subscribe_set_sender
// file /usr/include/alsa/seq.h line 334
void snd_seq_port_subscribe_set_sender(struct _snd_seq_port_subscribe *, const struct snd_seq_addr *);
// snd_seq_set_client_name
// file /usr/include/alsa/seqmid.h line 344
signed int snd_seq_set_client_name(struct _snd_seq *, const char *);
// snd_seq_subscribe_port
// file /usr/include/alsa/seq.h line 342
signed int snd_seq_subscribe_port(struct _snd_seq *, struct _snd_seq_port_subscribe *);
// snd_strerror
// file /usr/include/alsa/error.h line 45
const char * snd_strerror(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sort_media_device_entry
// file common/get_media_devices.c line 299
static signed int sort_media_device_entry(const void *a, const void *b);
// sort_media_device_entry_link1
// file common/get_media_devices.c line 299
static signed int sort_media_device_entry_link1(const void *a_link1, const void *b_link1);
// split_cmdline
// file ./common/commands.h line 79
char ** split_cmdline(char *line, signed int *count);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// stderr_close_cb
// file x11/motv.c line 3223
static void stderr_close_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// stderr_init
// file x11/motv.c line 3232
static void stderr_init(void);
// stderr_input
// file x11/motv.c line 3188
static void stderr_input(void *clientdata, signed int *src, unsigned long int *id);
// stderr_ok_cb
// file x11/motv.c line 3213
static void stderr_ok_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// str_to_int
// file common/channel.c line 739
signed int str_to_int(char *str, struct STRTAB *tab);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcasestr
// file /usr/include/string.h line 372
extern char * strcasestr(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strfamily
// file common/commands.c line 1198
static char * strfamily(signed int family);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strsignal
// file /usr/include/string.h line 563
extern char * strsignal(signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// sync
// file /usr/include/unistd.h line 972
extern void sync(void);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// tcp_connect
// file common/commands.c line 1209
static signed int tcp_connect(struct addrinfo *ai, char *host, char *serv);
// tcp_readbuf
// file common/commands.c line 1256
static signed int tcp_readbuf(signed int sock, signed int timeout, char *dest, char dlen);
// termsig
// file x11/xt.c line 749
static void termsig(signed int signal);
// termsig_handler
// file x11/xt.c line 743
static void termsig_handler(void *data, unsigned long int *id);
// tilde_expand
// file x11/complete.h line 1
char * tilde_expand(char *file);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// title_timeout
// file x11/xt.c line 1138
static void title_timeout(void *client_data, unsigned long int *id);
// toolkit_set_label
// file x11/motv.c line 215
void toolkit_set_label(struct _WidgetRec *widget, char *str);
// ttx_next
// file common/vbi-sim.c line 209
static unsigned char * ttx_next(void);
// ttx_sim
// file common/vbi-sim.c line 147
static inline double ttx_sim(double t, double F, const unsigned char *text);
// tv_expose_event
// file x11/xt.h line 157
void tv_expose_event(struct _WidgetRec *widget, void *client_data, union _XEvent *event, char *d);
// uname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 81
extern signed int uname(struct utsname *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// update_int
// file common/commands.c line 441
static signed int update_int(struct ng_attribute *attr, signed int old, char *new);
// update_movie_menus
// file x11/motv.c line 1933
static void update_movie_menus(void);
// update_title_object
//
void update_title_object(char *);
// usage
// file x11/xt.c line 1676
static void usage(void);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// v4lconf_init
// file x11/xt.h line 189
void v4lconf_init(void);
// vbi_calc_page
// file common/vbi-data.c line 220
signed int vbi_calc_page(signed int pagenr, signed int offset);
// vbi_calc_subpage
// file common/vbi-data.c line 244
signed int vbi_calc_subpage(struct vbi_decoder *dec, signed int pgno, signed int subno, signed int offset);
// vbi_capture_delete
// file /usr/include/libzvbi.h line 1655
extern void vbi_capture_delete(struct vbi_capture *);
// vbi_capture_fd
// file /usr/include/libzvbi.h line 1648
extern signed int vbi_capture_fd(struct vbi_capture *);
// vbi_capture_parameters
// file /usr/include/libzvbi.h line 1647
extern struct vbi_raw_decoder * vbi_capture_parameters(struct vbi_capture *);
// vbi_capture_read
// file /usr/include/libzvbi.h line 1638
extern signed int vbi_capture_read(struct vbi_capture *, void *, struct anonymous_98 *, signed int *, double *, struct timeval *);
// vbi_capture_v4l2_new
// file /usr/include/libzvbi.h line 1582
extern struct vbi_capture * vbi_capture_v4l2_new(const char *, signed int, unsigned int *, signed int, char **, signed int);
// vbi_capture_v4l_new
// file /usr/include/libzvbi.h line 1592
extern struct vbi_capture * vbi_capture_v4l_new(const char *, signed int, unsigned int *, signed int, char **, signed int);
// vbi_close
// file ./common/vbi-data.h line 35
void vbi_close(struct vbi_state *vbi);
// vbi_decode
// file /usr/include/libzvbi.h line 2145
extern void vbi_decode(struct vbi_decoder *, struct anonymous_98 *, signed int, double);
// vbi_decoder_delete
// file /usr/include/libzvbi.h line 2144
extern void vbi_decoder_delete(struct vbi_decoder *);
// vbi_decoder_new
// file /usr/include/libzvbi.h line 2143
extern struct vbi_decoder * vbi_decoder_new(void);
// vbi_dump_event
// file common/vbi-data.c line 154
void vbi_dump_event(struct vbi_event *ev, void *user);
// vbi_event_handler_add
// file /usr/include/libzvbi.h line 742
extern signed int vbi_event_handler_add(struct vbi_decoder *, signed int, void (*)(struct vbi_event *, void *), void *);
// vbi_event_handler_remove
// file /usr/include/libzvbi.h line 745
extern void vbi_event_handler_remove(struct vbi_decoder *, void (*)(struct vbi_event *, void *));
// vbi_export_pixmap
// file x11/vbi-x11.h line 55
unsigned long int vbi_export_pixmap(struct vbi_window *vw, struct vbi_page *pg, struct vbi_rect *rect);
// vbi_export_txt
// file common/vbi-data.c line 271
signed int vbi_export_txt(char *dest, char *charset, signed int size, struct vbi_page *pg, struct vbi_rect *rect, enum vbi_txt_colors color);
// vbi_fetch_vt_page
// file /usr/include/libzvbi.h line 2028
extern signed int vbi_fetch_vt_page(struct vbi_decoder *, struct vbi_page *, signed int, signed int, enum anonymous_23, signed int, signed int);
// vbi_find_subtitle
// file ./common/vbi-data.h line 43
void vbi_find_subtitle(struct vbi_page *pg, struct vbi_rect *rect);
// vbi_hasdata
// file ./common/vbi-data.h line 34
signed int vbi_hasdata(struct vbi_state *vbi);
// vbi_is_gfx
// file /usr/include/libzvbi.h line 855
static inline signed int vbi_is_gfx(unsigned int unicode);
// vbi_open
// file ./common/vbi-data.h line 33
struct vbi_state * vbi_open(char *dev, signed int debug, signed int sim);
// vbi_raw_decode
// file /usr/include/libzvbi.h line 1181
extern signed int vbi_raw_decode(struct vbi_raw_decoder *, unsigned char *, struct anonymous_98 *);
// vbi_raw_decoder_add_services
// file /usr/include/libzvbi.h line 1170
extern unsigned int vbi_raw_decoder_add_services(struct vbi_raw_decoder *, unsigned int, signed int);
// vbi_raw_decoder_init
// file /usr/include/libzvbi.h line 1167
extern void vbi_raw_decoder_init(struct vbi_raw_decoder *);
// vbi_render_free_font
// file x11/vbi-x11.c line 77
void vbi_render_free_font(struct _WidgetRec *shell, struct vbi_window *vw);
// vbi_render_init
// file x11/vbi-x11.h line 49
struct vbi_window * vbi_render_init(struct _WidgetRec *shell, struct _WidgetRec *tt, struct vbi_state *vbi);
// vbi_render_line
// file x11/vbi-x11.c line 176
void vbi_render_line(struct vbi_window *vw, unsigned long int d, struct vbi_char *ch, signed int y, signed int top, signed int left, signed int right);
// vbi_render_set_font
// file x11/vbi-x11.c line 95
void vbi_render_set_font(struct _WidgetRec *shell, struct vbi_window *vw, char *label);
// vbi_render_try_font
// file x11/vbi-x11.c line 59
static signed int vbi_render_try_font(struct _WidgetRec *shell, struct vbi_window *vw, struct vbi_font *fnt);
// vbi_teletext_set_default_region
// file /usr/include/libzvbi.h line 2025
extern void vbi_teletext_set_default_region(struct vbi_decoder *, signed int);
// vdr_handler
// file common/commands.c line 1293
static signed int vdr_handler(char *name, signed int argc, char **argv);
// video_close
// file x11/x11.c line 758
void video_close(void);
// video_event
// file x11/x11.c line 576
static void video_event(struct _WidgetRec *widget, void *client_data, union _XEvent *event, char *d);
// video_gd_blitframe
// file x11/x11.c line 152
signed int video_gd_blitframe(struct video_handle *h, struct ng_video_buf *buf);
// video_gd_configure
// file x11/x11.h line 18
void video_gd_configure(signed int width, signed int height);
// video_gd_filter
// file x11/x11.c line 128
static struct ng_video_buf * video_gd_filter(struct video_handle *h, struct ng_video_buf *buf);
// video_gd_idle
// file x11/x11.c line 167
static char video_gd_idle(void *data);
// video_gd_init
// file x11/x11.h line 13
void video_gd_init(struct _WidgetRec *widget, signed int use_gl);
// video_gd_restart
// file x11/x11.h line 17
void video_gd_restart(void);
// video_gd_start
// file x11/x11.h line 14
void video_gd_start(void);
// video_gd_stop
// file x11/x11.h line 15
void video_gd_stop(void);
// video_gd_suspend
// file x11/x11.h line 16
void video_gd_suspend(void);
// video_init
// file x11/x11.h line 23
struct _WidgetRec * video_init(struct _WidgetRec *parent, struct anonymous_1 *vinfo, struct _WidgetClassRec *class, signed int args_bpp, signed int args_gl);
// video_new_size
// file x11/x11.c line 553
void video_new_size(void);
// video_overlay
// file x11/x11.h line 21
void video_overlay(signed int state);
// vidmode_timer
// file x11/xt.c line 820
static void vidmode_timer(void *clientData, unsigned long int *id);
// visual_init
// file x11/xt.h line 186
void visual_init(char *n1, char *n2);
// volume_handler
// file common/commands.c line 796
static signed int volume_handler(char *name, signed int argc, char **argv);
// volume_notify_object
//
void volume_notify_object(void);
// vtx_subtitle_object
//
void vtx_subtitle_object(struct vbi_page *, struct vbi_rect *);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// watch_audio
// file x11/motv.c line 242
static void watch_audio(void *data, unsigned long int *id);
// wav_init_header
// file libng/writefile.c line 233
static void wav_init_header(struct WAVEHDR *fileheader, struct ng_audio_fmt *audio);
// wav_start_write
// file libng/writefile.c line 261
static void wav_start_write(signed int fd, struct WAVEHDR *fileheader, struct ng_audio_fmt *audio);
// wav_stop_write
// file libng/writefile.c line 268
static void wav_stop_write(signed int fd, struct WAVEHDR *fileheader, signed int wav_size);
// webcam_exit
// file common/webcam.c line 118
void webcam_exit(void);
// webcam_handler
// file common/commands.c line 1115
static signed int webcam_handler(char *hname, signed int argc, char **argv);
// webcam_init
// file common/webcam.c line 108
void webcam_init(void);
// webcam_put
// file common/webcam.c line 128
signed int webcam_put(char *filename, struct ng_video_buf *buf);
// webcam_writer
// file common/webcam.c line 30
static void * webcam_writer(void *arg);
// wm_check_capability
// file x11/wmhooks.c line 97
static signed int wm_check_capability(struct _XDisplay *dpy, unsigned long int root, unsigned long int list, unsigned long int wanted);
// wm_detect
// file x11/wmhooks.h line 1
void wm_detect(struct _XDisplay *dpy);
// wm_fullscreen_object
//
void wm_fullscreen_object(struct _XDisplay *, unsigned long int, signed int);
// wm_stay_on_top_object
//
void wm_stay_on_top_object(struct _XDisplay *, unsigned long int, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_jpeg
// file ./libng/writefile.h line 4
signed int write_jpeg(char *filename, struct ng_video_buf *buf, signed int quality, signed int gray);
// write_pgm
// file libng/writefile.c line 161
signed int write_pgm(char *filename, struct ng_video_buf *buf);
// write_ppm
// file ./libng/writefile.h line 6
signed int write_ppm(char *filename, struct ng_video_buf *buf);
// writebuf
// file common/alsa_stream.c line 448
static signed long int writebuf(struct _snd_pcm *handle, char *buf, signed long int len);
// writer_audio_thread
// file common/capture.c line 295
static void * writer_audio_thread(void *arg);
// writer_video_thread
// file common/capture.c line 321
static void * writer_video_thread(void *arg);
// wss525_sim
// file common/vbi-sim.c line 112
static inline double wss525_sim(double t, double F, unsigned int bits);
// wss625_sim
// file common/vbi-sim.c line 66
static inline double wss625_sim(double t, double F, unsigned int bits);
// x11_blit
// file x11/blit.c line 311
void x11_blit(struct _XDisplay *dpy, unsigned long int dr, struct _XGC *gc, struct _XImage *xi, signed int a, signed int b, signed int c, signed int d, signed int w, signed int h);
// x11_capture_pixmap
// file x11/x11.c line 50
unsigned long int x11_capture_pixmap(struct _XDisplay *dpy, struct anonymous_1 *vinfo, unsigned long int colormap, unsigned int width, unsigned int height);
// x11_check_remote
// file x11/xt.h line 185
void x11_check_remote(void);
// x11_create_pixmap
// file x11/blit.h line 10
unsigned long int x11_create_pixmap(struct _XDisplay *dpy, struct anonymous_1 *vinfo, struct ng_video_buf *buf);
// x11_create_ximage
// file x11/blit.c line 229
struct _XImage * x11_create_ximage(struct _XDisplay *dpy, struct anonymous_1 *vinfo, signed int width, signed int height, struct anonymous_2 **shm);
// x11_create_ximage::_tmp::return_value_XSetErrorHandler_1_object
//
signed int return_value_XSetErrorHandler_1_object(struct _XDisplay *, struct anonymous *);
// x11_ctrl_alt_backspace
// file x11/xt.h line 190
signed int x11_ctrl_alt_backspace(struct _XDisplay *dpy);
// x11_destroy_ximage
// file x11/blit.c line 300
void x11_destroy_ximage(struct _XDisplay *dpy, struct _XImage *ximage, struct anonymous_2 *shm);
// x11_error_dev_null
// file x11/x11.c line 93
static signed int x11_error_dev_null(struct _XDisplay *dpy, struct anonymous *event);
// x11_find_visual
// file x11/blit.c line 105
struct anonymous_8 * x11_find_visual(struct _XDisplay *dpy);
// x11_icons_init
// file x11/icons.h line 1
void x11_icons_init(struct _XDisplay *dpy, unsigned long int bg);
// x11_init_visual
// file x11/blit.c line 138
void x11_init_visual(struct _XDisplay *dpy, struct anonymous_1 *vinfo);
// x11_label_pixmap
// file x11/x11.h line 5
void x11_label_pixmap(struct _XDisplay *dpy, unsigned long int colormap, unsigned long int pixmap, signed int height, char *label);
// x11_misc_init
// file x11/xt.h line 177
void x11_misc_init(struct _XDisplay *dpy);
// x11_mute_notify
// file x11/xt.c line 1417
static void x11_mute_notify(signed int val);
// x11_vbi_data
// file x11/xt.c line 1989
static void x11_vbi_data(void *data, signed int *fd, unsigned long int *iproc);
// x11_vbi_event
// file x11/xt.c line 1960
static void x11_vbi_event(struct vbi_event *ev, void *user);
// x11_vbi_start
// file x11/xt.h line 199
signed int x11_vbi_start(char *device);
// x11_vbi_stop
// file x11/xt.h line 201
void x11_vbi_stop(void);
// x11_vbi_tuned
// file x11/xt.h line 200
signed int x11_vbi_tuned(void);
// xfree_dga_error_handler
// file x11/xt.c line 1406
static signed int xfree_dga_error_handler(struct _XDisplay *d, struct anonymous *e);
// xfree_dga_init
// file x11/xt.h line 178
void xfree_dga_init(struct _XDisplay *dpy);
// xfree_randr_init
// file x11/xt.c line 1358
void xfree_randr_init(struct _XDisplay *dpy);
// xfree_vm_init
// file x11/xt.h line 180
void xfree_vm_init(struct _XDisplay *dpy);
// xfree_xinerama_init
// file x11/xt.h line 179
void xfree_xinerama_init(struct _XDisplay *dpy);
// xscreensaver_command
// file ./jwz/remote.h line 16
extern signed int xscreensaver_command(struct _XDisplay *dpy, unsigned long int command, signed long int arg, signed int verbose_p, char **error_ret);
// xscreensaver_command_response
// file jwz/remote.c line 341
static signed int xscreensaver_command_response(struct _XDisplay *dpy, unsigned long int window, signed int verbose_p, signed int exiting_p, char **error_ret);
// xscreensaver_init
// file ./jwz/remote.h line 24
extern void xscreensaver_init(struct _XDisplay *dpy);
// xscreensaver_timefunc
// file x11/xt.c line 793
static void xscreensaver_timefunc(void *clientData, unsigned long int *id);
// xt_handle_pending
// file x11/xt.h line 226
signed int xt_handle_pending(struct _XDisplay *dpy);
// xt_joystick_data
// file x11/xt.c line 2136
static void xt_joystick_data(void *data, signed int *fd, unsigned long int *iproc);
// xt_joystick_init
// file x11/xt.c line 2141
signed int xt_joystick_init(void);
// xt_kbd_init
// file x11/xt.c line 2151
void xt_kbd_init(struct _WidgetRec *tv);
// xt_lirc_data
// file x11/xt.c line 2084
static void xt_lirc_data(void *data, signed int *fd, unsigned long int *iproc);
// xt_lirc_init
// file x11/xt.c line 2095
signed int xt_lirc_init(void);
// xt_main_loop
// file x11/xt.h line 228
signed int xt_main_loop(void);
// xt_midi_data
// file x11/xt.c line 2107
static void xt_midi_data(void *data, signed int *fd, unsigned long int *iproc);
// xt_midi_init
// file x11/xt.c line 2114
signed int xt_midi_init(char *dev);
// xt_siginit
// file x11/xt.h line 152
void xt_siginit(void);
// xt_vm_randr_input_init
// file x11/xt.h line 227
signed int xt_vm_randr_input_init(struct _XDisplay *dpy);
// xv_add_attr
// file x11/xv.c line 172
static void xv_add_attr(struct xv_handle *h, signed int id, signed int type, signed int defval, struct STRTAB *choices, struct anonymous_112 *at);
// xv_attrs
// file x11/xv.c line 321
static struct ng_attribute * xv_attrs(void *handle);
// xv_blit
// file x11/blit.c line 482
void xv_blit(struct _XDisplay *dpy, unsigned long int dr, struct _XGC *gc, struct anonymous_3 *xi, signed int a, signed int b, signed int c, signed int d, signed int x, signed int y, signed int w, signed int h);
// xv_close
// file x11/xv.c line 308
static signed int xv_close(void *handle);
// xv_create_ximage
// file x11/blit.c line 407
struct anonymous_3 * xv_create_ximage(struct _XDisplay *dpy, signed int width, signed int height, signed int format, struct anonymous_2 **shm);
// xv_create_ximage::_tmp::return_value_XSetErrorHandler_1_object
//
signed int return_value_XSetErrorHandler_1_object(struct _XDisplay *, struct anonymous *);
// xv_destroy_ximage
// file x11/blit.c line 471
void xv_destroy_ximage(struct _XDisplay *dpy, struct anonymous_3 *xvimage, struct anonymous_2 *shm);
// xv_flags
// file x11/xv.c line 310
static signed int xv_flags(void *handle);
// xv_getfreq
// file x11/xv.c line 219
static unsigned long int xv_getfreq(void *handle);
// xv_image_init
// file x11/blit.h line 17
void xv_image_init(struct _XDisplay *dpy);
// xv_overlay
// file x11/xv.c line 45
static signed int xv_overlay(void *handle, struct ng_video_fmt *fmt, signed int x, signed int y, struct OVERLAY_CLIP *oc, signed int count, signed int aspect);
// xv_read_attr
// file x11/xv.c line 116
static signed int xv_read_attr(struct ng_attribute *attr);
// xv_setfreq
// file x11/xv.c line 229
static void xv_setfreq(void *handle, unsigned long int freq);
// xv_strlist_add
// file x11/xv.c line 288
static signed int xv_strlist_add(struct STRTAB **tab, char *str);
// xv_tuned
// file x11/xv.c line 238
static signed int xv_tuned(void *handle);
// xv_video
// file x11/xv.h line 5
void xv_video(unsigned long int win, signed int dw, signed int dh, signed int on);
// xv_video_init
// file x11/xv.h line 2
void xv_video_init(unsigned int port, signed int hwscan);
// xv_write_attr
// file x11/xv.c line 139
static void xv_write_attr(struct ng_attribute *attr, signed int value);
// yuv420p_to_rgb24
// file libng/color_yuv2rgb.c line 170
static void yuv420p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// yuv422_to_gray
// file libng/color_yuv2rgb.c line 64
static void yuv422_to_gray(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// yuv422_to_rgb24
// file libng/color_yuv2rgb.c line 78
static void yuv422_to_rgb24(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// yuv422p_to_rgb24
// file libng/color_yuv2rgb.c line 206
static void yuv422p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// yuv42xp_to_gray
// file libng/color_yuv2rgb.c line 149
static void yuv42xp_to_gray(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// zap_timeout
// file x11/xt.c line 436
static void zap_timeout(void *client_data, unsigned long int *id);

struct anonymous_130
{
  // name
  char *name;
  // value
  char *value;
  // pixel
  unsigned long int pixel;
};

struct anonymous_11
{
  // name
  char *name;
  // value
  signed long int value;
};

struct anonymous_131
{
  // name
  char *name;
  // nlines
  unsigned int nlines;
  // lines
  char **lines;
};

struct anonymous_13
{
  // option
  char *option;
  // specifier
  char *specifier;
  // argKind
  enum anonymous_12 argKind;
  // value
  char *value;
};

struct anonymous_116
{
  // res_name
  char *res_name;
  // res_class
  char *res_class;
};

struct anonymous_132
{
  // string
  char *string;
  // symbolic
  char *symbolic;
  // m_color
  char *m_color;
  // g4_color
  char *g4_color;
  // g_color
  char *g_color;
  // c_color
  char *c_color;
};

struct anonymous_1
{
  // visual
  struct anonymous_8 *visual;
  // visualid
  unsigned long int visualid;
  // screen
  signed int screen;
  // depth
  signed int depth;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
};

struct anonymous_0
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous_109 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous_8 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous_10
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous_134 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous_0 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous_134
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous_120
{
  // lbearing
  signed short int lbearing;
  // rbearing
  signed short int rbearing;
  // width
  signed short int width;
  // ascent
  signed short int ascent;
  // descent
  signed short int descent;
  // attributes
  unsigned short int attributes;
};

struct anonymous_14
{
  // ext_data
  struct _XExtData *ext_data;
  // fid
  unsigned long int fid;
  // direction
  unsigned int direction;
  // min_char_or_byte2
  unsigned int min_char_or_byte2;
  // max_char_or_byte2
  unsigned int max_char_or_byte2;
  // min_byte1
  unsigned int min_byte1;
  // max_byte1
  unsigned int max_byte1;
  // all_chars_exist
  signed int all_chars_exist;
  // default_char
  unsigned int default_char;
  // n_properties
  signed int n_properties;
  // properties
  struct anonymous_119 *properties;
  // min_bounds
  struct anonymous_120 min_bounds;
  // max_bounds
  struct anonymous_120 max_bounds;
  // per_char
  struct anonymous_120 *per_char;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct anonymous_8
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous_106
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_104
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_115
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_122
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_16
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_126
{
  // bits
  unsigned char bits[17l];
  // huffval
  unsigned char huffval[256l];
  // sent_table
  signed int sent_table;
};

struct anonymous_125
{
  // quantval
  unsigned short int quantval[64l];
  // sent_table
  signed int sent_table;
};

struct anonymous_71
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_124
{
  // component_id
  signed int component_id;
  // component_index
  signed int component_index;
  // h_samp_factor
  signed int h_samp_factor;
  // v_samp_factor
  signed int v_samp_factor;
  // quant_tbl_no
  signed int quant_tbl_no;
  // dc_tbl_no
  signed int dc_tbl_no;
  // ac_tbl_no
  signed int ac_tbl_no;
  // width_in_blocks
  unsigned int width_in_blocks;
  // height_in_blocks
  unsigned int height_in_blocks;
  // DCT_scaled_size
  signed int DCT_scaled_size;
  // downsampled_width
  unsigned int downsampled_width;
  // downsampled_height
  unsigned int downsampled_height;
  // component_needed
  signed int component_needed;
  // MCU_width
  signed int MCU_width;
  // MCU_height
  signed int MCU_height;
  // MCU_blocks
  signed int MCU_blocks;
  // MCU_sample_width
  signed int MCU_sample_width;
  // last_col_width
  signed int last_col_width;
  // last_row_height
  signed int last_row_height;
  // quant_table
  struct anonymous_125 *quant_table;
  // dct_table
  void *dct_table;
};

struct anonymous_127
{
  // comps_in_scan
  signed int comps_in_scan;
  // component_index
  signed int component_index[4l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
};

struct anonymous_7
{
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous_109
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous_8 *visuals;
};

struct anonymous_85
{
  // first_line
  signed int first_line;
  // last_line
  signed int last_line;
  // ratio
  double ratio;
  // film_mode
  signed int film_mode;
  // open_subtitles
  enum anonymous_84 open_subtitles;
};

struct anonymous_112
{
  // flags
  signed int flags;
  // min_value
  signed int min_value;
  // max_value
  signed int max_value;
  // name
  char *name;
};

struct anonymous_9
{
  // fmt
  signed int fmt;
  // type
  signed int type;
  // ext
  char *ext;
};

struct anonymous_75
{
  // function
  signed int function;
  // plane_mask
  unsigned long int plane_mask;
  // foreground
  unsigned long int foreground;
  // background
  unsigned long int background;
  // line_width
  signed int line_width;
  // line_style
  signed int line_style;
  // cap_style
  signed int cap_style;
  // join_style
  signed int join_style;
  // fill_style
  signed int fill_style;
  // fill_rule
  signed int fill_rule;
  // arc_mode
  signed int arc_mode;
  // tile
  unsigned long int tile;
  // stipple
  unsigned long int stipple;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // font
  unsigned long int font;
  // subwindow_mode
  signed int subwindow_mode;
  // graphics_exposures
  signed int graphics_exposures;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // clip_mask
  unsigned long int clip_mask;
  // dash_offset
  signed int dash_offset;
  // dashes
  char dashes;
};

struct anonymous_6
{
  // id
  signed int id;
  // type
  signed int type;
  // byte_order
  signed int byte_order;
  // guid
  char guid[16l];
  // bits_per_pixel
  signed int bits_per_pixel;
  // format
  signed int format;
  // num_planes
  signed int num_planes;
  // depth
  signed int depth;
  // red_mask
  unsigned int red_mask;
  // green_mask
  unsigned int green_mask;
  // blue_mask
  unsigned int blue_mask;
  // y_sample_bits
  unsigned int y_sample_bits;
  // u_sample_bits
  unsigned int u_sample_bits;
  // v_sample_bits
  unsigned int v_sample_bits;
  // horz_y_period
  unsigned int horz_y_period;
  // horz_u_period
  unsigned int horz_u_period;
  // horz_v_period
  unsigned int horz_v_period;
  // vert_y_period
  unsigned int vert_y_period;
  // vert_u_period
  unsigned int vert_u_period;
  // vert_v_period
  unsigned int vert_v_period;
  // component_order
  char component_order[32l];
  // scanline_order
  signed int scanline_order;
};

struct anonymous_3
{
  // id
  signed int id;
  // width
  signed int width;
  // height
  signed int height;
  // data_size
  signed int data_size;
  // num_planes
  signed int num_planes;
  // pitches
  signed int *pitches;
  // offsets
  signed int *offsets;
  // data
  char *data;
  // obdata
  char *obdata;
};

struct anonymous_110
{
  // numerator
  signed int numerator;
  // denominator
  signed int denominator;
};

struct anonymous_94
{
  // pgno
  signed int pgno;
};

struct anonymous_63
{
  // pgno
  signed int pgno;
  // subno
  signed int subno;
};

struct anonymous_93
{
  // pgno
  signed int pgno;
  // subno
  signed int subno;
  // raw_header
  unsigned char *raw_header;
  // pn_offset
  signed int pn_offset;
  // roll_header
  unsigned int roll_header : 1;
  // header_update
  unsigned int header_update : 1;
  // clock_update
  unsigned int clock_update : 1;
};

struct anonymous_74
{
  // reason
  signed int reason;
  // event
  union _XEvent *event;
  // item_or_text
  union __XmStringRec *item_or_text;
  // item_position
  signed int item_position;
};

struct anonymous_83
{
  // reason
  signed int reason;
  // event
  union _XEvent *event;
  // value
  union __XmStringRec *value;
  // length
  signed int length;
};

struct anonymous_87
{
  // reason
  signed int reason;
  // event
  union _XEvent *event;
  // value
  union __XmStringRec *value;
  // length
  signed int length;
  // mask
  union __XmStringRec *mask;
  // mask_length
  signed int mask_length;
  // dir
  union __XmStringRec *dir;
  // dir_length
  signed int dir_length;
  // pattern
  union __XmStringRec *pattern;
  // pattern_length
  signed int pattern_length;
};

struct anonymous_57
{
  // reason
  signed int reason;
  // event
  union _XEvent *event;
  // set
  signed int set;
};

struct anonymous_66
{
  // reason
  signed int reason;
  // event
  union _XEvent *event;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // source_data
  void *source_data;
  // location_data
  void *location_data;
  // flags
  signed int flags;
  // parm
  void *parm;
  // parm_format
  signed int parm_format;
  // parm_length
  unsigned long int parm_length;
  // parm_type
  unsigned long int parm_type;
  // status
  signed int status;
  // value
  void *value;
  // type
  unsigned long int type;
  // format
  signed int format;
  // length
  unsigned long int length;
};

struct anonymous_59
{
  // screen_number
  signed int screen_number;
  // x_org
  signed short int x_org;
  // y_org
  signed short int y_org;
  // width
  signed short int width;
  // height
  signed short int height;
};

struct anonymous_100
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_103
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_102
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_101
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_105
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_107
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_100 _kill;
  // _timer
  struct anonymous_101 _timer;
  // _rt
  struct anonymous_102 _rt;
  // _sigchld
  struct anonymous_103 _sigchld;
  // _sigfault
  struct anonymous_104 _sigfault;
  // _sigpoll
  struct anonymous_105 _sigpoll;
  // _sigsys
  struct anonymous_106 _sigsys;
};

struct anonymous_19
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_107 _sifields;
};

struct anonymous
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous_54
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous_55
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous_32
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous_31
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous_35
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous_36
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous_37
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_44
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous_41
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous_40
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_39
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_48
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous_38
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous_45
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous_34
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_43
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous_49
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous_24
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous_53
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous_29
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous_52
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous_33
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous_42
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous_30
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous_46
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous_50
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous_118
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous_51
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous_118 data;
};

struct anonymous_28
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous_27
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous_26
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous_25
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous_47
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous_20
{
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
};

struct anonymous_117
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // depth
  signed int depth;
  // visual
  struct anonymous_8 *visual;
  // root
  unsigned long int root;
  // class
  signed int class;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // colormap
  unsigned long int colormap;
  // map_installed
  signed int map_installed;
  // map_state
  signed int map_state;
  // all_event_masks
  signed long int all_event_masks;
  // your_event_mask
  signed long int your_event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // screen
  struct anonymous_0 *screen;
};

struct anonymous_60
{
  // y0
  signed int y0;
  // y1
  signed int y1;
  // roll
  signed int roll;
};

struct anonymous_92
{
  // time
  signed long int time;
  // seconds_east
  signed int seconds_east;
  // seconds_east_valid
  signed int seconds_east_valid;
  // dst_state
  enum anonymous_91 dst_state;
};

struct anonymous_73
{
  // ts
  signed long int ts;
};

struct anonymous_69
{
  // ts
  signed long int ts;
  // seq
  signed int seq;
  // twice
  signed int twice;
};

struct anonymous_4
{
  // depth
  char depth;
  // visual_id
  unsigned long int visual_id;
};

struct anonymous_90
{
  // mode
  enum anonymous_89 mode;
  // language
  unsigned char *language;
};

struct anonymous_79
{
  // channel
  enum anonymous_77 channel;
  // cni_type
  enum anonymous_76 cni_type;
  // cni
  unsigned int cni;
  // pil
  unsigned int pil;
  // luf
  signed int luf;
  // mi
  signed int mi;
  // prf
  signed int prf;
  // pcs_audio
  enum anonymous_78 pcs_audio;
  // pty
  unsigned int pty;
  // tape_delayed
  signed int tape_delayed;
  // _reserved2
  void *_reserved2[2l];
  // _reserved3
  signed int _reserved3[4l];
};

struct anonymous_64
{
  // hdisplay
  unsigned short int hdisplay;
  // hsyncstart
  unsigned short int hsyncstart;
  // hsyncend
  unsigned short int hsyncend;
  // htotal
  unsigned short int htotal;
  // hskew
  unsigned short int hskew;
  // vdisplay
  unsigned short int vdisplay;
  // vsyncstart
  unsigned short int vsyncstart;
  // vsyncend
  unsigned short int vsyncend;
  // vtotal
  unsigned short int vtotal;
  // flags
  unsigned int flags;
  // privsize
  signed int privsize;
  // private
  signed int *private;
};

struct anonymous_113
{
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // alpha
  unsigned short int alpha;
};

struct anonymous_15
{
  // dotclock
  unsigned int dotclock;
  // hdisplay
  unsigned short int hdisplay;
  // hsyncstart
  unsigned short int hsyncstart;
  // hsyncend
  unsigned short int hsyncend;
  // htotal
  unsigned short int htotal;
  // hskew
  unsigned short int hskew;
  // vdisplay
  unsigned short int vdisplay;
  // vsyncstart
  unsigned short int vsyncstart;
  // vsyncend
  unsigned short int vsyncend;
  // vtotal
  unsigned short int vtotal;
  // flags
  unsigned int flags;
  // privsize
  signed int privsize;
  // private
  signed int *private;
};

struct anonymous_98
{
  // id
  unsigned int id;
  // line
  unsigned int line;
  // data
  unsigned char data[56l];
};

struct anonymous_80
{
  // nuid
  unsigned int nuid;
  // name
  signed char name[64l];
  // call
  signed char call[40l];
  // tape_delay
  signed int tape_delay;
  // cni_vps
  signed int cni_vps;
  // cni_8301
  signed int cni_8301;
  // cni_8302
  signed int cni_8302;
  // reserved
  signed int reserved;
  // cycle
  signed int cycle;
};

struct anonymous_135
{
  // background_pixmap
  unsigned long int background_pixmap;
  // background_pixel
  unsigned long int background_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // border_pixel
  unsigned long int border_pixel;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // event_mask
  signed long int event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // colormap
  unsigned long int colormap;
  // cursor
  unsigned long int cursor;
};

struct anonymous_5
{
  // base_id
  unsigned long int base_id;
  // num_ports
  unsigned long int num_ports;
  // type
  char type;
  // name
  char *name;
  // num_formats
  unsigned long int num_formats;
  // formats
  struct anonymous_4 *formats;
  // num_adaptors
  unsigned long int num_adaptors;
};

struct anonymous_111
{
  // encoding_id
  unsigned long int encoding_id;
  // name
  char *name;
  // width
  unsigned long int width;
  // height
  unsigned long int height;
  // rate
  struct anonymous_110 rate;
  // num_encodings
  unsigned long int num_encodings;
};

struct anonymous_119
{
  // name
  unsigned long int name;
  // card32
  unsigned long int card32;
};

struct anonymous_22
{
  // pixel
  unsigned long int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // flags
  char flags;
  // pad
  char pad;
};

struct anonymous_2
{
  // shmseg
  unsigned long int shmseg;
  // shmid
  signed int shmid;
  // shmaddr
  char *shmaddr;
  // readOnly
  signed int readOnly;
};

struct anonymous_133
{
  // valuemask
  unsigned long int valuemask;
  // visual
  struct anonymous_8 *visual;
  // colormap
  unsigned long int colormap;
  // depth
  unsigned int depth;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // x_hotspot
  unsigned int x_hotspot;
  // y_hotspot
  unsigned int y_hotspot;
  // cpp
  unsigned int cpp;
  // pixels
  unsigned long int *pixels;
  // npixels
  unsigned int npixels;
  // colorsymbols
  struct anonymous_130 *colorsymbols;
  // numsymbols
  unsigned int numsymbols;
  // rgb_fname
  char *rgb_fname;
  // nextensions
  unsigned int nextensions;
  // extensions
  struct anonymous_131 *extensions;
  // ncolors
  unsigned int ncolors;
  // colorTable
  struct anonymous_132 *colorTable;
  // hints_cmt
  char *hints_cmt;
  // colors_cmt
  char *colors_cmt;
  // pixels_cmt
  char *pixels_cmt;
  // mask_pixel
  unsigned int mask_pixel;
  // exactColors
  signed int exactColors;
  // closeness
  unsigned int closeness;
  // red_closeness
  unsigned int red_closeness;
  // green_closeness
  unsigned int green_closeness;
  // blue_closeness
  unsigned int blue_closeness;
  // color_key
  signed int color_key;
  // alloc_pixels
  unsigned long int *alloc_pixels;
  // nalloc_pixels
  signed int nalloc_pixels;
  // alloc_close_colors
  signed int alloc_close_colors;
  // bitmap_format
  signed int bitmap_format;
  // alloc_color
  signed int (*alloc_color)(struct _XDisplay *, unsigned long int, char *, struct anonymous_22 *, void *);
  // free_colors
  signed int (*free_colors)(struct _XDisplay *, unsigned long int, unsigned long int *, signed int, void *);
  // color_closure
  void *color_closure;
};

struct anonymous_114
{
  // byte1
  unsigned char byte1;
  // byte2
  unsigned char byte2;
};

union anonymous_18
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_19 *, void *);
};

union anonymous_56
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_121
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_129
{
  // i
  signed int i[8l];
  // s
  char s[80l];
};

struct snd_seq_real_time
{
  // tv_sec
  unsigned int tv_sec;
  // tv_nsec
  unsigned int tv_nsec;
};

union snd_seq_timestamp
{
  // tick
  unsigned int tick;
  // time
  struct snd_seq_real_time time;
};

struct snd_seq_queue_skew
{
  // value
  unsigned int value;
  // base
  unsigned int base;
};

union anonymous_99
{
  // value
  signed int value;
  // time
  union snd_seq_timestamp time;
  // position
  unsigned int position;
  // skew
  struct snd_seq_queue_skew skew;
  // d32
  unsigned int d32[2l];
  // d8
  unsigned char d8[8l];
};

union anonymous_72
{
  // __data
  struct anonymous_71 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous_95
{
  // ttx_page
  struct anonymous_93 ttx_page;
  // caption
  struct anonymous_94 caption;
  // network
  struct anonymous_80 network;
  // trigger
  struct vbi_link *trigger;
  // aspect
  struct anonymous_85 aspect;
  // prog_info
  struct vbi_program_info *prog_info;
  // local_time
  struct anonymous_92 *local_time;
  // prog_id
  struct anonymous_79 *prog_id;
  // _cc608
  struct _vbi_event_cc608_page *_cc608;
  // _cc608_stream
  struct _vbi_event_cc608_stream *_cc608_stream;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_70
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct snd_seq_ev_note
{
  // channel
  unsigned char channel;
  // note
  unsigned char note;
  // velocity
  unsigned char velocity;
  // off_velocity
  unsigned char off_velocity;
  // duration
  unsigned int duration;
};

struct snd_seq_ev_ctrl
{
  // channel
  unsigned char channel;
  // unused
  unsigned char unused[3l];
  // param
  unsigned int param;
  // value
  signed int value;
};

struct snd_seq_ev_raw8
{
  // d
  unsigned char d[12l];
};

struct snd_seq_ev_raw32
{
  // d
  unsigned int d[3l];
};

struct snd_seq_ev_ext
{
  // len
  unsigned int len;
  // ptr
  void *ptr;
} __attribute__ ((__packed__));

struct snd_seq_ev_queue_control
{
  // queue
  unsigned char queue;
  // unused
  unsigned char unused[3l];
  // param
  union anonymous_99 param;
};

struct snd_seq_addr
{
  // client
  unsigned char client;
  // port
  unsigned char port;
};

struct snd_seq_connect
{
  // sender
  struct snd_seq_addr sender;
  // dest
  struct snd_seq_addr dest;
};

struct snd_seq_result
{
  // event
  signed int event;
  // result
  signed int result;
};

union anonymous_21
{
  // note
  struct snd_seq_ev_note note;
  // control
  struct snd_seq_ev_ctrl control;
  // raw8
  struct snd_seq_ev_raw8 raw8;
  // raw32
  struct snd_seq_ev_raw32 raw32;
  // ext
  struct snd_seq_ev_ext ext;
  // queue
  struct snd_seq_ev_queue_control queue;
  // time
  union snd_seq_timestamp time;
  // addr
  struct snd_seq_addr addr;
  // connect
  struct snd_seq_connect connect;
  // result
  struct snd_seq_result result;
};

union anonymous_58
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_65
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct ARGS
{
  // device
  char *device;
  // driver
  char *driver;
  // dspdev
  char *dspdev;
  // vbidev
  char *vbidev;
  // joydev
  char *joydev;
  // basename
  char *basename;
  // conffile
  char *conffile;
  // alsa_cap
  char *alsa_cap;
  // alsa_pb
  char *alsa_pb;
  // debug
  signed int debug;
  // bpp
  signed int bpp;
  // shift
  signed int shift;
  // xv_port
  signed int xv_port;
  // parallel
  signed int parallel;
  // bufcount
  signed int bufcount;
  // alsa_latency
  signed int alsa_latency;
  // remote
  signed int remote;
  // readconfig
  signed int readconfig;
  // fullscreen
  signed int fullscreen;
  // fbdev
  signed int fbdev;
  // xv
  signed int xv;
  // xv_video
  signed int xv_video;
  // xv_image
  signed int xv_image;
  // gl
  signed int gl;
  // alsa
  signed int alsa;
  // vidmode
  signed int vidmode;
  // dga
  signed int dga;
  // randr
  signed int randr;
  // help
  signed int help;
  // hwscan
  signed int hwscan;
};

struct CFG_ENTRIES
{
  // ent_count
  signed int ent_count;
  // ent_names
  char **ent_names;
  // ent_values
  char **ent_values;
  // ent_seen
  signed int **ent_seen;
};

struct CFG_SECTIONS
{
  // sec_count
  signed int sec_count;
  // sec_names
  char **sec_names;
  // sec_entries
  struct CFG_ENTRIES **sec_entries;
};

struct CHANLIST
{
  // name
  char *name;
  // freq
  unsigned int freq;
};

struct CHANLISTS
{
  // name
  char *name;
  // filename
  char *filename;
  // list
  struct CHANLIST *list;
  // count
  signed int count;
};

struct CHANNEL
{
  // name
  char *name;
  // key
  char *key;
  // group
  char *group;
  // midi
  signed int midi;
  // cname
  char *cname;
  // channel
  signed int channel;
  // fine
  signed int fine;
  // freq
  signed int freq;
  // audio
  signed int audio;
  // capture
  signed int capture;
  // input
  signed int input;
  // norm
  signed int norm;
  // color
  signed int color;
  // bright
  signed int bright;
  // hue
  signed int hue;
  // contrast
  signed int contrast;
  // pixmap
  unsigned long int pixmap;
  // button
  struct _WidgetRec *button;
};

struct CHUNKHDR
{
  // ckid
  unsigned int ckid;
  // dwSize
  unsigned int dwSize;
};

struct COMMANDS
{
  // name
  char *name;
  // min_args
  signed int min_args;
  // handler
  signed int (*handler)(char *, signed int, char **);
};

struct DO_CMD
{
  // argc
  signed int argc;
  // argv
  char *argv[8l];
};

struct ENC_MAP
{
  // norm
  signed int norm;
  // input
  signed int input;
  // encoding
  signed int encoding;
};

struct FIFO
{
  // name
  char *name;
  // data
  unsigned char *data[64l];
  // slots
  signed int slots;
  // read
  signed int read;
  // write
  signed int write;
  // eof
  signed int eof;
  // max
  signed int max;
  // writers
  signed int writers;
  // lock
  union anonymous_70 lock;
  // hasdata
  union anonymous_72 hasdata;
};

struct FILE_DATA
{
  // filebox
  struct _WidgetRec *filebox;
  // text
  struct _WidgetRec *text;
  // push
  struct _WidgetRec *push;
};

struct JOYTAB
{
  // class
  signed int class;
  // number
  signed int number;
  // value
  signed int value;
  // event
  char *event;
};

struct LAUNCH
{
  // name
  char *name;
  // key
  char *key;
  // cmdline
  char *cmdline;
};

struct MY_TOPLEVELS
{
  // name
  char *name;
  // shell
  struct _WidgetRec **shell;
  // mapped
  signed int mapped;
};

struct OVERLAY_CLIP
{
  // x1
  signed int x1;
  // x2
  signed int x2;
  // y1
  signed int y1;
  // y2
  signed int y2;
};

struct SEARCHFORMAT
{
  // depth
  unsigned int depth;
  // order
  signed int order;
  // red
  unsigned long int red;
  // green
  unsigned long int green;
  // blue
  unsigned long int blue;
  // format
  unsigned int format;
};

struct STRTAB
{
  // nr
  signed long int nr;
  // str
  const char *str;
};

struct WAVEHDR
{
  // chkRiff
  struct CHUNKHDR chkRiff;
  // fccWave
  unsigned int fccWave;
  // chkFmt
  struct CHUNKHDR chkFmt;
  // wFormatTag
  unsigned short int wFormatTag;
  // nChannels
  unsigned short int nChannels;
  // nSamplesPerSec
  unsigned int nSamplesPerSec;
  // nAvgBytesPerSec
  unsigned int nAvgBytesPerSec;
  // nBlockAlign
  unsigned short int nBlockAlign;
  // wBitsPerSample
  unsigned short int wBitsPerSample;
  // chkData
  struct CHUNKHDR chkData;
};

struct WEBCAM
{
  // lock
  union anonymous_70 lock;
  // wait
  union anonymous_72 wait;
  // filename
  char *filename;
  // buf
  struct ng_video_buf *buf;
};

struct XVATTR
{
  // id
  signed int id;
  // type
  signed int type;
  // atom
  char *atom;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous_24 xany;
  // xkey
  struct anonymous_25 xkey;
  // xbutton
  struct anonymous_26 xbutton;
  // xmotion
  struct anonymous_27 xmotion;
  // xcrossing
  struct anonymous_28 xcrossing;
  // xfocus
  struct anonymous_29 xfocus;
  // xexpose
  struct anonymous_30 xexpose;
  // xgraphicsexpose
  struct anonymous_31 xgraphicsexpose;
  // xnoexpose
  struct anonymous_32 xnoexpose;
  // xvisibility
  struct anonymous_33 xvisibility;
  // xcreatewindow
  struct anonymous_34 xcreatewindow;
  // xdestroywindow
  struct anonymous_35 xdestroywindow;
  // xunmap
  struct anonymous_36 xunmap;
  // xmap
  struct anonymous_37 xmap;
  // xmaprequest
  struct anonymous_38 xmaprequest;
  // xreparent
  struct anonymous_39 xreparent;
  // xconfigure
  struct anonymous_40 xconfigure;
  // xgravity
  struct anonymous_41 xgravity;
  // xresizerequest
  struct anonymous_42 xresizerequest;
  // xconfigurerequest
  struct anonymous_43 xconfigurerequest;
  // xcirculate
  struct anonymous_44 xcirculate;
  // xcirculaterequest
  struct anonymous_45 xcirculaterequest;
  // xproperty
  struct anonymous_46 xproperty;
  // xselectionclear
  struct anonymous_47 xselectionclear;
  // xselectionrequest
  struct anonymous_48 xselectionrequest;
  // xselection
  struct anonymous_49 xselection;
  // xcolormap
  struct anonymous_50 xcolormap;
  // xclient
  struct anonymous_51 xclient;
  // xmapping
  struct anonymous_52 xmapping;
  // xerror
  struct anonymous xerror;
  // xkeymap
  struct anonymous_53 xkeymap;
  // xgeneric
  struct anonymous_54 xgeneric;
  // xcookie
  struct anonymous_55 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct funcs
{
  // create_image
  struct _XImage * (*create_image)(struct _XDisplay *, struct anonymous_8 *, unsigned int, signed int, signed int, char *, unsigned int, unsigned int, signed int, signed int);
  // destroy_image
  signed int (*destroy_image)(struct _XImage *);
  // get_pixel
  unsigned long int (*get_pixel)(struct _XImage *, signed int, signed int);
  // put_pixel
  signed int (*put_pixel)(struct _XImage *, signed int, signed int, unsigned long int);
  // sub_image
  struct _XImage * (*sub_image)(struct _XImage *, signed int, signed int, unsigned int, unsigned int);
  // add_pixel
  signed int (*add_pixel)(struct _XImage *, signed long int);
};

struct _XImage
{
  // width
  signed int width;
  // height
  signed int height;
  // xoffset
  signed int xoffset;
  // format
  signed int format;
  // data
  char *data;
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // bitmap_pad
  signed int bitmap_pad;
  // depth
  signed int depth;
  // bytes_per_line
  signed int bytes_per_line;
  // bits_per_pixel
  signed int bits_per_pixel;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // obdata
  char *obdata;
  // f
  struct funcs f;
};

struct _XftColor
{
  // pixel
  unsigned long int pixel;
  // color
  struct anonymous_113 color;
};

struct _XftFont
{
  // ascent
  signed int ascent;
  // descent
  signed int descent;
  // height
  signed int height;
  // max_advance_width
  signed int max_advance_width;
  // charset
  struct _FcCharSet *charset;
  // pattern
  struct _FcPattern *pattern;
};

struct _XtActionsRec
{
  // string
  char *string;
  // proc
  void (*proc)(struct _WidgetRec *, union _XEvent *, char **, unsigned int *);
};

struct _XtResource
{
  // resource_name
  char *resource_name;
  // resource_class
  char *resource_class;
  // resource_type
  char *resource_type;
  // resource_size
  unsigned int resource_size;
  // resource_offset
  unsigned int resource_offset;
  // default_type
  char *default_type;
  // default_addr
  void *default_addr;
};

struct vbi_bit_slicer
{
  // func
  signed int (*func)(struct vbi_bit_slicer *, unsigned char *, unsigned char *);
  // cri
  unsigned int cri;
  // cri_mask
  unsigned int cri_mask;
  // thresh
  signed int thresh;
  // cri_bytes
  signed int cri_bytes;
  // cri_rate
  signed int cri_rate;
  // oversampling_rate
  signed int oversampling_rate;
  // phase_shift
  signed int phase_shift;
  // step
  signed int step;
  // frc
  unsigned int frc;
  // frc_bits
  signed int frc_bits;
  // payload
  signed int payload;
  // endian
  signed int endian;
  // skip
  signed int skip;
};

struct _vbi_raw_decoder_job
{
  // id
  unsigned int id;
  // offset
  signed int offset;
  // slicer
  struct vbi_bit_slicer slicer;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct ng_video_fmt
{
  // fmtid
  unsigned int fmtid;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // bytesperline
  unsigned int bytesperline;
};

struct ng_video_buf
{
  // fmt
  struct ng_video_fmt fmt;
  // size
  unsigned long int size;
  // data
  unsigned char *data;
  // info
  struct anonymous_69 info;
  // lock
  union anonymous_70 lock;
  // cond
  union anonymous_72 cond;
  // refcount
  signed int refcount;
  // release
  void (*release)(struct ng_video_buf *);
  // priv
  void *priv;
};

struct blit_state
{
  // status
  enum blit_status status;
  // widget
  struct _WidgetRec *widget;
  // win_width
  unsigned short int win_width;
  // win_height
  unsigned short int win_height;
  // wx
  signed int wx;
  // wy
  signed int wy;
  // ww
  signed int ww;
  // wh
  signed int wh;
  // gc
  struct _XGC *gc;
  // vinfo
  struct anonymous_1 *vinfo;
  // fmt
  struct ng_video_fmt fmt;
  // buf
  struct ng_video_buf buf;
  // conv
  struct ng_video_conv *conv;
  // chandle
  struct ng_convert_handle *chandle;
  // shm
  struct anonymous_2 *shm;
  // ximage
  struct _XImage *ximage;
  // xvimage
  struct anonymous_3 *xvimage;
  // tex
  signed int tex;
  // tw
  signed int tw;
  // th
  signed int th;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct event_entry
{
  // event
  char event[128l];
  // action
  char action[128l];
  // argbuf
  char argbuf[128l];
  // argc
  signed int argc;
  // argv
  char *argv[16l];
  // next
  struct event_entry *next;
};

struct ng_audio_fmt
{
  // fmtid
  unsigned int fmtid;
  // rate
  unsigned int rate;
};

struct files_handle
{
  // file
  char file[4096l];
  // video
  struct ng_video_fmt video;
  // audio
  struct ng_audio_fmt audio;
  // wav_fd
  signed int wav_fd;
  // wav_header
  struct WAVEHDR wav_header;
  // wav_size
  signed int wav_size;
  // gotcha
  signed int gotcha;
};

struct filter_attribute
{
  // next
  struct filter_attribute *next;
  // filter
  struct ng_filter *filter;
  // attr
  struct ng_attribute *attr;
  // value
  signed int value;
  // widget
  struct _WidgetRec *widget;
};

struct final_params
{
  // bufsize
  signed int bufsize;
  // rate
  signed int rate;
  // latency
  signed int latency;
  // channels
  signed int channels;
};

struct in6_addr
{
  // __in6_u
  union anonymous_56 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct input_params
{
  // pdevice
  char *pdevice;
  // cdevice
  char *cdevice;
  // latency
  signed int latency;
};

struct list_head
{
  // next
  struct list_head *next;
  // prev
  struct list_head *prev;
};

struct ipc_data
{
  // list
  struct list_head list;
  // atom
  unsigned long int atom;
  // buf
  struct ng_video_buf *buf;
  // filename
  char *filename;
  // pix
  unsigned long int pix;
  // icon_pixmap
  unsigned long int icon_pixmap;
  // icon_widget
  struct _WidgetRec *icon_widget;
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

struct jpeg_common_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
};

struct jpeg_compress_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
  // dest
  struct jpeg_destination_mgr *dest;
  // image_width
  unsigned int image_width;
  // image_height
  unsigned int image_height;
  // input_components
  signed int input_components;
  // in_color_space
  enum anonymous_123 in_color_space;
  // input_gamma
  double input_gamma;
  // data_precision
  signed int data_precision;
  // num_components
  signed int num_components;
  // jpeg_color_space
  enum anonymous_123 jpeg_color_space;
  // comp_info
  struct anonymous_124 *comp_info;
  // quant_tbl_ptrs
  struct anonymous_125 *quant_tbl_ptrs[4l];
  // dc_huff_tbl_ptrs
  struct anonymous_126 *dc_huff_tbl_ptrs[4l];
  // ac_huff_tbl_ptrs
  struct anonymous_126 *ac_huff_tbl_ptrs[4l];
  // arith_dc_L
  unsigned char arith_dc_L[16l];
  // arith_dc_U
  unsigned char arith_dc_U[16l];
  // arith_ac_K
  unsigned char arith_ac_K[16l];
  // num_scans
  signed int num_scans;
  // scan_info
  const struct anonymous_127 *scan_info;
  // raw_data_in
  signed int raw_data_in;
  // arith_code
  signed int arith_code;
  // optimize_coding
  signed int optimize_coding;
  // CCIR601_sampling
  signed int CCIR601_sampling;
  // smoothing_factor
  signed int smoothing_factor;
  // dct_method
  enum anonymous_128 dct_method;
  // restart_interval
  unsigned int restart_interval;
  // restart_in_rows
  signed int restart_in_rows;
  // write_JFIF_header
  signed int write_JFIF_header;
  // JFIF_major_version
  unsigned char JFIF_major_version;
  // JFIF_minor_version
  unsigned char JFIF_minor_version;
  // density_unit
  unsigned char density_unit;
  // X_density
  unsigned short int X_density;
  // Y_density
  unsigned short int Y_density;
  // write_Adobe_marker
  signed int write_Adobe_marker;
  // next_scanline
  unsigned int next_scanline;
  // progressive_mode
  signed int progressive_mode;
  // max_h_samp_factor
  signed int max_h_samp_factor;
  // max_v_samp_factor
  signed int max_v_samp_factor;
  // total_iMCU_rows
  unsigned int total_iMCU_rows;
  // comps_in_scan
  signed int comps_in_scan;
  // cur_comp_info
  struct anonymous_124 *cur_comp_info[4l];
  // MCUs_per_row
  unsigned int MCUs_per_row;
  // MCU_rows_in_scan
  unsigned int MCU_rows_in_scan;
  // blocks_in_MCU
  signed int blocks_in_MCU;
  // MCU_membership
  signed int MCU_membership[10l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
  // master
  struct jpeg_comp_master *master;
  // main
  struct jpeg_c_main_controller *main;
  // prep
  struct jpeg_c_prep_controller *prep;
  // coef
  struct jpeg_c_coef_controller *coef;
  // marker
  struct jpeg_marker_writer *marker;
  // cconvert
  struct jpeg_color_converter *cconvert;
  // downsample
  struct jpeg_downsampler *downsample;
  // fdct
  struct jpeg_forward_dct *fdct;
  // entropy
  struct jpeg_entropy_encoder *entropy;
  // script_space
  struct anonymous_127 *script_space;
  // script_space_size
  signed int script_space_size;
};

struct jpeg_destination_mgr
{
  // next_output_byte
  unsigned char *next_output_byte;
  // free_in_buffer
  unsigned long int free_in_buffer;
  // init_destination
  void (*init_destination)(struct jpeg_compress_struct *);
  // empty_output_buffer
  signed int (*empty_output_buffer)(struct jpeg_compress_struct *);
  // term_destination
  void (*term_destination)(struct jpeg_compress_struct *);
};

struct jpeg_error_mgr
{
  // error_exit
  void (*error_exit)(struct jpeg_common_struct *);
  // emit_message
  void (*emit_message)(struct jpeg_common_struct *, signed int);
  // output_message
  void (*output_message)(struct jpeg_common_struct *);
  // format_message
  void (*format_message)(struct jpeg_common_struct *, char *);
  // reset_error_mgr
  void (*reset_error_mgr)(struct jpeg_common_struct *);
  // msg_code
  signed int msg_code;
  // msg_parm
  union anonymous_129 msg_parm;
  // trace_level
  signed int trace_level;
  // num_warnings
  signed long int num_warnings;
  // jpeg_message_table
  const char * const *jpeg_message_table;
  // last_jpeg_message
  signed int last_jpeg_message;
  // addon_message_table
  const char * const *addon_message_table;
  // first_addon_message
  signed int first_addon_message;
  // last_addon_message
  signed int last_addon_message;
};

struct jpeg_memory_mgr
{
  // alloc_small
  void * (*alloc_small)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_large
  void * (*alloc_large)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_sarray
  unsigned char ** (*alloc_sarray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int);
  // alloc_barray
  signed short int (**(*alloc_barray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int))[64l];
  // request_virt_sarray
  struct jvirt_sarray_control * (*request_virt_sarray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // request_virt_barray
  struct jvirt_barray_control * (*request_virt_barray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // realize_virt_arrays
  void (*realize_virt_arrays)(struct jpeg_common_struct *);
  // access_virt_sarray
  unsigned char ** (*access_virt_sarray)(struct jpeg_common_struct *, struct jvirt_sarray_control *, unsigned int, unsigned int, signed int);
  // access_virt_barray
  signed short int (**(*access_virt_barray)(struct jpeg_common_struct *, struct jvirt_barray_control *, unsigned int, unsigned int, signed int))[64l];
  // free_pool
  void (*free_pool)(struct jpeg_common_struct *, signed int);
  // self_destruct
  void (*self_destruct)(struct jpeg_common_struct *);
  // max_memory_to_use
  signed long int max_memory_to_use;
  // max_alloc_chunk
  signed long int max_alloc_chunk;
};

struct jpeg_progress_mgr
{
  // progress_monitor
  void (*progress_monitor)(struct jpeg_common_struct *);
  // pass_counter
  signed long int pass_counter;
  // pass_limit
  signed long int pass_limit;
  // completed_passes
  signed int completed_passes;
  // total_passes
  signed int total_passes;
};

struct js_event
{
  // time
  unsigned int time;
  // value
  signed short int value;
  // type
  unsigned char type;
  // number
  unsigned char number;
};

struct lirc_code
{
  // remote
  char *remote;
  // button
  char *button;
  // next
  struct lirc_code *next;
};

struct lirc_config
{
  // current_mode
  char *current_mode;
  // next
  struct lirc_config_entry *next;
  // first
  struct lirc_config_entry *first;
  // sockfd
  signed int sockfd;
};

struct lirc_config_entry
{
  // prog
  char *prog;
  // code
  struct lirc_code *code;
  // rep_delay
  unsigned int rep_delay;
  // rep
  unsigned int rep;
  // config
  struct lirc_list *config;
  // change_mode
  char *change_mode;
  // flags
  unsigned int flags;
  // mode
  char *mode;
  // next_config
  struct lirc_list *next_config;
  // next_code
  struct lirc_code *next_code;
  // next
  struct lirc_config_entry *next;
};

struct lirc_list
{
  // string
  char *string;
  // next
  struct lirc_list *next;
};

struct media_device_entry
{
  // device
  char *device;
  // node
  char *node;
  // type
  enum device_type type;
  // bus
  enum bus_type bus;
  // major
  unsigned int major;
  // minor
  unsigned int minor;
};

struct media_devices
{
  // md_entry
  struct media_device_entry *md_entry;
  // md_size
  unsigned int md_size;
};

struct midi_handle
{
  // seq
  struct _snd_seq *seq;
  // fd
  signed int fd;
  // port
  signed int port;
  // ev
  struct snd_seq_event *ev;
};

struct motif_attribute
{
  // next
  struct motif_attribute *next;
  // attr
  struct ng_attribute *attr;
  // widget
  struct _WidgetRec *widget;
};

struct ng_convthread_handle
{
  // c
  struct ng_convert_handle *c;
  // in
  struct FIFO *in;
  // out
  struct FIFO *out;
};

struct movie_handle
{
  // lock
  union anonymous_70 lock;
  // writer
  struct ng_writer *writer;
  // handle
  void *handle;
  // tflush
  unsigned long int tflush;
  // start
  unsigned long int start;
  // rts
  unsigned long int rts;
  // stopby
  unsigned long int stopby;
  // slots
  signed int slots;
  // vfmt
  struct ng_video_fmt vfmt;
  // fps
  signed int fps;
  // frames
  signed int frames;
  // seq
  signed int seq;
  // vfifo
  struct FIFO vfifo;
  // tvideo
  unsigned long int tvideo;
  // vts
  unsigned long int vts;
  // cfifo
  struct FIFO cfifo;
  // cthreads
  signed int cthreads;
  // hconv
  struct ng_convthread_handle *hconv[4l];
  // tconv
  unsigned long int tconv[4l];
  // dsp
  struct ng_dsp_driver *dsp;
  // hdsp
  void *hdsp;
  // afmt
  struct ng_audio_fmt afmt;
  // bytes_per_sec
  unsigned long int bytes_per_sec;
  // bytes
  unsigned long int bytes;
  // afifo
  struct FIFO afifo;
  // taudio
  unsigned long int taudio;
  // raudio
  unsigned long int raudio;
  // ats
  unsigned long int ats;
  // rdrift
  unsigned long int rdrift;
  // vdrift
  unsigned long int vdrift;
};

struct ng_attribute
{
  // id
  signed int id;
  // name
  const char *name;
  // type
  signed int type;
  // defval
  signed int defval;
  // choices
  struct STRTAB *choices;
  // min
  signed int min;
  // max
  signed int max;
  // points
  signed int points;
  // priv
  const void *priv;
  // handle
  void *handle;
  // read
  signed int (*read)(struct ng_attribute *);
  // write
  void (*write)(struct ng_attribute *, signed int);
};

struct ng_audio_buf
{
  // fmt
  struct ng_audio_fmt fmt;
  // size
  signed int size;
  // written
  signed int written;
  // data
  char *data;
  // info
  struct anonymous_73 info;
};

struct ng_audio_conv
{
  // fmtid_in
  unsigned int fmtid_in;
  // fmtid_out
  unsigned int fmtid_out;
  // init
  void * (*init)(void *);
  // frame
  struct ng_audio_buf * (*frame)(void *, struct ng_audio_buf *);
  // fini
  void (*fini)(void *);
  // priv
  void *priv;
  // list
  struct list_head list;
};

struct ng_convert_handle
{
  // ifmt
  struct ng_video_fmt ifmt;
  // ofmt
  struct ng_video_fmt ofmt;
  // isize
  signed int isize;
  // osize
  signed int osize;
  // conv
  struct ng_video_conv *conv;
  // chandle
  void *chandle;
};

struct ng_device_config
{
  // video
  char *video;
  // driver
  char *driver;
  // radio
  char *radio;
  // vbi
  char *vbi;
  // dsp
  char *dsp;
  // mixer
  char *mixer;
  // video_scan
  char *video_scan[32l];
  // mixer_scan
  char *mixer_scan[32l];
};

struct ng_devinfo
{
  // device
  char device[32l];
  // name
  char name[64l];
  // flags
  signed int flags;
};

struct ng_dsp_driver
{
  // name
  const char *name;
  // open
  void * (*open)(char *, struct ng_audio_fmt *, signed int);
  // close
  void (*close)(void *);
  // fd
  signed int (*fd)(void *);
  // startrec
  signed int (*startrec)(void *);
  // read
  struct ng_audio_buf * (*read)(void *, signed long int);
  // write
  struct ng_audio_buf * (*write)(void *, struct ng_audio_buf *);
  // latency
  signed long int (*latency)(void *);
  // list
  struct list_head list;
};

struct ng_filter
{
  // name
  char *name;
  // fmts
  signed int fmts;
  // attrs
  struct ng_attribute *attrs;
  // init
  void * (*init)(struct ng_video_fmt *);
  // frame
  struct ng_video_buf * (*frame)(void *, struct ng_video_buf *);
  // fini
  void (*fini)(void *);
  // list
  struct list_head list;
};

struct ng_format_list
{
  // name
  char *name;
  // desc
  char *desc;
  // ext
  char *ext;
  // fmtid
  unsigned int fmtid;
  // priv
  void *priv;
};

struct ng_mix_driver
{
  // name
  const char *name;
  // probe
  struct ng_devinfo * (*probe)(void);
  // channels
  struct ng_devinfo * (*channels)(char *);
  // open
  void * (*open)(char *);
  // volctl
  struct ng_attribute * (*volctl)(void *, char *);
  // close
  void (*close)(void *);
  // list
  struct list_head list;
};

struct ng_reader
{
  // name
  const char *name;
  // desc
  const char *desc;
  // magic
  char *magic[4l];
  // moff
  signed int moff[4l];
  // mlen
  signed int mlen[4l];
  // rd_open
  void * (*rd_open)(char *);
  // rd_vfmt
  struct ng_video_fmt * (*rd_vfmt)(void *, signed int *, signed int);
  // rd_afmt
  struct ng_audio_fmt * (*rd_afmt)(void *);
  // rd_vdata
  struct ng_video_buf * (*rd_vdata)(void *, unsigned int);
  // rd_adata
  struct ng_audio_buf * (*rd_adata)(void *);
  // frame_time
  signed long int (*frame_time)(void *);
  // rd_close
  signed int (*rd_close)(void *);
  // list
  struct list_head list;
};

struct ng_vid_driver
{
  // name
  const char *name;
  // open
  void * (*open)(char *, signed int);
  // close
  signed int (*close)(void *);
  // get_devname
  char * (*get_devname)(void *);
  // capabilities
  signed int (*capabilities)(void *);
  // list_attrs
  struct ng_attribute * (*list_attrs)(void *);
  // get_min_size
  void (*get_min_size)(void *, signed int *, signed int *);
  // setupfb
  signed int (*setupfb)(void *, struct ng_video_fmt *, void *);
  // overlay
  signed int (*overlay)(void *, struct ng_video_fmt *, signed int, signed int, struct OVERLAY_CLIP *, signed int, signed int);
  // setformat
  signed int (*setformat)(void *, struct ng_video_fmt *);
  // startvideo
  signed int (*startvideo)(void *, signed int, unsigned int);
  // stopvideo
  void (*stopvideo)(void *);
  // nextframe
  struct ng_video_buf * (*nextframe)(void *);
  // getimage
  struct ng_video_buf * (*getimage)(void *);
  // getfreq
  unsigned long int (*getfreq)(void *);
  // setfreq
  void (*setfreq)(void *, unsigned long int);
  // is_tuned
  signed int (*is_tuned)(void *);
  // list
  struct list_head list;
};

struct ng_video_conv
{
  // fmtid_in
  unsigned int fmtid_in;
  // fmtid_out
  unsigned int fmtid_out;
  // init
  void * (*init)(struct ng_video_fmt *, void *);
  // frame
  void (*frame)(void *, struct ng_video_buf *, struct ng_video_buf *);
  // fini
  void (*fini)(void *);
  // priv
  void *priv;
  // list
  struct list_head list;
};

struct ng_writer
{
  // name
  const char *name;
  // desc
  const char *desc;
  // video
  struct ng_format_list *video;
  // audio
  struct ng_format_list *audio;
  // combined
  const signed int combined;
  // wr_open
  void * (*wr_open)(char *, char *, struct ng_video_fmt *, const void *, signed int, struct ng_audio_fmt *, const void *);
  // wr_video
  signed int (*wr_video)(void *, struct ng_video_buf *);
  // wr_audio
  signed int (*wr_audio)(void *, struct ng_audio_buf *);
  // wr_close
  signed int (*wr_close)(void *);
  // list
  struct list_head list;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct raw_handle
{
  // video
  struct ng_video_fmt video;
  // audio
  struct ng_audio_fmt audio;
  // vpriv
  struct raw_priv *vpriv;
  // fd
  signed int fd;
  // wav_fd
  signed int wav_fd;
  // wav_header
  struct WAVEHDR wav_header;
  // wav_size
  signed int wav_size;
};

struct raw_priv
{
  // yuv4mpeg
  signed int yuv4mpeg;
};

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_18 __sigaction_handler;
  // sa_mask
  struct anonymous_16 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct snd_seq_event
{
  // type
  unsigned char type;
  // flags
  unsigned char flags;
  // tag
  unsigned char tag;
  // queue
  unsigned char queue;
  // time
  union snd_seq_timestamp time;
  // source
  struct snd_seq_addr source;
  // dest
  struct snd_seq_addr dest;
  // data
  union anonymous_21 data;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct stderr_handler
{
  // box
  struct _WidgetRec *box;
  // str
  union __XmStringRec *str;
  // pipe
  signed int pipe;
  // id
  unsigned long int id;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct utsname
{
  // sysname
  char sysname[65l];
  // nodename
  char nodename[65l];
  // release
  char release[65l];
  // version
  char version[65l];
  // machine
  char machine[65l];
  // domainname
  char domainname[65l];
};

struct v4l2_tuner
{
  // index
  unsigned int index;
  // name
  unsigned char name[32l];
  // type
  unsigned int type;
  // capability
  unsigned int capability;
  // rangelow
  unsigned int rangelow;
  // rangehigh
  unsigned int rangehigh;
  // rxsubchans
  unsigned int rxsubchans;
  // audmode
  unsigned int audmode;
  // signal
  signed int signal;
  // afc
  signed int afc;
  // reserved
  unsigned int reserved[4l];
};

struct vbi_char
{
  // underline
  unsigned int underline : 1;
  // bold
  unsigned int bold : 1;
  // italic
  unsigned int italic : 1;
  // flash
  unsigned int flash : 1;
  // conceal
  unsigned int conceal : 1;
  // proportional
  unsigned int proportional : 1;
  // link
  unsigned int link : 1;
  // reserved
  unsigned int reserved : 1;
  // size
  unsigned int size : 8;
  // opacity
  unsigned int opacity : 8;
  // foreground
  unsigned int foreground : 8;
  // background
  unsigned int background : 8;
  // drcs_clut_offs
  unsigned int drcs_clut_offs : 8;
  // unicode
  unsigned int unicode : 16;
};

struct vbi_event
{
  // type
  signed int type;
  // ev
  union anonymous_95 ev;
};

struct vbi_font
{
  // label
  char *label;
  // xlfd1
  char *xlfd1;
  // xlfd2
  char *xlfd2;
};

struct vbi_link
{
  // type
  enum anonymous_81 type;
  // eacem
  signed int eacem;
  // name
  signed char name[80l];
  // url
  signed char url[256l];
  // script
  signed char script[256l];
  // nuid
  unsigned int nuid;
  // pgno
  signed int pgno;
  // subno
  signed int subno;
  // expires
  double expires;
  // itv_type
  enum anonymous_82 itv_type;
  // priority
  signed int priority;
  // autoload
  signed int autoload;
};

struct vbi_page
{
  // vbi
  struct vbi_decoder *vbi;
  // nuid
  unsigned int nuid;
  // pgno
  signed int pgno;
  // subno
  signed int subno;
  // rows
  signed int rows;
  // columns
  signed int columns;
  // text
  struct vbi_char text[1056l];
  // dirty
  struct anonymous_60 dirty;
  // screen_color
  enum anonymous_61 screen_color;
  // screen_opacity
  enum anonymous_62 screen_opacity;
  // color_map
  unsigned int color_map[40l];
  // drcs_clut
  unsigned char *drcs_clut;
  // drcs
  unsigned char *drcs[32l];
  // nav_link
  struct anonymous_63 nav_link[6l];
  // nav_index
  char nav_index[64l];
  // font
  struct vbi_font_descr *font[2l];
  // double_height_lower
  unsigned int double_height_lower;
  // page_opacity
  enum anonymous_62 page_opacity[2l];
  // boxed_opacity
  enum anonymous_62 boxed_opacity[2l];
};

struct vbi_program_info
{
  // future
  unsigned int future : 1;
  // month
  signed char month;
  // day
  signed char day;
  // hour
  signed char hour;
  // min
  signed char min;
  // tape_delayed
  signed char tape_delayed;
  // length_hour
  signed char length_hour;
  // length_min
  signed char length_min;
  // elapsed_hour
  signed char elapsed_hour;
  // elapsed_min
  signed char elapsed_min;
  // elapsed_sec
  signed char elapsed_sec;
  // title
  signed char title[64l];
  // type_classf
  enum anonymous_88 type_classf;
  // type_id
  signed int type_id[33l];
  // rating_auth
  enum anonymous_86 rating_auth;
  // rating_id
  signed int rating_id;
  // rating_dlsv
  signed int rating_dlsv;
  // audio
  struct anonymous_90 audio[2l];
  // caption_services
  signed int caption_services;
  // caption_language
  unsigned char *caption_language[8l];
  // cgms_a
  signed int cgms_a;
  // aspect
  struct anonymous_85 aspect;
  // description
  signed char description[8l][33l];
};

struct vbi_raw_decoder
{
  // scanning
  signed int scanning;
  // sampling_format
  enum anonymous_97 sampling_format;
  // sampling_rate
  signed int sampling_rate;
  // bytes_per_line
  signed int bytes_per_line;
  // offset
  signed int offset;
  // start
  signed int start[2l];
  // count
  signed int count[2l];
  // interlaced
  signed int interlaced;
  // synchronous
  signed int synchronous;
  // mutex
  union anonymous_70 mutex;
  // services
  unsigned int services;
  // num_jobs
  signed int num_jobs;
  // pattern
  signed char *pattern;
  // jobs
  struct _vbi_raw_decoder_job jobs[8l];
};

struct vbi_rect
{
  // x1
  signed int x1;
  // x2
  signed int x2;
  // y1
  signed int y1;
  // y2
  signed int y2;
};

struct vbi_state
{
  // dec
  struct vbi_decoder *dec;
  // cap
  struct vbi_capture *cap;
  // par
  struct vbi_raw_decoder *par;
  // sliced
  struct anonymous_98 *sliced;
  // raw
  unsigned char *raw;
  // err
  char *err;
  // lines
  signed int lines;
  // fd
  signed int fd;
  // sim
  signed int sim;
  // debug
  signed int debug;
  // ts
  double ts;
  // tv
  struct timeval tv;
};

struct vbi_window
{
  // shell
  struct _WidgetRec *shell;
  // tt
  struct _WidgetRec *tt;
  // subbtn
  struct _WidgetRec *subbtn;
  // submenu
  struct _WidgetRec *submenu;
  // savebox
  struct _WidgetRec *savebox;
  // cmap
  unsigned long int cmap;
  // gc
  struct _XGC *gc;
  // font1
  struct anonymous_14 *font1;
  // font2
  struct anonymous_14 *font2;
  // w
  signed int w;
  // a
  signed int a;
  // d
  signed int d;
  // h
  signed int h;
  // colors
  unsigned long int colors[8l];
  // xft_font
  struct _XftFont *xft_font;
  // xft_color
  struct _XftColor xft_color[8l];
  // vbi
  struct vbi_state *vbi;
  // pg
  struct vbi_page pg;
  // pgno
  signed int pgno;
  // subno
  signed int subno;
  // charset
  char *charset;
  // newpage
  signed int newpage;
  // down
  unsigned long int down;
  // s
  struct vbi_rect s;
  // selections
  struct list_head selections;
};

struct video_handle
{
  // win
  struct _WidgetRec *win;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // work_id
  unsigned long int work_id;
  // suspend
  signed int suspend;
  // nw
  signed int nw;
  // nh
  signed int nh;
  // best
  struct ng_video_fmt best;
  // blit
  struct blit_state *blit;
  // filter
  struct ng_filter *filter;
  // fhandle
  void *fhandle;
  // ffmt
  struct ng_video_fmt ffmt;
};

struct xv_handle
{
  // vi_adaptor
  signed int vi_adaptor;
  // vi_port
  unsigned long int vi_port;
  // vi_gc
  struct _XGC *vi_gc;
  // nattr
  signed int nattr;
  // attr
  struct ng_attribute *attr;
  // xv_encoding
  unsigned long int xv_encoding;
  // xv_freq
  unsigned long int xv_freq;
  // xv_colorkey
  unsigned long int xv_colorkey;
  // enc_map
  struct ENC_MAP *enc_map;
  // norm
  signed int norm;
  // input
  signed int input;
  // enc
  signed int enc;
  // encodings
  signed int encodings;
};


// MIME_IMAGE_JPEG
// file x11/atoms.c line 46
unsigned long int MIME_IMAGE_JPEG;
// MIME_IMAGE_PPM
// file x11/atoms.c line 45
unsigned long int MIME_IMAGE_PPM;
// MIME_TEXT_ISO8859_1
// file x11/atoms.c line 42
unsigned long int MIME_TEXT_ISO8859_1;
// MIME_TEXT_URI_LIST
// file x11/atoms.c line 48
unsigned long int MIME_TEXT_URI_LIST;
// MIME_TEXT_UTF_8
// file x11/atoms.c line 43
unsigned long int MIME_TEXT_UTF_8;
// WM_DELETE_WINDOW
// file x11/atoms.c line 7
unsigned long int WM_DELETE_WINDOW;
// WM_PROTOCOLS
// file x11/atoms.c line 6
unsigned long int WM_PROTOCOLS;
// XA_BACKGROUND
// file x11/atoms.c line 39
unsigned long int XA_BACKGROUND;
// XA_BLANK
// file jwz/remote.c line 49
static unsigned long int XA_BLANK;
// XA_CLIPBOARD
// file x11/atoms.c line 34
unsigned long int XA_CLIPBOARD;
// XA_DEACTIVATE
// file x11/atoms.c line 22
unsigned long int XA_DEACTIVATE;
// XA_DEMO
// file jwz/remote.c line 49
static unsigned long int XA_DEMO;
// XA_DONE
// file x11/atoms.c line 33
unsigned long int XA_DONE;
// XA_EXIT
// file jwz/remote.c line 48
static unsigned long int XA_EXIT;
// XA_FILE
// file x11/atoms.c line 37
unsigned long int XA_FILE;
// XA_FILE_NAME
// file x11/atoms.c line 36
unsigned long int XA_FILE_NAME;
// XA_FOREGROUND
// file x11/atoms.c line 40
unsigned long int XA_FOREGROUND;
// XA_LOCK
// file jwz/remote.c line 49
static unsigned long int XA_LOCK;
// XA_PIXEL
// file x11/atoms.c line 38
unsigned long int XA_PIXEL;
// XA_SCREENSAVER
// file jwz/remote.c line 47
static unsigned long int XA_SCREENSAVER;
// XA_SCREENSAVER_ID
// file jwz/remote.c line 48
static unsigned long int XA_SCREENSAVER_ID;
// XA_SCREENSAVER_RESPONSE
// file jwz/remote.c line 47
static unsigned long int XA_SCREENSAVER_RESPONSE;
// XA_SCREENSAVER_STATUS
// file jwz/remote.c line 48
static unsigned long int XA_SCREENSAVER_STATUS;
// XA_SCREENSAVER_VERSION
// file jwz/remote.c line 47
static unsigned long int XA_SCREENSAVER_VERSION;
// XA_SELECT
// file jwz/remote.c line 49
static unsigned long int XA_SELECT;
// XA_TARGETS
// file x11/atoms.c line 32
unsigned long int XA_TARGETS;
// XA_UTF8_STRING
// file x11/atoms.c line 35
unsigned long int XA_UTF8_STRING;
// XA_VROOT
// file jwz/remote.c line 49
static unsigned long int XA_VROOT;
// XV_COLORKEY
// file x11/atoms.c line 55
unsigned long int XV_COLORKEY;
// XV_ENCODING
// file x11/atoms.c line 53
unsigned long int XV_ENCODING;
// XV_FREQ
// file x11/atoms.c line 54
unsigned long int XV_FREQ;
// XV_MUTE
// file x11/atoms.c line 52
unsigned long int XV_MUTE;
// XtShellStrings
// file /usr/include/X11/Shell.h line 189
extern const char XtShellStrings[];
// XtStrings
// file /usr/include/X11/StringDefs.h line 316
extern const char XtStrings[];
// _MOTIF_CLIPBOARD_TARGETS
// file x11/atoms.c line 25
unsigned long int _MOTIF_CLIPBOARD_TARGETS;
// _MOTIF_DEFERRED_CLIPBOARD_TARGETS
// file x11/atoms.c line 26
unsigned long int _MOTIF_DEFERRED_CLIPBOARD_TARGETS;
// _MOTIF_DROP
// file x11/atoms.c line 28
unsigned long int _MOTIF_DROP;
// _MOTIF_EXPORT_TARGETS
// file x11/atoms.c line 29
unsigned long int _MOTIF_EXPORT_TARGETS;
// _MOTIF_LOSE_SELECTION
// file x11/atoms.c line 30
unsigned long int _MOTIF_LOSE_SELECTION;
// _MOTIF_SNAPSHOT
// file x11/atoms.c line 27
unsigned long int _MOTIF_SNAPSHOT;
// _NETSCAPE_URL
// file x11/atoms.c line 49
unsigned long int _NETSCAPE_URL;
// _NET_SUPPORTED
// file x11/atoms.c line 9
unsigned long int _NET_SUPPORTED;
// _NET_WM_STATE
// file x11/atoms.c line 10
unsigned long int _NET_WM_STATE;
// _NET_WM_STATE_ABOVE
// file x11/atoms.c line 12
unsigned long int _NET_WM_STATE_ABOVE;
// _NET_WM_STATE_FULLSCREEN
// file x11/atoms.c line 13
unsigned long int _NET_WM_STATE_FULLSCREEN;
// _NET_WM_STATE_STAYS_ON_TOP
// file x11/atoms.c line 11
unsigned long int _NET_WM_STATE_STAYS_ON_TOP;
// _WIN_LAYER
// file x11/atoms.c line 16
unsigned long int _WIN_LAYER;
// _WIN_PROTOCOLS
// file x11/atoms.c line 15
unsigned long int _WIN_PROTOCOLS;
// _WIN_SUPPORTING_WM_CHECK
// file x11/atoms.c line 14
unsigned long int _WIN_SUPPORTING_WM_CHECK;
// _XAWTV_REMOTE
// file x11/atoms.c line 20
unsigned long int _XAWTV_REMOTE;
// _XAWTV_STATION
// file x11/atoms.c line 19
unsigned long int _XAWTV_STATION;
// _XmStrings
// file /usr/include/Xm/XmStrDefs.h line 1375
extern char _XmStrings[];
// actionTable
// file x11/motv.c line 90
static struct _XtActionsRec actionTable[16l];
// actionTable
// file x11/motv.c line 90
static struct _XtActionsRec actionTable[16l] = { { .string="CloseMain", .proc=CloseMainAction },
    { .string="Command", .proc=CommandAction },
    { .string="Popup", .proc=PopupAction }, { .string="Debug", .proc=DebugAction }, { .string="Remote", .proc=RemoteAction },
    { .string="Zap", .proc=ZapAction }, { .string="Scan", .proc=ScanAction }, { .string="man", .proc=man_action }, { .string="Ratio", .proc=RatioAction }, { .string="Launch", .proc=LaunchAction },
    { .string="Vtx", .proc=VtxAction }, { .string="Complete", .proc=CompleteAction },
    { .string="Ipc", .proc=IpcAction }, { .string="Filter", .proc=FilterAction },
    { .string="StayOnTop", .proc=ontop_ac },
    { .string="Event", .proc=EventAction } };
// adaptors
// file x11/blit.c line 50
static signed int adaptors;
// adaptors_link1
// file x11/xv.c line 38
static signed int adaptors_link1;
// ai
// file x11/blit.c line 52
static struct anonymous_5 *ai;
// ai_link1
// file x11/xv.c line 40
static struct anonymous_5 *ai_link1;
// alloc_count
// file common/channel.c line 66
signed int alloc_count = 0;
// alsa_cap
// file x11/xt.c line 107
static char *alsa_cap;
// alsa_is_running
// file common/alsa_stream.c line 598
static signed int alsa_is_running = 0;
// alsa_out
// file x11/xt.c line 108
static char *alsa_out;
// alsa_thread
// file common/alsa_stream.c line 599
static unsigned long int alsa_thread;
// app_context
// file x11/xt.c line 72
struct _XtAppStruct *app_context;
// app_shell
// file x11/xt.c line 73
struct _WidgetRec *app_shell;
// applicationShellWidgetClass
// file /usr/include/X11/Shell.h line 557
extern struct _WidgetClassRec *applicationShellWidgetClass;
// args
// file x11/xt.c line 119
struct ARGS args;
// args_count
// file x11/xt.c line 280
const signed int args_count = (const signed int)(unsigned int)(sizeof(struct _XtResource [30l]) /*1440ul*/  / sizeof(struct _XtResource) /*48ul*/ );
// args_desc
// file x11/xt.c line 121
struct _XtResource args_desc[30l];
// args_desc
// file x11/xt.c line 121
struct _XtResource args_desc[30l] = { { .resource_name="device", .resource_class=(char *)&XtStrings[(signed long int)1416], .resource_type=(char *)&XtStrings[(signed long int)1797],
    .resource_size=(unsigned int)sizeof(char *) /*8ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->device - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)0 },
    { .resource_name="driver", .resource_class=(char *)&XtStrings[(signed long int)1416], .resource_type=(char *)&XtStrings[(signed long int)1797],
    .resource_size=(unsigned int)sizeof(char *) /*8ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->driver - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)0 },
    { .resource_name="dspdev", .resource_class=(char *)&XtStrings[(signed long int)1416], .resource_type=(char *)&XtStrings[(signed long int)1797],
    .resource_size=(unsigned int)sizeof(char *) /*8ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->dspdev - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)0 },
    { .resource_name="vbidev", .resource_class=(char *)&XtStrings[(signed long int)1416], .resource_type=(char *)&XtStrings[(signed long int)1797],
    .resource_size=(unsigned int)sizeof(char *) /*8ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->vbidev - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)0 },
    { .resource_name="joydev", .resource_class=(char *)&XtStrings[(signed long int)1416], .resource_type=(char *)&XtStrings[(signed long int)1797],
    .resource_size=(unsigned int)sizeof(char *) /*8ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->joydev - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)0 },
    { .resource_name="basename", .resource_class=(char *)&XtStrings[(signed long int)1416], .resource_type=(char *)&XtStrings[(signed long int)1797],
    .resource_size=(unsigned int)sizeof(char *) /*8ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->basename - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"snap" },
    { .resource_name="conffile", .resource_class=(char *)&XtStrings[(signed long int)1416], .resource_type=(char *)&XtStrings[(signed long int)1797],
    .resource_size=(unsigned int)sizeof(char *) /*8ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->conffile - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)0 },
    { .resource_name="alsa_cap", .resource_class=(char *)&XtStrings[(signed long int)1416], .resource_type=(char *)&XtStrings[(signed long int)1797],
    .resource_size=(unsigned int)sizeof(char *) /*8ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->alsa_cap - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)0 },
    { .resource_name="alsa_pb", .resource_class=(char *)&XtStrings[(signed long int)1416], .resource_type=(char *)&XtStrings[(signed long int)1797],
    .resource_size=(unsigned int)sizeof(char *) /*8ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->alsa_pb - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)0 },
    { .resource_name="alsa_latency", .resource_class=(char *)&XtStrings[(signed long int)1497], .resource_type=(char *)&XtStrings[(signed long int)1718],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->alsa_latency - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"30" },
    { .resource_name="debug", .resource_class=(char *)&XtStrings[(signed long int)1497], .resource_type=(char *)&XtStrings[(signed long int)1718],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->debug - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"0" },
    { .resource_name="bpp", .resource_class=(char *)&XtStrings[(signed long int)1497], .resource_type=(char *)&XtStrings[(signed long int)1718],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->bpp - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"0" },
    { .resource_name="shift", .resource_class=(char *)&XtStrings[(signed long int)1497], .resource_type=(char *)&XtStrings[(signed long int)1718],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->shift - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"0" },
    { .resource_name="xvport", .resource_class=(char *)&XtStrings[(signed long int)1497], .resource_type=(char *)&XtStrings[(signed long int)1718],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->xv_port - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"0" },
    { .resource_name="parallel", .resource_class=(char *)&XtStrings[(signed long int)1497], .resource_type=(char *)&XtStrings[(signed long int)1718],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->parallel - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"1" },
    { .resource_name="bufcount", .resource_class=(char *)&XtStrings[(signed long int)1497], .resource_type=(char *)&XtStrings[(signed long int)1718],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->bufcount - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"16" },
    { .resource_name="remote", .resource_class=(char *)&XtStrings[(signed long int)920], .resource_type=(char *)&XtStrings[(signed long int)1561],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->remote - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"0" },
    { .resource_name="readconfig", .resource_class=(char *)&XtStrings[(signed long int)920], .resource_type=(char *)&XtStrings[(signed long int)1561],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->readconfig - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"1" },
    { .resource_name="fullscreen", .resource_class=(char *)&XtStrings[(signed long int)920], .resource_type=(char *)&XtStrings[(signed long int)1561],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->fullscreen - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"0" },
    { .resource_name="fbdev", .resource_class=(char *)&XtStrings[(signed long int)920], .resource_type=(char *)&XtStrings[(signed long int)1561],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->fbdev - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"0" },
    { .resource_name="xv", .resource_class=(char *)&XtStrings[(signed long int)920], .resource_type=(char *)&XtStrings[(signed long int)1561],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->xv - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"1" },
    { .resource_name="xvVideo", .resource_class=(char *)&XtStrings[(signed long int)920], .resource_type=(char *)&XtStrings[(signed long int)1561],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->xv_video - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"1" },
    { .resource_name="xvImage", .resource_class=(char *)&XtStrings[(signed long int)920], .resource_type=(char *)&XtStrings[(signed long int)1561],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->xv_image - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"1" },
    { .resource_name="gl", .resource_class=(char *)&XtStrings[(signed long int)920], .resource_type=(char *)&XtStrings[(signed long int)1561],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->gl - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"1" },
    { .resource_name="alsa", .resource_class=(char *)&XtStrings[(signed long int)920], .resource_type=(char *)&XtStrings[(signed long int)1561],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->alsa - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"1" },
    { .resource_name="vidmode", .resource_class=(char *)&XtStrings[(signed long int)920], .resource_type=(char *)&XtStrings[(signed long int)1561],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->vidmode - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"1" },
    { .resource_name="dga", .resource_class=(char *)&XtStrings[(signed long int)920], .resource_type=(char *)&XtStrings[(signed long int)1561],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->dga - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"1" },
    { .resource_name="randr", .resource_class=(char *)&XtStrings[(signed long int)920], .resource_type=(char *)&XtStrings[(signed long int)1561],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->randr - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"1" },
    { .resource_name="help", .resource_class=(char *)&XtStrings[(signed long int)920], .resource_type=(char *)&XtStrings[(signed long int)1561],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->help - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"0" },
    { .resource_name="hwscan", .resource_class=(char *)&XtStrings[(signed long int)920], .resource_type=(char *)&XtStrings[(signed long int)1561],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->hwscan - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"0" } };
// at
// file x11/xv.c line 42
static struct anonymous_112 *at;
// attr_notify
// file common/commands.c line 46
void (*attr_notify)(struct ng_attribute *, signed int);
// attributes
// file x11/xv.c line 39
static signed int attributes;
// attrs
// file common/commands.c line 79
struct ng_attribute *attrs = (struct ng_attribute *)(void *)0;
// audio_menu
// file x11/motv.c line 142
static struct _WidgetRec *audio_menu;
// audio_option
// file x11/motv.c line 142
static struct _WidgetRec *audio_option;
// audio_timer
// file x11/motv.c line 116
unsigned long int audio_timer;
// b_ontop
// file x11/motv.c line 125
static struct _WidgetRec *b_ontop;
// bm_no
// file x11/xt.c line 2183
unsigned long int bm_no;
// bm_no_data
// file x11/xt.c line 2196
static unsigned char bm_no_data[8l] = { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// bm_yes
// file x11/xt.c line 2182
unsigned long int bm_yes;
// bm_yes_data
// file x11/xt.c line 2185
static unsigned char bm_yes_data[8l] = { (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x18, (unsigned char)0x3c, (unsigned char)0x3c, (unsigned char)0x18, (unsigned char)0x00, (unsigned char)0x00 };
// booltab
// file common/channel.c line 728
struct STRTAB booltab[7l] = { { .nr=(signed long int)0, .str="no" }, { .nr=(signed long int)0, .str="false" },
    { .nr=(signed long int)0, .str="off" }, { .nr=(signed long int)1, .str="yes" }, { .nr=(signed long int)1, .str="true" },
    { .nr=(signed long int)1, .str="on" }, { .nr=(signed long int)-1, .str=(const char *)(void *)0 } };
// c
// file common/parseconfig.c line 26
static struct CFG_SECTIONS *c;
// cap_menu
// file x11/motv.c line 120
static struct _WidgetRec *cap_menu;
// captab
// file common/channel.c line 170
struct STRTAB captab[11l] = { { .nr=(signed long int)9, .str="on" }, { .nr=(signed long int)9, .str="yes" }, { .nr=(signed long int)9, .str="true" },
    { .nr=(signed long int)0, .str="off" }, { .nr=(signed long int)0, .str="no" }, { .nr=(signed long int)0, .str="false" },
    { .nr=(signed long int)1, .str="over" },
    { .nr=(signed long int)1, .str="overlay" },
    { .nr=(signed long int)2, .str="grab" },
    { .nr=(signed long int)2, .str="grabdisplay" },
    { .nr=(signed long int)-1, .str=(const char *)(void *)0 } };
// caption_i
// file common/vbi-sim.c line 184
static unsigned int caption_i = (unsigned int)0;
// caption_text
// file common/vbi-sim.c line 185
static const unsigned char caption_text[34l] = { (const unsigned char)0x14, (const unsigned char)0x25, (const unsigned char)0x14, (const unsigned char)0x25, (const unsigned char)76, (const unsigned char)73, (const unsigned char)66, (const unsigned char)90, (const unsigned char)86, (const unsigned char)66, (const unsigned char)73, (const unsigned char)32, (const unsigned char)67, (const unsigned char)65, (const unsigned char)80, (const unsigned char)84, (const unsigned char)73, (const unsigned char)79, (const unsigned char)78, (const unsigned char)32, (const unsigned char)83, (const unsigned char)73, (const unsigned char)77, (const unsigned char)85, (const unsigned char)76, (const unsigned char)65, (const unsigned char)84, (const unsigned char)73, (const unsigned char)79, (const unsigned char)78, (const unsigned char)0x14, (const unsigned char)0x2D, (const unsigned char)0x14, (const unsigned char)0x2D };
// capture_get_hook
// file common/commands.c line 62
void (*capture_get_hook)(void);
// capture_rel_hook
// file common/commands.c line 63
void (*capture_rel_hook)(void);
// chan_box
// file x11/motv.c line 121
static struct _WidgetRec *chan_box;
// chan_viewport
// file x11/motv.c line 121
static struct _WidgetRec *chan_viewport;
// chanlist_names
// file common/frequencies.c line 17
struct STRTAB *chanlist_names;
// chanlists
// file common/frequencies.c line 16
struct CHANLISTS *chanlists;
// channel_switch_hook
// file common/commands.c line 54
void (*channel_switch_hook)(void);
// channels
// file common/channel.c line 64
struct CHANNEL **channels = (struct CHANNEL **)(void *)0;
// chantab
// file common/frequencies.c line 15
signed int chantab = -1;
// chdlg
// file x11/motv.c line 2193
static struct _WidgetRec *chdlg;
// chscale
// file x11/motv.c line 2193
static struct _WidgetRec *chscale;
// chscan
// file x11/motv.c line 2190
static signed int chscan;
// chtimer
// file x11/motv.c line 2192
static unsigned long int chtimer;
// chvbi
// file x11/motv.c line 2191
static signed int chvbi;
// colormap
// file x11/xt.c line 79
unsigned long int colormap;
// commands
// file common/commands.c line 113
static struct COMMANDS commands[29l];
// commands
// file common/commands.c line 113
static struct COMMANDS commands[29l] = { { .name="setstation", .min_args=0, .handler=setstation_handler },
    { .name="setchannel", .min_args=0, .handler=setchannel_handler },
    { .name="setfreq", .min_args=1, .handler=setchannel_handler },
    { .name="setfreqtab", .min_args=1, .handler=setfreqtab_handler },
    { .name="capture", .min_args=1, .handler=capture_handler },
    { .name="setnorm", .min_args=1, .handler=attr_handler },
    { .name="setinput", .min_args=1, .handler=attr_handler },
    { .name="setattr", .min_args=1, .handler=attr_handler },
    { .name="color", .min_args=0, .handler=attr_handler },
    { .name="hue", .min_args=0, .handler=attr_handler },
    { .name="bright", .min_args=0, .handler=attr_handler },
    { .name="contrast", .min_args=0, .handler=attr_handler },
    { .name="show", .min_args=0, .handler=show_handler },
    { .name="list", .min_args=0, .handler=list_handler },
    { .name="volume", .min_args=0, .handler=volume_handler },
    { .name="attr", .min_args=0, .handler=dattr_handler },
    { .name="snap", .min_args=0, .handler=snap_handler },
    { .name="webcam", .min_args=1, .handler=webcam_handler },
    { .name="movie", .min_args=1, .handler=movie_handler },
    { .name="fullscreen", .min_args=0, .handler=fullscreen_handler },
    { .name="msg", .min_args=1, .handler=msg_handler },
    { .name="message", .min_args=0, .handler=msg_handler },
    { .name="exit", .min_args=0, .handler=exit_handler },
    { .name="quit", .min_args=0, .handler=exit_handler },
    { .name="bye", .min_args=0, .handler=exit_handler },
    { .name="keypad", .min_args=1, .handler=keypad_handler },
    { .name="showtime", .min_args=0, .handler=showtime_handler },
    { .name="vdr", .min_args=1, .handler=vdr_handler },
    { .name=(char *)(void *)0, .min_args=0, .handler=(signed int (*)(char *, signed int, char **))(void *)0 } };
// conf
// file x11/x11.c line 333
static signed int conf = 1;
// conf_id
// file x11/x11.c line 336
static unsigned long int conf_id;
// config
// file common/lirc.c line 24
static struct lirc_config *config = (struct lirc_config *)(void *)0;
// control_shell
// file x11/motv.c line 119
static struct _WidgetRec *control_shell;
// conv_list
// file libng/color_packed.c line 174
static struct ng_video_conv conv_list[12l];
// conv_list
// file libng/color_packed.c line 174
static struct ng_video_conv conv_list[12l] = { { .fmtid_in=(unsigned int)5, .fmtid_out=(unsigned int)2, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb15_be_gray, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)3, .fmtid_out=(unsigned int)2, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb15_native_gray, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)3, .fmtid_out=(unsigned int)5, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)5, .fmtid_out=(unsigned int)3, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)4, .fmtid_out=(unsigned int)6, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)6, .fmtid_out=(unsigned int)4, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=(unsigned int)9, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)redblue_swap, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)9, .fmtid_out=(unsigned int)7, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)redblue_swap, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=(unsigned int)9, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_rgb24, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=(unsigned int)7, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_bgr24, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=(unsigned int)8, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_bgr32, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=(unsigned int)10, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_rgb32, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// conv_list_link1
// file libng/color_yuv2rgb.c line 384
static struct ng_video_conv conv_list_link1[6l];
// conv_list_link1
// file libng/color_yuv2rgb.c line 384
static struct ng_video_conv conv_list_link1[6l] = { { .fmtid_in=(unsigned int)13, .fmtid_out=(unsigned int)9, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)yuv422_to_rgb24, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)13, .fmtid_out=(unsigned int)2, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)yuv422_to_gray, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=(unsigned int)9, .init=ng_conv_nop_init,
    .frame=yuv422p_to_rgb24, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=(unsigned int)9, .init=ng_conv_nop_init,
    .frame=yuv420p_to_rgb24, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=(unsigned int)2, .init=ng_conv_nop_init,
    .frame=yuv42xp_to_gray, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=(unsigned int)2, .init=ng_conv_nop_init,
    .frame=yuv42xp_to_gray, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// count
// file common/channel.c line 65
signed int count = 0;
// cur_attrs
// file common/commands.c line 72
signed int cur_attrs[256l];
// cur_capture
// file common/channel.c line 72
signed int cur_capture = 0;
// cur_channel
// file common/channel.c line 68
signed int cur_channel = -1;
// cur_dattr
// file common/commands.c line 154
static signed int cur_dattr = 0;
// cur_filter
// file common/channel.c line 70
struct ng_filter *cur_filter;
// cur_fine
// file common/channel.c line 68
signed int cur_fine = 0;
// cur_freq
// file common/channel.c line 69
signed int cur_freq;
// cur_movie
// file common/commands.c line 72
signed int cur_movie;
// cur_sender
// file common/channel.c line 68
signed int cur_sender = -1;
// cur_tv_height
// file common/commands.c line 71
unsigned int cur_tv_height;
// cur_tv_width
// file common/commands.c line 71
unsigned int cur_tv_width;
// dattr
// file common/commands.c line 155
static signed int dattr[5l] = { 3, 7, 9, 6, 8 };
// debug
// file x11/motv.c line 70
signed int debug;
// default_title
// file x11/xt.c line 113
static char default_title[256l] = { '?', '?', '?', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// defaults
// file common/channel.c line 52
struct CHANNEL defaults = { .name="defaults", .key=((char *)NULL), .group="main",
    .midi=0, .cname=((char *)NULL), .channel=-1,
    .fine=0, .freq=0, .audio=-1, .capture=9,
    .input=0, .norm=0, .color=-1, .bright=-1,
    .hue=-1, .contrast=-1, .pixmap=0ul, .button=((struct _WidgetRec *)NULL) };
// did_refresh
// file x11/x11.c line 331
static signed int did_refresh;
// display_bits
// file x11/blit.c line 40
static signed int display_bits = 0;
// display_bytes
// file x11/blit.c line 41
static unsigned int display_bytes = (unsigned int)0;
// display_message
// file common/commands.c line 36
void (*display_message)(char *);
// do_overlay
// file common/commands.c line 67
signed int do_overlay;
// dpy
// file x11/xt.c line 75
struct _XDisplay *dpy;
// driver_menu
// file x11/motv.c line 141
static struct _WidgetRec *driver_menu;
// driver_option
// file x11/motv.c line 141
static struct _WidgetRec *driver_option;
// drv
// file common/commands.c line 75
struct ng_vid_driver *drv;
// ei
// file x11/xv.c line 41
static struct anonymous_111 *ei;
// err
// file x11/blit.c line 48
static signed int err;
// err_link1
// file x11/xv.c line 37
static signed int err_link1;
// error_fp
// file common/alsa_stream.c line 52
struct _IO_FILE *error_fp;
// ev
// file x11/blit.c line 48
static signed int ev;
// ev_link1
// file x11/xv.c line 37
static signed int ev_link1;
// event_builtin_list
// file common/event.c line 17
static struct event_entry *event_builtin_list;
// event_conf_list
// file common/event.c line 16
static struct event_entry *event_conf_list;
// event_names
// file x11/x11.c line 340
char *event_names[35l] = { "0", "1", "KeyPress", "KeyRelease", "ButtonPress", "ButtonRelease", "MotionNotify", "EnterNotify", "LeaveNotify", "FocusIn", "FocusOut", "KeymapNotify", "Expose", "GraphicsExpose", "NoExpose", "VisibilityNotify", "CreateNotify", "DestroyNotify", "UnmapNotify", "MapNotify", "MapRequest", "ReparentNotify", "ConfigureNotify", "ConfigureRequest", "GravityNotify", "ResizeRequest", "CirculateNotify", "CirculateRequest", "PropertyNotify", "SelectionClear", "SelectionRequest", "SelectionNotify", "ColormapNotify", "ClientMessage", "MappingNotify" };
// exit_hook
// file common/commands.c line 61
void (*exit_hook)(void);
// exit_xpm
// file x11/xpm/exit.xpm line 2
static char *exit_xpm[20l] = { "16 16 3 1", " \tc gray77", ".\tc #000000000000", "X\tc #861782078617", "                ", "                ", "       ..       ", "       ..X      ", "    .  ..X .    ", "   ..X ..X ..   ", "  ..X  ..X  ..  ", "  ..X  ..X  ..X ", "  ..X  ..X  ..X ", "  ..X   XX  ..X ", "  ..X       ..X ", "   ..      ..XX ", "    ........XX  ", "     ......XX   ", "      XXXXXX    ", "                " };
// f_drv
// file common/commands.c line 77
signed int f_drv;
// fallback_ressources
// file x11/motv.c line 111
static char *fallback_ressources[476l] = { "", "", "", "", "", "MoTV.about_box_popup.title:\t\tAbout motv",
    "MoTV*about_box_popup*messageString:\t\tmotv - Motif TV application\t\\n\t\\n\t(c) 2002 Gerd Knorr <kraxel@bytesex.org>",
    "", "MoTV.errbox_popup.title:\t\tErrors", "", "control*menubar*fileM.tearOffTitle:\tFile",
    "control*menubar*editM.tearOffTitle:\tEdit",
    "control*menubar*toolsM.tearOffTitle:\tTools",
    "control*menubar*tuneM.tearOffTitle:\tTuner control",
    "control*menubar*grabM.tearOffTitle:\tGrab image",
    "control*menubar*ratioM.tearOffTitle:\tAspect ratio",
    "control*menubar*launchM.tearOffTitle:\tLaunch",
    "control*menubar*subM.tearOffTitle:\tSubtitles",
    "control*menubar*stationsM.tearOffTitle:\tTV Stations",
    "control*menubar*optionsM.tearOffTitle:\tOptions",
    "control*menubar*helpM.tearOffTitle:\tHelp",
    "control*menubar*captureM.tearOffTitle:\tCapture",
    "control*menubar*freqM.tearOffTitle:\tFrequency table",
    "control*menubar*inputM.tearOffTitle:\tInputs",
    "control*menubar*normM.tearOffTitle:\tTV Norm",
    "", "control*menubar.file.labelString:\tFile",
    "control*menubar.file.mnemonic:\t\tF", "control*menubar.edit.labelString:\tEdit",
    "control*menubar.edit.mnemonic:\t\tE", "control*menubar.tools.labelString:\tTools",
    "control*menubar.tools.mnemonic:\t\tT", "control*menubar*tune.labelString:\tTuner",
    "control*menubar*grab.labelString:\tGrab image",
    "control*menubar*ratio.labelString:\tAspect ratio",
    "control*menubar*launch.labelString:\tLaunch",
    "control*menubar*sub.labelString:\tSubtitles",
    "control*menubar.stations.labelString:\tStations",
    "control*menubar.stations.mnemonic:\tS",
    "control*menubar.options.labelString:\tOptions",
    "control*menubar.options.mnemonic:\tO", "control*menubar.filter.labelString:\tFilter",
    "control*menubar.filter.mnemonic:\tF", "control*menubar.help.labelString:\tHelp",
    "control*menubar.help.mnemonic:\t\tH", "", "control*menubar*rec.labelString:\tRecord movie ...",
    "control*menubar*rec.mnemonic:\t\tR", "control*menubar*rec.acceleratorText:\tR",
    "control*menubar*rec.accelerator:\t<Key>R",
    "control*menubar*quit.labelString:\tQuit",
    "control*menubar*quit.mnemonic:\t\tQ", "control*menubar*quit.acceleratorText:\tQ",
    "control*menubar*quit.accelerator:\t<Key>Q",
    "", "control*menubar*copy.labelString:\tCopy",
    "control*menubar*copy.mnemonic:\t\tC", "control*menubar*copy.acceleratorText:\tCtrl+C",
    "control*menubar*copy.accelerator:\tCtrl<Key>C",
    "", "control*menubar*mute.labelString:\tMute audio",
    "control*menubar*mute.mnemonic:\t\ta", "control*menubar*mute.acceleratorText:\tA",
    "control*menubar*mute.accelerator:\t<Key>A",
    "control*menubar*full.labelString:\tFullscreen",
    "control*menubar*full.mnemonic:\t\tF", "control*menubar*full.acceleratorText:\tF",
    "control*menubar*full.accelerator:\t<Key>F",
    "control*menubar*ontop.labelString:\tStay on Top",
    "control*menubar*ontop.mnemonic:\t\tT", "control*menubar*ontop.acceleratorText:\tT",
    "control*menubar*ontop.accelerator:\t<Key>T",
    "control*menubar*levels.labelString:\tRecord level monitor ...",
    "control*menubar*levels.mnemonic:\tl", "control*menubar*levels.acceleratorText:\tL",
    "control*menubar*levels.accelerator:\t<Key>L",
    "control*menubar*st_up.labelString:\tNext station",
    "control*menubar*st_up.acceleratorText:\tpage up",
    "control*menubar*st_dn.labelString:\tPrevious station",
    "control*menubar*st_dn.acceleratorText:\tpage down",
    "", "control*menubar*ch_up.labelString:\tChannel up",
    "control*menubar*ch_up.acceleratorText:\tup",
    "control*menubar*ch_dn.labelString:\tChannel down",
    "control*menubar*ch_dn.acceleratorText:\tdown",
    "control*menubar*fi_up.labelString:\tFinetune up",
    "control*menubar*fi_up.acceleratorText:\tright",
    "control*menubar*fi_dn.labelString:\tFinetune down",
    "control*menubar*fi_dn.acceleratorText:\tleft",
    "", "control*menubar*ppm_f.labelString:\tPPM, max size",
    "control*menubar*ppm_f.acceleratorText:\tG",
    "control*menubar*ppm_f.accelerator:\t~Ctrl<Key>G",
    "control*menubar*ppm_w.labelString:\tPPM, window size",
    "control*menubar*ppm_w.acceleratorText:\tCtrl+G",
    "control*menubar*ppm_w.accelerator:\tCtrl<Key>G",
    "control*menubar*jpg_f.labelString:\tJPEG, max size",
    "control*menubar*jpg_f.mnemonic:\t\tJ", "control*menubar*jpg_f.acceleratorText:\tJ",
    "control*menubar*jpg_f.accelerator:\t~Ctrl<Key>J",
    "control*menubar*jpg_w.labelString:\tJPEG, window size",
    "control*menubar*jpg_w.acceleratorText:\tCtrl+J",
    "control*menubar*jpg_w.accelerator:\tCtrl<Key>J",
    "", "control*menubar*r_no.labelString:\tno ratio",
    "control*menubar*r_no.mnemonic:\t\tn", "control*menubar*r_43.labelString:\t4:3",
    "control*menubar*r_43.mnemonic:\t\t4", "", "control*menubar*s_off.labelString:\tdisable",
    "control*menubar*s_150.labelString:\tpage 150",
    "control*menubar*s_150.mnemonic:\t\t1", "control*menubar*s_333.labelString:\tpage 333",
    "control*menubar*s_333.mnemonic:\t\t3", "control*menubar*s_777.labelString:\tpage 777",
    "control*menubar*s_777.mnemonic:\t\t7", "control*menubar*s_801.labelString:\tpage 801",
    "control*menubar*s_801.mnemonic:\t\t0", "control*menubar*s_888.labelString:\tpage 888",
    "control*menubar*s_888.mnemonic:\t\t8", "", "control*menubar*add.labelString:\tAdd station ...",
    "control*menubar*add.mnemonic:\t\tA", "control*menubar*scan.labelString:\tChannel scan ...",
    "control*menubar*pref.labelString:\tPreferences ...",
    "control*menubar*pref.mnemonic:\t\tP", "control*menubar*save.labelString:\tSave configuration",
    "control*menubar*save.mnemonic:\t\tS", "", "control*menubar*capture.labelString:\tCapture",
    "control*menubar*capture.mnemonic:\tC", "control*menubar*freq.labelString:\tFrequency table",
    "control*menubar*freq.mnemonic:\t\tF", "control*menubar*scale.labelString:\tScales ...",
    "control*menubar*scale.mnemonic:\t\tS", "control*menubar*scale.acceleratorText:\tS",
    "control*menubar*scale.accelerator:\t<Key>S",
    "", "control*menubar*input.labelString:\tInput",
    "control*menubar*input.mnemonic:\t\tI", "control*menubar*norm.labelString:\tTV Norm",
    "control*menubar*norm.mnemonic:\t\tN", "", "control*menubar*fnone.labelString:\tNo filter",
    "control*menubar*fnone.mnemonic:\t\tN", "", "control*menubar*man.labelString:\tShow manpage",
    "control*menubar*man.mnemonic:\t\tm", "control*menubar*about.labelString:\tAbout ...",
    "control*menubar*about.mnemonic:\t\tA", "", "control*tool.prev.toolTipString:\tprevious station",
    "control*tool.next.toolTipString:\tnext station",
    "control*tool.snap.toolTipString:\tgrab image",
    "control*tool.movie.toolTipString:\trecord movie",
    "control*tool.mute.toolTipString:\tmute audio",
    "control*tool.exit.toolTipString:\tquit",
    "", "control*box.XmPushButton*menu.del.labelString:\tDelete",
    "control*box.XmPushButton*menu.edit.labelString:\tEdit ...",
    "", "*chscan_popup.title:\t\tChannel scan", "*chscan_popup*okLabelString:\tStart", "*chscan_popup*hints.labelString:\t\tYou can let me scan all channels for\\n\tTV stations here.  This will create a\\n\tnew channel list from scratch, your\\n\tcurrent list will be lost.\\n\t\\n\tMake sure you have configured the correct\\n\tTV norm and Frequency table first (it's in\\n\tthe options menu too), otherwise the scan\\n\twill not find any station ...\\n\t\\n",
    "", "*prop_popup.title:\t\t\tEdit Station", "*prop_popup*rc.nameL.labelString:\tStation name",
    "*prop_popup*rc.keyL.labelString:\tHotkey",
    "*prop_popup*rc.groupL.labelString:\tGroup",
    "*prop_popup*rc.channelL.labelString:\tChannel",
    "*prop_popup*rc.buttons.ok.labelString:\tOK",
    "*prop_popup*rc.buttons.cancel.labelString: Cancel",
    "*prop_popup*no_name_popup.title:\tError",
    "*prop_popup*no_name_popup*messageString: \tYou have to specify a name for the TV Station",
    "", "*pref_popup.title:\t\t\tPreferences", "*pref_popup*okLabelString:\t\tSave", "*pref_popup*fsL.labelString:\t\tFullscreen",
    "*pref_popup*fsT.labelString:\t\tEnable mode switching",
    "*pref_popup*fsO.labelString:\t\tVideo mode:",
    "*pref_popup*mixL.labelString:\t\tVolume (needs restart to take effect)",
    "*pref_popup*mixT.labelString:\t\tUse mixer device for volume control",
    "*pref_popup*mix1O.labelString:\t\tmixer device:",
    "*pref_popup*mix2O.labelString:\t\tmixer control:",
    "*pref_popup*optL.labelString:\t\tOptions",
    "*pref_popup*osd.labelString:\t\tUse onscreen display in Fullscreen mode",
    "*pref_popup*keypad-ntsc.labelString:\tkeypad: ntsc mode",
    "*pref_popup*keypad-partial.labelString:\t\tkeypad: enable partial (switch on first key)",
    "*pref_popup*jpeg.label.labelString:\tJPEG quality:",
    "", "scale.title:\t\t\t\tScale controls", "scale*volume.titleString:\t\tVolume", "scale*bright.titleString:\t\tBright", "scale*hue.titleString:\t\t\tHue", "scale*color.titleString:\t\tSaturation",
    "scale*contrast.titleString:\t\tContrast",
    "", "levels.title:\t\t\t\tMonitor", "levels*enable.labelstring:\t\tenable", "", "streamer.title:\t\t\t\trecord a movie",
    "streamer*driverL.labelString:\t\tOutput format",
    "streamer*driver.labelString:\t\tDriver:",
    "streamer*videoL.labelString:\t\tVideo options",
    "streamer*video.labelString:\t\tFormat:",
    "streamer*fpsL.labelString:\t\tfps:", "streamer*audioL.labelString:\t\tAudio options",
    "streamer*audio.labelString:\t\tFormat:",
    "streamer*rateL.labelString:\t\tRate:", "streamer*fileL.labelString:\t\tFilenames",
    "streamer*fvideoL.labelString:\t\tVideo:",
    "streamer*faudioL.labelString:\t\tAudio:",
    "streamer*status.labelString:\t\tfixme",
    "", "streamer*files.labelString:\t\tBrowse ...",
    "streamer*buttons.rec.labelString:\tRecord",
    "streamer*buttons.stop.labelString:\tStop",
    "streamer*buttons.play.labelString:\tPlayback",
    "streamer*buttons.cancel.labelString:\tClose",
    "", "MoTV.man_popup.title:\t\t\tManual page",
    "MoTV.man_popup*okLabelString:\t\tclose window",
    "MoTV.man_popup*label.labelString:\tplease wait ...",
    "", "", "", "*renderTable:", "*renderTable.fontType: FONT_IS_FONTSET",
    "*renderTable.fontName:  -misc-fixed-bold-r-normal--13-*-*-*-*-*-iso10646-1,  -misc-fixed-bold-r-normal--13-*-*-*-*-*-iso8859-*  -*-*-*-*--13-*-*-*-*-*-*-*,*",
    "", "MoTV.onscreen.label.renderTable:", "MoTV.onscreen.label.renderTable.fontType: FONT_IS_FONTSET",
    "MoTV.onscreen.label.renderTable.fontName:  -misc-fixed-medium-r-normal--20-*-*-*-*-*-iso10646-1,  -misc-fixed-medium-r-normal--20-*-*-*-*-*-iso8859-*  -*-*-*-*--20-*-*-*-*-*-*-*,*",
    "", "MoTV.vtx.label.renderTable:", "MoTV.vtx.label.renderTable.fontType: FONT_IS_FONTSET",
    "MoTV.vtx.label.renderTable.fontName:  -misc-fixed-medium-r-normal--20-*-*-*-*-*-iso10646-1,  -misc-fixed-medium-r-normal--20-*-*-*-*-*-iso8859-*  -*-*-*-*--20-*-*-*-*-*-*-*,*",
    "", "", "", "MoTV.geometry:\t\t\t320x240+50+50", "MoTV.winGravity:\t\tStatic", "", "", "MoTV.tv.traversalOn:\t\tfalse", "MoTV.tv.highlightThickness:\t0", "MoTV.tv.background:\t\tblack", "MoTV.tv.translations:\t\t#replace\t\t\t\\n\t<Btn2Down>:\t\tIpc(drag)\t\t\t\\n\t<Btn3Up>:\t\tPopup(control)\t\t\t\\n\t~Alt ~Ctrl <Key>C:\tPopup(control)\t\t\t\\n\tCtrl <Key>C:\t\tIpc(clipboard)\t\t\t\\n\tAlt <Key>C:\t\tIpc(clipboard)\t\t\t\\n\t<Key>R:\t\t\tPopup(streamer)\t\t\t\\n\t<Key>S:\t\t\tPopup(scale)\t\t\t\\n\t<Key>L:\t\t\tPopup(levels)\t\t\t\\n\t<Key>T:\t\t\tStayOnTop()\t\t\t\\n\t<Key>H:\t\t\tman(motv)\t\t\t\\n\t<Key>F1:\t\tman(motv)\t\t\t\\n\t\t<Key>Q:\t\t\tCloseMain()\t\t\t\\n\t<Key>KP_Add:\t\tCommand(volume,inc)\t\t\\n\t<Key>KP_Subtract:\tCommand(volume,dec)\t\t\\n\t<Key>KP_Enter:\t\tCommand(volume,mute)\t\t\\n\t<Key>A:\t\t\tCommand(volume,mute)\t\t\\n\t<Key>F:\t\t\tCommand(fullscreen)\t\t\\n\tCtrl<Key>Z:\t\tZap(fast)\t\t\t\\n\t<Key>Z:\t\t\tZap()\t\t\t\t\\n\tCtrl<Key>G:\t\tCommand(snap,ppm,win)\t\t\\n\tCtrl<Key>J:\t\tCommand(snap,jpeg,win)\t\t\\n\t<Key>G:\t\t\tCommand(snap,ppm,full)\t\t\\n\t<Key>J:\t\t\tCommand(snap,jpeg,full)\t\t\\n\tCtrl<Key>Up:\t\tScan()\t\t\t\t\\n\t~Ctrl<Key>Up:\t\tCommand(setchannel,next)\t\\n\t<Key>Down:\t\tCommand(setchannel,prev)\t\\n\t<Key>Right:\t\tCommand(setchannel,fine_up)\t\\n\t<Key>Left:\t\tCommand(setchannel,fine_down)\t\\n\t<Key>Page_Up:\t\tCommand(setstation,next)\t\\n\t<Key>Page_Down:\t\tCommand(setstation,prev)\t\\n\t<Key>BackSpace:\t\tCommand(setstation,back)\t\\n\t<Btn4Up>:\t\tCommand(setstation,next)\t\\n\t<Btn5Up>:\t\tCommand(setstation,prev)\t\\n\t<Key>V:\t\t\tCommand(capture,toggle)\t\t\\n\t<Key>space:\t\tCommand(setstation,next)\t\\n\t\t<Key>XF86AudioRaiseVolume: Command(volume,inc)\t\t\\n\t<Key>XF86AudioLowerVolume: Command(volume,dec)\t\t\\n\t<Key>XF86AudioMute:\tCommand(volume,mute)\t\t\\n\t<Key>XF86AudioNext:\tCommand(setstation,next)\t\\n\t<Key>XF86AudioPrev:\tCommand(setstation,prev)\t\\n\t<Key>XF86AudioPlay:\tCommand(capture,on)\t\t\\n\t<Key>XF86AudioStop:\tCommand(capture,off)\t\t\\n\t\t<Key>KP_0:\t\tCommand(keypad,0)\t\t\\n\t<Key>KP_1:\t\tCommand(keypad,1)\t\t\\n\t<Key>KP_2:\t\tCommand(keypad,2)\t\t\\n\t<Key>KP_3:\t\tCommand(keypad,3)\t\t\\n\t<Key>KP_4:\t\tCommand(keypad,4)\t\t\\n\t<Key>KP_5:\t\tCommand(keypad,5)\t\t\\n\t<Key>KP_6:\t\tCommand(keypad,6)\t\t\\n\t<Key>KP_7:\t\tCommand(keypad,7)\t\t\\n\t<Key>KP_8:\t\tCommand(keypad,8)\t\t\\n\t<Key>KP_9:\t\tCommand(keypad,9)\t\t\\n\t\t<Key>osfHelp:\t\tman(motv)\t\t\t\\n\t<Key>osfActivate:\tCommand(volume,mute)\t\t\\n\tCtrl<Key>osfUp:\t\tScan()\t\t\t\t\\n\t~Ctrl<Key>osfUp:\tCommand(setchannel,next)\t\\n\t<Key>osfDown:\t\tCommand(setchannel,prev)\t\\n\t<Key>osfRight:\t\tCommand(setchannel,fine_up)\t\\n\t<Key>osfLeft:\t\tCommand(setchannel,fine_down)\t\\n\t<Key>osfPageUp:\t\tCommand(setstation,next)\t\\n\t<Key>osfPageDown:\tCommand(setstation,prev)\t\\n\t<Key>osfBackSpace:\tCommand(setstation,back)",
    "", "", "MoTV.tv*stationsM.menuPost:\t<Btn1>", "", "MoTV.about_box_popup.deleteResponse:\tDESTROY",
    "MoTV.errbox_popup.deleteResponse:\tUNMAP",
    "", "MoTV.tv*stationsM.packing:\t\tPACK_COLUMN",
    "control*menubar*stationsM.packing:\tPACK_COLUMN",
    "", "", "", "control.title:\t\t\t\tMoTV", "control.iconName:\t\t\tMoTV", "control.iconPixmap:\t\t\tTVimg", "control.iconMask:\t\t\tTVmask", "control*highlightThickness:\t\t0", "control*XmPushButton.highlightThickness: 1",
    "control.XmDialogShell*highlightThickness: 1",
    "", "control.toolTipEnable:\t\t\t1", "control.toolTipPostDelay:\t\t3000", "control.toolTipPostDuration:\t\t8000", "control*TipLabel.foreground:\t\tblack",
    "control*TipLabel.background:\t\tlightyellow",
    "control*TipShell.borderWidth:\t\t1", "control*TipShell.borderColor:\t\tblack",
    "control*tool.orientation:\t\tHORIZONTAL",
    "control*tool.?.shadowThickness:\t\t1", "control*tool.?.labelType:\t\tPIXMAP", "control*tool.XmSeparator.orientation:\tVERTICAL",
    "control*tool.XmSeparator.width:\t\t12",
    "control*tool.XmSeparator.margin:\t3", "control*tool.prev.labelPixmap:\t\tprev",
    "control*tool.next.labelPixmap:\t\tnext",
    "control*tool.snap.labelPixmap:\t\tsnap",
    "control*tool.movie.labelPixmap:\t\tmovie",
    "control*tool.mute.labelPixmap:\t\tmute",
    "control*tool.exit.labelPixmap:\t\texit",
    "", "control*menubar*XmMenuShell.XmRowColumn.tearOffModel:\tTEAR_OFF_ENABLED",
    "", "control.form.view.scrollingPolicy:\tAUTOMATIC",
    "control.form.view.scrollBarPlacement:\tBOTTOM_RIGHT",
    "control.form.view.scrolledWindowChildType: SCROLL_VERT",
    "control.form.view.box.resizeWidth:\tfalse",
    "control.form.view.box.packing:\t\tPACK_TIGHT",
    "control.form.view.box.orientation:\tHORIZONTAL",
    "control.form.view.box.entryAlignment:\tALIGNMENT_CENTER",
    "", "control.form.?.leftAttachment:\t\tATTACH_FORM",
    "control.form.?.rightAttachment:\t\tATTACH_FORM",
    "control.form.tool.topAttachment:\tATTACH_WIDGET",
    "control.form.tool.topWidget:\t\tmenubar",
    "control.form.view.topAttachment:\tATTACH_WIDGET",
    "control.form.view.topWidget:\t\ttool", "control.form.view.bottomAttachment:\tATTACH_WIDGET",
    "control.form.view.bottomWidget:\t\tstatus",
    "control.form.status.bottomAttachment:\tATTACH_FORM",
    "control.form.status.orientation:\tHORIZONTAL",
    "control.form.status.marginWidth:\t0", "control.form.status.marginHeight:\t0", "control.form.status.spacing:\t\t0", "control.form.status.f.shadowType:\tSHADOW_IN",
    "control.form.status.f.shadowThickness:\t1",
    "control.form.status.f.?.marginLeft:\t3",
    "control.form.status.f.?.marginRight:\t3",
    "control.form.status.f.?.labelString:", "", "", "", "*chscan_popup.deleteResponse:\t\tDESTROY",
    "*chscan_popup*dialogStyle:\t\tDIALOG_PRIMARY_APPLICATION_MODAL",
    "*chscan_popup*okLabelString:\t\tStart",
    "*chscan_popup*channel.editable:\t\tFalse",
    "*chscan_popup*channel.slidingMode:\tTHERMOMETER",
    "*chscan_popup*channel.orientation:\tHORIZONTAL",
    "*chscan_popup*channel.titleString:\t-",
    "*chscan_popup*channel.sliderVisual:\tSHADOWED_BACKGROUND",
    "", "", "", "*prop_popup.deleteResponse:\t\tUNMAP", "*prop_popup*rc.key.editable:\t\tfalse",
    "*prop_popup*rc.channel.visibleItemCount: 16",
    "*prop_popup*rc.channel.comboBoxType:\tDROP_DOWN_LIST",
    "*prop_popup*rc.channel.positionMode:\tONE_BASED",
    "*prop_popup*rc.keyL.marginTop:\t\t10", "*prop_popup*rc.groupL.marginTop:\t10", "*prop_popup*rc.channelL.marginTop:\t10",
    "*prop_popup*rc.XmLabel.alignment:\tALIGNMENT_BEGINNING",
    "", "*prop_popup*no_name_popup.deleteResponse: DESTROY",
    "", "", "", "*pref_popup.deleteResponse:\t\tUNMAP", "*pref_popup*fsL.frameChildType:\t\tFRAME_TITLE_CHILD",
    "*pref_popup*optL.frameChildType:\tFRAME_TITLE_CHILD",
    "*pref_popup*mixL.frameChildType:\tFRAME_TITLE_CHILD",
    "*pref_popup*jpeg.orientation:\t\tHORIZONTAL",
    "*pref_popup*jpeg.quality.columns:\t3", "", "", "", "scale.form.shadowThickness:\t\t0", "scale*XmScale.orientation:\t\tHORIZONTAL",
    "scale*XmScale.showValue:\t\ttrue", "scale*XmScale.highlightOnEnter:\t\ttrue",
    "scale*XmScale.highlightThickness:\t1", "scale*XmScale.topAttachment:\t\tATTACH_WIDGET",
    "scale*XmScale.leftAttachment:\t\tATTACH_FORM",
    "scale*XmScale.rightAttachment:\t\tATTACH_FORM",
    "scale*XmScale.topOffset:\t\t5", "scale*XmScale.BottomOffset:\t\t5", "scale*XmScale.leftOffset:\t\t10", "scale*XmScale.rightOffset:\t\t10", "scale*XmScale.width:\t\t\t160", "", "", "", "filter*label.frameChildType:\t\tFRAME_TITLE_CHILD",
    "filter*XmScale.showValue:\t\ttrue", "filter*XmScale.highlightOnEnter:\ttrue",
    "filter*XmScale.highlightThickness:\t1",
    "filter*XmScale.orientation:\t\tHORIZONTAL",
    "", "", "", "levels*highlightThickness:\t\t1", "levels*XmScale.editable:\t\tFalse", "levels*XmScale.slidingMode:\t\tTHERMOMETER",
    "levels*XmScale.orientation:\t\tHORIZONTAL",
    "levels*XmScale.sliderVisual:\t\tSHADOWED_BACKGROUND",
    "levels*XmScale.minimum:\t\t\t0", "levels*XmScale.maximum:\t\t\t128", "levels*XmScale.width:\t\t\t256", "", "", "", "streamer.title:\t\t\t\trecord a movie",
    "streamer*XmComboBox.comboBoxType:\tDROP_DOWN_COMBO_BOX",
    "streamer*XmComboBox.width:\t\t100", "streamer*XmLabel.alignment:\t\tALIGNMENT_BEGINNING",
    "", "streamer*highlightThickness:\t\t1", "", "streamer*form.?.leftAttachment:\t\t\tATTACH_FORM",
    "streamer*form.?.rightAttachment:\t\tATTACH_FORM",
    "streamer*form.?.topAttachment:\t\t\tATTACH_WIDGET",
    "streamer*form.?.topOffset:\t\t\t10", "streamer*form.?.leftOffset:\t\t\t10", "streamer*form.?.rightOffset:\t\t\t10", "streamer*form.XmFrame.marginWidth:\t\t5",
    "streamer*form.XmFrame.marginHeight:\t\t5",
    "", "streamer*XmFrame.XmRowColumn.orientation:\tHORIZONTAL",
    "streamer*XmFrame.fbox.orientation:\t\tVERTICAL",
    "streamer*XmFrame.fbox.spacing:\t\t\t0",
    "streamer*XmFrame.fbox.marginWidth:\t\t0",
    "streamer*XmFrame.fbox.marginHeight:\t\t0",
    "streamer*XmFrame.fbox.?.orientation:\t\tHORIZONTAL",
    "", "streamer*form.buttons.marginWidth:\t\t0",
    "streamer*form.buttons.packing:\t\t\tPACK_COLUMN",
    "streamer*form.buttons.orientation:\t\tHORIZONTAL",
    "streamer*form.buttons.entryAlignment:\t\tALIGNMENT_CENTER",
    "streamer*form.buttons.bottomAttachment:\t\tATTACH_FORM",
    "", "streamer*driverL.frameChildType:\tFRAME_TITLE_CHILD",
    "streamer*videoL.frameChildType:\t\tFRAME_TITLE_CHILD",
    "streamer*audioL.frameChildType:\t\tFRAME_TITLE_CHILD",
    "streamer*fileL.frameChildType:\t\tFRAME_TITLE_CHILD",
    "", "streamer*videoF.topWidget:\t\tdriverF",
    "streamer*audioF.topWidget:\t\tvideoF", "streamer*fileF.topWidget:\t\taudioF", "streamer*status.topWidget:\t\tfileF", "streamer*buttons.topWidget:\t\tstatus",
    "streamer*buttons.bottomOffset:\t\t10", "", "streamer*rate.itemCount:\t\t6", "streamer*rate.visibleItemCount:\t\t6", "streamer*rate.items:\t\t\t8000,11025,22050,32000,44100,48000",
    "streamer*rate.selectedItem:\t\t44100", "streamer*fps.itemCount:\t\t\t11", "streamer*fps.visibleItemCount:\t\t11", "streamer*fps.items:\t\t\t3,5,8,10,12,15,18,20,24,25,30",
    "streamer*fps.selectedItem:\t\t12", "", "streamer*fvideo.translations:\t\t#override\tCtrl<Key>Tab:\t\t\tComplete()",
    "streamer*faudio.translations:\t\t#override\tCtrl<Key>Tab:\t\t\tComplete()",
    "", "streamer.form.*.borderWidth:\t\t0", "", "", "", "MoTV.man_popup.deleteResponse:\t\t\tDESTROY",
    "MoTV.man_popup*view.width:\t\t\t500", "MoTV.man_popup*view.height:\t\t\t600", "MoTV.man_popup*view.scrollingPolicy:\t\tAUTOMATIC",
    "MoTV.man_popup*view.scrollBarPlacement:\t\tBOTTOM_RIGHT",
    "", "MoTV.man_popup*label.alignment:\t\t\tALIGNMENT_BEGINNING",
    "MoTV.man_popup*label.marginWidth:\t\t5",
    "MoTV.man_popup*label.marginHeight:\t\t5",
    "MoTV.man_popup*label.renderTable: bold,underline",
    "MoTV.man_popup*label.renderTable.fontType: FONT_IS_FONTSET",
    "MoTV.man_popup*label.renderTable.fontName:  -misc-fixed-medium-r-normal--13-*-*-*-*-*-iso10646-1,  -misc-fixed-medium-r-normal--13-*-*-*-*-*-iso8859-*  -*-*-*-*--13-*-*-*-*-*-*-*,*",
    "MoTV.man_popup*label.renderTable.bold.fontType: FONT_IS_FONTSET",
    "MoTV.man_popup*label.renderTable.bold.fontName:  -misc-fixed-bold-r-normal--13-*-*-*-*-*-iso10646-1,  -misc-fixed-bold-r-normal--13-*-*-*-*-*-iso8859-*  -*-*-*-*--13-*-*-*-*-*-*-*,*",
    "MoTV.man_popup*label.renderTable.underline.underlineType: SINGLE_LINE",
    "", "", "", "MoTV.onscreen.allowShellResize:\t\ttrue",
    "MoTV.onscreen*background:\t\tblack", "MoTV.onscreen*borderColor:\t\tblack", "MoTV.onscreen*foreground:\t\tlightgreen",
    "MoTV.onscreen*highlightThickness:\t0", "", "MoTV.vtx.allowShellResize:\t\ttrue", "MoTV.vtx*borderColor:\t\t\tblack", "MoTV.vtx*background:\t\t\tblack", "MoTV.vtx*foreground:\t\t\twhite", "MoTV.vtx*highlightThickness:\t\t0", "", (char *)(void *)0 };
// files_vformats
// file libng/writefile.c line 546
static struct ng_format_list files_vformats[4l] = { { .name="ppm", .desc=((char *)NULL), .ext="ppm", .fmtid=(unsigned int)9,
    .priv=NULL },
    { .name="pgm", .desc=((char *)NULL), .ext="pgm", .fmtid=(unsigned int)2,
    .priv=NULL },
    { .name="jpeg", .desc=((char *)NULL), .ext="jpeg", .fmtid=(unsigned int)17,
    .priv=NULL },
    { .name=((char *)NULL), .desc=((char *)NULL), .ext=((char *)NULL),
    .fmtid=0u, .priv=NULL } };
// files_writer
// file libng/writefile.c line 624
struct ng_writer files_writer;
// wav_aformats
// file libng/writefile.c line 606
static struct ng_format_list wav_aformats[4l] = { { .name="mono8", .desc=((char *)NULL), .ext="wav", .fmtid=(unsigned int)1,
    .priv=NULL },
    { .name="mono16", .desc=((char *)NULL), .ext="wav", .fmtid=(unsigned int)3,
    .priv=NULL },
    { .name="stereo", .desc=((char *)NULL), .ext="wav", .fmtid=(unsigned int)4,
    .priv=NULL },
    { .name=((char *)NULL), .desc=((char *)NULL), .ext=((char *)NULL),
    .fmtid=0u, .priv=NULL } };
// files_writer
// file libng/writefile.c line 624
struct ng_writer files_writer = { .name="files", .desc="multiple image files", .video=files_vformats,
    .audio=wav_aformats, .combined=0,
    .wr_open=files_open, .wr_video=files_video, .wr_audio=files_audio,
    .wr_close=files_close, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } };
// filter_attrs
// file x11/motv.c line 180
static struct filter_attribute *filter_attrs;
// filter_shell
// file x11/motv.c line 123
static struct _WidgetRec *filter_shell;
// fmt
// file x11/blit.c line 65
static struct SEARCHFORMAT fmt[15l] = { { .depth=(unsigned int)2, .order=1, .red=(unsigned long int)0x7c00, .green=(unsigned long int)0x03e0,
    .blue=(unsigned long int)0x001f, .format=(unsigned int)5 },
    { .depth=(unsigned int)2, .order=1, .red=(unsigned long int)0xf800, .green=(unsigned long int)0x07e0,
    .blue=(unsigned long int)0x001f, .format=(unsigned int)6 },
    { .depth=(unsigned int)2, .order=0, .red=(unsigned long int)0x7c00, .green=(unsigned long int)0x03e0,
    .blue=(unsigned long int)0x001f, .format=(unsigned int)3 },
    { .depth=(unsigned int)2, .order=0, .red=(unsigned long int)0xf800, .green=(unsigned long int)0x07e0,
    .blue=(unsigned long int)0x001f, .format=(unsigned int)4 },
    { .depth=(unsigned int)3, .order=0, .red=(unsigned long int)0x00ff0000, .green=(unsigned long int)0x0000ff00,
    .blue=(unsigned long int)0x000000ff,
    .format=(unsigned int)7 },
    { .depth=(unsigned int)3, .order=0, .red=(unsigned long int)0x000000ff, .green=(unsigned long int)0x0000ff00,
    .blue=(unsigned long int)0x00ff0000,
    .format=(unsigned int)9 },
    { .depth=(unsigned int)3, .order=1, .red=(unsigned long int)0x00ff0000, .green=(unsigned long int)0x0000ff00,
    .blue=(unsigned long int)0x000000ff,
    .format=(unsigned int)9 },
    { .depth=(unsigned int)3, .order=1, .red=(unsigned long int)0x000000ff, .green=(unsigned long int)0x0000ff00,
    .blue=(unsigned long int)0x00ff0000,
    .format=(unsigned int)7 },
    { .depth=(unsigned int)4, .order=0, .red=(unsigned long int)0x00ff0000, .green=(unsigned long int)0x0000ff00,
    .blue=(unsigned long int)0x000000ff,
    .format=(unsigned int)8 },
    { .depth=(unsigned int)4, .order=0, .red=(unsigned long int)0x0000ff00, .green=(unsigned long int)0x00ff0000,
    .blue=(unsigned long int)0xff000000,
    .format=(unsigned int)10 },
    { .depth=(unsigned int)4, .order=1, .red=(unsigned long int)0x00ff0000, .green=(unsigned long int)0x0000ff00,
    .blue=(unsigned long int)0x000000ff,
    .format=(unsigned int)10 },
    { .depth=(unsigned int)4, .order=1, .red=(unsigned long int)0x0000ff00, .green=(unsigned long int)0x00ff0000,
    .blue=(unsigned long int)0xff000000,
    .format=(unsigned int)8 },
    { .depth=(unsigned int)2, .order=-1, .red=(unsigned long int)0, .green=(unsigned long int)0,
    .blue=(unsigned long int)0, .format=(unsigned int)11 },
    { .depth=(unsigned int)4, .order=-1, .red=(unsigned long int)0, .green=(unsigned long int)0,
    .blue=(unsigned long int)0, .format=(unsigned int)12 },
    { .depth=(unsigned int)0, .order=0, .red=0ul, .green=0ul,
    .blue=0ul, .format=0u } };
// fo
// file x11/blit.c line 51
static struct anonymous_6 *fo;
// formats
// file x11/blit.c line 49
static signed int formats;
// freq_menu
// file x11/motv.c line 120
static struct _WidgetRec *freq_menu;
// freqtab_notify
// file common/commands.c line 49
void (*freqtab_notify)(void);
// fs
// file x11/xt.c line 84
signed int fs = 0;
// fs_height
// file common/channel.c line 80
signed int fs_height;
// fs_width
// file common/channel.c line 80
signed int fs_width;
// fs_xoff
// file common/channel.c line 80
signed int fs_xoff;
// fs_yoff
// file common/channel.c line 80
signed int fs_yoff;
// fullscreen_hook
// file common/commands.c line 60
void (*fullscreen_hook)(void);
// gl_attrib
// file x11/blit.c line 497
static signed int gl_attrib[9l] = { 4, 8, 1, 9, 1, 10, 1, 5, (signed int)0L };
// gl_error
// file x11/blit.c line 45
static signed int gl_error = 0;
// gl_formats
// file x11/blit.c line 508
struct anonymous_9 gl_formats[19l] = { { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0x80E0, .type=0x1401, .ext="GL_EXT_bgra" },
    { .fmt=0x80E1, .type=0x1401, .ext="GL_EXT_bgra" },
    { .fmt=0x1907, .type=0x1401, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) },
    { .fmt=0, .type=0, .ext=((char *)NULL) } };
// got_badwindow
// file jwz/remote.c line 53
static signed int got_badwindow = 0;
// grabbed
// file x11/xv.c line 37
static signed int grabbed;
// h_drv
// file common/commands.c line 76
void *h_drv;
// have_config
// file common/channel.c line 73
signed int have_config;
// have_dga
// file x11/xt.c line 81
signed int have_dga = 0;
// have_gl
// file x11/blit.c line 496
static signed int have_gl;
// have_randr
// file x11/xt.c line 83
signed int have_randr = 0;
// have_shmem
// file common/commands.c line 69
signed int have_shmem;
// have_vm
// file x11/xt.c line 82
signed int have_vm = 0;
// have_xv
// file x11/xv.c line 33
signed int have_xv;
// home_xpm
// file x11/xpm/home.xpm line 2
static char *home_xpm[20l] = { "16 16 3 1", " \tc #C71BC71BC71B", ".\tc #000000000000", "X\tc #861782078617", "                ", "       .        ", "   .. ...       ", "   ....X..      ", "   ...XX ..     ", "   ..XX   ..    ", "  ..XX     ..   ", " ...X      ...  ", "  X.X ...  .XXX ", "   .X . .X .X   ", "   .X . .X .X   ", "   .X . .X .X   ", "   .X . .X .X   ", "   .........X   ", "    XXXXXXXXX   ", "                " };
// i_movie_driver
// file x11/motv.c line 148
static unsigned int i_movie_driver;
// im_adaptor
// file x11/blit.c line 55
static unsigned int im_adaptor;
// im_formats
// file x11/blit.c line 56
static unsigned int im_formats[19l];
// im_port
// file x11/blit.c line 55
static unsigned int im_port = -1U;
// ipc_selections
// file x11/motv.c line 2700
struct list_head ipc_selections;
// joy_events
// file common/joystick.c line 43
static struct event_entry joy_events[7l] = { { .event={ 'j', 'o', 'y', '-', 'b', 'u', 't', 't', 'o', 'n', '-', '0', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'q', 'u', 'i', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'j', 'o', 'y', '-', 'b', 'u', 't', 't', 'o', 'n', '-', '1', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'f', 'u', 'l', 'l', 's', 'c', 'r', 'e', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'j', 'o', 'y', '-', 'a', 'x', 'i', 's', '-', 'u', 'p', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'v', 'o', 'l', 'u', 'm', 'e', ' ', 'i', 'n', 'c', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'j', 'o', 'y', '-', 'a', 'x', 'i', 's', '-', 'd', 'o', 'w', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'v', 'o', 'l', 'u', 'm', 'e', ' ', 'd', 'e', 'c', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'j', 'o', 'y', '-', 'a', 'x', 'i', 's', '-', 'l', 'e', 'f', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 'c', 'h', 'a', 'n', 'n', 'e', 'l', ' ', 'p', 'r', 'e', 'v', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'j', 'o', 'y', '-', 'a', 'x', 'i', 's', '-', 'r', 'i', 'g', 'h', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 'c', 'h', 'a', 'n', 'n', 'e', 'l', ' ', 'n', 'e', 'x', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) } };
// joytab
// file common/joystick.c line 33
static struct JOYTAB joytab[6l] = { { .class=0x01, .number=0, .value=1, .event="joy-button-0" },
    { .class=0x01, .number=1, .value=1, .event="joy-button-1" },
    { .class=0x02, .number=1, .value=-32767, .event="joy-axis-up" },
    { .class=0x02, .number=1, .value=32767, .event="joy-axis-down" },
    { .class=0x02, .number=0, .value=32767, .event="joy-axis-left" },
    { .class=0x02, .number=0, .value=-32767, .event="joy-axis-right" } };
// jpeg_quality
// file x11/motv.c line 70
signed int jpeg_quality;
// keypad_ntsc
// file common/channel.c line 74
signed int keypad_ntsc = 0;
// keypad_partial
// file common/channel.c line 75
signed int keypad_partial = 1;
// keypad_state
// file common/commands.c line 164
static signed int keypad_state = -1;
// last_sender
// file common/channel.c line 68
signed int last_sender = -1;
// launch
// file common/channel.c line 97
struct LAUNCH *launch = (struct LAUNCH *)(void *)0;
// launch_menu
// file x11/motv.c line 120
static struct _WidgetRec *launch_menu;
// left_ptr
// file x11/xt.c line 2177
unsigned long int left_ptr;
// levels_dsp
// file x11/motv.c line 3092
struct ng_dsp_driver *levels_dsp;
// levels_hdsp
// file x11/motv.c line 3093
void *levels_hdsp;
// levels_id
// file x11/motv.c line 3091
unsigned long int levels_id;
// levels_left
// file x11/motv.c line 3090
struct _WidgetRec *levels_left;
// levels_right
// file x11/motv.c line 3090
struct _WidgetRec *levels_right;
// levels_shell
// file x11/motv.c line 119
static struct _WidgetRec *levels_shell;
// levels_toggle
// file x11/motv.c line 119
static struct _WidgetRec *levels_toggle;
// lirc_events
// file common/lirc.c line 26
static struct event_entry lirc_events[19l] = { { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 'c', 'h', '+', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 's', 't', 'a', 't', 'i', 'o', 'n', ' ', 'n', 'e', 'x', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 'c', 'h', '-', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 's', 't', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'e', 'v', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 'v', 'o', 'l', '+', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'v', 'o', 'l', 'u', 'm', 'e', ' ', 'i', 'n', 'c', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 'v', 'o', 'l', '-', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'v', 'o', 'l', 'u', 'm', 'e', ' ', 'd', 'e', 'c', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 'm', 'u', 't', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'v', 'o', 'l', 'u', 'm', 'e', ' ', 'm', 'u', 't', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 'f', 'u', 'l', 'l', '_', 's', 'c', 'r', 'e', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'f', 'u', 'l', 'l', 's', 'c', 'r', 'e', 'e', 'n', ' ', 't', 'o', 'g', 'g', 'l', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 's', 'o', 'u', 'r', 'c', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 's', 'e', 't', 'i', 'n', 'p', 'u', 't', ' ', 'n', 'e', 'x', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', 'r', 'e', 's', 'e', 'r', 'v', 'e', 'd', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'q', 'u', 'i', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '0', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '0', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '1', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '1', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '2', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '2', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '3', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '3', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '4', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '4', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '5', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '5', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '6', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '6', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '7', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '7', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '8', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '8', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 'l', 'i', 'r', 'c', '-', 'k', 'e', 'y', '-', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 'k', 'e', 'y', 'p', 'a', 'd', ' ', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) },
    { .event={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .action={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .argc=0,
    .argv={ ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) }, .next=((struct event_entry *)NULL) } };
// lut2_list
// file libng/color_lut.c line 161
static struct ng_video_conv lut2_list[8l];
// lut2_list
// file libng/color_lut.c line 161
static struct ng_video_conv lut2_list[8l] = { { .fmtid_in=(unsigned int)9, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_rgb24_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)8, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr32_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)2, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)gray_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)13, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_yuv422_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv422p_to_lut2, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv420p_to_lut2, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// lut4_list
// file libng/color_lut.c line 199
static struct ng_video_conv lut4_list[8l];
// lut4_list
// file libng/color_lut.c line 199
static struct ng_video_conv lut4_list[8l] = { { .fmtid_in=(unsigned int)9, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_rgb24_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)8, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr32_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)2, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)gray_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)13, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_yuv422_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv422p_to_lut4, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv420p_to_lut4, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// m_faudio
// file x11/motv.c line 145
static struct _WidgetRec *m_faudio;
// m_faudioB
// file x11/motv.c line 145
static struct _WidgetRec *m_faudioB;
// m_faudioL
// file x11/motv.c line 145
static struct _WidgetRec *m_faudioL;
// m_fps
// file x11/motv.c line 144
static struct _WidgetRec *m_fps;
// m_fvideo
// file x11/motv.c line 144
static struct _WidgetRec *m_fvideo;
// m_rate
// file x11/motv.c line 144
static struct _WidgetRec *m_rate;
// m_status
// file x11/motv.c line 144
static struct _WidgetRec *m_status;
// man_tags
// file x11/man.c line 34
static char *man_tags[4l] = { (char *)(void *)0, (char *)(void *)0, "bold", "underline" };
// max_gl
// file x11/blit.c line 496
static signed int max_gl;
// menu_ptr
// file x11/xt.c line 2178
unsigned long int menu_ptr;
// midi
// file common/channel.c line 95
char *midi = (char *)(void *)0;
// midi_events
// file common/midictrl.c line 21
static char *midi_events[152l] = { "system", "result", "r2", "r3", "r4", "note", "noteon", "noteoff", "keypress", "r9", "controller", "pgmchange", "chanpress", "pitchbend", "control14", "nonregparam", "regparam", "r17", "r18", "r19", "songpos", "songsel", "qframe", "timesign", "keysign", "r25", "r26", "r27", "r28", "r29", "start", "continue", "stop", "setpos_tick", "setpos_time", "tempo", "clock", "tick", "r38", "r39", "tune_request", "reset", "sensing", "r43", "r44", "r45", "r46", "r47", "r48", "r49", "echo", "oss", "r52", "r53", "r54", "r55", "r56", "r57", "r58", "r59", "client_start", "client_exit", "client_change", "port_start", "port_exit", "port_change", "subscribed", "used", "unsubscribed", "unused", "sample", "sample_cluster", "sample_start", "sample_stop", "sample_freq", "sample_volume", "sample_loop", "sample_position", "sample_private1", "r79", "r80", "r81", "r82", "r83", "r84", "r85", "r86", "r87", "r88", "r89", "usr0", "usr1", "usr2", "usr3", "usr4", "usr5", "usr6", "usr7", "usr8", "usr9", "instr_begin", "instr_end", "instr_info", "instr_info_result", "instr_finfo", "instr_finfo_result", "instr_reset", "instr_status", "instr_status_result", "instr_put", "instr_get", "instr_get_result", "instr_free", "instr_list", "instr_list_result", "instr_cluster", "instr_cluster_get", "instr_cluster_result", "instr_change", "r119", "r120", "r121", "r122", "r123", "r124", "r125", "r126", "r127", "r128", "r129", "sysext", "bounce", "r132", "r133", "r134", "usr_var0", "usr_var1", "usr_var2", "usr_var3", "usr_var4", "ipcshm", "r141", "r142", "r143", "r144", "usr_varipc0", "usr_varipc1", "usr_varipc2", "usr_varipc3", "usr_varipc4", "kernel_error", "kernel_quote" };
// mixer
// file common/channel.c line 93
static char *mixer = (char *)(void *)0;
// mixerctl
// file common/channel.c line 94
char mixerctl[16l];
// mixerdev
// file common/channel.c line 94
char mixerdev[32l];
// mjpeg_quality
// file x11/motv.c line 70
signed int mjpeg_quality;
// motif_attrs
// file x11/motv.c line 171
static struct motif_attribute *motif_attrs;
// mouse_timer
// file x11/xt.c line 1797
static unsigned long int mouse_timer;
// mouse_visible
// file x11/xt.c line 1796
static signed int mouse_visible;
// mov_audio
// file common/channel.c line 86
char *mov_audio = (char *)(void *)0;
// mov_driver
// file common/channel.c line 83
char *mov_driver = (char *)(void *)0;
// mov_fps
// file common/channel.c line 85
char *mov_fps = (char *)(void *)0;
// mov_rate
// file common/channel.c line 87
char *mov_rate = (char *)(void *)0;
// mov_video
// file common/channel.c line 84
char *mov_video = (char *)(void *)0;
// move
// file x11/x11.c line 333
static signed int move = 1;
// movie_audio
// file x11/motv.c line 149
static unsigned int movie_audio;
// movie_blit
// file x11/xt.c line 87
signed int movie_blit;
// movie_driver
// file x11/motv.c line 147
static struct ng_writer *movie_driver;
// movie_hook
// file common/commands.c line 64
void (*movie_hook)(signed int, char **);
// movie_state
// file x11/xt.c line 86
void *movie_state;
// movie_video
// file x11/motv.c line 150
static unsigned int movie_video;
// movie_xpm
// file x11/xpm/movie.xpm line 2
static char *movie_xpm[20l] = { "16 16 3 1", " \tc gray77", ".\tc #000000000000", "X\tc #861782078617", "                ", "                ", "............... ", ". . . . . . . .X", "...............X", " X.XXXXXXX.XXXXX", "  .X      .X    ", "  .X      .X    ", "  .X      .X    ", "  .X      .X    ", "............... ", " . . . . . . . X", "...............X", " XXXXXXXXXXXXXXX", "                ", "                " };
// mute_notify
// file common/commands.c line 47
void (*mute_notify)(signed int);
// mute_xpm
// file x11/xpm/mute.xpm line 2
static char *mute_xpm[20l] = { "16 16 3 1", " \tc gray77", ".\tc #000000000000", "X\tc #861782078617", "                ", "         .      ", "        ..X     ", "       . .X     ", "      .  .X .   ", " .....   .X .X  ", " .       .X  .X ", " .       .X  .X ", " .       .X  .X ", " .....   .X .XX ", "  XXXX.  .X .X  ", "       . .X  X  ", "        ..X     ", "         .X     ", "          X     ", "                " };
// my_toplevels
// file x11/motv.c line 157
static struct MY_TOPLEVELS my_toplevels[5l];
// scale_shell
// file x11/motv.c line 123
static struct _WidgetRec *scale_shell;
// str_shell
// file x11/motv.c line 119
static struct _WidgetRec *str_shell;
// my_toplevels
// file x11/motv.c line 157
static struct MY_TOPLEVELS my_toplevels[5l] = { { .name="control", .shell=&control_shell, .mapped=0 },
    { .name="streamer", .shell=&str_shell, .mapped=0 },
    { .name="scale", .shell=&scale_shell, .mapped=0 },
    { .name="filter", .shell=&filter_shell, .mapped=0 },
    { .name="levels", .shell=&levels_shell, .mapped=0 } };
// nconv
// file libng/color_packed.c line 255
static const signed int nconv = (const signed int)(sizeof(struct ng_video_conv [12l]) /*672ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// nconv_link1
// file libng/color_yuv2rgb.c line 421
static const signed int nconv_link1 = (const signed int)(sizeof(struct ng_video_conv [6l]) /*336ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// nconv2
// file libng/color_lut.c line 237
static const unsigned int nconv2 = (const unsigned int)(sizeof(struct ng_video_conv [8l]) /*448ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// nconv4
// file libng/color_lut.c line 238
static const unsigned int nconv4 = (const unsigned int)(sizeof(struct ng_video_conv [8l]) /*448ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// nevent_names
// file x11/x11.c line 376
const signed int nevent_names = (const signed int)(sizeof(char *[35l]) /*280ul*/  / sizeof(char *) /*8ul*/ );
// next_xpm
// file x11/xpm/next.xpm line 2
static char *next_xpm[20l] = { "16 16 3 1", " \tc gray77", ".\tc #000000000000", "X\tc #868682828686", "                ", "                ", "        .       ", "        ..      ", "        ...     ", "        ....    ", "  ...........   ", "  ............  ", "  ...........XX ", "   XXXXX....XX  ", "        ...XX   ", "        ..XX    ", "        .XX     ", "         X      ", "                ", "                " };
// ng_aconv
// file libng/grab-ng.c line 373
struct list_head ng_aconv;
// ng_aconv
// file libng/grab-ng.c line 373
struct list_head ng_aconv = { .next=&ng_aconv, .prev=&ng_aconv };
// ng_afmt_to_bits
// file libng/grab-ng.c line 91
const unsigned int ng_afmt_to_bits[8l] = { (const unsigned int)0, (const unsigned int)8, (const unsigned int)8, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)0 };
// ng_afmt_to_channels
// file libng/grab-ng.c line 88
const unsigned int ng_afmt_to_channels[8l] = { (const unsigned int)0, (const unsigned int)1, (const unsigned int)2, (const unsigned int)1, (const unsigned int)2, (const unsigned int)1, (const unsigned int)2, (const unsigned int)0 };
// ng_afmt_to_desc
// file libng/grab-ng.c line 94
const char *ng_afmt_to_desc[8l] = { "none", "8bit mono", "8bit stereo", "16bit mono (LE)", "16bit stereo (LE)", "16bit mono (BE)", "16bit stereo (BE)", "mp3 compressed audio" };
// ng_attr_to_desc
// file libng/grab-ng.c line 107
const char *ng_attr_to_desc[10l] = { "none", "norm", "input", "volume", "mute", "audio mode", "color", "bright", "hue", "contrast" };
// ng_chromakey
// file libng/grab-ng.c line 33
signed int ng_chromakey = 0x00ff00ff;
// ng_clip
// file libng/color_yuv2rgb.c line 52
static unsigned int ng_clip[896l];
// ng_conv
// file libng/grab-ng.c line 372
struct list_head ng_conv;
// ng_conv
// file libng/grab-ng.c line 372
struct list_head ng_conv = { .next=&ng_conv, .prev=&ng_conv };
// ng_debug
// file libng/grab-ng.c line 32
signed int ng_debug = 0;
// ng_dev
// file libng/devices.c line 37
struct ng_device_config ng_dev = { .video="/dev/video0", .driver="libv4l", .radio="/dev/radio0",
    .vbi="/dev/vbi0", .dsp="/dev/dsp",
    .mixer="/dev/mixer", .video_scan={ "/dev/video0", "/dev/video1", "/dev/video2", "/dev/video3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) },
    .mixer_scan={ "/dev/mixer", "/dev/mixer1", "/dev/mixer2", "/dev/mixer3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) } };
// ng_dev_devfs
// file libng/devices.c line 60
struct ng_device_config ng_dev_devfs = { .video="/dev/v4l/video0", .driver="libv4l", .radio="/dev/v4l/radio0",
    .vbi="/dev/v4l/vbi0", .dsp="/dev/sound/dsp",
    .mixer="/dev/sound/mixer", .video_scan={ "/dev/v4l/video0", "/dev/v4l/video1", "/dev/v4l/video2", "/dev/v4l/video3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) },
    .mixer_scan={ "/dev/sound/mixer", "/dev/sound/mixer1", "/dev/sound/mixer2", "/dev/sound/mixer3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) } };
// ng_dsp_drivers
// file libng/grab-ng.c line 378
struct list_head ng_dsp_drivers;
// ng_dsp_drivers
// file libng/grab-ng.c line 378
struct list_head ng_dsp_drivers = { .next=&ng_dsp_drivers, .prev=&ng_dsp_drivers };
// ng_filters
// file libng/grab-ng.c line 374
struct list_head ng_filters;
// ng_filters
// file libng/grab-ng.c line 374
struct list_head ng_filters = { .next=&ng_filters, .prev=&ng_filters };
// ng_jpeg_quality
// file libng/grab-ng.c line 34
signed int ng_jpeg_quality = 75;
// ng_lut_blue
// file libng/grab-ng.h line 486
unsigned long int ng_lut_blue[256l];
// ng_lut_green
// file libng/grab-ng.h line 485
unsigned long int ng_lut_green[256l];
// ng_lut_red
// file libng/grab-ng.h line 484
unsigned long int ng_lut_red[256l];
// ng_mix_drivers
// file libng/grab-ng.c line 379
struct list_head ng_mix_drivers;
// ng_mix_drivers
// file libng/grab-ng.c line 379
struct list_head ng_mix_drivers = { .next=&ng_mix_drivers, .prev=&ng_mix_drivers };
// ng_ratio_x
// file libng/grab-ng.c line 35
signed int ng_ratio_x = 4;
// ng_ratio_y
// file libng/grab-ng.c line 36
signed int ng_ratio_y = 3;
// ng_readers
// file libng/grab-ng.c line 376
struct list_head ng_readers;
// ng_readers
// file libng/grab-ng.c line 376
struct list_head ng_readers = { .next=&ng_readers, .prev=&ng_readers };
// ng_v4l_conf
// file libng/grab-ng.c line 38
char ng_v4l_conf[256l] = { 'v', '4', 'l', '-', 'c', 'o', 'n', 'f', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// ng_vfmt_to_depth
// file libng/grab-ng.c line 42
const unsigned int ng_vfmt_to_depth[19l] = { (const unsigned int)0, (const unsigned int)8, (const unsigned int)8, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)24, (const unsigned int)32, (const unsigned int)24, (const unsigned int)32, (const unsigned int)16, (const unsigned int)32, (const unsigned int)16, (const unsigned int)16, (const unsigned int)12, (const unsigned int)0, (const unsigned int)0, (const unsigned int)16 };
// ng_vfmt_to_desc
// file libng/grab-ng.c line 64
const char *ng_vfmt_to_desc[19l] = { "none", "8 bit PseudoColor (dithering)", "8 bit StaticGray", "15 bit TrueColor (LE)", "16 bit TrueColor (LE)", "15 bit TrueColor (BE)", "16 bit TrueColor (BE)", "24 bit TrueColor (LE: bgr)", "32 bit TrueColor (LE: bgr-)", "24 bit TrueColor (BE: rgb)", "32 bit TrueColor (BE: -rgb)", "16 bit TrueColor (lut)", "32 bit TrueColor (lut)", "16 bit YUV 4:2:2 (packed, YUYV)", "16 bit YUV 4:2:2 (planar)", "12 bit YUV 4:2:0 (planar)", "MJPEG (AVI)", "JPEG (JFIF)", "16 bit YUV 4:2:2 (packed, UYVY)" };
// ng_vid_drivers
// file libng/grab-ng.c line 377
struct list_head ng_vid_drivers;
// ng_vid_drivers
// file libng/grab-ng.c line 377
struct list_head ng_vid_drivers = { .next=&ng_vid_drivers, .prev=&ng_vid_drivers };
// ng_writers
// file libng/grab-ng.c line 375
struct list_head ng_writers;
// ng_writers
// file libng/grab-ng.c line 375
struct list_head ng_writers = { .next=&ng_writers, .prev=&ng_writers };
// ng_yuv_blue
// file libng/color_yuv2rgb.c line 49
static unsigned int ng_yuv_blue[256l];
// ng_yuv_g1
// file libng/color_yuv2rgb.c line 50
static unsigned int ng_yuv_g1[256l];
// ng_yuv_g2
// file libng/color_yuv2rgb.c line 51
static unsigned int ng_yuv_g2[256l];
// ng_yuv_gray
// file libng/color_yuv2rgb.c line 47
static unsigned int ng_yuv_gray[256l];
// ng_yuv_red
// file libng/color_yuv2rgb.c line 48
static unsigned int ng_yuv_red[256l];
// nlaunch
// file common/channel.c line 98
signed int nlaunch = 0;
// no_mitshm
// file x11/blit.c line 44
static signed int no_mitshm = 0;
// no_ptr
// file x11/xt.c line 2180
unsigned long int no_ptr;
// nrandr
// file x11/xt.c line 103
signed int nrandr;
// nxinerama
// file x11/xt.c line 99
signed int nxinerama;
// oc
// file x11/x11.c line 335
static struct OVERLAY_CLIP oc[256l];
// oc_count
// file x11/x11.c line 331
static signed int oc_count;
// old_handler
// file jwz/remote.c line 52
static signed int (*old_handler)(struct _XDisplay *, struct anonymous *) = ((signed int (*)(struct _XDisplay *, struct anonymous *))NULL);
// on_label
// file x11/xt.c line 111
static struct _WidgetRec *on_label;
// on_shell
// file x11/xt.c line 74
struct _WidgetRec *on_shell;
// on_timer
// file x11/xt.c line 112
static unsigned long int on_timer;
// opt_count
// file x11/xt.c line 340
const signed int opt_count = (const signed int)(sizeof(struct anonymous_13 [48l]) /*1536ul*/  / sizeof(struct anonymous_13) /*32ul*/ );
// opt_desc
// file x11/xt.c line 282
struct anonymous_13 opt_desc[48l] = { { .option="-c", .specifier="device", .argKind=(enum anonymous_12)XrmoptionSepArg, .value=(char *)(void *)0 },
    { .option="-device", .specifier="device", .argKind=(enum anonymous_12)XrmoptionSepArg,
    .value=(char *)(void *)0 },
    { .option="-D", .specifier="driver", .argKind=(enum anonymous_12)XrmoptionSepArg, .value=(char *)(void *)0 },
    { .option="-driver", .specifier="driver", .argKind=(enum anonymous_12)XrmoptionSepArg,
    .value=(char *)(void *)0 },
    { .option="-C", .specifier="dspdev", .argKind=(enum anonymous_12)XrmoptionSepArg, .value=(char *)(void *)0 },
    { .option="-dspdev", .specifier="dspdev", .argKind=(enum anonymous_12)XrmoptionSepArg,
    .value=(char *)(void *)0 },
    { .option="-vbidev", .specifier="vbidev", .argKind=(enum anonymous_12)XrmoptionSepArg,
    .value=(char *)(void *)0 },
    { .option="-joydev", .specifier="joydev", .argKind=(enum anonymous_12)XrmoptionSepArg,
    .value=(char *)(void *)0 },
    { .option="-o", .specifier="basename", .argKind=(enum anonymous_12)XrmoptionSepArg, .value=(char *)(void *)0 },
    { .option="-outfile", .specifier="basename", .argKind=(enum anonymous_12)XrmoptionSepArg,
    .value=(char *)(void *)0 },
    { .option="-conffile", .specifier="conffile", .argKind=(enum anonymous_12)XrmoptionSepArg,
    .value=(char *)(void *)0 },
    { .option="-v", .specifier="debug", .argKind=(enum anonymous_12)XrmoptionSepArg, .value=(char *)(void *)0 },
    { .option="-debug", .specifier="debug", .argKind=(enum anonymous_12)XrmoptionSepArg, .value=(char *)(void *)0 },
    { .option="-b", .specifier="bpp", .argKind=(enum anonymous_12)XrmoptionSepArg, .value=(char *)(void *)0 },
    { .option="-bpp", .specifier="bpp", .argKind=(enum anonymous_12)XrmoptionSepArg, .value=(char *)(void *)0 },
    { .option="-shift", .specifier="shift", .argKind=(enum anonymous_12)XrmoptionSepArg, .value=(char *)(void *)0 },
    { .option="-xvport", .specifier="xvport", .argKind=(enum anonymous_12)XrmoptionSepArg,
    .value=(char *)(void *)0 },
    { .option="-parallel", .specifier="parallel", .argKind=(enum anonymous_12)XrmoptionSepArg,
    .value=(char *)(void *)0 },
    { .option="-bufcount", .specifier="bufcount", .argKind=(enum anonymous_12)XrmoptionSepArg,
    .value=(char *)(void *)0 },
    { .option="-alsa-cap", .specifier="alsa_cap", .argKind=(enum anonymous_12)XrmoptionSepArg,
    .value=(char *)(void *)0 },
    { .option="-alsa-pb", .specifier="alsa_pb", .argKind=(enum anonymous_12)XrmoptionSepArg,
    .value=(char *)(void *)0 },
    { .option="-alsa-latency", .specifier="alsa_latency", .argKind=(enum anonymous_12)XrmoptionSepArg,
    .value=(char *)(void *)0 },
    { .option="-remote", .specifier="remote", .argKind=(enum anonymous_12)XrmoptionNoArg,
    .value="1" },
    { .option="-n", .specifier="readconfig", .argKind=(enum anonymous_12)XrmoptionNoArg,
    .value="0" },
    { .option="-noconf", .specifier="readconfig", .argKind=(enum anonymous_12)XrmoptionNoArg,
    .value="0" },
    { .option="-f", .specifier="fullscreen", .argKind=(enum anonymous_12)XrmoptionNoArg,
    .value="1" },
    { .option="-fullscreen", .specifier="fullscreen", .argKind=(enum anonymous_12)XrmoptionNoArg,
    .value="1" },
    { .option="-hwscan", .specifier="hwscan", .argKind=(enum anonymous_12)XrmoptionNoArg,
    .value="1" },
    { .option="-fb", .specifier="fbdev", .argKind=(enum anonymous_12)XrmoptionNoArg, .value="1" },
    { .option="-xv", .specifier="xv", .argKind=(enum anonymous_12)XrmoptionNoArg, .value="1" },
    { .option="-noxv", .specifier="xv", .argKind=(enum anonymous_12)XrmoptionNoArg, .value="0" },
    { .option="-xv-video", .specifier="xvVideo", .argKind=(enum anonymous_12)XrmoptionNoArg,
    .value="1" },
    { .option="-noxv-video", .specifier="xvVideo", .argKind=(enum anonymous_12)XrmoptionNoArg,
    .value="0" },
    { .option="-xv-image", .specifier="xvImage", .argKind=(enum anonymous_12)XrmoptionNoArg,
    .value="1" },
    { .option="-noxv-image", .specifier="xvImage", .argKind=(enum anonymous_12)XrmoptionNoArg,
    .value="0" },
    { .option="-gl", .specifier="gl", .argKind=(enum anonymous_12)XrmoptionNoArg, .value="1" },
    { .option="-nogl", .specifier="gl", .argKind=(enum anonymous_12)XrmoptionNoArg, .value="0" },
    { .option="-alsa", .specifier="alsa", .argKind=(enum anonymous_12)XrmoptionNoArg, .value="1" },
    { .option="-noalsa", .specifier="alsa", .argKind=(enum anonymous_12)XrmoptionNoArg, .value="0" },
    { .option="-vm", .specifier="vidmode", .argKind=(enum anonymous_12)XrmoptionNoArg, .value="1" },
    { .option="-novm", .specifier="vidmode", .argKind=(enum anonymous_12)XrmoptionNoArg,
    .value="0" },
    { .option="-dga", .specifier="dga", .argKind=(enum anonymous_12)XrmoptionNoArg, .value="1" },
    { .option="-nodga", .specifier="dga", .argKind=(enum anonymous_12)XrmoptionNoArg, .value="0" },
    { .option="-randr", .specifier="randr", .argKind=(enum anonymous_12)XrmoptionNoArg, .value="1" },
    { .option="-norandr", .specifier="randr", .argKind=(enum anonymous_12)XrmoptionNoArg,
    .value="0" },
    { .option="-h", .specifier="help", .argKind=(enum anonymous_12)XrmoptionNoArg, .value="1" },
    { .option="-help", .specifier="help", .argKind=(enum anonymous_12)XrmoptionNoArg, .value="1" },
    { .option="--help", .specifier="help", .argKind=(enum anonymous_12)XrmoptionNoArg, .value="1" } };
// opt_menu
// file x11/motv.c line 120
static struct _WidgetRec *opt_menu;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// orig_xfree_error_handler
// file x11/xt.c line 1404
static signed int (*orig_xfree_error_handler)(struct _XDisplay *, struct anonymous *);
// osd_x
// file common/channel.c line 78
signed int osd_x = 30;
// osd_y
// file common/channel.c line 79
signed int osd_y = 20;
// output
// file common/alsa_stream.c line 51
struct _snd_output *output = (struct _snd_output *)(void *)0;
// overlay_enabled
// file x11/x11.c line 334
static signed int overlay_enabled = 0;
// overlay_on
// file x11/x11.c line 334
static signed int overlay_on = 0;
// overlay_refresh
// file x11/x11.c line 330
static unsigned long int overlay_refresh;
// pix_cols
// file common/channel.c line 81
signed int pix_cols = 1;
// pix_height
// file common/channel.c line 81
signed int pix_height = 96;
// pix_width
// file common/channel.c line 81
signed int pix_width = 128;
// pixmap_bytes
// file x11/blit.c line 42
static unsigned int pixmap_bytes = (unsigned int)0;
// pref_dlg
// file x11/motv.c line 135
static struct _WidgetRec *pref_dlg;
// pref_fs_menu
// file x11/motv.c line 135
static struct _WidgetRec *pref_fs_menu;
// pref_fs_option
// file x11/motv.c line 135
static struct _WidgetRec *pref_fs_option;
// pref_fs_toggle
// file x11/motv.c line 135
static struct _WidgetRec *pref_fs_toggle;
// pref_mix1_menu
// file x11/motv.c line 137
static struct _WidgetRec *pref_mix1_menu;
// pref_mix1_option
// file x11/motv.c line 137
static struct _WidgetRec *pref_mix1_option;
// pref_mix2_menu
// file x11/motv.c line 138
static struct _WidgetRec *pref_mix2_menu;
// pref_mix2_option
// file x11/motv.c line 138
static struct _WidgetRec *pref_mix2_option;
// pref_mix_toggle
// file x11/motv.c line 137
static struct _WidgetRec *pref_mix_toggle;
// pref_ntsc
// file x11/motv.c line 136
static struct _WidgetRec *pref_ntsc;
// pref_osd
// file x11/motv.c line 136
static struct _WidgetRec *pref_osd;
// pref_partial
// file x11/motv.c line 136
static struct _WidgetRec *pref_partial;
// pref_quality
// file x11/motv.c line 136
static struct _WidgetRec *pref_quality;
// prev_xpm
// file x11/xpm/prev.xpm line 2
static char *prev_xpm[20l] = { "16 16 3 1", " \tc gray77", ".\tc #000000000000", "X\tc #868682828686", "                ", "                ", "      .         ", "     ..X        ", "    ...X        ", "   ....X        ", "  ...........   ", " ............X  ", "  ...........X  ", "   ....XXXXXXX  ", "    ...X        ", "     ..X        ", "      .X        ", "       X        ", "                ", "                " };
// progname
// file jwz/remote.c line 46
static char *progname = "fixme";
// prop_button
// file x11/motv.c line 131
static struct _WidgetRec *prop_button;
// prop_channel
// file x11/motv.c line 131
static struct _WidgetRec *prop_channel;
// prop_dlg
// file x11/motv.c line 131
static struct _WidgetRec *prop_dlg;
// prop_group
// file x11/motv.c line 132
static struct _WidgetRec *prop_group;
// prop_key
// file x11/motv.c line 131
static struct _WidgetRec *prop_key;
// prop_name
// file x11/motv.c line 131
static struct _WidgetRec *prop_name;
// qu_ptr
// file x11/xt.c line 2179
unsigned long int qu_ptr;
// randr
// file x11/xt.c line 102
struct anonymous_20 *randr;
// randr_evbase
// file x11/xt.c line 104
signed int randr_evbase;
// raw_vformats
// file libng/writefile.c line 572
static struct ng_format_list raw_vformats[7l];
// yuv4mpeg
// file libng/writefile.c line 564
static struct raw_priv yuv4mpeg = { .yuv4mpeg=1 };
// yuv4mpeg2
// file libng/writefile.c line 568
static struct raw_priv yuv4mpeg2 = { .yuv4mpeg=2 };
// raw_vformats
// file libng/writefile.c line 572
static struct ng_format_list raw_vformats[7l] = { { .name="rgb", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)9,
    .priv=NULL },
    { .name="gray", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)2,
    .priv=NULL },
    { .name="422", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)13,
    .priv=NULL },
    { .name="422p", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)14,
    .priv=NULL },
    { .name="4mpeg", .desc="yuv4mpeg (mpeg2enc >= 1.6)", .ext="yuv",
    .fmtid=(unsigned int)15, .priv=(void *)&yuv4mpeg2 },
    { .name="4mpeg-o", .desc="yuv4mpeg (old mpeg2enc)", .ext="yuv",
    .fmtid=(unsigned int)15, .priv=(void *)&yuv4mpeg },
    { .name=((char *)NULL), .desc=((char *)NULL), .ext=((char *)NULL),
    .fmtid=0u, .priv=NULL } };
// raw_writer
// file libng/writefile.c line 635
struct ng_writer raw_writer;
// raw_writer
// file libng/writefile.c line 635
struct ng_writer raw_writer = { .name="raw", .desc="single file, raw video data", .video=raw_vformats,
    .audio=wav_aformats, .combined=0,
    .wr_open=raw_open, .wr_video=raw_video, .wr_audio=raw_audio,
    .wr_close=raw_close, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } };
// rec_status
// file common/commands.c line 37
void (*rec_status)(char *);
// rec_work_id
// file x11/motv.c line 151
static unsigned long int rec_work_id;
// rel
// file x11/blit.c line 48
static signed int rel;
// rel_link1
// file x11/xv.c line 37
static signed int rel_link1;
// req
// file x11/blit.c line 48
static signed int req;
// req_link1
// file x11/xv.c line 37
static signed int req_link1;
// scan_timer
// file x11/xt.c line 89
unsigned long int scan_timer;
// set_capture_hook
// file common/commands.c line 57
void (*set_capture_hook)(signed int, signed int, signed int);
// setfreqtab_notify
// file common/commands.c line 50
void (*setfreqtab_notify)(void);
// setstation_notify
// file common/commands.c line 51
void (*setstation_notify)(void);
// sheight
// file x11/x11.c line 322
unsigned int sheight;
// sig_id
// file x11/xt.c line 741
unsigned long int sig_id;
// sim
// file common/vbi-sim.c line 6
static struct vbi_raw_decoder sim;
// sim_time
// file common/vbi-sim.c line 7
static double sim_time;
// snap_xpm
// file x11/xpm/snap.xpm line 2
static char *snap_xpm[20l] = { "16 16 3 1", " \tc gray77", ".\tc #000000000000", "o\tc #861782078617", "                ", "                ", "                ", " .............  ", ".  .   ....   . ", ".  .  .    .  .o", ".... .  ..  . .o", ".    . .  . . .o", ".    . .  . . .o", ".    .  ..  . .o", ".     .    .  .o", ".      ....   .o", " .............oo", "  ooooooooooooo ", "                ", "                " };
// snapbase
// file common/commands.c line 68
char *snapbase = "snap";
// st_chan
// file x11/motv.c line 122
static struct _WidgetRec *st_chan;
// st_freq
// file x11/motv.c line 122
static struct _WidgetRec *st_freq;
// st_key
// file x11/motv.c line 122
static struct _WidgetRec *st_key;
// st_menu1
// file x11/motv.c line 118
static struct _WidgetRec *st_menu1;
// st_menu2
// file x11/motv.c line 118
static struct _WidgetRec *st_menu2;
// st_name
// file x11/motv.c line 122
static struct _WidgetRec *st_name;
// stay_on_top
// file x11/xt.c line 76
signed int stay_on_top = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// stop_alsa
// file common/alsa_stream.c line 48
static signed int stop_alsa = 0;
// swidth
// file x11/x11.c line 322
unsigned int swidth;
// title_timer
// file x11/xt.c line 112
static unsigned long int title_timer;
// topLevelShellWidgetClass
// file /usr/include/X11/Shell.h line 556
extern struct _WidgetClassRec *topLevelShellWidgetClass;
// transientShellWidgetClass
// file /usr/include/X11/Shell.h line 555
extern struct _WidgetClassRec *transientShellWidgetClass;
// tv
// file x11/xt.c line 73
struct _WidgetRec *tv;
// tv_xpm
// file x11/xpm/tv.xpm line 2
static char *tv_xpm[42l] = { "32 32 9 1", " \tc none", ".\tc #000000000000", "X\tc #861782078617", "o\tc #FFFF82070000", "O\tc #FFFFFFFF0000", "+\tc #0000FFFF0000", "@\tc #0000FFFFFFFF", "#\tc #FFFF00000000", "_\tc #00000000FFFF", "                                ", "                                ", "                                ", "      ..             ..         ", "      ..X            ..X        ", "       X.           .XXX        ", "         .         .X           ", "          .       .X            ", "           .     .X             ", "            .   .X              ", "             . .X               ", "    ......................      ", "    ......................X     ", "    ......ooOOO+++@@......XX    ", "    ...##oooOOO+++@@@__...XX    ", "    ..###oooOOO+++@@@___..XX    ", "    ..###oooOOO+++@@@___..XX    ", "    ..###oooOOO+++@@@___..XX    ", "    ..###oooOOO+++@@@___..XX    ", "    ..###oooOOO+++@@@___..XX    ", "    ..###oooOOO+++@@@____.XX    ", "    ..###oooOOO+++@@@___..XX    ", "    ...##oooOOO+++@@@__...XX    ", "    ......ooOOO+++@@......XX    ", "    ......................XX    ", "    ......................XX    ", "     XXXXXXXXXXXXXXXXXXXXXXX    ", "      XXXXXXXXXXXXXXXXXXXXXX    ", "                                ", "                                ", "                                ", "                                " };
// tweb
// file common/webcam.c line 105
static unsigned long int tweb;
// update_title
// file common/commands.c line 35
void (*update_title)(char *);
// use_osd
// file common/channel.c line 77
signed int use_osd = 1;
// use_wm_fullscreen
// file common/channel.c line 76
signed int use_wm_fullscreen = 1;
// vbi_colors
// file common/vbi-data.c line 22
char *vbi_colors[8l] = { "black", "red", "green", "yellow", "blue", "magenta", "cyan", "white" };
// vbi_fonts
// file x11/vbi-x11.c line 36
struct vbi_font vbi_fonts[5l] = { { .label="Teletext 20", .xlfd1="-*-teletext-medium-r-normal--20-*-*-*-*-*-iso10646-1", .xlfd2="-*-teletext-medium-r-normal--40-*-*-*-*-*-iso10646-1" },
    { .label="Teletext 10", .xlfd1="-*-teletext-medium-r-normal--10-*-*-*-*-*-iso10646-1", .xlfd2="-*-teletext-medium-r-normal--20-*-*-*-*-*-iso10646-1" },
    { .label="Fixed 18", .xlfd1="-*-fixed-medium-r-normal--18-*-*-*-*-*-iso10646-1", .xlfd2=((char *)NULL) },
    { .label="Fixed 13", .xlfd1="-misc-fixed-medium-r-semicondensed--13-*-*-*-*-*-iso10646-1", .xlfd2=((char *)NULL) },
    { .label=((char *)NULL), .xlfd1=((char *)NULL), .xlfd2=((char *)NULL) } };
// vbi_fullrect
// file common/vbi-data.c line 24
struct vbi_rect vbi_fullrect = { .x1=0, .x2=41, .y1=0, .y2=25 };
// vdr_sock
// file common/commands.c line 1290
static signed int vdr_sock = -1;
// ver
// file x11/blit.c line 48
static signed int ver;
// ver_link1
// file x11/xv.c line 37
static signed int ver_link1;
// verbose
// file common/alsa_stream.c line 53
signed int verbose = 0;
// vh
// file x11/x11.c line 115
struct video_handle vh;
// video
// file x11/x11.c line 326
static struct _WidgetRec *video;
// video_menu
// file x11/motv.c line 143
static struct _WidgetRec *video_menu;
// video_option
// file x11/motv.c line 143
static struct _WidgetRec *video_option;
// video_parent
// file x11/x11.c line 326
static struct _WidgetRec *video_parent;
// vinfo
// file x11/xt.c line 78
struct anonymous_1 vinfo;
// visibility
// file x11/x11.c line 332
static signed int visibility = 2;
// vm_count
// file x11/xt.c line 92
signed int vm_count;
// vm_dot
// file x11/xt.c line 95
signed int vm_dot;
// vm_line
// file x11/xt.c line 94
struct anonymous_64 vm_line;
// vm_modelines
// file x11/xt.c line 93
struct anonymous_15 **vm_modelines;
// volume_notify
// file common/commands.c line 48
void (*volume_notify)(void);
// vtx
// file x11/motv.c line 127
static struct vbi_window *vtx;
// vtx_subtitle
// file common/commands.c line 42
void (*vtx_subtitle)(struct vbi_page *, struct vbi_rect *);
// w_full
// file x11/motv.c line 124
static struct _WidgetRec *w_full;
// web
// file common/webcam.c line 104
static struct WEBCAM *web;
// webcam
// file common/webcam.c line 20
char *webcam;
// wfmt
// file x11/x11.c line 328
static struct ng_video_fmt wfmt;
// wm_fullscreen
// file x11/wmhooks.h line 3
void (*wm_fullscreen)(struct _XDisplay *, unsigned long int, signed int) = (void (*)(struct _XDisplay *, unsigned long int, signed int))(void *)0;
// wm_stay_on_top
// file x11/wmhooks.h line 2
void (*wm_stay_on_top)(struct _XDisplay *, unsigned long int, signed int) = (void (*)(struct _XDisplay *, unsigned long int, signed int))(void *)0;
// wmap
// file x11/x11.c line 327
static signed int wmap;
// wx
// file x11/x11.c line 327
static signed int wx;
// wy
// file x11/x11.c line 327
static signed int wy;
// x11_byteswap
// file x11/blit.c line 43
static signed int x11_byteswap = 0;
// x11_dpy_fmtid
// file x11/blit.c line 38
unsigned int x11_dpy_fmtid;
// x11_overlay_fmtid
// file x11/x11.c line 323
static signed int x11_overlay_fmtid;
// x11_vbi
// file x11/xt.c line 1835
static struct vbi_state *x11_vbi;
// x11_vbi_input
// file x11/xt.c line 1834
static unsigned long int x11_vbi_input;
// x11_vbi_page
// file x11/xt.c line 1836
static signed int x11_vbi_page;
// x11_vbi_station
// file x11/xt.c line 1837
char x11_vbi_station[64l];
// xfree_dga_error_base
// file x11/xt.c line 1300
static signed int xfree_dga_error_base;
// xinerama
// file x11/xt.c line 98
struct anonymous_59 *xinerama;
// xmCascadeButtonWidgetClass
// file /usr/include/Xm/CascadeB.h line 40
extern struct _WidgetClassRec *xmCascadeButtonWidgetClass;
// xmComboBoxWidgetClass
// file /usr/include/Xm/ComboBox.h line 38
extern struct _WidgetClassRec *xmComboBoxWidgetClass;
// xmFormWidgetClass
// file /usr/include/Xm/Form.h line 43
extern struct _WidgetClassRec *xmFormWidgetClass;
// xmFrameWidgetClass
// file /usr/include/Xm/Frame.h line 44
extern struct _WidgetClassRec *xmFrameWidgetClass;
// xmLabelWidgetClass
// file /usr/include/Xm/Label.h line 42
extern struct _WidgetClassRec *xmLabelWidgetClass;
// xmPrimitiveWidgetClass
// file /usr/include/Xm/Primitive.h line 40
extern struct _WidgetClassRec *xmPrimitiveWidgetClass;
// xmPushButtonWidgetClass
// file /usr/include/Xm/PushB.h line 56
extern struct _WidgetClassRec *xmPushButtonWidgetClass;
// xmRowColumnWidgetClass
// file /usr/include/Xm/RowColumn.h line 38
extern struct _WidgetClassRec *xmRowColumnWidgetClass;
// xmScaleWidgetClass
// file /usr/include/Xm/Scale.h line 43
extern struct _WidgetClassRec *xmScaleWidgetClass;
// xmSeparatorWidgetClass
// file /usr/include/Xm/Separator.h line 43
extern struct _WidgetClassRec *xmSeparatorWidgetClass;
// xmTextWidgetClass
// file /usr/include/Xm/Text.h line 57
extern struct _WidgetClassRec *xmTextWidgetClass;
// xmToggleButtonWidgetClass
// file /usr/include/Xm/ToggleB.h line 45
extern struct _WidgetClassRec *xmToggleButtonWidgetClass;
// xscreensaver_timer
// file x11/xt.c line 790
static unsigned long int xscreensaver_timer;
// xt_joystick
// file x11/xt.c line 2133
static signed int xt_joystick;
// xt_lirc
// file x11/xt.c line 2081
static signed int xt_lirc;
// xt_midi
// file x11/xt.c line 2104
static struct midi_handle xt_midi;
// xv_driver
// file x11/xv.c line 35
struct ng_vid_driver xv_driver;
// xv_driver
// file x11/xv.c line 35
struct ng_vid_driver xv_driver = { .name="Xvideo", .open=((void * (*)(char *, signed int))NULL), .close=xv_close,
    .get_devname=((char * (*)(void *))NULL), .capabilities=xv_flags,
    .list_attrs=xv_attrs, .get_min_size=((void (*)(void *, signed int *, signed int *))NULL),
    .setupfb=((signed int (*)(void *, struct ng_video_fmt *, void *))NULL),
    .overlay=xv_overlay,
    .setformat=((signed int (*)(void *, struct ng_video_fmt *))NULL), .startvideo=((signed int (*)(void *, signed int, unsigned int))NULL),
    .stopvideo=((void (*)(void *))NULL),
    .nextframe=((struct ng_video_buf * (*)(void *))NULL),
    .getimage=((struct ng_video_buf * (*)(void *))NULL),
    .getfreq=xv_getfreq,
    .setfreq=xv_setfreq, .is_tuned=xv_tuned,
    .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } };
// xvattr
// file x11/xv.c line 84
static struct XVATTR xvattr[29l] = { { .id=6, .type=1, .atom="XV_COLOR" }, { .id=6, .type=1, .atom="XV_SATURATION" },
    { .id=8, .type=1, .atom="XV_HUE" }, { .id=7, .type=1, .atom="XV_BRIGHTNESS" },
    { .id=9, .type=1, .atom="XV_CONTRAST" },
    { .id=-1, .type=3, .atom="XV_CHROMA_AGC" },
    { .id=-1, .type=3, .atom="XV_COMBFILTER" },
    { .id=-1, .type=3, .atom="XV_AUTOMUTE" },
    { .id=-1, .type=3, .atom="XV_LUMA_DECIMATION_FILTER" },
    { .id=-1, .type=3, .atom="XV_AGC_CRUSH" },
    { .id=-1, .type=3, .atom="XV_VCR_HACK" },
    { .id=-1, .type=3, .atom="XV_FULL_LUMA_RANGE" },
    { .id=4, .type=3, .atom="XV_MUTE" }, { .id=-1, .type=1, .atom="XV_BALANCE" },
    { .id=-1, .type=1, .atom="XV_BASS" }, { .id=-1, .type=1, .atom="XV_TREBLE" }, { .id=3, .type=1, .atom="XV_VOLUME" }, { .id=-1, .type=-1, .atom="XV_COLORKEY" },
    { .id=-1, .type=-1, .atom="XV_AUTOPAINT_COLORKEY" },
    { .id=-1, .type=-1, .atom="XV_FREQ" }, { .id=-1, .type=-1, .atom="XV_ENCODING" },
    { .id=-1, .type=-1, .atom="XV_WHITECRUSH_UPPER" },
    { .id=-1, .type=-1, .atom="XV_WHITECRUSH_LOWER" },
    { .id=-1, .type=-1, .atom="XV_UV_RATIO" },
    { .id=-1, .type=-1, .atom="XV_CORING" },
    { .id=-1, .type=-1, .atom="XV_AUTOPAINT_COLORKEY" },
    { .id=-1, .type=-1, .atom="XV_SET_DEFAULTS" },
    { .id=-1, .type=-1, .atom="XV_ITURBT_709" },
    { .id=0, .type=0, .atom=((char *)NULL) } };
// zap_fast
// file x11/xt.c line 115
static signed int zap_fast;
// zap_start
// file x11/xt.c line 115
static signed int zap_start;
// zap_timer
// file x11/xt.c line 89
unsigned long int zap_timer;

// BadWindow_ehandler
// file jwz/remote.c line 55
static signed int BadWindow_ehandler(struct _XDisplay *dpy, struct anonymous *error)
{
  if((signed int)error->error_code == 3)
  {
    got_badwindow = 1;
    return 0;
  }

  else
  {
    fprintf(stderr, "%s: ", progname);
    if(old_handler == ((signed int (*)(struct _XDisplay *, struct anonymous *))NULL))
      abort();

    signed int return_value;
    return_value=old_handler(dpy, error);
    return return_value;
  }
}

// CloseMainAction
// file x11/xt.h line 132
void CloseMainAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  char *return_value_XGetAtomName_1;
  if(!(event == ((union _XEvent *)NULL)))
  {
    if(event->type == 33)
    {
      if(!(debug == 0))
      {
        return_value_XGetAtomName_1=XGetAtomName(dpy, (unsigned long int)event->xclient.data.l[(signed long int)0]);
        fprintf(stderr, "CloseMainAction: received %s message\n", return_value_XGetAtomName_1);
      }

      if(!((unsigned long int)event->xclient.data.l[0l] == WM_DELETE_WINDOW))
        goto __CPROVER_DUMP_L4;

    }

  }

  ExitCB(widget, (void *)0, (void *)0);

__CPROVER_DUMP_L4:
  ;
}

// CommandAction
// file x11/xt.h line 171
void CommandAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  do_command((signed int)*num_params, params);
}

// CompleteAction
// file x11/complete.h line 2
void CompleteAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  char *fn;
  char *fn2;
  char *expand;
  char *dir;
  char filename[513l];
  char **list;
  struct stat st;
  signed int i;
  signed int n;
  signed int len;
  signed long int pos;
  struct passwd *pw;
  char *user;
  char pwmatch[32l];
  fn=XmTextGetString(widget);
  pos=XmTextGetInsertionPosition(widget);
  fn2=strdup(fn + pos);
  fn[pos] = (char)0;
  expand=tilde_expand(fn);
  signed int return_value_strncmp_3;
  unsigned long int return_value_strlen_11;
  unsigned long int return_value_strlen_12;
  signed int return_value_strncmp_14;
  if(!(expand == ((char *)NULL)))
  {
    list = (char **)(void *)0;
    memset((void *)filename, 0, (unsigned long int)513);
    if((signed int)*expand == 126)
    {
      char *return_value_strchr_1;
      return_value_strchr_1=strchr(expand, 47);
      if(!(return_value_strchr_1 == ((char *)NULL)))
        goto __CPROVER_DUMP_L35;

      user = &expand[(signed long int)1];
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(user);
      len = (signed int)return_value_strlen_2;
      n = 0;
      do
      {
        pw=getpwent();
        if(pw == ((struct passwd *)NULL))
          break;

        signed int return_value_strncmp_4;
        return_value_strncmp_4=strncmp(user, pw->pw_name, (unsigned long int)len);
        if(return_value_strncmp_4 == 0)
        {
          if(n == 0)
            strcpy(pwmatch, pw->pw_name);

          else
          {
            i = len;
            do
            {
              return_value_strncmp_3=strncmp(pw->pw_name, pwmatch, (unsigned long int)i);
              if(!(return_value_strncmp_3 == 0))
                break;

              i = i + 1;
            }
            while((_Bool)1);
            pwmatch[(signed long int)(i - 1)] = (char)0;
          }
          n = n + 1;
        }

      }
      while((_Bool)1);
      endpwent();
      if(n == 0)
      {
        XBell(dpy, 100);
        strcpy(filename, expand);
      }

      else
        if(n == 1)
          sprintf(filename, "~%s/", (const void *)pwmatch);

        else
          sprintf(filename, "~%s", (const void *)pwmatch);
    }

    else
    {
      static char *file;
      file=strrchr(expand, 47);
      if(!(file == ((char *)NULL)))
      {
        static char rootdir[2l] = { '/', 0 };
        if(file == expand)
          dir = rootdir;

        else
          dir = expand;
        *file = (char)0;
        file = file + 1l;
      }

      else
      {
        file = expand;
        static char thisdir[2l] = { '.', 0 };
        dir = thisdir;
      }
      n=my_scandir(dir, file, &list);
      if(n == -1)
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        char *return_value_strerror_6;
        return_value_strerror_6=strerror(*return_value___errno_location_5);
        fprintf(stderr, "%s:%d: %s: %s\n", (const void *)"x11/complete.c", 179, (const void *)"scandir", return_value_strerror_6);
        strcpy(filename, fn);
      }

      else
        if(n == 0)
        {
          XBell(dpy, 100);
          strcpy(filename, fn);
        }

        else
          if(n == 1)
          {
            sprintf(filename, "%s/%s", dir, list[(signed long int)0]);
            stat(filename, &st);
            char *return_value_strchr_8;
            return_value_strchr_8=strchr(fn, 47);
            if(!(return_value_strchr_8 == ((char *)NULL)))
            {
              strcpy(filename, fn);
              char *return_value_strrchr_7;
              return_value_strrchr_7=strrchr(filename, 47);
              return_value_strrchr_7[(signed long int)1] = (char)0;
              strcat(filename, list[(signed long int)0]);
            }

            else
              strcpy(filename, list[(signed long int)0]);
            if((61440u & st.st_mode) == 16384u)
              strcat(filename, "/");

            else
              strcat(filename, " ");
          }

          else
          {
            unsigned long int return_value_strlen_9;
            return_value_strlen_9=strlen(list[(signed long int)0]);
            unsigned long int return_value_strlen_10;
            return_value_strlen_10=strlen(list[(signed long int)(n - 1)]);
            unsigned long int tmp_if_expr_13;
            if(!(return_value_strlen_9 >= return_value_strlen_10))
            {
              return_value_strlen_11=strlen(list[(signed long int)0]);
              tmp_if_expr_13 = return_value_strlen_11;
            }

            else
            {
              return_value_strlen_12=strlen(list[(signed long int)(n - 1)]);
              tmp_if_expr_13 = return_value_strlen_12;
            }
            len = (signed int)tmp_if_expr_13;
            i = 0;
            do
            {
              return_value_strncmp_14=strncmp(list[(signed long int)0], list[(signed long int)(n - 1)], (unsigned long int)(i + 1));
              if(!(return_value_strncmp_14 == 0) || !(len >= i))
                break;

              i = i + 1;
            }
            while((_Bool)1);
            char *return_value_strchr_16;
            return_value_strchr_16=strchr(fn, 47);
            if(!(return_value_strchr_16 == ((char *)NULL)))
            {
              strcpy(filename, fn);
              char *return_value_strrchr_15;
              return_value_strrchr_15=strrchr(filename, 47);
              return_value_strrchr_15[(signed long int)1] = (char)0;
              strncat(filename, list[(signed long int)0], (unsigned long int)i);
            }

            else
              strncpy(filename, list[(signed long int)0], (unsigned long int)i);
          }
    }
    unsigned long int return_value_strlen_17;
    return_value_strlen_17=strlen(filename);
    pos = (signed long int)return_value_strlen_17;
    strcat(filename, fn2);
    XmTextSetString(widget, filename);
    XmTextSetInsertionPosition(widget, pos);
    if(!(list == ((char **)NULL)))
    {
      i = 0;
      for( ; !(i >= n); i = i + 1)
        free((void *)list[(signed long int)i]);
      free((void *)list);
    }

    free((void *)expand);
    goto __CPROVER_DUMP_L35;
  }


__CPROVER_DUMP_L35:
  ;
}

// DebugAction
// file x11/motv.c line 207
static void DebugAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  fprintf(stderr, "debug: foo\n");
}

// EventAction
// file x11/xt.h line 140
void EventAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  if(!(*num_params == 0u))
    event_dispatch(params[(signed long int)0]);

}

// ExitCB
// file x11/xt.h line 130
void ExitCB(struct _WidgetRec *widget, void *client_data, void *calldata)
{
  static signed int exit_pending = 0;
  if(exit_pending == 0)
  {
    exit_pending = 1;
    audio_off();
    video_overlay(0);
    video_close();
    do_va_cmd(2, (const void *)"capture", (const void *)"off");
    if(!(fs == 0))
      do_va_cmd(1, (const void *)"fullscreen");

    XSync(dpy, 0);
    drv->close(h_drv);
    XtAppAddWorkProc(app_context, ExitWP, (void *)0);
    XtDestroyWidget(app_shell);
  }

}

// ExitWP
// file x11/xt.c line 344
char ExitWP(void *client_data)
{
  exit(0);
}

// FilterAction
// file x11/xt.h line 139
void FilterAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  struct list_head *item;
  struct ng_filter *filter;
  cur_filter = (struct ng_filter *)(void *)0;
  if(!(*num_params == 0u))
  {
    item = (&ng_filters)->next;
    for( ; !(item == &ng_filters); item = item->next)
    {
      filter = (struct ng_filter *)((char *)item - (signed long int)(unsigned long int)&((struct ng_filter *)0)->list);
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(filter->name, params[(signed long int)0]);
      if(return_value_strcasecmp_1 == 0)
      {
        cur_filter = filter;
        break;
      }

    }
  }

}

// IpcAction
// file x11/motv.c line 3047
static void IpcAction(struct _WidgetRec *widget, union _XEvent *event, char **argv, unsigned int *argc)
{
  struct ipc_data *ipc;
  struct _WidgetRec *drag;
  struct anonymous_11 IpcAction__1__args[4l];
  unsigned int n = (unsigned int)0;
  if(!(*argc == 0u))
  {
    if((2 & f_drv) == 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "ipc: can't capture - cancel\n");

    }

    else
    {
      if(!(debug == 0))
        fprintf(stderr, "ipc: %s\n", argv[(signed long int)0]);

      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(argv[(signed long int)0], "drag");
      if(return_value_strcmp_1 == 0)
      {
        ipc_fini(_MOTIF_DROP);
        ipc=ipc_init(_MOTIF_DROP);
        ipc_iconify(widget, ipc);
        n = (unsigned int)0;
        IpcAction__1__args[(signed long int)n].name = (char *)&_XmStrings[(signed long int)6334];
        IpcAction__1__args[(signed long int)n].value = (signed long int)(1L << 1);
        n = n + 1u;
        IpcAction__1__args[(signed long int)n].name = (char *)&_XmStrings[(signed long int)9857];
        IpcAction__1__args[(signed long int)n].value = (signed long int)ipc->icon_widget;
        n = n + 1u;
        drag=XmeDragSource(tv, (void *)0, event, IpcAction__1__args, n);
        XtAddCallback(drag, (char *)&_XmStrings[(signed long int)6251], ipc_finish, (void *)0);
      }

      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(argv[(signed long int)0], "primary");
      if(return_value_strcmp_2 == 0)
        fprintf(stderr, "FIXME [primary called]\n");

      signed int return_value_strcmp_4;
      return_value_strcmp_4=strcmp(argv[(signed long int)0], "clipboard");
      if(return_value_strcmp_4 == 0)
      {
        unsigned long int return_value_XtLastTimestampProcessed_3;
        return_value_XtLastTimestampProcessed_3=XtLastTimestampProcessed(dpy);
        XmeClipboardSource(tv, (unsigned char)2, return_value_XtLastTimestampProcessed_3);
      }

    }
  }

}

// LaunchAction
// file x11/xt.h line 137
void LaunchAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  char **argv;
  signed int i;
  signed int argc;
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  if(*num_params == 1u)
  {
    i = 0;
    for( ; !(i >= nlaunch); i = i + 1)
    {
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(params[(signed long int)0], (launch + (signed long int)i)->name);
      if(return_value_strcasecmp_1 == 0)
        break;

    }
    if(!(i == nlaunch))
    {
      argv=split_cmdline((launch + (signed long int)i)->cmdline, &argc);
      signed int return_value_fork_2;
      return_value_fork_2=fork();
      if(!(return_value_fork_2 == -1))
      {
        if(return_value_fork_2 == 0)
          goto __CPROVER_DUMP_L6;

      }

      else
      {
        perror("fork");
        goto __CPROVER_DUMP_L11;

      __CPROVER_DUMP_L6:
        ;
        if(!(debug == 0))
        {
          signed int return_value_getpid_3;
          return_value_getpid_3=getpid();
          fprintf(stderr, "[%d]: exec ", return_value_getpid_3);
          i = 0;
          for( ; !(i >= argc); i = i + 1)
            fprintf(stderr, "\"%s\" ", argv[(signed long int)i]);
          fprintf(stderr, "\n");
        }

        execvp(argv[(signed long int)0], argv);
        return_value___errno_location_4=__errno_location();
        return_value_strerror_5=strerror(*return_value___errno_location_4);
        fprintf(stderr, "execvp %s: %s", argv[(signed long int)0], return_value_strerror_5);
        exit(1);
        goto __CPROVER_DUMP_L11;
      }
      goto __CPROVER_DUMP_L11;
    }

  }


__CPROVER_DUMP_L11:
  ;
}

// MyResize
// file x11/xt.h line 142
char MyResize(void *client_data)
{
  video_new_size();
  return (char)1;
}

// PopupAction
// file x11/motv.c line 341
static void PopupAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  unsigned int i;
  if(*num_params >= 1u)
  {
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 5ul); i = i + 1u)
    {
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(my_toplevels[(signed long int)i].name, params[(signed long int)0]);
      if(return_value_strcasecmp_1 == 0)
        break;

    }
    if((unsigned long int)i == 5ul)
    {
      fprintf(stderr, "PopupAction: oops: shell not found (name=%s)\n", params[(signed long int)0]);
      goto __CPROVER_DUMP_L11;
    }

  }

  else
  {
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 5ul); i = i + 1u)
      if(*my_toplevels[(signed long int)i].shell == widget)
        break;

    if((unsigned long int)i == 5ul)
    {
      char *return_value_XtName_2;
      return_value_XtName_2=XtName(widget);
      fprintf(stderr, "PopupAction: oops: shell not found (%p:%s)\n", widget, return_value_XtName_2);
      goto __CPROVER_DUMP_L11;
    }

  }
  unsigned long int return_value_XtWindow_3;
  if(my_toplevels[(signed long int)i].mapped == 0)
  {
    XtPopup(*my_toplevels[(signed long int)i].shell, (enum anonymous_17)XtGrabNone);
    if(stay_on_top >= 1 && !(wm_stay_on_top == ((void (*)(struct _XDisplay *, unsigned long int, signed int))NULL)))
    {
      return_value_XtWindow_3=XtWindow(*my_toplevels[(signed long int)i].shell);
      wm_stay_on_top(dpy, return_value_XtWindow_3, 1);
    }

    my_toplevels[(signed long int)i].mapped = 1;
  }

  else
  {
    XtPopdown(*my_toplevels[(signed long int)i].shell);
    my_toplevels[(signed long int)i].mapped = 0;
  }

__CPROVER_DUMP_L11:
  ;
}

// RatioAction
// file x11/xt.h line 136
void RatioAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  signed int w;
  signed int h;
  if(*num_params == 2u)
  {
    w=atoi(params[(signed long int)0]);
    h=atoi(params[(signed long int)1]);
    ng_ratio_x = w;
    ng_ratio_y = h;
    do_va_cmd(2, (const void *)"capture", (const void *)"off");
    do_va_cmd(2, (const void *)"capture", (const void *)"on");
  }

}

// RemoteAction
// file x11/xt.h line 172
void RemoteAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  unsigned long int type;
  signed int format;
  signed int argc;
  unsigned int i;
  char *argv[32l];
  unsigned long int nitems;
  unsigned long int bytesafter;
  unsigned char *RemoteAction__1__args = (unsigned char *)(void *)0;
  char *return_value_XGetAtomName_1;
  signed int return_value_XGetWindowProperty_5;
  unsigned long int return_value_strlen_2;
  if(event->type == 28)
  {
    if(debug >= 2)
    {
      return_value_XGetAtomName_1=XGetAtomName(dpy, event->xproperty.atom);
      fprintf(stderr, "PropertyNotify %s\n", return_value_XGetAtomName_1);
    }

    if(event->xproperty.atom == _XAWTV_REMOTE)
    {
      return_value_XGetWindowProperty_5=XGetWindowProperty(dpy, event->xproperty.window, event->xproperty.atom, (signed long int)0, (signed long int)((unsigned long int)65536 / sizeof(signed long int) /*8ul*/ ), 1, (unsigned long int)31, &type, &format, &nitems, &bytesafter, &RemoteAction__1__args);
      if(return_value_XGetWindowProperty_5 == 0)
      {
        if(!(nitems == 0ul))
        {
          i = (unsigned int)0;
          argc = 0;
          for( ; nitems >= (unsigned long int)i; i = i + (unsigned int)(return_value_strlen_2 + (unsigned long int)1))
          {
            _Bool tmp_if_expr_4;
            if((unsigned long int)i == nitems)
              tmp_if_expr_4 = (_Bool)1;

            else
              tmp_if_expr_4 = (signed int)RemoteAction__1__args[(signed long int)i] == 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_4)
            {
              argv[(signed long int)argc] = (char *)(void *)0;
              do_command(argc, argv);
              argc = 0;
            }

            else
            {
              signed int tmp_post_3 = argc;
              argc = argc + 1;
              argv[(signed long int)tmp_post_3] = (char *)(RemoteAction__1__args + (signed long int)i);
            }
            return_value_strlen_2=strlen((const char *)(RemoteAction__1__args + (signed long int)i));
          }
          XFree((void *)RemoteAction__1__args);
        }

      }

    }

  }

}

// ScanAction
// file x11/xt.h line 135
void ScanAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  if(!((4 & f_drv) == 0))
  {
    if(!(channel_switch_hook == ((void (*)(void))NULL)))
      channel_switch_hook();

    do_va_cmd(2, (const void *)"setchannel", (const void *)"next");
    scan_timer=XtAppAddTimeOut(app_context, (unsigned long int)100, scan_timeout, (void *)0);
  }

}

// VtxAction
// file x11/xt.h line 138
void VtxAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  if(!(*num_params == 0u))
  {
    signed int return_value_strcasecmp_1;
    return_value_strcasecmp_1=strcasecmp(params[(signed long int)0], "start");
    if(return_value_strcasecmp_1 == 0)
    {
      if(!(*num_params >= 3u))
        sscanf(params[(signed long int)1], "%x", &x11_vbi_page);

      if(!(debug == 0))
        fprintf(stderr, "subtitles page: %x\n", x11_vbi_page);

      x11_vbi_start(args.vbidev);
    }

    signed int return_value_strcasecmp_2;
    return_value_strcasecmp_2=strcasecmp(params[(signed long int)0], "stop");
    if(return_value_strcasecmp_2 == 0)
    {
      x11_vbi_page = 0;
      x11_vbi_stop();
      if(!(vtx_subtitle == ((void (*)(struct vbi_page *, struct vbi_rect *))NULL)))
        vtx_subtitle((struct vbi_page *)(void *)0, (struct vbi_rect *)(void *)0);

    }

  }

}

// ZapAction
// file x11/xt.h line 134
void ZapAction(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  if(!((4 & f_drv) == 0))
  {
    if(!(zap_timer == 0ul))
    {
      XtRemoveTimeOut(zap_timer);
      zap_timer = (unsigned long int)0;
    }

    else
    {
      zap_start = cur_sender == -1 ? 0 : cur_sender;
      zap_fast = 0;
      if(*num_params >= 1u)
      {
        signed int return_value_strcasecmp_1;
        return_value_strcasecmp_1=strcasecmp(params[(signed long int)0], "fast");
        if(return_value_strcasecmp_1 == 0)
          zap_fast = 1;

      }

      if(!(count == 0))
        zap_timer=XtAppAddTimeOut(app_context, (unsigned long int)100, zap_timeout, (void *)0);

    }
  }

}

// __list_add
// file ./libng/list.h line 34
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next)
{
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
}

// __list_add_link1
// file libng/list.h line 34
static inline void __list_add_link1(struct list_head *new_link1, struct list_head *prev_link1, struct list_head *next_link1)
{
  next_link1->prev = new_link1;
  new_link1->next = next_link1;
  new_link1->prev = prev_link1;
  prev_link1->next = new_link1;
}

// __list_del
// file ./libng/list.h line 77
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
  next->prev = prev;
  prev->next = next;
}

// about_cb
// file x11/motv.c line 410
static void about_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct _WidgetRec *msgbox;
  msgbox=XmCreateInformationDialog(app_shell, "about_box", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  struct _WidgetRec *return_value_XmMessageBoxGetChild_1;
  return_value_XmMessageBoxGetChild_1=XmMessageBoxGetChild(msgbox, (unsigned char)7);
  XtUnmanageChild(return_value_XmMessageBoxGetChild_1);
  struct _WidgetRec *return_value_XmMessageBoxGetChild_2;
  return_value_XmMessageBoxGetChild_2=XmMessageBoxGetChild(msgbox, (unsigned char)2);
  XtUnmanageChild(return_value_XmMessageBoxGetChild_2);
  XtAddCallback(msgbox, (char *)&_XmStrings[(signed long int)8560], destroy_cb, (void *)msgbox);
  XtManageChild(msgbox);
}

// action_cb
// file x11/motv.c line 422
static void action_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  char *calls;
  char *action;
  char *argv[8l];
  signed int argc;
  calls=strdup((const char *)clientdata);
  action=strtok(calls, "(),");
  argc = 0;
  do
  {
    argv[(signed long int)argc]=strtok((char *)(void *)0, "(),");
    if(argv[(signed long int)argc] == ((char *)NULL))
      break;

    argc = argc + 1;
  }
  while((_Bool)1);
  XtCallActionProc(widget, action, (union _XEvent *)(void *)0, argv, (unsigned int)argc);
  free((void *)calls);
}

// add_attr_option
// file x11/motv.c line 1052
static void add_attr_option(struct _WidgetRec *menu, struct ng_attribute *attr)
{
  signed int i;
  struct motif_attribute *a;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct motif_attribute) /*24ul*/ );
  a = (struct motif_attribute *)return_value_malloc_1;
  memset((void *)a, 0, sizeof(struct motif_attribute) /*24ul*/ );
  a->attr = attr;
  switch(attr->type)
  {
    case 2:
    {
      a->widget=XmCreatePulldownMenu(menu, (char *)attr->name, (struct anonymous_11 *)(void *)0, (unsigned int)0);
      XtVaCreateManagedWidget(attr->name, xmCascadeButtonWidgetClass, menu, (char *)&_XmStrings[(signed long int)9963], a->widget, (void *)0);
      i = 0;
      for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
        add_cmd_menuitem(attr->name, i, a->widget, (attr->choices + (signed long int)i)->str, (char *)(void *)0, (char *)(void *)0, 2, "setattr", attr->name, (attr->choices + (signed long int)i)->str);
      break;
    }
    case 3:
    {
      a->widget=XtVaCreateManagedWidget(attr->name, xmToggleButtonWidgetClass, menu, (void *)0);
      add_cmd_callback(a->widget, (char *)&_XmStrings[(signed long int)10591], "setattr", attr->name, "toggle");
    }
  }
  a->next = motif_attrs;
  motif_attrs = a;
}

// add_attrs
// file ./common/commands.h line 74
void add_attrs(struct ng_attribute *new)
{
  struct ng_attribute *all;
  signed int nold;
  signed int nnew;
  if(!(attrs == ((struct ng_attribute *)NULL)))
  {
    nold = 0;
    for( ; !((attrs + (signed long int)nold)->name == ((const char *)NULL)); nold = nold + 1)
      ;
  }

  else
    nold = 0;
  nnew = 0;
  for( ; !((new + (signed long int)nnew)->name == ((const char *)NULL)); nnew = nnew + 1)
    ;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)(nold + nnew + 1));
  all = (struct ng_attribute *)return_value_malloc_1;
  memset((void *)all, 0, sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)(nold + nnew + 1));
  memcpy((void *)all, (const void *)new, sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)nnew);
  if(!(attrs == ((struct ng_attribute *)NULL)))
  {
    memcpy((void *)(all + (signed long int)nnew), (const void *)attrs, sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)nold);
    free((void *)attrs);
  }

  attrs = all;
}

// add_channel
// file ./common/channel.h line 70
struct CHANNEL * add_channel(char *name)
{
  struct CHANNEL *channel;
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  if(alloc_count == count)
  {
    alloc_count = alloc_count + 16;
    if(alloc_count == 16)
    {
      return_value_malloc_1=malloc(sizeof(struct CHANNEL *) /*8ul*/  * (unsigned long int)alloc_count);
      channels = (struct CHANNEL **)return_value_malloc_1;
    }

    else
    {
      return_value_realloc_2=realloc((void *)channels, sizeof(struct CHANNEL *) /*8ul*/  * (unsigned long int)alloc_count);
      channels = (struct CHANNEL **)return_value_realloc_2;
    }
  }

  signed int tmp_post_3 = count;
  count = count + 1;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(sizeof(struct CHANNEL) /*104ul*/ );
  channels[(signed long int)tmp_post_3] = (struct CHANNEL *)return_value_malloc_4;
  channel = channels[(signed long int)tmp_post_3];
  memcpy((void *)channel, (const void *)&defaults, sizeof(struct CHANNEL) /*104ul*/ );
  channel->name=strdup(name);
  return channel;
}

// add_clip
// file x11/x11.c line 381
static void add_clip(signed int x1, signed int y1, signed int x2, signed int y2)
{
  _Bool tmp_if_expr_1;
  if(!(oc[(signed long int)oc_count].x1 == x1))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = oc[(signed long int)oc_count].y1 != y1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = oc[(signed long int)oc_count].x2 != x2 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = oc[(signed long int)oc_count].y2 != y2 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
    conf = 1;

  oc[(signed long int)oc_count].x1 = x1;
  oc[(signed long int)oc_count].y1 = y1;
  oc[(signed long int)oc_count].x2 = x2;
  oc[(signed long int)oc_count].y2 = y2;
  oc_count = oc_count + 1;
}

// add_cmd_callback
// file x11/motv.c line 991
static void add_cmd_callback(struct _WidgetRec *widget, char *callback, char *command, const char *arg1, const char *arg2)
{
  struct DO_CMD *cmd;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct DO_CMD) /*72ul*/ );
  cmd = (struct DO_CMD *)return_value_malloc_1;
  cmd->argc = 1;
  cmd->argv[(signed long int)0] = command;
  if(!(arg1 == ((const char *)NULL)))
  {
    cmd->argc = 2;
    cmd->argv[(signed long int)1] = (char *)arg1;
  }

  if(!(arg2 == ((const char *)NULL)))
  {
    cmd->argc = 3;
    cmd->argv[(signed long int)2] = (char *)arg2;
  }

  XtAddCallback(widget, callback, command_cb, (void *)cmd);
  XtAddCallback(widget, (char *)&XtStrings[(signed long int)169], free_cb, (void *)cmd);
}

// add_cmd_menuitem
// file x11/motv.c line 1012
static struct _WidgetRec * add_cmd_menuitem(const char *n, signed int nr, struct _WidgetRec *parent, const char *l, char *k, char *a, signed int toggle, char *c, const char *arg1, const char *arg2)
{
  char name[16l];
  union __XmStringRec *label;
  union __XmStringRec *accel;
  struct _WidgetRec *w;
  struct _WidgetClassRec *class;
  char *callback;
  sprintf(name, "%.10s%d", n, nr);
  label=XmStringGenerate((void *)(char *)l, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
  if(!(toggle == 0))
  {
    class = xmToggleButtonWidgetClass;
    callback = (char *)&_XmStrings[(signed long int)10591];
  }

  else
  {
    class = xmPushButtonWidgetClass;
    callback = (char *)&_XmStrings[(signed long int)4700];
  }
  if(!(a == ((char *)NULL)) && !(k == ((char *)NULL)))
  {
    accel=XmStringGenerate((void *)k, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
    w=XtVaCreateManagedWidget(name, class, parent, (char *)&_XmStrings[(signed long int)7535], label, (char *)&_XmStrings[(signed long int)4684], accel, (char *)&_XmStrings[(signed long int)4672], a, (void *)0);
  }

  else
    w=XtVaCreateManagedWidget(name, class, parent, (char *)&_XmStrings[(signed long int)7535], label, (void *)0);
  if(!(toggle == 0))
    XtVaSetValues(w, (char *)&_XmStrings[(signed long int)7324], toggle, (void *)0);

  if(!(c == ((char *)NULL)))
    add_cmd_callback(w, callback, c, arg1, arg2);

  XmStringFree(label);
  return w;
}

// add_dvb_class
// file common/get_media_devices.c line 275
static signed int add_dvb_class(struct media_device_entry *md)
{
  char *return_value_strstr_1;
  return_value_strstr_1=strstr(md->node, "video");
  if(!(return_value_strstr_1 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_VIDEO;

  char *return_value_strstr_2;
  return_value_strstr_2=strstr(md->node, "audio");
  if(!(return_value_strstr_2 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_AUDIO;

  char *return_value_strstr_3;
  return_value_strstr_3=strstr(md->node, "sec");
  if(!(return_value_strstr_3 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_SEC;

  char *return_value_strstr_9;
  return_value_strstr_9=strstr(md->node, "frontend");
  char *return_value_strstr_8;
  char *return_value_strstr_7;
  char *return_value_strstr_6;
  char *return_value_strstr_5;
  char *return_value_strstr_4;
  if(!(return_value_strstr_9 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_FRONTEND;

  else
  {
    return_value_strstr_8=strstr(md->node, "demux");
    if(!(return_value_strstr_8 == ((char *)NULL)))
      md->type = (enum device_type)MEDIA_DVB_DEMUX;

    else
    {
      return_value_strstr_7=strstr(md->node, "dvr");
      if(!(return_value_strstr_7 == ((char *)NULL)))
        md->type = (enum device_type)MEDIA_DVB_DVR;

      else
      {
        return_value_strstr_6=strstr(md->node, "net");
        if(!(return_value_strstr_6 == ((char *)NULL)))
          md->type = (enum device_type)MEDIA_DVB_NET;

        else
        {
          return_value_strstr_5=strstr(md->node, "ca");
          if(!(return_value_strstr_5 == ((char *)NULL)))
            md->type = (enum device_type)MEDIA_DVB_CA;

          else
          {
            return_value_strstr_4=strstr(md->node, "osd");
            if(!(return_value_strstr_4 == ((char *)NULL)))
              md->type = (enum device_type)MEDIA_DVB_OSD;

          }
        }
      }
    }
  }
  return 0;
}

// add_dvb_class_link1
// file common/get_media_devices.c line 275
static signed int add_dvb_class_link1(struct media_device_entry *md_link1)
{
  char *return_value_strstr_1_link1;
  return_value_strstr_1_link1=strstr(md_link1->node, "video");
  if(!(return_value_strstr_1_link1 == ((char *)NULL)))
    md_link1->type = (enum device_type)MEDIA_DVB_VIDEO;

  char *return_value_strstr_2_link1;
  return_value_strstr_2_link1=strstr(md_link1->node, "audio");
  if(!(return_value_strstr_2_link1 == ((char *)NULL)))
    md_link1->type = (enum device_type)MEDIA_DVB_AUDIO;

  char *return_value_strstr_3_link1;
  return_value_strstr_3_link1=strstr(md_link1->node, "sec");
  if(!(return_value_strstr_3_link1 == ((char *)NULL)))
    md_link1->type = (enum device_type)MEDIA_DVB_SEC;

  char *return_value_strstr_9_link1;
  return_value_strstr_9_link1=strstr(md_link1->node, "frontend");
  char *return_value_strstr_8_link1;
  char *return_value_strstr_7_link1;
  char *return_value_strstr_6_link1;
  char *return_value_strstr_5_link1;
  char *return_value_strstr_4_link1;
  if(!(return_value_strstr_9_link1 == ((char *)NULL)))
    md_link1->type = (enum device_type)MEDIA_DVB_FRONTEND;

  else
  {
    return_value_strstr_8_link1=strstr(md_link1->node, "demux");
    if(!(return_value_strstr_8_link1 == ((char *)NULL)))
      md_link1->type = (enum device_type)MEDIA_DVB_DEMUX;

    else
    {
      return_value_strstr_7_link1=strstr(md_link1->node, "dvr");
      if(!(return_value_strstr_7_link1 == ((char *)NULL)))
        md_link1->type = (enum device_type)MEDIA_DVB_DVR;

      else
      {
        return_value_strstr_6_link1=strstr(md_link1->node, "net");
        if(!(return_value_strstr_6_link1 == ((char *)NULL)))
          md_link1->type = (enum device_type)MEDIA_DVB_NET;

        else
        {
          return_value_strstr_5_link1=strstr(md_link1->node, "ca");
          if(!(return_value_strstr_5_link1 == ((char *)NULL)))
            md_link1->type = (enum device_type)MEDIA_DVB_CA;

          else
          {
            return_value_strstr_4_link1=strstr(md_link1->node, "osd");
            if(!(return_value_strstr_4_link1 == ((char *)NULL)))
              md_link1->type = (enum device_type)MEDIA_DVB_OSD;

          }
        }
      }
    }
  }
  return 0;
}

// add_pixmap
// file x11/icons.c line 22
static void add_pixmap(struct _XDisplay *dpy, unsigned long int bg, char *imgname, char *maskname, char **data)
{
  struct _XImage *image;
  struct _XImage *add_pixmap__1__shape;
  struct anonymous_133 attr;
  unsigned int x;
  unsigned int y;
  memset((void *)&attr, 0, sizeof(struct anonymous_133) /*224ul*/ );
  XpmCreateImageFromData(dpy, data, &image, &add_pixmap__1__shape, &attr);
  unsigned long int return_value;
  if(!(maskname == ((char *)NULL)))
  {
    XmInstallImage(image, imgname);
    if(!(add_pixmap__1__shape == ((struct _XImage *)NULL)))
      XmInstallImage(add_pixmap__1__shape, maskname);

  }

  else
  {
    if(!(add_pixmap__1__shape == ((struct _XImage *)NULL)))
    {
      y = (unsigned int)0;
      for( ; !(y >= attr.height); y = y + 1u)
      {
        x = (unsigned int)0;
        if(!(x >= attr.width))
        {
          return_value=add_pixmap__1__shape->f.get_pixel(add_pixmap__1__shape, (signed int)x, (signed int)y);
          if(return_value == 0ul)
            image->f.put_pixel(image, (signed int)x, (signed int)y, bg);

          x = x + 1u;
        }

      }
    }

    XmInstallImage(image, imgname);
  }
}

// add_snd_class
// file common/get_media_devices.c line 232
static signed int add_snd_class(struct media_device_entry *md)
{
  unsigned int add_snd_class__1__c = (unsigned int)65535;
  unsigned int d = (unsigned int)65535;
  char node[64l];
  char *return_value_strstr_2;
  return_value_strstr_2=strstr(md->node, "timer");
  char *return_value_strstr_1;
  if(!(return_value_strstr_2 == ((char *)NULL)))
  {
    md->type = (enum device_type)MEDIA_SND_TIMER;
    return 0;
  }

  else
  {
    return_value_strstr_1=strstr(md->node, "seq");
    if(!(return_value_strstr_1 == ((char *)NULL)))
    {
      md->type = (enum device_type)MEDIA_SND_SEQ;
      return 0;
    }

  }
  char *return_value_strstr_8;
  return_value_strstr_8=strstr(md->node, "card");
  char *return_value_strstr_7;
  char *return_value_strstr_6;
  char *return_value_strstr_5;
  unsigned long int return_value_strlen_3;
  if(!(return_value_strstr_8 == ((char *)NULL)))
  {
    sscanf(md->node, "card%u", &add_snd_class__1__c);
    md->type = (enum device_type)MEDIA_SND_CARD;
  }

  else
  {
    return_value_strstr_7=strstr(md->node, "hw");
    if(!(return_value_strstr_7 == ((char *)NULL)))
    {
      sscanf(md->node, "hwC%uD%u", &add_snd_class__1__c, &d);
      md->type = (enum device_type)MEDIA_SND_HW;
    }

    else
    {
      return_value_strstr_6=strstr(md->node, "control");
      if(!(return_value_strstr_6 == ((char *)NULL)))
      {
        sscanf(md->node, "controlC%u", &add_snd_class__1__c);
        md->type = (enum device_type)MEDIA_SND_CONTROL;
      }

      else
      {
        return_value_strstr_5=strstr(md->node, "pcm");
        if(!(return_value_strstr_5 == ((char *)NULL)))
        {
          sscanf(md->node, "pcmC%uD%u", &add_snd_class__1__c, &d);
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(md->node);
          if((signed int)md->node[-1l + (signed long int)return_value_strlen_4] == 112)
            md->type = (enum device_type)MEDIA_SND_OUT;

          else
          {
            return_value_strlen_3=strlen(md->node);
            if((signed int)md->node[-1l + (signed long int)return_value_strlen_3] == 99)
              md->type = (enum device_type)MEDIA_SND_CAP;

          }
        }

      }
    }
  }
  if(add_snd_class__1__c == 65535u)
    return 0;

  else
  {
    if(d == 65535u)
      snprintf(node, sizeof(char [64l]) /*64ul*/ , "hw:%u", add_snd_class__1__c);

    else
      snprintf(node, sizeof(char [64l]) /*64ul*/ , "hw:%u,%u", add_snd_class__1__c, d);
    free((void *)md->node);
    md->node=strdup(node);
    return 0;
  }
}

// add_snd_class_link1
// file common/get_media_devices.c line 232
static signed int add_snd_class_link1(struct media_device_entry *md_link1)
{
  unsigned int c_link1 = (unsigned int)65535;
  unsigned int d_link1 = (unsigned int)65535;
  char node_link1[64l];
  char *return_value_strstr_2_link1;
  return_value_strstr_2_link1=strstr(md_link1->node, "timer");
  char *return_value_strstr_1_link1;
  if(!(return_value_strstr_2_link1 == ((char *)NULL)))
  {
    md_link1->type = (enum device_type)MEDIA_SND_TIMER;
    return 0;
  }

  else
  {
    return_value_strstr_1_link1=strstr(md_link1->node, "seq");
    if(!(return_value_strstr_1_link1 == ((char *)NULL)))
    {
      md_link1->type = (enum device_type)MEDIA_SND_SEQ;
      return 0;
    }

  }
  char *return_value_strstr_8_link1;
  return_value_strstr_8_link1=strstr(md_link1->node, "card");
  char *return_value_strstr_7_link1;
  char *return_value_strstr_6_link1;
  char *return_value_strstr_5_link1;
  unsigned long int return_value_strlen_3_link1;
  if(!(return_value_strstr_8_link1 == ((char *)NULL)))
  {
    sscanf(md_link1->node, "card%u", &c_link1);
    md_link1->type = (enum device_type)MEDIA_SND_CARD;
  }

  else
  {
    return_value_strstr_7_link1=strstr(md_link1->node, "hw");
    if(!(return_value_strstr_7_link1 == ((char *)NULL)))
    {
      sscanf(md_link1->node, "hwC%uD%u", &c_link1, &d_link1);
      md_link1->type = (enum device_type)MEDIA_SND_HW;
    }

    else
    {
      return_value_strstr_6_link1=strstr(md_link1->node, "control");
      if(!(return_value_strstr_6_link1 == ((char *)NULL)))
      {
        sscanf(md_link1->node, "controlC%u", &c_link1);
        md_link1->type = (enum device_type)MEDIA_SND_CONTROL;
      }

      else
      {
        return_value_strstr_5_link1=strstr(md_link1->node, "pcm");
        if(!(return_value_strstr_5_link1 == ((char *)NULL)))
        {
          sscanf(md_link1->node, "pcmC%uD%u", &c_link1, &d_link1);
          unsigned long int return_value_strlen_4_link1;
          return_value_strlen_4_link1=strlen(md_link1->node);
          if((signed int)md_link1->node[-1l + (signed long int)return_value_strlen_4_link1] == 112)
            md_link1->type = (enum device_type)MEDIA_SND_OUT;

          else
          {
            return_value_strlen_3_link1=strlen(md_link1->node);
            if((signed int)md_link1->node[-1l + (signed long int)return_value_strlen_3_link1] == 99)
              md_link1->type = (enum device_type)MEDIA_SND_CAP;

          }
        }

      }
    }
  }
  if(c_link1 == 65535u)
    return 0;

  else
  {
    if(d_link1 == 65535u)
      snprintf(node_link1, sizeof(char [64l]) /*64ul*/ , "hw:%u", c_link1);

    else
      snprintf(node_link1, sizeof(char [64l]) /*64ul*/ , "hw:%u,%u", c_link1, d_link1);
    free((void *)md_link1->node);
    md_link1->node=strdup(node_link1);
    return 0;
  }
}

// add_v4l_class
// file common/get_media_devices.c line 218
static signed int add_v4l_class(struct media_device_entry *md)
{
  char *return_value_strstr_4;
  return_value_strstr_4=strstr(md->node, "video");
  char *return_value_strstr_3;
  char *return_value_strstr_2;
  char *return_value_strstr_1;
  if(!(return_value_strstr_4 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_V4L_VIDEO;

  else
  {
    return_value_strstr_3=strstr(md->node, "vbi");
    if(!(return_value_strstr_3 == ((char *)NULL)))
      md->type = (enum device_type)MEDIA_V4L_VBI;

    else
    {
      return_value_strstr_2=strstr(md->node, "radio");
      if(!(return_value_strstr_2 == ((char *)NULL)))
        md->type = (enum device_type)MEDIA_V4L_RADIO;

      else
      {
        return_value_strstr_1=strstr(md->node, "v4l-subdev");
        if(!(return_value_strstr_1 == ((char *)NULL)))
          md->type = (enum device_type)MEDIA_V4L_SUBDEV;

      }
    }
  }
  return 0;
}

// add_v4l_class_link1
// file common/get_media_devices.c line 218
static signed int add_v4l_class_link1(struct media_device_entry *md_link1)
{
  char *return_value_strstr_4_link1;
  return_value_strstr_4_link1=strstr(md_link1->node, "video");
  char *return_value_strstr_3_link1;
  char *return_value_strstr_2_link1;
  char *return_value_strstr_1_link1;
  if(!(return_value_strstr_4_link1 == ((char *)NULL)))
    md_link1->type = (enum device_type)MEDIA_V4L_VIDEO;

  else
  {
    return_value_strstr_3_link1=strstr(md_link1->node, "vbi");
    if(!(return_value_strstr_3_link1 == ((char *)NULL)))
      md_link1->type = (enum device_type)MEDIA_V4L_VBI;

    else
    {
      return_value_strstr_2_link1=strstr(md_link1->node, "radio");
      if(!(return_value_strstr_2_link1 == ((char *)NULL)))
        md_link1->type = (enum device_type)MEDIA_V4L_RADIO;

      else
      {
        return_value_strstr_1_link1=strstr(md_link1->node, "v4l-subdev");
        if(!(return_value_strstr_1_link1 == ((char *)NULL)))
          md_link1->type = (enum device_type)MEDIA_V4L_SUBDEV;

      }
    }
  }
  return 0;
}

// alsa_stream
// file common/alsa_stream.c line 470
static signed int alsa_stream(const char *pdevice, const char *cdevice, signed int latency)
{
  struct _snd_pcm *phandle;
  struct _snd_pcm *chandle;
  char *buffer;
  signed int alsa_stream__1__err;
  signed long int r;
  struct final_params negotiated;
  enum _snd_pcm_format format = (enum _snd_pcm_format)SND_PCM_FORMAT_S16_LE;
  char pdevice_new[32l];
  alsa_stream__1__err=snd_output_stdio_attach(&output, error_fp, 0);
  if(!(alsa_stream__1__err >= 0))
  {
    const char *return_value_snd_strerror_1;
    return_value_snd_strerror_1=snd_strerror(alsa_stream__1__err);
    fprintf(error_fp, "alsa: Output failed: %s\n", return_value_snd_strerror_1);
    return 0;
  }

  alsa_stream__1__err=snd_pcm_open(&phandle, pdevice, (enum _snd_pcm_stream)SND_PCM_STREAM_PLAYBACK, 0);
  if(!(alsa_stream__1__err >= 0))
  {
    const char *return_value_snd_strerror_2;
    return_value_snd_strerror_2=snd_strerror(alsa_stream__1__err);
    fprintf(error_fp, "alsa: Cannot open playback device %s: %s\n", pdevice, return_value_snd_strerror_2);
    return 0;
  }

  alsa_stream__1__err=snd_pcm_open(&chandle, cdevice, (enum _snd_pcm_stream)SND_PCM_STREAM_CAPTURE, 0x00000001);
  if(!(alsa_stream__1__err >= 0))
  {
    const char *return_value_snd_strerror_3;
    return_value_snd_strerror_3=snd_strerror(alsa_stream__1__err);
    fprintf(error_fp, "alsa: Cannot open capture device %s: %s\n", cdevice, return_value_snd_strerror_3);
    snd_pcm_close(phandle);
    return 0;
  }

  alsa_stream__1__err=setparams(phandle, chandle, format, latency, 0, &negotiated);
  signed int return_value_strncmp_5;
  if(alsa_stream__1__err == 2)
  {
    return_value_strncmp_5=strncmp(pdevice, "hw", (unsigned long int)2);
    if(return_value_strncmp_5 == 0)
    {
      snd_pcm_close(phandle);
      sprintf(pdevice_new, "plug%s", pdevice);
      pdevice = pdevice_new;
      if(!(verbose == 0))
        fprintf(error_fp, "alsa: Trying %s for playback\n", pdevice);

      alsa_stream__1__err=snd_pcm_open(&phandle, pdevice, (enum _snd_pcm_stream)SND_PCM_STREAM_PLAYBACK, 0);
      if(!(alsa_stream__1__err >= 0))
      {
        const char *return_value_snd_strerror_4;
        return_value_snd_strerror_4=snd_strerror(alsa_stream__1__err);
        fprintf(error_fp, "alsa: Cannot open playback device %s: %s\n", pdevice, return_value_snd_strerror_4);
        snd_pcm_close(chandle);
        return 0;
      }

      alsa_stream__1__err=setparams(phandle, chandle, format, latency, 1, &negotiated);
    }

  }

  signed int return_value_snd_pcm_wait_8;
  if(!(alsa_stream__1__err == 0))
  {
    fprintf(error_fp, "alsa: setparams failed\n");
    snd_pcm_close(phandle);
    snd_pcm_close(chandle);
    return 1;
  }

  else
  {
    signed int return_value_snd_pcm_format_width_6;
    return_value_snd_pcm_format_width_6=snd_pcm_format_width(format);
    void *return_value_malloc_7;
    return_value_malloc_7=malloc((unsigned long int)(((negotiated.bufsize * return_value_snd_pcm_format_width_6) / 8) * negotiated.channels));
    buffer = (char *)return_value_malloc_7;
    if(buffer == ((char *)NULL))
    {
      fprintf(error_fp, "alsa: Failed allocating buffer for audio\n");
      snd_pcm_close(phandle);
      snd_pcm_close(chandle);
      return 0;
    }

    else
    {
      if(!(verbose == 0))
        fprintf(error_fp, "alsa: stream started from %s to %s (%i Hz, buffer delay = %.2f ms)\n", cdevice, pdevice, negotiated.rate, ((double)negotiated.latency * 1000.0) / (double)negotiated.rate);

      while(stop_alsa == 0)
      {
        r=readbuf(chandle, buffer, (signed long int)negotiated.bufsize);
        if(!(r == 0l))
        {
          if(r >= 1l)
            writebuf(phandle, buffer, r);

          while(stop_alsa == 0)
          {
            return_value_snd_pcm_wait_8=snd_pcm_wait(chandle, 50);
            if(!(return_value_snd_pcm_wait_8 == 0))
              break;

          }
        }

      }
      snd_pcm_drop(chandle);
      snd_pcm_drop(phandle);
      snd_pcm_unlink(chandle);
      snd_pcm_hw_free(phandle);
      snd_pcm_hw_free(chandle);
      snd_pcm_close(phandle);
      snd_pcm_close(chandle);
      return 0;
    }
  }
}

// alsa_thread_entry
// file common/alsa_stream.c line 576
static void * alsa_thread_entry(void *whatever)
{
  struct input_params *inputs = (struct input_params *)whatever;
  if(!(verbose == 0))
    fprintf(error_fp, "alsa: starting copying alsa stream from %s to %s\n", inputs->cdevice, inputs->pdevice);

  alsa_stream(inputs->pdevice, inputs->cdevice, inputs->latency);
  if(!(verbose == 0))
    fprintf(error_fp, "alsa: stream stopped\n");

  free((void *)inputs->pdevice);
  free((void *)inputs->cdevice);
  free((void *)inputs);
  return (void *)0;
}

// alsa_thread_is_running
// file ./common/alsa_stream.h line 5
signed int alsa_thread_is_running(void)
{
  return alsa_is_running;
}

// alsa_thread_startup
// file ./common/alsa_stream.h line 1
signed int alsa_thread_startup(const char *pdevice, const char *cdevice, signed int latency, struct _IO_FILE *__error_fp, signed int __verbose)
{
  signed int ret;
  struct input_params *inputs;
  signed int return_value_strcasecmp_1;
  return_value_strcasecmp_1=strcasecmp(pdevice, "disabled");
  _Bool tmp_if_expr_3;
  signed int return_value_strcasecmp_2;
  if(return_value_strcasecmp_1 == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strcasecmp_2=strcasecmp(cdevice, "disabled");
    tmp_if_expr_3 = return_value_strcasecmp_2 == 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
    return 0;

  else
  {
    if(!(__error_fp == ((struct _IO_FILE *)NULL)))
      error_fp = __error_fp;

    else
      error_fp = stderr;
    verbose = __verbose;
    if(!(alsa_is_running == 0))
    {
      fprintf(error_fp, "alsa: Already running\n");
      return 16;
    }

    else
    {
      void *return_value_malloc_4;
      return_value_malloc_4=malloc(sizeof(struct input_params) /*24ul*/ );
      inputs = (struct input_params *)return_value_malloc_4;
      if(inputs == ((struct input_params *)NULL))
      {
        fprintf(error_fp, "alsa: failed allocating memory for inputs\n");
        return 12;
      }

      else
      {
        inputs->pdevice=strdup(pdevice);
        inputs->cdevice=strdup(cdevice);
        inputs->latency = latency;
        stop_alsa = 0;
        ret=pthread_create(&alsa_thread, (const union pthread_attr_t *)(void *)0, alsa_thread_entry, (void *)inputs);
        if(ret == 0)
          alsa_is_running = 1;

        return ret;
      }
    }
  }
}

// alsa_thread_stop
// file ./common/alsa_stream.h line 4
void alsa_thread_stop(void)
{
  if(!(alsa_is_running == 0))
  {
    stop_alsa = 1;
    pthread_join(alsa_thread, (void **)(void *)0);
    alsa_is_running = 0;
  }

}

// alsa_try_rate
// file common/alsa_stream.c line 222
static signed int alsa_try_rate(struct _snd_pcm *phandle, struct _snd_pcm *chandle, struct _snd_pcm_hw_params *p_hwparams, struct _snd_pcm_hw_params *c_hwparams, signed int allow_resample, unsigned int *ratep, unsigned int *ratec)
{
  signed int alsa_try_rate__1__err;
  alsa_try_rate__1__err=snd_pcm_hw_params_set_rate_near(chandle, c_hwparams, ratec, ((signed int *)NULL));
  if(!(alsa_try_rate__1__err == 0))
    return alsa_try_rate__1__err;

  else
  {
    *ratep = *ratec;
    alsa_try_rate__1__err=snd_pcm_hw_params_set_rate_near(phandle, p_hwparams, ratep, ((signed int *)NULL));
    if(!(alsa_try_rate__1__err == 0))
      return alsa_try_rate__1__err;

    else
      if(*ratep == *ratec)
        return 0;

      else
      {
        if(!(verbose == 0))
          fprintf(error_fp, "alsa_try_rate: capture wanted %u, playback wanted %u%s\n", *ratec, *ratep, allow_resample != 0 ? " with resample enabled" : "");

        return 1;
      }
  }
}

// attr_handler
// file common/commands.c line 833
static signed int attr_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  signed int val;
  signed int arg = 0;
  signed int return_value_strcasecmp_4;
  return_value_strcasecmp_4=strcasecmp(name, "setnorm");
  signed int return_value_strcasecmp_3;
  signed int return_value_strcasecmp_2;
  if(return_value_strcasecmp_4 == 0)
    attr=ng_attr_byname(attrs, "norm");

  else
  {
    return_value_strcasecmp_3=strcasecmp(name, "setinput");
    if(return_value_strcasecmp_3 == 0)
      attr=ng_attr_byname(attrs, "input");

    else
    {
      return_value_strcasecmp_2=strcasecmp(name, "setattr");
      if(return_value_strcasecmp_2 == 0 && argc >= 1)
      {
        signed int tmp_post_1 = arg;
        arg = arg + 1;
        attr=ng_attr_byname(attrs, argv[(signed long int)tmp_post_1]);
      }

      else
        attr=ng_attr_byname(attrs, name);
    }
  }
  if(attr == ((struct ng_attribute *)NULL))
  {
    char *tmp_if_expr_5;
    if(arg >= 1)
      tmp_if_expr_5 = argv[(signed long int)0];

    else
      tmp_if_expr_5 = name;
    fprintf(stderr, "cmd: %s: attribute not found\nvalid choices are:", tmp_if_expr_5);
    attr = attrs;
    for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
      fprintf(stderr, "%s \"%s\"", attr != attrs ? "," : "", attr->name);
    fprintf(stderr, "\n");
    return -1;
  }

  else
  {
    if(cur_movie == 0 && !(capture_get_hook == ((void (*)(void))NULL)))
      capture_get_hook();

    switch(attr->type)
    {
      case 2:
      {
        if(!(arg >= argc))
        {
          signed int return_value_strcasecmp_6;
          return_value_strcasecmp_6=strcasecmp("next", argv[(signed long int)arg]);
          if(return_value_strcasecmp_6 == 0)
          {
            val = cur_attrs[(signed long int)attr->id];
            val = val + 1;
            if((attr->choices + (signed long int)val)->str == ((const char *)NULL))
              val = 0;

          }

          else
            val=ng_attr_getint(attr, argv[(signed long int)arg]);
          if(val == -1)
          {
            fprintf(stderr, "invalid value for %s: %s\n", attr->name, argv[(signed long int)arg]);
            ng_attr_listchoices(attr);
          }

          else
          {
            set_attr(attr, val);
            set_msg_str(attr->name, (attr->choices + (signed long int)val)->str);
          }
        }

        break;
      }
      case 1:
      {
        if(!(arg >= argc))
        {
          cur_attrs[(signed long int)attr->id]=attr->read(attr);
          val=update_int(attr, cur_attrs[(signed long int)attr->id], argv[(signed long int)arg]);
          set_attr(attr, val);
        }

        set_msg_int(attr, cur_attrs[(signed long int)attr->id]);
        break;
      }
      case 3:
      {
        if(!(arg >= argc))
        {
          val=str_to_int(argv[(signed long int)arg], booltab);
          if(val == -1)
          {
            signed int return_value_strcasecmp_7;
            return_value_strcasecmp_7=strcasecmp(argv[(signed long int)arg], "toggle");
            if(return_value_strcasecmp_7 == 0)
              val = (signed int)!(cur_attrs[(signed long int)attr->id] != 0);

          }

          set_attr(attr, val);
        }

        set_msg_bool(attr->name, cur_attrs[(signed long int)attr->id]);
      }
    }
    if(cur_movie == 0 && !(capture_rel_hook == ((void (*)(void))NULL)))
      capture_rel_hook();

    return 0;
  }
}

// attr_init
// file ./common/commands.h line 68
void attr_init(void)
{
  struct ng_attribute *attr;
  signed int val;
  attr = attrs;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(attr == ((struct ng_attribute *)NULL)))
      tmp_if_expr_1 = attr->name != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    _Bool tmp_if_expr_2;
    if(attr->id == 3)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = attr->id == 4 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
    {
      val=attr->read(attr);
      if(!(attr_notify == ((void (*)(struct ng_attribute *, signed int))NULL)))
        attr_notify(attr, val);

      cur_attrs[(signed long int)attr->id] = val;
    }

    attr = attr + 1l;
  }
  while((_Bool)1);
  struct ng_attribute *return_value_ng_attr_byid_3;
  if(defaults.color == -1)
  {
    return_value_ng_attr_byid_3=ng_attr_byid(attrs, 6);
    if(!(return_value_ng_attr_byid_3 == ((struct ng_attribute *)NULL)))
      defaults.color = cur_attrs[(signed long int)6];

  }

  struct ng_attribute *return_value_ng_attr_byid_4;
  if(defaults.bright == -1)
  {
    return_value_ng_attr_byid_4=ng_attr_byid(attrs, 7);
    if(!(return_value_ng_attr_byid_4 == ((struct ng_attribute *)NULL)))
      defaults.bright = cur_attrs[(signed long int)7];

  }

  struct ng_attribute *return_value_ng_attr_byid_5;
  if(defaults.hue == -1)
  {
    return_value_ng_attr_byid_5=ng_attr_byid(attrs, 8);
    if(!(return_value_ng_attr_byid_5 == ((struct ng_attribute *)NULL)))
      defaults.hue = cur_attrs[(signed long int)8];

  }

  struct ng_attribute *return_value_ng_attr_byid_6;
  if(defaults.contrast == -1)
  {
    return_value_ng_attr_byid_6=ng_attr_byid(attrs, 9);
    if(!(return_value_ng_attr_byid_6 == ((struct ng_attribute *)NULL)))
      defaults.contrast = cur_attrs[(signed long int)9];

  }

}

// audio_init
// file ./common/commands.h line 69
void audio_init(void)
{
  struct ng_attribute *attr;
  attr=ng_attr_byid(attrs, 3);
  if(!(attr == ((struct ng_attribute *)NULL)))
    cur_attrs[(signed long int)3]=attr->read(attr);

  attr=ng_attr_byid(attrs, 4);
  if(!(attr == ((struct ng_attribute *)NULL)))
    cur_attrs[(signed long int)4]=attr->read(attr);

  if(!(volume_notify == ((void (*)(void))NULL)))
    volume_notify();

}

// audio_off
// file ./common/commands.h line 71
void audio_off(void)
{
  set_mute(1);
}

// audio_on
// file ./common/commands.h line 70
void audio_on(void)
{
  set_mute(0);
}

// bgr24_to_bgr32
// file libng/color_packed.c line 39
static void bgr24_to_bgr32(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_3 = s;
    s = s + 1l;
    *tmp_post_2 = *tmp_post_3;
    unsigned char * restrict tmp_post_4 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_5 = s;
    s = s + 1l;
    *tmp_post_4 = *tmp_post_5;
    unsigned char * restrict tmp_post_6 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_7 = s;
    s = s + 1l;
    *tmp_post_6 = *tmp_post_7;
    unsigned char * restrict tmp_post_8 = d;
    d = d + 1l;
    *tmp_post_8 = (unsigned char)0;
  }
  while((_Bool)1);
}

// bgr24_to_lut2
// file libng/color_lut.c line 43
static void bgr24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// bgr24_to_lut4
// file libng/color_lut.c line 109
static void bgr24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// bgr24_to_rgb32
// file libng/color_packed.c line 54
static void bgr24_to_rgb32(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned char)0;
    unsigned char * restrict tmp_post_3 = d;
    d = d + 1l;
    *tmp_post_3 = s[(signed long int)2];
    unsigned char * restrict tmp_post_4 = d;
    d = d + 1l;
    *tmp_post_4 = s[(signed long int)1];
    unsigned char * restrict tmp_post_5 = d;
    d = d + 1l;
    *tmp_post_5 = s[(signed long int)0];
    s = s + (signed long int)3;
  }
  while((_Bool)1);
}

// bgr32_to_lut2
// file libng/color_lut.c line 69
static void bgr32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// bgr32_to_lut4
// file libng/color_lut.c line 135
static void bgr32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// blit_fini
// file x11/blit.c line 906
void blit_fini(struct blit_state *st)
{
  free((void *)st);
}

// blit_fini_frame
// file x11/blit.h line 31
void blit_fini_frame(struct blit_state *st)
{
  struct _XDisplay *return_value_XtDisplay_3;
  unsigned long int return_value_XtWindow_4;
  switch((signed int)st->status)
  {
    case STATUS_CONVERT:
    {
      if(!(st->chandle == ((struct ng_convert_handle *)NULL)))
      {
        ng_convert_fini(st->chandle);
        st->chandle = (struct ng_convert_handle *)(void *)0;
      }

      if(!(st->ximage == ((struct _XImage *)NULL)))
      {
        struct _XDisplay *return_value_XtDisplay_1;
        return_value_XtDisplay_1=XtDisplay(st->widget);
        x11_destroy_ximage(return_value_XtDisplay_1, st->ximage, st->shm);
        st->ximage = (struct _XImage *)(void *)0;
      }

      goto __CPROVER_DUMP_L8;
    }
    case STATUS_XVIDEO:
    {
      if(!(st->xvimage == ((struct anonymous_3 *)NULL)))
      {
        struct _XDisplay *return_value_XtDisplay_2;
        return_value_XtDisplay_2=XtDisplay(st->widget);
        xv_destroy_ximage(return_value_XtDisplay_2, st->xvimage, st->shm);
        st->xvimage = (struct anonymous_3 *)(void *)0;
      }

      return_value_XtDisplay_3=XtDisplay(st->widget);
      return_value_XtWindow_4=XtWindow(st->widget);
      XvStopVideo(return_value_XtDisplay_3, (unsigned long int)im_port, return_value_XtWindow_4);
      goto __CPROVER_DUMP_L8;
    }
    case STATUS_OPENGL:
    {
      gl_cleanup(st->tex);
      goto __CPROVER_DUMP_L8;
    }
    case STATUS_UNKNOWN:

    case STATUS_BROKEN:
      ;
    default:
    {

    __CPROVER_DUMP_L8:
      ;
      memset((void *)&st->fmt, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
      memset((void *)&st->buf, 0, sizeof(struct ng_video_buf) /*160ul*/ );
      st->status = (enum blit_status)STATUS_UNKNOWN;
    }
  }
}

// blit_get_formats
// file x11/blit.h line 28
void blit_get_formats(struct blit_state *st, signed int *fmtids, signed int max)
{
  struct ng_video_conv *conv;
  signed int i;
  signed int n = 0;
  if(st == ((struct blit_state *)NULL))
  {
    fprintf(stderr, "BUG: %s [%s:%d]\n", (const void *)"blit handle is NULL", (const void *)"x11/blit.c", 728);
    exit(1);
  }

  i = 0;
  for( ; !(i >= 19); i = i + 1)
  {
    if(!(im_formats[(signed long int)i] == 0u))
    {
      signed int tmp_post_1 = n;
      n = n + 1;
      fmtids[(signed long int)tmp_post_1] = i;
    }

    if(n == max)
      goto __CPROVER_DUMP_L18;

  }
  signed int return_value_gl_ext_3;
  if(!(have_gl == 0))
  {
    i = 0;
    for( ; !(i >= 19); i = i + 1)
    {
      if(!(gl_formats[(signed long int)i].fmt == 0))
      {
        _Bool tmp_if_expr_4;
        if(gl_formats[(signed long int)i].ext == ((char *)NULL))
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_gl_ext_3=gl_ext((unsigned char *)gl_formats[(signed long int)i].ext);
          tmp_if_expr_4 = return_value_gl_ext_3 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          signed int tmp_post_2 = n;
          n = n + 1;
          fmtids[(signed long int)tmp_post_2] = i;
        }

      }

      if(n == max)
        goto __CPROVER_DUMP_L18;

    }
  }

  signed int tmp_post_5 = n;
  n = n + 1;
  fmtids[(signed long int)tmp_post_5] = (signed int)x11_dpy_fmtid;
  if(!(n == max))
  {
    i = 0;
    do
    {
      conv=ng_conv_find_to(x11_dpy_fmtid, &i);
      if(conv == ((struct ng_video_conv *)NULL))
        break;

      signed int tmp_post_6 = n;
      n = n + 1;
      fmtids[(signed long int)tmp_post_6] = (signed int)conv->fmtid_in;
      if(n == max)
        goto __CPROVER_DUMP_L18;

    }
    while((_Bool)1);
    for( ; !(n >= max); n = n + 1)
      fmtids[(signed long int)n] = 0;
  }


__CPROVER_DUMP_L18:
  ;
}

// blit_init
// file x11/blit.h line 27
struct blit_state * blit_init(struct _WidgetRec *widget, struct anonymous_1 *vinfo, signed int use_gl)
{
  struct blit_state *st;
  if(!(debug == 0))
    fprintf(stderr, "blit: init\n");

  unsigned long int return_value_XtWindow_1;
  return_value_XtWindow_1=XtWindow(widget);
  if(return_value_XtWindow_1 == 0ul)
  {
    fprintf(stderr, "BUG: %s [%s:%d]\n", (const void *)"no blit window", (const void *)"x11/blit.c", 707);
    exit(1);
  }

  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct blit_state) /*288ul*/ );
  st = (struct blit_state *)return_value_malloc_2;
  memset((void *)st, 0, sizeof(struct blit_state) /*288ul*/ );
  st->widget = widget;
  st->vinfo = vinfo;
  struct _XDisplay *return_value_XtDisplay_3;
  return_value_XtDisplay_3=XtDisplay(st->widget);
  unsigned long int return_value_XtWindow_4;
  return_value_XtWindow_4=XtWindow(st->widget);
  st->gc=XCreateGC(return_value_XtDisplay_3, return_value_XtWindow_4, (unsigned long int)0, (struct anonymous_75 *)(void *)0);
  if(!(use_gl == 0))
    gl_init(st->widget);

  return st;
}

// blit_init_frame
// file x11/blit.c line 785
void blit_init_frame(struct blit_state *st, struct ng_video_fmt *fmt)
{
  struct ng_video_conv *conv;
  signed int i;
  if(!(im_formats[(signed long int)fmt->fmtid] == 0u))
  {
    struct _XDisplay *return_value_XtDisplay_1;
    return_value_XtDisplay_1=XtDisplay(st->widget);
    st->xvimage=xv_create_ximage(return_value_XtDisplay_1, (signed int)fmt->width, (signed int)fmt->height, (signed int)im_formats[(signed long int)fmt->fmtid], &st->shm);
    st->buf.fmt = *fmt;
    st->status = (enum blit_status)STATUS_XVIDEO;
    if(!(debug == 0))
      fprintf(stderr, "blit: %dx%d/[%s] => Xvideo\n", fmt->width, fmt->height, ng_vfmt_to_desc[(signed long int)fmt->fmtid]);

    goto __CPROVER_DUMP_L18;
  }

  signed int return_value_gl_ext_3;
  signed int return_value_gl_resize_2;
  if(!(have_gl == 0))
  {
    if(!(gl_formats[(signed long int)fmt->fmtid].fmt == 0))
    {
      _Bool tmp_if_expr_4;
      if(gl_formats[(signed long int)fmt->fmtid].ext == ((char *)NULL))
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value_gl_ext_3=gl_ext((unsigned char *)gl_formats[(signed long int)fmt->fmtid].ext);
        tmp_if_expr_4 = return_value_gl_ext_3 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
      {
        return_value_gl_resize_2=gl_resize((signed int)fmt->width, (signed int)fmt->height, (signed int)st->win_width, (signed int)st->win_height, &st->tex, &st->tw, &st->th, gl_formats[(signed long int)fmt->fmtid].fmt, gl_formats[(signed long int)fmt->fmtid].type);
        if(return_value_gl_resize_2 == 0)
        {
          st->buf.fmt = *fmt;
          st->status = (enum blit_status)STATUS_OPENGL;
          if(!(debug == 0))
            fprintf(stderr, "blit: %dx%d/[%s] => OpenGL\n", fmt->width, fmt->height, ng_vfmt_to_desc[(signed long int)fmt->fmtid]);

          goto __CPROVER_DUMP_L18;
        }

      }

    }

  }

  struct _XDisplay *return_value_XtDisplay_5;
  return_value_XtDisplay_5=XtDisplay(st->widget);
  st->ximage=x11_create_ximage(return_value_XtDisplay_5, st->vinfo, (signed int)fmt->width, (signed int)fmt->height, &st->shm);
  st->buf.data = (unsigned char *)st->ximage->data;
  if(x11_dpy_fmtid == fmt->fmtid)
  {
    st->buf.fmt = *fmt;
    st->status = (enum blit_status)STATUS_CONVERT;
    if(!(debug == 0))
      fprintf(stderr, "blit: %dx%d/[%s] => X11 direct\n", fmt->width, fmt->height, ng_vfmt_to_desc[(signed long int)fmt->fmtid]);

  }

  else
  {
    i = 0;
    do
    {
      conv=ng_conv_find_to(x11_dpy_fmtid, &i);
      if(conv == ((struct ng_video_conv *)NULL))
      {
        st->status = (enum blit_status)STATUS_BROKEN;
        if(!(debug == 0))
          fprintf(stderr, "blit: %dx%d/[%s] => can't display\n", fmt->width, fmt->height, ng_vfmt_to_desc[(signed long int)fmt->fmtid]);

        goto __CPROVER_DUMP_L18;
      }

      if(!(debug == 0))
        fprintf(stderr, "blit test: %s\n", ng_vfmt_to_desc[(signed long int)conv->fmtid_in]);

      if(conv->fmtid_in == fmt->fmtid)
        break;

    }
    while((_Bool)1);
    st->buf.fmt = *fmt;
    st->status = (enum blit_status)STATUS_CONVERT;
    st->conv = conv;
    st->buf.fmt.fmtid = x11_dpy_fmtid;
    st->buf.fmt.bytesperline = (unsigned int)0;
    st->chandle=ng_convert_alloc(st->conv, fmt, &st->buf.fmt);
    ng_convert_init(st->chandle);
    if(!(debug == 0))
      fprintf(stderr, "blit: %dx%d/[%s] => X11 via [%s]\n", fmt->width, fmt->height, ng_vfmt_to_desc[(signed long int)fmt->fmtid], ng_vfmt_to_desc[(signed long int)st->buf.fmt.fmtid]);

    goto __CPROVER_DUMP_L18;
  }

__CPROVER_DUMP_L18:
  ;
}

// blit_putframe
// file x11/blit.h line 33
void blit_putframe(struct blit_state *st, struct ng_video_buf *buf)
{
  if(!(st->fmt.fmtid == buf->fmt.fmtid))
  {
    if(!(st->fmt.width == buf->fmt.width))
    {
      if(!(st->fmt.height == buf->fmt.height))
      {
        blit_fini_frame(st);
        blit_init_frame(st, &buf->fmt);
        st->fmt = buf->fmt;
      }

    }

  }

  if(debug >= 2)
    fprintf(stderr, "blit: putframe\n");

  struct _XDisplay *return_value_XtDisplay_1;
  unsigned long int return_value_XtWindow_2;
  struct _XDisplay *return_value_XtDisplay_4;
  unsigned long int return_value_XtWindow_5;
  switch((signed int)st->status)
  {
    case STATUS_CONVERT:
    {
      if(st->chandle == ((struct ng_convert_handle *)NULL))
      {
        memcpy((void *)st->ximage->data, (const void *)buf->data, buf->size);
        ng_release_video_buf(buf);
      }

      else
        buf=ng_convert_frame(st->chandle, &st->buf, buf);
      return_value_XtDisplay_1=XtDisplay(st->widget);
      return_value_XtWindow_2=XtWindow(st->widget);
      x11_blit(return_value_XtDisplay_1, return_value_XtWindow_2, st->gc, st->ximage, 0, 0, (signed int)((unsigned int)st->win_width - st->buf.fmt.width >> 1), (signed int)((unsigned int)st->win_height - st->buf.fmt.height >> 1), (signed int)st->buf.fmt.width, (signed int)st->buf.fmt.height);
      break;
    }
    case STATUS_XVIDEO:
    {
      unsigned long int tmp_if_expr_3;
      if(!(buf->size >= (unsigned long int)st->xvimage->data_size))
        tmp_if_expr_3 = buf->size;

      else
        tmp_if_expr_3 = (unsigned long int)st->xvimage->data_size;
      memcpy((void *)st->xvimage->data, (const void *)buf->data, tmp_if_expr_3);
      ng_release_video_buf(buf);
      return_value_XtDisplay_4=XtDisplay(st->widget);
      return_value_XtWindow_5=XtWindow(st->widget);
      xv_blit(return_value_XtDisplay_4, return_value_XtWindow_5, st->gc, st->xvimage, 0, 0, (signed int)st->buf.fmt.width, (signed int)st->buf.fmt.height, st->wx, st->wy, st->ww, st->wh);
      break;
    }
    case STATUS_OPENGL:
    {
      gl_blit(st->widget, (char *)buf->data, (signed int)st->buf.fmt.width, (signed int)st->buf.fmt.height, (signed int)st->win_width, (signed int)st->win_height, st->tex, st->tw, st->th, gl_formats[(signed long int)buf->fmt.fmtid].fmt, gl_formats[(signed long int)buf->fmt.fmtid].type);
      ng_release_video_buf(buf);
      break;
    }
    case STATUS_UNKNOWN:

    case STATUS_BROKEN:
    {
      if(debug >= 2)
        fprintf(stderr, "blit: putframe: oops: status = %d\n", st->status);

      ng_release_video_buf(buf);
    }
    default:
      ;
  }
}

// blit_resize
// file x11/blit.h line 29
void blit_resize(struct blit_state *st, unsigned short int width, unsigned short int height)
{
  if(!(debug == 0))
    fprintf(stderr, "blit: resize %dx%d\n", width, height);

  st->win_width = width;
  st->win_height = height;
  st->wx = 0;
  st->wy = 0;
  st->ww = (signed int)st->win_width;
  st->wh = (signed int)st->win_height;
  ng_ratio_fixup(&st->ww, &st->wh, &st->wx, &st->wy);
  blit_fini_frame(st);
}

// byteswap_short
// file libng/color_packed.c line 102
static void byteswap_short(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  do
  {
    p = p - 1;
    if(p == 0)
      break;

    unsigned char * restrict tmp_post_1 = d;
    d = d + 1l;
    *tmp_post_1 = s[(signed long int)1];
    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = s[(signed long int)0];
    s = s + (signed long int)2;
  }
  while((_Bool)1);
}

// calc_frequencies
// file ./common/channel.h line 74
void calc_frequencies(void)
{
  signed int i = 0;
  signed int return_value_get_freq_1;
  for( ; !(i >= count); i = i + 1)
    if(!(channels[(signed long int)i]->cname == ((char *)NULL)))
    {
      channels[(signed long int)i]->channel=lookup_channel(channels[(signed long int)i]->cname);
      if(channels[(signed long int)i]->channel == -1)
        channels[(signed long int)i]->freq = -1;

      else
      {
        return_value_get_freq_1=get_freq(channels[(signed long int)i]->channel);
        channels[(signed long int)i]->freq = return_value_get_freq_1 + channels[(signed long int)i]->fine;
      }
    }

}

// capture_handler
// file common/commands.c line 778
static signed int capture_handler(char *name, signed int argc, char **argv)
{
  signed int i;
  signed int temp = 0;
  signed int return_value_strcasecmp_1;
  return_value_strcasecmp_1=strcasecmp(argv[(signed long int)0], "toggle");
  if(return_value_strcasecmp_1 == 0)
    i = cur_capture == 0 ? 9 : 0;

  else
    i=str_to_int(argv[(signed long int)0], captab);
  signed int return_value_strcasecmp_2;
  if(argc == 2)
  {
    return_value_strcasecmp_2=strcasecmp(argv[(signed long int)1], "temp");
    if(return_value_strcasecmp_2 == 0)
      temp = 1;

  }

  if(!(i == -1))
    set_capture(i, temp);

  return 0;
}

// catch_gl_error
// file x11/blit.c line 94
static signed int catch_gl_error(struct _XDisplay *dpy, struct anonymous *event)
{
  fprintf(stderr, "WARNING: Your OpenGL setup is broken.\n");
  gl_error = gl_error + 1;
  return 0;
}

// catch_no_mitshm
// file x11/blit.c line 87
static signed int catch_no_mitshm(struct _XDisplay *dpy, struct anonymous *event)
{
  no_mitshm = no_mitshm + 1;
  return 0;
}

// cc_sim
// file common/vbi-sim.c line 22
static inline double cc_sim(double t, double F, unsigned char b1, unsigned char b2)
{
  signed int bits = ((signed int)b2 << 10) + ((signed int)b1 << 2) + 2;
  double t1 = 10.5e-6 - .25 / F;
  double t2 = t1 + (double)7 / F;
  double t3 = t2 + 1.5 / F;
  double t4 = t3 + (double)18 / F;
  double ph;
  if(t < t1)
    return 0.0;

  else
    if(t < t2)
    {
      t = t - t2;
      ph = 3.14159265358979323846 * (double)2 * t * F - 3.14159265358979323846 * .5;
      double return_value_sin_1;
      return_value_sin_1=sin(ph);
      return return_value_sin_1 / (double)2 + .5;
    }

    else
      if(t < t3)
        return 0.0;

      else
        if(t < t4)
        {
          signed int i;
          signed int n;
          t = t - t3;
          i = (signed int)(t * F - .0);
          n = bits >> i & 3;
          if(n == 0)
            return 0.0;

          else
            if(n == 3)
              return 1.0;

          if(!(((i ^ n) & 1) == 0))
            ph = (3.14159265358979323846 * (double)2 * (t - (double)1 / F) * F) / (double)4;

          else
            ph = (3.14159265358979323846 * (double)2 * (t - (double)0 / F) * F) / (double)4;
          double return_value_shape_2;
          return_value_shape_2=shape(ph);
          return return_value_shape_2;
        }

        else
          return 0.0;
}

// cf2freq
// file common/channel.c line 159
signed int cf2freq(char *name, signed int fine)
{
  signed int i;
  i=lookup_channel(name);
  if(i == -1)
    return -1;

  else
  {
    signed int return_value_get_freq_1;
    return_value_get_freq_1=get_freq(i);
    return return_value_get_freq_1 + fine;
  }
}

// cfg_find_section
// file common/parseconfig.c line 61
static struct CFG_ENTRIES * cfg_find_section(struct CFG_SECTIONS *c, char *name)
{
  struct CFG_ENTRIES *e;
  signed int i = 0;
  signed int return_value_strcasecmp_1;
  for( ; !(i >= c->sec_count); i = i + 1)
  {
    return_value_strcasecmp_1=strcasecmp(c->sec_names[(signed long int)i], name);
    if(return_value_strcasecmp_1 == 0)
      return c->sec_entries[(signed long int)i];

  }
  if(c->sec_count % 16 == 16)
  {
    void *return_value_realloc_2;
    return_value_realloc_2=realloc((void *)c->sec_names, (unsigned long int)(c->sec_count + 2 + 16) * sizeof(char *) /*8ul*/ );
    c->sec_names = (char **)return_value_realloc_2;
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)c->sec_entries, (unsigned long int)(c->sec_count + 2 + 16) * sizeof(struct CFG_ENTRIES *) /*8ul*/ );
    c->sec_entries = (struct CFG_ENTRIES **)return_value_realloc_3;
  }

  e=cfg_init_entries();
  c->sec_names[(signed long int)c->sec_count]=strdup(name);
  c->sec_entries[(signed long int)c->sec_count] = e;
  c->sec_count = c->sec_count + 1;
  c->sec_names[(signed long int)c->sec_count] = (char *)(void *)0;
  c->sec_entries[(signed long int)c->sec_count] = (struct CFG_ENTRIES *)(void *)0;
  return e;
}

// cfg_get_float
// file common/parseconfig.c line 245
float cfg_get_float(char *sec, char *ent)
{
  char *val;
  val=cfg_get_str(sec, ent);
  if(val == ((char *)NULL))
    return (float)-1;

  else
  {
    double return_value_atof_1;
    return_value_atof_1=atof(val);
    return (float)return_value_atof_1;
  }
}

// cfg_get_int
// file ./common/parseconfig.h line 8
signed int cfg_get_int(char *sec, char *ent)
{
  char *val;
  val=cfg_get_str(sec, ent);
  if(val == ((char *)NULL))
    return -1;

  else
  {
    signed int return_value_atoi_1;
    return_value_atoi_1=atoi(val);
    return return_value_atoi_1;
  }
}

// cfg_get_signed_int
// file common/parseconfig.h line 9
signed int cfg_get_signed_int(char *sec, char *ent)
{
  char *val;
  val=cfg_get_str(sec, ent);
  if(val == ((char *)NULL))
    return 0;

  else
  {
    signed int return_value_atoi_1;
    return_value_atoi_1=atoi(val);
    return return_value_atoi_1;
  }
}

// cfg_get_str
// file common/parseconfig.h line 7
char * cfg_get_str(char *sec, char *ent)
{
  struct CFG_ENTRIES *e = (struct CFG_ENTRIES *)(void *)0;
  char *v = (char *)(void *)0;
  signed int i = 0;
  signed int return_value_strcasecmp_1;
  for( ; !(i >= c->sec_count); i = i + 1)
  {
    return_value_strcasecmp_1=strcasecmp(c->sec_names[(signed long int)i], sec);
    if(return_value_strcasecmp_1 == 0)
      e = c->sec_entries[(signed long int)i];

  }
  signed int return_value_strcasecmp_2;
  if(e == ((struct CFG_ENTRIES *)NULL))
    return (char *)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= e->ent_count); i = i + 1)
    {
      return_value_strcasecmp_2=strcasecmp(e->ent_names[(signed long int)i], ent);
      if(return_value_strcasecmp_2 == 0)
      {
        v = e->ent_values[(signed long int)i];
        e->ent_seen[(signed long int)i] = e->ent_seen[(signed long int)i] + 1l;
      }

    }
    return v;
  }
}

// cfg_init_entries
// file common/parseconfig.c line 46
static struct CFG_ENTRIES * cfg_init_entries(void)
{
  struct CFG_ENTRIES *e;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct CFG_ENTRIES) /*32ul*/ );
  e = (struct CFG_ENTRIES *)return_value_malloc_1;
  memset((void *)e, 0, sizeof(struct CFG_ENTRIES) /*32ul*/ );
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)16 * sizeof(char *) /*8ul*/ );
  e->ent_names = (char **)return_value_malloc_2;
  e->ent_names[(signed long int)0] = (char *)(void *)0;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)16 * sizeof(char *) /*8ul*/ );
  e->ent_values = (char **)return_value_malloc_3;
  e->ent_values[(signed long int)0] = (char *)(void *)0;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc((unsigned long int)16 * sizeof(signed int *) /*8ul*/ );
  e->ent_seen = (signed int **)return_value_malloc_4;
  e->ent_seen[(signed long int)0] = ((signed int *)NULL);
  return e;
}

// cfg_init_sections
// file common/parseconfig.c line 33
static struct CFG_SECTIONS * cfg_init_sections(void)
{
  struct CFG_SECTIONS *cfg_init_sections__1__c;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct CFG_SECTIONS) /*24ul*/ );
  cfg_init_sections__1__c = (struct CFG_SECTIONS *)return_value_malloc_1;
  memset((void *)cfg_init_sections__1__c, 0, sizeof(struct CFG_SECTIONS) /*24ul*/ );
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)16 * sizeof(char *) /*8ul*/ );
  cfg_init_sections__1__c->sec_names = (char **)return_value_malloc_2;
  cfg_init_sections__1__c->sec_names[(signed long int)0] = (char *)(void *)0;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)16 * sizeof(struct CFG_ENTRIES *) /*8ul*/ );
  cfg_init_sections__1__c->sec_entries = (struct CFG_ENTRIES **)return_value_malloc_3;
  cfg_init_sections__1__c->sec_entries[(signed long int)0] = (struct CFG_ENTRIES *)(void *)0;
  return cfg_init_sections__1__c;
}

// cfg_list_entries
// file ./common/parseconfig.h line 6
char ** cfg_list_entries(char *name)
{
  signed int i;
  signed int return_value_strcasecmp_1;
  if(c == ((struct CFG_SECTIONS *)NULL))
    return (char **)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= c->sec_count); i = i + 1)
    {
      return_value_strcasecmp_1=strcasecmp(c->sec_names[(signed long int)i], name);
      if(return_value_strcasecmp_1 == 0)
        return c->sec_entries[(signed long int)i]->ent_names;

    }
    return (char **)(void *)0;
  }
}

// cfg_list_sections
// file common/parseconfig.h line 5
char ** cfg_list_sections(void)
{
  return c->sec_names;
}

// cfg_parse_file
// file common/parseconfig.h line 1
signed int cfg_parse_file(char *filename)
{
  struct CFG_ENTRIES *e = (struct CFG_ENTRIES *)(void *)0;
  char line[256l];
  char tag[64l];
  char value[192l];
  struct _IO_FILE *fp;
  signed int nr;
  if(c == ((struct CFG_SECTIONS *)NULL))
    c=cfg_init_sections();

  fp=fopen(filename, "r");
  char *return_value_fgets_1;
  signed int return_value_sscanf_6;
  if(fp == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    nr = 0;
    do
    {
      return_value_fgets_1=fgets(line, 255, fp);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      nr = nr + 1;
      _Bool tmp_if_expr_2;
      if((signed int)line[0l] == 10)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_3;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)line[(signed long int)0] == 37 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_3)
      {
        signed int return_value_sscanf_7;
        return_value_sscanf_7=sscanf(line, "[%99[^]]]", (const void *)value);
        if(return_value_sscanf_7 == 1)
          e=cfg_find_section(c, value);

        else
        {
          return_value_sscanf_6=sscanf(line, " %63[^= ] = %191[^\n]", (const void *)tag, (const void *)value);
          if(return_value_sscanf_6 == 2)
          {
            if(e == ((struct CFG_ENTRIES *)NULL))
              fprintf(stderr, "%s:%d: error: no section\n", filename, nr);

            else
            {
              char *cfg_parse_file__1__1__2__2__c;
              unsigned long int return_value_strlen_4;
              return_value_strlen_4=strlen(value);
              cfg_parse_file__1__1__2__2__c = (value + (signed long int)return_value_strlen_4) - (signed long int)1;
              while(!(value >= cfg_parse_file__1__1__2__2__c))
              {
                if(!((signed int)*cfg_parse_file__1__1__2__2__c == 32))
                {
                  if(!((signed int)*cfg_parse_file__1__1__2__2__c == 9))
                    break;

                }

                char *tmp_post_5 = cfg_parse_file__1__1__2__2__c;
                cfg_parse_file__1__1__2__2__c = cfg_parse_file__1__1__2__2__c - 1l;
                *tmp_post_5 = (char)0;
              }
              cfg_set_entry(e, tag, value);
            }
          }

          else
            fprintf(stderr, "%s:%d: syntax error\n", filename, nr);
        }
      }

    }
    while((_Bool)1);
    fclose(fp);
    return 0;
  }
}

// cfg_parse_option
// file common/parseconfig.c line 153
void cfg_parse_option(char *section, char *tag, char *value)
{
  struct CFG_ENTRIES *e = (struct CFG_ENTRIES *)(void *)0;
  if(c == ((struct CFG_SECTIONS *)NULL))
    c=cfg_init_sections();

  e=cfg_find_section(c, section);
  cfg_set_entry(e, tag, value);
}

// cfg_parse_options
// file common/parseconfig.h line 3
void cfg_parse_options(signed int *argc, char **argv)
{
  char section[64l];
  char tag[64l];
  signed int i;
  signed int j;
  i = 1;
  while(!(1 + i >= *argc))
  {
    signed int return_value_sscanf_1;
    return_value_sscanf_1=sscanf(argv[(signed long int)i], "-%63[^:]:%63s", (const void *)section, (const void *)tag);
    if(return_value_sscanf_1 == 2)
    {
      cfg_parse_option(section, tag, argv[(signed long int)(i + 1)]);
      j = i;
      for( ; !(j >= *argc + -1); j = j + 1)
        argv[(signed long int)j] = argv[(signed long int)(j + 2)];
      *argc = *argc - 2;
    }

    else
      i = i + 1;
  }
}

// cfg_set_entry
// file common/parseconfig.c line 85
static void cfg_set_entry(struct CFG_ENTRIES *e, char *name, char *value)
{
  signed int i = 0;
  signed int return_value_strcasecmp_1;
  for( ; !(i >= e->ent_count); i = i + 1)
  {
    return_value_strcasecmp_1=strcasecmp(e->ent_names[(signed long int)i], name);
    if(return_value_strcasecmp_1 == 0)
      break;

  }
  if(i == e->ent_count)
  {
    if(e->ent_count % 16 == 16)
    {
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)e->ent_names, (unsigned long int)(e->ent_count + 2 + 16) * sizeof(char *) /*8ul*/ );
      e->ent_names = (char **)return_value_realloc_2;
      void *return_value_realloc_3;
      return_value_realloc_3=realloc((void *)e->ent_values, (unsigned long int)(e->ent_count + 2 + 16) * sizeof(char *) /*8ul*/ );
      e->ent_values = (char **)return_value_realloc_3;
      void *return_value_realloc_4;
      return_value_realloc_4=realloc((void *)e->ent_seen, (unsigned long int)(e->ent_count + 2 + 16) * sizeof(signed int *) /*8ul*/ );
      e->ent_seen = (signed int **)return_value_realloc_4;
    }

    e->ent_count = e->ent_count + 1;
    e->ent_names[(signed long int)e->ent_count] = (char *)(void *)0;
    e->ent_values[(signed long int)e->ent_count] = (char *)(void *)0;
    e->ent_seen[(signed long int)e->ent_count] = ((signed int *)NULL);
  }

  e->ent_names[(signed long int)i]=strdup(name);
  e->ent_values[(signed long int)i]=strdup(value);
}

// chan_add_cb
// file x11/motv.c line 679
static void chan_add_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  union __XmStringRec *str;
  signed int i;
  prop_button = (struct _WidgetRec *)(void *)0;
  XmTextSetString(prop_name, "");
  XmTextSetString(prop_key, "");
  XmTextSetString(prop_group, "main");
  i = -1 == cur_channel ? 0 : cur_channel;
  struct CHANLIST *tmp_if_expr_1;
  if(!(chantab == -1))
    tmp_if_expr_1 = (chanlists + (signed long int)chantab)->list;

  else
    tmp_if_expr_1 = (struct CHANLIST *)(void *)0;
  str=XmStringGenerate((void *)(tmp_if_expr_1 + (signed long int)i)->name, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
  XtVaSetValues(prop_channel, (char *)&_XmStrings[(signed long int)12735], str, (void *)0);
  XmStringFree(str);
  XtManageChild(prop_dlg);
}

// chan_apply_cb
// file x11/motv.c line 724
static void chan_apply_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  char *name;
  char *key;
  char *cname;
  char *group;
  struct CHANNEL *chan_apply_cb__1__c;
  union __XmStringRec *str;
  signed int i;
  signed int channel;
  struct _WidgetRec *msgbox;
  i = count;
  if(!(prop_button == ((struct _WidgetRec *)NULL)))
  {
    i = 0;
    for( ; !(i >= count); i = i + 1)
      if(prop_button == channels[(signed long int)i]->button)
        break;

  }

  name=XmTextGetString(prop_name);
  key=XmTextGetString(prop_key);
  group=XmTextGetString(prop_group);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(group);
  if(return_value_strlen_1 == 0ul)
    group = "main";

  XtVaGetValues(prop_channel, (char *)&_XmStrings[(signed long int)12735], &str, (void *)0);
  void *return_value_XmStringUnparse_2;
  return_value_XmStringUnparse_2=XmStringUnparse(str, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (enum anonymous_67)XmMULTIBYTE_TEXT, (struct __XmParseMappingRec **)(void *)0, (unsigned int)0, (enum anonymous_68)0);
  cname = (char *)return_value_XmStringUnparse_2;
  channel=lookup_channel(cname);
  unsigned long int return_value_strlen_5;
  return_value_strlen_5=strlen(name);
  if(return_value_strlen_5 == 0ul)
  {
    msgbox=XmCreateErrorDialog(prop_dlg, "no_name", (struct anonymous_11 *)(void *)0, (unsigned int)0);
    struct _WidgetRec *return_value_XmMessageBoxGetChild_3;
    return_value_XmMessageBoxGetChild_3=XmMessageBoxGetChild(msgbox, (unsigned char)7);
    XtUnmanageChild(return_value_XmMessageBoxGetChild_3);
    struct _WidgetRec *return_value_XmMessageBoxGetChild_4;
    return_value_XmMessageBoxGetChild_4=XmMessageBoxGetChild(msgbox, (unsigned char)2);
    XtUnmanageChild(return_value_XmMessageBoxGetChild_4);
    XtAddCallback(msgbox, (char *)&_XmStrings[(signed long int)8560], destroy_cb, (void *)msgbox);
    XtManageChild(msgbox);
    goto __CPROVER_DUMP_L10;
  }

  if(i == count)
  {
    chan_apply_cb__1__c=add_channel(name);
    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(key);
    if(return_value_strlen_6 >= 1ul)
      chan_apply_cb__1__c->key=strdup(key);

    chan_apply_cb__1__c->cname=strdup(cname);
    chan_apply_cb__1__c->group=strdup(group);
    chan_apply_cb__1__c->channel = channel;
  }

  else
  {
    chan_apply_cb__1__c = channels[(signed long int)i];
    free((void *)chan_apply_cb__1__c->name);
    chan_apply_cb__1__c->name=strdup(name);
    if(!(chan_apply_cb__1__c->key == ((char *)NULL)))
    {
      free((void *)chan_apply_cb__1__c->key);
      chan_apply_cb__1__c->key = (char *)(void *)0;
    }

    unsigned long int return_value_strlen_7;
    return_value_strlen_7=strlen(key);
    if(!(return_value_strlen_7 == 0ul))
      chan_apply_cb__1__c->key=strdup(key);

    chan_apply_cb__1__c->cname=strdup(cname);
    chan_apply_cb__1__c->group=strdup(group);
    chan_apply_cb__1__c->channel = channel;
    XtRemoveAllCallbacks(chan_apply_cb__1__c->button, (char *)&_XmStrings[(signed long int)4700]);
    add_cmd_callback(chan_apply_cb__1__c->button, (char *)&_XmStrings[(signed long int)4700], "setstation", chan_apply_cb__1__c->name, (const char *)(void *)0);
    toolkit_set_label(chan_apply_cb__1__c->button, chan_apply_cb__1__c->name);
  }
  channel_menu();

__CPROVER_DUMP_L10:
  ;
}

// chan_del_cb
// file x11/motv.c line 1193
static void chan_del_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct _WidgetRec *button = (struct _WidgetRec *)clientdata;
  signed int i = 0;
  for( ; !(i >= count); i = i + 1)
    if(button == channels[(signed long int)i]->button)
      break;

  if(!(i == count))
  {
    XtDestroyWidget(channels[(signed long int)i]->button);
    del_channel(i);
    if(cur_sender == i)
      cur_sender = -1;

    if(!(i >= cur_sender))
      cur_sender = cur_sender - 1;

    channel_menu();
  }

}

// chan_edit_cb
// file x11/motv.c line 698
static void chan_edit_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  union __XmStringRec *str;
  signed int i;
  prop_button = (struct _WidgetRec *)clientdata;
  i = 0;
  for( ; !(i >= count); i = i + 1)
    if(prop_button == channels[(signed long int)i]->button)
      break;

  if(!(i == count))
  {
    XmTextSetString(prop_name, channels[(signed long int)i]->name);
    XmTextSetString(prop_key, channels[(signed long int)i]->key);
    XmTextSetString(prop_group, channels[(signed long int)i]->group);
    signed int tmp_if_expr_1;
    if(channels[(signed long int)i]->channel == -1)
      tmp_if_expr_1 = 0;

    else
      tmp_if_expr_1 = channels[(signed long int)i]->channel;
    i = tmp_if_expr_1;
    struct CHANLIST *tmp_if_expr_2;
    if(!(chantab == -1))
      tmp_if_expr_2 = (chanlists + (signed long int)chantab)->list;

    else
      tmp_if_expr_2 = (struct CHANLIST *)(void *)0;
    str=XmStringGenerate((void *)(tmp_if_expr_2 + (signed long int)i)->name, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
    XtVaSetValues(prop_channel, (char *)&_XmStrings[(signed long int)12735], str, (void *)0);
    XmStringFree(str);
    XtManageChild(prop_dlg);
  }

}

// chan_key_eh
// file x11/motv.c line 657
static void chan_key_eh(struct _WidgetRec *widget, void *client_data, union _XEvent *event, char *cont)
{
  struct anonymous_25 *ke = (struct anonymous_25 *)event;
  unsigned long int sym;
  char *key;
  char line[64l];
  sym=XKeycodeToKeysym(dpy, (unsigned char)ke->keycode, 0);
  if(sym == 0ul)
    fprintf(stderr, "can't translate keycode %d\n", ke->keycode);

  else
  {
    key=XKeysymToString(sym);
    line[(signed long int)0] = (char)0;
    if(!((1u & ke->state) == 0u))
      strcpy(line, "Shift+");

    if(!((4u & ke->state) == 0u))
      strcpy(line, "Ctrl+");

    strcat(line, key);
    XmTextSetString(prop_key, line);
  }
}

// chan_makebutton
// file x11/motv.c line 1213
static void chan_makebutton(struct CHANNEL *channel)
{
  struct _WidgetRec *menu;
  struct _WidgetRec *push;
  if(channel->button == ((struct _WidgetRec *)NULL))
  {
    channel->button=XtVaCreateManagedWidget(channel->name, xmPushButtonWidgetClass, chan_box, (void *)0);
    add_cmd_callback(channel->button, (char *)&_XmStrings[(signed long int)4700], "setstation", channel->name, (const char *)(void *)0);
    menu=XmCreatePopupMenu(channel->button, "menu", (struct anonymous_11 *)(void *)0, (unsigned int)0);
    XtAddEventHandler(channel->button, (unsigned long int)(1L << 2), (char)0, popup_eh, (void *)menu);
    push=XtVaCreateManagedWidget("del", xmPushButtonWidgetClass, menu, (void *)0);
    XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], chan_del_cb, (void *)channel->button);
    push=XtVaCreateManagedWidget("edit", xmPushButtonWidgetClass, menu, (void *)0);
    XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], chan_edit_cb, (void *)channel->button);
  }

}

// chan_resize_eh
// file x11/motv.c line 1182
static void chan_resize_eh(struct _WidgetRec *widget, void *client_data, union _XEvent *event, char *d)
{
  struct _WidgetRec *clip;
  unsigned short int width;
  XtVaGetValues(chan_viewport, (char *)&_XmStrings[(signed long int)5505], &clip, (void *)0);
  XtVaGetValues(clip, (char *)&XtStrings[(signed long int)872], &width, (void *)0);
  XtVaSetValues(chan_box, (char *)&XtStrings[(signed long int)872], width, (void *)0);
}

// chan_save_cb
// file x11/motv.c line 794
static void chan_save_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  save_config();
}

// chan_tune_cb
// file x11/motv.c line 800
static void chan_tune_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct anonymous_74 *cb = (struct anonymous_74 *)call_data;
  char *line;
  void *return_value_XmStringUnparse_1;
  return_value_XmStringUnparse_1=XmStringUnparse(cb->item_or_text, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (enum anonymous_67)XmMULTIBYTE_TEXT, (struct __XmParseMappingRec **)(void *)0, (unsigned int)0, (enum anonymous_68)0);
  line = (char *)return_value_XmStringUnparse_1;
  do_va_cmd(3, (const void *)"setchannel", line);
}

// change_audio
// file x11/xt.h line 156
void change_audio(signed int mode)
{
  struct ng_attribute *attr;
  const char *mname;
  char label[64l];
  attr=ng_attr_byid(attrs, 5);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    if(!(mode == -1))
      attr->write(attr, mode);

    if(mode == 0 || mode == -1)
      mode=attr->read(attr);

    mname=ng_attr_getstr(attr, mode);
    if(mname == ((const char *)NULL))
      mname = "???";

    if(!(attr_notify == ((void (*)(struct ng_attribute *, signed int))NULL)))
      attr_notify(attr, mode);

    sprintf(label, "%s (%s)", (const void *)default_title, mname);
    XtVaSetValues(app_shell, (char *)&XtShellStrings[(signed long int)356], (const void *)label, (void *)0);
  }

}

// channel_menu
// file x11/motv.c line 1102
static void channel_menu(void)
{
  /* tag-#anon#lST[l*{S8}_S8_'name'|*{SYM#tag-_WidgetRec#}_SYM#tag-_WidgetRec#_'menu1'|*{SYM#tag-_WidgetRec#}_SYM#tag-_WidgetRec#_'menu2'] */
struct anonymous_96
{
  // name
  char *name;
  // menu1
  struct _WidgetRec *menu1;
  // menu2
  struct _WidgetRec *menu2;
};

/* */
  ;
  struct anonymous_96 *sub = (struct anonymous_96 *)(void *)0;
  signed int subs = 0;
  struct _WidgetRec *menu1;
  struct _WidgetRec *menu2;
  char ctrl[16l];
  char key[32l];
  char accel[64l];
  signed int i;
  signed int j;
  if(st_menu2 == ((struct _WidgetRec *)NULL))
  {
    st_menu2=XmCreatePopupMenu(tv, "stationsM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
    XtAddEventHandler(tv, (unsigned long int)(1L << 2), (char)0, popup_eh, (void *)st_menu2);
    XtAddCallback(st_menu2, (char *)&_XmStrings[(signed long int)7864], menu_cols_cb, (void *)0);
  }

  delete_children(st_menu1);
  delete_children(st_menu2);
  i = 0;
  signed int return_value_strcmp_2;
  for( ; !(i >= count); i = i + 1)
  {
    if(!(channels[(signed long int)i]->key == ((char *)NULL)))
    {
      signed int return_value_sscanf_1;
      return_value_sscanf_1=sscanf(channels[(signed long int)i]->key, "%15[A-Za-z0-9_]+%31[A-Za-z0-9_]", (const void *)ctrl, (const void *)key);
      if(return_value_sscanf_1 == 2)
        sprintf(accel, "%s<Key>%s", (const void *)ctrl, (const void *)key);

      else
        sprintf(accel, "<Key>%s", channels[(signed long int)i]->key);
    }

    else
      accel[(signed long int)0] = (char)0;
    menu1 = st_menu1;
    menu2 = st_menu2;
    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(channels[(signed long int)i]->group, "main");
    if(!(return_value_strcmp_4 == 0))
    {
      j = 0;
      for( ; !(j >= subs); j = j + 1)
      {
        return_value_strcmp_2=strcmp(channels[(signed long int)i]->group, (sub + (signed long int)j)->name);
        if(return_value_strcmp_2 == 0)
          break;

      }
      if(j == subs)
      {
        subs = subs + 1;
        void *return_value_realloc_3;
        return_value_realloc_3=realloc((void *)sub, (unsigned long int)subs * sizeof(struct anonymous_96) /*24ul*/ );
        sub = (struct anonymous_96 *)return_value_realloc_3;
        (sub + (signed long int)j)->name = channels[(signed long int)i]->group;
        (sub + (signed long int)j)->menu1=XmCreatePulldownMenu(st_menu1, channels[(signed long int)i]->group, (struct anonymous_11 *)(void *)0, (unsigned int)0);
        (sub + (signed long int)j)->menu2=XmCreatePulldownMenu(st_menu2, channels[(signed long int)i]->group, (struct anonymous_11 *)(void *)0, (unsigned int)0);
        XtVaCreateManagedWidget(channels[(signed long int)i]->group, xmCascadeButtonWidgetClass, st_menu1, (char *)&_XmStrings[(signed long int)9963], (sub + (signed long int)j)->menu1, (void *)0);
        XtVaCreateManagedWidget(channels[(signed long int)i]->group, xmCascadeButtonWidgetClass, st_menu2, (char *)&_XmStrings[(signed long int)9963], (sub + (signed long int)j)->menu2, (void *)0);
      }

      menu1 = (sub + (signed long int)j)->menu1;
      menu2 = (sub + (signed long int)j)->menu2;
    }

    add_cmd_menuitem("station", i, menu1, channels[(signed long int)i]->name, channels[(signed long int)i]->key, accel, 0, "setstation", channels[(signed long int)i]->name, (const char *)(void *)0);
    add_cmd_menuitem("station", i, menu2, channels[(signed long int)i]->name, channels[(signed long int)i]->key, accel, 0, "setstation", channels[(signed long int)i]->name, (const char *)(void *)0);
    if(channels[(signed long int)i]->button == ((struct _WidgetRec *)NULL))
      chan_makebutton(channels[(signed long int)i]);

  }
  free((void *)sub);
  calc_frequencies();
}

// chscan_cancel_cb
// file x11/motv.c line 2296
static void chscan_cancel_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  x11_vbi_stop();
  if(!(chtimer == 0ul))
    XtRemoveTimeOut(chtimer);

  chtimer = (unsigned long int)0;
  XtDestroyWidget(chdlg);
  chdlg = (struct _WidgetRec *)(void *)0;
}

// chscan_cb
// file x11/motv.c line 2307
static void chscan_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct _WidgetRec *rc;
  chdlg=XmCreatePromptDialog(control_shell, "chscan", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  struct _WidgetRec *return_value_XtParent_1;
  return_value_XtParent_1=XtParent(chdlg);
  XtAddEventHandler(return_value_XtParent_1, (unsigned long int)0, (char)1, (void (*)(struct _WidgetRec *, void *, union _XEvent *, char *))_XEditResCheckMessages, (void *)0);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_2;
  return_value_XmSelectionBoxGetChild_2=XmSelectionBoxGetChild(chdlg, (unsigned char)11);
  XtUnmanageChild(return_value_XmSelectionBoxGetChild_2);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_3;
  return_value_XmSelectionBoxGetChild_3=XmSelectionBoxGetChild(chdlg, (unsigned char)7);
  XtUnmanageChild(return_value_XmSelectionBoxGetChild_3);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_4;
  return_value_XmSelectionBoxGetChild_4=XmSelectionBoxGetChild(chdlg, (unsigned char)13);
  XtUnmanageChild(return_value_XmSelectionBoxGetChild_4);
  rc=XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass, chdlg, (void *)0);
  XtVaCreateManagedWidget("hints", xmLabelWidgetClass, rc, (void *)0);
  chscale=XtVaCreateManagedWidget("channel", xmScaleWidgetClass, rc, (void *)0);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_5;
  return_value_XmSelectionBoxGetChild_5=XmSelectionBoxGetChild(chdlg, (unsigned char)4);
  XtRemoveAllCallbacks(return_value_XmSelectionBoxGetChild_5, (char *)&_XmStrings[(signed long int)4700]);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_6;
  return_value_XmSelectionBoxGetChild_6=XmSelectionBoxGetChild(chdlg, (unsigned char)4);
  XtAddCallback(return_value_XmSelectionBoxGetChild_6, (char *)&_XmStrings[(signed long int)4700], chscan_start_cb, (void *)0);
  XtAddCallback(chdlg, (char *)&_XmStrings[(signed long int)5319], chscan_cancel_cb, (void *)0);
  XtManageChild(chdlg);
}

// chscan_start_cb
// file x11/motv.c line 2264
static void chscan_start_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  union __XmStringRec *xmstr;
  if(!((4 & f_drv) == 0))
  {
    if(!(channel_switch_hook == ((void (*)(void))NULL)))
      channel_switch_hook();

    while(!(count == 0))
    {
      XtDestroyWidget(channels[(signed long int)(count - 1)]->button);
      del_channel(count - 1);
    }
    cur_sender = -1;
    channel_menu();
    x11_vbi_start(args.vbidev);
    chscan = 0;
    chvbi = 0;
    struct CHANLIST *tmp_if_expr_1;
    if(!(chantab == -1))
      tmp_if_expr_1 = (chanlists + (signed long int)chantab)->list;

    else
      tmp_if_expr_1 = (struct CHANLIST *)(void *)0;
    xmstr=XmStringGenerate((void *)(tmp_if_expr_1 + (signed long int)chscan)->name, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
    signed int tmp_if_expr_2;
    if(!(chantab == -1))
      tmp_if_expr_2 = (chanlists + (signed long int)chantab)->count;

    else
      tmp_if_expr_2 = 0;
    XtVaSetValues(chscale, (char *)&_XmStrings[(signed long int)10137], xmstr, (char *)&_XmStrings[(signed long int)7982], tmp_if_expr_2, (void *)0);
    XmStringFree(xmstr);
    XmScaleSetValue(chscale, chscan);
    struct CHANLIST *tmp_if_expr_3;
    if(!(chantab == -1))
      tmp_if_expr_3 = (chanlists + (signed long int)chantab)->list;

    else
      tmp_if_expr_3 = (struct CHANLIST *)(void *)0;
    do_va_cmd(2, (const void *)"setchannel", tmp_if_expr_3[(signed long int)chscan]);
    x11_vbi_station[(signed long int)0] = (char)0;
    chtimer=XtAppAddTimeOut(app_context, (unsigned long int)250, chscan_timeout, (void *)0);
  }

}

// chscan_timeout
// file x11/motv.c line 2196
static void chscan_timeout(void *client_data, unsigned long int *id)
{
  struct CHANNEL *chscan_timeout__1__c;
  char title[32l];
  union __XmStringRec *xmstr;
  signed int return_value_x11_vbi_tuned_2;
  return_value_x11_vbi_tuned_2=x11_vbi_tuned();
  if(return_value_x11_vbi_tuned_2 == 0)
  {
    if(!(debug == 0))
    {
      struct CHANLIST *tmp_if_expr_1;
      if(!(chantab == -1))
        tmp_if_expr_1 = (chanlists + (signed long int)chantab)->list;

      else
        tmp_if_expr_1 = (struct CHANLIST *)(void *)0;
      fprintf(stderr, "scan [%s]: no station\n", (tmp_if_expr_1 + (signed long int)chscan)->name);
    }

  }

  else
    if(!((signed int)x11_vbi_station[0l] == 0))
    {
      if(!(debug == 0))
      {
        struct CHANLIST *tmp_if_expr_3;
        if(!(chantab == -1))
          tmp_if_expr_3 = (chanlists + (signed long int)chantab)->list;

        else
          tmp_if_expr_3 = (struct CHANLIST *)(void *)0;
        fprintf(stderr, "scan [%s]: %s\n", (tmp_if_expr_3 + (signed long int)chscan)->name, (const void *)x11_vbi_station);
      }

      chscan_timeout__1__c=add_channel(x11_vbi_station);
      struct CHANLIST *tmp_if_expr_4;
      if(!(chantab == -1))
        tmp_if_expr_4 = (chanlists + (signed long int)chantab)->list;

      else
        tmp_if_expr_4 = (struct CHANLIST *)(void *)0;
      chscan_timeout__1__c->cname=strdup((tmp_if_expr_4 + (signed long int)chscan)->name);
      chscan_timeout__1__c->channel = chscan;
      cur_sender = count - 1;
      channel_menu();
    }

    else
    {
      signed int tmp_post_8 = chvbi;
      chvbi = chvbi + 1;
      if(tmp_post_8 >= 4)
      {
        if(!(debug == 0))
        {
          struct CHANLIST *tmp_if_expr_5;
          if(!(chantab == -1))
            tmp_if_expr_5 = (chanlists + (signed long int)chantab)->list;

          else
            tmp_if_expr_5 = (struct CHANLIST *)(void *)0;
          fprintf(stderr, "scan [%s]: no vbi name\n", (tmp_if_expr_5 + (signed long int)chscan)->name);
        }

        struct CHANLIST *tmp_if_expr_6;
        if(!(chantab == -1))
          tmp_if_expr_6 = (chanlists + (signed long int)chantab)->list;

        else
          tmp_if_expr_6 = (struct CHANLIST *)(void *)0;
        sprintf(title, "%s [no name]", (tmp_if_expr_6 + (signed long int)chscan)->name);
        chscan_timeout__1__c=add_channel(title);
        struct CHANLIST *tmp_if_expr_7;
        if(!(chantab == -1))
          tmp_if_expr_7 = (chanlists + (signed long int)chantab)->list;

        else
          tmp_if_expr_7 = (struct CHANLIST *)(void *)0;
        chscan_timeout__1__c->cname=strdup((tmp_if_expr_7 + (signed long int)chscan)->name);
        chscan_timeout__1__c->channel = chscan;
        cur_sender = count - 1;
        channel_menu();
      }

      else
      {
        if(!(debug == 0))
        {
          struct CHANLIST *tmp_if_expr_9;
          if(!(chantab == -1))
            tmp_if_expr_9 = (chanlists + (signed long int)chantab)->list;

          else
            tmp_if_expr_9 = (struct CHANLIST *)(void *)0;
          fprintf(stderr, "scan [%s] vbi ...\n", (tmp_if_expr_9 + (signed long int)chscan)->name);
        }

        chtimer=XtAppAddTimeOut(app_context, (unsigned long int)250, chscan_timeout, (void *)0);
        goto __CPROVER_DUMP_L32;
      }
    }

next_station:
  ;
  chscan = chscan + 1;
  signed int tmp_if_expr_10;
  if(!(chantab == -1))
    tmp_if_expr_10 = (chanlists + (signed long int)chantab)->count;

  else
    tmp_if_expr_10 = 0;
  if(chscan >= tmp_if_expr_10)
  {
    x11_vbi_stop();
    chtimer = (unsigned long int)0;
    if(!(count == 0))
      do_va_cmd(2, (const void *)"setchannel", channels[(signed long int)0]->name);

    XtDestroyWidget(chdlg);
    chdlg = (struct _WidgetRec *)(void *)0;
  }

  else
  {
    chvbi = 0;
    if(!(channel_switch_hook == ((void (*)(void))NULL)))
      channel_switch_hook();

    struct CHANLIST *tmp_if_expr_11;
    if(!(chantab == -1))
      tmp_if_expr_11 = (chanlists + (signed long int)chantab)->list;

    else
      tmp_if_expr_11 = (struct CHANLIST *)(void *)0;
    xmstr=XmStringGenerate((void *)(tmp_if_expr_11 + (signed long int)chscan)->name, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
    XtVaSetValues(chscale, (char *)&_XmStrings[(signed long int)10137], xmstr, (void *)0);
    XmStringFree(xmstr);
    XmScaleSetValue(chscale, chscan);
    struct CHANLIST *tmp_if_expr_12;
    if(!(chantab == -1))
      tmp_if_expr_12 = (chanlists + (signed long int)chantab)->list;

    else
      tmp_if_expr_12 = (struct CHANLIST *)(void *)0;
    do_va_cmd(2, (const void *)"setchannel", tmp_if_expr_12[(signed long int)chscan]);
    x11_vbi_station[(signed long int)0] = (char)0;
    chtimer=XtAppAddTimeOut(app_context, (unsigned long int)250, chscan_timeout, (void *)0);
    goto __CPROVER_DUMP_L32;
  }

__CPROVER_DUMP_L32:
  ;
}

// clip_drop
// file libng/grab-ng.c line 841
static void clip_drop(struct OVERLAY_CLIP *oc, signed int n, signed int *count)
{
  *count = *count - 1;
  memmove((void *)(oc + (signed long int)n), (const void *)(oc + (signed long int)n + (signed long int)1), sizeof(struct OVERLAY_CLIP) /*16ul*/  * (unsigned long int)(*count - n));
}

// clip_dump
// file libng/grab-ng.c line 829
static void clip_dump(char *state, struct OVERLAY_CLIP *oc, signed int count)
{
  signed int i;
  fprintf(stderr, "clip: %s - %d clips\n", state, count);
  i = 0;
  for( ; !(i >= count); i = i + 1)
    fprintf(stderr, "clip:   %d: %dx%d+%d+%d\n", i, (oc + (signed long int)i)->x2 - (oc + (signed long int)i)->x1, (oc + (signed long int)i)->y2 - (oc + (signed long int)i)->y1, (oc + (signed long int)i)->x1, (oc + (signed long int)i)->y1);
}

// command_cb
// file x11/xt.h line 167
void command_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct DO_CMD *cmd = (struct DO_CMD *)clientdata;
  do_command(cmd->argc, cmd->argv);
}

// configure_delayed
// file x11/x11.c line 496
static char configure_delayed(void *data)
{
  if(debug >= 2)
    fprintf(stderr, "video: configure delayed");

  if(!(visibility == 2) && !(wmap == 0))
  {
    if(visibility == 1)
      get_clips();

    else
      oc_count = 0;
    if(debug >= 2)
      fprintf(stderr, " %s\n", conf != 0 ? "yes" : "no");

    if(!(conf == 0))
    {
      overlay_on = 1;
      if(!((1 & f_drv) == 0))
        drv->overlay(h_drv, &wfmt, wx, wy, oc, oc_count, 1);

      if(!(overlay_refresh == 0ul))
        XtRemoveTimeOut(overlay_refresh);

      overlay_refresh=XtAppAddTimeOut(app_context, (unsigned long int)200, refresh_timer, (void *)0);
      conf = 0;
    }

  }

  else
  {
    if(debug >= 2)
      fprintf(stderr, " off\n");

    if(!(conf == 0) && !(overlay_on == 0))
    {
      overlay_on = 0;
      if(!((1 & f_drv) == 0))
        drv->overlay(h_drv, (struct ng_video_fmt *)(void *)0, 0, 0, (struct OVERLAY_CLIP *)(void *)0, 0, 0);

      if(!(overlay_refresh == 0ul))
        XtRemoveTimeOut(overlay_refresh);

      overlay_refresh=XtAppAddTimeOut(app_context, (unsigned long int)200, refresh_timer, (void *)0);
      conf = 0;
    }

  }
  conf_id = (unsigned long int)0;
  return (char)1;
}

// configure_overlay
// file x11/x11.c line 535
static void configure_overlay(void)
{
  unsigned long int return_value_XtWindow_1;
  if(!(overlay_enabled == 0))
  {
    if(!(have_xv == 0))
    {
      if(!(wfmt.height == 0u) && !(wfmt.width == 0u))
      {
        return_value_XtWindow_1=XtWindow(video);
        xv_video(return_value_XtWindow_1, (signed int)wfmt.width, (signed int)wfmt.height, 1);
      }

      goto __CPROVER_DUMP_L3;
    }

    if(conf_id == 0ul)
      conf_id=XtAppAddWorkProc(app_context, configure_delayed, (void *)0);

  }


__CPROVER_DUMP_L3:
  ;
}

// convert_buffer
// file x11/motv.c line 2634
static struct ng_video_buf * convert_buffer(struct ng_video_buf *in, signed int out_fmt)
{
  struct ng_video_conv *conv;
  struct ng_convert_handle *ch;
  struct ng_video_fmt ofmt;
  signed int i = 0;
  do
  {
    conv=ng_conv_find_to((unsigned int)out_fmt, &i);
    if(conv == ((struct ng_video_conv *)NULL))
      break;

    if(conv->fmtid_in == in->fmt.fmtid)
      goto found;

  }
  while((_Bool)1);
  return (struct ng_video_buf *)(void *)0;

found:
  ;
  memset((void *)&ofmt, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
  ofmt.fmtid = (unsigned int)out_fmt;
  ofmt.width = in->fmt.width;
  ofmt.height = in->fmt.height;
  ch=ng_convert_alloc(conv, &in->fmt, &ofmt);
  struct ng_video_buf *return_value_ng_convert_single_1;
  return_value_ng_convert_single_1=ng_convert_single(ch, in);
  return return_value_ng_convert_single_1;
}

// create_attr_widgets
// file x11/motv.c line 1513
static void create_attr_widgets(void)
{
  struct ng_attribute *attr;
  struct _WidgetRec *push;
  union __XmStringRec *label;
  union __XmStringRec *accel;
  char str[100l];
  char key[32l];
  char ctrl[16l];
  struct anonymous_11 argv[8l];
  unsigned int argc;
  signed int i;
  attr=ng_attr_byid(attrs, 1);
  if(!(attr == ((struct ng_attribute *)NULL)))
    add_attr_option(opt_menu, attr);

  attr=ng_attr_byid(attrs, 2);
  if(!(attr == ((struct ng_attribute *)NULL)))
    add_attr_option(opt_menu, attr);

  attr=ng_attr_byid(attrs, 5);
  if(!(attr == ((struct ng_attribute *)NULL)))
    add_attr_option(opt_menu, attr);

  attr = attrs;
  for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
    if(attr->id >= 10)
    {
      if(attr->type == 2)
        add_attr_option(opt_menu, attr);

    }

  attr=ng_attr_byid(attrs, 4);
  if(!(attr == ((struct ng_attribute *)NULL)))
    add_attr_option(opt_menu, attr);

  attr = attrs;
  for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
    if(attr->id >= 10)
    {
      if(attr->type == 3)
        add_attr_option(opt_menu, attr);

    }

  push=XtVaCreateManagedWidget("scale", xmPushButtonWidgetClass, opt_menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Popup(scale)");
  i = 0;
  for( ; !(i >= nlaunch); i = i + 1)
  {
    argc = (unsigned int)0;
    label = (union __XmStringRec *)(void *)0;
    accel = (union __XmStringRec *)(void *)0;
    label=XmStringGenerate((void *)(launch + (signed long int)i)->name, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
    argv[(signed long int)argc].name = (char *)&_XmStrings[(signed long int)7535];
    argv[(signed long int)argc].value = (signed long int)label;
    argc = argc + 1u;
    if(!((launch + (signed long int)i)->key == ((char *)NULL)))
    {
      accel=XmStringGenerate((void *)(launch + (signed long int)i)->key, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
      argv[(signed long int)argc].name = (char *)&_XmStrings[(signed long int)4684];
      argv[(signed long int)argc].value = (signed long int)accel;
      argc = argc + 1u;
      signed int return_value_sscanf_1;
      return_value_sscanf_1=sscanf((launch + (signed long int)i)->key, "%15[A-Za-z0-9_]+%31[A-Za-z0-9_]", (const void *)ctrl, (const void *)key);
      if(return_value_sscanf_1 == 2)
        sprintf(str, "%s<Key>%s", (const void *)ctrl, (const void *)key);

      else
        sprintf(str, "<Key>%s", (launch + (signed long int)i)->key);
      argv[(signed long int)argc].name = (char *)&_XmStrings[(signed long int)4672];
      argv[(signed long int)argc].value = (signed long int)str;
      argc = argc + 1u;
    }

    push=XtCreateManagedWidget((launch + (signed long int)i)->name, xmPushButtonWidgetClass, launch_menu, argv, argc);
    if(!(label == ((union __XmStringRec *)NULL)))
      XmStringFree(label);

    if(!(accel == ((union __XmStringRec *)NULL)))
      XmStringFree(accel);

    strcat(str, ": Launch(");
    strcat(str, (launch + (signed long int)i)->name);
    strcat(str, ")");
    struct _TranslationData *return_value_XtParseTranslationTable_2;
    return_value_XtParseTranslationTable_2=XtParseTranslationTable(str);
    XtOverrideTranslations(tv, return_value_XtParseTranslationTable_2);
    sprintf(str, "Launch(%s)", (launch + (signed long int)i)->name);
    char *return_value_strdup_3;
    return_value_strdup_3=strdup(str);
    XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)return_value_strdup_3);
  }
}

// create_bitmaps
// file x11/xt.h line 214
void create_bitmaps(struct _WidgetRec *app_shell)
{
  struct anonymous_22 black;
  struct anonymous_22 dummy;
  unsigned long int return_value_XtWindow_1;
  return_value_XtWindow_1=XtWindow(app_shell);
  bm_yes=XCreateBitmapFromData(dpy, return_value_XtWindow_1, (const char *)bm_yes_data, (unsigned int)8, (unsigned int)8);
  unsigned long int return_value_XtWindow_2;
  return_value_XtWindow_2=XtWindow(app_shell);
  bm_no=XCreateBitmapFromData(dpy, return_value_XtWindow_2, (const char *)bm_no_data, (unsigned int)8, (unsigned int)8);
  XAllocNamedColor(dpy, colormap, "black", &black, &dummy);
  no_ptr=XCreatePixmapCursor(dpy, bm_no, bm_no, &black, &black, (unsigned int)0, (unsigned int)0);
}

// create_control
// file x11/motv.c line 1235
static void create_control(void)
{
  struct _WidgetRec *form;
  struct _WidgetRec *menubar;
  struct _WidgetRec *menu;
  struct _WidgetRec *smenu;
  struct _WidgetRec *push;
  struct _WidgetRec *clip;
  struct _WidgetRec *tool;
  struct _WidgetRec *rc;
  struct _WidgetRec *fr;
  char action[256l];
  signed int i;
  control_shell=XtVaAppCreateShell("control", "MoTV", topLevelShellWidgetClass, dpy, (char *)&XtShellStrings[(signed long int)813], app_shell, (char *)&XtShellStrings[(signed long int)104], vinfo.visual, (char *)&XtStrings[(signed long int)154], colormap, (char *)&XtStrings[(signed long int)163], vinfo.depth, (char *)&_XmStrings[(signed long int)6018], 2, (void *)0);
  XtAddEventHandler(control_shell, (unsigned long int)0, (char)1, (void (*)(struct _WidgetRec *, void *, union _XEvent *, char *))_XEditResCheckMessages, (void *)0);
  struct _XDisplay *return_value_XtDisplay_1;
  return_value_XtDisplay_1=XtDisplay(control_shell);
  unsigned long int return_value_XInternAtom_2;
  return_value_XInternAtom_2=XInternAtom(return_value_XtDisplay_1, "WM_PROTOCOLS", 0);
  XmAddProtocolCallback(control_shell, return_value_XInternAtom_2, WM_DELETE_WINDOW, popupdown_cb, (void *)control_shell);
  form=XtVaCreateManagedWidget("form", xmFormWidgetClass, control_shell, (void *)0);
  menubar=XmCreateMenuBar(form, "menubar", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  XtManageChild(menubar);
  tool=XtVaCreateManagedWidget("tool", xmRowColumnWidgetClass, form, (void *)0);
  rc=XtVaCreateManagedWidget("status", xmRowColumnWidgetClass, form, (void *)0);
  fr=XtVaCreateManagedWidget("f", xmFrameWidgetClass, rc, (void *)0);
  st_freq=XtVaCreateManagedWidget("freq", xmLabelWidgetClass, fr, (void *)0);
  fr=XtVaCreateManagedWidget("f", xmFrameWidgetClass, rc, (void *)0);
  st_chan=XtVaCreateManagedWidget("chan", xmLabelWidgetClass, fr, (void *)0);
  fr=XtVaCreateManagedWidget("f", xmFrameWidgetClass, rc, (void *)0);
  st_name=XtVaCreateManagedWidget("name", xmLabelWidgetClass, fr, (void *)0);
  fr=XtVaCreateManagedWidget("f", xmFrameWidgetClass, rc, (void *)0);
  st_key=XtVaCreateManagedWidget("key", xmLabelWidgetClass, fr, (void *)0);
  chan_viewport=XmCreateScrolledWindow(form, "view", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  XtManageChild(chan_viewport);
  chan_box=XtVaCreateManagedWidget("box", xmRowColumnWidgetClass, chan_viewport, (void *)0);
  XtVaGetValues(chan_viewport, (char *)&_XmStrings[(signed long int)5505], &clip, (void *)0);
  XtAddEventHandler(clip, (unsigned long int)(1L << 17), (char)1, chan_resize_eh, (void *)0);
  menu=XmCreatePulldownMenu(menubar, "fileM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  XtVaCreateManagedWidget("file", xmCascadeButtonWidgetClass, menubar, (char *)&_XmStrings[(signed long int)9963], menu, (void *)0);
  push=XtVaCreateManagedWidget("rec", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], popupdown_cb, (void *)str_shell);
  XtVaCreateManagedWidget("sep", xmSeparatorWidgetClass, menu, (void *)0);
  push=XtVaCreateManagedWidget("quit", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], ExitCB, (void *)0);
  if(!((2 & f_drv) == 0))
  {
    menu=XmCreatePulldownMenu(menubar, "editM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
    XtVaCreateManagedWidget("edit", xmCascadeButtonWidgetClass, menubar, (char *)&_XmStrings[(signed long int)9963], menu, (void *)0);
    push=XtVaCreateManagedWidget("copy", xmPushButtonWidgetClass, menu, (void *)0);
    XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Ipc(clipboard)");
  }

  st_menu1=XmCreatePulldownMenu(menubar, "stationsM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  XtVaCreateManagedWidget("stations", xmCascadeButtonWidgetClass, menubar, (char *)&_XmStrings[(signed long int)9963], st_menu1, (void *)0);
  XtAddCallback(st_menu1, (char *)&_XmStrings[(signed long int)7864], menu_cols_cb, (void *)0);
  menu=XmCreatePulldownMenu(menubar, "toolsM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  XtVaCreateManagedWidget("tools", xmCascadeButtonWidgetClass, menubar, (char *)&_XmStrings[(signed long int)9963], menu, (void *)0);
  w_full=XtVaCreateManagedWidget("full", xmToggleButtonWidgetClass, menu, (void *)0);
  XtAddCallback(w_full, (char *)&_XmStrings[(signed long int)10591], action_cb, (void *)"Command(fullscreen)");
  push=XtVaCreateManagedWidget("ontop", xmToggleButtonWidgetClass, menu, (void *)0);
  b_ontop = push;
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)10591], ontop_cb, (void *)0);
  push=XtVaCreateManagedWidget("levels", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Popup(levels)");
  XtVaCreateManagedWidget("sep", xmSeparatorWidgetClass, menu, (void *)0);
  push=XtVaCreateManagedWidget("st_up", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Command(setstation,next)");
  push=XtVaCreateManagedWidget("st_dn", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Command(setstation,prev)");
  smenu=XmCreatePulldownMenu(menu, "tuneM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  XtVaCreateManagedWidget("tune", xmCascadeButtonWidgetClass, menu, (char *)&_XmStrings[(signed long int)9963], smenu, (void *)0);
  push=XtVaCreateManagedWidget("ch_up", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Command(setchannel,next)");
  push=XtVaCreateManagedWidget("ch_dn", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Command(setchannel,prev)");
  push=XtVaCreateManagedWidget("fi_up", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Command(setchannel,fine_up)");
  push=XtVaCreateManagedWidget("fi_dn", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Command(setchannel,fine_down)");
  smenu=XmCreatePulldownMenu(menu, "grabM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  XtVaCreateManagedWidget("grab", xmCascadeButtonWidgetClass, menu, (char *)&_XmStrings[(signed long int)9963], smenu, (void *)0);
  push=XtVaCreateManagedWidget("ppm_f", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Command(snap,ppm,full)");
  push=XtVaCreateManagedWidget("ppm_w", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Command(snap,ppm,win)");
  push=XtVaCreateManagedWidget("jpg_f", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Command(snap,jpeg,full)");
  push=XtVaCreateManagedWidget("jpg_w", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Command(snap,jpeg,win)");
  smenu=XmCreatePulldownMenu(menu, "ratioM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  XtVaCreateManagedWidget("ratio", xmCascadeButtonWidgetClass, menu, (char *)&_XmStrings[(signed long int)9963], smenu, (void *)0);
  push=XtVaCreateManagedWidget("r_no", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Ratio(0,0)");
  push=XtVaCreateManagedWidget("r_43", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Ratio(4,3)");
  launch_menu=XmCreatePulldownMenu(menu, "launchM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  XtVaCreateManagedWidget("launch", xmCascadeButtonWidgetClass, menu, (char *)&_XmStrings[(signed long int)9963], launch_menu, (void *)0);
  smenu=XmCreatePulldownMenu(menu, "subM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  XtVaCreateManagedWidget("sub", xmCascadeButtonWidgetClass, menu, (char *)&_XmStrings[(signed long int)9963], smenu, (void *)0);
  push=XtVaCreateManagedWidget("s_off", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Vtx(stop)");
  push=XtVaCreateManagedWidget("s_150", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Vtx(start,150)");
  push=XtVaCreateManagedWidget("s_333", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Vtx(start,333)");
  push=XtVaCreateManagedWidget("s_777", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Vtx(start,777)");
  push=XtVaCreateManagedWidget("s_801", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Vtx(start,801)");
  push=XtVaCreateManagedWidget("s_888", xmPushButtonWidgetClass, smenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Vtx(start,888)");
  menu=XmCreatePulldownMenu(menubar, "optionsM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  opt_menu = menu;
  XtVaCreateManagedWidget("options", xmCascadeButtonWidgetClass, menubar, (char *)&_XmStrings[(signed long int)9963], menu, (void *)0);
  push=XtVaCreateManagedWidget("add", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], chan_add_cb, (void *)0);
  push=XtVaCreateManagedWidget("scan", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], chscan_cb, (void *)0);
  push=XtVaCreateManagedWidget("pref", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], pref_manage_cb, (void *)0);
  push=XtVaCreateManagedWidget("save", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], chan_save_cb, (void *)0);
  XtVaCreateManagedWidget("sep", xmSeparatorWidgetClass, menu, (void *)0);
  cap_menu=XmCreatePulldownMenu(menu, "captureM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  XtVaCreateManagedWidget("capture", xmCascadeButtonWidgetClass, menu, (char *)&_XmStrings[(signed long int)9963], cap_menu, (void *)0);
  push=XtVaCreateManagedWidget("overlay", xmToggleButtonWidgetClass, cap_menu, (char *)&_XmStrings[(signed long int)7324], 2, (void *)0);
  add_cmd_callback(push, (char *)&_XmStrings[(signed long int)10591], "capture", "overlay", (const char *)(void *)0);
  push=XtVaCreateManagedWidget("grabdisplay", xmToggleButtonWidgetClass, cap_menu, (char *)&_XmStrings[(signed long int)7324], 2, (void *)0);
  add_cmd_callback(push, (char *)&_XmStrings[(signed long int)10591], "capture", "grab", (const char *)(void *)0);
  push=XtVaCreateManagedWidget("none", xmToggleButtonWidgetClass, cap_menu, (char *)&_XmStrings[(signed long int)7324], 2, (void *)0);
  add_cmd_callback(push, (char *)&_XmStrings[(signed long int)10591], "capture", "off", (const char *)(void *)0);
  freq_menu=XmCreatePulldownMenu(menu, "freqM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  XtVaCreateManagedWidget("freq", xmCascadeButtonWidgetClass, menu, (char *)&_XmStrings[(signed long int)9963], freq_menu, (void *)0);
  i = 0;
  for( ; !((chanlist_names + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
  {
    push=XtVaCreateManagedWidget((chanlist_names + (signed long int)i)->str, xmToggleButtonWidgetClass, freq_menu, (char *)&_XmStrings[(signed long int)7324], 2, (void *)0);
    add_cmd_callback(push, (char *)&_XmStrings[(signed long int)10591], "setfreqtab", (chanlist_names + (signed long int)i)->str, (const char *)(void *)0);
  }
  XtVaCreateManagedWidget("sep", xmSeparatorWidgetClass, menu, (void *)0);
  signed int return_value_list_empty_4;
  if(!((2 & f_drv) == 0))
  {
    return_value_list_empty_4=list_empty(&ng_filters);
    if(return_value_list_empty_4 == 0)
    {
      struct list_head *item;
      struct ng_filter *filter;
      menu=XmCreatePulldownMenu(menubar, "filterM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
      XtVaCreateManagedWidget("filter", xmCascadeButtonWidgetClass, menubar, (char *)&_XmStrings[(signed long int)9963], menu, (void *)0);
      push=XtVaCreateManagedWidget("fnone", xmPushButtonWidgetClass, menu, (void *)0);
      XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Filter()");
      item = (&ng_filters)->next;
      for( ; !(item == &ng_filters); item = item->next)
      {
        filter = (struct ng_filter *)((char *)item - (signed long int)(unsigned long int)&((struct ng_filter *)0)->list);
        push=XtVaCreateManagedWidget(filter->name, xmPushButtonWidgetClass, menu, (void *)0);
        sprintf(action, "Filter(%s)", filter->name);
        char *return_value_strdup_3;
        return_value_strdup_3=strdup(action);
        XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)return_value_strdup_3);
      }
      XtVaCreateManagedWidget("sep", xmSeparatorWidgetClass, menu, (void *)0);
      push=XtVaCreateManagedWidget("fopts", xmPushButtonWidgetClass, menu, (void *)0);
      XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Popup(filter)");
    }

  }

  menu=XmCreatePulldownMenu(menubar, "helpM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  push=XtVaCreateManagedWidget("help", xmCascadeButtonWidgetClass, menubar, (char *)&_XmStrings[(signed long int)9963], menu, (void *)0);
  XtVaSetValues(menubar, (char *)&_XmStrings[(signed long int)8025], push, (void *)0);
  push=XtVaCreateManagedWidget("man", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], man_cb, (void *)"motv");
  XtVaCreateManagedWidget("sep", xmSeparatorWidgetClass, menu, (void *)0);
  push=XtVaCreateManagedWidget("about", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], about_cb, (void *)0);
  push=XtVaCreateManagedWidget("prev", xmPushButtonWidgetClass, tool, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Command(setstation,prev)");
  push=XtVaCreateManagedWidget("next", xmPushButtonWidgetClass, tool, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Command(setstation,next)");
  XtVaCreateManagedWidget("sep", xmSeparatorWidgetClass, tool, (void *)0);
  push=XtVaCreateManagedWidget("snap", xmPushButtonWidgetClass, tool, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Command(snap,jpeg,full)");
  push=XtVaCreateManagedWidget("movie", xmPushButtonWidgetClass, tool, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], popupdown_cb, (void *)str_shell);
  push=XtVaCreateManagedWidget("mute", xmPushButtonWidgetClass, tool, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], action_cb, (void *)"Command(volume,mute,toggle)");
  XtVaCreateManagedWidget("sep", xmSeparatorWidgetClass, tool, (void *)0);
  push=XtVaCreateManagedWidget("exit", xmPushButtonWidgetClass, tool, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], ExitCB, (void *)0);
}

// create_filter_prop
// file x11/motv.c line 933
static void create_filter_prop(void)
{
  struct _WidgetRec *rc1;
  struct _WidgetRec *frame;
  struct _WidgetRec *rc2;
  union __XmStringRec *str;
  struct list_head *item;
  struct ng_filter *filter;
  signed int j;
  filter_shell=XtVaAppCreateShell("filter", "MoTV", topLevelShellWidgetClass, dpy, (char *)&XtShellStrings[(signed long int)813], app_shell, (char *)&XtShellStrings[(signed long int)104], vinfo.visual, (char *)&XtStrings[(signed long int)154], colormap, (char *)&XtStrings[(signed long int)163], vinfo.depth, (char *)&_XmStrings[(signed long int)6018], 2, (void *)0);
  XtAddEventHandler(filter_shell, (unsigned long int)0, (char)1, (void (*)(struct _WidgetRec *, void *, union _XEvent *, char *))_XEditResCheckMessages, (void *)0);
  struct _XDisplay *return_value_XtDisplay_1;
  return_value_XtDisplay_1=XtDisplay(filter_shell);
  unsigned long int return_value_XInternAtom_2;
  return_value_XInternAtom_2=XInternAtom(return_value_XtDisplay_1, "WM_PROTOCOLS", 0);
  XmAddProtocolCallback(filter_shell, return_value_XInternAtom_2, WM_DELETE_WINDOW, popupdown_cb, (void *)filter_shell);
  rc1=XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass, filter_shell, (void *)0);
  item = (&ng_filters)->next;
  for( ; !(item == &ng_filters); item = item->next)
  {
    filter = (struct ng_filter *)((char *)item - (signed long int)(unsigned long int)&((struct ng_filter *)0)->list);
    if(!(filter->attrs == ((struct ng_attribute *)NULL)))
    {
      str=XmStringGenerate((void *)filter->name, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
      frame=XtVaCreateManagedWidget("frame", xmFrameWidgetClass, rc1, (void *)0);
      XtVaCreateManagedWidget("label", xmLabelWidgetClass, frame, (char *)&_XmStrings[(signed long int)7535], str, (void *)0);
      rc2=XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass, frame, (void *)0);
      XmStringFree(str);
      j = 0;
      for( ; !((filter->attrs + (signed long int)j)->name == ((const char *)NULL)); j = j + 1)
        filter_add_ctrls(rc2, filter, &filter->attrs[(signed long int)j]);
    }

  }
}

// create_levels
// file x11/motv.c line 3146
static void create_levels(void)
{
  struct _WidgetRec *rc;
  levels_shell=XtVaAppCreateShell("levels", "MoTV", topLevelShellWidgetClass, dpy, (char *)&XtShellStrings[(signed long int)813], app_shell, (char *)&XtShellStrings[(signed long int)104], vinfo.visual, (char *)&XtStrings[(signed long int)154], colormap, (char *)&XtStrings[(signed long int)163], vinfo.depth, (char *)&_XmStrings[(signed long int)6018], 2, (void *)0);
  XtAddEventHandler(levels_shell, (unsigned long int)0, (char)1, (void (*)(struct _WidgetRec *, void *, union _XEvent *, char *))_XEditResCheckMessages, (void *)0);
  struct _XDisplay *return_value_XtDisplay_1;
  return_value_XtDisplay_1=XtDisplay(levels_shell);
  unsigned long int return_value_XInternAtom_2;
  return_value_XInternAtom_2=XInternAtom(return_value_XtDisplay_1, "WM_PROTOCOLS", 0);
  XmAddProtocolCallback(levels_shell, return_value_XInternAtom_2, WM_DELETE_WINDOW, popupdown_cb, (void *)levels_shell);
  rc=XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass, levels_shell, (void *)0);
  levels_toggle=XtVaCreateManagedWidget("enable", xmToggleButtonWidgetClass, rc, (void *)0);
  XtAddCallback(levels_toggle, (char *)&_XmStrings[(signed long int)10591], levels_toggle_cb, (void *)0);
  levels_left=XtVaCreateManagedWidget("left", xmScaleWidgetClass, rc, (void *)0);
  levels_right=XtVaCreateManagedWidget("right", xmScaleWidgetClass, rc, (void *)0);
}

// create_onscreen
// file x11/xt.h line 145
void create_onscreen(struct _WidgetClassRec *class)
{
  on_shell=XtVaCreateWidget("onscreen", transientShellWidgetClass, app_shell, (char *)&XtShellStrings[(signed long int)186], 1, (char *)&XtShellStrings[(signed long int)104], vinfo.visual, (char *)&XtStrings[(signed long int)154], colormap, (char *)&XtStrings[(signed long int)163], vinfo.depth, (void *)0);
  on_label=XtVaCreateManagedWidget("label", class, on_shell, (void *)0);
}

// create_pointers
// file x11/xt.h line 213
void create_pointers(struct _WidgetRec *app_shell)
{
  struct anonymous_22 white;
  struct anonymous_22 red;
  struct anonymous_22 dummy;
  left_ptr=XCreateFontCursor(dpy, (unsigned int)68);
  menu_ptr=XCreateFontCursor(dpy, (unsigned int)94);
  qu_ptr=XCreateFontCursor(dpy, (unsigned int)92);
  signed int return_value_XAllocNamedColor_1;
  if(vinfo.depth >= 2)
  {
    signed int return_value_XAllocNamedColor_2;
    return_value_XAllocNamedColor_2=XAllocNamedColor(dpy, colormap, "white", &white, &dummy);
    if(!(return_value_XAllocNamedColor_2 == 0))
    {
      return_value_XAllocNamedColor_1=XAllocNamedColor(dpy, colormap, "red", &red, &dummy);
      if(!(return_value_XAllocNamedColor_1 == 0))
      {
        XRecolorCursor(dpy, left_ptr, &red, &white);
        XRecolorCursor(dpy, menu_ptr, &red, &white);
        XRecolorCursor(dpy, qu_ptr, &red, &white);
      }

    }

  }

}

// create_pref
// file x11/motv.c line 2553
static void create_pref(void)
{
  struct _WidgetRec *rc1;
  struct _WidgetRec *frame;
  struct _WidgetRec *rc2;
  struct _WidgetRec *rc3;
  struct anonymous_11 create_pref__1__args[2l];
  pref_dlg=XmCreatePromptDialog(control_shell, "pref", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  struct _WidgetRec *return_value_XtParent_1;
  return_value_XtParent_1=XtParent(pref_dlg);
  XtAddEventHandler(return_value_XtParent_1, (unsigned long int)0, (char)1, (void (*)(struct _WidgetRec *, void *, union _XEvent *, char *))_XEditResCheckMessages, (void *)0);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_2;
  return_value_XmSelectionBoxGetChild_2=XmSelectionBoxGetChild(pref_dlg, (unsigned char)11);
  XtUnmanageChild(return_value_XmSelectionBoxGetChild_2);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_3;
  return_value_XmSelectionBoxGetChild_3=XmSelectionBoxGetChild(pref_dlg, (unsigned char)7);
  XtUnmanageChild(return_value_XmSelectionBoxGetChild_3);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_4;
  return_value_XmSelectionBoxGetChild_4=XmSelectionBoxGetChild(pref_dlg, (unsigned char)1);
  XtManageChild(return_value_XmSelectionBoxGetChild_4);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_5;
  return_value_XmSelectionBoxGetChild_5=XmSelectionBoxGetChild(pref_dlg, (unsigned char)13);
  XtUnmanageChild(return_value_XmSelectionBoxGetChild_5);
  rc1=XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass, pref_dlg, (void *)0);
  frame=XtVaCreateManagedWidget("fsF", xmFrameWidgetClass, rc1, (void *)0);
  XtVaCreateManagedWidget("fsL", xmLabelWidgetClass, frame, (void *)0);
  rc2=XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass, frame, (void *)0);
  pref_fs_toggle=XtVaCreateManagedWidget("fsT", xmToggleButtonWidgetClass, rc2, (void *)0);
  XtAddCallback(pref_fs_toggle, (char *)&_XmStrings[(signed long int)10591], pref_fst_cb, (void *)0);
  pref_fs_menu=XmCreatePulldownMenu(rc2, "fsM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  create_pref__1__args[(signed long int)0].name = (char *)&_XmStrings[(signed long int)9963];
  create_pref__1__args[(signed long int)0].value = (signed long int)pref_fs_menu;
  pref_fs_option=XmCreateOptionMenu(rc2, "fsO", create_pref__1__args, (unsigned int)1);
  XtManageChild(pref_fs_option);
  frame=XtVaCreateManagedWidget("mixF", xmFrameWidgetClass, rc1, (void *)0);
  XtVaCreateManagedWidget("mixL", xmLabelWidgetClass, frame, (void *)0);
  rc2=XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass, frame, (void *)0);
  pref_mix_toggle=XtVaCreateManagedWidget("mixT", xmToggleButtonWidgetClass, rc2, (void *)0);
  XtAddCallback(pref_mix_toggle, (char *)&_XmStrings[(signed long int)10591], pref_mix1_cb, (void *)0);
  pref_mix1_menu=XmCreatePulldownMenu(rc2, "mix1M", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  create_pref__1__args[(signed long int)0].name = (char *)&_XmStrings[(signed long int)9963];
  create_pref__1__args[(signed long int)0].value = (signed long int)pref_mix1_menu;
  pref_mix1_option=XmCreateOptionMenu(rc2, "mix1O", create_pref__1__args, (unsigned int)1);
  XtManageChild(pref_mix1_option);
  pref_mix2_menu=XmCreatePulldownMenu(rc2, "mix2M", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  create_pref__1__args[(signed long int)0].name = (char *)&_XmStrings[(signed long int)9963];
  create_pref__1__args[(signed long int)0].value = (signed long int)pref_mix2_menu;
  pref_mix2_option=XmCreateOptionMenu(rc2, "mix2O", create_pref__1__args, (unsigned int)1);
  XtManageChild(pref_mix2_option);
  frame=XtVaCreateManagedWidget("optF", xmFrameWidgetClass, rc1, (void *)0);
  XtVaCreateManagedWidget("optL", xmLabelWidgetClass, frame, (void *)0);
  rc2=XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass, frame, (void *)0);
  pref_osd=XtVaCreateManagedWidget("osd", xmToggleButtonWidgetClass, rc2, (void *)0);
  pref_ntsc=XtVaCreateManagedWidget("keypad-ntsc", xmToggleButtonWidgetClass, rc2, (void *)0);
  pref_partial=XtVaCreateManagedWidget("keypad-partial", xmToggleButtonWidgetClass, rc2, (void *)0);
  rc3=XtVaCreateManagedWidget("jpeg", xmRowColumnWidgetClass, rc2, (void *)0);
  XtVaCreateManagedWidget("label", xmLabelWidgetClass, rc3, (void *)0);
  pref_quality=XtVaCreateManagedWidget("quality", xmTextWidgetClass, rc3, (void *)0);
  XtAddCallback(pref_dlg, (char *)&_XmStrings[(signed long int)8560], pref_done_cb, (void *)0);
  XtAddCallback(pref_dlg, (char *)&_XmStrings[(signed long int)4859], pref_done_cb, (void *)0);
  XtAddCallback(pref_dlg, (char *)&_XmStrings[(signed long int)5319], pref_done_cb, (void *)0);
}

// create_prop
// file x11/motv.c line 812
static void create_prop(void)
{
  struct _WidgetRec *label;
  struct _WidgetRec *rowcol;
  prop_dlg=XmCreatePromptDialog(control_shell, "prop", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  struct _WidgetRec *return_value_XtParent_1;
  return_value_XtParent_1=XtParent(prop_dlg);
  XtAddEventHandler(return_value_XtParent_1, (unsigned long int)0, (char)1, (void (*)(struct _WidgetRec *, void *, union _XEvent *, char *))_XEditResCheckMessages, (void *)0);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_2;
  return_value_XmSelectionBoxGetChild_2=XmSelectionBoxGetChild(prop_dlg, (unsigned char)11);
  XtUnmanageChild(return_value_XmSelectionBoxGetChild_2);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_3;
  return_value_XmSelectionBoxGetChild_3=XmSelectionBoxGetChild(prop_dlg, (unsigned char)7);
  XtUnmanageChild(return_value_XmSelectionBoxGetChild_3);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_4;
  return_value_XmSelectionBoxGetChild_4=XmSelectionBoxGetChild(prop_dlg, (unsigned char)13);
  XtUnmanageChild(return_value_XmSelectionBoxGetChild_4);
  rowcol=XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass, prop_dlg, (void *)0);
  label=XtVaCreateManagedWidget("nameL", xmLabelWidgetClass, rowcol, (void *)0);
  prop_name=XtVaCreateManagedWidget("name", xmTextWidgetClass, rowcol, (void *)0);
  label=XtVaCreateManagedWidget("keyL", xmLabelWidgetClass, rowcol, (void *)0);
  prop_key=XtVaCreateManagedWidget("key", xmTextWidgetClass, rowcol, (void *)0);
  XtAddEventHandler(prop_key, (unsigned long int)(1L << 0), (char)0, chan_key_eh, (void *)0);
  label=XtVaCreateManagedWidget("groupL", xmLabelWidgetClass, rowcol, (void *)0);
  prop_group=XtVaCreateManagedWidget("group", xmTextWidgetClass, rowcol, (void *)0);
  label=XtVaCreateManagedWidget("channelL", xmLabelWidgetClass, rowcol, (void *)0);
  prop_channel=XtVaCreateManagedWidget("channel", xmComboBoxWidgetClass, rowcol, (void *)0);
  XtAddCallback(prop_channel, (char *)&_XmStrings[(signed long int)12761], chan_tune_cb, (void *)0);
  XtAddCallback(prop_dlg, (char *)&_XmStrings[(signed long int)8560], chan_apply_cb, (void *)0);
}

// create_scale
// file x11/motv.c line 1599
static void create_scale(void)
{
  struct _WidgetRec *form;
  struct _WidgetRec *attach;
  struct ng_attribute *attr;
  struct motif_attribute *a;
  signed int vol = 0;
  union __XmStringRec *str;
  scale_shell=XtVaAppCreateShell("scale", "MoTV", topLevelShellWidgetClass, dpy, (char *)&XtShellStrings[(signed long int)813], app_shell, (char *)&XtShellStrings[(signed long int)104], vinfo.visual, (char *)&XtStrings[(signed long int)154], colormap, (char *)&XtStrings[(signed long int)163], vinfo.depth, (char *)&_XmStrings[(signed long int)6018], 2, (void *)0);
  XtAddEventHandler(scale_shell, (unsigned long int)0, (char)1, (void (*)(struct _WidgetRec *, void *, union _XEvent *, char *))_XEditResCheckMessages, (void *)0);
  struct _XDisplay *return_value_XtDisplay_1;
  return_value_XtDisplay_1=XtDisplay(scale_shell);
  unsigned long int return_value_XInternAtom_2;
  return_value_XInternAtom_2=XInternAtom(return_value_XtDisplay_1, "WM_PROTOCOLS", 0);
  XmAddProtocolCallback(scale_shell, return_value_XInternAtom_2, WM_DELETE_WINDOW, popupdown_cb, (void *)scale_shell);
  form=XtVaCreateManagedWidget("form", xmFormWidgetClass, scale_shell, (void *)0);
  attach = (struct _WidgetRec *)(void *)0;
  attr = attrs;
  for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
  {
    if(attr->type == 1)
    {
      if(attr->id == 3)
      {
        if(!(vol == 0))
          goto __CPROVER_DUMP_L5;

        vol = vol + 1;
      }

      void *return_value_malloc_3;
      return_value_malloc_3=malloc(sizeof(struct motif_attribute) /*24ul*/ );
      a = (struct motif_attribute *)return_value_malloc_3;
      memset((void *)a, 0, sizeof(struct motif_attribute) /*24ul*/ );
      a->attr = attr;
      a->next = motif_attrs;
      motif_attrs = a;
      if(!(a->attr->id >= 10))
        a->widget=XtVaCreateManagedWidget(attr->name, xmScaleWidgetClass, form, (char *)&_XmStrings[(signed long int)10339], attach, (char *)&_XmStrings[(signed long int)8134], attr->min, (char *)&_XmStrings[(signed long int)7982], attr->max, (char *)&_XmStrings[(signed long int)5711], attr->points, (void *)0);

      else
      {
        str=XmStringGenerate((void *)(char *)attr->name, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
        a->widget=XtVaCreateManagedWidget(attr->name, xmScaleWidgetClass, form, (char *)&_XmStrings[(signed long int)10339], attach, (char *)&_XmStrings[(signed long int)10137], str, (char *)&_XmStrings[(signed long int)8134], attr->min, (char *)&_XmStrings[(signed long int)7982], attr->max, (char *)&_XmStrings[(signed long int)5711], attr->points, (void *)0);
        XmStringFree(str);
      }
      XtAddCallback(a->widget, (char *)&_XmStrings[(signed long int)10591], scroll_cb, (void *)a);
      XtAddCallback(a->widget, (char *)&_XmStrings[(signed long int)6221], scroll_cb, (void *)a);
      attach = a->widget;
    }


  __CPROVER_DUMP_L5:
    ;
  }
}

// create_strwin
// file x11/motv.c line 1828
static void create_strwin(void)
{
  struct _WidgetRec *form;
  struct _WidgetRec *push;
  struct _WidgetRec *rowcol;
  struct _WidgetRec *frame;
  struct _WidgetRec *fbox;
  struct FILE_DATA *h;
  struct anonymous_11 create_strwin__1__args[2l];
  str_shell=XtVaAppCreateShell("streamer", "MoTV", topLevelShellWidgetClass, dpy, (char *)&XtShellStrings[(signed long int)813], app_shell, (char *)&XtShellStrings[(signed long int)104], vinfo.visual, (char *)&XtStrings[(signed long int)154], colormap, (char *)&XtStrings[(signed long int)163], vinfo.depth, (char *)&_XmStrings[(signed long int)6018], 2, (void *)0);
  XtAddEventHandler(str_shell, (unsigned long int)0, (char)1, (void (*)(struct _WidgetRec *, void *, union _XEvent *, char *))_XEditResCheckMessages, (void *)0);
  struct _XDisplay *return_value_XtDisplay_1;
  return_value_XtDisplay_1=XtDisplay(str_shell);
  unsigned long int return_value_XInternAtom_2;
  return_value_XInternAtom_2=XInternAtom(return_value_XtDisplay_1, "WM_PROTOCOLS", 0);
  XmAddProtocolCallback(str_shell, return_value_XInternAtom_2, WM_DELETE_WINDOW, popupdown_cb, (void *)str_shell);
  form=XtVaCreateManagedWidget("form", xmFormWidgetClass, str_shell, (void *)0);
  frame=XtVaCreateManagedWidget("driverF", xmFrameWidgetClass, form, (void *)0);
  XtVaCreateManagedWidget("driverL", xmLabelWidgetClass, frame, (void *)0);
  driver_menu=XmCreatePulldownMenu(form, "driverM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  create_strwin__1__args[(signed long int)0].name = (char *)&_XmStrings[(signed long int)9963];
  create_strwin__1__args[(signed long int)0].value = (signed long int)driver_menu;
  driver_option=XmCreateOptionMenu(frame, "driver", create_strwin__1__args, (unsigned int)1);
  XtManageChild(driver_option);
  frame=XtVaCreateManagedWidget("videoF", xmFrameWidgetClass, form, (void *)0);
  XtVaCreateManagedWidget("videoL", xmLabelWidgetClass, frame, (void *)0);
  rowcol=XtVaCreateManagedWidget("videoB", xmRowColumnWidgetClass, frame, (void *)0);
  video_menu=XmCreatePulldownMenu(rowcol, "videoM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  create_strwin__1__args[(signed long int)0].name = (char *)&_XmStrings[(signed long int)9963];
  create_strwin__1__args[(signed long int)0].value = (signed long int)video_menu;
  video_option=XmCreateOptionMenu(rowcol, "video", create_strwin__1__args, (unsigned int)1);
  XtManageChild(video_option);
  XtVaCreateManagedWidget("fpsL", xmLabelWidgetClass, rowcol, (void *)0);
  m_fps=XtVaCreateManagedWidget("fps", xmComboBoxWidgetClass, rowcol, (void *)0);
  frame=XtVaCreateManagedWidget("audioF", xmFrameWidgetClass, form, (void *)0);
  XtVaCreateManagedWidget("audioL", xmLabelWidgetClass, frame, (void *)0);
  rowcol=XtVaCreateManagedWidget("audioB", xmRowColumnWidgetClass, frame, (void *)0);
  audio_menu=XmCreatePulldownMenu(rowcol, "audioM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  create_strwin__1__args[(signed long int)0].name = (char *)&_XmStrings[(signed long int)9963];
  create_strwin__1__args[(signed long int)0].value = (signed long int)audio_menu;
  audio_option=XmCreateOptionMenu(rowcol, "audio", create_strwin__1__args, (unsigned int)1);
  XtManageChild(audio_option);
  XtVaCreateManagedWidget("rateL", xmLabelWidgetClass, rowcol, (void *)0);
  m_rate=XtVaCreateManagedWidget("rate", xmComboBoxWidgetClass, rowcol, (void *)0);
  frame=XtVaCreateManagedWidget("fileF", xmFrameWidgetClass, form, (void *)0);
  XtVaCreateManagedWidget("fileL", xmLabelWidgetClass, frame, (void *)0);
  fbox=XtVaCreateManagedWidget("fbox", xmRowColumnWidgetClass, frame, (void *)0);
  rowcol=XtVaCreateManagedWidget("fvideoB", xmRowColumnWidgetClass, fbox, (void *)0);
  XtVaCreateManagedWidget("fvideoL", xmLabelWidgetClass, rowcol, (void *)0);
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(struct FILE_DATA) /*24ul*/ );
  h = (struct FILE_DATA *)return_value_malloc_3;
  memset((void *)h, 0, sizeof(struct FILE_DATA) /*24ul*/ );
  h->text=XtVaCreateManagedWidget("fvideo", xmTextWidgetClass, rowcol, (void *)0);
  m_fvideo = h->text;
  h->push=XtVaCreateManagedWidget("files", xmPushButtonWidgetClass, rowcol, (void *)0);
  XtAddCallback(h->push, (char *)&_XmStrings[(signed long int)4700], file_browse_cb, (void *)h);
  rowcol=XtVaCreateManagedWidget("faudioB", xmRowColumnWidgetClass, fbox, (void *)0);
  m_faudioL=XtVaCreateManagedWidget("faudioL", xmLabelWidgetClass, rowcol, (void *)0);
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(sizeof(struct FILE_DATA) /*24ul*/ );
  h = (struct FILE_DATA *)return_value_malloc_4;
  memset((void *)h, 0, sizeof(struct FILE_DATA) /*24ul*/ );
  h->text=XtVaCreateManagedWidget("faudio", xmTextWidgetClass, rowcol, (void *)0);
  m_faudio = h->text;
  h->push=XtVaCreateManagedWidget("files", xmPushButtonWidgetClass, rowcol, (void *)0);
  m_faudioB = h->push;
  XtAddCallback(h->push, (char *)&_XmStrings[(signed long int)4700], file_browse_cb, (void *)h);
  m_status=XtVaCreateManagedWidget("status", xmLabelWidgetClass, form, (void *)0);
  rowcol=XtVaCreateManagedWidget("buttons", xmRowColumnWidgetClass, form, (void *)0);
  push=XtVaCreateManagedWidget("rec", xmPushButtonWidgetClass, rowcol, (void *)0);
  add_cmd_callback(push, (char *)&_XmStrings[(signed long int)4700], "movie", "start", (const char *)(void *)0);
  push=XtVaCreateManagedWidget("stop", xmPushButtonWidgetClass, rowcol, (void *)0);
  add_cmd_callback(push, (char *)&_XmStrings[(signed long int)4700], "movie", "stop", (const char *)(void *)0);
  push=XtVaCreateManagedWidget("play", xmPushButtonWidgetClass, rowcol, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], exec_player_cb, (void *)0);
  push=XtVaCreateManagedWidget("cancel", xmPushButtonWidgetClass, rowcol, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], popupdown_cb, (void *)str_shell);
}

// create_vtx
// file x11/motv.c line 469
static void create_vtx(void)
{
  struct _WidgetRec *shell;
  struct _WidgetRec *label;
  shell=XtVaCreateWidget("vtx", transientShellWidgetClass, app_shell, (char *)&XtShellStrings[(signed long int)186], 1, (char *)&XtShellStrings[(signed long int)104], vinfo.visual, (char *)&XtStrings[(signed long int)154], colormap, (char *)&XtStrings[(signed long int)163], vinfo.depth, (void *)0);
  label=XtVaCreateManagedWidget("label", xmLabelWidgetClass, shell, (void *)0);
  vtx=vbi_render_init(shell, label, (struct vbi_state *)(void *)0);
}

// dattr_handler
// file common/commands.c line 980
static signed int dattr_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr = (struct ng_attribute *)(void *)0;
  unsigned int i;
  signed int return_value_strcasecmp_1;
  if(argc >= 1)
  {
    return_value_strcasecmp_1=strcasecmp(argv[(signed long int)0], "next");
    if(return_value_strcasecmp_1 == 0)
    {
      i = (unsigned int)0;
      for( ; !((unsigned long int)i >= 2ul); i = i + 1u)
      {
        cur_dattr = cur_dattr + 1;
        cur_dattr = cur_dattr % (signed int)(sizeof(signed int [5l]) /*20ul*/  / sizeof(char *) /*8ul*/ );
        attr=ng_attr_byid(attrs, dattr[(signed long int)cur_dattr]);
        if(!(attr == ((struct ng_attribute *)NULL)))
          break;

      }
      if(attr == ((struct ng_attribute *)NULL))
        return 0;

      argc = 0;
    }

  }

  if(attr == ((struct ng_attribute *)NULL))
    attr=ng_attr_byid(attrs, dattr[(signed long int)cur_dattr]);

  if(attr == ((struct ng_attribute *)NULL))
    return 0;

  else
  {
    signed int return_value_attr_handler_2;
    return_value_attr_handler_2=attr_handler((char *)attr->name, argc, argv);
    return return_value_attr_handler_2;
  }
}

// del_channel
// file ./common/channel.h line 73
void del_channel(signed int i)
{
  free((void *)channels[(signed long int)i]->name);
  if(!(channels[(signed long int)i]->key == ((char *)NULL)))
    free((void *)channels[(signed long int)i]->key);

  free((void *)channels[(signed long int)i]);
  count = count - 1;
  if(!(i >= count))
    memmove((void *)(channels + (signed long int)i), (const void *)(channels + (signed long int)i + (signed long int)1), (unsigned long int)(count - i) * sizeof(struct CHANNEL *) /*8ul*/ );

}

// delete_children
// file x11/motv.c line 224
static void delete_children(struct _WidgetRec *widget)
{
  struct _WidgetRec **children;
  struct _WidgetRec **list;
  unsigned int nchildren;
  unsigned int i;
  XtVaGetValues(widget, (char *)&XtStrings[(signed long int)145], &children, (char *)&XtStrings[(signed long int)493], &nchildren, (void *)0);
  if(!(nchildren == 0u))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct _WidgetRec **) /*8ul*/  * (unsigned long int)nchildren);
    list = (struct _WidgetRec **)return_value_malloc_1;
    memcpy((void *)list, (const void *)children, sizeof(struct _WidgetRec **) /*8ul*/  * (unsigned long int)nchildren);
    i = (unsigned int)0;
    for( ; !(i >= nchildren); i = i + 1u)
      XtDestroyWidget(list[(signed long int)i]);
    free((void *)list);
  }

}

// destroy_cb
// file x11/motv.c line 398
static void destroy_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  XtDestroyWidget((struct _WidgetRec *)clientdata);
}

// discover_media_devices
// file ./common/get_media_devices.h line 81
void * discover_media_devices(void)
{
  struct media_devices *md = (struct media_devices *)(void *)0;
  struct media_device_entry *md_entry = (struct media_device_entry *)(void *)0;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct media_devices) /*16ul*/ );
  md = (struct media_devices *)return_value_calloc_1;
  signed int return_value_get_class_3;
  signed int return_value_get_class_4;
  if(md == ((struct media_devices *)NULL))
    return (void *)0;

  else
  {
    md->md_size = (unsigned int)0;
    signed int return_value_get_class_2;
    return_value_get_class_2=get_class("video4linux", &md_entry, &md->md_size, add_v4l_class);
    if(return_value_get_class_2 == 0)
    {
      return_value_get_class_3=get_class("sound", &md_entry, &md->md_size, add_snd_class);
      if(!(return_value_get_class_3 == 0))
        goto error;

      return_value_get_class_4=get_class("dvb", &md_entry, &md->md_size, add_dvb_class);
      if(!(return_value_get_class_4 == 0))
        goto error;

      if(md_entry == ((struct media_device_entry *)NULL))
        goto error;

      qsort((void *)md_entry, (unsigned long int)md->md_size, sizeof(struct media_device_entry) /*32ul*/ , sort_media_device_entry);
      md->md_entry = md_entry;
      return (void *)md;
    }

    else
    {

    error:
      ;
      free_media_devices((void *)md);
      return (void *)0;
    }
  }
}

// display_media_devices
// file common/get_media_devices.c line 418
void display_media_devices(void *opaque)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i;
  char *prev = "";
  i = 0;
  for( ; !((unsigned int)i >= md->md_size); i = i + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(prev, md_ptr->device);
    if(!(return_value_strcmp_1 == 0))
    {
      printf("\nDevice %s:\n\t", md_ptr->device);
      prev = md_ptr->device;
    }

    const char *return_value_media_device_type_2;
    return_value_media_device_type_2=media_device_type(md_ptr->type);
    printf("%s(%s, dev %i:%i) ", md_ptr->node, return_value_media_device_type_2, md_ptr->major, md_ptr->minor);
    md_ptr = md_ptr + 1l;
  }
  printf("\n");
}

// display_onscreen
// file x11/xt.c line 556
static void display_onscreen(char *title)
{
  unsigned short int x;
  unsigned short int y;
  unsigned long int return_value_XtWindow_1;
  if(!(fs == 0))
  {
    if(!(use_osd == 0))
    {
      if(!(debug == 0))
        fprintf(stderr, "osd: show (%s)\n", title);

      XtVaGetValues(app_shell, (char *)&XtStrings[(signed long int)885], &x, (char *)&XtStrings[(signed long int)887], &y, (void *)0);
      XtVaSetValues(on_shell, (char *)&XtStrings[(signed long int)885], (signed int)x + osd_x, (char *)&XtStrings[(signed long int)887], (signed int)y + osd_y, (void *)0);
      toolkit_set_label(on_label, title);
      XtPopup(on_shell, (enum anonymous_17)XtGrabNone);
      if(stay_on_top >= 1 && !(wm_stay_on_top == ((void (*)(struct _XDisplay *, unsigned long int, signed int))NULL)))
      {
        return_value_XtWindow_1=XtWindow(on_shell);
        wm_stay_on_top(dpy, return_value_XtWindow_1, 1);
      }

      if(!(on_timer == 0ul))
        XtRemoveTimeOut(on_timer);

      on_timer=XtAppAddTimeOut(app_context, (unsigned long int)5000, popdown_onscreen, (void *)0);
      static signed int first = 1;
      if(!(first == 0))
      {
        first = 0;
        unsigned long int return_value_XtWindow_2;
        return_value_XtWindow_2=XtWindow(on_shell);
        XDefineCursor(dpy, return_value_XtWindow_2, no_ptr);
        unsigned long int return_value_XtWindow_3;
        return_value_XtWindow_3=XtWindow(on_label);
        XDefineCursor(dpy, return_value_XtWindow_3, no_ptr);
      }

    }

  }

}

// display_subtitle
// file x11/motv.c line 544
static void display_subtitle(struct vbi_page *pg, struct vbi_rect *rect)
{
  unsigned short int x;
  unsigned short int y;
  unsigned short int w;
  unsigned short int h;
  unsigned short int sw;
  unsigned short int sh;
  unsigned long int return_value_XtWindow_1;
  if(pg == ((struct vbi_page *)NULL))
    XtPopdown(vtx->shell);

  else
  {
    static unsigned long int pix;
    if(!(pix == 0ul))
      XFreePixmap(dpy, pix);

    pix=vbi_export_pixmap(vtx, pg, rect);
    XtVaSetValues(vtx->tt, (char *)&_XmStrings[(signed long int)7523], pix, (char *)&_XmStrings[(signed long int)7547], 1, (void *)0);
    XtVaGetValues(app_shell, (char *)&XtStrings[(signed long int)885], &x, (char *)&XtStrings[(signed long int)887], &y, (char *)&XtStrings[(signed long int)872], &w, (char *)&XtStrings[(signed long int)234], &h, (void *)0);
    XtVaGetValues(vtx->shell, (char *)&XtStrings[(signed long int)872], &sw, (char *)&XtStrings[(signed long int)234], &sh, (void *)0);
    XtVaSetValues(vtx->shell, (char *)&XtStrings[(signed long int)885], (signed int)x + ((signed int)w - (signed int)sw) / 2, (char *)&XtStrings[(signed long int)887], (((signed int)y + (signed int)h) - 10) - (signed int)sh, (void *)0);
    XtPopup(vtx->shell, (enum anonymous_17)XtGrabNone);
    if(stay_on_top >= 1 && !(wm_stay_on_top == ((void (*)(struct _XDisplay *, unsigned long int, signed int))NULL)))
    {
      return_value_XtWindow_1=XtWindow(vtx->shell);
      wm_stay_on_top(dpy, return_value_XtWindow_1, 1);
    }

    static signed int first = 1;
    if(!(first == 0))
    {
      first = 0;
      unsigned long int return_value_XtWindow_2;
      return_value_XtWindow_2=XtWindow(vtx->shell);
      XDefineCursor(dpy, return_value_XtWindow_2, left_ptr);
      unsigned long int return_value_XtWindow_3;
      return_value_XtWindow_3=XtWindow(vtx->tt);
      XDefineCursor(dpy, return_value_XtWindow_3, left_ptr);
    }

  }
}

// do_capture
// file x11/motv.c line 1728
static void do_capture(signed int from, signed int to, signed int tmp_switch)
{
  struct _WidgetRec **children;
  struct _XDisplay *return_value_XtDisplay_1;
  unsigned long int return_value_XtWindow_2;
  switch(from)
  {
    case 2:
    {
      video_gd_stop();
      if(tmp_switch == 0)
      {
        return_value_XtDisplay_1=XtDisplay(tv);
        return_value_XtWindow_2=XtWindow(tv);
        XClearArea(return_value_XtDisplay_1, return_value_XtWindow_2, 0, 0, (unsigned int)0, (unsigned int)0, 1);
      }

      break;
    }
    case 1:
      video_overlay(0);
  }
  switch(to)
  {
    case 2:
    {
      static signed int niced = 0;
      if(niced == 0)
      {
        niced = 10;
        nice(niced);
      }

      video_gd_start();
      break;
    }
    case 1:
      video_overlay(1);
  }
  XtVaGetValues(cap_menu, (char *)&XtStrings[(signed long int)145], &children, (void *)0);
  XmToggleButtonSetState(children[(signed long int)0], (char)(to == 1), (char)0);
  XmToggleButtonSetState(children[(signed long int)1], (char)(to == 2), (char)0);
  XmToggleButtonSetState(children[(signed long int)2], (char)(to == 0), (char)0);
}

// do_command
// file ./common/commands.h line 78
signed int do_command(signed int argc, char **argv)
{
  signed int i;
  signed int return_value_strcasecmp_1;
  if(argc == 0)
  {
    fprintf(stderr, "do_command: no argument\n");
    return -1;
  }

  else
  {
    if(!(debug == 0))
    {
      fprintf(stderr, "cmd:");
      i = 0;
      for( ; !(i >= argc); i = i + 1)
        fprintf(stderr, " \"%s\"", argv[(signed long int)i]);
      fprintf(stderr, "\n");
    }

    i = 0;
    for( ; !(commands[(signed long int)i].name == ((char *)NULL)); i = i + 1)
    {
      return_value_strcasecmp_1=strcasecmp(commands[(signed long int)i].name, argv[(signed long int)0]);
      if(return_value_strcasecmp_1 == 0)
        break;

    }
    if(commands[(signed long int)i].name == ((char *)NULL))
    {
      fprintf(stderr, "no handler for %s\n", argv[(signed long int)0]);
      return -1;
    }

    else
      if(!(argc + -1 >= commands[(signed long int)i].min_args))
      {
        fprintf(stderr, "no enough args for %s\n", argv[(signed long int)0]);
        return -1;
      }

      else
      {
        signed int return_value;
        return_value=commands[(signed long int)i].handler(argv[(signed long int)0], argc - 1, argv + (signed long int)1);
        return return_value;
      }
  }
}

// do_exit
// file x11/xt.h line 131
void do_exit(void)
{
  ExitCB((struct _WidgetRec *)(void *)0, (void *)0, (void *)0);
}

// do_fullscreen
// file x11/xt.h line 143
void do_fullscreen(void)
{
  unsigned long int root;
  unsigned long int child;
  signed int wpx;
  signed int wpy;
  signed int mask;
  unsigned int vp_width;
  unsigned int vp_height;
  if(!(wm_fullscreen == ((void (*)(struct _XDisplay *, unsigned long int, signed int))NULL)) && !(use_wm_fullscreen == 0))
  {
    fs = (signed int)!(fs != 0);
    if(!(debug == 0))
      fprintf(stderr, "fullscreen %s via netwm\n", fs != 0 ? "on" : "off");

    do_modeswitch(fs, (signed int *)&vp_width, (signed int *)&vp_height);
    XSync(dpy, 0);
    unsigned long int return_value_XtWindow_1;
    return_value_XtWindow_1=XtWindow(app_shell);
    wm_fullscreen(dpy, return_value_XtWindow_1, fs);
    if(fs == 0 && !(on_timer == 0ul))
    {
      XtPopdown(on_shell);
      XtRemoveTimeOut(on_timer);
      on_timer = (unsigned long int)0;
    }

    do_screensaver(fs);
  }

  struct anonymous_0 *return_value_XtScreen_2;
  unsigned long int return_value_XtWindow_7;
  static signed int rpy;
  static signed int rpx;
  static signed int warp_pointer;
  static unsigned short int y;
  static unsigned short int x;
  static unsigned short int h;
  static unsigned short int w;
  if(!(fs == 0))
  {
    if(!(debug == 0))
      fprintf(stderr, "turning fs off (%dx%d+%d+%d)\n", w, h, x, y);

    do_modeswitch(0, (signed int *)&vp_width, (signed int *)&vp_height);
    if(!(on_timer == 0ul))
    {
      XtPopdown(on_shell);
      XtRemoveTimeOut(on_timer);
      on_timer = (unsigned long int)0;
    }

    XtVaSetValues(app_shell, (char *)&XtShellStrings[(signed long int)627], 32, (char *)&XtShellStrings[(signed long int)645], 24, (char *)&XtStrings[(signed long int)885], (signed int)x + fs_xoff, (char *)&XtStrings[(signed long int)887], (signed int)y + fs_yoff, (char *)&XtStrings[(signed long int)872], w, (char *)&XtStrings[(signed long int)234], h, (void *)0);
    do_screensaver(0);
    if(!(warp_pointer == 0))
    {
      return_value_XtScreen_2=XtScreen(tv);
      XWarpPointer(dpy, (unsigned long int)0L, return_value_XtScreen_2->root, 0, 0, (unsigned int)0, (unsigned int)0, rpx, rpy);
    }

    fs = 0;
  }

  else
  {
    signed int vp_x;
    signed int vp_y;
    if(!(debug == 0))
      fprintf(stderr, "turning fs on\n");

    struct anonymous_0 *return_value_XtScreen_3;
    return_value_XtScreen_3=XtScreen(tv);
    XQueryPointer(dpy, return_value_XtScreen_3->root, &root, &child, &rpx, &rpy, &wpx, &wpy, (unsigned int *)&mask);
    vp_x = 0;
    vp_y = 0;
    do_modeswitch(1, (signed int *)&vp_width, (signed int *)&vp_height);
    if(!(vp_width >= sheight) || !(vp_width >= swidth))
    {
      warp_pointer = 1;
      struct anonymous_0 *return_value_XtScreen_4;
      return_value_XtScreen_4=XtScreen(tv);
      XWarpPointer(dpy, (unsigned long int)0L, return_value_XtScreen_4->root, 0, 0, (unsigned int)0, (unsigned int)0, (signed int)(vp_width / (unsigned int)2), (signed int)(vp_height / (unsigned int)2));
      signed int return_value_XDefaultScreen_5;
      return_value_XDefaultScreen_5=XDefaultScreen(dpy);
      XF86VidModeSetViewPort(dpy, return_value_XDefaultScreen_5, 0, 0);
    }

    XtVaGetValues(app_shell, (char *)&XtStrings[(signed long int)885], &x, (char *)&XtStrings[(signed long int)887], &y, (char *)&XtStrings[(signed long int)872], &w, (char *)&XtStrings[(signed long int)234], &h, (void *)0);
    if(!(nxinerama == 0))
    {
      signed int i = 0;
      for( ; !(i >= nxinerama); i = i + 1)
        if((signed int)x >= (signed int)(xinerama + (signed long int)i)->x_org)
        {
          if((signed int)y >= (signed int)(xinerama + (signed long int)i)->y_org)
          {
            if(!((signed int)x >= (signed int)(xinerama + (signed long int)i)->width + (signed int)(xinerama + (signed long int)i)->x_org))
            {
              if(!((signed int)y >= (signed int)(xinerama + (signed long int)i)->height + (signed int)(xinerama + (signed long int)i)->y_org))
              {
                vp_x = (signed int)(xinerama + (signed long int)i)->x_org;
                vp_y = (signed int)(xinerama + (signed long int)i)->y_org;
                vp_width = (unsigned int)(xinerama + (signed long int)i)->width;
                vp_height = (unsigned int)(xinerama + (signed long int)i)->height;
                break;
              }

            }

          }

        }

    }

    if(!(debug == 0))
      fprintf(stderr, "viewport: %dx%d+%d+%d\n", vp_width, vp_height, vp_x, vp_y);

    XtVaSetValues(app_shell, (char *)&XtShellStrings[(signed long int)627], 1, (char *)&XtShellStrings[(signed long int)645], 1, (void *)0);
    XtVaSetValues(app_shell, (char *)&XtStrings[(signed long int)885], (vp_x & 0xfffc) + fs_xoff, (char *)&XtStrings[(signed long int)887], vp_y + fs_yoff, (char *)&XtStrings[(signed long int)872], vp_width, (char *)&XtStrings[(signed long int)234], vp_height, (void *)0);
    unsigned long int return_value_XtWindow_6;
    return_value_XtWindow_6=XtWindow(app_shell);
    XRaiseWindow(dpy, return_value_XtWindow_6);
    do_screensaver(1);
    if(!(warp_pointer == 0))
    {
      return_value_XtWindow_7=XtWindow(tv);
      XWarpPointer(dpy, (unsigned long int)0L, return_value_XtWindow_7, 0, 0, (unsigned int)0, (unsigned int)0, 30, 15);
    }

    fs = 1;
  }
  XtAppAddWorkProc(app_context, MyResize, (void *)0);
}

// do_modeswitch
// file x11/xt.c line 948
static void do_modeswitch(signed int fs_state, signed int *vp_width, signed int *vp_height)
{
  *vp_width = (signed int)swidth;
  *vp_height = (signed int)sheight;
  if(!(have_vm == 0))
    do_vidmode_modeswitch(fs_state, vp_width, vp_height);

  if(have_vm == 0 && !(have_randr == 0))
    do_randr_modeswitch(fs_state, vp_width, vp_height);

}

// do_motif_fullscreen
// file x11/motv.c line 1765
static void do_motif_fullscreen(void)
{
  XmToggleButtonSetState(w_full, (char)!(fs != 0), (char)0);
  do_fullscreen();
}

// do_movie_record
// file x11/motv.c line 2036
static void do_movie_record(signed int argc, char **argv)
{
  char *fvideo;
  char *faudio;
  struct ng_video_fmt do_movie_record__1__video;
  struct ng_audio_fmt audio;
  struct ng_writer *wr;
  struct _WidgetRec **children;
  unsigned int nchildren;
  struct _WidgetRec *text;
  signed int i;
  signed int rate;
  signed int fps;
  signed int return_value_strcasecmp_2;
  if(argc >= 2)
  {
    return_value_strcasecmp_2=strcasecmp(argv[(signed long int)0], "driver");
    if(return_value_strcasecmp_2 == 0)
    {
      struct list_head *item;
      struct ng_writer *writer;
      if(!(debug == 0))
        fprintf(stderr, "set driver: %s\n", argv[(signed long int)1]);

      XtVaGetValues(driver_menu, (char *)&XtStrings[(signed long int)145], &children, (char *)&XtStrings[(signed long int)493], &nchildren, (void *)0);
      i = 0;
      item = (&ng_writers)->next;
      for( ; !(item == &ng_writers); item = item->next)
      {
        writer = (struct ng_writer *)((char *)item - (signed long int)(unsigned long int)&((struct ng_writer *)0)->list);
        signed int return_value_strcasecmp_1;
        return_value_strcasecmp_1=strcasecmp(argv[(signed long int)1], writer->name);
        if(return_value_strcasecmp_1 == 0)
        {
          movie_driver = writer;
          i_movie_driver = (unsigned int)i;
        }

        i = i + 1;
      }
      update_movie_menus();
    }

  }

  signed int return_value_strcasecmp_5;
  if(argc >= 2)
  {
    return_value_strcasecmp_5=strcasecmp(argv[(signed long int)0], "audio");
    if(return_value_strcasecmp_5 == 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "set audio: %s\n", argv[(signed long int)1]);

      XtVaGetValues(audio_menu, (char *)&XtStrings[(signed long int)145], &children, (char *)&XtStrings[(signed long int)493], &nchildren, (void *)0);
      i = 0;
      for( ; !((movie_driver->audio + (signed long int)i)->name == ((char *)NULL)); i = i + 1)
      {
        signed int return_value_strcasecmp_3;
        return_value_strcasecmp_3=strcasecmp(argv[(signed long int)1], (movie_driver->audio + (signed long int)i)->name);
        if(return_value_strcasecmp_3 == 0)
        {
          XtVaSetValues(audio_option, (char *)&_XmStrings[(signed long int)8040], children[(signed long int)i], (void *)0);
          movie_audio = (unsigned int)i;
        }

      }
      signed int return_value_strcmp_4;
      return_value_strcmp_4=strcmp(argv[(signed long int)1], "none");
      if(return_value_strcmp_4 == 0)
      {
        XtVaSetValues(audio_option, (char *)&_XmStrings[(signed long int)8040], children[(signed long int)i], (void *)0);
        movie_audio = (unsigned int)i;
      }

    }

  }

  signed int return_value_strcasecmp_7;
  if(argc >= 2)
  {
    return_value_strcasecmp_7=strcasecmp(argv[(signed long int)0], "video");
    if(return_value_strcasecmp_7 == 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "set video: %s\n", argv[(signed long int)1]);

      XtVaGetValues(video_menu, (char *)&XtStrings[(signed long int)145], &children, (char *)&XtStrings[(signed long int)493], &nchildren, (void *)0);
      i = 0;
      for( ; !((movie_driver->video + (signed long int)i)->name == ((char *)NULL)); i = i + 1)
      {
        signed int return_value_strcasecmp_6;
        return_value_strcasecmp_6=strcasecmp(argv[(signed long int)1], (movie_driver->video + (signed long int)i)->name);
        if(return_value_strcasecmp_6 == 0)
        {
          XtVaSetValues(video_option, (char *)&_XmStrings[(signed long int)8040], children[(signed long int)i], (void *)0);
          movie_video = (unsigned int)i;
        }

      }
    }

  }

  signed int return_value_strcasecmp_8;
  if(argc >= 2)
  {
    return_value_strcasecmp_8=strcasecmp(argv[(signed long int)0], "rate");
    if(return_value_strcasecmp_8 == 0)
    {
      XtVaGetValues(m_rate, (char *)&_XmStrings[(signed long int)18880], &text, (void *)0);
      XmTextSetString(text, argv[(signed long int)1]);
    }

  }

  signed int return_value_strcasecmp_9;
  if(argc >= 2)
  {
    return_value_strcasecmp_9=strcasecmp(argv[(signed long int)0], "fps");
    if(return_value_strcasecmp_9 == 0)
    {
      XtVaGetValues(m_fps, (char *)&_XmStrings[(signed long int)18880], &text, (void *)0);
      XmTextSetString(text, argv[(signed long int)1]);
    }

  }

  signed int return_value_strcasecmp_10;
  if(argc >= 2)
  {
    return_value_strcasecmp_10=strcasecmp(argv[(signed long int)0], "fvideo");
    if(return_value_strcasecmp_10 == 0)
      XmTextSetString(m_fvideo, argv[(signed long int)1]);

  }

  signed int return_value_strcasecmp_11;
  if(argc >= 2)
  {
    return_value_strcasecmp_11=strcasecmp(argv[(signed long int)0], "faudio");
    if(return_value_strcasecmp_11 == 0)
      XmTextSetString(m_faudio, argv[(signed long int)1]);

  }

  signed int return_value_strcasecmp_17;
  if(argc >= 1)
  {
    return_value_strcasecmp_17=strcasecmp(argv[(signed long int)0], "start");
    if(return_value_strcasecmp_17 == 0)
    {
      if(!(cur_movie == 0))
        goto __CPROVER_DUMP_L35;

      cur_movie = 1;
      movie_blit = (signed int)(cur_capture == 2);
      video_gd_suspend();
      XmToggleButtonSetState(levels_toggle, (char)0, (char)1);
      fvideo=XmTextGetString(m_fvideo);
      faudio=XmTextGetString(m_faudio);
      fvideo=tilde_expand(fvideo);
      faudio=tilde_expand(faudio);
      XtVaGetValues(m_rate, (char *)&_XmStrings[(signed long int)18880], &text, (void *)0);
      char *return_value_XmTextGetString_12;
      return_value_XmTextGetString_12=XmTextGetString(text);
      rate=atoi(return_value_XmTextGetString_12);
      XtVaGetValues(m_fps, (char *)&_XmStrings[(signed long int)18880], &text, (void *)0);
      char *return_value_XmTextGetString_13;
      return_value_XmTextGetString_13=XmTextGetString(text);
      double return_value_atof_14;
      return_value_atof_14=atof(return_value_XmTextGetString_13);
      fps = (signed int)(return_value_atof_14 * (double)1000);
      memset((void *)&do_movie_record__1__video, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
      memset((void *)&audio, 0, sizeof(struct ng_audio_fmt) /*8ul*/ );
      wr = movie_driver;
      do_movie_record__1__video.fmtid = (wr->video + (signed long int)movie_video)->fmtid;
      do_movie_record__1__video.width = cur_tv_width;
      do_movie_record__1__video.height = cur_tv_height;
      audio.fmtid = (wr->audio + (signed long int)movie_audio)->fmtid;
      audio.rate = (unsigned int)rate;
      struct movie_handle *return_value_movie_writer_init_15;
      return_value_movie_writer_init_15=movie_writer_init(fvideo, faudio, wr, &do_movie_record__1__video, (wr->video + (signed long int)movie_video)->priv, fps, &audio, (wr->audio + (signed long int)movie_audio)->priv, args.dspdev, args.bufcount, args.parallel);
      movie_state = (void *)return_value_movie_writer_init_15;
      if(movie_state == NULL)
      {
        video_gd_restart();
        cur_movie = 0;
        toolkit_set_label(m_status, "error [init]");
        goto __CPROVER_DUMP_L35;
      }

      signed int return_value_movie_writer_start_16;
      return_value_movie_writer_start_16=movie_writer_start((struct movie_handle *)movie_state);
      if(!(return_value_movie_writer_start_16 == 0))
      {
        movie_writer_stop((struct movie_handle *)movie_state);
        video_gd_restart();
        cur_movie = 0;
        toolkit_set_label(m_status, "error [start]");
        goto __CPROVER_DUMP_L35;
      }

      rec_work_id=XtAppAddWorkProc(app_context, rec_work, (void *)0);
      toolkit_set_label(m_status, "recording");
      goto __CPROVER_DUMP_L35;
    }

  }

  signed int return_value_strcasecmp_18;
  if(argc >= 1)
  {
    return_value_strcasecmp_18=strcasecmp(argv[(signed long int)0], "stop");
    if(return_value_strcasecmp_18 == 0)
    {
      if(cur_movie == 0)
        goto __CPROVER_DUMP_L35;

      movie_writer_stop((struct movie_handle *)movie_state);
      XtRemoveWorkProc(rec_work_id);
      rec_work_id = (unsigned long int)0;
      video_gd_restart();
      cur_movie = 0;
      goto __CPROVER_DUMP_L35;
    }

  }


__CPROVER_DUMP_L35:
  ;
}

// do_ontop
// file x11/motv.c line 284
static void do_ontop(char state)
{
  unsigned int i;
  unsigned long int return_value_XtWindow_3;
  if(!(wm_stay_on_top == ((void (*)(struct _XDisplay *, unsigned long int, signed int))NULL)))
  {
    stay_on_top = (signed int)state;
    unsigned long int return_value_XtWindow_1;
    return_value_XtWindow_1=XtWindow(app_shell);
    wm_stay_on_top(dpy, return_value_XtWindow_1, stay_on_top);
    unsigned long int return_value_XtWindow_2;
    return_value_XtWindow_2=XtWindow(on_shell);
    wm_stay_on_top(dpy, return_value_XtWindow_2, stay_on_top);
    i = (unsigned int)0;
    if(!((unsigned long int)i >= 5ul))
    {
      return_value_XtWindow_3=XtWindow(*my_toplevels[(signed long int)i].shell);
      wm_stay_on_top(dpy, return_value_XtWindow_3, stay_on_top == -1 ? 0 : stay_on_top);
      i = i + 1u;
    }

    XmToggleButtonSetState(b_ontop, state, (char)0);
  }

}

// do_randr_modeswitch
// file x11/xt.c line 905
static void do_randr_modeswitch(signed int fs_state, signed int *vp_width, signed int *vp_height)
{
  unsigned long int root = (&((struct anonymous_10 *)dpy)->screens[(signed long int)((struct anonymous_10 *)dpy)->default_screen])->root;
  struct _XRRScreenConfiguration *sc;
  unsigned short int rotation;
  unsigned short int current;
  unsigned short int new;
  unsigned short int i;
  sc=XRRGetScreenInfo(dpy, root);
  current=XRRConfigCurrentConfiguration(sc, &rotation);
  new = current;
  static unsigned short int normal;
  if(!(fs_state == 0))
  {
    normal = current;
    new = current;
    i = (unsigned short int)0;
    for( ; !((signed int)i >= nrandr); i = i + 1)
      if((randr + (signed long int)i)->width == fs_width)
      {
        if((randr + (signed long int)i)->height == fs_height)
        {
          new = i;
          break;
        }

      }

  }

  else
    new = normal;
  if(!(new == current))
  {
    if(!(debug == 0))
      fprintf(stderr, "randr: switch to %dx%d\n", (randr + (signed long int)new)->width, (randr + (signed long int)new)->height);

    XRRSetScreenConfig(dpy, sc, root, (signed int)new, rotation, (unsigned long int)0L);
  }

  XRRFreeScreenConfigInfo(sc);
  *vp_width = (randr + (signed long int)new)->width;
  *vp_height = (randr + (signed long int)new)->height;
}

// do_rec_status
// file x11/motv.c line 2181
static void do_rec_status(char *message)
{
  toolkit_set_label(m_status, message);
}

// do_screensaver
// file x11/xt.c line 974
static void do_screensaver(signed int fs_state)
{
  unsigned short int dpms_state;
  signed int dpms_dummy;
  signed int return_value_DPMSCapable_1;
  signed int return_value_DPMSCapable_3;
  static unsigned char dpms_on;
  static signed int allow_exposures;
  static signed int prefer_blanking;
  static signed int interval;
  static signed int timeout;
  if(!(fs_state == 0))
  {
    XGetScreenSaver(dpy, &timeout, &interval, &prefer_blanking, &allow_exposures);
    XSetScreenSaver(dpy, 0, 0, 2, 2);
    signed int return_value_DPMSQueryExtension_2;
    return_value_DPMSQueryExtension_2=DPMSQueryExtension(dpy, &dpms_dummy, &dpms_dummy);
    if(!(return_value_DPMSQueryExtension_2 == 0))
    {
      return_value_DPMSCapable_1=DPMSCapable(dpy);
      if(!(return_value_DPMSCapable_1 == 0))
      {
        DPMSInfo(dpy, &dpms_state, &dpms_on);
        DPMSDisable(dpy);
      }

    }

    xscreensaver_timer=XtAppAddTimeOut(app_context, (unsigned long int)60000, xscreensaver_timefunc, (void *)0);
  }

  else
  {
    XSetScreenSaver(dpy, timeout, interval, prefer_blanking, allow_exposures);
    signed int return_value_DPMSQueryExtension_4;
    return_value_DPMSQueryExtension_4=DPMSQueryExtension(dpy, &dpms_dummy, &dpms_dummy);
    if(!(return_value_DPMSQueryExtension_4 == 0))
    {
      return_value_DPMSCapable_3=DPMSCapable(dpy);
      if(!(return_value_DPMSCapable_3 == 0))
      {
        if(!(dpms_on == 0))
          DPMSEnable(dpy);

      }

    }

    if(!(xscreensaver_timer == 0ul))
      XtRemoveTimeOut(xscreensaver_timer);

  }
}

// do_va_cmd
// file ./common/commands.h line 77
signed int do_va_cmd(signed int argc, ...)
{
  __builtin_va_list ap;
  signed int i;
  char *argv[32l];
  va_start(ap, argc);
  i = 0;
  for( ; !(i >= argc); i = i + 1)
    argv[(signed long int)i]=va_arg(ap, __typeof__(argv[(signed long int)i]));
  argv[(signed long int)i] = (char *)(void *)0;
  va_end(ap);
  signed int return_value_do_command_1;
  return_value_do_command_1=do_command(argc, argv);
  return return_value_do_command_1;
}

// do_vidmode_modeswitch
// file x11/xt.c line 850
static void do_vidmode_modeswitch(signed int fs_state, signed int *vp_width, signed int *vp_height)
{
  signed int i;
  static signed int vm_switched;
  static struct anonymous_15 *vm_current = (struct anonymous_15 *)(void *)0;
  if(!(fs_state == 0))
  {
    signed int return_value_XDefaultScreen_1;
    return_value_XDefaultScreen_1=XDefaultScreen(dpy);
    XF86VidModeGetModeLine(dpy, return_value_XDefaultScreen_1, &vm_dot, &vm_line);
    signed int return_value_XDefaultScreen_2;
    return_value_XDefaultScreen_2=XDefaultScreen(dpy);
    XF86VidModeGetAllModeLines(dpy, return_value_XDefaultScreen_2, &vm_count, &vm_modelines);
    static struct anonymous_15 *vm_fullscreen = (struct anonymous_15 *)(void *)0;
    vm_fullscreen = (struct anonymous_15 *)(void *)0;
    i = 0;
    for( ; !(i >= vm_count); i = i + 1)
    {
      if(fs_width == (signed int)vm_modelines[(signed long int)i]->hdisplay)
      {
        if(fs_height == (signed int)vm_modelines[(signed long int)i]->vdisplay)
        {
          if(vm_fullscreen == ((struct anonymous_15 *)NULL))
            vm_fullscreen = vm_modelines[(signed long int)i];

        }

      }

      if(vm_line.hdisplay == vm_modelines[(signed long int)i]->hdisplay)
      {
        if(vm_line.vdisplay == vm_modelines[(signed long int)i]->vdisplay)
        {
          if(vm_current == ((struct anonymous_15 *)NULL))
            vm_current = vm_modelines[(signed long int)i];

        }

      }

    }
    if(!(debug == 0))
    {
      fprintf(stderr, "vm: current=%dx%d", vm_current->hdisplay, vm_current->vdisplay);
      if(!(vm_fullscreen == ((struct anonymous_15 *)NULL)))
        fprintf(stderr, "fullscreen=%dx%d", vm_fullscreen->hdisplay, vm_fullscreen->vdisplay);

      fprintf(stderr, "\n");
    }

    _Bool tmp_if_expr_3;
    if(!(vm_current == ((struct anonymous_15 *)NULL)) && !(vm_fullscreen == ((struct anonymous_15 *)NULL)))
      tmp_if_expr_3 = vm_fullscreen->hdisplay != vm_current->hdisplay ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    _Bool tmp_if_expr_4;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = vm_fullscreen->vdisplay != vm_current->vdisplay ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      set_vidmode(vm_fullscreen);
      vm_switched = 1;
      *vp_width = (signed int)vm_fullscreen->hdisplay;
      *vp_height = (signed int)vm_fullscreen->vdisplay;
    }

    else
    {
      vm_switched = 0;
      *vp_width = (signed int)vm_current->hdisplay;
      *vp_height = (signed int)vm_current->vdisplay;
    }
  }

  else
    if(!(vm_switched == 0))
    {
      set_vidmode(vm_current);
      vm_switched = 0;
    }

}

// do_write_jpeg
// file libng/writefile.c line 87
static signed int do_write_jpeg(struct _IO_FILE *fp, struct ng_video_buf *buf, signed int quality, signed int gray)
{
  struct jpeg_compress_struct cinfo;
  struct jpeg_error_mgr jerr;
  unsigned int i;
  unsigned char *line;
  signed int line_length;
  cinfo.err=jpeg_std_error(&jerr);
  jpeg_CreateCompress(&cinfo, 62, (unsigned long int)sizeof(struct jpeg_compress_struct) /*520ul*/ );
  jpeg_stdio_dest(&cinfo, fp);
  cinfo.image_width = buf->fmt.width;
  cinfo.image_height = buf->fmt.height;
  cinfo.input_components = gray != 0 ? 1 : 3;
  cinfo.in_color_space = (enum anonymous_123)(gray != 0 ? JCS_GRAYSCALE : JCS_RGB);
  jpeg_set_defaults(&cinfo);
  jpeg_set_quality(&cinfo, quality, 1);
  jpeg_start_compress(&cinfo, 1);
  unsigned int tmp_if_expr_1;
  if(!(gray == 0))
    tmp_if_expr_1 = buf->fmt.width;

  else
    tmp_if_expr_1 = buf->fmt.width * (unsigned int)3;
  line_length = (signed int)tmp_if_expr_1;
  i = (unsigned int)0;
  line = buf->data;
  for( ; !(i >= buf->fmt.height); line = line + (signed long int)line_length)
  {
    jpeg_write_scanlines(&cinfo, &line, (unsigned int)1);
    i = i + 1u;
  }
  jpeg_finish_compress(&cinfo);
  jpeg_destroy_compress(&cinfo);
  fclose(fp);
  return 0;
}

// event_dispatch
// file ./common/event.h line 23
signed int event_dispatch(char *event)
{
  struct event_entry *entry = (struct event_entry *)(void *)0;
  char *name;
  char *arg;
  char *h;
  char *argv[16l];
  signed int argc;
  h=strchr(event, 40);
  if(!(h == ((char *)NULL)))
  {
    name = event;
    arg = h + (signed long int)1;
    *h = (char)0;
    h=strchr(arg, 41);
    if(!(h == ((char *)NULL)))
      *h = (char)0;

    if(!(debug == 0))
      fprintf(stderr, "ev: dispatch name=%s arg=%s\n", name, arg);

  }

  else
  {
    name = event;
    arg = (char *)(void *)0;
    if(!(debug == 0))
      fprintf(stderr, "ev: dispatch name=%s\n", name);

  }
  signed int return_value_strcasecmp_1;
  if(entry == ((struct event_entry *)NULL))
  {
    entry = event_conf_list;
    for( ; !(entry == ((struct event_entry *)NULL)); entry = entry->next)
    {
      return_value_strcasecmp_1=strcasecmp(name, entry->event);
      if(return_value_strcasecmp_1 == 0)
        break;

    }
  }

  signed int return_value_strcasecmp_2;
  if(entry == ((struct event_entry *)NULL))
  {
    entry = event_builtin_list;
    for( ; !(entry == ((struct event_entry *)NULL)); entry = entry->next)
    {
      return_value_strcasecmp_2=strcasecmp(name, entry->event);
      if(return_value_strcasecmp_2 == 0)
        break;

    }
  }

  if(entry == ((struct event_entry *)NULL))
  {
    if(!(debug == 0))
      fprintf(stderr, "ev: 404: %s\n", name);

    return 0;
  }

  else
  {
    memcpy((void *)argv, (const void *)entry->argv, sizeof(char *[16l]) /*128ul*/ );
    argc = entry->argc;
    if(!(arg == ((char *)NULL)))
    {
      signed int tmp_post_3 = argc;
      argc = argc + 1;
      argv[(signed long int)tmp_post_3] = arg;
    }

    do_command(argc, argv);
    return 0;
  }
}

// event_readconfig
// file common/event.h line 20
void event_readconfig(void)
{
  char **list;
  char *val;
  list=cfg_list_entries("eventmap");
  if(!(list == ((char **)NULL)))
    for( ; !(*list == ((char *)NULL)); list = list + 1l)
    {
      val=cfg_get_str("eventmap", *list);
      if(!(val == ((char *)NULL)))
        event_register(*list, val);

    }

}

// event_register
// file common/event.c line 54
signed int event_register(char *event, char *action)
{
  struct event_entry *entry;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct event_entry) /*528ul*/ );
  entry = (struct event_entry *)return_value_malloc_1;
  memset((void *)entry, 0, sizeof(struct event_entry) /*528ul*/ );
  strncpy(entry->event, event, (unsigned long int)127);
  strncpy(entry->action, action, (unsigned long int)127);
  entry->next = event_conf_list;
  event_conf_list = entry;
  parse_action(entry);
  if(!(debug == 0))
    fprintf(stderr, "ev: reg conf \"%s\" => \"%s\"\n", (const void *)entry->event, (const void *)entry->action);

  return 0;
}

// event_register_list
// file common/event.h line 18
signed int event_register_list(struct event_entry *entry)
{
  _Bool tmp_if_expr_1;
  do
  {
    if(!(entry == ((struct event_entry *)NULL)))
      tmp_if_expr_1 = 0 != (signed int)entry->event[(signed long int)0] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    entry->next = event_builtin_list;
    event_builtin_list = entry;
    parse_action(entry);
    if(!(debug == 0))
      fprintf(stderr, "ev: reg built-in \"%s\" => \"%s\"\n", (const void *)entry->event, (const void *)entry->action);

    entry = entry + 1l;
  }
  while((_Bool)1);
  return 0;
}

// event_writeconfig
// file common/event.h line 21
void event_writeconfig(struct _IO_FILE *fp)
{
  struct event_entry *entry;
  if(!(event_conf_list == ((struct event_entry *)NULL)))
  {
    fprintf(fp, "[eventmap]\n");
    entry = event_conf_list;
    for( ; !(entry == ((struct event_entry *)NULL)); entry = entry->next)
      fprintf(fp, "%s = %s\n", (const void *)entry->event, (const void *)entry->action);
    fprintf(fp, "\n");
  }

}

// exec_done
// file x11/xt.c line 605
void exec_done(signed int signal)
{
  signed int pid;
  signed int exec_done__1__stat;
  if(!(debug == 0))
    fprintf(stderr, "got sigchild\n");

  pid=waitpid(-1, &exec_done__1__stat, 2 | 1);
  if(!(debug == 0))
  {
    /* tag-#anon#lUN[lS32'__in'|S32'__i'] */
union anonymous_108
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
    ;
    if(pid == -1)
      perror("waitpid");

    else
      if(pid == 0)
        fprintf(stderr, "oops: got sigchild and waitpid returns 0 ???\n");

      else
        if((0x7f & exec_done__1__stat) == 0)
          fprintf(stderr, "[%d]: normal exit (%d)\n", pid, (((union anonymous_108){ .__in=exec_done__1__stat }).__i & 0xff00) >> 8);

        else
          if((signed int)((127 & (signed char)exec_done__1__stat) + 1) >> 1 >= 1)
          {
            char *return_value_strsignal_1;
            return_value_strsignal_1=strsignal(((union anonymous_108){ .__in=exec_done__1__stat }).__i & 0x7f);
            fprintf(stderr, "[%d]: %s\n", pid, return_value_strsignal_1);
          }

          else
            if((0xff & exec_done__1__stat) == 0x7f)
            {
              char *return_value_strsignal_2;
              return_value_strsignal_2=strsignal((((union anonymous_108){ .__in=exec_done__1__stat }).__i & 0xff00) >> 8);
              fprintf(stderr, "[%d]: %s\n", pid, return_value_strsignal_2);
            }

  }

}

// exec_output
// file x11/xt.c line 628
static void exec_output(void *data, signed int *fd, unsigned long int *iproc)
{
  char buffer[81l];
  signed int len;
  signed long int return_value_read_1;
  return_value_read_1=read(*fd, (void *)buffer, (unsigned long int)80);
  len = (signed int)return_value_read_1;
  if(!(len == -1))
  {
    if(len == 0)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    perror("read pipe");

  __CPROVER_DUMP_L2:
    ;
    close(*fd);
    XtRemoveInput(*iproc);
    goto __CPROVER_DUMP_L4;
  }
  buffer[(signed long int)len] = (char)0;
  fprintf(stderr, "%s", (const void *)buffer);

__CPROVER_DUMP_L4:
  ;
}

// exec_player
// file x11/xt.h line 151
void exec_player(char *moviefile)
{
  char *cmd;
  char **argv;
  signed int argc;
  unsigned long int return_value_strlen_1;
  static char *command = "pia";
  return_value_strlen_1=strlen(command);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(moviefile);
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)5);
  cmd = (char *)return_value_malloc_3;
  sprintf(cmd, "%s %s", command, moviefile);
  argv=split_cmdline(cmd, &argc);
  exec_x11(argv);
}

// exec_player_cb
// file x11/motv.c line 1819
static void exec_player_cb(struct _WidgetRec *widget, void *client_data, void *calldata)
{
  char *filename;
  filename=XmTextGetString(m_fvideo);
  exec_player(filename);
}

// exec_x11
// file x11/xt.c line 649
signed int exec_x11(char **argv)
{
  signed int p[2l];
  signed int pid;
  signed int i;
  if(!(debug == 0))
  {
    fprintf(stderr, "exec: \"%s\"", argv[(signed long int)0]);
    i = 1;
    for( ; !(argv[(signed long int)i] == ((char *)NULL)); i = i + 1)
      fprintf(stderr, ", \"%s\"", argv[(signed long int)i]);
    fprintf(stderr, "\n");
  }

  pipe(p);
  pid=fork();
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!(pid == -1))
  {
    if(pid == 0)
      goto __CPROVER_DUMP_L5;

  }

  else
  {
    perror("fork");
    return -1;

  __CPROVER_DUMP_L5:
    ;
    dup2(p[(signed long int)1], 1);
    dup2(p[(signed long int)1], 2);
    close(p[(signed long int)0]);
    close(p[(signed long int)1]);
    close(((struct anonymous_10 *)dpy)->fd);
    execvp(argv[(signed long int)0], argv);
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "exec %s: %s\n", argv[(signed long int)0], return_value_strerror_2);
    exit(1);
  }
  close(p[(signed long int)1]);
  XtAppAddInput(app_context, p[(signed long int)0], (void *)(1L << 0), exec_output, (void *)0);
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
  return pid;
}

// exit_handler
// file common/commands.c line 1189
static signed int exit_handler(char *name, signed int argc, char **argv)
{
  if(!(exit_hook == ((void (*)(void))NULL)))
    exit_hook();

  return 0;
}

// fget_associated_device
// file common/get_media_devices.c line 501
const char * fget_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const signed int fd_seek_device, const enum device_type seek_type)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  struct stat f_status;
  unsigned int dev_major;
  unsigned int dev_minor;
  signed int i;
  signed int found = 0;
  char *prev;
  signed int return_value_fstat_1;
  return_value_fstat_1=fstat(fd_seek_device, &f_status);
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(return_value_fstat_1 == 0))
  {
    perror("Can't get file status");
    return (const char *)(void *)0;
  }

  else
    if(!((61440u & f_status.st_mode) == 8192u))
    {
      fprintf(stderr, "File descriptor is not a char device\n");
      return (const char *)(void *)0;
    }

    else
    {
      dev_major=gnu_dev_major(f_status.st_rdev);
      dev_minor=gnu_dev_minor(f_status.st_rdev);
      i = 0;
      for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
      {
        if(!(last_seek == ((const char *)NULL)))
        {
          if(!(md_ptr->type == seek_type))
            goto __CPROVER_DUMP_L4;

          if(!(md_ptr->major == dev_major))
            goto __CPROVER_DUMP_L4;

          if(!(md_ptr->minor == dev_minor))
            goto __CPROVER_DUMP_L4;

          found = 1;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          if(!(found == 0) || last_seek == ((const char *)NULL))
          {
            if(md_ptr->type == seek_type)
            {
              if(md_ptr->major == dev_major)
              {
                if(md_ptr->minor == dev_minor)
                  break;

              }

            }

          }

        }
        i = i + 1;
      }
      if((unsigned int)i == md->md_size)
        return (const char *)(void *)0;

      else
      {
        i = i + 1;
        prev = md_ptr->device;
        md_ptr = md_ptr + 1l;
        do
        {
          if(!((unsigned int)i >= md->md_size))
          {
            return_value_strcmp_2=strcmp(prev, md_ptr->device);
            tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_3 = (_Bool)0;
          if(!tmp_if_expr_3)
            break;

          if(!(last_seek == ((const char *)NULL)))
          {
            if(!(md_ptr->type == seek_type))
              goto __CPROVER_DUMP_L11;

            if(!(md_ptr->major == dev_major))
              goto __CPROVER_DUMP_L11;

            if(!(md_ptr->minor == dev_minor))
              goto __CPROVER_DUMP_L11;

            found = 1;
          }

          else
          {

          __CPROVER_DUMP_L11:
            ;
            if(!(found == 0) || last_seek == ((const char *)NULL))
            {
              if(md_ptr->type == desired_type)
                return md_ptr->node;

            }

          }
          i = i + 1;
          md_ptr = md_ptr + 1l;
        }
        while((_Bool)1);
        return (const char *)(void *)0;
      }
    }
}

// fifo_get
// file common/capture.c line 81
void * fifo_get(struct FIFO *fifo)
{
  void *data;
  pthread_mutex_lock(&fifo->lock);
  while(fifo->write == fifo->read)
  {
    if(fifo->writers == fifo->eof)
      break;

    pthread_cond_wait(&fifo->hasdata, &fifo->lock);
  }
  signed int return_value_getpid_1;
  if(fifo->write == fifo->read)
  {
    pthread_cond_signal(&fifo->hasdata);
    pthread_mutex_unlock(&fifo->lock);
    return (void *)0;
  }

  else
  {
    if(debug >= 2)
    {
      return_value_getpid_1=getpid();
      fprintf(stderr, "get %s %d=%p [pid=%d]\n", fifo->name, fifo->read, fifo->data[(signed long int)fifo->read], return_value_getpid_1);
    }

    data = (void *)fifo->data[(signed long int)fifo->read];
    fifo->read = fifo->read + 1;
    if(fifo->read >= fifo->slots)
      fifo->read = 0;

    pthread_mutex_unlock(&fifo->lock);
    return data;
  }
}

// fifo_init
// file common/capture.c line 31
void fifo_init(struct FIFO *fifo, char *name, signed int slots, signed int writers)
{
  pthread_mutex_init(&fifo->lock, (const union anonymous_121 *)(void *)0);
  pthread_cond_init(&fifo->hasdata, (const union anonymous_121 *)(void *)0);
  fifo->name = name;
  fifo->slots = slots;
  fifo->writers = writers;
  fifo->read = 0;
  fifo->write = 0;
  fifo->eof = 0;
  fifo->max = 0;
}

// fifo_put
// file common/capture.c line 45
signed int fifo_put(struct FIFO *fifo, void *data)
{
  signed int full;
  pthread_mutex_lock(&fifo->lock);
  signed int return_value_getpid_1;
  if(data == NULL)
  {
    fifo->eof = fifo->eof + 1;
    if(!(debug == 0))
      fprintf(stderr, "fifo %s: EOF %d/%d\n", fifo->name, fifo->eof, fifo->writers);

    if(fifo->writers == fifo->eof)
      pthread_cond_broadcast(&fifo->hasdata);

    pthread_mutex_unlock(&fifo->lock);
    return 0;
  }

  else
    if((1 + fifo->write) % fifo->slots == fifo->read)
    {
      pthread_mutex_unlock(&fifo->lock);
      fprintf(stderr, "fifo %s is full\n", fifo->name);
      return -1;
    }

    else
    {
      if(debug >= 2)
      {
        return_value_getpid_1=getpid();
        fprintf(stderr, "put %s %d=%p [pid=%d]\n", fifo->name, fifo->write, data, return_value_getpid_1);
      }

      fifo->data[(signed long int)fifo->write] = (unsigned char *)data;
      fifo->write = fifo->write + 1;
      full = ((fifo->write + fifo->slots) - fifo->read) % fifo->slots;
      if(!(fifo->max >= full))
        fifo->max = full;

      if(fifo->write >= fifo->slots)
        fifo->write = 0;

      pthread_cond_signal(&fifo->hasdata);
      pthread_mutex_unlock(&fifo->lock);
      return 0;
    }
}

// file_browse_cb
// file x11/motv.c line 1796
static void file_browse_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct FILE_DATA *h = (struct FILE_DATA *)clientdata;
  struct _WidgetRec *help;
  if(h->filebox == ((struct _WidgetRec *)NULL))
  {
    h->filebox=XmCreateFileSelectionDialog(h->push, "filebox", (struct anonymous_11 *)(void *)0, (unsigned int)0);
    help=XmFileSelectionBoxGetChild(h->filebox, (unsigned char)7);
    XtUnmanageChild(help);
    XtAddCallback(h->filebox, (char *)&_XmStrings[(signed long int)8560], file_done_cb, (void *)h);
    XtAddCallback(h->filebox, (char *)&_XmStrings[(signed long int)5319], file_done_cb, (void *)h);
  }

  XtManageChild(h->filebox);
}

// file_done_cb
// file x11/motv.c line 1780
static void file_done_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct anonymous_87 *cb = (struct anonymous_87 *)call_data;
  struct FILE_DATA *h = (struct FILE_DATA *)clientdata;
  char *line;
  if(cb->reason == 31)
  {
    void *return_value_XmStringUnparse_1;
    return_value_XmStringUnparse_1=XmStringUnparse(cb->value, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (enum anonymous_67)XmMULTIBYTE_TEXT, (struct __XmParseMappingRec **)(void *)0, (unsigned int)0, (enum anonymous_68)0);
    line = (char *)return_value_XmStringUnparse_1;
    XmTextSetString(h->text, line);
  }

  XtUnmanageChild(h->filebox);
}

// files_audio
// file libng/writefile.c line 364
static signed int files_audio(void *handle, struct ng_audio_buf *buf)
{
  struct files_handle *h = (struct files_handle *)handle;
  signed long int return_value_write_1;
  return_value_write_1=write(h->wav_fd, (const void *)buf->data, (unsigned long int)buf->size);
  if(!((signed long int)buf->size == return_value_write_1))
    return -1;

  else
  {
    h->wav_size = h->wav_size + buf->size;
    return 0;
  }
}

// files_close
// file libng/writefile.c line 374
static signed int files_close(void *handle)
{
  struct files_handle *h = (struct files_handle *)handle;
  if(!(h->audio.fmtid == 0u))
  {
    wav_stop_write(h->wav_fd, &h->wav_header, h->wav_size);
    close(h->wav_fd);
  }

  free((void *)h);
  return 0;
}

// files_open
// file libng/writefile.c line 298
static void * files_open(char *filesname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio)
{
  struct files_handle *h;
  if(!(video->fmtid == 0u))
  {
    if(!(filesname == ((char *)NULL)))
      goto __CPROVER_DUMP_L1;

    return (void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct files_handle) /*4176ul*/ );
    h = (struct files_handle *)return_value_malloc_1;
    if(h == ((struct files_handle *)NULL))
      return (void *)0;

    else
    {
      memset((void *)h, 0, sizeof(struct files_handle) /*4176ul*/ );
      h->video = *video;
      h->audio = *audio;
      if(!(filesname == ((char *)NULL)))
        strcpy(h->file, filesname);

      if(!(h->audio.fmtid == 0u))
      {
        h->wav_fd=open(audioname, 0100 | 02 | 01000, 0666);
        if(h->wav_fd == -1)
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          char *return_value_strerror_3;
          return_value_strerror_3=strerror(*return_value___errno_location_2);
          fprintf(stderr, "open %s: %s\n", audioname, return_value_strerror_3);
          free((void *)h);
          return (void *)0;
        }

        wav_start_write(h->wav_fd, &h->wav_header, &h->audio);
      }

      return (void *)h;
    }
  }
}

// files_video
// file libng/writefile.c line 330
static signed int files_video(void *handle, struct ng_video_buf *buf)
{
  struct files_handle *h = (struct files_handle *)handle;
  signed int rc = -1;
  struct _IO_FILE *fp;
  if(!(h->gotcha == 0))
  {
    fprintf(stderr, "Oops: can't count up file names any more\n");
    return -1;
  }

  else
  {
    switch(h->video.fmtid)
    {
      case (unsigned int)9:
      {
        rc=write_ppm(h->file, buf);
        break;
      }
      case (unsigned int)2:
      {
        rc=write_pgm(h->file, buf);
        break;
      }
      case (unsigned int)17:
      {
        fp=fopen(h->file, "w");
        if(fp == ((struct _IO_FILE *)NULL))
        {
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          char *return_value_strerror_2;
          return_value_strerror_2=strerror(*return_value___errno_location_1);
          fprintf(stderr, "grab: can't open %s: %s\n", (const void *)h->file, return_value_strerror_2);
          rc = -1;
        }

        else
        {
          fwrite((const void *)buf->data, buf->size, (unsigned long int)1, fp);
          fclose(fp);
          rc = 0;
        }
      }
    }
    signed int return_value_patch_up_3;
    return_value_patch_up_3=patch_up(h->file);
    if(!(return_value_patch_up_3 == 1))
      h->gotcha = 1;

    return rc;
  }
}

// filter_add_ctrls
// file x11/motv.c line 875
static void filter_add_ctrls(struct _WidgetRec *rc, struct ng_filter *filter, struct ng_attribute *attr)
{
  struct filter_attribute *f;
  struct _WidgetRec *opt;
  struct _WidgetRec *push;
  union __XmStringRec *str;
  struct anonymous_11 filter_add_ctrls__1__args[2l];
  signed int i;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct filter_attribute) /*40ul*/ );
  f = (struct filter_attribute *)return_value_malloc_1;
  memset((void *)f, 0, sizeof(struct filter_attribute) /*40ul*/ );
  f->filter = filter;
  f->attr = attr;
  f->next = filter_attrs;
  f->value=attr->read(attr);
  filter_attrs = f;
  str=XmStringGenerate((void *)(char *)attr->name, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
  if(attr->type == 1)
  {
    f->widget=XtVaCreateManagedWidget("scale", xmScaleWidgetClass, rc, (char *)&_XmStrings[(signed long int)10137], str, (char *)&_XmStrings[(signed long int)8134], attr->min, (char *)&_XmStrings[(signed long int)7982], attr->max, (char *)&_XmStrings[(signed long int)5711], attr->points, (void *)0);
    XmScaleSetValue(f->widget, f->value);
    XtAddCallback(f->widget, (char *)&_XmStrings[(signed long int)10591], filter_cb, (void *)f);
    f->widget=XtVaCreateManagedWidget("bool", xmToggleButtonWidgetClass, rc, (char *)&_XmStrings[(signed long int)7535], str, (void *)0);
    XmToggleButtonSetState(f->widget, (char)f->value, (char)0);
    XtAddCallback(f->widget, (char *)&_XmStrings[(signed long int)10591], filter_cb, (void *)f);
    f->widget=XmCreatePulldownMenu(rc, "choiceM", (struct anonymous_11 *)(void *)0, (unsigned int)0);
    filter_add_ctrls__1__args[(signed long int)0].name = (char *)&_XmStrings[(signed long int)9963];
    filter_add_ctrls__1__args[(signed long int)0].value = (signed long int)f->widget;
    filter_add_ctrls__1__args[(signed long int)1].name = (char *)&_XmStrings[(signed long int)7535];
    filter_add_ctrls__1__args[(signed long int)1].value = (signed long int)str;
    opt=XmCreateOptionMenu(rc, "choiceO", filter_add_ctrls__1__args, (unsigned int)2);
    XtManageChild(opt);
    i = 0;
    if(!((attr->choices + (signed long int)i)->str == ((const char *)NULL)))
    {
      push=XtVaCreateManagedWidget((attr->choices + (signed long int)i)->str, xmPushButtonWidgetClass, f->widget, (void *)0);
      XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], filter_cb, (void *)f);
      if((signed long int)f->value == (attr->choices + (signed long int)i)->nr)
        XtVaSetValues(f->widget, (char *)&_XmStrings[(signed long int)8040], push, (void *)0);

      i = i + 1;
    }

  }

  XmStringFree(str);
}

// filter_cb
// file x11/motv.c line 853
static void filter_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct filter_attribute *f = (struct filter_attribute *)clientdata;
  struct _WidgetRec *w;
  char return_value_XmToggleButtonGetState_1;
  char *return_value_XtName_2;
  switch(f->attr->type)
  {
    case 1:
    {
      XmScaleGetValue(f->widget, &f->value);
      break;
    }
    case 3:
    {
      return_value_XmToggleButtonGetState_1=XmToggleButtonGetState(f->widget);
      f->value = (signed int)return_value_XmToggleButtonGetState_1;
      break;
    }
    case 2:
    {
      w = (struct _WidgetRec *)(void *)0;
      XtVaGetValues(f->widget, (char *)&_XmStrings[(signed long int)8040], &w, (void *)0);
      return_value_XtName_2=XtName(w);
      f->value=ng_attr_getint(f->attr, return_value_XtName_2);
    }
  }
  f->attr->write(f->attr, f->value);
}

// find_screensaver_window
// file jwz/remote.c line 73
static unsigned long int find_screensaver_window(struct _XDisplay *dpy, char **version)
{
  unsigned int i;
  unsigned long int root = (&((struct anonymous_10 *)dpy)->screens[(signed long int)((struct anonymous_10 *)dpy)->default_screen])->root;
  unsigned long int root2;
  unsigned long int parent;
  unsigned long int *kids;
  unsigned int nkids;
  if(!(version == ((char **)NULL)))
    *version = ((char *)NULL);

  signed int return_value_XQueryTree_1;
  return_value_XQueryTree_1=XQueryTree(dpy, root, &root2, &parent, &kids, &nkids);
  if(return_value_XQueryTree_1 == 0)
    abort();

  if(!(root == root2))
    abort();

  if(!(parent == 0ul))
    abort();

  if(kids == ((unsigned long int *)NULL) || nkids == 0u)
    return (unsigned long int)0;

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= nkids); i = i + 1u)
    {
      unsigned long int type;
      signed int format;
      unsigned long int nitems;
      unsigned long int bytesafter;
      char *v;
      signed int status;
      XSync(dpy, 0);
      if(!(old_handler == ((signed int (*)(struct _XDisplay *, struct anonymous *))NULL)))
        abort();

      got_badwindow = 0;
      old_handler=XSetErrorHandler(BadWindow_ehandler);
      status=XGetWindowProperty(dpy, kids[(signed long int)i], XA_SCREENSAVER_VERSION, (signed long int)0, (signed long int)200, 0, (unsigned long int)31, &type, &format, &nitems, &bytesafter, (unsigned char **)&v);
      XSync(dpy, 0);
      XSetErrorHandler(old_handler);
      old_handler = ((signed int (*)(struct _XDisplay *, struct anonymous *))NULL);
      if(!(got_badwindow == 0))
      {
        status = 3;
        got_badwindow = 0;
      }

      if(status == 0 && !(type == 0ul))
      {
        if(!(version == ((char **)NULL)))
          *version = v;

        return kids[(signed long int)i];
      }

    }
    return (unsigned long int)0;
  }
}

// flushit
// file common/capture.c line 106
static void * flushit(void *arg)
{
  signed int old;
  pthread_setcancelstate(0, &old);
  pthread_setcanceltype(1, &old);
  do
  {
    sleep((unsigned int)1);
    sync();
  }
  while((_Bool)1);
  return (void *)0;
}

// free_cb
// file x11/motv.c line 404
static void free_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  free(clientdata);
}

// free_media_devices
// file ./common/get_media_devices.h line 92
void free_media_devices(void *opaque)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i = 0;
  for( ; !((unsigned int)i >= md->md_size); i = i + 1)
  {
    free((void *)md_ptr->node);
    free((void *)md_ptr->device);
    md_ptr = md_ptr + 1l;
  }
  free((void *)md->md_entry);
  free((void *)md);
}

// freq_init
// file ./common/frequencies.h line 105
void freq_init(void)
{
  char line[256l];
  char value[256l];
  struct _IO_FILE *fp;
  signed int nr;
  signed int i;
  signed int j;
  fp=fopen("/usr/share/xawtv/Index.map", "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    perror("open /usr/share/xawtv/Index.map");
    exit(1);
  }

  if(!(debug == 0))
    fprintf(stderr, "freq: reading /usr/share/xawtv/Index.map\n");

  nr = 0;
  i = 0;
  char *return_value_fgets_1;
  do
  {
    return_value_fgets_1=fgets(line, 255, fp);
    if(return_value_fgets_1 == ((char *)NULL))
      break;

    nr = nr + 1;
    _Bool tmp_if_expr_2;
    if((signed int)line[0l] == 10)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_3;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)line[(signed long int)0] == 37 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_3)
    {
      signed int return_value_sscanf_5;
      return_value_sscanf_5=sscanf(line, "[%255[^]]]", (const void *)value);
      if(return_value_sscanf_5 == 1)
      {
        void *return_value_realloc_4;
        return_value_realloc_4=realloc((void *)chanlists, (unsigned long int)(i + 2) * sizeof(struct CHANLISTS) /*32ul*/ );
        chanlists = (struct CHANLISTS *)return_value_realloc_4;
        memset((void *)(chanlists + (signed long int)i), 0, (unsigned long int)2 * sizeof(struct CHANLISTS) /*32ul*/ );
        (chanlists + (signed long int)i)->name=strdup(value);
        i = i + 1;
        continue;
      }

      if(chanlists == ((struct CHANLISTS *)NULL))
        fprintf(stderr, "%s:%d: error: no section\n", (const void *)"/usr/share/xawtv/Index.map", nr);

      else
      {
        signed int return_value_sscanf_6;
        return_value_sscanf_6=sscanf(line, " file = %255[^\n]", (const void *)value);
        if(return_value_sscanf_6 == 1)
          (chanlists + (signed long int)(i - 1))->filename=strdup(value);

        else
          fprintf(stderr, "%s:%d: syntax error\n", (const void *)"/usr/share/xawtv/Index.map", nr);
      }
    }

  }
  while((_Bool)1);
  fclose(fp);
  void *return_value_malloc_7;
  return_value_malloc_7=malloc((unsigned long int)(i + 1) * sizeof(struct STRTAB) /*16ul*/ );
  chanlist_names = (struct STRTAB *)return_value_malloc_7;
  j = 0;
  for( ; !(j >= i); j = j + 1)
  {
    (chanlist_names + (signed long int)j)->nr = (signed long int)j;
    (chanlist_names + (signed long int)j)->str = (chanlists + (signed long int)j)->name;
  }
  (chanlist_names + (signed long int)j)->nr = (signed long int)-1;
  (chanlist_names + (signed long int)j)->str = (const char *)(void *)0;
}

// freq_newtab
// file common/frequencies.h line 106
void freq_newtab(signed int n)
{
  if(!(debug == 0))
    fprintf(stderr, "freq: newtab %d\n", n);

  if((chanlists + (signed long int)n)->list == ((struct CHANLIST *)NULL))
    (chanlists + (signed long int)n)->count=freq_readlist(&(chanlists + (signed long int)n)->list, 0, (chanlists + (signed long int)n)->filename);

  chantab = n;
}

// freq_readlist
// file common/frequencies.c line 78
static signed int freq_readlist(struct CHANLIST **list, signed int n, char *name)
{
  char line[256l];
  char value[256l];
  char filename[256l];
  struct _IO_FILE *fp;
  signed int nr;
  sprintf(filename, "%s/%s", (const void *)"/usr/share/xawtv", name);
  fp=fopen(filename, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "open %s: %s\n", (const void *)filename, return_value_strerror_2);
    exit(1);
  }

  if(!(debug == 0))
    fprintf(stderr, "freq: reading %s\n", (const void *)filename);

  nr = 0;
  char *return_value_fgets_3;
  do
  {
    return_value_fgets_3=fgets(line, 255, fp);
    if(return_value_fgets_3 == ((char *)NULL))
      break;

    nr = nr + 1;
    signed int return_value_sscanf_4;
    return_value_sscanf_4=sscanf(line, "# include \"%[^\"]\"", (const void *)value);
    if(return_value_sscanf_4 == 1)
      n=freq_readlist(list, n, value);

    else
    {
      _Bool tmp_if_expr_5;
      if((signed int)line[0l] == 10)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_6;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = (signed int)line[(signed long int)0] == 37 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_6)
      {
        signed int return_value_sscanf_8;
        return_value_sscanf_8=sscanf(line, "[%255[^]]]", (const void *)value);
        if(return_value_sscanf_8 == 1)
        {
          if(n % 16 == 0)
          {
            void *return_value_realloc_7;
            return_value_realloc_7=realloc((void *)*list, (unsigned long int)(n + 16) * sizeof(struct CHANLIST) /*16ul*/ );
            *list = (struct CHANLIST *)return_value_realloc_7;
            memset((void *)(*list + (signed long int)n), 0, (unsigned long int)16 * sizeof(struct CHANLIST) /*16ul*/ );
          }

          (*list + (signed long int)n)->name=strdup(value);
          n = n + 1;
        }

        else
          if(n == 0)
            fprintf(stderr, "%s:%d: error: no section\n", (const void *)filename, nr);

          else
          {
            signed int return_value_sscanf_10;
            return_value_sscanf_10=sscanf(line, " freq = %255[^\n]", (const void *)value);
            if(return_value_sscanf_10 == 1)
            {
              signed int return_value_atoi_9;
              return_value_atoi_9=atoi(value);
              (*list + (signed long int)(n - 1))->freq = (unsigned int)return_value_atoi_9;
              continue;
            }

            fprintf(stderr, "%s:%d: syntax error\n", (const void *)filename, nr);
          }
      }

    }
  }
  while((_Bool)1);
  fclose(fp);
  return n;
}

// fullscreen_handler
// file common/commands.c line 1158
static signed int fullscreen_handler(char *name, signed int argc, char **argv)
{
  if(!(fullscreen_hook == ((void (*)(void))NULL)))
    fullscreen_hook();

  return 0;
}

// get_associated_device
// file ./common/get_media_devices.h line 124
const char * get_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const char *seek_device, const enum device_type seek_type)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i;
  signed int found = 0;
  char *prev;
  char *p;
  _Bool tmp_if_expr_7;
  if(!((signed int)seek_type == NONE))
    tmp_if_expr_7 = seek_device[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_7 = (_Bool)0;
  signed int return_value_strcmp_1;
  signed int return_value_strcmp_2;
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_6;
  if(tmp_if_expr_7)
  {
    p=strrchr(seek_device, 47);
    if(!(p == ((char *)NULL)))
      seek_device = p + (signed long int)1;

    i = 0;
    for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
    {
      if(!(last_seek == ((const char *)NULL)))
      {
        if(md_ptr->type == seek_type)
        {
          return_value_strcmp_1=strcmp(md_ptr->node, last_seek);
          if(return_value_strcmp_1 == 0)
          {
            found = 1;
            goto __CPROVER_DUMP_L10;
          }

        }

      }

      if(!(found == 0) || last_seek == ((const char *)NULL))
      {
        if(md_ptr->type == seek_type)
        {
          return_value_strcmp_2=strcmp(seek_device, md_ptr->node);
          if(return_value_strcmp_2 == 0)
            break;

        }

      }


    __CPROVER_DUMP_L10:
      ;
      i = i + 1;
    }
    if((unsigned int)i == md->md_size)
      return (const char *)(void *)0;

    i = i + 1;
    prev = md_ptr->device;
    md_ptr = md_ptr + 1l;
    do
    {
      if(!((unsigned int)i >= md->md_size))
      {
        return_value_strcmp_3=strcmp(prev, md_ptr->device);
        tmp_if_expr_4 = !(return_value_strcmp_3 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(!tmp_if_expr_4)
        break;

      if(!(last_seek == ((const char *)NULL)))
      {
        if(md_ptr->type == seek_type)
        {
          return_value_strcmp_5=strcmp(md_ptr->node, last_seek);
          if(return_value_strcmp_5 == 0)
          {
            found = 1;
            goto __CPROVER_DUMP_L20;
          }

        }

      }

      if(!(found == 0) || last_seek == ((const char *)NULL))
      {
        if(md_ptr->type == desired_type)
          return md_ptr->node;

      }


    __CPROVER_DUMP_L20:
      ;
      i = i + 1;
      md_ptr = md_ptr + 1l;
    }
    while((_Bool)1);
  }

  else
  {
    i = 0;
    for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
    {
      if(!(last_seek == ((const char *)NULL)))
      {
        return_value_strcmp_6=strcmp(md_ptr->node, last_seek);
        if(return_value_strcmp_6 == 0)
        {
          found = 1;
          goto __CPROVER_DUMP_L28;
        }

      }

      if(!(found == 0) || last_seek == ((const char *)NULL))
      {
        if(md_ptr->type == desired_type)
          return md_ptr->node;

      }


    __CPROVER_DUMP_L28:
      ;
      i = i + 1;
    }
  }
  return (const char *)(void *)0;
}

// get_bus
// file common/get_media_devices.c line 96
static enum bus_type get_bus(char *device)
{
  char file[4096l];
  char s[1024l];
  struct _IO_FILE *f;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(device, "/sys/devices/virtual");
  if(return_value_strcmp_1 == 0)
    return (enum bus_type)MEDIA_BUS_VIRTUAL;

  else
  {
    snprintf(file, (unsigned long int)4096, "%s/modalias", device);
    f=fopen(file, "r");
    if(f == ((struct _IO_FILE *)NULL))
      return (enum bus_type)MEDIA_BUS_UNKNOWN;

    else
    {
      char *return_value_fgets_2;
      return_value_fgets_2=fgets(s, (signed int)sizeof(char [1024l]) /*1024ul*/ , f);
      if(return_value_fgets_2 == ((char *)NULL))
        return (enum bus_type)MEDIA_BUS_UNKNOWN;

      else
      {
        fclose(f);
        signed int return_value_strncmp_3;
        return_value_strncmp_3=strncmp(s, "pci", (unsigned long int)3);
        if(return_value_strncmp_3 == 0)
          return (enum bus_type)MEDIA_BUS_PCI;

        else
        {
          signed int return_value_strncmp_4;
          return_value_strncmp_4=strncmp(s, "usb", (unsigned long int)3);
          if(return_value_strncmp_4 == 0)
            return (enum bus_type)MEDIA_BUS_USB;

          else
            return (enum bus_type)MEDIA_BUS_UNKNOWN;
        }
      }
    }
  }
}

// get_bus_link1
// file common/get_media_devices.c line 96
static enum bus_type get_bus_link1(char *device_link1)
{
  char file_link1[4096l];
  char s_link1[1024l];
  struct _IO_FILE *f_link1;
  signed int return_value_strcmp_1_link1;
  return_value_strcmp_1_link1=strcmp(device_link1, "/sys/devices/virtual");
  if(return_value_strcmp_1_link1 == 0)
    return (enum bus_type)MEDIA_BUS_VIRTUAL;

  else
  {
    snprintf(file_link1, (unsigned long int)4096, "%s/modalias", device_link1);
    f_link1=fopen(file_link1, "r");
    if(f_link1 == ((struct _IO_FILE *)NULL))
      return (enum bus_type)MEDIA_BUS_UNKNOWN;

    else
    {
      char *return_value_fgets_2_link1;
      return_value_fgets_2_link1=fgets(s_link1, (signed int)sizeof(char [1024l]) /*1024ul*/ , f_link1);
      if(return_value_fgets_2_link1 == ((char *)NULL))
        return (enum bus_type)MEDIA_BUS_UNKNOWN;

      else
      {
        fclose(f_link1);
        signed int return_value_strncmp_3_link1;
        return_value_strncmp_3_link1=strncmp(s_link1, "pci", (unsigned long int)3);
        if(return_value_strncmp_3_link1 == 0)
          return (enum bus_type)MEDIA_BUS_PCI;

        else
        {
          signed int return_value_strncmp_4_link1;
          return_value_strncmp_4_link1=strncmp(s_link1, "usb", (unsigned long int)3);
          if(return_value_strncmp_4_link1 == 0)
            return (enum bus_type)MEDIA_BUS_USB;

          else
            return (enum bus_type)MEDIA_BUS_UNKNOWN;
        }
      }
    }
  }
}

// get_class
// file common/get_media_devices.c line 121
static signed int get_class(char *class, struct media_device_entry **md, unsigned int *md_size, signed int (*fill)(struct media_device_entry *))
{
  struct __dirstream *dir;
  struct dirent *entry;
  char dname[4096l];
  char fname[4096l];
  char get_class__1__link[4096l];
  char virt_dev[60l];
  signed int get_class__1__err = -2;
  struct media_device_entry *md_ptr = (struct media_device_entry *)(void *)0;
  char *p;
  char *device;
  enum bus_type bus;
  snprintf(dname, (unsigned long int)4096, "/sys/class/%s", class);
  dir=opendir(dname);
  char *return_value_strchr_1;
  if(dir == ((struct __dirstream *)NULL))
    return 0;

  else
  {
    entry=readdir(dir);
    while(!(entry == ((struct dirent *)NULL)))
    {
      if(!((signed int)entry->d_name[0l] == 46))
      {
        snprintf(fname, (unsigned long int)4096, "%s/%s", (const void *)dname, (const void *)entry->d_name);
        char *return_value_realpath_4;
        return_value_realpath_4=realpath(fname, get_class__1__link);
        if(!(return_value_realpath_4 == ((char *)NULL)))
        {
          device = get_class__1__link;
          p=strstr(device, class);
          if(p == ((char *)NULL))
            goto __CPROVER_DUMP_L9;

          *(p - (signed long int)1) = (char)0;
          bus=get_bus(device);
          device = device + (signed long int)13;
          switch((signed int)bus)
          {
            case MEDIA_BUS_PCI:
            {
              p=strrchr(device, 46);
              if(p == ((char *)NULL))
                goto __CPROVER_DUMP_L9;

              *p = (char)0;
              break;
            }
            case MEDIA_BUS_USB:
            {
              p=strrchr(device, 47);
              if(p == ((char *)NULL))
                goto __CPROVER_DUMP_L9;

              return_value_strchr_1=strchr(p, 58);
              if(return_value_strchr_1 == ((char *)NULL))
                break;

              *p = (char)0;
              break;
            }
            case MEDIA_BUS_VIRTUAL:
            {
              static signed int virtual = 0;
              signed int tmp_post_2 = virtual;
              virtual = virtual + 1;
              sprintf(virt_dev, "virtual%d", tmp_post_2);
              device = virt_dev;
              break;
            }
            case MEDIA_BUS_UNKNOWN:
              ;
          }
          void *return_value_realloc_3;
          return_value_realloc_3=realloc((void *)*md, (unsigned long int)(*md_size + (unsigned int)1) * sizeof(struct media_device_entry) /*32ul*/ );
          *md = (struct media_device_entry *)return_value_realloc_3;
          if(*md == ((struct media_device_entry *)NULL))
            goto error;

          md_ptr = *md + (signed long int)*md_size;
          *md_size = *md_size + 1u;
          memset((void *)md_ptr, 0, sizeof(struct media_device_entry) /*32ul*/ );
          md_ptr->type = (enum device_type)UNKNOWN;
          md_ptr->device=strdup(device);
          md_ptr->node=strdup(entry->d_name);
          get_uevent_info(md_ptr, dname);
          fill(md_ptr);
        }

      }


    __CPROVER_DUMP_L9:
      ;
      entry=readdir(dir);
    }
    get_class__1__err = 0;

  error:
    ;
    closedir(dir);
    return get_class__1__err;
  }
}

// get_class_link1
// file common/get_media_devices.c line 121
static signed int get_class_link1(char *class_link1, struct media_device_entry **md_link1, unsigned int *md_size_link1, signed int (*fill_link1)(struct media_device_entry *))
{
  struct __dirstream *dir_link1;
  struct dirent *entry_link1;
  char dname_link1[4096l];
  char fname_link1[4096l];
  char link_link1[4096l];
  char virt_dev_link1[60l];
  signed int get_class__1__err_link1 = -2;
  struct media_device_entry *md_ptr_link1 = (struct media_device_entry *)(void *)0;
  char *p_link1;
  char *device_link1;
  enum bus_type bus_link1;
  snprintf(dname_link1, (unsigned long int)4096, "/sys/class/%s", class_link1);
  dir_link1=opendir(dname_link1);
  char *return_value_strchr_1_link1;
  if(dir_link1 == ((struct __dirstream *)NULL))
    return 0;

  else
  {
    entry_link1=readdir(dir_link1);
    while(!(entry_link1 == ((struct dirent *)NULL)))
    {
      if(!((signed int)entry_link1->d_name[0l] == 46))
      {
        snprintf(fname_link1, (unsigned long int)4096, "%s/%s", (const void *)dname_link1, (const void *)entry_link1->d_name);
        char *return_value_realpath_4_link1;
        return_value_realpath_4_link1=realpath(fname_link1, link_link1);
        if(!(return_value_realpath_4_link1 == ((char *)NULL)))
        {
          device_link1 = link_link1;
          p_link1=strstr(device_link1, class_link1);
          if(p_link1 == ((char *)NULL))
            goto __CPROVER_DUMP_L9;

          *(p_link1 - (signed long int)1) = (char)0;
          bus_link1=get_bus_link1(device_link1);
          device_link1 = device_link1 + (signed long int)13;
          switch((signed int)bus_link1)
          {
            case MEDIA_BUS_PCI:
            {
              p_link1=strrchr(device_link1, 46);
              if(p_link1 == ((char *)NULL))
                goto __CPROVER_DUMP_L9;

              *p_link1 = (char)0;
              break;
            }
            case MEDIA_BUS_USB:
            {
              p_link1=strrchr(device_link1, 47);
              if(p_link1 == ((char *)NULL))
                goto __CPROVER_DUMP_L9;

              return_value_strchr_1_link1=strchr(p_link1, 58);
              if(return_value_strchr_1_link1 == ((char *)NULL))
                break;

              *p_link1 = (char)0;
              break;
            }
            case MEDIA_BUS_VIRTUAL:
            {
              static signed int virtual_link1 = 0;
              signed int tmp_post_2_link1 = virtual_link1;
              virtual_link1 = virtual_link1 + 1;
              sprintf(virt_dev_link1, "virtual%d", tmp_post_2_link1);
              device_link1 = virt_dev_link1;
              break;
            }
            case MEDIA_BUS_UNKNOWN:
              ;
          }
          void *return_value_realloc_3_link1;
          return_value_realloc_3_link1=realloc((void *)*md_link1, (unsigned long int)(*md_size_link1 + (unsigned int)1) * sizeof(struct media_device_entry) /*32ul*/ );
          *md_link1 = (struct media_device_entry *)return_value_realloc_3_link1;
          if(*md_link1 == ((struct media_device_entry *)NULL))
            goto error;

          md_ptr_link1 = *md_link1 + (signed long int)*md_size_link1;
          *md_size_link1 = *md_size_link1 + 1u;
          memset((void *)md_ptr_link1, 0, sizeof(struct media_device_entry) /*32ul*/ );
          md_ptr_link1->type = (enum device_type)UNKNOWN;
          md_ptr_link1->device=strdup(device_link1);
          md_ptr_link1->node=strdup(entry_link1->d_name);
          get_uevent_info_link1(md_ptr_link1, dname_link1);
          fill_link1(md_ptr_link1);
        }

      }


    __CPROVER_DUMP_L9:
      ;
      entry_link1=readdir(dir_link1);
    }
    get_class__1__err_link1 = 0;

  error:
    ;
    closedir(dir_link1);
    return get_class__1__err_link1;
  }
}

// get_clips
// file x11/x11.c line 395
static void get_clips(void)
{
  signed int x1;
  signed int y1;
  signed int x2;
  signed int y2;
  signed int lastcount;
  struct _XDisplay *get_clips__1__dpy;
  struct anonymous_117 wts;
  unsigned long int root;
  unsigned long int me;
  unsigned long int rroot;
  unsigned long int parent;
  unsigned long int *children;
  unsigned int nchildren;
  unsigned int i;
  void *get_clips__1__old_handler;
  signed int (*return_value_XSetErrorHandler_1)(struct _XDisplay *, struct anonymous *);
  return_value_XSetErrorHandler_1=XSetErrorHandler(x11_error_dev_null);
  get_clips__1__old_handler = (void *)return_value_XSetErrorHandler_1;
  if(debug >= 2)
    fprintf(stderr, " getclips");

  lastcount = oc_count;
  oc_count = 0;
  get_clips__1__dpy=XtDisplay(video);
  if(!(wx >= 0))
    add_clip(0, 0, (signed int)(unsigned int)-wx, (signed int)wfmt.height);

  if(!(wy >= 0))
    add_clip(0, 0, (signed int)wfmt.width, (signed int)(unsigned int)-wy);

  if(!(swidth >= wfmt.width + (unsigned int)wx))
    add_clip((signed int)(swidth - (unsigned int)wx), 0, (signed int)wfmt.width, (signed int)wfmt.height);

  if(!(sheight >= wfmt.height + (unsigned int)wy))
    add_clip(0, (signed int)(sheight - (unsigned int)wy), (signed int)wfmt.width, (signed int)wfmt.height);

  root = (&((struct anonymous_10 *)get_clips__1__dpy)->screens[(signed long int)((struct anonymous_10 *)get_clips__1__dpy)->default_screen])->root;
  me=XtWindow(video);
  do
  {
    XQueryTree(get_clips__1__dpy, me, &rroot, &parent, &children, &nchildren);
    XFree((void *)(char *)children);
    if(root == parent)
      break;

    me = parent;
  }
  while((_Bool)1);
  XQueryTree(get_clips__1__dpy, root, &rroot, &parent, &children, &nchildren);
  i = (unsigned int)0;
  for( ; !(i >= nchildren); i = i + 1u)
    if(children[(signed long int)i] == me)
      break;

  i = i + 1u;
  for( ; !(i >= nchildren); i = i + 1u)
  {
    XGetWindowAttributes(get_clips__1__dpy, children[(signed long int)i], &wts);
    if(!((2 & wts.map_state) == 0))
    {
      x1 = wts.x - wx;
      y1 = wts.y - wy;
      x2 = x1 + wts.width + 2 * wts.border_width;
      y2 = y1 + wts.height + 2 * wts.border_width;
      if(x2 >= 0 && y2 >= 0 && (signed int)wfmt.height >= y1 && (signed int)wfmt.width >= x1)
      {
        if(!(x1 >= 0))
          x1 = 0;

        if(!(y1 >= 0))
          y1 = 0;

        if(!((signed int)wfmt.width >= x2))
          x2 = (signed int)wfmt.width;

        if(!((signed int)wfmt.height >= y2))
          y2 = (signed int)wfmt.height;

        add_clip(x1, y1, x2, y2);
      }

    }

  }
  XFree((void *)(char *)children);
  if(!(lastcount == oc_count))
    conf = 1;

  XSetErrorHandler((signed int (*)(struct _XDisplay *, struct anonymous *))get_clips__1__old_handler);
}

// get_freq
// file common/channel.c line 152
signed int get_freq(signed int i)
{
  _Bool tmp_if_expr_2;
  signed int tmp_if_expr_1;
  if(!(i >= 0))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(!(chantab == -1))
      tmp_if_expr_1 = (chanlists + (signed long int)chantab)->count;

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = i >= tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return -1;

  else
  {
    struct CHANLIST *tmp_if_expr_3;
    if(!(chantab == -1))
      tmp_if_expr_3 = (chanlists + (signed long int)chantab)->list;

    else
      tmp_if_expr_3 = (struct CHANLIST *)(void *)0;
    return (signed int)(((tmp_if_expr_3 + (signed long int)i)->freq * (unsigned int)16) / (unsigned int)1000);
  }
}

// get_not_associated_device
// file common/get_media_devices.c line 561
const char * get_not_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const enum device_type not_desired_type)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i;
  signed int skip = 0;
  signed int found = 0;
  char *prev = "";
  char *result = (char *)(void *)0;
  i = 0;
  signed int return_value_strcmp_1;
  for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
  {
    if(!(last_seek == ((const char *)NULL)))
    {
      return_value_strcmp_1=strcmp(md_ptr->node, last_seek);
      if(return_value_strcmp_1 == 0)
      {
        found = 1;
        goto __CPROVER_DUMP_L9;
      }

    }

    if(!(found == 0) || last_seek == ((const char *)NULL))
    {
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(prev, md_ptr->device);
      if(!(return_value_strcmp_2 == 0))
      {
        if(skip == 0 && !(result == ((char *)NULL)))
          break;

        prev = md_ptr->device;
        skip = 0;
        result = (char *)(void *)0;
      }

      if(md_ptr->type == not_desired_type)
        skip = 1;

      else
        if(result == ((char *)NULL) && skip == 0)
        {
          if(md_ptr->type == desired_type)
            result = md_ptr->node;

        }

    }


  __CPROVER_DUMP_L9:
    ;
    i = i + 1;
  }
  if(!(skip == 0))
    result = (char *)(void *)0;

  return result;
}

// get_uevent_info
// file common/get_media_devices.c line 69
static void get_uevent_info(struct media_device_entry *md_ptr, char *dname)
{
  struct _IO_FILE *fd;
  char file[4096l];
  char *name;
  char *p;
  char s[1024l];
  snprintf(file, (unsigned long int)4096, "%s/%s/uevent", dname, md_ptr->node);
  fd=fopen(file, "r");
  char *return_value_fgets_1;
  signed long int return_value_atol_2;
  signed int return_value_strcmp_4;
  signed long int return_value_atol_3;
  if(!(fd == ((struct _IO_FILE *)NULL)))
  {
    do
    {
      return_value_fgets_1=fgets(s, (signed int)sizeof(char [1024l]) /*1024ul*/ , fd);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      p=strtok(s, "=");
      if(!(p == ((char *)NULL)))
      {
        name = p;
        p=strtok((char *)(void *)0, "\n");
        if(!(p == ((char *)NULL)))
        {
          signed int return_value_strcmp_5;
          return_value_strcmp_5=strcmp(name, "MAJOR");
          if(return_value_strcmp_5 == 0)
          {
            return_value_atol_2=atol(p);
            md_ptr->major = (unsigned int)return_value_atol_2;
          }

          else
          {
            return_value_strcmp_4=strcmp(name, "MINOR");
            if(return_value_strcmp_4 == 0)
            {
              return_value_atol_3=atol(p);
              md_ptr->minor = (unsigned int)return_value_atol_3;
            }

          }
        }

      }

    }
    while((_Bool)1);
    fclose(fd);
  }

}

// get_uevent_info_link1
// file common/get_media_devices.c line 69
static void get_uevent_info_link1(struct media_device_entry *md_ptr_link1, char *dname_link1)
{
  struct _IO_FILE *fd_link1;
  char file_link1[4096l];
  char *name_link1;
  char *p_link1;
  char s_link1[1024l];
  snprintf(file_link1, (unsigned long int)4096, "%s/%s/uevent", dname_link1, md_ptr_link1->node);
  fd_link1=fopen(file_link1, "r");
  char *return_value_fgets_1_link1;
  signed long int return_value_atol_2_link1;
  signed int return_value_strcmp_4_link1;
  signed long int return_value_atol_3_link1;
  if(!(fd_link1 == ((struct _IO_FILE *)NULL)))
  {
    do
    {
      return_value_fgets_1_link1=fgets(s_link1, (signed int)sizeof(char [1024l]) /*1024ul*/ , fd_link1);
      if(return_value_fgets_1_link1 == ((char *)NULL))
        break;

      p_link1=strtok(s_link1, "=");
      if(!(p_link1 == ((char *)NULL)))
      {
        name_link1 = p_link1;
        p_link1=strtok((char *)(void *)0, "\n");
        if(!(p_link1 == ((char *)NULL)))
        {
          signed int return_value_strcmp_5_link1;
          return_value_strcmp_5_link1=strcmp(name_link1, "MAJOR");
          if(return_value_strcmp_5_link1 == 0)
          {
            return_value_atol_2_link1=atol(p_link1);
            md_ptr_link1->major = (unsigned int)return_value_atol_2_link1;
          }

          else
          {
            return_value_strcmp_4_link1=strcmp(name_link1, "MINOR");
            if(return_value_strcmp_4_link1 == 0)
            {
              return_value_atol_3_link1=atol(p_link1);
              md_ptr_link1->minor = (unsigned int)return_value_atol_3_link1;
            }

          }
        }

      }

    }
    while((_Bool)1);
    fclose(fd_link1);
  }

}

// getparams_periods
// file common/alsa_stream.c line 108
static void getparams_periods(struct _snd_pcm *handle, struct _snd_pcm_hw_params *params, unsigned int *usecs, unsigned int *count, signed int allow_adjust, const char *id)
{
  unsigned int min = (unsigned int)0;
  unsigned int max = (unsigned int)0;
  unsigned int desired = *usecs * *count;
  snd_pcm_hw_params_get_periods_min(params, &min, ((signed int *)NULL));
  snd_pcm_hw_params_get_periods_max(params, &max, ((signed int *)NULL));
  if(!(max == 0u) && !(min == 0u))
  {
    if(!(verbose == 0))
      fprintf(error_fp, "alsa: %s periods range between %u and %u. Want: %u\n", id, min, max, *count);

    if(!(*count >= min))
      *count = min;

    if(!(max >= *count))
      *count = max;

  }

  max = (unsigned int)0;
  min = max;
  snd_pcm_hw_params_get_period_time_min(params, &min, ((signed int *)NULL));
  snd_pcm_hw_params_get_period_time_max(params, &max, ((signed int *)NULL));
  if(!(max == 0u) && !(min == 0u))
  {
    if(!(verbose == 0))
      fprintf(error_fp, "alsa: %s period time range between %u and %u. Want: %u\n", id, min, max, *usecs);

    if(!(*usecs >= min))
      *usecs = min;

    if(!(max >= *usecs))
      *usecs = max;

  }

  if(!(allow_adjust == 0))
  {
    _Bool tmp_if_expr_1;
    if(!(*count * *usecs >= (8u * desired) / 10u))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = *usecs * *count > (desired * (unsigned int)12) / (unsigned int)10 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      *count = (desired + *usecs / (unsigned int)2) / *usecs;
      getparams_periods(handle, params, usecs, count, 0, id);
    }

  }

}

// gl_blit
// file x11/blit.c line 644
static void gl_blit(struct _WidgetRec *widget, char *rgbbuf, signed int iw, signed int ih, signed int ww, signed int wh, signed int tex, signed int tw, signed int th, signed int fmt, signed int type)
{
  float x;
  float y;
  glTexSubImage2D((unsigned int)0x0DE1, 0, 0, 0, iw, ih, (unsigned int)fmt, (unsigned int)type, (const void *)rgbbuf);
  x = (float)iw / (float)tw;
  y = (float)ih / (float)th;
  glEnable((unsigned int)0x0DE1);
  glTexEnvf((unsigned int)0x2300, (unsigned int)0x2200, (float)0x2101);
  glBegin((unsigned int)0x0007);
  glTexCoord2f((float)0, y);
  glVertex3f((float)0, (float)0, (float)0);
  glTexCoord2f((float)0, (float)0);
  glVertex3f((float)0, (float)wh, (float)0);
  glTexCoord2f(x, (float)0);
  glVertex3f((float)ww, (float)wh, (float)0);
  glTexCoord2f(x, y);
  glVertex3f((float)ww, (float)0, (float)0);
  glEnd();
  struct _XDisplay *return_value_XtDisplay_1;
  return_value_XtDisplay_1=XtDisplay(widget);
  unsigned long int return_value_XtWindow_2;
  return_value_XtWindow_2=XtWindow(widget);
  glXSwapBuffers(return_value_XtDisplay_1, return_value_XtWindow_2);
  glDisable((unsigned int)0x0DE1);
}

// gl_cleanup
// file x11/blit.c line 639
static void gl_cleanup(signed int tex)
{
  ;
}

// gl_ext
// file x11/blit.c line 572
static signed int gl_ext(unsigned char *find)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen((const char *)find);
  len = (signed int)return_value_strlen_1;
  const unsigned char *ext;
  unsigned char *pos;
  ext=glGetString((unsigned int)0x1F03);
  if(ext == ((const unsigned char *)NULL))
    return 0;

  else
  {
    char *return_value_strstr_2;
    return_value_strstr_2=strstr((const char *)ext, (const char *)find);
    pos = (unsigned char *)return_value_strstr_2;
    if(pos == ((unsigned char *)NULL))
      return 0;

    else
      if(!(pos == ext))
      {
        if((signed int)pos[-1l] == 32)
          goto __CPROVER_DUMP_L3;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        if(!((signed int)pos[(signed long int)len] == 32))
        {
          if((signed int)pos[(signed long int)len] == 0)
            goto __CPROVER_DUMP_L4;

          return 0;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          if(!(debug == 0))
            fprintf(stderr, "blit: gl: extension %s is available\n", find);

          return 1;
        }
      }
  }
}

// gl_init
// file x11/blit.c line 527
static signed int gl_init(struct _WidgetRec *widget)
{
  void *gl_init__1__old_handler;
  struct anonymous_1 *visinfo;
  struct __GLXcontextRec *ctx;
  if(!(debug == 0))
    fprintf(stderr, "blit: gl: init\n");

  struct _XDisplay *return_value_XtDisplay_1;
  return_value_XtDisplay_1=XtDisplay(widget);
  struct anonymous_0 *return_value_XtScreen_2;
  return_value_XtScreen_2=XtScreen(widget);
  signed int return_value_XScreenNumberOfScreen_3;
  return_value_XScreenNumberOfScreen_3=XScreenNumberOfScreen(return_value_XtScreen_2);
  visinfo=glXChooseVisual(return_value_XtDisplay_1, return_value_XScreenNumberOfScreen_3, gl_attrib);
  struct _XDisplay *return_value_XtDisplay_5;
  signed int return_value_glXIsDirect_6;
  if(visinfo == ((struct anonymous_1 *)NULL))
  {
    if(!(debug == 0))
      fprintf(stderr, "blit: gl: can't get visual (rgb,db)\n");

    return -1;
  }

  else
  {
    struct _XDisplay *return_value_XtDisplay_4;
    return_value_XtDisplay_4=XtDisplay(widget);
    ctx=glXCreateContext(return_value_XtDisplay_4, visinfo, (struct __GLXcontextRec *)(void *)0, 1);
    if(ctx == ((struct __GLXcontextRec *)NULL))
    {
      if(!(debug == 0))
        fprintf(stderr, "blit: gl: can't create context\n");

      return -1;
    }

    else
    {
      if(!(debug == 0))
      {
        return_value_XtDisplay_5=XtDisplay(widget);
        return_value_glXIsDirect_6=glXIsDirect(return_value_XtDisplay_5, ctx);
        fprintf(stderr, "blit: gl: DRI=%s\n", return_value_glXIsDirect_6 != 0 ? "Yes" : "No");
      }

      struct _XDisplay *return_value_XtDisplay_7;
      return_value_XtDisplay_7=XtDisplay(widget);
      signed int return_value_glXIsDirect_8;
      return_value_glXIsDirect_8=glXIsDirect(return_value_XtDisplay_7, ctx);
      if(return_value_glXIsDirect_8 == 0)
        return -1;

      else
      {
        signed int (*return_value_XSetErrorHandler_9)(struct _XDisplay *, struct anonymous *);
        return_value_XSetErrorHandler_9=XSetErrorHandler(catch_gl_error);
        gl_init__1__old_handler = (void *)return_value_XSetErrorHandler_9;
        struct _XDisplay *return_value_XtDisplay_10;
        return_value_XtDisplay_10=XtDisplay(widget);
        unsigned long int return_value_XtWindow_11;
        return_value_XtWindow_11=XtWindow(widget);
        glXMakeCurrent(return_value_XtDisplay_10, return_value_XtWindow_11, ctx);
        struct _XDisplay *return_value_XtDisplay_12;
        return_value_XtDisplay_12=XtDisplay(widget);
        XSync(return_value_XtDisplay_12, 0);
        XSetErrorHandler((signed int (*)(struct _XDisplay *, struct anonymous *))gl_init__1__old_handler);
        if(!(gl_error == 0))
          return -1;

        else
        {
          have_gl = 1;
          glGetIntegerv((unsigned int)0x0D33, &max_gl);
          if(!(debug == 0))
            fprintf(stderr, "blit: gl: texture max size: %d\n", max_gl);

          return 0;
        }
      }
    }
  }
}

// gl_resize
// file x11/blit.c line 592
static signed int gl_resize(signed int iw, signed int ih, signed int ww, signed int wh, signed int *tex, signed int *tw, signed int *th, signed int fmt, signed int type)
{
  char *dummy;
  signed int i;
  if(!(max_gl >= iw))
    return -1;

  else
    if(!(max_gl >= ih))
      return -1;

    else
    {
      i = 0;
      for( ; iw >= 1 << i; i = i + 1)
        ;
      *tw = 1 << i;
      i = 0;
      for( ; ih >= 1 << i; i = i + 1)
        ;
      *th = 1 << i;
      if(!(debug == 0))
        fprintf(stderr, "blit: gl: frame=%dx%d, texture=%dx%d\n", iw, ih, *tw, *th);

      glClearColor((float)0.0, (float)0.0, (float)0.0, (float)0.0);
      glShadeModel((unsigned int)0x1D00);
      glPixelStorei((unsigned int)0x0CF5, 1);
      glViewport(0, 0, ww, wh);
      glMatrixMode((unsigned int)0x1701);
      glLoadIdentity();
      glOrtho(0.0, (double)ww, 0.0, (double)wh, (double)-1, (double)1);
      glMatrixMode((unsigned int)0x1700);
      glLoadIdentity();
      glGenTextures(1, (unsigned int *)tex);
      glBindTexture((unsigned int)0x0DE1, (unsigned int)*tex);
      glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2800, 0x2601);
      glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2801, 0x2601);
      void *return_value_malloc_1;
      return_value_malloc_1=malloc((unsigned long int)(*tw * *th * 3));
      dummy = (char *)return_value_malloc_1;
      memset((void *)dummy, 128, (unsigned long int)(*tw * *th * 3));
      glTexImage2D((unsigned int)0x0DE1, 0, 0x1907, *tw, *th, 0, (unsigned int)fmt, (unsigned int)type, (const void *)dummy);
      free((void *)dummy);
      return 0;
    }
}

// gnome_stay_on_top
// file x11/wmhooks.c line 75
static void gnome_stay_on_top(struct _XDisplay *dpy, unsigned long int win, signed int state)
{
  struct anonymous_51 xev;
  if(!(win == 0ul))
  {
    memset((void *)&xev, 0, sizeof(struct anonymous_51) /*96ul*/ );
    xev.type = 33;
    xev.window = win;
    xev.message_type = _WIN_LAYER;
    xev.format = 32;
    xev.data.l[(signed long int)0] = (signed long int)(state != 0 ? 6 : 4);
    XSendEvent(dpy, (&((struct anonymous_10 *)dpy)->screens[(signed long int)((struct anonymous_10 *)dpy)->default_screen])->root, 0, 1L << 19, (union _XEvent *)&xev);
    if(!(state == 0))
      XRaiseWindow(dpy, win);

  }

}

// grabber_init
// file x11/xt.h line 183
void grabber_init(void)
{
  struct ng_video_fmt screen;
  void *base = (void *)0;
  memset((void *)&screen, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
  if(!(have_dga == 0))
  {
    signed int bar;
    signed int fred;
    orig_xfree_error_handler=XSetErrorHandler(xfree_dga_error_handler);
    signed int return_value_XDefaultScreen_1;
    return_value_XDefaultScreen_1=XDefaultScreen(dpy);
    signed int return_value_XF86DGAGetVideoLL_2;
    return_value_XF86DGAGetVideoLL_2=XF86DGAGetVideoLL(dpy, return_value_XDefaultScreen_1, (unsigned int *)(void *)&base, (signed int *)&screen.bytesperline, &bar, &fred);
    if(return_value_XF86DGAGetVideoLL_2 == 0)
    {
      have_dga = 0;
      memset((void *)&screen, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
      base = (void *)0;
    }

    XSync(dpy, 0);
    XSetErrorHandler(orig_xfree_error_handler);
  }

  if(do_overlay == 0)
  {
    if(!(debug == 0))
      fprintf(stderr, "x11: remote display (overlay disabled)\n");

    drv=ng_vid_open(&args.device, args.driver, (struct ng_video_fmt *)(void *)0, base, &h_drv);
  }

  else
  {
    struct anonymous_0 *return_value_XtScreen_3;
    return_value_XtScreen_3=XtScreen(app_shell);
    screen.width = (unsigned int)return_value_XtScreen_3->width;
    struct anonymous_0 *return_value_XtScreen_4;
    return_value_XtScreen_4=XtScreen(app_shell);
    screen.height = (unsigned int)return_value_XtScreen_4->height;
    screen.fmtid = x11_dpy_fmtid;
    screen.bytesperline = screen.bytesperline * (ng_vfmt_to_depth[(signed long int)x11_dpy_fmtid] / (unsigned int)8);
    if(!(debug == 0))
      fprintf(stderr, "x11: %dx%d, %d bit/pixel, %d byte/scanline%s%s\n", screen.width, screen.height, ng_vfmt_to_depth[(signed long int)screen.fmtid], screen.bytesperline, have_dga != 0 ? ", DGA" : "", have_vm != 0 ? ", VidMode" : "");

    drv=ng_vid_open(&args.device, args.driver, &screen, base, &h_drv);
  }
  if(drv == ((struct ng_vid_driver *)NULL))
  {
    fprintf(stderr, "no video grabber device available\n");
    exit(1);
  }

  f_drv=drv->capabilities(h_drv);
  struct ng_attribute *return_value;
  return_value=drv->list_attrs(h_drv);
  add_attrs(return_value);
  if(!(args.alsa == 0))
  {
    void *md;
    md=discover_media_devices();
    const char *p;
    p=strrchr(args.device, 47);
    if(!(p == ((const char *)NULL)))
      p = p + 1l;

    else
      p = args.device;
    if(!(args.alsa_cap == ((char *)NULL)))
      alsa_cap = args.alsa_cap;

    else
    {
      p=get_associated_device(md, (const char *)(void *)0, (const enum device_type)MEDIA_SND_CAP, p, (const enum device_type)MEDIA_V4L_VIDEO);
      if(!(p == ((const char *)NULL)))
        alsa_cap=strdup(p);

    }
    if(!(args.alsa_pb == ((char *)NULL)))
      alsa_out = args.alsa_pb;

    else
      alsa_out = "default";
    if(!(alsa_cap == ((char *)NULL)) && !(alsa_out == ((char *)NULL)))
    {
      fprintf(stderr, "Alsa devices: cap: %s (%s), out: %s\n", alsa_cap, args.device, alsa_out);
      mute_notify = x11_mute_notify;
    }

    free_media_devices(md);
  }

}

// grabber_scan
// file x11/xt.h line 184
void grabber_scan(void)
{
  struct ng_vid_driver *driver;
  void *handle;
  struct stat st;
  signed int n;
  signed int i;
  signed int fh;
  signed int flags;
  i = 0;
  char *return_value;
  for( ; !(ng_dev.video_scan[(signed long int)i] == ((char *)NULL)); i = i + 1)
  {
    signed int return_value_lstat_4;
    return_value_lstat_4=lstat(ng_dev.video_scan[(signed long int)i], &st);
    if(return_value_lstat_4 == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 2)
        goto __CPROVER_DUMP_L7;

      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      fprintf(stderr, "%s: %s\n", ng_dev.video_scan[(signed long int)i], return_value_strerror_3);
      goto __CPROVER_DUMP_L7;
    }

    fh=open(ng_dev.video_scan[(signed long int)i], 02);
    if(fh == -1)
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      if(*return_value___errno_location_5 == 19)
        goto __CPROVER_DUMP_L7;

      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      char *return_value_strerror_7;
      return_value_strerror_7=strerror(*return_value___errno_location_6);
      fprintf(stderr, "%s: %s\n", ng_dev.video_scan[(signed long int)i], return_value_strerror_7);
      goto __CPROVER_DUMP_L7;
    }

    close(fh);
    driver=ng_vid_open(&ng_dev.video_scan[(signed long int)i], args.driver, (struct ng_video_fmt *)(void *)0, (void *)0, &handle);
    if(driver == ((struct ng_vid_driver *)NULL))
      fprintf(stderr, "%s: initialization failed\n", ng_dev.video_scan[(signed long int)i]);

    else
    {
      flags=driver->capabilities(handle);
      n=fprintf(stderr, "%s: OK", ng_dev.video_scan[(signed long int)i]);
      fprintf(stderr, "%*s[ -device %s ]\n", 40 - n, (const void *)"", ng_dev.video_scan[(signed long int)i]);
      fprintf(stderr, "    type : %s\n", driver->name);
      if(!(driver->get_devname == ((char * (*)(void *))NULL)))
      {
        return_value=driver->get_devname(handle);
        fprintf(stderr, "    name : %s\n", return_value);
      }

      fprintf(stderr, "    flags: %s %s %s %s\n", (flags & 1) != 0 ? "overlay" : "", (flags & 2) != 0 ? "capture" : "", (flags & 4) != 0 ? "tuner" : "", (flags & 8) != 0 ? "chromakey" : "");
      driver->close(handle);
      fprintf(stderr, "\n");
    }

  __CPROVER_DUMP_L7:
    ;
  }
  exit(0);
}

// gray_to_lut2
// file libng/color_lut.c line 82
static void gray_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)*src] | ng_lut_green[(signed long int)*src] | ng_lut_blue[(signed long int)*src]);
    src = src + 1l;
  }
  while((_Bool)1);
}

// gray_to_lut4
// file libng/color_lut.c line 148
static void gray_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)*src] | ng_lut_green[(signed long int)*src] | ng_lut_blue[(signed long int)*src]);
    src = src + 1l;
  }
  while((_Bool)1);
}

// handle_cmdline_args
// file x11/xt.h line 188
void handle_cmdline_args(void)
{
  XtGetApplicationResources(app_shell, (void *)&args, args_desc, (unsigned int)args_count, (struct anonymous_11 *)(void *)0, (unsigned int)0);
  if(!(args.help == 0))
  {
    usage();
    exit(0);
  }

  snapbase = args.basename;
  debug = args.debug;
  ng_debug = args.debug;
  if(args.xv == 0)
  {
    args.xv_video = 0;
    args.xv_image = 0;
  }

  if(args.dspdev == ((char *)NULL))
    args.dspdev = ng_dev.dsp;

  if(args.vbidev == ((char *)NULL))
    args.vbidev = ng_dev.vbi;

  if(!(args.device == ((char *)NULL)) || !(args.driver == ((char *)NULL)))
    args.xv_video = 0;

  if(args.device == ((char *)NULL))
    args.device = "auto";

  if(args.driver == ((char *)NULL))
    args.driver = ng_dev.driver;

  if(!(args.xv_port == 0))
    args.xv_video = 1;

}

// hello_world
// file x11/xt.h line 187
void hello_world(char *name)
{
  struct utsname uts;
  unsigned int return_value_geteuid_2;
  return_value_geteuid_2=geteuid();
  unsigned int return_value_getuid_1;
  if(return_value_geteuid_2 == 0u)
  {
    return_value_getuid_1=getuid();
    if(!(return_value_getuid_1 == 0u))
    {
      fprintf(stderr, "%s *must not* be installed suid root\n", name);
      exit(1);
    }

  }

  uname(&uts);
  fprintf(stderr, "This is %s-%s, running on %s/%s (%s)\n", name, (const void *)"3.103", (const void *)uts.sysname, (const void *)uts.machine, (const void *)uts.release);
}

// init_atoms
// file x11/atoms.h line 2
void init_atoms(struct _XDisplay *dpy)
{
  WM_PROTOCOLS=XInternAtom(dpy, "WM_PROTOCOLS", 0);
  WM_DELETE_WINDOW=XInternAtom(dpy, "WM_DELETE_WINDOW", 0);
  _NET_SUPPORTED=XInternAtom(dpy, "_NET_SUPPORTED", 0);
  _NET_WM_STATE=XInternAtom(dpy, "_NET_WM_STATE", 0);
  _NET_WM_STATE_STAYS_ON_TOP=XInternAtom(dpy, "_NET_WM_STATE_STAYS_ON_TOP", 0);
  _NET_WM_STATE_ABOVE=XInternAtom(dpy, "_NET_WM_STATE_ABOVE", 0);
  _NET_WM_STATE_FULLSCREEN=XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", 0);
  _WIN_SUPPORTING_WM_CHECK=XInternAtom(dpy, "_WIN_SUPPORTING_WM_CHECK", 0);
  _WIN_PROTOCOLS=XInternAtom(dpy, "_WIN_PROTOCOLS", 0);
  _WIN_LAYER=XInternAtom(dpy, "_WIN_LAYER", 0);
  _NETSCAPE_URL=XInternAtom(dpy, "_NETSCAPE_URL", 0);
  _XAWTV_STATION=XInternAtom(dpy, "_XAWTV_STATION", 0);
  _XAWTV_REMOTE=XInternAtom(dpy, "_XAWTV_REMOTE", 0);
  XV_MUTE=XInternAtom(dpy, "XV_MUTE", 0);
  XV_ENCODING=XInternAtom(dpy, "XV_ENCODING", 0);
  XV_FREQ=XInternAtom(dpy, "XV_FREQ", 0);
  XV_COLORKEY=XInternAtom(dpy, "XV_COLORKEY", 0);
  _MOTIF_CLIPBOARD_TARGETS=XInternAtom(dpy, "_MOTIF_CLIPBOARD_TARGETS", 0);
  _MOTIF_DEFERRED_CLIPBOARD_TARGETS=XInternAtom(dpy, "_MOTIF_DEFERRED_CLIPBOARD_TARGETS", 0);
  _MOTIF_SNAPSHOT=XInternAtom(dpy, "_MOTIF_SNAPSHOT", 0);
  _MOTIF_DROP=XInternAtom(dpy, "_MOTIF_DROP", 0);
  _MOTIF_EXPORT_TARGETS=XInternAtom(dpy, "_MOTIF_EXPORT_TARGETS", 0);
  _MOTIF_LOSE_SELECTION=XInternAtom(dpy, "_MOTIF_LOSE_SELECTION", 0);
  XA_DEACTIVATE=XInternAtom(dpy, "DEACTIVATE", 0);
  XA_TARGETS=XInternAtom(dpy, "TARGETS", 0);
  XA_DONE=XInternAtom(dpy, "DONE", 0);
  XA_CLIPBOARD=XInternAtom(dpy, "CLIPBOARD", 0);
  XA_UTF8_STRING=XInternAtom(dpy, "UTF8_STRING", 0);
  XA_FILE_NAME=XInternAtom(dpy, "FILE_NAME", 0);
  XA_FILE=XInternAtom(dpy, "FILE", 0);
  XA_BACKGROUND=XInternAtom(dpy, "BACKGROUND", 0);
  XA_FOREGROUND=XInternAtom(dpy, "FOREGROUND", 0);
  XA_PIXEL=XInternAtom(dpy, "PIXEL", 0);
  MIME_TEXT_ISO8859_1=XInternAtom(dpy, "text/plain;charset=ISO-8859-1", 0);
  MIME_TEXT_UTF_8=XInternAtom(dpy, "text/plain;charset=UTF-8", 0);
  MIME_IMAGE_PPM=XInternAtom(dpy, "image/ppm", 0);
  MIME_IMAGE_JPEG=XInternAtom(dpy, "image/jpeg", 0);
  MIME_TEXT_URI_LIST=XInternAtom(dpy, "text/uri-list", 0);
}

// init_channel
// file common/channel.c line 318
static void init_channel(char *name, struct CHANNEL *c)
{
  struct ng_attribute *attr;
  char *val;
  signed int n;
  signed int i;
  val=cfg_get_str(name, "capture");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, captab);
    if(!(i == -1))
      c->capture = i;

    else
      fprintf(stderr, "config: invalid value for capture: %s\n", val);
  }

  attr=ng_attr_byid(attrs, 2);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "input");
    _Bool tmp_if_expr_1;
    if(!(val == ((char *)NULL)))
      tmp_if_expr_1 = (_Bool)1;

    else
    {
      val=cfg_get_str(name, "source");
      tmp_if_expr_1 = (char *)(void *)0 != val ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_1)
    {
      i=ng_attr_getint(attr, val);
      if(!(i == -1))
        c->input = i;

      else
      {
        fprintf(stderr, "config: invalid value for input: %s\n", val);
        ng_attr_listchoices(attr);
      }
    }

  }

  attr=ng_attr_byid(attrs, 1);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "norm");
    if(!(val == ((char *)NULL)))
    {
      i=ng_attr_getint(attr, val);
      if(!(i == -1))
        c->norm = i;

      else
      {
        fprintf(stderr, "config: invalid value for norm: %s\n", val);
        ng_attr_listchoices(attr);
      }
    }

  }

  attr=ng_attr_byid(attrs, 5);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "audio");
    if(!(val == ((char *)NULL)))
    {
      i=ng_attr_getint(attr, val);
      if(!(i == -1))
        c->audio = i;

      else
      {
        fprintf(stderr, "config: invalid value for audio: %s\n", val);
        ng_attr_listchoices(attr);
      }
    }

  }

  val=cfg_get_str(name, "channel");
  if(!(val == ((char *)NULL)))
    c->cname=strdup(val);

  val=cfg_get_str(name, "freq");
  double return_value_atof_2;
  if(!(val == ((char *)NULL)))
  {
    return_value_atof_2=atof(val);
    c->freq = (signed int)(return_value_atof_2 * (double)16);
  }

  n=cfg_get_signed_int(name, "fine");
  if(!(n == 0))
    c->fine = n;

  val=cfg_get_str(name, "key");
  if(!(val == ((char *)NULL)))
    c->key=strdup(val);

  val=cfg_get_str(name, "group");
  if(!(val == ((char *)NULL)))
    c->group=strdup(val);

  val=cfg_get_str(name, "midi");
  if(!(val == ((char *)NULL)))
    c->midi=atoi(val);

  attr=ng_attr_byid(attrs, 6);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "color");
    if(!(val == ((char *)NULL)))
      c->color=ng_attr_parse_int(attr, val);

  }

  attr=ng_attr_byid(attrs, 7);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "bright");
    if(!(val == ((char *)NULL)))
      c->bright=ng_attr_parse_int(attr, val);

  }

  attr=ng_attr_byid(attrs, 8);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "hue");
    if(!(val == ((char *)NULL)))
      c->hue=ng_attr_parse_int(attr, val);

  }

  attr=ng_attr_byid(attrs, 9);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "contrast");
    if(!(val == ((char *)NULL)))
      c->contrast=ng_attr_parse_int(attr, val);

  }

}

// init_movie_menus
// file x11/motv.c line 2025
static void init_movie_menus(void)
{
  update_movie_menus();
  if(!(mov_rate == ((char *)NULL)))
    do_va_cmd(3, (const void *)"movie", (const void *)"rate", mov_rate);

  if(!(mov_fps == ((char *)NULL)))
    do_va_cmd(3, (const void *)"movie", (const void *)"fps", mov_fps);

}

// init_overlay
// file ./common/commands.h line 75
void init_overlay(void)
{
  const char *tmp_if_expr_1;
  if(!(chantab == -1))
    tmp_if_expr_1 = (chanlist_names + (signed long int)chantab)->str;

  else
    tmp_if_expr_1 = "europe-west";
  do_va_cmd(2, (const void *)"setfreqtab", tmp_if_expr_1);
  cur_capture = -1;
  switch(defaults.capture)
  {
    case 9:

    case 1:
    {
      do_va_cmd(2, (const void *)"capture", (const void *)"overlay");
      break;
    }
    case 2:
    {
      do_va_cmd(2, (const void *)"capture", (const void *)"grabdisplay");
      break;
    }
    default:
      do_va_cmd(2, (const void *)"capture", (const void *)"off");
  }
}

// init_sim
// file common/vbi-sim.c line 429
static struct vbi_raw_decoder * init_sim(signed int scanning, unsigned int services)
{
  vbi_raw_decoder_init(&sim);
  sim.scanning = scanning;
  sim.sampling_format = (enum anonymous_97)VBI_PIXFMT_YUV420;
  sim.sampling_rate = 2 * 13500000;
  sim.bytes_per_line = 1440;
  sim.offset = (signed int)(9.7e-6 * (double)sim.sampling_rate);
  sim.interlaced = 0;
  sim.synchronous = 1;
  if(scanning == 525)
  {
    sim.start[(signed long int)0] = 10;
    sim.count[(signed long int)0] = (21 - 10) + 1;
    sim.start[(signed long int)1] = 272;
    sim.count[(signed long int)1] = (285 - 272) + 1;
  }

  else
    if(scanning == 625)
    {
      sim.start[(signed long int)0] = 6;
      sim.count[(signed long int)0] = (23 - 6) + 1;
      sim.start[(signed long int)1] = 318;
      sim.count[(signed long int)1] = (335 - 318) + 1;
    }

    else
      /* assertion !"invalid scanning value" */
      assert(!((_Bool)"invalid scanning value"));
  sim_time = 0.0;
  vbi_raw_decoder_add_services(&sim, services, 0);
  return &sim;
}

// int_to_str
// file common/channel.c line 752
const char * int_to_str(signed int n, struct STRTAB *tab)
{
  signed int i = 0;
  for( ; !((tab + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
    if((tab + (signed long int)i)->nr == (signed long int)n)
      return (tab + (signed long int)i)->str;

  return (const char *)(void *)0;
}

// ipc_convert
// file x11/motv.c line 2858
static void ipc_convert(struct _WidgetRec *widget, void *ignore, void *call_data)
{
  struct anonymous_66 *ccs = (struct anonymous_66 *)call_data;
  struct ipc_data *ipc;
  unsigned long int *targs;
  unsigned long int *pix;
  unsigned long int *ldata;
  unsigned char *cdata;
  char *filename;
  signed int n;
  char *return_value_XGetAtomName_1;
  char *return_value_XGetAtomName_3;
  char *return_value_XGetAtomName_5;
  if(!(debug == 0))
  {
    char *y;
    char *tmp_if_expr_2;
    if(ccs->type == 0ul)
      tmp_if_expr_2 = (char *)(void *)0;

    else
    {
      return_value_XGetAtomName_1=XGetAtomName(dpy, ccs->type);
      tmp_if_expr_2 = return_value_XGetAtomName_1;
    }
    y = tmp_if_expr_2;
    char *t;
    char *tmp_if_expr_4;
    if(ccs->target == 0ul)
      tmp_if_expr_4 = (char *)(void *)0;

    else
    {
      return_value_XGetAtomName_3=XGetAtomName(dpy, ccs->target);
      tmp_if_expr_4 = return_value_XGetAtomName_3;
    }
    t = tmp_if_expr_4;
    char *s;
    char *tmp_if_expr_6;
    if(ccs->selection == 0ul)
      tmp_if_expr_6 = (char *)(void *)0;

    else
    {
      return_value_XGetAtomName_5=XGetAtomName(dpy, ccs->selection);
      tmp_if_expr_6 = return_value_XGetAtomName_5;
    }
    s = tmp_if_expr_6;
    fprintf(stderr, "conv: target=%s type=%s selection=%s\n", t, y, s);
    if(!(y == ((char *)NULL)))
      XFree((void *)y);

    if(!(t == ((char *)NULL)))
      XFree((void *)t);

    if(!(s == ((char *)NULL)))
      XFree((void *)s);

  }

  _Bool tmp_if_expr_21;
  if(ccs->target == XA_TARGETS)
    tmp_if_expr_21 = (_Bool)1;

  else
    tmp_if_expr_21 = ccs->target == _MOTIF_CLIPBOARD_TARGETS ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_22;
  if(tmp_if_expr_21)
    tmp_if_expr_22 = (_Bool)1;

  else
    tmp_if_expr_22 = ccs->target == _MOTIF_DEFERRED_CLIPBOARD_TARGETS ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_23;
  if(tmp_if_expr_22)
    tmp_if_expr_23 = (_Bool)1;

  else
    tmp_if_expr_23 = ccs->target == _MOTIF_EXPORT_TARGETS ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_23)
  {
    n = 0;
    char *return_value_XtMalloc_7;
    return_value_XtMalloc_7=XtMalloc((unsigned int)(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)12));
    targs = (unsigned long int *)return_value_XtMalloc_7;
    if(!(ccs->target == _MOTIF_CLIPBOARD_TARGETS))
    {
      signed int tmp_post_8 = n;
      n = n + 1;
      targs[(signed long int)tmp_post_8] = XA_TARGETS;
      signed int tmp_post_9 = n;
      n = n + 1;
      targs[(signed long int)tmp_post_9] = MIME_IMAGE_PPM;
      signed int tmp_post_10 = n;
      n = n + 1;
      targs[(signed long int)tmp_post_10] = (unsigned long int)20;
      signed int tmp_post_11 = n;
      n = n + 1;
      targs[(signed long int)tmp_post_11] = XA_FOREGROUND;
      signed int tmp_post_12 = n;
      n = n + 1;
      targs[(signed long int)tmp_post_12] = XA_BACKGROUND;
      signed int tmp_post_13 = n;
      n = n + 1;
      targs[(signed long int)tmp_post_13] = (unsigned long int)7;
      signed int tmp_post_14 = n;
      n = n + 1;
      targs[(signed long int)tmp_post_14] = MIME_IMAGE_JPEG;
      signed int tmp_post_15 = n;
      n = n + 1;
      targs[(signed long int)tmp_post_15] = XA_FILE_NAME;
      signed int tmp_post_16 = n;
      n = n + 1;
      targs[(signed long int)tmp_post_16] = XA_FILE;
      signed int tmp_post_17 = n;
      n = n + 1;
      targs[(signed long int)tmp_post_17] = MIME_TEXT_URI_LIST;
      signed int tmp_post_18 = n;
      n = n + 1;
      targs[(signed long int)tmp_post_18] = _NETSCAPE_URL;
    }

    if(ccs->target == _MOTIF_EXPORT_TARGETS)
      ipc_init(ccs->selection);

    ccs->value = (void *)targs;
    ccs->length = (unsigned long int)n;
    ccs->type = (unsigned long int)4;
    ccs->format = 32;
    ccs->status = 4;
    goto __CPROVER_DUMP_L54;
  }

  else
    if(ccs->target == _MOTIF_SNAPSHOT)
    {
      n = 0;
      char *return_value_XtMalloc_19;
      return_value_XtMalloc_19=XtMalloc((unsigned int)sizeof(unsigned long int) /*8ul*/ );
      targs = (unsigned long int *)return_value_XtMalloc_19;
      signed int tmp_post_20 = n;
      n = n + 1;
      targs[(signed long int)tmp_post_20]=ipc_unique_atom(widget);
      ipc_init(targs[(signed long int)0]);
      ccs->value = (void *)targs;
      ccs->length = (unsigned long int)n;
      ccs->type = (unsigned long int)4;
      ccs->format = 32;
      ccs->status = 4;
      goto __CPROVER_DUMP_L54;
    }

  ipc=ipc_find(ccs->selection);
  if(ipc == ((struct ipc_data *)NULL))
  {
    fprintf(stderr, "oops: selection data not found\n");
    ccs->status = 3;
  }

  else
  {
    _Bool tmp_if_expr_24;
    if(ccs->target == _MOTIF_LOSE_SELECTION)
      tmp_if_expr_24 = (_Bool)1;

    else
      tmp_if_expr_24 = ccs->target == XA_DONE ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_24)
    {
      ipc_fini(ccs->selection);
      ccs->value = (void *)0;
      ccs->length = (unsigned long int)0;
      ccs->type = (unsigned long int)19;
      ccs->format = 32;
      ccs->status = 4;
    }

    else
    {
      _Bool tmp_if_expr_42;
      if(ccs->target == XA_BACKGROUND)
        tmp_if_expr_42 = (_Bool)1;

      else
        tmp_if_expr_42 = ccs->target == XA_FOREGROUND ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_43;
      if(tmp_if_expr_42)
        tmp_if_expr_43 = (_Bool)1;

      else
        tmp_if_expr_43 = ccs->target == (unsigned long int)7 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_43)
      {
        n = 0;
        char *return_value_XtMalloc_25;
        return_value_XtMalloc_25=XtMalloc((unsigned int)(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8));
        ldata = (unsigned long int *)return_value_XtMalloc_25;
        if(ccs->target == XA_BACKGROUND)
        {
          signed int tmp_post_26 = n;
          n = n + 1;
          struct anonymous_0 *return_value_XtScreen_27;
          return_value_XtScreen_27=XtScreen(widget);
          ldata[(signed long int)tmp_post_26] = return_value_XtScreen_27->white_pixel;
          ccs->type = XA_PIXEL;
        }

        if(ccs->target == XA_FOREGROUND)
        {
          signed int tmp_post_28 = n;
          n = n + 1;
          struct anonymous_0 *return_value_XtScreen_29;
          return_value_XtScreen_29=XtScreen(widget);
          ldata[(signed long int)tmp_post_28] = return_value_XtScreen_29->black_pixel;
          ccs->type = XA_PIXEL;
        }

        if(ccs->target == 7ul)
        {
          signed int tmp_post_30 = n;
          n = n + 1;
          struct anonymous_0 *return_value_XtScreen_31;
          return_value_XtScreen_31=XtScreen(widget);
          ldata[(signed long int)tmp_post_30] = return_value_XtScreen_31->cmap;
          ccs->type = (unsigned long int)7;
        }

        ccs->value = (void *)ldata;
        ccs->length = (unsigned long int)n;
        ccs->format = 32;
        ccs->status = 4;
      }

      else
        if(ccs->target == 20ul)
        {
          ipc_pixmap(ipc);
          char *return_value_XtMalloc_32;
          return_value_XtMalloc_32=XtMalloc((unsigned int)sizeof(unsigned long int) /*8ul*/ );
          pix = (unsigned long int *)return_value_XtMalloc_32;
          pix[(signed long int)0] = ipc->pix;
          if(!(debug == 0))
            fprintf(stderr, "conv: pixmap id is 0x%lx\n", pix[(signed long int)0]);

          ccs->value = (void *)pix;
          ccs->length = (unsigned long int)1;
          ccs->type = (unsigned long int)17;
          ccs->format = 32;
          ccs->status = 4;
        }

        else
          if(ccs->target == MIME_IMAGE_PPM)
          {
            char *return_value_XtMalloc_33;
            return_value_XtMalloc_33=XtMalloc((unsigned int)(ipc->buf->size + (unsigned long int)32));
            cdata = (unsigned char *)return_value_XtMalloc_33;
            n=sprintf((char *)cdata, "P6\n%d %d\n255\n", ipc->buf->fmt.width, ipc->buf->fmt.height);
            memcpy((void *)(cdata + (signed long int)n), (const void *)ipc->buf->data, ipc->buf->size);
            ccs->value = (void *)cdata;
            ccs->length = (unsigned long int)n + ipc->buf->size;
            ccs->type = MIME_IMAGE_PPM;
            ccs->format = 8;
            ccs->status = 4;
          }

          else
            if(ccs->target == MIME_IMAGE_JPEG)
            {
              struct ng_video_buf *buf;
              ipc->buf->refcount = ipc->buf->refcount + 1;
              buf=convert_buffer(ipc->buf, 17);
              char *return_value_XtMalloc_34;
              return_value_XtMalloc_34=XtMalloc((unsigned int)buf->size);
              cdata = (unsigned char *)return_value_XtMalloc_34;
              memcpy((void *)cdata, (const void *)buf->data, buf->size);
              ng_release_video_buf(buf);
              ccs->value = (void *)cdata;
              ccs->length = buf->size;
              ccs->type = MIME_IMAGE_JPEG;
              ccs->format = 8;
              ccs->status = 4;
            }

            else
            {
              _Bool tmp_if_expr_38;
              if(ccs->target == XA_FILE_NAME)
                tmp_if_expr_38 = (_Bool)1;

              else
                tmp_if_expr_38 = ccs->target == XA_FILE ? (_Bool)1 : (_Bool)0;
              _Bool tmp_if_expr_39;
              if(tmp_if_expr_38)
                tmp_if_expr_39 = (_Bool)1;

              else
                tmp_if_expr_39 = ccs->target == (unsigned long int)31 ? (_Bool)1 : (_Bool)0;
              _Bool tmp_if_expr_40;
              if(tmp_if_expr_39)
                tmp_if_expr_40 = (_Bool)1;

              else
                tmp_if_expr_40 = ccs->target == MIME_TEXT_URI_LIST ? (_Bool)1 : (_Bool)0;
              _Bool tmp_if_expr_41;
              if(tmp_if_expr_40)
                tmp_if_expr_41 = (_Bool)1;

              else
                tmp_if_expr_41 = ccs->target == _NETSCAPE_URL ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_41)
              {
                ipc_tmpfile(ipc);
                _Bool tmp_if_expr_37;
                if(ccs->target == MIME_TEXT_URI_LIST)
                  tmp_if_expr_37 = (_Bool)1;

                else
                  tmp_if_expr_37 = ccs->target == _NETSCAPE_URL ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_37)
                {
                  unsigned long int return_value_strlen_35;
                  return_value_strlen_35=strlen(ipc->filename);
                  filename=XtMalloc((unsigned int)(return_value_strlen_35 + (unsigned long int)8));
                  sprintf(filename, "file:%s\r\n", ipc->filename);
                  ccs->type = ccs->target;
                  if(!(debug == 0))
                    fprintf(stderr, "conv: tmp url is %s\n", filename);

                }

                else
                {
                  unsigned long int return_value_strlen_36;
                  return_value_strlen_36=strlen(ipc->filename);
                  filename=XtMalloc((unsigned int)return_value_strlen_36);
                  strcpy(filename, ipc->filename);
                  ccs->type = (unsigned long int)31;
                  if(!(debug == 0))
                    fprintf(stderr, "conv: tmp file is %s\n", filename);

                }
                ccs->value = (void *)filename;
                ccs->length=strlen(filename);
                ccs->format = 8;
                ccs->status = 4;
              }

              else
              {
                fprintf(stderr, "oops: unknown target\n");
                ccs->status = 3;
              }
            }
    }
  }

__CPROVER_DUMP_L54:
  ;
}

// ipc_find
// file x11/motv.c line 2735
static struct ipc_data * ipc_find(unsigned long int selection)
{
  struct list_head *item;
  struct ipc_data *ipc;
  item = (&ipc_selections)->next;
  for( ; !(item == &ipc_selections); item = item->next)
  {
    ipc = (struct ipc_data *)((char *)item - (signed long int)(unsigned long int)&((struct ipc_data *)0)->list);
    if(ipc->atom == selection)
      return ipc;

  }
  return (struct ipc_data *)(void *)0;
}

// ipc_fini
// file x11/motv.c line 2816
static void ipc_fini(unsigned long int selection)
{
  struct ipc_data *ipc;
  ipc=ipc_find(selection);
  if(!(ipc == ((struct ipc_data *)NULL)))
  {
    if(!(ipc->buf == ((struct ng_video_buf *)NULL)))
      ng_release_video_buf(ipc->buf);

    if(!(ipc->filename == ((char *)NULL)))
    {
      unlink(ipc->filename);
      free((void *)ipc->filename);
    }

    if(!(ipc->icon_widget == ((struct _WidgetRec *)NULL)))
      XtDestroyWidget(ipc->icon_widget);

    if(!(ipc->icon_pixmap == 0ul))
      XFreePixmap(dpy, ipc->icon_pixmap);

    if(!(ipc->pix == 0ul))
      XFreePixmap(dpy, ipc->pix);

    list_del(&ipc->list);
    free((void *)ipc);
  }

}

// ipc_finish
// file x11/motv.c line 3040
static void ipc_finish(struct _WidgetRec *widget, void *ignore, void *call_data)
{
  if(!(debug == 0))
    fprintf(stderr, "conv: transfer finished\n");

  ipc_fini(_MOTIF_DROP);
}

// ipc_iconify
// file x11/motv.c line 2703
static void ipc_iconify(struct _WidgetRec *widget, struct ipc_data *ipc)
{
  struct ng_video_buf *small;
  signed int scale;
  signed int depth;
  struct anonymous_11 ipc_iconify__1__args[4l];
  unsigned int n = (unsigned int)0;
  scale = 1;
  for( ; (_Bool)1; scale = scale + 1)
    if(!(ipc->buf->fmt.width / (unsigned int)scale >= 128u))
    {
      if(!(ipc->buf->fmt.height / (unsigned int)scale >= 128u))
        goto __CPROVER_DUMP_L3;

    }


__CPROVER_DUMP_L3:
  ;
  small=scale_rgb_buffer(ipc->buf, scale);
  small=convert_buffer(small, (signed int)x11_dpy_fmtid);
  ipc->icon_pixmap=x11_create_pixmap(dpy, &vinfo, small);
  n = (unsigned int)0;
  struct anonymous_0 *return_value_XtScreen_1;
  return_value_XtScreen_1=XtScreen(widget);
  depth = return_value_XtScreen_1->root_depth;
  ipc_iconify__1__args[(signed long int)n].name = (char *)&XtStrings[(signed long int)527];
  ipc_iconify__1__args[(signed long int)n].value = (signed long int)ipc->icon_pixmap;
  n = n + 1u;
  ipc_iconify__1__args[(signed long int)n].name = (char *)&XtStrings[(signed long int)872];
  ipc_iconify__1__args[(signed long int)n].value = (signed long int)small->fmt.width;
  n = n + 1u;
  ipc_iconify__1__args[(signed long int)n].name = (char *)&XtStrings[(signed long int)234];
  ipc_iconify__1__args[(signed long int)n].value = (signed long int)small->fmt.height;
  n = n + 1u;
  ipc_iconify__1__args[(signed long int)n].name = (char *)&XtStrings[(signed long int)163];
  ipc_iconify__1__args[(signed long int)n].value = (signed long int)depth;
  n = n + 1u;
  ipc->icon_widget=XmCreateDragIcon(widget, "dragicon", ipc_iconify__1__args, n);
  ng_release_video_buf(small);
}

// ipc_init
// file x11/motv.c line 2749
static struct ipc_data * ipc_init(unsigned long int selection)
{
  struct ipc_data *ipc;
  struct ng_video_fmt ipc_init__1__fmt;
  struct ng_video_buf *buf;
  video_gd_suspend();
  memset((void *)&ipc_init__1__fmt, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
  ipc_init__1__fmt.fmtid = (unsigned int)9;
  ipc_init__1__fmt.width = cur_tv_width;
  ipc_init__1__fmt.height = cur_tv_height;
  buf=ng_grabber_get_image(&ipc_init__1__fmt);
  buf=ng_filter_single(cur_filter, buf);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ipc_data) /*64ul*/ );
  ipc = (struct ipc_data *)return_value_malloc_1;
  memset((void *)ipc, 0, sizeof(struct ipc_data) /*64ul*/ );
  ipc->buf=ng_malloc_video_buf(&buf->fmt, (signed int)buf->size);
  ipc->atom = selection;
  ipc->buf->info = buf->info;
  memcpy((void *)ipc->buf->data, (const void *)buf->data, buf->size);
  ng_release_video_buf(buf);
  video_gd_restart();
  list_add_tail(&ipc->list, &ipc_selections);
  return ipc;
}

// ipc_pixmap
// file x11/motv.c line 2801
static void ipc_pixmap(struct ipc_data *ipc)
{
  struct ng_video_buf *buf;
  if(ipc->pix == 0ul)
  {
    ipc->buf->refcount = ipc->buf->refcount + 1;
    buf=convert_buffer(ipc->buf, (signed int)x11_dpy_fmtid);
    ipc->pix=x11_create_pixmap(dpy, &vinfo, buf);
    ng_release_video_buf(buf);
    goto __CPROVER_DUMP_L2;
  }


__CPROVER_DUMP_L2:
  ;
}

// ipc_tmpfile
// file x11/motv.c line 2777
static void ipc_tmpfile(struct ipc_data *ipc)
{
  struct ng_video_buf *buf;
  char *tmpdir;
  signed int fd;
  if(ipc->filename == ((char *)NULL))
  {
    tmpdir=getenv("TMPDIR");
    if(tmpdir == ((char *)NULL))
      tmpdir = "/tmp";

    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(tmpdir);
    unsigned long int return_value_strlen_2;
    static char *base = "motv";
    return_value_strlen_2=strlen(base);
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)16);
    ipc->filename = (char *)return_value_malloc_3;
    sprintf(ipc->filename, "%s/%s-XXXXXX", tmpdir, base);
    fd=mkstemp(ipc->filename);
    ipc->buf->refcount = ipc->buf->refcount + 1;
    buf=convert_buffer(ipc->buf, 17);
    write(fd, (const void *)buf->data, buf->size);
    ng_release_video_buf(buf);
  }

}

// ipc_unique_atom
// file x11/motv.c line 2842
static unsigned long int ipc_unique_atom(struct _WidgetRec *widget)
{
  char id_name[32l];
  unsigned long int id;
  signed int i = 0;
  do
  {
    unsigned long int return_value_XtWindow_1;
    return_value_XtWindow_1=XtWindow(widget);
    sprintf(id_name, "_MOTV_IMAGE_%lX_%d", return_value_XtWindow_1, i);
    struct _XDisplay *return_value_XtDisplay_2;
    return_value_XtDisplay_2=XtDisplay(widget);
    id=XInternAtom(return_value_XtDisplay_2, id_name, 0);
    struct ipc_data *return_value_ipc_find_3;
    return_value_ipc_find_3=ipc_find(id);
    if(return_value_ipc_find_3 == ((struct ipc_data *)NULL))
      break;

    i = i + 1;
  }
  while((_Bool)1);
  return id;
}

// joystick_tv_havedata
// file ./common/joystick.h line 2
void joystick_tv_havedata(signed int js)
{
  unsigned int i;
  struct js_event event;
  if(!(debug == 0))
    fprintf(stderr, "joystick: received input\n");

  signed long int return_value_read_1;
  return_value_read_1=read(js, (void *)&event, sizeof(struct js_event) /*8ul*/ );
  if(!(return_value_read_1 == 0l))
  {
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 6ul); i = i + 1u)
      if(joytab[(signed long int)i].class == (signed int)event.type)
      {
        if(joytab[(signed long int)i].number == (signed int)event.number)
        {
          if(joytab[(signed long int)i].value == (signed int)event.value)
            break;

        }

      }

    if(!((unsigned long int)i == 6ul))
      event_dispatch(joytab[(signed long int)i].event);

  }

}

// joystick_tv_init
// file ./common/joystick.h line 1
signed int joystick_tv_init(char *dev)
{
  signed int fd;
  if(dev == ((char *)NULL))
    return -1;

  else
  {
    fd=open(dev, 04000);
    if(fd == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      fprintf(stderr, "joystick: open %s: %s\n", dev, return_value_strerror_2);
      return -1;
    }

    fcntl(fd, 2, 1);
    event_register_list(joy_events);
    return fd;
  }
}

// keypad_handler
// file common/commands.c line 1484
static signed int keypad_handler(char *name, signed int argc, char **argv)
{
  signed int n;
  signed int return_value_atoi_1;
  return_value_atoi_1=atoi(argv[(signed long int)0]);
  n = return_value_atoi_1 % 10;
  char msg[8l];
  char ch[8l];
  if(!(debug == 0))
    fprintf(stderr, "keypad: key %d\n", n);

  if(keypad_state == -1)
  {
    if((keypad_ntsc == 0 ? count >= n : !(n >= 100)) && n >= 1 && !(keypad_partial == 0) || keypad_partial == 0 && (keypad_ntsc == 0 ? count >= n : !(n >= 100)) && n >= 1 && !(keypad_ntsc == 0 ? count >= 10 * n : !(10 * n >= 100)))
    {
      if(!(keypad_ntsc == 0))
      {
        sprintf(ch, "%d", n);
        do_va_cmd(2, (const void *)"setchannel", (const void *)ch, (void *)0);
      }

      else
        do_va_cmd(2, (const void *)"setstation", channels[(signed long int)(n - 1)]->name, (void *)0);
    }

    if((keypad_ntsc == 0 ? count >= 10 * n : !(10 * n >= 100)) && n >= 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "keypad: hang: %d\n", n);

      keypad_state = n;
      if(!(display_message == ((void (*)(char *))NULL)))
      {
        sprintf(msg, "%d_", n);
        display_message(msg);
      }

    }

  }

  else
  {
    if((keypad_ntsc == 0 ? count : 99) >= 10 * keypad_state + n)
      n = n + keypad_state * 10;

    keypad_state = -1;
    if(!(debug == 0))
      fprintf(stderr, "keypad: ok: %d\n", n);

    if((keypad_ntsc == 0 ? count >= n : !(n >= 100)) && n >= 1)
    {
      if(!(keypad_ntsc == 0))
      {
        sprintf(ch, "%d", n);
        do_va_cmd(2, (const void *)"setchannel", (const void *)ch, (void *)0);
      }

      else
        do_va_cmd(2, (const void *)"setstation", channels[(signed long int)(n - 1)]->name, (void *)0);
    }

  }
  return 0;
}

// keypad_timeout
// file ./common/commands.h line 80
void keypad_timeout(void)
{
  if(!(debug == 0))
    fprintf(stderr, "keypad: timeout\n");

  if(keypad_state == 1 + cur_sender)
    set_title();

  keypad_state = -1;
}

// levels_input
// file x11/motv.c line 3096
static void levels_input(void *clientdata, signed int *src, unsigned long int *id)
{
  struct ng_audio_buf *buf;
  signed int left;
  signed int right;
  buf=levels_dsp->read(levels_hdsp, (signed long int)0);
  oss_levels(buf, &left, &right);
  XmScaleSetValue(levels_left, left);
  XmScaleSetValue(levels_right, right);
  if(debug >= 2)
    fprintf(stderr, "levels: left = %3d, right = %3d\r", left, right);

}

// levels_toggle_cb
// file x11/motv.c line 3110
static void levels_toggle_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct anonymous_57 *tb = (struct anonymous_57 *)call_data;
  struct ng_audio_fmt a;
  if(tb->reason == 2)
  {
    if(!(tb->set == 0))
    {
      if(levels_dsp == ((struct ng_dsp_driver *)NULL))
      {
        a.fmtid = (unsigned int)2;
        a.rate = (unsigned int)44100;
        levels_dsp=ng_dsp_open(args.dspdev, &a, 1, &levels_hdsp);
        if(!(levels_dsp == ((struct ng_dsp_driver *)NULL)))
        {
          levels_dsp->startrec(levels_hdsp);
          signed int return_value;
          return_value=levels_dsp->fd(levels_hdsp);
          levels_id=XtAppAddInput(app_context, return_value, (void *)(1L << 0), levels_input, (void *)0);
          if(!(debug == 0))
            fprintf(stderr, "levels: started sound monitor\n");

        }

      }

    }

    if(tb->set == 0)
    {
      if(!(levels_hdsp == NULL))
      {
        XtRemoveInput(levels_id);
        levels_dsp->close(levels_hdsp);
        levels_dsp = (struct ng_dsp_driver *)(void *)0;
        levels_hdsp = (void *)0;
        XmScaleSetValue(levels_left, 0);
        XmScaleSetValue(levels_right, 0);
        if(!(debug == 0))
          fprintf(stderr, "levels: stopped sound monitor\n");

      }

    }

  }

}

// lirc_tv_havedata
// file ./common/lirc.h line 2
signed int lirc_tv_havedata(void)
{
  char *code;
  char event[32l];
  char *cmd;
  char **argv;
  signed int dummy;
  signed int repeat;
  signed int argc;
  signed int ret = -1;
  strcpy(event, "lirc-key-");
  signed int return_value_lirc_nextcode_1;
  signed int return_value_lirc_code2char_3;
  do
  {
    return_value_lirc_nextcode_1=lirc_nextcode(&code);
    if(!(return_value_lirc_nextcode_1 == 0))
      break;

    if(code == ((char *)NULL))
      break;

    ret = 0;
    signed int return_value_sscanf_2;
    return_value_sscanf_2=sscanf(code, "%x %x %20s", &dummy, &repeat, event + (signed long int)9);
    if(!(return_value_sscanf_2 == 3))
      fprintf(stderr, "lirc: oops, parse error: %s", code);

    else
    {
      if(!(debug == 0))
        fprintf(stderr, "lirc: key=%s repeat=%d\n", event + (signed long int)9, repeat);

      if(!(config == ((struct lirc_config *)NULL)))
        do
        {
          return_value_lirc_code2char_3=lirc_code2char(config, code, &cmd);
          if(!(return_value_lirc_code2char_3 == 0))
            break;

          if(cmd == ((char *)NULL))
            break;

          if(!(debug == 0))
            fprintf(stderr, "lirc: cmd \"%s\"\n", cmd);

          signed int return_value_strcasecmp_4;
          return_value_strcasecmp_4=strcasecmp(cmd, "eventmap");
          if(return_value_strcasecmp_4 == 0)
            event_dispatch(event);

          else
          {
            argv=split_cmdline(cmd, &argc);
            do_command(argc, argv);
          }
        }
        while((_Bool)1);

      else
        if(repeat == 0)
          event_dispatch(event);

      free((void *)code);
    }
  }
  while((_Bool)1);
  return ret;
}

// lirc_tv_init
// file ./common/lirc.h line 1
signed int lirc_tv_init(void)
{
  signed int fd;
  fd=lirc_init("xawtv", debug);
  if(fd == -1)
  {
    if(!(debug == 0))
      fprintf(stderr, "lirc: no infrared remote support available\n");

    return -1;
  }

  else
  {
    signed int return_value_lirc_readconfig_1;
    return_value_lirc_readconfig_1=lirc_readconfig((char *)(void *)0, &config, (signed int (*)(char *))(void *)0);
    if(!(return_value_lirc_readconfig_1 == 0))
      config = (struct lirc_config *)(void *)0;

    if(!(debug == 0))
      fprintf(stderr, "lirc: ~/.lircrc file %sfound\n", config != ((struct lirc_config *)NULL) ? "" : "not ");

    fcntl(fd, 4, 04000);
    fcntl(fd, 2, 1);
    event_register_list(lirc_events);
    if(!(debug == 0))
      fprintf(stderr, "lirc: init ok\n");

    return fd;
  }
}

// list_add_tail
// file ./libng/list.h line 65
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
  __list_add(new, head->prev, head);
}

// list_add_tail_link1
// file libng/list.h line 65
static inline void list_add_tail_link1(struct list_head *new_link1, struct list_head *head_link1)
{
  __list_add_link1(new_link1, head_link1->prev, head_link1);
}

// list_del
// file ./libng/list.h line 89
static inline void list_del(struct list_head *entry)
{
  __list_del(entry->prev, entry->next);
}

// list_empty
// file ./libng/list.h line 108
static inline signed int list_empty(struct list_head *head)
{
  return (signed int)(head->next == head);
}

// list_handler
// file common/commands.c line 943
static signed int list_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  signed int val;
  signed int i;
  printf("%-10.10s | type   | %-7.7s | %-7.7s | %s\n", (const void *)"attribute", (const void *)"current", (const void *)"default", (const void *)"comment");
  printf("-----------+--------+---------+---------+-------------------------------------\n");
  attr = attrs;
  const char *return_value_ng_attr_getstr_1;
  const char *return_value_ng_attr_getstr_2;
  for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
  {
    val = cur_attrs[(signed long int)attr->id];
    switch(attr->type)
    {
      case 2:
      {
        return_value_ng_attr_getstr_1=ng_attr_getstr(attr, val);
        return_value_ng_attr_getstr_2=ng_attr_getstr(attr, attr->defval);
        printf("%-10.10s | choice | %-7.7s | %-7.7s |", attr->name, return_value_ng_attr_getstr_1, return_value_ng_attr_getstr_2);
        i = 0;
        for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
          printf(" %s", (attr->choices + (signed long int)i)->str);
        printf("\n");
        break;
      }
      case 1:
      {
        printf("%-10.10s | int    | %7d | %7d | range is %d => %d\n", attr->name, val, attr->defval, attr->min, attr->max);
        break;
      }
      case 3:
        printf("%-10.10s | bool   | %-7.7s | %-7.7s |\n", attr->name, val != 0 ? "on" : "off", attr->defval != 0 ? "on" : "off");
    }
  }
  return 0;
}

// lookup_channel
// file ./common/channel.h line 66
signed int lookup_channel(char *channel)
{
  signed int i;
  signed int tmp_if_expr_1;
  signed int return_value_strcasecmp_3;
  if(channel == ((char *)NULL))
    return -1;

  else
  {
    i = 0;
    do
    {
      if(!(chantab == -1))
        tmp_if_expr_1 = (chanlists + (signed long int)chantab)->count;

      else
        tmp_if_expr_1 = 0;
      if(i >= tmp_if_expr_1)
        break;

      struct CHANLIST *tmp_if_expr_2;
      if(!(chantab == -1))
        tmp_if_expr_2 = (chanlists + (signed long int)chantab)->list;

      else
        tmp_if_expr_2 = (struct CHANLIST *)(void *)0;
      return_value_strcasecmp_3=strcasecmp((tmp_if_expr_2 + (signed long int)i)->name, channel);
      if(return_value_strcasecmp_3 == 0)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    signed int tmp_if_expr_4;
    if(!(chantab == -1))
      tmp_if_expr_4 = (chanlists + (signed long int)chantab)->count;

    else
      tmp_if_expr_4 = 0;
    if(i == tmp_if_expr_4)
      return -1;

    else
      return i;
  }
}

// main
// file x11/motv.c line 3258
signed int main(signed int argc, char **argv)
{
  signed int i;
  unsigned long int freq;
  hello_world("motv");
  XtSetLanguageProc((struct _XtAppStruct *)(void *)0, (char * (*)(struct _XDisplay *, char *, void *))(void *)0, (void *)0);
  app_shell=XtVaAppInitialize(&app_context, "MoTV", opt_desc, (unsigned int)opt_count, &argc, argv, fallback_ressources, (void *)0);
  XtAddEventHandler(app_shell, (unsigned long int)0, (char)1, (void (*)(struct _WidgetRec *, void *, union _XEvent *, char *))_XEditResCheckMessages, (void *)0);
  dpy=XtDisplay(app_shell);
  x11_icons_init(dpy, (unsigned long int)0);
  init_atoms(dpy);
  ng_init();
  handle_cmdline_args();
  if(!(args.hwscan == 0))
  {
    fprintf(stderr, "looking for available devices\n");
    xv_video_init((unsigned int)-1, 1);
    grabber_scan();
  }

  visual_init("motv", "MoTV");
  do_overlay = (signed int)!(args.remote != 0);
  if(!(do_overlay == 0))
    x11_check_remote();

  v4lconf_init();
  XtAppAddActions(app_context, actionTable, (unsigned int)(sizeof(struct _XtActionsRec [16l]) /*256ul*/  / sizeof(struct _XtActionsRec) /*16ul*/ ));
  x11_misc_init(dpy);
  struct _XDisplay *return_value_XtDisplay_1;
  return_value_XtDisplay_1=XtDisplay(app_shell);
  unsigned long int return_value_XInternAtom_2;
  return_value_XInternAtom_2=XInternAtom(return_value_XtDisplay_1, "WM_PROTOCOLS", 0);
  XmAddProtocolCallback(app_shell, return_value_XInternAtom_2, WM_DELETE_WINDOW, ExitCB, (void *)0);
  if(!(debug == 0))
    fprintf(stderr, "main: dga extension...\n");

  xfree_dga_init(dpy);
  if(!(debug == 0))
    fprintf(stderr, "main: xinerama extension...\n");

  xfree_xinerama_init(dpy);
  if(!(debug == 0))
    fprintf(stderr, "main: xvideo extension [video]...\n");

  if(!(args.xv_video == 0))
    xv_video_init((unsigned int)args.xv_port, 0);

  if(!(debug == 0))
    fprintf(stderr, "main: xvideo extension [image]...\n");

  if(!(args.xv_image == 0))
    xv_image_init(dpy);

  update_title = new_title;
  display_message = new_message;
  vtx_subtitle = display_subtitle;
  set_capture_hook = do_capture;
  fullscreen_hook = do_motif_fullscreen;
  attr_notify = new_attr;
  volume_notify = new_volume;
  freqtab_notify = new_freqtab;
  setstation_notify = new_channel;
  movie_hook = do_movie_record;
  rec_status = do_rec_status;
  exit_hook = do_exit;
  capture_get_hook = video_gd_suspend;
  capture_rel_hook = video_gd_restart;
  channel_switch_hook = pixit;
  if(!(debug == 0))
    fprintf(stderr, "main: init main window...\n");

  tv=video_init(app_shell, &vinfo, xmPrimitiveWidgetClass, args.bpp, args.gl);
  struct _WidgetRec *return_value_XtParent_3;
  return_value_XtParent_3=XtParent(tv);
  XtAddEventHandler(return_value_XtParent_3, (unsigned long int)(1L << 17), (char)1, resize_event, (void *)0);
  if(!(debug == 0))
    fprintf(stderr, "main: install signal handlers...\n");

  xt_siginit();
  if(drv == ((struct ng_vid_driver *)NULL))
  {
    if(!(debug == 0))
      fprintf(stderr, "main: open grabber device...\n");

    grabber_init();
  }

  XSetIOErrorHandler(x11_ctrl_alt_backspace);
  if(!(debug == 0))
    fprintf(stderr, "main: checking wm...\n");

  wm_detect(dpy);
  if(!(debug == 0))
    fprintf(stderr, "main: creating windows ...\n");

  create_onscreen(xmLabelWidgetClass);
  create_vtx();
  create_strwin();
  stderr_init();
  if(!(debug == 0))
    fprintf(stderr, "main: init frequency tables ...\n");

  freq_init();
  if(!(args.readconfig == 0))
  {
    if(!(debug == 0))
      fprintf(stderr, "main: read config file ...\n");

    read_config(args.conffile != ((char *)NULL) ? args.conffile : (char *)(void *)0, &argc, argv);
  }

  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(mixerdev);
  if(!(return_value_strlen_4 == 0ul))
  {
    struct ng_attribute *attr;
    if(!(debug == 0))
      fprintf(stderr, "main: open mixer device...\n");

    attr=ng_mix_init(mixerdev, mixerctl);
    if(!(attr == ((struct ng_attribute *)NULL)))
      add_attrs(attr);

  }

  create_control();
  create_prop();
  create_pref();
  create_levels();
  create_filter_prop();
  init_movie_menus();
  create_scale();
  create_attr_widgets();
  do
  {
    (&ipc_selections)->next = &ipc_selections;
    (&ipc_selections)->prev = &ipc_selections;
  }
  while((_Bool)0);
  xt_vm_randr_input_init(dpy);
  if(!(debug == 0))
    fprintf(stderr, "main: mapping main window ...\n");

  XtRealizeWidget(app_shell);
  create_pointers(app_shell);
  create_bitmaps(app_shell);
  unsigned long int return_value_XtWindow_5;
  return_value_XtWindow_5=XtWindow(app_shell);
  XDefineCursor(dpy, return_value_XtWindow_5, left_ptr);
  if(!((2 & f_drv) == 0))
    XtAddCallback(tv, (char *)&_XmStrings[(signed long int)12699], ipc_convert, (void *)0);

  XtVaSetValues(app_shell, (char *)&XtShellStrings[(signed long int)627], 32, (char *)&XtShellStrings[(signed long int)645], 24, (char *)&XtShellStrings[(signed long int)551], 32, (char *)&XtShellStrings[(signed long int)569], 24, (void *)0);
  XtAddEventHandler(tv, (unsigned long int)(1L << 6), (char)1, mouse_event, (void *)0);
  mouse_event(tv, (void *)0, (union _XEvent *)(void *)0, (char *)(void *)0);
  if(!(debug == 0))
    fprintf(stderr, "main: initialize hardware ...\n");

  attr_init();
  audio_on();
  audio_init();
  if(!(args.readconfig == 0))
  {
    if(!(debug == 0))
      fprintf(stderr, "main: parse channels from config file ...\n");

    parse_config(1);
  }

  channel_menu();
  xt_handle_pending(dpy);
  init_overlay();
  set_property(0, (char *)(void *)0, (char *)(void *)0);
  if(1 + optind == argc)
    do_va_cmd(2, (const void *)"setstation", argv[(signed long int)optind]);

  else
  {
    if(!((4 & f_drv) == 0))
    {
      freq=drv->getfreq(h_drv);
      if(!(freq == 0ul))
      {
        i = 0;
        signed int tmp_if_expr_6;
        if(!(chantab == -1))
          tmp_if_expr_6 = (chanlists + (signed long int)chantab)->count;

        else
          tmp_if_expr_6 = 0;
        if(!(i >= tmp_if_expr_6))
        {
          struct CHANLIST *tmp_if_expr_8;
          if(!(chantab == -1))
            tmp_if_expr_8 = (chanlists + (signed long int)chantab)->list;

          else
            tmp_if_expr_8 = (struct CHANLIST *)(void *)0;
          if((unsigned long int)(tmp_if_expr_8 + (signed long int)i)->freq == (1000ul * freq) / 16ul)
          {
            struct CHANLIST *tmp_if_expr_7;
            if(!(chantab == -1))
              tmp_if_expr_7 = (chanlists + (signed long int)chantab)->list;

            else
              tmp_if_expr_7 = (struct CHANLIST *)(void *)0;
            do_va_cmd(2, (const void *)"setchannel", (tmp_if_expr_7 + (signed long int)i)->name);
          }

          else
            i = i + 1;
        }

      }

    }

    if(cur_channel == -1)
    {
      if(count >= 1)
      {
        if(!(debug == 0))
          fprintf(stderr, "main: tuning first station\n");

        do_va_cmd(2, (const void *)"setstation", (const void *)"0");
      }

      else
      {
        if(!(debug == 0))
          fprintf(stderr, "main: setting defaults\n");

        set_defaults();
      }
    }

    else
      if(!(debug == 0))
        fprintf(stderr, "main: known station tuned, not changing\n");

  }
  XtAddEventHandler(tv, (unsigned long int)(1L << 15), (char)1, tv_expose_event, (void *)0);
  if(!(args.fullscreen == 0))
    do_motif_fullscreen();

  else
    XtAppAddWorkProc(app_context, MyResize, (void *)0);
  xt_main_loop();
  return 0;
}

// man
// file x11/man.c line 45
void man(char *page)
{
  struct _WidgetRec *dlg;
  struct _WidgetRec *view;
  struct _WidgetRec *label;
  union __XmStringRec *xmpage;
  union __XmStringRec *xmchunk;
  char line[1024l];
  char chunk[256l];
  signed int s;
  signed int d;
  signed int cur;
  signed int last;
  struct _IO_FILE *fp;
  dlg=XmCreatePromptDialog(app_shell, "man", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  struct _WidgetRec *return_value_XtParent_1;
  return_value_XtParent_1=XtParent(dlg);
  XtAddEventHandler(return_value_XtParent_1, (unsigned long int)0, (char)1, (void (*)(struct _WidgetRec *, void *, union _XEvent *, char *))_XEditResCheckMessages, (void *)0);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_2;
  return_value_XmSelectionBoxGetChild_2=XmSelectionBoxGetChild(dlg, (unsigned char)11);
  XtUnmanageChild(return_value_XmSelectionBoxGetChild_2);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_3;
  return_value_XmSelectionBoxGetChild_3=XmSelectionBoxGetChild(dlg, (unsigned char)7);
  XtUnmanageChild(return_value_XmSelectionBoxGetChild_3);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_4;
  return_value_XmSelectionBoxGetChild_4=XmSelectionBoxGetChild(dlg, (unsigned char)2);
  XtUnmanageChild(return_value_XmSelectionBoxGetChild_4);
  struct _WidgetRec *return_value_XmSelectionBoxGetChild_5;
  return_value_XmSelectionBoxGetChild_5=XmSelectionBoxGetChild(dlg, (unsigned char)13);
  XtUnmanageChild(return_value_XmSelectionBoxGetChild_5);
  XtAddCallback(dlg, (char *)&_XmStrings[(signed long int)8560], man_destroy, (void *)dlg);
  view=XmCreateScrolledWindow(dlg, "view", (struct anonymous_11 *)(void *)0, (unsigned int)0);
  XtManageChild(view);
  label=XtVaCreateManagedWidget("label", xmLabelWidgetClass, view, (void *)0);
  XtManageChild(dlg);
  sprintf(line, "man %s 2>/dev/null", page);
  fp=popen(line, "r");
  xmpage=XmStringGenerate((void *)"", (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
  char *return_value_fgets_6;
  do
  {
    return_value_fgets_6=fgets(line, (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1), fp);
    if(return_value_fgets_6 == ((char *)NULL))
      break;

    last = 0;
    s = 0;
    d = 0;
    for( ; !((signed int)line[(signed long int)s] == 0); last = cur)
    {
      cur = 1;
      if((signed int)line[(signed long int)(1 + s)] == 8)
      {
        if(line[(signed long int)s] == line[(signed long int)(2 + s)])
          cur = 2;

      }

      if((signed int)line[(signed long int)s] == 95)
      {
        if((signed int)line[(signed long int)(1 + s)] == 8)
          cur = 3;

      }

      if(!(cur == last) && !(last == 0))
      {
        xmchunk=XmStringGenerate((void *)chunk, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, man_tags[(signed long int)last]);
        xmpage=XmStringConcatAndFree(xmpage, xmchunk);
        d = 0;
      }

      switch(cur)
      {
        case 2:

        case 3:
          s = s + 2;
        case 1:
        {
          signed int tmp_post_7 = d;
          d = d + 1;
          signed int tmp_post_8 = s;
          s = s + 1;
          chunk[(signed long int)tmp_post_7] = line[(signed long int)tmp_post_8];
        }
      }
      chunk[(signed long int)d] = (char)0;
    }
    xmchunk=XmStringGenerate((void *)chunk, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, man_tags[(signed long int)last]);
    xmpage=XmStringConcatAndFree(xmpage, xmchunk);
  }
  while((_Bool)1);
  XtVaSetValues(label, (char *)&_XmStrings[(signed long int)7535], xmpage, (void *)0);
  XmStringFree(xmpage);
  fclose(fp);
}

// man_action
// file x11/man.h line 3
void man_action(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  if(*num_params >= 1u)
    man(params[(signed long int)0]);

}

// man_cb
// file x11/man.h line 2
void man_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  char *page = (char *)clientdata;
  man(page);
}

// man_destroy
// file x11/man.c line 39
static void man_destroy(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  XtDestroyWidget((struct _WidgetRec *)clientdata);
}

// media_device_type
// file common/get_media_devices.c line 364
const char * media_device_type(enum device_type type)
{
  switch((signed int)type)
  {
    case MEDIA_V4L_VIDEO:
      return "video";
    case MEDIA_V4L_VBI:
      return "vbi";
    case MEDIA_V4L_RADIO:
      return "radio";
    case MEDIA_V4L_SUBDEV:
      return "v4l subdevice";
    case MEDIA_DVB_VIDEO:
      return "dvb video";
    case MEDIA_DVB_AUDIO:
      return "dvb audio";
    case MEDIA_DVB_SEC:
      return "dvb sec";
    case MEDIA_DVB_FRONTEND:
      return "dvb frontend";
    case MEDIA_DVB_DEMUX:
      return "dvb demux";
    case MEDIA_DVB_DVR:
      return "dvb dvr";
    case MEDIA_DVB_NET:
      return "dvb net";
    case MEDIA_DVB_CA:
      return "dvb conditional access";
    case MEDIA_DVB_OSD:
      return "dvb OSD";
    case MEDIA_SND_CARD:
      return "sound card";
    case MEDIA_SND_CAP:
      return "pcm capture";
    case MEDIA_SND_OUT:
      return "pcm output";
    case MEDIA_SND_CONTROL:
      return "mixer";
    case MEDIA_SND_HW:
      return "sound hardware";
    case MEDIA_SND_TIMER:
      return "sound timer";
    case MEDIA_SND_SEQ:
      return "sound sequencer";
    default:
      return "unknown";
  }
}

// menu_cols_cb
// file x11/motv.c line 1085
static void menu_cols_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  unsigned short int height;
  unsigned short int num;
  signed int i = 8;
  for( ; !(i == 0); i = i - 1)
  {
    XtVaGetValues(widget, (char *)&XtStrings[(signed long int)234], &height, (char *)&_XmStrings[(signed long int)8450], &num, (void *)0);
    struct anonymous_0 *return_value_XtScreen_1;
    return_value_XtScreen_1=XtScreen(widget);
    if(!((signed int)height >= return_value_XtScreen_1->height + -100))
      break;

    XtVaSetValues(widget, (char *)&_XmStrings[(signed long int)8450], (signed int)num + 1, (void *)0);
  }
}

// midi_close
// file common/midictrl.c line 182
signed int midi_close(struct midi_handle *h)
{
  if(!(debug == 0))
    fprintf(stderr, "midi: close\n");

  if(!(h->ev == ((struct snd_seq_event *)NULL)))
  {
    snd_seq_free_event(h->ev);
    h->ev = (struct snd_seq_event *)(void *)0;
  }

  if(!(h->seq == ((struct _snd_seq *)NULL)))
  {
    snd_seq_close(h->seq);
    h->seq = (struct _snd_seq *)(void *)0;
  }

  return 0;
}

// midi_connect
// file ./common/midictrl.h line 18
signed int midi_connect(struct midi_handle *h, char *arg)
{
  signed int client;
  signed int port;
  signed int rc;
  struct _snd_seq_port_subscribe *psubs;
  struct snd_seq_addr addr;
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(arg, "%d:%d", &client, &port);
  if(!(return_value_sscanf_1 == 2))
    return -1;

  else
  {
    snd_seq_port_subscribe_malloc(&psubs);
    addr.client = (unsigned char)client;
    addr.port = (unsigned char)port;
    snd_seq_port_subscribe_set_sender(psubs, &addr);
    signed int return_value_snd_seq_client_id_2;
    return_value_snd_seq_client_id_2=snd_seq_client_id(h->seq);
    addr.client = (unsigned char)return_value_snd_seq_client_id_2;
    addr.port = (unsigned char)h->port;
    snd_seq_port_subscribe_set_dest(psubs, &addr);
    rc=snd_seq_subscribe_port(h->seq, psubs);
    if(!(rc >= 0))
    {
      const char *return_value_snd_strerror_3;
      return_value_snd_strerror_3=snd_strerror(rc);
      fprintf(stderr, "midi: snd_seq_subscribe_port: %s\n", return_value_snd_strerror_3);
    }

    else
      if(!(debug == 0))
        fprintf(stderr, "midi: subscribe ok [%d:%d]\n", client, port);

    snd_seq_port_subscribe_free(psubs);
    return rc;
  }
}

// midi_dump_ev
// file common/midictrl.c line 68
static void midi_dump_ev(struct _IO_FILE *out, struct snd_seq_event *ev)
{
  fprintf(out, "midi ev:");
  if(!((0 & (signed int)ev->flags) == 0))
    fprintf(out, " tick %d", ev->time.tick);

  if(!((1 & (signed int)ev->flags) == 0))
    fprintf(out, " real %d:%06d", ev->time.time.tv_sec, ev->time.time.tv_nsec);

  if(!((0 & (signed int)ev->flags) == 0))
    fprintf(out, " abs");

  if(!((2 & (signed int)ev->flags) == 0))
    fprintf(out, " rel");

  char *tmp_if_expr_1;
  if(!((unsigned long int)ev->type >= 152ul))
    tmp_if_expr_1 = midi_events[(signed long int)ev->type];

  else
    tmp_if_expr_1 = "UNKNOWN";
  fprintf(out, " [%d:%d] %s", ev->source.client, ev->source.port, tmp_if_expr_1);
  switch((signed int)ev->type)
  {
    case 5:
    {
      fprintf(out, " ch=%d note=%d vel=%d off_vel=%d dur=%d", ev->data.note.channel, ev->data.note.note, ev->data.note.velocity, ev->data.note.off_velocity, ev->data.note.duration);
      goto __CPROVER_DUMP_L12;
    }
    case 6:

    case 7:

    case 8:
    {
      fprintf(out, " ch=%d note=%d vel=%d", ev->data.note.channel, ev->data.note.note, ev->data.note.velocity);
      goto __CPROVER_DUMP_L12;
    }
    case 10:

    case 11:

    case 14:

    case 15:

    case 16:
    {
      fprintf(out, " ch=%d par=%d val=%d", ev->data.control.channel, ev->data.control.param, ev->data.control.value);
      goto __CPROVER_DUMP_L12;
    }
    case 12:

    case 13:
    {
      fprintf(out, " ch=%d val=%d", ev->data.control.channel, ev->data.control.value);
      goto __CPROVER_DUMP_L12;
    }
    case 20:

    case 21:

    case 22:

    case 23:

    case 24:
      fprintf(out, " val=%d", ev->data.control.value);
    default:
    {

    __CPROVER_DUMP_L12:
      ;
      fprintf(out, "\n");
    }
  }
}

// midi_open
// file ./common/midictrl.h line 16
signed int midi_open(struct midi_handle *h, char *name)
{
  char *func;
  signed int rc;
  func = "snd_seq_open";
  rc=snd_seq_open(&h->seq, "default", 2, 0x0001);
  signed int return_value_snd_seq_client_id_1;
  if(rc >= 0)
  {
    func = "snd_seq_set_client_name";
    rc=snd_seq_set_client_name(h->seq, name);
    if(!(rc >= 0))
      goto err;

    func = "snd_seq_create_simple_port";
    rc=snd_seq_create_simple_port(h->seq, "name", (unsigned int)(1 << 1 | 1 << 6), (unsigned int)(1 << 20));
    if(!(rc >= 0))
      goto err;

    h->port = rc;
    if(!(debug == 0))
    {
      return_value_snd_seq_client_id_1=snd_seq_client_id(h->seq);
      fprintf(stderr, "midi: open ok [%d:%d]\n", return_value_snd_seq_client_id_1, h->port);
    }

    struct pollfd p;
    snd_seq_poll_descriptors(h->seq, &p, (unsigned int)1, (signed short int)0x001);
    h->fd = p.fd;
    return h->fd;
  }

  else
  {

  err:
    ;
    const char *return_value_snd_strerror_2;
    return_value_snd_strerror_2=snd_strerror(rc);
    fprintf(stderr, "midi: %s: %s\n", func, return_value_snd_strerror_2);
    if(!(h->seq == ((struct _snd_seq *)NULL)))
    {
      snd_seq_close(h->seq);
      h->seq = (struct _snd_seq *)(void *)0;
    }

    return -1;
  }
}

// midi_read
// file ./common/midictrl.h line 19
signed int midi_read(struct midi_handle *h)
{
  signed int rc;
  if(!(h->ev == ((struct snd_seq_event *)NULL)))
  {
    snd_seq_free_event(h->ev);
    h->ev = (struct snd_seq_event *)(void *)0;
  }

  rc=snd_seq_event_input(h->seq, &h->ev);
  if(!(rc >= 0))
  {
    const char *return_value_snd_strerror_1;
    return_value_snd_strerror_1=snd_strerror(rc);
    fprintf(stderr, "midi: snd_seq_event_input: %s\n", return_value_snd_strerror_1);
    return -1;
  }

  if(debug >= 2)
    midi_dump_ev(stderr, h->ev);

  return 0;
}

// midi_translate
// file ./common/midictrl.h line 21
void midi_translate(struct midi_handle *h)
{
  char event[64l];
  signed int i;
  switch((signed int)h->ev->type)
  {
    case 6:
    {
      if((signed int)h->ev->data.note.velocity == 0)
        goto __CPROVER_DUMP_L8;

      i = 0;
      for( ; !(i >= count); i = i + 1)
        if(!(channels[(signed long int)i]->midi == 0))
        {
          if(channels[(signed long int)i]->midi == (signed int)h->ev->data.note.note)
          {
            do_va_cmd(2, (const void *)"setstation", channels[(signed long int)i]->name);
            goto __CPROVER_DUMP_L8;
          }

        }

      sprintf(event, "midi-note-%d", h->ev->data.note.note);
      event_dispatch(event);
      break;
    }
    case 10:
    {
      sprintf(event, "midi-ctrl-%d(%d%%)", h->ev->data.control.param, (h->ev->data.control.value * 100) / 128);
      event_dispatch(event);
    }
  }

__CPROVER_DUMP_L8:
  ;
}

// mouse_event
// file x11/xt.h line 192
void mouse_event(struct _WidgetRec *widget, void *client_data, union _XEvent *event, char *d)
{
  unsigned long int return_value_XtWindow_1;
  if(mouse_visible == 0)
  {
    if(debug >= 2)
      fprintf(stderr, "xt: pointer show\n");

    unsigned long int return_value_XtWindow_2;
    return_value_XtWindow_2=XtWindow(widget);
    if(!(return_value_XtWindow_2 == 0ul))
    {
      return_value_XtWindow_1=XtWindow(widget);
      XDefineCursor(dpy, return_value_XtWindow_1, left_ptr);
    }

    mouse_visible = 1;
  }

  if(!(mouse_timer == 0ul))
    XtRemoveTimeOut(mouse_timer);

  mouse_timer=XtAppAddTimeOut(app_context, (unsigned long int)1000, mouse_timeout, (void *)widget);
}

// mouse_timeout
// file x11/xt.c line 1800
static void mouse_timeout(void *clientData, unsigned long int *id)
{
  struct _WidgetRec *widget = (struct _WidgetRec *)clientData;
  if(debug >= 2)
    fprintf(stderr, "xt: pointer hide\n");

  unsigned long int return_value_XtWindow_2;
  return_value_XtWindow_2=XtWindow(widget);
  unsigned long int return_value_XtWindow_1;
  if(!(return_value_XtWindow_2 == 0ul))
  {
    return_value_XtWindow_1=XtWindow(widget);
    XDefineCursor(dpy, return_value_XtWindow_1, no_ptr);
  }

  mouse_visible = 0;
  mouse_timer = (unsigned long int)0;
}

// movie_grab_put_video
// file ./common/capture.h line 36
signed int movie_grab_put_video(struct movie_handle *h, struct ng_video_buf **ret)
{
  struct ng_video_buf *buf;
  signed int expected;
  signed int rc;
  if(debug >= 2)
    fprintf(stderr, "grab_put_video\n");

  buf=ng_grabber_grab_image(0);
  if(buf == ((struct ng_video_buf *)NULL))
  {
    if(!(debug == 0))
      fprintf(stderr, "grab_put_video: grab image failed\n");

    return -1;
  }

  else
  {
    expected = (signed int)((((unsigned long int)buf->info.ts - h->vdrift) * (unsigned long int)h->fps) / (unsigned long int)1000000000000ULL);
    if(!(expected >= h->frames + -1))
    {
      if(debug >= 2)
        fprintf(stderr, "rate: ignoring frame [%d %d]\n", expected, h->frames);

      ng_release_video_buf(buf);
      return 0;
    }

    else
    {
      if(!(1 + h->frames >= expected))
      {
        fprintf(stderr, "rate: queueing frame twice (%d)\n", expected - h->frames);
        buf->info.twice = buf->info.twice + 1;
        h->frames = h->frames + 1;
      }

      h->frames = h->frames + 1;
      h->vts = (unsigned long int)buf->info.ts;
      buf->info.seq = h->seq;
      if(!(ret == ((struct ng_video_buf **)NULL)))
      {
        buf->refcount = buf->refcount + 1;
        *ret = buf;
      }

      if(!(h->cthreads == 0))
        rc=fifo_put(&h->cfifo, (void *)buf);

      else
        rc=fifo_put(&h->vfifo, (void *)buf);
      if(!(rc == 0))
      {
        ng_release_video_buf(buf);
        return h->frames;
      }

      else
      {
        h->seq = h->seq + 1;
        movie_print_timestamps(h);
        return h->frames;
      }
    }
  }
}

// movie_handler
// file common/commands.c line 1149
static signed int movie_handler(char *name, signed int argc, char **argv)
{
  if(movie_hook == ((void (*)(signed int, char **))NULL))
    return 0;

  else
  {
    movie_hook(argc, argv);
    return 0;
  }
}

// movie_print_timestamps
// file common/capture.c line 583
static void movie_print_timestamps(struct movie_handle *h)
{
  char line[128l];
  if(!(rec_status == ((void (*)(char *))NULL)))
  {
    signed int return_value_abs_1;
    return_value_abs_1=abs((signed int)h->rdrift);
    signed int return_value_abs_2;
    return_value_abs_2=abs((signed int)h->rdrift);
    signed int return_value_abs_3;
    return_value_abs_3=abs((signed int)h->vdrift);
    signed int return_value_abs_4;
    return_value_abs_4=abs((signed int)h->vdrift);
    sprintf(line, "rec %d:%02d.%02d  -  a/r: %c%d.%02ds [%d], a/v: %c%d.%02ds [%d]", (signed int)((h->rts / (unsigned long int)1000000000) / (unsigned long int)60), (signed int)((h->rts / (unsigned long int)1000000000) % (unsigned long int)60), (signed int)((h->rts % (unsigned long int)1000000000) / (unsigned long int)10000000), h->rdrift > (unsigned long int)0 ? 43 : 45, (signed int)(return_value_abs_1 / 1000000000), (signed int)((return_value_abs_2 % 1000000000) / 10000000), (signed int)((h->rdrift * (unsigned long int)h->fps) / (unsigned long int)1000000000000ULL), h->vdrift > (unsigned long int)0 ? 43 : 45, (signed int)(return_value_abs_3 / 1000000000), (signed int)((return_value_abs_4 % 1000000000) / 10000000), (signed int)((h->vdrift * (unsigned long int)h->fps) / (unsigned long int)1000000000000ULL));
    rec_status(line);
  }

}

// movie_writer_init
// file ./common/capture.h line 28
struct movie_handle * movie_writer_init(char *moviename, char *audioname, struct ng_writer *writer, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio, char *dsp, signed int slots, signed int threads)
{
  struct movie_handle *h;
  struct ng_video_conv *conv;
  void *dummy;
  signed int i;
  if(!(debug == 0))
    fprintf(stderr, "movie_init_writer start\n");

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct movie_handle) /*2184ul*/ );
  h = (struct movie_handle *)return_value_malloc_1;
  if(h == ((struct movie_handle *)NULL))
    return (struct movie_handle *)(void *)0;

  else
  {
    memset((void *)h, 0, sizeof(struct movie_handle) /*2184ul*/ );
    pthread_mutex_init(&h->lock, (const union anonymous_121 *)(void *)0);
    h->writer = writer;
    h->slots = slots;
    if(!(audio->fmtid == 0u))
    {
      h->dsp=ng_dsp_open(dsp, audio, 1, &h->hdsp);
      if(h->dsp == ((struct ng_dsp_driver *)NULL))
      {
        free((void *)h);
        return (struct movie_handle *)(void *)0;
      }

      fifo_init(&h->afifo, "audio", slots, 1);
      pthread_create(&h->taudio, (const union pthread_attr_t *)(void *)0, writer_audio_thread, (void *)h);
      h->bytes_per_sec = (unsigned long int)((ng_afmt_to_bits[(signed long int)audio->fmtid] * ng_afmt_to_channels[(signed long int)audio->fmtid] * audio->rate) / (unsigned int)8);
      h->afmt = *audio;
    }

    if(!(video->fmtid == 0u))
    {
      signed int return_value_ng_grabber_setformat_3;
      return_value_ng_grabber_setformat_3=ng_grabber_setformat(video, 1);
      if(return_value_ng_grabber_setformat_3 == 0)
      {
        fifo_init(&h->vfifo, "video", slots, 1);
        pthread_create(&h->tvideo, (const union pthread_attr_t *)(void *)0, writer_video_thread, (void *)h);
      }

      else
      {
        struct ng_video_fmt gfmt = *video;
        conv=ng_grabber_findconv(&gfmt, 1);
        if(conv == ((struct ng_video_conv *)NULL))
        {
          if(!(h->afmt.fmtid == 0u))
            h->dsp->close(h->hdsp);

          free((void *)h);
          return (struct movie_handle *)(void *)0;
        }

        h->cthreads = threads;
        if(!(h->cthreads >= 1))
          h->cthreads = 1;

        if(h->cthreads >= 5)
          h->cthreads = 4;

        fifo_init(&h->vfifo, "video", slots, h->cthreads);
        fifo_init(&h->cfifo, "conv", slots, 1);
        pthread_create(&h->tvideo, (const union pthread_attr_t *)(void *)0, writer_video_thread, (void *)h);
        i = 0;
        for( ; !(i >= h->cthreads); i = i + 1)
        {
          void *return_value_malloc_2;
          return_value_malloc_2=malloc(sizeof(struct ng_convthread_handle) /*24ul*/ );
          h->hconv[(signed long int)i] = (struct ng_convthread_handle *)return_value_malloc_2;
          memset((void *)h->hconv[(signed long int)i], 0, sizeof(struct ng_convthread_handle) /*24ul*/ );
          h->hconv[(signed long int)i]->c=ng_convert_alloc(conv, &gfmt, video);
          h->hconv[(signed long int)i]->in = &h->cfifo;
          h->hconv[(signed long int)i]->out = &h->vfifo;
          pthread_create(&h->tconv[(signed long int)i], (const union pthread_attr_t *)(void *)0, ng_convert_thread, (void *)h->hconv[(signed long int)i]);
        }
      }
      h->vfmt = *video;
      h->fps = fps;
    }

    h->handle=writer->wr_open(moviename, audioname, video, priv_video, fps, audio, priv_audio);
    if(!(debug == 0))
      fprintf(stderr, "movie_init_writer end (h=%p)\n", h->handle);

    if(!(h->handle == NULL))
      return h;

    else
    {
      if(!(h->afmt.fmtid == 0u))
      {
        pthread_cancel(h->taudio);
        pthread_join(h->taudio, &dummy);
        h->dsp->close(h->hdsp);
      }

      if(!(h->vfmt.fmtid == 0u))
      {
        pthread_cancel(h->tvideo);
        pthread_join(h->tvideo, &dummy);
      }

      i = 0;
      if(!(i >= h->cthreads))
      {
        pthread_cancel(h->tconv[(signed long int)i]);
        pthread_join(h->tconv[(signed long int)i], &dummy);
        i = i + 1;
      }

      free((void *)h);
      return (struct movie_handle *)(void *)0;
    }
  }
}

// movie_writer_start
// file ./common/capture.h line 33
signed int movie_writer_start(struct movie_handle *h)
{
  signed int rc = 0;
  if(!(debug == 0))
    fprintf(stderr, "movie_writer_start\n");

  signed long int return_value_ng_get_timestamp_1;
  return_value_ng_get_timestamp_1=ng_get_timestamp();
  h->start = (unsigned long int)return_value_ng_get_timestamp_1;
  signed int return_value;
  if(!(h->afmt.fmtid == 0u))
  {
    return_value=h->dsp->startrec(h->hdsp);
    if(!(return_value == 0))
      rc = -1;

  }

  signed int return_value_1;
  if(!(h->vfmt.fmtid == 0u))
  {
    return_value_1=drv->startvideo(h_drv, h->fps, (unsigned int)h->slots);
    if(!(return_value_1 == 0))
      rc = -1;

  }

  if(!(h->afmt.fmtid == 0u))
    pthread_create(&h->raudio, (const union pthread_attr_t *)(void *)0, record_audio_thread, (void *)h);

  pthread_create(&h->tflush, (const union pthread_attr_t *)(void *)0, flushit, (void *)0);
  return rc;
}

// movie_writer_stop
// file ./common/capture.h line 34
signed int movie_writer_stop(struct movie_handle *h)
{
  char line[128l];
  unsigned long int stopby;
  signed int frames;
  signed int i;
  void *dummy;
  if(!(debug == 0))
    fprintf(stderr, "movie_writer_stop\n");

  _Bool tmp_if_expr_1;
  if(!(h->vfmt.fmtid == 0u))
    tmp_if_expr_1 = h->afmt.fmtid != (unsigned int)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    frames = 0;
    for( ; !(frames >= 16); frames = frames + 1)
    {
      stopby = ((unsigned long int)(h->frames + frames) * (unsigned long int)1000000000000ULL) / (unsigned long int)h->fps;
      if(!(h->ats >= stopby))
        break;

    }
    frames = frames + 1;
    h->stopby = ((unsigned long int)(h->frames + frames) * (unsigned long int)1000000000000ULL) / (unsigned long int)h->fps;
    for( ; !(frames == 0); frames = frames - 1)
      movie_grab_put_video(h, (struct ng_video_buf **)(void *)0);
  }

  else
    if(!(h->afmt.fmtid == 0u))
      h->stopby = h->ats;

  if(!(h->cthreads == 0))
    fifo_put(&h->cfifo, (void *)0);

  else
    fifo_put(&h->vfifo, (void *)0);
  if(!(h->afmt.fmtid == 0u))
  {
    pthread_join(h->raudio, &dummy);
    pthread_join(h->taudio, &dummy);
  }

  if(!(h->vfmt.fmtid == 0u))
    pthread_join(h->tvideo, &dummy);

  i = 0;
  for( ; !(i >= h->cthreads); i = i + 1)
    pthread_join(h->tconv[(signed long int)i], &dummy);
  pthread_cancel(h->tflush);
  pthread_join(h->tflush, &dummy);
  h->writer->wr_close(h->handle);
  if(!(h->afmt.fmtid == 0u))
    h->dsp->close(h->hdsp);

  if(!(h->vfmt.fmtid == 0u))
    drv->stopvideo(h_drv);

  sprintf(line, "fifo max fill: audio %d/%d, video %d/%d, convert %d/%d", h->afifo.max, h->afifo.slots, h->vfifo.max, h->vfifo.slots, h->cfifo.max, h->cfifo.slots);
  rec_status(line);
  free((void *)h);
  return 0;
}

// msg_handler
// file common/commands.c line 1166
static signed int msg_handler(char *name, signed int argc, char **argv)
{
  if(!(display_message == ((void (*)(char *))NULL)))
    display_message(argv[(signed long int)0]);

  return 0;
}

// my_cmp
// file x11/complete.c line 34
static signed int my_cmp(const void *a, const void *b)
{
  char *aa;
  char *bb;
  aa = *((char **)a);
  bb = *((char **)b);
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(aa, bb);
  return return_value_strcmp_1;
}

// my_scandir
// file x11/complete.c line 44
static signed int my_scandir(char *dir, char *match, char ***namelist)
{
  struct __dirstream *d;
  struct dirent *e;
  signed int n = 0;
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(match);
  len = (signed int)return_value_strlen_1;
  *namelist = (char **)(void *)0;
  d=opendir(dir);
  void *return_value_malloc_3;
  void *return_value_realloc_4;
  if(d == ((struct __dirstream *)NULL))
    return 0;

  else
  {
    do
    {
      e=readdir(d);
      if(e == ((struct dirent *)NULL))
        break;

      signed int return_value_strncmp_2;
      return_value_strncmp_2=strncmp(e->d_name, match, (unsigned long int)len);
      if(return_value_strncmp_2 == 0)
      {
        if(n % 16 == 0)
        {
          if(n == 0)
          {
            return_value_malloc_3=malloc((unsigned long int)16 * sizeof(char *) /*8ul*/ );
            *namelist = (char **)return_value_malloc_3;
          }

          else
          {
            return_value_realloc_4=realloc((void *)*namelist, (unsigned long int)(n + 16) * sizeof(char *) /*8ul*/ );
            *namelist = (char **)return_value_realloc_4;
          }
        }

        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(e->d_name);
        void *return_value_malloc_6;
        return_value_malloc_6=malloc(return_value_strlen_5 + (unsigned long int)1);
        (*namelist)[(signed long int)n] = (char *)return_value_malloc_6;
        strcpy((*namelist)[(signed long int)n], e->d_name);
        n = n + 1;
      }

    }
    while((_Bool)1);
    closedir(d);
    qsort((void *)*namelist, (unsigned long int)n, sizeof(char *) /*8ul*/ , my_cmp);
    return n;
  }
}

// netwm_fullscreen
// file x11/wmhooks.c line 62
static void netwm_fullscreen(struct _XDisplay *dpy, unsigned long int win, signed int state)
{
  signed int op = state != 0 ? 1 : 0;
  netwm_set_state(dpy, win, op, _NET_WM_STATE_FULLSCREEN);
}

// netwm_old_stay_on_top
// file x11/wmhooks.c line 55
static void netwm_old_stay_on_top(struct _XDisplay *dpy, unsigned long int win, signed int state)
{
  signed int op = state != 0 ? 1 : 0;
  netwm_set_state(dpy, win, op, _NET_WM_STATE_STAYS_ON_TOP);
}

// netwm_set_state
// file x11/wmhooks.c line 30
static void netwm_set_state(struct _XDisplay *dpy, unsigned long int win, signed int operation, unsigned long int state)
{
  union _XEvent e;
  memset((void *)&e, 0, sizeof(union _XEvent) /*192ul*/ );
  e.xclient.type = 33;
  e.xclient.message_type = _NET_WM_STATE;
  e.xclient.display = dpy;
  e.xclient.window = win;
  e.xclient.format = 32;
  e.xclient.data.l[(signed long int)0] = (signed long int)operation;
  e.xclient.data.l[(signed long int)1] = (signed long int)state;
  XSendEvent(dpy, (&((struct anonymous_10 *)dpy)->screens[(signed long int)((struct anonymous_10 *)dpy)->default_screen])->root, 0, 1L << 20, &e);
}

// netwm_stay_on_top
// file x11/wmhooks.c line 48
static void netwm_stay_on_top(struct _XDisplay *dpy, unsigned long int win, signed int state)
{
  signed int op = state != 0 ? 1 : 0;
  netwm_set_state(dpy, win, op, _NET_WM_STATE_ABOVE);
}

// new_attr
// file x11/motv.c line 578
static void new_attr(struct ng_attribute *attr, signed int val)
{
  struct motif_attribute *a;
  struct _WidgetRec **children;
  unsigned int nchildren;
  unsigned int i;
  a = motif_attrs;
  for( ; !(a == ((struct motif_attribute *)NULL)); a = a->next)
    if(a->attr->id == attr->id)
      break;

  if(!(a == ((struct motif_attribute *)NULL)))
  {
    switch(attr->type)
    {
      case 2:
      {
        XtVaGetValues(a->widget, (char *)&XtStrings[(signed long int)145], &children, (char *)&XtStrings[(signed long int)493], &nchildren, (void *)0);
        i = (unsigned int)0;
        for( ; !(i >= nchildren); i = i + 1u)
          XmToggleButtonSetState(children[(signed long int)i], (char)((a->attr->choices + (signed long int)i)->nr == (signed long int)val), (char)0);
        break;
      }
      case 3:
      {
        XmToggleButtonSetState(a->widget, (char)val, (char)0);
        break;
      }
      case 1:
        XmScaleSetValue(a->widget, val);
    }
    goto __CPROVER_DUMP_L10;
  }


__CPROVER_DUMP_L10:
  ;
}

// new_channel
// file x11/motv.c line 250
static void new_channel(void)
{
  char line[1024l];
  char *tmp_if_expr_2;
  struct CHANLIST *tmp_if_expr_1;
  if(cur_channel == -1)
    tmp_if_expr_2 = (char *)(void *)0;

  else
  {
    if(!(chantab == -1))
      tmp_if_expr_1 = (chanlists + (signed long int)chantab)->list;

    else
      tmp_if_expr_1 = (struct CHANLIST *)(void *)0;
    tmp_if_expr_2 = (tmp_if_expr_1 + (signed long int)cur_channel)->name;
  }
  char *tmp_if_expr_3;
  if(cur_sender == -1)
    tmp_if_expr_3 = (char *)(void *)0;

  else
    tmp_if_expr_3 = channels[(signed long int)cur_sender]->name;
  set_property(cur_freq, tmp_if_expr_2, tmp_if_expr_3);
  sprintf(line, "%d.%02d MHz", cur_freq / 16, ((cur_freq % 16) * 100) / 16);
  toolkit_set_label(st_freq, line);
  char *tmp_if_expr_5;
  struct CHANLIST *tmp_if_expr_4;
  if(!(cur_channel == -1))
  {
    if(!(chantab == -1))
      tmp_if_expr_4 = (chanlists + (signed long int)chantab)->list;

    else
      tmp_if_expr_4 = (struct CHANLIST *)(void *)0;
    tmp_if_expr_5 = (tmp_if_expr_4 + (signed long int)cur_channel)->name;
  }

  else
    tmp_if_expr_5 = "";
  toolkit_set_label(st_chan, tmp_if_expr_5);
  char *tmp_if_expr_6;
  if(!(cur_sender == -1))
    tmp_if_expr_6 = channels[(signed long int)cur_sender]->name;

  else
    tmp_if_expr_6 = "";
  toolkit_set_label(st_name, tmp_if_expr_6);
  _Bool tmp_if_expr_7;
  if(!(cur_sender == -1))
    tmp_if_expr_7 = (char *)(void *)0 != channels[(signed long int)cur_sender]->key ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_7 = (_Bool)0;
  char *tmp_if_expr_8;
  if(tmp_if_expr_7)
    tmp_if_expr_8 = channels[(signed long int)cur_sender]->key;

  else
    tmp_if_expr_8 = "";
  toolkit_set_label(st_key, tmp_if_expr_8);
  if(!(zap_timer == 0ul))
  {
    XtRemoveTimeOut(zap_timer);
    zap_timer = (unsigned long int)0;
  }

  if(!(scan_timer == 0ul))
  {
    XtRemoveTimeOut(scan_timer);
    scan_timer = (unsigned long int)0;
  }

  if(!(audio_timer == 0ul))
  {
    XtRemoveTimeOut(audio_timer);
    audio_timer = (unsigned long int)0;
  }

  audio_timer=XtAppAddTimeOut(app_context, (unsigned long int)5000, watch_audio, (void *)0);
}

// new_freqtab
// file x11/motv.c line 625
static void new_freqtab(void)
{
  struct _WidgetRec **children;
  unsigned int nchildren;
  union __XmStringRec **tab;
  signed int i;
  XtVaGetValues(freq_menu, (char *)&XtStrings[(signed long int)145], &children, (char *)&XtStrings[(signed long int)493], &nchildren, (void *)0);
  i = 0;
  for( ; !((chanlist_names + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
    XmToggleButtonSetState(children[(signed long int)i], (char)((chanlist_names + (signed long int)i)->nr == (signed long int)chantab), (char)0);
  signed int tmp_if_expr_1;
  if(!(chantab == -1))
    tmp_if_expr_1 = (chanlists + (signed long int)chantab)->count;

  else
    tmp_if_expr_1 = 0;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)tmp_if_expr_1 * sizeof(union __XmStringRec *) /*8ul*/ );
  tab = (union __XmStringRec **)return_value_malloc_2;
  i = 0;
  signed int tmp_if_expr_3;
  do
  {
    if(!(chantab == -1))
      tmp_if_expr_3 = (chanlists + (signed long int)chantab)->count;

    else
      tmp_if_expr_3 = 0;
    if(i >= tmp_if_expr_3)
      break;

    struct CHANLIST *tmp_if_expr_4;
    if(!(chantab == -1))
      tmp_if_expr_4 = (chanlists + (signed long int)chantab)->list;

    else
      tmp_if_expr_4 = (struct CHANLIST *)(void *)0;
    tab[(signed long int)i]=XmStringGenerate((void *)(tmp_if_expr_4 + (signed long int)i)->name, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
    i = i + 1;
  }
  while((_Bool)1);
  signed int tmp_if_expr_5;
  if(!(chantab == -1))
    tmp_if_expr_5 = (chanlists + (signed long int)chantab)->count;

  else
    tmp_if_expr_5 = 0;
  XtVaSetValues(prop_channel, (char *)&_XmStrings[(signed long int)7450], tmp_if_expr_5, (char *)&_XmStrings[(signed long int)7460], tab, (char *)&_XmStrings[(signed long int)12735], tab[(signed long int)0], (void *)0);
  i = 0;
  signed int tmp_if_expr_6;
  do
  {
    if(!(chantab == -1))
      tmp_if_expr_6 = (chanlists + (signed long int)chantab)->count;

    else
      tmp_if_expr_6 = 0;
    if(i >= tmp_if_expr_6)
      break;

    XmStringFree(tab[(signed long int)i]);
    i = i + 1;
  }
  while((_Bool)1);
  free((void *)tab);
}

// new_message
// file x11/xt.h line 155
void new_message(char *txt)
{
  XtVaSetValues(app_shell, (char *)&XtShellStrings[(signed long int)356], txt, (void *)0);
  display_onscreen(txt);
  if(!(title_timer == 0ul))
    XtRemoveTimeOut(title_timer);

  title_timer=XtAppAddTimeOut(app_context, (unsigned long int)6000, title_timeout, (void *)0);
}

// new_title
// file x11/xt.h line 154
void new_title(char *txt)
{
  strcpy(default_title, txt);
  XtVaSetValues(app_shell, (char *)&XtShellStrings[(signed long int)356], (const void *)default_title, (char *)&XtShellStrings[(signed long int)0], (const void *)default_title, (void *)0);
  display_onscreen(default_title);
  if(!(title_timer == 0ul))
  {
    XtRemoveTimeOut(title_timer);
    title_timer = (unsigned long int)0;
  }

}

// new_volume
// file x11/motv.c line 612
static void new_volume(void)
{
  struct ng_attribute *attr;
  attr=ng_attr_byid(attrs, 3);
  if(!(attr == ((struct ng_attribute *)NULL)))
    new_attr(attr, cur_attrs[(signed long int)3]);

  attr=ng_attr_byid(attrs, 4);
  if(!(attr == ((struct ng_attribute *)NULL)))
    new_attr(attr, cur_attrs[(signed long int)4]);

}

// ng_aconv_register
// file libng/grab-ng.c line 409
signed int ng_aconv_register(signed int magic, char *plugname, struct ng_audio_conv *list, signed int count)
{
  signed int n;
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "audio converters");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    n = 0;
    for( ; !(n >= count); n = n + 1)
      list_add_tail_link1(&(list + (signed long int)n)->list, &ng_aconv);
    return 0;
  }
}

// ng_attr_byid
// file ./libng/grab-ng.h line 257
struct ng_attribute * ng_attr_byid(struct ng_attribute *attrs, signed int id)
{
  if(attrs == ((struct ng_attribute *)NULL))
    return (struct ng_attribute *)(void *)0;

  else
    for( ; (_Bool)1; attrs = attrs + 1l)
    {
      if(attrs->name == ((const char *)NULL))
        return (struct ng_attribute *)(void *)0;

      if(attrs->id == id)
        return attrs;

    }
}

// ng_attr_byname
// file ./libng/grab-ng.h line 258
struct ng_attribute * ng_attr_byname(struct ng_attribute *attrs, char *name)
{
  if(attrs == ((struct ng_attribute *)NULL))
    return (struct ng_attribute *)(void *)0;

  else
    while((_Bool)1)
    {
      if(attrs->name == ((const char *)NULL))
        return (struct ng_attribute *)(void *)0;

      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(attrs->name, name);
      if(return_value_strcasecmp_1 == 0)
        return attrs;

      attrs = attrs + 1l;
    }
}

// ng_attr_getint
// file ./libng/grab-ng.h line 260
signed int ng_attr_getint(struct ng_attribute *attr, char *value)
{
  signed int i;
  signed int val;
  if(attr == ((struct ng_attribute *)NULL))
    return -1;

  else
    if(!(attr->type == 2))
      return -1;

    else
    {
      i = 0;
      for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
      {
        signed int return_value_strcasecmp_1;
        return_value_strcasecmp_1=strcasecmp((attr->choices + (signed long int)i)->str, value);
        if(return_value_strcasecmp_1 == 0)
          return (signed int)(attr->choices + (signed long int)i)->nr;

      }
      const unsigned short int **return_value___ctype_b_loc_2;
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*value]) == 0))
      {
        val=atoi(value);
        i = 0;
        for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
          if((signed long int)val == (attr->choices + (signed long int)i)->nr)
            return (signed int)(attr->choices + (signed long int)i)->nr;

      }

      return -1;
    }
}

// ng_attr_getstr
// file ./libng/grab-ng.h line 259
const char * ng_attr_getstr(struct ng_attribute *attr, signed int value)
{
  signed int i;
  if(attr == ((struct ng_attribute *)NULL))
    return (const char *)(void *)0;

  else
    if(!(attr->type == 2))
      return (const char *)(void *)0;

    else
    {
      i = 0;
      for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
        if((attr->choices + (signed long int)i)->nr == (signed long int)value)
          return (attr->choices + (signed long int)i)->str;

      return (const char *)(void *)0;
    }
}

// ng_attr_int2percent
// file ./libng/grab-ng.h line 262
signed int ng_attr_int2percent(struct ng_attribute *attr, signed int value)
{
  signed int range;
  signed int percent;
  range = attr->max - attr->min;
  percent = ((value - attr->min) * 100) / range;
  if(!(percent >= 0))
    percent = 0;

  if(percent >= 101)
    percent = 100;

  return percent;
}

// ng_attr_listchoices
// file ./libng/grab-ng.h line 261
void ng_attr_listchoices(struct ng_attribute *attr)
{
  signed int i;
  fprintf(stderr, "valid choices for \"%s\": ", attr->name);
  i = 0;
  for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
    fprintf(stderr, "%s\"%s\"", i != 0 ? ", " : "", (attr->choices + (signed long int)i)->str);
  fprintf(stderr, "\n");
}

// ng_attr_parse_int
// file ./libng/grab-ng.h line 264
signed int ng_attr_parse_int(struct ng_attribute *attr, char *str)
{
  signed int value;
  signed int n;
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(str, "%d%n", &value, &n);
  if(return_value_sscanf_1 == 0)
    return attr->defval;

  else
  {
    if((signed int)str[(signed long int)n] == 37)
      value=ng_attr_percent2int(attr, value);

    if(!(value >= attr->min))
      value = attr->min;

    if(!(attr->max >= value))
      value = attr->max;

    return value;
  }
}

// ng_attr_percent2int
// file libng/grab-ng.c line 297
signed int ng_attr_percent2int(struct ng_attribute *attr, signed int percent)
{
  signed int range;
  signed int value;
  range = attr->max - attr->min;
  value = (percent * range) / 100 + attr->min;
  if(!(value >= attr->min))
    value = attr->min;

  if(!(attr->max >= value))
    value = attr->max;

  return value;
}

// ng_check_clipping
// file libng/grab-ng.c line 847
void ng_check_clipping(signed int width, signed int height, signed int xadjust, signed int yadjust, struct OVERLAY_CLIP *oc, signed int *count)
{
  signed int i;
  signed int j;
  if(ng_debug >= 2)
  {
    fprintf(stderr, "clip: win=%dx%d xa=%d ya=%d\n", width, height, xadjust, yadjust);
    clip_dump("init", oc, *count);
  }

  i = 0;
  for( ; !(i >= *count); i = i + 1)
  {
    (oc + (signed long int)i)->x1 = (oc + (signed long int)i)->x1 + xadjust;
    (oc + (signed long int)i)->x2 = (oc + (signed long int)i)->x2 + xadjust;
    (oc + (signed long int)i)->y1 = (oc + (signed long int)i)->y1 + yadjust;
    (oc + (signed long int)i)->y2 = (oc + (signed long int)i)->y2 + yadjust;
  }
  if(ng_debug >= 2)
    clip_dump("fixup adjust", oc, *count);

  i = 0;
  for( ; !(i >= *count); i = i + 1)
  {
    if(!((oc + (signed long int)i)->x1 >= 0))
      (oc + (signed long int)i)->x1 = 0;

    if(!((oc + (signed long int)i)->x2 >= 0))
      (oc + (signed long int)i)->x2 = 0;

    if(!(width >= (oc + (signed long int)i)->x1))
      (oc + (signed long int)i)->x1 = width;

    if(!(width >= (oc + (signed long int)i)->x2))
      (oc + (signed long int)i)->x2 = width;

    if(!((oc + (signed long int)i)->y1 >= 0))
      (oc + (signed long int)i)->y1 = 0;

    if(!((oc + (signed long int)i)->y2 >= 0))
      (oc + (signed long int)i)->y2 = 0;

    if(!(height >= (oc + (signed long int)i)->y1))
      (oc + (signed long int)i)->y1 = height;

    if(!(height >= (oc + (signed long int)i)->y2))
      (oc + (signed long int)i)->y2 = height;

  }
  if(ng_debug >= 2)
    clip_dump("fixup range", oc, *count);

  i = 0;
  while(!(i >= *count))
  {
    _Bool tmp_if_expr_1;
    if((oc + (signed long int)i)->x1 == (oc + (signed long int)i)->x2)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (oc + (signed long int)i)->y1 == (oc + (signed long int)i)->y2 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      clip_drop(oc, i, count);

    else
      i = i + 1;
  }
  if(ng_debug >= 2)
    clip_dump("zerosize done", oc, *count);

  do
  {

  restart_merge:
    ;
    j = *count - 1;

  __CPROVER_DUMP_L23:
    ;
    if(!(j >= 0))
      goto __CPROVER_DUMP_L34;

    i = 0;

  __CPROVER_DUMP_L24:
    ;
    if(i >= *count)
      goto __CPROVER_DUMP_L33;

    if(i == j)
      break;

    if((oc + (signed long int)i)->x1 == (oc + (signed long int)j)->x1)
    {
      if((oc + (signed long int)i)->x2 == (oc + (signed long int)j)->x2)
      {
        if((oc + (signed long int)j)->y1 >= (oc + (signed long int)i)->y1)
        {
          if((oc + (signed long int)i)->y2 >= (oc + (signed long int)j)->y1)
          {
            if(ng_debug >= 2)
              fprintf(stderr, "clip: merge y %d,%d\n", i, j);

            if(!((oc + (signed long int)i)->y2 >= (oc + (signed long int)j)->y2))
              (oc + (signed long int)i)->y2 = (oc + (signed long int)j)->y2;

            clip_drop(oc, j, count);
            if(ng_debug >= 2)
              clip_dump("merge y done", oc, *count);

            goto restart_merge;
          }

        }

      }

    }

    if(!((oc + (signed long int)i)->y1 == (oc + (signed long int)j)->y1))
      break;

    if(!((oc + (signed long int)i)->y2 == (oc + (signed long int)j)->y2))
      break;

    if(!((oc + (signed long int)j)->x1 >= (oc + (signed long int)i)->x1))
      break;

    if(!((oc + (signed long int)i)->x2 >= (oc + (signed long int)j)->x1))
      break;

    if(ng_debug >= 2)
      fprintf(stderr, "clip: merge x %d,%d\n", i, j);

    if(!((oc + (signed long int)i)->x2 >= (oc + (signed long int)j)->x2))
      (oc + (signed long int)i)->x2 = (oc + (signed long int)j)->x2;

    clip_drop(oc, j, count);
    if(ng_debug >= 2)
      clip_dump("merge x done", oc, *count);

  }
  while((_Bool)1);
  i = i + 1;
  goto __CPROVER_DUMP_L24;

__CPROVER_DUMP_L33:
  ;
  j = j - 1;
  goto __CPROVER_DUMP_L23;

__CPROVER_DUMP_L34:
  ;
  if(!(ng_debug == 0))
    clip_dump("final", oc, *count);

}

// ng_check_magic
// file libng/grab-ng.c line 381
static signed int ng_check_magic(signed int magic, char *plugname, char *type)
{
  if(!(magic == 0x20030129))
  {
    fprintf(stderr, "ERROR: plugin magic mismatch [xawtv=%d,%s=%d]\n", 0x20030129, plugname, magic);
    return -1;
  }

  else
    return 0;
}

// ng_color_packed_init
// file libng/grab-ng.h line 479
void ng_color_packed_init(void)
{
  ng_conv_register(0x20030129, "built-in", conv_list, nconv);
}

// ng_color_yuv2rgb_init
// file libng/grab-ng.h line 480
void ng_color_yuv2rgb_init(void)
{
  signed int i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    ng_yuv_gray[(signed long int)i] = (unsigned int)(i * 256 >> 8);
    ng_yuv_red[(signed long int)i] = (unsigned int)(-128 * 512 + i * 512 >> 8);
    ng_yuv_blue[(signed long int)i] = (unsigned int)(-128 * 512 + i * 512 >> 8);
    ng_yuv_g1[(signed long int)i] = (unsigned int)(-(-128 * 512) / 2 + i * (-512 / 2) >> 8);
    ng_yuv_g2[(signed long int)i] = (unsigned int)(-(-128 * 512) / 6 + i * (-512 / 6) >> 8);
  }
  i = 0;
  for( ; !(i >= 320); i = i + 1)
    ng_clip[(signed long int)i] = (unsigned int)0;
  for( ; !(i >= 256); i = i + 1)
    ng_clip[(signed long int)i] = (unsigned int)(i - 320);
  for( ; !(i >= 256); i = i + 1)
    ng_clip[(signed long int)i] = (unsigned int)255;
  ng_conv_register(0x20030129, "built-in", conv_list_link1, nconv_link1);
}

// ng_conv_find_from
// file libng/grab-ng.c line 504
struct ng_video_conv * ng_conv_find_from(unsigned int in, signed int *i)
{
  struct list_head *item;
  struct ng_video_conv *ret;
  signed int j = 0;
  item = (&ng_conv)->next;
  for( ; !(item == &ng_conv); item = item->next)
    if(!(j >= *i))
      j = j + 1;

    else
    {
      ret = (struct ng_video_conv *)((char *)item - (signed long int)(unsigned long int)&((struct ng_video_conv *)0)->list);
      if(ret->fmtid_in == in)
      {
        *i = *i + 1;
        return ret;
      }

    }
  return (struct ng_video_conv *)(void *)0;
}

// ng_conv_find_match
// file libng/grab-ng.c line 531
struct ng_video_conv * ng_conv_find_match(unsigned int in, unsigned int out)
{
  struct list_head *item;
  struct ng_video_conv *ret = (struct ng_video_conv *)(void *)0;
  item = (&ng_conv)->next;
  for( ; !(item == &ng_conv); item = item->next)
  {
    ret = (struct ng_video_conv *)((char *)item - (signed long int)(unsigned long int)&((struct ng_video_conv *)0)->list);
    if(ret->fmtid_in == in)
    {
      if(ret->fmtid_out == out)
        return ret;

    }

  }
  return (struct ng_video_conv *)(void *)0;
}

// ng_conv_find_to
// file ./libng/grab-ng.h line 445
struct ng_video_conv * ng_conv_find_to(unsigned int out, signed int *i)
{
  struct list_head *item;
  struct ng_video_conv *ret;
  signed int j = 0;
  item = (&ng_conv)->next;
  for( ; !(item == &ng_conv); item = item->next)
    if(!(j >= *i))
      j = j + 1;

    else
    {
      ret = (struct ng_video_conv *)((char *)item - (signed long int)(unsigned long int)&((struct ng_video_conv *)0)->list);
      if(ret->fmtid_out == out)
      {
        *i = *i + 1;
        return ret;
      }

      *i = *i + 1;
      j = j + 1;
    }
  return (struct ng_video_conv *)(void *)0;
}

// ng_conv_nop_fini
// file libng/color_common.c line 56
void ng_conv_nop_fini(void *handle)
{
  ;
}

// ng_conv_nop_init
// file libng/color_common.c line 49
void * ng_conv_nop_init(struct ng_video_fmt *out, void *priv)
{
  return (void *)0;
}

// ng_conv_register
// file libng/grab-ng.c line 396
signed int ng_conv_register(signed int magic, char *plugname, struct ng_video_conv *list, signed int count)
{
  signed int n;
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "video converters");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    n = 0;
    for( ; !(n >= count); n = n + 1)
      list_add_tail_link1(&(list + (signed long int)n)->list, &ng_conv);
    return 0;
  }
}

// ng_convert_alloc
// file ./libng/grab-ng.h line 373
struct ng_convert_handle * ng_convert_alloc(struct ng_video_conv *conv, struct ng_video_fmt *i, struct ng_video_fmt *o)
{
  struct ng_convert_handle *h;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ng_convert_handle) /*56ul*/ );
  h = (struct ng_convert_handle *)return_value_malloc_1;
  if(h == ((struct ng_convert_handle *)NULL))
    return ((struct ng_convert_handle *)NULL);

  else
  {
    memset((void *)h, 0, sizeof(struct ng_convert_handle) /*56ul*/ );
    o->width = i->width;
    o->height = i->height;
    if(o->bytesperline == 0u)
      o->bytesperline = (o->width * ng_vfmt_to_depth[(signed long int)o->fmtid]) / (unsigned int)8;

    h->ifmt = *i;
    h->ofmt = *o;
    if(!(conv == ((struct ng_video_conv *)NULL)))
      h->conv = conv;

    return h;
  }
}

// ng_convert_copyframe
// file libng/convert.c line 69
static void ng_convert_copyframe(struct ng_video_buf *dest, struct ng_video_buf *src)
{
  unsigned int i;
  unsigned int sw;
  unsigned int dw;
  unsigned char *sp;
  unsigned char *dp;
  dw = (dest->fmt.width * ng_vfmt_to_depth[(signed long int)dest->fmt.fmtid]) / (unsigned int)8;
  sw = (src->fmt.width * ng_vfmt_to_depth[(signed long int)src->fmt.fmtid]) / (unsigned int)8;
  _Bool tmp_if_expr_1;
  if(src->fmt.bytesperline == sw)
    tmp_if_expr_1 = dest->fmt.bytesperline == dw ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    memcpy((void *)dest->data, (const void *)src->data, (unsigned long int)(src->fmt.bytesperline * src->fmt.height));

  else
  {
    dp = dest->data;
    sp = src->data;
    i = (unsigned int)0;
    for( ; !(i >= src->fmt.height); i = i + 1u)
    {
      memcpy((void *)dp, (const void *)sp, (unsigned long int)dw);
      dp = dp + (signed long int)dest->fmt.bytesperline;
      sp = sp + (signed long int)src->fmt.bytesperline;
    }
  }
}

// ng_convert_fini
// file ./libng/grab-ng.h line 380
void ng_convert_fini(struct ng_convert_handle *h)
{
  if(!(h->conv == ((struct ng_video_conv *)NULL)))
    h->conv->fini(h->chandle);

  free((void *)h);
}

// ng_convert_frame
// file ./libng/grab-ng.h line 377
struct ng_video_buf * ng_convert_frame(struct ng_convert_handle *h, struct ng_video_buf *dest, struct ng_video_buf *buf)
{
  if(buf == ((struct ng_video_buf *)NULL))
    return (struct ng_video_buf *)(void *)0;

  else
  {
    if(dest == ((struct ng_video_buf *)NULL))
    {
      if(!(h->conv == ((struct ng_video_conv *)NULL)))
        dest=ng_malloc_video_buf(&h->ofmt, h->osize);

    }

    if(!(dest == ((struct ng_video_buf *)NULL)))
    {
      dest->fmt = h->ofmt;
      dest->size = (unsigned long int)h->osize;
      if(!(h->conv == ((struct ng_video_conv *)NULL)))
        h->conv->frame(h->chandle, dest, buf);

      else
        ng_convert_copyframe(dest, buf);
      dest->info = buf->info;
      ng_release_video_buf(buf);
      buf = dest;
    }

    return buf;
  }
}

// ng_convert_init
// file ./libng/grab-ng.h line 376
void ng_convert_init(struct ng_convert_handle *h)
{
  if(h->ifmt.bytesperline == 0u)
    h->ifmt.bytesperline = (h->ifmt.width * ng_vfmt_to_depth[(signed long int)h->ifmt.fmtid]) / (unsigned int)8;

  if(h->ofmt.bytesperline == 0u)
    h->ofmt.bytesperline = (h->ofmt.width * ng_vfmt_to_depth[(signed long int)h->ofmt.fmtid]) / (unsigned int)8;

  h->isize = (signed int)(h->ifmt.height * h->ifmt.bytesperline);
  if(h->isize == 0)
    h->isize = (signed int)(h->ifmt.width * h->ifmt.height * (unsigned int)3);

  h->osize = (signed int)(h->ofmt.height * h->ofmt.bytesperline);
  if(h->osize == 0)
    h->osize = (signed int)(h->ofmt.width * h->ofmt.height * (unsigned int)3);

  if(!(h->conv == ((struct ng_video_conv *)NULL)))
    h->chandle=h->conv->init(&h->ofmt, h->conv->priv);

  if(!(ng_debug == 0))
  {
    fprintf(stderr, "convert-in : %dx%d %s (size=%d)\n", h->ifmt.width, h->ifmt.height, ng_vfmt_to_desc[(signed long int)h->ifmt.fmtid], h->isize);
    fprintf(stderr, "convert-out: %dx%d %s (size=%d)\n", h->ofmt.width, h->ofmt.height, ng_vfmt_to_desc[(signed long int)h->ofmt.fmtid], h->osize);
  }

}

// ng_convert_single
// file ./libng/grab-ng.h line 381
struct ng_video_buf * ng_convert_single(struct ng_convert_handle *h, struct ng_video_buf *in)
{
  struct ng_video_buf *out;
  ng_convert_init(h);
  out=ng_convert_frame(h, (struct ng_video_buf *)(void *)0, in);
  ng_convert_fini(h);
  return out;
}

// ng_convert_thread
// file common/capture.c line 132
void * ng_convert_thread(void *arg)
{
  struct ng_convthread_handle *h = (struct ng_convthread_handle *)arg;
  struct ng_video_buf *in;
  struct ng_video_buf *out;
  signed int return_value_getpid_1;
  if(!(debug == 0))
  {
    return_value_getpid_1=getpid();
    fprintf(stderr, "convert_thread start [pid=%d]\n", return_value_getpid_1);
  }

  ng_convert_init(h->c);
  signed int return_value_webcam_put_3;
  do
  {
    void *return_value_fifo_get_2;
    return_value_fifo_get_2=fifo_get(h->in);
    in = (struct ng_video_buf *)return_value_fifo_get_2;
    if(in == ((struct ng_video_buf *)NULL))
      break;

    out=ng_convert_frame(h->c, (struct ng_video_buf *)(void *)0, in);
    if(!(webcam == ((char *)NULL)))
    {
      return_value_webcam_put_3=webcam_put(webcam, out);
      if(return_value_webcam_put_3 == 0)
      {
        free((void *)webcam);
        webcam = (char *)(void *)0;
      }

    }

    fifo_put(h->out, (void *)out);
  }
  while((_Bool)1);
  fifo_put(h->out, (void *)0);
  ng_convert_fini(h->c);
  signed int return_value_getpid_4;
  if(!(debug == 0))
  {
    return_value_getpid_4=getpid();
    fprintf(stderr, "convert_thread done [pid=%d]\n", return_value_getpid_4);
  }

  return (void *)0;
}

// ng_device_init
// file libng/devices.h line 14
void ng_device_init(void)
{
  struct stat st;
  signed int return_value_lstat_1;
  return_value_lstat_1=lstat("/dev/.devfsd", &st);
  if(!(return_value_lstat_1 == -1))
  {
    if((61440u & st.st_mode) == 8192u)
      ng_dev = ng_dev_devfs;

  }

}

// ng_dsp_driver_register
// file libng/grab-ng.c line 458
signed int ng_dsp_driver_register(signed int magic, char *plugname, struct ng_dsp_driver *driver)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "dsp drv");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail_link1(&driver->list, &ng_dsp_drivers);
    return 0;
  }
}

// ng_dsp_open
// file ./libng/grab-ng.h line 452
struct ng_dsp_driver * ng_dsp_open(char *device, struct ng_audio_fmt *fmt, signed int record, void **handle)
{
  struct list_head *item;
  struct ng_dsp_driver *ng_dsp_open__1__drv;
  item = (&ng_dsp_drivers)->next;
  for( ; !(item == &ng_dsp_drivers); item = item->next)
  {
    ng_dsp_open__1__drv = (struct ng_dsp_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_dsp_driver *)0)->list);
    if(!(ng_dsp_open__1__drv->name == ((const char *)NULL)))
    {
      if(!(record == 0))
      {
        if(ng_dsp_open__1__drv->read == ((struct ng_audio_buf * (*)(void *, signed long int))NULL))
          goto __CPROVER_DUMP_L5;

      }

      if(record == 0)
      {
        if(ng_dsp_open__1__drv->write == ((struct ng_audio_buf * (*)(void *, struct ng_audio_buf *))NULL))
          goto __CPROVER_DUMP_L5;

      }

      if(!(ng_debug == 0))
        fprintf(stderr, "dsp-open: trying: %s... \n", ng_dsp_open__1__drv->name);

      *handle=ng_dsp_open__1__drv->open(device, fmt, record);
      if(!(*handle == NULL))
        break;

      if(!(ng_debug == 0))
        fprintf(stderr, "dsp-open: failed: %s\n", ng_dsp_open__1__drv->name);

    }


  __CPROVER_DUMP_L5:
    ;
  }
  if(item == &ng_dsp_drivers)
    return (struct ng_dsp_driver *)(void *)0;

  else
  {
    if(!(ng_debug == 0))
      fprintf(stderr, "dsp-open: ok: %s\n", ng_dsp_open__1__drv->name);

    return ng_dsp_open__1__drv;
  }
}

// ng_filter_register
// file libng/grab-ng.c line 422
signed int ng_filter_register(signed int magic, char *plugname, struct ng_filter *filter)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "filter");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail_link1(&filter->list, &ng_filters);
    return 0;
  }
}

// ng_filter_single
// file ./libng/grab-ng.h line 461
struct ng_video_buf * ng_filter_single(struct ng_filter *filter, struct ng_video_buf *in)
{
  struct ng_video_buf *out = in;
  void *handle;
  if(!(filter == ((struct ng_filter *)NULL)))
  {
    if(!((filter->fmts & 1 << in->fmt.fmtid) == 0))
    {
      handle=filter->init(&in->fmt);
      out=filter->frame(handle, in);
      filter->fini(handle);
    }

  }

  return out;
}

// ng_find_reader
// file libng/grab-ng.c line 763
struct ng_reader * ng_find_reader(char *filename)
{
  struct list_head *item;
  struct ng_reader *reader;
  char blk[512l];
  struct _IO_FILE *fp;
  signed int m;
  fp=fopen(filename, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "open %s: %s\n", filename, return_value_strerror_2);
    return (struct ng_reader *)(void *)0;
  }

  memset((void *)blk, 0, sizeof(char [512l]) /*512ul*/ );
  fread((void *)blk, (unsigned long int)1, sizeof(char [512l]) /*512ul*/ , fp);
  fclose(fp);
  item = (&ng_readers)->next;
  _Bool tmp_if_expr_3;
  for( ; !(item == &ng_readers); item = item->next)
  {
    reader = (struct ng_reader *)((char *)item - (signed long int)(unsigned long int)&((struct ng_reader *)0)->list);
    m = 0;
    do
    {
      if(!(m >= 4))
        tmp_if_expr_3 = reader->mlen[(signed long int)m] > 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        break;

      signed int return_value_memcmp_4;
      return_value_memcmp_4=memcmp((const void *)(blk + (signed long int)reader->moff[(signed long int)m]), (const void *)reader->magic[(signed long int)m], (unsigned long int)reader->mlen[(signed long int)m]);
      if(return_value_memcmp_4 == 0)
        return reader;

      m = m + 1;
    }
    while((_Bool)1);
  }
  if(!(ng_debug == 0))
    fprintf(stderr, "%s: no reader found\n", filename);

  return (struct ng_reader *)(void *)0;
}

// ng_free_video_buf
// file libng/grab-ng.c line 154
static void ng_free_video_buf(struct ng_video_buf *buf)
{
  free((void *)buf->data);
  free((void *)buf);
}

// ng_get_timestamp
// file ./libng/grab-ng.h line 458
signed long int ng_get_timestamp(void)
{
  struct timeval ng_get_timestamp__1__tv;
  gettimeofday(&ng_get_timestamp__1__tv, (struct timezone *)(void *)0);
  signed long int return_value_ng_tofday_to_timestamp_1;
  return_value_ng_tofday_to_timestamp_1=ng_tofday_to_timestamp(&ng_get_timestamp__1__tv);
  return return_value_ng_tofday_to_timestamp_1;
}

// ng_grabber_findconv
// file common/capture.c line 199
struct ng_video_conv * ng_grabber_findconv(struct ng_video_fmt *fmt, signed int fix_ratio)
{
  struct ng_video_fmt gfmt;
  struct ng_video_conv *conv;
  signed int i = 0;
  do
  {
    conv=ng_conv_find_to(fmt->fmtid, &i);
    if(conv == ((struct ng_video_conv *)NULL))
      break;

    gfmt = *fmt;
    gfmt.fmtid = conv->fmtid_in;
    signed int return_value_ng_grabber_setformat_1;
    return_value_ng_grabber_setformat_1=ng_grabber_setformat(&gfmt, fix_ratio);
    if(return_value_ng_grabber_setformat_1 == 0)
      goto found;

  }
  while((_Bool)1);
  fprintf(stderr, "no way to get: %dx%d %s\n", fmt->width, fmt->height, ng_vfmt_to_desc[(signed long int)fmt->fmtid]);
  return (struct ng_video_conv *)(void *)0;

found:
  ;
  *fmt = gfmt;
  return conv;
}

// ng_grabber_get_image
// file ./common/capture.h line 24
struct ng_video_buf * ng_grabber_get_image(struct ng_video_fmt *fmt)
{
  struct ng_video_fmt gfmt;
  struct ng_video_conv *conv;
  struct ng_convert_handle *ch;
  struct ng_video_buf *buf;
  signed int return_value_ng_grabber_setformat_2;
  return_value_ng_grabber_setformat_2=ng_grabber_setformat(fmt, 1);
  struct ng_video_buf *return_value_ng_grabber_grab_image_1;
  if(return_value_ng_grabber_setformat_2 == 0)
  {
    return_value_ng_grabber_grab_image_1=ng_grabber_grab_image(1);
    return return_value_ng_grabber_grab_image_1;
  }

  gfmt = *fmt;
  conv=ng_grabber_findconv(&gfmt, 1);
  if(conv == ((struct ng_video_conv *)NULL))
    return (struct ng_video_buf *)(void *)0;

  else
  {
    ch=ng_convert_alloc(conv, &gfmt, fmt);
    buf=ng_grabber_grab_image(1);
    if(buf == ((struct ng_video_buf *)NULL))
      return (struct ng_video_buf *)(void *)0;

    else
    {
      buf=ng_convert_single(ch, buf);
      return buf;
    }
  }
}

// ng_grabber_grab_image
// file ./common/capture.h line 23
struct ng_video_buf * ng_grabber_grab_image(signed int single)
{
  struct ng_video_buf *tmp_if_expr_1;
  struct ng_video_buf *return_value;
  struct ng_video_buf *return_value_1;
  if(!(single == 0))
  {
    return_value=drv->getimage(h_drv);
    tmp_if_expr_1 = return_value;
  }

  else
  {
    return_value_1=drv->nextframe(h_drv);
    tmp_if_expr_1 = return_value_1;
  }
  return tmp_if_expr_1;
}

// ng_grabber_setformat
// file ./common/capture.h line 20
signed int ng_grabber_setformat(struct ng_video_fmt *fmt, signed int fix_ratio)
{
  struct ng_video_fmt gfmt;
  signed int rc;
  if((2 & f_drv) == 0)
    return -1;

  else
  {
    gfmt = *fmt;
    rc=drv->setformat(h_drv, &gfmt);
    if(!(debug == 0))
      fprintf(stderr, "setformat: %s (%dx%d): %s\n", ng_vfmt_to_desc[(signed long int)gfmt.fmtid], gfmt.width, gfmt.height, 0 == rc ? "ok" : "failed");

    if(!(rc == 0))
      return -1;

    else
    {
      if(!(fix_ratio == 0))
      {
        ng_ratio_fixup((signed int *)&gfmt.width, (signed int *)&gfmt.height, (signed int *)(void *)0, (signed int *)(void *)0);
        gfmt.bytesperline = (unsigned int)0;
        signed int return_value;
        return_value=drv->setformat(h_drv, &gfmt);
        if(!(return_value == 0))
        {
          fprintf(stderr, "Oops: ratio size renegotiation failed\n");
          exit(1);
        }

      }

      *fmt = gfmt;
      return 0;
    }
  }
}

// ng_init
// file ./libng/grab-ng.h line 466
void ng_init(void)
{
  signed int ng_init__1__count = 0;
  static signed int once = 0;
  signed int tmp_post_1 = once;
  once = once + 1;
  if(!(tmp_post_1 == 0))
  {
    fprintf(stderr, "panic: ng_init called twice\n");
    exit(1);
  }

  ng_device_init();
  ng_color_packed_init();
  ng_color_yuv2rgb_init();
  ng_writefile_init();
  signed int return_value_ng_plugins_2;
  return_value_ng_plugins_2=ng_plugins("/usr/lib/x86_64-linux-gnu/xawtv");
  ng_init__1__count = ng_init__1__count + return_value_ng_plugins_2;
  if(ng_init__1__count == 0)
  {
    signed int return_value_ng_plugins_3;
    return_value_ng_plugins_3=ng_plugins("../libng/plugins");
    ng_init__1__count = ng_init__1__count + return_value_ng_plugins_3;
    signed int return_value_ng_plugins_4;
    return_value_ng_plugins_4=ng_plugins("../libng/contrib-plugins");
    ng_init__1__count = ng_init__1__count + return_value_ng_plugins_4;
  }

  if(ng_init__1__count == 0)
    fprintf(stderr, "WARNING: no plugins found [%s]\n", (const void *)"/usr/lib/x86_64-linux-gnu/xawtv");

}

// ng_init_video_buf
// file libng/grab-ng.c line 122
void ng_init_video_buf(struct ng_video_buf *buf)
{
  memset((void *)buf, 0, sizeof(struct ng_video_buf) /*160ul*/ );
  pthread_mutex_init(&buf->lock, (const union anonymous_121 *)(void *)0);
  pthread_cond_init(&buf->cond, (const union anonymous_121 *)(void *)0);
}

// ng_lut_init
// file ./libng/grab-ng.h line 467
void ng_lut_init(unsigned long int red_mask, unsigned long int green_mask, unsigned long int blue_mask, unsigned int fmtid, signed int swap)
{
  signed int rgb_red_bits = 0;
  signed int rgb_red_shift = 0;
  signed int rgb_green_bits = 0;
  signed int rgb_green_shift = 0;
  signed int rgb_blue_bits = 0;
  signed int rgb_blue_shift = 0;
  unsigned int i;
  unsigned int mask;
  static signed int once = 0;
  signed int tmp_post_1 = once;
  once = once + 1;
  if(!(tmp_post_1 == 0))
  {
    fprintf(stderr, "panic: ng_lut_init called twice\n");
    exit(1);
  }

  i = (unsigned int)0;
  for( ; !(i >= 32u); i = i + 1u)
  {
    mask = (unsigned int)(1 << i);
    if(!((red_mask & (unsigned long int)mask) == 0ul))
      rgb_red_bits = rgb_red_bits + 1;

    else
      if(rgb_red_bits == 0)
        rgb_red_shift = rgb_red_shift + 1;

    if(!((green_mask & (unsigned long int)mask) == 0ul))
      rgb_green_bits = rgb_green_bits + 1;

    else
      if(rgb_green_bits == 0)
        rgb_green_shift = rgb_green_shift + 1;

    if(!((blue_mask & (unsigned long int)mask) == 0ul))
      rgb_blue_bits = rgb_blue_bits + 1;

    else
      if(rgb_blue_bits == 0)
        rgb_blue_shift = rgb_blue_shift + 1;

  }
  if(rgb_red_bits >= 9)
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_red[(signed long int)i] = (unsigned long int)(i << (rgb_red_bits + rgb_red_shift) - 8);
  }

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_red[(signed long int)i] = (unsigned long int)((i >> 8 - rgb_red_bits) << rgb_red_shift);
  }
  if(rgb_green_bits >= 9)
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_green[(signed long int)i] = (unsigned long int)(i << (rgb_green_bits + rgb_green_shift) - 8);
  }

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_green[(signed long int)i] = (unsigned long int)((i >> 8 - rgb_green_bits) << rgb_green_shift);
  }
  if(rgb_blue_bits >= 9)
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_blue[(signed long int)i] = (unsigned long int)(i << (rgb_blue_bits + rgb_blue_shift) - 8);
  }

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_blue[(signed long int)i] = (unsigned long int)((i >> 8 - rgb_blue_bits) << rgb_blue_shift);
  }
  switch(ng_vfmt_to_depth[(signed long int)fmtid])
  {
    case (const unsigned int)16:
    {
      if(!(swap == 0))
      {
        i = (unsigned int)0;
        for( ; !(i >= 256u); i = i + 1u)
        {
          ng_lut_red[(signed long int)i] = ng_lut_red[(signed long int)i] >> 8 & (unsigned long int)0x00ff | ng_lut_red[(signed long int)i] << 8 & (unsigned long int)0xff00;
          ng_lut_green[(signed long int)i] = ng_lut_green[(signed long int)i] >> 8 & (unsigned long int)0x00ff | ng_lut_green[(signed long int)i] << 8 & (unsigned long int)0xff00;
          ng_lut_blue[(signed long int)i] = ng_lut_blue[(signed long int)i] >> 8 & (unsigned long int)0x00ff | ng_lut_blue[(signed long int)i] << 8 & (unsigned long int)0xff00;
        }
      }

      i = (unsigned int)0;
      for( ; !(i >= nconv2); i = i + 1u)
        lut2_list[(signed long int)i].fmtid_out = fmtid;
      ng_conv_register(0x20030129, "built-in", lut2_list, (signed int)nconv2);
      break;
    }
    case (const unsigned int)32:
    {
      if(!(swap == 0))
      {
        i = (unsigned int)0;
        for( ; !(i >= 256u); i = i + 1u)
        {
          ng_lut_red[(signed long int)i] = ng_lut_red[(signed long int)i] >> 24 & (unsigned long int)0x000000ff | ng_lut_red[(signed long int)i] >> 8 & (unsigned long int)0x0000ff00 | ng_lut_red[(signed long int)i] << 8 & (unsigned long int)0x00ff0000 | ng_lut_red[(signed long int)i] << 24 & (unsigned long int)0xff000000;
          ng_lut_green[(signed long int)i] = ng_lut_green[(signed long int)i] >> 24 & (unsigned long int)0x000000ff | ng_lut_green[(signed long int)i] >> 8 & (unsigned long int)0x0000ff00 | ng_lut_green[(signed long int)i] << 8 & (unsigned long int)0x00ff0000 | ng_lut_green[(signed long int)i] << 24 & (unsigned long int)0xff000000;
          ng_lut_blue[(signed long int)i] = ng_lut_blue[(signed long int)i] >> 24 & (unsigned long int)0x000000ff | ng_lut_blue[(signed long int)i] >> 8 & (unsigned long int)0x0000ff00 | ng_lut_blue[(signed long int)i] << 8 & (unsigned long int)0x00ff0000 | ng_lut_blue[(signed long int)i] << 24 & (unsigned long int)0xff000000;
        }
      }

      i = (unsigned int)0;
      for( ; !(i >= nconv4); i = i + 1u)
        lut4_list[(signed long int)i].fmtid_out = fmtid;
      ng_conv_register(0x20030129, "built-in", lut4_list, (signed int)nconv4);
    }
  }
}

// ng_malloc_audio_buf
// file libng/grab-ng.c line 184
struct ng_audio_buf * ng_malloc_audio_buf(struct ng_audio_fmt *fmt, signed int size)
{
  struct ng_audio_buf *buf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ng_audio_buf) /*32ul*/  + (unsigned long int)size);
  buf = (struct ng_audio_buf *)return_value_malloc_1;
  memset((void *)buf, 0, sizeof(struct ng_audio_buf) /*32ul*/ );
  buf->fmt = *fmt;
  buf->size = size;
  buf->data = (char *)buf + (signed long int)sizeof(struct ng_audio_buf) /*32ul*/ ;
  return buf;
}

// ng_malloc_video_buf
// file ./libng/grab-ng.h line 163
struct ng_video_buf * ng_malloc_video_buf(struct ng_video_fmt *fmt, signed int size)
{
  struct ng_video_buf *buf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ng_video_buf) /*160ul*/ );
  buf = (struct ng_video_buf *)return_value_malloc_1;
  if(buf == ((struct ng_video_buf *)NULL))
    return (struct ng_video_buf *)(void *)0;

  else
  {
    ng_init_video_buf(buf);
    buf->fmt = *fmt;
    buf->size = (unsigned long int)size;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)size);
    buf->data = (unsigned char *)return_value_malloc_2;
    if(buf->data == ((unsigned char *)NULL))
    {
      free((void *)buf);
      return (struct ng_video_buf *)(void *)0;
    }

    else
    {
      buf->refcount = 1;
      buf->release = ng_free_video_buf;
      return buf;
    }
  }
}

// ng_mix_driver_register
// file libng/grab-ng.c line 467
signed int ng_mix_driver_register(signed int magic, char *plugname, struct ng_mix_driver *driver)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "mixer drv");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail_link1(&driver->list, &ng_mix_drivers);
    return 0;
  }
}

// ng_mix_init
// file ./libng/grab-ng.h line 454
struct ng_attribute * ng_mix_init(char *device, char *channel)
{
  struct list_head *item;
  struct ng_mix_driver *ng_mix_init__1__drv = (struct ng_mix_driver *)(void *)0;
  struct ng_attribute *ng_mix_init__1__attrs = (struct ng_attribute *)(void *)0;
  void *handle;
  item = (&ng_mix_drivers)->next;
  if(!(item == &ng_mix_drivers))
  {
    ng_mix_init__1__drv = (struct ng_mix_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_mix_driver *)0)->list);
    if(!(ng_debug == 0))
      fprintf(stderr, "mix-init: trying: %s... \n", ng_mix_init__1__drv->name);

    handle=ng_mix_init__1__drv->open(device);
    if(!(handle == NULL))
    {
      ng_mix_init__1__attrs=ng_mix_init__1__drv->volctl(handle, channel);
      ng_mix_init__1__drv->close(handle);
    }

    if(!(ng_debug == 0))
      fprintf(stderr, "mix-init: failed: %s\n", ng_mix_init__1__drv->name);

    item = item->next;
  }

  if(!(ng_mix_init__1__attrs == ((struct ng_attribute *)NULL)) && !(ng_debug == 0))
    fprintf(stderr, "mix-init: ok: %s\n", ng_mix_init__1__drv->name);

  return ng_mix_init__1__attrs;
}

// ng_packed_frame
// file libng/color_common.c line 22
void ng_packed_frame(void *handle, struct ng_video_buf *out, struct ng_video_buf *in)
{
  signed int (*func)(unsigned char *, unsigned char *, signed int) = (signed int (*)(unsigned char *, unsigned char *, signed int))handle;
  unsigned char *sp;
  unsigned char *dp;
  unsigned int i;
  unsigned int sw;
  unsigned int dw = out->fmt.width * ng_vfmt_to_depth[(signed long int)out->fmt.fmtid] >> 3;
  sw = in->fmt.width * ng_vfmt_to_depth[(signed long int)in->fmt.fmtid] >> 3;
  _Bool tmp_if_expr_1;
  if(in->fmt.bytesperline == sw)
    tmp_if_expr_1 = out->fmt.bytesperline == dw ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    func(out->data, in->data, (signed int)(in->fmt.width * in->fmt.height));

  else
  {
    dp = out->data;
    sp = in->data;
    i = (unsigned int)0;
    if(!(i >= in->fmt.height))
    {
      func(dp, sp, (signed int)in->fmt.width);
      dp = dp + (signed long int)out->fmt.bytesperline;
      sp = sp + (signed long int)in->fmt.bytesperline;
      i = i + 1u;
    }

  }
}

// ng_packed_init
// file libng/color_common.c line 16
void * ng_packed_init(struct ng_video_fmt *out, void *priv)
{
  return priv;
}

// ng_plugins
// file libng/grab-ng.c line 940
static signed int ng_plugins(char *dirname)
{
  struct dirent **list;
  char filename[1024l];
  void *plugin;
  void (*initcall)(void);
  signed int i;
  signed int n = 0;
  signed int l = 0;
  n=scandir(dirname, &list, (signed int (*)(struct dirent *))(void *)0, alphasort);
  if(!(n >= 1))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      signed int return_value_fnmatch_1;
      return_value_fnmatch_1=fnmatch("*.so", list[(signed long int)i]->d_name, 0);
      if(return_value_fnmatch_1 == 0)
      {
        sprintf(filename, "%s/%s", dirname, (const void *)list[(signed long int)i]->d_name);
        plugin=dlopen(filename, 0x00002);
        if(plugin == NULL)
        {
          char *return_value_dlerror_2;
          return_value_dlerror_2=dlerror();
          fprintf(stderr, "dlopen: %s\n", return_value_dlerror_2);
          goto __CPROVER_DUMP_L6;
        }

        void *return_value_dlsym_5;
        return_value_dlsym_5=dlsym(plugin, "ng_plugin_init");
        initcall = (void (*)(void))return_value_dlsym_5;
        if(initcall == ((void (*)(void))NULL))
        {
          void *return_value_dlsym_4;
          return_value_dlsym_4=dlsym(plugin, "_ng_plugin_init");
          initcall = (void (*)(void))return_value_dlsym_4;
          if(initcall == ((void (*)(void))NULL))
          {
            char *return_value_dlerror_3;
            return_value_dlerror_3=dlerror();
            fprintf(stderr, "dlsym[%s]: %s\n", (const void *)filename, return_value_dlerror_3);
            goto __CPROVER_DUMP_L6;
          }

        }

        initcall();
        l = l - 1;
      }


    __CPROVER_DUMP_L6:
      ;
    }
    i = 0;
    for( ; !(i >= n); i = i + 1)
      free((void *)list[(signed long int)i]);
    free((void *)list);
    return l;
  }
}

// ng_ratio_fixup
// file ./libng/grab-ng.h line 268
void ng_ratio_fixup(signed int *width, signed int *height, signed int *xoff, signed int *yoff)
{
  signed int h = *height;
  signed int w = *width;
  if(!(ng_ratio_x == 0) && !(ng_ratio_y == 0))
  {
    if(!(w * ng_ratio_y >= h * ng_ratio_x))
    {
      *height = (*width * ng_ratio_y) / ng_ratio_x;
      if(!(yoff == ((signed int *)NULL)))
        *yoff = *yoff + (h - *height) / 2;

    }

    else
      if(!(h * ng_ratio_x >= w * ng_ratio_y))
      {
        *width = (*height * ng_ratio_x) / ng_ratio_y;
        if(!(yoff == ((signed int *)NULL)))
          *xoff = *xoff + (w - *width) / 2;

      }

  }

}

// ng_ratio_fixup2
// file libng/grab-ng.c line 349
void ng_ratio_fixup2(signed int *width, signed int *height, signed int *xoff, signed int *yoff, signed int ratio_x, signed int ratio_y, signed int up)
{
  signed int h = *height;
  signed int w = *width;
  if(!(ratio_x == 0) && !(ratio_y == 0))
  {
    if(up == 0 && !(w * ratio_y >= h * ratio_x) || !(up == 0) && !(h * ratio_x >= w * ratio_y))
    {
      *height = (*width * ratio_y) / ratio_x;
      if(!(yoff == ((signed int *)NULL)))
        *yoff = *yoff + (h - *height) / 2;

    }

    else
      if(up == 0 && !(h * ratio_x >= w * ratio_y) || !(up == 0) && !(w * ratio_y >= h * ratio_x))
      {
        *width = (*height * ratio_x) / ratio_y;
        if(!(yoff == ((signed int *)NULL)))
          *xoff = *xoff + (w - *width) / 2;

      }

  }

}

// ng_reader_register
// file libng/grab-ng.c line 440
signed int ng_reader_register(signed int magic, char *plugname, struct ng_reader *reader)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "reader");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail_link1(&reader->list, &ng_readers);
    return 0;
  }
}

// ng_release_video_buf
// file ./libng/grab-ng.h line 162
void ng_release_video_buf(struct ng_video_buf *buf)
{
  signed int release;
  pthread_mutex_lock(&buf->lock);
  buf->refcount = buf->refcount - 1;
  release = (signed int)(buf->refcount == 0);
  pthread_mutex_unlock(&buf->lock);
  if(!(release == 0))
  {
    if(!(buf->release == ((void (*)(struct ng_video_buf *))NULL)))
      buf->release(buf);

  }

}

// ng_rgb24_to_lut2
// file libng/color_lut.c line 30
void ng_rgb24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)0]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)2]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// ng_rgb24_to_lut4
// file libng/color_lut.c line 96
void ng_rgb24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)0]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)2]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// ng_tofday_to_timestamp
// file libng/grab-ng.c line 793
signed long int ng_tofday_to_timestamp(struct timeval *tv)
{
  signed long long int ts = tv->tv_sec;
  ts = ts * (signed long long int)1000000;
  ts = ts + tv->tv_usec;
  ts = ts * (signed long long int)1000;
  return ts;
}

// ng_vid_driver_register
// file libng/grab-ng.c line 449
signed int ng_vid_driver_register(signed int magic, char *plugname, struct ng_vid_driver *driver)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "video drv");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail_link1(&driver->list, &ng_vid_drivers);
    return 0;
  }
}

// ng_vid_open
// file ./libng/grab-ng.h line 449
struct ng_vid_driver * ng_vid_open(char **device, char *driver, struct ng_video_fmt *screen, void *base, void **handle)
{
  struct list_head *item;
  struct ng_vid_driver *ng_vid_open__1__drv;
  signed int return_value_strcmp_5;
  signed int return_value;
  if(driver == ((char *)NULL))
  {
    fprintf(stderr, "Video4linux driver is not specified\n");
    return (struct ng_vid_driver *)(void *)0;
  }

  else
  {
    item = (&ng_vid_drivers)->next;
    for( ; !(item == &ng_vid_drivers); item = item->next)
    {
      ng_vid_open__1__drv = (struct ng_vid_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_vid_driver *)0)->list);
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(driver, ng_vid_open__1__drv->name);
      if(return_value_strcasecmp_1 == 0)
        break;

    }
    if(item == &ng_vid_drivers)
    {
      signed int return_value_strcasecmp_2;
      return_value_strcasecmp_2=strcasecmp(driver, "help");
      if(!(return_value_strcasecmp_2 == 0))
        fprintf(stderr, "Cannot find %s video driver\n", driver);

      fprintf(stderr, "Available drivers:");
      item = (&ng_vid_drivers)->next;
      for( ; !(item == &ng_vid_drivers); item = item->next)
      {
        ng_vid_open__1__drv = (struct ng_vid_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_vid_driver *)0)->list);
        fprintf(stderr, " %s", ng_vid_open__1__drv->name);
      }
      fprintf(stderr, "\n");
      return (struct ng_vid_driver *)(void *)0;
    }

    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(*device, "auto");
    _Bool tmp_if_expr_6;
    if(return_value_strcmp_4 == 0)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_strcmp_5=strcmp(*device, "auto_tv");
      tmp_if_expr_6 = !(return_value_strcmp_5 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      char devpath[4096l];
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(*device, "auto_tv");
      *handle=ng_vid_open_auto(ng_vid_open__1__drv, devpath, !(return_value_strcmp_3 != 0) ? 0 : 1);
      if(*handle == NULL)
      {
        fprintf(stderr, "vid-open: could not find a suitable videodev\n");
        return (struct ng_vid_driver *)(void *)0;
      }

      *device=strdup(devpath);
    }

    else
    {
      if(!(ng_debug == 0))
        fprintf(stderr, "vid-open: trying: %s... \n", ng_vid_open__1__drv->name);

      *handle=ng_vid_open__1__drv->open(*device, 0);
      if(*handle == NULL)
      {
        fprintf(stderr, "vid-open: failed: %s\n", ng_vid_open__1__drv->name);
        return (struct ng_vid_driver *)(void *)0;
      }

      if(!(ng_debug == 0))
        fprintf(stderr, "vid-open: ok: %s\n", ng_vid_open__1__drv->name);

    }
    if(!(screen == ((struct ng_video_fmt *)NULL)))
    {
      return_value=ng_vid_open__1__drv->capabilities(*handle);
      if(!((1 & return_value) == 0))
      {
        signed int l;
        unsigned long int return_value_strlen_7;
        return_value_strlen_7=strlen(ng_v4l_conf);
        l = (signed int)return_value_strlen_7;
        snprintf(ng_v4l_conf + (signed long int)l, sizeof(char [256l]) /*256ul*/  - (unsigned long int)l, " -c %s", *device);
        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open: closing dev to run v4lconf\n");

        ng_vid_open__1__drv->close(*handle);
        signed int return_value_system_8;
        return_value_system_8=system(ng_v4l_conf);
        if(return_value_system_8 == -1)
          fprintf(stderr, "could'nt start v4l-conf\n");

        fprintf(stderr, "v4l-conf had some trouble, trying to continue anyway\n");
        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open: re-opening dev after v4lconf\n");

        *handle=ng_vid_open__1__drv->open(*device, 0);
        if(*handle == NULL)
        {
          fprintf(stderr, "vid-open: failed: %s\n", ng_vid_open__1__drv->name);
          return (struct ng_vid_driver *)(void *)0;
        }

        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open: re-open ok\n");

        ng_vid_open__1__drv->setupfb(*handle, screen, base);
      }

    }

    return ng_vid_open__1__drv;
  }
}

// ng_vid_open_auto
// file libng/grab-ng.c line 547
static void * ng_vid_open_auto(struct ng_vid_driver *drv, char *devpath, signed int allow_grabber)
{
  void *md;
  void *handle = (void *)0;
  const char *device = (const char *)(void *)0;
  const char *scan_type = "an analog TV";
  *devpath = (char)0;
  md=discover_media_devices();
  if(!(md == NULL))
  {
    device=get_associated_device(md, device, (const enum device_type)MEDIA_V4L_VIDEO, (const char *)(void *)0, (const enum device_type)NONE);
    if(!(device == ((const char *)NULL)))
    {
      snprintf(devpath, (unsigned long int)4096, "/dev/%s", device);
      if(!(ng_debug == 0))
        fprintf(stderr, "vid-open-auto: trying: %s... \n", devpath);

      handle=drv->open(devpath, 2 | 4);
      if(!(handle == NULL))
        fprintf(stderr, "vid-open-auto: using analog TV device %s\n", devpath);

    }

    if(handle == NULL)
    {
      if(allow_grabber == 0)
        goto error;

      scan_type = "a capture";
      device = (const char *)(void *)0;
      device=get_associated_device(md, device, (const enum device_type)MEDIA_V4L_VIDEO, (const char *)(void *)0, (const enum device_type)NONE);
      if(!(device == ((const char *)NULL)))
      {
        snprintf(devpath, (unsigned long int)4096, "/dev/%s", device);
        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open-auto: trying: %s... \n", devpath);

        handle=drv->open(devpath, 2);
        if(!(handle == NULL))
          fprintf(stderr, "vid-open-auto: using grabber/webcam device %s\n", devpath);

      }

    }

    free_media_devices(md);
  }


error:
  ;
  if(handle == NULL)
  {
    fprintf(stderr, "vid-open-auto: failed to open %s device", scan_type);
    if(!(*devpath == 0))
      fprintf(stderr, " at %s\n", devpath);

    else
      fprintf(stderr, "\n");
    return (void *)0;
  }

  else
  {
    if(!(handle == NULL) && !(ng_debug == 0))
      fprintf(stderr, "vid-open-auto: success, using: %s\n", devpath);

    return handle;
  }
}

// ng_waiton_video_buf
// file libng/grab-ng.c line 146
void ng_waiton_video_buf(struct ng_video_buf *buf)
{
  pthread_mutex_lock(&buf->lock);
  while(!(buf->refcount == 0))
    pthread_cond_wait(&buf->cond, &buf->lock);
  pthread_mutex_unlock(&buf->lock);
}

// ng_wakeup_video_buf
// file libng/grab-ng.c line 141
void ng_wakeup_video_buf(struct ng_video_buf *buf)
{
  pthread_cond_signal(&buf->cond);
}

// ng_writefile_init
// file libng/grab-ng.h line 481
void ng_writefile_init(void)
{
  ng_writer_register(0x20030129, "built-in", &files_writer);
  ng_writer_register(0x20030129, "built-in", &raw_writer);
}

// ng_writer_register
// file libng/grab-ng.c line 431
signed int ng_writer_register(signed int magic, char *plugname, struct ng_writer *writer)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "writer");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail_link1(&writer->list, &ng_writers);
    return 0;
  }
}

// ng_yuv420p_to_lut2
// file libng/grab-ng.h line 489
void ng_yuv420p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *us;
  unsigned char *vs;
  unsigned char *dp;
  unsigned short int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)4);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned short int *)dp;
    us = u;
    vs = v;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    if(i % 2u == 0u)
    {
      u = us;
      v = vs;
    }

    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// ng_yuv420p_to_lut4
// file libng/grab-ng.h line 491
void ng_yuv420p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *us;
  unsigned char *vs;
  unsigned char *dp;
  unsigned int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)4);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned int *)dp;
    us = u;
    vs = v;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    if(i % 2u == 0u)
    {
      u = us;
      v = vs;
    }

    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// ng_yuv422_to_lut2
// file libng/grab-ng.h line 487
void ng_yuv422_to_lut2(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int gray;
  for( ; !(p == 0); p = p - 2)
  {
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    unsigned short int * restrict tmp_post_1 = d;
    d = d + 1l;
    *tmp_post_1 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)2]];
    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    s = s + (signed long int)4;
  }
}

// ng_yuv422_to_lut4
// file libng/grab-ng.h line 488
void ng_yuv422_to_lut4(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int gray;
  for( ; !(p == 0); p = p - 2)
  {
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    unsigned int * restrict tmp_post_1 = d;
    d = d + 1l;
    *tmp_post_1 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)2]];
    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    s = s + (signed long int)4;
  }
}

// ng_yuv422p_to_lut2
// file libng/grab-ng.h line 493
void ng_yuv422p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *dp;
  unsigned short int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)2);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned short int *)dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// ng_yuv422p_to_lut4
// file libng/grab-ng.h line 495
void ng_yuv422p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *dp;
  unsigned int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)2);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned int *)dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// odd
// file common/vbi-sim.c line 194
static inline signed int odd(signed int c)
{
  signed int n = c ^ c >> 4;
  n = n ^ n >> 2;
  n = n ^ n >> 1;
  if((1 & n) == 0)
    c = c | 0x80;

  return c;
}

// ontop_ac
// file x11/motv.c line 311
static void ontop_ac(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  do_ontop((char)(stay_on_top != 0 ? 0 : 1));
}

// ontop_cb
// file x11/motv.c line 301
static void ontop_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct anonymous_57 *tb = (struct anonymous_57 *)call_data;
  if(tb->reason == 2)
    do_ontop((char)tb->set);

}

// oss_levels
// file ./common/sound.h line 4
void oss_levels(struct ng_audio_buf *buf, signed int *left, signed int *right)
{
  signed int lmax;
  signed int rmax;
  signed int i;
  signed int level;
  signed char *s = (signed char *)buf->data;
  unsigned char *u = (unsigned char *)buf->data;
  lmax = 0;
  rmax = 0;
  switch(buf->fmt.fmtid)
  {
    case (unsigned int)1:
    {
      i = 0;
      while(!(i >= buf->size))
      {
        signed int tmp_post_1 = i;
        i = i + 1;
        level=abs((signed int)u[(signed long int)tmp_post_1] - 128);
        if(!(lmax >= level))
        {
          lmax = level;
          rmax = level;
        }

      }
      goto __CPROVER_DUMP_L18;
    }
    case (unsigned int)2:
    {
      i = 0;
      while(!(i >= buf->size))
      {
        signed int tmp_post_2 = i;
        i = i + 1;
        level=abs((signed int)u[(signed long int)tmp_post_2] - 128);
        if(!(lmax >= level))
          lmax = level;

        signed int tmp_post_3 = i;
        i = i + 1;
        level=abs((signed int)u[(signed long int)tmp_post_3] - 128);
        if(!(rmax >= level))
          rmax = level;

      }
      goto __CPROVER_DUMP_L18;
    }
    case (unsigned int)5:

    case (unsigned int)3:
    {
      i = (unsigned int)5 == buf->fmt.fmtid ? 0 : 1;
      while(!(i >= buf->size))
      {
        level=abs((signed int)s[(signed long int)i]);
        i = i + 2;
        if(!(lmax >= level))
        {
          lmax = level;
          rmax = level;
        }

      }
      goto __CPROVER_DUMP_L18;
    }
    case (unsigned int)4:

    case (unsigned int)6:
    {
      i = (unsigned int)6 == buf->fmt.fmtid ? 0 : 1;
      while(!(i >= buf->size))
      {
        level=abs((signed int)s[(signed long int)i]);
        i = i + 2;
        if(!(lmax >= level))
          lmax = level;

        level=abs((signed int)s[(signed long int)i]);
        i = i + 2;
        if(!(rmax >= level))
          rmax = level;

      }
    }
    default:
    {

    __CPROVER_DUMP_L18:
      ;
      *left = lmax;
      *right = rmax;
    }
  }
}

// parse_action
// file common/event.c line 21
static void parse_action(struct event_entry *entry)
{
  char *token;
  char *h;
  strcpy(entry->argbuf, entry->action);
  h = entry->argbuf;

__CPROVER_DUMP_L1:
  ;
  while((_Bool)1)
  {
    if(!((signed int)*h == 32))
    {
      if((signed int)*h == 9)
        goto __CPROVER_DUMP_L2;

    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      h = h + 1l;
      goto __CPROVER_DUMP_L1;
    }
    if((signed int)*h == 0)
      break;

    if((signed int)*h == 34)
    {
      h = h + 1l;
      token = h;
      for( ; !((signed int)*h == 0); h = h + 1l)
        if((signed int)*h == 34)
          break;

    }

    else
    {
      token = h;
      for( ; !((signed int)*h == 0); h = h + 1l)
      {
        if((signed int)*h == 32)
          break;

        if((signed int)*h == 9)
          break;

      }
    }
    if(!((signed int)*h == 0))
    {
      *h = (char)0;
      h = h + 1l;
    }

    signed int tmp_post_1 = entry->argc;
    entry->argc = entry->argc + 1;
    entry->argv[(signed long int)tmp_post_1] = token;
  }
}

// parse_config
// file ./common/channel.h line 77
void parse_config(signed int parse_channels)
{
  char key[16l];
  char cmdline[128l];
  char **list;
  char *val;
  list=cfg_list_entries("launch");
  signed int return_value_sscanf_2;
  if(!(list == ((char **)NULL)))
    for( ; !(*list == ((char *)NULL)); list = list + 1l)
    {
      val=cfg_get_str("launch", *list);
      _Bool tmp_if_expr_3;
      if(!(val == ((char *)NULL)))
      {
        return_value_sscanf_2=sscanf(val, "%15[^,], %127[^\n]", (const void *)key, (const void *)cmdline);
        tmp_if_expr_3 = 2 == return_value_sscanf_2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
      {
        void *return_value_realloc_1;
        return_value_realloc_1=realloc((void *)launch, sizeof(struct LAUNCH) /*24ul*/  * (unsigned long int)(nlaunch + 1));
        launch = (struct LAUNCH *)return_value_realloc_1;
        (launch + (signed long int)nlaunch)->name=strdup(*list);
        (launch + (signed long int)nlaunch)->key=strdup(key);
        (launch + (signed long int)nlaunch)->cmdline=strdup(cmdline);
        nlaunch = nlaunch + 1;
      }

      else
        fprintf(stderr, "invalid value in section [launch]: %s\n", val);
    }

  event_readconfig();
  if(!(parse_channels == 0))
  {
    init_channel("defaults", &defaults);
    list=cfg_list_sections();
    for( ; !(*list == ((char *)NULL)); list = list + 1l)
    {
      signed int return_value_strcmp_4;
      return_value_strcmp_4=strcmp(*list, "defaults");
      if(!(return_value_strcmp_4 == 0))
      {
        signed int return_value_strcmp_5;
        return_value_strcmp_5=strcmp(*list, "global");
        if(!(return_value_strcmp_5 == 0))
        {
          signed int return_value_strcmp_6;
          return_value_strcmp_6=strcmp(*list, "launch");
          if(!(return_value_strcmp_6 == 0))
          {
            signed int return_value_strcmp_7;
            return_value_strcmp_7=strcmp(*list, "eventmap");
            if(!(return_value_strcmp_7 == 0))
            {
              struct CHANNEL *return_value_add_channel_8;
              return_value_add_channel_8=add_channel(*list);
              init_channel(*list, return_value_add_channel_8);
            }

          }

        }

      }

    }
    defaults.channel=lookup_channel(defaults.cname);
    signed int return_value_get_freq_9;
    return_value_get_freq_9=get_freq(defaults.channel);
    defaults.freq = return_value_get_freq_9 + defaults.fine;
    calc_frequencies();
  }

}

// patch_up
// file libng/writefile.c line 36
signed int patch_up(char *name)
{
  char *ptr;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  ptr = name + (signed long int)return_value_strlen_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  for( ; ptr >= name; ptr = ptr - 1l)
  {
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if(!((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*ptr]) == 0))
      break;

  }
  if(!(ptr >= name))
    return 0;

  else
  {
    while((signed int)*ptr == 57)
    {
      if(!(ptr >= name))
        break;

      char *tmp_post_3 = ptr;
      ptr = ptr - 1l;
      *tmp_post_3 = (char)48;
    }
    if(!(ptr >= name))
      return 0;

    else
    {
      const unsigned short int **return_value___ctype_b_loc_4;
      return_value___ctype_b_loc_4=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)*ptr]) == 0))
      {
        *ptr = *ptr + 1;
        return 1;
      }

      else
        return 0;
    }
  }
}

// pixit
// file x11/motv.c line 1676
static void pixit(void)
{
  unsigned long int pix;
  struct ng_video_fmt pixit__1__fmt;
  struct ng_video_buf *buf;
  if(!(cur_sender == -1))
  {
    channels[(signed long int)cur_sender]->color = cur_attrs[(signed long int)6];
    channels[(signed long int)cur_sender]->bright = cur_attrs[(signed long int)7];
    channels[(signed long int)cur_sender]->hue = cur_attrs[(signed long int)8];
    channels[(signed long int)cur_sender]->contrast = cur_attrs[(signed long int)9];
    channels[(signed long int)cur_sender]->input = cur_attrs[(signed long int)2];
    channels[(signed long int)cur_sender]->norm = cur_attrs[(signed long int)1];
    if(!(pix_height == 0) && !(pix_width == 0))
    {
      if(!((2 & f_drv) == 0))
      {
        video_gd_suspend();
        memset((void *)&pixit__1__fmt, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
        pixit__1__fmt.fmtid = x11_dpy_fmtid;
        pixit__1__fmt.width = (unsigned int)pix_width;
        pixit__1__fmt.height = (unsigned int)pix_height;
        buf=ng_grabber_get_image(&pixit__1__fmt);
        if(!(buf == ((struct ng_video_buf *)NULL)))
        {
          buf=ng_filter_single(cur_filter, buf);
          pix=x11_create_pixmap(dpy, &vinfo, buf);
          if(!(pix == 0ul))
          {
            x11_label_pixmap(dpy, colormap, pix, (signed int)buf->fmt.height, channels[(signed long int)cur_sender]->name);
            XtVaSetValues(channels[(signed long int)cur_sender]->button, (char *)&_XmStrings[(signed long int)7523], pix, (char *)&_XmStrings[(signed long int)7547], 1, (void *)0);
            if(!(channels[(signed long int)cur_sender]->pixmap == 0ul))
              XFreePixmap(dpy, channels[(signed long int)cur_sender]->pixmap);

            channels[(signed long int)cur_sender]->pixmap = pix;
          }


        done2:
          ;
          ng_release_video_buf(buf);
        }


      done1:
        ;
        video_gd_restart();
      }

    }

  }

}

// popdown_onscreen
// file x11/xt.c line 547
static void popdown_onscreen(void *client_data, unsigned long int *id)
{
  if(!(debug == 0))
    fprintf(stderr, "osd: hide\n");

  XtPopdown(on_shell);
  on_timer = (unsigned long int)0;
}

// popup_eh
// file x11/motv.c line 382
static void popup_eh(struct _WidgetRec *widget, void *clientdata, union _XEvent *event, char *cont)
{
  struct _WidgetRec *popup = (struct _WidgetRec *)clientdata;
  XmMenuPosition(popup, (struct anonymous_26 *)event);
  XtManageChild(popup);
}

// popupdown_cb
// file x11/motv.c line 391
static void popupdown_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  signed int i = 0;
  PopupAction((struct _WidgetRec *)clientdata, (union _XEvent *)(void *)0, (char **)(void *)0, (unsigned int *)&i);
}

// pref_done_cb
// file x11/motv.c line 2486
static void pref_done_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct anonymous_83 *cb = (struct anonymous_83 *)call_data;
  struct _WidgetRec *w;
  char *name = (char *)(void *)0;
  signed int on;
  signed int width;
  signed int height;
  _Bool tmp_if_expr_9;
  if(cb->reason == 31)
    tmp_if_expr_9 = (_Bool)1;

  else
    tmp_if_expr_9 = cb->reason == 34 ? (_Bool)1 : (_Bool)0;
  char *return_value_XtName_3;
  char *return_value_XtName_4;
  if(tmp_if_expr_9)
  {
    char return_value_XmToggleButtonGetState_1;
    return_value_XmToggleButtonGetState_1=XmToggleButtonGetState(pref_fs_toggle);
    on = (signed int)return_value_XmToggleButtonGetState_1;
    if(!(on == 0))
    {
      XtVaGetValues(pref_fs_menu, (char *)&_XmStrings[(signed long int)8040], &w, (void *)0);
      name=XtName(w);
      sscanf(name, "%d x %d", &width, &height);
      fs_width = width;
      fs_height = height;
    }

    else
    {
      fs_width = 0;
      fs_height = 0;
    }
    char return_value_XmToggleButtonGetState_2;
    return_value_XmToggleButtonGetState_2=XmToggleButtonGetState(pref_mix_toggle);
    on = (signed int)return_value_XmToggleButtonGetState_2;
    if(!(on == 0))
    {
      w = (struct _WidgetRec *)(void *)0;
      XtVaGetValues(pref_mix1_menu, (char *)&_XmStrings[(signed long int)8040], &w, (void *)0);
      if(!(w == ((struct _WidgetRec *)NULL)))
      {
        return_value_XtName_3=XtName(w);
        strcpy(mixerdev, return_value_XtName_3);
      }

      w = (struct _WidgetRec *)(void *)0;
      XtVaGetValues(pref_mix2_menu, (char *)&_XmStrings[(signed long int)8040], &w, (void *)0);
      if(!(w == ((struct _WidgetRec *)NULL)))
      {
        return_value_XtName_4=XtName(w);
        strcpy(mixerctl, return_value_XtName_4);
      }

    }

    else
    {
      mixerdev[(signed long int)0] = (char)0;
      mixerctl[(signed long int)0] = (char)0;
    }
    char return_value_XmToggleButtonGetState_5;
    return_value_XmToggleButtonGetState_5=XmToggleButtonGetState(pref_osd);
    use_osd = (signed int)return_value_XmToggleButtonGetState_5;
    char return_value_XmToggleButtonGetState_6;
    return_value_XmToggleButtonGetState_6=XmToggleButtonGetState(pref_ntsc);
    keypad_ntsc = (signed int)return_value_XmToggleButtonGetState_6;
    char return_value_XmToggleButtonGetState_7;
    return_value_XmToggleButtonGetState_7=XmToggleButtonGetState(pref_partial);
    keypad_partial = (signed int)return_value_XmToggleButtonGetState_7;
    char *return_value_XmTextGetString_8;
    return_value_XmTextGetString_8=XmTextGetString(pref_quality);
    ng_jpeg_quality=atoi(return_value_XmTextGetString_8);
  }

  if(cb->reason == 31)
    save_config();

  XtUnmanageChild(pref_dlg);
}

// pref_fs
// file x11/motv.c line 2345
static void pref_fs(void)
{
  struct _WidgetRec *push;
  char s[32l];
  signed int i;
  signed int on;
  char return_value_XmToggleButtonGetState_1;
  return_value_XmToggleButtonGetState_1=XmToggleButtonGetState(pref_fs_toggle);
  on = (signed int)return_value_XmToggleButtonGetState_1;
  if(!(on == 0))
  {
    if(args.vidmode == 0 && have_randr == 0)
    {
      args.vidmode = 1;
      xfree_vm_init(dpy);
    }

    if(have_randr == 0 && have_vm == 0)
    {
      on = 0;
      XtVaSetValues(pref_fs_toggle, (char *)&XtStrings[(signed long int)711], 0, (void *)0);
    }

  }

  XmToggleButtonSetState(pref_fs_toggle, (char)on, (char)0);
  if(!(on == 0))
  {
    pref_menu(pref_fs_option, pref_fs_menu, 1);
    if(!(have_randr == 0))
    {
      i = 0;
      for( ; !(i >= nrandr); i = i + 1)
      {
        sprintf(s, "%d x %d", (randr + (signed long int)i)->width, (randr + (signed long int)i)->height);
        push=XtVaCreateManagedWidget(s, xmPushButtonWidgetClass, pref_fs_menu, (void *)0);
        if((randr + (signed long int)i)->width == fs_width)
        {
          if((randr + (signed long int)i)->height == fs_height)
            XtVaSetValues(pref_fs_menu, (char *)&_XmStrings[(signed long int)8040], push, (void *)0);

        }

      }
    }

    if(have_randr == 0)
    {
      i = 0;
      for( ; !(i >= vm_count); i = i + 1)
      {
        sprintf(s, "%d x %d", vm_modelines[(signed long int)i]->hdisplay, vm_modelines[(signed long int)i]->vdisplay);
        push=XtVaCreateManagedWidget(s, xmPushButtonWidgetClass, pref_fs_menu, (void *)0);
        if((signed int)vm_modelines[(signed long int)i]->hdisplay == fs_width)
        {
          if((signed int)vm_modelines[(signed long int)i]->vdisplay == fs_height)
            XtVaSetValues(pref_fs_menu, (char *)&_XmStrings[(signed long int)8040], push, (void *)0);

        }

      }
    }

  }

  else
    pref_menu(pref_fs_option, pref_fs_menu, 0);
}

// pref_fst_cb
// file x11/motv.c line 2402
static void pref_fst_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  pref_fs();
}

// pref_manage_cb
// file x11/motv.c line 2533
static void pref_manage_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  char tmp[16l];
  XmToggleButtonSetState(pref_fs_toggle, (char)(fs_width != 0 && fs_height != 0), (char)0);
  pref_fs();
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(mixerdev);
  XmToggleButtonSetState(pref_mix_toggle, (char)(return_value_strlen_1 > (unsigned long int)0), (char)0);
  pref_mix1();
  pref_mix2();
  XmToggleButtonSetState(pref_osd, (char)use_osd, (char)0);
  XmToggleButtonSetState(pref_ntsc, (char)keypad_ntsc, (char)0);
  XmToggleButtonSetState(pref_partial, (char)keypad_partial, (char)0);
  sprintf(tmp, "%d", ng_jpeg_quality);
  XmTextSetString(pref_quality, tmp);
  XtManageChild(pref_dlg);
}

// pref_menu
// file x11/motv.c line 2333
static void pref_menu(struct _WidgetRec *option, struct _WidgetRec *menu, signed int enable)
{
  delete_children(menu);
  struct _WidgetRec *return_value_XmOptionButtonGadget_1;
  return_value_XmOptionButtonGadget_1=XmOptionButtonGadget(option);
  XtVaSetValues(return_value_XmOptionButtonGadget_1, (char *)&XtStrings[(signed long int)711], enable, (void *)0);
  struct _WidgetRec *return_value_XmOptionLabelGadget_2;
  return_value_XmOptionLabelGadget_2=XmOptionLabelGadget(option);
  XtVaSetValues(return_value_XmOptionLabelGadget_2, (char *)&XtStrings[(signed long int)711], enable, (void *)0);
  if(enable == 0)
    XtVaCreateManagedWidget("none", xmPushButtonWidgetClass, menu, (void *)0);

}

// pref_mix1
// file x11/motv.c line 2449
static void pref_mix1(void)
{
  struct ng_mix_driver *mix;
  struct _WidgetRec *push;
  signed int on;
  signed int i;
  struct ng_devinfo *info = (struct ng_devinfo *)(void *)0;
  char return_value_XmToggleButtonGetState_1;
  return_value_XmToggleButtonGetState_1=XmToggleButtonGetState(pref_mix_toggle);
  on = (signed int)return_value_XmToggleButtonGetState_1;
  signed int return_value_list_empty_2;
  return_value_list_empty_2=list_empty(&ng_mix_drivers);
  if(return_value_list_empty_2 == 0)
  {
    mix = (struct ng_mix_driver *)((char *)ng_mix_drivers.next - (signed long int)(unsigned long int)&((struct ng_mix_driver *)0)->list);
    info=mix->probe();
  }

  unsigned long int return_value_strlen_3;
  signed int return_value_strcmp_4;
  if(!(info == ((struct ng_devinfo *)NULL)) && !(on == 0))
  {
    pref_menu(pref_mix1_option, pref_mix1_menu, 1);
    i = 0;
    do
    {
      return_value_strlen_3=strlen((info + (signed long int)i)->name);
      if(return_value_strlen_3 == 0ul)
        break;

      push=XtVaCreateManagedWidget((info + (signed long int)i)->device, xmPushButtonWidgetClass, pref_mix1_menu, (void *)0);
      XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], pref_mix2_cb, (void *)0);
      toolkit_set_label(push, (info + (signed long int)i)->name);
      _Bool tmp_if_expr_5;
      if(i == 0)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_strcmp_4=strcmp((info + (signed long int)i)->device, mixerdev);
        tmp_if_expr_5 = 0 == return_value_strcmp_4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        XtVaSetValues(pref_mix1_menu, (char *)&_XmStrings[(signed long int)8040], push, (void *)0);

      i = i + 1;
    }
    while((_Bool)1);
  }

  else
    pref_menu(pref_mix1_option, pref_mix1_menu, 0);
}

// pref_mix1_cb
// file x11/motv.c line 2479
static void pref_mix1_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  pref_mix1();
  pref_mix2();
}

// pref_mix2
// file x11/motv.c line 2409
static void pref_mix2(void)
{
  struct ng_mix_driver *mix;
  struct _WidgetRec *push;
  struct _WidgetRec *w = (struct _WidgetRec *)(void *)0;
  char *name;
  signed int i;
  signed int on;
  struct ng_devinfo *info = (struct ng_devinfo *)(void *)0;
  char return_value_XmToggleButtonGetState_1;
  return_value_XmToggleButtonGetState_1=XmToggleButtonGetState(pref_mix_toggle);
  on = (signed int)return_value_XmToggleButtonGetState_1;
  XtVaGetValues(pref_mix1_menu, (char *)&_XmStrings[(signed long int)8040], &w, (void *)0);
  signed int return_value_strcmp_2;
  if(!(w == ((struct _WidgetRec *)NULL)))
  {
    name=XtName(w);
    signed int return_value_list_empty_3;
    return_value_list_empty_3=list_empty(&ng_mix_drivers);
    if(return_value_list_empty_3 == 0)
    {
      return_value_strcmp_2=strcmp(name, "none");
      if(!(return_value_strcmp_2 == 0))
      {
        mix = (struct ng_mix_driver *)((char *)ng_mix_drivers.next - (signed long int)(unsigned long int)&((struct ng_mix_driver *)0)->list);
        info=mix->channels(name);
      }

    }

  }

  unsigned long int return_value_strlen_4;
  if(!(info == ((struct ng_devinfo *)NULL)) && !(on == 0))
  {
    pref_menu(pref_mix2_option, pref_mix2_menu, 1);
    i = 0;
    do
    {
      return_value_strlen_4=strlen((info + (signed long int)i)->name);
      if(return_value_strlen_4 == 0ul)
        break;

      push=XtVaCreateManagedWidget((info + (signed long int)i)->device, xmPushButtonWidgetClass, pref_mix2_menu, (void *)0);
      toolkit_set_label(push, (info + (signed long int)i)->name);
      signed int return_value_strcasecmp_5;
      return_value_strcasecmp_5=strcasecmp((info + (signed long int)i)->device, mixerctl);
      if(return_value_strcasecmp_5 == 0)
        XtVaSetValues(pref_mix2_menu, (char *)&_XmStrings[(signed long int)8040], push, (void *)0);

      i = i + 1;
    }
    while((_Bool)1);
  }

  else
    pref_menu(pref_mix2_option, pref_mix2_menu, 0);
}

// pref_mix2_cb
// file x11/motv.c line 2443
static void pref_mix2_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  pref_mix2();
}

// print_choices
// file common/commands.c line 753
static void print_choices(char *name, char *value, struct STRTAB *tab)
{
  signed int i;
  fprintf(stderr, "unknown %s: '%s' (available: ", name, value);
  i = 0;
  for( ; !((tab + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
    fprintf(stderr, "%s'%s'", 0 == i ? "" : ", ", (tab + (signed long int)i)->str);
  fprintf(stderr, ")\n");
}

// raw_audio
// file libng/writefile.c line 519
static signed int raw_audio(void *handle, struct ng_audio_buf *buf)
{
  struct raw_handle *h = (struct raw_handle *)handle;
  signed long int return_value_write_1;
  return_value_write_1=write(h->wav_fd, (const void *)buf->data, (unsigned long int)buf->size);
  if(!((signed long int)buf->size == return_value_write_1))
    return -1;

  else
  {
    h->wav_size = h->wav_size + buf->size;
    return 0;
  }
}

// raw_close
// file libng/writefile.c line 529
static signed int raw_close(void *handle)
{
  struct raw_handle *h = (struct raw_handle *)handle;
  if(!(h->audio.fmtid == 0u))
  {
    wav_stop_write(h->wav_fd, &h->wav_header, h->wav_size);
    close(h->wav_fd);
  }

  if(!(h->video.fmtid == 0u))
  {
    if(!(h->fd == 1))
      close(h->fd);

  }

  free((void *)h);
  return 0;
}

// raw_open
// file libng/writefile.c line 408
static void * raw_open(char *videoname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio)
{
  struct raw_handle *h;
  signed int frame_rate_code = 0;
  signed int frame_rate_mul = fps;
  signed int frame_rate_div = 1000;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct raw_handle) /*88ul*/ );
  h = (struct raw_handle *)return_value_malloc_1;
  if(h == ((struct raw_handle *)NULL))
    return (void *)0;

  else
  {
    memset((void *)h, 0, sizeof(struct raw_handle) /*88ul*/ );
    h->video = *video;
    h->audio = *audio;
    h->vpriv = (struct raw_priv *)priv_video;
    if(!(h->audio.fmtid == 0u))
    {
      h->wav_fd=open(audioname, 0100 | 02 | 01000, 0666);
      if(h->wav_fd == -1)
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        char *return_value_strerror_3;
        return_value_strerror_3=strerror(*return_value___errno_location_2);
        fprintf(stderr, "open %s: %s\n", audioname, return_value_strerror_3);
        free((void *)h);
        return (void *)0;
      }

      wav_start_write(h->wav_fd, &h->wav_header, &h->audio);
    }

    if(!(h->video.fmtid == 0u))
    {
      if(!(h->vpriv == ((struct raw_priv *)NULL)))
      {
        if(!(h->vpriv->yuv4mpeg == 0))
          switch(fps)
          {
            case 23976:
            {
              frame_rate_code = 1;
              frame_rate_mul = 24000;
              frame_rate_div = 1001;
              break;
            }
            case 29970:
            {
              frame_rate_code = 4;
              frame_rate_mul = 30000;
              frame_rate_div = 1001;
              break;
            }
            case 59940:
            {
              frame_rate_code = 7;
              frame_rate_mul = 60000;
              frame_rate_div = 1001;
              break;
            }
            case 24000:
            {
              frame_rate_code = 2;
              break;
            }
            case 25000:
            {
              frame_rate_code = 3;
              break;
            }
            case 30000:
            {
              frame_rate_code = 5;
              break;
            }
            case 50000:
            {
              frame_rate_code = 6;
              break;
            }
            case 60000:
            {
              frame_rate_code = 8;
              break;
            }
            default:
            {
              fprintf(stderr, "illegal frame rate\n");
              free((void *)h);
              return (void *)0;
            }
          }

      }

      if(!(videoname == ((char *)NULL)))
      {
        h->fd=open(videoname, 0100 | 02 | 01000, 0666);
        if(h->fd == -1)
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          char *return_value_strerror_5;
          return_value_strerror_5=strerror(*return_value___errno_location_4);
          fprintf(stderr, "open %s: %s\n", videoname, return_value_strerror_5);
          if(!(h->wav_fd == 0))
            close(h->wav_fd);

          free((void *)h);
          return (void *)0;
        }

      }

      else
        h->fd = 1;
      if(!(h->vpriv == ((struct raw_priv *)NULL)))
      {
        if(!(h->vpriv->yuv4mpeg == 0))
        {
          char header[64l];
          switch(h->vpriv->yuv4mpeg)
          {
            case 1:
            {
              sprintf(header, "YUV4MPEG %d %d %d\n", h->video.width, h->video.height, frame_rate_code);
              break;
            }
            case 2:
              sprintf(header, "YUV4MPEG2 W%d H%d F%d:%d\n", h->video.width, h->video.height, frame_rate_mul, frame_rate_div);
          }
          unsigned long int return_value_strlen_6;
          return_value_strlen_6=strlen(header);
          write(h->fd, (const void *)header, return_value_strlen_6);
        }

      }

    }

    return (void *)h;
  }
}

// raw_video
// file libng/writefile.c line 497
static signed int raw_video(void *handle, struct ng_video_buf *buf)
{
  struct raw_handle *h = (struct raw_handle *)handle;
  signed long int return_value_write_1;
  signed long int return_value_write_2;
  if(!(h->vpriv == ((struct raw_priv *)NULL)))
  {
    if(!(h->vpriv->yuv4mpeg == 0))
      switch(h->vpriv->yuv4mpeg)
      {
        case 1:
        {
          return_value_write_1=write(h->fd, (const void *)"FRAME\n", (unsigned long int)6);
          if(!(return_value_write_1 == 6l))
            return -1;

          break;
        }
        case 2:
        {
          return_value_write_2=write(h->fd, (const void *)"FRAME \n", (unsigned long int)7);
          if(!(return_value_write_2 == 7l))
            return -1;

        }
      }

  }

  signed long int return_value_write_3;
  return_value_write_3=write(h->fd, (const void *)buf->data, buf->size);
  if(!(buf->size == (unsigned long int)return_value_write_3))
    return -1;

  else
    return 0;
}

// read_config
// file ./common/channel.h line 76
void read_config(char *conffile, signed int *argc, char **argv)
{
  struct list_head *item;
  char filename[100l];
  char *val;
  signed int i;
  if(!(conffile == ((char *)NULL)))
  {
    signed int return_value_cfg_parse_file_1;
    return_value_cfg_parse_file_1=cfg_parse_file(conffile);
    if(return_value_cfg_parse_file_1 == 0)
      have_config = 1;

  }

  else
  {
    char *return_value_getenv_2;
    return_value_getenv_2=getenv("HOME");
    sprintf(filename, "%.*s/%s", (signed int)sizeof(char [100l]) /*100ul*/  - 8, return_value_getenv_2, (const void *)".xawtv");
    signed int return_value_cfg_parse_file_3;
    return_value_cfg_parse_file_3=cfg_parse_file("/etc/X11/xawtvrc");
    if(return_value_cfg_parse_file_3 == 0)
      have_config = 1;

    signed int return_value_cfg_parse_file_4;
    return_value_cfg_parse_file_4=cfg_parse_file(filename);
    if(return_value_cfg_parse_file_4 == 0)
      have_config = 1;

  }
  if(!(argc == ((signed int *)NULL)))
    cfg_parse_options(argc, argv);

  val=cfg_get_str("global", "mixer");
  if(!(val == ((char *)NULL)))
  {
    mixer=strdup(val);
    signed int return_value_sscanf_5;
    return_value_sscanf_5=sscanf(mixer, "%31[^:]:%15s", (const void *)mixerdev, (const void *)mixerctl);
    if(!(return_value_sscanf_5 == 2))
    {
      strcpy(mixerdev, ng_dev.mixer);
      strncpy(mixerctl, val, (unsigned long int)15);
      mixerctl[(signed long int)15] = (char)0;
    }

  }

  val=cfg_get_str("global", "midi");
  if(!(val == ((char *)NULL)))
    midi=strdup(val);

  val=cfg_get_str("global", "freqtab");
  signed int return_value_strcasecmp_6;
  if(!(val == ((char *)NULL)))
  {
    i = 0;
    for( ; !((chanlists + (signed long int)i)->name == ((char *)NULL)); i = i + 1)
    {
      return_value_strcasecmp_6=strcasecmp(val, (chanlists + (signed long int)i)->name);
      if(return_value_strcasecmp_6 == 0)
        break;

    }
    if(!((chanlists + (signed long int)i)->name == ((char *)NULL)))
      freq_newtab(i);

    else
      fprintf(stderr, "invalid value for freqtab: %s\n", val);
  }

  val=cfg_get_str("global", "fullscreen");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf_7;
    return_value_sscanf_7=sscanf(val, "%d x %d", &fs_width, &fs_height);
    if(!(return_value_sscanf_7 == 2))
    {
      fprintf(stderr, "invalid value for fullscreen: %s\n", val);
      fs_height = 0;
      fs_width = fs_height;
    }

  }

  val=cfg_get_str("global", "pixsize");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf_8;
    return_value_sscanf_8=sscanf(val, "%d x %d", &pix_width, &pix_height);
    if(!(return_value_sscanf_8 == 2))
    {
      fprintf(stderr, "invalid value for pixsize: %s\n", val);
      pix_width = 128;
      pix_height = 96;
    }

  }

  i=cfg_get_int("global", "pixcols");
  if(!(i == -1))
    pix_cols = i;

  val=cfg_get_str("global", "wm-off-by");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf_9;
    return_value_sscanf_9=sscanf(val, "%d %d", &fs_xoff, &fs_yoff);
    if(!(return_value_sscanf_9 == 2))
    {
      fprintf(stderr, "invalid value for wm-off-by: %s\n", val);
      fs_yoff = 0;
      fs_xoff = fs_yoff;
    }

  }

  val=cfg_get_str("global", "ratio");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf_10;
    return_value_sscanf_10=sscanf(val, "%d:%d", &ng_ratio_x, &ng_ratio_y);
    if(!(return_value_sscanf_10 == 2))
    {
      fprintf(stderr, "invalid value for ratio: %s\n", val);
      ng_ratio_y = 0;
      ng_ratio_x = ng_ratio_y;
    }

  }

  i=cfg_get_int("global", "jpeg-quality");
  if(!(i == -1))
    ng_jpeg_quality = i;

  val=cfg_get_str("global", "keypad-ntsc");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      keypad_ntsc = i;

  }

  val=cfg_get_str("global", "keypad-partial");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      keypad_partial = i;

  }

  val=cfg_get_str("global", "osd");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      use_osd = i;

  }

  val=cfg_get_str("global", "osd-position");
  signed int return_value_sscanf_11;
  if(!(val == ((char *)NULL)))
  {
    return_value_sscanf_11=sscanf(val, "%d , %d", &osd_x, &osd_y);
    if(!(return_value_sscanf_11 == 2))
      fprintf(stderr, "invalid values for osd-position: %s\n", val);

  }

  val=cfg_get_str("global", "use-wm-fullscreen");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      use_wm_fullscreen = i;

  }

  val=cfg_get_str("global", "mov-driver");
  if(!(val == ((char *)NULL)))
    mov_driver = val;

  val=cfg_get_str("global", "mov-video");
  if(!(val == ((char *)NULL)))
    mov_video = val;

  val=cfg_get_str("global", "mov-fps");
  if(!(val == ((char *)NULL)))
    mov_fps = val;

  val=cfg_get_str("global", "mov-audio");
  if(!(val == ((char *)NULL)))
    mov_audio = val;

  val=cfg_get_str("global", "mov-rate");
  if(!(val == ((char *)NULL)))
    mov_rate = val;

  val=cfg_get_str("global", "filter");
  if(!(val == ((char *)NULL)))
  {
    item = (&ng_filters)->next;
    for( ; !(item == &ng_filters); item = item->next)
    {
      struct ng_filter *f = (struct ng_filter *)((char *)item - (signed long int)(unsigned long int)&((struct ng_filter *)0)->list);
      signed int return_value_strcasecmp_12;
      return_value_strcasecmp_12=strcasecmp(f->name, val);
      if(return_value_strcasecmp_12 == 0)
        cur_filter = f;

    }
  }

}

// read_sim
// file common/vbi-sim.c line 301
static void read_sim(unsigned char *raw_data, struct anonymous_98 *sliced_data, signed int *lines, double *timestamp)
{
  unsigned char *buf;
  double start;
  double inc;
  signed int i;
  memset((void *)raw_data, 0, (unsigned long int)((sim.count[(signed long int)0] + sim.count[(signed long int)1]) * sim.bytes_per_line));
  *timestamp = sim_time;
  if(sim.scanning == 525)
    sim_time = sim_time + (double)1001 / 30000.0;

  else
    sim_time = sim_time + (double)1 / 25.0;
  start = (double)sim.offset / (double)sim.sampling_rate;
  inc = (double)1 / (double)sim.sampling_rate;
  signed int return_value_odd_1;
  signed int return_value_odd_2;
  double return_value_cc_sim_3;
  double return_value_wss525_sim_4;
  signed int return_value_odd_5;
  signed int return_value_odd_6;
  double return_value_cc_sim_7;
  double return_value_wss625_sim_8;
  if(sim.scanning == 525)
  {
    buf = raw_data + (signed long int)((21 - sim.start[(signed long int)0]) * sim.bytes_per_line);
    i = 0;
    for( ; !(i >= sim.bytes_per_line); i = i + 1)
    {
      return_value_odd_1=odd((signed int)caption_text[(signed long int)caption_i]);
      return_value_odd_2=odd((signed int)caption_text[(signed long int)(caption_i + (unsigned int)1)]);
      return_value_cc_sim_3=cc_sim(start + (double)i * inc, (double)(15734 * 32), (unsigned char)return_value_odd_1, (unsigned char)return_value_odd_2);
      buf[(signed long int)i] = (unsigned char)(return_value_cc_sim_3 * (double)110 + (double)60);
    }
    caption_i = caption_i + (unsigned int)2;
    if((unsigned long int)caption_i >= 35ul)
      caption_i = (unsigned int)0;

    const signed int poly = (1 << 6) + (1 << 1) + 1;
    signed int b0 = 1;
    signed int b1 = 1;
    signed int bits = (b0 << 13) + (b1 << 12);
    signed int crc;
    signed int j;
    crc = ((1 << 6) - 1 << 14 + 6) + (bits << 6);
    j = (14 + 6) - 1;
    for( ; j >= 0; j = j - 1)
      if(!((64 << j & crc) == 0))
        crc = crc ^ poly << j;

    bits = bits << 6;
    bits = bits | crc;
    buf = raw_data + (signed long int)((20 - sim.start[(signed long int)0]) * sim.bytes_per_line);
    i = 0;
    for( ; !(i >= sim.bytes_per_line); i = i + 1)
    {
      return_value_wss525_sim_4=wss525_sim(start + (double)i * inc, (double)447443, (unsigned int)bits);
      buf[(signed long int)i] = (unsigned char)(return_value_wss525_sim_4 * (double)110 + (double)60);
    }
  }

  else
  {
    buf = raw_data + (signed long int)((22 - sim.start[(signed long int)0]) * sim.bytes_per_line);
    i = 0;
    for( ; !(i >= sim.bytes_per_line); i = i + 1)
    {
      return_value_odd_5=odd((signed int)caption_text[(signed long int)caption_i]);
      return_value_odd_6=odd((signed int)caption_text[(signed long int)(caption_i + (unsigned int)1)]);
      return_value_cc_sim_7=cc_sim(start + (double)i * inc, (double)(15625 * 32), (unsigned char)return_value_odd_5, (unsigned char)return_value_odd_6);
      buf[(signed long int)i] = (unsigned char)(return_value_cc_sim_7 * (double)110 + (double)60);
    }
    caption_i = caption_i + (unsigned int)2;
    if((unsigned long int)caption_i >= 35ul)
      caption_i = (unsigned int)0;

    signed int g0 = 1;
    signed int g1 = 2;
    signed int g2 = 3;
    signed int g3 = 4;
    signed int read_sim__1__2__2__bits = (g3 << 11) + (g2 << 8) + (g1 << 4) + g0;
    buf = raw_data + (signed long int)((23 - sim.start[(signed long int)0]) * sim.bytes_per_line);
    i = 0;
    for( ; !(i >= sim.bytes_per_line); i = i + 1)
    {
      return_value_wss625_sim_8=wss625_sim(start + (double)i * inc, (double)(15625 * 320), (unsigned int)read_sim__1__2__2__bits);
      buf[(signed long int)i] = (unsigned char)(return_value_wss625_sim_8 * (double)110 + (double)60);
    }
    signed int line;
    signed int read_sim__1__2__3__count;
    unsigned char *text;
    buf = raw_data;
    line = sim.start[(signed long int)0];
    read_sim__1__2__3__count = sim.count[(signed long int)0];
    for( ; read_sim__1__2__3__count >= 1; buf = buf + (signed long int)sim.bytes_per_line)
    {
      if(line >= 7 && !(line >= 16) || line >= 19 && !(line >= 22))
      {
        text=ttx_next();
        i = 0;
        for( ; !(i >= sim.bytes_per_line); i = i + 1)
        {
          double return_value_ttx_sim_9;
          return_value_ttx_sim_9=ttx_sim(start + (double)i * inc, (double)(15625 * 444), text);
          buf[(signed long int)i] = (unsigned char)(return_value_ttx_sim_9 * (double)110 + (double)60);
        }
      }

      line = line + 1;
      read_sim__1__2__3__count = read_sim__1__2__3__count - 1;
    }
    line = sim.start[(signed long int)1];
    read_sim__1__2__3__count = sim.count[(signed long int)1];
    for( ; read_sim__1__2__3__count >= 1; buf = buf + (signed long int)sim.bytes_per_line)
    {
      if(line >= 320 && !(line >= 329) || line >= 332 && !(line >= 336))
      {
        text=ttx_next();
        i = 0;
        for( ; !(i >= sim.bytes_per_line); i = i + 1)
        {
          double return_value_ttx_sim_10;
          return_value_ttx_sim_10=ttx_sim(start + (double)i * inc, (double)(15625 * 444), text);
          buf[(signed long int)i] = (unsigned char)(return_value_ttx_sim_10 * (double)110 + (double)60);
        }
      }

      line = line + 1;
      read_sim__1__2__3__count = read_sim__1__2__3__count - 1;
    }
  }
  *lines=vbi_raw_decode(&sim, raw_data, sliced_data);
}

// readbuf
// file common/alsa_stream.c line 434
static signed long int readbuf(struct _snd_pcm *handle, char *buf, signed long int len)
{
  signed long int r;
  r=snd_pcm_readi(handle, (void *)buf, (unsigned long int)len);
  const char *return_value_snd_strerror_2;
  if(!(r == -11l) && !(r >= 0l))
  {
    signed int return_value_snd_pcm_recover_1;
    return_value_snd_pcm_recover_1=snd_pcm_recover(handle, (signed int)r, 0);
    r = (signed long int)return_value_snd_pcm_recover_1;
    if(!(r >= 0l))
    {
      return_value_snd_strerror_2=snd_strerror((signed int)r);
      fprintf(error_fp, "alsa: overrun recover error: %s\n", return_value_snd_strerror_2);
    }

  }

  return r;
}

// rec_work
// file x11/xt.h line 146
char rec_work(void *client_data)
{
  struct ng_video_buf *buf;
  if(!(movie_blit == 0))
  {
    buf = (struct ng_video_buf *)(void *)0;
    movie_grab_put_video((struct movie_handle *)movie_state, &buf);
    if(!(buf == ((struct ng_video_buf *)NULL)))
      video_gd_blitframe(&vh, buf);

  }

  else
    movie_grab_put_video((struct movie_handle *)movie_state, (struct ng_video_buf **)(void *)0);
  return (char)0;
}

// record_audio_thread
// file common/capture.c line 371
static void * record_audio_thread(void *arg)
{
  struct movie_handle *h = (struct movie_handle *)arg;
  struct ng_audio_buf *buf;
  signed int return_value_getpid_1;
  if(!(debug == 0))
  {
    return_value_getpid_1=getpid();
    fprintf(stderr, "record_audio_thread start [pid=%d]\n", return_value_getpid_1);
  }

  buf=h->dsp->read(h->hdsp, (signed long int)h->stopby);
  if(!(buf == ((struct ng_audio_buf *)NULL)))
  {
    if(!(buf->size == 0))
    {
      h->ats = (unsigned long int)buf->info.ts;
      signed long int return_value_ng_get_timestamp_2;
      return_value_ng_get_timestamp_2=ng_get_timestamp();
      h->rts = (unsigned long int)return_value_ng_get_timestamp_2 - h->start;
      h->rdrift = h->rts - h->ats;
      h->vdrift = h->vts - h->ats;
      signed int return_value_fifo_put_3;
      return_value_fifo_put_3=fifo_put(&h->afifo, (void *)buf);
      if(!(return_value_fifo_put_3 == 0))
        free((void *)buf);

    }

  }

  fifo_put(&h->afifo, (void *)0);
  if(!(debug == 0))
    fprintf(stderr, "record_audio_thread done\n");

  return (void *)0;
}

// redblue_swap
// file libng/color_packed.c line 25
static void redblue_swap(unsigned char *dest, unsigned char *src, signed int p)
{
  unsigned char *s = src;
  unsigned char *d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    unsigned char *tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = s[(signed long int)2];
    unsigned char *tmp_post_3 = d;
    d = d + 1l;
    *tmp_post_3 = s[(signed long int)1];
    unsigned char *tmp_post_4 = d;
    d = d + 1l;
    *tmp_post_4 = s[(signed long int)0];
    s = s + (signed long int)3;
  }
  while((_Bool)1);
}

// refresh_timer
// file x11/x11.c line 462
static void refresh_timer(void *clientData, unsigned long int *id)
{
  unsigned long int win;
  struct anonymous_0 *return_value_XtScreen_1;
  return_value_XtScreen_1=XtScreen(video);
  win = return_value_XtScreen_1->root;
  struct _XDisplay *refresh_timer__1__dpy;
  refresh_timer__1__dpy=XtDisplay(video);
  struct anonymous_135 xswa;
  unsigned long int mask;
  unsigned long int tmp;
  if(move == 0 && visibility == 0 && !(wmap == 0))
  {
    if(debug >= 2)
      fprintf(stderr, "video: refresh skipped\n");

  }

  else
  {
    if(debug >= 2)
      fprintf(stderr, "video: refresh\n");

    overlay_refresh = (unsigned long int)0;
    if(!(visibility == 2) && !(wmap == 0))
      did_refresh = 1;

    xswa.override_redirect = 1;
    xswa.backing_store = 0;
    xswa.save_under = 0;
    mask = (unsigned long int)(1L << 10 | 1L << 6 | 1L << 9);
    tmp=XCreateWindow(refresh_timer__1__dpy, win, 0, 0, swidth, sheight, (unsigned int)0, (signed int)0L, (unsigned int)1, ((struct anonymous_8 *)NULL), mask, &xswa);
    XMapWindow(refresh_timer__1__dpy, tmp);
    XUnmapWindow(refresh_timer__1__dpy, tmp);
    XDestroyWindow(refresh_timer__1__dpy, tmp);
    move = 0;
  }
}

// resize_event
// file x11/motv.c line 319
static void resize_event(struct _WidgetRec *widget, void *client_data, union _XEvent *event, char *d)
{
  if(event->type == 22)
  {
    static signed int first = 1;
    if(!(first == 0))
    {
      video_gd_init(tv, args.gl);
      first = 0;
    }

    _Bool tmp_if_expr_3;
    static signed int height = 0;
    static signed int width = 0;
    if(!(width == event->xconfigure.width))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = height != event->xconfigure.height ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      width = event->xconfigure.width;
      height = event->xconfigure.height;
      video_gd_configure(width, height);
      struct _XDisplay *return_value_XtDisplay_1;
      return_value_XtDisplay_1=XtDisplay(tv);
      unsigned long int return_value_XtWindow_2;
      return_value_XtWindow_2=XtWindow(tv);
      XClearWindow(return_value_XtDisplay_1, return_value_XtWindow_2);
    }

  }

}

// rgb15_be_gray
// file libng/color_packed.c line 137
static void rgb15_be_gray(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  signed int r;
  signed int g;
  signed int b;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    r = ((signed int)src[(signed long int)0] & 0x7c) >> 2;
    g = ((signed int)src[(signed long int)0] & 0x03) << 3 | ((signed int)src[(signed long int)1] & 0xe0) >> 5;
    b = (signed int)src[(signed long int)1] & 0x1f;
    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned char)((3 * r + 6 * g + b) / 10 << 3);
    src = src + (signed long int)2;
  }
  while((_Bool)1);
}

// rgb15_native_gray
// file libng/color_packed.c line 119
static void rgb15_native_gray(unsigned char * restrict dest, unsigned char *s, signed int p)
{
  signed int r;
  signed int g;
  signed int b;
  unsigned short int * restrict src = (unsigned short int *)s;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    r = ((signed int)src[(signed long int)0] & 0x7c00) >> 10;
    g = ((signed int)src[(signed long int)0] & 0x03e0) >> 5;
    b = (signed int)src[(signed long int)0] & 0x001f;
    unsigned char * restrict tmp_post_2 = dest;
    dest = dest + 1l;
    *tmp_post_2 = (unsigned char)((3 * r + 6 * g + b) / 10 << 3);
    src = src + 1l;
  }
  while((_Bool)1);
}

// rgb32_to_bgr24
// file libng/color_packed.c line 85
static void rgb32_to_bgr24(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    s = s + 1l;
    unsigned char * restrict tmp_post_2 = s;
    s = s + 1l;
    d[(signed long int)2] = *tmp_post_2;
    unsigned char * restrict tmp_post_3 = s;
    s = s + 1l;
    d[(signed long int)1] = *tmp_post_3;
    unsigned char * restrict tmp_post_4 = s;
    s = s + 1l;
    d[(signed long int)0] = *tmp_post_4;
    d = d + (signed long int)3;
  }
  while((_Bool)1);
}

// rgb32_to_lut2
// file libng/color_lut.c line 56
static void rgb32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)1]] | ng_lut_green[(signed long int)src[(signed long int)2]] | ng_lut_blue[(signed long int)src[(signed long int)3]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// rgb32_to_lut4
// file libng/color_lut.c line 122
static void rgb32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)1]] | ng_lut_green[(signed long int)src[(signed long int)2]] | ng_lut_blue[(signed long int)src[(signed long int)3]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// rgb32_to_rgb24
// file libng/color_packed.c line 70
static void rgb32_to_rgb24(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    s = s + 1l;
    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_3 = s;
    s = s + 1l;
    *tmp_post_2 = *tmp_post_3;
    unsigned char * restrict tmp_post_4 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_5 = s;
    s = s + 1l;
    *tmp_post_4 = *tmp_post_5;
    unsigned char * restrict tmp_post_6 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_7 = s;
    s = s + 1l;
    *tmp_post_6 = *tmp_post_7;
  }
  while((_Bool)1);
}

// save_config
// file ./common/channel.h line 78
void save_config(void)
{
  struct ng_attribute *attr;
  char filename1[100l];
  char filename2[100l];
  struct _IO_FILE *fp;
  signed int i;
  char *return_value_getenv_1;
  return_value_getenv_1=getenv("HOME");
  sprintf(filename1, "%s/%s", return_value_getenv_1, (const void *)".xawtv");
  char *return_value_getenv_2;
  return_value_getenv_2=getenv("HOME");
  sprintf(filename2, "%s/%s", return_value_getenv_2, (const void *)".xawtv~");
  unlink(filename2);
  signed int return_value_link_3;
  return_value_link_3=link(filename1, filename2);
  if(return_value_link_3 == 0)
    unlink(filename1);

  fp=fopen(filename1, "w");
  signed int return_value_ng_attr_int2percent_13;
  signed int return_value_ng_attr_int2percent_14;
  signed int return_value_ng_attr_int2percent_15;
  signed int return_value_ng_attr_int2percent_16;
  struct ng_attribute *return_value_ng_attr_byid_18;
  const char *return_value_ng_attr_getstr_19;
  struct ng_attribute *return_value_ng_attr_byid_20;
  const char *return_value_ng_attr_getstr_21;
  const char *return_value_int_to_str_23;
  signed int return_value_ng_attr_int2percent_24;
  signed int return_value_ng_attr_int2percent_25;
  signed int return_value_ng_attr_int2percent_26;
  signed int return_value_ng_attr_int2percent_27;
  if(fp == ((struct _IO_FILE *)NULL))
    fprintf(stderr, "can't open config file %s\n", (const void *)filename1);

  else
  {
    fprintf(fp, "[global]\n");
    if(!(fs_height == 0) && !(fs_width == 0))
      fprintf(fp, "fullscreen = %d x %d\n", fs_width, fs_height);

    if(!(fs_xoff == 0) || !(fs_yoff == 0))
      fprintf(fp, "wm-off-by = %+d%+d\n", fs_xoff, fs_yoff);

    if(!(ng_ratio_x == 0) || !(ng_ratio_y == 0))
      fprintf(fp, "ratio = %d:%d\n", ng_ratio_x, ng_ratio_y);

    fprintf(fp, "freqtab = %s\n", (chanlists + (signed long int)chantab)->name);
    fprintf(fp, "pixsize = %d x %d\n", pix_width, pix_height);
    fprintf(fp, "pixcols = %d\n", pix_cols);
    fprintf(fp, "jpeg-quality = %d\n", ng_jpeg_quality);
    const char *return_value_int_to_str_4;
    return_value_int_to_str_4=int_to_str(keypad_ntsc, booltab);
    fprintf(fp, "keypad-ntsc = %s\n", return_value_int_to_str_4);
    const char *return_value_int_to_str_5;
    return_value_int_to_str_5=int_to_str(keypad_partial, booltab);
    fprintf(fp, "keypad-partial = %s\n", return_value_int_to_str_5);
    const char *return_value_int_to_str_6;
    return_value_int_to_str_6=int_to_str(use_osd, booltab);
    fprintf(fp, "osd = %s\n", return_value_int_to_str_6);
    fprintf(fp, "osd-position = %d , %d\n", osd_x, osd_y);
    const char *return_value_int_to_str_7;
    return_value_int_to_str_7=int_to_str(use_wm_fullscreen, booltab);
    fprintf(fp, "use-wm-fullscreen = %s\n", return_value_int_to_str_7);
    if(!(mixer == ((char *)NULL)))
      fprintf(fp, "mixer = %s\n", mixer);

    if(!(midi == ((char *)NULL)))
      fprintf(fp, "midi = %s\n", midi);

    if(!(mov_driver == ((char *)NULL)))
      fprintf(fp, "mov-driver = %s\n", mov_driver);

    if(!(mov_video == ((char *)NULL)))
      fprintf(fp, "mov-video = %s\n", mov_video);

    if(!(mov_fps == ((char *)NULL)))
      fprintf(fp, "mov-fps = %s\n", mov_fps);

    if(!(mov_audio == ((char *)NULL)))
      fprintf(fp, "mov-audio = %s\n", mov_audio);

    if(!(mov_rate == ((char *)NULL)))
      fprintf(fp, "mov-rate = %s\n", mov_rate);

    fprintf(fp, "\n");
    if(nlaunch >= 1)
    {
      fprintf(fp, "[launch]\n");
      i = 0;
      for( ; !(i >= nlaunch); i = i + 1)
        fprintf(fp, "%s = %s, %s\n", (launch + (signed long int)i)->name, (launch + (signed long int)i)->key, (launch + (signed long int)i)->cmdline);
      fprintf(fp, "\n");
    }

    event_writeconfig(fp);
    fprintf(fp, "# [Station name]\n");
    fprintf(fp, "# capture = overlay | grabdisplay | on | off\n");
    fprintf(fp, "# input = Television | Composite1 | S-Video | ...\n");
    fprintf(fp, "# norm = PAL | NTSC | SECAM | ... \n");
    fprintf(fp, "# channel = #\n");
    fprintf(fp, "# fine = # (-128..+127)\n");
    fprintf(fp, "# key = keysym | modifier+keysym\n");
    fprintf(fp, "# color = #\n");
    fprintf(fp, "# bright = #\n");
    fprintf(fp, "# hue = #\n");
    fprintf(fp, "# contrast = #\n");
    fprintf(fp, "\n");
    fprintf(fp, "[defaults]\n");
    fprintf(fp, "group = %s\n", defaults.group);
    struct ng_attribute *return_value_ng_attr_byid_8;
    return_value_ng_attr_byid_8=ng_attr_byid(attrs, 1);
    const char *return_value_ng_attr_getstr_9;
    return_value_ng_attr_getstr_9=ng_attr_getstr(return_value_ng_attr_byid_8, cur_attrs[(signed long int)1]);
    fprintf(fp, "norm = %s\n", return_value_ng_attr_getstr_9);
    struct ng_attribute *return_value_ng_attr_byid_10;
    return_value_ng_attr_byid_10=ng_attr_byid(attrs, 2);
    const char *return_value_ng_attr_getstr_11;
    return_value_ng_attr_getstr_11=ng_attr_getstr(return_value_ng_attr_byid_10, cur_attrs[(signed long int)2]);
    fprintf(fp, "input = %s\n", return_value_ng_attr_getstr_11);
    const char *return_value_int_to_str_12;
    return_value_int_to_str_12=int_to_str(cur_capture, captab);
    fprintf(fp, "capture = %s\n", return_value_int_to_str_12);
    attr=ng_attr_byid(attrs, 6);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[6l]))
      {
        return_value_ng_attr_int2percent_13=ng_attr_int2percent(attr, cur_attrs[(signed long int)6]);
        fprintf(fp, "color = %d%%\n", return_value_ng_attr_int2percent_13);
      }

    }

    attr=ng_attr_byid(attrs, 7);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[7l]))
      {
        return_value_ng_attr_int2percent_14=ng_attr_int2percent(attr, cur_attrs[(signed long int)7]);
        fprintf(fp, "bright = %d%%\n", return_value_ng_attr_int2percent_14);
      }

    }

    attr=ng_attr_byid(attrs, 8);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[8l]))
      {
        return_value_ng_attr_int2percent_15=ng_attr_int2percent(attr, cur_attrs[(signed long int)8]);
        fprintf(fp, "hue = %d%%\n", return_value_ng_attr_int2percent_15);
      }

    }

    attr=ng_attr_byid(attrs, 9);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[9l]))
      {
        return_value_ng_attr_int2percent_16=ng_attr_int2percent(attr, cur_attrs[(signed long int)9]);
        fprintf(fp, "contrast = %d%%\n", return_value_ng_attr_int2percent_16);
      }

    }

    fprintf(fp, "\n");
    i = 0;
    for( ; !(i >= count); i = i + 1)
    {
      fprintf(fp, "[%s]\n", channels[(signed long int)i]->name);
      if(!(channels[(signed long int)i]->cname == ((char *)NULL)))
      {
        struct CHANLIST *tmp_if_expr_17;
        if(!(chantab == -1))
          tmp_if_expr_17 = (chanlists + (signed long int)chantab)->list;

        else
          tmp_if_expr_17 = (struct CHANLIST *)(void *)0;
        fprintf(fp, "channel = %s\n", (tmp_if_expr_17 + (signed long int)channels[(signed long int)i]->channel)->name);
        if(!(channels[(signed long int)i]->fine == 0))
          fprintf(fp, "fine = %+d\n", channels[(signed long int)i]->fine);

      }

      else
        fprintf(fp, "freq = %.2f\n", (float)channels[(signed long int)i]->freq / (float)16);
      if(!(channels[(signed long int)i]->norm == cur_attrs[1l]))
      {
        return_value_ng_attr_byid_18=ng_attr_byid(attrs, 1);
        return_value_ng_attr_getstr_19=ng_attr_getstr(return_value_ng_attr_byid_18, channels[(signed long int)i]->norm);
        fprintf(fp, "norm = %s\n", return_value_ng_attr_getstr_19);
      }

      if(!(channels[(signed long int)i]->input == cur_attrs[2l]))
      {
        return_value_ng_attr_byid_20=ng_attr_byid(attrs, 2);
        return_value_ng_attr_getstr_21=ng_attr_getstr(return_value_ng_attr_byid_20, channels[(signed long int)i]->input);
        fprintf(fp, "input = %s\n", return_value_ng_attr_getstr_21);
      }

      if(!(channels[(signed long int)i]->key == ((char *)NULL)))
        fprintf(fp, "key = %s\n", channels[(signed long int)i]->key);

      signed int return_value_strcmp_22;
      return_value_strcmp_22=strcmp(channels[(signed long int)i]->group, defaults.group);
      if(!(return_value_strcmp_22 == 0))
        fprintf(fp, "group = %s\n", channels[(signed long int)i]->group);

      if(!(channels[(signed long int)i]->midi == 0))
        fprintf(fp, "midi = %d\n", channels[(signed long int)i]->midi);

      if(!(channels[(signed long int)i]->capture == cur_capture))
      {
        return_value_int_to_str_23=int_to_str(channels[(signed long int)i]->capture, captab);
        fprintf(fp, "capture = %s\n", return_value_int_to_str_23);
      }

      attr=ng_attr_byid(attrs, 6);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[6l] == channels[(signed long int)i]->color))
        {
          return_value_ng_attr_int2percent_24=ng_attr_int2percent(attr, channels[(signed long int)i]->color);
          fprintf(fp, "color = %d%%\n", return_value_ng_attr_int2percent_24);
        }

      }

      attr=ng_attr_byid(attrs, 7);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[7l] == channels[(signed long int)i]->bright))
        {
          return_value_ng_attr_int2percent_25=ng_attr_int2percent(attr, channels[(signed long int)i]->bright);
          fprintf(fp, "bright = %d%%\n", return_value_ng_attr_int2percent_25);
        }

      }

      attr=ng_attr_byid(attrs, 8);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[8l] == channels[(signed long int)i]->hue))
        {
          return_value_ng_attr_int2percent_26=ng_attr_int2percent(attr, channels[(signed long int)i]->hue);
          fprintf(fp, "hue = %d%%\n", return_value_ng_attr_int2percent_26);
        }

      }

      attr=ng_attr_byid(attrs, 9);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[9l] == channels[(signed long int)i]->contrast))
        {
          return_value_ng_attr_int2percent_27=ng_attr_int2percent(attr, channels[(signed long int)i]->contrast);
          fprintf(fp, "contrast = %d%%\n", return_value_ng_attr_int2percent_27);
        }

      }

      fprintf(fp, "\n");
    }
    fclose(fp);
  }
}

// scale_rgb_buffer
// file x11/motv.c line 2661
static struct ng_video_buf * scale_rgb_buffer(struct ng_video_buf *in, signed int scale)
{
  struct ng_video_fmt scale_rgb_buffer__1__fmt;
  struct ng_video_buf *buf;
  char *src;
  char *dst;
  unsigned int x;
  unsigned int y;
  scale_rgb_buffer__1__fmt = in->fmt;
  scale_rgb_buffer__1__fmt.width = in->fmt.width / (unsigned int)scale;
  scale_rgb_buffer__1__fmt.height = in->fmt.height / (unsigned int)scale;
  for( ; !((3u & scale_rgb_buffer__1__fmt.width) == 0u); scale_rgb_buffer__1__fmt.width = scale_rgb_buffer__1__fmt.width + 1u)
    ;
  scale_rgb_buffer__1__fmt.bytesperline = scale_rgb_buffer__1__fmt.width * (unsigned int)3;
  buf=ng_malloc_video_buf(&scale_rgb_buffer__1__fmt, (signed int)(scale_rgb_buffer__1__fmt.width * scale_rgb_buffer__1__fmt.height * (unsigned int)3));
  dst = (char *)buf->data;
  y = (unsigned int)0;
  for( ; !(y >= scale_rgb_buffer__1__fmt.height); y = y + 1u)
  {
    src = (char *)(in->data + (signed long int)(y * (unsigned int)scale * in->fmt.bytesperline));
    x = (unsigned int)0;
    for( ; !(x >= scale_rgb_buffer__1__fmt.width); x = x + 1u)
    {
      dst[(signed long int)0] = src[(signed long int)0];
      dst[(signed long int)1] = src[(signed long int)1];
      dst[(signed long int)2] = src[(signed long int)2];
      dst = dst + (signed long int)3;
      src = src + (signed long int)(3 * scale);
    }
  }
  return buf;
}

// scan_timeout
// file x11/xt.c line 486
static void scan_timeout(void *client_data, unsigned long int *id)
{
  scan_timer = (unsigned long int)0;
  if(!((4 & f_drv) == 0))
  {
    signed int return_value;
    return_value=drv->is_tuned(h_drv);
    if(return_value == 0)
    {
      do_va_cmd(2, (const void *)"setchannel", (const void *)"next");
      scan_timer=XtAppAddTimeOut(app_context, (unsigned long int)100, scan_timeout, (void *)0);
    }

  }

}

// scroll_cb
// file x11/motv.c line 978
static void scroll_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct motif_attribute *a = (struct motif_attribute *)clientdata;
  signed int ret;
  char val[10l];
  XmScaleGetValue(a->widget, &ret);
  sprintf(val, "%d", ret);
  do_va_cmd(3, (const void *)"setattr", a->attr->name, (const void *)val);
}

// segfault
// file x11/xt.c line 757
static void segfault(signed int signal)
{
  signed int return_value_getpid_1;
  return_value_getpid_1=getpid();
  fprintf(stderr, "[pid=%d] segfault catched, aborting\n", return_value_getpid_1);
  abort();
}

// send_xscreensaver_command
// file jwz/remote.c line 135
static signed int send_xscreensaver_command(struct _XDisplay *dpy, unsigned long int command, signed long int arg, unsigned long int *window_ret, char **error_ret)
{
  char *v = ((char *)NULL);
  unsigned long int window;
  window=find_screensaver_window(dpy, &v);
  struct anonymous_117 xgwa;
  char send_xscreensaver_command__1__err[2048l];
  if(!(window_ret == ((unsigned long int *)NULL)))
    *window_ret = window;

  unsigned long int return_value_strlen_2;
  if(window == 0ul)
  {
    sprintf(send_xscreensaver_command__1__err, "no screensaver is running on display %s", ((struct anonymous_10 *)dpy)->display_name);
    if(!(error_ret == ((char **)NULL)))
    {
      *error_ret=strdup(send_xscreensaver_command__1__err);
      return -1;
    }

    if(command == XA_EXIT)
      return 1;

    fprintf(stderr, "%s: %s\n", progname, (const void *)send_xscreensaver_command__1__err);
    return -1;
  }

  else
  {
    XGetWindowAttributes(dpy, window, &xgwa);
    XSelectInput(dpy, window, xgwa.your_event_mask | 1L << 22);
    if(command == XA_SCREENSAVER_STATUS || command == XA_SCREENSAVER_VERSION)
    {
      struct anonymous_116 hint;
      memset((void *)&hint, 0, sizeof(struct anonymous_116) /*16ul*/ );
      _Bool tmp_if_expr_1;
      if(v == ((char *)NULL))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = !(*v != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        sprintf(send_xscreensaver_command__1__err, "version property not set on window 0x%x?", (unsigned int)window);
        if(!(error_ret == ((char **)NULL)))
          *error_ret=strdup(send_xscreensaver_command__1__err);

        else
          fprintf(stderr, "%s: %s\n", progname, (const void *)send_xscreensaver_command__1__err);
        return -1;
      }

      XGetClassHint(dpy, window, &hint);
      if(hint.res_class == ((char *)NULL))
      {
        sprintf(send_xscreensaver_command__1__err, "class hints not set on window 0x%x?", (unsigned int)window);
        if(!(error_ret == ((char **)NULL)))
          *error_ret=strdup(send_xscreensaver_command__1__err);

        else
          fprintf(stderr, "%s: %s\n", progname, (const void *)send_xscreensaver_command__1__err);
        return -1;
      }

      fprintf(stdout, "%s %s", hint.res_class, v);
      if(!(command == XA_SCREENSAVER_STATUS))
        fprintf(stdout, "\n");

      else
      {
        unsigned long int type;
        signed int format;
        unsigned long int nitems;
        unsigned long int bytesafter;
        unsigned int *data = ((unsigned int *)NULL);
        signed int return_value_XGetWindowProperty_4;
        return_value_XGetWindowProperty_4=XGetWindowProperty(dpy, (&((struct anonymous_10 *)dpy)->screens[(signed long int)0])->root, XA_SCREENSAVER_STATUS, (signed long int)0, (signed long int)999, 0, (unsigned long int)19, &type, &format, &nitems, &bytesafter, (unsigned char **)&data);
        if(return_value_XGetWindowProperty_4 == 0 && !(data == ((unsigned int *)NULL)) && !(type == 0ul))
        {
          unsigned long int blanked;
          signed long int tt;
          char *s;
          if(!(type == 19ul) || !(nitems >= 3ul))
          {

          STATUS_LOSE:
            ;
            if(!(data == ((unsigned int *)NULL)))
              free((void *)data);

            fprintf(stdout, "\n");
            fflush(stdout);
            fprintf(stderr, "bad status format on root window.\n");
            return -1;
          }

          blanked = (unsigned long int)data[(signed long int)0];
          tt = (signed long int)data[(signed long int)1];
          if(!(tt >= 666000001l))
            goto STATUS_LOSE;

          if(blanked == XA_BLANK)
            fputs(": screen blanked since ", stdout);

          else
            if(blanked == XA_LOCK)
              fputs(": screen locked since ", stdout);

            else
              if(blanked == 0ul)
                fputs(": screen non-blanked since ", stdout);

              else
                goto STATUS_LOSE;
          s=ctime(&tt);
          unsigned long int return_value_strlen_3;
          return_value_strlen_3=strlen(s);
          if((signed int)s[-1l + (signed long int)return_value_strlen_3] == 10)
          {
            return_value_strlen_2=strlen(s);
            s[(signed long int)(return_value_strlen_2 - (unsigned long int)1)] = (char)0;
          }

          fputs(s, stdout);
          signed int nhacks = (signed int)(nitems - (unsigned long int)2);
          signed int any = 0;
          signed int i = 0;
          for( ; !(i >= nhacks); i = i + 1)
            if(data[(signed long int)(2 + i)] >= 1u)
            {
              any = 1;
              break;
            }

          if(nhacks == 1 && !(any == 0))
            fprintf(stdout, " (hack #%ld)\n", (signed long int)data[(signed long int)2]);

          else
            if(!(any == 0))
            {
              fprintf(stdout, " (hacks: ");
              i = 0;
              for( ; !(i >= nhacks); i = i + 1)
              {
                fprintf(stdout, "#%ld", (signed long int)data[(signed long int)(2 + i)]);
                if(!(i == nhacks + -1))
                  fputs(", ", stdout);

              }
              fputs(")\n", stdout);
            }

            else
              fputs("\n", stdout);
          if(!(data == ((unsigned int *)NULL)))
            free((void *)data);

        }

        else
        {
          if(!(data == ((unsigned int *)NULL)))
            free((void *)data);

          fprintf(stdout, "\n");
          fflush(stdout);
          fprintf(stderr, "no saver status on root window.\n");
          return -1;
        }
      }
      return 1;
    }

    else
    {
      union _XEvent event;
      signed long int arg1 = arg;
      signed long int arg2 = (signed long int)0;
      if(!(arg >= 0l))
        abort();

      else
        if(arg == 0l && command == XA_SELECT)
          abort();

        else
          if(command == XA_DEMO && !(arg == 0l))
          {
            arg1 = (signed long int)300;
            arg2 = arg;
          }

      event.xany.type = 33;
      event.xclient.display = dpy;
      event.xclient.window = window;
      event.xclient.message_type = XA_SCREENSAVER;
      event.xclient.format = 32;
      memset((void *)&event.xclient.data, 0, sizeof(union anonymous_118) /*40ul*/ );
      event.xclient.data.l[(signed long int)0] = (signed long int)command;
      event.xclient.data.l[(signed long int)1] = arg1;
      event.xclient.data.l[(signed long int)2] = arg2;
      signed int return_value_XSendEvent_5;
      return_value_XSendEvent_5=XSendEvent(dpy, window, 0, 0L, &event);
      if(return_value_XSendEvent_5 == 0)
      {
        sprintf(send_xscreensaver_command__1__err, "XSendEvent(dpy, 0x%x ...) failed.\n", (unsigned int)window);
        if(!(error_ret == ((char **)NULL)))
          *error_ret=strdup(send_xscreensaver_command__1__err);

        else
          fprintf(stderr, "%s: %s\n", progname, (const void *)send_xscreensaver_command__1__err);
        return -1;
      }

    }
    XSync(dpy, 0);
    return 0;
  }
}

// server_xscreensaver_version
// file jwz/remote.c line 492
extern void server_xscreensaver_version(struct _XDisplay *dpy, char **version_ret, char **user_ret, char **host_ret)
{
  unsigned long int window;
  window=find_screensaver_window(dpy, ((char **)NULL));
  unsigned long int type;
  signed int format;
  unsigned long int nitems;
  unsigned long int bytesafter;
  if(!(version_ret == ((char **)NULL)))
    *version_ret = ((char *)NULL);

  if(!(user_ret == ((char **)NULL)))
    *user_ret = ((char *)NULL);

  if(!(host_ret == ((char **)NULL)))
    *host_ret = ((char *)NULL);

  if(!(window == 0ul))
  {
    if(!(version_ret == ((char **)NULL)))
    {
      char *v = ((char *)NULL);
      XGetWindowProperty(dpy, window, XA_SCREENSAVER_VERSION, (signed long int)0, (signed long int)1, 0, (unsigned long int)31, &type, &format, &nitems, &bytesafter, (unsigned char **)&v);
      if(!(v == ((char *)NULL)))
      {
        *version_ret=strdup(v);
        XFree((void *)v);
      }

    }

    if(!(host_ret == ((char **)NULL)) || !(user_ret == ((char **)NULL)))
    {
      char *id = ((char *)NULL);
      const char *user = ((const char *)NULL);
      const char *host = ((const char *)NULL);
      XGetWindowProperty(dpy, window, XA_SCREENSAVER_ID, (signed long int)0, (signed long int)512, 0, (unsigned long int)31, &type, &format, &nitems, &bytesafter, (unsigned char **)&id);
      if(!(id == ((char *)NULL)))
      {
        if(!(*id == 0))
        {
          const char *old_tag = " on host ";
          const char *s;
          s=strstr(id, old_tag);
          if(!(s == ((const char *)NULL)))
          {
            user = ((const char *)NULL);
            unsigned long int return_value_strlen_1;
            return_value_strlen_1=strlen(old_tag);
            host = s + (signed long int)return_value_strlen_1;
          }

          else
          {
            char *o = ((char *)NULL);
            char *p = ((char *)NULL);
            char *server_xscreensaver_version__1__2__1__2__c = ((char *)NULL);
            o=strchr(id, 40);
            if(!(o == ((char *)NULL)))
              p=strchr(o, 64);

            if(!(p == ((char *)NULL)))
              server_xscreensaver_version__1__2__1__2__c=strchr(p, 41);

            if(!(server_xscreensaver_version__1__2__1__2__c == ((char *)NULL)))
            {
              user = o + (signed long int)1;
              host = p + (signed long int)1;
              *p = (char)0;
              *server_xscreensaver_version__1__2__1__2__c = (char)0;
            }

          }
        }

      }

      _Bool tmp_if_expr_2;
      if(!(user == ((const char *)NULL)))
        tmp_if_expr_2 = *user != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      _Bool tmp_if_expr_3;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = (signed int)*user != 63 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
        *user_ret=strdup(user);

      else
        *user_ret = ((char *)NULL);
      _Bool tmp_if_expr_4;
      if(!(host == ((const char *)NULL)))
        tmp_if_expr_4 = *host != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      _Bool tmp_if_expr_5;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = (signed int)*host != 63 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        *host_ret=strdup(host);

      else
        *host_ret = ((char *)NULL);
      if(!(id == ((char *)NULL)))
        XFree((void *)id);

    }

  }

}

// set_attr
// file common/commands.c line 331
static void set_attr(struct ng_attribute *attr, signed int val)
{
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    attr->write(attr, val);
    cur_attrs[(signed long int)attr->id] = val;
    if(!(attr_notify == ((void (*)(struct ng_attribute *, signed int))NULL)))
      attr_notify(attr, val);

  }

}

// set_capture
// file common/commands.c line 304
static void set_capture(signed int capture, signed int tmp_switch)
{
  if(!(set_capture_hook == ((void (*)(signed int, signed int, signed int))NULL)))
  {
    static signed int last_on = 1;
    if(capture == 9)
      capture = last_on;

    if(capture == 1)
    {
      if((1 & f_drv) == 0)
        capture = 2;

      if(do_overlay == 0)
        capture = 2;

    }

    if(!(cur_capture == capture))
    {
      set_capture_hook(cur_capture, capture, tmp_switch);
      cur_capture = capture;
    }

    if(!(cur_capture == 0))
      last_on = cur_capture;

  }

}

// set_defaults
// file ./common/commands.h line 72
void set_defaults(void)
{
  struct ng_attribute *attr;
  attr=ng_attr_byid(attrs, 6);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.color);

  attr=ng_attr_byid(attrs, 7);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.bright);

  attr=ng_attr_byid(attrs, 8);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.hue);

  attr=ng_attr_byid(attrs, 9);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.contrast);

  attr=ng_attr_byid(attrs, 2);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.input);

  attr=ng_attr_byid(attrs, 1);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.norm);

  set_capture(defaults.capture, 0);
  cur_channel = defaults.channel;
  cur_fine = defaults.fine;
  cur_freq = defaults.freq;
  if(!((4 & f_drv) == 0))
    drv->setfreq(h_drv, (unsigned long int)defaults.freq);

}

// set_freqtab
// file common/commands.c line 364
static void set_freqtab(signed int j)
{
  if(!((4 & f_drv) == 0))
  {
    freq_newtab(j);
    cur_channel = -1;
    calc_frequencies();
    if(!(freqtab_notify == ((void (*)(void))NULL)))
      freqtab_notify();

  }

}

// set_msg_bool
// file common/commands.c line 418
static void set_msg_bool(const char *name, signed int val)
{
  if(!(display_message == ((void (*)(char *))NULL)))
  {
    static char title[256l];
    sprintf(title, "%s: %s", name, val != 0 ? "on" : "off");
    display_message(title);
  }

}

// set_msg_int
// file common/commands.c line 406
static void set_msg_int(struct ng_attribute *attr, signed int val)
{
  if(!(display_message == ((void (*)(char *))NULL)))
  {
    signed int return_value_ng_attr_int2percent_1;
    return_value_ng_attr_int2percent_1=ng_attr_int2percent(attr, val);
    static char title[256l];
    sprintf(title, "%s: %d%%", attr->name, return_value_ng_attr_int2percent_1);
    display_message(title);
  }

}

// set_msg_str
// file common/commands.c line 429
static void set_msg_str(const char *name, const char *val)
{
  if(!(display_message == ((void (*)(char *))NULL)))
  {
    static char title[256l];
    sprintf(title, "%s: %s", name, val);
    display_message(title);
  }

}

// set_mute
// file common/commands.c line 351
static void set_mute(signed int val)
{
  struct ng_attribute *attr;
  cur_attrs[(signed long int)4] = val;
  attr=ng_attr_byid(attrs, 4);
  if(!(attr == ((struct ng_attribute *)NULL)))
    attr->write(attr, val);

  if(!(mute_notify == ((void (*)(signed int))NULL)))
    mute_notify(val);

}

// set_property
// file x11/xt.h line 173
void set_property(signed int freq, char *channel, char *name)
{
  signed int len;
  char line[80l];
  signed int return_value_sprintf_1;
  return_value_sprintf_1=sprintf(line, "%.3f", (float)freq / (float)16);
  len = return_value_sprintf_1 + 1;
  signed int return_value_sprintf_2;
  return_value_sprintf_2=sprintf(line + (signed long int)len, "%s", channel != ((char *)NULL) ? channel : "?");
  len = len + return_value_sprintf_2 + 1;
  signed int return_value_sprintf_3;
  return_value_sprintf_3=sprintf(line + (signed long int)len, "%s", name != ((char *)NULL) ? name : "?");
  len = len + return_value_sprintf_3 + 1;
  unsigned long int return_value_XtWindow_4;
  return_value_XtWindow_4=XtWindow(app_shell);
  XChangeProperty(dpy, return_value_XtWindow_4, _XAWTV_STATION, (unsigned long int)31, 8, 0, (const unsigned char *)line, len);
}

// set_title
// file common/commands.c line 381
static void set_title(void)
{
  const char *norm;
  keypad_state = -1;
  unsigned long int return_value_strlen_2;
  if(!(update_title == ((void (*)(char *))NULL)))
  {
    static char title[256l];
    if(!(cur_sender == -1))
      sprintf(title, "%s", channels[(signed long int)cur_sender]->name);

    else
      if(!(cur_channel == -1))
      {
        struct CHANLIST *tmp_if_expr_1;
        if(!(chantab == -1))
          tmp_if_expr_1 = (chanlists + (signed long int)chantab)->list;

        else
          tmp_if_expr_1 = (struct CHANLIST *)(void *)0;
        sprintf(title, "channel %s", (tmp_if_expr_1 + (signed long int)cur_channel)->name);
        if(!(cur_fine == 0))
        {
          return_value_strlen_2=strlen(title);
          sprintf(title + (signed long int)return_value_strlen_2, " (%d)", cur_fine);
        }

        struct ng_attribute *return_value_ng_attr_byid_3;
        return_value_ng_attr_byid_3=ng_attr_byid(attrs, 1);
        norm=ng_attr_getstr(return_value_ng_attr_byid_3, cur_attrs[(signed long int)1]);
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(title);
        sprintf(title + (signed long int)return_value_strlen_4, " (%s/%s)", norm != ((const char *)NULL) ? norm : "???", (chanlists + (signed long int)chantab)->name);
      }

      else
        sprintf(title, "%.3f MHz", (double)cur_freq / 16.0);
    update_title(title);
  }

}

// set_vidmode
// file x11/xt.c line 826
static void set_vidmode(struct anonymous_15 *mode)
{
  if(cur_capture == 1)
  {
    do_va_cmd(2, (const void *)"capture", (const void *)"off");
    XtAppAddTimeOut(app_context, (unsigned long int)100, vidmode_timer, (void *)0);
  }

  if(!(debug == 0))
    fprintf(stderr, "switching mode: %d  %d %d %d %d  %d %d %d %d  %d\n", mode->dotclock, mode->hdisplay, mode->hsyncstart, mode->hsyncend, mode->htotal, mode->vdisplay, mode->vsyncstart, mode->vsyncend, mode->vtotal, mode->flags);

  signed int return_value_XDefaultScreen_1;
  return_value_XDefaultScreen_1=XDefaultScreen(dpy);
  XF86VidModeSwitchToMode(dpy, return_value_XDefaultScreen_1, mode);
  XSync(dpy, 0);
}

// set_volume
// file common/commands.c line 342
static void set_volume(signed int val)
{
  struct ng_attribute *attr;
  cur_attrs[(signed long int)3] = val;
  attr=ng_attr_byid(attrs, 3);
  if(!(attr == ((struct ng_attribute *)NULL)))
    attr->write(attr, val);

}

// setchannel_handler
// file common/commands.c line 667
static signed int setchannel_handler(char *name, signed int argc, char **argv)
{
  signed int i;
  signed int setchannel_handler__1__c;
  signed int orig_mute;
  signed int return_value_strcasecmp_7;
  signed int return_value_strcasecmp_6;
  signed int return_value_strcasecmp_5;
  signed int return_value_get_freq_11;
  if((4 & f_drv) == 0)
    return 0;

  else
    if(argc == 0)
    {
      set_title();
      return 0;
    }

    else
      if(!(cur_movie == 0))
      {
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message("grabber busy");

        return -1;
      }

      else
      {
        signed int return_value_strcasecmp_12;
        return_value_strcasecmp_12=strcasecmp("setfreq", name);
        if(return_value_strcasecmp_12 == 0)
        {
          double return_value_atof_1;
          return_value_atof_1=atof(argv[(signed long int)0]);
          cur_freq = (signed int)(unsigned long int)(return_value_atof_1 * (double)16);
          cur_sender = -1;
          cur_channel = -1;
          cur_fine = 0;
        }

        else
        {
          signed int return_value_strcasecmp_8;
          return_value_strcasecmp_8=strcasecmp(argv[(signed long int)0], "next");
          if(return_value_strcasecmp_8 == 0)
          {
            signed int tmp_if_expr_2;
            if(!(chantab == -1))
              tmp_if_expr_2 = (chanlists + (signed long int)chantab)->count;

            else
              tmp_if_expr_2 = 0;
            cur_channel = (cur_channel + 1) % tmp_if_expr_2;
            cur_fine = defaults.fine;
          }

          else
          {
            return_value_strcasecmp_7=strcasecmp(argv[(signed long int)0], "prev");
            if(return_value_strcasecmp_7 == 0)
            {
              signed int tmp_if_expr_3;
              if(!(chantab == -1))
                tmp_if_expr_3 = (chanlists + (signed long int)chantab)->count;

              else
                tmp_if_expr_3 = 0;
              signed int tmp_if_expr_4;
              if(!(chantab == -1))
                tmp_if_expr_4 = (chanlists + (signed long int)chantab)->count;

              else
                tmp_if_expr_4 = 0;
              cur_channel = ((cur_channel + tmp_if_expr_3) - 1) % tmp_if_expr_4;
              cur_fine = defaults.fine;
            }

            else
            {
              return_value_strcasecmp_6=strcasecmp(argv[(signed long int)0], "fine_up");
              if(return_value_strcasecmp_6 == 0)
                cur_fine = cur_fine + 1;

              else
              {
                return_value_strcasecmp_5=strcasecmp(argv[(signed long int)0], "fine_down");
                if(return_value_strcasecmp_5 == 0)
                  cur_fine = cur_fine - 1;

                else
                {
                  setchannel_handler__1__c=lookup_channel(argv[(signed long int)0]);
                  if(!(setchannel_handler__1__c == -1))
                  {
                    cur_channel = setchannel_handler__1__c;
                    cur_fine = defaults.fine;
                  }

                }
              }
            }
          }
          signed int return_value_strncmp_10;
          return_value_strncmp_10=strncmp(argv[(signed long int)0], "fine", (unsigned long int)4);
          if(!(return_value_strncmp_10 == 0))
          {
            i = 0;
            for( ; !(i >= count); i = i + 1)
              if(cur_channel == channels[(signed long int)i]->channel)
              {
                char *setchannel_handler__1__4__6__1__1__1__argv[2l];
                setchannel_handler__1__4__6__1__1__1__argv[(signed long int)0] = channels[(signed long int)i]->name;
                setchannel_handler__1__4__6__1__1__1__argv[(signed long int)1] = (char *)(void *)0;
                signed int return_value_setstation_handler_9;
                return_value_setstation_handler_9=setstation_handler("", argc, setchannel_handler__1__4__6__1__1__1__argv);
                return return_value_setstation_handler_9;
              }

          }

          cur_sender = -1;
          if(!(cur_channel == -1))
          {
            return_value_get_freq_11=get_freq(cur_channel);
            cur_freq = return_value_get_freq_11 + cur_fine;
          }

          else
          {
            cur_freq = cur_freq + cur_fine;
            cur_fine = 0;
          }
        }
        if(!(channel_switch_hook == ((void (*)(void))NULL)))
          channel_switch_hook();

        set_capture(0, 1);
        orig_mute = cur_attrs[(signed long int)4];
        if(orig_mute == 0)
          set_mute(1);

        if(!((4 & f_drv) == 0))
          drv->setfreq(h_drv, (unsigned long int)cur_freq);

        set_capture(defaults.capture, 0);
        set_title();
        if(!(setstation_notify == ((void (*)(void))NULL)))
          setstation_notify();

        if(orig_mute == 0)
        {
          usleep((unsigned int)20000);
          set_mute(0);
        }

        return 0;
      }
}

// setfreqtab_handler
// file common/commands.c line 763
static signed int setfreqtab_handler(char *name, signed int argc, char **argv)
{
  signed int i;
  if((4 & f_drv) == 0)
    return 0;

  else
  {
    i=str_to_int(argv[(signed long int)0], chanlist_names);
    if(!(i == -1))
      set_freqtab(i);

    else
      print_choices("freqtab", argv[(signed long int)0], chanlist_names);
    return 0;
  }
}

// setparams
// file common/alsa_stream.c line 249
static signed int setparams(struct _snd_pcm *phandle, struct _snd_pcm *chandle, enum _snd_pcm_format format, signed int latency, signed int allow_resample, struct final_params *negotiated)
{
  signed int i;
  unsigned int ratep;
  unsigned int ratec = (unsigned int)0;
  unsigned int ratemin = (unsigned int)32000;
  unsigned int ratemax = (unsigned int)96000;
  unsigned int val;
  signed int setparams__1__err;
  signed int setparams__1__channels = 2;
  struct _snd_pcm_hw_params *p_hwparams;
  struct _snd_pcm_hw_params *c_hwparams;
  struct _snd_pcm_sw_params *p_swparams;
  struct _snd_pcm_sw_params *c_swparams;
  unsigned long int c_size;
  unsigned long int p_psize;
  unsigned long int c_psize;
  unsigned int c_periods = (unsigned int)2;
  unsigned int p_periods;
  unsigned int c_periodtime;
  unsigned int p_periodtime;
  const unsigned int prefered_rates[3l] = { (const unsigned int)44100, (const unsigned int)48000, (const unsigned int)32000 };
  do
  {
    unsigned long int return_value_snd_pcm_hw_params_sizeof_1;
    return_value_snd_pcm_hw_params_sizeof_1=snd_pcm_hw_params_sizeof();
    void *return_value___builtin_alloca_2;
    return_value___builtin_alloca_2=__builtin_alloca(return_value_snd_pcm_hw_params_sizeof_1);
    *(&p_hwparams) = (struct _snd_pcm_hw_params *)return_value___builtin_alloca_2;
    unsigned long int return_value_snd_pcm_hw_params_sizeof_3;
    return_value_snd_pcm_hw_params_sizeof_3=snd_pcm_hw_params_sizeof();
    memset((void *)*(&p_hwparams), 0, return_value_snd_pcm_hw_params_sizeof_3);
  }
  while((_Bool)0);
  do
  {
    unsigned long int return_value_snd_pcm_hw_params_sizeof_4;
    return_value_snd_pcm_hw_params_sizeof_4=snd_pcm_hw_params_sizeof();
    void *return_value___builtin_alloca_5;
    return_value___builtin_alloca_5=__builtin_alloca(return_value_snd_pcm_hw_params_sizeof_4);
    *(&c_hwparams) = (struct _snd_pcm_hw_params *)return_value___builtin_alloca_5;
    unsigned long int return_value_snd_pcm_hw_params_sizeof_6;
    return_value_snd_pcm_hw_params_sizeof_6=snd_pcm_hw_params_sizeof();
    memset((void *)*(&c_hwparams), 0, return_value_snd_pcm_hw_params_sizeof_6);
  }
  while((_Bool)0);
  do
  {
    unsigned long int return_value_snd_pcm_sw_params_sizeof_7;
    return_value_snd_pcm_sw_params_sizeof_7=snd_pcm_sw_params_sizeof();
    void *return_value___builtin_alloca_8;
    return_value___builtin_alloca_8=__builtin_alloca(return_value_snd_pcm_sw_params_sizeof_7);
    *(&p_swparams) = (struct _snd_pcm_sw_params *)return_value___builtin_alloca_8;
    unsigned long int return_value_snd_pcm_sw_params_sizeof_9;
    return_value_snd_pcm_sw_params_sizeof_9=snd_pcm_sw_params_sizeof();
    memset((void *)*(&p_swparams), 0, return_value_snd_pcm_sw_params_sizeof_9);
  }
  while((_Bool)0);
  do
  {
    unsigned long int return_value_snd_pcm_sw_params_sizeof_10;
    return_value_snd_pcm_sw_params_sizeof_10=snd_pcm_sw_params_sizeof();
    void *return_value___builtin_alloca_11;
    return_value___builtin_alloca_11=__builtin_alloca(return_value_snd_pcm_sw_params_sizeof_10);
    *(&c_swparams) = (struct _snd_pcm_sw_params *)return_value___builtin_alloca_11;
    unsigned long int return_value_snd_pcm_sw_params_sizeof_12;
    return_value_snd_pcm_sw_params_sizeof_12=snd_pcm_sw_params_sizeof();
    memset((void *)*(&c_swparams), 0, return_value_snd_pcm_sw_params_sizeof_12);
  }
  while((_Bool)0);
  signed int return_value_setparams_stream_13;
  return_value_setparams_stream_13=setparams_stream(chandle, c_hwparams, format, &setparams__1__channels, "capture");
  if(!(return_value_setparams_stream_13 == 0))
    return 1;

  else
  {
    signed int return_value_setparams_stream_14;
    return_value_setparams_stream_14=setparams_stream(phandle, p_hwparams, format, &setparams__1__channels, "playback");
    if(!(return_value_setparams_stream_14 == 0))
      return 1;

    else
    {
      if(!(allow_resample == 0))
      {
        setparams__1__err=snd_pcm_hw_params_set_rate_resample(chandle, c_hwparams, (unsigned int)1);
        if(!(setparams__1__err >= 0))
        {
          const char *return_value_snd_strerror_15;
          return_value_snd_strerror_15=snd_strerror(setparams__1__err);
          fprintf(error_fp, "alsa: Resample setup failed: %s\n", return_value_snd_strerror_15);
          return 1;
        }

        else
          if(!(verbose == 0))
            fprintf(error_fp, "alsa: Resample enabled.\n");

      }

      setparams__1__err=snd_pcm_hw_params_get_rate_min(c_hwparams, &ratemin, ((signed int *)NULL));
      if(setparams__1__err >= 0 && !(verbose == 0))
        fprintf(error_fp, "alsa: Capture min rate is %d\n", ratemin);

      setparams__1__err=snd_pcm_hw_params_get_rate_max(c_hwparams, &ratemax, ((signed int *)NULL));
      if(setparams__1__err >= 0 && !(verbose == 0))
        fprintf(error_fp, "alsa: Capture max rate is %u\n", ratemax);

      setparams__1__err=snd_pcm_hw_params_get_rate_min(p_hwparams, &val, ((signed int *)NULL));
      if(setparams__1__err >= 0)
      {
        if(!(verbose == 0))
          fprintf(error_fp, "alsa: Playback min rate is %u\n", val);

        if(!(ratemin >= val))
          ratemin = val;

      }

      setparams__1__err=snd_pcm_hw_params_get_rate_max(p_hwparams, &val, ((signed int *)NULL));
      if(setparams__1__err >= 0)
      {
        if(!(verbose == 0))
          fprintf(error_fp, "alsa: Playback max rate is %u\n", val);

        if(!(val >= ratemax))
          ratemax = val;

      }

      if(!(verbose == 0))
        fprintf(error_fp, "alsa: Will search a common rate between %u and %u\n", ratemin, ratemax);

      setparams__1__err = -1;
      i = 0;
      for( ; !((unsigned long int)i >= 3ul); i = i + 1)
      {
        _Bool tmp_if_expr_16;
        if(!(prefered_rates[(signed long int)i] >= ratemin))
          tmp_if_expr_16 = (_Bool)1;

        else
          tmp_if_expr_16 = prefered_rates[(signed long int)i] > ratemax ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_16)
        {
          ratec = prefered_rates[(signed long int)i];
          ratep = ratec;
          setparams__1__err=alsa_try_rate(phandle, chandle, p_hwparams, c_hwparams, allow_resample, &ratep, &ratec);
          if(setparams__1__err == 0)
            break;

        }

      }
      if(!(setparams__1__err == 0))
      {
        if(ratemin >= 44100u)
        {
          i = (signed int)ratemin;
          for( ; ratemax >= (unsigned int)i; i = i + 100)
          {
            ratec = (unsigned int)i;
            ratep = ratec;
            setparams__1__err=alsa_try_rate(phandle, chandle, p_hwparams, c_hwparams, allow_resample, &ratep, &ratec);
            if(setparams__1__err == 0)
              break;

          }
        }

        else
        {
          i = (signed int)ratemax;
          for( ; (unsigned int)i >= ratemin; i = i - 100)
          {
            ratec = (unsigned int)i;
            ratep = ratec;
            setparams__1__err=alsa_try_rate(phandle, chandle, p_hwparams, c_hwparams, allow_resample, &ratep, &ratec);
            if(setparams__1__err == 0)
              break;

          }
        }
      }

      if(!(setparams__1__err >= 0))
      {
        const char *return_value_snd_strerror_17;
        return_value_snd_strerror_17=snd_strerror(setparams__1__err);
        fprintf(error_fp, "alsa: Failed to set a supported rate: %s\n", return_value_snd_strerror_17);
        return 1;
      }

      if(!(ratep == ratec))
      {
        if(!(allow_resample == 0) || !(verbose == 0))
          fprintf(error_fp, "alsa: Couldn't find a rate that it is supported by both playback and capture\n");

        return 2;
      }

      else
      {
        if(!(verbose == 0))
          fprintf(error_fp, "alsa: Using Rate %d\n", ratec);

        c_periodtime = (unsigned int)(latency * 1000) / c_periods;
        getparams_periods(chandle, c_hwparams, &c_periodtime, &c_periods, 1, "capture");
        p_periods = c_periods * (unsigned int)2;
        p_periodtime = c_periodtime;
        getparams_periods(phandle, p_hwparams, &p_periodtime, &p_periods, 0, "playback");
        c_periods = p_periods / (unsigned int)2;
        if(!(verbose == 0))
          fprintf(error_fp, "alsa: Capture %u periods of %u usecs, Playback %u periods of %u usecs\n", c_periods, c_periodtime, p_periods, p_periodtime);

        if(!(p_periodtime >= c_periodtime))
        {
          c_periodtime = p_periodtime;
          double return_value_round_18;
          return_value_round_18=round(((double)latency * 1000.0) / (double)c_periodtime + 0.5);
          c_periods = (unsigned int)return_value_round_18;
          getparams_periods(chandle, c_hwparams, &c_periodtime, &c_periods, 0, "capture");
          p_periods = c_periods * (unsigned int)2;
          p_periodtime = c_periodtime;
          getparams_periods(phandle, p_hwparams, &p_periodtime, &p_periods, 0, "playback");
          c_periods = p_periods / (unsigned int)2;
        }

        signed int return_value_setparams_periods_19;
        return_value_setparams_periods_19=setparams_periods(chandle, c_hwparams, &c_periodtime, &c_periods, "capture");
        if(!(return_value_setparams_periods_19 == 0))
          return 1;

        else
        {
          signed int return_value_setparams_periods_20;
          return_value_setparams_periods_20=setparams_periods(phandle, p_hwparams, &p_periodtime, &p_periods, "playback");
          if(!(return_value_setparams_periods_20 == 0))
            return 1;

          else
          {
            snd_pcm_hw_params_get_period_size(p_hwparams, &p_psize, (signed int *)(void *)0);
            snd_pcm_hw_params_get_period_size(c_hwparams, &c_psize, (signed int *)(void *)0);
            snd_pcm_hw_params_get_buffer_size(c_hwparams, &c_size);
            latency = (signed int)((unsigned long int)c_periods * c_psize);
            signed int return_value_setparams_set_21;
            return_value_setparams_set_21=setparams_set(phandle, p_hwparams, p_swparams, (unsigned long int)latency, "playback");
            if(!(return_value_setparams_set_21 == 0))
              return 1;

            else
            {
              signed int return_value_setparams_set_22;
              return_value_setparams_set_22=setparams_set(chandle, c_hwparams, c_swparams, c_psize, "capture");
              if(!(return_value_setparams_set_22 == 0))
                return 1;

              else
              {
                setparams__1__err=snd_pcm_prepare(phandle);
                if(!(setparams__1__err >= 0))
                {
                  const char *return_value_snd_strerror_23;
                  return_value_snd_strerror_23=snd_strerror(setparams__1__err);
                  fprintf(error_fp, "alsa: Prepare error: %s\n", return_value_snd_strerror_23);
                  return 1;
                }

                if(!(verbose == 0))
                {
                  fprintf(error_fp, "alsa: Negociated configuration:\n");
                  snd_pcm_dump_setup(phandle, output);
                  snd_pcm_dump_setup(chandle, output);
                  const char *return_value_snd_pcm_format_name_24;
                  return_value_snd_pcm_format_name_24=snd_pcm_format_name(format);
                  fprintf(error_fp, "alsa: Parameters are %iHz, %s, %i channels\n", ratep, return_value_snd_pcm_format_name_24, setparams__1__channels);
                  fprintf(error_fp, "alsa: Set bitrate to %u%s, buffer size is %u\n", ratec, allow_resample != 0 ? " with resample enabled at playback" : "", (unsigned int)c_size);
                }

                negotiated->bufsize = (signed int)c_size;
                negotiated->rate = (signed int)ratep;
                negotiated->channels = setparams__1__channels;
                negotiated->latency = latency;
                return 0;
              }
            }
          }
        }
      }
    }
  }
}

// setparams_periods
// file common/alsa_stream.c line 150
static signed int setparams_periods(struct _snd_pcm *handle, struct _snd_pcm_hw_params *params, unsigned int *usecs, unsigned int *count, const char *id)
{
  signed int setparams_periods__1__err;
  setparams_periods__1__err=snd_pcm_hw_params_set_period_time_near(handle, params, usecs, ((signed int *)NULL));
  if(!(setparams_periods__1__err >= 0))
  {
    const char *return_value_snd_strerror_1;
    return_value_snd_strerror_1=snd_strerror(setparams_periods__1__err);
    fprintf(error_fp, "alsa: Unable to set period time %u for %s: %s\n", *usecs, id, return_value_snd_strerror_1);
    return setparams_periods__1__err;
  }

  setparams_periods__1__err=snd_pcm_hw_params_set_periods_near(handle, params, count, ((signed int *)NULL));
  if(!(setparams_periods__1__err >= 0))
  {
    const char *return_value_snd_strerror_2;
    return_value_snd_strerror_2=snd_strerror(setparams_periods__1__err);
    fprintf(error_fp, "alsa: Unable to set %u periods for %s: %s\n", *count, id, return_value_snd_strerror_2);
    return setparams_periods__1__err;
  }

  if(!(verbose == 0))
    fprintf(error_fp, "alsa: %s period set to %u periods of %u time\n", id, *count, *usecs);

  return 0;
}

// setparams_set
// file common/alsa_stream.c line 179
static signed int setparams_set(struct _snd_pcm *handle, struct _snd_pcm_hw_params *params, struct _snd_pcm_sw_params *swparams, unsigned long int start_treshold, const char *id)
{
  signed int setparams_set__1__err;
  setparams_set__1__err=snd_pcm_hw_params(handle, params);
  if(!(setparams_set__1__err >= 0))
  {
    const char *return_value_snd_strerror_1;
    return_value_snd_strerror_1=snd_strerror(setparams_set__1__err);
    fprintf(error_fp, "alsa: Unable to set hw params for %s: %s\n", id, return_value_snd_strerror_1);
    return setparams_set__1__err;
  }

  setparams_set__1__err=snd_pcm_sw_params_current(handle, swparams);
  if(!(setparams_set__1__err >= 0))
  {
    const char *return_value_snd_strerror_2;
    return_value_snd_strerror_2=snd_strerror(setparams_set__1__err);
    fprintf(error_fp, "alsa: Unable to determine current swparams for %s: %s\n", id, return_value_snd_strerror_2);
    return setparams_set__1__err;
  }

  setparams_set__1__err=snd_pcm_sw_params_set_start_threshold(handle, swparams, start_treshold);
  if(!(setparams_set__1__err >= 0))
  {
    const char *return_value_snd_strerror_3;
    return_value_snd_strerror_3=snd_strerror(setparams_set__1__err);
    fprintf(error_fp, "alsa: Unable to set start threshold mode for %s: %s\n", id, return_value_snd_strerror_3);
    return setparams_set__1__err;
  }

  setparams_set__1__err=snd_pcm_sw_params_set_avail_min(handle, swparams, (unsigned long int)4);
  if(!(setparams_set__1__err >= 0))
  {
    const char *return_value_snd_strerror_4;
    return_value_snd_strerror_4=snd_strerror(setparams_set__1__err);
    fprintf(error_fp, "alsa: Unable to set avail min for %s: %s\n", id, return_value_snd_strerror_4);
    return setparams_set__1__err;
  }

  setparams_set__1__err=snd_pcm_sw_params(handle, swparams);
  if(!(setparams_set__1__err >= 0))
  {
    const char *return_value_snd_strerror_5;
    return_value_snd_strerror_5=snd_strerror(setparams_set__1__err);
    fprintf(error_fp, "alsa: Unable to set sw params for %s: %s\n", id, return_value_snd_strerror_5);
    return setparams_set__1__err;
  }

  return 0;
}

// setparams_stream
// file common/alsa_stream.c line 62
static signed int setparams_stream(struct _snd_pcm *handle, struct _snd_pcm_hw_params *params, enum _snd_pcm_format format, signed int *channels, const char *id)
{
  signed int setparams_stream__1__err;
  setparams_stream__1__err=snd_pcm_hw_params_any(handle, params);
  if(!(setparams_stream__1__err >= 0))
  {
    const char *return_value_snd_strerror_1;
    return_value_snd_strerror_1=snd_strerror(setparams_stream__1__err);
    fprintf(error_fp, "alsa: Broken configuration for %s PCM: no configurations available: %s\n", return_value_snd_strerror_1, id);
    return setparams_stream__1__err;
  }

  setparams_stream__1__err=snd_pcm_hw_params_set_access(handle, params, (enum _snd_pcm_access)SND_PCM_ACCESS_RW_INTERLEAVED);
  if(!(setparams_stream__1__err >= 0))
  {
    const char *return_value_snd_strerror_2;
    return_value_snd_strerror_2=snd_strerror(setparams_stream__1__err);
    fprintf(error_fp, "alsa: Access type not available for %s: %s\n", id, return_value_snd_strerror_2);
    return setparams_stream__1__err;
  }

  setparams_stream__1__err=snd_pcm_hw_params_set_format(handle, params, format);
  if(!(setparams_stream__1__err >= 0))
  {
    const char *return_value_snd_strerror_3;
    return_value_snd_strerror_3=snd_strerror(setparams_stream__1__err);
    fprintf(error_fp, "alsa: Sample format not available for %s: %s\n", id, return_value_snd_strerror_3);
    return setparams_stream__1__err;
  }

  signed int return_value_strcmp_4;
  do
  {

  retry:
    ;
    setparams_stream__1__err=snd_pcm_hw_params_set_channels(handle, params, (unsigned int)*channels);
    if(setparams_stream__1__err >= 0)
      goto __CPROVER_DUMP_L5;

    return_value_strcmp_4=strcmp(id, "capture");
    if(!(return_value_strcmp_4 == 0))
      break;

    if(!(*channels == 2))
      break;

    *channels = 1;
  }
  while((_Bool)1);
  const char *return_value_snd_strerror_5;
  return_value_snd_strerror_5=snd_strerror(setparams_stream__1__err);
  fprintf(error_fp, "alsa: Channels count (%i) not available for %s: %s\n", *channels, id, return_value_snd_strerror_5);
  return setparams_stream__1__err;

__CPROVER_DUMP_L5:
  ;
  return 0;
}

// setstation_handler
// file common/commands.c line 567
static signed int setstation_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  signed int i;
  signed int orig_mute;
  signed int return_value_strcasecmp_8;
  signed int return_value_strcasecmp_6;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_1;
  char *return_value_strcasestr_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  if((4 & f_drv) == 0)
    return 0;

  else
    if(argc == 0)
    {
      set_title();
      return 0;
    }

    else
      if(!(cur_movie == 0))
      {
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message("grabber busy");

        return -1;
      }

      else
      {
        _Bool tmp_if_expr_9;
        if(!(count == 0))
        {
          return_value_strcasecmp_8=strcasecmp(argv[(signed long int)0], "next");
          tmp_if_expr_9 = 0 == return_value_strcasecmp_8 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_9 = (_Bool)0;
        if(tmp_if_expr_9)
          i = (cur_sender + 1) % count;

        else
        {
          _Bool tmp_if_expr_7;
          if(!(count == 0))
          {
            return_value_strcasecmp_6=strcasecmp(argv[(signed long int)0], "prev");
            tmp_if_expr_7 = 0 == return_value_strcasecmp_6 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_7 = (_Bool)0;
          if(tmp_if_expr_7)
            i = ((cur_sender + count) - 1) % count;

          else
          {
            _Bool tmp_if_expr_5;
            if(!(count == 0))
            {
              return_value_strcasecmp_4=strcasecmp(argv[(signed long int)0], "back");
              tmp_if_expr_5 = 0 == return_value_strcasecmp_4 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_5 = (_Bool)0;
            if(tmp_if_expr_5)
            {
              if(last_sender == -1)
                return -1;

              i = last_sender;
            }

            else
            {
              i = 0;
              for( ; !(i >= count); i = i + 1)
              {
                return_value_strcasecmp_1=strcasecmp(channels[(signed long int)i]->name, argv[(signed long int)0]);
                if(return_value_strcasecmp_1 == 0)
                  break;

              }
              if(i == count)
              {
                i = 0;
                for( ; !(i >= count); i = i + 1)
                {
                  return_value_strcasestr_2=strcasestr(channels[(signed long int)i]->name, argv[(signed long int)0]);
                  if(!(return_value_strcasestr_2 == ((char *)NULL)))
                    break;

                }
              }

              if(i == count)
              {
                return_value___ctype_b_loc_3=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*(*argv)]) == 0))
                  i=atoi(argv[(signed long int)0]);

              }

              if(i == count)
              {
                fprintf(stderr, "station \"%s\" not found\n", argv[(signed long int)0]);
                return -1;
              }

            }
          }
        }
        if(i >= count || !(i >= 0))
          return -1;

        else
        {
          if(!(channel_switch_hook == ((void (*)(void))NULL)))
            channel_switch_hook();

          set_capture(0, 1);
          orig_mute = cur_attrs[(signed long int)4];
          if(orig_mute == 0)
            set_mute(1);

          last_sender = cur_sender;
          cur_sender = i;
          attr=ng_attr_byid(attrs, 6);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->color);

          attr=ng_attr_byid(attrs, 7);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->bright);

          attr=ng_attr_byid(attrs, 8);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->hue);

          attr=ng_attr_byid(attrs, 9);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->contrast);

          if(!(cur_attrs[2l] == channels[(signed long int)i]->input))
          {
            attr=ng_attr_byid(attrs, 2);
            if(!(attr == ((struct ng_attribute *)NULL)))
              set_attr(attr, channels[(signed long int)i]->input);

          }

          if(!(cur_attrs[1l] == channels[(signed long int)i]->norm))
          {
            attr=ng_attr_byid(attrs, 1);
            if(!(attr == ((struct ng_attribute *)NULL)))
              set_attr(attr, channels[(signed long int)i]->norm);

          }

          cur_channel = channels[(signed long int)i]->channel;
          cur_fine = channels[(signed long int)i]->fine;
          cur_freq = channels[(signed long int)i]->freq;
          if(!((4 & f_drv) == 0))
            drv->setfreq(h_drv, (unsigned long int)channels[(signed long int)i]->freq);

          set_capture(channels[(signed long int)i]->capture, 0);
          set_title();
          if(!(setstation_notify == ((void (*)(void))NULL)))
            setstation_notify();

          if(orig_mute == 0)
          {
            usleep((unsigned int)20000);
            set_mute(0);
          }

          return 0;
        }
      }
}

// shape
// file common/vbi-sim.c line 10
static inline double shape(double ph)
{
  double x;
  x=sin(ph);
  return x * x;
}

// show_handler
// file common/commands.c line 909
static signed int show_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  char *n[2l] = { (char *)(void *)0, (char *)(void *)0 };
  signed int val;
  const char *return_value_ng_attr_getstr_1;
  if(argc == 0)
  {
    attr = attrs;
    for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
    {
      n[(signed long int)0] = (char *)attr->name;
      show_handler("show", 1, n);
    }
    return 0;
  }

  else
  {
    attr=ng_attr_byname(attrs, argv[(signed long int)0]);
    if(attr == ((struct ng_attribute *)NULL))
    {
      fprintf(stderr, "fixme: 404 %s\n", argv[(signed long int)0]);
      return 0;
    }

    else
    {
      val = cur_attrs[(signed long int)attr->id];
      switch(attr->type)
      {
        case 2:
        {
          return_value_ng_attr_getstr_1=ng_attr_getstr(attr, val);
          printf("%s: %s\n", attr->name, return_value_ng_attr_getstr_1);
          break;
        }
        case 1:
        {
          printf("%s: %d\n", attr->name, val);
          break;
        }
        case 3:
          printf("%s: %s\n", attr->name, val != 0 ? "on" : "off");
      }
      return 0;
    }
  }
}

// showtime_handler
// file common/commands.c line 1174
static signed int showtime_handler(char *name, signed int argc, char **argv)
{
  char timestr[6l];
  struct tm *times;
  signed long int timet;
  timet=time((signed long int *)(void *)0);
  times=localtime(&timet);
  strftime(timestr, (unsigned long int)6, "%k:%M", times);
  if(!(display_message == ((void (*)(char *))NULL)))
    display_message(timestr);

  return 0;
}

// snap_filename
// file ./libng/writefile.h line 2
char * snap_filename(char *base, char *channel, char *ext)
{
  signed long int now;
  struct tm *tm;
  char timestamp[32l];
  time(&now);
  tm=localtime(&now);
  static signed int snap_filename__1__count = 0;
  static signed long int last = (signed long int)0;
  if(!(last == now))
    snap_filename__1__count = 0;

  last = now;
  snap_filename__1__count = snap_filename__1__count + 1;
  static char *filename = (char *)(void *)0;
  if(!(filename == ((char *)NULL)))
    free((void *)filename);

  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(base);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(channel);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(ext);
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(return_value_strlen_1 + return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)32);
  filename = (char *)return_value_malloc_4;
  strftime(timestamp, (unsigned long int)31, "%Y%m%d-%H%M%S", tm);
  sprintf(filename, "%s-%s-%s-%d.%s", base, channel, (const void *)timestamp, snap_filename__1__count, ext);
  return filename;
}

// snap_handler
// file common/commands.c line 1006
static signed int snap_handler(char *hname, signed int argc, char **argv)
{
  char message[512l];
  char *tmpfilename = (char *)(void *)0;
  char *filename = (char *)(void *)0;
  char *name;
  signed int jpeg = 0;
  signed int ret = 0;
  struct ng_video_fmt snap_handler__1__fmt;
  struct ng_video_buf *buf = (struct ng_video_buf *)(void *)0;
  signed int return_value_strcasecmp_4;
  signed int return_value_sscanf_3;
  unsigned long int return_value_strlen_7;
  void *return_value_malloc_8;
  signed int return_value_link_17;
  if((2 & f_drv) == 0)
  {
    fprintf(stderr, "grabbing: not supported [try -noxv switch?]\n");
    return -1;
  }

  else
    if(!(cur_movie == 0))
    {
      if(!(display_message == ((void (*)(char *))NULL)))
        display_message("grabber busy");

      return -1;
    }

    else
    {
      if(!(capture_get_hook == ((void (*)(void))NULL)))
        capture_get_hook();

      if(argc >= 1)
      {
        signed int return_value_strcasecmp_1;
        return_value_strcasecmp_1=strcasecmp(argv[(signed long int)0], "jpeg");
        if(return_value_strcasecmp_1 == 0)
          jpeg = 1;

        signed int return_value_strcasecmp_2;
        return_value_strcasecmp_2=strcasecmp(argv[(signed long int)0], "ppm");
        if(return_value_strcasecmp_2 == 0)
          jpeg = 0;

      }

      memset((void *)&snap_handler__1__fmt, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
      snap_handler__1__fmt.fmtid = (unsigned int)9;
      snap_handler__1__fmt.width = (unsigned int)2048;
      snap_handler__1__fmt.height = (unsigned int)1572;
      if(argc >= 2)
      {
        signed int return_value_strcasecmp_5;
        return_value_strcasecmp_5=strcasecmp(argv[(signed long int)1], "full");
        if(!(return_value_strcasecmp_5 == 0))
        {
          return_value_strcasecmp_4=strcasecmp(argv[(signed long int)1], "win");
          if(return_value_strcasecmp_4 == 0)
          {
            snap_handler__1__fmt.width = cur_tv_width;
            snap_handler__1__fmt.height = cur_tv_height;
          }

          else
          {
            return_value_sscanf_3=sscanf(argv[(signed long int)1], "%dx%d", &snap_handler__1__fmt.width, &snap_handler__1__fmt.height);
            if(!(return_value_sscanf_3 == 2))
              return -1;

          }
        }

      }

      if(argc >= 3)
        filename = argv[(signed long int)2];

      buf=ng_grabber_get_image(&snap_handler__1__fmt);
      if(buf == ((struct ng_video_buf *)NULL))
      {
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message("grabbing failed");

        ret = -1;
      }

      else
      {
        buf=ng_filter_single(cur_filter, buf);
        if(filename == ((char *)NULL))
        {
          if(!(cur_sender == -1))
            name = channels[(signed long int)cur_sender]->name;

          else
            if(!(cur_channel == -1))
            {
              struct CHANLIST *tmp_if_expr_6;
              if(!(chantab == -1))
                tmp_if_expr_6 = (chanlists + (signed long int)chantab)->list;

              else
                tmp_if_expr_6 = (struct CHANLIST *)(void *)0;
              name = (tmp_if_expr_6 + (signed long int)cur_channel)->name;
            }

            else
              name = "unknown";
          filename=snap_filename(snapbase, name, jpeg != 0 ? "jpeg" : "ppm");
        }

        return_value_strlen_7=strlen(filename);
        return_value_malloc_8=malloc(return_value_strlen_7 + (unsigned long int)8);
        tmpfilename = (char *)return_value_malloc_8;
        sprintf(tmpfilename, "%s.___", filename);
        if(!(jpeg == 0))
        {
          signed int return_value_write_jpeg_11;
          return_value_write_jpeg_11=write_jpeg(tmpfilename, buf, ng_jpeg_quality, 0);
          if(return_value_write_jpeg_11 == -1)
          {
            signed int *return_value___errno_location_9;
            return_value___errno_location_9=__errno_location();
            char *return_value_strerror_10;
            return_value_strerror_10=strerror(*return_value___errno_location_9);
            sprintf(message, "open %s: %s\n", tmpfilename, return_value_strerror_10);
          }

          else
            sprintf(message, "saved jpeg: %s", filename);
        }

        else
        {
          signed int return_value_write_ppm_14;
          return_value_write_ppm_14=write_ppm(tmpfilename, buf);
          if(return_value_write_ppm_14 == -1)
          {
            signed int *return_value___errno_location_12;
            return_value___errno_location_12=__errno_location();
            char *return_value_strerror_13;
            return_value_strerror_13=strerror(*return_value___errno_location_12);
            sprintf(message, "open %s: %s\n", tmpfilename, return_value_strerror_13);
          }

          else
            sprintf(message, "saved ppm: %s", filename);
        }
        unlink(filename);
        return_value_link_17=link(tmpfilename, filename);
        if(return_value_link_17 == -1)
        {
          signed int *return_value___errno_location_15;
          return_value___errno_location_15=__errno_location();
          char *return_value_strerror_16;
          return_value_strerror_16=strerror(*return_value___errno_location_15);
          fprintf(stderr, "link(%s,%s): %s\n", tmpfilename, filename, return_value_strerror_16);
          goto done;
        }

        unlink(tmpfilename);
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message(message);

      }

    done:
      ;
      if(!(tmpfilename == ((char *)NULL)))
        free((void *)tmpfilename);

      if(!(buf == ((struct ng_video_buf *)NULL)))
        ng_release_video_buf(buf);

      if(!(capture_rel_hook == ((void (*)(void))NULL)))
        capture_rel_hook();

      return ret;
    }
}

// sort_media_device_entry
// file common/get_media_devices.c line 299
static signed int sort_media_device_entry(const void *a, const void *b)
{
  struct media_device_entry *md_a = (struct media_device_entry *)a;
  struct media_device_entry *md_b = (struct media_device_entry *)b;
  signed int cmp;
  cmp=strcmp(md_a->device, md_b->device);
  if(!(cmp == 0))
    return cmp;

  else
  {
    cmp = (signed int)md_a->type - (signed int)md_b->type;
    if(!(cmp == 0))
      return cmp;

    else
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(md_a->node, md_b->node);
      return return_value_strcmp_1;
    }
  }
}

// sort_media_device_entry_link1
// file common/get_media_devices.c line 299
static signed int sort_media_device_entry_link1(const void *a_link1, const void *b_link1)
{
  struct media_device_entry *md_a_link1 = (struct media_device_entry *)a_link1;
  struct media_device_entry *md_b_link1 = (struct media_device_entry *)b_link1;
  signed int cmp_link1;
  cmp_link1=strcmp(md_a_link1->device, md_b_link1->device);
  if(!(cmp_link1 == 0))
    return cmp_link1;

  else
  {
    cmp_link1 = (signed int)md_a_link1->type - (signed int)md_b_link1->type;
    if(!(cmp_link1 == 0))
      return cmp_link1;

    else
    {
      signed int return_value_strcmp_1_link1;
      return_value_strcmp_1_link1=strcmp(md_a_link1->node, md_b_link1->node);
      return return_value_strcmp_1_link1;
    }
  }
}

// split_cmdline
// file ./common/commands.h line 79
char ** split_cmdline(char *line, signed int *count)
{
  signed int argc;
  signed int i;
  static char cmdline[1024l];
  strcpy(cmdline, line);
  argc = 0;
  i = 0;
  static char *argv[32l];
  while(!(argc >= 31))
  {
    signed int tmp_post_1 = argc;
    argc = argc + 1;
    argv[(signed long int)tmp_post_1] = cmdline + (signed long int)i;
    for( ; !((signed int)cmdline[(signed long int)i] == 32); i = i + 1)
    {
      if((signed int)cmdline[(signed long int)i] == 9)
        break;

      if((signed int)cmdline[(signed long int)i] == 0)
        break;

    }
    if((signed int)cmdline[(signed long int)i] == 0)
      break;

    signed int tmp_post_2 = i;
    i = i + 1;
    cmdline[(signed long int)tmp_post_2] = (char)0;
    for( ; (_Bool)1; i = i + 1)
      if(!((signed int)cmdline[(signed long int)i] == 32))
      {
        if(!((signed int)cmdline[(signed long int)i] == 9))
          goto __CPROVER_DUMP_L6;

      }


  __CPROVER_DUMP_L6:
    ;
    if((signed int)cmdline[(signed long int)i] == 0)
      break;

  }
  argv[(signed long int)argc] = (char *)(void *)0;
  *count = argc;
  return argv;
}

// stderr_close_cb
// file x11/motv.c line 3223
static void stderr_close_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct stderr_handler *h = (struct stderr_handler *)clientdata;
  XmStringFree(h->str);
  h->str=XmStringGenerate((void *)"", (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
}

// stderr_init
// file x11/motv.c line 3232
static void stderr_init(void)
{
  struct stderr_handler *h;
  signed int p[2l];
  if(debug == 0)
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct stderr_handler) /*32ul*/ );
    h = (struct stderr_handler *)return_value_malloc_1;
    memset((void *)h, 0, sizeof(struct stderr_handler) /*32ul*/ );
    h->str=XmStringGenerate((void *)"", (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
    h->box=XmCreateErrorDialog(app_shell, "errbox", (struct anonymous_11 *)(void *)0, (unsigned int)0);
    struct _WidgetRec *return_value_XmMessageBoxGetChild_2;
    return_value_XmMessageBoxGetChild_2=XmMessageBoxGetChild(h->box, (unsigned char)7);
    XtUnmanageChild(return_value_XmMessageBoxGetChild_2);
    struct _WidgetRec *return_value_XmMessageBoxGetChild_3;
    return_value_XmMessageBoxGetChild_3=XmMessageBoxGetChild(h->box, (unsigned char)2);
    XtUnmanageChild(return_value_XmMessageBoxGetChild_3);
    XtAddCallback(h->box, (char *)&_XmStrings[(signed long int)8560], stderr_ok_cb, (void *)h);
    struct _WidgetRec *return_value_XtParent_4;
    return_value_XtParent_4=XtParent(h->box);
    XtAddCallback(return_value_XtParent_4, (char *)&XtStrings[(signed long int)548], stderr_close_cb, (void *)h);
    pipe(p);
    dup2(p[(signed long int)1], 2);
    close(p[(signed long int)1]);
    h->pipe = p[(signed long int)0];
    h->id=XtAppAddInput(app_context, h->pipe, (void *)(1L << 0), stderr_input, (void *)h);
  }

}

// stderr_input
// file x11/motv.c line 3188
static void stderr_input(void *clientdata, signed int *src, unsigned long int *id)
{
  struct stderr_handler *h = (struct stderr_handler *)clientdata;
  union __XmStringRec *item;
  struct _WidgetRec *label;
  char buf[1024l];
  signed int rc;
  signed long int return_value_read_1;
  return_value_read_1=read(h->pipe, (void *)buf, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
  rc = (signed int)return_value_read_1;
  if(!(rc >= 1))
  {
    XtRemoveInput(h->id);
    close(h->pipe);
    XtDestroyWidget(h->box);
    free((void *)h);
  }

  buf[(signed long int)rc] = (char)0;
  item=XmStringGenerate((void *)buf, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
  h->str=XmStringConcatAndFree(h->str, item);
  label=XmMessageBoxGetChild(h->box, (unsigned char)10);
  XtVaSetValues(label, (char *)&_XmStrings[(signed long int)7535], h->str, (void *)0);
  XtManageChild(h->box);
}

// stderr_ok_cb
// file x11/motv.c line 3213
static void stderr_ok_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct stderr_handler *h = (struct stderr_handler *)clientdata;
  XmStringFree(h->str);
  h->str=XmStringGenerate((void *)"", (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
  XtUnmanageChild(h->box);
}

// str_to_int
// file common/channel.c line 739
signed int str_to_int(char *str, struct STRTAB *tab)
{
  signed int i;
  signed int return_value_atoi_1;
  if((signed int)*str >= 48)
  {
    if(!((signed int)*str >= 58))
    {
      return_value_atoi_1=atoi(str);
      return return_value_atoi_1;
    }

  }

  i = 0;
  signed int return_value_strcasecmp_2;
  for( ; !((tab + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
  {
    return_value_strcasecmp_2=strcasecmp(str, (tab + (signed long int)i)->str);
    if(return_value_strcasecmp_2 == 0)
      return (signed int)(tab + (signed long int)i)->nr;

  }
  return -1;
}

// strfamily
// file common/commands.c line 1198
static char * strfamily(signed int family)
{
  switch(family)
  {
    case 10:
      return "ipv6";
    case 2:
      return "ipv4";
    case 1:
      return "unix";
    default:
      return "????";
  }
}

// tcp_connect
// file common/commands.c line 1209
static signed int tcp_connect(struct addrinfo *ai, char *host, char *serv)
{
  struct addrinfo *res;
  struct addrinfo *e;
  char uhost[47l];
  char userv[33l];
  signed int sock;
  signed int rc;
  signed int opt = 1;
  ai->ai_flags = 0x0002;
  if(!(debug == 0))
    fprintf(stderr, "tcp: lookup %s:%s ... ", host, serv);

  rc=getaddrinfo(host, serv, ai, &res);
  if(!(rc == 0))
  {
    const char *return_value_gai_strerror_1;
    return_value_gai_strerror_1=gai_strerror(rc);
    fprintf(stderr, "tcp: getaddrinfo (%s:%s): %s\n", host, serv, return_value_gai_strerror_1);
    return -1;
  }

  if(!(debug == 0))
    fprintf(stderr, "ok\n");

  e = res;
  char *return_value_strfamily_3;
  for( ; !(e == ((struct addrinfo *)NULL)); e = e->ai_next)
  {
    signed int return_value_getnameinfo_2;
    return_value_getnameinfo_2=getnameinfo((struct sockaddr *)e->ai_addr, e->ai_addrlen, uhost, (unsigned int)46, userv, (unsigned int)32, 1 | 2);
    if(!(return_value_getnameinfo_2 == 0))
      fprintf(stderr, "tcp: getnameinfo (peer): oops\n");

    else
    {
      if(!(debug == 0))
      {
        return_value_strfamily_3=strfamily(e->ai_family);
        fprintf(stderr, "tcp: trying %s (%s:%s) ... ", return_value_strfamily_3, (const void *)uhost, (const void *)userv);
      }

      sock=socket(e->ai_family, e->ai_socktype, e->ai_protocol);
      if(sock == -1)
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        char *return_value_strerror_5;
        return_value_strerror_5=strerror(*return_value___errno_location_4);
        fprintf(stderr, "tcp: socket: %s\n", return_value_strerror_5);
        goto __CPROVER_DUMP_L10;
      }

      setsockopt(sock, 1, 2, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int return_value_connect_8;
      return_value_connect_8=connect(sock, e->ai_addr, e->ai_addrlen);
      if(return_value_connect_8 == -1)
      {
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        char *return_value_strerror_7;
        return_value_strerror_7=strerror(*return_value___errno_location_6);
        fprintf(stderr, "tcp: connect: %s\n", return_value_strerror_7);
        close(sock);
        goto __CPROVER_DUMP_L10;
      }

      if(!(debug == 0))
        fprintf(stderr, "ok\n");

      fcntl(sock, 4, 04000);
      fcntl(sock, 2, 1);
      return sock;
    }

  __CPROVER_DUMP_L10:
    ;
  }
  return -1;
}

// tcp_readbuf
// file common/commands.c line 1256
static signed int tcp_readbuf(signed int sock, signed int timeout, char *dest, char dlen)
{
  struct timeval tcp_readbuf__1__tv;
  struct anonymous_122 set;
  signed int rc;
  signed int *return_value___errno_location_1;
  do
  {

  again:
    ;
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_122) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&set)->fds_bits[(signed long int)0]) : "memory");
    (&set)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    tcp_readbuf__1__tv.tv_sec = (signed long int)timeout;
    tcp_readbuf__1__tv.tv_usec = (signed long int)0;
    rc=select(sock + 1, &set, (struct anonymous_122 *)(void *)0, (struct anonymous_122 *)(void *)0, &tcp_readbuf__1__tv);
    if(!(rc == -1))
      goto __CPROVER_DUMP_L2;

    return_value___errno_location_1=__errno_location();
  }
  while(*return_value___errno_location_1 == 4);

__CPROVER_DUMP_L2:
  ;
  if(rc == -1)
  {
    if(!(debug == 0))
      perror("tcp: select");

    return -1;
  }

  else
    if(rc == 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "tcp: select timeout\n");

      return -1;
    }

    else
    {
      signed long int return_value_read_2;
      return_value_read_2=read(sock, (void *)dest, (unsigned long int)((signed int)dlen - 1));
      rc = (signed int)return_value_read_2;
      if(rc == -1)
      {
        if(!(debug == 0))
          perror("tcp: read");

        return -1;
      }

      else
      {
        dest[(signed long int)rc] = (char)0;
        return rc;
      }
    }
}

// termsig
// file x11/xt.c line 749
static void termsig(signed int signal)
{
  char *return_value_strsignal_1;
  if(!(debug == 0))
  {
    return_value_strsignal_1=strsignal(signal);
    fprintf(stderr, "received signal %d [%s]\n", signal, return_value_strsignal_1);
  }

  XtNoticeSignal(sig_id);
}

// termsig_handler
// file x11/xt.c line 743
static void termsig_handler(void *data, unsigned long int *id)
{
  ExitCB((struct _WidgetRec *)(void *)0, (void *)0, (void *)0);
}

// tilde_expand
// file x11/complete.h line 1
char * tilde_expand(char *file)
{
  char *ret;
  char *user;
  struct passwd *pw;
  signed int len;
  char *return_value_strchr_7;
  if(file == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    _Bool tmp_if_expr_8;
    if((signed int)*file == 126)
    {
      return_value_strchr_7=strchr(file, 47);
      tmp_if_expr_8 = return_value_strchr_7 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    if(!tmp_if_expr_8)
      ret=strdup(file);

    else
    {
      if((signed int)file[1l] == 47)
      {
        unsigned int return_value_getuid_1;
        return_value_getuid_1=getuid();
        pw=getpwuid(return_value_getuid_1);
      }

      else
      {
        user=strdup(&file[(signed long int)1]);
        char *return_value_strchr_2;
        return_value_strchr_2=strchr(user, 47);
        *return_value_strchr_2 = (char)0;
        pw=getpwnam(user);
        free((void *)user);
      }
      if(pw == ((struct passwd *)NULL))
        ret=strdup(file);

      else
      {
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(file);
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(pw->pw_dir);
        void *return_value_malloc_5;
        return_value_malloc_5=malloc(return_value_strlen_3 + return_value_strlen_4);
        ret = (char *)return_value_malloc_5;
        char *return_value_strchr_6;
        return_value_strchr_6=strchr(file, 47);
        sprintf(ret, "%s%s", pw->pw_dir, return_value_strchr_6);
      }
    }
    unsigned long int return_value_strlen_9;
    return_value_strlen_9=strlen(ret);
    len = (signed int)return_value_strlen_9;
    for( ; (signed int)ret[(signed long int)(len + -1)] == 32; len = len - 1)
      ret[(signed long int)(len - 1)] = (char)0;
    return ret;
  }
}

// title_timeout
// file x11/xt.c line 1138
static void title_timeout(void *client_data, unsigned long int *id)
{
  keypad_timeout();
  XtVaSetValues(app_shell, (char *)&XtShellStrings[(signed long int)356], (const void *)default_title, (void *)0);
  title_timer = (unsigned long int)0;
}

// toolkit_set_label
// file x11/motv.c line 215
void toolkit_set_label(struct _WidgetRec *widget, char *str)
{
  union __XmStringRec *xmstr;
  xmstr=XmStringGenerate((void *)str, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
  XtVaSetValues(widget, (char *)&_XmStrings[(signed long int)7535], xmstr, (void *)0);
  XmStringFree(xmstr);
}

// ttx_next
// file common/vbi-sim.c line 209
static unsigned char * ttx_next(void)
{
  signed int i;
  static unsigned char buf[45l];
  buf[(signed long int)0] = (unsigned char)0x55;
  buf[(signed long int)1] = (unsigned char)0x55;
  buf[(signed long int)2] = (unsigned char)0x27;
  signed int return_value_odd_1;
  signed int return_value_odd_2;
  signed int return_value_odd_3;
  static unsigned char s5[10l][42l] = { { (unsigned char)0x02, (unsigned char)0x2f, (unsigned char)0x97, (unsigned char)0x20, (unsigned char)0x37, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0xc7, (unsigned char)0x2f, (unsigned char)0x97, (unsigned char)0x0d, (unsigned char)0xb5, (unsigned char)0x04, (unsigned char)0x20, (unsigned char)0x9d, (unsigned char)0x83, (unsigned char)0x8c, (unsigned char)0x08, (unsigned char)0x2a, (unsigned char)0x2a, (unsigned char)0x2a, (unsigned char)0x89, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x0d, (unsigned char)0x54, (unsigned char)0x45, (unsigned char)0xd3, (unsigned char)0x54, (unsigned char)0x20, (unsigned char)0xd0, (unsigned char)0xc1, (unsigned char)0xc7, (unsigned char)0x45, (unsigned char)0x8c, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x08, (unsigned char)0x2a, (unsigned char)0x2a, (unsigned char)0x2a, (unsigned char)0x89, (unsigned char)0x0d, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x1c, (unsigned char)0x97, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0x02, (unsigned char)0xd0, (unsigned char)0x97, (unsigned char)0x20, (unsigned char)0xb5, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0xea, (unsigned char)0x20 },
    { (unsigned char)0xc7, (unsigned char)0xd0, (unsigned char)0x97, (unsigned char)0x20, (unsigned char)0xb5, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0x02, (unsigned char)0xc7, (unsigned char)0x97, (unsigned char)0x20, (unsigned char)0xb5, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x15, (unsigned char)0x1a, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x97, (unsigned char)0x19, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0xc7, (unsigned char)0xc7, (unsigned char)0x97, (unsigned char)0x20, (unsigned char)0xb5, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0x02, (unsigned char)0x8c, (unsigned char)0x97, (unsigned char)0x9e, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x13, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x16, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x92, (unsigned char)0x7f, (unsigned char)0x92, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x15, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x15, (unsigned char)0x7f, (unsigned char)0x91, (unsigned char)0x91, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x91, (unsigned char)0x94, (unsigned char)0x7f, (unsigned char)0x94, (unsigned char)0x7f, (unsigned char)0x94, (unsigned char)0x97, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0xc7, (unsigned char)0x8c, (unsigned char)0x97, (unsigned char)0x9e, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x13, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x16, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x92, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x15, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x91, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x94, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x97, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0x02, (unsigned char)0x9b, (unsigned char)0x97, (unsigned char)0x9e, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x13, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x16, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x92, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x15, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x91, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x94, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x97, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0xc7, (unsigned char)0x9b, (unsigned char)0x97, (unsigned char)0x20, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0xa1, (unsigned char)0x20 } };
  static signed int row = 0;
  if(row == 0)
  {
    static signed int page = 0;
    static unsigned char s1[2l][10l] = { { (unsigned char)0x02, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15 },
    { (unsigned char)0x02, (unsigned char)0x15, (unsigned char)0x02, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15 } };
    memcpy((void *)(buf + (signed long int)3), (const void *)s1[(signed long int)page], (unsigned long int)10);
    page = page ^ 1;
    i = 0;
    for( ; !(i >= 32); i = i + 1)
    {
      static unsigned char s2[32l] = { '1', '0', '0', 2, 'L', 'I', 'B', 'Z', 'V', 'B', 'I', 7, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '0', '0', ':', '0', '0', ':', '0', '0' };
      return_value_odd_1=odd((signed int)s2[(signed long int)i]);
      buf[(signed long int)(13 + i)] = (unsigned char)return_value_odd_1;
    }
  }

  else
    if(row == 1)
    {
      buf[(signed long int)3] = (unsigned char)0x02;
      buf[(signed long int)4] = (unsigned char)0x02;
      i = 0;
      for( ; !(i >= 40); i = i + 1)
      {
        static unsigned char s3[40l] = { ' ', ' ', 'L', 'I', 'B', 'Z', 'V', 'B', 'I', ' ', 'T', 'E', 'L', 'E', 'T', 'E', 'X', 'T', ' ', 'S', 'I', 'M', 'U', 'L', 'A', 'T', 'I', 'O', 'N', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
        return_value_odd_2=odd((signed int)s3[(signed long int)i]);
        buf[(signed long int)(5 + i)] = (unsigned char)return_value_odd_2;
      }
    }

    else
      if(row == 2)
      {
        buf[(signed long int)3] = (unsigned char)0x02;
        buf[(signed long int)4] = (unsigned char)0x49;
        i = 0;
        for( ; !(i >= 40); i = i + 1)
        {
          static unsigned char s4[40l] = { ' ', ' ', 'P', 'a', 'g', 'e', ' ', '1', '0', '0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
          return_value_odd_3=odd((signed int)s4[(signed long int)i]);
          buf[(signed long int)(5 + i)] = (unsigned char)return_value_odd_3;
        }
      }

      else
        memcpy((void *)(buf + (signed long int)3), (const void *)s5[(signed long int)(row - 3)], (unsigned long int)42);
  row = row + 1;
  if(row >= 13)
    row = 0;

  return buf;
}

// ttx_sim
// file common/vbi-sim.c line 147
static inline double ttx_sim(double t, double F, const unsigned char *text)
{
  double t1 = 10.3e-6 - .5 / F;
  double t2 = t1 + (double)(45 * 8 + 1) / F;
  double ph;
  if(t < t1)
    return 0.0;

  else
    if(t < t2)
    {
      signed int i;
      signed int j;
      signed int n;
      t = t - t1;
      i = (signed int)(t * F);
      j = i >> 3;
      i = i & 7;
      if(j == 0)
        n = (signed int)text[(signed long int)0] * 2 >> i & 3;

      else
        n = ((signed int)text[(signed long int)(j - 1)] >> 7) + (signed int)text[(signed long int)j] * 2 >> i & 3;
      if(n == 0)
        return 0.0;

      else
        if(n == 3)
          return 1.0;

        else
          if(!(((i ^ n) & 1) == 0))
          {
            ph = (3.14159265358979323846 * (double)2 * (t - (double)1 / F) * F) / (double)4;
            double return_value_shape_1;
            return_value_shape_1=shape(ph);
            return return_value_shape_1;
          }

          else
          {
            ph = (3.14159265358979323846 * (double)2 * (t - (double)0 / F) * F) / (double)4;
            double return_value_shape_2;
            return_value_shape_2=shape(ph);
            return return_value_shape_2;
          }
    }

    else
      return 0.0;
}

// tv_expose_event
// file x11/xt.h line 157
void tv_expose_event(struct _WidgetRec *widget, void *client_data, union _XEvent *event, char *d)
{
  struct anonymous_75 values;
  if(event->type == 12)
  {
    if(!(debug == 0))
      fprintf(stderr, "expose count=%d\n", event->xexpose.count);

    if(event->xexpose.count == 0)
    {
      if(cur_capture == 1)
      {
        if(!((8 & f_drv) == 0))
        {
          unsigned short int win_width;
          unsigned short int win_height;
          if(!(debug == 0))
            fprintf(stderr, "expose: chromakey [%dx%d]\n", cur_tv_width, cur_tv_height);

          static struct _XGC *gc;
          if(gc == ((struct _XGC *)NULL))
          {
            struct anonymous_22 color;
            color.red = (unsigned short int)((ng_chromakey & 0x00ff0000) >> 8);
            color.green = (unsigned short int)(ng_chromakey & 0x0000ff00);
            color.blue = (unsigned short int)((ng_chromakey & 0x000000ff) << 8);
            XAllocColor(dpy, colormap, &color);
            values.foreground = color.pixel;
            unsigned long int return_value_XtWindow_1;
            return_value_XtWindow_1=XtWindow(widget);
            gc=XCreateGC(dpy, return_value_XtWindow_1, (unsigned long int)(1L << 2), &values);
          }

          XtVaGetValues(widget, (char *)&XtStrings[(signed long int)872], &win_width, (char *)&XtStrings[(signed long int)234], &win_height, (void *)0);
          unsigned long int return_value_XtWindow_2;
          return_value_XtWindow_2=XtWindow(widget);
          XFillRectangle(dpy, return_value_XtWindow_2, gc, (signed int)((unsigned int)win_width - cur_tv_width >> 1), (signed int)((unsigned int)win_height - cur_tv_height >> 1), cur_tv_width, cur_tv_height);
        }

        if(!(have_xv == 0))
        {
          if(!(debug == 0))
            fprintf(stderr, "expose: xv reblit\n");

          video_new_size();
        }

      }

    }

  }

}

// update_int
// file common/commands.c line 441
static signed int update_int(struct ng_attribute *attr, signed int old, char *new)
{
  signed int value = old;
  signed int step = ((attr->max - attr->min) * 3) / 100;
  if(step == 0)
    step = 1;

  signed int return_value_strcasecmp_9;
  return_value_strcasecmp_9=strcasecmp(new, "inc");
  signed int return_value_strcasecmp_8;
  signed int return_value_strncasecmp_7;
  signed int return_value_ng_attr_parse_int_1;
  signed int return_value_strncasecmp_6;
  signed int return_value_ng_attr_parse_int_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  if(return_value_strcasecmp_9 == 0)
    value = value + step;

  else
  {
    return_value_strcasecmp_8=strcasecmp(new, "dec");
    if(return_value_strcasecmp_8 == 0)
      value = value - step;

    else
    {
      return_value_strncasecmp_7=strncasecmp(new, "+=", (unsigned long int)2);
      if(return_value_strncasecmp_7 == 0)
      {
        return_value_ng_attr_parse_int_1=ng_attr_parse_int(attr, new + (signed long int)2);
        value = value + return_value_ng_attr_parse_int_1;
      }

      else
      {
        return_value_strncasecmp_6=strncasecmp(new, "-=", (unsigned long int)2);
        if(return_value_strncasecmp_6 == 0)
        {
          return_value_ng_attr_parse_int_2=ng_attr_parse_int(attr, new + (signed long int)2);
          value = value - return_value_ng_attr_parse_int_2;
        }

        else
        {
          return_value___ctype_b_loc_3=__ctype_b_loc();
          _Bool tmp_if_expr_4;
          if(!((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*new]) == 0))
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = 43 == (signed int)new[(signed long int)0] ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr_5;
          if(tmp_if_expr_4)
            tmp_if_expr_5 = (_Bool)1;

          else
            tmp_if_expr_5 = 45 == (signed int)new[(signed long int)0] ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_5)
            value=ng_attr_parse_int(attr, new);

          else
            fprintf(stderr, "update_int: can't parse %s\n", new);
        }
      }
    }
  }
  if(!(value >= attr->min))
    value = attr->min;

  if(!(attr->max >= value))
    value = attr->max;

  return value;
}

// update_movie_menus
// file x11/motv.c line 1933
static void update_movie_menus(void)
{
  struct list_head *item;
  struct ng_writer *writer;
  struct _WidgetRec *push;
  union __XmStringRec *str;
  char sensitive;
  signed int i;
  _Bool tmp_if_expr_2;
  signed int return_value_strcasecmp_1;
  static signed int first = 1;
  if(!(first == 0))
  {
    first = 0;
    i = 0;
    item = (&ng_writers)->next;
    for( ; !(item == &ng_writers); item = item->next)
    {
      writer = (struct ng_writer *)((char *)item - (signed long int)(unsigned long int)&((struct ng_writer *)0)->list);
      str=XmStringGenerate((void *)(char *)writer->desc, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
      push=XtVaCreateManagedWidget(writer->name, xmPushButtonWidgetClass, driver_menu, (char *)&_XmStrings[(signed long int)7535], str, (void *)0);
      XmStringFree(str);
      add_cmd_callback(push, (char *)&_XmStrings[(signed long int)4700], "movie", "driver", writer->name);
      _Bool tmp_if_expr_3;
      if(movie_driver == ((struct ng_writer *)NULL))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        if(!(mov_driver == ((char *)NULL)))
        {
          return_value_strcasecmp_1=strcasecmp(mov_driver, writer->name);
          tmp_if_expr_2 = 0 == return_value_strcasecmp_1 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_2 = (_Bool)0;
        tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
      {
        movie_driver = writer;
        i_movie_driver = (unsigned int)i;
        XtVaSetValues(driver_option, (char *)&_XmStrings[(signed long int)8040], push, (void *)0);
      }

      i = i + 1;
    }
  }

  delete_children(audio_menu);
  i = 0;
  signed int return_value_strcasecmp_5;
  for( ; !((movie_driver->audio + (signed long int)i)->name == ((char *)NULL)); i = i + 1)
  {
    char *tmp_if_expr_4;
    if(!((movie_driver->audio + (signed long int)i)->desc == ((char *)NULL)))
      tmp_if_expr_4 = (movie_driver->audio + (signed long int)i)->desc;

    else
      tmp_if_expr_4 = ng_afmt_to_desc[(signed long int)(movie_driver->audio + (signed long int)i)->fmtid];
    str=XmStringGenerate((void *)(char *)tmp_if_expr_4, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
    push=XtVaCreateManagedWidget((movie_driver->audio + (signed long int)i)->name, xmPushButtonWidgetClass, audio_menu, (char *)&_XmStrings[(signed long int)7535], str, (void *)0);
    XmStringFree(str);
    add_cmd_callback(push, (char *)&_XmStrings[(signed long int)4700], "movie", "audio", (movie_driver->audio + (signed long int)i)->name);
    if(!(mov_audio == ((char *)NULL)))
    {
      return_value_strcasecmp_5=strcasecmp(mov_audio, (movie_driver->audio + (signed long int)i)->name);
      if(return_value_strcasecmp_5 == 0)
      {
        XtVaSetValues(audio_option, (char *)&_XmStrings[(signed long int)8040], push, (void *)0);
        movie_audio = (unsigned int)i;
      }

    }

  }
  str=XmStringGenerate((void *)"no sound", (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
  push=XtVaCreateManagedWidget("none", xmPushButtonWidgetClass, audio_menu, (char *)&_XmStrings[(signed long int)7535], str, (void *)0);
  XmStringFree(str);
  add_cmd_callback(push, (char *)&_XmStrings[(signed long int)4700], "movie", "audio", "none");
  delete_children(video_menu);
  i = 0;
  signed int return_value_strcasecmp_7;
  for( ; !((movie_driver->video + (signed long int)i)->name == ((char *)NULL)); i = i + 1)
  {
    char *tmp_if_expr_6;
    if(!((movie_driver->video + (signed long int)i)->desc == ((char *)NULL)))
      tmp_if_expr_6 = (movie_driver->video + (signed long int)i)->desc;

    else
      tmp_if_expr_6 = ng_vfmt_to_desc[(signed long int)(movie_driver->video + (signed long int)i)->fmtid];
    str=XmStringGenerate((void *)(char *)tmp_if_expr_6, (char *)(void *)0, (enum anonymous_67)XmMULTIBYTE_TEXT, (char *)(void *)0);
    push=XtVaCreateManagedWidget((movie_driver->video + (signed long int)i)->name, xmPushButtonWidgetClass, video_menu, (char *)&_XmStrings[(signed long int)7535], str, (void *)0);
    XmStringFree(str);
    add_cmd_callback(push, (char *)&_XmStrings[(signed long int)4700], "movie", "video", (movie_driver->video + (signed long int)i)->name);
    if(!(mov_video == ((char *)NULL)))
    {
      return_value_strcasecmp_7=strcasecmp(mov_video, (movie_driver->video + (signed long int)i)->name);
      if(return_value_strcasecmp_7 == 0)
      {
        XtVaSetValues(video_option, (char *)&_XmStrings[(signed long int)8040], push, (void *)0);
        movie_video = (unsigned int)i;
      }

    }

  }
  sensitive = (char)(movie_driver->combined != 0 ? 0 : 1);
  XtVaSetValues(m_faudio, (char *)&XtStrings[(signed long int)711], sensitive, (void *)0);
  XtVaSetValues(m_faudioL, (char *)&XtStrings[(signed long int)711], sensitive, (void *)0);
  XtVaSetValues(m_faudioB, (char *)&XtStrings[(signed long int)711], sensitive, (void *)0);
}

// usage
// file x11/xt.c line 1676
static void usage(void)
{
  fprintf(stderr, "\nusage: xawtv [ options ] [ station ]\noptions:\n  -h  -help           print this text\n  -v  -debug n        debug level n, n = [0..2]\n      -remote         assume remote display\n  -n  -noconf         don't read the config file\n  -m  -nomouse        startup with mouse pointer disabled\n  -f  -fullscreen     startup in fullscreen mode\n      -(no)dga        enable/disable DGA extension\n      -(no)vm         enable/disable VidMode extension\n      -(no)randr      enable/disable Xrandr extension\n      -(no)xv         enable/disable Xvideo extension altogether\n      -(no)xv-video   enable/disable Xvideo extension (for video only,\n                      i.e. XvPutVideo() calls)\n      -(no)xv-image   enable/disable Xvideo extension (for image scaling\n                      only, i.e. XvPutImage() calls)\n      -(no)gl         enable/disable OpenGL\n      -(no)alsa       enable/disable alsa streaming. Default: enabled\n      -(no)alsa-cap   manually specify an alsa capture interface\n      -(no)alsa-pb    manually specify an alsa playback interface\n      -alsa-latency   manually specify an alsa latency in ms. Default: 30\n  -b  -bpp n          color depth of the display is n (n=24,32)\n  -o  -outfile file   filename base for snapshots\n  -c  -device file    use <file> as video4linux device\n  -D  -driver name    use <name> as video4linux driver\n  -C  -dspdev file    use <file> as audio (oss) device\n      -vbidev file    use <file> as vbi device\n      -joydev file    use <file> as joystick device\n      -shift x        shift display by x bytes\n      -fb             let fb (not X) set up v4l device\n      -parallel n     use n compression threads\n      -bufcount n     use n video buffers\n      -hwscan         print a list of available devices.\nstation:\n  this is one of the stations listed in _HOME/.xawtv\n\nCheck the manual page for a more detailed description.\n\n--\nGerd Knorr <kraxel@bytesex.org>\n");
}

// v4lconf_init
// file x11/xt.h line 189
void v4lconf_init(void)
{
  unsigned long int return_value_strlen_1;
  unsigned long int return_value_strlen_2;
  if(!(do_overlay == 0))
  {
    strcpy(ng_v4l_conf, "v4l-conf");
    if(args.debug == 0)
      strcat(ng_v4l_conf, " -q");

    if(!(args.fbdev == 0))
      strcat(ng_v4l_conf, " -f");

    if(!(args.shift == 0))
    {
      return_value_strlen_1=strlen(ng_v4l_conf);
      sprintf(ng_v4l_conf + (signed long int)return_value_strlen_1, " -s %d", args.shift);
    }

    if(!(args.bpp == 0))
    {
      return_value_strlen_2=strlen(ng_v4l_conf);
      sprintf(ng_v4l_conf + (signed long int)return_value_strlen_2, " -b %d", args.bpp);
    }

  }

}

// vbi_calc_page
// file common/vbi-data.c line 220
signed int vbi_calc_page(signed int pagenr, signed int offset)
{
  signed int result = pagenr + offset;
  if(!(offset >= 0))
  {
    for( ; (0x0f & result) >= 10; result = result - 0x01)
      ;
    for( ; (0xf0 & result) >= 145; result = result - 0x10)
      ;
    if(!(result >= 0x100))
      result = 0x100;

  }

  if(offset >= 1)
  {
    for( ; (0x0f & result) >= 10; result = result + 0x01)
      ;
    for( ; (0xf0 & result) >= 145; result = result + 0x10)
      ;
    if(result >= 2202)
      result = 0x899;

  }

  return result;
}

// vbi_calc_subpage
// file common/vbi-data.c line 244
signed int vbi_calc_subpage(struct vbi_decoder *dec, signed int pgno, signed int subno, signed int offset)
{
  struct vbi_page pg;
  signed int newno = subno + offset;
  while(!(newno == subno))
  {
    signed int return_value_vbi_fetch_vt_page_1;
    return_value_vbi_fetch_vt_page_1=vbi_fetch_vt_page(dec, &pg, pgno, newno, (enum anonymous_23)VBI_WST_LEVEL_1, 0, 0);
    if(!(return_value_vbi_fetch_vt_page_1 == 0))
      break;

    if(!(offset >= 0))
    {
      newno = newno - 1;
      if(!(newno >= 0))
        newno = newno + 64;

      for( ; (0x0f & newno) >= 10; newno = newno - 0x01)
        ;
    }

    if(offset >= 1)
    {
      newno = newno + 1;
      for( ; (0x0f & newno) >= 10; newno = newno + 0x01)
        ;
      if(newno >= 64)
        newno = 0;

    }

  }
  return newno;
}

// vbi_close
// file ./common/vbi-data.h line 35
void vbi_close(struct vbi_state *vbi)
{
  if(!(vbi == ((struct vbi_state *)NULL)))
  {
    if(!(vbi->sliced == ((struct anonymous_98 *)NULL)))
      free((void *)vbi->sliced);

    if(!(vbi->raw == ((unsigned char *)NULL)))
      free((void *)vbi->raw);

    if(!(vbi->cap == ((struct vbi_capture *)NULL)))
      vbi_capture_delete(vbi->cap);

    if(!(vbi->dec == ((struct vbi_decoder *)NULL)))
      vbi_decoder_delete(vbi->dec);

    free((void *)vbi);
  }

}

// vbi_dump_event
// file common/vbi-data.c line 154
void vbi_dump_event(struct vbi_event *ev, void *user)
{
  switch(ev->type)
  {
    case 0x0002:
    {
      fprintf(stderr, "vbi ev: ttx page %03x.%02x \r", ev->ev.ttx_page.pgno, ev->ev.ttx_page.subno);
      break;
    }
    case 0x0001:
    {
      fprintf(stderr, "vbi ev: close \n");
      break;
    }
    case 0x0004:
    {
      fprintf(stderr, "vbi ev: caption \n");
      break;
    }
    case 0x0008:
    {
      fprintf(stderr, "vbi ev: network id=%d name=\"%s\" call=\"%s\"\n", ev->ev.network.nuid, (const void *)ev->ev.network.name, (const void *)ev->ev.network.call);
      break;
    }
    case 0x0010:
    {
      switch((signed int)ev->ev.trigger->type)
      {
        case VBI_LINK_NONE:
        {
          fprintf(stderr, "vbi ev: trigger none \n");
          break;
        }
        case VBI_LINK_MESSAGE:
        {
          fprintf(stderr, "vbi ev: trigger message \n");
          break;
        }
        case VBI_LINK_PAGE:
        {
          fprintf(stderr, "vbi ev: trigger page [%03x.%02x]\n", ev->ev.trigger->pgno, ev->ev.trigger->subno);
          break;
        }
        case VBI_LINK_SUBPAGE:
        {
          fprintf(stderr, "vbi ev: trigger subpage \n");
          break;
        }
        case VBI_LINK_HTTP:
        {
          fprintf(stderr, "vbi ev: trigger http [%s]\n", (const void *)ev->ev.trigger->url);
          break;
        }
        case VBI_LINK_FTP:
        {
          fprintf(stderr, "vbi ev: trigger ftp \n");
          break;
        }
        case VBI_LINK_EMAIL:
        {
          fprintf(stderr, "vbi ev: trigger email \n");
          break;
        }
        case VBI_LINK_LID:
        {
          fprintf(stderr, "vbi ev: trigger lid \n");
          break;
        }
        case VBI_LINK_TELEWEB:
          fprintf(stderr, "vbi ev: trigger teleweb \n");
      }
      break;
    }
    case 0x0040:
    {
      fprintf(stderr, "vbi ev: aspect \n");
      break;
    }
    case 0x0080:
    {
      fprintf(stderr, "vbi ev: prog info \n");
      break;
    }
    default:
      fprintf(stderr, "vbi ev: UNKNOWN[0x%x] \n", ev->type);
  }
}

// vbi_export_pixmap
// file x11/vbi-x11.h line 55
unsigned long int vbi_export_pixmap(struct vbi_window *vw, struct vbi_page *pg, struct vbi_rect *rect)
{
  unsigned long int pix;
  struct vbi_char *ch;
  signed int y;
  struct _XDisplay *return_value_XtDisplay_1;
  return_value_XtDisplay_1=XtDisplay(vw->tt);
  unsigned long int return_value_XtWindow_2;
  return_value_XtWindow_2=XtWindow(vw->tt);
  struct anonymous_0 *return_value_XtScreen_3;
  return_value_XtScreen_3=XtScreen(vw->tt);
  pix=XCreatePixmap(return_value_XtDisplay_1, return_value_XtWindow_2, (unsigned int)(vw->w * (rect->x2 - rect->x1)), (unsigned int)(vw->h * (rect->y2 - rect->y1)), (unsigned int)return_value_XtScreen_3->root_depth);
  y = rect->y1;
  for( ; !(y >= rect->y2); y = y + 1)
  {
    ch = vw->pg.text + (signed long int)(41 * y);
    vbi_render_line(vw, pix, ch, y, rect->y1, rect->x1, rect->x2);
  }
  return pix;
}

// vbi_export_txt
// file common/vbi-data.c line 271
signed int vbi_export_txt(char *dest, char *charset, signed int size, struct vbi_page *pg, struct vbi_rect *rect, enum vbi_txt_colors color)
{
  signed int x;
  signed int y;
  signed int rc;
  unsigned long int olen;
  unsigned long int ilen;
  signed int fg;
  signed int bg;
  signed int len = 0;
  char *ibuf;
  char *obuf;
  struct vbi_char *ch;
  signed int wch;
  void *ic;
  ic=iconv_open(charset, "WCHAR_T");
  unsigned long int return_value_iconv_2;
  signed int *return_value___errno_location_4;
  signed int return_value_vbi_is_gfx_3;
  if(ic == NULL)
    return -1;

  else
  {
    obuf = dest;
    olen = (unsigned long int)size;
    y = rect->y1;
    for( ; !(y >= rect->y2); y = y + 1)
    {
      ch = pg->text + (signed long int)(41 * y);
      fg = -1;
      bg = -1;
      x = rect->x1;
      for( ; rect->x2 >= x; x = x + 1)
      {
        if(!(x >= rect->x2))
        {
          wch = (signed int)(ch + (signed long int)x)->unicode;
          if((signed int)(ch + (signed long int)x)->size >= 4)
            wch = 32;

          if(!((ch + (signed long int)x)->conceal == 0u))
            wch = 32;

        }

        else
          wch = 10;
        _Bool tmp_if_expr_1;
        if(!(fg == (signed int)(ch + (signed long int)x)->foreground))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = bg != (signed int)(ch + (signed long int)x)->background ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          fg = (signed int)(ch + (signed long int)x)->foreground;
          bg = (signed int)(ch + (signed long int)x)->background;
          switch((signed int)color)
          {
            case VBI_ANSICOLOR:
            {
              len=sprintf(obuf, "\033[%d;%dm", 30 + (fg & 7), 40 + (bg & 7));
              break;
            }
            case VBI_NOCOLOR:
              len = 0;
          }
          olen = olen - (unsigned long int)len;
          obuf = obuf + (signed long int)len;
        }

        ibuf = (char *)&wch;
        ilen = sizeof(signed int) /*4ul*/ ;
        do
        {

        retry:
          ;
          return_value_iconv_2=iconv(ic, &ibuf, &ilen, &obuf, &olen);
          rc = (signed int)return_value_iconv_2;
          if(!(rc == -1))
            goto __CPROVER_DUMP_L18;

          return_value___errno_location_4=__errno_location();
          if(!(*return_value___errno_location_4 == 84))
            break;

          if(wch == 63)
            break;

          return_value_vbi_is_gfx_3=vbi_is_gfx((unsigned int)wch);
          if(!(return_value_vbi_is_gfx_3 == 0))
            wch = 35;

          else
            wch = 63;
        }
        while((_Bool)1);

      __CPROVER_DUMP_L18:
        ;
        if(rc == -1)
          goto done;

      }
      switch((signed int)color)
      {
        case VBI_ANSICOLOR:
        {
          len=sprintf(obuf, "\033[0m");
          break;
        }
        case VBI_NOCOLOR:
          len = 0;
      }
      olen = olen - (unsigned long int)len;
      obuf = obuf + (signed long int)len;
    }

  done:
    ;
    return (signed int)(obuf - dest);
  }
}

// vbi_find_subtitle
// file ./common/vbi-data.h line 43
void vbi_find_subtitle(struct vbi_page *pg, struct vbi_rect *rect)
{
  signed int x;
  signed int y;
  signed int showline;
  struct vbi_char *ch;
  *rect = vbi_fullrect;
  y = 1;
  for( ; !(y >= 25); y = y + 1)
  {
    showline = 0;
    ch = pg->text + (signed long int)(41 * y);
    x = 0;
    for( ; !(x >= 41); x = x + 1)
      if(!((signed int)(ch + (signed long int)x)->unicode == 32))
        showline = 1;

    if(!(showline == 0))
      break;

  }
  rect->y1 = y;
  y = 25;
  for( ; y >= rect->y1; y = y - 1)
  {
    showline = 0;
    ch = pg->text + (signed long int)(41 * y);
    x = 0;
    for( ; !(x >= 41); x = x + 1)
      if(!((signed int)(ch + (signed long int)x)->unicode == 32))
        showline = 1;

    if(!(showline == 0))
      break;

  }
  rect->y2 = y + 1;
}

// vbi_hasdata
// file ./common/vbi-data.h line 34
signed int vbi_hasdata(struct vbi_state *vbi)
{
  char buf[1l];
  signed int rc;
  if(!(vbi->sim == 0))
  {
    read(vbi->fd, (void *)buf, (unsigned long int)1);
    read_sim(vbi->raw, vbi->sliced, &vbi->lines, &vbi->ts);
    rc = 1;
  }

  else
    rc=vbi_capture_read(vbi->cap, (void *)vbi->raw, vbi->sliced, &vbi->lines, &vbi->ts, &vbi->tv);
  vbi_decode(vbi->dec, vbi->sliced, vbi->lines, vbi->ts);
  return rc;
}

// vbi_is_gfx
// file /usr/include/libzvbi.h line 855
static inline signed int vbi_is_gfx(unsigned int unicode)
{
  return (signed int)(unicode >= (unsigned int)0xEE00 && unicode <= (unsigned int)0xEFFF);
}

// vbi_open
// file ./common/vbi-data.h line 33
struct vbi_state * vbi_open(char *dev, signed int debug, signed int sim)
{
  struct vbi_state *vbi;
  signed int services = 0x40000000 | 0x20000000 | 0x00000001 | 0x00000002 | 0x00000020 | 0x00000040 | 0x00000008 | 0x00000010 | 0x00000004 | 0x00000400 | 0x00000800;
  signed int p[2l];
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct vbi_state) /*88ul*/ );
  vbi = (struct vbi_state *)return_value_malloc_1;
  unsigned long int return_value_strtoul_2;
  void *return_value_malloc_5;
  void *return_value_malloc_6;
  if(!(vbi == ((struct vbi_state *)NULL)))
  {
    memset((void *)vbi, 0, sizeof(struct vbi_state) /*88ul*/ );
    vbi->debug = debug;
    vbi->sim = sim;
    vbi->dec=vbi_decoder_new();
    if(vbi->dec == ((struct vbi_decoder *)NULL))
      goto oops;

    {
      char *env;
      env=getenv("ALEVTD_REGION");
      unsigned int region;
      if(!(env == ((char *)NULL)))
      {
        return_value_strtoul_2=strtoul(env, (char ** restrict )(void *)0, 0);
        region = (unsigned int)return_value_strtoul_2;
        if(!(region == 0u))
          vbi_teletext_set_default_region(vbi->dec, (signed int)region);

      }

    }
    if(!(vbi->sim == 0))
    {
      vbi->par=init_sim(625, (unsigned int)services);
      pipe(p);
      signed int return_value_fork_3;
      return_value_fork_3=fork();
      if(!(return_value_fork_3 == -1))
      {
        if(return_value_fork_3 == 0)
          goto __CPROVER_DUMP_L5;

      }

      else
      {
        perror("fork");
        exit(1);

      __CPROVER_DUMP_L5:
        ;
        close(p[(signed long int)0]);
        do
        {
          signed long int return_value_write_4;
          return_value_write_4=write(p[(signed long int)1], (const void *)"x", (unsigned long int)1);
          if(!(return_value_write_4 == 1l))
            exit(0);

          usleep((unsigned int)(100 * 1000));
        }
        while((_Bool)1);
      }
      vbi->fd = p[(signed long int)0];
      close(p[(signed long int)1]);
    }

    else
    {
      vbi->cap=vbi_capture_v4l2_new(dev, 16, (unsigned int *)&services, -1, &vbi->err, debug);
      if(vbi->cap == ((struct vbi_capture *)NULL))
      {
        vbi->cap=vbi_capture_v4l_new(dev, 16, (unsigned int *)&services, -1, &vbi->err, debug);
        if(vbi->cap == ((struct vbi_capture *)NULL))
          goto oops;

      }

      vbi->par=vbi_capture_parameters(vbi->cap);
      vbi->fd=vbi_capture_fd(vbi->cap);
    }
    vbi->lines = vbi->par->count[(signed long int)0] + vbi->par->count[(signed long int)1];
    return_value_malloc_5=malloc((unsigned long int)(vbi->lines * vbi->par->bytes_per_line));
    vbi->raw = (unsigned char *)return_value_malloc_5;
    if(vbi->raw == ((unsigned char *)NULL))
      goto oops;

    return_value_malloc_6=malloc((unsigned long int)vbi->lines * sizeof(struct anonymous_98) /*64ul*/ );
    vbi->sliced = (struct anonymous_98 *)return_value_malloc_6;
    if(vbi->sliced == ((struct anonymous_98 *)NULL))
      goto oops;

    vbi->tv.tv_sec = (signed long int)1;
    vbi->tv.tv_usec = (signed long int)0;
    return vbi;
  }

  else
  {

  oops:
    ;
    if(!(vbi == ((struct vbi_state *)NULL)))
    {
      if(!(vbi->sliced == ((struct anonymous_98 *)NULL)))
        free((void *)vbi->sliced);

      if(!(vbi->raw == ((unsigned char *)NULL)))
        free((void *)vbi->raw);

      if(!(vbi->cap == ((struct vbi_capture *)NULL)))
        vbi_capture_delete(vbi->cap);

      if(!(vbi->dec == ((struct vbi_decoder *)NULL)))
        vbi_decoder_delete(vbi->dec);

      free((void *)vbi);
    }

    fprintf(stderr, "vbi: open failed [%s]\n", dev);
    return (struct vbi_state *)(void *)0;
  }
}

// vbi_render_free_font
// file x11/vbi-x11.c line 77
void vbi_render_free_font(struct _WidgetRec *shell, struct vbi_window *vw)
{
  if(!(vw->xft_font == ((struct _XftFont *)NULL)))
  {
    struct _XDisplay *return_value_XtDisplay_1;
    return_value_XtDisplay_1=XtDisplay(shell);
    XftFontClose(return_value_XtDisplay_1, vw->xft_font);
    vw->xft_font = (struct _XftFont *)(void *)0;
  }

  if(!(vw->font1 == ((struct anonymous_14 *)NULL)))
  {
    struct _XDisplay *return_value_XtDisplay_2;
    return_value_XtDisplay_2=XtDisplay(shell);
    XFreeFont(return_value_XtDisplay_2, vw->font1);
    vw->font1 = (struct anonymous_14 *)(void *)0;
  }

  if(!(vw->font2 == ((struct anonymous_14 *)NULL)))
  {
    struct _XDisplay *return_value_XtDisplay_3;
    return_value_XtDisplay_3=XtDisplay(shell);
    XFreeFont(return_value_XtDisplay_3, vw->font2);
    vw->font2 = (struct anonymous_14 *)(void *)0;
  }

}

// vbi_render_init
// file x11/vbi-x11.h line 49
struct vbi_window * vbi_render_init(struct _WidgetRec *shell, struct _WidgetRec *tt, struct vbi_state *vbi)
{
  struct vbi_window *vw;
  struct anonymous_22 color;
  struct anonymous_22 dummy;
  signed int i;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct vbi_window) /*9432ul*/ );
  vw = (struct vbi_window *)return_value_malloc_1;
  memset((void *)vw, 0, sizeof(struct vbi_window) /*9432ul*/ );
  vw->shell = shell;
  vw->tt = tt;
  vw->vbi = vbi;
  struct _XDisplay *return_value_XtDisplay_2;
  return_value_XtDisplay_2=XtDisplay(shell);
  struct anonymous_0 *return_value_XtScreen_3;
  return_value_XtScreen_3=XtScreen(shell);
  vw->gc=XCreateGC(return_value_XtDisplay_2, return_value_XtScreen_3->root, (unsigned long int)0, (struct anonymous_75 *)(void *)0);
  XtVaGetValues(tt, (char *)&XtStrings[(signed long int)154], &vw->cmap, (void *)0);
  i = 0;
  for( ; !(i >= 8); i = i + 1)
  {
    struct _XDisplay *return_value_XtDisplay_4;
    return_value_XtDisplay_4=XtDisplay(shell);
    struct anonymous_0 *return_value_XtScreen_5;
    return_value_XtScreen_5=XtScreen(shell);
    XftColorAllocName(return_value_XtDisplay_4, return_value_XtScreen_5->root_visual, vw->cmap, vbi_colors[(signed long int)i], &vw->xft_color[(signed long int)i]);
    struct _XDisplay *return_value_XtDisplay_6;
    return_value_XtDisplay_6=XtDisplay(shell);
    XAllocNamedColor(return_value_XtDisplay_6, vw->cmap, vbi_colors[(signed long int)i], &color, &dummy);
    vw->colors[(signed long int)i] = color.pixel;
  }
  vbi_render_set_font(shell, vw, (char *)(void *)0);
  do
  {
    (&vw->selections)->next = &vw->selections;
    (&vw->selections)->prev = &vw->selections;
  }
  while((_Bool)0);
  return vw;
}

// vbi_render_line
// file x11/vbi-x11.c line 176
void vbi_render_line(struct vbi_window *vw, unsigned long int d, struct vbi_char *ch, signed int y, signed int top, signed int left, signed int right)
{
  struct anonymous_75 values;
  struct anonymous_114 line[42l];
  signed int x1;
  signed int x2;
  signed int i;
  signed int code;
  signed int sy;
  unsigned int wline[42l];
  struct _XftDraw *xft_draw = (struct _XftDraw *)(void *)0;
  x1 = left;
  struct _XDisplay *return_value_XtDisplay_8;
  struct anonymous_0 *return_value_XtScreen_9;
  for( ; !(x1 >= right); x1 = x2)
  {
    x2 = x1;
    for( ; !(x2 >= right); x2 = x2 + 1)
    {
      if(!((ch + (signed long int)x1)->foreground == (ch + (signed long int)x2)->foreground))
        break;

      if(!((ch + (signed long int)x1)->background == (ch + (signed long int)x2)->background))
        break;

      if(!((ch + (signed long int)x1)->size == (ch + (signed long int)x2)->size))
        break;

    }
    sy = 1;
    if(!(vw->font2 == ((struct anonymous_14 *)NULL)))
    {
      _Bool tmp_if_expr_1;
      if((signed int)(ch + (signed long int)x1)->size == 2)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (signed int)(ch + (signed long int)x1)->size == 3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        sy = 2;

      _Bool tmp_if_expr_2;
      if((signed int)(ch + (signed long int)x1)->size == 6)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)(ch + (signed long int)x1)->size == 7 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        goto __CPROVER_DUMP_L25;

    }

    i = x1;
    for( ; !(i >= x2); i = i + 1)
    {
      code = (signed int)(ch + (signed long int)i)->unicode;
      if(!((ch + (signed long int)i)->conceal == 0u))
        code = 32;

      _Bool tmp_if_expr_3;
      if((signed int)(ch + (signed long int)i)->size == 4)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)(ch + (signed long int)i)->size == 5 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_4;
      if(tmp_if_expr_3)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (signed int)(ch + (signed long int)i)->size == 6 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_5;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)(ch + (signed long int)i)->size == 7 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
        code = 32;

      line[(signed long int)(i - x1)].byte1 = (unsigned char)(code >> 8 & 0xff);
      line[(signed long int)(i - x1)].byte2 = (unsigned char)(code & 0xff);
      wline[(signed long int)(i - x1)] = (unsigned int)code;
    }
    values.function = 0x3;
    values.foreground = vw->colors[(signed long int)((signed int)(ch + (signed long int)x1)->background & 7)];
    struct _XDisplay *return_value_XtDisplay_6;
    return_value_XtDisplay_6=XtDisplay(vw->tt);
    XChangeGC(return_value_XtDisplay_6, vw->gc, (unsigned long int)(1L << 2 | 1L << 0), &values);
    struct _XDisplay *return_value_XtDisplay_7;
    return_value_XtDisplay_7=XtDisplay(vw->tt);
    XFillRectangle(return_value_XtDisplay_7, d, vw->gc, (x1 - left) * vw->w, (y - top) * vw->h, (unsigned int)(vw->w * (x2 - x1)), (unsigned int)(vw->h * sy));
    if(!(vw->xft_font == ((struct _XftFont *)NULL)))
    {
      if(xft_draw == ((struct _XftDraw *)NULL))
      {
        return_value_XtDisplay_8=XtDisplay(vw->tt);
        return_value_XtScreen_9=XtScreen(vw->tt);
        xft_draw=XftDrawCreate(return_value_XtDisplay_8, d, return_value_XtScreen_9->root_visual, vw->cmap);
      }

      XftDrawString32(xft_draw, &vw->xft_color[(signed long int)((signed int)(ch + (signed long int)x1)->foreground & 7)], vw->xft_font, (x1 - left) * vw->w, vw->a + (((y - top) + sy) - 1) * vw->h, wline, x2 - x1);
    }

    else
    {
      values.foreground = vw->colors[(signed long int)((signed int)(ch + (signed long int)x1)->foreground & 7)];
      unsigned long int tmp_if_expr_10;
      if(sy == 1)
        tmp_if_expr_10 = vw->font1->fid;

      else
        tmp_if_expr_10 = vw->font2->fid;
      values.font = tmp_if_expr_10;
      struct _XDisplay *return_value_XtDisplay_11;
      return_value_XtDisplay_11=XtDisplay(vw->tt);
      XChangeGC(return_value_XtDisplay_11, vw->gc, (unsigned long int)(1L << 2 | 1L << 14), &values);
      struct _XDisplay *return_value_XtDisplay_12;
      return_value_XtDisplay_12=XtDisplay(vw->tt);
      XDrawString16(return_value_XtDisplay_12, d, vw->gc, (x1 - left) * vw->w, vw->a + (((y - top) + sy) - 1) * vw->h, line, x2 - x1);
    }

  __CPROVER_DUMP_L25:
    ;
  }
  if(!(xft_draw == ((struct _XftDraw *)NULL)))
    XftDrawDestroy(xft_draw);

}

// vbi_render_set_font
// file x11/vbi-x11.c line 95
void vbi_render_set_font(struct _WidgetRec *shell, struct vbi_window *vw, char *label)
{
  struct _FcPattern *pattern;
  enum _FcResult rc;
  signed int i;
  vbi_render_free_font(shell, vw);
  if(!(label == ((char *)NULL)))
  {
    i = 0;
    for( ; !(vbi_fonts[(signed long int)i].label == ((char *)NULL)); i = i + 1)
    {
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(label, vbi_fonts[(signed long int)i].label);
      if(return_value_strcasecmp_1 == 0)
      {
        signed int return_value_vbi_render_try_font_2;
        return_value_vbi_render_try_font_2=vbi_render_try_font(shell, vw, &vbi_fonts[(signed long int)i]);
        if(return_value_vbi_render_try_font_2 == 0)
          goto __CPROVER_DUMP_L10;

      }

    }
    pattern=FcNameParse((const unsigned char *)label);
    struct _XDisplay *return_value_XtDisplay_3;
    return_value_XtDisplay_3=XtDisplay(shell);
    struct anonymous_0 *return_value_XtScreen_4;
    return_value_XtScreen_4=XtScreen(shell);
    signed int return_value_XScreenNumberOfScreen_5;
    return_value_XScreenNumberOfScreen_5=XScreenNumberOfScreen(return_value_XtScreen_4);
    pattern=XftFontMatch(return_value_XtDisplay_3, return_value_XScreenNumberOfScreen_5, pattern, &rc);
    struct _XDisplay *return_value_XtDisplay_6;
    return_value_XtDisplay_6=XtDisplay(shell);
    vw->xft_font=XftFontOpenPattern(return_value_XtDisplay_6, pattern);
    if(!(vw->xft_font == ((struct _XftFont *)NULL)))
    {
      vw->a = vw->xft_font->ascent;
      vw->d = vw->xft_font->descent;
      vw->w = vw->xft_font->max_advance_width;
      vw->h = vw->xft_font->height;
      goto __CPROVER_DUMP_L10;
    }

  }

  i = 0;
  for( ; !(vbi_fonts[(signed long int)i].label == ((char *)NULL)); i = i + 1)
  {
    signed int return_value_vbi_render_try_font_7;
    return_value_vbi_render_try_font_7=vbi_render_try_font(shell, vw, &vbi_fonts[(signed long int)i]);
    if(return_value_vbi_render_try_font_7 == 0)
      goto __CPROVER_DUMP_L10;

  }
  fprintf(stderr, "Oops: can't load any font\n");
  exit(1);

__CPROVER_DUMP_L10:
  ;
}

// vbi_render_try_font
// file x11/vbi-x11.c line 59
static signed int vbi_render_try_font(struct _WidgetRec *shell, struct vbi_window *vw, struct vbi_font *fnt)
{
  struct _XDisplay *return_value_XtDisplay_2;
  if(vw->xft_font == ((struct _XftFont *)NULL))
  {
    if(!(fnt->xlfd1 == ((char *)NULL)))
    {
      struct _XDisplay *return_value_XtDisplay_1;
      return_value_XtDisplay_1=XtDisplay(shell);
      vw->font1=XLoadQueryFont(return_value_XtDisplay_1, fnt->xlfd1);
      if(!(fnt->xlfd2 == ((char *)NULL)))
      {
        return_value_XtDisplay_2=XtDisplay(shell);
        vw->font2=XLoadQueryFont(return_value_XtDisplay_2, fnt->xlfd2);
      }

      if(!(vw->font1 == ((struct anonymous_14 *)NULL)))
      {
        vw->a = (signed int)vw->font1->max_bounds.ascent;
        vw->d = (signed int)vw->font1->max_bounds.descent;
        vw->w = (signed int)vw->font1->max_bounds.width;
        vw->h = vw->a + vw->d;
        return 0;
      }

    }

  }

  return 1;
}

// vdr_handler
// file common/commands.c line 1293
static signed int vdr_handler(char *name, signed int argc, char **argv)
{
  char line[80l];
  struct addrinfo ask;
  signed int i;
  signed int rc;
  unsigned int l;
  unsigned int len;

reconnect:
  ;
  signed long int return_value_write_4;
  signed int *return_value___errno_location_3;
  for( ; (_Bool)1; vdr_sock = -1)
  {
    if(vdr_sock == -1)
    {
      memset((void *)&ask, 0, sizeof(struct addrinfo) /*48ul*/ );
      ask.ai_family = 0;
      ask.ai_socktype = 1;
      vdr_sock=tcp_connect(&ask, "localhost", "2001");
      if(vdr_sock == -1)
        return -1;

      if(!(debug == 0))
        fprintf(stderr, "vdr: connected\n");

      signed int return_value_tcp_readbuf_1;
      return_value_tcp_readbuf_1=tcp_readbuf(vdr_sock, 3, line, (char)sizeof(char [80l]) /*80ul*/ );
      if(return_value_tcp_readbuf_1 == -1)
        goto oops;

      if(!(debug == 0))
        fprintf(stderr, "vdr: << %s", (const void *)line);

    }

    line[(signed long int)0] = (char)0;
    i = 0;
    len = (unsigned int)0;
    for( ; !(i >= argc); i = i + 1)
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(argv[(signed long int)i]);
      l = (unsigned int)return_value_strlen_2;
      if((unsigned long int)(4u + l + len) >= 81ul)
        break;

      if(!(len == 0u))
      {
        strcpy(line + (signed long int)len, " ");
        len = len + 1u;
      }

      strcpy(line + (signed long int)len, argv[(signed long int)i]);
      len = len + l;
    }
    strcpy(line + (signed long int)len, "\r\n");
    len = len + (unsigned int)2;
    return_value_write_4=write(vdr_sock, (const void *)line, (unsigned long int)len);
    rc = (signed int)return_value_write_4;
    if(len == (unsigned int)rc)
      goto __CPROVER_DUMP_L14;

    if(!(rc == -1))
      goto __CPROVER_DUMP_L12;

    return_value___errno_location_3=__errno_location();
    if(!(*return_value___errno_location_3 == 32))
      break;

    if(!(debug == 0))
      fprintf(stderr, "tcp: write: broken pipe, trying reconnect\n");

    close(vdr_sock);
  }

__CPROVER_DUMP_L12:
  ;
  if(!(debug == 0))
    perror("tcp: write");

  goto oops;

__CPROVER_DUMP_L14:
  ;
  if(!(debug == 0))
    fprintf(stderr, "vdr: >> %s", (const void *)line);

  signed int return_value_tcp_readbuf_5;
  return_value_tcp_readbuf_5=tcp_readbuf(vdr_sock, 3, line, (char)sizeof(char [80l]) /*80ul*/ );
  if(!(return_value_tcp_readbuf_5 == -1))
  {
    if(!(debug == 0))
      fprintf(stderr, "vdr: << %s", (const void *)line);

    return 0;
  }

  else
  {

  oops:
    ;
    close(vdr_sock);
    vdr_sock = -1;
    return -1;
  }
}

// video_close
// file x11/x11.c line 758
void video_close(void)
{
  unsigned long int root;
  struct _XDisplay *return_value_XtDisplay_1;
  return_value_XtDisplay_1=XtDisplay(video);
  struct _XDisplay *return_value_XtDisplay_2;
  return_value_XtDisplay_2=XtDisplay(video);
  root = (&((struct anonymous_10 *)return_value_XtDisplay_1)->screens[(signed long int)((struct anonymous_10 *)return_value_XtDisplay_2)->default_screen])->root;
  if(!(overlay_refresh == 0ul))
    XtRemoveTimeOut(overlay_refresh);

  struct _XDisplay *return_value_XtDisplay_3;
  return_value_XtDisplay_3=XtDisplay(video);
  XSelectInput(return_value_XtDisplay_3, root, (signed long int)0);
  struct _XDisplay *return_value_XtDisplay_4;
  return_value_XtDisplay_4=XtDisplay(video);
  XtUnregisterDrawable(return_value_XtDisplay_4, root);
}

// video_event
// file x11/x11.c line 576
static void video_event(struct _WidgetRec *widget, void *client_data, union _XEvent *event, char *d)
{
  unsigned long int return_value_XtWindow_1;
  unsigned long int return_value_XtWindow_2;
  unsigned long int return_value_XtWindow_3;
  if(widget == video_parent)
  {
    switch(event->type)
    {
      case 22:
      {
        video_new_size();
        break;
      }
      case 19:
      {
        if(debug >= 2)
          fprintf(stderr, "video: shell: map\n");

        wmap = 1;
        conf = 1;
        configure_overlay();
        break;
      }
      case 18:
      {
        if(debug >= 2)
          fprintf(stderr, "video: shell: unmap\n");

        wmap = 0;
        conf = 1;
        configure_overlay();
        break;
      }
      default:
        if(debug >= 2)
          fprintf(stderr, "video: shell: %s\n", event_names[(signed long int)event->type]);

    }
    goto __CPROVER_DUMP_L26;
  }

  else
    switch(event->type)
    {
      case 12:
      {
        return_value_XtWindow_1=XtWindow(video);
        if(event->xvisibility.window == return_value_XtWindow_1)
        {
          if(event->xexpose.count == 0)
          {
            if(!(did_refresh == 0))
            {
              did_refresh = 0;
              if(debug >= 2)
                fprintf(stderr, "video: tv: last refresh expose\n");

            }

            else
            {
              if(debug >= 2)
                fprintf(stderr, "video: tv: expose\n");

              conf = 1;
              configure_overlay();
            }
          }

        }

        break;
      }
      case 15:
      {
        return_value_XtWindow_2=XtWindow(video);
        if(event->xvisibility.window == return_value_XtWindow_2)
        {
          visibility = event->xvisibility.state;
          if(debug >= 2)
            fprintf(stderr, "video: tv: visibility %d%s\n", event->xvisibility.state, did_refresh != 0 ? " (ignored)" : "");

          if(!(did_refresh == 0))
          {
            if(!(event->xvisibility.state == 2))
              did_refresh = 0;

          }

          else
          {
            conf = 1;
            configure_overlay();
          }
        }

        else
          if(debug >= 2)
            fprintf(stderr, "video: root: visibility\n");

        break;
      }
      case 19:

      case 18:

      case 22:
      {
        return_value_XtWindow_3=XtWindow(video);
        if(!(event->xvisibility.window == return_value_XtWindow_3))
        {
          if(debug >= 2)
            fprintf(stderr, "video: root: %s%s\n", event_names[(signed long int)event->type], did_refresh != 0 ? " (ignored)" : "");

          if(did_refresh == 0)
            configure_overlay();

        }

        break;
      }
      default:
        if(debug >= 2)
          fprintf(stderr, "video: tv(+root): %s\n", event_names[(signed long int)event->type]);

    }

__CPROVER_DUMP_L26:
  ;
}

// video_gd_blitframe
// file x11/x11.c line 152
signed int video_gd_blitframe(struct video_handle *h, struct ng_video_buf *buf)
{
  _Bool tmp_if_expr_1;
  if(!(cur_tv_width >= buf->fmt.width))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = buf->fmt.height > cur_tv_height ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    ng_release_video_buf(buf);
    return -1;
  }

  else
  {
    if(!(cur_filter == ((struct ng_filter *)NULL)))
      buf=video_gd_filter(h, buf);

    blit_putframe(h->blit, buf);
    return 0;
  }
}

// video_gd_configure
// file x11/x11.h line 18
void video_gd_configure(signed int width, signed int height)
{
  struct video_handle *h = &vh;
  unsigned int i;
  unsigned int fmtids[38l];
  unsigned long int return_value_XtWindow_1;
  if(!((2 & f_drv) == 0))
  {
    blit_resize(h->blit, (unsigned short int)width, (unsigned short int)height);
    if(!(h->suspend == 0))
    {
      if(!(debug == 0))
        fprintf(stderr, "gd: delay configure\n");

      h->nw = width;
      h->nh = height;
    }

    else
    {
      if(!(debug == 0))
      {
        return_value_XtWindow_1=XtWindow(h->win);
        fprintf(stderr, "gd: config %dx%d win=%lx\n", width, height, return_value_XtWindow_1);
      }

      unsigned long int return_value_XtWindow_2;
      return_value_XtWindow_2=XtWindow(h->win);
      if(!(return_value_XtWindow_2 == 0ul))
      {
        cur_tv_width = (unsigned int)width;
        cur_tv_height = (unsigned int)height;
        h->best.width = (unsigned int)width;
        h->best.height = (unsigned int)height;
        h->best.bytesperline = (unsigned int)0;
        ng_ratio_fixup((signed int *)&cur_tv_width, (signed int *)&cur_tv_height, (signed int *)(void *)0, (signed int *)(void *)0);
        ng_ratio_fixup((signed int *)&h->best.width, (signed int *)&h->best.height, (signed int *)(void *)0, (signed int *)(void *)0);
        if(h->best.fmtid == 0u)
        {
          blit_get_formats(h->blit, (signed int *)fmtids, (signed int)(sizeof(unsigned int [38l]) /*152ul*/  / sizeof(signed int) /*4ul*/ ));
          i = (unsigned int)0;
          for( ; !((unsigned long int)i >= 38ul); i = i + 1u)
          {
            h->best.fmtid = fmtids[(signed long int)i];
            signed int return_value_ng_grabber_setformat_3;
            return_value_ng_grabber_setformat_3=ng_grabber_setformat(&h->best, 0);
            if(return_value_ng_grabber_setformat_3 == 0)
              goto done;

          }
          h->best.fmtid = (unsigned int)0;
        }


      done:
        ;
        if(!(debug == 0))
          fprintf(stderr, "grabdisplay: using \"%s\"\n", ng_vfmt_to_desc[(signed long int)h->best.fmtid]);

        if(cur_capture == 2)
        {
          do_va_cmd(2, (const void *)"capture", (const void *)"off");
          do_va_cmd(2, (const void *)"capture", (const void *)"grab");
        }

      }

    }
  }

}

// video_gd_filter
// file x11/x11.c line 128
static struct ng_video_buf * video_gd_filter(struct video_handle *h, struct ng_video_buf *buf)
{
  if(!(h->filter == ((struct ng_filter *)NULL)))
  {
    _Bool tmp_if_expr_1;
    if(!(cur_filter == h->filter))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = buf->fmt.fmtid != h->ffmt.fmtid ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_2;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = buf->fmt.width != h->ffmt.width ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_3;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = buf->fmt.height != h->ffmt.height ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      h->filter->fini(h->fhandle);
      h->filter = (struct ng_filter *)(void *)0;
      h->fhandle = (void *)0;
      memset((void *)&h->ffmt, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
    }

  }

  if(!((cur_filter->fmts & 1 << buf->fmt.fmtid) == 0))
  {
    if(h->filter == ((struct ng_filter *)NULL))
    {
      h->filter = cur_filter;
      h->fhandle=h->filter->init(&buf->fmt);
      h->ffmt = buf->fmt;
    }

    buf=cur_filter->frame(h->fhandle, buf);
  }

  return buf;
}

// video_gd_idle
// file x11/x11.c line 167
static char video_gd_idle(void *data)
{
  struct video_handle *h = (struct video_handle *)data;
  struct ng_video_buf *buf;
  if(!((2 & f_drv) == 0))
  {
    buf=ng_grabber_grab_image(0);
    if(!(buf == ((struct ng_video_buf *)NULL)))
      video_gd_blitframe(h, buf);

    else
      goto oops;
    if(!(debug == 0))
    {
      struct timeval t;
      struct timezone tz;
      gettimeofday(&t, &tz);
      static signed long int video_gd_idle__1__3__count;
      static signed long int lastsec;
      if(!(t.tv_sec == lastsec))
      {
        if(lastsec == t.tv_sec + -1l)
          fprintf(stderr, "%5ld fps \r", video_gd_idle__1__3__count);

        lastsec = t.tv_sec;
        video_gd_idle__1__3__count = (signed long int)0;
      }

      video_gd_idle__1__3__count = video_gd_idle__1__3__count + 1l;
    }

    return (char)0;
  }

  else
  {

  oops:
    ;
    h->work_id = (unsigned long int)0;
    if(!((2 & f_drv) == 0))
      drv->stopvideo(h_drv);

    return (char)1;
  }
}

// video_gd_init
// file x11/x11.h line 13
void video_gd_init(struct _WidgetRec *widget, signed int use_gl)
{
  struct video_handle *h = &vh;
  if(!(debug == 0))
    fprintf(stderr, "gd: init\n");

  h->win = widget;
  h->blit=blit_init(h->win, &vinfo, use_gl);
}

// video_gd_restart
// file x11/x11.h line 17
void video_gd_restart(void)
{
  struct video_handle *h = &vh;
  if(!(h->suspend == 0))
  {
    h->suspend = 0;
    if(!(h->nw == 0))
    {
      if(!(h->nh == 0))
      {
        video_gd_configure(h->nw, h->nh);
        h->nw = 0;
        h->nh = 0;
      }

    }

    if(cur_capture == 0)
      do_va_cmd(3, (const void *)"capture", (const void *)"grab", (const void *)"temp");

  }

}

// video_gd_start
// file x11/x11.h line 14
void video_gd_start(void)
{
  struct video_handle *h = &vh;
  if(!(debug == 0))
    fprintf(stderr, "gd: start [%d]\n", h->best.fmtid);

  if(!(h->best.fmtid == 0u))
  {
    signed int return_value_ng_grabber_setformat_1;
    return_value_ng_grabber_setformat_1=ng_grabber_setformat(&h->best, 0);
    if(return_value_ng_grabber_setformat_1 == 0)
    {
      drv->startvideo(h_drv, -1, (unsigned int)2);
      h->work_id=XtAppAddWorkProc(app_context, video_gd_idle, (void *)h);
    }

  }

}

// video_gd_stop
// file x11/x11.h line 15
void video_gd_stop(void)
{
  struct video_handle *h = &vh;
  if(!(debug == 0))
    fprintf(stderr, "gd: stop\n");

  if(!(h->work_id == 0ul))
  {
    drv->stopvideo(h_drv);
    XtRemoveWorkProc(h->work_id);
    h->work_id = (unsigned long int)0;
    blit_fini_frame(h->blit);
  }

}

// video_gd_suspend
// file x11/x11.h line 16
void video_gd_suspend(void)
{
  struct video_handle *h = &vh;
  h->suspend = 1;
  if(cur_capture == 2)
    do_va_cmd(3, (const void *)"capture", (const void *)"off", (const void *)"temp");

}

// video_init
// file x11/x11.h line 23
struct _WidgetRec * video_init(struct _WidgetRec *parent, struct anonymous_1 *vinfo, struct _WidgetClassRec *class, signed int args_bpp, signed int args_gl)
{
  unsigned long int root;
  struct _XDisplay *return_value_XtDisplay_1;
  return_value_XtDisplay_1=XtDisplay(parent);
  struct _XDisplay *return_value_XtDisplay_2;
  return_value_XtDisplay_2=XtDisplay(parent);
  root = (&((struct anonymous_10 *)return_value_XtDisplay_1)->screens[(signed long int)((struct anonymous_10 *)return_value_XtDisplay_2)->default_screen])->root;
  struct anonymous_0 *return_value_XtScreen_3;
  return_value_XtScreen_3=XtScreen(parent);
  swidth = (unsigned int)return_value_XtScreen_3->width;
  struct anonymous_0 *return_value_XtScreen_4;
  return_value_XtScreen_4=XtScreen(parent);
  sheight = (unsigned int)return_value_XtScreen_4->height;
  x11_overlay_fmtid = (signed int)x11_dpy_fmtid;
  struct _XDisplay *return_value_XtDisplay_5;
  return_value_XtDisplay_5=XtDisplay(parent);
  if(((struct anonymous_10 *)return_value_XtDisplay_5)->byte_order == 1)
    switch(args_bpp)
    {
      case 8:
      {
        x11_overlay_fmtid = 1;
        break;
      }
      case 15:
      {
        x11_overlay_fmtid = 5;
        break;
      }
      case 16:
      {
        x11_overlay_fmtid = 6;
        break;
      }
      case 24:
      {
        x11_overlay_fmtid = 7;
        break;
      }
      case 32:
        x11_overlay_fmtid = 8;
    }

  else
    switch(args_bpp)
    {
      case 8:
      {
        x11_overlay_fmtid = 1;
        break;
      }
      case 15:
      {
        x11_overlay_fmtid = 3;
        break;
      }
      case 16:
      {
        x11_overlay_fmtid = 4;
        break;
      }
      case 24:
      {
        x11_overlay_fmtid = 7;
        break;
      }
      case 32:
        x11_overlay_fmtid = 8;
    }
  video_parent = parent;
  video=XtVaCreateManagedWidget("tv", class, parent, (void *)0);
  XtAddEventHandler(parent, (unsigned long int)(1L << 17), (char)1, video_event, (void *)0);
  if(have_xv == 0)
  {
    XtAddEventHandler(video, (unsigned long int)(1L << 16 | 1L << 17), (char)0, video_event, (void *)0);
    struct _XDisplay *return_value_XtDisplay_6;
    return_value_XtDisplay_6=XtDisplay(video);
    XSelectInput(return_value_XtDisplay_6, root, 1L << 16 | 1L << 19 | 1L << 17);
    struct _XDisplay *return_value_XtDisplay_7;
    return_value_XtDisplay_7=XtDisplay(video);
    XtRegisterDrawable(return_value_XtDisplay_7, root, video);
  }

  return video;
}

// video_new_size
// file x11/x11.c line 553
void video_new_size(void)
{
  unsigned short int x;
  unsigned short int y;
  unsigned short int w;
  unsigned short int h;
  XtVaGetValues(video_parent, (char *)&XtStrings[(signed long int)885], &x, (char *)&XtStrings[(signed long int)887], &y, (char *)&XtStrings[(signed long int)872], &w, (char *)&XtStrings[(signed long int)234], &h, (void *)0);
  wx = (signed int)x;
  if(wx >= 32769)
    wx = wx - 65536;

  wy = (signed int)y;
  if(wy >= 32769)
    wy = wy - 65536;

  wfmt.width = (unsigned int)w;
  if(wfmt.width >= 32769u)
    wfmt.width = wfmt.width - (unsigned int)65536;

  wfmt.height = (unsigned int)h;
  if(wfmt.height >= 32769u)
    wfmt.height = wfmt.height - (unsigned int)65536;

  wfmt.fmtid = (unsigned int)x11_overlay_fmtid;
  if(debug >= 2)
    fprintf(stderr, "video: shell: size %dx%d+%d+%d\n", wfmt.width, wfmt.height, wx, wy);

  conf = 1;
  move = 1;
  configure_overlay();
}

// video_overlay
// file x11/x11.h line 21
void video_overlay(signed int state)
{
  if(!(state == 0))
  {
    conf = 1;
    overlay_enabled = 1;
    configure_overlay();
  }

  else
  {
    if(overlay_enabled == 1)
    {
      if(!(have_xv == 0))
      {
        unsigned long int return_value_XtWindow_1;
        return_value_XtWindow_1=XtWindow(video);
        xv_video(return_value_XtWindow_1, 0, 0, 0);
      }

      else
      {
        overlay_on = 0;
        if(!((1 & f_drv) == 0))
          drv->overlay(h_drv, (struct ng_video_fmt *)(void *)0, 0, 0, (struct OVERLAY_CLIP *)(void *)0, 0, 0);

        overlay_refresh=XtAppAddTimeOut(app_context, (unsigned long int)200, refresh_timer, (void *)0);
      }
    }

    overlay_enabled = 0;
  }
}

// vidmode_timer
// file x11/xt.c line 820
static void vidmode_timer(void *clientData, unsigned long int *id)
{
  do_va_cmd(2, (const void *)"capture", (const void *)"on");
}

// visual_init
// file x11/xt.h line 186
void visual_init(char *n1, char *n2)
{
  struct anonymous_8 *visual;
  struct anonymous_1 *vinfo_list;
  signed int n;
  struct _XDisplay *return_value_XtDisplay_1;
  return_value_XtDisplay_1=XtDisplay(app_shell);
  visual=x11_find_visual(return_value_XtDisplay_1);
  vinfo.visualid=XVisualIDFromVisual(visual);
  vinfo_list=XGetVisualInfo(dpy, (signed long int)0x1, &vinfo, &n);
  vinfo = vinfo_list[(signed long int)0];
  XFree((void *)vinfo_list);
  struct anonymous_0 *return_value_XtScreen_4;
  return_value_XtScreen_4=XtScreen(app_shell);
  if(!(visual == return_value_XtScreen_4->root_visual))
  {
    fprintf(stderr, "switching visual (0x%lx)\n", vinfo.visualid);
    struct anonymous_0 *return_value_XtScreen_2;
    return_value_XtScreen_2=XtScreen(app_shell);
    colormap=XCreateColormap(dpy, return_value_XtScreen_2->root, vinfo.visual, 0);
    XtDestroyWidget(app_shell);
    app_shell=XtVaAppCreateShell(n1, n2, applicationShellWidgetClass, dpy, (char *)&XtShellStrings[(signed long int)104], vinfo.visual, (char *)&XtStrings[(signed long int)154], colormap, (char *)&XtStrings[(signed long int)163], vinfo.depth, (void *)0);
  }

  else
  {
    struct anonymous_0 *return_value_XtScreen_3;
    return_value_XtScreen_3=XtScreen(app_shell);
    colormap = return_value_XtScreen_3->cmap;
  }
  struct _XDisplay *return_value_XtDisplay_5;
  return_value_XtDisplay_5=XtDisplay(app_shell);
  x11_init_visual(return_value_XtDisplay_5, &vinfo);
}

// volume_handler
// file common/commands.c line 796
static signed int volume_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *vol;
  vol=ng_attr_byid(attrs, 3);
  signed int return_value_strcasecmp_3;
  if(!(argc == 0))
  {
    return_value_strcasecmp_3=strcasecmp(argv[(signed long int)0], "mute");
    if(return_value_strcasecmp_3 == 0)
    {
      if(argc >= 2)
      {
        signed int return_value_str_to_int_1;
        return_value_str_to_int_1=str_to_int(argv[(signed long int)1], booltab);
        switch(return_value_str_to_int_1)
        {
          case 0:
          {
            set_mute(0);
            break;
          }
          case 1:
          {
            set_mute(1);
            break;
          }
          default:
            set_mute((signed int)!(cur_attrs[(signed long int)4] != 0));
        }
      }

      else
        set_mute((signed int)!(cur_attrs[(signed long int)4] != 0));
    }

    else
      if(!(vol == ((struct ng_attribute *)NULL)))
      {
        signed int return_value;
        return_value=vol->read(vol);
        signed int return_value_update_int_2;
        return_value_update_int_2=update_int(vol, return_value, argv[(signed long int)0]);
        set_volume(return_value_update_int_2);
      }

    if(!(volume_notify == ((void (*)(void))NULL)))
      volume_notify();

  }


display:
  ;
  if(!(cur_attrs[4l] == 0))
    set_msg_str("volume", "muted");

  else
    if(!(vol == ((struct ng_attribute *)NULL)))
      set_msg_int(vol, cur_attrs[(signed long int)3]);

    else
      set_msg_str("volume", "unmuted");
  return 0;
}

// watch_audio
// file x11/motv.c line 242
static void watch_audio(void *data, unsigned long int *id)
{
  if(!(cur_sender == -1))
    change_audio(channels[(signed long int)cur_sender]->audio);

  audio_timer = (unsigned long int)0;
}

// wav_init_header
// file libng/writefile.c line 233
static void wav_init_header(struct WAVEHDR *fileheader, struct ng_audio_fmt *audio)
{
  signed int nBitsPerSample = (signed int)ng_afmt_to_bits[(signed long int)audio->fmtid];
  signed int wav_init_header__1__channels = (signed int)ng_afmt_to_channels[(signed long int)audio->fmtid];
  signed int rate = (signed int)audio->rate;
  unsigned long int nBlockAlign = (unsigned long int)(wav_init_header__1__channels * ((nBitsPerSample + 7) / 8));
  unsigned long int nAvgBytesPerSec = nBlockAlign * (unsigned long int)rate;
  unsigned long int temp = ((unsigned long int)0 + sizeof(struct WAVEHDR) /*44ul*/ ) - sizeof(struct CHUNKHDR) /*8ul*/ ;
  fileheader->chkRiff.ckid = (unsigned int)(unsigned char)82 | (unsigned int)(unsigned char)73 << 8 | (unsigned int)(unsigned char)70 << 16 | (unsigned int)(unsigned char)70 << 24;
  fileheader->fccWave = (unsigned int)(unsigned char)87 | (unsigned int)(unsigned char)65 << 8 | (unsigned int)(unsigned char)86 << 16 | (unsigned int)(unsigned char)69 << 24;
  fileheader->chkFmt.ckid = (unsigned int)(unsigned char)102 | (unsigned int)(unsigned char)109 << 8 | (unsigned int)(unsigned char)116 << 16 | (unsigned int)(unsigned char)32 << 24;
  fileheader->chkFmt.dwSize = (unsigned int)16;
  fileheader->wFormatTag = (unsigned short int)1;
  fileheader->nChannels = (unsigned short int)wav_init_header__1__channels;
  fileheader->nSamplesPerSec = (unsigned int)rate;
  fileheader->nAvgBytesPerSec = (unsigned int)nAvgBytesPerSec;
  fileheader->nBlockAlign = (unsigned short int)nBlockAlign;
  fileheader->wBitsPerSample = (unsigned short int)nBitsPerSample;
  fileheader->chkData.ckid = (unsigned int)(unsigned char)100 | (unsigned int)(unsigned char)97 << 8 | (unsigned int)(unsigned char)116 << 16 | (unsigned int)(unsigned char)97 << 24;
  fileheader->chkRiff.dwSize = (unsigned int)temp;
  fileheader->chkData.dwSize = (unsigned int)0;
}

// wav_start_write
// file libng/writefile.c line 261
static void wav_start_write(signed int fd, struct WAVEHDR *fileheader, struct ng_audio_fmt *audio)
{
  wav_init_header(fileheader, audio);
  write(fd, (const void *)fileheader, sizeof(struct WAVEHDR) /*44ul*/ );
}

// wav_stop_write
// file libng/writefile.c line 268
static void wav_stop_write(signed int fd, struct WAVEHDR *fileheader, signed int wav_size)
{
  unsigned long int temp = ((unsigned long int)wav_size + sizeof(struct WAVEHDR) /*44ul*/ ) - sizeof(struct CHUNKHDR) /*8ul*/ ;
  fileheader->chkRiff.dwSize = (unsigned int)temp;
  fileheader->chkData.dwSize = (unsigned int)wav_size;
  lseek(fd, (signed long int)0, 0);
  write(fd, (const void *)fileheader, sizeof(struct WAVEHDR) /*44ul*/ );
}

// webcam_exit
// file common/webcam.c line 118
void webcam_exit(void)
{
  if(!(web == ((struct WEBCAM *)NULL)))
  {
    pthread_cancel(tweb);
    free((void *)web);
    web = (struct WEBCAM *)(void *)0;
  }

}

// webcam_handler
// file common/commands.c line 1115
static signed int webcam_handler(char *hname, signed int argc, char **argv)
{
  struct ng_video_fmt webcam_handler__1__fmt;
  struct ng_video_buf *buf;
  if(!(webcam == ((char *)NULL)))
    free((void *)webcam);

  webcam=strdup(argv[(signed long int)0]);
  if(!(cur_movie == 0))
    return 0;

  else
    if(cur_capture == 2)
      return 0;

    else
    {
      if(!(capture_get_hook == ((void (*)(void))NULL)))
        capture_get_hook();

      memset((void *)&webcam_handler__1__fmt, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
      webcam_handler__1__fmt.fmtid = (unsigned int)9;
      webcam_handler__1__fmt.width = cur_tv_width;
      webcam_handler__1__fmt.height = cur_tv_height;
      buf=ng_grabber_get_image(&webcam_handler__1__fmt);
      if(!(buf == ((struct ng_video_buf *)NULL)))
        ng_release_video_buf(buf);

      if(!(capture_rel_hook == ((void (*)(void))NULL)))
        capture_rel_hook();

      return 0;
    }
}

// webcam_init
// file common/webcam.c line 108
void webcam_init(void)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct WEBCAM) /*104ul*/ );
  web = (struct WEBCAM *)return_value_malloc_1;
  memset((void *)web, 0, sizeof(struct WEBCAM) /*104ul*/ );
  pthread_mutex_init(&web->lock, (const union anonymous_121 *)(void *)0);
  pthread_create(&tweb, (const union pthread_attr_t *)(void *)0, webcam_writer, (void *)web);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// webcam_put
// file common/webcam.c line 128
signed int webcam_put(char *filename, struct ng_video_buf *buf)
{
  signed int ret = 0;
  if(web == ((struct WEBCAM *)NULL))
    webcam_init();

  signed int return_value_pthread_mutex_trylock_1;
  return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&web->lock);
  if(return_value_pthread_mutex_trylock_1 == -1)
  {
    if(!(debug == 0))
      fprintf(stderr, "webcam_put: locked\n");

    return -1;
  }

  else
  {
    if(!(web->buf == ((struct ng_video_buf *)NULL)))
    {
      if(!(debug == 0))
        fprintf(stderr, "webcam_put: still has data\n");

      ret = -1;
    }

    else
    {
      web->filename=strdup(filename);
      web->buf = buf;
      buf->refcount = buf->refcount + 1;
      if(!(debug == 0))
        fprintf(stderr, "webcam_put: ok\n");

      pthread_cond_signal(&web->wait);
    }

  done:
    ;
    pthread_mutex_unlock(&web->lock);
    return ret;
  }
}

// webcam_writer
// file common/webcam.c line 30
static void * webcam_writer(void *arg)
{
  struct WEBCAM *webcam_writer__1__web = (struct WEBCAM *)arg;
  signed int rename;
  signed int fd;
  signed int old;
  char tmpfilename[512l];
  struct ng_video_fmt *webcam_writer__1__fmt;
  if(!(debug == 0))
    fprintf(stderr, "webcam_writer start\n");

  pthread_setcancelstate(0, &old);
  pthread_setcanceltype(1, &old);
  pthread_mutex_lock(&webcam_writer__1__web->lock);

__CPROVER_DUMP_L2:
  ;
  for( ; (_Bool)1; webcam_writer__1__web->buf = (struct ng_video_buf *)(void *)0)
  {
    if(webcam_writer__1__web->buf == ((struct ng_video_buf *)NULL))
    {
      if(!(debug == 0))
        fprintf(stderr, "webcam_writer: waiting for data\n");

      pthread_cond_wait(&webcam_writer__1__web->wait, &webcam_writer__1__web->lock);
      goto __CPROVER_DUMP_L2;
    }

    webcam_writer__1__fmt = &webcam_writer__1__web->buf->fmt;
    if(!(debug == 0))
      fprintf(stderr, "webcam_writer: %d %dx%d \n", webcam_writer__1__fmt->fmtid, webcam_writer__1__fmt->width, webcam_writer__1__fmt->height);

    rename = 1;
    sprintf(tmpfilename, "%s.___", webcam_writer__1__web->filename);
    switch(webcam_writer__1__fmt->fmtid)
    {
      case (unsigned int)16:

      case (unsigned int)17:
      {
        fd=open(tmpfilename, 0100 | 01, 0666);
        if(fd == -1)
        {
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          char *return_value_strerror_2;
          return_value_strerror_2=strerror(*return_value___errno_location_1);
          fprintf(stderr, "open(%s): %s\n", (const void *)tmpfilename, return_value_strerror_2);
          goto done;
        }

        write(fd, (const void *)webcam_writer__1__web->buf->data, webcam_writer__1__web->buf->size);
        close(fd);
        break;
      }
      case (unsigned int)9:
      {
        write_jpeg(tmpfilename, webcam_writer__1__web->buf, ng_jpeg_quality, 0);
        break;
      }
      default:
      {
        fprintf(stderr, "webcam_writer: can't deal with format=%d\n", webcam_writer__1__fmt->fmtid);
        rename = 0;
      }
    }
    if(!(rename == 0))
    {
      unlink(webcam_writer__1__web->filename);
      signed int return_value_link_5;
      return_value_link_5=link(tmpfilename, webcam_writer__1__web->filename);
      if(return_value_link_5 == -1)
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        char *return_value_strerror_4;
        return_value_strerror_4=strerror(*return_value___errno_location_3);
        fprintf(stderr, "link(%s,%s): %s\n", (const void *)tmpfilename, webcam_writer__1__web->filename, return_value_strerror_4);
        break;
      }

      unlink(tmpfilename);
    }

    free((void *)webcam_writer__1__web->filename);
    ng_release_video_buf(webcam_writer__1__web->buf);
  }

done:
  ;
  pthread_mutex_unlock(&webcam_writer__1__web->lock);
  if(!(debug == 0))
    fprintf(stderr, "webcam_writer done\n");

  return (void *)0;
}

// wm_check_capability
// file x11/wmhooks.c line 97
static signed int wm_check_capability(struct _XDisplay *dpy, unsigned long int root, unsigned long int list, unsigned long int wanted)
{
  unsigned long int type;
  signed int format;
  unsigned int i;
  unsigned long int nitems;
  unsigned long int bytesafter;
  unsigned char *wm_check_capability__1__args;
  unsigned long int *ldata;
  char *name;
  signed int retval = -1;
  signed int return_value_XGetWindowProperty_1;
  return_value_XGetWindowProperty_1=XGetWindowProperty(dpy, root, list, (signed long int)0, (signed long int)((unsigned long int)65536 / sizeof(signed long int) /*8ul*/ ), 0, (unsigned long int)0L, &type, &format, &nitems, &bytesafter, &wm_check_capability__1__args);
  if(!(return_value_XGetWindowProperty_1 == 0))
    return -1;

  else
    if(!(type == 4ul))
      return -1;

    else
    {
      ldata = (unsigned long int *)wm_check_capability__1__args;
      i = (unsigned int)0;
      for( ; !((unsigned long int)i >= nitems); i = i + 1u)
      {
        if(ldata[(signed long int)i] == wanted)
          retval = 0;

        if(debug >= 2)
        {
          name=XGetAtomName(dpy, ldata[(signed long int)i]);
          fprintf(stderr, "wm cap: %s\n", name);
          XFree((void *)name);
        }

      }
      XFree((void *)ldata);
      return retval;
    }
}

// wm_detect
// file x11/wmhooks.h line 1
void wm_detect(struct _XDisplay *dpy)
{
  unsigned long int root = (&((struct anonymous_10 *)dpy)->screens[(signed long int)((struct anonymous_10 *)dpy)->default_screen])->root;
  signed int return_value_wm_check_capability_1;
  if(wm_stay_on_top == ((void (*)(struct _XDisplay *, unsigned long int, signed int))NULL))
  {
    return_value_wm_check_capability_1=wm_check_capability(dpy, root, _NET_SUPPORTED, _NET_WM_STATE_ABOVE);
    if(return_value_wm_check_capability_1 == 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "wmhooks: netwm state above\n");

      wm_stay_on_top = netwm_stay_on_top;
    }

  }

  signed int return_value_wm_check_capability_2;
  if(wm_stay_on_top == ((void (*)(struct _XDisplay *, unsigned long int, signed int))NULL))
  {
    return_value_wm_check_capability_2=wm_check_capability(dpy, root, _NET_SUPPORTED, _NET_WM_STATE_STAYS_ON_TOP);
    if(return_value_wm_check_capability_2 == 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "wmhooks: netwm state stays_on_top\n");

      wm_stay_on_top = netwm_old_stay_on_top;
    }

  }

  signed int return_value_wm_check_capability_3;
  if(wm_fullscreen == ((void (*)(struct _XDisplay *, unsigned long int, signed int))NULL))
  {
    return_value_wm_check_capability_3=wm_check_capability(dpy, root, _NET_SUPPORTED, _NET_WM_STATE_FULLSCREEN);
    if(return_value_wm_check_capability_3 == 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "wmhooks: netwm state fullscreen\n");

      wm_fullscreen = netwm_fullscreen;
    }

  }

  signed int return_value_wm_check_capability_4;
  if(wm_stay_on_top == ((void (*)(struct _XDisplay *, unsigned long int, signed int))NULL))
  {
    return_value_wm_check_capability_4=wm_check_capability(dpy, root, _WIN_PROTOCOLS, _WIN_LAYER);
    if(return_value_wm_check_capability_4 == 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "wmhooks: gnome layer\n");

      wm_stay_on_top = gnome_stay_on_top;
    }

  }

}

// write_jpeg
// file ./libng/writefile.h line 4
signed int write_jpeg(char *filename, struct ng_video_buf *buf, signed int quality, signed int gray)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "w");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "grab: can't open %s: %s\n", filename, return_value_strerror_2);
    return -1;
  }

  signed int return_value_do_write_jpeg_3;
  return_value_do_write_jpeg_3=do_write_jpeg(fp, buf, quality, gray);
  return return_value_do_write_jpeg_3;
}

// write_pgm
// file libng/writefile.c line 161
signed int write_pgm(char *filename, struct ng_video_buf *buf)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "w");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "grab: can't open %s: %s\n", filename, return_value_strerror_2);
    return -1;
  }

  fprintf(fp, "P5\n%d %d\n255\n", buf->fmt.width, buf->fmt.height);
  fwrite((const void *)buf->data, (unsigned long int)buf->fmt.height, (unsigned long int)buf->fmt.width, fp);
  fclose(fp);
  return 0;
}

// write_ppm
// file ./libng/writefile.h line 6
signed int write_ppm(char *filename, struct ng_video_buf *buf)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "w");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "grab: can't open %s: %s\n", filename, return_value_strerror_2);
    return -1;
  }

  fprintf(fp, "P6\n%d %d\n255\n", buf->fmt.width, buf->fmt.height);
  fwrite((const void *)buf->data, (unsigned long int)buf->fmt.height, (unsigned long int)((unsigned int)3 * buf->fmt.width), fp);
  fclose(fp);
  return 0;
}

// writebuf
// file common/alsa_stream.c line 448
static signed long int writebuf(struct _snd_pcm *handle, char *buf, signed long int len)
{
  signed long int r;
  while((_Bool)1)
  {
    r=snd_pcm_writei(handle, (const void *)buf, (unsigned long int)len);
    if(r == len)
      return (signed long int)0;

    if(!(r >= 0l))
    {
      signed int return_value_snd_pcm_recover_1;
      return_value_snd_pcm_recover_1=snd_pcm_recover(handle, (signed int)r, 0);
      r = (signed long int)return_value_snd_pcm_recover_1;
      if(!(r >= 0l))
      {
        const char *return_value_snd_strerror_2;
        return_value_snd_strerror_2=snd_strerror((signed int)r);
        fprintf(error_fp, "alsa: underrun recover error: %s\n", return_value_snd_strerror_2);
        return r;
      }

    }

    buf = buf + r * (signed long int)4;
    len = len - r;
    snd_pcm_wait(handle, 100);
  }
}

// writer_audio_thread
// file common/capture.c line 295
static void * writer_audio_thread(void *arg)
{
  struct movie_handle *h = (struct movie_handle *)arg;
  struct ng_audio_buf *buf;
  signed int return_value_getpid_1;
  if(!(debug == 0))
  {
    return_value_getpid_1=getpid();
    fprintf(stderr, "writer_audio_thread start [pid=%d]\n", return_value_getpid_1);
  }

  void *return_value_fifo_get_2;
  return_value_fifo_get_2=fifo_get(&h->afifo);
  buf = (struct ng_audio_buf *)return_value_fifo_get_2;
  if(!(buf == ((struct ng_audio_buf *)NULL)))
  {
    pthread_mutex_lock(&h->lock);
    h->writer->wr_audio(h->handle, buf);
    pthread_mutex_unlock(&h->lock);
    free((void *)buf);
  }

  if(!(debug == 0))
    fprintf(stderr, "writer_audio_thread done\n");

  return (void *)0;
}

// writer_video_thread
// file common/capture.c line 321
static void * writer_video_thread(void *arg)
{
  struct movie_handle *h = (struct movie_handle *)arg;
  struct ng_video_buf *buf;
  struct ng_video_buf *reorder[32l];
  signed int seq;
  signed int slot;
  signed int return_value_getpid_1;
  if(!(debug == 0))
  {
    return_value_getpid_1=getpid();
    fprintf(stderr, "writer_video_thread start [pid=%d]\n", return_value_getpid_1);
  }

  seq = 0;
  memset((void *)&reorder, 0, sizeof(struct ng_video_buf *[32l]) /*256ul*/ );
  do
  {
    void *return_value_fifo_get_2;
    return_value_fifo_get_2=fifo_get(&h->vfifo);
    buf = (struct ng_video_buf *)return_value_fifo_get_2;
    if(buf == ((struct ng_video_buf *)NULL))
      break;

    slot = buf->info.seq % 32;
    if(debug >= 2)
      fprintf(stderr, "video write: get seq=%d [%d]\n", buf->info.seq, slot);

    if(!(reorder[(signed long int)slot] == ((struct ng_video_buf *)NULL)))
    {
      fprintf(stderr, "panic: reorder buffer full\n");
      exit(1);
    }

    reorder[(signed long int)slot] = buf;
    slot = seq % 32;
    if(!(reorder[(signed long int)slot] == ((struct ng_video_buf *)NULL)))
    {
      buf = reorder[(signed long int)slot];
      reorder[(signed long int)slot] = (struct ng_video_buf *)(void *)0;
      if(debug >= 2)
        fprintf(stderr, "video write: put seq=%d [%d/%d]\n", buf->info.seq, slot, seq);

      seq = seq + 1;
      pthread_mutex_lock(&h->lock);
      h->writer->wr_video(h->handle, buf);
      if(!(buf->info.twice == 0))
        h->writer->wr_video(h->handle, buf);

      pthread_mutex_unlock(&h->lock);
      ng_release_video_buf(buf);
    }

  }
  while((_Bool)1);
  if(!(debug == 0))
    fprintf(stderr, "writer_video_thread done\n");

  return (void *)0;
}

// wss525_sim
// file common/vbi-sim.c line 112
static inline double wss525_sim(double t, double F, unsigned int bits)
{
  double t1 = 11.2e-6 - .5 / F;
  double t4 = t1 + (double)(2 + 14 + 6 + 1) / F;
  double ph;
  signed int i;
  signed int n;
  bits = bits * (unsigned int)2 + (unsigned int)(2 << 21);
  if(t < t1)
    return 0.0;

  else
    if(t < t4)
    {
      t = t - t1;
      i = (signed int)(t * F - .0);
      n = (signed int)(bits >> 22 - i & (unsigned int)3);
      if(n == 0)
        return 0.0;

      else
        if(n == 3)
          return 1.0;

      if(!(((i ^ n) & 1) == 0))
        ph = (3.14159265358979323846 * (double)2 * (t - (double)0 / F) * F) / (double)4;

      else
        ph = (3.14159265358979323846 * (double)2 * (t - (double)1 / F) * F) / (double)4;
      double return_value_shape_1;
      return_value_shape_1=shape(ph);
      return return_value_shape_1;
    }

    else
      return 0.0;
}

// wss625_sim
// file common/vbi-sim.c line 66
static inline double wss625_sim(double t, double F, unsigned int bits)
{
  double t1 = 11.0e-6 - .5 / F;
  double t4 = t1 + (double)(29 + 24 + 84) / F;
  double ph;
  signed int i;
  signed int j;
  signed int n;
  static char frame[56l] = { 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 'x', 0 };
  frame[(signed long int)(1 + 29 + 24)] = (char)(bits & (unsigned int)1);
  if(t < t1)
    return 0.0;

  else
    if(t < t4)
    {
      t = t - t1;
      i = (signed int)(t * F - .0);
      if(!(i >= 24))
        n = (signed int)frame[(signed long int)i] + 2 * (signed int)frame[(signed long int)(i + 1)];

      else
      {
        j = (i - 29) - 24;
        static signed int twobit[4l] = { 0xE38, 0xE07, 0x1F8, 0x1C7 };
        n = twobit[(signed long int)(bits >> j / 6 & (unsigned int)3)];
        n = n >> j % 6 & 3;
      }
      if(n == 0)
        return 0.0;

      else
        if(n == 3)
          return 1.0;

      if(!(((i ^ n) & 1) == 0))
        ph = (3.14159265358979323846 * (double)2 * (t - (double)1 / F) * F) / (double)4;

      else
        ph = (3.14159265358979323846 * (double)2 * (t - (double)0 / F) * F) / (double)4;
      double return_value_shape_1;
      return_value_shape_1=shape(ph);
      return return_value_shape_1;
    }

    else
      return 0.0;
}

// x11_blit
// file x11/blit.c line 311
void x11_blit(struct _XDisplay *dpy, unsigned long int dr, struct _XGC *gc, struct _XImage *xi, signed int a, signed int b, signed int c, signed int d, signed int w, signed int h)
{
  if(!(no_mitshm == 0))
    XPutImage(dpy, dr, gc, xi, a, b, c, d, (unsigned int)w, (unsigned int)h);

  else
    XShmPutImage(dpy, dr, gc, xi, a, b, c, d, (unsigned int)w, (unsigned int)h, 1);
}

// x11_capture_pixmap
// file x11/x11.c line 50
unsigned long int x11_capture_pixmap(struct _XDisplay *dpy, struct anonymous_1 *vinfo, unsigned long int colormap, unsigned int width, unsigned int height)
{
  struct ng_video_buf *buf;
  struct ng_video_fmt x11_capture_pixmap__1__fmt;
  unsigned long int pix = (unsigned long int)0;
  if((2 & f_drv) == 0)
    return (unsigned long int)0;

  else
  {
    memset((void *)&x11_capture_pixmap__1__fmt, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
    x11_capture_pixmap__1__fmt.fmtid = x11_dpy_fmtid;
    x11_capture_pixmap__1__fmt.width = width != 0u ? width : cur_tv_width;
    x11_capture_pixmap__1__fmt.height = height != 0u ? height : cur_tv_height;
    buf=ng_grabber_get_image(&x11_capture_pixmap__1__fmt);
    if(buf == ((struct ng_video_buf *)NULL))
      return (unsigned long int)0;

    else
    {
      buf=ng_filter_single(cur_filter, buf);
      pix=x11_create_pixmap(dpy, vinfo, buf);
      ng_release_video_buf(buf);
      return pix;
    }
  }
}

// x11_check_remote
// file x11/xt.h line 185
void x11_check_remote(void)
{
  signed int fd = ((struct anonymous_10 *)dpy)->fd;
  struct sockaddr_storage ss;
  char me[47l];
  char peer[47l];
  char port[17l];
  signed int length;
  if(!(debug == 0))
    fprintf(stderr, "check if the X-Server is local ... ");

  length = (signed int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  signed int return_value_getsockname_1;
  return_value_getsockname_1=getsockname(fd, (struct sockaddr *)&ss, (unsigned int *)&length);
  if(return_value_getsockname_1 == -1)
    perror("getsockname");

  else
  {
    if(!(debug == 0))
      fprintf(stderr, "*");

    if(length == 0 || (signed int)ss.ss_family == 1)
    {
      if(!(debug == 0))
        fprintf(stderr, " ok (unix socket)\n");

    }

    else
    {
      getnameinfo((struct sockaddr *)&ss, (unsigned int)length, me, (unsigned int)46, port, (unsigned int)16, 1 | 2);
      if(!(debug == 0))
        fprintf(stderr, "*");

      length = (signed int)sizeof(struct sockaddr_storage) /*128ul*/ ;
      signed int return_value_getpeername_2;
      return_value_getpeername_2=getpeername(fd, (struct sockaddr *)&ss, (unsigned int *)&length);
      if(return_value_getpeername_2 == -1)
        perror("getsockname");

      else
      {
        if(!(debug == 0))
          fprintf(stderr, "*");

        getnameinfo((struct sockaddr *)&ss, (unsigned int)length, peer, (unsigned int)46, port, (unsigned int)16, 1 | 2);
        if(!(debug == 0))
          fprintf(stderr, "*");

        if(!(debug == 0))
          fprintf(stderr, " ok\nx11 socket: me=%s, server=%s\n", (const void *)me, (const void *)peer);

        signed int return_value_strcmp_3;
        return_value_strcmp_3=strcmp(me, peer);
        if(!(return_value_strcmp_3 == 0))
          do_overlay = 0;

        goto __CPROVER_DUMP_L12;
      }
    }
  }

__CPROVER_DUMP_L12:
  ;
}

// x11_create_pixmap
// file x11/blit.h line 10
unsigned long int x11_create_pixmap(struct _XDisplay *dpy, struct anonymous_1 *vinfo, struct ng_video_buf *buf)
{
  unsigned long int pixmap;
  struct _XImage *ximage;
  struct _XGC *gc;
  struct anonymous_2 *shm;
  struct anonymous_0 *scr = &((struct anonymous_10 *)dpy)->screens[(signed long int)((struct anonymous_10 *)dpy)->default_screen];
  pixmap=XCreatePixmap(dpy, scr->root, buf->fmt.width, buf->fmt.height, (unsigned int)vinfo->depth);
  gc=XCreateGC(dpy, pixmap, (unsigned long int)0, (struct anonymous_75 *)(void *)0);
  ximage=x11_create_ximage(dpy, vinfo, (signed int)buf->fmt.width, (signed int)buf->fmt.height, &shm);
  if(ximage == ((struct _XImage *)NULL))
  {
    XFreePixmap(dpy, pixmap);
    XFreeGC(dpy, gc);
    return (unsigned long int)0;
  }

  else
  {
    memcpy((void *)ximage->data, (const void *)buf->data, buf->size);
    x11_blit(dpy, pixmap, gc, ximage, 0, 0, 0, 0, (signed int)buf->fmt.width, (signed int)buf->fmt.height);
    x11_destroy_ximage(dpy, ximage, shm);
    XFreeGC(dpy, gc);
    return pixmap;
  }
}

// x11_create_ximage
// file x11/blit.c line 229
struct _XImage * x11_create_ximage(struct _XDisplay *dpy, struct anonymous_1 *vinfo, signed int width, signed int height, struct anonymous_2 **shm)
{
  struct _XImage *ximage = (struct _XImage *)(void *)0;
  unsigned char *ximage_data;
  struct anonymous_2 *shminfo = (struct anonymous_2 *)(void *)0;
  void *x11_create_ximage__1__old_handler;
  signed int (*return_value_XSetErrorHandler_1)(struct _XDisplay *, struct anonymous *);
  void *return_value_malloc_2;
  void *return_value_shmat_3;
  if(no_mitshm == 0)
  {
    /* assertion width > 0 && height > 0 */
    assert(width > 0 && height > 0);
    return_value_XSetErrorHandler_1=XSetErrorHandler(catch_no_mitshm);
    x11_create_ximage__1__old_handler = (void *)return_value_XSetErrorHandler_1;
    return_value_malloc_2=malloc(sizeof(struct anonymous_2) /*32ul*/ );
    shminfo = (struct anonymous_2 *)return_value_malloc_2;
    memset((void *)shminfo, 0, sizeof(struct anonymous_2) /*32ul*/ );
    ximage=XShmCreateImage(dpy, vinfo->visual, (unsigned int)vinfo->depth, 2, (char *)(void *)0, shminfo, (unsigned int)width, (unsigned int)height);
    if(!(ximage == ((struct _XImage *)NULL)))
    {
      shminfo->shmid=shmget((signed int)0, (unsigned long int)(ximage->bytes_per_line * ximage->height), 01000 | 0777);
      if(shminfo->shmid == -1)
        perror("shmget [x11]");

      else
      {
        return_value_shmat_3=shmat(shminfo->shmid, NULL, 0);
        shminfo->shmaddr = (char *)return_value_shmat_3;
        if((char *)-1 == shminfo->shmaddr)
          perror("shmat");

        else
        {
          ximage->data = shminfo->shmaddr;
          shminfo->readOnly = 0;
          XShmAttach(dpy, shminfo);
          XSync(dpy, 0);
          if(no_mitshm == 0)
          {
            shmctl(shminfo->shmid, 0, ((struct shmid_ds *)NULL));
            XSetErrorHandler((signed int (*)(struct _XDisplay *, struct anonymous *))x11_create_ximage__1__old_handler);
            *shm = shminfo;
            return ximage;
          }

        }
      }
    }


  shm_error:
    ;
    if(!(ximage == ((struct _XImage *)NULL)))
    {
      ximage->f.destroy_image(ximage);
      ximage = (struct _XImage *)(void *)0;
    }

    if(!((char *)-1 == shminfo->shmaddr))
    {
      if(!(shminfo->shmaddr == ((char *)NULL)))
        shmdt((const void *)shminfo->shmaddr);

    }

    free((void *)shminfo);
    XSetErrorHandler((signed int (*)(struct _XDisplay *, struct anonymous *))x11_create_ximage__1__old_handler);
    no_mitshm = 1;
  }


no_mitshm:
  ;
  *shm = (struct anonymous_2 *)(void *)0;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc((unsigned long int)((unsigned int)(width * height) * pixmap_bytes));
  ximage_data = (unsigned char *)return_value_malloc_4;
  if(ximage_data == ((unsigned char *)NULL))
  {
    fprintf(stderr, "out of memory\n");
    exit(1);
  }

  ximage=XCreateImage(dpy, vinfo->visual, (unsigned int)vinfo->depth, 2, 0, (char *)ximage_data, (unsigned int)width, (unsigned int)height, 8, 0);
  memset((void *)ximage->data, 0, (unsigned long int)(ximage->bytes_per_line * ximage->height));
  return ximage;
}

// x11_ctrl_alt_backspace
// file x11/xt.h line 190
signed int x11_ctrl_alt_backspace(struct _XDisplay *dpy)
{
  fprintf(stderr, "game over\n");
  if(!(debug == 0))
    abort();

  audio_off();
  video_overlay(0);
  video_close();
  drv->close(h_drv);
  exit(0);
}

// x11_destroy_ximage
// file x11/blit.c line 300
void x11_destroy_ximage(struct _XDisplay *dpy, struct _XImage *ximage, struct anonymous_2 *shm)
{
  if(no_mitshm == 0 && !(shm == ((struct anonymous_2 *)NULL)))
  {
    XShmDetach(dpy, shm);
    ximage->f.destroy_image(ximage);
    shmdt((const void *)shm->shmaddr);
    free((void *)shm);
  }

  else
    ximage->f.destroy_image(ximage);
}

// x11_error_dev_null
// file x11/x11.c line 93
static signed int x11_error_dev_null(struct _XDisplay *dpy, struct anonymous *event)
{
  return 0;
}

// x11_find_visual
// file x11/blit.c line 105
struct anonymous_8 * x11_find_visual(struct _XDisplay *dpy)
{
  struct anonymous_1 *info;
  struct anonymous_1 template;
  struct anonymous_8 *vi = ((struct anonymous_8 *)NULL);
  signed int found;
  signed int i;
  char *class;
  template.screen=XDefaultScreen(dpy);
  info=XGetVisualInfo(dpy, (signed long int)0x2, &template, &found);
  i = 0;
  for( ; !(i >= found); i = i + 1)
  {
    switch((info + (signed long int)i)->class)
    {
      case 0:
      {
        class = "StaticGray";
        break;
      }
      case 1:
      {
        class = "GrayScale";
        break;
      }
      case 2:
      {
        class = "StaticColor";
        break;
      }
      case 3:
      {
        class = "PseudoColor";
        break;
      }
      case 4:
      {
        class = "TrueColor";
        break;
      }
      case 5:
      {
        class = "DirectColor";
        break;
      }
      default:
        class = "UNKNOWN";
    }
    if(!(debug == 0))
      fprintf(stderr, "visual: id=0x%lx class=%d (%s), depth=%d\n", (info + (signed long int)i)->visualid, (info + (signed long int)i)->class, class, (info + (signed long int)i)->depth);

  }
  i = 0;
  for( ; vi == ((struct anonymous_8 *)NULL) && !(i >= found); i = i + 1)
    if((info + (signed long int)i)->class == 4)
    {
      if((info + (signed long int)i)->depth >= 15)
        vi = (info + (signed long int)i)->visual;

    }

  i = 0;
  for( ; vi == ((struct anonymous_8 *)NULL) && !(i >= found); i = i + 1)
    if((info + (signed long int)i)->class == 0)
    {
      if((info + (signed long int)i)->depth == 8)
        vi = (info + (signed long int)i)->visual;

    }

  return vi;
}

// x11_icons_init
// file x11/icons.h line 1
void x11_icons_init(struct _XDisplay *dpy, unsigned long int bg)
{
  add_pixmap(dpy, bg, "home", (char *)(void *)0, home_xpm);
  add_pixmap(dpy, bg, "prev", (char *)(void *)0, prev_xpm);
  add_pixmap(dpy, bg, "next", (char *)(void *)0, next_xpm);
  add_pixmap(dpy, bg, "movie", (char *)(void *)0, movie_xpm);
  add_pixmap(dpy, bg, "snap", (char *)(void *)0, snap_xpm);
  add_pixmap(dpy, bg, "mute", (char *)(void *)0, mute_xpm);
  add_pixmap(dpy, bg, "exit", (char *)(void *)0, exit_xpm);
  add_pixmap(dpy, bg, "TVimg", "TVmask", tv_xpm);
}

// x11_init_visual
// file x11/blit.c line 138
void x11_init_visual(struct _XDisplay *dpy, struct anonymous_1 *vinfo)
{
  struct anonymous_7 *pf;
  signed int i;
  signed int n;
  signed int format = 0;
  signed int return_value_XShmQueryExtension_1;
  return_value_XShmQueryExtension_1=XShmQueryExtension(dpy);
  if(return_value_XShmQueryExtension_1 == 0)
    no_mitshm = 1;

  display_bits = vinfo->depth;
  display_bytes = (unsigned int)((display_bits + 7) / 8);
  pf=XListPixmapFormats(dpy, &n);
  i = 0;
  for( ; !(i >= n); i = i + 1)
    if((pf + (signed long int)i)->depth == display_bits)
      pixmap_bytes = (unsigned int)((pf + (signed long int)i)->bits_per_pixel / 8);

  if(!(debug == 0))
  {
    fprintf(stderr, "x11: color depth: %d bits, %d bytes - pixmap: %d bytes\n", display_bits, display_bytes, pixmap_bytes);
    _Bool tmp_if_expr_2;
    if(vinfo->class == 4)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = vinfo->class == 5 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      fprintf(stderr, "x11: color masks: red=0x%08lx green=0x%08lx blue=0x%08lx\n", vinfo->red_mask, vinfo->green_mask, vinfo->blue_mask);

    fprintf(stderr, "x11: server byte order: %s\n", ((struct anonymous_10 *)dpy)->byte_order == 0 ? "little endian" : "big endian");
    fprintf(stderr, "x11: client byte order: %s\n", 1234 == 1234 ? "little endian" : "big endian");
  }

  if(((struct anonymous_10 *)dpy)->byte_order == 1)
    x11_byteswap = 1;

  if(vinfo->class == 4)
  {
    i = 0;
    for( ; fmt[(signed long int)i].depth >= 1u; i = i + 1)
      if(fmt[(signed long int)i].depth == pixmap_bytes)
      {
        _Bool tmp_if_expr_6;
        if(fmt[(signed long int)i].order == ((struct anonymous_10 *)dpy)->byte_order)
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = fmt[(signed long int)i].order == -1 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
        {
          _Bool tmp_if_expr_5;
          if(fmt[(signed long int)i].red == vinfo->red_mask)
            tmp_if_expr_5 = (_Bool)1;

          else
            tmp_if_expr_5 = fmt[(signed long int)i].red == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_5)
          {
            _Bool tmp_if_expr_4;
            if(fmt[(signed long int)i].green == vinfo->green_mask)
              tmp_if_expr_4 = (_Bool)1;

            else
              tmp_if_expr_4 = fmt[(signed long int)i].green == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_4)
            {
              _Bool tmp_if_expr_3;
              if(fmt[(signed long int)i].blue == vinfo->blue_mask)
                tmp_if_expr_3 = (_Bool)1;

              else
                tmp_if_expr_3 = fmt[(signed long int)i].blue == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_3)
              {
                x11_dpy_fmtid = fmt[(signed long int)i].format;
                break;
              }

            }

          }

        }

      }

    if(fmt[(signed long int)i].depth == 0u)
    {
      fprintf(stderr, "Huh?\n");
      exit(1);
    }

    ng_lut_init(vinfo->red_mask, vinfo->green_mask, vinfo->blue_mask, x11_dpy_fmtid, x11_byteswap);
    if(((struct anonymous_10 *)dpy)->byte_order == 1)
      switch(pixmap_bytes)
      {
        case (unsigned int)2:
        {
          format = display_bits == 15 ? 5 : 6;
          break;
        }
        case (unsigned int)3:
        {
          format = 9;
          break;
        }
        case (unsigned int)4:
          format = 10;
      }

    else
      switch(pixmap_bytes)
      {
        case (unsigned int)2:
        {
          format = display_bits == 15 ? 3 : 4;
          break;
        }
        case (unsigned int)3:
        {
          format = 7;
          break;
        }
        case (unsigned int)4:
          format = 8;
      }
  }

  if(vinfo->class == 0)
  {
    if(vinfo->depth == 8)
      format = 2;

  }

  if(format == 0)
  {
    _Bool tmp_if_expr_7;
    if(vinfo->class == 3)
      tmp_if_expr_7 = vinfo->depth == 8 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_7 = (_Bool)0;
    if(tmp_if_expr_7)
      fprintf(stderr, "\n8-bit Pseudocolor Visual (256 colors) is *not* supported.\nYou can startup X11 either with 15 bpp (or more)...\n\txinit -- -bpp 16\n... or with StaticGray visual:\n\txinit -- -cc StaticGray\n");

    else
      fprintf(stderr, "Sorry, I can't handle your strange display\n");
    exit(1);
  }

  x11_dpy_fmtid = (unsigned int)format;
}

// x11_label_pixmap
// file x11/x11.h line 5
void x11_label_pixmap(struct _XDisplay *dpy, unsigned long int colormap, unsigned long int pixmap, signed int height, char *label)
{
  struct anonymous_75 values;
  struct _XGC *gc;
  static struct anonymous_22 color;
  static struct anonymous_14 *font;
  if(font == ((struct anonymous_14 *)NULL))
  {
    font=XLoadQueryFont(dpy, "fixed");
    static struct anonymous_22 dummy;
    XAllocNamedColor(dpy, colormap, "yellow", &color, &dummy);
  }

  values.font = font->fid;
  values.foreground = color.pixel;
  gc=XCreateGC(dpy, pixmap, (unsigned long int)(1L << 14 | 1L << 2), &values);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(label);
  XDrawString(dpy, pixmap, gc, 5, height - 5, label, (signed int)return_value_strlen_1);
  XFreeGC(dpy, gc);
}

// x11_misc_init
// file x11/xt.h line 177
void x11_misc_init(struct _XDisplay *dpy)
{
  fcntl(((struct anonymous_10 *)dpy)->fd, 2, 1);
}

// x11_mute_notify
// file x11/xt.c line 1417
static void x11_mute_notify(signed int val)
{
  signed int return_value_alsa_thread_is_running_1;
  if(!(val == 0))
    alsa_thread_stop();

  else
  {
    return_value_alsa_thread_is_running_1=alsa_thread_is_running();
    if(return_value_alsa_thread_is_running_1 == 0)
    {
      if(args.alsa_latency == 30 && !(args.readconfig == 0))
      {
        signed int x11_mute_notify__1__1__1__val;
        x11_mute_notify__1__1__1__val=cfg_get_int("global", "alsa_latency");
        if(x11_mute_notify__1__1__1__val >= 1)
          args.alsa_latency = x11_mute_notify__1__1__1__val;

      }

      alsa_thread_startup(alsa_out, alsa_cap, args.alsa_latency, stderr, debug);
    }

  }
}

// x11_vbi_data
// file x11/xt.c line 1989
static void x11_vbi_data(void *data, signed int *fd, unsigned long int *iproc)
{
  struct vbi_state *vbi = (struct vbi_state *)data;
  vbi_hasdata(vbi);
}

// x11_vbi_event
// file x11/xt.c line 1960
static void x11_vbi_event(struct vbi_event *ev, void *user)
{
  struct vbi_page pg;
  struct vbi_rect rect;
  switch(ev->type)
  {
    case 0x0008:
    {
      strcpy(x11_vbi_station, ev->ev.network.name);
      break;
    }
    case 0x0002:
      if(ev->ev.ttx_page.pgno == x11_vbi_page)
      {
        if(!(debug == 0))
          fprintf(stderr, "got vtx page %03x\n", ev->ev.ttx_page.pgno);

        if(!(vtx_subtitle == ((void (*)(struct vbi_page *, struct vbi_rect *))NULL)))
        {
          vbi_fetch_vt_page(x11_vbi->dec, &pg, ev->ev.ttx_page.pgno, ev->ev.ttx_page.subno, (enum anonymous_23)VBI_WST_LEVEL_1p5, 25, 1);
          vbi_find_subtitle(&pg, &rect);
          if(rect.y1 == 25)
            vtx_subtitle((struct vbi_page *)(void *)0, (struct vbi_rect *)(void *)0);

          else
            vtx_subtitle(&pg, &rect);
        }

      }

  }
}

// x11_vbi_start
// file x11/xt.h line 199
signed int x11_vbi_start(char *device)
{
  if(!(x11_vbi == ((struct vbi_state *)NULL)))
    return 0;

  else
  {
    if(device == ((char *)NULL))
      device = ng_dev.vbi;

    x11_vbi=vbi_open(device, debug, 0);
    if(x11_vbi == ((struct vbi_state *)NULL))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      fprintf(stderr, "open %s: %s\n", device, return_value_strerror_2);
      return -1;
    }

    vbi_event_handler_add(x11_vbi->dec, ~0, x11_vbi_event, (void *)x11_vbi);
    x11_vbi_input=XtAppAddInput(app_context, x11_vbi->fd, (void *)(1L << 0), x11_vbi_data, (void *)x11_vbi);
    if(!(debug == 0))
      fprintf(stderr, "x11_vbi_start\n");

    return 0;
  }
}

// x11_vbi_stop
// file x11/xt.h line 201
void x11_vbi_stop(void)
{
  if(!(x11_vbi == ((struct vbi_state *)NULL)))
  {
    XtRemoveInput(x11_vbi_input);
    vbi_event_handler_remove(x11_vbi->dec, x11_vbi_event);
    vbi_close(x11_vbi);
    x11_vbi = (struct vbi_state *)(void *)0;
    if(!(debug == 0))
      fprintf(stderr, "x11_vbi_stop\n");

  }

}

// x11_vbi_tuned
// file x11/xt.h line 200
signed int x11_vbi_tuned(void)
{
  struct v4l2_tuner tuner;
  signed int return_value;
  if(x11_vbi == ((struct vbi_state *)NULL))
  {
    return_value=drv->is_tuned(h_drv);
    return return_value;
  }

  memset((void *)&tuner, 0, sizeof(struct v4l2_tuner) /*84ul*/ );
  signed int return_value_ioctl_1;
  return_value_ioctl_1=ioctl(x11_vbi->fd, (unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(29 << 0)) | sizeof(struct v4l2_tuner) /*84ul*/  << 0 + 8 + 8, &tuner);
  if(!(return_value_ioctl_1 == -1))
    return tuner.signal != 0 ? 1 : 0;

  else
  {
    signed int return_value_1;
    return_value_1=drv->is_tuned(h_drv);
    return return_value_1;
  }
}

// xfree_dga_error_handler
// file x11/xt.c line 1406
static signed int xfree_dga_error_handler(struct _XDisplay *d, struct anonymous *e)
{
  if((signed int)e->error_code == 1 + xfree_dga_error_base)
  {
    have_dga = 0;
    return 0;
  }

  else
  {
    signed int return_value;
    return_value=orig_xfree_error_handler(d, e);
    return return_value;
  }
}

// xfree_dga_init
// file x11/xt.h line 178
void xfree_dga_init(struct _XDisplay *dpy)
{
  signed int flags;
  signed int foo;
  signed int ma;
  signed int mi;
  if(!(do_overlay == 0))
  {
    if(!(args.dga == 0))
    {
      signed int return_value_XF86DGAQueryExtension_2;
      return_value_XF86DGAQueryExtension_2=XF86DGAQueryExtension(dpy, &foo, &xfree_dga_error_base);
      if(!(return_value_XF86DGAQueryExtension_2 == 0))
      {
        signed int return_value_XDefaultScreen_1;
        return_value_XDefaultScreen_1=XDefaultScreen(dpy);
        XF86DGAQueryDirectVideo(dpy, return_value_XDefaultScreen_1, &flags);
        if(!((0x0001 & flags) == 0))
        {
          XF86DGAQueryVersion(dpy, &ma, &mi);
          if(!(debug == 0))
            fprintf(stderr, "DGA version %d.%d\n", ma, mi);

          have_dga = 1;
        }

      }

    }

  }

}

// xfree_randr_init
// file x11/xt.c line 1358
void xfree_randr_init(struct _XDisplay *dpy)
{
  signed int bar;
  signed int i;
  if(!(args.randr == 0))
  {
    signed int return_value_XRRQueryExtension_1;
    return_value_XRRQueryExtension_1=XRRQueryExtension(dpy, &randr_evbase, &bar);
    if(!(return_value_XRRQueryExtension_1 == 0))
    {
      randr=XRRSizes(dpy, ((struct anonymous_10 *)dpy)->default_screen, &nrandr);
      if(nrandr >= 1)
      {
        have_randr = 1;
        if(!(debug == 0))
        {
          fprintf(stderr, "xrandr:");
          i = 0;
          for( ; !(i >= nrandr); i = i + 1)
            fprintf(stderr, " %dx%d", (randr + (signed long int)i)->width, (randr + (signed long int)i)->height);
          fprintf(stderr, "\n");
        }

      }

    }

  }

}

// xfree_vm_init
// file x11/xt.h line 180
void xfree_vm_init(struct _XDisplay *dpy)
{
  signed int foo;
  signed int bar;
  signed int i;
  signed int ma;
  signed int mi;
  if(!(do_overlay == 0))
  {
    if(!(args.vidmode == 0))
    {
      signed int return_value_XF86VidModeQueryExtension_2;
      return_value_XF86VidModeQueryExtension_2=XF86VidModeQueryExtension(dpy, &foo, &bar);
      if(!(return_value_XF86VidModeQueryExtension_2 == 0))
      {
        XF86VidModeQueryVersion(dpy, &ma, &mi);
        if(!(debug == 0))
          fprintf(stderr, "VidMode  version %d.%d\n", ma, mi);

        have_vm = 1;
        signed int return_value_XDefaultScreen_1;
        return_value_XDefaultScreen_1=XDefaultScreen(dpy);
        XF86VidModeGetAllModeLines(dpy, return_value_XDefaultScreen_1, &vm_count, &vm_modelines);
        if(!(debug == 0))
        {
          fprintf(stderr, "  available video mode(s):");
          i = 0;
          for( ; !(i >= vm_count); i = i + 1)
            fprintf(stderr, " %dx%d", vm_modelines[(signed long int)i]->hdisplay, vm_modelines[(signed long int)i]->vdisplay);
          fprintf(stderr, "\n");
        }

      }

    }

  }

}

// xfree_xinerama_init
// file x11/xt.h line 179
void xfree_xinerama_init(struct _XDisplay *dpy)
{
  signed int foo;
  signed int bar;
  signed int i;
  signed int return_value_XineramaQueryExtension_2;
  return_value_XineramaQueryExtension_2=XineramaQueryExtension(dpy, &foo, &bar);
  signed int return_value_XineramaIsActive_1;
  if(!(return_value_XineramaQueryExtension_2 == 0))
  {
    return_value_XineramaIsActive_1=XineramaIsActive(dpy);
    if(!(return_value_XineramaIsActive_1 == 0))
    {
      xinerama=XineramaQueryScreens(dpy, &nxinerama);
      i = 0;
      for( ; !(i >= nxinerama); i = i + 1)
        fprintf(stderr, "xinerama %d: %dx%d+%d+%d\n", (xinerama + (signed long int)i)->screen_number, (xinerama + (signed long int)i)->width, (xinerama + (signed long int)i)->height, (xinerama + (signed long int)i)->x_org, (xinerama + (signed long int)i)->y_org);
    }

  }

}

// xscreensaver_command
// file ./jwz/remote.h line 16
extern signed int xscreensaver_command(struct _XDisplay *dpy, unsigned long int command, signed long int arg, signed int verbose_p, char **error_ret)
{
  unsigned long int w = (unsigned long int)0;
  signed int status;
  status=send_xscreensaver_command(dpy, command, arg, &w, error_ret);
  if(status == 0)
    status=xscreensaver_command_response(dpy, w, verbose_p, (signed int)(command == XA_EXIT), error_ret);

  fflush(stdout);
  fflush(stderr);
  return status < 0 ? status : 0;
}

// xscreensaver_command_response
// file jwz/remote.c line 341
static signed int xscreensaver_command_response(struct _XDisplay *dpy, unsigned long int window, signed int verbose_p, signed int exiting_p, char **error_ret)
{
  signed int fd = ((struct anonymous_10 *)dpy)->fd;
  signed int timeout = 10;
  signed int status;
  struct anonymous_115 fds;
  struct timeval xscreensaver_command_response__1__tv;
  char xscreensaver_command_response__1__err[2048l];
  _Bool tmp_if_expr_1;
  while((_Bool)1)
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_115) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&fds)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    memset((void *)&xscreensaver_command_response__1__tv, 0, sizeof(struct timeval) /*16ul*/ );
    xscreensaver_command_response__1__tv.tv_sec = (signed long int)timeout;
    status=select(fd + 1, &fds, ((struct anonymous_115 *)NULL), &fds, &xscreensaver_command_response__1__tv);
    if(!(status >= 0))
    {
      char buf[1024l];
      if(!(error_ret == ((char **)NULL)))
      {
        sprintf(buf, "error waiting for reply");
        *error_ret=strdup(buf);
      }

      else
      {
        sprintf(buf, "%s: error waiting for reply", progname);
        perror(buf);
      }
      return status;
    }

    else
      if(status == 0)
      {
        sprintf(xscreensaver_command_response__1__err, "no response to command.");
        if(!(error_ret == ((char **)NULL)))
          *error_ret=strdup(xscreensaver_command_response__1__err);

        else
          fprintf(stderr, "%s: %s\n", progname, (const void *)xscreensaver_command_response__1__err);
        return -1;
      }

      else
      {
        union _XEvent event;
        XtAppNextEvent(app_context, &event);
        if(event.xany.type == 28 && event.xproperty.state == 0 && event.xproperty.atom == XA_SCREENSAVER_RESPONSE)
        {
          signed int st2;
          unsigned long int type;
          signed int format;
          unsigned long int nitems;
          unsigned long int bytesafter;
          char *msg = ((char *)NULL);
          XSync(dpy, 0);
          if(!(old_handler == ((signed int (*)(struct _XDisplay *, struct anonymous *))NULL)))
            abort();

          old_handler=XSetErrorHandler(BadWindow_ehandler);
          st2=XGetWindowProperty(dpy, window, XA_SCREENSAVER_RESPONSE, (signed long int)0, (signed long int)1024, 1, (unsigned long int)0L, &type, &format, &nitems, &bytesafter, (unsigned char **)&msg);
          XSync(dpy, 0);
          XSetErrorHandler(old_handler);
          old_handler = ((signed int (*)(struct _XDisplay *, struct anonymous *))NULL);
          if(!(got_badwindow == 0))
          {
            if(!(exiting_p == 0))
              return 0;

            sprintf(xscreensaver_command_response__1__err, "xscreensaver window unexpectedly deleted.");
            if(!(error_ret == ((char **)NULL)))
              *error_ret=strdup(xscreensaver_command_response__1__err);

            else
              fprintf(stderr, "%s: %s\n", progname, (const void *)xscreensaver_command_response__1__err);
            return -1;
          }

          if(st2 == 0 && !(type == 0ul))
          {
            if(!(format == 8) || !(type == 31ul))
            {
              sprintf(xscreensaver_command_response__1__err, "unrecognized response property.");
              if(!(error_ret == ((char **)NULL)))
                *error_ret=strdup(xscreensaver_command_response__1__err);

              else
                fprintf(stderr, "%s: %s\n", progname, (const void *)xscreensaver_command_response__1__err);
              if(!(msg == ((char *)NULL)))
                XFree((void *)msg);

              return -1;
            }

            else
            {
              _Bool tmp_if_expr_2;
              if(msg == ((char *)NULL))
                tmp_if_expr_2 = (_Bool)1;

              else
              {
                if(!((signed int)*msg == 43))
                  tmp_if_expr_1 = (signed int)msg[(signed long int)0] != 45 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_1 = (_Bool)0;
                tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_2)
              {
                sprintf(xscreensaver_command_response__1__err, "unrecognized response message.");
                if(!(error_ret == ((char **)NULL)))
                  *error_ret=strdup(xscreensaver_command_response__1__err);

                else
                  fprintf(stderr, "%s: %s\n", progname, (const void *)xscreensaver_command_response__1__err);
                if(!(msg == ((char *)NULL)))
                  XFree((void *)msg);

                return -1;
              }

              else
              {
                signed int ret = (signed int)msg[(signed long int)0] == 43 ? 0 : -1;
                sprintf(xscreensaver_command_response__1__err, "%s: %s\n", progname, msg + (signed long int)1);
                if(!(error_ret == ((char **)NULL)))
                  *error_ret=strdup(xscreensaver_command_response__1__err);

                else
                  if(!(ret == 0) || !(verbose_p == 0))
                    fprintf(ret < 0 ? stderr : stdout, "%s\n", (const void *)xscreensaver_command_response__1__err);

                XFree((void *)msg);
                return ret;
              }
            }
          }

        }

        else
          XtDispatchEvent(&event);
      }
  }
}

// xscreensaver_init
// file ./jwz/remote.h line 24
extern void xscreensaver_init(struct _XDisplay *dpy)
{
  XA_VROOT=XInternAtom(dpy, "__SWM_VROOT", 0);
  XA_SCREENSAVER=XInternAtom(dpy, "SCREENSAVER", 0);
  XA_SCREENSAVER_ID=XInternAtom(dpy, "_SCREENSAVER_ID", 0);
  XA_SCREENSAVER_VERSION=XInternAtom(dpy, "_SCREENSAVER_VERSION", 0);
  XA_SCREENSAVER_STATUS=XInternAtom(dpy, "_SCREENSAVER_STATUS", 0);
  XA_SCREENSAVER_RESPONSE=XInternAtom(dpy, "_SCREENSAVER_RESPONSE", 0);
  XA_SELECT=XInternAtom(dpy, "SELECT", 0);
  XA_EXIT=XInternAtom(dpy, "EXIT", 0);
  XA_DEMO=XInternAtom(dpy, "DEMO", 0);
  XA_LOCK=XInternAtom(dpy, "LOCK", 0);
  XA_BLANK=XInternAtom(dpy, "BLANK", 0);
}

// xscreensaver_timefunc
// file x11/xt.c line 793
static void xscreensaver_timefunc(void *clientData, unsigned long int *id)
{
  signed int status;
  char *xscreensaver_timefunc__1__err;
  if(!(debug == 0))
    fprintf(stderr, "xscreensaver_timefunc\n");

  xscreensaver_timer = (unsigned long int)0;
  static signed int first = 1;
  if(!(first == 0))
  {
    xscreensaver_init(dpy);
    first = 0;
  }

  status=xscreensaver_command(dpy, XA_DEACTIVATE, (signed long int)0, debug, &xscreensaver_timefunc__1__err);
  if(!(status == 0))
  {
    if(!(debug == 0))
      fprintf(stderr, "xscreensaver_command: %s\n", xscreensaver_timefunc__1__err);

  }

  else
    xscreensaver_timer=XtAppAddTimeOut(app_context, (unsigned long int)60000, xscreensaver_timefunc, (void *)0);
}

// xt_handle_pending
// file x11/xt.h line 226
signed int xt_handle_pending(struct _XDisplay *dpy)
{
  union _XEvent event;
  if(!(debug == 0))
    fprintf(stderr, "xt: handle_pending:  start ...\n");

  XFlush(dpy);
  signed int return_value_XCheckMaskEvent_1;
  do
  {
    return_value_XCheckMaskEvent_1=XCheckMaskEvent(dpy, (signed long int)~0, &event);
    if(!(return_value_XCheckMaskEvent_1 == 1))
      break;

    XtDispatchEvent(&event);
  }
  while((_Bool)1);
  if(!(debug == 0))
    fprintf(stderr, "xt: handle_pending:  ... done\n");

  return 0;
}

// xt_joystick_data
// file x11/xt.c line 2136
static void xt_joystick_data(void *data, signed int *fd, unsigned long int *iproc)
{
  joystick_tv_havedata(xt_joystick);
}

// xt_joystick_init
// file x11/xt.c line 2141
signed int xt_joystick_init(void)
{
  xt_joystick=joystick_tv_init(args.joydev);
  if(!(xt_joystick == -1))
    XtAppAddInput(app_context, xt_joystick, (void *)(1L << 0), xt_joystick_data, (void *)0);

  return 0;
}

// xt_kbd_init
// file x11/xt.c line 2151
void xt_kbd_init(struct _WidgetRec *tv)
{
  char **list;
  char key[32l];
  char str[128l];
  list=cfg_list_entries("eventmap");
  if(!(list == ((char **)NULL)))
    for( ; !(*list == ((char *)NULL)); list = list + 1l)
    {
      signed int return_value_sscanf_1;
      return_value_sscanf_1=sscanf(*list, "kbd-key-%31s", (const void *)key);
      if(return_value_sscanf_1 == 1)
      {
        sprintf(str, "<Key>%s: Event(%s)", (const void *)key, *list);
        struct _TranslationData *return_value_XtParseTranslationTable_2;
        return_value_XtParseTranslationTable_2=XtParseTranslationTable(str);
        XtOverrideTranslations(tv, return_value_XtParseTranslationTable_2);
      }

    }

}

// xt_lirc_data
// file x11/xt.c line 2084
static void xt_lirc_data(void *data, signed int *fd, unsigned long int *iproc)
{
  if(!(debug == 0))
    fprintf(stderr, "lirc_input triggered\n");

  signed int return_value_lirc_tv_havedata_1;
  return_value_lirc_tv_havedata_1=lirc_tv_havedata();
  if(return_value_lirc_tv_havedata_1 == -1)
  {
    fprintf(stderr, "lirc: connection lost\n");
    XtRemoveInput(*iproc);
    close(*fd);
  }

}

// xt_lirc_init
// file x11/xt.c line 2095
signed int xt_lirc_init(void)
{
  xt_lirc=lirc_tv_init();
  if(!(xt_lirc == -1))
    XtAppAddInput(app_context, xt_lirc, (void *)(1L << 0), xt_lirc_data, (void *)0);

  return 0;
}

// xt_main_loop
// file x11/xt.h line 228
signed int xt_main_loop(void)
{
  union _XEvent event;
  if(!(debug == 0))
    fprintf(stderr, "xt: enter main event loop... \n");

  signal(1, (void (*)(signed int))1);
  do
  {
    char return_value_XtAppGetExitFlag_1;
    return_value_XtAppGetExitFlag_1=XtAppGetExitFlag(app_context);
    if(!(return_value_XtAppGetExitFlag_1 == 0))
      break;

    XtAppNextEvent(app_context, &event);
    char return_value_XtDispatchEvent_2;
    return_value_XtDispatchEvent_2=XtDispatchEvent(&event);
  }
  while((_Bool)1);
  return 0;
}

// xt_midi_data
// file x11/xt.c line 2107
static void xt_midi_data(void *data, signed int *fd, unsigned long int *iproc)
{
  midi_read(&xt_midi);
  midi_translate(&xt_midi);
}

// xt_midi_init
// file x11/xt.c line 2114
signed int xt_midi_init(char *dev)
{
  if(dev == ((char *)NULL))
    return -1;

  else
  {
    memset((void *)&xt_midi, 0, sizeof(struct midi_handle) /*24ul*/ );
    signed int return_value_midi_open_1;
    return_value_midi_open_1=midi_open(&xt_midi, "xawtv");
    if(return_value_midi_open_1 == -1)
      return -1;

    else
    {
      midi_connect(&xt_midi, dev);
      XtAppAddInput(app_context, xt_midi.fd, (void *)(1L << 0), xt_midi_data, (void *)0);
      return 0;
    }
  }
}

// xt_siginit
// file x11/xt.h line 152
void xt_siginit(void)
{
  struct sigaction act;
  struct sigaction old;
  memset((void *)&act, 0, sizeof(struct sigaction) /*152ul*/ );
  sigemptyset(&act.sa_mask);
  act.__sigaction_handler.sa_handler = exec_done;
  sigaction(17, &act, &old);
  sig_id=XtAppAddSignal(app_context, termsig_handler, (void *)0);
  act.__sigaction_handler.sa_handler = termsig;
  sigaction(2, &act, &old);
  sigaction(15, &act, &old);
  act.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  sigaction(13, &act, &old);
  if(!(debug == 0))
  {
    act.__sigaction_handler.sa_handler = segfault;
    sigaction(11, &act, &old);
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    fprintf(stderr, "main thread [pid=%d]\n", return_value_getpid_1);
  }

}

// xt_vm_randr_input_init
// file x11/xt.h line 227
signed int xt_vm_randr_input_init(struct _XDisplay *dpy)
{
  if(!(debug == 0))
    fprintf(stderr, "xt: checking for randr extension ...\n");

  xfree_randr_init(dpy);
  if(!(debug == 0))
    fprintf(stderr, "xt: checking for vidmode extension ...\n");

  xfree_vm_init(dpy);
  if(!(debug == 0))
    fprintf(stderr, "xt: checking for lirc ...\n");

  xt_lirc_init();
  if(!(debug == 0))
    fprintf(stderr, "xt: checking for joystick ...\n");

  xt_joystick_init();
  if(!(debug == 0))
    fprintf(stderr, "xt: checking for midi ...\n");

  xt_midi_init(midi);
  if(!(debug == 0))
    fprintf(stderr, "xt: adding kbd hooks ...\n");

  xt_kbd_init(tv);
  return 0;
}

// xv_add_attr
// file x11/xv.c line 172
static void xv_add_attr(struct xv_handle *h, signed int id, signed int type, signed int defval, struct STRTAB *choices, struct anonymous_112 *at)
{
  signed int i;
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)h->attr, (unsigned long int)(h->nattr + 2) * sizeof(struct ng_attribute) /*80ul*/ );
  h->attr = (struct ng_attribute *)return_value_realloc_1;
  memset((void *)(h->attr + (signed long int)h->nattr), 0, sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)2);
  signed int return_value_strcmp_2;
  if(!(at == ((struct anonymous_112 *)NULL)))
  {
    (h->attr + (signed long int)h->nattr)->priv = (const void *)at;
    i = 0;
    for( ; !(xvattr[(signed long int)i].atom == ((char *)NULL)); i = i + 1)
    {
      return_value_strcmp_2=strcmp(xvattr[(signed long int)i].atom, at->name);
      if(return_value_strcmp_2 == 0)
        break;

    }
    if(xvattr[(signed long int)i].type == -1)
      goto __CPROVER_DUMP_L12;

    if(!(xvattr[(signed long int)i].atom == ((char *)NULL)))
    {
      (h->attr + (signed long int)h->nattr)->id = xvattr[(signed long int)i].id;
      (h->attr + (signed long int)h->nattr)->type = xvattr[(signed long int)i].type;
      (h->attr + (signed long int)h->nattr)->priv = (const void *)at;
      if((h->attr + (signed long int)h->nattr)->type == 1)
      {
        (h->attr + (signed long int)h->nattr)->min = at->min_value;
        (h->attr + (signed long int)h->nattr)->max = at->max_value;
      }

      goto __CPROVER_DUMP_L6;
    }

  }

  else
  {

  __CPROVER_DUMP_L6:
    ;
    if(!(id == 0))
      (h->attr + (signed long int)h->nattr)->id = id;

    if(!(type == 0))
      (h->attr + (signed long int)h->nattr)->type = type;

    if(!(defval == 0))
      (h->attr + (signed long int)h->nattr)->defval = defval;

    if(!(choices == ((struct STRTAB *)NULL)))
      (h->attr + (signed long int)h->nattr)->choices = choices;

    if(!((h->attr + (signed long int)h->nattr)->id >= 10))
      (h->attr + (signed long int)h->nattr)->name = ng_attr_to_desc[(signed long int)(h->attr + (signed long int)h->nattr)->id];

    (h->attr + (signed long int)h->nattr)->read = xv_read_attr;
    (h->attr + (signed long int)h->nattr)->write = xv_write_attr;
    (h->attr + (signed long int)h->nattr)->handle = (void *)h;
    h->nattr = h->nattr + 1;
  }

__CPROVER_DUMP_L12:
  ;
}

// xv_attrs
// file x11/xv.c line 321
static struct ng_attribute * xv_attrs(void *handle)
{
  struct xv_handle *h = (struct xv_handle *)handle;
  return h->attr;
}

// xv_blit
// file x11/blit.c line 482
void xv_blit(struct _XDisplay *dpy, unsigned long int dr, struct _XGC *gc, struct anonymous_3 *xi, signed int a, signed int b, signed int c, signed int d, signed int x, signed int y, signed int w, signed int h)
{
  if(!(no_mitshm == 0))
    XvPutImage(dpy, (unsigned long int)im_port, dr, gc, xi, a, b, (unsigned int)c, (unsigned int)d, x, y, (unsigned int)w, (unsigned int)h);

  else
    XvShmPutImage(dpy, (unsigned long int)im_port, dr, gc, xi, a, b, (unsigned int)c, (unsigned int)d, x, y, (unsigned int)w, (unsigned int)h, 1);
}

// xv_close
// file x11/xv.c line 308
static signed int xv_close(void *handle)
{
  return 0;
}

// xv_create_ximage
// file x11/blit.c line 407
struct anonymous_3 * xv_create_ximage(struct _XDisplay *dpy, signed int width, signed int height, signed int format, struct anonymous_2 **shm)
{
  struct anonymous_3 *xvimage = (struct anonymous_3 *)(void *)0;
  unsigned char *ximage_data;
  struct anonymous_2 *shminfo = (struct anonymous_2 *)(void *)0;
  void *xv_create_ximage__1__old_handler;
  signed int (*return_value_XSetErrorHandler_1)(struct _XDisplay *, struct anonymous *);
  void *return_value_malloc_2;
  void *return_value_shmat_3;
  if(no_mitshm == 0)
  {
    return_value_XSetErrorHandler_1=XSetErrorHandler(catch_no_mitshm);
    xv_create_ximage__1__old_handler = (void *)return_value_XSetErrorHandler_1;
    return_value_malloc_2=malloc(sizeof(struct anonymous_2) /*32ul*/ );
    shminfo = (struct anonymous_2 *)return_value_malloc_2;
    memset((void *)shminfo, 0, sizeof(struct anonymous_2) /*32ul*/ );
    xvimage=XvShmCreateImage(dpy, (unsigned long int)im_port, format, ((char *)NULL), width, height, shminfo);
    if(!(xvimage == ((struct anonymous_3 *)NULL)))
    {
      shminfo->shmid=shmget((signed int)0, (unsigned long int)xvimage->data_size, 01000 | 0777);
      if(shminfo->shmid == -1)
        perror("shmget [xv]");

      else
      {
        return_value_shmat_3=shmat(shminfo->shmid, NULL, 0);
        shminfo->shmaddr = (char *)return_value_shmat_3;
        if((char *)-1 == shminfo->shmaddr)
          perror("shmat");

        else
        {
          xvimage->data = shminfo->shmaddr;
          shminfo->readOnly = 0;
          XShmAttach(dpy, shminfo);
          XSync(dpy, 0);
          if(no_mitshm == 0)
          {
            shmctl(shminfo->shmid, 0, ((struct shmid_ds *)NULL));
            XSetErrorHandler((signed int (*)(struct _XDisplay *, struct anonymous *))xv_create_ximage__1__old_handler);
            *shm = shminfo;
            return xvimage;
          }

        }
      }
    }


  shm_error:
    ;
    if(!(xvimage == ((struct anonymous_3 *)NULL)))
    {
      XFree((void *)xvimage);
      xvimage = (struct anonymous_3 *)(void *)0;
    }

    if(!((char *)-1 == shminfo->shmaddr))
    {
      if(!(shminfo->shmaddr == ((char *)NULL)))
        shmdt((const void *)shminfo->shmaddr);

    }

    free((void *)shminfo);
    XSetErrorHandler((signed int (*)(struct _XDisplay *, struct anonymous *))xv_create_ximage__1__old_handler);
    no_mitshm = 1;
  }


no_mitshm:
  ;
  *shm = (struct anonymous_2 *)(void *)0;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc((unsigned long int)(width * height * 2));
  ximage_data = (unsigned char *)return_value_malloc_4;
  if(ximage_data == ((unsigned char *)NULL))
  {
    fprintf(stderr, "out of memory\n");
    exit(1);
  }

  xvimage=XvCreateImage(dpy, (unsigned long int)im_port, format, (char *)ximage_data, width, height);
  return xvimage;
}

// xv_destroy_ximage
// file x11/blit.c line 471
void xv_destroy_ximage(struct _XDisplay *dpy, struct anonymous_3 *xvimage, struct anonymous_2 *shm)
{
  if(no_mitshm == 0 && !(shm == ((struct anonymous_2 *)NULL)))
  {
    XShmDetach(dpy, shm);
    XFree((void *)xvimage);
    shmdt((const void *)shm->shmaddr);
    free((void *)shm);
  }

  else
    XFree((void *)xvimage);
}

// xv_flags
// file x11/xv.c line 310
static signed int xv_flags(void *handle)
{
  struct xv_handle *h = (struct xv_handle *)handle;
  signed int ret = 0;
  ret = ret | 1;
  if(!(h->xv_freq == 0ul))
    ret = ret | 4;

  return ret;
}

// xv_getfreq
// file x11/xv.c line 219
static unsigned long int xv_getfreq(void *handle)
{
  struct xv_handle *h = (struct xv_handle *)handle;
  unsigned int freq;
  XvGetPortAttribute(dpy, h->vi_port, h->xv_freq, (signed int *)&freq);
  return (unsigned long int)freq;
}

// xv_image_init
// file x11/blit.h line 17
void xv_image_init(struct _XDisplay *dpy)
{
  signed int i;
  signed int return_value_XvQueryExtension_1;
  return_value_XvQueryExtension_1=XvQueryExtension(dpy, (unsigned int *)&ver, (unsigned int *)&rel, (unsigned int *)&req, (unsigned int *)&ev, (unsigned int *)&err);
  if(!(return_value_XvQueryExtension_1 == 0))
  {
    if(!(debug == 0))
      fprintf(stderr, "Xvideo: Server has no Xvideo extension support\n");

  }

  else
  {
    signed int return_value_XvQueryAdaptors_2;
    return_value_XvQueryAdaptors_2=XvQueryAdaptors(dpy, (&((struct anonymous_10 *)dpy)->screens[(signed long int)((struct anonymous_10 *)dpy)->default_screen])->root, (unsigned int *)&adaptors, &ai);
    if(!(return_value_XvQueryAdaptors_2 == 0))
      fprintf(stderr, "Xvideo: XvQueryAdaptors failed");

    else
    {
      i = 0;
      for( ; !(i >= adaptors); i = i + 1)
        if(!((1L & (signed long int)(ai + (signed long int)i)->type) == 0l))
        {
          if(!((0x00000010 & (signed int)(ai + (signed long int)i)->type) == 0))
          {
            if(im_port == 4294967295u)
            {
              im_port = (unsigned int)(ai + (signed long int)i)->base_id;
              im_adaptor = (unsigned int)i;
            }

          }

        }

      if(!(im_port == 4294967295u))
      {
        fo=XvListImageFormats(dpy, (unsigned long int)im_port, &formats);
        i = 0;
        for( ; !(i >= formats); i = i + 1)
        {
          if(!(debug == 0))
            fprintf(stderr, "blit: xv: 0x%x (%c%c%c%c) %s", (fo + (signed long int)i)->id, (fo + (signed long int)i)->id & 0xff, (fo + (signed long int)i)->id >> 8 & 0xff, (fo + (signed long int)i)->id >> 16 & 0xff, (fo + (signed long int)i)->id >> 24 & 0xff, (fo + (signed long int)i)->format == 0 ? "packed" : "planar");

          if((fo + (signed long int)i)->id == 0x32595559)
          {
            im_formats[(signed long int)13] = (unsigned int)(fo + (signed long int)i)->id;
            if(!(debug == 0))
              fprintf(stderr, " [ok: %s]", ng_vfmt_to_desc[(signed long int)13]);

          }

          if((fo + (signed long int)i)->id == 0x59565955)
          {
            im_formats[(signed long int)18] = (unsigned int)(fo + (signed long int)i)->id;
            if(!(debug == 0))
              fprintf(stderr, " [ok: %s]", ng_vfmt_to_desc[(signed long int)18]);

          }

          if((fo + (signed long int)i)->id == 0x30323449)
          {
            im_formats[(signed long int)15] = (unsigned int)(fo + (signed long int)i)->id;
            if(!(debug == 0))
              fprintf(stderr, " [ok: %s]", ng_vfmt_to_desc[(signed long int)15]);

          }

          if(!(debug == 0))
            fprintf(stderr, "\n");

        }
      }

    }
  }
}

// xv_overlay
// file x11/xv.c line 45
static signed int xv_overlay(void *handle, struct ng_video_fmt *fmt, signed int x, signed int y, struct OVERLAY_CLIP *oc, signed int count, signed int aspect)
{
  if(!(debug == 0))
    fprintf(stderr, "Ouch: xv_overlay called\n");

  return 0;
}

// xv_read_attr
// file x11/xv.c line 116
static signed int xv_read_attr(struct ng_attribute *attr)
{
  struct xv_handle *h = (struct xv_handle *)attr->handle;
  const struct anonymous_112 *xv_read_attr__1__at = (const struct anonymous_112 *)attr->priv;
  unsigned long int atom;
  signed int value = 0;
  if(!(xv_read_attr__1__at == ((const struct anonymous_112 *)NULL)))
  {
    atom=XInternAtom(dpy, xv_read_attr__1__at->name, 0);
    XvGetPortAttribute(dpy, h->vi_port, atom, &value);
    if(!(debug == 0))
      fprintf(stderr, "xv: get %s: %d\n", xv_read_attr__1__at->name, value);

  }

  else
    if(attr->id == 1)
      value = h->norm;

    else
      if(attr->id == 2)
        value = h->input;

  return value;
}

// xv_setfreq
// file x11/xv.c line 229
static void xv_setfreq(void *handle, unsigned long int freq)
{
  struct xv_handle *h = (struct xv_handle *)handle;
  XvSetPortAttribute(dpy, h->vi_port, h->xv_freq, (signed int)freq);
  XSync(dpy, 0);
}

// xv_strlist_add
// file x11/xv.c line 288
static signed int xv_strlist_add(struct STRTAB **tab, char *str)
{
  signed int i;
  signed int return_value_strcasecmp_2;
  if(*tab == ((struct STRTAB *)NULL))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct STRTAB) /*16ul*/  * (unsigned long int)2);
    *tab = (struct STRTAB *)return_value_malloc_1;
    i = 0;
  }

  else
  {
    i = 0;
    for( ; !((*tab + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
    {
      return_value_strcasecmp_2=strcasecmp((*tab + (signed long int)i)->str, str);
      if(return_value_strcasecmp_2 == 0)
        return (signed int)(*tab + (signed long int)i)->nr;

    }
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)*tab, sizeof(struct STRTAB) /*16ul*/  * (unsigned long int)(i + 2));
    *tab = (struct STRTAB *)return_value_realloc_3;
  }
  (*tab + (signed long int)i)->nr = (signed long int)i;
  (*tab + (signed long int)i)->str=strdup(str);
  (*tab + (signed long int)(i + 1))->nr = (signed long int)-1;
  (*tab + (signed long int)(i + 1))->str = (const char *)(void *)0;
  return i;
}

// xv_tuned
// file x11/xv.c line 238
static signed int xv_tuned(void *handle)
{
  return 0;
}

// xv_video
// file x11/xv.h line 5
void xv_video(unsigned long int win, signed int dw, signed int dh, signed int on)
{
  struct xv_handle *h = (struct xv_handle *)h_drv;
  signed int sx;
  signed int sy;
  signed int dx;
  signed int dy;
  signed int sw;
  signed int sh;
  signed int return_value_XvGrabPort_1;
  if(!(on == 0))
  {
    dy = 0;
    dx = dy;
    sy = dx;
    sx = sy;
    sw = dw;
    sh = dh;
    if(!(h->enc == -1))
    {
      sw = (signed int)(ei + (signed long int)h->enc)->width;
      sh = (signed int)(ei + (signed long int)h->enc)->height;
    }

    if(h->vi_gc == ((struct _XGC *)NULL))
      h->vi_gc=XCreateGC(dpy, win, (unsigned long int)0, (struct anonymous_75 *)(void *)0);

    ng_ratio_fixup(&dw, &dh, &dx, &dy);
    if(grabbed == 0)
    {
      return_value_XvGrabPort_1=XvGrabPort(dpy, h->vi_port, (unsigned long int)0L);
      if(return_value_XvGrabPort_1 == 0)
        grabbed = 1;

    }

    if(grabbed == 1)
    {
      XvPutVideo(dpy, h->vi_port, win, h->vi_gc, sx, sy, (unsigned int)sw, (unsigned int)sh, dx, dy, (unsigned int)dw, (unsigned int)dh);
      if(!(debug == 0))
        fprintf(stderr, "Xvideo: video: win=0x%lx, src=%dx%d+%d+%d dst=%dx%d+%d+%d\n", win, sw, sh, sx, sy, dw, dh, dx, dy);

    }

    else
      fprintf(stderr, "Xvideo: port %ld busy\n", h->vi_port);
  }

  else
    if(!(grabbed == 0))
    {
      XClearArea(dpy, win, 0, 0, (unsigned int)0, (unsigned int)0, 0);
      XvStopVideo(dpy, h->vi_port, win);
      XvUngrabPort(dpy, h->vi_port, (unsigned long int)0L);
      grabbed = 0;
      if(!(debug == 0))
        fprintf(stderr, "Xvideo: video off\n");

    }

}

// xv_video_init
// file x11/xv.h line 2
void xv_video_init(unsigned int port, signed int hwscan)
{
  struct xv_handle *handle;
  struct STRTAB *norms = (struct STRTAB *)(void *)0;
  struct STRTAB *inputs = (struct STRTAB *)(void *)0;
  char *h;
  signed int n;
  signed int i;
  signed int vi_port = -1;
  signed int vi_adaptor = -1;
  signed int return_value_XvQueryExtension_1;
  return_value_XvQueryExtension_1=XvQueryExtension(dpy, (unsigned int *)&ver_link1, (unsigned int *)&rel_link1, (unsigned int *)&req_link1, (unsigned int *)&ev_link1, (unsigned int *)&err_link1);
  if(!(return_value_XvQueryExtension_1 == 0))
  {
    if(!(debug == 0))
      fprintf(stderr, "Xvideo: Server has no Xvideo extension support\n");

  }

  else
  {
    signed int return_value_XvQueryAdaptors_2;
    return_value_XvQueryAdaptors_2=XvQueryAdaptors(dpy, (&((struct anonymous_10 *)dpy)->screens[(signed long int)((struct anonymous_10 *)dpy)->default_screen])->root, (unsigned int *)&adaptors_link1, &ai_link1);
    if(!(return_value_XvQueryAdaptors_2 == 0))
    {
      fprintf(stderr, "Xvideo: XvQueryAdaptors failed");
      exit(1);
    }

    if(!(debug == 0))
      fprintf(stderr, "Xvideo: %d adaptors available.\n", adaptors_link1);

    i = 0;
    for( ; !(i >= adaptors_link1); i = i + 1)
    {
      if(!(debug == 0))
        fprintf(stderr, "Xvideo: %s:%s%s%s%s%s, ports %ld-%ld\n", (ai_link1 + (signed long int)i)->name, ((signed long int)(ai_link1 + (signed long int)i)->type & 1L << 0) != 0l ? " input" : "", ((signed long int)(ai_link1 + (signed long int)i)->type & 1L << 1) != 0l ? " output" : "", ((signed int)(ai_link1 + (signed long int)i)->type & 0x00000004) != 0 ? " video" : "", ((signed int)(ai_link1 + (signed long int)i)->type & 0x00000008) != 0 ? " still" : "", ((signed int)(ai_link1 + (signed long int)i)->type & 0x00000010) != 0 ? " image" : "", (ai_link1 + (signed long int)i)->base_id, ((ai_link1 + (signed long int)i)->base_id + (ai_link1 + (signed long int)i)->num_ports) - (unsigned long int)1);

      if(!(hwscan == 0))
      {
        n=fprintf(stderr, "port %ld-%ld", (ai_link1 + (signed long int)i)->base_id, ((ai_link1 + (signed long int)i)->base_id + (ai_link1 + (signed long int)i)->num_ports) - (unsigned long int)1);
        if(!((1L & (signed long int)(ai_link1 + (signed long int)i)->type) == 0l))
        {
          if(!((0x00000004 & (signed int)(ai_link1 + (signed long int)i)->type) == 0))
            fprintf(stderr, "%*s[ -xvport %ld ]", 40 - n, (const void *)"", (ai_link1 + (signed long int)i)->base_id);

        }

        fprintf(stderr, "\n");
        if(!((1L & (signed long int)(ai_link1 + (signed long int)i)->type) == 0l))
        {
          if(!((0x00000004 & (signed int)(ai_link1 + (signed long int)i)->type) == 0))
            fprintf(stderr, "    type : Xvideo, video overlay\n");

        }

        if(!((1L & (signed long int)(ai_link1 + (signed long int)i)->type) == 0l))
        {
          if(!((0x00000010 & (signed int)(ai_link1 + (signed long int)i)->type) == 0))
            fprintf(stderr, "    type : Xvideo, image scaler\n");

        }

        fprintf(stderr, "    name : %s\n", (ai_link1 + (signed long int)i)->name);
        fprintf(stderr, "\n");
      }

      else
        if(!((1L & (signed long int)(ai_link1 + (signed long int)i)->type) == 0l))
        {
          if(!((0x00000004 & (signed int)(ai_link1 + (signed long int)i)->type) == 0))
          {
            if(vi_port == -1)
            {
              if(port == 0u)
              {
                vi_port = (signed int)(ai_link1 + (signed long int)i)->base_id;
                vi_adaptor = i;
              }

              else
              {
                _Bool tmp_if_expr_3;
                if((unsigned long int)port >= (ai_link1 + (signed long int)i)->base_id)
                  tmp_if_expr_3 = (unsigned long int)port < (ai_link1 + (signed long int)i)->base_id + (ai_link1 + (signed long int)i)->num_ports ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_3 = (_Bool)0;
                if(tmp_if_expr_3)
                {
                  vi_port = (signed int)port;
                  vi_adaptor = i;
                }

                else
                  if(!(debug == 0))
                    fprintf(stderr, "Xvideo: skipping ports %ld-%ld (configured other: %d)\n", (ai_link1 + (signed long int)i)->base_id, ((ai_link1 + (signed long int)i)->base_id + (ai_link1 + (signed long int)i)->num_ports) - (unsigned long int)1, port);

              }
            }

          }

        }

    }
    if(hwscan == 0)
    {
      if(vi_port == -1)
      {
        if(!(debug == 0))
          fprintf(stderr, "Xvideo: no usable video port found\n");

      }

      else
      {
        if(!(debug == 0))
          fprintf(stderr, "Xvideo: using port %d for video\n", vi_port);

        void *return_value_malloc_4;
        return_value_malloc_4=malloc(sizeof(struct xv_handle) /*88ul*/ );
        handle = (struct xv_handle *)return_value_malloc_4;
        memset((void *)handle, 0, sizeof(struct xv_handle) /*88ul*/ );
        handle->vi_port = (unsigned long int)vi_port;
        handle->vi_adaptor = vi_adaptor;
        handle->xv_encoding = (unsigned long int)0L;
        handle->xv_freq = (unsigned long int)0L;
        handle->xv_colorkey = (unsigned long int)0L;
        handle->enc = -1;
        handle->norm = -1;
        handle->input = -1;
        signed int return_value_XvQueryEncodings_5;
        return_value_XvQueryEncodings_5=XvQueryEncodings(dpy, (unsigned long int)vi_port, (unsigned int *)&handle->encodings, &ei);
        if(!(return_value_XvQueryEncodings_5 == 0))
        {
          fprintf(stderr, "Oops: XvQueryEncodings failed\n");
          exit(1);
        }

        void *return_value_malloc_6;
        return_value_malloc_6=malloc(sizeof(struct ENC_MAP) /*12ul*/  * (unsigned long int)handle->encodings);
        handle->enc_map = (struct ENC_MAP *)return_value_malloc_6;
        i = 0;
        for( ; !(i >= handle->encodings); i = i + 1)
        {
          h=strrchr((ei + (signed long int)i)->name, 45);
          if(!(h == ((char *)NULL)))
          {
            char *tmp_post_7 = h;
            h = h + 1l;
            *tmp_post_7 = (char)0;
            (handle->enc_map + (signed long int)i)->input=xv_strlist_add(&inputs, h);
          }

          (handle->enc_map + (signed long int)i)->norm=xv_strlist_add(&norms, (ei + (signed long int)i)->name);
          (handle->enc_map + (signed long int)i)->encoding = (signed int)(ei + (signed long int)i)->encoding_id;
        }
        at=XvQueryPortAttributes(dpy, (unsigned long int)vi_port, &attributes);
        i = 0;
        for( ; !(i >= attributes); i = i + 1)
        {
          if(!(debug == 0))
            fprintf(stderr, "  %s%s%s, %i -> %i\n", (at + (signed long int)i)->name, ((at + (signed long int)i)->flags & 0x01) != 0 ? " get" : "", ((at + (signed long int)i)->flags & 0x02) != 0 ? " set" : "", (at + (signed long int)i)->min_value, (at + (signed long int)i)->max_value);

          signed int return_value_strcmp_8;
          return_value_strcmp_8=strcmp("XV_ENCODING", (at + (signed long int)i)->name);
          if(return_value_strcmp_8 == 0)
            handle->xv_encoding = XV_ENCODING;

          signed int return_value_strcmp_9;
          return_value_strcmp_9=strcmp("XV_FREQ", (at + (signed long int)i)->name);
          if(return_value_strcmp_9 == 0)
            handle->xv_freq = XV_FREQ;

          xv_add_attr(handle, 0, 0, 0, (struct STRTAB *)(void *)0, at + (signed long int)i);
        }
        if(!(handle->xv_encoding == 0ul))
        {
          if(!(norms == ((struct STRTAB *)NULL)))
            xv_add_attr(handle, 1, 2, 0, norms, (struct anonymous_112 *)(void *)0);

          if(!(inputs == ((struct STRTAB *)NULL)))
            xv_add_attr(handle, 2, 2, 0, inputs, (struct anonymous_112 *)(void *)0);

        }

        have_xv = 1;
        drv = &xv_driver;
        h_drv = (void *)handle;
        f_drv=xv_flags(h_drv);
        struct ng_attribute *return_value_xv_attrs_10;
        return_value_xv_attrs_10=xv_attrs(h_drv);
        add_attrs(return_value_xv_attrs_10);
      }
    }

  }
}

// xv_write_attr
// file x11/xv.c line 139
static void xv_write_attr(struct ng_attribute *attr, signed int value)
{
  struct xv_handle *h = (struct xv_handle *)attr->handle;
  const struct anonymous_112 *xv_write_attr__1__at = (const struct anonymous_112 *)attr->priv;
  unsigned long int atom;
  signed int i;
  if(!(xv_write_attr__1__at == ((const struct anonymous_112 *)NULL)))
  {
    atom=XInternAtom(dpy, xv_write_attr__1__at->name, 0);
    XvSetPortAttribute(dpy, h->vi_port, atom, value);
    if(!(debug == 0))
      fprintf(stderr, "xv: set %s: %d\n", xv_write_attr__1__at->name, value);

  }

  else
  {
    _Bool tmp_if_expr_1;
    if(attr->id == 1)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = attr->id == 2 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if(attr->id == 1)
        h->norm = value;

      if(attr->id == 2)
        h->input = value;

      i = 0;
      for( ; !(i >= h->encodings); i = i + 1)
        if((h->enc_map + (signed long int)i)->norm == h->norm)
        {
          if((h->enc_map + (signed long int)i)->input == h->input)
          {
            h->enc = i;
            XvSetPortAttribute(dpy, h->vi_port, h->xv_encoding, h->enc);
            break;
          }

        }

    }

  }
  XSync(dpy, 0);
}

// yuv420p_to_rgb24
// file libng/color_yuv2rgb.c line 170
static void yuv420p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char * restrict d;
  unsigned char *us;
  unsigned char *vs;
  unsigned char *dp;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)4);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = dp;
    us = u;
    vs = v;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post_3 = d;
      d = d + 1l;
      *tmp_post_3 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post_4 = d;
      d = d + 1l;
      *tmp_post_4 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post_5 = d;
      d = d + 1l;
      *tmp_post_5 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post_6 = d;
      d = d + 1l;
      *tmp_post_6 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    if(i % 2u == 0u)
    {
      u = us;
      v = vs;
    }

    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// yuv422_to_gray
// file libng/color_yuv2rgb.c line 64
static void yuv422_to_gray(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned char * restrict d = dest;
  for( ; !(p == 0); s = s + (signed long int)2)
  {
    d[(signed long int)0] = (unsigned char)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    p = p - 1;
    d = d + 1l;
  }
}

// yuv422_to_rgb24
// file libng/color_yuv2rgb.c line 78
static void yuv422_to_rgb24(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned char * restrict d = dest;
  signed int gray;
  for( ; !(p == 0); p = p - 2)
  {
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    d[(signed long int)0] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])];
    d[(signed long int)1] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])];
    d[(signed long int)2] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])];
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)2]];
    d[(signed long int)3] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])];
    d[(signed long int)4] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])];
    d[(signed long int)5] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])];
    d = d + (signed long int)6;
    s = s + (signed long int)4;
  }
}

// yuv422p_to_rgb24
// file libng/color_yuv2rgb.c line 206
static void yuv422p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char * restrict d;
  unsigned char *dp;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)2);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post_3 = d;
      d = d + 1l;
      *tmp_post_3 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post_4 = d;
      d = d + 1l;
      *tmp_post_4 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post_5 = d;
      d = d + 1l;
      *tmp_post_5 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post_6 = d;
      d = d + 1l;
      *tmp_post_6 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// yuv42xp_to_gray
// file libng/color_yuv2rgb.c line 149
static void yuv42xp_to_gray(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict d;
  unsigned char *dp;
  unsigned int i;
  unsigned int j;
  dp = out->data;
  y = in->data;
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + 1u)
    {
      *d = (unsigned char)ng_yuv_gray[(signed long int)*y];
      d = d + 1l;
      y = y + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// zap_timeout
// file x11/xt.c line 436
static void zap_timeout(void *client_data, unsigned long int *id)
{
  static signed int muted = 0;
  if(!(zap_fast == 0))
  {
    if(cur_attrs[4l] == 0)
    {
      muted = 1;
      do_va_cmd(2, (const void *)"volume", (const void *)"mute", (const void *)"on");
    }

  }

  do_va_cmd(2, (const void *)"setstation", (const void *)"next");
  if(!(cur_sender == zap_start))
    zap_timer=XtAppAddTimeOut(app_context, (unsigned long int)(zap_fast != 0 ? 100 : 8000), zap_timeout, (void *)0);

  else
    if(!(muted == 0))
    {
      muted = 0;
      do_va_cmd(2, (const void *)"volume", (const void *)"mute", (const void *)"off");
    }

}

