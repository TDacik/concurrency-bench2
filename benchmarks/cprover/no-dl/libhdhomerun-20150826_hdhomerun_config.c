// tag-#anon#UN[*{S8}_S8_'ifcu_buf'||*{SYM#tag-ifreq#}_SYM#tag-ifreq#_'ifcu_req'|]
// file /usr/include/net/if.h line 179
union anonymous;

// tag-#anon#UN[ARR16{S8}_S8_'ifrn_name'|]
// file /usr/include/net/if.h line 130
union anonymous_1;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_3;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_2;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'||SYM#tag-sockaddr#'ifru_dstaddr'||SYM#tag-sockaddr#'ifru_broadaddr'||SYM#tag-sockaddr#'ifru_netmask'||SYM#tag-sockaddr#'ifru_hwaddr'||S16'ifru_flags'||S32'ifru_ivalue'||S32'ifru_mtu'||SYM#tag-ifmap#'ifru_map'||ARR16{S8}_S8_'ifru_slave'||ARR16{S8}_S8_'ifru_newname'||*{S8}_S8_'ifru_data'|]
// file /usr/include/net/if.h line 135
union anonymous_0;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-hdhomerun_channel_entry_t
// file hdhomerun_channels.h line 25
struct hdhomerun_channel_entry_t;

// tag-hdhomerun_channel_list_t
// file hdhomerun_channels.h line 26
struct hdhomerun_channel_list_t;

// tag-hdhomerun_channelmap_range_t
// file hdhomerun_channels.c line 36
struct hdhomerun_channelmap_range_t;

// tag-hdhomerun_channelmap_record_t
// file hdhomerun_channels.c line 43
struct hdhomerun_channelmap_record_t;

// tag-hdhomerun_channelscan_program_t
// file hdhomerun_types.h line 53
struct hdhomerun_channelscan_program_t;

// tag-hdhomerun_channelscan_result_t
// file hdhomerun_types.h line 64
struct hdhomerun_channelscan_result_t;

// tag-hdhomerun_channelscan_t
// file hdhomerun_channelscan.h line 30
struct hdhomerun_channelscan_t;

// tag-hdhomerun_control_sock_t
// file hdhomerun_control.h line 24
struct hdhomerun_control_sock_t;

// tag-hdhomerun_debug_message_t
// file hdhomerun_debug.c line 42
struct hdhomerun_debug_message_t;

// tag-hdhomerun_debug_t
// file hdhomerun_debug.h line 33
struct hdhomerun_debug_t;

// tag-hdhomerun_device_selector_t
// file hdhomerun_device_selector.h line 30
struct hdhomerun_device_selector_t;

// tag-hdhomerun_device_t
// file hdhomerun_types.h line 26
struct hdhomerun_device_t;

// tag-hdhomerun_discover_device_t
// file hdhomerun_discover.h line 24
struct hdhomerun_discover_device_t;

// tag-hdhomerun_discover_sock_t
// file hdhomerun_discover.c line 25
struct hdhomerun_discover_sock_t;

// tag-hdhomerun_discover_t
// file hdhomerun_discover.h line 53
struct hdhomerun_discover_t;

// tag-hdhomerun_local_ip_info_t
// file hdhomerun_sock.h line 24
struct hdhomerun_local_ip_info_t;

// tag-hdhomerun_pkt_t
// file hdhomerun_pkt.h line 140
struct hdhomerun_pkt_t;

// tag-hdhomerun_plotsample_t
// file hdhomerun_types.h line 77
struct hdhomerun_plotsample_t;

// tag-hdhomerun_tuner_status_t
// file hdhomerun_types.h line 29
struct hdhomerun_tuner_status_t;

// tag-hdhomerun_tuner_vstatus_t
// file hdhomerun_types.h line 42
struct hdhomerun_tuner_vstatus_t;

// tag-hdhomerun_video_sock_t
// file hdhomerun_video.h line 24
struct hdhomerun_video_sock_t;

// tag-hdhomerun_video_stats_t
// file hdhomerun_video.h line 26
struct hdhomerun_video_stats_t;

// tag-ifconf
// file /usr/include/net/if.h line 176
struct ifconf;

// tag-ifmap
// file /usr/include/net/if.h line 111
struct ifmap;

// tag-ifreq
// file /usr/include/net/if.h line 126
struct ifreq;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-ip_mreq
// file /usr/include/netinet/in.h line 264
struct ip_mreq;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __bswap_32_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link1(unsigned int __bsx_link1);
// __bswap_32_link2
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link2(unsigned int __bsx_link2);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// channelscan_advance
// file hdhomerun_channelscan.c line 224
extern signed int channelscan_advance(struct hdhomerun_channelscan_t *scan, struct hdhomerun_channelscan_result_t *result);
// channelscan_create
// file hdhomerun_channelscan.c line 30
extern struct hdhomerun_channelscan_t * channelscan_create(struct hdhomerun_device_t *hd, const char *channelmap);
// channelscan_destroy
// file hdhomerun_channelscan.c line 49
extern void channelscan_destroy(struct hdhomerun_channelscan_t *scan);
// channelscan_detect
// file hdhomerun_channelscan.c line 259
extern signed int channelscan_detect(struct hdhomerun_channelscan_t *scan, struct hdhomerun_channelscan_result_t *result);
// channelscan_detect_programs
// file hdhomerun_channelscan.c line 130
static signed int channelscan_detect_programs(struct hdhomerun_channelscan_t *scan, struct hdhomerun_channelscan_result_t *result, signed int *pchanged, signed int *pincomplete);
// channelscan_extract_name
// file hdhomerun_channelscan.c line 95
static void channelscan_extract_name(struct hdhomerun_channelscan_program_t *program, const char *line);
// channelscan_find_lock
// file hdhomerun_channelscan.c line 55
static signed int channelscan_find_lock(struct hdhomerun_channelscan_t *scan, unsigned int frequency, struct hdhomerun_channelscan_result_t *result);
// channelscan_get_progress
// file hdhomerun_channelscan.c line 324
extern unsigned char channelscan_get_progress(struct hdhomerun_channelscan_t *scan);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// cmd_execute
// file hdhomerun_config.c line 502
static signed int cmd_execute(void);
// cmd_get
// file hdhomerun_config.c line 127
static signed int cmd_get(const char *item);
// cmd_save
// file hdhomerun_config.c line 350
static signed int cmd_save(const char *tuner_str, const char *filename);
// cmd_save_print_stats
// file hdhomerun_config.c line 336
static void cmd_save_print_stats(void);
// cmd_scan
// file hdhomerun_config.c line 240
static signed int cmd_scan(const char *tuner_str, const char *filename);
// cmd_scan_printf
// file hdhomerun_config.c line 219
static void cmd_scan_printf(struct _IO_FILE *fp, const char *fmt, ...);
// cmd_set
// file hdhomerun_config.c line 161
static signed int cmd_set(const char *item, const char *value);
// cmd_set_internal
// file hdhomerun_config.c line 145
static signed int cmd_set_internal(const char *item, const char *value);
// cmd_upgrade
// file hdhomerun_config.c line 460
static signed int cmd_upgrade(const char *filename);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// contains
// file hdhomerun_config.c line 63
static signed int contains(const char *arg, const char *cmpstr);
// discover_print
// file hdhomerun_config.c line 92
static signed int discover_print(char *target_ip_str);
// extract_appname
// file hdhomerun_config.c line 50
static void extract_appname(const char *argv0);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getcurrenttime
// file hdhomerun_os_posix.h line 54
extern unsigned long int getcurrenttime(void);
// getpeername
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 141
extern signed int getpeername(signed int, struct sockaddr *, unsigned int *);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);
// hdhomerun_channel_entry_channel_number
// file hdhomerun_channels.c line 204
extern unsigned short int hdhomerun_channel_entry_channel_number(struct hdhomerun_channel_entry_t *entry);
// hdhomerun_channel_entry_frequency
// file hdhomerun_channels.c line 209
extern unsigned int hdhomerun_channel_entry_frequency(struct hdhomerun_channel_entry_t *entry);
// hdhomerun_channel_entry_name
// file hdhomerun_channels.c line 214
extern const char * hdhomerun_channel_entry_name(struct hdhomerun_channel_entry_t *entry);
// hdhomerun_channel_frequency_round
// file hdhomerun_channels.c line 270
extern unsigned int hdhomerun_channel_frequency_round(unsigned int frequency, unsigned int resolution);
// hdhomerun_channel_frequency_round_normal
// file hdhomerun_channels.c line 276
extern unsigned int hdhomerun_channel_frequency_round_normal(unsigned int frequency);
// hdhomerun_channel_frequency_to_number
// file hdhomerun_channels.c line 295
extern unsigned short int hdhomerun_channel_frequency_to_number(struct hdhomerun_channel_list_t *channel_list, unsigned int frequency);
// hdhomerun_channel_list_build_insert
// file hdhomerun_channels.c line 314
static void hdhomerun_channel_list_build_insert(struct hdhomerun_channel_list_t *channel_list, struct hdhomerun_channel_entry_t *entry);
// hdhomerun_channel_list_build_range
// file hdhomerun_channels.c line 344
static void hdhomerun_channel_list_build_range(struct hdhomerun_channel_list_t *channel_list, const char *channelmap, struct hdhomerun_channelmap_range_t *range);
// hdhomerun_channel_list_build_ranges
// file hdhomerun_channels.c line 362
static void hdhomerun_channel_list_build_ranges(struct hdhomerun_channel_list_t *channel_list, struct hdhomerun_channelmap_record_t *record);
// hdhomerun_channel_list_create
// file hdhomerun_channels.c line 382
extern struct hdhomerun_channel_list_t * hdhomerun_channel_list_create(const char *channelmap);
// hdhomerun_channel_list_destroy
// file hdhomerun_channels.c line 371
extern void hdhomerun_channel_list_destroy(struct hdhomerun_channel_list_t *channel_list);
// hdhomerun_channel_list_first
// file hdhomerun_channels.c line 219
extern struct hdhomerun_channel_entry_t * hdhomerun_channel_list_first(struct hdhomerun_channel_list_t *channel_list);
// hdhomerun_channel_list_frequency_count
// file hdhomerun_channels.c line 252
extern unsigned int hdhomerun_channel_list_frequency_count(struct hdhomerun_channel_list_t *channel_list);
// hdhomerun_channel_list_last
// file hdhomerun_channels.c line 224
extern struct hdhomerun_channel_entry_t * hdhomerun_channel_list_last(struct hdhomerun_channel_list_t *channel_list);
// hdhomerun_channel_list_next
// file hdhomerun_channels.c line 229
extern struct hdhomerun_channel_entry_t * hdhomerun_channel_list_next(struct hdhomerun_channel_list_t *channel_list, struct hdhomerun_channel_entry_t *entry);
// hdhomerun_channel_list_prev
// file hdhomerun_channels.c line 234
extern struct hdhomerun_channel_entry_t * hdhomerun_channel_list_prev(struct hdhomerun_channel_list_t *channel_list, struct hdhomerun_channel_entry_t *entry);
// hdhomerun_channel_list_total_count
// file hdhomerun_channels.c line 239
extern unsigned int hdhomerun_channel_list_total_count(struct hdhomerun_channel_list_t *channel_list);
// hdhomerun_channel_number_to_frequency
// file hdhomerun_channels.c line 281
extern unsigned int hdhomerun_channel_number_to_frequency(struct hdhomerun_channel_list_t *channel_list, unsigned short int channel_number);
// hdhomerun_channelmap_get_channelmap_from_country_source
// file hdhomerun_channels.c line 153
extern const char * hdhomerun_channelmap_get_channelmap_from_country_source(const char *countrycode, const char *source, const char *supported);
// hdhomerun_channelmap_get_channelmap_scan_group
// file hdhomerun_channels.h line 29
extern const char * hdhomerun_channelmap_get_channelmap_scan_group(const char *channelmap);
// hdhomerun_control_close_sock
// file hdhomerun_control.c line 39
static void hdhomerun_control_close_sock(struct hdhomerun_control_sock_t *cs);
// hdhomerun_control_connect_sock
// file hdhomerun_control.c line 80
static signed int hdhomerun_control_connect_sock(struct hdhomerun_control_sock_t *cs);
// hdhomerun_control_create
// file hdhomerun_control.c line 59
extern struct hdhomerun_control_sock_t * hdhomerun_control_create(unsigned int device_id, unsigned int device_ip, struct hdhomerun_debug_t *dbg);
// hdhomerun_control_destroy
// file hdhomerun_control.c line 74
extern void hdhomerun_control_destroy(struct hdhomerun_control_sock_t *cs);
// hdhomerun_control_get
// file hdhomerun_control.c line 340
extern signed int hdhomerun_control_get(struct hdhomerun_control_sock_t *cs, const char *name, char **pvalue, char **perror);
// hdhomerun_control_get_device_id
// file hdhomerun_control.c line 122
extern unsigned int hdhomerun_control_get_device_id(struct hdhomerun_control_sock_t *cs);
// hdhomerun_control_get_device_id_requested
// file hdhomerun_control.c line 142
extern unsigned int hdhomerun_control_get_device_id_requested(struct hdhomerun_control_sock_t *cs);
// hdhomerun_control_get_device_ip
// file hdhomerun_control.c line 132
extern unsigned int hdhomerun_control_get_device_ip(struct hdhomerun_control_sock_t *cs);
// hdhomerun_control_get_device_ip_requested
// file hdhomerun_control.c line 147
extern unsigned int hdhomerun_control_get_device_ip_requested(struct hdhomerun_control_sock_t *cs);
// hdhomerun_control_get_local_addr
// file hdhomerun_control.c line 152
extern unsigned int hdhomerun_control_get_local_addr(struct hdhomerun_control_sock_t *cs);
// hdhomerun_control_get_set
// file hdhomerun_control.c line 255
static signed int hdhomerun_control_get_set(struct hdhomerun_control_sock_t *cs, const char *name, const char *value, unsigned int lockkey, char **pvalue, char **perror);
// hdhomerun_control_recv_sock
// file hdhomerun_control.c line 179
static signed int hdhomerun_control_recv_sock(struct hdhomerun_control_sock_t *cs, struct hdhomerun_pkt_t *rx_pkt, unsigned short int *ptype, unsigned long int recv_timeout);
// hdhomerun_control_send_recv
// file hdhomerun_control.c line 250
extern signed int hdhomerun_control_send_recv(struct hdhomerun_control_sock_t *cs, struct hdhomerun_pkt_t *tx_pkt, struct hdhomerun_pkt_t *rx_pkt, unsigned short int type);
// hdhomerun_control_send_recv_internal
// file hdhomerun_control.c line 213
static signed int hdhomerun_control_send_recv_internal(struct hdhomerun_control_sock_t *cs, struct hdhomerun_pkt_t *tx_pkt, struct hdhomerun_pkt_t *rx_pkt, unsigned short int type, unsigned long int recv_timeout);
// hdhomerun_control_send_sock
// file hdhomerun_control.c line 168
static signed int hdhomerun_control_send_sock(struct hdhomerun_control_sock_t *cs, struct hdhomerun_pkt_t *tx_pkt);
// hdhomerun_control_set
// file hdhomerun_control.c line 345
extern signed int hdhomerun_control_set(struct hdhomerun_control_sock_t *cs, const char *name, const char *value, char **pvalue, char **perror);
// hdhomerun_control_set_device
// file hdhomerun_control.c line 49
extern void hdhomerun_control_set_device(struct hdhomerun_control_sock_t *cs, unsigned int device_id, unsigned int device_ip);
// hdhomerun_control_set_with_lockkey
// file hdhomerun_control.c line 350
extern signed int hdhomerun_control_set_with_lockkey(struct hdhomerun_control_sock_t *cs, const char *name, const char *value, unsigned int lockkey, char **pvalue, char **perror);
// hdhomerun_control_upgrade
// file hdhomerun_control.c line 355
extern signed int hdhomerun_control_upgrade(struct hdhomerun_control_sock_t *cs, struct _IO_FILE *upgrade_file);
// hdhomerun_debug_close
// file hdhomerun_debug.c line 133
extern void hdhomerun_debug_close(struct hdhomerun_debug_t *dbg, unsigned long int timeout);
// hdhomerun_debug_close_internal
// file hdhomerun_debug.c line 120
static void hdhomerun_debug_close_internal(struct hdhomerun_debug_t *dbg);
// hdhomerun_debug_create
// file hdhomerun_debug.c line 73
extern struct hdhomerun_debug_t * hdhomerun_debug_create(void);
// hdhomerun_debug_destroy
// file hdhomerun_debug.c line 94
extern void hdhomerun_debug_destroy(struct hdhomerun_debug_t *dbg);
// hdhomerun_debug_disable
// file hdhomerun_debug.c line 211
extern void hdhomerun_debug_disable(struct hdhomerun_debug_t *dbg);
// hdhomerun_debug_enable
// file hdhomerun_debug.c line 202
extern void hdhomerun_debug_enable(struct hdhomerun_debug_t *dbg);
// hdhomerun_debug_enabled
// file hdhomerun_debug.c line 220
extern signed int hdhomerun_debug_enabled(struct hdhomerun_debug_t *dbg);
// hdhomerun_debug_flush
// file hdhomerun_debug.c line 229
extern void hdhomerun_debug_flush(struct hdhomerun_debug_t *dbg, unsigned long int timeout);
// hdhomerun_debug_output_message
// file hdhomerun_debug.c line 386
static signed int hdhomerun_debug_output_message(struct hdhomerun_debug_t *dbg, struct hdhomerun_debug_message_t *message);
// hdhomerun_debug_output_message_file
// file hdhomerun_debug.c line 329
static signed int hdhomerun_debug_output_message_file(struct hdhomerun_debug_t *dbg, struct hdhomerun_debug_message_t *message);
// hdhomerun_debug_output_message_sock
// file hdhomerun_debug.c line 351
static signed int hdhomerun_debug_output_message_sock(struct hdhomerun_debug_t *dbg, struct hdhomerun_debug_message_t *message);
// hdhomerun_debug_pop_and_free_message
// file hdhomerun_debug.c line 401
static void hdhomerun_debug_pop_and_free_message(struct hdhomerun_debug_t *dbg);
// hdhomerun_debug_printf
// file hdhomerun_debug.h line 47
extern void hdhomerun_debug_printf(struct hdhomerun_debug_t *dbg, const char *fmt, ...);
// hdhomerun_debug_set_filename
// file hdhomerun_debug.c line 149
extern void hdhomerun_debug_set_filename(struct hdhomerun_debug_t *dbg, const char *filename);
// hdhomerun_debug_set_prefix
// file hdhomerun_debug.c line 182
extern void hdhomerun_debug_set_prefix(struct hdhomerun_debug_t *dbg, const char *prefix);
// hdhomerun_debug_thread_execute
// file hdhomerun_debug.c line 419
static void * hdhomerun_debug_thread_execute(void *arg);
// hdhomerun_debug_vprintf
// file hdhomerun_debug.c line 258
extern void hdhomerun_debug_vprintf(struct hdhomerun_debug_t *dbg, const char *fmt, void **args);
// hdhomerun_device_channelscan_advance
// file hdhomerun_device.h line 228
extern signed int hdhomerun_device_channelscan_advance(struct hdhomerun_device_t *hd, struct hdhomerun_channelscan_result_t *result);
// hdhomerun_device_channelscan_detect
// file hdhomerun_device.h line 229
extern signed int hdhomerun_device_channelscan_detect(struct hdhomerun_device_t *hd, struct hdhomerun_channelscan_result_t *result);
// hdhomerun_device_channelscan_get_progress
// file hdhomerun_device.c line 1253
extern unsigned char hdhomerun_device_channelscan_get_progress(struct hdhomerun_device_t *hd);
// hdhomerun_device_channelscan_init
// file hdhomerun_device.h line 227
extern signed int hdhomerun_device_channelscan_init(struct hdhomerun_device_t *hd, const char *channelmap);
// hdhomerun_device_create
// file hdhomerun_device.c line 149
extern struct hdhomerun_device_t * hdhomerun_device_create(unsigned int device_id, unsigned int device_ip, unsigned int tuner, struct hdhomerun_debug_t *dbg);
// hdhomerun_device_create_from_str
// file hdhomerun_device.h line 68
extern struct hdhomerun_device_t * hdhomerun_device_create_from_str(const char *device_str, struct hdhomerun_debug_t *dbg);
// hdhomerun_device_create_internal
// file hdhomerun_device.c line 137
static struct hdhomerun_device_t * hdhomerun_device_create_internal(struct hdhomerun_debug_t *dbg);
// hdhomerun_device_create_multicast
// file hdhomerun_device.c line 172
extern struct hdhomerun_device_t * hdhomerun_device_create_multicast(unsigned int multicast_ip, unsigned short int multicast_port, struct hdhomerun_debug_t *dbg);
// hdhomerun_device_debug_print_video_stats
// file hdhomerun_device.c line 1320
extern void hdhomerun_device_debug_print_video_stats(struct hdhomerun_device_t *hd);
// hdhomerun_device_destroy
// file hdhomerun_device.h line 69
extern void hdhomerun_device_destroy(struct hdhomerun_device_t *hd);
// hdhomerun_device_get_control_sock
// file hdhomerun_device.c line 331
extern struct hdhomerun_control_sock_t * hdhomerun_device_get_control_sock(struct hdhomerun_device_t *hd);
// hdhomerun_device_get_device_id
// file hdhomerun_device.c line 285
extern unsigned int hdhomerun_device_get_device_id(struct hdhomerun_device_t *hd);
// hdhomerun_device_get_device_id_requested
// file hdhomerun_device.h line 77
extern unsigned int hdhomerun_device_get_device_id_requested(struct hdhomerun_device_t *hd);
// hdhomerun_device_get_device_ip
// file hdhomerun_device.c line 290
extern unsigned int hdhomerun_device_get_device_ip(struct hdhomerun_device_t *hd);
// hdhomerun_device_get_device_ip_requested
// file hdhomerun_device.c line 314
extern unsigned int hdhomerun_device_get_device_ip_requested(struct hdhomerun_device_t *hd);
// hdhomerun_device_get_hw_model_str
// file hdhomerun_device.c line 1263
extern const char * hdhomerun_device_get_hw_model_str(struct hdhomerun_device_t *hd);
// hdhomerun_device_get_ir_target
// file hdhomerun_device.c line 767
extern signed int hdhomerun_device_get_ir_target(struct hdhomerun_device_t *hd, char **ptarget);
// hdhomerun_device_get_local_machine_addr
// file hdhomerun_device.c line 353
extern unsigned int hdhomerun_device_get_local_machine_addr(struct hdhomerun_device_t *hd);
// hdhomerun_device_get_model_str
// file hdhomerun_device.h line 128
extern const char * hdhomerun_device_get_model_str(struct hdhomerun_device_t *hd);
// hdhomerun_device_get_name
// file hdhomerun_device.c line 280
extern const char * hdhomerun_device_get_name(struct hdhomerun_device_t *hd);
// hdhomerun_device_get_oob_plotsample
// file hdhomerun_device.c line 745
extern signed int hdhomerun_device_get_oob_plotsample(struct hdhomerun_device_t *hd, struct hdhomerun_plotsample_t **psamples, unsigned long int *pcount);
// hdhomerun_device_get_oob_status
// file hdhomerun_device.c line 494
extern signed int hdhomerun_device_get_oob_status(struct hdhomerun_device_t *hd, char **pstatus_str, struct hdhomerun_tuner_status_t *status);
// hdhomerun_device_get_status_parse
// file hdhomerun_device.c line 362
static unsigned int hdhomerun_device_get_status_parse(const char *status_str, const char *tag);
// hdhomerun_device_get_supported
// file hdhomerun_device.c line 806
extern signed int hdhomerun_device_get_supported(struct hdhomerun_device_t *hd, char *prefix, char **pstr);
// hdhomerun_device_get_tuner
// file hdhomerun_device.c line 326
extern unsigned int hdhomerun_device_get_tuner(struct hdhomerun_device_t *hd);
// hdhomerun_device_get_tuner_channel
// file hdhomerun_device.c line 615
extern signed int hdhomerun_device_get_tuner_channel(struct hdhomerun_device_t *hd, char **pchannel);
// hdhomerun_device_get_tuner_channelmap
// file hdhomerun_device.h line 111
extern signed int hdhomerun_device_get_tuner_channelmap(struct hdhomerun_device_t *hd, char **pchannelmap);
// hdhomerun_device_get_tuner_filter
// file hdhomerun_device.c line 651
extern signed int hdhomerun_device_get_tuner_filter(struct hdhomerun_device_t *hd, char **pfilter);
// hdhomerun_device_get_tuner_lockkey_owner
// file hdhomerun_device.c line 755
extern signed int hdhomerun_device_get_tuner_lockkey_owner(struct hdhomerun_device_t *hd, char **powner);
// hdhomerun_device_get_tuner_plotsample
// file hdhomerun_device.c line 733
extern signed int hdhomerun_device_get_tuner_plotsample(struct hdhomerun_device_t *hd, struct hdhomerun_plotsample_t **psamples, unsigned long int *pcount);
// hdhomerun_device_get_tuner_plotsample_internal
// file hdhomerun_device.c line 687
static signed int hdhomerun_device_get_tuner_plotsample_internal(struct hdhomerun_device_t *hd, const char *name, struct hdhomerun_plotsample_t **psamples, unsigned long int *pcount);
// hdhomerun_device_get_tuner_program
// file hdhomerun_device.c line 663
extern signed int hdhomerun_device_get_tuner_program(struct hdhomerun_device_t *hd, char **pprogram);
// hdhomerun_device_get_tuner_status
// file hdhomerun_device.h line 106
extern signed int hdhomerun_device_get_tuner_status(struct hdhomerun_device_t *hd, char **pstatus_str, struct hdhomerun_tuner_status_t *status);
// hdhomerun_device_get_tuner_status_lock_is_bcast
// file hdhomerun_device.c line 375
static signed int hdhomerun_device_get_tuner_status_lock_is_bcast(struct hdhomerun_tuner_status_t *status);
// hdhomerun_device_get_tuner_status_seq_color
// file hdhomerun_device.c line 432
extern unsigned int hdhomerun_device_get_tuner_status_seq_color(struct hdhomerun_tuner_status_t *status);
// hdhomerun_device_get_tuner_status_snq_color
// file hdhomerun_device.c line 420
extern unsigned int hdhomerun_device_get_tuner_status_snq_color(struct hdhomerun_tuner_status_t *status);
// hdhomerun_device_get_tuner_status_ss_color
// file hdhomerun_device.c line 393
extern unsigned int hdhomerun_device_get_tuner_status_ss_color(struct hdhomerun_tuner_status_t *status);
// hdhomerun_device_get_tuner_streaminfo
// file hdhomerun_device.h line 108
extern signed int hdhomerun_device_get_tuner_streaminfo(struct hdhomerun_device_t *hd, char **pstreaminfo);
// hdhomerun_device_get_tuner_target
// file hdhomerun_device.c line 675
extern signed int hdhomerun_device_get_tuner_target(struct hdhomerun_device_t *hd, char **ptarget);
// hdhomerun_device_get_tuner_vchannel
// file hdhomerun_device.c line 627
extern signed int hdhomerun_device_get_tuner_vchannel(struct hdhomerun_device_t *hd, char **pvchannel);
// hdhomerun_device_get_tuner_vstatus
// file hdhomerun_device.c line 533
extern signed int hdhomerun_device_get_tuner_vstatus(struct hdhomerun_device_t *hd, char **pvstatus_str, struct hdhomerun_tuner_vstatus_t *vstatus);
// hdhomerun_device_get_var
// file hdhomerun_device.h line 166
extern signed int hdhomerun_device_get_var(struct hdhomerun_device_t *hd, const char *name, char **pvalue, char **perror);
// hdhomerun_device_get_version
// file hdhomerun_device.h line 120
extern signed int hdhomerun_device_get_version(struct hdhomerun_device_t *hd, char **pversion_str, unsigned int *pversion_num);
// hdhomerun_device_get_video_sock
// file hdhomerun_device.c line 336
extern struct hdhomerun_video_sock_t * hdhomerun_device_get_video_sock(struct hdhomerun_device_t *hd);
// hdhomerun_device_get_video_stats
// file hdhomerun_device.h line 253
extern void hdhomerun_device_get_video_stats(struct hdhomerun_device_t *hd, struct hdhomerun_video_stats_t *stats);
// hdhomerun_device_selector_add_device
// file hdhomerun_device_selector.c line 64
extern void hdhomerun_device_selector_add_device(struct hdhomerun_device_selector_t *hds, struct hdhomerun_device_t *hd);
// hdhomerun_device_selector_choose_and_lock
// file hdhomerun_device_selector.c line 423
extern struct hdhomerun_device_t * hdhomerun_device_selector_choose_and_lock(struct hdhomerun_device_selector_t *hds, struct hdhomerun_device_t *prefered);
// hdhomerun_device_selector_choose_test
// file hdhomerun_device_selector.c line 318
static signed int hdhomerun_device_selector_choose_test(struct hdhomerun_device_selector_t *hds, struct hdhomerun_device_t *test_hd);
// hdhomerun_device_selector_create
// file hdhomerun_device_selector.c line 29
extern struct hdhomerun_device_selector_t * hdhomerun_device_selector_create(struct hdhomerun_debug_t *dbg);
// hdhomerun_device_selector_destroy
// file hdhomerun_device_selector.c line 42
extern void hdhomerun_device_selector_destroy(struct hdhomerun_device_selector_t *hds, signed int destroy_devices);
// hdhomerun_device_selector_find_device
// file hdhomerun_device_selector.c line 108
extern struct hdhomerun_device_t * hdhomerun_device_selector_find_device(struct hdhomerun_device_selector_t *hds, unsigned int device_id, unsigned int tuner_index);
// hdhomerun_device_selector_get_device_count
// file hdhomerun_device_selector.c line 59
extern signed int hdhomerun_device_selector_get_device_count(struct hdhomerun_device_selector_t *hds);
// hdhomerun_device_selector_load_from_file
// file hdhomerun_device_selector.c line 245
extern signed int hdhomerun_device_selector_load_from_file(struct hdhomerun_device_selector_t *hds, char *filename);
// hdhomerun_device_selector_load_from_str
// file hdhomerun_device_selector.c line 151
extern signed int hdhomerun_device_selector_load_from_str(struct hdhomerun_device_selector_t *hds, char *device_str);
// hdhomerun_device_selector_load_from_str_discover
// file hdhomerun_device_selector.c line 125
static signed int hdhomerun_device_selector_load_from_str_discover(struct hdhomerun_device_selector_t *hds, unsigned int target_ip, unsigned int device_id);
// hdhomerun_device_selector_remove_device
// file hdhomerun_device_selector.c line 83
extern void hdhomerun_device_selector_remove_device(struct hdhomerun_device_selector_t *hds, struct hdhomerun_device_t *hd);
// hdhomerun_device_set_device
// file hdhomerun_device.c line 37
extern signed int hdhomerun_device_set_device(struct hdhomerun_device_t *hd, unsigned int device_id, unsigned int device_ip);
// hdhomerun_device_set_ir_target
// file hdhomerun_device.c line 995
extern signed int hdhomerun_device_set_ir_target(struct hdhomerun_device_t *hd, const char *target);
// hdhomerun_device_set_multicast
// file hdhomerun_device.c line 75
extern signed int hdhomerun_device_set_multicast(struct hdhomerun_device_t *hd, unsigned int multicast_ip, unsigned short int multicast_port);
// hdhomerun_device_set_sys_dvbc_modulation
// file hdhomerun_device.c line 1005
extern signed int hdhomerun_device_set_sys_dvbc_modulation(struct hdhomerun_device_t *hd, const char *modulation_list);
// hdhomerun_device_set_tuner
// file hdhomerun_device.c line 105
extern signed int hdhomerun_device_set_tuner(struct hdhomerun_device_t *hd, unsigned int tuner);
// hdhomerun_device_set_tuner_channel
// file hdhomerun_device.h line 139
extern signed int hdhomerun_device_set_tuner_channel(struct hdhomerun_device_t *hd, const char *channel);
// hdhomerun_device_set_tuner_channelmap
// file hdhomerun_device.c line 864
extern signed int hdhomerun_device_set_tuner_channelmap(struct hdhomerun_device_t *hd, const char *channelmap);
// hdhomerun_device_set_tuner_filter
// file hdhomerun_device.c line 876
extern signed int hdhomerun_device_set_tuner_filter(struct hdhomerun_device_t *hd, const char *filter);
// hdhomerun_device_set_tuner_filter_by_array
// file hdhomerun_device.c line 897
extern signed int hdhomerun_device_set_tuner_filter_by_array(struct hdhomerun_device_t *hd, unsigned char *filter_array);
// hdhomerun_device_set_tuner_filter_by_array_append
// file hdhomerun_device.c line 888
static signed int hdhomerun_device_set_tuner_filter_by_array_append(char *ptr, char *end, unsigned short int range_begin, unsigned short int range_end);
// hdhomerun_device_set_tuner_from_str
// file hdhomerun_device.h line 84
extern signed int hdhomerun_device_set_tuner_from_str(struct hdhomerun_device_t *hd, const char *tuner_str);
// hdhomerun_device_set_tuner_program
// file hdhomerun_device.c line 946
extern signed int hdhomerun_device_set_tuner_program(struct hdhomerun_device_t *hd, const char *program);
// hdhomerun_device_set_tuner_target
// file hdhomerun_device.h line 145
extern signed int hdhomerun_device_set_tuner_target(struct hdhomerun_device_t *hd, const char *target);
// hdhomerun_device_set_tuner_target_to_local
// file hdhomerun_device.c line 970
static signed int hdhomerun_device_set_tuner_target_to_local(struct hdhomerun_device_t *hd, const char *protocol);
// hdhomerun_device_set_tuner_vchannel
// file hdhomerun_device.c line 852
extern signed int hdhomerun_device_set_tuner_vchannel(struct hdhomerun_device_t *hd, const char *vchannel);
// hdhomerun_device_set_var
// file hdhomerun_device.h line 167
extern signed int hdhomerun_device_set_var(struct hdhomerun_device_t *hd, const char *name, const char *value, char **pvalue, char **perror);
// hdhomerun_device_stream_flush
// file hdhomerun_device.c line 1182
extern void hdhomerun_device_stream_flush(struct hdhomerun_device_t *hd);
// hdhomerun_device_stream_recv
// file hdhomerun_device.h line 220
extern unsigned char * hdhomerun_device_stream_recv(struct hdhomerun_device_t *hd, unsigned long int max_size, unsigned long int *pactual_size);
// hdhomerun_device_stream_start
// file hdhomerun_device.h line 219
extern signed int hdhomerun_device_stream_start(struct hdhomerun_device_t *hd);
// hdhomerun_device_stream_stop
// file hdhomerun_device.h line 222
extern void hdhomerun_device_stream_stop(struct hdhomerun_device_t *hd);
// hdhomerun_device_tuner_lockkey_force
// file hdhomerun_device.c line 1085
extern signed int hdhomerun_device_tuner_lockkey_force(struct hdhomerun_device_t *hd);
// hdhomerun_device_tuner_lockkey_release
// file hdhomerun_device.h line 183
extern signed int hdhomerun_device_tuner_lockkey_release(struct hdhomerun_device_t *hd);
// hdhomerun_device_tuner_lockkey_request
// file hdhomerun_device.h line 182
extern signed int hdhomerun_device_tuner_lockkey_request(struct hdhomerun_device_t *hd, char **perror);
// hdhomerun_device_tuner_lockkey_use_value
// file hdhomerun_device.h line 189
extern void hdhomerun_device_tuner_lockkey_use_value(struct hdhomerun_device_t *hd, unsigned int lockkey);
// hdhomerun_device_upgrade
// file hdhomerun_device.h line 241
extern signed int hdhomerun_device_upgrade(struct hdhomerun_device_t *hd, struct _IO_FILE *upgrade_file);
// hdhomerun_device_wait_for_lock
// file hdhomerun_device.h line 201
extern signed int hdhomerun_device_wait_for_lock(struct hdhomerun_device_t *hd, struct hdhomerun_tuner_status_t *status);
// hdhomerun_discover_create
// file hdhomerun_discover.c line 79
extern struct hdhomerun_discover_t * hdhomerun_discover_create(struct hdhomerun_debug_t *dbg);
// hdhomerun_discover_destroy
// file hdhomerun_discover.c line 98
extern void hdhomerun_discover_destroy(struct hdhomerun_discover_t *ds);
// hdhomerun_discover_find_devices_custom_v2
// file hdhomerun_discover.h line 48
extern signed int hdhomerun_discover_find_devices_custom_v2(unsigned int target_ip, unsigned int device_type, unsigned int device_id, struct hdhomerun_discover_device_t *result_list, signed int max_count);
// hdhomerun_discover_find_devices_v2
// file hdhomerun_discover.c line 406
extern signed int hdhomerun_discover_find_devices_v2(struct hdhomerun_discover_t *ds, unsigned int target_ip, unsigned int device_type, unsigned int device_id, struct hdhomerun_discover_device_t *result_list, signed int max_count);
// hdhomerun_discover_find_in_list
// file hdhomerun_discover.c line 393
static struct hdhomerun_discover_device_t * hdhomerun_discover_find_in_list(struct hdhomerun_discover_device_t *result_list, signed int count, struct hdhomerun_discover_device_t *lookup);
// hdhomerun_discover_is_ip_multicast
// file hdhomerun_discover.h line 74
extern signed int hdhomerun_discover_is_ip_multicast(unsigned int ip_addr);
// hdhomerun_discover_is_legacy
// file hdhomerun_discover.c line 234
static signed int hdhomerun_discover_is_legacy(unsigned int device_id);
// hdhomerun_discover_recv
// file hdhomerun_discover.c line 379
static signed int hdhomerun_discover_recv(struct hdhomerun_discover_t *ds, struct hdhomerun_discover_device_t *result);
// hdhomerun_discover_recv_internal
// file hdhomerun_discover.c line 256
static signed int hdhomerun_discover_recv_internal(struct hdhomerun_discover_t *ds, struct hdhomerun_discover_sock_t *dss, struct hdhomerun_discover_device_t *result);
// hdhomerun_discover_send
// file hdhomerun_discover.c line 225
static signed int hdhomerun_discover_send(struct hdhomerun_discover_t *ds, unsigned int target_ip, unsigned int device_type, unsigned int device_id);
// hdhomerun_discover_send_internal
// file hdhomerun_discover.c line 154
static signed int hdhomerun_discover_send_internal(struct hdhomerun_discover_t *ds, struct hdhomerun_discover_sock_t *dss, unsigned int target_ip, unsigned int device_type, unsigned int device_id);
// hdhomerun_discover_send_target_ip
// file hdhomerun_discover.c line 196
static signed int hdhomerun_discover_send_target_ip(struct hdhomerun_discover_t *ds, unsigned int target_ip, unsigned int device_type, unsigned int device_id);
// hdhomerun_discover_send_wildcard_ip
// file hdhomerun_discover.c line 170
static signed int hdhomerun_discover_send_wildcard_ip(struct hdhomerun_discover_t *ds, unsigned int device_type, unsigned int device_id);
// hdhomerun_discover_sock_add
// file hdhomerun_discover.c line 40
static signed int hdhomerun_discover_sock_add(struct hdhomerun_discover_t *ds, unsigned int local_ip, unsigned int subnet_mask);
// hdhomerun_discover_sock_detect
// file hdhomerun_discover.c line 109
static void hdhomerun_discover_sock_detect(struct hdhomerun_discover_t *ds);
// hdhomerun_discover_validate_device_id
// file hdhomerun_discover.h line 66
extern signed int hdhomerun_discover_validate_device_id(unsigned int device_id);
// hdhomerun_local_ip_info
// file hdhomerun_sock.h line 29
extern signed int hdhomerun_local_ip_info(struct hdhomerun_local_ip_info_t *ip_info_list, signed int max_count);
// hdhomerun_pkt_calc_crc
// file hdhomerun_pkt.c line 48
static unsigned int hdhomerun_pkt_calc_crc(unsigned char *start, unsigned char *end);
// hdhomerun_pkt_create
// file hdhomerun_pkt.c line 23
extern struct hdhomerun_pkt_t * hdhomerun_pkt_create(void);
// hdhomerun_pkt_destroy
// file hdhomerun_pkt.c line 35
extern void hdhomerun_pkt_destroy(struct hdhomerun_pkt_t *pkt);
// hdhomerun_pkt_open_frame
// file hdhomerun_pkt.h line 165
extern signed int hdhomerun_pkt_open_frame(struct hdhomerun_pkt_t *pkt, unsigned short int *ptype);
// hdhomerun_pkt_read_mem
// file hdhomerun_pkt.h line 157
extern void hdhomerun_pkt_read_mem(struct hdhomerun_pkt_t *pkt, void *mem, unsigned long int length);
// hdhomerun_pkt_read_tlv
// file hdhomerun_pkt.h line 156
extern unsigned char * hdhomerun_pkt_read_tlv(struct hdhomerun_pkt_t *pkt, unsigned char *ptag, unsigned long int *plength);
// hdhomerun_pkt_read_u16
// file hdhomerun_pkt.c line 73
extern unsigned short int hdhomerun_pkt_read_u16(struct hdhomerun_pkt_t *pkt);
// hdhomerun_pkt_read_u32
// file hdhomerun_pkt.h line 154
extern unsigned int hdhomerun_pkt_read_u32(struct hdhomerun_pkt_t *pkt);
// hdhomerun_pkt_read_u8
// file hdhomerun_pkt.h line 152
extern unsigned char hdhomerun_pkt_read_u8(struct hdhomerun_pkt_t *pkt);
// hdhomerun_pkt_read_var_length
// file hdhomerun_pkt.c line 91
extern unsigned long int hdhomerun_pkt_read_var_length(struct hdhomerun_pkt_t *pkt);
// hdhomerun_pkt_reset
// file hdhomerun_pkt.h line 150
extern void hdhomerun_pkt_reset(struct hdhomerun_pkt_t *pkt);
// hdhomerun_pkt_seal_frame
// file hdhomerun_pkt.h line 166
extern void hdhomerun_pkt_seal_frame(struct hdhomerun_pkt_t *pkt, unsigned short int frame_type);
// hdhomerun_pkt_write_mem
// file hdhomerun_pkt.h line 163
extern void hdhomerun_pkt_write_mem(struct hdhomerun_pkt_t *pkt, const void *mem, unsigned long int length);
// hdhomerun_pkt_write_u16
// file hdhomerun_pkt.c line 143
extern void hdhomerun_pkt_write_u16(struct hdhomerun_pkt_t *pkt, unsigned short int v);
// hdhomerun_pkt_write_u32
// file hdhomerun_pkt.h line 161
extern void hdhomerun_pkt_write_u32(struct hdhomerun_pkt_t *pkt, unsigned int v);
// hdhomerun_pkt_write_u8
// file hdhomerun_pkt.h line 159
extern void hdhomerun_pkt_write_u8(struct hdhomerun_pkt_t *pkt, unsigned char v);
// hdhomerun_pkt_write_var_length
// file hdhomerun_pkt.h line 162
extern void hdhomerun_pkt_write_var_length(struct hdhomerun_pkt_t *pkt, unsigned long int v);
// hdhomerun_sock_bind
// file hdhomerun_sock.h line 48
extern signed int hdhomerun_sock_bind(signed int sock, unsigned int local_addr, unsigned short int local_port, signed int allow_reuse);
// hdhomerun_sock_connect
// file hdhomerun_sock.h line 49
extern signed int hdhomerun_sock_connect(signed int sock, unsigned int remote_addr, unsigned short int remote_port, unsigned long int timeout);
// hdhomerun_sock_create_tcp
// file hdhomerun_sock.h line 36
extern signed int hdhomerun_sock_create_tcp(void);
// hdhomerun_sock_create_udp
// file hdhomerun_sock.h line 35
extern signed int hdhomerun_sock_create_udp(void);
// hdhomerun_sock_destroy
// file hdhomerun_sock.h line 37
extern void hdhomerun_sock_destroy(signed int sock);
// hdhomerun_sock_getaddrinfo_addr
// file hdhomerun_sock.h line 43
extern unsigned int hdhomerun_sock_getaddrinfo_addr(signed int sock, const char *name);
// hdhomerun_sock_getlasterror
// file hdhomerun_sock.h line 39
extern signed int hdhomerun_sock_getlasterror(void);
// hdhomerun_sock_getpeername_addr
// file hdhomerun_sock_posix.c line 216
extern unsigned int hdhomerun_sock_getpeername_addr(signed int sock);
// hdhomerun_sock_getsockname_addr
// file hdhomerun_sock.h line 40
extern unsigned int hdhomerun_sock_getsockname_addr(signed int sock);
// hdhomerun_sock_getsockname_port
// file hdhomerun_sock_posix.c line 204
extern unsigned short int hdhomerun_sock_getsockname_port(signed int sock);
// hdhomerun_sock_join_multicast_group
// file hdhomerun_sock_posix.c line 248
extern signed int hdhomerun_sock_join_multicast_group(signed int sock, unsigned int multicast_ip, unsigned int local_ip);
// hdhomerun_sock_leave_multicast_group
// file hdhomerun_sock_posix.c line 262
extern signed int hdhomerun_sock_leave_multicast_group(signed int sock, unsigned int multicast_ip, unsigned int local_ip);
// hdhomerun_sock_recv
// file hdhomerun_sock.h line 54
extern signed int hdhomerun_sock_recv(signed int sock, void *data, unsigned long int *length, unsigned long int timeout);
// hdhomerun_sock_recvfrom
// file hdhomerun_sock.h line 55
extern signed int hdhomerun_sock_recvfrom(signed int sock, unsigned int *remote_addr, unsigned short int *remote_port, void *data, unsigned long int *length, unsigned long int timeout);
// hdhomerun_sock_send
// file hdhomerun_sock.h line 51
extern signed int hdhomerun_sock_send(signed int sock, const void *data, unsigned long int length, unsigned long int timeout);
// hdhomerun_sock_sendto
// file hdhomerun_sock.h line 52
extern signed int hdhomerun_sock_sendto(signed int sock, unsigned int remote_addr, unsigned short int remote_port, const void *data, unsigned long int length, unsigned long int timeout);
// hdhomerun_sock_wait_for_event
// file hdhomerun_sock_posix.c line 294
static signed int hdhomerun_sock_wait_for_event(signed int sock, signed short int event_type, unsigned long int stop_time);
// hdhomerun_sprintf
// file hdhomerun_os_posix.h line 59
extern signed int hdhomerun_sprintf(char *buffer, char *end, const char *fmt, ...);
// hdhomerun_video_create
// file hdhomerun_video.h line 51
extern struct hdhomerun_video_sock_t * hdhomerun_video_create(unsigned short int listen_port, signed int allow_port_reuse, unsigned long int buffer_size, struct hdhomerun_debug_t *dbg);
// hdhomerun_video_debug_print_stats
// file hdhomerun_video.h line 94
extern void hdhomerun_video_debug_print_stats(struct hdhomerun_video_sock_t *vs);
// hdhomerun_video_destroy
// file hdhomerun_video.h line 52
extern void hdhomerun_video_destroy(struct hdhomerun_video_sock_t *vs);
// hdhomerun_video_flush
// file hdhomerun_video.h line 89
extern void hdhomerun_video_flush(struct hdhomerun_video_sock_t *vs);
// hdhomerun_video_get_local_port
// file hdhomerun_video.h line 59
extern unsigned short int hdhomerun_video_get_local_port(struct hdhomerun_video_sock_t *vs);
// hdhomerun_video_get_sock
// file hdhomerun_video.c line 128
extern signed int hdhomerun_video_get_sock(struct hdhomerun_video_sock_t *vs);
// hdhomerun_video_get_stats
// file hdhomerun_video.h line 95
extern void hdhomerun_video_get_stats(struct hdhomerun_video_sock_t *vs, struct hdhomerun_video_stats_t *stats);
// hdhomerun_video_join_multicast_group
// file hdhomerun_video.h line 64
extern signed int hdhomerun_video_join_multicast_group(struct hdhomerun_video_sock_t *vs, unsigned int multicast_ip, unsigned int local_ip);
// hdhomerun_video_leave_multicast_group
// file hdhomerun_video.h line 65
extern void hdhomerun_video_leave_multicast_group(struct hdhomerun_video_sock_t *vs, unsigned int multicast_ip, unsigned int local_ip);
// hdhomerun_video_parse_rtp
// file hdhomerun_video.c line 193
static void hdhomerun_video_parse_rtp(struct hdhomerun_video_sock_t *vs, struct hdhomerun_pkt_t *pkt);
// hdhomerun_video_recv
// file hdhomerun_video.h line 84
extern unsigned char * hdhomerun_video_recv(struct hdhomerun_video_sock_t *vs, unsigned long int max_size, unsigned long int *pactual_size);
// hdhomerun_video_stats_ts_pkt
// file hdhomerun_video.c line 161
static void hdhomerun_video_stats_ts_pkt(struct hdhomerun_video_sock_t *vs, unsigned char *ptr);
// hdhomerun_video_thread_execute
// file hdhomerun_video.c line 222
static void * hdhomerun_video_thread_execute(void *arg);
// hdhomerun_vsprintf
// file hdhomerun_os_posix.h line 58
extern signed int hdhomerun_vsprintf(char *buffer, char *end, const char *fmt, void **ap);
// help
// file hdhomerun_config.c line 37
static signed int help(void);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// main_cmd
// file hdhomerun_config.c line 561
static signed int main_cmd(signed int argc, char **argv);
// main_internal
// file hdhomerun_config.c line 626
static signed int main_internal(signed int argc, char **argv);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// msleep_approx
// file hdhomerun_os_posix.h line 55
extern void msleep_approx(unsigned long int ms);
// msleep_minimum
// file hdhomerun_os_posix.h line 56
extern void msleep_minimum(unsigned long int ms);
// parse_ip_addr
// file hdhomerun_config.c line 82
static unsigned int parse_ip_addr(const char *str);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_2 *, const union anonymous_3 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_2 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_2 *);
// pthread_once
// file /usr/include/pthread.h line 496
extern signed int pthread_once(signed int *, void (*)(void));
// random_get32
// file hdhomerun_os_posix.h line 53
extern unsigned int random_get32(void);
// random_get32_init
// file hdhomerun_os_posix.c line 31
static void random_get32_init(void);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, struct sockaddr *, unsigned int *);
// register_signal_handlers
// file hdhomerun_config.c line 206
static void register_signal_handlers(void (*sigpipe_handler)(signed int), void (*sigint_handler)(signed int), void (*siginfo_handler)(signed int));
// register_signal_handlers::siginfo_handler_object
//
void siginfo_handler_object(signed int);
// register_signal_handlers::sigint_handler_object
//
void sigint_handler_object(signed int);
// register_signal_handlers::sigpipe_handler_object
//
void sigpipe_handler_object(signed int);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, struct sockaddr *, unsigned int);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// sigabort_handler
// file hdhomerun_config.c line 196
static void sigabort_handler(signed int arg);
// siginfo_handler
// file hdhomerun_config.c line 201
static void siginfo_handler(signed int arg);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 36
static inline signed int vprintf(const char * restrict __fmt, void **__arg);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);

union anonymous
{
  // ifcu_buf
  char *ifcu_buf;
  // ifcu_req
  struct ifreq *ifcu_req;
};

union anonymous_1
{
  // ifrn_name
  char ifrn_name[16l];
};

union anonymous_3
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_2
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct ifmap
{
  // mem_start
  unsigned long int mem_start;
  // mem_end
  unsigned long int mem_end;
  // base_addr
  unsigned short int base_addr;
  // irq
  unsigned char irq;
  // dma
  unsigned char dma;
  // port
  unsigned char port;
};

union anonymous_0
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  char *ifru_data;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct hdhomerun_channel_entry_t
{
  // next
  struct hdhomerun_channel_entry_t *next;
  // prev
  struct hdhomerun_channel_entry_t *prev;
  // frequency
  unsigned int frequency;
  // channel_number
  unsigned short int channel_number;
  // name
  char name[16l];
};

struct hdhomerun_channel_list_t
{
  // head
  struct hdhomerun_channel_entry_t *head;
  // tail
  struct hdhomerun_channel_entry_t *tail;
};

struct hdhomerun_channelmap_range_t
{
  // channel_range_start
  unsigned short int channel_range_start;
  // channel_range_end
  unsigned short int channel_range_end;
  // frequency
  unsigned int frequency;
  // spacing
  unsigned int spacing;
};

struct hdhomerun_channelmap_record_t
{
  // channelmap
  const char *channelmap;
  // range_list
  struct hdhomerun_channelmap_range_t *range_list;
  // channelmap_scan_group
  const char *channelmap_scan_group;
  // countrycodes
  const char *countrycodes;
};

struct hdhomerun_channelscan_program_t
{
  // program_str
  char program_str[64l];
  // program_number
  unsigned short int program_number;
  // virtual_major
  unsigned short int virtual_major;
  // virtual_minor
  unsigned short int virtual_minor;
  // type
  unsigned short int type;
  // name
  char name[32l];
};

struct hdhomerun_tuner_status_t
{
  // channel
  char channel[32l];
  // lock_str
  char lock_str[32l];
  // signal_present
  signed int signal_present;
  // lock_supported
  signed int lock_supported;
  // lock_unsupported
  signed int lock_unsupported;
  // signal_strength
  unsigned int signal_strength;
  // signal_to_noise_quality
  unsigned int signal_to_noise_quality;
  // symbol_error_quality
  unsigned int symbol_error_quality;
  // raw_bits_per_second
  unsigned int raw_bits_per_second;
  // packets_per_second
  unsigned int packets_per_second;
};

struct hdhomerun_channelscan_result_t
{
  // channel_str
  char channel_str[64l];
  // channelmap
  unsigned int channelmap;
  // frequency
  unsigned int frequency;
  // status
  struct hdhomerun_tuner_status_t status;
  // program_count
  signed int program_count;
  // programs
  struct hdhomerun_channelscan_program_t programs[64l];
  // transport_stream_id_detected
  signed int transport_stream_id_detected;
  // original_network_id_detected
  signed int original_network_id_detected;
  // transport_stream_id
  unsigned short int transport_stream_id;
  // original_network_id
  unsigned short int original_network_id;
};

struct hdhomerun_channelscan_t
{
  // hd
  struct hdhomerun_device_t *hd;
  // scanned_channels
  unsigned int scanned_channels;
  // channel_list
  struct hdhomerun_channel_list_t *channel_list;
  // next_channel
  struct hdhomerun_channel_entry_t *next_channel;
};

struct hdhomerun_pkt_t
{
  // pos
  unsigned char *pos;
  // start
  unsigned char *start;
  // end
  unsigned char *end;
  // limit
  unsigned char *limit;
  // buffer
  unsigned char buffer[3074l];
};

struct hdhomerun_control_sock_t
{
  // desired_device_id
  unsigned int desired_device_id;
  // desired_device_ip
  unsigned int desired_device_ip;
  // actual_device_id
  unsigned int actual_device_id;
  // actual_device_ip
  unsigned int actual_device_ip;
  // sock
  signed int sock;
  // dbg
  struct hdhomerun_debug_t *dbg;
  // tx_pkt
  struct hdhomerun_pkt_t tx_pkt;
  // rx_pkt
  struct hdhomerun_pkt_t rx_pkt;
};

struct hdhomerun_debug_message_t
{
  // next
  struct hdhomerun_debug_message_t *next;
  // prev
  struct hdhomerun_debug_message_t *prev;
  // buffer
  char buffer[2048l];
};

struct hdhomerun_debug_t
{
  // thread
  unsigned long int thread;
  // enabled
  volatile signed int enabled;
  // terminate
  volatile signed int terminate;
  // prefix
  char *prefix;
  // print_lock
  union anonymous_2 print_lock;
  // queue_lock
  union anonymous_2 queue_lock;
  // send_lock
  union anonymous_2 send_lock;
  // queue_head
  struct hdhomerun_debug_message_t *queue_head;
  // queue_tail
  struct hdhomerun_debug_message_t *queue_tail;
  // queue_depth
  unsigned int queue_depth;
  // connect_delay
  unsigned long int connect_delay;
  // file_name
  char *file_name;
  // file_fp
  struct _IO_FILE *file_fp;
  // sock
  signed int sock;
};

struct hdhomerun_device_selector_t
{
  // hd_list
  struct hdhomerun_device_t **hd_list;
  // hd_count
  unsigned long int hd_count;
  // dbg
  struct hdhomerun_debug_t *dbg;
};

struct hdhomerun_device_t
{
  // cs
  struct hdhomerun_control_sock_t *cs;
  // vs
  struct hdhomerun_video_sock_t *vs;
  // dbg
  struct hdhomerun_debug_t *dbg;
  // scan
  struct hdhomerun_channelscan_t *scan;
  // multicast_ip
  unsigned int multicast_ip;
  // multicast_port
  unsigned short int multicast_port;
  // device_id
  unsigned int device_id;
  // tuner
  unsigned int tuner;
  // lockkey
  unsigned int lockkey;
  // name
  char name[32l];
  // model
  char model[32l];
};

struct hdhomerun_discover_device_t
{
  // ip_addr
  unsigned int ip_addr;
  // device_type
  unsigned int device_type;
  // device_id
  unsigned int device_id;
  // tuner_count
  unsigned char tuner_count;
  // is_legacy
  signed int is_legacy;
  // device_auth
  char device_auth[25l];
  // base_url
  char base_url[29l];
};

struct hdhomerun_discover_sock_t
{
  // sock
  signed int sock;
  // detected
  signed int detected;
  // local_ip
  unsigned int local_ip;
  // subnet_mask
  unsigned int subnet_mask;
};

struct hdhomerun_discover_t
{
  // socks
  struct hdhomerun_discover_sock_t socks[16l];
  // sock_count
  unsigned int sock_count;
  // tx_pkt
  struct hdhomerun_pkt_t tx_pkt;
  // rx_pkt
  struct hdhomerun_pkt_t rx_pkt;
  // dbg
  struct hdhomerun_debug_t *dbg;
};

struct hdhomerun_local_ip_info_t
{
  // ip_addr
  unsigned int ip_addr;
  // subnet_mask
  unsigned int subnet_mask;
};

struct hdhomerun_plotsample_t
{
  // real
  signed short int real;
  // imag
  signed short int imag;
};

struct hdhomerun_tuner_vstatus_t
{
  // vchannel
  char vchannel[32l];
  // name
  char name[32l];
  // auth
  char auth[32l];
  // cci
  char cci[32l];
  // cgms
  char cgms[32l];
  // not_subscribed
  signed int not_subscribed;
  // not_available
  signed int not_available;
  // copy_protected
  signed int copy_protected;
};

struct hdhomerun_video_sock_t
{
  // lock
  union anonymous_2 lock;
  // dbg
  struct hdhomerun_debug_t *dbg;
  // sock
  signed int sock;
  // head
  volatile unsigned long int head;
  // tail
  volatile unsigned long int tail;
  // buffer
  unsigned char *buffer;
  // buffer_size
  unsigned long int buffer_size;
  // advance
  unsigned long int advance;
  // thread
  unsigned long int thread;
  // terminate
  volatile signed int terminate;
  // packet_count
  volatile unsigned int packet_count;
  // transport_error_count
  volatile unsigned int transport_error_count;
  // network_error_count
  volatile unsigned int network_error_count;
  // sequence_error_count
  volatile unsigned int sequence_error_count;
  // overflow_error_count
  volatile unsigned int overflow_error_count;
  // rtp_sequence
  volatile unsigned int rtp_sequence;
  // sequence
  volatile unsigned char sequence[8192l];
};

struct hdhomerun_video_stats_t
{
  // packet_count
  unsigned int packet_count;
  // network_error_count
  unsigned int network_error_count;
  // transport_error_count
  unsigned int transport_error_count;
  // sequence_error_count
  unsigned int sequence_error_count;
  // overflow_error_count
  unsigned int overflow_error_count;
};

struct ifconf
{
  // ifc_len
  signed int ifc_len;
  // ifc_ifcu
  union anonymous ifc_ifcu;
};

struct ifreq
{
  // ifr_ifrn
  union anonymous_1 ifr_ifrn;
  // ifr_ifru
  union anonymous_0 ifr_ifru;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct ip_mreq
{
  // imr_multiaddr
  struct in_addr imr_multiaddr;
  // imr_interface
  struct in_addr imr_interface;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// appname
// file hdhomerun_config.c line 33
static const char *appname;
// hd
// file hdhomerun_config.c line 35
struct hdhomerun_device_t *hd;
// hdhomerun_channelmap_range_au_bcast
// file hdhomerun_channels.c line 51
static struct hdhomerun_channelmap_range_t hdhomerun_channelmap_range_au_bcast[3l] = { { .channel_range_start=(unsigned short int)5, .channel_range_end=(unsigned short int)12,
    .frequency=(unsigned int)177500000,
    .spacing=(unsigned int)7000000 },
    { .channel_range_start=(unsigned short int)21, .channel_range_end=(unsigned short int)69,
    .frequency=(unsigned int)480500000,
    .spacing=(unsigned int)7000000 },
    { .channel_range_start=(unsigned short int)0, .channel_range_end=(unsigned short int)0,
    .frequency=(unsigned int)0,
    .spacing=(unsigned int)0 } };
// hdhomerun_channelmap_range_eu_bcast
// file hdhomerun_channels.c line 58
static struct hdhomerun_channelmap_range_t hdhomerun_channelmap_range_eu_bcast[3l] = { { .channel_range_start=(unsigned short int)5, .channel_range_end=(unsigned short int)12,
    .frequency=(unsigned int)177500000,
    .spacing=(unsigned int)7000000 },
    { .channel_range_start=(unsigned short int)21, .channel_range_end=(unsigned short int)69,
    .frequency=(unsigned int)474000000,
    .spacing=(unsigned int)8000000 },
    { .channel_range_start=(unsigned short int)0, .channel_range_end=(unsigned short int)0,
    .frequency=(unsigned int)0,
    .spacing=(unsigned int)0 } };
// hdhomerun_channelmap_range_eu_cable
// file hdhomerun_channels.c line 65
static struct hdhomerun_channelmap_range_t hdhomerun_channelmap_range_eu_cable[2l] = { { .channel_range_start=(unsigned short int)108, .channel_range_end=(unsigned short int)862,
    .frequency=(unsigned int)108000000,
    .spacing=(unsigned int)1000000 },
    { .channel_range_start=(unsigned short int)0, .channel_range_end=(unsigned short int)0,
    .frequency=(unsigned int)0,
    .spacing=(unsigned int)0 } };
// hdhomerun_channelmap_range_jp_bcast
// file hdhomerun_channels.c line 81
static struct hdhomerun_channelmap_range_t hdhomerun_channelmap_range_jp_bcast[2l] = { { .channel_range_start=(unsigned short int)13, .channel_range_end=(unsigned short int)62,
    .frequency=(unsigned int)473000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)0, .channel_range_end=(unsigned short int)0,
    .frequency=(unsigned int)0,
    .spacing=(unsigned int)0 } };
// hdhomerun_channelmap_range_kr_cable
// file hdhomerun_channels.c line 71
static struct hdhomerun_channelmap_range_t hdhomerun_channelmap_range_kr_cable[6l] = { { .channel_range_start=(unsigned short int)2, .channel_range_end=(unsigned short int)4,
    .frequency=(unsigned int)57000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)5, .channel_range_end=(unsigned short int)6,
    .frequency=(unsigned int)79000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)7, .channel_range_end=(unsigned short int)13,
    .frequency=(unsigned int)177000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)14, .channel_range_end=(unsigned short int)22,
    .frequency=(unsigned int)123000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)23, .channel_range_end=(unsigned short int)153,
    .frequency=(unsigned int)219000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)0, .channel_range_end=(unsigned short int)0,
    .frequency=(unsigned int)0,
    .spacing=(unsigned int)0 } };
// hdhomerun_channelmap_range_us_bcast
// file hdhomerun_channels.c line 87
static struct hdhomerun_channelmap_range_t hdhomerun_channelmap_range_us_bcast[5l] = { { .channel_range_start=(unsigned short int)2, .channel_range_end=(unsigned short int)4,
    .frequency=(unsigned int)57000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)5, .channel_range_end=(unsigned short int)6,
    .frequency=(unsigned int)79000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)7, .channel_range_end=(unsigned short int)13,
    .frequency=(unsigned int)177000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)14, .channel_range_end=(unsigned short int)69,
    .frequency=(unsigned int)473000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)0, .channel_range_end=(unsigned short int)0,
    .frequency=(unsigned int)0,
    .spacing=(unsigned int)0 } };
// hdhomerun_channelmap_range_us_cable
// file hdhomerun_channels.c line 96
static struct hdhomerun_channelmap_range_t hdhomerun_channelmap_range_us_cable[8l] = { { .channel_range_start=(unsigned short int)2, .channel_range_end=(unsigned short int)4,
    .frequency=(unsigned int)57000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)5, .channel_range_end=(unsigned short int)6,
    .frequency=(unsigned int)79000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)7, .channel_range_end=(unsigned short int)13,
    .frequency=(unsigned int)177000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)14, .channel_range_end=(unsigned short int)22,
    .frequency=(unsigned int)123000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)23, .channel_range_end=(unsigned short int)94,
    .frequency=(unsigned int)219000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)95, .channel_range_end=(unsigned short int)99,
    .frequency=(unsigned int)93000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)100, .channel_range_end=(unsigned short int)158,
    .frequency=(unsigned int)651000000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)0, .channel_range_end=(unsigned short int)0,
    .frequency=(unsigned int)0,
    .spacing=(unsigned int)0 } };
// hdhomerun_channelmap_range_us_hrc
// file hdhomerun_channels.c line 108
static struct hdhomerun_channelmap_range_t hdhomerun_channelmap_range_us_hrc[8l] = { { .channel_range_start=(unsigned short int)2, .channel_range_end=(unsigned short int)4,
    .frequency=(unsigned int)55752700,
    .spacing=(unsigned int)6000300 },
    { .channel_range_start=(unsigned short int)5, .channel_range_end=(unsigned short int)6,
    .frequency=(unsigned int)79753900,
    .spacing=(unsigned int)6000300 },
    { .channel_range_start=(unsigned short int)7, .channel_range_end=(unsigned short int)13,
    .frequency=(unsigned int)175758700,
    .spacing=(unsigned int)6000300 },
    { .channel_range_start=(unsigned short int)14, .channel_range_end=(unsigned short int)22,
    .frequency=(unsigned int)121756000,
    .spacing=(unsigned int)6000300 },
    { .channel_range_start=(unsigned short int)23, .channel_range_end=(unsigned short int)94,
    .frequency=(unsigned int)217760800,
    .spacing=(unsigned int)6000300 },
    { .channel_range_start=(unsigned short int)95, .channel_range_end=(unsigned short int)99,
    .frequency=(unsigned int)91754500,
    .spacing=(unsigned int)6000300 },
    { .channel_range_start=(unsigned short int)100, .channel_range_end=(unsigned short int)158,
    .frequency=(unsigned int)649782400,
    .spacing=(unsigned int)6000300 },
    { .channel_range_start=(unsigned short int)0, .channel_range_end=(unsigned short int)0,
    .frequency=(unsigned int)0,
    .spacing=(unsigned int)0 } };
// hdhomerun_channelmap_range_us_irc
// file hdhomerun_channels.c line 120
static struct hdhomerun_channelmap_range_t hdhomerun_channelmap_range_us_irc[11l] = { { .channel_range_start=(unsigned short int)2, .channel_range_end=(unsigned short int)4,
    .frequency=(unsigned int)57012500,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)5, .channel_range_end=(unsigned short int)6,
    .frequency=(unsigned int)81012500,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)7, .channel_range_end=(unsigned short int)13,
    .frequency=(unsigned int)177012500,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)14, .channel_range_end=(unsigned short int)22,
    .frequency=(unsigned int)123012500,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)23, .channel_range_end=(unsigned short int)41,
    .frequency=(unsigned int)219012500,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)42, .channel_range_end=(unsigned short int)42,
    .frequency=(unsigned int)333025000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)43, .channel_range_end=(unsigned short int)94,
    .frequency=(unsigned int)339012500,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)95, .channel_range_end=(unsigned short int)97,
    .frequency=(unsigned int)93012500,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)98, .channel_range_end=(unsigned short int)99,
    .frequency=(unsigned int)111025000,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)100, .channel_range_end=(unsigned short int)158,
    .frequency=(unsigned int)651012500,
    .spacing=(unsigned int)6000000 },
    { .channel_range_start=(unsigned short int)0, .channel_range_end=(unsigned short int)0,
    .frequency=(unsigned int)0,
    .spacing=(unsigned int)0 } };
// hdhomerun_channelmap_table
// file hdhomerun_channels.c line 134
static struct hdhomerun_channelmap_record_t hdhomerun_channelmap_table[14l];
// hdhomerun_channelmap_table
// file hdhomerun_channels.c line 134
static struct hdhomerun_channelmap_record_t hdhomerun_channelmap_table[14l] = { { .channelmap="au-bcast", .range_list=hdhomerun_channelmap_range_au_bcast, .channelmap_scan_group="au-bcast",
    .countrycodes="AU" },
    { .channelmap="au-cable", .range_list=hdhomerun_channelmap_range_eu_cable, .channelmap_scan_group="au-cable",
    .countrycodes="AU" },
    { .channelmap="eu-bcast", .range_list=hdhomerun_channelmap_range_eu_bcast, .channelmap_scan_group="eu-bcast",
    .countrycodes=(const char *)(void *)0 },
    { .channelmap="eu-cable", .range_list=hdhomerun_channelmap_range_eu_cable, .channelmap_scan_group="eu-cable",
    .countrycodes=(const char *)(void *)0 },
    { .channelmap="tw-bcast", .range_list=hdhomerun_channelmap_range_us_bcast, .channelmap_scan_group="tw-bcast",
    .countrycodes="TW" },
    { .channelmap="tw-cable", .range_list=hdhomerun_channelmap_range_us_cable, .channelmap_scan_group="tw-cable",
    .countrycodes="TW" },
    { .channelmap="kr-bcast", .range_list=hdhomerun_channelmap_range_us_bcast, .channelmap_scan_group="kr-bcast",
    .countrycodes="KR" },
    { .channelmap="kr-cable", .range_list=hdhomerun_channelmap_range_kr_cable, .channelmap_scan_group="kr-cable",
    .countrycodes="KR" },
    { .channelmap="us-bcast", .range_list=hdhomerun_channelmap_range_us_bcast, .channelmap_scan_group="us-bcast",
    .countrycodes=(const char *)(void *)0 },
    { .channelmap="us-cable", .range_list=hdhomerun_channelmap_range_us_cable, .channelmap_scan_group="us-cable us-hrc us-irc",
    .countrycodes=(const char *)(void *)0 },
    { .channelmap="us-hrc", .range_list=hdhomerun_channelmap_range_us_hrc, .channelmap_scan_group="us-cable us-hrc us-irc",
    .countrycodes=(const char *)(void *)0 },
    { .channelmap="us-irc", .range_list=hdhomerun_channelmap_range_us_irc, .channelmap_scan_group="us-cable us-hrc us-irc",
    .countrycodes=(const char *)(void *)0 },
    { .channelmap="jp-bcast", .range_list=hdhomerun_channelmap_range_jp_bcast, .channelmap_scan_group="jp-bcast",
    .countrycodes="JP" },
    { .channelmap=(const char *)(void *)0, .range_list=(struct hdhomerun_channelmap_range_t *)(void *)0, .channelmap_scan_group=(const char *)(void *)0,
    .countrycodes=(const char *)(void *)0 } };
// random_get32_fp
// file hdhomerun_os_posix.c line 29
static struct _IO_FILE *random_get32_fp = (struct _IO_FILE *)(void *)0;
// random_get32_once
// file hdhomerun_os_posix.c line 28
static signed int random_get32_once = 0;
// sigabort_flag
// file hdhomerun_config.c line 193
static volatile signed int sigabort_flag = 0;
// siginfo_flag
// file hdhomerun_config.c line 194
static volatile signed int siginfo_flag = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32_1;
  return_value___builtin_bswap32_1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32_1;
}

// __bswap_32_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link1(unsigned int __bsx_link1)
{
  signed long int return_value___builtin_bswap32_1;
  return_value___builtin_bswap32_1=__builtin_bswap32((signed long int)__bsx_link1);
  return (unsigned int)return_value___builtin_bswap32_1;
}

// __bswap_32_link2
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link2(unsigned int __bsx_link2)
{
  signed long int return_value___builtin_bswap32_1;
  return_value___builtin_bswap32_1=__builtin_bswap32((signed long int)__bsx_link2);
  return (unsigned int)return_value___builtin_bswap32_1;
}

// channelscan_advance
// file hdhomerun_channelscan.c line 224
extern signed int channelscan_advance(struct hdhomerun_channelscan_t *scan, struct hdhomerun_channelscan_result_t *result)
{
  memset((void *)result, 0, sizeof(struct hdhomerun_channelscan_result_t) /*6840ul*/ );
  struct hdhomerun_channel_entry_t *entry = scan->next_channel;
  if(entry == ((struct hdhomerun_channel_entry_t *)NULL))
    return 0;

  else
  {
    result->frequency=hdhomerun_channel_entry_frequency(entry);
    char *ptr = result->channel_str;
    char *end = result->channel_str + (signed long int)sizeof(char [64l]) /*64ul*/ ;
    const char *return_value_hdhomerun_channel_entry_name_1;
    return_value_hdhomerun_channel_entry_name_1=hdhomerun_channel_entry_name(entry);
    hdhomerun_sprintf(ptr, end, return_value_hdhomerun_channel_entry_name_1);
    while((_Bool)1)
    {
      entry=hdhomerun_channel_list_prev(scan->channel_list, entry);
      if(entry == ((struct hdhomerun_channel_entry_t *)NULL))
      {
        scan->next_channel = (struct hdhomerun_channel_entry_t *)(void *)0;
        break;
      }

      unsigned int return_value_hdhomerun_channel_entry_frequency_2;
      return_value_hdhomerun_channel_entry_frequency_2=hdhomerun_channel_entry_frequency(entry);
      if(!(return_value_hdhomerun_channel_entry_frequency_2 == result->frequency))
      {
        scan->next_channel = entry;
        break;
      }

      void *return_value___rawmemchr_3;
      return_value___rawmemchr_3=__rawmemchr((const void *)ptr, 0);
      ptr = (char *)return_value___rawmemchr_3;
      const char *return_value_hdhomerun_channel_entry_name_4;
      return_value_hdhomerun_channel_entry_name_4=hdhomerun_channel_entry_name(entry);
      hdhomerun_sprintf(ptr, end, ", %s", return_value_hdhomerun_channel_entry_name_4);
    }
    return 1;
  }
}

// channelscan_create
// file hdhomerun_channelscan.c line 30
extern struct hdhomerun_channelscan_t * channelscan_create(struct hdhomerun_device_t *hd, const char *channelmap)
{
  struct hdhomerun_channelscan_t *scan;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct hdhomerun_channelscan_t) /*32ul*/ );
  scan = (struct hdhomerun_channelscan_t *)return_value_calloc_1;
  if(scan == ((struct hdhomerun_channelscan_t *)NULL))
    return (struct hdhomerun_channelscan_t *)(void *)0;

  else
  {
    scan->hd = hd;
    scan->channel_list=hdhomerun_channel_list_create(channelmap);
    if(scan->channel_list == ((struct hdhomerun_channel_list_t *)NULL))
    {
      free((void *)scan);
      return (struct hdhomerun_channelscan_t *)(void *)0;
    }

    else
    {
      scan->next_channel=hdhomerun_channel_list_last(scan->channel_list);
      return scan;
    }
  }
}

// channelscan_destroy
// file hdhomerun_channelscan.c line 49
extern void channelscan_destroy(struct hdhomerun_channelscan_t *scan)
{
  hdhomerun_channel_list_destroy(scan->channel_list);
  free((void *)scan);
}

// channelscan_detect
// file hdhomerun_channelscan.c line 259
extern signed int channelscan_detect(struct hdhomerun_channelscan_t *scan, struct hdhomerun_channelscan_result_t *result)
{
  scan->scanned_channels = scan->scanned_channels + 1u;
  signed int ret;
  ret=channelscan_find_lock(scan, result->frequency, result);
  unsigned long int return_value_getcurrenttime_7;
  if(!(ret >= 1))
    return ret;

  else
    if(result->status.lock_supported == 0)
      return 1;

    else
    {
      result->program_count = 0;
      unsigned long int timeout;
      const char *return_value_hdhomerun_device_get_model_str_3;
      return_value_hdhomerun_device_get_model_str_3=hdhomerun_device_get_model_str(scan->hd);
      char *return_value_strstr_4;
      return_value_strstr_4=strstr(return_value_hdhomerun_device_get_model_str_3, "atsc");
      if(!(return_value_strstr_4 == ((char *)NULL)))
      {
        unsigned long int return_value_getcurrenttime_1;
        return_value_getcurrenttime_1=getcurrenttime();
        timeout = return_value_getcurrenttime_1 + (unsigned long int)4000;
      }

      else
      {
        unsigned long int return_value_getcurrenttime_2;
        return_value_getcurrenttime_2=getcurrenttime();
        timeout = return_value_getcurrenttime_2 + (unsigned long int)10000;
      }
      unsigned long int complete_time;
      unsigned long int return_value_getcurrenttime_5;
      return_value_getcurrenttime_5=getcurrenttime();
      complete_time = return_value_getcurrenttime_5 + (unsigned long int)1000;
      while((_Bool)1)
      {
        signed int changed;
        signed int incomplete;
        ret=channelscan_detect_programs(scan, result, &changed, &incomplete);
        if(!(ret >= 1))
          return ret;

        if(!(changed == 0))
        {
          unsigned long int return_value_getcurrenttime_6;
          return_value_getcurrenttime_6=getcurrenttime();
          complete_time = return_value_getcurrenttime_6 + (unsigned long int)1000;
        }

        if(incomplete == 0)
        {
          return_value_getcurrenttime_7=getcurrenttime();
          if(return_value_getcurrenttime_7 >= complete_time)
            break;

        }

        unsigned long int return_value_getcurrenttime_8;
        return_value_getcurrenttime_8=getcurrenttime();
        if(return_value_getcurrenttime_8 >= timeout)
          break;

        msleep_approx((unsigned long int)250);
      }
      unsigned int max_next_frequency = result->frequency - (unsigned int)5500000;
      while((_Bool)1)
      {
        if(scan->next_channel == ((struct hdhomerun_channel_entry_t *)NULL))
          break;

        unsigned int return_value_hdhomerun_channel_entry_frequency_9;
        return_value_hdhomerun_channel_entry_frequency_9=hdhomerun_channel_entry_frequency(scan->next_channel);
        if(max_next_frequency >= return_value_hdhomerun_channel_entry_frequency_9)
          break;

        scan->next_channel=hdhomerun_channel_list_prev(scan->channel_list, scan->next_channel);
      }
      return 1;
    }
}

// channelscan_detect_programs
// file hdhomerun_channelscan.c line 130
static signed int channelscan_detect_programs(struct hdhomerun_channelscan_t *scan, struct hdhomerun_channelscan_result_t *result, signed int *pchanged, signed int *pincomplete)
{
  *pchanged = 0;
  *pincomplete = 0;
  char *streaminfo;
  signed int ret;
  ret=hdhomerun_device_get_tuner_streaminfo(scan->hd, &streaminfo);
  char *tmp_post_2;
  char *return_value_strstr_9;
  char *return_value_strstr_8;
  _Bool tmp_if_expr_7;
  if(!(ret >= 1))
    return ret;

  else
  {
    char *next_line = streaminfo;
    signed int program_count = 0;
    while((_Bool)1)
    {
      char *line = next_line;
      char *return_value___builtin_strchr_1;
      return_value___builtin_strchr_1=__builtin_strchr(line, 10);
      next_line = return_value___builtin_strchr_1;
      if(next_line == ((char *)NULL))
        break;

      tmp_post_2 = next_line;
      next_line = next_line + 1l;
      *tmp_post_2 = (char)0;
      unsigned int transport_stream_id;
      signed int return_value_sscanf_3;
      return_value_sscanf_3=sscanf(line, "tsid=0x%x", &transport_stream_id);
      if(return_value_sscanf_3 == 1)
      {
        result->transport_stream_id = (unsigned short int)transport_stream_id;
        result->transport_stream_id_detected = 1;
      }

      else
      {
        unsigned int original_network_id;
        signed int return_value_sscanf_4;
        return_value_sscanf_4=sscanf(line, "onid=0x%x", &original_network_id);
        if(return_value_sscanf_4 == 1)
        {
          result->original_network_id = (unsigned short int)original_network_id;
          result->original_network_id_detected = 1;
        }

        else
          if(!(program_count >= 64))
          {
            struct hdhomerun_channelscan_program_t program;
            memset((void *)&program, 0, sizeof(struct hdhomerun_channelscan_program_t) /*104ul*/ );
            hdhomerun_sprintf(program.program_str, program.program_str + (signed long int)sizeof(char [64l]) /*64ul*/ , "%s", line);
            unsigned int program_number;
            unsigned int virtual_major;
            unsigned int virtual_minor;
            signed int return_value_sscanf_6;
            return_value_sscanf_6=sscanf(line, "%u: %u.%u", &program_number, &virtual_major, &virtual_minor);
            if(!(return_value_sscanf_6 == 3))
            {
              signed int return_value_sscanf_5;
              return_value_sscanf_5=sscanf(line, "%u: %u", &program_number, &virtual_major);
              if(!(return_value_sscanf_5 == 2))
                continue;

              virtual_minor = (unsigned int)0;
            }

            program.program_number = (unsigned short int)program_number;
            program.virtual_major = (unsigned short int)virtual_major;
            program.virtual_minor = (unsigned short int)virtual_minor;
            channelscan_extract_name(&program, line);
            char *return_value_strstr_10;
            return_value_strstr_10=strstr(line, "(control)");
            if(!(return_value_strstr_10 == ((char *)NULL)))
              program.type = (unsigned short int)2;

            else
            {
              return_value_strstr_9=strstr(line, "(encrypted)");
              if(!(return_value_strstr_9 == ((char *)NULL)))
                program.type = (unsigned short int)3;

              else
              {
                return_value_strstr_8=strstr(line, "(no data)");
                if(!(return_value_strstr_8 == ((char *)NULL)))
                {
                  program.type = (unsigned short int)1;
                  *pincomplete = 1;
                }

                else
                {
                  program.type = (unsigned short int)0;
                  if((signed int)program.virtual_major == 0)
                    tmp_if_expr_7 = (_Bool)1;

                  else
                    tmp_if_expr_7 = (signed int)program.name[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_7)
                    *pincomplete = 1;

                }
              }
            }
            signed int return_value_memcmp_11;
            return_value_memcmp_11=memcmp((const void *)&result->programs[(signed long int)program_count], (const void *)&program, sizeof(struct hdhomerun_channelscan_program_t) /*104ul*/ );
            if(!(return_value_memcmp_11 == 0))
            {
              memcpy((void *)&result->programs[(signed long int)program_count], (const void *)&program, sizeof(struct hdhomerun_channelscan_program_t) /*104ul*/ );
              *pchanged = 1;
            }

            program_count = program_count + 1;
          }

      }
    }
    if(program_count == 0)
      *pincomplete = 1;

    if(!(result->program_count == program_count))
    {
      result->program_count = program_count;
      *pchanged = 1;
    }

    return 1;
  }
}

// channelscan_extract_name
// file hdhomerun_channelscan.c line 95
static void channelscan_extract_name(struct hdhomerun_channelscan_program_t *program, const char *line)
{
  const char *start;
  char *return_value___builtin_strchr_1;
  return_value___builtin_strchr_1=__builtin_strchr(line, 32);
  start = return_value___builtin_strchr_1;
  if(!(start == ((const char *)NULL)))
  {
    start = start + 1l;
    char *return_value___builtin_strchr_2;
    return_value___builtin_strchr_2=__builtin_strchr(start, 32);
    start = return_value___builtin_strchr_2;
    if(!(start == ((const char *)NULL)))
    {
      start = start + 1l;
      const char *end;
      end=strstr(start, " (");
      if(end == ((const char *)NULL))
      {
        void *return_value___rawmemchr_3;
        return_value___rawmemchr_3=__rawmemchr((const void *)line, 0);
        end = (char *)return_value___rawmemchr_3;
      }

      if(!(start >= end))
      {
        unsigned long int length = (unsigned long int)(end - start);
        if(length >= 32ul)
          length = sizeof(char [32l]) /*32ul*/  - (unsigned long int)1;

        __builtin_strncpy(program->name, start, length);
        program->name[(signed long int)length] = (char)0;
      }

    }

  }

}

// channelscan_find_lock
// file hdhomerun_channelscan.c line 55
static signed int channelscan_find_lock(struct hdhomerun_channelscan_t *scan, unsigned int frequency, struct hdhomerun_channelscan_result_t *result)
{
  char channel_str[64l];
  hdhomerun_sprintf(channel_str, channel_str + (signed long int)sizeof(char [64l]) /*64ul*/ , "auto:%u", (unsigned int)frequency);
  signed int ret;
  ret=hdhomerun_device_set_tuner_channel(scan->hd, channel_str);
  if(!(ret >= 1))
    return ret;

  else
  {
    ret=hdhomerun_device_wait_for_lock(scan->hd, &result->status);
    if(!(ret >= 1))
      return ret;

    else
      if(result->status.lock_supported == 0)
        return 1;

      else
      {
        unsigned long int timeout;
        unsigned long int return_value_getcurrenttime_1;
        return_value_getcurrenttime_1=getcurrenttime();
        timeout = return_value_getcurrenttime_1 + (unsigned long int)5000;
        while((_Bool)1)
        {
          ret=hdhomerun_device_get_tuner_status(scan->hd, (char **)(void *)0, &result->status);
          if(!(ret >= 1))
            return ret;

          if(result->status.symbol_error_quality == 100u)
            return 1;

          unsigned long int return_value_getcurrenttime_2;
          return_value_getcurrenttime_2=getcurrenttime();
          if(return_value_getcurrenttime_2 >= timeout)
            return 1;

          msleep_approx((unsigned long int)250);
        }
      }
  }
}

// channelscan_get_progress
// file hdhomerun_channelscan.c line 324
extern unsigned char channelscan_get_progress(struct hdhomerun_channelscan_t *scan)
{
  struct hdhomerun_channel_entry_t *entry = scan->next_channel;
  if(entry == ((struct hdhomerun_channel_entry_t *)NULL))
    return (unsigned char)100;

  else
  {
    unsigned int channels_remaining = (unsigned int)1;
    unsigned int frequency;
    frequency=hdhomerun_channel_entry_frequency(entry);
    while((_Bool)1)
    {
      entry=hdhomerun_channel_list_prev(scan->channel_list, entry);
      if(entry == ((struct hdhomerun_channel_entry_t *)NULL))
        break;

      unsigned int return_value_hdhomerun_channel_entry_frequency_1;
      return_value_hdhomerun_channel_entry_frequency_1=hdhomerun_channel_entry_frequency(entry);
      if(!(return_value_hdhomerun_channel_entry_frequency_1 == frequency))
      {
        channels_remaining = channels_remaining + 1u;
        frequency=hdhomerun_channel_entry_frequency(entry);
      }

    }
    return (unsigned char)((scan->scanned_channels * (unsigned int)100) / (scan->scanned_channels + channels_remaining));
  }
}

// cmd_execute
// file hdhomerun_config.c line 502
static signed int cmd_execute(void)
{
  char *ret_value;
  char *ret_error;
  signed int return_value_hdhomerun_device_get_var_1;
  return_value_hdhomerun_device_get_var_1=hdhomerun_device_get_var(hd, "/sys/boot", &ret_value, &ret_error);
  if(!(return_value_hdhomerun_device_get_var_1 >= 0))
  {
    fprintf(stderr, "communication error sending request to hdhomerun device\n");
    return -1;
  }

  else
    if(!(ret_error == ((char *)NULL)))
    {
      printf("%s\n", ret_error);
      return 0;
    }

    else
    {
      char *end;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(ret_value);
      end = ret_value + (signed long int)return_value_strlen_2;
      char *pos = ret_value;
      while((_Bool)1)
      {
        if(pos >= end)
          break;

        char *eol_r;
        char *return_value___builtin_strchr_3;
        return_value___builtin_strchr_3=__builtin_strchr(pos, 13);
        eol_r = return_value___builtin_strchr_3;
        if(eol_r == ((char *)NULL))
          eol_r = end;

        char *eol_n;
        char *return_value___builtin_strchr_4;
        return_value___builtin_strchr_4=__builtin_strchr(pos, 10);
        eol_n = return_value___builtin_strchr_4;
        if(eol_n == ((char *)NULL))
          eol_n = end;

        char *eol = eol_r;
        if(!(eol_n >= eol))
          eol = eol_n;

        char *sep;
        char *return_value___builtin_strchr_5;
        return_value___builtin_strchr_5=__builtin_strchr(pos, 32);
        sep = return_value___builtin_strchr_5;
        if(sep == ((char *)NULL) || !(eol >= sep))
          pos = eol + (signed long int)1;

        else
        {
          *sep = (char)0;
          *eol = (char)0;
          char *item = pos;
          char *value = sep + (signed long int)1;
          printf("set %s \"%s\"\n", item, value);
          cmd_set_internal(item, value);
          pos = eol + (signed long int)1;
        }
      }
      return 1;
    }
}

// cmd_get
// file hdhomerun_config.c line 127
static signed int cmd_get(const char *item)
{
  char *ret_value;
  char *ret_error;
  signed int return_value_hdhomerun_device_get_var_1;
  return_value_hdhomerun_device_get_var_1=hdhomerun_device_get_var(hd, item, &ret_value, &ret_error);
  if(!(return_value_hdhomerun_device_get_var_1 >= 0))
  {
    fprintf(stderr, "communication error sending request to hdhomerun device\n");
    return -1;
  }

  else
    if(!(ret_error == ((char *)NULL)))
    {
      printf("%s\n", ret_error);
      return 0;
    }

    else
    {
      printf("%s\n", ret_value);
      return 1;
    }
}

// cmd_save
// file hdhomerun_config.c line 350
static signed int cmd_save(const char *tuner_str, const char *filename)
{
  signed int return_value_hdhomerun_device_set_tuner_from_str_1;
  return_value_hdhomerun_device_set_tuner_from_str_1=hdhomerun_device_set_tuner_from_str(hd, tuner_str);
  signed int tmp_statement_expression_4;
  signed int tmp_statement_expression_2;
  if(!(return_value_hdhomerun_device_set_tuner_from_str_1 >= 1))
  {
    fprintf(stderr, "invalid tuner number\n");
    return -1;
  }

  else
  {
    struct _IO_FILE *fp;
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_5;
    return_value___builtin_strcmp_5=__builtin_strcmp(filename, "null");
    tmp_statement_expression_4 = return_value___builtin_strcmp_5;
    if(tmp_statement_expression_4 == 0)
      fp = (struct _IO_FILE *)(void *)0;

    else
    {
      unsigned long int cmd_save__1__4____s1_len;
      unsigned long int cmd_save__1__4____s2_len;
      signed int return_value___builtin_strcmp_3;
      return_value___builtin_strcmp_3=__builtin_strcmp(filename, "-");
      tmp_statement_expression_2 = return_value___builtin_strcmp_3;
      if(tmp_statement_expression_2 == 0)
        fp = stdout;

      else
      {
        fp=fopen(filename, "wb");
        if(fp == ((struct _IO_FILE *)NULL))
        {
          fprintf(stderr, "unable to create file %s\n", filename);
          return -1;
        }

      }
    }
    signed int ret;
    ret=hdhomerun_device_stream_start(hd);
    if(!(ret >= 1))
    {
      fprintf(stderr, "unable to start stream\n");
      if(!(fp == ((struct _IO_FILE *)NULL)) && !(fp == stdout))
        fclose(fp);

      return ret;
    }

    else
    {
      register_signal_handlers(sigabort_handler, sigabort_handler, siginfo_handler);
      struct hdhomerun_video_stats_t stats_old;
      struct hdhomerun_video_stats_t stats_cur;
      hdhomerun_device_get_video_stats(hd, &stats_old);
      unsigned long int next_progress;
      unsigned long int return_value_getcurrenttime_6;
      return_value_getcurrenttime_6=getcurrenttime();
      next_progress = return_value_getcurrenttime_6 + (unsigned long int)1000;
      while(sigabort_flag == 0)
      {
        unsigned long int loop_start_time;
        loop_start_time=getcurrenttime();
        if(!(siginfo_flag == 0))
        {
          fprintf(stderr, "\n");
          cmd_save_print_stats();
          siginfo_flag = 0;
        }

        unsigned long int actual_size;
        unsigned char *ptr;
        ptr=hdhomerun_device_stream_recv(hd, (unsigned long int)(20000000 / 8), &actual_size);
        if(ptr == ((unsigned char *)NULL))
          msleep_approx((unsigned long int)64);

        else
        {
          if(!(fp == ((struct _IO_FILE *)NULL)))
          {
            unsigned long int return_value_fwrite_7;
            return_value_fwrite_7=fwrite((const void *)ptr, (unsigned long int)1, actual_size, fp);
            if(!(return_value_fwrite_7 == actual_size))
            {
              fprintf(stderr, "error writing output\n");
              return -1;
            }

          }

          if(loop_start_time >= next_progress)
          {
            next_progress = next_progress + (unsigned long int)1000;
            if(loop_start_time >= next_progress)
              next_progress = loop_start_time + (unsigned long int)1000;

            hdhomerun_device_get_video_stats(hd, &stats_cur);
            if(!(stats_old.overflow_error_count >= stats_cur.overflow_error_count))
              fprintf(stderr, "o");

            else
              if(!(stats_old.network_error_count >= stats_cur.network_error_count))
                fprintf(stderr, "n");

              else
                if(!(stats_old.transport_error_count >= stats_cur.transport_error_count))
                  fprintf(stderr, "t");

                else
                  if(!(stats_old.sequence_error_count >= stats_cur.sequence_error_count))
                    fprintf(stderr, "s");

                  else
                    fprintf(stderr, ".");
            stats_old = stats_cur;
            fflush(stderr);
          }

          signed int delay;
          unsigned long int return_value_getcurrenttime_8;
          return_value_getcurrenttime_8=getcurrenttime();
          delay = 64 - (signed int)(return_value_getcurrenttime_8 - loop_start_time);
          if(delay >= 1)
            msleep_approx((unsigned long int)delay);

        }
      }
      if(!(fp == ((struct _IO_FILE *)NULL)))
        fclose(fp);

      hdhomerun_device_stream_stop(hd);
      fprintf(stderr, "\n");
      fprintf(stderr, "-- Video statistics --\n");
      cmd_save_print_stats();
      return 0;
    }
  }
}

// cmd_save_print_stats
// file hdhomerun_config.c line 336
static void cmd_save_print_stats(void)
{
  struct hdhomerun_video_stats_t stats;
  hdhomerun_device_get_video_stats(hd, &stats);
  fprintf(stderr, "%u packets received, %u overflow errors, %u network errors, %u transport errors, %u sequence errors\n", (unsigned int)stats.packet_count, (unsigned int)stats.overflow_error_count, (unsigned int)stats.network_error_count, (unsigned int)stats.transport_error_count, (unsigned int)stats.sequence_error_count);
}

// cmd_scan
// file hdhomerun_config.c line 240
static signed int cmd_scan(const char *tuner_str, const char *filename)
{
  signed int return_value_hdhomerun_device_set_tuner_from_str_1;
  return_value_hdhomerun_device_set_tuner_from_str_1=hdhomerun_device_set_tuner_from_str(hd, tuner_str);
  if(!(return_value_hdhomerun_device_set_tuner_from_str_1 >= 1))
  {
    fprintf(stderr, "invalid tuner number\n");
    return -1;
  }

  else
  {
    char *ret_error;
    signed int return_value_hdhomerun_device_tuner_lockkey_request_2;
    return_value_hdhomerun_device_tuner_lockkey_request_2=hdhomerun_device_tuner_lockkey_request(hd, &ret_error);
    if(!(return_value_hdhomerun_device_tuner_lockkey_request_2 >= 1))
    {
      fprintf(stderr, "failed to lock tuner\n");
      if(!(ret_error == ((char *)NULL)))
        fprintf(stderr, "%s\n", ret_error);

      return -1;
    }

    else
    {
      hdhomerun_device_set_tuner_target(hd, "none");
      char *channelmap;
      signed int return_value_hdhomerun_device_get_tuner_channelmap_3;
      return_value_hdhomerun_device_get_tuner_channelmap_3=hdhomerun_device_get_tuner_channelmap(hd, &channelmap);
      if(!(return_value_hdhomerun_device_get_tuner_channelmap_3 >= 1))
      {
        fprintf(stderr, "failed to query channelmap from device\n");
        return -1;
      }

      else
      {
        const char *channelmap_scan_group;
        channelmap_scan_group=hdhomerun_channelmap_get_channelmap_scan_group(channelmap);
        if(channelmap_scan_group == ((const char *)NULL))
        {
          fprintf(stderr, "unknown channelmap '%s'\n", channelmap);
          return -1;
        }

        else
        {
          signed int return_value_hdhomerun_device_channelscan_init_4;
          return_value_hdhomerun_device_channelscan_init_4=hdhomerun_device_channelscan_init(hd, channelmap_scan_group);
          if(!(return_value_hdhomerun_device_channelscan_init_4 >= 1))
          {
            fprintf(stderr, "failed to initialize channel scan\n");
            return -1;
          }

          else
          {
            struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
            if(!(filename == ((const char *)NULL)))
            {
              fp=fopen(filename, "w");
              if(!(fp == ((struct _IO_FILE *)NULL)))
                goto __CPROVER_DUMP_L7;

              fprintf(stderr, "unable to create file: %s\n", filename);
              return -1;
            }

            else
            {

            __CPROVER_DUMP_L7:
              ;
              register_signal_handlers(sigabort_handler, sigabort_handler, siginfo_handler);
              signed int ret = 0;
              while(sigabort_flag == 0)
              {
                struct hdhomerun_channelscan_result_t result;
                ret=hdhomerun_device_channelscan_advance(hd, &result);
                if(!(ret >= 1))
                  break;

                cmd_scan_printf(fp, "SCANNING: %u (%s)\n", (unsigned int)result.frequency, (const void *)result.channel_str);
                ret=hdhomerun_device_channelscan_detect(hd, &result);
                if(!(ret >= 0))
                  break;

                if(!(ret == 0))
                {
                  cmd_scan_printf(fp, "LOCK: %s (ss=%u snq=%u seq=%u)\n", (const void *)result.status.lock_str, result.status.signal_strength, result.status.signal_to_noise_quality, result.status.symbol_error_quality);
                  if(!(result.transport_stream_id_detected == 0))
                    cmd_scan_printf(fp, "TSID: 0x%04X\n", result.transport_stream_id);

                  if(!(result.original_network_id_detected == 0))
                    cmd_scan_printf(fp, "ONID: 0x%04X\n", result.original_network_id);

                  signed int i = 0;
                  for( ; !(i >= result.program_count); i = i + 1)
                  {
                    struct hdhomerun_channelscan_program_t *program = &result.programs[(signed long int)i];
                    cmd_scan_printf(fp, "PROGRAM %s\n", (const void *)program->program_str);
                  }
                }

              }
              hdhomerun_device_tuner_lockkey_release(hd);
              if(!(fp == ((struct _IO_FILE *)NULL)))
                fclose(fp);

              if(!(ret >= 0))
                fprintf(stderr, "communication error sending request to hdhomerun device\n");

              return ret;
            }
          }
        }
      }
    }
  }
}

// cmd_scan_printf
// file hdhomerun_config.c line 219
static void cmd_scan_printf(struct _IO_FILE *fp, const char *fmt, ...)
{
  void **ap = (void **)&fmt;
  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    void **apc = (void **)ap;
    vfprintf(fp, fmt, apc);
    fflush(fp);
    apc = ((void **)NULL);
  }

  vprintf(fmt, ap);
  fflush(stdout);
  ap = ((void **)NULL);
}

// cmd_set
// file hdhomerun_config.c line 161
static signed int cmd_set(const char *item, const char *value)
{
  signed int tmp_statement_expression_2;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp_3;
  return_value___builtin_strcmp_3=__builtin_strcmp(value, "-");
  tmp_statement_expression_2 = return_value___builtin_strcmp_3;
  if(tmp_statement_expression_2 == 0)
  {
    char *buffer = (char *)(void *)0;
    unsigned long int pos = (unsigned long int)0;
    while((_Bool)1)
    {
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)buffer, pos + (unsigned long int)1024);
      buffer = (char *)return_value_realloc_1;
      if(buffer == ((char *)NULL))
      {
        fprintf(stderr, "out of memory\n");
        return -1;
      }

      unsigned long int size;
      size=fread((void *)(buffer + (signed long int)pos), (unsigned long int)1, (unsigned long int)1024, stdin);
      pos = pos + size;
      if(!(size >= 1024ul))
        break;

    }
    buffer[(signed long int)pos] = (char)0;
    signed int ret;
    ret=cmd_set_internal(item, buffer);
    free((void *)buffer);
    return ret;
  }

  signed int return_value_cmd_set_internal_4;
  return_value_cmd_set_internal_4=cmd_set_internal(item, value);
  return return_value_cmd_set_internal_4;
}

// cmd_set_internal
// file hdhomerun_config.c line 145
static signed int cmd_set_internal(const char *item, const char *value)
{
  char *ret_error;
  signed int return_value_hdhomerun_device_set_var_1;
  return_value_hdhomerun_device_set_var_1=hdhomerun_device_set_var(hd, item, value, (char **)(void *)0, &ret_error);
  if(!(return_value_hdhomerun_device_set_var_1 >= 0))
  {
    fprintf(stderr, "communication error sending request to hdhomerun device\n");
    return -1;
  }

  else
    if(!(ret_error == ((char *)NULL)))
    {
      printf("%s\n", ret_error);
      return 0;
    }

    else
      return 1;
}

// cmd_upgrade
// file hdhomerun_config.c line 460
static signed int cmd_upgrade(const char *filename)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "rb");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    fprintf(stderr, "unable to open file %s\n", filename);
    return -1;
  }

  else
  {
    printf("uploading firmware...\n");
    signed int return_value_hdhomerun_device_upgrade_1;
    return_value_hdhomerun_device_upgrade_1=hdhomerun_device_upgrade(hd, fp);
    if(!(return_value_hdhomerun_device_upgrade_1 >= 1))
    {
      fprintf(stderr, "error sending upgrade file to hdhomerun device\n");
      fclose(fp);
      return -1;
    }

    else
    {
      fclose(fp);
      msleep_minimum((unsigned long int)2000);
      printf("upgrading firmware...\n");
      msleep_minimum((unsigned long int)8000);
      printf("rebooting...\n");
      signed int count = 0;
      char *version_str;
      while((_Bool)1)
      {
        signed int return_value_hdhomerun_device_get_version_2;
        return_value_hdhomerun_device_get_version_2=hdhomerun_device_get_version(hd, &version_str, (unsigned int *)(void *)0);
        if(return_value_hdhomerun_device_get_version_2 >= 0)
          break;

        count = count + 1;
        if(count >= 31)
        {
          fprintf(stderr, "error finding device after firmware upgrade\n");
          return -1;
        }

        msleep_minimum((unsigned long int)1000);
      }
      printf("upgrade complete - now running firmware %s\n", version_str);
      return 0;
    }
  }
}

// contains
// file hdhomerun_config.c line 63
static signed int contains(const char *arg, const char *cmpstr)
{
  signed int tmp_statement_expression_1;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp_2;
  return_value___builtin_strcmp_2=__builtin_strcmp(arg, cmpstr);
  tmp_statement_expression_1 = return_value___builtin_strcmp_2;
  const char *tmp_post_3;
  const char *tmp_post_4;
  signed int tmp_statement_expression_5;
  if(tmp_statement_expression_1 == 0)
    return 1;

  else
  {
    tmp_post_3 = arg;
    arg = arg + 1l;
    if(!((signed int)*tmp_post_3 == 45))
      return 0;

    else
    {
      tmp_post_4 = arg;
      arg = arg + 1l;
      if(!((signed int)*tmp_post_4 == 45))
        return 0;

      else
      {
        unsigned long int contains__1__5____s1_len;
        unsigned long int contains__1__5____s2_len;
        signed int return_value___builtin_strcmp_6;
        return_value___builtin_strcmp_6=__builtin_strcmp(arg, cmpstr);
        tmp_statement_expression_5 = return_value___builtin_strcmp_6;
        if(tmp_statement_expression_5 == 0)
          return 1;

        else
          return 0;
      }
    }
  }
}

// discover_print
// file hdhomerun_config.c line 92
static signed int discover_print(char *target_ip_str)
{
  unsigned int target_ip = (unsigned int)0;
  if(!(target_ip_str == ((char *)NULL)))
  {
    target_ip=parse_ip_addr(target_ip_str);
    if(!(target_ip == 0u))
      goto __CPROVER_DUMP_L1;

    fprintf(stderr, "invalid ip address: %s\n", target_ip_str);
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    struct hdhomerun_discover_device_t result_list[64l];
    signed int count;
    count=hdhomerun_discover_find_devices_custom_v2(target_ip, (unsigned int)0x00000001, 0xFFFFFFFF, result_list, 64);
    if(!(count >= 0))
    {
      fprintf(stderr, "error sending discover request\n");
      return -1;
    }

    else
      if(count == 0)
      {
        printf("no devices found\n");
        return 0;
      }

      else
      {
        signed int index = 0;
        for( ; !(index >= count); index = index + 1)
        {
          struct hdhomerun_discover_device_t *result = &result_list[(signed long int)index];
          printf("hdhomerun device %08X found at %u.%u.%u.%u\n", (unsigned int)result->device_id, (unsigned int)(result->ip_addr >> 24) & (unsigned int)0x0FF, (unsigned int)(result->ip_addr >> 16) & (unsigned int)0x0FF, (unsigned int)(result->ip_addr >> 8) & (unsigned int)0x0FF, (unsigned int)(result->ip_addr >> 0) & (unsigned int)0x0FF);
        }
        return count;
      }
  }
}

// extract_appname
// file hdhomerun_config.c line 50
static void extract_appname(const char *argv0)
{
  const char *ptr;
  ptr=strrchr(argv0, 47);
  if(!(ptr == ((const char *)NULL)))
    argv0 = ptr + (signed long int)1;

  ptr=strrchr(argv0, 92);
  if(!(ptr == ((const char *)NULL)))
    argv0 = ptr + (signed long int)1;

  appname = argv0;
}

// getcurrenttime
// file hdhomerun_os_posix.h line 54
extern unsigned long int getcurrenttime(void)
{
  struct timespec t;
  clock_gettime(1, &t);
  return (unsigned long int)t.tv_sec * (unsigned long int)1000 + (unsigned long int)(t.tv_nsec / (signed long int)1000000);
}

// hdhomerun_channel_entry_channel_number
// file hdhomerun_channels.c line 204
extern unsigned short int hdhomerun_channel_entry_channel_number(struct hdhomerun_channel_entry_t *entry)
{
  return entry->channel_number;
}

// hdhomerun_channel_entry_frequency
// file hdhomerun_channels.c line 209
extern unsigned int hdhomerun_channel_entry_frequency(struct hdhomerun_channel_entry_t *entry)
{
  return entry->frequency;
}

// hdhomerun_channel_entry_name
// file hdhomerun_channels.c line 214
extern const char * hdhomerun_channel_entry_name(struct hdhomerun_channel_entry_t *entry)
{
  return entry->name;
}

// hdhomerun_channel_frequency_round
// file hdhomerun_channels.c line 270
extern unsigned int hdhomerun_channel_frequency_round(unsigned int frequency, unsigned int resolution)
{
  frequency = frequency + resolution / (unsigned int)2;
  return (frequency / resolution) * resolution;
}

// hdhomerun_channel_frequency_round_normal
// file hdhomerun_channels.c line 276
extern unsigned int hdhomerun_channel_frequency_round_normal(unsigned int frequency)
{
  unsigned int return_value_hdhomerun_channel_frequency_round_1;
  return_value_hdhomerun_channel_frequency_round_1=hdhomerun_channel_frequency_round(frequency, (unsigned int)125000);
  return return_value_hdhomerun_channel_frequency_round_1;
}

// hdhomerun_channel_frequency_to_number
// file hdhomerun_channels.c line 295
extern unsigned short int hdhomerun_channel_frequency_to_number(struct hdhomerun_channel_list_t *channel_list, unsigned int frequency)
{
  frequency=hdhomerun_channel_frequency_round_normal(frequency);
  struct hdhomerun_channel_entry_t *entry;
  entry=hdhomerun_channel_list_first(channel_list);
  while(!(entry == ((struct hdhomerun_channel_entry_t *)NULL)))
  {
    if(entry->frequency == frequency)
      return entry->channel_number;

    if(!(frequency >= entry->frequency))
      return (unsigned short int)0;

    entry=hdhomerun_channel_list_next(channel_list, entry);
  }
  return (unsigned short int)0;
}

// hdhomerun_channel_list_build_insert
// file hdhomerun_channels.c line 314
static void hdhomerun_channel_list_build_insert(struct hdhomerun_channel_list_t *channel_list, struct hdhomerun_channel_entry_t *entry)
{
  struct hdhomerun_channel_entry_t *prev = (struct hdhomerun_channel_entry_t *)(void *)0;
  struct hdhomerun_channel_entry_t *next = channel_list->head;
  for( ; !(next == ((struct hdhomerun_channel_entry_t *)NULL)); next = next->next)
  {
    if(!(entry->frequency >= next->frequency))
      break;

    prev = next;
  }
  entry->prev = prev;
  entry->next = next;
  if(!(prev == ((struct hdhomerun_channel_entry_t *)NULL)))
    prev->next = entry;

  else
    channel_list->head = entry;
  if(!(next == ((struct hdhomerun_channel_entry_t *)NULL)))
    next->prev = entry;

  else
    channel_list->tail = entry;
}

// hdhomerun_channel_list_build_range
// file hdhomerun_channels.c line 344
static void hdhomerun_channel_list_build_range(struct hdhomerun_channel_list_t *channel_list, const char *channelmap, struct hdhomerun_channelmap_range_t *range)
{
  unsigned short int channel_number = range->channel_range_start;
  for( ; (signed int)range->channel_range_end >= (signed int)channel_number; channel_number = channel_number + 1)
  {
    struct hdhomerun_channel_entry_t *entry;
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct hdhomerun_channel_entry_t) /*40ul*/ );
    entry = (struct hdhomerun_channel_entry_t *)return_value_calloc_1;
    if(entry == ((struct hdhomerun_channel_entry_t *)NULL))
      goto __CPROVER_DUMP_L4;

    entry->channel_number = channel_number;
    entry->frequency = range->frequency + (unsigned int)((signed int)channel_number - (signed int)range->channel_range_start) * range->spacing;
    entry->frequency=hdhomerun_channel_frequency_round_normal(entry->frequency);
    hdhomerun_sprintf(entry->name, entry->name + (signed long int)sizeof(char [16l]) /*16ul*/ , "%s:%u", channelmap, entry->channel_number);
    hdhomerun_channel_list_build_insert(channel_list, entry);
  }

__CPROVER_DUMP_L4:
  ;
}

// hdhomerun_channel_list_build_ranges
// file hdhomerun_channels.c line 362
static void hdhomerun_channel_list_build_ranges(struct hdhomerun_channel_list_t *channel_list, struct hdhomerun_channelmap_record_t *record)
{
  struct hdhomerun_channelmap_range_t *range = record->range_list;
  for( ; !(range->frequency == 0u); range = range + 1l)
    hdhomerun_channel_list_build_range(channel_list, record->channelmap, range);
}

// hdhomerun_channel_list_create
// file hdhomerun_channels.c line 382
extern struct hdhomerun_channel_list_t * hdhomerun_channel_list_create(const char *channelmap)
{
  struct hdhomerun_channel_list_t *channel_list;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct hdhomerun_channel_list_t) /*16ul*/ );
  channel_list = (struct hdhomerun_channel_list_t *)return_value_calloc_1;
  if(channel_list == ((struct hdhomerun_channel_list_t *)NULL))
    return (struct hdhomerun_channel_list_t *)(void *)0;

  else
  {
    struct hdhomerun_channelmap_record_t *record = hdhomerun_channelmap_table;
    while(!(record->channelmap == ((const char *)NULL)))
    {
      char *return_value_strstr_2;
      return_value_strstr_2=strstr(channelmap, record->channelmap);
      if(return_value_strstr_2 == ((char *)NULL))
        record = record + 1l;

      else
      {
        hdhomerun_channel_list_build_ranges(channel_list, record);
        record = record + 1l;
      }
    }
    if(channel_list->head == ((struct hdhomerun_channel_entry_t *)NULL))
    {
      free((void *)channel_list);
      return (struct hdhomerun_channel_list_t *)(void *)0;
    }

    else
      return channel_list;
  }
}

// hdhomerun_channel_list_destroy
// file hdhomerun_channels.c line 371
extern void hdhomerun_channel_list_destroy(struct hdhomerun_channel_list_t *channel_list)
{
  while(!(channel_list->head == ((struct hdhomerun_channel_entry_t *)NULL)))
  {
    struct hdhomerun_channel_entry_t *entry = channel_list->head;
    channel_list->head = entry->next;
    free((void *)entry);
  }
  free((void *)channel_list);
}

// hdhomerun_channel_list_first
// file hdhomerun_channels.c line 219
extern struct hdhomerun_channel_entry_t * hdhomerun_channel_list_first(struct hdhomerun_channel_list_t *channel_list)
{
  return channel_list->head;
}

// hdhomerun_channel_list_frequency_count
// file hdhomerun_channels.c line 252
extern unsigned int hdhomerun_channel_list_frequency_count(struct hdhomerun_channel_list_t *channel_list)
{
  unsigned int count = (unsigned int)0;
  unsigned int last_frequency = (unsigned int)0;
  struct hdhomerun_channel_entry_t *entry;
  entry=hdhomerun_channel_list_first(channel_list);
  while(!(entry == ((struct hdhomerun_channel_entry_t *)NULL)))
  {
    if(!(entry->frequency == last_frequency))
    {
      last_frequency = entry->frequency;
      count = count + 1u;
    }

    entry=hdhomerun_channel_list_next(channel_list, entry);
  }
  return count;
}

// hdhomerun_channel_list_last
// file hdhomerun_channels.c line 224
extern struct hdhomerun_channel_entry_t * hdhomerun_channel_list_last(struct hdhomerun_channel_list_t *channel_list)
{
  return channel_list->tail;
}

// hdhomerun_channel_list_next
// file hdhomerun_channels.c line 229
extern struct hdhomerun_channel_entry_t * hdhomerun_channel_list_next(struct hdhomerun_channel_list_t *channel_list, struct hdhomerun_channel_entry_t *entry)
{
  return entry->next;
}

// hdhomerun_channel_list_prev
// file hdhomerun_channels.c line 234
extern struct hdhomerun_channel_entry_t * hdhomerun_channel_list_prev(struct hdhomerun_channel_list_t *channel_list, struct hdhomerun_channel_entry_t *entry)
{
  return entry->prev;
}

// hdhomerun_channel_list_total_count
// file hdhomerun_channels.c line 239
extern unsigned int hdhomerun_channel_list_total_count(struct hdhomerun_channel_list_t *channel_list)
{
  unsigned int count = (unsigned int)0;
  struct hdhomerun_channel_entry_t *entry;
  entry=hdhomerun_channel_list_first(channel_list);
  while(!(entry == ((struct hdhomerun_channel_entry_t *)NULL)))
  {
    count = count + 1u;
    entry=hdhomerun_channel_list_next(channel_list, entry);
  }
  return count;
}

// hdhomerun_channel_number_to_frequency
// file hdhomerun_channels.c line 281
extern unsigned int hdhomerun_channel_number_to_frequency(struct hdhomerun_channel_list_t *channel_list, unsigned short int channel_number)
{
  struct hdhomerun_channel_entry_t *entry;
  entry=hdhomerun_channel_list_first(channel_list);
  while(!(entry == ((struct hdhomerun_channel_entry_t *)NULL)))
  {
    if(entry->channel_number == channel_number)
      return entry->frequency;

    entry=hdhomerun_channel_list_next(channel_list, entry);
  }
  return (unsigned int)0;
}

// hdhomerun_channelmap_get_channelmap_from_country_source
// file hdhomerun_channels.c line 153
extern const char * hdhomerun_channelmap_get_channelmap_from_country_source(const char *countrycode, const char *source, const char *supported)
{
  const char *default_result = (const char *)(void *)0;
  struct hdhomerun_channelmap_record_t *record = hdhomerun_channelmap_table;
  while(!(record->channelmap == ((const char *)NULL)))
  {
    char *return_value_strstr_1;
    return_value_strstr_1=strstr(record->channelmap, source);
    if(return_value_strstr_1 == ((char *)NULL))
      record = record + 1l;

    else
    {
      char *return_value_strstr_2;
      return_value_strstr_2=strstr(supported, record->channelmap);
      if(return_value_strstr_2 == ((char *)NULL))
        record = record + 1l;

      else
        if(record->countrycodes == ((const char *)NULL))
        {
          default_result = record->channelmap;
          record = record + 1l;
        }

        else
        {
          char *return_value_strstr_3;
          return_value_strstr_3=strstr(record->countrycodes, countrycode);
          if(return_value_strstr_3 == ((char *)NULL))
            record = record + 1l;

          else
            return record->channelmap;
        }
    }
  }
  return default_result;
}

// hdhomerun_channelmap_get_channelmap_scan_group
// file hdhomerun_channels.h line 29
extern const char * hdhomerun_channelmap_get_channelmap_scan_group(const char *channelmap)
{
  struct hdhomerun_channelmap_record_t *record = hdhomerun_channelmap_table;
  while(!(record->channelmap == ((const char *)NULL)))
  {
    char *return_value_strstr_1;
    return_value_strstr_1=strstr(channelmap, record->channelmap);
    if(!(return_value_strstr_1 == ((char *)NULL)))
      return record->channelmap_scan_group;

    record = record + 1l;
  }
  return (const char *)(void *)0;
}

// hdhomerun_control_close_sock
// file hdhomerun_control.c line 39
static void hdhomerun_control_close_sock(struct hdhomerun_control_sock_t *cs)
{
  if(!(cs->sock == -1))
  {
    hdhomerun_sock_destroy(cs->sock);
    cs->sock = -1;
  }

}

// hdhomerun_control_connect_sock
// file hdhomerun_control.c line 80
static signed int hdhomerun_control_connect_sock(struct hdhomerun_control_sock_t *cs)
{
  if(!(cs->sock == -1))
    return 1;

  else
    if(cs->desired_device_id == 0u)
    {
      if(!(cs->desired_device_ip == 0u))
        goto __CPROVER_DUMP_L2;

      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: no device specified\n");
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      signed int return_value_hdhomerun_discover_is_ip_multicast_1;
      return_value_hdhomerun_discover_is_ip_multicast_1=hdhomerun_discover_is_ip_multicast(cs->desired_device_ip);
      if(!(return_value_hdhomerun_discover_is_ip_multicast_1 == 0))
      {
        hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: cannot use multicast ip address for device operations\n");
        return 0;
      }

      else
      {
        struct hdhomerun_discover_device_t result;
        signed int return_value_hdhomerun_discover_find_devices_custom_v2_2;
        return_value_hdhomerun_discover_find_devices_custom_v2_2=hdhomerun_discover_find_devices_custom_v2(cs->desired_device_ip, 0xFFFFFFFF, cs->desired_device_id, &result, 1);
        if(!(return_value_hdhomerun_discover_find_devices_custom_v2_2 >= 1))
        {
          hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: device not found\n");
          return 0;
        }

        else
        {
          cs->actual_device_ip = result.ip_addr;
          cs->actual_device_id = result.device_id;
          cs->sock=hdhomerun_sock_create_tcp();
          if(cs->sock == -1)
          {
            signed int return_value_hdhomerun_sock_getlasterror_3;
            return_value_hdhomerun_sock_getlasterror_3=hdhomerun_sock_getlasterror();
            hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: failed to create socket (%d)\n", return_value_hdhomerun_sock_getlasterror_3);
            return 0;
          }

          signed int return_value_hdhomerun_sock_connect_5;
          return_value_hdhomerun_sock_connect_5=hdhomerun_sock_connect(cs->sock, cs->actual_device_ip, (unsigned short int)65001, (unsigned long int)2500);
          if(return_value_hdhomerun_sock_connect_5 == 0)
          {
            signed int return_value_hdhomerun_sock_getlasterror_4;
            return_value_hdhomerun_sock_getlasterror_4=hdhomerun_sock_getlasterror();
            hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_connect_sock: failed to connect (%d)\n", return_value_hdhomerun_sock_getlasterror_4);
            hdhomerun_control_close_sock(cs);
            return 0;
          }

          return 1;
        }
      }
    }
}

// hdhomerun_control_create
// file hdhomerun_control.c line 59
extern struct hdhomerun_control_sock_t * hdhomerun_control_create(unsigned int device_id, unsigned int device_ip, struct hdhomerun_debug_t *dbg)
{
  struct hdhomerun_control_sock_t *cs;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct hdhomerun_control_sock_t) /*6256ul*/ );
  cs = (struct hdhomerun_control_sock_t *)return_value_calloc_1;
  if(cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(dbg, "hdhomerun_control_create: failed to allocate control object\n");
    return (struct hdhomerun_control_sock_t *)(void *)0;
  }

  else
  {
    cs->dbg = dbg;
    cs->sock = -1;
    hdhomerun_control_set_device(cs, device_id, device_ip);
    return cs;
  }
}

// hdhomerun_control_destroy
// file hdhomerun_control.c line 74
extern void hdhomerun_control_destroy(struct hdhomerun_control_sock_t *cs)
{
  hdhomerun_control_close_sock(cs);
  free((void *)cs);
}

// hdhomerun_control_get
// file hdhomerun_control.c line 340
extern signed int hdhomerun_control_get(struct hdhomerun_control_sock_t *cs, const char *name, char **pvalue, char **perror)
{
  signed int return_value_hdhomerun_control_get_set_1;
  return_value_hdhomerun_control_get_set_1=hdhomerun_control_get_set(cs, name, (const char *)(void *)0, (unsigned int)0, pvalue, perror);
  return return_value_hdhomerun_control_get_set_1;
}

// hdhomerun_control_get_device_id
// file hdhomerun_control.c line 122
extern unsigned int hdhomerun_control_get_device_id(struct hdhomerun_control_sock_t *cs)
{
  signed int return_value_hdhomerun_control_connect_sock_1;
  return_value_hdhomerun_control_connect_sock_1=hdhomerun_control_connect_sock(cs);
  if(return_value_hdhomerun_control_connect_sock_1 == 0)
  {
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_device_id: connect failed\n");
    return (unsigned int)0;
  }

  else
    return cs->actual_device_id;
}

// hdhomerun_control_get_device_id_requested
// file hdhomerun_control.c line 142
extern unsigned int hdhomerun_control_get_device_id_requested(struct hdhomerun_control_sock_t *cs)
{
  return cs->desired_device_id;
}

// hdhomerun_control_get_device_ip
// file hdhomerun_control.c line 132
extern unsigned int hdhomerun_control_get_device_ip(struct hdhomerun_control_sock_t *cs)
{
  signed int return_value_hdhomerun_control_connect_sock_1;
  return_value_hdhomerun_control_connect_sock_1=hdhomerun_control_connect_sock(cs);
  if(return_value_hdhomerun_control_connect_sock_1 == 0)
  {
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_device_ip: connect failed\n");
    return (unsigned int)0;
  }

  else
    return cs->actual_device_ip;
}

// hdhomerun_control_get_device_ip_requested
// file hdhomerun_control.c line 147
extern unsigned int hdhomerun_control_get_device_ip_requested(struct hdhomerun_control_sock_t *cs)
{
  return cs->desired_device_ip;
}

// hdhomerun_control_get_local_addr
// file hdhomerun_control.c line 152
extern unsigned int hdhomerun_control_get_local_addr(struct hdhomerun_control_sock_t *cs)
{
  signed int return_value_hdhomerun_control_connect_sock_1;
  return_value_hdhomerun_control_connect_sock_1=hdhomerun_control_connect_sock(cs);
  if(return_value_hdhomerun_control_connect_sock_1 == 0)
  {
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_local_addr: connect failed\n");
    return (unsigned int)0;
  }

  else
  {
    unsigned int addr;
    addr=hdhomerun_sock_getsockname_addr(cs->sock);
    if(addr == 0u)
    {
      signed int return_value_hdhomerun_sock_getlasterror_2;
      return_value_hdhomerun_sock_getlasterror_2=hdhomerun_sock_getlasterror();
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_local_addr: getsockname failed (%d)\n", return_value_hdhomerun_sock_getlasterror_2);
      return (unsigned int)0;
    }

    return addr;
  }
}

// hdhomerun_control_get_set
// file hdhomerun_control.c line 255
static signed int hdhomerun_control_get_set(struct hdhomerun_control_sock_t *cs, const char *name, const char *value, unsigned int lockkey, char **pvalue, char **perror)
{
  struct hdhomerun_pkt_t *tx_pkt = &cs->tx_pkt;
  struct hdhomerun_pkt_t *rx_pkt = &cs->rx_pkt;
  hdhomerun_pkt_reset(tx_pkt);
  signed int name_len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  name_len = (signed int)return_value_strlen_1 + 1;
  if(!(tx_pkt->limit >= tx_pkt->end + 3l + (signed long int)name_len))
  {
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: request too long\n");
    return -1;
  }

  else
  {
    hdhomerun_pkt_write_u8(tx_pkt, (unsigned char)0x03);
    hdhomerun_pkt_write_var_length(tx_pkt, (unsigned long int)name_len);
    hdhomerun_pkt_write_mem(tx_pkt, (const void *)name, (unsigned long int)name_len);
    if(!(value == ((const char *)NULL)))
    {
      signed int value_len;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(value);
      value_len = (signed int)return_value_strlen_2 + 1;
      if(!(tx_pkt->limit >= tx_pkt->end + 3l + (signed long int)value_len))
      {
        hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: request too long\n");
        return -1;
      }

      hdhomerun_pkt_write_u8(tx_pkt, (unsigned char)0x04);
      hdhomerun_pkt_write_var_length(tx_pkt, (unsigned long int)value_len);
      hdhomerun_pkt_write_mem(tx_pkt, (const void *)value, (unsigned long int)value_len);
    }

    if(!(lockkey == 0u))
    {
      if(!(tx_pkt->limit >= tx_pkt->end + 6l))
      {
        hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: request too long\n");
        return -1;
      }

      hdhomerun_pkt_write_u8(tx_pkt, (unsigned char)0x15);
      hdhomerun_pkt_write_var_length(tx_pkt, (unsigned long int)4);
      hdhomerun_pkt_write_u32(tx_pkt, lockkey);
    }

    signed int return_value_hdhomerun_control_send_recv_internal_3;
    return_value_hdhomerun_control_send_recv_internal_3=hdhomerun_control_send_recv_internal(cs, tx_pkt, rx_pkt, (unsigned short int)0x0004, (unsigned long int)2500);
    if(!(return_value_hdhomerun_control_send_recv_internal_3 >= 0))
    {
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: send/recv error\n");
      return -1;
    }

    else
    {
      while((_Bool)1)
      {
        unsigned char tag;
        unsigned long int len;
        unsigned char *next;
        next=hdhomerun_pkt_read_tlv(rx_pkt, &tag, &len);
        if(next == ((unsigned char *)NULL))
          break;

        switch((signed int)tag)
        {
          case 0x04:
          {
            if(!(pvalue == ((char **)NULL)))
            {
              *pvalue = (char *)rx_pkt->pos;
              rx_pkt->pos[(signed long int)len] = (unsigned char)0;
            }

            if(!(perror == ((char **)NULL)))
              *perror = (char *)(void *)0;

            return 1;
          }
          case 0x05:
          {
            rx_pkt->pos[(signed long int)len] = (unsigned char)0;
            hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: %s\n", rx_pkt->pos);
            if(!(pvalue == ((char **)NULL)))
              *pvalue = (char *)(void *)0;

            if(!(perror == ((char **)NULL)))
              *perror = (char *)rx_pkt->pos;

            return 0;
          }
          default:
            rx_pkt->pos = next;
        }
      }
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_get_set: missing response tags\n");
      return -1;
    }
  }
}

// hdhomerun_control_recv_sock
// file hdhomerun_control.c line 179
static signed int hdhomerun_control_recv_sock(struct hdhomerun_control_sock_t *cs, struct hdhomerun_pkt_t *rx_pkt, unsigned short int *ptype, unsigned long int recv_timeout)
{
  unsigned long int stop_time;
  unsigned long int return_value_getcurrenttime_1;
  return_value_getcurrenttime_1=getcurrenttime();
  stop_time = return_value_getcurrenttime_1 + recv_timeout;
  hdhomerun_pkt_reset(rx_pkt);
  while((_Bool)1)
  {
    unsigned long int current_time;
    current_time=getcurrenttime();
    if(current_time >= stop_time)
    {
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_recv_sock: timeout\n");
      hdhomerun_control_close_sock(cs);
      return 0;
    }

    unsigned long int length = (unsigned long int)(rx_pkt->limit - rx_pkt->end);
    signed int return_value_hdhomerun_sock_recv_3;
    return_value_hdhomerun_sock_recv_3=hdhomerun_sock_recv(cs->sock, (void *)rx_pkt->end, &length, stop_time - current_time);
    if(return_value_hdhomerun_sock_recv_3 == 0)
    {
      signed int return_value_hdhomerun_sock_getlasterror_2;
      return_value_hdhomerun_sock_getlasterror_2=hdhomerun_sock_getlasterror();
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_recv_sock: recv failed (%d)\n", return_value_hdhomerun_sock_getlasterror_2);
      hdhomerun_control_close_sock(cs);
      return 0;
    }

    rx_pkt->end = rx_pkt->end + (signed long int)length;
    signed int ret;
    ret=hdhomerun_pkt_open_frame(rx_pkt, ptype);
    if(!(ret >= 0))
    {
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_recv_sock: frame error\n");
      hdhomerun_control_close_sock(cs);
      return 0;
    }

    if(ret >= 1)
      return 1;

  }
}

// hdhomerun_control_send_recv
// file hdhomerun_control.c line 250
extern signed int hdhomerun_control_send_recv(struct hdhomerun_control_sock_t *cs, struct hdhomerun_pkt_t *tx_pkt, struct hdhomerun_pkt_t *rx_pkt, unsigned short int type)
{
  signed int return_value_hdhomerun_control_send_recv_internal_1;
  return_value_hdhomerun_control_send_recv_internal_1=hdhomerun_control_send_recv_internal(cs, tx_pkt, rx_pkt, type, (unsigned long int)2500);
  return return_value_hdhomerun_control_send_recv_internal_1;
}

// hdhomerun_control_send_recv_internal
// file hdhomerun_control.c line 213
static signed int hdhomerun_control_send_recv_internal(struct hdhomerun_control_sock_t *cs, struct hdhomerun_pkt_t *tx_pkt, struct hdhomerun_pkt_t *rx_pkt, unsigned short int type, unsigned long int recv_timeout)
{
  hdhomerun_pkt_seal_frame(tx_pkt, type);
  signed int i = 0;
  for( ; !(i >= 2); i = i + 1)
  {
    if(cs->sock == -1)
    {
      signed int return_value_hdhomerun_control_connect_sock_1;
      return_value_hdhomerun_control_connect_sock_1=hdhomerun_control_connect_sock(cs);
      if(return_value_hdhomerun_control_connect_sock_1 == 0)
      {
        hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_send_recv: connect failed\n");
        return -1;
      }

    }

    signed int return_value_hdhomerun_control_send_sock_2;
    return_value_hdhomerun_control_send_sock_2=hdhomerun_control_send_sock(cs, tx_pkt);
    if(!(return_value_hdhomerun_control_send_sock_2 == 0))
    {
      if(rx_pkt == ((struct hdhomerun_pkt_t *)NULL))
        return 1;

      unsigned short int rsp_type;
      signed int return_value_hdhomerun_control_recv_sock_3;
      return_value_hdhomerun_control_recv_sock_3=hdhomerun_control_recv_sock(cs, rx_pkt, &rsp_type, recv_timeout);
      if(!(return_value_hdhomerun_control_recv_sock_3 == 0))
      {
        if(!((signed int)rsp_type == 1 + (signed int)type))
        {
          hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_send_recv: unexpected frame type\n");
          hdhomerun_control_close_sock(cs);
        }

        else
          return 1;
      }

    }

  }
  hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_send_recv: failed\n");
  return -1;
}

// hdhomerun_control_send_sock
// file hdhomerun_control.c line 168
static signed int hdhomerun_control_send_sock(struct hdhomerun_control_sock_t *cs, struct hdhomerun_pkt_t *tx_pkt)
{
  signed int return_value_hdhomerun_sock_send_2;
  return_value_hdhomerun_sock_send_2=hdhomerun_sock_send(cs->sock, (const void *)tx_pkt->start, (unsigned long int)(tx_pkt->end - tx_pkt->start), (unsigned long int)2500);
  if(return_value_hdhomerun_sock_send_2 == 0)
  {
    signed int return_value_hdhomerun_sock_getlasterror_1;
    return_value_hdhomerun_sock_getlasterror_1=hdhomerun_sock_getlasterror();
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_send_sock: send failed (%d)\n", return_value_hdhomerun_sock_getlasterror_1);
    hdhomerun_control_close_sock(cs);
    return 0;
  }

  return 1;
}

// hdhomerun_control_set
// file hdhomerun_control.c line 345
extern signed int hdhomerun_control_set(struct hdhomerun_control_sock_t *cs, const char *name, const char *value, char **pvalue, char **perror)
{
  signed int return_value_hdhomerun_control_get_set_1;
  return_value_hdhomerun_control_get_set_1=hdhomerun_control_get_set(cs, name, value, (unsigned int)0, pvalue, perror);
  return return_value_hdhomerun_control_get_set_1;
}

// hdhomerun_control_set_device
// file hdhomerun_control.c line 49
extern void hdhomerun_control_set_device(struct hdhomerun_control_sock_t *cs, unsigned int device_id, unsigned int device_ip)
{
  hdhomerun_control_close_sock(cs);
  cs->desired_device_id = device_id;
  cs->desired_device_ip = device_ip;
  cs->actual_device_id = (unsigned int)0;
  cs->actual_device_ip = (unsigned int)0;
}

// hdhomerun_control_set_with_lockkey
// file hdhomerun_control.c line 350
extern signed int hdhomerun_control_set_with_lockkey(struct hdhomerun_control_sock_t *cs, const char *name, const char *value, unsigned int lockkey, char **pvalue, char **perror)
{
  signed int return_value_hdhomerun_control_get_set_1;
  return_value_hdhomerun_control_get_set_1=hdhomerun_control_get_set(cs, name, value, lockkey, pvalue, perror);
  return return_value_hdhomerun_control_get_set_1;
}

// hdhomerun_control_upgrade
// file hdhomerun_control.c line 355
extern signed int hdhomerun_control_upgrade(struct hdhomerun_control_sock_t *cs, struct _IO_FILE *upgrade_file)
{
  struct hdhomerun_pkt_t *tx_pkt = &cs->tx_pkt;
  struct hdhomerun_pkt_t *rx_pkt = &cs->rx_pkt;
  signed int upload_delay = 0;
  unsigned int sequence = (unsigned int)0;
  char *version_str;
  signed int ret;
  ret=hdhomerun_control_get(cs, "/sys/version", &version_str, (char **)(void *)0);
  signed int tmp_statement_expression_1;
  if(ret >= 1)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(version_str, "20120704beta1");
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    upload_delay = (signed int)(tmp_statement_expression_1 == 0);
  }

  while((_Bool)1)
  {
    unsigned char data[1024l];
    unsigned long int length;
    length=fread((void *)data, (unsigned long int)1, (unsigned long int)1024, upgrade_file);
    if(length == 0ul)
      break;

    hdhomerun_pkt_reset(tx_pkt);
    hdhomerun_pkt_write_u32(tx_pkt, sequence);
    hdhomerun_pkt_write_mem(tx_pkt, (const void *)data, length);
    signed int return_value_hdhomerun_control_send_recv_internal_3;
    return_value_hdhomerun_control_send_recv_internal_3=hdhomerun_control_send_recv_internal(cs, tx_pkt, (struct hdhomerun_pkt_t *)(void *)0, (unsigned short int)0x0006, (unsigned long int)0);
    if(!(return_value_hdhomerun_control_send_recv_internal_3 >= 0))
    {
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_upgrade: send/recv failed\n");
      return -1;
    }

    sequence = sequence + (unsigned int)length;
    if(!(upload_delay == 0))
      msleep_approx((unsigned long int)25);

  }
  if(sequence == 0u)
  {
    hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_upgrade: zero length file\n");
    return 0;
  }

  else
  {
    hdhomerun_pkt_reset(tx_pkt);
    hdhomerun_pkt_write_u32(tx_pkt, 0xFFFFFFFF);
    signed int return_value_hdhomerun_control_send_recv_internal_4;
    return_value_hdhomerun_control_send_recv_internal_4=hdhomerun_control_send_recv_internal(cs, tx_pkt, rx_pkt, (unsigned short int)0x0006, (unsigned long int)30000);
    if(!(return_value_hdhomerun_control_send_recv_internal_4 >= 0))
    {
      hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_upgrade: send/recv failed\n");
      return -1;
    }

    else
    {
      while((_Bool)1)
      {
        unsigned char tag;
        unsigned long int len;
        unsigned char *next;
        next=hdhomerun_pkt_read_tlv(rx_pkt, &tag, &len);
        if(next == ((unsigned char *)NULL))
          break;

        if((signed int)tag == 0x05)
        {
          rx_pkt->pos[(signed long int)len] = (unsigned char)0;
          hdhomerun_debug_printf(cs->dbg, "hdhomerun_control_upgrade: %s\n", (char *)rx_pkt->pos);
          return 0;
        }

        rx_pkt->pos = next;
      }
      return 1;
    }
  }
}

// hdhomerun_debug_close
// file hdhomerun_debug.c line 133
extern void hdhomerun_debug_close(struct hdhomerun_debug_t *dbg, unsigned long int timeout)
{
  if(!(dbg == ((struct hdhomerun_debug_t *)NULL)))
  {
    if(timeout >= 1ul)
      hdhomerun_debug_flush(dbg, timeout);

    pthread_mutex_lock(&dbg->send_lock);
    hdhomerun_debug_close_internal(dbg);
    dbg->connect_delay = (unsigned long int)0;
    pthread_mutex_unlock(&dbg->send_lock);
  }

}

// hdhomerun_debug_close_internal
// file hdhomerun_debug.c line 120
static void hdhomerun_debug_close_internal(struct hdhomerun_debug_t *dbg)
{
  if(!(dbg->file_fp == ((struct _IO_FILE *)NULL)))
  {
    fclose(dbg->file_fp);
    dbg->file_fp = (struct _IO_FILE *)(void *)0;
  }

  if(!(dbg->sock == -1))
  {
    hdhomerun_sock_destroy(dbg->sock);
    dbg->sock = -1;
  }

}

// hdhomerun_debug_create
// file hdhomerun_debug.c line 73
extern struct hdhomerun_debug_t * hdhomerun_debug_create(void)
{
  struct hdhomerun_debug_t *dbg;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct hdhomerun_debug_t) /*200ul*/ );
  dbg = (struct hdhomerun_debug_t *)return_value_calloc_1;
  if(dbg == ((struct hdhomerun_debug_t *)NULL))
    return (struct hdhomerun_debug_t *)(void *)0;

  else
  {
    dbg->sock = -1;
    pthread_mutex_init(&dbg->print_lock, (const union anonymous_3 *)(void *)0);
    pthread_mutex_init(&dbg->queue_lock, (const union anonymous_3 *)(void *)0);
    pthread_mutex_init(&dbg->send_lock, (const union anonymous_3 *)(void *)0);
    signed int return_value_pthread_create_2;
    return_value_pthread_create_2=pthread_create(&dbg->thread, (const union pthread_attr_t *)(void *)0, hdhomerun_debug_thread_execute, (void *)dbg);
    if(!(return_value_pthread_create_2 == 0))
    {
      free((void *)dbg);
      return (struct hdhomerun_debug_t *)(void *)0;
    }

    else
      return dbg;
  }
}

// hdhomerun_debug_destroy
// file hdhomerun_debug.c line 94
extern void hdhomerun_debug_destroy(struct hdhomerun_debug_t *dbg)
{
  if(!(dbg == ((struct hdhomerun_debug_t *)NULL)))
  {
    dbg->terminate = 1;
    pthread_join(dbg->thread, (void **)(void *)0);
    if(!(dbg->prefix == ((char *)NULL)))
      free((void *)dbg->prefix);

    if(!(dbg->file_name == ((char *)NULL)))
      free((void *)dbg->file_name);

    if(!(dbg->file_fp == ((struct _IO_FILE *)NULL)))
      fclose(dbg->file_fp);

    if(!(dbg->sock == -1))
      hdhomerun_sock_destroy(dbg->sock);

    free((void *)dbg);
  }

}

// hdhomerun_debug_disable
// file hdhomerun_debug.c line 211
extern void hdhomerun_debug_disable(struct hdhomerun_debug_t *dbg)
{
  if(!(dbg == ((struct hdhomerun_debug_t *)NULL)))
    dbg->enabled = 0;

}

// hdhomerun_debug_enable
// file hdhomerun_debug.c line 202
extern void hdhomerun_debug_enable(struct hdhomerun_debug_t *dbg)
{
  if(!(dbg == ((struct hdhomerun_debug_t *)NULL)))
    dbg->enabled = 1;

}

// hdhomerun_debug_enabled
// file hdhomerun_debug.c line 220
extern signed int hdhomerun_debug_enabled(struct hdhomerun_debug_t *dbg)
{
  if(dbg == ((struct hdhomerun_debug_t *)NULL))
    return 0;

  else
    return dbg->enabled;
}

// hdhomerun_debug_flush
// file hdhomerun_debug.c line 229
extern void hdhomerun_debug_flush(struct hdhomerun_debug_t *dbg, unsigned long int timeout)
{
  unsigned long int return_value_getcurrenttime_2;
  if(!(dbg == ((struct hdhomerun_debug_t *)NULL)))
  {
    unsigned long int return_value_getcurrenttime_1;
    return_value_getcurrenttime_1=getcurrenttime();
    timeout = return_value_getcurrenttime_1 + timeout;
    do
    {
      return_value_getcurrenttime_2=getcurrenttime();
      if(return_value_getcurrenttime_2 >= timeout)
        break;

      pthread_mutex_lock(&dbg->queue_lock);
      struct hdhomerun_debug_message_t *message = dbg->queue_tail;
      pthread_mutex_unlock(&dbg->queue_lock);
      if(message == ((struct hdhomerun_debug_message_t *)NULL))
        goto __CPROVER_DUMP_L4;

      msleep_approx((unsigned long int)10);
    }
    while((_Bool)1);
  }


__CPROVER_DUMP_L4:
  ;
}

// hdhomerun_debug_output_message
// file hdhomerun_debug.c line 386
static signed int hdhomerun_debug_output_message(struct hdhomerun_debug_t *dbg, struct hdhomerun_debug_message_t *message)
{
  pthread_mutex_lock(&dbg->send_lock);
  signed int ret;
  if(!(dbg->file_name == ((char *)NULL)))
    ret=hdhomerun_debug_output_message_file(dbg, message);

  else
    ret=hdhomerun_debug_output_message_sock(dbg, message);
  pthread_mutex_unlock(&dbg->send_lock);
  return ret;
}

// hdhomerun_debug_output_message_file
// file hdhomerun_debug.c line 329
static signed int hdhomerun_debug_output_message_file(struct hdhomerun_debug_t *dbg, struct hdhomerun_debug_message_t *message)
{
  if(dbg->file_fp == ((struct _IO_FILE *)NULL))
  {
    unsigned long int current_time;
    current_time=getcurrenttime();
    if(!(current_time >= dbg->connect_delay))
      return 0;

    dbg->connect_delay = current_time + (unsigned long int)(30 * 1000);
    dbg->file_fp=fopen(dbg->file_name, "a");
    if(dbg->file_fp == ((struct _IO_FILE *)NULL))
      return 0;

  }

  fprintf(dbg->file_fp, "%s", (const void *)message->buffer);
  fflush(dbg->file_fp);
  return 1;
}

// hdhomerun_debug_output_message_sock
// file hdhomerun_debug.c line 351
static signed int hdhomerun_debug_output_message_sock(struct hdhomerun_debug_t *dbg, struct hdhomerun_debug_message_t *message)
{
  if(dbg->sock == -1)
  {
    unsigned long int current_time;
    current_time=getcurrenttime();
    if(!(current_time >= dbg->connect_delay))
      return 0;

    dbg->connect_delay = current_time + (unsigned long int)30000;
    dbg->sock=hdhomerun_sock_create_tcp();
    if(dbg->sock == -1)
      return 0;

    unsigned int remote_addr;
    remote_addr=hdhomerun_sock_getaddrinfo_addr(dbg->sock, "debug.silicondust.com");
    if(remote_addr == 0u)
    {
      hdhomerun_debug_close_internal(dbg);
      return 0;
    }

    signed int return_value_hdhomerun_sock_connect_1;
    return_value_hdhomerun_sock_connect_1=hdhomerun_sock_connect(dbg->sock, remote_addr, (unsigned short int)8002, (unsigned long int)10000);
    if(return_value_hdhomerun_sock_connect_1 == 0)
    {
      hdhomerun_debug_close_internal(dbg);
      return 0;
    }

  }

  unsigned long int length;
  length=strlen(message->buffer);
  signed int return_value_hdhomerun_sock_send_2;
  return_value_hdhomerun_sock_send_2=hdhomerun_sock_send(dbg->sock, (const void *)message->buffer, length, (unsigned long int)10000);
  if(return_value_hdhomerun_sock_send_2 == 0)
  {
    hdhomerun_debug_close_internal(dbg);
    return 0;
  }

  else
    return 1;
}

// hdhomerun_debug_pop_and_free_message
// file hdhomerun_debug.c line 401
static void hdhomerun_debug_pop_and_free_message(struct hdhomerun_debug_t *dbg)
{
  pthread_mutex_lock(&dbg->queue_lock);
  struct hdhomerun_debug_message_t *message = dbg->queue_tail;
  dbg->queue_tail = message->prev;
  if(!(message->prev == ((struct hdhomerun_debug_message_t *)NULL)))
    message->prev->next = (struct hdhomerun_debug_message_t *)(void *)0;

  else
    dbg->queue_head = (struct hdhomerun_debug_message_t *)(void *)0;
  dbg->queue_depth = dbg->queue_depth - 1u;
  pthread_mutex_unlock(&dbg->queue_lock);
  free((void *)message);
}

// hdhomerun_debug_printf
// file hdhomerun_debug.h line 47
extern void hdhomerun_debug_printf(struct hdhomerun_debug_t *dbg, const char *fmt, ...)
{
  void **args = (void **)&fmt;
  hdhomerun_debug_vprintf(dbg, fmt, args);
  args = ((void **)NULL);
}

// hdhomerun_debug_set_filename
// file hdhomerun_debug.c line 149
extern void hdhomerun_debug_set_filename(struct hdhomerun_debug_t *dbg, const char *filename)
{
  signed int tmp_statement_expression_1;
  if(!(dbg == ((struct hdhomerun_debug_t *)NULL)))
  {
    pthread_mutex_lock(&dbg->send_lock);
    if(filename == ((const char *)NULL))
    {
      if(!(dbg->file_name == ((char *)NULL)))
        goto __CPROVER_DUMP_L1;

      pthread_mutex_unlock(&dbg->send_lock);
    }

    else
    {

    __CPROVER_DUMP_L1:
      ;
      if(!(filename == ((const char *)NULL)))
      {
        if(dbg->file_name == ((char *)NULL))
          goto __CPROVER_DUMP_L2;

        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp_2;
        return_value___builtin_strcmp_2=__builtin_strcmp(filename, dbg->file_name);
        tmp_statement_expression_1 = return_value___builtin_strcmp_2;
        if(!(tmp_statement_expression_1 == 0))
          goto __CPROVER_DUMP_L2;

        pthread_mutex_unlock(&dbg->send_lock);
      }

      else
      {

      __CPROVER_DUMP_L2:
        ;
        hdhomerun_debug_close_internal(dbg);
        dbg->connect_delay = (unsigned long int)0;
        if(!(dbg->file_name == ((char *)NULL)))
        {
          free((void *)dbg->file_name);
          dbg->file_name = (char *)(void *)0;
        }

        if(!(filename == ((const char *)NULL)))
        {
          char *return_value___strdup_3;
          return_value___strdup_3=__strdup(filename);
          dbg->file_name = return_value___strdup_3;
        }

        pthread_mutex_unlock(&dbg->send_lock);
      }
    }
  }

}

// hdhomerun_debug_set_prefix
// file hdhomerun_debug.c line 182
extern void hdhomerun_debug_set_prefix(struct hdhomerun_debug_t *dbg, const char *prefix)
{
  if(!(dbg == ((struct hdhomerun_debug_t *)NULL)))
  {
    pthread_mutex_lock(&dbg->print_lock);
    if(!(dbg->prefix == ((char *)NULL)))
    {
      free((void *)dbg->prefix);
      dbg->prefix = (char *)(void *)0;
    }

    if(!(prefix == ((const char *)NULL)))
    {
      char *return_value___strdup_1;
      return_value___strdup_1=__strdup(prefix);
      dbg->prefix = return_value___strdup_1;
    }

    pthread_mutex_unlock(&dbg->print_lock);
  }

}

// hdhomerun_debug_thread_execute
// file hdhomerun_debug.c line 419
static void * hdhomerun_debug_thread_execute(void *arg)
{
  struct hdhomerun_debug_t *dbg = (struct hdhomerun_debug_t *)arg;
  while(dbg->terminate == 0)
  {
    pthread_mutex_lock(&dbg->queue_lock);
    struct hdhomerun_debug_message_t *message = dbg->queue_tail;
    unsigned int queue_depth = dbg->queue_depth;
    pthread_mutex_unlock(&dbg->queue_lock);
    if(message == ((struct hdhomerun_debug_message_t *)NULL))
      msleep_approx((unsigned long int)250);

    else
      if(queue_depth >= 1025u)
        hdhomerun_debug_pop_and_free_message(dbg);

      else
      {
        signed int return_value_hdhomerun_debug_output_message_1;
        return_value_hdhomerun_debug_output_message_1=hdhomerun_debug_output_message(dbg, message);
        if(return_value_hdhomerun_debug_output_message_1 == 0)
          msleep_approx((unsigned long int)250);

        else
          hdhomerun_debug_pop_and_free_message(dbg);
      }
  }
  return NULL;
}

// hdhomerun_debug_vprintf
// file hdhomerun_debug.c line 258
extern void hdhomerun_debug_vprintf(struct hdhomerun_debug_t *dbg, const char *fmt, void **args)
{
  if(!(dbg == ((struct hdhomerun_debug_t *)NULL)))
  {
    if(!(dbg->enabled == 0))
    {
      struct hdhomerun_debug_message_t *message;
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(sizeof(struct hdhomerun_debug_message_t) /*2064ul*/ );
      message = (struct hdhomerun_debug_message_t *)return_value_malloc_1;
      if(!(message == ((struct hdhomerun_debug_message_t *)NULL)))
      {
        char *ptr = message->buffer;
        char *end = (message->buffer + (signed long int)sizeof(char [2048l]) /*2048ul*/ ) - (signed long int)2;
        *end = (char)0;
        signed long int current_time;
        current_time=time((signed long int *)(void *)0);
        struct tm *return_value_localtime_2;
        return_value_localtime_2=localtime(&current_time);
        unsigned long int return_value_strftime_3;
        return_value_strftime_3=strftime(ptr, (unsigned long int)(end - ptr), "%Y%m%d-%H:%M:%S ", return_value_localtime_2);
        ptr = ptr + (signed long int)return_value_strftime_3;
        if(!(end >= ptr))
          ptr = end;

        pthread_mutex_lock(&dbg->print_lock);
        if(!(dbg->prefix == ((char *)NULL)))
        {
          hdhomerun_sprintf(ptr, end, "%s ", dbg->prefix);
          void *return_value___rawmemchr_4;
          return_value___rawmemchr_4=__rawmemchr((const void *)ptr, 0);
          ptr = (char *)return_value___rawmemchr_4;
        }

        pthread_mutex_unlock(&dbg->print_lock);
        hdhomerun_vsprintf(ptr, end, fmt, args);
        void *return_value___rawmemchr_5;
        return_value___rawmemchr_5=__rawmemchr((const void *)ptr, 0);
        ptr = (char *)return_value___rawmemchr_5;
        if(!((signed int)ptr[-1l] == 10))
          hdhomerun_sprintf(ptr, end, "\n");

        pthread_mutex_lock(&dbg->queue_lock);
        message->prev = (struct hdhomerun_debug_message_t *)(void *)0;
        message->next = dbg->queue_head;
        dbg->queue_head = message;
        if(!(message->next == ((struct hdhomerun_debug_message_t *)NULL)))
          message->next->prev = message;

        else
          dbg->queue_tail = message;
        dbg->queue_depth = dbg->queue_depth + 1u;
        pthread_mutex_unlock(&dbg->queue_lock);
      }

    }

  }

}

// hdhomerun_device_channelscan_advance
// file hdhomerun_device.h line 228
extern signed int hdhomerun_device_channelscan_advance(struct hdhomerun_device_t *hd, struct hdhomerun_channelscan_result_t *result)
{
  if(hd->scan == ((struct hdhomerun_channelscan_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_channelscan_advance: scan not initialized\n");
    return 0;
  }

  else
  {
    signed int ret;
    ret=channelscan_advance(hd->scan, result);
    if(!(ret >= 1))
    {
      channelscan_destroy(hd->scan);
      hd->scan = (struct hdhomerun_channelscan_t *)(void *)0;
    }

    return ret;
  }
}

// hdhomerun_device_channelscan_detect
// file hdhomerun_device.h line 229
extern signed int hdhomerun_device_channelscan_detect(struct hdhomerun_device_t *hd, struct hdhomerun_channelscan_result_t *result)
{
  if(hd->scan == ((struct hdhomerun_channelscan_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_channelscan_detect: scan not initialized\n");
    return 0;
  }

  else
  {
    signed int ret;
    ret=channelscan_detect(hd->scan, result);
    if(!(ret >= 0))
    {
      channelscan_destroy(hd->scan);
      hd->scan = (struct hdhomerun_channelscan_t *)(void *)0;
    }

    return ret;
  }
}

// hdhomerun_device_channelscan_get_progress
// file hdhomerun_device.c line 1253
extern unsigned char hdhomerun_device_channelscan_get_progress(struct hdhomerun_device_t *hd)
{
  if(hd->scan == ((struct hdhomerun_channelscan_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_channelscan_get_progress: scan not initialized\n");
    return (unsigned char)0;
  }

  else
  {
    unsigned char return_value_channelscan_get_progress_1;
    return_value_channelscan_get_progress_1=channelscan_get_progress(hd->scan);
    return return_value_channelscan_get_progress_1;
  }
}

// hdhomerun_device_channelscan_init
// file hdhomerun_device.h line 227
extern signed int hdhomerun_device_channelscan_init(struct hdhomerun_device_t *hd, const char *channelmap)
{
  if(!(hd->scan == ((struct hdhomerun_channelscan_t *)NULL)))
    channelscan_destroy(hd->scan);

  hd->scan=channelscan_create(hd, channelmap);
  if(hd->scan == ((struct hdhomerun_channelscan_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_channelscan_init: failed to create scan object\n");
    return -1;
  }

  else
    return 1;
}

// hdhomerun_device_create
// file hdhomerun_device.c line 149
extern struct hdhomerun_device_t * hdhomerun_device_create(unsigned int device_id, unsigned int device_ip, unsigned int tuner, struct hdhomerun_debug_t *dbg)
{
  struct hdhomerun_device_t *hdhomerun_device_create__1__hd;
  hdhomerun_device_create__1__hd=hdhomerun_device_create_internal(dbg);
  if(hdhomerun_device_create__1__hd == ((struct hdhomerun_device_t *)NULL))
    return (struct hdhomerun_device_t *)(void *)0;

  else
    if(device_id == 0u && device_ip == 0u && tuner == 0u)
      return hdhomerun_device_create__1__hd;

    else
    {
      signed int return_value_hdhomerun_device_set_device_1;
      return_value_hdhomerun_device_set_device_1=hdhomerun_device_set_device(hdhomerun_device_create__1__hd, device_id, device_ip);
      if(!(return_value_hdhomerun_device_set_device_1 >= 1))
      {
        free((void *)hdhomerun_device_create__1__hd);
        return (struct hdhomerun_device_t *)(void *)0;
      }

      else
      {
        signed int return_value_hdhomerun_device_set_tuner_2;
        return_value_hdhomerun_device_set_tuner_2=hdhomerun_device_set_tuner(hdhomerun_device_create__1__hd, tuner);
        if(!(return_value_hdhomerun_device_set_tuner_2 >= 1))
        {
          free((void *)hdhomerun_device_create__1__hd);
          return (struct hdhomerun_device_t *)(void *)0;
        }

        else
          return hdhomerun_device_create__1__hd;
      }
    }
}

// hdhomerun_device_create_from_str
// file hdhomerun_device.h line 68
extern struct hdhomerun_device_t * hdhomerun_device_create_from_str(const char *device_str, struct hdhomerun_debug_t *dbg)
{
  unsigned int a[4l];
  signed int return_value_sscanf_6;
  return_value_sscanf_6=sscanf(device_str, "%u.%u.%u.%u", &a[(signed long int)0], &a[(signed long int)1], &a[(signed long int)2], &a[(signed long int)3]);
  if(return_value_sscanf_6 == 4)
  {
    unsigned int ip_addr = (unsigned int)(a[(signed long int)0] << 24 | a[(signed long int)1] << 16 | a[(signed long int)2] << 8 | a[(signed long int)3] << 0);
    unsigned int port;
    signed int return_value_sscanf_2;
    return_value_sscanf_2=sscanf(device_str, "%u.%u.%u.%u:%u", &a[(signed long int)0], &a[(signed long int)1], &a[(signed long int)2], &a[(signed long int)3], &port);
    if(return_value_sscanf_2 == 5)
    {
      struct hdhomerun_device_t *return_value_hdhomerun_device_create_multicast_1;
      return_value_hdhomerun_device_create_multicast_1=hdhomerun_device_create_multicast(ip_addr, (unsigned short int)port, dbg);
      return return_value_hdhomerun_device_create_multicast_1;
    }

    unsigned int tuner;
    signed int return_value_sscanf_4;
    return_value_sscanf_4=sscanf(device_str, "%u.%u.%u.%u-%u", &a[(signed long int)0], &a[(signed long int)1], &a[(signed long int)2], &a[(signed long int)3], &tuner);
    if(return_value_sscanf_4 == 5)
    {
      struct hdhomerun_device_t *return_value_hdhomerun_device_create_3;
      return_value_hdhomerun_device_create_3=hdhomerun_device_create(0xFFFFFFFF, ip_addr, tuner, dbg);
      return return_value_hdhomerun_device_create_3;
    }

    struct hdhomerun_device_t *return_value_hdhomerun_device_create_5;
    return_value_hdhomerun_device_create_5=hdhomerun_device_create(0xFFFFFFFF, ip_addr, (unsigned int)0, dbg);
    return return_value_hdhomerun_device_create_5;
  }

  char *end;
  unsigned int device_id;
  unsigned long int return_value_strtoul_7;
  return_value_strtoul_7=strtoul(device_str, &end, 16);
  device_id = (unsigned int)return_value_strtoul_7;
  signed int return_value_hdhomerun_discover_validate_device_id_11;
  if(end == device_str + 8l)
  {
    return_value_hdhomerun_discover_validate_device_id_11=hdhomerun_discover_validate_device_id(device_id);
    if(!(return_value_hdhomerun_discover_validate_device_id_11 == 0))
    {
      if((signed int)*end == 45)
      {
        unsigned int hdhomerun_device_create_from_str__1__2__1__tuner;
        unsigned long int return_value_strtoul_8;
        return_value_strtoul_8=strtoul(end + (signed long int)1, (char ** restrict )(void *)0, 10);
        hdhomerun_device_create_from_str__1__2__1__tuner = (unsigned int)return_value_strtoul_8;
        struct hdhomerun_device_t *return_value_hdhomerun_device_create_9;
        return_value_hdhomerun_device_create_9=hdhomerun_device_create(device_id, (unsigned int)0, hdhomerun_device_create_from_str__1__2__1__tuner, dbg);
        return return_value_hdhomerun_device_create_9;
      }

      struct hdhomerun_device_t *return_value_hdhomerun_device_create_10;
      return_value_hdhomerun_device_create_10=hdhomerun_device_create(device_id, (unsigned int)0, (unsigned int)0, dbg);
      return return_value_hdhomerun_device_create_10;
    }

  }

  struct addrinfo hints;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 2;
  hints.ai_socktype = 1;
  hints.ai_protocol = 6;
  struct addrinfo *sock_info;
  signed int return_value_getaddrinfo_12;
  return_value_getaddrinfo_12=getaddrinfo(device_str, "65001", &hints, &sock_info);
  if(!(return_value_getaddrinfo_12 == 0))
    return (struct hdhomerun_device_t *)(void *)0;

  else
  {
    struct sockaddr_in *sock_addr = (struct sockaddr_in *)sock_info->ai_addr;
    unsigned int hdhomerun_device_create_from_str__1__ip_addr;
    unsigned int return_value___bswap_32_13;
    return_value___bswap_32_13=__bswap_32(sock_addr->sin_addr.s_addr);
    hdhomerun_device_create_from_str__1__ip_addr = (unsigned int)return_value___bswap_32_13;
    freeaddrinfo(sock_info);
    if(hdhomerun_device_create_from_str__1__ip_addr == 0u)
      return (struct hdhomerun_device_t *)(void *)0;

    else
    {
      struct hdhomerun_device_t *return_value_hdhomerun_device_create_14;
      return_value_hdhomerun_device_create_14=hdhomerun_device_create(0xFFFFFFFF, hdhomerun_device_create_from_str__1__ip_addr, (unsigned int)0, dbg);
      return return_value_hdhomerun_device_create_14;
    }
  }
}

// hdhomerun_device_create_internal
// file hdhomerun_device.c line 137
static struct hdhomerun_device_t * hdhomerun_device_create_internal(struct hdhomerun_debug_t *dbg)
{
  struct hdhomerun_device_t *hdhomerun_device_create_internal__1__hd;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct hdhomerun_device_t) /*120ul*/ );
  hdhomerun_device_create_internal__1__hd = (struct hdhomerun_device_t *)return_value_calloc_1;
  if(hdhomerun_device_create_internal__1__hd == ((struct hdhomerun_device_t *)NULL))
  {
    hdhomerun_debug_printf(dbg, "hdhomerun_device_create: failed to allocate device object\n");
    return (struct hdhomerun_device_t *)(void *)0;
  }

  else
  {
    hdhomerun_device_create_internal__1__hd->dbg = dbg;
    return hdhomerun_device_create_internal__1__hd;
  }
}

// hdhomerun_device_create_multicast
// file hdhomerun_device.c line 172
extern struct hdhomerun_device_t * hdhomerun_device_create_multicast(unsigned int multicast_ip, unsigned short int multicast_port, struct hdhomerun_debug_t *dbg)
{
  struct hdhomerun_device_t *hdhomerun_device_create_multicast__1__hd;
  hdhomerun_device_create_multicast__1__hd=hdhomerun_device_create_internal(dbg);
  if(hdhomerun_device_create_multicast__1__hd == ((struct hdhomerun_device_t *)NULL))
    return (struct hdhomerun_device_t *)(void *)0;

  else
  {
    signed int return_value_hdhomerun_device_set_multicast_1;
    return_value_hdhomerun_device_set_multicast_1=hdhomerun_device_set_multicast(hdhomerun_device_create_multicast__1__hd, multicast_ip, multicast_port);
    if(!(return_value_hdhomerun_device_set_multicast_1 >= 1))
    {
      free((void *)hdhomerun_device_create_multicast__1__hd);
      return (struct hdhomerun_device_t *)(void *)0;
    }

    else
      return hdhomerun_device_create_multicast__1__hd;
  }
}

// hdhomerun_device_debug_print_video_stats
// file hdhomerun_device.c line 1320
extern void hdhomerun_device_debug_print_video_stats(struct hdhomerun_device_t *hd)
{
  signed int return_value_hdhomerun_debug_enabled_1;
  return_value_hdhomerun_debug_enabled_1=hdhomerun_debug_enabled(hd->dbg);
  if(!(return_value_hdhomerun_debug_enabled_1 == 0))
  {
    if(!(hd->cs == ((struct hdhomerun_control_sock_t *)NULL)))
    {
      char name[32l];
      hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/debug", hd->tuner);
      char *debug_str;
      char *error_str;
      signed int ret;
      ret=hdhomerun_control_get(hd->cs, name, &debug_str, &error_str);
      if(!(ret >= 0))
      {
        hdhomerun_debug_printf(hd->dbg, "video dev: communication error getting debug stats\n");
        goto __CPROVER_DUMP_L6;
      }

      if(!(error_str == ((char *)NULL)))
        hdhomerun_debug_printf(hd->dbg, "video dev: %s\n", error_str);

      else
        hdhomerun_debug_printf(hd->dbg, "video dev: %s\n", debug_str);
    }

    if(!(hd->vs == ((struct hdhomerun_video_sock_t *)NULL)))
      hdhomerun_video_debug_print_stats(hd->vs);

  }


__CPROVER_DUMP_L6:
  ;
}

// hdhomerun_device_destroy
// file hdhomerun_device.h line 69
extern void hdhomerun_device_destroy(struct hdhomerun_device_t *hd)
{
  if(!(hd->scan == ((struct hdhomerun_channelscan_t *)NULL)))
    channelscan_destroy(hd->scan);

  if(!(hd->vs == ((struct hdhomerun_video_sock_t *)NULL)))
    hdhomerun_video_destroy(hd->vs);

  if(!(hd->cs == ((struct hdhomerun_control_sock_t *)NULL)))
    hdhomerun_control_destroy(hd->cs);

  free((void *)hd);
}

// hdhomerun_device_get_control_sock
// file hdhomerun_device.c line 331
extern struct hdhomerun_control_sock_t * hdhomerun_device_get_control_sock(struct hdhomerun_device_t *hd)
{
  return hd->cs;
}

// hdhomerun_device_get_device_id
// file hdhomerun_device.c line 285
extern unsigned int hdhomerun_device_get_device_id(struct hdhomerun_device_t *hd)
{
  return hd->device_id;
}

// hdhomerun_device_get_device_id_requested
// file hdhomerun_device.h line 77
extern unsigned int hdhomerun_device_get_device_id_requested(struct hdhomerun_device_t *hd)
{
  if(!(hd->multicast_ip == 0u))
    return (unsigned int)0;

  else
  {
    if(!(hd->cs == ((struct hdhomerun_control_sock_t *)NULL)))
    {
      unsigned int return_value_hdhomerun_control_get_device_id_requested_1;
      return_value_hdhomerun_control_get_device_id_requested_1=hdhomerun_control_get_device_id_requested(hd->cs);
      return return_value_hdhomerun_control_get_device_id_requested_1;
    }

    return (unsigned int)0;
  }
}

// hdhomerun_device_get_device_ip
// file hdhomerun_device.c line 290
extern unsigned int hdhomerun_device_get_device_ip(struct hdhomerun_device_t *hd)
{
  if(!(hd->multicast_ip == 0u))
    return hd->multicast_ip;

  else
  {
    if(!(hd->cs == ((struct hdhomerun_control_sock_t *)NULL)))
    {
      unsigned int return_value_hdhomerun_control_get_device_ip_1;
      return_value_hdhomerun_control_get_device_ip_1=hdhomerun_control_get_device_ip(hd->cs);
      return return_value_hdhomerun_control_get_device_ip_1;
    }

    return (unsigned int)0;
  }
}

// hdhomerun_device_get_device_ip_requested
// file hdhomerun_device.c line 314
extern unsigned int hdhomerun_device_get_device_ip_requested(struct hdhomerun_device_t *hd)
{
  if(!(hd->multicast_ip == 0u))
    return hd->multicast_ip;

  else
  {
    if(!(hd->cs == ((struct hdhomerun_control_sock_t *)NULL)))
    {
      unsigned int return_value_hdhomerun_control_get_device_ip_requested_1;
      return_value_hdhomerun_control_get_device_ip_requested_1=hdhomerun_control_get_device_ip_requested(hd->cs);
      return return_value_hdhomerun_control_get_device_ip_requested_1;
    }

    return (unsigned int)0;
  }
}

// hdhomerun_device_get_hw_model_str
// file hdhomerun_device.c line 1263
extern const char * hdhomerun_device_get_hw_model_str(struct hdhomerun_device_t *hd)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_hw_model_str: device not set\n");
    return (const char *)(void *)0;
  }

  else
  {
    char *model_str;
    signed int ret;
    ret=hdhomerun_control_get(hd->cs, "/sys/hwmodel", &model_str, (char **)(void *)0);
    if(!(ret >= 0))
      return (const char *)(void *)0;

    else
      return model_str;
  }
}

// hdhomerun_device_get_ir_target
// file hdhomerun_device.c line 767
extern signed int hdhomerun_device_get_ir_target(struct hdhomerun_device_t *hd, char **ptarget)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_ir_target: device not set\n");
    return -1;
  }

  else
  {
    signed int return_value_hdhomerun_control_get_1;
    return_value_hdhomerun_control_get_1=hdhomerun_control_get(hd->cs, "/ir/target", ptarget, (char **)(void *)0);
    return return_value_hdhomerun_control_get_1;
  }
}

// hdhomerun_device_get_local_machine_addr
// file hdhomerun_device.c line 353
extern unsigned int hdhomerun_device_get_local_machine_addr(struct hdhomerun_device_t *hd)
{
  if(!(hd->cs == ((struct hdhomerun_control_sock_t *)NULL)))
  {
    unsigned int return_value_hdhomerun_control_get_local_addr_1;
    return_value_hdhomerun_control_get_local_addr_1=hdhomerun_control_get_local_addr(hd->cs);
    return return_value_hdhomerun_control_get_local_addr_1;
  }

  return (unsigned int)0;
}

// hdhomerun_device_get_model_str
// file hdhomerun_device.h line 128
extern const char * hdhomerun_device_get_model_str(struct hdhomerun_device_t *hd)
{
  if(!(hd->model[0l] == 0))
    return hd->model;

  else
    if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
    {
      hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_model_str: device not set\n");
      return (const char *)(void *)0;
    }

    else
    {
      char *model_str;
      signed int ret;
      ret=hdhomerun_control_get(hd->cs, "/sys/model", &model_str, (char **)(void *)0);
      if(!(ret >= 0))
        return (const char *)(void *)0;

      else
        if(ret == 0)
        {
          hdhomerun_sprintf(hd->model, hd->model + (signed long int)sizeof(char [32l]) /*32ul*/ , "hdhomerun_atsc");
          return hd->model;
        }

        else
        {
          hdhomerun_sprintf(hd->model, hd->model + (signed long int)sizeof(char [32l]) /*32ul*/ , "%s", model_str);
          return hd->model;
        }
    }
}

// hdhomerun_device_get_name
// file hdhomerun_device.c line 280
extern const char * hdhomerun_device_get_name(struct hdhomerun_device_t *hd)
{
  return hd->name;
}

// hdhomerun_device_get_oob_plotsample
// file hdhomerun_device.c line 745
extern signed int hdhomerun_device_get_oob_plotsample(struct hdhomerun_device_t *hd, struct hdhomerun_plotsample_t **psamples, unsigned long int *pcount)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_oob_plotsample: device not set\n");
    return -1;
  }

  else
  {
    signed int return_value_hdhomerun_device_get_tuner_plotsample_internal_1;
    return_value_hdhomerun_device_get_tuner_plotsample_internal_1=hdhomerun_device_get_tuner_plotsample_internal(hd, "/oob/plotsample", psamples, pcount);
    return return_value_hdhomerun_device_get_tuner_plotsample_internal_1;
  }
}

// hdhomerun_device_get_oob_status
// file hdhomerun_device.c line 494
extern signed int hdhomerun_device_get_oob_status(struct hdhomerun_device_t *hd, char **pstatus_str, struct hdhomerun_tuner_status_t *status)
{
  signed int tmp_statement_expression_3;
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_oob_status: device not set\n");
    return -1;
  }

  else
  {
    memset((void *)status, 0, sizeof(struct hdhomerun_tuner_status_t) /*96ul*/ );
    char *status_str;
    signed int ret;
    ret=hdhomerun_control_get(hd->cs, "/oob/status", &status_str, (char **)(void *)0);
    if(!(ret >= 1))
      return ret;

    else
    {
      if(!(pstatus_str == ((char **)NULL)))
        *pstatus_str = status_str;

      if(!(status == ((struct hdhomerun_tuner_status_t *)NULL)))
      {
        char *channel;
        channel=strstr(status_str, "ch=");
        if(!(channel == ((char *)NULL)))
          sscanf(channel + (signed long int)3, "%31s", (const void *)status->channel);

        char *lock;
        lock=strstr(status_str, "lock=");
        if(!(lock == ((char *)NULL)))
          sscanf(lock + (signed long int)5, "%31s", (const void *)status->lock_str);

        unsigned int return_value_hdhomerun_device_get_status_parse_1;
        return_value_hdhomerun_device_get_status_parse_1=hdhomerun_device_get_status_parse(status_str, "ss=");
        status->signal_strength = (unsigned int)return_value_hdhomerun_device_get_status_parse_1;
        unsigned int return_value_hdhomerun_device_get_status_parse_2;
        return_value_hdhomerun_device_get_status_parse_2=hdhomerun_device_get_status_parse(status_str, "snq=");
        status->signal_to_noise_quality = (unsigned int)return_value_hdhomerun_device_get_status_parse_2;
        status->signal_present = (signed int)(status->signal_strength >= (unsigned int)45);
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp_4;
        return_value___builtin_strcmp_4=__builtin_strcmp(status->lock_str, "none");
        tmp_statement_expression_3 = return_value___builtin_strcmp_4;
        status->lock_supported = (signed int)(tmp_statement_expression_3 != 0);
      }

      return 1;
    }
  }
}

// hdhomerun_device_get_status_parse
// file hdhomerun_device.c line 362
static unsigned int hdhomerun_device_get_status_parse(const char *status_str, const char *tag)
{
  const char *ptr;
  ptr=strstr(status_str, tag);
  if(ptr == ((const char *)NULL))
    return (unsigned int)0;

  else
  {
    unsigned int value = (unsigned int)0;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(tag);
    sscanf(ptr + (signed long int)return_value_strlen_1, "%u", &value);
    return (unsigned int)value;
  }
}

// hdhomerun_device_get_supported
// file hdhomerun_device.c line 806
extern signed int hdhomerun_device_get_supported(struct hdhomerun_device_t *hd, char *prefix, char **pstr)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_tuner_channel: device not set\n");
    return -1;
  }

  else
  {
    char *features;
    signed int ret;
    ret=hdhomerun_control_get(hd->cs, "/sys/features", &features, (char **)(void *)0);
    if(!(ret >= 1))
      return ret;

    else
      if(prefix == ((char *)NULL))
      {
        *pstr = features;
        return 1;
      }

      else
      {
        char *ptr;
        ptr=strstr(features, prefix);
        if(ptr == ((char *)NULL))
          return 0;

        else
        {
          unsigned long int return_value_strlen_1;
          return_value_strlen_1=strlen(prefix);
          ptr = ptr + (signed long int)return_value_strlen_1;
          *pstr = ptr;
          char *return_value___builtin_strchr_2;
          return_value___builtin_strchr_2=__builtin_strchr(ptr, 10);
          ptr = return_value___builtin_strchr_2;
          if(!(ptr == ((char *)NULL)))
            *ptr = (char)0;

          return 1;
        }
      }
  }
}

// hdhomerun_device_get_tuner
// file hdhomerun_device.c line 326
extern unsigned int hdhomerun_device_get_tuner(struct hdhomerun_device_t *hd)
{
  return hd->tuner;
}

// hdhomerun_device_get_tuner_channel
// file hdhomerun_device.c line 615
extern signed int hdhomerun_device_get_tuner_channel(struct hdhomerun_device_t *hd, char **pchannel)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_tuner_channel: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/channel", hd->tuner);
    signed int return_value_hdhomerun_control_get_1;
    return_value_hdhomerun_control_get_1=hdhomerun_control_get(hd->cs, name, pchannel, (char **)(void *)0);
    return return_value_hdhomerun_control_get_1;
  }
}

// hdhomerun_device_get_tuner_channelmap
// file hdhomerun_device.h line 111
extern signed int hdhomerun_device_get_tuner_channelmap(struct hdhomerun_device_t *hd, char **pchannelmap)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_tuner_channelmap: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/channelmap", hd->tuner);
    signed int return_value_hdhomerun_control_get_1;
    return_value_hdhomerun_control_get_1=hdhomerun_control_get(hd->cs, name, pchannelmap, (char **)(void *)0);
    return return_value_hdhomerun_control_get_1;
  }
}

// hdhomerun_device_get_tuner_filter
// file hdhomerun_device.c line 651
extern signed int hdhomerun_device_get_tuner_filter(struct hdhomerun_device_t *hd, char **pfilter)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_tuner_filter: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/filter", hd->tuner);
    signed int return_value_hdhomerun_control_get_1;
    return_value_hdhomerun_control_get_1=hdhomerun_control_get(hd->cs, name, pfilter, (char **)(void *)0);
    return return_value_hdhomerun_control_get_1;
  }
}

// hdhomerun_device_get_tuner_lockkey_owner
// file hdhomerun_device.c line 755
extern signed int hdhomerun_device_get_tuner_lockkey_owner(struct hdhomerun_device_t *hd, char **powner)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_tuner_lockkey_owner: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/lockkey", hd->tuner);
    signed int return_value_hdhomerun_control_get_1;
    return_value_hdhomerun_control_get_1=hdhomerun_control_get(hd->cs, name, powner, (char **)(void *)0);
    return return_value_hdhomerun_control_get_1;
  }
}

// hdhomerun_device_get_tuner_plotsample
// file hdhomerun_device.c line 733
extern signed int hdhomerun_device_get_tuner_plotsample(struct hdhomerun_device_t *hd, struct hdhomerun_plotsample_t **psamples, unsigned long int *pcount)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_tuner_plotsample: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/plotsample", hd->tuner);
    signed int return_value_hdhomerun_device_get_tuner_plotsample_internal_1;
    return_value_hdhomerun_device_get_tuner_plotsample_internal_1=hdhomerun_device_get_tuner_plotsample_internal(hd, name, psamples, pcount);
    return return_value_hdhomerun_device_get_tuner_plotsample_internal_1;
  }
}

// hdhomerun_device_get_tuner_plotsample_internal
// file hdhomerun_device.c line 687
static signed int hdhomerun_device_get_tuner_plotsample_internal(struct hdhomerun_device_t *hd, const char *name, struct hdhomerun_plotsample_t **psamples, unsigned long int *pcount)
{
  char *result;
  signed int ret;
  ret=hdhomerun_control_get(hd->cs, name, &result, (char **)(void *)0);
  char *tmp_post_2;
  if(!(ret >= 1))
    return ret;

  else
  {
    struct hdhomerun_plotsample_t *samples = (struct hdhomerun_plotsample_t *)result;
    *psamples = samples;
    unsigned long int count = (unsigned long int)0;
    while((_Bool)1)
    {
      char *ptr;
      char *return_value___builtin_strchr_1;
      return_value___builtin_strchr_1=__builtin_strchr(result, 32);
      ptr = return_value___builtin_strchr_1;
      if(ptr == ((char *)NULL))
        break;

      tmp_post_2 = ptr;
      ptr = ptr + 1l;
      *tmp_post_2 = (char)0;
      unsigned int raw;
      signed int return_value_sscanf_3;
      return_value_sscanf_3=sscanf(result, "%x", &raw);
      if(!(return_value_sscanf_3 == 1))
        break;

      unsigned short int real = (unsigned short int)(raw >> 12 & (unsigned int)0x0FFF);
      if(!((0x0800 & (signed int)real) == 0))
        real = real | (unsigned short int)0xF000;

      unsigned short int imag = (unsigned short int)(raw >> 0 & (unsigned int)0x0FFF);
      if(!((0x0800 & (signed int)imag) == 0))
        imag = imag | (unsigned short int)0xF000;

      samples->real = (signed short int)real;
      samples->imag = (signed short int)imag;
      samples = samples + 1l;
      count = count + 1ul;
      result = ptr;
    }
    *pcount = count;
    return 1;
  }
}

// hdhomerun_device_get_tuner_program
// file hdhomerun_device.c line 663
extern signed int hdhomerun_device_get_tuner_program(struct hdhomerun_device_t *hd, char **pprogram)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_tuner_program: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/program", hd->tuner);
    signed int return_value_hdhomerun_control_get_1;
    return_value_hdhomerun_control_get_1=hdhomerun_control_get(hd->cs, name, pprogram, (char **)(void *)0);
    return return_value_hdhomerun_control_get_1;
  }
}

// hdhomerun_device_get_tuner_status
// file hdhomerun_device.h line 106
extern signed int hdhomerun_device_get_tuner_status(struct hdhomerun_device_t *hd, char **pstatus_str, struct hdhomerun_tuner_status_t *status)
{
  signed int tmp_statement_expression_4;
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_tuner_status: device not set\n");
    return -1;
  }

  else
  {
    memset((void *)status, 0, sizeof(struct hdhomerun_tuner_status_t) /*96ul*/ );
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/status", hd->tuner);
    char *status_str;
    signed int ret;
    ret=hdhomerun_control_get(hd->cs, name, &status_str, (char **)(void *)0);
    if(!(ret >= 1))
      return ret;

    else
    {
      if(!(pstatus_str == ((char **)NULL)))
        *pstatus_str = status_str;

      if(!(status == ((struct hdhomerun_tuner_status_t *)NULL)))
      {
        char *channel;
        channel=strstr(status_str, "ch=");
        if(!(channel == ((char *)NULL)))
          sscanf(channel + (signed long int)3, "%31s", (const void *)status->channel);

        char *lock;
        lock=strstr(status_str, "lock=");
        if(!(lock == ((char *)NULL)))
          sscanf(lock + (signed long int)5, "%31s", (const void *)status->lock_str);

        unsigned int return_value_hdhomerun_device_get_status_parse_1;
        return_value_hdhomerun_device_get_status_parse_1=hdhomerun_device_get_status_parse(status_str, "ss=");
        status->signal_strength = (unsigned int)return_value_hdhomerun_device_get_status_parse_1;
        unsigned int return_value_hdhomerun_device_get_status_parse_2;
        return_value_hdhomerun_device_get_status_parse_2=hdhomerun_device_get_status_parse(status_str, "snq=");
        status->signal_to_noise_quality = (unsigned int)return_value_hdhomerun_device_get_status_parse_2;
        unsigned int return_value_hdhomerun_device_get_status_parse_3;
        return_value_hdhomerun_device_get_status_parse_3=hdhomerun_device_get_status_parse(status_str, "seq=");
        status->symbol_error_quality = (unsigned int)return_value_hdhomerun_device_get_status_parse_3;
        status->raw_bits_per_second=hdhomerun_device_get_status_parse(status_str, "bps=");
        status->packets_per_second=hdhomerun_device_get_status_parse(status_str, "pps=");
        status->signal_present = (signed int)(status->signal_strength >= (unsigned int)45);
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp_5;
        return_value___builtin_strcmp_5=__builtin_strcmp(status->lock_str, "none");
        tmp_statement_expression_4 = return_value___builtin_strcmp_5;
        if(!(tmp_statement_expression_4 == 0))
        {
          if((signed int)status->lock_str[0l] == 40)
            status->lock_unsupported = 1;

          else
            status->lock_supported = 1;
        }

      }

      return 1;
    }
  }
}

// hdhomerun_device_get_tuner_status_lock_is_bcast
// file hdhomerun_device.c line 375
static signed int hdhomerun_device_get_tuner_status_lock_is_bcast(struct hdhomerun_tuner_status_t *status)
{
  signed int tmp_statement_expression_1;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp_2;
  return_value___builtin_strcmp_2=__builtin_strcmp(status->lock_str, "8vsb");
  tmp_statement_expression_1 = return_value___builtin_strcmp_2;
  if(tmp_statement_expression_1 == 0)
    return 1;

  else
  {
    signed int return_value_strncmp_3;
    return_value_strncmp_3=strncmp(status->lock_str, "t8", (unsigned long int)2);
    if(return_value_strncmp_3 == 0)
      return 1;

    else
    {
      signed int return_value_strncmp_4;
      return_value_strncmp_4=strncmp(status->lock_str, "t7", (unsigned long int)2);
      if(return_value_strncmp_4 == 0)
        return 1;

      else
      {
        signed int return_value_strncmp_5;
        return_value_strncmp_5=strncmp(status->lock_str, "t6", (unsigned long int)2);
        if(return_value_strncmp_5 == 0)
          return 1;

        else
          return 0;
      }
    }
  }
}

// hdhomerun_device_get_tuner_status_seq_color
// file hdhomerun_device.c line 432
extern unsigned int hdhomerun_device_get_tuner_status_seq_color(struct hdhomerun_tuner_status_t *status)
{
  if(status->symbol_error_quality >= 100u)
    return 0xFF00C000;

  else
    return 0xFFFF0000;
}

// hdhomerun_device_get_tuner_status_snq_color
// file hdhomerun_device.c line 420
extern unsigned int hdhomerun_device_get_tuner_status_snq_color(struct hdhomerun_tuner_status_t *status)
{
  if(status->signal_to_noise_quality >= 70u)
    return 0xFF00C000;

  else
    if(status->signal_to_noise_quality >= 50u)
      return 0xFFFFFF00;

    else
      return 0xFFFF0000;
}

// hdhomerun_device_get_tuner_status_ss_color
// file hdhomerun_device.c line 393
extern unsigned int hdhomerun_device_get_tuner_status_ss_color(struct hdhomerun_tuner_status_t *status)
{
  unsigned int ss_yellow_min;
  unsigned int ss_green_min;
  if(status->lock_supported == 0)
    return 0xFFFFFFFF;

  else
  {
    signed int return_value_hdhomerun_device_get_tuner_status_lock_is_bcast_1;
    return_value_hdhomerun_device_get_tuner_status_lock_is_bcast_1=hdhomerun_device_get_tuner_status_lock_is_bcast(status);
    if(!(return_value_hdhomerun_device_get_tuner_status_lock_is_bcast_1 == 0))
    {
      ss_yellow_min = (unsigned int)50;
      ss_green_min = (unsigned int)75;
    }

    else
    {
      ss_yellow_min = (unsigned int)80;
      ss_green_min = (unsigned int)90;
    }
    if(status->signal_strength >= ss_green_min)
      return 0xFF00C000;

    else
      if(status->signal_strength >= ss_yellow_min)
        return 0xFFFFFF00;

      else
        return 0xFFFF0000;
  }
}

// hdhomerun_device_get_tuner_streaminfo
// file hdhomerun_device.h line 108
extern signed int hdhomerun_device_get_tuner_streaminfo(struct hdhomerun_device_t *hd, char **pstreaminfo)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_tuner_streaminfo: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/streaminfo", hd->tuner);
    signed int return_value_hdhomerun_control_get_1;
    return_value_hdhomerun_control_get_1=hdhomerun_control_get(hd->cs, name, pstreaminfo, (char **)(void *)0);
    return return_value_hdhomerun_control_get_1;
  }
}

// hdhomerun_device_get_tuner_target
// file hdhomerun_device.c line 675
extern signed int hdhomerun_device_get_tuner_target(struct hdhomerun_device_t *hd, char **ptarget)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_tuner_target: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/target", hd->tuner);
    signed int return_value_hdhomerun_control_get_1;
    return_value_hdhomerun_control_get_1=hdhomerun_control_get(hd->cs, name, ptarget, (char **)(void *)0);
    return return_value_hdhomerun_control_get_1;
  }
}

// hdhomerun_device_get_tuner_vchannel
// file hdhomerun_device.c line 627
extern signed int hdhomerun_device_get_tuner_vchannel(struct hdhomerun_device_t *hd, char **pvchannel)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_tuner_vchannel: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/vchannel", hd->tuner);
    signed int return_value_hdhomerun_control_get_1;
    return_value_hdhomerun_control_get_1=hdhomerun_control_get(hd->cs, name, pvchannel, (char **)(void *)0);
    return return_value_hdhomerun_control_get_1;
  }
}

// hdhomerun_device_get_tuner_vstatus
// file hdhomerun_device.c line 533
extern signed int hdhomerun_device_get_tuner_vstatus(struct hdhomerun_device_t *hd, char **pvstatus_str, struct hdhomerun_tuner_vstatus_t *vstatus)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_tuner_vstatus: device not set\n");
    return -1;
  }

  else
  {
    memset((void *)vstatus, 0, sizeof(struct hdhomerun_tuner_vstatus_t) /*172ul*/ );
    char var_name[32l];
    hdhomerun_sprintf(var_name, var_name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/vstatus", hd->tuner);
    char *vstatus_str;
    signed int ret;
    ret=hdhomerun_control_get(hd->cs, var_name, &vstatus_str, (char **)(void *)0);
    if(!(ret >= 1))
      return ret;

    else
    {
      if(!(pvstatus_str == ((char **)NULL)))
        *pvstatus_str = vstatus_str;

      if(!(vstatus == ((struct hdhomerun_tuner_vstatus_t *)NULL)))
      {
        char *vch;
        vch=strstr(vstatus_str, "vch=");
        if(!(vch == ((char *)NULL)))
          sscanf(vch + (signed long int)4, "%31s", (const void *)vstatus->vchannel);

        char *name;
        name=strstr(vstatus_str, "name=");
        if(!(name == ((char *)NULL)))
          sscanf(name + (signed long int)5, "%31s", (const void *)vstatus->name);

        char *auth;
        auth=strstr(vstatus_str, "auth=");
        if(!(auth == ((char *)NULL)))
          sscanf(auth + (signed long int)5, "%31s", (const void *)vstatus->auth);

        char *cci;
        cci=strstr(vstatus_str, "cci=");
        if(!(cci == ((char *)NULL)))
          sscanf(cci + (signed long int)4, "%31s", (const void *)vstatus->cci);

        char *cgms;
        cgms=strstr(vstatus_str, "cgms=");
        if(!(cgms == ((char *)NULL)))
          sscanf(cgms + (signed long int)5, "%31s", (const void *)vstatus->cgms);

        signed int return_value_strncmp_1;
        return_value_strncmp_1=strncmp(vstatus->auth, "not-subscribed", (unsigned long int)14);
        if(return_value_strncmp_1 == 0)
          vstatus->not_subscribed = 1;

        signed int return_value_strncmp_2;
        return_value_strncmp_2=strncmp(vstatus->auth, "error", (unsigned long int)5);
        if(return_value_strncmp_2 == 0)
          vstatus->not_available = 1;

        signed int return_value_strncmp_3;
        return_value_strncmp_3=strncmp(vstatus->auth, "dialog", (unsigned long int)6);
        if(return_value_strncmp_3 == 0)
          vstatus->not_available = 1;

        signed int return_value_strncmp_4;
        return_value_strncmp_4=strncmp(vstatus->cci, "protected", (unsigned long int)9);
        if(return_value_strncmp_4 == 0)
          vstatus->copy_protected = 1;

        signed int return_value_strncmp_5;
        return_value_strncmp_5=strncmp(vstatus->cgms, "protected", (unsigned long int)9);
        if(return_value_strncmp_5 == 0)
          vstatus->copy_protected = 1;

      }

      return 1;
    }
  }
}

// hdhomerun_device_get_var
// file hdhomerun_device.h line 166
extern signed int hdhomerun_device_get_var(struct hdhomerun_device_t *hd, const char *name, char **pvalue, char **perror)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_var: device not set\n");
    return -1;
  }

  else
  {
    signed int return_value_hdhomerun_control_get_1;
    return_value_hdhomerun_control_get_1=hdhomerun_control_get(hd->cs, name, pvalue, perror);
    return return_value_hdhomerun_control_get_1;
  }
}

// hdhomerun_device_get_version
// file hdhomerun_device.h line 120
extern signed int hdhomerun_device_get_version(struct hdhomerun_device_t *hd, char **pversion_str, unsigned int *pversion_num)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_version: device not set\n");
    return -1;
  }

  else
  {
    char *version_str;
    signed int ret;
    ret=hdhomerun_control_get(hd->cs, "/sys/version", &version_str, (char **)(void *)0);
    if(!(ret >= 1))
      return ret;

    else
    {
      if(!(pversion_str == ((char **)NULL)))
        *pversion_str = version_str;

      if(!(pversion_num == ((unsigned int *)NULL)))
      {
        unsigned int version_num;
        signed int return_value_sscanf_1;
        return_value_sscanf_1=sscanf(version_str, "%u", &version_num);
        if(!(return_value_sscanf_1 == 1))
          *pversion_num = (unsigned int)0;

        else
          *pversion_num = (unsigned int)version_num;
      }

      return 1;
    }
  }
}

// hdhomerun_device_get_video_sock
// file hdhomerun_device.c line 336
extern struct hdhomerun_video_sock_t * hdhomerun_device_get_video_sock(struct hdhomerun_device_t *hd)
{
  if(!(hd->vs == ((struct hdhomerun_video_sock_t *)NULL)))
    return hd->vs;

  else
  {
    signed int allow_port_reuse = (signed int)((signed int)hd->multicast_port != 0);
    hd->vs=hdhomerun_video_create(hd->multicast_port, allow_port_reuse, (unsigned long int)((20000000 / 8) * 2), hd->dbg);
    if(hd->vs == ((struct hdhomerun_video_sock_t *)NULL))
    {
      hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_get_video_sock: failed to create video object\n");
      return (struct hdhomerun_video_sock_t *)(void *)0;
    }

    else
      return hd->vs;
  }
}

// hdhomerun_device_get_video_stats
// file hdhomerun_device.h line 253
extern void hdhomerun_device_get_video_stats(struct hdhomerun_device_t *hd, struct hdhomerun_video_stats_t *stats)
{
  if(hd->vs == ((struct hdhomerun_video_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_stream_flush: video not initialized\n");
    memset((void *)stats, 0, sizeof(struct hdhomerun_video_stats_t) /*20ul*/ );
  }

  else
    hdhomerun_video_get_stats(hd->vs, stats);
}

// hdhomerun_device_selector_add_device
// file hdhomerun_device_selector.c line 64
extern void hdhomerun_device_selector_add_device(struct hdhomerun_device_selector_t *hds, struct hdhomerun_device_t *hd)
{
  unsigned long int index = (unsigned long int)0;
  for( ; !(index >= hds->hd_count); index = index + 1ul)
  {
    struct hdhomerun_device_t *entry = hds->hd_list[(signed long int)index];
    if(entry == hd)
      goto __CPROVER_DUMP_L5;

  }
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)hds->hd_list, (hds->hd_count + (unsigned long int)1) * sizeof(struct hdhomerun_device_selector_t *) /*8ul*/ );
  hds->hd_list = (struct hdhomerun_device_t **)return_value_realloc_1;
  unsigned long int tmp_post_2;
  if(hds->hd_list == ((struct hdhomerun_device_t **)NULL))
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_add_device: failed to allocate device list\n");

  else
  {
    tmp_post_2 = hds->hd_count;
    hds->hd_count = hds->hd_count + 1ul;
    hds->hd_list[(signed long int)tmp_post_2] = hd;
  }

__CPROVER_DUMP_L5:
  ;
}

// hdhomerun_device_selector_choose_and_lock
// file hdhomerun_device_selector.c line 423
extern struct hdhomerun_device_t * hdhomerun_device_selector_choose_and_lock(struct hdhomerun_device_selector_t *hds, struct hdhomerun_device_t *prefered)
{
  if(!(prefered == ((struct hdhomerun_device_t *)NULL)))
  {
    signed int return_value_hdhomerun_device_selector_choose_test_1;
    return_value_hdhomerun_device_selector_choose_test_1=hdhomerun_device_selector_choose_test(hds, prefered);
    if(!(return_value_hdhomerun_device_selector_choose_test_1 == 0))
      return prefered;

  }

  unsigned long int index = (unsigned long int)0;
  for( ; !(index >= hds->hd_count); index = index + 1ul)
  {
    struct hdhomerun_device_t *entry = hds->hd_list[(signed long int)index];
    if(!(entry == prefered))
    {
      signed int return_value_hdhomerun_device_selector_choose_test_2;
      return_value_hdhomerun_device_selector_choose_test_2=hdhomerun_device_selector_choose_test(hds, entry);
      if(!(return_value_hdhomerun_device_selector_choose_test_2 == 0))
        return entry;

    }

  }
  hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_and_lock: no devices available\n");
  return (struct hdhomerun_device_t *)(void *)0;
}

// hdhomerun_device_selector_choose_test
// file hdhomerun_device_selector.c line 318
static signed int hdhomerun_device_selector_choose_test(struct hdhomerun_device_selector_t *hds, struct hdhomerun_device_t *test_hd)
{
  const char *name;
  name=hdhomerun_device_get_name(test_hd);
  char *error;
  signed int ret;
  ret=hdhomerun_device_tuner_lockkey_request(test_hd, &error);
  signed int tmp_statement_expression_1;
  signed int return_value_strncmp_3;
  if(ret >= 1)
  {
    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s chosen\n", name);
    return 1;
  }

  else
    if(!(ret >= 0))
    {
      hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s communication error\n", name);
      return 0;
    }

    else
    {
      char *target;
      ret=hdhomerun_device_get_tuner_target(test_hd, &target);
      if(!(ret >= 0))
      {
        hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s communication error\n", name);
        return 0;
      }

      else
        if(ret == 0)
        {
          hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use, failed to read target\n", name);
          return 0;
        }

        else
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp_2;
          return_value___builtin_strcmp_2=__builtin_strcmp(target, "none");
          tmp_statement_expression_1 = return_value___builtin_strcmp_2;
          if(tmp_statement_expression_1 == 0)
          {
            hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use, no target set\n", name);
            return 0;
          }

          else
          {
            signed int return_value_strncmp_4;
            return_value_strncmp_4=strncmp(target, "udp://", (unsigned long int)6);
            if(!(return_value_strncmp_4 == 0))
            {
              return_value_strncmp_3=strncmp(target, "rtp://", (unsigned long int)6);
              if(return_value_strncmp_3 == 0)
                goto __CPROVER_DUMP_L6;

              hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use by %s\n", name, target);
              return 0;
            }

            else
            {

            __CPROVER_DUMP_L6:
              ;
              unsigned int a[4l];
              unsigned int target_port;
              signed int return_value_sscanf_5;
              return_value_sscanf_5=sscanf(target + (signed long int)6, "%u.%u.%u.%u:%u", &a[(signed long int)0], &a[(signed long int)1], &a[(signed long int)2], &a[(signed long int)3], &target_port);
              if(!(return_value_sscanf_5 == 5))
              {
                hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use, unexpected target set (%s)\n", name, target);
                return 0;
              }

              else
              {
                unsigned int target_ip = (unsigned int)(a[(signed long int)0] << 24 | a[(signed long int)1] << 16 | a[(signed long int)2] << 8 | a[(signed long int)3] << 0);
                unsigned int local_ip;
                local_ip=hdhomerun_device_get_local_machine_addr(test_hd);
                if(!(target_ip == local_ip))
                {
                  hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use by %s\n", name, target);
                  return 0;
                }

                else
                {
                  signed int test_sock;
                  test_sock=hdhomerun_sock_create_udp();
                  if(test_sock == -1)
                  {
                    hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use, failed to create test sock\n", name);
                    return 0;
                  }

                  else
                  {
                    signed int inuse;
                    signed int return_value_hdhomerun_sock_bind_6;
                    return_value_hdhomerun_sock_bind_6=hdhomerun_sock_bind(test_sock, (unsigned int)0x00000000, (unsigned short int)target_port, 0);
                    inuse = (signed int)(return_value_hdhomerun_sock_bind_6 == 0);
                    hdhomerun_sock_destroy(test_sock);
                    if(!(inuse == 0))
                    {
                      hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use by local machine\n", name);
                      return 0;
                    }

                    else
                    {
                      ret=hdhomerun_device_tuner_lockkey_force(test_hd);
                      if(!(ret >= 0))
                      {
                        hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s communication error\n", name);
                        return 0;
                      }

                      else
                        if(ret == 0)
                        {
                          hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use by local machine, dead target, failed to force release lockkey\n", name);
                          return 0;
                        }

                        else
                        {
                          hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s in use by local machine, dead target, lockkey force successful\n", name);
                          ret=hdhomerun_device_tuner_lockkey_request(test_hd, &error);
                          if(ret >= 1)
                          {
                            hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s chosen\n", name);
                            return 1;
                          }

                          else
                            if(!(ret >= 0))
                            {
                              hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s communication error\n", name);
                              return 0;
                            }

                            else
                            {
                              hdhomerun_debug_printf(hds->dbg, "hdhomerun_device_selector_choose_test: device %s still in use after lockkey force (%s)\n", name, error);
                              return 0;
                            }
                        }
                    }
                  }
                }
              }
            }
          }
        }
    }
}

// hdhomerun_device_selector_create
// file hdhomerun_device_selector.c line 29
extern struct hdhomerun_device_selector_t * hdhomerun_device_selector_create(struct hdhomerun_debug_t *dbg)
{
  struct hdhomerun_device_selector_t *hds;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct hdhomerun_device_selector_t) /*24ul*/ );
  hds = (struct hdhomerun_device_selector_t *)return_value_calloc_1;
  if(hds == ((struct hdhomerun_device_selector_t *)NULL))
  {
    hdhomerun_debug_printf(dbg, "hdhomerun_device_selector_create: failed to allocate selector object\n");
    return (struct hdhomerun_device_selector_t *)(void *)0;
  }

  else
  {
    hds->dbg = dbg;
    return hds;
  }
}

// hdhomerun_device_selector_destroy
// file hdhomerun_device_selector.c line 42
extern void hdhomerun_device_selector_destroy(struct hdhomerun_device_selector_t *hds, signed int destroy_devices)
{
  if(!(destroy_devices == 0))
  {
    unsigned long int index = (unsigned long int)0;
    for( ; !(index >= hds->hd_count); index = index + 1ul)
    {
      struct hdhomerun_device_t *entry = hds->hd_list[(signed long int)index];
      hdhomerun_device_destroy(entry);
    }
  }

  if(!(hds->hd_list == ((struct hdhomerun_device_t **)NULL)))
    free((void *)hds->hd_list);

  free((void *)hds);
}

// hdhomerun_device_selector_find_device
// file hdhomerun_device_selector.c line 108
extern struct hdhomerun_device_t * hdhomerun_device_selector_find_device(struct hdhomerun_device_selector_t *hds, unsigned int device_id, unsigned int tuner_index)
{
  unsigned long int index = (unsigned long int)0;
  for( ; !(index >= hds->hd_count); index = index + 1ul)
  {
    struct hdhomerun_device_t *entry = hds->hd_list[(signed long int)index];
    unsigned int return_value_hdhomerun_device_get_device_id_1;
    return_value_hdhomerun_device_get_device_id_1=hdhomerun_device_get_device_id(entry);
    if(return_value_hdhomerun_device_get_device_id_1 == device_id)
    {
      unsigned int return_value_hdhomerun_device_get_tuner_2;
      return_value_hdhomerun_device_get_tuner_2=hdhomerun_device_get_tuner(entry);
      if(return_value_hdhomerun_device_get_tuner_2 == tuner_index)
        return entry;

    }

  }
  return (struct hdhomerun_device_t *)(void *)0;
}

// hdhomerun_device_selector_get_device_count
// file hdhomerun_device_selector.c line 59
extern signed int hdhomerun_device_selector_get_device_count(struct hdhomerun_device_selector_t *hds)
{
  return (signed int)hds->hd_count;
}

// hdhomerun_device_selector_load_from_file
// file hdhomerun_device_selector.c line 245
extern signed int hdhomerun_device_selector_load_from_file(struct hdhomerun_device_selector_t *hds, char *filename)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "r");
  if(fp == ((struct _IO_FILE *)NULL))
    return 0;

  else
  {
    signed int count = 0;
    while((_Bool)1)
    {
      char device_str[32l];
      char *return_value_fgets_1;
      return_value_fgets_1=fgets(device_str, (signed int)sizeof(char [32l]) /*32ul*/ , fp);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      signed int return_value_hdhomerun_device_selector_load_from_str_2;
      return_value_hdhomerun_device_selector_load_from_str_2=hdhomerun_device_selector_load_from_str(hds, device_str);
      count = count + return_value_hdhomerun_device_selector_load_from_str_2;
    }
    fclose(fp);
    return count;
  }
}

// hdhomerun_device_selector_load_from_str
// file hdhomerun_device_selector.c line 151
extern signed int hdhomerun_device_selector_load_from_str(struct hdhomerun_device_selector_t *hds, char *device_str)
{
  unsigned int a[4l];
  signed int return_value_sscanf_4;
  return_value_sscanf_4=sscanf(device_str, "%u.%u.%u.%u", &a[(signed long int)0], &a[(signed long int)1], &a[(signed long int)2], &a[(signed long int)3]);
  if(return_value_sscanf_4 == 4)
  {
    unsigned int ip_addr = (unsigned int)(a[(signed long int)0] << 24 | a[(signed long int)1] << 16 | a[(signed long int)2] << 8 | a[(signed long int)3] << 0);
    unsigned int port;
    signed int return_value_sscanf_1;
    return_value_sscanf_1=sscanf(device_str, "%u.%u.%u.%u:%u", &a[(signed long int)0], &a[(signed long int)1], &a[(signed long int)2], &a[(signed long int)3], &port);
    if(return_value_sscanf_1 == 5)
    {
      struct hdhomerun_device_t *hdhomerun_device_selector_load_from_str__1__1__1__hd;
      hdhomerun_device_selector_load_from_str__1__1__1__hd=hdhomerun_device_create_multicast(ip_addr, (unsigned short int)port, hds->dbg);
      if(hdhomerun_device_selector_load_from_str__1__1__1__hd == ((struct hdhomerun_device_t *)NULL))
        return 0;

      hdhomerun_device_selector_add_device(hds, hdhomerun_device_selector_load_from_str__1__1__1__hd);
      return 1;
    }

    unsigned int tuner;
    signed int return_value_sscanf_2;
    return_value_sscanf_2=sscanf(device_str, "%u.%u.%u.%u-%u", &a[(signed long int)0], &a[(signed long int)1], &a[(signed long int)2], &a[(signed long int)3], &tuner);
    if(return_value_sscanf_2 == 5)
    {
      struct hdhomerun_device_t *hdhomerun_device_selector_load_from_str__1__1__2__hd;
      hdhomerun_device_selector_load_from_str__1__1__2__hd=hdhomerun_device_create(0xFFFFFFFF, ip_addr, tuner, hds->dbg);
      if(hdhomerun_device_selector_load_from_str__1__1__2__hd == ((struct hdhomerun_device_t *)NULL))
        return 0;

      hdhomerun_device_selector_add_device(hds, hdhomerun_device_selector_load_from_str__1__1__2__hd);
      return 1;
    }

    signed int return_value_hdhomerun_device_selector_load_from_str_discover_3;
    return_value_hdhomerun_device_selector_load_from_str_discover_3=hdhomerun_device_selector_load_from_str_discover(hds, ip_addr, 0xFFFFFFFF);
    return return_value_hdhomerun_device_selector_load_from_str_discover_3;
  }

  char *end;
  unsigned int device_id;
  unsigned long int return_value_strtoul_5;
  return_value_strtoul_5=strtoul(device_str, &end, 16);
  device_id = (unsigned int)return_value_strtoul_5;
  signed int return_value_hdhomerun_discover_validate_device_id_8;
  if(end == device_str + 8l)
  {
    return_value_hdhomerun_discover_validate_device_id_8=hdhomerun_discover_validate_device_id(device_id);
    if(!(return_value_hdhomerun_discover_validate_device_id_8 == 0))
    {
      if((signed int)*end == 45)
      {
        unsigned int hdhomerun_device_selector_load_from_str__1__2__1__tuner;
        unsigned long int return_value_strtoul_6;
        return_value_strtoul_6=strtoul(end + (signed long int)1, (char ** restrict )(void *)0, 10);
        hdhomerun_device_selector_load_from_str__1__2__1__tuner = (unsigned int)return_value_strtoul_6;
        struct hdhomerun_device_t *hdhomerun_device_selector_load_from_str__1__2__1__hd;
        hdhomerun_device_selector_load_from_str__1__2__1__hd=hdhomerun_device_create(device_id, (unsigned int)0, hdhomerun_device_selector_load_from_str__1__2__1__tuner, hds->dbg);
        if(hdhomerun_device_selector_load_from_str__1__2__1__hd == ((struct hdhomerun_device_t *)NULL))
          return 0;

        hdhomerun_device_selector_add_device(hds, hdhomerun_device_selector_load_from_str__1__2__1__hd);
        return 1;
      }

      signed int return_value_hdhomerun_device_selector_load_from_str_discover_7;
      return_value_hdhomerun_device_selector_load_from_str_discover_7=hdhomerun_device_selector_load_from_str_discover(hds, (unsigned int)0, device_id);
      return return_value_hdhomerun_device_selector_load_from_str_discover_7;
    }

  }

  struct addrinfo hints;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 2;
  hints.ai_socktype = 1;
  hints.ai_protocol = 6;
  struct addrinfo *sock_info;
  signed int return_value_getaddrinfo_9;
  return_value_getaddrinfo_9=getaddrinfo(device_str, "65001", &hints, &sock_info);
  if(!(return_value_getaddrinfo_9 == 0))
    return 0;

  else
  {
    struct sockaddr_in *sock_addr = (struct sockaddr_in *)sock_info->ai_addr;
    unsigned int hdhomerun_device_selector_load_from_str__1__ip_addr;
    unsigned int return_value___bswap_32_10;
    return_value___bswap_32_10=__bswap_32_link1(sock_addr->sin_addr.s_addr);
    hdhomerun_device_selector_load_from_str__1__ip_addr = (unsigned int)return_value___bswap_32_10;
    freeaddrinfo(sock_info);
    if(hdhomerun_device_selector_load_from_str__1__ip_addr == 0u)
      return 0;

    else
    {
      signed int return_value_hdhomerun_device_selector_load_from_str_discover_11;
      return_value_hdhomerun_device_selector_load_from_str_discover_11=hdhomerun_device_selector_load_from_str_discover(hds, hdhomerun_device_selector_load_from_str__1__ip_addr, 0xFFFFFFFF);
      return return_value_hdhomerun_device_selector_load_from_str_discover_11;
    }
  }
}

// hdhomerun_device_selector_load_from_str_discover
// file hdhomerun_device_selector.c line 125
static signed int hdhomerun_device_selector_load_from_str_discover(struct hdhomerun_device_selector_t *hds, unsigned int target_ip, unsigned int device_id)
{
  struct hdhomerun_discover_device_t result_list[64l];
  signed int discover_count;
  discover_count=hdhomerun_discover_find_devices_custom_v2(target_ip, (unsigned int)0x00000001, device_id, result_list, 64);
  signed int count = 0;
  signed int result_index;
  struct hdhomerun_discover_device_t *result = result_list;
  result_index = 0;
  for( ; !(result_index >= discover_count); result_index = result_index + 1)
  {
    unsigned int tuner_index = (unsigned int)0;
    for( ; !(tuner_index >= (unsigned int)result->tuner_count); tuner_index = tuner_index + 1u)
    {
      struct hdhomerun_device_t *hdhomerun_device_selector_load_from_str_discover__1__1__1__1__1__hd;
      hdhomerun_device_selector_load_from_str_discover__1__1__1__1__1__hd=hdhomerun_device_create(result->device_id, result->ip_addr, tuner_index, hds->dbg);
      if(!(hdhomerun_device_selector_load_from_str_discover__1__1__1__1__1__hd == ((struct hdhomerun_device_t *)NULL)))
      {
        hdhomerun_device_selector_add_device(hds, hdhomerun_device_selector_load_from_str_discover__1__1__1__1__1__hd);
        count = count + 1;
      }

    }
    result = result + 1l;
  }
  return count;
}

// hdhomerun_device_selector_remove_device
// file hdhomerun_device_selector.c line 83
extern void hdhomerun_device_selector_remove_device(struct hdhomerun_device_selector_t *hds, struct hdhomerun_device_t *hd)
{
  unsigned long int index = (unsigned long int)0;
  while((_Bool)1)
  {
    if(index >= hds->hd_count)
      goto __CPROVER_DUMP_L6;

    struct hdhomerun_device_t *entry = hds->hd_list[(signed long int)index];
    if(entry == hd)
      break;

    index = index + 1ul;
  }
  for( ; !(1ul + index >= hds->hd_count); index = index + 1ul)
    hds->hd_list[(signed long int)index] = hds->hd_list[(signed long int)(index + (unsigned long int)1)];
  hds->hd_list[(signed long int)index] = (struct hdhomerun_device_t *)(void *)0;
  hds->hd_count = hds->hd_count - 1ul;

__CPROVER_DUMP_L6:
  ;
}

// hdhomerun_device_set_device
// file hdhomerun_device.c line 37
extern signed int hdhomerun_device_set_device(struct hdhomerun_device_t *hd, unsigned int device_id, unsigned int device_ip)
{
  if(device_id == 0u && device_ip == 0u)
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_device: device not specified\n");
    return -1;
  }

  else
  {
    signed int return_value_hdhomerun_discover_is_ip_multicast_1;
    return_value_hdhomerun_discover_is_ip_multicast_1=hdhomerun_discover_is_ip_multicast(device_ip);
    if(!(return_value_hdhomerun_discover_is_ip_multicast_1 == 0))
    {
      hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_device: invalid address %08X\n", (unsigned int)device_ip);
      return -1;
    }

    else
      if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
      {
        hd->cs=hdhomerun_control_create((unsigned int)0, (unsigned int)0, hd->dbg);
        if(!(hd->cs == ((struct hdhomerun_control_sock_t *)NULL)))
          goto __CPROVER_DUMP_L3;

        hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_device: failed to create control object\n");
        return -1;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        hdhomerun_control_set_device(hd->cs, device_id, device_ip);
        if(device_id == 0u || device_id == 0xFFFFFFFF)
          device_id=hdhomerun_control_get_device_id(hd->cs);

        hd->multicast_ip = (unsigned int)0;
        hd->multicast_port = (unsigned short int)0;
        hd->device_id = device_id;
        hd->tuner = (unsigned int)0;
        hd->lockkey = (unsigned int)0;
        hdhomerun_sprintf(hd->name, hd->name + (signed long int)sizeof(char [32l]) /*32ul*/ , "%08X-%u", (unsigned int)hd->device_id, hd->tuner);
        hdhomerun_sprintf(hd->model, hd->model + (signed long int)sizeof(char [32l]) /*32ul*/ , "");
        return 1;
      }
  }
}

// hdhomerun_device_set_ir_target
// file hdhomerun_device.c line 995
extern signed int hdhomerun_device_set_ir_target(struct hdhomerun_device_t *hd, const char *target)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_ir_target: device not set\n");
    return -1;
  }

  else
  {
    signed int return_value_hdhomerun_control_set_1;
    return_value_hdhomerun_control_set_1=hdhomerun_control_set(hd->cs, "/ir/target", target, (char **)(void *)0, (char **)(void *)0);
    return return_value_hdhomerun_control_set_1;
  }
}

// hdhomerun_device_set_multicast
// file hdhomerun_device.c line 75
extern signed int hdhomerun_device_set_multicast(struct hdhomerun_device_t *hd, unsigned int multicast_ip, unsigned short int multicast_port)
{
  signed int return_value_hdhomerun_discover_is_ip_multicast_1;
  return_value_hdhomerun_discover_is_ip_multicast_1=hdhomerun_discover_is_ip_multicast(multicast_ip);
  if(return_value_hdhomerun_discover_is_ip_multicast_1 == 0)
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_device_multicast: invalid address %08X\n", (unsigned int)multicast_ip);
    return -1;
  }

  else
    if((signed int)multicast_port == 0)
    {
      hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_device_multicast: invalid port %u\n", (unsigned int)multicast_port);
      return -1;
    }

    else
    {
      if(!(hd->cs == ((struct hdhomerun_control_sock_t *)NULL)))
      {
        hdhomerun_control_destroy(hd->cs);
        hd->cs = (struct hdhomerun_control_sock_t *)(void *)0;
      }

      hd->multicast_ip = multicast_ip;
      hd->multicast_port = multicast_port;
      hd->device_id = (unsigned int)0;
      hd->tuner = (unsigned int)0;
      hd->lockkey = (unsigned int)0;
      unsigned int ip = multicast_ip;
      hdhomerun_sprintf(hd->name, hd->name + (signed long int)sizeof(char [32l]) /*32ul*/ , "%u.%u.%u.%u:%u", ip >> 24 & (unsigned int)0xFF, ip >> 16 & (unsigned int)0xFF, ip >> 8 & (unsigned int)0xFF, ip >> 0 & (unsigned int)0xFF, (unsigned int)multicast_port);
      hdhomerun_sprintf(hd->model, hd->model + (signed long int)sizeof(char [32l]) /*32ul*/ , "multicast");
      return 1;
    }
}

// hdhomerun_device_set_sys_dvbc_modulation
// file hdhomerun_device.c line 1005
extern signed int hdhomerun_device_set_sys_dvbc_modulation(struct hdhomerun_device_t *hd, const char *modulation_list)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_sys_dvbc_modulation: device not set\n");
    return -1;
  }

  else
  {
    signed int return_value_hdhomerun_control_set_1;
    return_value_hdhomerun_control_set_1=hdhomerun_control_set(hd->cs, "/sys/dvbc_modulation", modulation_list, (char **)(void *)0, (char **)(void *)0);
    return return_value_hdhomerun_control_set_1;
  }
}

// hdhomerun_device_set_tuner
// file hdhomerun_device.c line 105
extern signed int hdhomerun_device_set_tuner(struct hdhomerun_device_t *hd, unsigned int tuner)
{
  if(!(hd->multicast_ip == 0u))
  {
    if(!(tuner == 0u))
    {
      hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_tuner: tuner cannot be specified in multicast mode\n");
      return -1;
    }

    return 1;
  }

  else
  {
    hd->tuner = tuner;
    hdhomerun_sprintf(hd->name, hd->name + (signed long int)sizeof(char [32l]) /*32ul*/ , "%08X-%u", (unsigned int)hd->device_id, hd->tuner);
    return 1;
  }
}

// hdhomerun_device_set_tuner_channel
// file hdhomerun_device.h line 139
extern signed int hdhomerun_device_set_tuner_channel(struct hdhomerun_device_t *hd, const char *channel)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_tuner_channel: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/channel", hd->tuner);
    signed int return_value_hdhomerun_control_set_with_lockkey_1;
    return_value_hdhomerun_control_set_with_lockkey_1=hdhomerun_control_set_with_lockkey(hd->cs, name, channel, hd->lockkey, (char **)(void *)0, (char **)(void *)0);
    return return_value_hdhomerun_control_set_with_lockkey_1;
  }
}

// hdhomerun_device_set_tuner_channelmap
// file hdhomerun_device.c line 864
extern signed int hdhomerun_device_set_tuner_channelmap(struct hdhomerun_device_t *hd, const char *channelmap)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_tuner_channelmap: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/channelmap", hd->tuner);
    signed int return_value_hdhomerun_control_set_with_lockkey_1;
    return_value_hdhomerun_control_set_with_lockkey_1=hdhomerun_control_set_with_lockkey(hd->cs, name, channelmap, hd->lockkey, (char **)(void *)0, (char **)(void *)0);
    return return_value_hdhomerun_control_set_with_lockkey_1;
  }
}

// hdhomerun_device_set_tuner_filter
// file hdhomerun_device.c line 876
extern signed int hdhomerun_device_set_tuner_filter(struct hdhomerun_device_t *hd, const char *filter)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_tuner_filter: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/filter", hd->tuner);
    signed int return_value_hdhomerun_control_set_with_lockkey_1;
    return_value_hdhomerun_control_set_with_lockkey_1=hdhomerun_control_set_with_lockkey(hd->cs, name, filter, hd->lockkey, (char **)(void *)0, (char **)(void *)0);
    return return_value_hdhomerun_control_set_with_lockkey_1;
  }
}

// hdhomerun_device_set_tuner_filter_by_array
// file hdhomerun_device.c line 897
extern signed int hdhomerun_device_set_tuner_filter_by_array(struct hdhomerun_device_t *hd, unsigned char *filter_array)
{
  char filter[1024l];
  char *ptr = filter;
  char *end = filter + (signed long int)sizeof(char [1024l]) /*1024ul*/ ;
  unsigned short int range_begin = (unsigned short int)0xFFFF;
  unsigned short int range_end = (unsigned short int)0xFFFF;
  unsigned short int i = (unsigned short int)0;
  for( ; !((signed int)i >= 8192); i = i + 1)
  {
    if(filter_array[(signed long int)i] == 0)
    {
      if((signed int)range_begin == 0xFFFF)
        goto __CPROVER_DUMP_L5;

      signed int return_value_hdhomerun_device_set_tuner_filter_by_array_append_1;
      return_value_hdhomerun_device_set_tuner_filter_by_array_append_1=hdhomerun_device_set_tuner_filter_by_array_append(ptr, end, range_begin, range_end);
      if(return_value_hdhomerun_device_set_tuner_filter_by_array_append_1 == 0)
        return 0;

      void *return_value___rawmemchr_2;
      return_value___rawmemchr_2=__rawmemchr((const void *)ptr, 0);
      ptr = (char *)return_value___rawmemchr_2;
      range_begin = (unsigned short int)0xFFFF;
      range_end = (unsigned short int)0xFFFF;
      goto __CPROVER_DUMP_L5;
    }

    if((signed int)range_begin == 0xFFFF)
    {
      range_begin = i;
      range_end = i;
    }

    else
      range_end = i;

  __CPROVER_DUMP_L5:
    ;
  }
  if(!((signed int)range_begin == 0xFFFF))
  {
    signed int return_value_hdhomerun_device_set_tuner_filter_by_array_append_3;
    return_value_hdhomerun_device_set_tuner_filter_by_array_append_3=hdhomerun_device_set_tuner_filter_by_array_append(ptr, end, range_begin, range_end);
    if(return_value_hdhomerun_device_set_tuner_filter_by_array_append_3 == 0)
      return 0;

    void *return_value___rawmemchr_4;
    return_value___rawmemchr_4=__rawmemchr((const void *)ptr, 0);
    ptr = (char *)return_value___rawmemchr_4;
  }

  if(!(filter >= ptr))
  {
    ptr = ptr - 1l;
    *ptr = (char)0;
  }

  signed int return_value_hdhomerun_device_set_tuner_filter_5;
  return_value_hdhomerun_device_set_tuner_filter_5=hdhomerun_device_set_tuner_filter(hd, filter);
  return return_value_hdhomerun_device_set_tuner_filter_5;
}

// hdhomerun_device_set_tuner_filter_by_array_append
// file hdhomerun_device.c line 888
static signed int hdhomerun_device_set_tuner_filter_by_array_append(char *ptr, char *end, unsigned short int range_begin, unsigned short int range_end)
{
  if(range_begin == range_end)
  {
    signed int return_value_hdhomerun_sprintf_1;
    return_value_hdhomerun_sprintf_1=hdhomerun_sprintf(ptr, end, "0x%04x ", (unsigned int)range_begin);
    return return_value_hdhomerun_sprintf_1;
  }

  else
  {
    signed int return_value_hdhomerun_sprintf_2;
    return_value_hdhomerun_sprintf_2=hdhomerun_sprintf(ptr, end, "0x%04x-0x%04x ", (unsigned int)range_begin, (unsigned int)range_end);
    return return_value_hdhomerun_sprintf_2;
  }
}

// hdhomerun_device_set_tuner_from_str
// file hdhomerun_device.h line 84
extern signed int hdhomerun_device_set_tuner_from_str(struct hdhomerun_device_t *hd, const char *tuner_str)
{
  unsigned int tuner;
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(tuner_str, "%u", &tuner);
  if(return_value_sscanf_1 == 1)
  {
    hdhomerun_device_set_tuner(hd, tuner);
    return 1;
  }

  else
  {
    signed int return_value_sscanf_2;
    return_value_sscanf_2=sscanf(tuner_str, "/tuner%u", &tuner);
    if(return_value_sscanf_2 == 1)
    {
      hdhomerun_device_set_tuner(hd, tuner);
      return 1;
    }

    else
      return -1;
  }
}

// hdhomerun_device_set_tuner_program
// file hdhomerun_device.c line 946
extern signed int hdhomerun_device_set_tuner_program(struct hdhomerun_device_t *hd, const char *program)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_tuner_program: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/program", hd->tuner);
    signed int return_value_hdhomerun_control_set_with_lockkey_1;
    return_value_hdhomerun_control_set_with_lockkey_1=hdhomerun_control_set_with_lockkey(hd->cs, name, program, hd->lockkey, (char **)(void *)0, (char **)(void *)0);
    return return_value_hdhomerun_control_set_with_lockkey_1;
  }
}

// hdhomerun_device_set_tuner_target
// file hdhomerun_device.h line 145
extern signed int hdhomerun_device_set_tuner_target(struct hdhomerun_device_t *hd, const char *target)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_tuner_target: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/target", hd->tuner);
    signed int return_value_hdhomerun_control_set_with_lockkey_1;
    return_value_hdhomerun_control_set_with_lockkey_1=hdhomerun_control_set_with_lockkey(hd->cs, name, target, hd->lockkey, (char **)(void *)0, (char **)(void *)0);
    return return_value_hdhomerun_control_set_with_lockkey_1;
  }
}

// hdhomerun_device_set_tuner_target_to_local
// file hdhomerun_device.c line 970
static signed int hdhomerun_device_set_tuner_target_to_local(struct hdhomerun_device_t *hd, const char *protocol)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_tuner_target_to_local: device not set\n");
    return -1;
  }

  else
    if(hd->vs == ((struct hdhomerun_video_sock_t *)NULL))
    {
      hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_tuner_target_to_local: video not initialized\n");
      return -1;
    }

    else
    {
      char target[64l];
      unsigned int local_ip;
      local_ip=hdhomerun_control_get_local_addr(hd->cs);
      unsigned short int local_port;
      local_port=hdhomerun_video_get_local_port(hd->vs);
      hdhomerun_sprintf(target, target + (signed long int)sizeof(char [64l]) /*64ul*/ , "%s://%u.%u.%u.%u:%u", protocol, (unsigned int)(local_ip >> 24) & (unsigned int)0xFF, (unsigned int)(local_ip >> 16) & (unsigned int)0xFF, (unsigned int)(local_ip >> 8) & (unsigned int)0xFF, (unsigned int)(local_ip >> 0) & (unsigned int)0xFF, (unsigned int)local_port);
      signed int return_value_hdhomerun_device_set_tuner_target_1;
      return_value_hdhomerun_device_set_tuner_target_1=hdhomerun_device_set_tuner_target(hd, target);
      return return_value_hdhomerun_device_set_tuner_target_1;
    }
}

// hdhomerun_device_set_tuner_vchannel
// file hdhomerun_device.c line 852
extern signed int hdhomerun_device_set_tuner_vchannel(struct hdhomerun_device_t *hd, const char *vchannel)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_tuner_vchannel: device not set\n");
    return -1;
  }

  else
  {
    char name[32l];
    hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/vchannel", hd->tuner);
    signed int return_value_hdhomerun_control_set_with_lockkey_1;
    return_value_hdhomerun_control_set_with_lockkey_1=hdhomerun_control_set_with_lockkey(hd->cs, name, vchannel, hd->lockkey, (char **)(void *)0, (char **)(void *)0);
    return return_value_hdhomerun_control_set_with_lockkey_1;
  }
}

// hdhomerun_device_set_var
// file hdhomerun_device.h line 167
extern signed int hdhomerun_device_set_var(struct hdhomerun_device_t *hd, const char *name, const char *value, char **pvalue, char **perror)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_set_var: device not set\n");
    return -1;
  }

  else
  {
    signed int return_value_hdhomerun_control_set_with_lockkey_1;
    return_value_hdhomerun_control_set_with_lockkey_1=hdhomerun_control_set_with_lockkey(hd->cs, name, value, hd->lockkey, pvalue, perror);
    return return_value_hdhomerun_control_set_with_lockkey_1;
  }
}

// hdhomerun_device_stream_flush
// file hdhomerun_device.c line 1182
extern void hdhomerun_device_stream_flush(struct hdhomerun_device_t *hd)
{
  if(hd->vs == ((struct hdhomerun_video_sock_t *)NULL))
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_stream_flush: video not initialized\n");

  else
    hdhomerun_video_flush(hd->vs);
}

// hdhomerun_device_stream_recv
// file hdhomerun_device.h line 220
extern unsigned char * hdhomerun_device_stream_recv(struct hdhomerun_device_t *hd, unsigned long int max_size, unsigned long int *pactual_size)
{
  if(hd->vs == ((struct hdhomerun_video_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_stream_recv: video not initialized\n");
    return (unsigned char *)(void *)0;
  }

  else
  {
    unsigned char *return_value_hdhomerun_video_recv_1;
    return_value_hdhomerun_video_recv_1=hdhomerun_video_recv(hd->vs, max_size, pactual_size);
    return return_value_hdhomerun_video_recv_1;
  }
}

// hdhomerun_device_stream_start
// file hdhomerun_device.h line 219
extern signed int hdhomerun_device_stream_start(struct hdhomerun_device_t *hd)
{
  hdhomerun_device_get_video_sock(hd);
  if(hd->vs == ((struct hdhomerun_video_sock_t *)NULL))
    return -1;

  else
  {
    if(!(hd->multicast_ip == 0u))
    {
      signed int hdhomerun_device_stream_start__1__2__ret;
      hdhomerun_device_stream_start__1__2__ret=hdhomerun_video_join_multicast_group(hd->vs, hd->multicast_ip, (unsigned int)0);
      if(!(hdhomerun_device_stream_start__1__2__ret >= 1))
        return hdhomerun_device_stream_start__1__2__ret;

    }

    else
    {
      signed int ret;
      ret=hdhomerun_device_set_tuner_target_to_local(hd, "rtp");
      if(ret == 0)
        ret=hdhomerun_device_set_tuner_target_to_local(hd, "udp");

      if(!(ret >= 1))
        return ret;

    }
    msleep_minimum((unsigned long int)64);
    hdhomerun_video_flush(hd->vs);
    return 1;
  }
}

// hdhomerun_device_stream_stop
// file hdhomerun_device.h line 222
extern void hdhomerun_device_stream_stop(struct hdhomerun_device_t *hd)
{
  if(hd->vs == ((struct hdhomerun_video_sock_t *)NULL))
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_stream_stop: video not initialized\n");

  else
    if(!(hd->multicast_ip == 0u))
      hdhomerun_video_leave_multicast_group(hd->vs, hd->multicast_ip, (unsigned int)0);

    else
      hdhomerun_device_set_tuner_target(hd, "none");
}

// hdhomerun_device_tuner_lockkey_force
// file hdhomerun_device.c line 1085
extern signed int hdhomerun_device_tuner_lockkey_force(struct hdhomerun_device_t *hd)
{
  if(!(hd->multicast_ip == 0u))
    return 1;

  else
    if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
    {
      hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_tuner_lockkey_force: device not set\n");
      return -1;
    }

    else
    {
      char name[32l];
      hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/lockkey", hd->tuner);
      signed int ret;
      ret=hdhomerun_control_set(hd->cs, name, "force", (char **)(void *)0, (char **)(void *)0);
      hd->lockkey = (unsigned int)0;
      return ret;
    }
}

// hdhomerun_device_tuner_lockkey_release
// file hdhomerun_device.h line 183
extern signed int hdhomerun_device_tuner_lockkey_release(struct hdhomerun_device_t *hd)
{
  if(!(hd->multicast_ip == 0u))
    return 1;

  else
    if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
    {
      hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_tuner_lockkey_release: device not set\n");
      return -1;
    }

    else
      if(hd->lockkey == 0u)
        return 1;

      else
      {
        char name[32l];
        hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/lockkey", hd->tuner);
        signed int ret;
        ret=hdhomerun_control_set_with_lockkey(hd->cs, name, "none", hd->lockkey, (char **)(void *)0, (char **)(void *)0);
        hd->lockkey = (unsigned int)0;
        return ret;
      }
}

// hdhomerun_device_tuner_lockkey_request
// file hdhomerun_device.h line 182
extern signed int hdhomerun_device_tuner_lockkey_request(struct hdhomerun_device_t *hd, char **perror)
{
  if(!(hd->multicast_ip == 0u))
    return 1;

  else
    if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
    {
      hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_tuner_lockkey_request: device not set\n");
      return -1;
    }

    else
    {
      unsigned int new_lockkey;
      new_lockkey=random_get32();
      char name[32l];
      hdhomerun_sprintf(name, name + (signed long int)sizeof(char [32l]) /*32ul*/ , "/tuner%u/lockkey", hd->tuner);
      char new_lockkey_str[64l];
      hdhomerun_sprintf(new_lockkey_str, new_lockkey_str + (signed long int)sizeof(char [64l]) /*64ul*/ , "%u", (unsigned int)new_lockkey);
      signed int ret;
      ret=hdhomerun_control_set_with_lockkey(hd->cs, name, new_lockkey_str, hd->lockkey, (char **)(void *)0, perror);
      if(!(ret >= 1))
      {
        hd->lockkey = (unsigned int)0;
        return ret;
      }

      else
      {
        hd->lockkey = new_lockkey;
        return ret;
      }
    }
}

// hdhomerun_device_tuner_lockkey_use_value
// file hdhomerun_device.h line 189
extern void hdhomerun_device_tuner_lockkey_use_value(struct hdhomerun_device_t *hd, unsigned int lockkey)
{
  if(hd->multicast_ip == 0u)
    hd->lockkey = lockkey;

}

// hdhomerun_device_upgrade
// file hdhomerun_device.h line 241
extern signed int hdhomerun_device_upgrade(struct hdhomerun_device_t *hd, struct _IO_FILE *upgrade_file)
{
  if(hd->cs == ((struct hdhomerun_control_sock_t *)NULL))
  {
    hdhomerun_debug_printf(hd->dbg, "hdhomerun_device_upgrade: device not set\n");
    return -1;
  }

  else
  {
    hdhomerun_control_set(hd->cs, "/tuner0/lockkey", "force", (char **)(void *)0, (char **)(void *)0);
    hdhomerun_control_set(hd->cs, "/tuner0/channel", "none", (char **)(void *)0, (char **)(void *)0);
    hdhomerun_control_set(hd->cs, "/tuner1/lockkey", "force", (char **)(void *)0, (char **)(void *)0);
    hdhomerun_control_set(hd->cs, "/tuner1/channel", "none", (char **)(void *)0, (char **)(void *)0);
    signed int return_value_hdhomerun_control_upgrade_1;
    return_value_hdhomerun_control_upgrade_1=hdhomerun_control_upgrade(hd->cs, upgrade_file);
    return return_value_hdhomerun_control_upgrade_1;
  }
}

// hdhomerun_device_wait_for_lock
// file hdhomerun_device.h line 201
extern signed int hdhomerun_device_wait_for_lock(struct hdhomerun_device_t *hd, struct hdhomerun_tuner_status_t *status)
{
  msleep_minimum((unsigned long int)250);
  unsigned long int timeout;
  unsigned long int return_value_getcurrenttime_1;
  return_value_getcurrenttime_1=getcurrenttime();
  timeout = return_value_getcurrenttime_1 + (unsigned long int)2500;
  _Bool tmp_if_expr_2;
  while((_Bool)1)
  {
    signed int ret;
    ret=hdhomerun_device_get_tuner_status(hd, (char **)(void *)0, status);
    if(!(ret >= 1))
      return ret;

    if(status->signal_present == 0)
      return 1;

    if(!(status->lock_supported == 0))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = status->lock_unsupported != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return 1;

    unsigned long int return_value_getcurrenttime_3;
    return_value_getcurrenttime_3=getcurrenttime();
    if(return_value_getcurrenttime_3 >= timeout)
      return 1;

    msleep_approx((unsigned long int)250);
  }
}

// hdhomerun_discover_create
// file hdhomerun_discover.c line 79
extern struct hdhomerun_discover_t * hdhomerun_discover_create(struct hdhomerun_debug_t *dbg)
{
  struct hdhomerun_discover_t *ds;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct hdhomerun_discover_t) /*6496ul*/ );
  ds = (struct hdhomerun_discover_t *)return_value_calloc_1;
  if(ds == ((struct hdhomerun_discover_t *)NULL))
    return (struct hdhomerun_discover_t *)(void *)0;

  else
  {
    ds->dbg = dbg;
    signed int return_value_hdhomerun_discover_sock_add_2;
    return_value_hdhomerun_discover_sock_add_2=hdhomerun_discover_sock_add(ds, (unsigned int)0, (unsigned int)0);
    if(return_value_hdhomerun_discover_sock_add_2 == 0)
    {
      free((void *)ds);
      return (struct hdhomerun_discover_t *)(void *)0;
    }

    else
      return ds;
  }
}

// hdhomerun_discover_destroy
// file hdhomerun_discover.c line 98
extern void hdhomerun_discover_destroy(struct hdhomerun_discover_t *ds)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= ds->sock_count); i = i + 1u)
  {
    struct hdhomerun_discover_sock_t *dss = &ds->socks[(signed long int)i];
    hdhomerun_sock_destroy(dss->sock);
  }
  free((void *)ds);
}

// hdhomerun_discover_find_devices_custom_v2
// file hdhomerun_discover.h line 48
extern signed int hdhomerun_discover_find_devices_custom_v2(unsigned int target_ip, unsigned int device_type, unsigned int device_id, struct hdhomerun_discover_device_t *result_list, signed int max_count)
{
  signed int return_value_hdhomerun_discover_is_ip_multicast_1;
  return_value_hdhomerun_discover_is_ip_multicast_1=hdhomerun_discover_is_ip_multicast(target_ip);
  if(!(return_value_hdhomerun_discover_is_ip_multicast_1 == 0))
    return 0;

  else
  {
    struct hdhomerun_discover_t *ds;
    ds=hdhomerun_discover_create((struct hdhomerun_debug_t *)(void *)0);
    if(ds == ((struct hdhomerun_discover_t *)NULL))
      return -1;

    else
    {
      signed int ret;
      ret=hdhomerun_discover_find_devices_v2(ds, target_ip, device_type, device_id, result_list, max_count);
      hdhomerun_discover_destroy(ds);
      return ret;
    }
  }
}

// hdhomerun_discover_find_devices_v2
// file hdhomerun_discover.c line 406
extern signed int hdhomerun_discover_find_devices_v2(struct hdhomerun_discover_t *ds, unsigned int target_ip, unsigned int device_type, unsigned int device_id, struct hdhomerun_discover_device_t *result_list, signed int max_count)
{
  hdhomerun_discover_sock_detect(ds);
  signed int count = 0;
  signed int attempt = 0;
  for( ; !(attempt >= 2); attempt = attempt + 1)
  {
    signed int return_value_hdhomerun_discover_send_1;
    return_value_hdhomerun_discover_send_1=hdhomerun_discover_send(ds, target_ip, device_type, device_id);
    if(return_value_hdhomerun_discover_send_1 == 0)
      return -1;

    unsigned long int timeout;
    unsigned long int return_value_getcurrenttime_2;
    return_value_getcurrenttime_2=getcurrenttime();
    timeout = return_value_getcurrenttime_2 + (unsigned long int)200;
    while((_Bool)1)
    {
      struct hdhomerun_discover_device_t *result = &result_list[(signed long int)count];
      memset((void *)result, 0, sizeof(struct hdhomerun_discover_device_t) /*76ul*/ );
      signed int return_value_hdhomerun_discover_recv_4;
      return_value_hdhomerun_discover_recv_4=hdhomerun_discover_recv(ds, result);
      if(return_value_hdhomerun_discover_recv_4 == 0)
      {
        unsigned long int return_value_getcurrenttime_3;
        return_value_getcurrenttime_3=getcurrenttime();
        if(return_value_getcurrenttime_3 >= timeout)
          break;

        msleep_approx((unsigned long int)10);
        continue;
      }

      if(!(device_type == 0xFFFFFFFF))
      {
        if(device_type == result->device_type)
          goto __CPROVER_DUMP_L6;

      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        if(!(device_id == 0xFFFFFFFF))
        {
          if(device_id == result->device_id)
            goto __CPROVER_DUMP_L7;

        }

        else
        {

        __CPROVER_DUMP_L7:
          ;
          struct hdhomerun_discover_device_t *return_value_hdhomerun_discover_find_in_list_5;
          return_value_hdhomerun_discover_find_in_list_5=hdhomerun_discover_find_in_list(result_list, count, result);
          if(return_value_hdhomerun_discover_find_in_list_5 == ((struct hdhomerun_discover_device_t *)NULL))
          {
            count = count + 1;
            if(count >= max_count)
              return count;

          }

        }
      }
    }
  }
  return count;
}

// hdhomerun_discover_find_in_list
// file hdhomerun_discover.c line 393
static struct hdhomerun_discover_device_t * hdhomerun_discover_find_in_list(struct hdhomerun_discover_device_t *result_list, signed int count, struct hdhomerun_discover_device_t *lookup)
{
  signed int index = 0;
  for( ; !(index >= count); index = index + 1)
  {
    struct hdhomerun_discover_device_t *entry = &result_list[(signed long int)index];
    signed int return_value_memcmp_1;
    return_value_memcmp_1=memcmp((const void *)lookup, (const void *)entry, sizeof(struct hdhomerun_discover_device_t) /*76ul*/ );
    if(return_value_memcmp_1 == 0)
      return entry;

  }
  return (struct hdhomerun_discover_device_t *)(void *)0;
}

// hdhomerun_discover_is_ip_multicast
// file hdhomerun_discover.h line 74
extern signed int hdhomerun_discover_is_ip_multicast(unsigned int ip_addr)
{
  return (signed int)(ip_addr >= 0xE0000000 && ip_addr < 0xF0000000);
}

// hdhomerun_discover_is_legacy
// file hdhomerun_discover.c line 234
static signed int hdhomerun_discover_is_legacy(unsigned int device_id)
{
  switch(device_id >> 20)
  {
    case (unsigned int)0x100:
      return (signed int)(device_id < (unsigned int)0x10040000);
    case (unsigned int)0x120:
      return (signed int)(device_id < (unsigned int)0x12030000);
    case (unsigned int)0x101:

    case (unsigned int)0x102:

    case (unsigned int)0x103:

    case (unsigned int)0x111:

    case (unsigned int)0x121:

    case (unsigned int)0x122:
      return 1;
    default:
      return 0;
  }
}

// hdhomerun_discover_recv
// file hdhomerun_discover.c line 379
static signed int hdhomerun_discover_recv(struct hdhomerun_discover_t *ds, struct hdhomerun_discover_device_t *result)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= ds->sock_count); i = i + 1u)
  {
    struct hdhomerun_discover_sock_t *dss = &ds->socks[(signed long int)i];
    signed int return_value_hdhomerun_discover_recv_internal_1;
    return_value_hdhomerun_discover_recv_internal_1=hdhomerun_discover_recv_internal(ds, dss, result);
    if(!(return_value_hdhomerun_discover_recv_internal_1 == 0))
      return 1;

  }
  return 0;
}

// hdhomerun_discover_recv_internal
// file hdhomerun_discover.c line 256
static signed int hdhomerun_discover_recv_internal(struct hdhomerun_discover_t *ds, struct hdhomerun_discover_sock_t *dss, struct hdhomerun_discover_device_t *result)
{
  struct hdhomerun_pkt_t *rx_pkt = &ds->rx_pkt;
  hdhomerun_pkt_reset(rx_pkt);
  unsigned int remote_addr;
  unsigned short int remote_port;
  unsigned long int length = (unsigned long int)(rx_pkt->limit - rx_pkt->end);
  signed int return_value_hdhomerun_sock_recvfrom_1;
  return_value_hdhomerun_sock_recvfrom_1=hdhomerun_sock_recvfrom(dss->sock, &remote_addr, &remote_port, (void *)rx_pkt->end, &length, (unsigned long int)0);
  if(return_value_hdhomerun_sock_recvfrom_1 == 0)
    return 0;

  else
  {
    rx_pkt->end = rx_pkt->end + (signed long int)length;
    unsigned short int type;
    signed int return_value_hdhomerun_pkt_open_frame_2;
    return_value_hdhomerun_pkt_open_frame_2=hdhomerun_pkt_open_frame(rx_pkt, &type);
    if(!(return_value_hdhomerun_pkt_open_frame_2 >= 1))
      return 0;

    else
      if(!((signed int)type == 0x0003))
        return 0;

      else
      {
        memset((void *)result, 0, sizeof(struct hdhomerun_discover_device_t) /*76ul*/ );
        result->ip_addr = remote_addr;
        hdhomerun_sprintf(result->base_url, result->base_url + (signed long int)sizeof(char [29l]) /*29ul*/ , "http://%u.%u.%u.%u:80", remote_addr >> 24 & (unsigned int)0xFF, remote_addr >> 16 & (unsigned int)0xFF, remote_addr >> 8 & (unsigned int)0xFF, remote_addr >> 0 & (unsigned int)0xFF);
        while((_Bool)1)
        {
          unsigned char tag;
          unsigned long int len;
          unsigned char *next;
          next=hdhomerun_pkt_read_tlv(rx_pkt, &tag, &len);
          if(next == ((unsigned char *)NULL))
            break;

          signed int i;
          switch((signed int)tag)
          {
            case 0x01:
            {
              if(!(len == 4ul))
                break;

              result->device_type=hdhomerun_pkt_read_u32(rx_pkt);
              break;
            }
            case 0x02:
            {
              if(!(len == 4ul))
                break;

              result->device_id=hdhomerun_pkt_read_u32(rx_pkt);
              result->is_legacy=hdhomerun_discover_is_legacy(result->device_id);
              break;
            }
            case 0x10:
            {
              if(!(len == 1ul))
                break;

              result->tuner_count=hdhomerun_pkt_read_u8(rx_pkt);
              break;
            }
            case 0x2B:
            {
              if(len >= sizeof(char [25l]) /*25ul*/ )
                break;

              hdhomerun_pkt_read_mem(rx_pkt, (void *)result->device_auth, len);
              result->device_auth[(signed long int)len] = (char)0;
              break;
            }
            case 0x29:
            {
              if(!(len == 18ul))
                break;

              i = 0;
              for( ; !(i >= 24); i = i + 4)
              {
                unsigned int raw24;
                unsigned char return_value_hdhomerun_pkt_read_u8_3;
                return_value_hdhomerun_pkt_read_u8_3=hdhomerun_pkt_read_u8(rx_pkt);
                raw24 = (unsigned int)return_value_hdhomerun_pkt_read_u8_3 << 16;
                unsigned char return_value_hdhomerun_pkt_read_u8_4;
                return_value_hdhomerun_pkt_read_u8_4=hdhomerun_pkt_read_u8(rx_pkt);
                raw24 = raw24 | (unsigned int)return_value_hdhomerun_pkt_read_u8_4 << 8;
                unsigned char return_value_hdhomerun_pkt_read_u8_5;
                return_value_hdhomerun_pkt_read_u8_5=hdhomerun_pkt_read_u8(rx_pkt);
                raw24 = raw24 | (unsigned int)return_value_hdhomerun_pkt_read_u8_5 << 0;
                static char hdhomerun_discover_recv_base64_encode_table[65l] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', 0 };
                result->device_auth[(signed long int)(i + 0)] = hdhomerun_discover_recv_base64_encode_table[(signed long int)(raw24 >> 18 & (unsigned int)0x3F)];
                result->device_auth[(signed long int)(i + 1)] = hdhomerun_discover_recv_base64_encode_table[(signed long int)(raw24 >> 12 & (unsigned int)0x3F)];
                result->device_auth[(signed long int)(i + 2)] = hdhomerun_discover_recv_base64_encode_table[(signed long int)(raw24 >> 6 & (unsigned int)0x3F)];
                result->device_auth[(signed long int)(i + 3)] = hdhomerun_discover_recv_base64_encode_table[(signed long int)(raw24 >> 0 & (unsigned int)0x3F)];
              }
              result->device_auth[(signed long int)24] = (char)0;
              break;
            }
            case 0x2A:
              if(!(len >= sizeof(char [29l]) /*29ul*/ ))
              {
                hdhomerun_pkt_read_mem(rx_pkt, (void *)result->base_url, len);
                result->base_url[(signed long int)len] = (char)0;
              }

          }
          rx_pkt->pos = next;
        }
        if((signed int)result->tuner_count == 0)
          switch(result->device_id >> 20)
          {
            case (unsigned int)0x102:
            {
              result->tuner_count = (unsigned char)1;
              break;
            }
            case (unsigned int)0x100:

            case (unsigned int)0x101:

            case (unsigned int)0x121:
              result->tuner_count = (unsigned char)2;
            default:
              ;
          }

        return 1;
      }
  }
}

// hdhomerun_discover_send
// file hdhomerun_discover.c line 225
static signed int hdhomerun_discover_send(struct hdhomerun_discover_t *ds, unsigned int target_ip, unsigned int device_type, unsigned int device_id)
{
  if(target_ip == 0u)
  {
    signed int return_value_hdhomerun_discover_send_wildcard_ip_1;
    return_value_hdhomerun_discover_send_wildcard_ip_1=hdhomerun_discover_send_wildcard_ip(ds, device_type, device_id);
    return return_value_hdhomerun_discover_send_wildcard_ip_1;
  }

  else
  {
    signed int return_value_hdhomerun_discover_send_target_ip_2;
    return_value_hdhomerun_discover_send_target_ip_2=hdhomerun_discover_send_target_ip(ds, target_ip, device_type, device_id);
    return return_value_hdhomerun_discover_send_target_ip_2;
  }
}

// hdhomerun_discover_send_internal
// file hdhomerun_discover.c line 154
static signed int hdhomerun_discover_send_internal(struct hdhomerun_discover_t *ds, struct hdhomerun_discover_sock_t *dss, unsigned int target_ip, unsigned int device_type, unsigned int device_id)
{
  struct hdhomerun_pkt_t *tx_pkt = &ds->tx_pkt;
  hdhomerun_pkt_reset(tx_pkt);
  hdhomerun_pkt_write_u8(tx_pkt, (unsigned char)0x01);
  hdhomerun_pkt_write_var_length(tx_pkt, (unsigned long int)4);
  hdhomerun_pkt_write_u32(tx_pkt, device_type);
  hdhomerun_pkt_write_u8(tx_pkt, (unsigned char)0x02);
  hdhomerun_pkt_write_var_length(tx_pkt, (unsigned long int)4);
  hdhomerun_pkt_write_u32(tx_pkt, device_id);
  hdhomerun_pkt_seal_frame(tx_pkt, (unsigned short int)0x0002);
  signed int return_value_hdhomerun_sock_sendto_1;
  return_value_hdhomerun_sock_sendto_1=hdhomerun_sock_sendto(dss->sock, target_ip, (unsigned short int)65001, (const void *)tx_pkt->start, (unsigned long int)(tx_pkt->end - tx_pkt->start), (unsigned long int)0);
  return return_value_hdhomerun_sock_sendto_1;
}

// hdhomerun_discover_send_target_ip
// file hdhomerun_discover.c line 196
static signed int hdhomerun_discover_send_target_ip(struct hdhomerun_discover_t *ds, unsigned int target_ip, unsigned int device_type, unsigned int device_id)
{
  signed int result = 0;
  unsigned int i = (unsigned int)1;
  for( ; !(i >= ds->sock_count); i = i + 1u)
  {
    struct hdhomerun_discover_sock_t *dss = &ds->socks[(signed long int)i];
    if((dss->subnet_mask & target_ip) == (dss->local_ip & dss->subnet_mask))
    {
      signed int return_value_hdhomerun_discover_send_internal_1;
      return_value_hdhomerun_discover_send_internal_1=hdhomerun_discover_send_internal(ds, dss, target_ip, device_type, device_id);
      result = result | return_value_hdhomerun_discover_send_internal_1;
    }

  }
  if(result == 0)
  {
    struct hdhomerun_discover_sock_t *hdhomerun_discover_send_target_ip__1__2__dss = &ds->socks[(signed long int)0];
    result=hdhomerun_discover_send_internal(ds, hdhomerun_discover_send_target_ip__1__2__dss, target_ip, device_type, device_id);
  }

  return result;
}

// hdhomerun_discover_send_wildcard_ip
// file hdhomerun_discover.c line 170
static signed int hdhomerun_discover_send_wildcard_ip(struct hdhomerun_discover_t *ds, unsigned int device_type, unsigned int device_id)
{
  signed int result = 0;
  unsigned int i = (unsigned int)1;
  for( ; !(i >= ds->sock_count); i = i + 1u)
  {
    struct hdhomerun_discover_sock_t *dss = &ds->socks[(signed long int)i];
    unsigned int target_ip = dss->local_ip | ~dss->subnet_mask;
    signed int return_value_hdhomerun_discover_send_internal_1;
    return_value_hdhomerun_discover_send_internal_1=hdhomerun_discover_send_internal(ds, dss, target_ip, device_type, device_id);
    result = result | return_value_hdhomerun_discover_send_internal_1;
  }
  if(result == 0)
  {
    struct hdhomerun_discover_sock_t *hdhomerun_discover_send_wildcard_ip__1__2__dss = &ds->socks[(signed long int)0];
    result=hdhomerun_discover_send_internal(ds, hdhomerun_discover_send_wildcard_ip__1__2__dss, 0xFFFFFFFF, device_type, device_id);
  }

  return result;
}

// hdhomerun_discover_sock_add
// file hdhomerun_discover.c line 40
static signed int hdhomerun_discover_sock_add(struct hdhomerun_discover_t *ds, unsigned int local_ip, unsigned int subnet_mask)
{
  unsigned int i = (unsigned int)1;
  for( ; !(i >= ds->sock_count); i = i + 1u)
  {
    struct hdhomerun_discover_sock_t *dss = &ds->socks[(signed long int)i];
    if(dss->local_ip == local_ip)
    {
      if(dss->subnet_mask == subnet_mask)
      {
        dss->detected = 1;
        return 1;
      }

    }

  }
  unsigned int tmp_post_2;
  if(ds->sock_count >= 16u)
    return 0;

  else
  {
    signed int sock;
    sock=hdhomerun_sock_create_udp();
    if(sock == -1)
      return 0;

    else
    {
      signed int return_value_hdhomerun_sock_bind_1;
      return_value_hdhomerun_sock_bind_1=hdhomerun_sock_bind(sock, local_ip, (unsigned short int)0, 0);
      if(return_value_hdhomerun_sock_bind_1 == 0)
      {
        hdhomerun_debug_printf(ds->dbg, "discover: failed to bind to %u.%u.%u.%u:0\n", (unsigned int)(local_ip >> 24) & (unsigned int)0xFF, (unsigned int)(local_ip >> 16) & (unsigned int)0xFF, (unsigned int)(local_ip >> 8) & (unsigned int)0xFF, (unsigned int)(local_ip >> 0) & (unsigned int)0xFF);
        hdhomerun_sock_destroy(sock);
        return 0;
      }

      else
      {
        struct hdhomerun_discover_sock_t *hdhomerun_discover_sock_add__1__dss;
        tmp_post_2 = ds->sock_count;
        ds->sock_count = ds->sock_count + 1u;
        hdhomerun_discover_sock_add__1__dss = &ds->socks[(signed long int)tmp_post_2];
        hdhomerun_discover_sock_add__1__dss->sock = sock;
        hdhomerun_discover_sock_add__1__dss->detected = 1;
        hdhomerun_discover_sock_add__1__dss->local_ip = local_ip;
        hdhomerun_discover_sock_add__1__dss->subnet_mask = subnet_mask;
        return 1;
      }
    }
  }
}

// hdhomerun_discover_sock_detect
// file hdhomerun_discover.c line 109
static void hdhomerun_discover_sock_detect(struct hdhomerun_discover_t *ds)
{
  unsigned int i = (unsigned int)1;
  for( ; !(i >= ds->sock_count); i = i + 1u)
  {
    struct hdhomerun_discover_sock_t *dss = &ds->socks[(signed long int)i];
    dss->detected = 0;
  }
  struct hdhomerun_local_ip_info_t ip_info_list[16l];
  signed int count;
  count=hdhomerun_local_ip_info(ip_info_list, 16);
  if(!(count >= 0))
  {
    hdhomerun_debug_printf(ds->dbg, "discover: hdhomerun_local_ip_info returned error\n");
    count = 0;
  }

  if(count >= 17)
  {
    hdhomerun_debug_printf(ds->dbg, "discover: too many local IP addresses\n");
    count = 16;
  }

  signed int index = 0;
  for( ; !(index >= count); index = index + 1)
  {
    struct hdhomerun_local_ip_info_t *ip_info = &ip_info_list[(signed long int)index];
    hdhomerun_discover_sock_add(ds, ip_info->ip_addr, ip_info->subnet_mask);
  }
  struct hdhomerun_discover_sock_t *src = &ds->socks[(signed long int)1];
  struct hdhomerun_discover_sock_t *dst = &ds->socks[(signed long int)1];
  count = 1;
  i = (unsigned int)1;
  for( ; !(i >= ds->sock_count); i = i + 1u)
    if(src->detected == 0)
    {
      hdhomerun_sock_destroy(src->sock);
      src = src + 1l;
    }

    else
    {
      if(!(dst == src))
        *dst = *src;

      src = src + 1l;
      dst = dst + 1l;
      count = count + 1;
    }
  ds->sock_count = (unsigned int)count;
}

// hdhomerun_discover_validate_device_id
// file hdhomerun_discover.h line 66
extern signed int hdhomerun_discover_validate_device_id(unsigned int device_id)
{
  unsigned char checksum = (unsigned char)0;
  static unsigned char lookup_table[16l] = { (unsigned char)0xA, (unsigned char)0x5, (unsigned char)0xF, (unsigned char)0x6, (unsigned char)0x7, (unsigned char)0xC, (unsigned char)0x1, (unsigned char)0xB, (unsigned char)0x9, (unsigned char)0x2, (unsigned char)0x8, (unsigned char)0xD, (unsigned char)0x4, (unsigned char)0x3, (unsigned char)0xE, (unsigned char)0x0 };
  checksum = checksum ^ lookup_table[(signed long int)(device_id >> 28 & (unsigned int)0x0F)];
  checksum = checksum ^ (unsigned char)(device_id >> 24 & (unsigned int)0x0F);
  checksum = checksum ^ lookup_table[(signed long int)(device_id >> 20 & (unsigned int)0x0F)];
  checksum = checksum ^ (unsigned char)(device_id >> 16 & (unsigned int)0x0F);
  checksum = checksum ^ lookup_table[(signed long int)(device_id >> 12 & (unsigned int)0x0F)];
  checksum = checksum ^ (unsigned char)(device_id >> 8 & (unsigned int)0x0F);
  checksum = checksum ^ lookup_table[(signed long int)(device_id >> 4 & (unsigned int)0x0F)];
  checksum = checksum ^ (unsigned char)(device_id >> 0 & (unsigned int)0x0F);
  return (signed int)((signed int)checksum == 0);
}

// hdhomerun_local_ip_info
// file hdhomerun_sock.h line 29
extern signed int hdhomerun_local_ip_info(struct hdhomerun_local_ip_info_t *ip_info_list, signed int max_count)
{
  signed int sock;
  sock=socket(2, 2, 0);
  if(sock == -1)
    return -1;

  else
  {
    struct ifconf ifc;
    unsigned long int ifreq_buffer_size = (unsigned long int)1024;
    while((_Bool)1)
    {
      ifc.ifc_len = (signed int)ifreq_buffer_size;
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(ifreq_buffer_size);
      ifc.ifc_ifcu.ifcu_buf = (char *)return_value_malloc_1;
      if(ifc.ifc_ifcu.ifcu_buf == ((char *)NULL))
      {
        close(sock);
        return -1;
      }

      memset((void *)ifc.ifc_ifcu.ifcu_buf, 0, ifreq_buffer_size);
      signed int return_value_ioctl_2;
      return_value_ioctl_2=ioctl(sock, (unsigned long int)0x8912, &ifc);
      if(!(return_value_ioctl_2 == 0))
      {
        free((void *)ifc.ifc_ifcu.ifcu_buf);
        close(sock);
        return -1;
      }

      if(!((unsigned long int)ifc.ifc_len >= ifreq_buffer_size))
        break;

      free((void *)ifc.ifc_ifcu.ifcu_buf);
      ifreq_buffer_size = ifreq_buffer_size + (unsigned long int)1024;
    }
    char *ptr = ifc.ifc_ifcu.ifcu_buf;
    char *end = ifc.ifc_ifcu.ifcu_buf + (signed long int)ifc.ifc_len;
    signed int count = 0;
    while(!(ptr >= end))
    {
      struct ifreq *ifr = (struct ifreq *)ptr;
      ptr = ptr + (signed long int)sizeof(struct ifreq) /*40ul*/ ;
      signed int return_value_ioctl_3;
      return_value_ioctl_3=ioctl(sock, (unsigned long int)0x8913, ifr);
      if(return_value_ioctl_3 == 0)
      {
        if(!((1 & (signed int)ifr->ifr_ifru.ifru_flags) == 0))
        {
          if(!((64 & (signed int)ifr->ifr_ifru.ifru_flags) == 0))
          {
            signed int return_value_ioctl_4;
            return_value_ioctl_4=ioctl(sock, (unsigned long int)0x8915, ifr);
            if(return_value_ioctl_4 == 0)
            {
              struct sockaddr_in *ip_addr_in = (struct sockaddr_in *)&ifr->ifr_ifru.ifru_addr;
              unsigned int ip_addr;
              ip_addr=__bswap_32_link2(ip_addr_in->sin_addr.s_addr);
              if(!(ip_addr == 0u))
              {
                signed int return_value_ioctl_5;
                return_value_ioctl_5=ioctl(sock, (unsigned long int)0x891b, ifr);
                if(return_value_ioctl_5 == 0)
                {
                  struct sockaddr_in *subnet_mask_in = (struct sockaddr_in *)&ifr->ifr_ifru.ifru_addr;
                  unsigned int subnet_mask;
                  subnet_mask=__bswap_32_link2(subnet_mask_in->sin_addr.s_addr);
                  if(!(count >= max_count))
                  {
                    struct hdhomerun_local_ip_info_t *ip_info = &ip_info_list[(signed long int)count];
                    ip_info->ip_addr = ip_addr;
                    ip_info->subnet_mask = subnet_mask;
                  }

                  count = count + 1;
                }

              }

            }

          }

        }

      }

    }
    free((void *)ifc.ifc_ifcu.ifcu_buf);
    close(sock);
    return count;
  }
}

// hdhomerun_pkt_calc_crc
// file hdhomerun_pkt.c line 48
static unsigned int hdhomerun_pkt_calc_crc(unsigned char *start, unsigned char *end)
{
  unsigned char *pos = start;
  unsigned int crc = 0xFFFFFFFF;
  unsigned char *tmp_post_1;
  while(!(pos >= end))
  {
    unsigned char x;
    tmp_post_1 = pos;
    pos = pos + 1l;
    x = (unsigned char)((signed int)(unsigned char)crc ^ (signed int)*tmp_post_1);
    crc = crc >> 8;
    if(!((0x01 & (signed int)x) == 0))
      crc = crc ^ (unsigned int)0x77073096;

    if(!((0x02 & (signed int)x) == 0))
      crc = crc ^ 0xEE0E612C;

    if(!((0x04 & (signed int)x) == 0))
      crc = crc ^ (unsigned int)0x076DC419;

    if(!((0x08 & (signed int)x) == 0))
      crc = crc ^ (unsigned int)0x0EDB8832;

    if(!((0x10 & (signed int)x) == 0))
      crc = crc ^ (unsigned int)0x1DB71064;

    if(!((0x20 & (signed int)x) == 0))
      crc = crc ^ (unsigned int)0x3B6E20C8;

    if(!((0x40 & (signed int)x) == 0))
      crc = crc ^ (unsigned int)0x76DC4190;

    if(!((0x80 & (signed int)x) == 0))
      crc = crc ^ 0xEDB88320;

  }
  return crc ^ 0xFFFFFFFF;
}

// hdhomerun_pkt_create
// file hdhomerun_pkt.c line 23
extern struct hdhomerun_pkt_t * hdhomerun_pkt_create(void)
{
  struct hdhomerun_pkt_t *pkt;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct hdhomerun_pkt_t) /*3112ul*/ );
  pkt = (struct hdhomerun_pkt_t *)return_value_calloc_1;
  if(pkt == ((struct hdhomerun_pkt_t *)NULL))
    return (struct hdhomerun_pkt_t *)(void *)0;

  else
  {
    hdhomerun_pkt_reset(pkt);
    return pkt;
  }
}

// hdhomerun_pkt_destroy
// file hdhomerun_pkt.c line 35
extern void hdhomerun_pkt_destroy(struct hdhomerun_pkt_t *pkt)
{
  free((void *)pkt);
}

// hdhomerun_pkt_open_frame
// file hdhomerun_pkt.h line 165
extern signed int hdhomerun_pkt_open_frame(struct hdhomerun_pkt_t *pkt, unsigned short int *ptype)
{
  pkt->pos = pkt->start;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  if(!(pkt->end >= pkt->pos + 4l))
    return 0;

  else
  {
    *ptype=hdhomerun_pkt_read_u16(pkt);
    unsigned long int length;
    unsigned short int return_value_hdhomerun_pkt_read_u16_1;
    return_value_hdhomerun_pkt_read_u16_1=hdhomerun_pkt_read_u16(pkt);
    length = (unsigned long int)return_value_hdhomerun_pkt_read_u16_1;
    pkt->pos = pkt->pos + (signed long int)length;
    if(!(pkt->end >= pkt->pos + 4l))
    {
      pkt->pos = pkt->start;
      return 0;
    }

    else
    {
      unsigned int calc_crc;
      calc_crc=hdhomerun_pkt_calc_crc(pkt->start, pkt->pos);
      unsigned int packet_crc;
      tmp_post_2 = pkt->pos;
      pkt->pos = pkt->pos + 1l;
      packet_crc = (unsigned int)*tmp_post_2 << 0;
      tmp_post_3 = pkt->pos;
      pkt->pos = pkt->pos + 1l;
      packet_crc = packet_crc | (unsigned int)*tmp_post_3 << 8;
      tmp_post_4 = pkt->pos;
      pkt->pos = pkt->pos + 1l;
      packet_crc = packet_crc | (unsigned int)*tmp_post_4 << 16;
      tmp_post_5 = pkt->pos;
      pkt->pos = pkt->pos + 1l;
      packet_crc = packet_crc | (unsigned int)*tmp_post_5 << 24;
      if(!(calc_crc == packet_crc))
        return -1;

      else
      {
        pkt->start = pkt->start + (signed long int)4;
        pkt->end = pkt->start + (signed long int)length;
        pkt->pos = pkt->start;
        return 1;
      }
    }
  }
}

// hdhomerun_pkt_read_mem
// file hdhomerun_pkt.h line 157
extern void hdhomerun_pkt_read_mem(struct hdhomerun_pkt_t *pkt, void *mem, unsigned long int length)
{
  memcpy(mem, (const void *)pkt->pos, length);
  pkt->pos = pkt->pos + (signed long int)length;
}

// hdhomerun_pkt_read_tlv
// file hdhomerun_pkt.h line 156
extern unsigned char * hdhomerun_pkt_read_tlv(struct hdhomerun_pkt_t *pkt, unsigned char *ptag, unsigned long int *plength)
{
  if(!(pkt->end >= pkt->pos + 2l))
    return (unsigned char *)(void *)0;

  else
  {
    *ptag=hdhomerun_pkt_read_u8(pkt);
    *plength=hdhomerun_pkt_read_var_length(pkt);
    if(!(pkt->end >= pkt->pos + (signed long int)*plength))
      return (unsigned char *)(void *)0;

    else
      return pkt->pos + (signed long int)*plength;
  }
}

// hdhomerun_pkt_read_u16
// file hdhomerun_pkt.c line 73
extern unsigned short int hdhomerun_pkt_read_u16(struct hdhomerun_pkt_t *pkt)
{
  unsigned short int v;
  unsigned char *tmp_post_1 = pkt->pos;
  pkt->pos = pkt->pos + 1l;
  v = (unsigned short int)((signed int)(unsigned short int)*tmp_post_1 << 8);
  unsigned char *tmp_post_2 = pkt->pos;
  pkt->pos = pkt->pos + 1l;
  v = v | (unsigned short int)((signed int)(unsigned short int)*tmp_post_2 << 0);
  return v;
}

// hdhomerun_pkt_read_u32
// file hdhomerun_pkt.h line 154
extern unsigned int hdhomerun_pkt_read_u32(struct hdhomerun_pkt_t *pkt)
{
  unsigned int v;
  unsigned char *tmp_post_1 = pkt->pos;
  pkt->pos = pkt->pos + 1l;
  v = (unsigned int)*tmp_post_1 << 24;
  unsigned char *tmp_post_2 = pkt->pos;
  pkt->pos = pkt->pos + 1l;
  v = v | (unsigned int)*tmp_post_2 << 16;
  unsigned char *tmp_post_3 = pkt->pos;
  pkt->pos = pkt->pos + 1l;
  v = v | (unsigned int)*tmp_post_3 << 8;
  unsigned char *tmp_post_4 = pkt->pos;
  pkt->pos = pkt->pos + 1l;
  v = v | (unsigned int)*tmp_post_4 << 0;
  return v;
}

// hdhomerun_pkt_read_u8
// file hdhomerun_pkt.h line 152
extern unsigned char hdhomerun_pkt_read_u8(struct hdhomerun_pkt_t *pkt)
{
  unsigned char v;
  unsigned char *tmp_post_1 = pkt->pos;
  pkt->pos = pkt->pos + 1l;
  v = *tmp_post_1;
  return v;
}

// hdhomerun_pkt_read_var_length
// file hdhomerun_pkt.c line 91
extern unsigned long int hdhomerun_pkt_read_var_length(struct hdhomerun_pkt_t *pkt)
{
  unsigned long int length;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  if(!(pkt->end >= pkt->pos + 1l))
    return (unsigned long int)-1;

  else
  {
    tmp_post_1 = pkt->pos;
    pkt->pos = pkt->pos + 1l;
    length = (unsigned long int)*tmp_post_1;
    if(!((128ul & length) == 0ul))
    {
      if(!(pkt->end >= pkt->pos + 1l))
        return (unsigned long int)-1;

      length = length & (unsigned long int)0x007F;
      tmp_post_2 = pkt->pos;
      pkt->pos = pkt->pos + 1l;
      length = length | (unsigned long int)*tmp_post_2 << 7;
    }

    return length;
  }
}

// hdhomerun_pkt_reset
// file hdhomerun_pkt.h line 150
extern void hdhomerun_pkt_reset(struct hdhomerun_pkt_t *pkt)
{
  pkt->limit = (pkt->buffer + (signed long int)sizeof(unsigned char [3074l]) /*3074ul*/ ) - (signed long int)4;
  pkt->start = pkt->buffer + (signed long int)1024;
  pkt->end = pkt->start;
  pkt->pos = pkt->start;
}

// hdhomerun_pkt_seal_frame
// file hdhomerun_pkt.h line 166
extern void hdhomerun_pkt_seal_frame(struct hdhomerun_pkt_t *pkt, unsigned short int frame_type)
{
  unsigned long int length = (unsigned long int)(pkt->end - pkt->start);
  pkt->start = pkt->start - (signed long int)4;
  pkt->pos = pkt->start;
  hdhomerun_pkt_write_u16(pkt, frame_type);
  hdhomerun_pkt_write_u16(pkt, (unsigned short int)length);
  unsigned int crc;
  crc=hdhomerun_pkt_calc_crc(pkt->start, pkt->end);
  unsigned char *tmp_post_1 = pkt->end;
  pkt->end = pkt->end + 1l;
  *tmp_post_1 = (unsigned char)(crc >> 0);
  unsigned char *tmp_post_2 = pkt->end;
  pkt->end = pkt->end + 1l;
  *tmp_post_2 = (unsigned char)(crc >> 8);
  unsigned char *tmp_post_3 = pkt->end;
  pkt->end = pkt->end + 1l;
  *tmp_post_3 = (unsigned char)(crc >> 16);
  unsigned char *tmp_post_4 = pkt->end;
  pkt->end = pkt->end + 1l;
  *tmp_post_4 = (unsigned char)(crc >> 24);
  pkt->pos = pkt->start;
}

// hdhomerun_pkt_write_mem
// file hdhomerun_pkt.h line 163
extern void hdhomerun_pkt_write_mem(struct hdhomerun_pkt_t *pkt, const void *mem, unsigned long int length)
{
  memcpy((void *)pkt->pos, mem, length);
  pkt->pos = pkt->pos + (signed long int)length;
  if(!(pkt->end >= pkt->pos))
    pkt->end = pkt->pos;

}

// hdhomerun_pkt_write_u16
// file hdhomerun_pkt.c line 143
extern void hdhomerun_pkt_write_u16(struct hdhomerun_pkt_t *pkt, unsigned short int v)
{
  unsigned char *tmp_post_1 = pkt->pos;
  pkt->pos = pkt->pos + 1l;
  *tmp_post_1 = (unsigned char)((signed int)v >> 8);
  unsigned char *tmp_post_2 = pkt->pos;
  pkt->pos = pkt->pos + 1l;
  *tmp_post_2 = (unsigned char)((signed int)v >> 0);
  if(!(pkt->end >= pkt->pos))
    pkt->end = pkt->pos;

}

// hdhomerun_pkt_write_u32
// file hdhomerun_pkt.h line 161
extern void hdhomerun_pkt_write_u32(struct hdhomerun_pkt_t *pkt, unsigned int v)
{
  unsigned char *tmp_post_1 = pkt->pos;
  pkt->pos = pkt->pos + 1l;
  *tmp_post_1 = (unsigned char)(v >> 24);
  unsigned char *tmp_post_2 = pkt->pos;
  pkt->pos = pkt->pos + 1l;
  *tmp_post_2 = (unsigned char)(v >> 16);
  unsigned char *tmp_post_3 = pkt->pos;
  pkt->pos = pkt->pos + 1l;
  *tmp_post_3 = (unsigned char)(v >> 8);
  unsigned char *tmp_post_4 = pkt->pos;
  pkt->pos = pkt->pos + 1l;
  *tmp_post_4 = (unsigned char)(v >> 0);
  if(!(pkt->end >= pkt->pos))
    pkt->end = pkt->pos;

}

// hdhomerun_pkt_write_u8
// file hdhomerun_pkt.h line 159
extern void hdhomerun_pkt_write_u8(struct hdhomerun_pkt_t *pkt, unsigned char v)
{
  unsigned char *tmp_post_1 = pkt->pos;
  pkt->pos = pkt->pos + 1l;
  *tmp_post_1 = v;
  if(!(pkt->end >= pkt->pos))
    pkt->end = pkt->pos;

}

// hdhomerun_pkt_write_var_length
// file hdhomerun_pkt.h line 162
extern void hdhomerun_pkt_write_var_length(struct hdhomerun_pkt_t *pkt, unsigned long int v)
{
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  if(!(v >= 128ul))
  {
    tmp_post_1 = pkt->pos;
    pkt->pos = pkt->pos + 1l;
    *tmp_post_1 = (unsigned char)v;
  }

  else
  {
    tmp_post_2 = pkt->pos;
    pkt->pos = pkt->pos + 1l;
    *tmp_post_2 = (unsigned char)(v | (unsigned long int)0x80);
    tmp_post_3 = pkt->pos;
    pkt->pos = pkt->pos + 1l;
    *tmp_post_3 = (unsigned char)(v >> 7);
  }
  if(!(pkt->end >= pkt->pos))
    pkt->end = pkt->pos;

}

// hdhomerun_sock_bind
// file hdhomerun_sock.h line 48
extern signed int hdhomerun_sock_bind(signed int sock, unsigned int local_addr, unsigned short int local_port, signed int allow_reuse)
{
  signed int sock_opt = allow_reuse;
  setsockopt(sock, 1, 2, (const void *)(char *)&sock_opt, (unsigned int)sizeof(signed int) /*4ul*/ );
  struct sockaddr_in sock_addr;
  memset((void *)&sock_addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  sock_addr.sin_family = (unsigned short int)2;
  sock_addr.sin_addr.s_addr=__bswap_32_link2(local_addr);
  unsigned short int tmp_statement_expression_1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)local_port;
  asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression_1 = __v;
  sock_addr.sin_port = tmp_statement_expression_1;
  signed int return_value_bind_2;
  return_value_bind_2=bind(sock, (struct sockaddr *)&sock_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(return_value_bind_2 == 0))
    return 0;

  else
    return 1;
}

// hdhomerun_sock_connect
// file hdhomerun_sock.h line 49
extern signed int hdhomerun_sock_connect(signed int sock, unsigned int remote_addr, unsigned short int remote_port, unsigned long int timeout)
{
  struct sockaddr_in sock_addr;
  memset((void *)&sock_addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  sock_addr.sin_family = (unsigned short int)2;
  sock_addr.sin_addr.s_addr=__bswap_32_link2(remote_addr);
  unsigned short int tmp_statement_expression_1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)remote_port;
  asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression_1 = __v;
  sock_addr.sin_port = tmp_statement_expression_1;
  signed int return_value_connect_5;
  return_value_connect_5=connect(sock, (struct sockaddr *)&sock_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  signed int *return_value___errno_location_3;
  signed int *return_value___errno_location_2;
  if(!(return_value_connect_5 == 0))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    if(!(*return_value___errno_location_4 == 11))
    {
      return_value___errno_location_3=__errno_location();
      if(!(*return_value___errno_location_3 == 11))
      {
        return_value___errno_location_2=__errno_location();
        if(!(*return_value___errno_location_2 == 115))
          return 0;

      }

    }

  }

  unsigned long int stop_time;
  unsigned long int return_value_getcurrenttime_6;
  return_value_getcurrenttime_6=getcurrenttime();
  stop_time = return_value_getcurrenttime_6 + timeout;
  signed int return_value_hdhomerun_sock_wait_for_event_7;
  return_value_hdhomerun_sock_wait_for_event_7=hdhomerun_sock_wait_for_event(sock, (signed short int)0x004, stop_time);
  return return_value_hdhomerun_sock_wait_for_event_7;
}

// hdhomerun_sock_create_tcp
// file hdhomerun_sock.h line 36
extern signed int hdhomerun_sock_create_tcp(void)
{
  signed int sock;
  signed int return_value_socket_1;
  return_value_socket_1=socket(2, 1, 0);
  sock = (signed int)return_value_socket_1;
  if(sock == -1)
    return -1;

  else
  {
    signed int return_value_fcntl_2;
    return_value_fcntl_2=fcntl(sock, 4, 04000);
    if(!(return_value_fcntl_2 == 0))
    {
      close(sock);
      return -1;
    }

    else
      return sock;
  }
}

// hdhomerun_sock_create_udp
// file hdhomerun_sock.h line 35
extern signed int hdhomerun_sock_create_udp(void)
{
  signed int sock;
  signed int return_value_socket_1;
  return_value_socket_1=socket(2, 2, 0);
  sock = (signed int)return_value_socket_1;
  if(sock == -1)
    return -1;

  else
  {
    signed int return_value_fcntl_2;
    return_value_fcntl_2=fcntl(sock, 4, 04000);
    if(!(return_value_fcntl_2 == 0))
    {
      close(sock);
      return -1;
    }

    else
    {
      signed int sock_opt = 1;
      setsockopt(sock, 1, 6, (const void *)(char *)&sock_opt, (unsigned int)sizeof(signed int) /*4ul*/ );
      return sock;
    }
  }
}

// hdhomerun_sock_destroy
// file hdhomerun_sock.h line 37
extern void hdhomerun_sock_destroy(signed int sock)
{
  close(sock);
}

// hdhomerun_sock_getaddrinfo_addr
// file hdhomerun_sock.h line 43
extern unsigned int hdhomerun_sock_getaddrinfo_addr(signed int sock, const char *name)
{
  struct addrinfo hints;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 2;
  hints.ai_socktype = 1;
  hints.ai_protocol = 6;
  struct addrinfo *sock_info;
  signed int return_value_getaddrinfo_1;
  return_value_getaddrinfo_1=getaddrinfo(name, (const char *)(void *)0, &hints, &sock_info);
  if(!(return_value_getaddrinfo_1 == 0))
    return (unsigned int)0;

  else
  {
    struct sockaddr_in *sock_addr = (struct sockaddr_in *)sock_info->ai_addr;
    unsigned int addr;
    addr=__bswap_32_link2(sock_addr->sin_addr.s_addr);
    freeaddrinfo(sock_info);
    return addr;
  }
}

// hdhomerun_sock_getlasterror
// file hdhomerun_sock.h line 39
extern signed int hdhomerun_sock_getlasterror(void)
{
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  return *return_value___errno_location_1;
}

// hdhomerun_sock_getpeername_addr
// file hdhomerun_sock_posix.c line 216
extern unsigned int hdhomerun_sock_getpeername_addr(signed int sock)
{
  struct sockaddr_in sock_addr;
  unsigned int sockaddr_size = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  signed int return_value_getpeername_1;
  return_value_getpeername_1=getpeername(sock, (struct sockaddr *)&sock_addr, &sockaddr_size);
  if(!(return_value_getpeername_1 == 0))
    return (unsigned int)0;

  else
  {
    unsigned int return_value___bswap_32_2;
    return_value___bswap_32_2=__bswap_32_link2(sock_addr.sin_addr.s_addr);
    return return_value___bswap_32_2;
  }
}

// hdhomerun_sock_getsockname_addr
// file hdhomerun_sock.h line 40
extern unsigned int hdhomerun_sock_getsockname_addr(signed int sock)
{
  struct sockaddr_in sock_addr;
  unsigned int sockaddr_size = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  signed int return_value_getsockname_1;
  return_value_getsockname_1=getsockname(sock, (struct sockaddr *)&sock_addr, &sockaddr_size);
  if(!(return_value_getsockname_1 == 0))
    return (unsigned int)0;

  else
  {
    unsigned int return_value___bswap_32_2;
    return_value___bswap_32_2=__bswap_32_link2(sock_addr.sin_addr.s_addr);
    return return_value___bswap_32_2;
  }
}

// hdhomerun_sock_getsockname_port
// file hdhomerun_sock_posix.c line 204
extern unsigned short int hdhomerun_sock_getsockname_port(signed int sock)
{
  struct sockaddr_in sock_addr;
  unsigned int sockaddr_size = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  signed int return_value_getsockname_1;
  return_value_getsockname_1=getsockname(sock, (struct sockaddr *)&sock_addr, &sockaddr_size);
  unsigned short int tmp_statement_expression_2;
  if(!(return_value_getsockname_1 == 0))
    return (unsigned short int)0;

  else
  {
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)sock_addr.sin_port;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression_2 = __v;
    return tmp_statement_expression_2;
  }
}

// hdhomerun_sock_join_multicast_group
// file hdhomerun_sock_posix.c line 248
extern signed int hdhomerun_sock_join_multicast_group(signed int sock, unsigned int multicast_ip, unsigned int local_ip)
{
  struct ip_mreq imr;
  memset((void *)&imr, 0, sizeof(struct ip_mreq) /*8ul*/ );
  imr.imr_multiaddr.s_addr=__bswap_32_link2(multicast_ip);
  imr.imr_interface.s_addr=__bswap_32_link2(local_ip);
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(sock, 0, 35, (const void *)(const char *)&imr, (unsigned int)sizeof(struct ip_mreq) /*8ul*/ );
  if(!(return_value_setsockopt_1 == 0))
    return 0;

  else
    return 1;
}

// hdhomerun_sock_leave_multicast_group
// file hdhomerun_sock_posix.c line 262
extern signed int hdhomerun_sock_leave_multicast_group(signed int sock, unsigned int multicast_ip, unsigned int local_ip)
{
  struct ip_mreq imr;
  memset((void *)&imr, 0, sizeof(struct ip_mreq) /*8ul*/ );
  imr.imr_multiaddr.s_addr=__bswap_32_link2(multicast_ip);
  imr.imr_interface.s_addr=__bswap_32_link2(local_ip);
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(sock, 0, 36, (const void *)(const char *)&imr, (unsigned int)sizeof(struct ip_mreq) /*8ul*/ );
  if(!(return_value_setsockopt_1 == 0))
    return 0;

  else
    return 1;
}

// hdhomerun_sock_recv
// file hdhomerun_sock.h line 54
extern signed int hdhomerun_sock_recv(signed int sock, void *data, unsigned long int *length, unsigned long int timeout)
{
  unsigned long int stop_time;
  unsigned long int return_value_getcurrenttime_1;
  return_value_getcurrenttime_1=getcurrenttime();
  stop_time = return_value_getcurrenttime_1 + timeout;
  signed int *return_value___errno_location_4;
  signed int *return_value___errno_location_3;
  while((_Bool)1)
  {
    signed int ret;
    signed long int return_value_recv_2;
    return_value_recv_2=recv(sock, data, *length, 0);
    ret = (signed int)return_value_recv_2;
    if(!(ret >= 0))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      if(!(*return_value___errno_location_5 == 11))
      {
        return_value___errno_location_4=__errno_location();
        if(!(*return_value___errno_location_4 == 11))
        {
          return_value___errno_location_3=__errno_location();
          if(!(*return_value___errno_location_3 == 115))
            return 0;

        }

      }

      signed int return_value_hdhomerun_sock_wait_for_event_6;
      return_value_hdhomerun_sock_wait_for_event_6=hdhomerun_sock_wait_for_event(sock, (signed short int)0x001, stop_time);
      if(return_value_hdhomerun_sock_wait_for_event_6 == 0)
        return 0;

      continue;
    }

    if(ret == 0)
      return 0;

    *length = (unsigned long int)ret;
    return 1;
  }
}

// hdhomerun_sock_recvfrom
// file hdhomerun_sock.h line 55
extern signed int hdhomerun_sock_recvfrom(signed int sock, unsigned int *remote_addr, unsigned short int *remote_port, void *data, unsigned long int *length, unsigned long int timeout)
{
  unsigned long int stop_time;
  unsigned long int return_value_getcurrenttime_1;
  return_value_getcurrenttime_1=getcurrenttime();
  stop_time = return_value_getcurrenttime_1 + timeout;
  signed int *return_value___errno_location_4;
  signed int *return_value___errno_location_3;
  unsigned short int tmp_statement_expression_7;
  while((_Bool)1)
  {
    struct sockaddr_in sock_addr;
    memset((void *)&sock_addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    unsigned int sockaddr_size = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
    signed int ret;
    signed long int return_value_recvfrom_2;
    return_value_recvfrom_2=recvfrom(sock, data, *length, 0, (struct sockaddr *)&sock_addr, &sockaddr_size);
    ret = (signed int)return_value_recvfrom_2;
    if(!(ret >= 0))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      if(!(*return_value___errno_location_5 == 11))
      {
        return_value___errno_location_4=__errno_location();
        if(!(*return_value___errno_location_4 == 11))
        {
          return_value___errno_location_3=__errno_location();
          if(!(*return_value___errno_location_3 == 115))
            return 0;

        }

      }

      signed int return_value_hdhomerun_sock_wait_for_event_6;
      return_value_hdhomerun_sock_wait_for_event_6=hdhomerun_sock_wait_for_event(sock, (signed short int)0x001, stop_time);
      if(return_value_hdhomerun_sock_wait_for_event_6 == 0)
        return 0;

      continue;
    }

    if(ret == 0)
      return 0;

    *remote_addr=__bswap_32_link2(sock_addr.sin_addr.s_addr);
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)sock_addr.sin_port;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression_7 = __v;
    *remote_port = tmp_statement_expression_7;
    *length = (unsigned long int)ret;
    return 1;
  }
}

// hdhomerun_sock_send
// file hdhomerun_sock.h line 51
extern signed int hdhomerun_sock_send(signed int sock, const void *data, unsigned long int length, unsigned long int timeout)
{
  unsigned long int stop_time;
  unsigned long int return_value_getcurrenttime_1;
  return_value_getcurrenttime_1=getcurrenttime();
  stop_time = return_value_getcurrenttime_1 + timeout;
  const unsigned char *ptr = (const unsigned char *)data;
  signed int *return_value___errno_location_4;
  signed int *return_value___errno_location_3;
  while((_Bool)1)
  {
    signed int ret;
    signed long int return_value_send_2;
    return_value_send_2=send(sock, (const void *)ptr, length, 16384);
    ret = (signed int)return_value_send_2;
    if(!(ret >= 1))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      if(!(*return_value___errno_location_5 == 11))
      {
        return_value___errno_location_4=__errno_location();
        if(!(*return_value___errno_location_4 == 11))
        {
          return_value___errno_location_3=__errno_location();
          if(!(*return_value___errno_location_3 == 115))
            return 0;

        }

      }

      signed int return_value_hdhomerun_sock_wait_for_event_6;
      return_value_hdhomerun_sock_wait_for_event_6=hdhomerun_sock_wait_for_event(sock, (signed short int)0x004, stop_time);
      if(return_value_hdhomerun_sock_wait_for_event_6 == 0)
        return 0;

      continue;
    }

    if(!(ret >= (signed int)length))
    {
      ptr = ptr + (signed long int)ret;
      length = length - (unsigned long int)ret;
    }

    else
      return 1;
  }
}

// hdhomerun_sock_sendto
// file hdhomerun_sock.h line 52
extern signed int hdhomerun_sock_sendto(signed int sock, unsigned int remote_addr, unsigned short int remote_port, const void *data, unsigned long int length, unsigned long int timeout)
{
  unsigned long int stop_time;
  unsigned long int return_value_getcurrenttime_1;
  return_value_getcurrenttime_1=getcurrenttime();
  stop_time = return_value_getcurrenttime_1 + timeout;
  const unsigned char *ptr = (const unsigned char *)data;
  unsigned short int tmp_statement_expression_2;
  signed int *return_value___errno_location_5;
  signed int *return_value___errno_location_4;
  while((_Bool)1)
  {
    struct sockaddr_in sock_addr;
    memset((void *)&sock_addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    sock_addr.sin_family = (unsigned short int)2;
    sock_addr.sin_addr.s_addr=__bswap_32_link2(remote_addr);
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)remote_port;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression_2 = __v;
    sock_addr.sin_port = tmp_statement_expression_2;
    signed int ret;
    signed long int return_value_sendto_3;
    return_value_sendto_3=sendto(sock, (const void *)ptr, length, 0, (struct sockaddr *)&sock_addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    ret = (signed int)return_value_sendto_3;
    if(!(ret >= 1))
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      if(!(*return_value___errno_location_6 == 11))
      {
        return_value___errno_location_5=__errno_location();
        if(!(*return_value___errno_location_5 == 11))
        {
          return_value___errno_location_4=__errno_location();
          if(!(*return_value___errno_location_4 == 115))
            return 0;

        }

      }

      signed int return_value_hdhomerun_sock_wait_for_event_7;
      return_value_hdhomerun_sock_wait_for_event_7=hdhomerun_sock_wait_for_event(sock, (signed short int)0x004, stop_time);
      if(return_value_hdhomerun_sock_wait_for_event_7 == 0)
        return 0;

      continue;
    }

    if(!(ret >= (signed int)length))
    {
      ptr = ptr + (signed long int)ret;
      length = length - (unsigned long int)ret;
    }

    else
      return 1;
  }
}

// hdhomerun_sock_wait_for_event
// file hdhomerun_sock_posix.c line 294
static signed int hdhomerun_sock_wait_for_event(signed int sock, signed short int event_type, unsigned long int stop_time)
{
  unsigned long int current_time;
  current_time=getcurrenttime();
  if(current_time >= stop_time)
    return 0;

  else
  {
    struct pollfd poll_event;
    poll_event.fd = sock;
    poll_event.events = event_type;
    poll_event.revents = (signed short int)0;
    unsigned long int timeout = stop_time - current_time;
    signed int return_value_poll_1;
    return_value_poll_1=poll(&poll_event, (unsigned long int)1, (signed int)timeout);
    if(!(return_value_poll_1 >= 1))
      return 0;

    else
      if(((signed int)poll_event.revents & (signed int)event_type) == 0)
        return 0;

      else
        return 1;
  }
}

// hdhomerun_sprintf
// file hdhomerun_os_posix.h line 59
extern signed int hdhomerun_sprintf(char *buffer, char *end, const char *fmt, ...)
{
  void **ap = (void **)&fmt;
  signed int result;
  result=hdhomerun_vsprintf(buffer, end, fmt, ap);
  ap = ((void **)NULL);
  return result;
}

// hdhomerun_video_create
// file hdhomerun_video.h line 51
extern struct hdhomerun_video_sock_t * hdhomerun_video_create(unsigned short int listen_port, signed int allow_port_reuse, unsigned long int buffer_size, struct hdhomerun_debug_t *dbg)
{
  struct hdhomerun_video_sock_t *vs;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct hdhomerun_video_sock_t) /*8328ul*/ );
  vs = (struct hdhomerun_video_sock_t *)return_value_calloc_1;
  void *return_value_malloc_2;
  signed int rx_size;
  signed int return_value_hdhomerun_sock_bind_3;
  signed int return_value_pthread_create_4;
  if(vs == ((struct hdhomerun_video_sock_t *)NULL))
  {
    hdhomerun_debug_printf(dbg, "hdhomerun_video_create: failed to allocate video object\n");
    return (struct hdhomerun_video_sock_t *)(void *)0;
  }

  else
  {
    vs->dbg = dbg;
    vs->sock = -1;
    pthread_mutex_init(&vs->lock, (const union anonymous_3 *)(void *)0);
    hdhomerun_video_flush(vs);
    vs->buffer_size = (buffer_size / (unsigned long int)(188 * 7)) * (unsigned long int)(188 * 7);
    if(vs->buffer_size == 0ul)
      hdhomerun_debug_printf(dbg, "hdhomerun_video_create: invalid buffer size (%lu bytes)\n", (unsigned long int)buffer_size);

    else
    {
      vs->buffer_size = vs->buffer_size + (unsigned long int)(188 * 7);
      return_value_malloc_2=malloc(vs->buffer_size);
      vs->buffer = (unsigned char *)return_value_malloc_2;
      if(vs->buffer == ((unsigned char *)NULL))
        hdhomerun_debug_printf(dbg, "hdhomerun_video_create: failed to allocate buffer (%lu bytes)\n", (unsigned long int)vs->buffer_size);

      else
      {
        vs->sock=hdhomerun_sock_create_udp();
        if(vs->sock == -1)
          hdhomerun_debug_printf(dbg, "hdhomerun_video_create: failed to allocate socket\n");

        else
        {
          rx_size = 1024 * 1024;
          setsockopt(vs->sock, 1, 8, (const void *)(char *)&rx_size, (unsigned int)sizeof(signed int) /*4ul*/ );
          return_value_hdhomerun_sock_bind_3=hdhomerun_sock_bind(vs->sock, (unsigned int)0x00000000, listen_port, allow_port_reuse);
          if(return_value_hdhomerun_sock_bind_3 == 0)
            hdhomerun_debug_printf(dbg, "hdhomerun_video_create: failed to bind socket (port %u)\n", listen_port);

          else
          {
            return_value_pthread_create_4=pthread_create(&vs->thread, (const union pthread_attr_t *)(void *)0, hdhomerun_video_thread_execute, (void *)vs);
            if(!(return_value_pthread_create_4 == 0))
              hdhomerun_debug_printf(dbg, "hdhomerun_video_create: failed to start thread\n");

            else
              return vs;
          }
        }
      }
    }

  error:
    ;
    if(!(vs->sock == -1))
      hdhomerun_sock_destroy(vs->sock);

    if(!(vs->buffer == ((unsigned char *)NULL)))
      free((void *)vs->buffer);

    free((void *)vs);
    return (struct hdhomerun_video_sock_t *)(void *)0;
  }
}

// hdhomerun_video_debug_print_stats
// file hdhomerun_video.h line 94
extern void hdhomerun_video_debug_print_stats(struct hdhomerun_video_sock_t *vs)
{
  struct hdhomerun_video_stats_t stats;
  hdhomerun_video_get_stats(vs, &stats);
  hdhomerun_debug_printf(vs->dbg, "video sock: pkt=%u net=%u te=%u miss=%u drop=%u\n", (unsigned int)stats.packet_count, (unsigned int)stats.network_error_count, (unsigned int)stats.transport_error_count, (unsigned int)stats.sequence_error_count, (unsigned int)stats.overflow_error_count);
}

// hdhomerun_video_destroy
// file hdhomerun_video.h line 52
extern void hdhomerun_video_destroy(struct hdhomerun_video_sock_t *vs)
{
  vs->terminate = 1;
  pthread_join(vs->thread, (void **)(void *)0);
  hdhomerun_sock_destroy(vs->sock);
  free((void *)vs->buffer);
  free((void *)vs);
}

// hdhomerun_video_flush
// file hdhomerun_video.h line 89
extern void hdhomerun_video_flush(struct hdhomerun_video_sock_t *vs)
{
  pthread_mutex_lock(&vs->lock);
  vs->tail = vs->head;
  vs->advance = (unsigned long int)0;
  vs->rtp_sequence = 0xFFFFFFFF;
  signed int i = 0;
  for( ; !(i >= 0x2000); i = i + 1)
    vs->sequence[(signed long int)i] = (volatile unsigned char)0xFF;
  vs->packet_count = (volatile unsigned int)0;
  vs->transport_error_count = (volatile unsigned int)0;
  vs->network_error_count = (volatile unsigned int)0;
  vs->sequence_error_count = (volatile unsigned int)0;
  vs->overflow_error_count = (volatile unsigned int)0;
  pthread_mutex_unlock(&vs->lock);
}

// hdhomerun_video_get_local_port
// file hdhomerun_video.h line 59
extern unsigned short int hdhomerun_video_get_local_port(struct hdhomerun_video_sock_t *vs)
{
  unsigned short int port;
  port=hdhomerun_sock_getsockname_port(vs->sock);
  if((signed int)port == 0)
  {
    signed int return_value_hdhomerun_sock_getlasterror_1;
    return_value_hdhomerun_sock_getlasterror_1=hdhomerun_sock_getlasterror();
    hdhomerun_debug_printf(vs->dbg, "hdhomerun_video_get_local_port: getsockname failed (%d)\n", return_value_hdhomerun_sock_getlasterror_1);
    return (unsigned short int)0;
  }

  return port;
}

// hdhomerun_video_get_sock
// file hdhomerun_video.c line 128
extern signed int hdhomerun_video_get_sock(struct hdhomerun_video_sock_t *vs)
{
  return vs->sock;
}

// hdhomerun_video_get_stats
// file hdhomerun_video.h line 95
extern void hdhomerun_video_get_stats(struct hdhomerun_video_sock_t *vs, struct hdhomerun_video_stats_t *stats)
{
  memset((void *)stats, 0, sizeof(struct hdhomerun_video_stats_t) /*20ul*/ );
  pthread_mutex_lock(&vs->lock);
  stats->packet_count = vs->packet_count;
  stats->network_error_count = vs->network_error_count;
  stats->transport_error_count = vs->transport_error_count;
  stats->sequence_error_count = vs->sequence_error_count;
  stats->overflow_error_count = vs->overflow_error_count;
  pthread_mutex_unlock(&vs->lock);
}

// hdhomerun_video_join_multicast_group
// file hdhomerun_video.h line 64
extern signed int hdhomerun_video_join_multicast_group(struct hdhomerun_video_sock_t *vs, unsigned int multicast_ip, unsigned int local_ip)
{
  signed int return_value_hdhomerun_sock_join_multicast_group_2;
  return_value_hdhomerun_sock_join_multicast_group_2=hdhomerun_sock_join_multicast_group(vs->sock, multicast_ip, local_ip);
  if(return_value_hdhomerun_sock_join_multicast_group_2 == 0)
  {
    signed int return_value_hdhomerun_sock_getlasterror_1;
    return_value_hdhomerun_sock_getlasterror_1=hdhomerun_sock_getlasterror();
    hdhomerun_debug_printf(vs->dbg, "hdhomerun_video_join_multicast_group: setsockopt failed (%d)\n", return_value_hdhomerun_sock_getlasterror_1);
    return -1;
  }

  return 1;
}

// hdhomerun_video_leave_multicast_group
// file hdhomerun_video.h line 65
extern void hdhomerun_video_leave_multicast_group(struct hdhomerun_video_sock_t *vs, unsigned int multicast_ip, unsigned int local_ip)
{
  signed int return_value_hdhomerun_sock_leave_multicast_group_2;
  return_value_hdhomerun_sock_leave_multicast_group_2=hdhomerun_sock_leave_multicast_group(vs->sock, multicast_ip, local_ip);
  if(return_value_hdhomerun_sock_leave_multicast_group_2 == 0)
  {
    signed int return_value_hdhomerun_sock_getlasterror_1;
    return_value_hdhomerun_sock_getlasterror_1=hdhomerun_sock_getlasterror();
    hdhomerun_debug_printf(vs->dbg, "hdhomerun_video_leave_multicast_group: setsockopt failed (%d)\n", return_value_hdhomerun_sock_getlasterror_1);
  }

}

// hdhomerun_video_parse_rtp
// file hdhomerun_video.c line 193
static void hdhomerun_video_parse_rtp(struct hdhomerun_video_sock_t *vs, struct hdhomerun_pkt_t *pkt)
{
  pkt->pos = pkt->pos + (signed long int)2;
  unsigned int rtp_sequence;
  unsigned short int return_value_hdhomerun_pkt_read_u16_1;
  return_value_hdhomerun_pkt_read_u16_1=hdhomerun_pkt_read_u16(pkt);
  rtp_sequence = (unsigned int)return_value_hdhomerun_pkt_read_u16_1;
  pkt->pos = pkt->pos + (signed long int)8;
  unsigned int previous_rtp_sequence = vs->rtp_sequence;
  vs->rtp_sequence = rtp_sequence;
  if(!(previous_rtp_sequence == 0xFFFFFFFF))
  {
    if(!(rtp_sequence == (1u + previous_rtp_sequence & 65535u)))
    {
      vs->network_error_count = vs->network_error_count + 1u;
      signed int i = 0;
      for( ; !(i >= 0x2000); i = i + 1)
        vs->sequence[(signed long int)i] = (volatile unsigned char)0xFF;
    }

  }

}

// hdhomerun_video_recv
// file hdhomerun_video.h line 84
extern unsigned char * hdhomerun_video_recv(struct hdhomerun_video_sock_t *vs, unsigned long int max_size, unsigned long int *pactual_size)
{
  pthread_mutex_lock(&vs->lock);
  unsigned long int head = vs->head;
  unsigned long int tail = vs->tail;
  if(vs->advance >= 1ul)
  {
    tail = tail + vs->advance;
    if(tail >= vs->buffer_size)
      tail = tail - vs->buffer_size;

    vs->tail = tail;
  }

  if(head == tail)
  {
    vs->advance = (unsigned long int)0;
    *pactual_size = (unsigned long int)0;
    pthread_mutex_unlock(&vs->lock);
    return (unsigned char *)(void *)0;
  }

  else
  {
    unsigned long int size = (max_size / (unsigned long int)(188 * 7)) * (unsigned long int)(188 * 7);
    if(size == 0ul)
    {
      vs->advance = (unsigned long int)0;
      *pactual_size = (unsigned long int)0;
      pthread_mutex_unlock(&vs->lock);
      return (unsigned char *)(void *)0;
    }

    else
    {
      unsigned long int avail;
      if(!(tail >= head))
        avail = head - tail;

      else
        avail = vs->buffer_size - tail;
      if(!(avail >= size))
        size = avail;

      vs->advance = size;
      *pactual_size = size;
      unsigned char *result = vs->buffer + (signed long int)tail;
      pthread_mutex_unlock(&vs->lock);
      return result;
    }
  }
}

// hdhomerun_video_stats_ts_pkt
// file hdhomerun_video.c line 161
static void hdhomerun_video_stats_ts_pkt(struct hdhomerun_video_sock_t *vs, unsigned char *ptr)
{
  unsigned short int packet_identifier = (unsigned short int)((signed int)(unsigned short int)((signed int)ptr[(signed long int)1] & 0x1F) << 8 | (signed int)(unsigned short int)ptr[(signed long int)2]);
  if(!((signed int)packet_identifier == 0x1FFF))
  {
    signed int transport_error = (signed int)ptr[(signed long int)1] >> 7;
    if(!(transport_error == 0))
    {
      vs->transport_error_count = vs->transport_error_count + 1u;
      vs->sequence[(signed long int)packet_identifier] = (volatile unsigned char)0xFF;
    }

    else
    {
      unsigned char sequence = (unsigned char)((signed int)ptr[(signed long int)3] & 0x0F);
      unsigned char previous_sequence = vs->sequence[(signed long int)packet_identifier];
      vs->sequence[(signed long int)packet_identifier] = sequence;
      if(!((signed int)previous_sequence == 0xFF))
      {
        if(!((signed int)sequence == (1 + (signed int)previous_sequence & 0x0F)))
        {
          if(!(sequence == previous_sequence))
            vs->sequence_error_count = vs->sequence_error_count + 1u;

        }

      }

    }
  }

}

// hdhomerun_video_thread_execute
// file hdhomerun_video.c line 222
static void * hdhomerun_video_thread_execute(void *arg)
{
  struct hdhomerun_video_sock_t *vs = (struct hdhomerun_video_sock_t *)arg;
  struct hdhomerun_pkt_t pkt_inst;
  while(vs->terminate == 0)
  {
    struct hdhomerun_pkt_t *pkt = &pkt_inst;
    hdhomerun_pkt_reset(pkt);
    unsigned long int length = (unsigned long int)(188 * 7 + 12);
    signed int return_value_hdhomerun_sock_recv_1;
    return_value_hdhomerun_sock_recv_1=hdhomerun_sock_recv(vs->sock, (void *)pkt->end, &length, (unsigned long int)25);
    if(!(return_value_hdhomerun_sock_recv_1 == 0))
    {
      pkt->end = pkt->end + (signed long int)length;
      if(length == 1328ul)
      {
        hdhomerun_video_parse_rtp(vs, pkt);
        length = (unsigned long int)(signed int)(pkt->end - pkt->pos);
      }

      if(length == 1316ul)
      {
        pthread_mutex_lock(&vs->lock);
        unsigned long int head = vs->head;
        unsigned char *ptr = vs->buffer + (signed long int)head;
        memcpy((void *)ptr, (const void *)pkt->pos, length);
        vs->packet_count = vs->packet_count + 1u;
        hdhomerun_video_stats_ts_pkt(vs, ptr + (signed long int)(188 * 0));
        hdhomerun_video_stats_ts_pkt(vs, ptr + (signed long int)(188 * 1));
        hdhomerun_video_stats_ts_pkt(vs, ptr + (signed long int)(188 * 2));
        hdhomerun_video_stats_ts_pkt(vs, ptr + (signed long int)(188 * 3));
        hdhomerun_video_stats_ts_pkt(vs, ptr + (signed long int)(188 * 4));
        hdhomerun_video_stats_ts_pkt(vs, ptr + (signed long int)(188 * 5));
        hdhomerun_video_stats_ts_pkt(vs, ptr + (signed long int)(188 * 6));
        head = head + length;
        if(head >= vs->buffer_size)
          head = head - vs->buffer_size;

        if(head == vs->tail)
        {
          vs->overflow_error_count = vs->overflow_error_count + 1u;
          pthread_mutex_unlock(&vs->lock);
        }

        else
        {
          vs->head = head;
          pthread_mutex_unlock(&vs->lock);
        }
      }

    }

  }
  return (void *)0;
}

// hdhomerun_vsprintf
// file hdhomerun_os_posix.h line 58
extern signed int hdhomerun_vsprintf(char *buffer, char *end, const char *fmt, void **ap)
{
  if(buffer >= end)
    return 0;

  else
  {
    signed int length;
    length=vsnprintf(buffer, (unsigned long int)((end - buffer) - (signed long int)1), fmt, ap);
    if(!(length >= 0))
    {
      *buffer = (char)0;
      return 0;
    }

    else
      if(!(end >= buffer + (signed long int)length + 1l))
      {
        *(end - (signed long int)1) = (char)0;
        return 0;
      }

      else
        return 1;
  }
}

// help
// file hdhomerun_config.c line 37
static signed int help(void)
{
  printf("Usage:\n");
  printf("\t%s discover\n", appname);
  printf("\t%s <id> get help\n", appname);
  printf("\t%s <id> get <item>\n", appname);
  printf("\t%s <id> set <item> <value>\n", appname);
  printf("\t%s <id> scan <tuner> [<filename>]\n", appname);
  printf("\t%s <id> save <tuner> <filename>\n", appname);
  printf("\t%s <id> upgrade <filename>\n", appname);
  return -1;
}

// main
// file hdhomerun_config.c line 686
signed int main(signed int argc, char **argv)
{
  signed int ret;
  ret=main_internal(argc, argv);
  if(!(ret >= 1))
    return 1;

  else
    return 0;
}

// main_cmd
// file hdhomerun_config.c line 561
static signed int main_cmd(signed int argc, char **argv)
{
  if(!(argc >= 1))
  {
    signed int return_value_help_1;
    return_value_help_1=help();
    return return_value_help_1;
  }

  char *cmd;
  char **tmp_post_2 = argv;
  argv = argv + 1l;
  cmd = *tmp_post_2;
  argc = argc - 1;
  signed int return_value_contains_5;
  return_value_contains_5=contains(cmd, "key");
  if(!(return_value_contains_5 == 0))
  {
    if(!(argc >= 2))
    {
      signed int return_value_help_3;
      return_value_help_3=help();
      return return_value_help_3;
    }

    unsigned int lockkey;
    unsigned long int return_value_strtoul_4;
    return_value_strtoul_4=strtoul(argv[(signed long int)0], (char ** restrict )(void *)0, 0);
    lockkey = (unsigned int)return_value_strtoul_4;
    hdhomerun_device_tuner_lockkey_use_value(hd, lockkey);
    cmd = argv[(signed long int)1];
    argv = argv + (signed long int)2;
    argc = argc - 2;
  }

  signed int return_value_contains_8;
  return_value_contains_8=contains(cmd, "get");
  if(!(return_value_contains_8 == 0))
  {
    if(!(argc >= 1))
    {
      signed int return_value_help_6;
      return_value_help_6=help();
      return return_value_help_6;
    }

    signed int return_value_cmd_get_7;
    return_value_cmd_get_7=cmd_get(argv[(signed long int)0]);
    return return_value_cmd_get_7;
  }

  signed int return_value_contains_11;
  return_value_contains_11=contains(cmd, "set");
  if(!(return_value_contains_11 == 0))
  {
    if(!(argc >= 2))
    {
      signed int return_value_help_9;
      return_value_help_9=help();
      return return_value_help_9;
    }

    signed int return_value_cmd_set_10;
    return_value_cmd_set_10=cmd_set(argv[(signed long int)0], argv[(signed long int)1]);
    return return_value_cmd_set_10;
  }

  signed int return_value_contains_15;
  return_value_contains_15=contains(cmd, "scan");
  if(!(return_value_contains_15 == 0))
  {
    if(!(argc >= 1))
    {
      signed int return_value_help_12;
      return_value_help_12=help();
      return return_value_help_12;
    }

    if(!(argc >= 2))
    {
      signed int return_value_cmd_scan_13;
      return_value_cmd_scan_13=cmd_scan(argv[(signed long int)0], (const char *)(void *)0);
      return return_value_cmd_scan_13;
    }

    else
    {
      signed int return_value_cmd_scan_14;
      return_value_cmd_scan_14=cmd_scan(argv[(signed long int)0], argv[(signed long int)1]);
      return return_value_cmd_scan_14;
    }
  }

  signed int return_value_contains_18;
  return_value_contains_18=contains(cmd, "save");
  if(!(return_value_contains_18 == 0))
  {
    if(!(argc >= 2))
    {
      signed int return_value_help_16;
      return_value_help_16=help();
      return return_value_help_16;
    }

    signed int return_value_cmd_save_17;
    return_value_cmd_save_17=cmd_save(argv[(signed long int)0], argv[(signed long int)1]);
    return return_value_cmd_save_17;
  }

  signed int return_value_contains_21;
  return_value_contains_21=contains(cmd, "upgrade");
  if(!(return_value_contains_21 == 0))
  {
    if(!(argc >= 1))
    {
      signed int return_value_help_19;
      return_value_help_19=help();
      return return_value_help_19;
    }

    signed int return_value_cmd_upgrade_20;
    return_value_cmd_upgrade_20=cmd_upgrade(argv[(signed long int)0]);
    return return_value_cmd_upgrade_20;
  }

  signed int return_value_contains_23;
  return_value_contains_23=contains(cmd, "execute");
  if(!(return_value_contains_23 == 0))
  {
    signed int return_value_cmd_execute_22;
    return_value_cmd_execute_22=cmd_execute();
    return return_value_cmd_execute_22;
  }

  signed int return_value_help_24;
  return_value_help_24=help();
  return return_value_help_24;
}

// main_internal
// file hdhomerun_config.c line 626
static signed int main_internal(signed int argc, char **argv)
{
  extract_appname(argv[(signed long int)0]);
  argv = argv + 1l;
  argc = argc - 1;
  if(argc == 0)
  {
    signed int return_value_help_1;
    return_value_help_1=help();
    return return_value_help_1;
  }

  char *id_str;
  char **tmp_post_2 = argv;
  argv = argv + 1l;
  id_str = *tmp_post_2;
  argc = argc - 1;
  signed int return_value_contains_4;
  return_value_contains_4=contains(id_str, "help");
  if(!(return_value_contains_4 == 0))
  {
    signed int return_value_help_3;
    return_value_help_3=help();
    return return_value_help_3;
  }

  signed int return_value_contains_7;
  return_value_contains_7=contains(id_str, "discover");
  if(!(return_value_contains_7 == 0))
  {
    if(!(argc >= 1))
    {
      signed int return_value_discover_print_5;
      return_value_discover_print_5=discover_print((char *)(void *)0);
      return return_value_discover_print_5;
    }

    else
    {
      signed int return_value_discover_print_6;
      return_value_discover_print_6=discover_print(argv[(signed long int)0]);
      return return_value_discover_print_6;
    }
  }

  hd=hdhomerun_device_create_from_str(id_str, (struct hdhomerun_debug_t *)(void *)0);
  if(hd == ((struct hdhomerun_device_t *)NULL))
  {
    fprintf(stderr, "invalid device id: %s\n", id_str);
    return -1;
  }

  else
  {
    unsigned int device_id_requested;
    device_id_requested=hdhomerun_device_get_device_id_requested(hd);
    signed int return_value_hdhomerun_discover_validate_device_id_8;
    return_value_hdhomerun_discover_validate_device_id_8=hdhomerun_discover_validate_device_id(device_id_requested);
    if(return_value_hdhomerun_discover_validate_device_id_8 == 0)
      fprintf(stderr, "invalid device id: %08X\n", (unsigned int)device_id_requested);

    const char *model;
    model=hdhomerun_device_get_model_str(hd);
    if(model == ((const char *)NULL))
    {
      fprintf(stderr, "unable to connect to device\n");
      hdhomerun_device_destroy(hd);
      return -1;
    }

    else
    {
      signed int ret;
      ret=main_cmd(argc, argv);
      hdhomerun_device_destroy(hd);
      return ret;
    }
  }
}

// msleep_approx
// file hdhomerun_os_posix.h line 55
extern void msleep_approx(unsigned long int ms)
{
  unsigned int delay_s = (unsigned int)(ms / (unsigned long int)1000);
  if(delay_s >= 1u)
  {
    sleep(delay_s);
    ms = ms - (unsigned long int)(delay_s * (unsigned int)1000);
  }

  unsigned int delay_us = (unsigned int)(ms * (unsigned long int)1000);
  if(delay_us >= 1u)
    usleep(delay_us);

}

// msleep_minimum
// file hdhomerun_os_posix.h line 56
extern void msleep_minimum(unsigned long int ms)
{
  unsigned long int stop_time;
  unsigned long int return_value_getcurrenttime_1;
  return_value_getcurrenttime_1=getcurrenttime();
  stop_time = return_value_getcurrenttime_1 + ms;
  while((_Bool)1)
  {
    unsigned long int current_time;
    current_time=getcurrenttime();
    if(current_time >= stop_time)
      goto __CPROVER_DUMP_L4;

    msleep_approx(stop_time - current_time);
  }

__CPROVER_DUMP_L4:
  ;
}

// parse_ip_addr
// file hdhomerun_config.c line 82
static unsigned int parse_ip_addr(const char *str)
{
  unsigned int a[4l];
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(str, "%u.%u.%u.%u", &a[(signed long int)0], &a[(signed long int)1], &a[(signed long int)2], &a[(signed long int)3]);
  if(!(return_value_sscanf_1 == 4))
    return (unsigned int)0;

  else
    return (unsigned int)(a[(signed long int)0] << 24 | a[(signed long int)1] << 16 | a[(signed long int)2] << 8 | a[(signed long int)3] << 0);
}

// random_get32
// file hdhomerun_os_posix.h line 53
extern unsigned int random_get32(void)
{
  pthread_once(&random_get32_once, random_get32_init);
  if(random_get32_fp == ((struct _IO_FILE *)NULL))
  {
    unsigned long int return_value_getcurrenttime_1;
    return_value_getcurrenttime_1=getcurrenttime();
    return (unsigned int)return_value_getcurrenttime_1;
  }

  unsigned int Result;
  unsigned long int return_value_fread_3;
  return_value_fread_3=fread((void *)&Result, (unsigned long int)4, (unsigned long int)1, random_get32_fp);
  if(!(return_value_fread_3 == 1ul))
  {
    unsigned long int return_value_getcurrenttime_2;
    return_value_getcurrenttime_2=getcurrenttime();
    return (unsigned int)return_value_getcurrenttime_2;
  }

  return Result;
}

// random_get32_init
// file hdhomerun_os_posix.c line 31
static void random_get32_init(void)
{
  random_get32_fp=fopen("/dev/urandom", "rb");
}

// register_signal_handlers
// file hdhomerun_config.c line 206
static void register_signal_handlers(void (*sigpipe_handler)(signed int), void (*sigint_handler)(signed int), void (*siginfo_handler)(signed int))
{
  signal(13, sigpipe_handler);
  signal(2, sigint_handler);
}

// sigabort_handler
// file hdhomerun_config.c line 196
static void sigabort_handler(signed int arg)
{
  sigabort_flag = 1;
}

// siginfo_handler
// file hdhomerun_config.c line 201
static void siginfo_handler(signed int arg)
{
  siginfo_flag = 1;
}

// vprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 36
static inline signed int vprintf(const char * restrict __fmt, void **__arg)
{
  signed int return_value_vfprintf_1;
  return_value_vfprintf_1=vfprintf(stdout, __fmt, __arg);
  return return_value_vfprintf_1;
}

