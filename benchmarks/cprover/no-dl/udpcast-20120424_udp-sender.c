// #anon_enum$SLICE_FREE=0$SLICE_NEW=1$SLICE_XMITTED=2$SLICE_ACKED=3$SLICE_PRE_FREE=4
// file senddata.c line 30
volatile enum anonymous$10 { SLICE_FREE=0, SLICE_NEW=1, SLICE_XMITTED=2, SLICE_ACKED=3, SLICE_PRE_FREE=4 };

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$4;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$3;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$7;

// tag-#anon#ST[S32'clNo'||SYM#tag-message#'msg'|]
// file senddata.c line 77
struct anonymous;

// tag-#anon#UN[*{S8}$S8$'ifcu_buf'||*{SYM#tag-ifreq#}$SYM#tag-ifreq#$'ifcu_req'|]
// file /usr/include/net/if.h line 179
union anonymous$2;

// tag-#anon#UN[ARR16{S8}$S8$'ifrn_name'|]
// file /usr/include/net/if.h line 130
union anonymous$0;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$6;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$8;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$5;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'||SYM#tag-sockaddr#'ifru_dstaddr'||SYM#tag-sockaddr#'ifru_broadaddr'||SYM#tag-sockaddr#'ifru_netmask'||SYM#tag-sockaddr#'ifru_hwaddr'||S16'ifru_flags'||S32'ifru_ivalue'||S32'ifru_mtu'||SYM#tag-ifmap#'ifru_map'||ARR16{S8}$S8$'ifru_slave'||ARR16{S8}$S8$'ifru_newname'||*{S8}$S8$'ifru_data'|]
// file /usr/include/net/if.h line 135
union anonymous$1;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addr_type_t
// file socklib.h line 120
enum addr_type_t { ADDR_TYPE_UCAST=0, ADDR_TYPE_MCAST=1, ADDR_TYPE_BCAST=2 };

// tag-auto_rate_t
// file auto-rate.c line 18
struct auto_rate_t;

// tag-clientDesc
// file participants.c line 13
struct clientDesc;

// tag-connectReply
// file udpc-protoc.h line 82
struct connectReply;

// tag-connectReq
// file udpc-protoc.h line 62
struct connectReq;

// tag-console_t
// file console.h line 15
struct console_t;

// tag-dataBlock
// file udpc-protoc.h line 108
struct dataBlock;

// tag-disconnect
// file udpc-protoc.h line 74
struct disconnect;

// tag-discovery
// file udpcast.h line 61
enum discovery { DSC_DOUBLING=0, DSC_REDUCING=1 };

// tag-disk_config
// file udpcast.h line 33
struct disk_config;

// tag-ethtool_cmd
// file /usr/include/linux/ethtool.h line 93
struct ethtool_cmd;

// tag-ethtool_value
// file /usr/include/linux/ethtool.h line 209
struct ethtool_value;

// tag-fecBlock
// file udpc-protoc.h line 117
struct fecBlock;

// tag-fifo
// file fifo.h line 7
struct fifo;

// tag-go
// file udpc-protoc.h line 69
struct go;

// tag-hello
// file udpc-protoc.h line 91
struct hello;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-ifconf
// file /usr/include/net/if.h line 176
struct ifconf;

// tag-ifmap
// file /usr/include/net/if.h line 111
struct ifmap;

// tag-ifreq
// file /usr/include/net/if.h line 126
struct ifreq;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-ip_mreqn
// file /usr/include/x86_64-linux-gnu/bits/in.h line 145
struct ip_mreqn;

// tag-message
// file udpc-protoc.h line 46
union message;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-net_config
// file udpcast.h line 44
struct net_config;

// tag-net_if
// file socklib.h line 110
struct net_if$0;

// tag-net_if$link1
// file socklib.h line 110
struct net_if;

// tag-ok
// file udpc-protoc.h line 48
struct ok;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-participantsDb
// file participants.h line 6
struct participantsDb;

// tag-produconsum
// file produconsum.h line 4
struct produconsum;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rateGovernor_t
// file udpcast.h line 55
struct rateGovernor_t;

// tag-rate_limit
// file rate-limit.c line 10
struct rate_limit;

// tag-receiver_stats
// file statistics.h line 5
struct receiver_stats;

// tag-reqack
// file udpc-protoc.h line 126
struct reqack;

// tag-reqackBm
// file senddata.c line 51
struct reqackBm;

// tag-retransmit
// file udpc-protoc.h line 54
struct retransmit;

// tag-returnChannel
// file senddata.c line 72
struct returnChannel;

// tag-senderState
// file senddata.c line 87
struct senderState;

// tag-sender_stats
// file statistics.h line 6
struct sender_stats;

// tag-slice
// file senddata.c line 25
struct slice;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-stat_config
// file udpcast.h line 107
struct stat_config;

// tag-stats
// file statistics.c line 28
struct stats;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// INET_ATON
// file socklib.c line 209
static inline signed int INET_ATON(const char *a, struct in_addr *i);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __bswap_32$link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32$link1(unsigned int __bsx$link1);
// __bswap_32$link2
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32$link2(unsigned int __bsx$link2);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __strndup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1297
extern char * __strndup(const char *, unsigned long int);
// __strpbrk_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1100
static inline char * __strpbrk_c2(const char *__s, signed int __accept1, signed int __accept2);
// __strpbrk_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1111
static inline char * __strpbrk_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3);
// _consumeAny
// file produconsum.c line 104
static signed int _consumeAny(struct produconsum *pc, unsigned int minAmount, struct timespec *ts);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// ackSlice
// file senddata.c line 392
static signed int ackSlice(struct slice *slice, struct net_config *net_config, struct fifo *fifo, struct sender_stats *stats);
// addmul
// file fec.c line 406
static void addmul(unsigned char *dst, unsigned char *src, unsigned char c, signed int sz);
// allocAutoRate
// file auto-rate.c line 36
static void * allocAutoRate(void);
// allocRateLimit
// file rate-limit.c line 52
static void * allocRateLimit(void);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// atol
// file /usr/include/stdlib.h line 283
static inline signed long int atol(const char *__nptr);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cancelReturnChannel
// file senddata.c line 715
static void cancelReturnChannel(struct returnChannel *returnChannel);
// checkClientWait
// file udps-negotiate.c line 101
static signed int checkClientWait(struct participantsDb *db, struct net_config *net_config, signed long int *firstConnected);
// cleanPidfile
// file udp-sender.c line 174
static void cleanPidfile(signed int nr);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// doAutoRate
// file auto-rate.c line 59
static void doAutoRate(void *data, signed int sock, unsigned int ip, signed long int size);
// doRateLimit
// file rate-limit.c line 70
static void doRateLimit(void *data, signed int fd, unsigned int ip, signed long int size);
// doRetransmissions
// file senddata.c line 499
static signed int doRetransmissions(struct senderState *sendst, struct slice *slice);
// doTransfer
// file udps-negotiate.c line 442
static signed int doTransfer(signed int sock, struct participantsDb *db, struct disk_config *disk_config, struct net_config *net_config, struct stat_config *stat_config);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// dupFd
// file process.c line 10
static void dupFd(signed int src, signed int target);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fecMain
// file senddata.c line 1001
static void * fecMain(void *args0);
// fec_decode
// file fec.c line 919
void fec_decode(unsigned int blockSize, unsigned char **data_blocks, unsigned int nr_data_blocks, unsigned char **fec_blocks, unsigned int *fec_block_nos, unsigned int *erased_blocks, unsigned short int nr_fec_blocks);
// fec_encode
// file fec.h line 19
void fec_encode(unsigned int blockSize, unsigned char **data_blocks, unsigned int nrDataBlocks, unsigned char **fec_blocks, unsigned int nrFecBlocks);
// fec_encode_all_stripes
// file senddata.c line 968
static void fec_encode_all_stripes(struct senderState *sendst, struct slice *slice);
// fec_init
// file fec.h line 17
void fec_init(void);
// fec_license
// file fec.h line 35
void fec_license(void);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fillMreq
// file socklib.c line 371
static signed int fillMreq(struct net_if *net_if, struct in_addr addr, struct ip_mreqn *mreq);
// findSlice
// file senddata.c line 620
static struct slice * findSlice(struct slice *slice1, struct slice *slice2, signed int sliceNo);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeSlice
// file senddata.c line 132
static signed int freeSlice(struct senderState *sendst, struct slice *slice);
// generate_gf
// file fec.c line 217
static void generate_gf(void);
// getCurrentQueueLength
// file auto-rate.c line 25
static signed int getCurrentQueueLength(signed int sock);
// getLongLongDate
// file rate-limit.c line 42
static signed long long int getLongLongDate(void);
// getProducedAmount
// file produconsum.c line 88
static signed int getProducedAmount(struct produconsum *pc);
// getSliceBlocks
// file senddata.c line 105
static signed int getSliceBlocks(struct slice *slice, struct net_config *net_config);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// handleDisconnect
// file senddata.c line 609
static signed int handleDisconnect(struct participantsDb *db, struct slice *slice1, struct slice *slice2, signed int clNo);
// handleDisconnect1
// file senddata.c line 593
static signed int handleDisconnect1(struct slice *slice, signed int clNo);
// handleNextMessage
// file senddata.c line 631
static signed int handleNextMessage(struct senderState *sendst, struct slice *xmitSlice, struct slice *rexmitSlice);
// handleOk
// file senddata.c line 529
static signed int handleOk(struct senderState *sendst, struct slice *slice, signed int clNo);
// handleRetransmit
// file senddata.c line 557
static signed int handleRetransmit(struct senderState *sendst, struct slice *slice, signed int clNo, unsigned char *map, signed int rxmit);
// hasLink
// file socklib.c line 494
static signed int hasLink(signed int s, const char *ifname);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// initMsgHdr
// file socklib.h line 218
static inline void initMsgHdr(struct msghdr *hdr);
// initReturnChannel
// file senddata.c line 701
static void initReturnChannel(struct returnChannel *returnChannel, struct net_config *config, signed int sock);
// initSockAddress
// file socklib.c line 219
static signed int initSockAddress(enum addr_type_t addr_type, struct net_if *net_if, unsigned int ip, unsigned short int port, struct sockaddr_in *addr);
// initStats
// file statistics.c line 60
static void initStats(struct stats *s, signed int fd, signed long int statPeriod, signed int printUncompressedPos, signed int noProgress);
// init_mul_table
// file fec.c line 189
static void init_mul_table(void);
// initialize
// file auto-rate.c line 44
static void initialize(struct auto_rate_t *autoRate_l, signed int sock);
// invert_mat
// file fec.c line 545
static signed int invert_mat(unsigned char *src, signed int k);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// isMcastAddress
// file socklib.c line 1111
signed int isMcastAddress(struct sockaddr_in *addr);
// isPointToPoint
// file udps-negotiate.c line 33
static signed int isPointToPoint(struct participantsDb *db, signed int flags);
// isSliceAcked
// file senddata.c line 110
static signed int isSliceAcked(struct slice *slice);
// isSliceXmitted
// file senddata.c line 123
static signed int isSliceXmitted(struct slice *slice);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// lseek64
// file /usr/include/unistd.h line 345
extern signed long int lseek64(signed int, signed long int, signed int);
// mainDispatcher
// file udps-negotiate.c line 157
static signed int mainDispatcher(signed int *fd, signed int nr, struct participantsDb *db, struct net_config *net_config, struct console_t **console, signed int *tries, signed long int *firstConnected);
// makeSlice
// file senddata.c line 150
static struct slice * makeSlice(struct senderState *sendst, signed int sliceNo);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// markParticipantAnswered
// file senddata.c line 517
static void markParticipantAnswered(struct slice *slice, signed int clNo);
// mcastListen
// file socklib.c line 418
static signed int mcastListen(signed int sock, struct net_if *net_if, struct sockaddr_in *addr);
// mcastOp
// file socklib.c line 387
static signed int mcastOp(signed int sock, struct net_if *net_if, struct in_addr addr, signed int code, const char *message);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// modnn
// file fec.c line 152
static inline unsigned char modnn(signed int x);
// mul
// file fec.c line 532
static inline void mul(unsigned char *dst, unsigned char *src, unsigned char c, signed int sz);
// netSenderMain
// file senddata.c line 724
static void * netSenderMain(void *args0);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// open2
// file udpc_process.h line 17
signed int open2(signed int in, signed int out, char **arg, signed int closeFd);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// parseSpeed
// file rate-limit.c line 20
static unsigned long int parseSpeed(const char *speedString);
// pc_consume
// file produconsum.h line 30
signed int pc_consume(struct produconsum *pc, signed int amount);
// pc_consumeAny
// file produconsum.h line 9
signed int pc_consumeAny(struct produconsum *pc);
// pc_consumeAnyContiguous
// file produconsum.c line 177
signed int pc_consumeAnyContiguous(struct produconsum *pc);
// pc_consumeAnyWithTimeout
// file produconsum.h line 10
signed int pc_consumeAnyWithTimeout(struct produconsum *pc, struct timespec *ts);
// pc_consumeContiguousMinAmount
// file produconsum.h line 21
signed int pc_consumeContiguousMinAmount(struct produconsum *pc, signed int amount);
// pc_consumed
// file produconsum.h line 58
signed int pc_consumed(struct produconsum *pc, signed int amount);
// pc_getConsumerPosition
// file produconsum.h line 35
unsigned int pc_getConsumerPosition(struct produconsum *pc);
// pc_getProducerPosition
// file produconsum.h line 40
unsigned int pc_getProducerPosition(struct produconsum *pc);
// pc_getSize
// file produconsum.c line 207
unsigned int pc_getSize(struct produconsum *pc);
// pc_getWaiting
// file produconsum.h line 52
unsigned int pc_getWaiting(struct produconsum *pc);
// pc_makeProduconsum
// file produconsum.h line 6
struct produconsum * pc_makeProduconsum(signed int size, const char *name);
// pc_produce
// file produconsum.h line 7
void pc_produce(struct produconsum *pc, unsigned int amount);
// pc_produceEnd
// file produconsum.h line 8
void pc_produceEnd(struct produconsum *pc);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// printFilePosition
// file statistics.c line 94
static void printFilePosition(signed int fd);
// printNewlineIfNeeded
// file log.c line 13
static void printNewlineIfNeeded(void);
// printProcessStatus
// file udpcast.c line 30
static signed int printProcessStatus(const char *message, signed int status);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$8 *, const union anonymous$6 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$8 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$8 *, union anonymous$5 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$8 *, union anonymous$5 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$5 *, const union anonymous$6 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$5 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$5 *);
// raise
// file /usr/include/signal.h line 139
extern signed int raise(signed int);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, struct sockaddr *, unsigned int *);
// reduce
// file fec.c line 810
static inline void reduce(unsigned int blockSize, unsigned char **data_blocks, unsigned int nr_data_blocks, unsigned char **fec_blocks, unsigned int *fec_block_nos, unsigned int *erased_blocks, unsigned short int nr_fec_blocks);
// resolve
// file fec.c line 856
static inline void resolve(signed int blockSize, unsigned char **data_blocks, unsigned char **fec_blocks, unsigned int *fec_block_nos, unsigned int *erased_blocks, signed short int nr_fec_blocks);
// returnChannelMain
// file senddata.c line 676
static void * returnChannelMain(void *args);
// rgInitGovernor
// file udpcast.h line 117
void * rgInitGovernor(struct net_config *cfg, struct rateGovernor_t *gov);
// rgParseRateGovernor
// file udpcast.h line 118
void rgParseRateGovernor(struct net_config *net_config, char *rg);
// rgShutdownAll
// file udpcast.h line 120
void rgShutdownAll(struct net_config *cfg);
// rgWaitAll
// file rateGovernor.c line 106
void rgWaitAll(struct net_config *cfg, signed int sock, unsigned int ip, signed int size);
// safe_inet_aton
// file socklib.c line 266
static signed int safe_inet_aton(const char *address, struct in_addr *ip);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$4 *, struct anonymous$4 *, struct anonymous$4 *, struct timeval *);
// selectWithConsole
// file console.h line 26
signed int selectWithConsole(struct console_t *con, signed int maxFd, struct anonymous$4 *read_set, struct timeval *tv, signed int *keyPressed);
// sendConnectionReply
// file udps-negotiate.c line 42
static signed int sendConnectionReply(struct participantsDb *db, signed int sock, struct net_config *config, struct sockaddr_in *client, signed int capabilities, unsigned int rcvbuf);
// sendRawData
// file senddata.c line 191
static signed int sendRawData(signed int sock, struct net_config *config, char *header, signed int headerSize, unsigned char *data, signed int dataSize);
// sendReqack
// file senddata.c line 425
static signed int sendReqack(struct slice *slice, struct net_config *net_config, struct fifo *fifo, struct sender_stats *stats, signed int sock);
// sendSlice
// file senddata.c line 284
static signed int sendSlice(struct senderState *sendst, struct slice *slice, signed int retransmitting);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, struct sockaddr *, unsigned int);
// setProp
// file rate-limit.c line 62
static void setProp(void *data, const char *key, const char *bitrate);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shouldPrint
// file statistics.c line 47
static signed int shouldPrint(struct stats *s, struct timeval *now, signed int isFinal);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous$3 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$3 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous$3 *, struct anonymous$3 *);
// slow_addmul1
// file fec.c line 301
static void slow_addmul1(unsigned char *dst1, unsigned char *src1, unsigned char c, signed int sz);
// slow_mul1
// file fec.c line 427
static void slow_mul1(unsigned char *dst1, unsigned char *src1, unsigned char c, signed int sz);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// strtoull
// file /usr/include/stdlib.h line 214
extern unsigned long long int strtoull(const char *, char ** restrict , signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// transmitDataBlock
// file senddata.c line 228
static signed int transmitDataBlock(struct senderState *sendst, struct slice *slice, signed int i);
// transmitFecBlock
// file senddata.c line 260
static signed int transmitFecBlock(struct senderState *sendst, struct slice *slice, signed int i);
// udpc_addParticipant
// file participants.h line 24
signed int udpc_addParticipant(struct participantsDb *db, struct sockaddr_in *addr, signed int capabilities, unsigned int rcvbuf, signed int pointopoint);
// udpc_allocReadStats
// file statistics.c line 73
struct receiver_stats * udpc_allocReadStats(signed int fd, signed long int statPeriod, signed int printUncompressedPos, signed int noProgress);
// udpc_allocSenderStats
// file statistics.h line 26
struct sender_stats * udpc_allocSenderStats(signed int fd, struct _IO_FILE *logfile, signed long int bwPeriod, signed long int statPeriod, signed int printUncompressedPos, signed int noProgress);
// udpc_clearIp
// file socklib.h line 173
void udpc_clearIp(struct sockaddr_in *addr);
// udpc_closeSock
// file socklib.c line 1100
void udpc_closeSock(signed int *socks, signed int nr, signed int target);
// udpc_copyFromMessage
// file socklib.c line 1018
void udpc_copyFromMessage(struct sockaddr_in *dst, unsigned char *src);
// udpc_copyIpFrom
// file socklib.c line 1000
void udpc_copyIpFrom(struct sockaddr_in *dst, struct sockaddr_in *src);
// udpc_copyToMessage
// file socklib.c line 1012
void udpc_copyToMessage(unsigned char *dst, struct sockaddr_in *src);
// udpc_displayReceiverStats
// file statistics.c line 153
void udpc_displayReceiverStats(struct receiver_stats *rs, signed int isFinal);
// udpc_displaySenderStats
// file statistics.h line 32
void udpc_displaySenderStats(struct sender_stats *ss, signed int blockSize, signed int sliceSize, signed int isFinal);
// udpc_doReceive
// file socklib.c line 296
signed int udpc_doReceive(signed int s, void *message, unsigned long int len, struct sockaddr_in *from, signed int portBase);
// udpc_doSend
// file socklib.c line 288
signed int udpc_doSend(signed int s, void *message, unsigned long int len, struct sockaddr_in *to);
// udpc_fatal
// file log.h line 19
signed int udpc_fatal(signed int code, const char *fmt, ...);
// udpc_flprintf
// file log.h line 17
signed int udpc_flprintf(const char *fmt, ...);
// udpc_getBroadCastAddress
// file socklib.c line 250
signed int udpc_getBroadCastAddress(struct net_if *net_if, struct sockaddr_in *addr, signed short int port);
// udpc_getDefaultMcastAddress
// file socklib.c line 1005
void udpc_getDefaultMcastAddress(struct net_if *net_if, struct sockaddr_in *mcast);
// udpc_getIpString
// file socklib.c line 963
char * udpc_getIpString(struct sockaddr_in *addr, char *buffer);
// udpc_getMcastAllAddress
// file socklib.c line 273
signed int udpc_getMcastAllAddress(struct sockaddr_in *addr, const char *address, signed short int port);
// udpc_getMyAddress
// file socklib.c line 245
signed int udpc_getMyAddress(struct net_if *net_if, struct sockaddr_in *addr);
// udpc_getNetIf
// file socklib.c line 557
struct net_if * udpc_getNetIf(const char *wanted);
// udpc_getParticipantCapabilities
// file participants.h line 30
signed int udpc_getParticipantCapabilities(struct participantsDb *db, signed int i);
// udpc_getParticipantIp
// file participants.h line 32
struct sockaddr_in * udpc_getParticipantIp(struct participantsDb *db, signed int i);
// udpc_getParticipantRcvBuf
// file participants.h line 31
unsigned int udpc_getParticipantRcvBuf(struct participantsDb *db, signed int i);
// udpc_getPort
// file socklib.c line 981
unsigned short int udpc_getPort(struct sockaddr_in *addr);
// udpc_getRcvBuf
// file socklib.c line 334
unsigned int udpc_getRcvBuf(signed int sock);
// udpc_getSelectedSock
// file socklib.c line 1089
signed int udpc_getSelectedSock(signed int *socks, signed int nr, struct anonymous$4 *read_set);
// udpc_getSendBuf
// file socklib.c line 321
signed int udpc_getSendBuf(signed int sock);
// udpc_initFifo
// file fifo.h line 20
void udpc_initFifo(struct fifo *fifo, signed int blockSize);
// udpc_ipIsEqual
// file socklib.c line 973
signed int udpc_ipIsEqual(struct sockaddr_in *left, struct sockaddr_in *right);
// udpc_ipIsZero
// file socklib.h line 171
signed int udpc_ipIsZero(struct sockaddr_in *ip);
// udpc_isAddressEqual
// file socklib.c line 1022
signed int udpc_isAddressEqual(struct sockaddr_in *a, struct sockaddr_in *b);
// udpc_isFullDuplex
// file socklib.c line 523
signed int udpc_isFullDuplex(signed int s, const char *ifname);
// udpc_isParticipantValid
// file participants.h line 20
signed int udpc_isParticipantValid(struct participantsDb *db, signed int i);
// udpc_localReader
// file sender-diskio.c line 78
signed int udpc_localReader(struct fifo *fifo, signed int in);
// udpc_logprintf
// file log.h line 15
signed int udpc_logprintf(struct _IO_FILE *logfile, const char *fmt, ...);
// udpc_lookupParticipant
// file participants.h line 22
signed int udpc_lookupParticipant(struct participantsDb *db, struct sockaddr_in *addr);
// udpc_makeParticipantsDb
// file participants.h line 29
struct participantsDb * udpc_makeParticipantsDb(void);
// udpc_makeSockAddr
// file socklib.c line 174
signed int udpc_makeSockAddr(char *hostname, signed short int port, struct sockaddr_in *addr);
// udpc_makeSocket
// file socklib.c line 899
signed int udpc_makeSocket(enum addr_type_t addr_type, struct net_if *net_if, struct sockaddr_in *tmpl, signed int port);
// udpc_nrParticipants
// file participants.h line 23
signed int udpc_nrParticipants(struct participantsDb *db);
// udpc_openFile
// file sender-diskio.c line 24
signed int udpc_openFile(struct disk_config *config);
// udpc_openMainSenderSock
// file udp-sender.h line 34
signed int udpc_openMainSenderSock(struct net_config *net_config, const char *ifName);
// udpc_parseCommand
// file udpcast.c line 7
signed int udpc_parseCommand(char *pipeName, char **arg);
// udpc_parseSize
// file socklib.h line 185
unsigned long int udpc_parseSize(char *sizeString);
// udpc_prepareConsole
// file console.h line 20
struct console_t * udpc_prepareConsole(signed int fd);
// udpc_prepareForSelect
// file socklib.c line 1074
signed int udpc_prepareForSelect(signed int *socks, signed int nr, struct anonymous$4 *read_set);
// udpc_printLongNum
// file log.c line 96
signed int udpc_printLongNum(unsigned long long int x);
// udpc_printMyIp
// file socklib.c line 954
void udpc_printMyIp(struct net_if *net_if);
// udpc_printNotSet
// file participants.h line 33
void udpc_printNotSet(struct participantsDb *db, char *d);
// udpc_printSet
// file participants.c line 133
void udpc_printSet(struct participantsDb *db, char *d);
// udpc_receiverStatsAddBytes
// file statistics.c line 82
void udpc_receiverStatsAddBytes(struct receiver_stats *rs, signed long int bytes);
// udpc_receiverStatsStartTimer
// file statistics.c line 87
void udpc_receiverStatsStartTimer(struct receiver_stats *rs);
// udpc_removeParticipant
// file participants.h line 21
signed int udpc_removeParticipant(struct participantsDb *db, signed int i);
// udpc_restoreConsole
// file console.h line 34
void udpc_restoreConsole(struct console_t **cp, signed int doConsume);
// udpc_selectSock
// file socklib.c line 1055
signed int udpc_selectSock(signed int *socks, signed int nr, signed int startTimeout);
// udpc_sendHello
// file udp-sender.h line 32
void udpc_sendHello(struct net_config *net_config, signed int sock, signed int streaming);
// udpc_senderSetAnswered
// file statistics.h line 34
void udpc_senderSetAnswered(struct sender_stats *ss, signed int clNo);
// udpc_senderStatsAddBytes
// file statistics.h line 29
void udpc_senderStatsAddBytes(struct sender_stats *ss, signed long int bytes);
// udpc_senderStatsAddRetransmissions
// file statistics.h line 30
void udpc_senderStatsAddRetransmissions(struct sender_stats *ss, signed int retransmissions);
// udpc_setIpFromString
// file socklib.h line 174
void udpc_setIpFromString(struct sockaddr_in *addr, char *ip);
// udpc_setMcastDestination
// file socklib.c line 424
signed int udpc_setMcastDestination(signed int sock, struct net_if *net_if, struct sockaddr_in *addr);
// udpc_setPort
// file socklib.c line 985
void udpc_setPort(struct sockaddr_in *addr, unsigned short int port);
// udpc_setRcvBuf
// file socklib.c line 342
void udpc_setRcvBuf(signed int sock, unsigned int bufsize);
// udpc_setSendBuf
// file socklib.c line 329
void udpc_setSendBuf(signed int sock, unsigned int bufsize);
// udpc_setSocketToBroadcast
// file socklib.c line 348
signed int udpc_setSocketToBroadcast(signed int sock);
// udpc_setTtl
// file socklib.c line 354
signed int udpc_setTtl(signed int sock, signed int ttl);
// udpc_shouldPrintUncompressedPos
// file udpcast.h line 125
signed int udpc_shouldPrintUncompressedPos(signed int deflt, signed int fd, signed int ref);
// udpc_spawnNetSender
// file senddata.c line 1019
signed int udpc_spawnNetSender(struct fifo *fifo, signed int sock, struct net_config *config, struct participantsDb *db, struct sender_stats *stats);
// udpc_startSender
// file udp-sender.h line 37
signed int udpc_startSender(struct disk_config *disk_config, struct net_config *net_config, struct stat_config *stat_config, signed int mainSock);
// udpc_waitForProcess
// file udpcast.c line 59
signed int udpc_waitForProcess(signed int pid, const char *message);
// udpc_zeroSockArray
// file socklib.c line 1048
void udpc_zeroSockArray(signed int *socks, signed int nr);
// udpcs_openPipe
// file sender-diskio.c line 47
signed int udpcs_openPipe(struct disk_config *config, signed int in, signed int *pidp);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file udp-sender.c line 142
static void usage(char *progname);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vlogprintf
// file log.c line 34
static signed int vlogprintf(struct _IO_FILE *logfile, const char *fmt, void **ap);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// wakeConsumer
// file produconsum.c line 39
static void wakeConsumer(struct produconsum *pc);

struct anonymous$4
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$3
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$7
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct ok
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // sliceNo
  signed int sliceNo;
};

struct retransmit
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // sliceNo
  signed int sliceNo;
  // rxmit
  signed int rxmit;
  // map
  unsigned char map[128l];
};

struct connectReq
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // capabilities
  signed int capabilities;
  // rcvbuf
  unsigned int rcvbuf;
};

struct go
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
};

struct disconnect
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
};

union message
{
  // opCode
  unsigned short int opCode;
  // ok
  struct ok ok;
  // retransmit
  struct retransmit retransmit;
  // connectReq
  struct connectReq connectReq;
  // go
  struct go go;
  // disconnect
  struct disconnect disconnect;
};

struct anonymous
{
  // clNo
  signed int clNo;
  // msg
  union message msg;
};

union anonymous$2
{
  // ifcu_buf
  char *ifcu_buf;
  // ifcu_req
  struct ifreq *ifcu_req;
};

union anonymous$0
{
  // ifrn_name
  char ifrn_name[16l];
};

union anonymous$6
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$8
{
  // __data
  struct anonymous$7 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$5
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct ifmap
{
  // mem_start
  unsigned long int mem_start;
  // mem_end
  unsigned long int mem_end;
  // base_addr
  unsigned short int base_addr;
  // irq
  unsigned char irq;
  // dma
  unsigned char dma;
  // port
  unsigned char port;
};

union anonymous$1
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  char *ifru_data;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct auto_rate_t
{
  // isInitialized
  signed int isInitialized;
  // dir
  signed int dir;
  // sendbuf
  signed int sendbuf;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct clientDesc
{
  // addr
  struct sockaddr_in addr;
  // used
  signed int used;
  // capabilities
  signed int capabilities;
  // rcvbuf
  unsigned int rcvbuf;
};

struct connectReply
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // clNr
  signed int clNr;
  // blockSize
  signed int blockSize;
  // capabilities
  signed int capabilities;
  // mcastAddr
  unsigned char mcastAddr[16l];
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct console_t
{
  // fd
  signed int fd;
  // oldtio
  struct termios oldtio;
  // needClose
  signed int needClose;
  // needRestore
  signed int needRestore;
};

struct dataBlock
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // sliceNo
  signed int sliceNo;
  // blockNo
  unsigned short int blockNo;
  // reserved2
  unsigned short int reserved2;
  // bytes
  signed int bytes;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct disk_config
{
  // origOutFile
  signed int origOutFile;
  // fileName
  const char *fileName;
  // pipeName
  char *pipeName;
  // flags
  signed int flags;
  // stats_last_printed
  struct timeval stats_last_printed;
};

struct ethtool_cmd
{
  // cmd
  unsigned int cmd;
  // supported
  unsigned int supported;
  // advertising
  unsigned int advertising;
  // speed
  unsigned short int speed;
  // duplex
  unsigned char duplex;
  // port
  unsigned char port;
  // phy_address
  unsigned char phy_address;
  // transceiver
  unsigned char transceiver;
  // autoneg
  unsigned char autoneg;
  // mdio_support
  unsigned char mdio_support;
  // maxtxpkt
  unsigned int maxtxpkt;
  // maxrxpkt
  unsigned int maxrxpkt;
  // speed_hi
  unsigned short int speed_hi;
  // eth_tp_mdix
  unsigned char eth_tp_mdix;
  // eth_tp_mdix_ctrl
  unsigned char eth_tp_mdix_ctrl;
  // lp_advertising
  unsigned int lp_advertising;
  // reserved
  unsigned int reserved[2l];
};

struct ethtool_value
{
  // cmd
  unsigned int cmd;
  // data
  unsigned int data;
};

struct fecBlock
{
  // opCode
  unsigned short int opCode;
  // stripes
  signed short int stripes;
  // sliceNo
  signed int sliceNo;
  // blockNo
  unsigned short int blockNo;
  // reserved2
  unsigned short int reserved2;
  // bytes
  signed int bytes;
};

struct fifo
{
  // dataBuffer
  unsigned char *dataBuffer;
  // dataBufSize
  unsigned int dataBufSize;
  // freeMemQueue
  struct produconsum *freeMemQueue;
  // data
  struct produconsum *data;
  // thread
  unsigned long int thread;
};

struct hello
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // capabilities
  signed int capabilities;
  // mcastAddr
  unsigned char mcastAddr[16l];
  // blockSize
  signed short int blockSize;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct ifconf
{
  // ifc_len
  signed int ifc_len;
  // ifc_ifcu
  union anonymous$2 ifc_ifcu;
};

struct ifreq
{
  // ifr_ifrn
  union anonymous$0 ifr_ifrn;
  // ifr_ifru
  union anonymous$1 ifr_ifru;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct ip_mreqn
{
  // imr_multiaddr
  struct in_addr imr_multiaddr;
  // imr_address
  struct in_addr imr_address;
  // imr_ifindex
  signed int imr_ifindex;
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct rateGovernor_t
{
  // rgInitialize
  void * (*rgInitialize)(void);
  // rgSetProp
  void (*rgSetProp)(void *, const char *, const char *);
  // rgEndConfig
  void (*rgEndConfig)(void *);
  // rgWait
  void (*rgWait)(void *, signed int, unsigned int, signed long int);
  // rgShutdown
  void (*rgShutdown)(void *);
};

struct net_config
{
  // net_if
  struct net_if$0 *net_if;
  // portBase
  signed int portBase;
  // blockSize
  signed int blockSize;
  // sliceSize
  signed int sliceSize;
  // controlMcastAddr
  struct sockaddr_in controlMcastAddr;
  // dataMcastAddr
  struct sockaddr_in dataMcastAddr;
  // mcastRdv
  const char *mcastRdv;
  // ttl
  signed int ttl;
  // nrGovernors
  signed int nrGovernors;
  // rateGovernor
  struct rateGovernor_t *rateGovernor[10l];
  // rateGovernorData
  void *rateGovernorData[10l];
  // ref_tv
  struct timeval ref_tv;
  // discovery
  enum discovery discovery;
  // flags
  signed int flags;
  // capabilities
  signed int capabilities;
  // min_slice_size
  signed int min_slice_size;
  // default_slice_size
  signed int default_slice_size;
  // max_slice_size
  signed int max_slice_size;
  // rcvbuf
  unsigned int rcvbuf;
  // rexmit_hello_interval
  signed int rexmit_hello_interval;
  // autostart
  signed int autostart;
  // requestedBufSize
  signed int requestedBufSize;
  // min_receivers
  signed int min_receivers;
  // max_receivers_wait
  signed int max_receivers_wait;
  // min_receivers_wait
  signed int min_receivers_wait;
  // retriesUntilDrop
  signed int retriesUntilDrop;
  // exitWait
  signed int exitWait;
  // startTimeout
  signed int startTimeout;
  // receiveTimeout
  signed int receiveTimeout;
  // fec_redundancy
  signed int fec_redundancy;
  // fec_stripesize
  signed int fec_stripesize;
  // fec_stripes
  signed int fec_stripes;
  // rehelloOffset
  signed int rehelloOffset;
};

struct net_if$0
{
  // addr
  struct in_addr addr;
  // bcast
  struct in_addr bcast;
  // name
  const char *name;
};

struct net_if
{
  // addr
  struct in_addr addr;
  // bcast
  struct in_addr bcast;
  // name
  const char *name;
  // index
  signed int index;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct participantsDb
{
  // udpc_nrParticipants
  signed int udpc_nrParticipants;
  // clientTable
  struct clientDesc clientTable[1024l];
};

struct produconsum
{
  // size
  unsigned int size;
  // produced
  volatile unsigned int produced;
  // consumed
  unsigned int consumed;
  // atEnd
  volatile signed int atEnd;
  // mutex
  union anonymous$5 mutex;
  // consumerIsWaiting
  volatile signed int consumerIsWaiting;
  // cond
  union anonymous$8 cond;
  // name
  const char *name;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rate_limit
{
  // date
  signed long long int date;
  // realDate
  signed long long int realDate;
  // bitrate
  signed int bitrate;
  // queueSize
  signed int queueSize;
};

struct stats
{
  // fd
  signed int fd;
  // lastPrinted
  struct timeval lastPrinted;
  // statPeriod
  signed long int statPeriod;
  // printUncompressedPos
  signed int printUncompressedPos;
  // noProgress
  signed int noProgress;
};

struct receiver_stats
{
  // tv_start
  struct timeval tv_start;
  // bytesOrig
  signed int bytesOrig;
  // totalBytes
  signed long long int totalBytes;
  // timerStarted
  signed int timerStarted;
  // s
  struct stats s;
};

struct reqack
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // sliceNo
  signed int sliceNo;
  // bytes
  signed int bytes;
  // rxmit
  signed int rxmit;
};

struct reqackBm
{
  // ra
  struct reqack ra;
  // readySet
  char readySet[128l];
};

struct returnChannel
{
  // thread
  unsigned long int thread;
  // rcvSock
  signed int rcvSock;
  // incoming
  struct produconsum *incoming;
  // freeSpace
  struct produconsum *freeSpace;
  // q
  struct anonymous q[256l];
  // config
  struct net_config *config;
  // participantsDb
  struct participantsDb *participantsDb;
};

struct slice
{
  // base
  signed int base;
  // sliceNo
  signed int sliceNo;
  // bytes
  signed int bytes;
  // nextBlock
  signed int nextBlock;
  // state
  volatile enum anonymous$10 state;
  // rxmitMap
  char rxmitMap[128l];
  // isXmittedMap
  char isXmittedMap[128l];
  // rxmitId
  signed int rxmitId;
  // sl_reqack
  struct reqackBm sl_reqack;
  // answeredSet
  char answeredSet[128l];
  // nrReady
  signed int nrReady;
  // nrAnswered
  signed int nrAnswered;
  // needRxmit
  signed int needRxmit;
  // lastGoodBlock
  signed int lastGoodBlock;
  // lastReqack
  signed int lastReqack;
  // fec_data
  unsigned char *fec_data;
};

struct senderState
{
  // rc
  struct returnChannel rc;
  // fifo
  struct fifo *fifo;
  // config
  struct net_config *config;
  // stats
  struct sender_stats *stats;
  // socket
  signed int socket;
  // slices
  struct slice slices[2l];
  // free_slices_pc
  struct produconsum *free_slices_pc;
  // fec_data
  unsigned char *fec_data;
  // fec_thread
  unsigned long int fec_thread;
  // fec_data_pc
  struct produconsum *fec_data_pc;
};

struct sender_stats
{
  // log
  struct _IO_FILE *log;
  // totalBytes
  unsigned long long int totalBytes;
  // retransmissions
  unsigned long long int retransmissions;
  // clNo
  signed int clNo;
  // periodBytes
  unsigned long int periodBytes;
  // periodStart
  struct timeval periodStart;
  // bwPeriod
  signed long int bwPeriod;
  // s
  struct stats s;
};

struct stat_config
{
  // log
  struct _IO_FILE *log;
  // bwPeriod
  signed long int bwPeriod;
  // statPeriod
  signed int statPeriod;
  // printUncompressedPos
  signed int printUncompressedPos;
  // noProgress
  signed int noProgress;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// allPp
// file fec.c line 112
static char *allPp[17l] = { (char *)(void *)0, (char *)(void *)0, "111", "1101", "11001", "101001", "1100001", "10010001", "101110001", "1000100001", "10010000001", "101000000001", "1100101000001", "11011000000001", "110000100010001", "1100000000000001", "11010000000010001" };
// autoRate
// file auto-rate.c line 81
struct rateGovernor_t autoRate;
// autoRate
// file auto-rate.c line 81
struct rateGovernor_t autoRate = { .rgInitialize=allocAutoRate, .rgSetProp=(void (*)(void *, const char *, const char *))(void *)0, .rgEndConfig=(void (*)(void *))(void *)0,
    .rgWait=doAutoRate,
    .rgShutdown=(void (*)(void *))(void *)0 };
// fec_initialized
// file fec.c line 665
static signed int fec_initialized = 0;
// gf_exp
// file fec.c line 142
static unsigned char gf_exp[510l];
// gf_log
// file fec.c line 143
static signed int gf_log[256l];
// gf_mul_table
// file fec.c line 173
static unsigned char gf_mul_table[65536l];
// inverse
// file fec.c line 144
static unsigned char inverse[256l];
// maxBitrate
// file rate-limit.c line 100
struct rateGovernor_t maxBitrate;
// maxBitrate
// file rate-limit.c line 100
struct rateGovernor_t maxBitrate = { .rgInitialize=allocRateLimit, .rgSetProp=setProp, .rgEndConfig=(void (*)(void *))(void *)0,
    .rgWait=doRateLimit,
    .rgShutdown=(void (*)(void *))(void *)0 };
// needNewline
// file log.c line 11
static signed int needNewline = 0;
// newlineSeen
// file log.c line 32
static signed int newlineSeen = 1;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// options
// file udp-sender.c line 42
static struct option options[58l] = { { .name="file", .has_arg=1, .flag=(signed int *)(void *)0, .val=102 },
    { .name="half-duplex", .has_arg=0, .flag=(signed int *)(void *)0, .val=99 },
    { .name="full-duplex", .has_arg=0, .flag=(signed int *)(void *)0, .val=100 },
    { .name="pipe", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 },
    { .name="port", .has_arg=1, .flag=(signed int *)(void *)0, .val=80 },
    { .name="portbase", .has_arg=1, .flag=(signed int *)(void *)0, .val=80 },
    { .name="blocksize", .has_arg=1, .flag=(signed int *)(void *)0, .val=98 },
    { .name="interface", .has_arg=1, .flag=(signed int *)(void *)0, .val=105 },
    { .name="mcast_address", .has_arg=1, .flag=(signed int *)(void *)0, .val=109 },
    { .name="mcast-address", .has_arg=1, .flag=(signed int *)(void *)0, .val=109 },
    { .name="mcast_data_address", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=109 },
    { .name="mcast-data-address", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=109 },
    { .name="mcast_all_address", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=77 },
    { .name="mcast-all-address", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=77 },
    { .name="mcast_rdv_address", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=77 },
    { .name="mcast-rdv-address", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=77 },
    { .name="max_bitrate", .has_arg=1, .flag=(signed int *)(void *)0, .val=114 },
    { .name="max-bitrate", .has_arg=1, .flag=(signed int *)(void *)0, .val=114 },
    { .name="point-to-point", .has_arg=0, .flag=(signed int *)(void *)0, .val=49 },
    { .name="point_to_point", .has_arg=0, .flag=(signed int *)(void *)0, .val=49 },
    { .name="pointopoint", .has_arg=0, .flag=(signed int *)(void *)0, .val=49 },
    { .name="nopoint-to-point", .has_arg=0, .flag=(signed int *)(void *)0, .val=50 },
    { .name="nopoint_to_point", .has_arg=0, .flag=(signed int *)(void *)0, .val=50 },
    { .name="nopointopoint", .has_arg=0, .flag=(signed int *)(void *)0, .val=50 },
    { .name="async", .has_arg=0, .flag=(signed int *)(void *)0, .val=97 },
    { .name="autorate", .has_arg=0, .flag=(signed int *)(void *)0, .val=65 },
    { .name="log", .has_arg=1, .flag=(signed int *)(void *)0, .val=108 },
    { .name="no-progress", .has_arg=0, .flag=(signed int *)(void *)0, .val=0x701 },
    { .name="min-slice-size", .has_arg=1, .flag=(signed int *)(void *)0, .val=0x0101 },
    { .name="default-slice-size", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=0x0102 },
    { .name="slice-size", .has_arg=1, .flag=(signed int *)(void *)0, .val=0x0102 },
    { .name="max-slice-size", .has_arg=1, .flag=(signed int *)(void *)0, .val=0x0103 },
    { .name="ttl", .has_arg=1, .flag=(signed int *)(void *)0, .val=116 },
    { .name="fec", .has_arg=1, .flag=(signed int *)(void *)0, .val=70 },
    { .name="license", .has_arg=0, .flag=(signed int *)(void *)0, .val=76 },
    { .name="rexmit-hello-interval", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=72 },
    { .name="autostart", .has_arg=1, .flag=(signed int *)(void *)0, .val=83 },
    { .name="broadcast", .has_arg=0, .flag=(signed int *)(void *)0, .val=66 },
    { .name="sendbuf", .has_arg=1, .flag=(signed int *)(void *)0, .val=115 },
    { .name="min-clients", .has_arg=1, .flag=(signed int *)(void *)0, .val=67 },
    { .name="min-receivers", .has_arg=1, .flag=(signed int *)(void *)0, .val=67 },
    { .name="max-wait", .has_arg=1, .flag=(signed int *)(void *)0, .val=87 },
    { .name="min-wait", .has_arg=1, .flag=(signed int *)(void *)0, .val=119 },
    { .name="nokbd", .has_arg=0, .flag=(signed int *)(void *)0, .val=107 },
    { .name="start-timeout", .has_arg=1, .flag=(signed int *)(void *)0, .val=84 },
    { .name="retriesUntilDrop", .has_arg=1, .flag=(signed int *)(void *)0, .val=82 },
    { .name="retries-until-drop", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=82 },
    { .name="daemon-mode", .has_arg=0, .flag=(signed int *)(void *)0, .val=68 },
    { .name="pid-file", .has_arg=1, .flag=(signed int *)(void *)0, .val=0x901 },
    { .name="kill", .has_arg=0, .flag=(signed int *)(void *)0, .val=75 },
    { .name="bw-period", .has_arg=1, .flag=(signed int *)(void *)0, .val=73 },
    { .name="rate-governor", .has_arg=1, .flag=(signed int *)(void *)0, .val=103 },
    { .name="print-uncompressed-position", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=120 },
    { .name="statistics-period", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=122 },
    { .name="stat-period", .has_arg=1, .flag=(signed int *)(void *)0, .val=122 },
    { .name="streaming", .has_arg=0, .flag=(signed int *)(void *)0, .val=90 },
    { .name="rehello-offset", .has_arg=0, .flag=(signed int *)(void *)0, .val=89 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
// pidfile
// file udp-sender.c line 171
static const char *pidfile = (const char *)(void *)0;
// quitting
// file log.c line 71
volatile signed int quitting = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// udpc_log
// file udpcast.c line 5
struct _IO_FILE *udpc_log;
// version
// file udpc_version.c line 3
const char *version = "20120424";

// INET_ATON
// file socklib.c line 209
static inline signed int INET_ATON(const char *a, struct in_addr *i)
{
  i->s_addr=inet_addr(a);
  signed int tmp_statement_expression$1;
  if(i->s_addr == 0xffffffff)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$2;
    return_value___builtin_strcmp$2=__builtin_strcmp(a, "255.255.255.255");
    tmp_statement_expression$1 = return_value___builtin_strcmp$2;
    if(tmp_statement_expression$1 == 0)
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 1;
  }
}

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32$1;
  return_value___builtin_bswap32$1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32$1;
}

// __bswap_32$link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32$link1(unsigned int __bsx$link1)
{
  signed long int return_value___builtin_bswap32$1$link1;
  return_value___builtin_bswap32$1$link1=__builtin_bswap32((signed long int)__bsx$link1);
  return (unsigned int)return_value___builtin_bswap32$1$link1;
}

// __bswap_32$link2
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32$link2(unsigned int __bsx$link2)
{
  signed long int return_value___builtin_bswap32$1$link2;
  return_value___builtin_bswap32$1$link2=__builtin_bswap32((signed long int)__bsx$link2);
  return (unsigned int)return_value___builtin_bswap32$1$link2;
}

// __strpbrk_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1100
static inline char * __strpbrk_c2(const char *__s, signed int __accept1, signed int __accept2)
{
  for( ; !((signed int)*__s == 0); __s = __s + 1l)
  {
    if((signed int)*__s == __accept1)
      break;

    if((signed int)*__s == __accept2)
      break;

  }
  return (signed int)*__s == 0 ? (char *)(void *)0 : (char *)(unsigned long int)__s;
}

// __strpbrk_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1111
static inline char * __strpbrk_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3)
{
  for( ; !((signed int)*__s == 0); __s = __s + 1l)
  {
    if((signed int)*__s == __accept1)
      break;

    if((signed int)*__s == __accept2)
      break;

    if((signed int)*__s == __accept3)
      break;

  }
  return (signed int)*__s == 0 ? (char *)(void *)0 : (char *)(unsigned long int)__s;
}

// _consumeAny
// file produconsum.c line 104
static signed int _consumeAny(struct produconsum *pc, unsigned int minAmount, struct timespec *ts)
{
  unsigned int amount;
  pc->consumerIsWaiting = 1;
  signed int return_value_getProducedAmount$1;
  return_value_getProducedAmount$1=getProducedAmount(pc);
  amount = (unsigned int)return_value_getProducedAmount$1;
  _Bool tmp_if_expr$2;
  if(amount >= minAmount)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = pc->atEnd != 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_getProducedAmount$3;
  if(tmp_if_expr$2)
  {
    pc->consumerIsWaiting = 0;
    return (signed int)amount;
  }

  else
  {
    pthread_mutex_lock(&pc->mutex);
    do
    {
      return_value_getProducedAmount$3=getProducedAmount(pc);
      amount = (unsigned int)return_value_getProducedAmount$3;
      if(amount >= minAmount)
        break;

      if(!(pc->atEnd == 0))
        break;

      if(ts == ((struct timespec *)NULL))
        pthread_cond_wait(&pc->cond, &pc->mutex);

      else
      {
        signed int r;
        r=pthread_cond_timedwait(&pc->cond, &pc->mutex, ts);
        if(r == 110)
        {
          signed int return_value_getProducedAmount$4;
          return_value_getProducedAmount$4=getProducedAmount(pc);
          amount = (unsigned int)return_value_getProducedAmount$4;
          break;
        }

      }
    }
    while((_Bool)1);
    pthread_mutex_unlock(&pc->mutex);
    pc->consumerIsWaiting = 0;
    return (signed int)amount;
  }
}

// ackSlice
// file senddata.c line 392
static signed int ackSlice(struct slice *slice, struct net_config *net_config, struct fifo *fifo, struct sender_stats *stats)
{
  if((signed int)slice->state == SLICE_ACKED)
    return 0;

  else
  {
    if((0x0001 & net_config->flags) == 0)
    {
      if((signed int)net_config->discovery == DSC_DOUBLING)
      {
        net_config->sliceSize = net_config->sliceSize + net_config->sliceSize / 4;
        if(net_config->sliceSize >= net_config->max_slice_size)
        {
          net_config->sliceSize = net_config->max_slice_size;
          net_config->discovery = (enum discovery)DSC_REDUCING;
        }

        udpc_logprintf(udpc_log, "Doubling slice size to %d\n", net_config->sliceSize);
      }

    }

    slice->state = (volatile enum anonymous$10)SLICE_ACKED;
    pc_produce(fifo->freeMemQueue, (unsigned int)slice->bytes);
    udpc_senderStatsAddBytes(stats, (signed long int)slice->bytes);
    if(!(slice->bytes == 0))
      udpc_displaySenderStats(stats, net_config->blockSize, net_config->sliceSize, 0);

    return 0;
  }
}

// addmul
// file fec.c line 406
static void addmul(unsigned char *dst, unsigned char *src, unsigned char c, signed int sz)
{
  if(!((signed int)c == 0))
    slow_addmul1(dst, src, c, sz);

}

// allocAutoRate
// file auto-rate.c line 36
static void * allocAutoRate(void)
{
  struct auto_rate_t *autoRate_l;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct auto_rate_t) /*12ul*/ );
  autoRate_l = (struct auto_rate_t *)return_value_calloc$1;
  if(autoRate_l == ((struct auto_rate_t *)NULL))
    return (void *)0;

  else
  {
    autoRate_l->isInitialized = 0;
    return (void *)autoRate_l;
  }
}

// allocRateLimit
// file rate-limit.c line 52
static void * allocRateLimit(void)
{
  struct rate_limit *rateLimit;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct rate_limit) /*24ul*/ );
  rateLimit = (struct rate_limit *)return_value_calloc$1;
  if(rateLimit == ((struct rate_limit *)NULL))
    return (void *)0;

  else
  {
    rateLimit->date=getLongLongDate();
    rateLimit->bitrate = 0;
    rateLimit->queueSize = 0;
    return (void *)rateLimit;
  }
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1;
}

// atol
// file /usr/include/stdlib.h line 283
static inline signed long int atol(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return return_value_strtol$1;
}

// cancelReturnChannel
// file senddata.c line 715
static void cancelReturnChannel(struct returnChannel *returnChannel)
{
  pthread_cancel(returnChannel->thread);
  pthread_join(returnChannel->thread, (void **)(void *)0);
}

// checkClientWait
// file udps-negotiate.c line 101
static signed int checkClientWait(struct participantsDb *db, struct net_config *net_config, signed long int *firstConnected)
{
  signed long int now;
  signed int return_value_udpc_nrParticipants$1;
  return_value_udpc_nrParticipants$1=udpc_nrParticipants(db);
  _Bool tmp_if_expr$2;
  if(firstConnected == ((signed long int *)NULL) || return_value_udpc_nrParticipants$1 == 0)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(*firstConnected != 0l) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$6;
  signed int return_value_udpc_nrParticipants$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$2)
    return 0;

  else
  {
    now=time(((signed long int *)NULL));
    if(!(net_config->max_receivers_wait == 0))
      tmp_if_expr$6 = now >= *firstConnected + (signed long int)net_config->max_receivers_wait ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
    {
      syslog(6, "max wait[%d] passed: starting", net_config->max_receivers_wait);
      return 1;
    }

    else
    {
      return_value_udpc_nrParticipants$3=udpc_nrParticipants(db);
      if(return_value_udpc_nrParticipants$3 >= net_config->min_receivers)
      {
        if(net_config->min_receivers_wait == 0)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = now >= *firstConnected + (signed long int)net_config->min_receivers_wait ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
      {
        syslog(6, "min receivers[%d] reached: starting", net_config->min_receivers);
        return 1;
      }

      else
        return 0;
    }
  }
}

// cleanPidfile
// file udp-sender.c line 174
static void cleanPidfile(signed int nr)
{
  unlink(pidfile);
  signal(15, (void (*)(signed int))0);
  raise(15);
}

// doAutoRate
// file auto-rate.c line 59
static void doAutoRate(void *data, signed int sock, unsigned int ip, signed long int size)
{
  struct auto_rate_t *autoRate_l = (struct auto_rate_t *)data;
  (void)ip;
  if(autoRate_l->isInitialized == 0)
    initialize(autoRate_l, sock);

  while((_Bool)1)
  {
    signed int r;
    r=getCurrentQueueLength(sock);
    if(!(autoRate_l->dir == 0))
      r = autoRate_l->sendbuf - r;

    if(!((signed long int)r >= (signed long int)(autoRate_l->sendbuf / 2) + -size))
      goto __CPROVER_DUMP_L5;

    usleep((unsigned int)2500);
  }

__CPROVER_DUMP_L5:
  ;
}

// doRateLimit
// file rate-limit.c line 70
static void doRateLimit(void *data, signed int fd, unsigned int ip, signed long int size)
{
  struct rate_limit *rateLimit = (struct rate_limit *)data;
  (void)fd;
  (void)ip;
  _Bool tmp_if_expr$1;
  if(!(rateLimit == ((struct rate_limit *)NULL)))
  {
    signed long long int now;
    now=getLongLongDate();
    signed long long int elapsed = now - rateLimit->date;
    signed long long int bits = (elapsed * (signed long long int)rateLimit->bitrate) / (signed long long int)1000000;
    signed int sleepTime;
    size = size + (signed long int)28;
    if(bits >= (signed long int)(8 * rateLimit->queueSize))
    {
      rateLimit->queueSize = (signed int)size;
      rateLimit->date = now;
      goto __CPROVER_DUMP_L6;
    }

    rateLimit->queueSize = rateLimit->queueSize - (signed int)(bits / (signed long int)8);
    rateLimit->date = rateLimit->date + (bits * (signed long long int)1000000) / (signed long int)rateLimit->bitrate;
    rateLimit->realDate = now;
    sleepTime = (signed int)(((signed long int)(rateLimit->queueSize * 8) * (signed long long int)1000000) / (signed long int)rateLimit->bitrate);
    if(sleepTime >= 40001)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = rateLimit->queueSize >= 100000 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      sleepTime = sleepTime - 10000;
      sleepTime = sleepTime - sleepTime % 10000;
      usleep((unsigned int)sleepTime);
    }

    rateLimit->queueSize = rateLimit->queueSize + (signed int)size;
  }


__CPROVER_DUMP_L6:
  ;
}

// doRetransmissions
// file senddata.c line 499
static signed int doRetransmissions(struct senderState *sendst, struct slice *slice)
{
  if((signed int)slice->state == SLICE_ACKED)
    return 0;

  else
  {
    if(!(slice->needRxmit == 0))
      sendSlice(sendst, slice, 1);

    return 0;
  }
}

// doTransfer
// file udps-negotiate.c line 442
static signed int doTransfer(signed int sock, struct participantsDb *db, struct disk_config *disk_config, struct net_config *net_config, struct stat_config *stat_config)
{
  signed int i;
  struct fifo fifo;
  struct sender_stats *stats;
  signed int in;
  signed int origIn;
  signed int pid;
  signed int isPtP;
  isPtP=isPointToPoint(db, net_config->flags);
  signed int printUncompressedPos;
  signed int return_value_udpc_nrParticipants$2;
  if(!((0x0008 & net_config->flags) == 0))
  {
    return_value_udpc_nrParticipants$2=udpc_nrParticipants(db);
    if(!(return_value_udpc_nrParticipants$2 == 1))
    {
      signed int return_value_udpc_nrParticipants$1;
      return_value_udpc_nrParticipants$1=udpc_nrParticipants(db);
      udpc_fatal(1, "pointopoint mode set, and %d participants instead of 1\n", return_value_udpc_nrParticipants$1);
    }

  }

  net_config->rcvbuf = (unsigned int)0;
  i = 0;
  signed int return_value_udpc_isParticipantValid$6;
  struct sockaddr_in *return_value_udpc_getParticipantIp$3;
  _Bool tmp_if_expr$5;
  for( ; !(i >= 1024); i = i + 1)
  {
    return_value_udpc_isParticipantValid$6=udpc_isParticipantValid(db, i);
    if(!(return_value_udpc_isParticipantValid$6 == 0))
    {
      unsigned int pRcvBuf;
      pRcvBuf=udpc_getParticipantRcvBuf(db, i);
      if(!(isPtP == 0))
      {
        return_value_udpc_getParticipantIp$3=udpc_getParticipantIp(db, i);
        udpc_copyIpFrom(&net_config->dataMcastAddr, return_value_udpc_getParticipantIp$3);
      }

      signed int return_value_udpc_getParticipantCapabilities$4;
      return_value_udpc_getParticipantCapabilities$4=udpc_getParticipantCapabilities(db, i);
      net_config->capabilities = net_config->capabilities & return_value_udpc_getParticipantCapabilities$4;
      if(!(pRcvBuf == 0u))
      {
        if(net_config->rcvbuf == 0u)
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = net_config->rcvbuf > pRcvBuf ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
          net_config->rcvbuf = pRcvBuf;

      }

    }

  }
  signed int return_value_isMcastAddress$7;
  return_value_isMcastAddress$7=isMcastAddress(&net_config->dataMcastAddr);
  if(!(return_value_isMcastAddress$7 == 0))
    udpc_setMcastDestination(sock, net_config->net_if, &net_config->dataMcastAddr);

  udpc_flprintf("Starting transfer: %08x\n", net_config->capabilities);
  char *tmp_if_expr$8;
  if(disk_config->fileName == ((const char *)NULL))
    tmp_if_expr$8 = "";

  else
    tmp_if_expr$8 = disk_config->fileName;
  char *tmp_if_expr$9;
  if(disk_config->pipeName == ((char *)NULL))
    tmp_if_expr$9 = "";

  else
    tmp_if_expr$9 = disk_config->pipeName;
  char *tmp_if_expr$10;
  if(net_config->net_if->name == ((const char *)NULL))
    tmp_if_expr$10 = "";

  else
    tmp_if_expr$10 = net_config->net_if->name;
  signed int return_value_udpc_nrParticipants$11;
  return_value_udpc_nrParticipants$11=udpc_nrParticipants(db);
  syslog(6, "Starting transfer: file[%s] pipe[%s] port[%d] if[%s] participants[%d]", tmp_if_expr$8, tmp_if_expr$9, net_config->portBase, tmp_if_expr$10, return_value_udpc_nrParticipants$11);
  if((0x0008 & net_config->capabilities) == 0)
    udpc_fatal(1, "Peer with incompatible endianness");

  if((0x0001 & net_config->capabilities) == 0)
  {
    net_config->dataMcastAddr = net_config->controlMcastAddr;
    net_config->flags = net_config->flags & ~(0x0001 | 0x0004);
  }

  if(!((0x0020 & net_config->flags) == 0))
    net_config->dataMcastAddr = net_config->controlMcastAddr;

  origIn=udpc_openFile(disk_config);
  in=udpcs_openPipe(disk_config, origIn, &pid);
  printUncompressedPos=udpc_shouldPrintUncompressedPos(stat_config->printUncompressedPos, origIn, in);
  stats=udpc_allocSenderStats(origIn, stat_config->log, stat_config->bwPeriod, (signed long int)stat_config->statPeriod, printUncompressedPos, stat_config->noProgress);
  udpc_initFifo(&fifo, net_config->blockSize);
  udpc_spawnNetSender(&fifo, sock, net_config, db, stats);
  udpc_localReader(&fifo, in);
  close(in);
  if(!(pid == 0))
    udpc_waitForProcess(pid, "Pipe");

  pthread_join(fifo.thread, (void **)(void *)0);
  udpc_displaySenderStats(stats, net_config->blockSize, net_config->sliceSize, 1);
  if(!(in == origIn))
    close(origIn);

  udpc_flprintf("Transfer complete.\a\n");
  syslog(6, "Transfer complete.");
  i = 0;
  for( ; !(i >= 1024); i = i + 1)
    udpc_removeParticipant(db, i);
  udpc_flprintf("\n");
  return 0;
}

// dupFd
// file process.c line 10
static void dupFd(signed int src, signed int target)
{
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(!(src == target))
  {
    close(target);
    signed int return_value_dup2$3;
    return_value_dup2$3=dup2(src, target);
    if(!(return_value_dup2$3 >= 0))
    {
      return_value___errno_location$1=__errno_location();
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      udpc_fatal(1, "dup2 %d->%d: %s\n", src, target, return_value_strerror$2);
    }

    close(src);
  }

}

// fecMain
// file senddata.c line 1001
static void * fecMain(void *args0)
{
  struct senderState *sendst = (struct senderState *)args0;
  struct slice *slice;
  signed int sliceNo = 0;
  signed int tmp_post$1;
  while((_Bool)1)
  {
    tmp_post$1 = sliceNo;
    sliceNo = sliceNo + 1;
    slice=makeSlice(sendst, tmp_post$1);
    fec_encode_all_stripes(sendst, slice);
    pc_produce(sendst->fec_data_pc, (unsigned int)1);
  }
  return NULL;
}

// fec_decode
// file fec.c line 919
void fec_decode(unsigned int blockSize, unsigned char **data_blocks, unsigned int nr_data_blocks, unsigned char **fec_blocks, unsigned int *fec_block_nos, unsigned int *erased_blocks, unsigned short int nr_fec_blocks)
{
  reduce(blockSize, data_blocks, nr_data_blocks, fec_blocks, fec_block_nos, erased_blocks, nr_fec_blocks);
  resolve((signed int)blockSize, data_blocks, fec_blocks, fec_block_nos, erased_blocks, (signed short int)nr_fec_blocks);
}

// fec_encode
// file fec.h line 19
void fec_encode(unsigned int blockSize, unsigned char **data_blocks, unsigned int nrDataBlocks, unsigned char **fec_blocks, unsigned int nrFecBlocks)
{
  unsigned int blockNo;
  unsigned int row;
  unsigned int col;
  /* assertion fec_initialized */
  assert(fec_initialized != 0);
  /* assertion nrDataBlocks <= 128 */
  assert(nrDataBlocks <= (unsigned int)128);
  /* assertion nrFecBlocks <= 128 */
  assert(nrFecBlocks <= (unsigned int)128);
  if(!(nrDataBlocks == 0u))
  {
    row = (unsigned int)0;
    for( ; !(row >= nrFecBlocks); row = row + 1u)
      mul(fec_blocks[(signed long int)row], data_blocks[(signed long int)0], inverse[(signed long int)((unsigned int)128 ^ row)], (signed int)blockSize);
    col = (unsigned int)129;
    blockNo = (unsigned int)1;
    for( ; !(blockNo >= nrDataBlocks); blockNo = blockNo + 1u)
    {
      row = (unsigned int)0;
      for( ; !(row >= nrFecBlocks); row = row + 1u)
        addmul(fec_blocks[(signed long int)row], data_blocks[(signed long int)blockNo], inverse[(signed long int)(row ^ col)], (signed int)blockSize);
      col = col + 1u;
    }
  }

}

// fec_encode_all_stripes
// file senddata.c line 968
static void fec_encode_all_stripes(struct senderState *sendst, struct slice *slice)
{
  signed int stripe;
  struct net_config *config = sendst->config;
  struct fifo *fifo = sendst->fifo;
  signed int bytes = slice->bytes;
  signed int stripes = config->fec_stripes;
  signed int redundancy = config->fec_redundancy;
  signed int nrBlocks = ((bytes + config->blockSize) - 1) / config->blockSize;
  signed int leftOver = bytes % config->blockSize;
  unsigned char *fec_data = slice->fec_data;
  const signed long int fec_data$array_size0 = (signed long int)redundancy;
  unsigned char *fec_blocks[fec_data$array_size0];
  unsigned char *data_blocks[128l];
  if(!(leftOver == 0))
  {
    unsigned char *lastBlock = fifo->dataBuffer + (signed long int)((unsigned int)(slice->base + (nrBlocks - 1) * config->blockSize) % fifo->dataBufSize);
    memset((void *)(lastBlock + (signed long int)leftOver), 0, (unsigned long int)(config->blockSize - leftOver));
  }

  stripe = 0;
  for( ; !(stripe >= stripes); stripe = stripe + 1)
  {
    signed int i;
    signed int j;
    i = 0;
    for( ; !(i >= redundancy); i = i + 1)
      fec_blocks[(signed long int)i] = fec_data + (signed long int)(config->blockSize * (stripe + i * stripes));
    i = stripe;
    j = 0;
    for( ; !(i >= nrBlocks); j = j + 1)
    {
      data_blocks[(signed long int)j] = fifo->dataBuffer + (signed long int)((unsigned int)(slice->base + i * config->blockSize) % fifo->dataBufSize);
      i = i + stripes;
    }
    fec_encode((unsigned int)config->blockSize, data_blocks, (unsigned int)j, fec_blocks, (unsigned int)redundancy);
  }
}

// fec_init
// file fec.h line 17
void fec_init(void)
{
  generate_gf();
  init_mul_table();
  fec_initialized = 1;
}

// fec_license
// file fec.h line 35
void fec_license(void)
{
  fprintf(stderr, "   udpcast and its FEC code are free software\n\n   you can redistribute udpcast core functionality and/or\n   it them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Alain Knaff\n   <alain@knaff.lu>\n   http://udpcast.linux.lu/\n\nthe FEC code is covered by the following license:\nfec.c -- forward error correction based on Vandermonde matrices\n980624\n(C) 1997-98 Luigi Rizzo (luigi@iet.unipi.it)\n(C) 2001 Alain Knaff (alain@knaff.lu)\n\nPortions derived from code by Phil Karn (karn@ka9q.ampr.org),\nRobert Morelos-Zaragoza (robert@spectra.eng.hawaii.edu) and Hari\nThirumoorthy (harit@spectra.eng.hawaii.edu), Aug 1995\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above\n   copyright notice, this list of conditions and the following\n   disclaimer in the documentation and/or other materials\n   provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS\nBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\nOR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\nTORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\nOF SUCH DAMAGE.\n");
  exit(0);
}

// fillMreq
// file socklib.c line 371
static signed int fillMreq(struct net_if *net_if, struct in_addr addr, struct ip_mreqn *mreq)
{
  mreq->imr_ifindex = net_if->index;
  mreq->imr_address.s_addr = (unsigned int)0;
  mreq->imr_multiaddr = addr;
  return 0;
}

// findSlice
// file senddata.c line 620
static struct slice * findSlice(struct slice *slice1, struct slice *slice2, signed int sliceNo)
{
  if(!(slice1 == ((struct slice *)NULL)))
  {
    if(!(slice1->sliceNo == sliceNo))
      goto __CPROVER_DUMP_L1;

    return slice1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(slice2 == ((struct slice *)NULL)))
    {
      if(!(slice2->sliceNo == sliceNo))
        goto __CPROVER_DUMP_L2;

      return slice2;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      return (struct slice *)(void *)0;
    }
  }
}

// freeSlice
// file senddata.c line 132
static signed int freeSlice(struct senderState *sendst, struct slice *slice)
{
  slice->state = (volatile enum anonymous$10)SLICE_PRE_FREE;
  while((_Bool)1)
  {
    signed int pos;
    unsigned int return_value_pc_getProducerPosition$1;
    return_value_pc_getProducerPosition$1=pc_getProducerPosition(sendst->free_slices_pc);
    pos = (signed int)return_value_pc_getProducerPosition$1;
    if((signed int)sendst->slices[(signed long int)pos].state == SLICE_PRE_FREE)
      sendst->slices[(signed long int)pos].state = (volatile enum anonymous$10)SLICE_FREE;

    else
      break;
    pc_produce(sendst->free_slices_pc, (unsigned int)1);
  }
  return 0;
}

// generate_gf
// file fec.c line 217
static void generate_gf(void)
{
  signed int i;
  unsigned char mask;
  char *Pp = allPp[(signed long int)8];
  mask = (unsigned char)1;
  gf_exp[(signed long int)8] = (unsigned char)0;
  i = 0;
  for( ; !(i >= 8); mask = mask << 1)
  {
    gf_exp[(signed long int)i] = mask;
    gf_log[(signed long int)gf_exp[(signed long int)i]] = i;
    if((signed int)Pp[(signed long int)i] == 49)
      gf_exp[(signed long int)8] = gf_exp[(signed long int)8] ^ mask;

    i = i + 1;
  }
  gf_log[(signed long int)gf_exp[(signed long int)8]] = 8;
  mask = (unsigned char)(1 << 8 - 1);
  i = 8 + 1;
  for( ; !(i >= 255); i = i + 1)
  {
    if((signed int)gf_exp[(signed long int)(i + -1)] >= (signed int)mask)
      gf_exp[(signed long int)i] = (unsigned char)((signed int)gf_exp[(signed long int)8] ^ ((signed int)gf_exp[(signed long int)(i - 1)] ^ (signed int)mask) << 1);

    else
      gf_exp[(signed long int)i] = (unsigned char)((signed int)gf_exp[(signed long int)(i - 1)] << 1);
    gf_log[(signed long int)gf_exp[(signed long int)i]] = i;
  }
  gf_log[(signed long int)0] = (1 << 8) - 1;
  i = 0;
  for( ; !(i >= 255); i = i + 1)
    gf_exp[(signed long int)(i + ((1 << 8) - 1))] = gf_exp[(signed long int)i];
  inverse[(signed long int)0] = (unsigned char)0;
  inverse[(signed long int)1] = (unsigned char)1;
  i = 2;
  for( ; !(i >= 256); i = i + 1)
    inverse[(signed long int)i] = gf_exp[(signed long int)(((1 << 8) - 1) - gf_log[(signed long int)i])];
}

// getCurrentQueueLength
// file auto-rate.c line 25
static signed int getCurrentQueueLength(signed int sock)
{
  signed int length;
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(sock, (unsigned long int)0x5411, &length);
  if(!(return_value_ioctl$1 >= 0))
    return -1;

  else
    return length;
}

// getLongLongDate
// file rate-limit.c line 42
static signed long long int getLongLongDate(void)
{
  signed long long int date;
  struct timeval tv;
  gettimeofday(&tv, ((struct timezone *)NULL));
  date = (signed long long int)tv.tv_sec;
  date = date * (signed long long int)1000000;
  date = date + (signed long long int)tv.tv_usec;
  return date;
}

// getProducedAmount
// file produconsum.c line 88
static signed int getProducedAmount(struct produconsum *pc)
{
  unsigned int produced = pc->produced;
  unsigned int consumed = pc->consumed;
  if(!(produced >= consumed))
    return (signed int)((produced + (unsigned int)2 * pc->size) - consumed);

  else
    return (signed int)(produced - consumed);
}

// getSliceBlocks
// file senddata.c line 105
static signed int getSliceBlocks(struct slice *slice, struct net_config *net_config)
{
  return ((slice->bytes + net_config->blockSize) - 1) / net_config->blockSize;
}

// handleDisconnect
// file senddata.c line 609
static signed int handleDisconnect(struct participantsDb *db, struct slice *slice1, struct slice *slice2, signed int clNo)
{
  handleDisconnect1(slice1, clNo);
  handleDisconnect1(slice2, clNo);
  udpc_removeParticipant(db, clNo);
  return 0;
}

// handleDisconnect1
// file senddata.c line 593
static signed int handleDisconnect1(struct slice *slice, signed int clNo)
{
  if(!(slice == ((struct slice *)NULL)))
  {
    if(!((1 << (unsigned long int)clNo % sizeof(char) * 8 /*8ul*/  & (signed int)slice->sl_reqack.readySet[(signed long int)((unsigned long int)clNo / sizeof(char) * 8 /*8ul*/ )]) == 0))
    {
      slice->sl_reqack.readySet[(signed long int)((unsigned long int)clNo / (sizeof(char) /*1ul*/  * (unsigned long int)8))] = slice->sl_reqack.readySet[(signed long int)((unsigned long int)clNo / (sizeof(char) /*1ul*/  * (unsigned long int)8))] & (char)~(1 << (unsigned long int)clNo % (sizeof(char) /*1ul*/  * (unsigned long int)8));
      slice->nrReady = slice->nrReady - 1;
    }

    if(!((1 << (unsigned long int)clNo % sizeof(char) * 8 /*8ul*/  & (signed int)slice->answeredSet[(signed long int)((unsigned long int)clNo / sizeof(char) * 8 /*8ul*/ )]) == 0))
    {
      slice->nrAnswered = slice->nrAnswered - 1;
      slice->answeredSet[(signed long int)((unsigned long int)clNo / (sizeof(char) /*1ul*/  * (unsigned long int)8))] = slice->answeredSet[(signed long int)((unsigned long int)clNo / (sizeof(char) /*1ul*/  * (unsigned long int)8))] & (char)~(1 << (unsigned long int)clNo % (sizeof(char) /*1ul*/  * (unsigned long int)8));
    }

  }

  return 0;
}

// handleNextMessage
// file senddata.c line 631
static signed int handleNextMessage(struct senderState *sendst, struct slice *xmitSlice, struct slice *rexmitSlice)
{
  signed int pos;
  unsigned int return_value_pc_getConsumerPosition$1;
  return_value_pc_getConsumerPosition$1=pc_getConsumerPosition(sendst->rc.incoming);
  pos = (signed int)return_value_pc_getConsumerPosition$1;
  union message *msg = &sendst->rc.q[(signed long int)pos].msg;
  signed int clNo = sendst->rc.q[(signed long int)pos].clNo;
  pc_consumeAny(sendst->rc.incoming);
  unsigned short int tmp_statement_expression$2;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)msg->opCode;
  asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression$2 = __v;
  unsigned int return_value___bswap_32$3;
  struct slice *return_value_findSlice$4;
  unsigned int return_value___bswap_32$5;
  struct slice *return_value_findSlice$6;
  switch((signed int)tmp_statement_expression$2)
  {
    case 0:
    {
      return_value___bswap_32$3=__bswap_32$link1((unsigned int)msg->ok.sliceNo);
      return_value_findSlice$4=findSlice(xmitSlice, rexmitSlice, (signed int)return_value___bswap_32$3);
      handleOk(sendst, return_value_findSlice$4, clNo);
      break;
    }
    case 4:
    {
      handleDisconnect(sendst->rc.participantsDb, xmitSlice, rexmitSlice, clNo);
      break;
    }
    case 1:
    {
      return_value___bswap_32$5=__bswap_32$link1((unsigned int)msg->retransmit.sliceNo);
      return_value_findSlice$6=findSlice(xmitSlice, rexmitSlice, (signed int)return_value___bswap_32$5);
      handleRetransmit(sendst, return_value_findSlice$6, clNo, msg->retransmit.map, msg->retransmit.rxmit);
      break;
    }
    default:
      udpc_flprintf("Bad command %04x\n", (unsigned short int)msg->opCode);
  }
  pc_consumed(sendst->rc.incoming, 1);
  pc_produce(sendst->rc.freeSpace, (unsigned int)1);
  return 0;
}

// handleOk
// file senddata.c line 529
static signed int handleOk(struct senderState *sendst, struct slice *slice, signed int clNo)
{
  if(slice == ((struct slice *)NULL))
    return 0;

  else
  {
    signed int return_value_udpc_isParticipantValid$1;
    return_value_udpc_isParticipantValid$1=udpc_isParticipantValid(sendst->rc.participantsDb, clNo);
    if(return_value_udpc_isParticipantValid$1 == 0)
    {
      udpc_flprintf("Invalid participant %d\n", clNo);
      return 0;
    }

    else
    {
      if((1 << (unsigned long int)clNo % sizeof(char) * 8 /*8ul*/  & (signed int)slice->sl_reqack.readySet[(signed long int)((unsigned long int)clNo / sizeof(char) * 8 /*8ul*/ )]) == 0)
      {
        slice->sl_reqack.readySet[(signed long int)((unsigned long int)clNo / (sizeof(char) /*1ul*/  * (unsigned long int)8))] = slice->sl_reqack.readySet[(signed long int)((unsigned long int)clNo / (sizeof(char) /*1ul*/  * (unsigned long int)8))] | (char)(1 << (unsigned long int)clNo % (sizeof(char) /*1ul*/  * (unsigned long int)8));
        slice->nrReady = slice->nrReady + 1;
        udpc_senderSetAnswered(sendst->stats, clNo);
        markParticipantAnswered(slice, clNo);
      }

      return 0;
    }
  }
}

// handleRetransmit
// file senddata.c line 557
static signed int handleRetransmit(struct senderState *sendst, struct slice *slice, signed int clNo, unsigned char *map, signed int rxmit)
{
  unsigned int i;
  signed int return_value_udpc_isParticipantValid$1;
  return_value_udpc_isParticipantValid$1=udpc_isParticipantValid(sendst->rc.participantsDb, clNo);
  if(return_value_udpc_isParticipantValid$1 == 0)
  {
    udpc_flprintf("Invalid participant %d\n", clNo);
    return 0;
  }

  else
    if(slice == ((struct slice *)NULL))
      return 0;

    else
      if(!(rxmit >= slice->rxmitId))
        return 0;

      else
      {
        i = (unsigned int)0;
        for( ; !((unsigned long int)i >= sizeof(char [128l]) /*128ul*/ ); i = i + 1u)
          slice->rxmitMap[(signed long int)i] = slice->rxmitMap[(signed long int)i] | (char)~((signed int)map[(signed long int)i]);
        slice->needRxmit = 1;
        markParticipantAnswered(slice, clNo);
        return 0;
      }
}

// hasLink
// file socklib.c line 494
static signed int hasLink(signed int s, const char *ifname)
{
  struct ifreq ifr;
  struct ethtool_value edata;
  edata.cmd = (unsigned int)0x0000000a;
  __builtin_strncpy(ifr.ifr_ifrn.ifrn_name, ifname, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
  ifr.ifr_ifru.ifru_data = (char *)&edata;
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(s, (unsigned long int)0x8946, &ifr);
  if(return_value_ioctl$1 == -1)
    return -1;

  else
    return (signed int)edata.data;
}

// initMsgHdr
// file socklib.h line 218
static inline void initMsgHdr(struct msghdr *hdr)
{
  hdr->msg_control = NULL;
  hdr->msg_controllen = (unsigned long int)0;
  hdr->msg_flags = 0;
}

// initReturnChannel
// file senddata.c line 701
static void initReturnChannel(struct returnChannel *returnChannel, struct net_config *config, signed int sock)
{
  returnChannel->config = config;
  returnChannel->rcvSock = sock;
  returnChannel->freeSpace=pc_makeProduconsum(256, "msg:free-queue");
  pc_produce(returnChannel->freeSpace, (unsigned int)256);
  returnChannel->incoming=pc_makeProduconsum(256, "msg:incoming");
  pthread_create(&returnChannel->thread, (const union pthread_attr_t *)(void *)0, returnChannelMain, (void *)returnChannel);
}

// initSockAddress
// file socklib.c line 219
static signed int initSockAddress(enum addr_type_t addr_type, struct net_if *net_if, unsigned int ip, unsigned short int port, struct sockaddr_in *addr)
{
  memset((void *)(char *)addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  addr->sin_family = (unsigned short int)2;
  unsigned short int tmp_statement_expression$1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)port;
  asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression$1 = __v;
  addr->sin_port = tmp_statement_expression$1;
  if(net_if == ((struct net_if *)NULL) && !((signed int)addr_type == ADDR_TYPE_MCAST))
    udpc_fatal(1, "initSockAddr without ifname\n");

  switch((signed int)addr_type)
  {
    case ADDR_TYPE_UCAST:
    {
      addr->sin_addr = net_if->addr;
      break;
    }
    case ADDR_TYPE_BCAST:
    {
      addr->sin_addr = net_if->bcast;
      break;
    }
    case ADDR_TYPE_MCAST:
      addr->sin_addr.s_addr = ip;
  }
  return 0;
}

// initStats
// file statistics.c line 60
static void initStats(struct stats *s, signed int fd, signed long int statPeriod, signed int printUncompressedPos, signed int noProgress)
{
  struct timeval now;
  gettimeofday(&now, ((struct timezone *)NULL));
  s->fd = fd;
  s->statPeriod = statPeriod;
  s->printUncompressedPos = printUncompressedPos;
  s->lastPrinted = now;
  s->noProgress = noProgress;
}

// init_mul_table
// file fec.c line 189
static void init_mul_table(void)
{
  signed int i;
  signed int j;
  i = 0;
  unsigned char return_value_modnn$1;
  for( ; !(i >= 1); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 1); j = j + 1)
    {
      return_value_modnn$1=modnn(gf_log[(signed long int)i] + gf_log[(signed long int)j]);
      gf_mul_table[(signed long int)((i << 8) + j)] = gf_exp[(signed long int)return_value_modnn$1];
    }
  }
  j = 0;
  for( ; !(j >= 1); j = j + 1)
  {
    gf_mul_table[(signed long int)(j << 8)] = (unsigned char)0;
    gf_mul_table[(signed long int)j] = gf_mul_table[(signed long int)(j << 8)];
  }
}

// initialize
// file auto-rate.c line 44
static void initialize(struct auto_rate_t *autoRate_l, signed int sock)
{
  signed int q;
  q=getCurrentQueueLength(sock);
  if(q == 0)
  {
    autoRate_l->dir = 0;
    autoRate_l->sendbuf=udpc_getSendBuf(sock);
  }

  else
  {
    autoRate_l->dir = 1;
    autoRate_l->sendbuf = q;
  }
  autoRate_l->isInitialized = 1;
}

// invert_mat
// file fec.c line 545
static signed int invert_mat(unsigned char *src, signed int k)
{
  unsigned char c;
  unsigned char *p;
  signed int irow;
  signed int icol;
  signed int row;
  signed int col;
  signed int i;
  signed int ix;
  signed int error = 1;
  const signed long int error$array_size0 = (signed long int)k;
  signed int indxc[error$array_size0];
  const signed long int indxc$array_size0 = (signed long int)k;
  signed int indxr[indxc$array_size0];
  const signed long int indxr$array_size0 = (signed long int)k;
  signed int ipiv[indxr$array_size0];
  const signed long int ipiv$array_size0 = (signed long int)k;
  unsigned char id_row[ipiv$array_size0];
  memset((void *)id_row, 0, (unsigned long int)k * sizeof(unsigned char) /*1ul*/ );
  i = 0;
  for( ; !(i >= k); i = i + 1)
    ipiv[(signed long int)i] = 0;
  col = 0;
  for( ; !(col >= k); col = col + 1)
  {
    unsigned char *pivot_row;
    icol = -1;
    irow = icol;
    if(!(ipiv[(signed long int)col] == 1))
    {
      if((signed int)src[(signed long int)(col * k + col)] == 0)
        goto __CPROVER_DUMP_L4;

      irow = col;
      icol = col;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      row = 0;
      for( ; !(row >= k); row = row + 1)
        if(!(ipiv[(signed long int)row] == 1))
        {
          ix = 0;
          for( ; !(ix >= k); ix = ix + 1)
            if(ipiv[(signed long int)ix] == 0)
            {
              if(!((signed int)src[(signed long int)(row * k + ix)] == 0))
              {
                irow = row;
                icol = ix;
                goto found_piv;
              }

            }

            else
              if(ipiv[(signed long int)ix] >= 2)
              {
                fprintf(stderr, "singular matrix\n");
                goto fail;
              }

        }

      if(icol == -1)
      {
        fprintf(stderr, "XXX pivot not found!\n");
        goto fail;
      }

    }

  found_piv:
    ;
    ipiv[(signed long int)icol] = ipiv[(signed long int)icol] + 1;
    if(!(irow == icol))
    {
      ix = 0;
      for( ; !(ix >= k); ix = ix + 1)
      {
        unsigned char tmp = src[(signed long int)(irow * k + ix)];
        src[(signed long int)(irow * k + ix)] = src[(signed long int)(icol * k + ix)];
        src[(signed long int)(icol * k + ix)] = tmp;
      }
    }

    indxr[(signed long int)col] = irow;
    indxc[(signed long int)col] = icol;
    pivot_row = &src[(signed long int)(icol * k)];
    c = pivot_row[(signed long int)icol];
    if((signed int)c == 0)
    {
      fprintf(stderr, "singular matrix 2\n");
      goto fail;
    }

    if(!((signed int)c == 1))
    {
      c = inverse[(signed long int)c];
      pivot_row[(signed long int)icol] = (unsigned char)1;
      ix = 0;
      for( ; !(ix >= k); ix = ix + 1)
        pivot_row[(signed long int)ix] = gf_mul_table[(signed long int)(((signed int)c << 8) + (signed int)pivot_row[(signed long int)ix])];
    }

    id_row[(signed long int)icol] = (unsigned char)1;
    signed int return_value_memcmp$1;
    return_value_memcmp$1=memcmp((const void *)pivot_row, (const void *)id_row, (unsigned long int)k * sizeof(unsigned char) /*1ul*/ );
    if(!(return_value_memcmp$1 == 0))
    {
      p = src;
      ix = 0;
      for( ; !(ix >= k); p = p + (signed long int)k)
      {
        if(!(ix == icol))
        {
          c = p[(signed long int)icol];
          p[(signed long int)icol] = (unsigned char)0;
          addmul(p, pivot_row, c, k);
        }

        ix = ix + 1;
      }
    }

    id_row[(signed long int)icol] = (unsigned char)0;
  }
  col = k - 1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  for( ; col >= 0; col = col - 1)
  {
    if(!(indxr[(signed long int)col] >= 0))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = indxr[(signed long int)col] >= k ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      fprintf(stderr, "AARGH, indxr[col] %d\n", indxr[(signed long int)col]);

    else
    {
      if(!(indxc[(signed long int)col] >= 0))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = indxc[(signed long int)col] >= k ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        fprintf(stderr, "AARGH, indxc[col] %d\n", indxc[(signed long int)col]);

      else
        if(!(indxr[(signed long int)col] == indxc[(signed long int)col]))
        {
          row = 0;
          for( ; !(row >= k); row = row + 1)
          {
            unsigned char invert_mat$$1$$3$$1$$1$$1$$1$$1$$tmp = src[(signed long int)(row * k + indxr[(signed long int)col])];
            src[(signed long int)(row * k + indxr[(signed long int)col])] = src[(signed long int)(row * k + indxc[(signed long int)col])];
            src[(signed long int)(row * k + indxc[(signed long int)col])] = invert_mat$$1$$3$$1$$1$$1$$1$$1$$tmp;
          }
        }

    }
  }
  error = 0;

fail:
  ;
  return error;
}

// isMcastAddress
// file socklib.c line 1111
signed int isMcastAddress(struct sockaddr_in *addr)
{
  signed int ip;
  unsigned int return_value___bswap_32$1;
  return_value___bswap_32$1=__bswap_32(addr->sin_addr.s_addr);
  ip = (signed int)(return_value___bswap_32$1 >> 24);
  return (signed int)(ip >= 0xe0 && ip < 0xf0);
}

// isPointToPoint
// file udps-negotiate.c line 33
static signed int isPointToPoint(struct participantsDb *db, signed int flags)
{
  if(!((0x0008 & flags) == 0))
    return 1;

  else
    if(!((68 & flags) == 0))
      return 0;

    else
    {
      signed int return_value_udpc_nrParticipants$1;
      return_value_udpc_nrParticipants$1=udpc_nrParticipants(db);
      return (signed int)(return_value_udpc_nrParticipants$1 == 1);
    }
}

// isSliceAcked
// file senddata.c line 110
static signed int isSliceAcked(struct slice *slice)
{
  if((signed int)slice->state == SLICE_ACKED)
    return 1;

  else
    return 0;
}

// isSliceXmitted
// file senddata.c line 123
static signed int isSliceXmitted(struct slice *slice)
{
  if((signed int)slice->state == SLICE_XMITTED)
    return 1;

  else
    return 0;
}

// main
// file udp-sender.c line 185
signed int main(signed int argc, char **argv)
{
  signed int c;
  char *ptr;
  signed int daemon_mode = 0;
  signed int doKill = 0;
  signed int r;
  struct net_config net_config;
  struct disk_config disk_config;
  struct stat_config stat_config;
  char *ifName = (char *)(void *)0;
  signed int dataMcastSupplied = 0;
  signed int mainSock;
  disk_config.fileName = (const char *)(void *)0;
  disk_config.pipeName = (char *)(void *)0;
  disk_config.flags = 0;
  udpc_clearIp(&net_config.dataMcastAddr);
  net_config.mcastRdv = (const char *)(void *)0;
  net_config.blockSize = 1456;
  net_config.sliceSize = 16;
  net_config.portBase = 9000;
  net_config.nrGovernors = 0;
  net_config.flags = 0;
  net_config.capabilities = 0;
  net_config.min_slice_size = 16;
  net_config.max_slice_size = 1024;
  net_config.default_slice_size = 0;
  net_config.ttl = 1;
  net_config.rexmit_hello_interval = 0;
  net_config.autostart = 0;
  net_config.requestedBufSize = 0;
  net_config.min_receivers = 0;
  net_config.max_receivers_wait = 0;
  net_config.min_receivers_wait = 0;
  net_config.startTimeout = 0;
  net_config.retriesUntilDrop = 200;
  net_config.rehelloOffset = 50;
  stat_config.log = (struct _IO_FILE *)(void *)0;
  stat_config.bwPeriod = (signed long int)0;
  stat_config.printUncompressedPos = -1;
  stat_config.statPeriod = 500000;
  stat_config.noProgress = 0;
  ptr=strrchr(argv[(signed long int)0], 47);
  if(ptr == ((char *)NULL))
    ptr = argv[(signed long int)0];

  else
    ptr = ptr + 1l;
  net_config.net_if = (struct net_if$0 *)(void *)0;
  signed int tmp_statement_expression$11;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp$12;
  return_value___builtin_strcmp$12=__builtin_strcmp(ptr, "init");
  tmp_statement_expression$11 = return_value___builtin_strcmp$12;
  unsigned long int return_value_strtoul$2;
  char *return_value___strdup$3;
  void *gov;
  signed int return_value_atoi$8;
  unsigned long int return_value_udpc_parseSize$9;
  signed long int return_value_atol$10;
  if(tmp_statement_expression$11 == 0)
  {
    char *return_value___strdup$1;
    return_value___strdup$1=__strdup("/bin/gzip -c");
    disk_config.pipeName = return_value___strdup$1;
    disk_config.fileName = "/dev/hda";
  }

  else
  {
    const char *argLetters = "b:C:f:F:g:H:i:I:Kl:m:M:p:P:r:R:s:S:t:T:w:W:x:z:12aABcdDkLY:Z";
    do
    {
      c=getopt_long(argc, argv, argLetters, options, (signed int *)(void *)0);
      if(c == -1)
        break;

      switch(c)
      {
        case 97:
        {
          net_config.flags = net_config.flags | 0x0004 | 0x0001;
          break;
        }
        case 99:
        {
          net_config.flags = net_config.flags & ~0x0001;
          net_config.flags = net_config.flags | 0x0002;
          break;
        }
        case 100:
        {
          net_config.flags = net_config.flags | 0x0001;
          break;
        }
        case 102:
        {
          disk_config.fileName = optarg;
          break;
        }
        case 105:
        {
          ifName = optarg;
          break;
        }
        case 112:
        {
          disk_config.pipeName = optarg;
          break;
        }
        case 80:
        {
          net_config.portBase=atoi(optarg);
          break;
        }
        case 49:
        {
          net_config.flags = net_config.flags | 0x0008;
          break;
        }
        case 50:
        {
          net_config.flags = net_config.flags | 0x0040;
          break;
        }
        case 98:
        {
          return_value_strtoul$2=strtoul(optarg, ((char ** restrict )NULL), 0);
          net_config.blockSize = (signed int)return_value_strtoul$2;
          net_config.blockSize = net_config.blockSize - net_config.blockSize % 4;
          if(!(net_config.blockSize >= 1))
          {
            perror("block size too small");
            exit(1);
          }

          break;
        }
        case 108:
        {
          udpc_log=fopen(optarg, "a");
          stat_config.log = udpc_log;
          break;
        }
        case 0x701:
        {
          stat_config.noProgress = 1;
          break;
        }
        case 109:
        {
          udpc_setIpFromString(&net_config.dataMcastAddr, optarg);
          udpc_ipIsZero(&net_config.dataMcastAddr);
          dataMcastSupplied = 1;
          break;
        }
        case 77:
        {
          return_value___strdup$3=__strdup(optarg);
          net_config.mcastRdv = return_value___strdup$3;
          break;
        }
        case 114:
        {
          gov=rgInitGovernor(&net_config, &maxBitrate);
          maxBitrate.rgSetProp(gov, "maxBitrate", optarg);
        }
        case 65:
        {
          rgInitGovernor(&net_config, &autoRate);
          break;
        }
        case 0x0101:
        {
          net_config.min_slice_size=atoi(optarg);
          if(net_config.min_slice_size >= 1025)
            udpc_fatal(1, "min slice size too big\n");

          break;
        }
        case 0x0102:
        {
          net_config.default_slice_size=atoi(optarg);
          break;
        }
        case 0x0103:
        {
          net_config.max_slice_size=atoi(optarg);
          if(net_config.max_slice_size >= 1025)
            udpc_fatal(1, "max slice size too big\n");

          break;
        }
        case 116:
        {
          net_config.ttl=atoi(optarg);
          break;
        }
        case 70:
        {
          net_config.flags = net_config.flags | 0x0010;
          char *eptr;
          char *return_value___builtin_strchr$4;
          return_value___builtin_strchr$4=__builtin_strchr(optarg, 120);
          ptr = return_value___builtin_strchr$4;
          if(!(ptr == ((char *)NULL)))
          {
            unsigned long int return_value_strtoul$5;
            return_value_strtoul$5=strtoul(optarg, &eptr, 10);
            net_config.fec_stripes = (signed int)return_value_strtoul$5;
            if(!(ptr == eptr))
            {
              udpc_flprintf("%s != %s\n", ptr, eptr);
              usage(argv[(signed long int)0]);
            }

            ptr = ptr + 1l;
          }

          else
          {
            net_config.fec_stripes = 8;
            ptr = optarg;
          }
          unsigned long int return_value_strtoul$6;
          return_value_strtoul$6=strtoul(ptr, &eptr, 10);
          net_config.fec_redundancy = (signed int)return_value_strtoul$6;
          if((signed int)*eptr == 47)
          {
            ptr = eptr + (signed long int)1;
            unsigned long int return_value_strtoul$7;
            return_value_strtoul$7=strtoul(ptr, &eptr, 10);
            net_config.fec_stripesize = (signed int)return_value_strtoul$7;
          }

          else
            net_config.fec_stripesize = 128;
          if(!(*eptr == 0))
          {
            udpc_flprintf("string not at end %s\n", eptr);
            usage(argv[(signed long int)0]);
          }

          fprintf(stderr, "stripes=%d redund=%d stripesize=%d\n", net_config.fec_stripes, net_config.fec_redundancy, net_config.fec_stripesize);
          break;
        }
        case 122:
        {
          return_value_atoi$8=atoi(optarg);
          stat_config.statPeriod = return_value_atoi$8 * 1000;
          break;
        }
        case 120:
        {
          stat_config.printUncompressedPos=atoi(optarg);
          break;
        }
        case 76:
        {
          fec_license();
          break;
        }
        case 72:
        {
          net_config.rexmit_hello_interval=atoi(optarg);
          break;
        }
        case 83:
        {
          net_config.autostart=atoi(optarg);
          break;
        }
        case 66:
        {
          net_config.flags = net_config.flags | 0x0020;
          break;
        }
        case 115:
        {
          return_value_udpc_parseSize$9=udpc_parseSize(optarg);
          net_config.requestedBufSize = (signed int)return_value_udpc_parseSize$9;
          break;
        }
        case 67:
        {
          net_config.min_receivers=atoi(optarg);
          break;
        }
        case 87:
        {
          net_config.max_receivers_wait=atoi(optarg);
          break;
        }
        case 119:
        {
          net_config.min_receivers_wait=atoi(optarg);
          break;
        }
        case 84:
        {
          net_config.startTimeout=atoi(optarg);
          break;
        }
        case 107:
        {
          net_config.flags = net_config.flags | 0x0080;
          break;
        }
        case 82:
        {
          net_config.retriesUntilDrop=atoi(optarg);
          break;
        }
        case 68:
        {
          daemon_mode = daemon_mode + 1;
          break;
        }
        case 75:
        {
          doKill = 1;
          break;
        }
        case 0x901:
        {
          pidfile = optarg;
          break;
        }
        case 73:
        {
          stat_config.bwPeriod=atol(optarg);
          break;
        }
        case 103:
        {
          rgParseRateGovernor(&net_config, optarg);
          break;
        }
        case 90:
        {
          net_config.flags = net_config.flags | 0x0100;
          break;
        }
        case 89:
        {
          return_value_atol$10=atol(optarg);
          net_config.rehelloOffset = (signed int)return_value_atol$10;
          break;
        }
        case 63:

        default:
          usage(argv[(signed long int)0]);
      }
    }
    while((_Bool)1);
  }
  if(!(doKill == 0))
  {
    struct _IO_FILE *main$$1$$4$$p;
    char line[80l];
    signed int pid;
    if(pidfile == ((const char *)NULL))
    {
      fprintf(stderr, "-K only works together with --pidfile\n");
      return 1;
    }

    main$$1$$4$$p=fopen(pidfile, "r");
    if(main$$1$$4$$p == ((struct _IO_FILE *)NULL))
    {
      perror("Could not read pidfile");
      return 1;
    }

    char *return_value_fgets$13;
    return_value_fgets$13=fgets(line, (signed int)sizeof(char [80l]) /*80ul*/ , main$$1$$4$$p);
    if(return_value_fgets$13 == ((char *)NULL))
    {
      fprintf(stderr, "Empty pid file\n");
      return 1;
    }

    fclose(main$$1$$4$$p);
    pid=atoi(line);
    if(!(pid >= 1))
    {
      fprintf(stderr, "Negative or null pid\n");
      return -1;
    }

    signed int return_value_kill$15;
    return_value_kill$15=kill(pid, 15);
    if(!(return_value_kill$15 >= 0))
    {
      signed int *return_value___errno_location$14;
      return_value___errno_location$14=__errno_location();
      if(*return_value___errno_location$14 == 3)
        unlink(pidfile);

      perror("Kill");
      return 1;
    }

    return 0;
  }

  signed int tmp_post$16;
  if(!((0x0004 & net_config.flags) == 0))
  {
    if(!(dataMcastSupplied == 0))
      net_config.flags = net_config.flags & ~0x0008;

    if((0x0008 & net_config.flags) == 0)
      goto __CPROVER_DUMP_L67;

    fprintf(stderr, "Pointopoint supplied together with async, but no dataMcastAddress (-m)\n");
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L67:
    ;
    if(disk_config.fileName == ((const char *)NULL) && !(optind >= argc))
    {
      tmp_post$16 = optind;
      optind = optind + 1;
      disk_config.fileName = argv[(signed long int)tmp_post$16];
    }

    if(!(optind >= argc))
      fprintf(stderr, "Extra argument \"%s\" ignored\n", argv[(signed long int)optind]);

    if(!((0x0008 & net_config.flags) == 0) && !((0x0040 & net_config.flags) == 0))
      udpc_fatal(1, "pointopoint and nopointopoint cannot be set both\n");

    if(net_config.rexmit_hello_interval == 0 && (!((0x0004 & net_config.flags) == 0) || !(net_config.autostart == 0)))
      net_config.rexmit_hello_interval = 1000;

    if(!((0x0004 & net_config.flags) == 0))
    {
      if((0x0010 & net_config.flags) == 0)
      {
        fprintf(stderr, "Warning: Async mode but no forward error correction\n");
        fprintf(stderr, "Transmission may fail due to packet loss\n");
        fprintf(stderr, "Add \"--fec 8x8\" to commandline\n");
      }

    }

    if(!(net_config.min_slice_size >= 1))
      net_config.min_slice_size = 1;

    if(!(net_config.max_slice_size >= net_config.min_slice_size))
      net_config.max_slice_size = net_config.min_slice_size;

    if(!(net_config.default_slice_size == 0))
    {
      if(!(net_config.default_slice_size >= net_config.min_slice_size))
        net_config.default_slice_size = net_config.min_slice_size;

      if(!(net_config.max_slice_size >= net_config.default_slice_size))
        net_config.default_slice_size = net_config.max_slice_size;

    }

    if(!(daemon_mode >= 2))
      fprintf(stderr, "Udp-sender %s\n", version);

    openlog((const char *)"udpcast", 0x08 | 0x01, 5 << 3);
    mainSock=udpc_openMainSenderSock(&net_config, ifName);
    if(!(mainSock >= 0))
    {
      perror("Make main sock");
      exit(1);
    }

    if(daemon_mode == 2)
    {
      net_config.flags = net_config.flags | 0x0080;
      stat_config.noProgress = 1;
      signed int return_value_daemon$17;
      return_value_daemon$17=daemon(1, 0);
      if(!(return_value_daemon$17 >= 0))
      {
        perror("Could not daemonize");
        exit(1);
      }

      if(!(pidfile == ((const char *)NULL)))
      {
        struct _IO_FILE *p;
        p=fopen(pidfile, "w");
        signed int return_value_getpid$18;
        return_value_getpid$18=getpid();
        fprintf(p, "%d\n", return_value_getpid$18);
        fclose(p);
        signal(15, cleanPidfile);
      }

    }

    do
      r=udpc_startSender(&disk_config, &net_config, &stat_config, mainSock);
    while(!(daemon_mode == 0));
    close(mainSock);
    rgShutdownAll(&net_config);
    return r;
  }
}

// mainDispatcher
// file udps-negotiate.c line 157
static signed int mainDispatcher(signed int *fd, signed int nr, struct participantsDb *db, struct net_config *net_config, struct console_t **console, signed int *tries, signed long int *firstConnected)
{
  struct sockaddr_in client;
  union message fromClient;
  struct anonymous$4 read_set;
  signed int ret;
  signed int msgLength;
  signed int startNow = 0;
  signed int selected;
  signed int keyPressed = 0;
  signed long int loopStart;
  loopStart=time(((signed long int *)NULL));
  signed int return_value_udpc_nrParticipants$1;
  return_value_udpc_nrParticipants$1=udpc_nrParticipants(db);
  _Bool tmp_if_expr$2;
  if(!(return_value_udpc_nrParticipants$1 == 0))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (net_config->flags & 0x0004) != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    if((0x0080 & net_config->flags) == 0)
    {
      if(!(*console == ((struct console_t *)NULL)))
        fprintf(stderr, "Ready. Press any key to start sending data.\n");

    }

  }

  signed int return_value_udpc_nrParticipants$3;
  if(!(firstConnected == ((signed long int *)NULL)))
  {
    if(*firstConnected == 0l)
    {
      return_value_udpc_nrParticipants$3=udpc_nrParticipants(db);
      if(!(return_value_udpc_nrParticipants$3 == 0))
      {
        *firstConnected=time(((signed long int *)NULL));
        syslog(6, "first connection: min wait[%d] secs - max wait[%d] - min clients[%d]", net_config->min_receivers_wait, net_config->max_receivers_wait, net_config->min_receivers);
      }

    }

  }

  _Bool tmp_if_expr$5;
  signed int return_value_udpc_nrParticipants$4;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$8;
  signed int return_value_checkClientWait$7;
  signed long int return_value_time$9;
  while(startNow == 0)
  {
    struct timeval tv;
    struct timeval *tvp;
    signed int nr_desc;
    signed int maxFd;
    maxFd=udpc_prepareForSelect(fd, nr, &read_set);
    if(!(net_config->rexmit_hello_interval == 0))
    {
      tv.tv_usec = (signed long int)((net_config->rexmit_hello_interval % 1000) * 1000);
      tv.tv_sec = (signed long int)(net_config->rexmit_hello_interval / 1000);
      tvp = &tv;
    }

    else
    {
      if(!(firstConnected == ((signed long int *)NULL)))
      {
        return_value_udpc_nrParticipants$4=udpc_nrParticipants(db);
        tmp_if_expr$5 = return_value_udpc_nrParticipants$4 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = net_config->startTimeout != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
      {
        tv.tv_usec = (signed long int)0;
        tv.tv_sec = (signed long int)2;
        tvp = &tv;
      }

      else
        tvp = ((struct timeval *)NULL);
    }
    nr_desc=selectWithConsole(*console, maxFd + 1, &read_set, tvp, &keyPressed);
    if(!(nr_desc >= 0))
    {
      perror("select");
      return -1;
    }

    if(nr_desc >= 1 || !(keyPressed == 0))
      break;

    if(!(net_config->rexmit_hello_interval == 0))
    {
      udpc_sendHello(net_config, fd[(signed long int)0], 0);
      *tries = *tries + 1;
      if(!(net_config->autostart == 0))
      {
        if(!(net_config->autostart >= *tries))
          startNow = 1;

      }

    }

    if(!(firstConnected == ((signed long int *)NULL)))
    {
      if(!(startNow == 0))
        tmp_if_expr$8 = (_Bool)1;

      else
      {
        return_value_checkClientWait$7=checkClientWait(db, net_config, firstConnected);
        tmp_if_expr$8 = return_value_checkClientWait$7 != 0 ? (_Bool)1 : (_Bool)0;
      }
      startNow = (signed int)tmp_if_expr$8;
    }

    if(startNow == 0)
    {
      if(!(net_config->startTimeout == 0))
      {
        return_value_time$9=time(((signed long int *)NULL));
        if(return_value_time$9 + -loopStart >= (signed long int)net_config->startTimeout)
        {
          startNow = -1;
          break;
        }

      }

    }

  }
  if(!(keyPressed == 0))
  {
    udpc_restoreConsole(console, 1);
    startNow = 1;
  }

  selected=udpc_getSelectedSock(fd, nr, &read_set);
  unsigned short int tmp_statement_expression$10;
  unsigned int return_value___bswap_32$11;
  unsigned int return_value___bswap_32$12;
  if(selected == -1)
    return startNow;

  else
  {
    memset((void *)&fromClient, 0, sizeof(union message) /*140ul*/ );
    msgLength=udpc_doReceive(selected, (void *)&fromClient, sizeof(union message) /*140ul*/ , &client, net_config->portBase);
    if(!(msgLength >= 0))
    {
      perror("problem getting data from client");
      return 0;
    }

    else
      if(!((0x0004 & net_config->flags) == 0))
        return 0;

      else
      {
        unsigned short int __v;
        unsigned short int __x = (unsigned short int)fromClient.opCode;
        asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
        tmp_statement_expression$10 = __v;
        switch((signed int)tmp_statement_expression$10)
        {
          case 3:
          {
            return_value___bswap_32$11=__bswap_32$link2((unsigned int)fromClient.connectReq.capabilities);
            return_value___bswap_32$12=__bswap_32$link2(fromClient.connectReq.rcvbuf);
            sendConnectionReply(db, fd[(signed long int)0], net_config, &client, (signed int)((unsigned int)0x0008 | return_value___bswap_32$11), return_value___bswap_32$12);
            return startNow;
          }
          case 2:
            return 1;
          case 4:
          {
            ret=udpc_lookupParticipant(db, &client);
            if(ret >= 0)
              udpc_removeParticipant(db, ret);

            return startNow;
          }
          default:
          {
            udpc_flprintf("Unexpected command %04x\n", (unsigned short int)fromClient.opCode);
            return startNow;
          }
        }
      }
  }
}

// makeSlice
// file senddata.c line 150
static struct slice * makeSlice(struct senderState *sendst, signed int sliceNo)
{
  struct net_config *config = sendst->config;
  struct fifo *fifo = sendst->fifo;
  signed int i;
  struct slice *slice = (struct slice *)(void *)0;
  pc_consume(sendst->free_slices_pc, 1);
  unsigned int return_value_pc_getConsumerPosition$1;
  return_value_pc_getConsumerPosition$1=pc_getConsumerPosition(sendst->free_slices_pc);
  i = (signed int)return_value_pc_getConsumerPosition$1;
  slice = &sendst->slices[(signed long int)i];
  /* assertion slice->state == SLICE_FREE */
  assert((signed int)slice->state == SLICE_FREE);
  memset((void *)&(*slice), 0, sizeof(struct slice) /*584ul*/ );
  pc_consumed(sendst->free_slices_pc, 1);
  unsigned int return_value_pc_getConsumerPosition$2;
  return_value_pc_getConsumerPosition$2=pc_getConsumerPosition(sendst->fifo->data);
  slice->base = (signed int)return_value_pc_getConsumerPosition$2;
  slice->sliceNo = sliceNo;
  slice->bytes=pc_consume(fifo->data, 10 * config->blockSize);
  if(!(config->blockSize * config->sliceSize >= slice->bytes))
    slice->bytes = config->blockSize * config->sliceSize;

  if(!(config->blockSize >= slice->bytes))
    slice->bytes = slice->bytes - slice->bytes % config->blockSize;

  pc_consumed(fifo->data, slice->bytes);
  slice->nextBlock = 0;
  slice->state = (volatile enum anonymous$10)SLICE_NEW;
  memset((void *)&slice->sl_reqack.readySet, 0, sizeof(char [128l]) /*128ul*/ );
  slice->nrReady = 0;
  slice->fec_data = sendst->fec_data + (signed long int)(i * config->fec_stripes * config->fec_redundancy * config->blockSize);
  return slice;
}

// markParticipantAnswered
// file senddata.c line 517
static void markParticipantAnswered(struct slice *slice, signed int clNo)
{
  if((1 << (unsigned long int)clNo % sizeof(char) * 8 /*8ul*/  & (signed int)slice->answeredSet[(signed long int)((unsigned long int)clNo / sizeof(char) * 8 /*8ul*/ )]) == 0)
  {
    slice->nrAnswered = slice->nrAnswered + 1;
    slice->answeredSet[(signed long int)((unsigned long int)clNo / (sizeof(char) /*1ul*/  * (unsigned long int)8))] = slice->answeredSet[(signed long int)((unsigned long int)clNo / (sizeof(char) /*1ul*/  * (unsigned long int)8))] | (char)(1 << (unsigned long int)clNo % (sizeof(char) /*1ul*/  * (unsigned long int)8));
  }

}

// mcastListen
// file socklib.c line 418
static signed int mcastListen(signed int sock, struct net_if *net_if, struct sockaddr_in *addr)
{
  signed int return_value_mcastOp$1;
  return_value_mcastOp$1=mcastOp(sock, net_if, ((struct sockaddr_in *)addr)->sin_addr, 35, "Subscribe to multicast group");
  return return_value_mcastOp$1;
}

// mcastOp
// file socklib.c line 387
static signed int mcastOp(signed int sock, struct net_if *net_if, struct in_addr addr, signed int code, const char *message)
{
  struct ip_mreqn mreq;
  signed int r;
  fillMreq(net_if, addr, &mreq);
  r=setsockopt(sock, 0, code, (const void *)(char *)&mreq, (unsigned int)sizeof(struct ip_mreqn) /*12ul*/ );
  if(!(r >= 0))
  {
    perror(message);
    exit(1);
  }

  return 0;
}

// modnn
// file fec.c line 152
static inline unsigned char modnn(signed int x)
{
  for( ; x >= 255; x = (x >> 8) + (x & (1 << 8) - 1))
    x = x - ((1 << 8) - 1);
  return (unsigned char)x;
}

// mul
// file fec.c line 532
static inline void mul(unsigned char *dst, unsigned char *src, unsigned char c, signed int sz)
{
  if(!((signed int)c == 0))
    slow_mul1(dst, src, c, sz);

  else
    memset((void *)dst, 0, (unsigned long int)sz);
}

// netSenderMain
// file senddata.c line 724
static void * netSenderMain(void *args0)
{
  struct senderState *sendst = (struct senderState *)args0;
  struct net_config *config = sendst->config;
  struct timeval tv;
  struct timespec ts;
  signed int atEnd = 0;
  signed int nrWaited = 0;
  unsigned long int waitAverage = (unsigned long int)10000;
  struct slice *xmitSlice = (struct slice *)(void *)0;
  struct slice *rexmitSlice = (struct slice *)(void *)0;
  signed int sliceNo = 0;
  if(config->default_slice_size == 0)
  {
    if(!((0x0010 & config->flags) == 0))
      config->sliceSize = config->fec_stripesize * config->fec_stripes;

    else
      if(!((0x0004 & config->flags) == 0))
        config->sliceSize = 1024;

      else
        if(!((0x0001 & sendst->config->flags) == 0))
          sendst->config->sliceSize = 112;

        else
          sendst->config->sliceSize = 130;
    sendst->config->discovery = (enum discovery)DSC_DOUBLING;
  }

  else
  {
    config->sliceSize = config->default_slice_size;
    if(!((0x0010 & config->flags) == 0))
    {
      if(!(128 * config->fec_stripes >= config->sliceSize))
        config->sliceSize = 128 * config->fec_stripes;

    }

  }
  if(!((0x0010 & sendst->config->flags) == 0))
  {
    if(!(128 * config->fec_stripes >= config->max_slice_size))
      config->max_slice_size = config->fec_stripes * 128;

  }

  if(!(config->max_slice_size >= config->sliceSize))
    config->sliceSize = config->max_slice_size;

  /* assertion config->sliceSize <= 1024 */
  assert(config->sliceSize <= 1024);
  signed int return_value_isSliceXmitted$5;
  signed int return_value_udpc_nrParticipants$7;
  signed int tmp_post$9;
  signed int return_value_udpc_nrParticipants$1;
  _Bool tmp_if_expr$2;
  while((_Bool)1)
  {
    if(!(rexmitSlice == ((struct slice *)NULL)))
    {
      signed int return_value_udpc_nrParticipants$3;
      return_value_udpc_nrParticipants$3=udpc_nrParticipants(sendst->rc.participantsDb);
      if(rexmitSlice->nrReady == return_value_udpc_nrParticipants$3)
        ackSlice(rexmitSlice, sendst->config, sendst->fifo, sendst->stats);

      signed int return_value_isSliceAcked$4;
      return_value_isSliceAcked$4=isSliceAcked(rexmitSlice);
      if(!(return_value_isSliceAcked$4 == 0))
      {
        freeSlice(sendst, rexmitSlice);
        rexmitSlice = (struct slice *)(void *)0;
      }

    }

    if(rexmitSlice == ((struct slice *)NULL) && !(xmitSlice == ((struct slice *)NULL)))
    {
      return_value_isSliceXmitted$5=isSliceXmitted(xmitSlice);
      if(!(return_value_isSliceXmitted$5 == 0))
      {
        rexmitSlice = xmitSlice;
        xmitSlice = (struct slice *)(void *)0;
        sendReqack(rexmitSlice, sendst->config, sendst->fifo, sendst->stats, sendst->socket);
      }

    }

    unsigned int return_value_pc_getWaiting$6;
    return_value_pc_getWaiting$6=pc_getWaiting(sendst->rc.incoming);
    if(!(return_value_pc_getWaiting$6 == 0u))
      handleNextMessage(sendst, xmitSlice, rexmitSlice);

    else
      if(!(rexmitSlice == ((struct slice *)NULL)))
      {
        if(rexmitSlice->needRxmit == 0)
          goto __CPROVER_DUMP_L15;

        doRetransmissions(sendst, rexmitSlice);
      }

      else
      {

      __CPROVER_DUMP_L15:
        ;
        if(!(rexmitSlice == ((struct slice *)NULL)))
        {
          return_value_udpc_nrParticipants$7=udpc_nrParticipants(sendst->rc.participantsDb);
          if(rexmitSlice->nrAnswered == return_value_udpc_nrParticipants$7)
          {
            rexmitSlice->rxmitId = rexmitSlice->rxmitId + 1;
            sendReqack(rexmitSlice, sendst->config, sendst->fifo, sendst->stats, sendst->socket);
          }

        }

        if(xmitSlice == ((struct slice *)NULL) && atEnd == 0)
        {
          if(rexmitSlice == ((struct slice *)NULL) || !((0x0001 & sendst->config->flags) == 0))
          {
            if(!((0x0010 & sendst->config->flags) == 0))
            {
              signed int i;
              pc_consume(sendst->fec_data_pc, 1);
              unsigned int return_value_pc_getConsumerPosition$8;
              return_value_pc_getConsumerPosition$8=pc_getConsumerPosition(sendst->fec_data_pc);
              i = (signed int)return_value_pc_getConsumerPosition$8;
              xmitSlice = &sendst->slices[(signed long int)i];
              pc_consumed(sendst->fec_data_pc, 1);
            }

            else
            {
              tmp_post$9 = sliceNo;
              sliceNo = sliceNo + 1;
              xmitSlice=makeSlice(sendst, tmp_post$9);
            }
            if(xmitSlice->bytes == 0)
              atEnd = 1;

          }

        }

        if(!(xmitSlice == ((struct slice *)NULL)))
        {
          if(!((signed int)xmitSlice->state == SLICE_NEW))
            goto __CPROVER_DUMP_L20;

          sendSlice(sendst, xmitSlice, 0);
        }

        else
        {

        __CPROVER_DUMP_L20:
          ;
          if(rexmitSlice == ((struct slice *)NULL) && xmitSlice == ((struct slice *)NULL) && !(atEnd == 0))
            break;

          if(!((0x0004 & sendst->config->flags) == 0))
            break;

          gettimeofday(&tv, ((struct timezone *)NULL));
          ts.tv_sec = tv.tv_sec;
          ts.tv_nsec = (signed long int)(((double)tv.tv_usec + 1.1 * (double)waitAverage) * (double)1000);
          for( ; ts.tv_nsec >= 1000000000l; ts.tv_sec = ts.tv_sec + 1l)
            ts.tv_nsec = ts.tv_nsec - (signed long int)1000000000;
          if(rexmitSlice->rxmitId >= 11)
            ts.tv_sec = ts.tv_sec + 1l;

          signed int return_value_pc_consumeAnyWithTimeout$10;
          return_value_pc_consumeAnyWithTimeout$10=pc_consumeAnyWithTimeout(sendst->rc.incoming, &ts);
          if(!(return_value_pc_consumeAnyWithTimeout$10 == 0))
          {
            struct timeval tv2;
            unsigned long int timeout;
            gettimeofday(&tv2, ((struct timezone *)NULL));
            timeout = (unsigned long int)(((tv2.tv_sec - tv.tv_sec) * (signed long int)1000000 + tv2.tv_usec) - tv.tv_usec);
            if(!(nrWaited == 0))
              timeout = timeout + waitAverage;

            waitAverage = waitAverage + (unsigned long int)9;
            waitAverage = (unsigned long int)(0.9 * (double)waitAverage + 0.1 * (double)timeout);
            nrWaited = 0;
          }

          else
          {
            if(rexmitSlice == ((struct slice *)NULL))
            {
              udpc_flprintf("Weird. Timeout and no rxmit slice");
              break;
            }

            if(nrWaited >= 6)
            {
              udpc_flprintf("Timeout notAnswered=");
              udpc_printNotSet(sendst->rc.participantsDb, rexmitSlice->answeredSet);
              udpc_flprintf(" notReady=");
              udpc_printNotSet(sendst->rc.participantsDb, rexmitSlice->sl_reqack.readySet);
              signed int return_value_udpc_nrParticipants$11;
              return_value_udpc_nrParticipants$11=udpc_nrParticipants(sendst->rc.participantsDb);
              udpc_flprintf(" nrAns=%d nrRead=%d nrPart=%d avg=%ld\n", rexmitSlice->nrAnswered, rexmitSlice->nrReady, return_value_udpc_nrParticipants$11, waitAverage);
              nrWaited = 0;
            }

            nrWaited = nrWaited + 1;
            if(!(config->retriesUntilDrop >= rexmitSlice->rxmitId))
            {
              signed int netSenderMain$$1$$3$$12$$i = 0;
              for( ; !(netSenderMain$$1$$3$$12$$i >= 1024); netSenderMain$$1$$3$$12$$i = netSenderMain$$1$$3$$12$$i + 1)
              {
                signed int return_value_udpc_isParticipantValid$13;
                return_value_udpc_isParticipantValid$13=udpc_isParticipantValid(sendst->rc.participantsDb, netSenderMain$$1$$3$$12$$i);
                if(!(return_value_udpc_isParticipantValid$13 == 0))
                {
                  if((1 << (unsigned long int)netSenderMain$$1$$3$$12$$i % sizeof(char) * 8 /*8ul*/  & (signed int)rexmitSlice->sl_reqack.readySet[(signed long int)((unsigned long int)netSenderMain$$1$$3$$12$$i / sizeof(char) * 8 /*8ul*/ )]) == 0)
                  {
                    udpc_flprintf("Dropping client #%d because of timeout\n", netSenderMain$$1$$3$$12$$i);
                    syslog(6, "dropped client #%d because of timeout", netSenderMain$$1$$3$$12$$i);
                    udpc_removeParticipant(sendst->rc.participantsDb, netSenderMain$$1$$3$$12$$i);
                    signed int return_value_udpc_nrParticipants$12;
                    return_value_udpc_nrParticipants$12=udpc_nrParticipants(sendst->rc.participantsDb);
                    if(return_value_udpc_nrParticipants$12 == 0)
                      goto exit_main_loop;

                  }

                }

              }
              goto __CPROVER_DUMP_L34;
            }

            rexmitSlice->rxmitId = rexmitSlice->rxmitId + 1;
            sendReqack(rexmitSlice, sendst->config, sendst->fifo, sendst->stats, sendst->socket);
          }
        }
      }

  __CPROVER_DUMP_L34:
    ;
    return_value_udpc_nrParticipants$1=udpc_nrParticipants(sendst->rc.participantsDb);
    if(!(return_value_udpc_nrParticipants$1 == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (config->flags & 0x0004) != 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$2)
      break;

  }

exit_main_loop:
  ;
  cancelReturnChannel(&sendst->rc);
  pc_produceEnd(sendst->fifo->freeMemQueue);
  return NULL;
}

// open2
// file udpc_process.h line 17
signed int open2(signed int in, signed int out, char **arg, signed int closeFd)
{
  signed int pid;
  pid=fork();
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(!(pid == 0))
  {
    if(pid == -1)
      goto __CPROVER_DUMP_L3;

  }

  else
  {
    dupFd(in, 0);
    dupFd(out, 1);
    if(!(closeFd == -1))
      close(closeFd);

    execvp(arg[(signed long int)0], arg);
    return_value___errno_location$1=__errno_location();
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    udpc_fatal(1, "exec %s: %s\n", arg[(signed long int)0], return_value_strerror$2);

  __CPROVER_DUMP_L3:
    ;
    perror("fork");
    return -1;
  }
  return pid;
}

// parseSpeed
// file rate-limit.c line 20
static unsigned long int parseSpeed(const char *speedString)
{
  char *eptr;
  unsigned long int speed;
  speed=strtoul(speedString, &eptr, 10);
  if(!(eptr == ((char *)NULL)))
  {
    if(!(*eptr == 0))
      switch((signed int)*eptr)
      {
        case 109:

        case 77:
        {
          speed = speed * (unsigned long int)1000000;
          break;
        }
        case 107:

        case 75:
        {
          speed = speed * (unsigned long int)1000;
          break;
        }
        case 0:
          break;
        default:
          udpc_fatal(1, "Unit %c unsupported\n", *eptr);
      }

  }

  return speed;
}

// pc_consume
// file produconsum.h line 30
signed int pc_consume(struct produconsum *pc, signed int amount)
{
  signed int return_value__consumeAny$1;
  return_value__consumeAny$1=_consumeAny(pc, (unsigned int)amount, ((struct timespec *)NULL));
  return return_value__consumeAny$1;
}

// pc_consumeAny
// file produconsum.h line 9
signed int pc_consumeAny(struct produconsum *pc)
{
  signed int return_value__consumeAny$1;
  return_value__consumeAny$1=_consumeAny(pc, (unsigned int)1, ((struct timespec *)NULL));
  return return_value__consumeAny$1;
}

// pc_consumeAnyContiguous
// file produconsum.c line 177
signed int pc_consumeAnyContiguous(struct produconsum *pc)
{
  signed int return_value_pc_consumeContiguousMinAmount$1;
  return_value_pc_consumeContiguousMinAmount$1=pc_consumeContiguousMinAmount(pc, 1);
  return return_value_pc_consumeContiguousMinAmount$1;
}

// pc_consumeAnyWithTimeout
// file produconsum.h line 10
signed int pc_consumeAnyWithTimeout(struct produconsum *pc, struct timespec *ts)
{
  signed int return_value__consumeAny$1;
  return_value__consumeAny$1=_consumeAny(pc, (unsigned int)1, ts);
  return return_value__consumeAny$1;
}

// pc_consumeContiguousMinAmount
// file produconsum.h line 21
signed int pc_consumeContiguousMinAmount(struct produconsum *pc, signed int amount)
{
  signed int n;
  n=_consumeAny(pc, (unsigned int)amount, ((struct timespec *)NULL));
  signed int l = (signed int)(pc->size - pc->consumed % pc->size);
  if(!(l >= n))
    n = l;

  return n;
}

// pc_consumed
// file produconsum.h line 58
signed int pc_consumed(struct produconsum *pc, signed int amount)
{
  unsigned int consumed = pc->consumed;
  if(consumed >= 2u * pc->size + -((unsigned int)amount))
    consumed = consumed + ((unsigned int)amount - (unsigned int)2 * pc->size);

  else
    consumed = consumed + (unsigned int)amount;
  pc->consumed = consumed;
  return amount;
}

// pc_getConsumerPosition
// file produconsum.h line 35
unsigned int pc_getConsumerPosition(struct produconsum *pc)
{
  return pc->consumed % pc->size;
}

// pc_getProducerPosition
// file produconsum.h line 40
unsigned int pc_getProducerPosition(struct produconsum *pc)
{
  return pc->produced % pc->size;
}

// pc_getSize
// file produconsum.c line 207
unsigned int pc_getSize(struct produconsum *pc)
{
  return pc->size;
}

// pc_getWaiting
// file produconsum.h line 52
unsigned int pc_getWaiting(struct produconsum *pc)
{
  signed int return_value_getProducedAmount$1;
  return_value_getProducedAmount$1=getProducedAmount(pc);
  return (unsigned int)return_value_getProducedAmount$1;
}

// pc_makeProduconsum
// file produconsum.h line 6
struct produconsum * pc_makeProduconsum(signed int size, const char *name)
{
  struct produconsum *pc;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct produconsum) /*120ul*/ );
  pc = (struct produconsum *)return_value_calloc$1;
  pc->size = (unsigned int)size;
  pc->produced = (volatile unsigned int)0;
  pc->consumed = (unsigned int)0;
  pc->atEnd = 0;
  pthread_mutex_init(&pc->mutex, (const union anonymous$6 *)(void *)0);
  pc->consumerIsWaiting = 0;
  pthread_cond_init(&pc->cond, (const union anonymous$6 *)(void *)0);
  pc->name = name;
  return pc;
}

// pc_produce
// file produconsum.h line 7
void pc_produce(struct produconsum *pc, unsigned int amount)
{
  unsigned int produced = pc->produced;
  unsigned int consumed = pc->consumed;
  if(!(pc->size >= amount))
    udpc_fatal(1, "Buffer overflow in produce %s: %d > %d \n", pc->name, amount, pc->size);

  produced = produced + amount;
  if(produced >= 2u * pc->size)
    produced = produced - (unsigned int)2 * pc->size;

  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(!(pc->size + consumed >= produced))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if(!(produced >= consumed))
      tmp_if_expr$1 = produced > consumed - pc->size ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    udpc_fatal(1, "Buffer overflow in produce %s: %d > %d [%d] \n", pc->name, produced, consumed, pc->size);

  pc->produced = produced;
  wakeConsumer(pc);
}

// pc_produceEnd
// file produconsum.h line 8
void pc_produceEnd(struct produconsum *pc)
{
  pc->atEnd = 1;
  wakeConsumer(pc);
}

// printFilePosition
// file statistics.c line 94
static void printFilePosition(signed int fd)
{
  char *tmp_statement_expression$2;
  if(!(fd == -1))
  {
    char fn[80l];
    signed int pfd;
    sprintf(fn, "/proc/self/fdinfo/%d", fd);
    pfd=open(fn, 00);
    if(!(pfd == -1))
    {
      char buf[161l];
      signed int n;
      signed long int return_value_read$1;
      return_value_read$1=read(pfd, (void *)buf, (unsigned long int)160);
      n = (signed int)return_value_read$1;
      if(n >= 0)
      {
        char *num;
        signed long long int offset;
        buf[(signed long int)n] = (char)0;
        char __a0;
        char __a1;
        char __a2;
        char *return_value___builtin_strpbrk$3;
        return_value___builtin_strpbrk$3=__builtin_strpbrk(buf, "0123456789");
        tmp_statement_expression$2 = return_value___builtin_strpbrk$3;
        num = tmp_statement_expression$2;
        unsigned long long int return_value_strtoull$4;
        return_value_strtoull$4=strtoull(num, ((char ** restrict )NULL), 10);
        offset = (signed long long int)return_value_strtoull$4;
        if(offset >= 0l)
          udpc_printLongNum((unsigned long long int)offset);

      }

      close(pfd);
    }

    else
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      char *return_value_strerror$6;
      return_value_strerror$6=strerror(*return_value___errno_location$5);
      fprintf(stderr, "%s --> %s\n", (const void *)fn, return_value_strerror$6);
    }
  }

}

// printNewlineIfNeeded
// file log.c line 13
static void printNewlineIfNeeded(void)
{
  if(!(needNewline == 0))
    fprintf(stderr, "\n");

  needNewline = 0;
}

// printProcessStatus
// file udpcast.c line 30
static signed int printProcessStatus(const char *message, signed int status)
{
  /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous$9
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
  ;
  if((0x7f & status) == 0)
  {
    if(!((0xff00 & status) >> 8 == 0))
    {
      udpc_flprintf("%s process died with code %d\n", message, (((union anonymous$9){ .__in=status }).__i & 0xff00) >> 8);
      return (((union anonymous$9){ .__in=status }).__i & 0xff00) >> 8;
    }

  }

  else
  {
    if((signed int)((127 & (signed char)status) + 1) >> 1 >= 1)
    {
      udpc_flprintf("%s process caught signal %d\n", message, ((union anonymous$9){ .__in=status }).__i & 0x7f);
      return 1;
    }

    udpc_flprintf("%s process did not cleanly exit\n", message);
    return 1;
  }
  return 0;
}

// reduce
// file fec.c line 810
static inline void reduce(unsigned int blockSize, unsigned char **data_blocks, unsigned int nr_data_blocks, unsigned char **fec_blocks, unsigned int *fec_block_nos, unsigned int *erased_blocks, unsigned short int nr_fec_blocks)
{
  signed int erasedIdx = 0;
  unsigned int col = (unsigned int)0;
  _Bool tmp_if_expr$1;
  for( ; !(col >= nr_data_blocks); col = col + 1u)
  {
    if(!(erasedIdx >= (signed int)nr_fec_blocks))
      tmp_if_expr$1 = erased_blocks[(signed long int)erasedIdx] == col ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      erasedIdx = erasedIdx + 1;

    else
    {
      unsigned char *src = data_blocks[(signed long int)col];
      signed int j = 0;
      for( ; !(j >= (signed int)nr_fec_blocks); j = j + 1)
      {
        signed int blno = (signed int)fec_block_nos[(signed long int)j];
        addmul(fec_blocks[(signed long int)j], src, inverse[(signed long int)((unsigned int)blno ^ col ^ (unsigned int)128)], (signed int)blockSize);
      }
    }
  }
  /* assertion nr_fec_blocks == erasedIdx */
  assert((signed int)nr_fec_blocks == erasedIdx);
}

// resolve
// file fec.c line 856
static inline void resolve(signed int blockSize, unsigned char **data_blocks, unsigned char **fec_blocks, unsigned int *fec_block_nos, unsigned int *erased_blocks, signed short int nr_fec_blocks)
{
  signed int row;
  const signed long int row$array_size0 = (signed long int)((signed int)nr_fec_blocks * (signed int)nr_fec_blocks);
  unsigned char matrix[row$array_size0];
  signed int ptr;
  signed int r;
  row = 0;
  ptr = 0;
  for( ; !(row >= (signed int)nr_fec_blocks); row = row + 1)
  {
    signed int col;
    signed int irow = (signed int)((unsigned int)128 + fec_block_nos[(signed long int)row]);
    col = 0;
    for( ; !(col >= (signed int)nr_fec_blocks); ptr = ptr + 1)
    {
      signed int icol = (signed int)erased_blocks[(signed long int)col];
      matrix[(signed long int)ptr] = inverse[(signed long int)(irow ^ icol)];
      col = col + 1;
    }
  }
  r=invert_mat(matrix, (signed int)nr_fec_blocks);
  if(!(r == 0))
  {
    signed int resolve$$1$$2$$col;
    fprintf(stderr, "Pivot not found\n");
    fprintf(stderr, "Rows: ");
    row = 0;
    for( ; !(row >= (signed int)nr_fec_blocks); row = row + 1)
      fprintf(stderr, "%d ", (unsigned int)128 + fec_block_nos[(signed long int)row]);
    fprintf(stderr, "\n");
    fprintf(stderr, "Columns: ");
    resolve$$1$$2$$col = 0;
    for( ; !(resolve$$1$$2$$col >= (signed int)nr_fec_blocks); ptr = ptr + 1)
    {
      fprintf(stderr, "%d ", erased_blocks[(signed long int)resolve$$1$$2$$col]);
      resolve$$1$$2$$col = resolve$$1$$2$$col + 1;
    }
    fprintf(stderr, "\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  row = 0;
  ptr = 0;
  signed int tmp_post$1;
  for( ; !(row >= (signed int)nr_fec_blocks); row = row + 1)
  {
    signed int resolve$$1$$3$$1$$col;
    unsigned char *target = data_blocks[(signed long int)erased_blocks[(signed long int)row]];
    tmp_post$1 = ptr;
    ptr = ptr + 1;
    mul(target, fec_blocks[(signed long int)0], matrix[(signed long int)tmp_post$1], blockSize);
    resolve$$1$$3$$1$$col = 1;
    for( ; !(resolve$$1$$3$$1$$col >= (signed int)nr_fec_blocks); ptr = ptr + 1)
    {
      addmul(target, fec_blocks[(signed long int)resolve$$1$$3$$1$$col], matrix[(signed long int)ptr], blockSize);
      resolve$$1$$3$$1$$col = resolve$$1$$3$$1$$col + 1;
    }
  }
}

// returnChannelMain
// file senddata.c line 676
static void * returnChannelMain(void *args)
{
  struct returnChannel *returnChannel = (struct returnChannel *)args;
  while((_Bool)1)
  {
    struct sockaddr_in from;
    signed int clNo;
    signed int pos;
    unsigned int return_value_pc_getConsumerPosition$1;
    return_value_pc_getConsumerPosition$1=pc_getConsumerPosition(returnChannel->freeSpace);
    pos = (signed int)return_value_pc_getConsumerPosition$1;
    pc_consumeAny(returnChannel->freeSpace);
    udpc_doReceive(returnChannel->rcvSock, (void *)&returnChannel->q[(signed long int)pos].msg, sizeof(union message) /*140ul*/ , &from, returnChannel->config->portBase);
    clNo=udpc_lookupParticipant(returnChannel->participantsDb, &from);
    if(clNo >= 0)
    {
      returnChannel->q[(signed long int)pos].clNo = clNo;
      pc_consumed(returnChannel->freeSpace, 1);
      pc_produce(returnChannel->incoming, (unsigned int)1);
    }

  }
  return NULL;
}

// rgInitGovernor
// file udpcast.h line 117
void * rgInitGovernor(struct net_config *cfg, struct rateGovernor_t *gov)
{
  if(cfg->nrGovernors == 10)
  {
    fprintf(stderr, "Too many rate governors\n");
    exit(1);
  }

  cfg->rateGovernor[(signed long int)cfg->nrGovernors] = gov;
  signed int tmp_post$1 = cfg->nrGovernors;
  cfg->nrGovernors = cfg->nrGovernors + 1;
  cfg->rateGovernorData[(signed long int)tmp_post$1]=gov->rgInitialize();
  return cfg->rateGovernorData[(signed long int)tmp_post$1];
}

// rgParseRateGovernor
// file udpcast.h line 118
void rgParseRateGovernor(struct net_config *net_config, char *rg)
{
  char *pos;
  char *return_value___builtin_strchr$1;
  return_value___builtin_strchr$1=__builtin_strchr(rg, 58);
  pos = return_value___builtin_strchr$1;
  char *dlname;
  char *params;
  char *error;
  void *rgdl;
  struct rateGovernor_t *gov;
  void *data;
  if(!(pos == ((char *)NULL)))
  {
    char *return_value___strndup$2;
    return_value___strndup$2=__strndup(rg, (unsigned long int)(pos - rg));
    dlname = return_value___strndup$2;
    params = pos + (signed long int)1;
  }

  else
  {
    dlname = rg;
    params = (char *)(void *)0;
  }
  rgdl=dlopen(dlname, 0x00001);
  if(rgdl == NULL)
  {
    char *return_value_dlerror$3;
    return_value_dlerror$3=dlerror();
    fprintf(stderr, "Library load error %s\n", return_value_dlerror$3);
    exit(1);
  }

  dlerror();
  void *return_value_dlsym$4;
  return_value_dlsym$4=dlsym(rgdl, "governor");
  gov = (struct rateGovernor_t *)return_value_dlsym$4;
  error=dlerror();
  if(!(error == ((char *)NULL)))
  {
    fprintf(stderr, "Symbol resolve error: %s\n", error);
    exit(1);
  }

  if(!(pos == ((char *)NULL)))
    free((void *)dlname);

  data=rgInitGovernor(net_config, gov);
  unsigned long int return_value_strlen$6;
  if(!(gov->rgSetProp == ((void (*)(void *, const char *, const char *))NULL)))
  {
    if(!(params == ((char *)NULL)))
    {
      if(!(*params == 0))
      {
        char *eqPos;
        const char *key;
        const char *value;
        char *return_value___builtin_strchr$5;
        return_value___builtin_strchr$5=__builtin_strchr(params, 44);
        pos = return_value___builtin_strchr$5;
        if(pos == ((char *)NULL))
        {
          return_value_strlen$6=strlen(params);
          pos = params + (signed long int)return_value_strlen$6;
        }

        char *return_value___builtin_strchr$7;
        return_value___builtin_strchr$7=__builtin_strchr(params, 61);
        eqPos = return_value___builtin_strchr$7;
        if(eqPos == ((char *)NULL) || eqPos >= pos)
        {
          char *return_value___strndup$8;
          return_value___strndup$8=__strndup(params, (unsigned long int)(pos - params));
          key = return_value___strndup$8;
          value = (const char *)(void *)0;
        }

        else
        {
          char *return_value___strndup$9;
          return_value___strndup$9=__strndup(params, (unsigned long int)(eqPos - params));
          key = return_value___strndup$9;
          char *return_value___strndup$10;
          return_value___strndup$10=__strndup(eqPos + (signed long int)1, (unsigned long int)(pos - (eqPos + (signed long int)1)));
          value = return_value___strndup$10;
        }
        gov->rgSetProp(data, key, value);
        if(!(*pos == 0))
          pos = pos + 1l;

        params = pos;
      }

    }

  }

  if(!(gov->rgEndConfig == ((void (*)(void *))NULL)))
    gov->rgEndConfig(data);

}

// rgShutdownAll
// file udpcast.h line 120
void rgShutdownAll(struct net_config *cfg)
{
  signed int i = 0;
  i = 0;
  for( ; !(i >= cfg->nrGovernors); i = i + 1)
    if(!(cfg->rateGovernor[(signed long int)i]->rgShutdown == ((void (*)(void *))NULL)))
      cfg->rateGovernor[(signed long int)i]->rgShutdown(cfg->rateGovernorData[(signed long int)i]);

}

// rgWaitAll
// file rateGovernor.c line 106
void rgWaitAll(struct net_config *cfg, signed int sock, unsigned int ip, signed int size)
{
  signed int i = 0;
  i = 0;
  if(!(i >= cfg->nrGovernors))
  {
    cfg->rateGovernor[(signed long int)i]->rgWait(cfg->rateGovernorData[(signed long int)i], sock, ip, (signed long int)size);
    i = i + 1;
  }

}

// safe_inet_aton
// file socklib.c line 266
static signed int safe_inet_aton(const char *address, struct in_addr *ip)
{
  signed int return_value_INET_ATON$1;
  return_value_INET_ATON$1=INET_ATON(address, ip);
  if(return_value_INET_ATON$1 == 0)
    udpc_fatal(-1, "Bad address %s", address);

  return 0;
}

// selectWithConsole
// file console.h line 26
signed int selectWithConsole(struct console_t *con, signed int maxFd, struct anonymous$4 *read_set, struct timeval *tv, signed int *keyPressed)
{
  signed int ret;
  if(!(con == ((struct console_t *)NULL)))
  {
    signed int fd = con->fd;
    read_set->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = read_set->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    if(fd >= maxFd)
      maxFd = fd + 1;

  }

  ret=select(maxFd, read_set, (struct anonymous$4 *)(void *)0, (struct anonymous$4 *)(void *)0, tv);
  if(!(ret >= 0))
    return -1;

  else
  {
    if(!(con == ((struct console_t *)NULL)))
    {
      if(!((read_set->__fds_bits[(signed long int)(con->fd / 8)] & (signed long int)(1UL << con->fd % 8)) == 0l))
        *keyPressed = 1;

    }

    return ret;
  }
}

// sendConnectionReply
// file udps-negotiate.c line 42
static signed int sendConnectionReply(struct participantsDb *db, signed int sock, struct net_config *config, struct sockaddr_in *client, signed int capabilities, unsigned int rcvbuf)
{
  struct connectReply reply;
  if(rcvbuf == 0u)
    rcvbuf = (unsigned int)65536;

  unsigned short int tmp_statement_expression$1;
  if(!((0x0008 & capabilities) == 0))
  {
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)7;
    asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression$1 = __v;
    reply.opCode = tmp_statement_expression$1;
    signed int return_value_udpc_addParticipant$2;
    return_value_udpc_addParticipant$2=udpc_addParticipant(db, client, capabilities, rcvbuf, config->flags & 0x0008);
    unsigned int return_value___bswap_32$3;
    return_value___bswap_32$3=__bswap_32$link2((unsigned int)return_value_udpc_addParticipant$2);
    reply.clNr = (signed int)return_value___bswap_32$3;
    unsigned int return_value___bswap_32$4;
    return_value___bswap_32$4=__bswap_32$link2((unsigned int)config->blockSize);
    reply.blockSize = (signed int)return_value___bswap_32$4;
  }

  else
    udpc_fatal(1, "Little endian protocol no longer supported");
  reply.reserved = (signed short int)0;
  if(!((0x0008 & config->flags) == 0))
    udpc_copyIpFrom(&config->dataMcastAddr, client);

  unsigned int return_value___bswap_32$5;
  return_value___bswap_32$5=__bswap_32$link2((unsigned int)config->capabilities);
  reply.capabilities = (signed int)return_value___bswap_32$5;
  udpc_copyToMessage(reply.mcastAddr, &config->dataMcastAddr);
  rgWaitAll(config, sock, client->sin_addr.s_addr, (signed int)sizeof(struct connectReply) /*32ul*/ );
  signed int return_value_udpc_doSend$6;
  return_value_udpc_doSend$6=udpc_doSend(sock, (void *)&reply, sizeof(struct connectReply) /*32ul*/ , &(*client));
  if(!(return_value_udpc_doSend$6 >= 0))
  {
    perror("reply add new client");
    return -1;
  }

  else
    return 0;
}

// sendRawData
// file senddata.c line 191
static signed int sendRawData(signed int sock, struct net_config *config, char *header, signed int headerSize, unsigned char *data, signed int dataSize)
{
  struct iovec iov[2l];
  struct msghdr hdr;
  signed int packetSize;
  signed int ret;
  iov[(signed long int)0].iov_base = (void *)header;
  iov[(signed long int)0].iov_len = (unsigned long int)headerSize;
  iov[(signed long int)1].iov_base = (void *)data;
  iov[(signed long int)1].iov_len = (unsigned long int)dataSize;
  hdr.msg_name = (void *)&config->dataMcastAddr;
  hdr.msg_namelen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  hdr.msg_iov = iov;
  hdr.msg_iovlen = (unsigned long int)2;
  initMsgHdr(&hdr);
  packetSize = dataSize + headerSize;
  rgWaitAll(config, sock, config->dataMcastAddr.sin_addr.s_addr, packetSize);
  signed long int return_value_sendmsg$1;
  return_value_sendmsg$1=sendmsg(sock, &hdr, 0);
  ret = (signed int)return_value_sendmsg$1;
  if(!(ret >= 0))
  {
    char ipBuffer[16l];
    char *return_value_udpc_getIpString$2;
    return_value_udpc_getIpString$2=udpc_getIpString(&config->dataMcastAddr, ipBuffer);
    unsigned short int return_value_udpc_getPort$3;
    return_value_udpc_getPort$3=udpc_getPort(&config->dataMcastAddr);
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    udpc_fatal(1, "Could not broadcast data packet to %s:%d (%s)\n", return_value_udpc_getIpString$2, return_value_udpc_getPort$3, return_value_strerror$5);
  }

  return 0;
}

// sendReqack
// file senddata.c line 425
static signed int sendReqack(struct slice *slice, struct net_config *net_config, struct fifo *fifo, struct sender_stats *stats, signed int sock)
{
  unsigned short int tmp_statement_expression$1;
  if(!((0x0004 & net_config->flags) == 0))
  {
    if(slice->bytes == 0)
      goto __CPROVER_DUMP_L1;

    ackSlice(slice, net_config, fifo, stats);
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!((0x0004 & net_config->flags) == 0))
    {
      if((0x0010 & net_config->flags) == 0)
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if((0x0001 & net_config->flags) == 0)
      {
        if(!(slice->rxmitId == 0))
        {
          signed int nrBlocks;
          nrBlocks=getSliceBlocks(slice, net_config);
          if(!(slice->lastGoodBlock == 0))
          {
            if(!(slice->lastGoodBlock >= nrBlocks))
            {
              net_config->discovery = (enum discovery)DSC_REDUCING;
              if(!(slice->lastGoodBlock >= net_config->sliceSize / 2))
                net_config->sliceSize = net_config->sliceSize / 2;

              else
                net_config->sliceSize = slice->lastGoodBlock;
              if(!(net_config->sliceSize >= 32))
                net_config->sliceSize = 32;

              udpc_logprintf(udpc_log, "Slice size=%d\n", net_config->sliceSize);
            }

          }

        }

      }

      slice->lastGoodBlock = 0;
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)6;
      asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression$1 = __v;
      slice->sl_reqack.ra.opCode = tmp_statement_expression$1;
      unsigned int return_value___bswap_32$2;
      return_value___bswap_32$2=__bswap_32$link1((unsigned int)slice->sliceNo);
      slice->sl_reqack.ra.sliceNo = (signed int)return_value___bswap_32$2;
      unsigned int return_value___bswap_32$3;
      return_value___bswap_32$3=__bswap_32$link1((unsigned int)slice->bytes);
      slice->sl_reqack.ra.bytes = (signed int)return_value___bswap_32$3;
      slice->sl_reqack.ra.reserved = (signed short int)0;
      memcpy((void *)&slice->answeredSet, (void *)&slice->sl_reqack.readySet, sizeof(char [128l]) /*128ul*/ );
      slice->nrAnswered = slice->nrReady;
      slice->needRxmit = 0;
      memset((void *)slice->rxmitMap, 0, sizeof(char [128l]) /*128ul*/ );
      memset((void *)slice->isXmittedMap, 0, sizeof(char [128l]) /*128ul*/ );
      unsigned int return_value___bswap_32$4;
      return_value___bswap_32$4=__bswap_32$link1((unsigned int)slice->rxmitId);
      slice->sl_reqack.ra.rxmit = (signed int)return_value___bswap_32$4;
      rgWaitAll(net_config, sock, net_config->dataMcastAddr.sin_addr.s_addr, (signed int)sizeof(struct reqackBm) /*144ul*/ );
      udpc_doSend(sock, (void *)&slice->sl_reqack, sizeof(struct reqackBm) /*144ul*/ , &net_config->dataMcastAddr);
      return 0;
    }
  }
}

// sendSlice
// file senddata.c line 284
static signed int sendSlice(struct senderState *sendst, struct slice *slice, signed int retransmitting)
{
  struct net_config *config = sendst->config;
  signed int nrBlocks;
  signed int i;
  signed int rehello;
  signed int fecBlocks;
  signed int retransmissions = 0;
  if(!(retransmitting == 0))
  {
    slice->nextBlock = 0;
    if(!((signed int)slice->state == SLICE_XMITTED))
      return 0;

  }

  else
    if(!((signed int)slice->state == SLICE_NEW))
      return 0;

  nrBlocks=getSliceBlocks(slice, config);
  if(retransmitting == 0 && !((0x0010 & config->flags) == 0))
    fecBlocks = config->fec_redundancy * config->fec_stripes;

  else
    fecBlocks = 0;
  if(!((0x0100 & sendst->config->flags) == 0))
  {
    rehello = nrBlocks - sendst->config->rehelloOffset;
    if(!(rehello >= 0))
      rehello = 0;

  }

  else
    rehello = -1;
  i = slice->nextBlock;
  _Bool tmp_if_expr$1;
  unsigned int return_value_pc_getWaiting$2;
  for( ; !(i >= fecBlocks + nrBlocks); i = i + 1)
  {
    if(!(retransmitting == 0))
    {
      if((1 << (unsigned long int)i % sizeof(char) * 8 /*8ul*/  & (signed int)slice->rxmitMap[(signed long int)((unsigned long int)i / sizeof(char) * 8 /*8ul*/ )]) == 0)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = ((signed int)slice->isXmittedMap[(signed long int)((unsigned long int)i / (sizeof(char) /*1ul*/  * (unsigned long int)8))] & 1 << (unsigned long int)i % (sizeof(char) /*1ul*/  * (unsigned long int)8)) != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        if(!(slice->lastGoodBlock >= i))
          slice->lastGoodBlock = i;

        goto __CPROVER_DUMP_L19;
      }

      slice->isXmittedMap[(signed long int)((unsigned long int)i / (sizeof(char) /*1ul*/  * (unsigned long int)8))] = slice->isXmittedMap[(signed long int)((unsigned long int)i / (sizeof(char) /*1ul*/  * (unsigned long int)8))] | (char)(1 << (unsigned long int)i % (sizeof(char) /*1ul*/  * (unsigned long int)8));
      retransmissions = retransmissions + 1;
    }

    if(i == rehello)
      udpc_sendHello(sendst->config, sendst->socket, 1);

    if(!(i >= nrBlocks))
      transmitDataBlock(sendst, slice, i);

    else
      transmitFecBlock(sendst, slice, i - nrBlocks);
    if(retransmitting == 0)
    {
      return_value_pc_getWaiting$2=pc_getWaiting(sendst->rc.incoming);
      if(!(return_value_pc_getWaiting$2 == 0u))
      {
        i = i + 1;
        break;
      }

    }


  __CPROVER_DUMP_L19:
    ;
  }
  if(!(retransmissions == 0))
    udpc_senderStatsAddRetransmissions(sendst->stats, retransmissions);

  slice->nextBlock = i;
  if(i == fecBlocks + nrBlocks)
  {
    slice->needRxmit = 0;
    if(retransmitting == 0)
      slice->state = (volatile enum anonymous$10)SLICE_XMITTED;

    return 2;
  }

  else
    return 1;
}

// setProp
// file rate-limit.c line 62
static void setProp(void *data, const char *key, const char *bitrate)
{
  struct rate_limit *rateLimit = (struct rate_limit *)data;
  signed int tmp_statement_expression$2;
  unsigned long int return_value_parseSpeed$1;
  if(!(rateLimit == ((struct rate_limit *)NULL)))
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$3;
    return_value___builtin_strcmp$3=__builtin_strcmp("maxBitrate", key);
    tmp_statement_expression$2 = return_value___builtin_strcmp$3;
    if(tmp_statement_expression$2 == 0)
    {
      return_value_parseSpeed$1=parseSpeed(bitrate);
      rateLimit->bitrate = (signed int)return_value_parseSpeed$1;
    }

  }

}

// shouldPrint
// file statistics.c line 47
static signed int shouldPrint(struct stats *s, struct timeval *now, signed int isFinal)
{
  signed long long int sinceLastPrint;
  if(!(isFinal == 0))
    return 1;

  else
  {
    sinceLastPrint = (now->tv_sec - s->lastPrinted.tv_sec) * (signed long int)1000000 + (now->tv_usec - s->lastPrinted.tv_usec);
    if(!(sinceLastPrint >= s->statPeriod))
      return 0;

    else
    {
      s->lastPrinted = *now;
      return 1;
    }
  }
}

// slow_addmul1
// file fec.c line 301
static void slow_addmul1(unsigned char *dst1, unsigned char *src1, unsigned char c, signed int sz)
{
  unsigned char *__gf_mulc_;
  unsigned char *dst = dst1;
  unsigned char *src = src1;
  unsigned char *lim = &dst[(signed long int)((sz - 16) + 1)];
  __gf_mulc_ = &gf_mul_table[(signed long int)((signed int)c << 8)];
  for( ; !(dst >= lim); src = src + (signed long int)16)
  {
    dst[(signed long int)0] = dst[(signed long int)0] ^ __gf_mulc_[(signed long int)src[(signed long int)0]];
    dst[(signed long int)1] = dst[(signed long int)1] ^ __gf_mulc_[(signed long int)src[(signed long int)1]];
    dst[(signed long int)2] = dst[(signed long int)2] ^ __gf_mulc_[(signed long int)src[(signed long int)2]];
    dst[(signed long int)3] = dst[(signed long int)3] ^ __gf_mulc_[(signed long int)src[(signed long int)3]];
    dst[(signed long int)4] = dst[(signed long int)4] ^ __gf_mulc_[(signed long int)src[(signed long int)4]];
    dst[(signed long int)5] = dst[(signed long int)5] ^ __gf_mulc_[(signed long int)src[(signed long int)5]];
    dst[(signed long int)6] = dst[(signed long int)6] ^ __gf_mulc_[(signed long int)src[(signed long int)6]];
    dst[(signed long int)7] = dst[(signed long int)7] ^ __gf_mulc_[(signed long int)src[(signed long int)7]];
    dst[(signed long int)8] = dst[(signed long int)8] ^ __gf_mulc_[(signed long int)src[(signed long int)8]];
    dst[(signed long int)9] = dst[(signed long int)9] ^ __gf_mulc_[(signed long int)src[(signed long int)9]];
    dst[(signed long int)10] = dst[(signed long int)10] ^ __gf_mulc_[(signed long int)src[(signed long int)10]];
    dst[(signed long int)11] = dst[(signed long int)11] ^ __gf_mulc_[(signed long int)src[(signed long int)11]];
    dst[(signed long int)12] = dst[(signed long int)12] ^ __gf_mulc_[(signed long int)src[(signed long int)12]];
    dst[(signed long int)13] = dst[(signed long int)13] ^ __gf_mulc_[(signed long int)src[(signed long int)13]];
    dst[(signed long int)14] = dst[(signed long int)14] ^ __gf_mulc_[(signed long int)src[(signed long int)14]];
    dst[(signed long int)15] = dst[(signed long int)15] ^ __gf_mulc_[(signed long int)src[(signed long int)15]];
    dst = dst + (signed long int)16;
  }
  lim = lim + (signed long int)(16 - 1);
  for( ; !(dst >= lim); src = src + 1l)
  {
    *dst = *dst ^ __gf_mulc_[(signed long int)*src];
    dst = dst + 1l;
  }
}

// slow_mul1
// file fec.c line 427
static void slow_mul1(unsigned char *dst1, unsigned char *src1, unsigned char c, signed int sz)
{
  unsigned char *__gf_mulc_;
  unsigned char *dst = dst1;
  unsigned char *src = src1;
  unsigned char *lim = &dst[(signed long int)((sz - 16) + 1)];
  __gf_mulc_ = &gf_mul_table[(signed long int)((signed int)c << 8)];
  for( ; !(dst >= lim); src = src + (signed long int)16)
  {
    dst[(signed long int)0] = __gf_mulc_[(signed long int)src[(signed long int)0]];
    dst[(signed long int)1] = __gf_mulc_[(signed long int)src[(signed long int)1]];
    dst[(signed long int)2] = __gf_mulc_[(signed long int)src[(signed long int)2]];
    dst[(signed long int)3] = __gf_mulc_[(signed long int)src[(signed long int)3]];
    dst[(signed long int)4] = __gf_mulc_[(signed long int)src[(signed long int)4]];
    dst[(signed long int)5] = __gf_mulc_[(signed long int)src[(signed long int)5]];
    dst[(signed long int)6] = __gf_mulc_[(signed long int)src[(signed long int)6]];
    dst[(signed long int)7] = __gf_mulc_[(signed long int)src[(signed long int)7]];
    dst[(signed long int)8] = __gf_mulc_[(signed long int)src[(signed long int)8]];
    dst[(signed long int)9] = __gf_mulc_[(signed long int)src[(signed long int)9]];
    dst[(signed long int)10] = __gf_mulc_[(signed long int)src[(signed long int)10]];
    dst[(signed long int)11] = __gf_mulc_[(signed long int)src[(signed long int)11]];
    dst[(signed long int)12] = __gf_mulc_[(signed long int)src[(signed long int)12]];
    dst[(signed long int)13] = __gf_mulc_[(signed long int)src[(signed long int)13]];
    dst[(signed long int)14] = __gf_mulc_[(signed long int)src[(signed long int)14]];
    dst[(signed long int)15] = __gf_mulc_[(signed long int)src[(signed long int)15]];
    dst = dst + (signed long int)16;
  }
  lim = lim + (signed long int)(16 - 1);
  for( ; !(dst >= lim); src = src + 1l)
  {
    *dst = __gf_mulc_[(signed long int)*src];
    dst = dst + 1l;
  }
}

// transmitDataBlock
// file senddata.c line 228
static signed int transmitDataBlock(struct senderState *sendst, struct slice *slice, signed int i)
{
  struct fifo *fifo = sendst->fifo;
  struct net_config *config = sendst->config;
  struct dataBlock msg;
  signed int size;
  /* assertion i < 1024 */
  assert(i < 1024);
  unsigned short int tmp_statement_expression$1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)8;
  asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression$1 = __v;
  msg.opCode = tmp_statement_expression$1;
  unsigned int return_value___bswap_32$2;
  return_value___bswap_32$2=__bswap_32$link1((unsigned int)slice->sliceNo);
  msg.sliceNo = (signed int)return_value___bswap_32$2;
  unsigned short int tmp_statement_expression$3;
  unsigned short int transmitDataBlock$$1$$2$$__v;
  unsigned short int transmitDataBlock$$1$$2$$__x = (unsigned short int)i;
  asm("rorw $8, %w0" : "=r"(transmitDataBlock$$1$$2$$__v) : "0"(transmitDataBlock$$1$$2$$__x) : "cc");
  tmp_statement_expression$3 = transmitDataBlock$$1$$2$$__v;
  msg.blockNo = tmp_statement_expression$3;
  msg.reserved = (signed short int)0;
  msg.reserved2 = (unsigned short int)0;
  unsigned int return_value___bswap_32$4;
  return_value___bswap_32$4=__bswap_32$link1((unsigned int)slice->bytes);
  msg.bytes = (signed int)return_value___bswap_32$4;
  size = slice->bytes - i * config->blockSize;
  if(!(size >= 0))
    size = 0;

  if(!(config->blockSize >= size))
    size = config->blockSize;

  sendRawData(sendst->socket, config, (char *)&msg, (signed int)sizeof(struct dataBlock) /*16ul*/ , fifo->dataBuffer + (signed long int)((unsigned int)(slice->base + i * config->blockSize) % fifo->dataBufSize), size);
  return 0;
}

// transmitFecBlock
// file senddata.c line 260
static signed int transmitFecBlock(struct senderState *sendst, struct slice *slice, signed int i)
{
  struct net_config *config = sendst->config;
  struct fecBlock msg;
  unsigned short int tmp_statement_expression$1;
  unsigned short int tmp_statement_expression$2;
  unsigned short int tmp_statement_expression$4;
  if(slice->bytes == 0)
  {
    if(!((0x0004 & config->flags) == 0))
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {
  /* assertion i < config->fec_redundancy * config->fec_stripes */

  __CPROVER_DUMP_L1:
    ;
    /* assertion i < config->fec_redundancy * config->fec_stripes */
    assert(i < config->fec_redundancy * config->fec_stripes);
    unsigned short int transmitFecBlock$$1$$1$$__v;
    unsigned short int transmitFecBlock$$1$$1$$__x = (unsigned short int)9;
    asm("rorw $8, %w0" : "=r"(transmitFecBlock$$1$$1$$__v) : "0"(transmitFecBlock$$1$$1$$__x) : "cc");
    tmp_statement_expression$1 = transmitFecBlock$$1$$1$$__v;
    msg.opCode = tmp_statement_expression$1;
    unsigned short int transmitFecBlock$$1$$2$$__v;
    unsigned short int transmitFecBlock$$1$$2$$__x = (unsigned short int)config->fec_stripes;
    asm("rorw $8, %w0" : "=r"(transmitFecBlock$$1$$2$$__v) : "0"(transmitFecBlock$$1$$2$$__x) : "cc");
    tmp_statement_expression$2 = transmitFecBlock$$1$$2$$__v;
    msg.stripes = (signed short int)tmp_statement_expression$2;
    unsigned int return_value___bswap_32$3;
    return_value___bswap_32$3=__bswap_32$link1((unsigned int)slice->sliceNo);
    msg.sliceNo = (signed int)return_value___bswap_32$3;
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)i;
    asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression$4 = __v;
    msg.blockNo = tmp_statement_expression$4;
    msg.reserved2 = (unsigned short int)0;
    unsigned int return_value___bswap_32$5;
    return_value___bswap_32$5=__bswap_32$link1((unsigned int)slice->bytes);
    msg.bytes = (signed int)return_value___bswap_32$5;
    sendRawData(sendst->socket, sendst->config, (char *)&msg, (signed int)sizeof(struct fecBlock) /*16ul*/ , slice->fec_data + (signed long int)(i * config->blockSize), config->blockSize);
    return 0;
  }
}

// udpc_addParticipant
// file participants.h line 24
signed int udpc_addParticipant(struct participantsDb *db, struct sockaddr_in *addr, signed int capabilities, unsigned int rcvbuf, signed int pointopoint)
{
  signed int i;
  i=udpc_lookupParticipant(db, addr);
  if(i >= 0)
    return i;

  else
  {
    i = 0;
    for( ; !(i >= 1024); i = i + 1)
      if(db->clientTable[(signed long int)i].used == 0)
      {
        char ipBuffer[16l];
        db->clientTable[(signed long int)i].addr = *addr;
        db->clientTable[(signed long int)i].used = 1;
        db->clientTable[(signed long int)i].capabilities = capabilities;
        db->clientTable[(signed long int)i].rcvbuf = rcvbuf;
        db->udpc_nrParticipants = db->udpc_nrParticipants + 1;
        char *return_value_udpc_getIpString$1;
        return_value_udpc_getIpString$1=udpc_getIpString(addr, ipBuffer);
        fprintf(stderr, "New connection from %s  (#%d) %08x\n", return_value_udpc_getIpString$1, i, capabilities);
        char *return_value_udpc_getIpString$2;
        return_value_udpc_getIpString$2=udpc_getIpString(addr, ipBuffer);
        syslog(6, "New connection from %s  (#%d)\n", return_value_udpc_getIpString$2, i);
        return i;
      }

      else
        if(!(pointopoint == 0))
          return -1;

    return -1;
  }
}

// udpc_allocReadStats
// file statistics.c line 73
struct receiver_stats * udpc_allocReadStats(signed int fd, signed long int statPeriod, signed int printUncompressedPos, signed int noProgress)
{
  struct receiver_stats *rs;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct receiver_stats) /*80ul*/ );
  rs = (struct receiver_stats *)return_value_calloc$1;
  initStats(&rs->s, fd, statPeriod, printUncompressedPos, noProgress);
  return rs;
}

// udpc_allocSenderStats
// file statistics.h line 26
struct sender_stats * udpc_allocSenderStats(signed int fd, struct _IO_FILE *logfile, signed long int bwPeriod, signed long int statPeriod, signed int printUncompressedPos, signed int noProgress)
{
  struct sender_stats *ss;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct sender_stats) /*104ul*/ );
  ss = (struct sender_stats *)return_value_calloc$1;
  ss->log = logfile;
  ss->bwPeriod = bwPeriod;
  gettimeofday(&ss->periodStart, ((struct timezone *)NULL));
  initStats(&ss->s, fd, statPeriod, printUncompressedPos, noProgress);
  return ss;
}

// udpc_clearIp
// file socklib.h line 173
void udpc_clearIp(struct sockaddr_in *addr)
{
  addr->sin_addr.s_addr = (unsigned int)0;
  addr->sin_family = (unsigned short int)2;
}

// udpc_closeSock
// file socklib.c line 1100
void udpc_closeSock(signed int *socks, signed int nr, signed int target)
{
  signed int i;
  signed int sock = socks[(signed long int)target];
  socks[(signed long int)target] = -1;
  i = 0;
  for( ; !(i >= nr); i = i + 1)
    if(socks[(signed long int)i] == sock)
      goto __CPROVER_DUMP_L4;

  close(sock);

__CPROVER_DUMP_L4:
  ;
}

// udpc_copyFromMessage
// file socklib.c line 1018
void udpc_copyFromMessage(struct sockaddr_in *dst, unsigned char *src)
{
  memcpy((void *)(char *)&dst->sin_addr, (const void *)src, sizeof(struct in_addr) /*4ul*/ );
}

// udpc_copyIpFrom
// file socklib.c line 1000
void udpc_copyIpFrom(struct sockaddr_in *dst, struct sockaddr_in *src)
{
  dst->sin_addr = src->sin_addr;
  dst->sin_family = src->sin_family;
}

// udpc_copyToMessage
// file socklib.c line 1012
void udpc_copyToMessage(unsigned char *dst, struct sockaddr_in *src)
{
  memcpy((void *)dst, (const void *)(char *)&((struct sockaddr_in *)src)->sin_addr, sizeof(struct in_addr) /*4ul*/ );
}

// udpc_displayReceiverStats
// file statistics.c line 153
void udpc_displayReceiverStats(struct receiver_stats *rs, signed int isFinal)
{
  signed long long int timePassed;
  struct timeval tv_now;
  _Bool tmp_if_expr$1;
  if(rs == ((struct receiver_stats *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = rs->s.noProgress != 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
  {
    gettimeofday(&tv_now, ((struct timezone *)NULL));
    signed int return_value_shouldPrint$2;
    return_value_shouldPrint$2=shouldPrint(&rs->s, &tv_now, isFinal);
    if(!(return_value_shouldPrint$2 == 0))
    {
      fprintf(stderr, "bytes=");
      udpc_printLongNum((unsigned long long int)rs->totalBytes);
      fprintf(stderr, " (");
      timePassed = tv_now.tv_sec - rs->tv_start.tv_sec;
      timePassed = timePassed * (signed long long int)1000000;
      timePassed = timePassed + (tv_now.tv_usec - rs->tv_start.tv_usec);
      if(!(timePassed == 0l))
      {
        signed int mbps = (signed int)((rs->totalBytes * (signed long int)800) / timePassed);
        fprintf(stderr, "%3d.%02d", mbps / 100, mbps % 100);
      }

      else
        fprintf(stderr, "***.**");
      fprintf(stderr, " Mbps)");
      if(!(rs->s.printUncompressedPos == 0))
        printFilePosition(rs->s.fd);

      fprintf(stderr, "\r");
      fflush(stderr);
    }

  }

}

// udpc_displaySenderStats
// file statistics.h line 32
void udpc_displaySenderStats(struct sender_stats *ss, signed int blockSize, signed int sliceSize, signed int isFinal)
{
  unsigned int blocks;
  unsigned int percent;
  struct timeval tv_now;
  _Bool tmp_if_expr$1;
  if(ss == ((struct sender_stats *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ss->s.noProgress != 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
  {
    gettimeofday(&tv_now, ((struct timezone *)NULL));
    signed int return_value_shouldPrint$2;
    return_value_shouldPrint$2=shouldPrint(&ss->s, &tv_now, isFinal);
    if(!(return_value_shouldPrint$2 == 0))
    {
      blocks = (unsigned int)(((ss->totalBytes + (unsigned long int)blockSize) - (unsigned long int)1) / (unsigned long int)blockSize);
      if(blocks == 0u)
        percent = (unsigned int)0;

      else
        percent = (unsigned int)(((unsigned long int)1000L * ss->retransmissions) / (unsigned long int)blocks);
      fprintf(stderr, "bytes=");
      udpc_printLongNum(ss->totalBytes);
      fprintf(stderr, " re-xmits=%07llu (%3u.%01u%%) slice=%04d ", ss->retransmissions, percent / (unsigned int)10, percent % (unsigned int)10, sliceSize);
      if(!(ss->s.printUncompressedPos == 0))
        printFilePosition(ss->s.fd);

      fprintf(stderr, "- %3d\r", ss->clNo);
      fflush(stderr);
    }

  }

}

// udpc_doReceive
// file socklib.c line 296
signed int udpc_doReceive(signed int s, void *message, unsigned long int len, struct sockaddr_in *from, signed int portBase)
{
  unsigned int slen;
  signed int r;
  unsigned short int port;
  char ipBuffer[16l];
  slen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  signed long int return_value_recvfrom$1;
  return_value_recvfrom$1=recvfrom(s, message, len, 0, (struct sockaddr *)from, &slen);
  r = (signed int)return_value_recvfrom$1;
  unsigned short int tmp_statement_expression$2;
  unsigned short int tmp_statement_expression$4;
  if(!(r >= 0))
    return r;

  else
  {
    unsigned short int __v;
    unsigned short int udpc_doReceive$$1$$1$$__x = (unsigned short int)from->sin_port;
    asm("rorw $8, %w0" : "=r"(__v) : "0"(udpc_doReceive$$1$$1$$__x) : "cc");
    tmp_statement_expression$2 = __v;
    port = tmp_statement_expression$2;
    if(!((signed int)port == 1 + portBase) && !((signed int)port == portBase))
    {
      char *return_value_udpc_getIpString$3;
      return_value_udpc_getIpString$3=udpc_getIpString(from, ipBuffer);
      unsigned short int udpc_doReceive$$1$$2$$1$$__v;
      unsigned short int __x = (unsigned short int)((struct sockaddr_in *)from)->sin_port;
      asm("rorw $8, %w0" : "=r"(udpc_doReceive$$1$$2$$1$$__v) : "0"(__x) : "cc");
      tmp_statement_expression$4 = udpc_doReceive$$1$$2$$1$$__v;
      udpc_flprintf("Bad message from port %s.%d\n", return_value_udpc_getIpString$3, tmp_statement_expression$4);
      return -1;
    }

    return r;
  }
}

// udpc_doSend
// file socklib.c line 288
signed int udpc_doSend(signed int s, void *message, unsigned long int len, struct sockaddr_in *to)
{
  signed long int return_value_sendto$1;
  return_value_sendto$1=sendto(s, message, len, 0, (struct sockaddr *)to, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  return (signed int)return_value_sendto$1;
}

// udpc_fatal
// file log.h line 19
signed int udpc_fatal(signed int code, const char *fmt, ...)
{
  void **ap = (void **)&fmt;
  if(!(quitting == 0))
    _exit(code);

  quitting = 1;
  printNewlineIfNeeded();
  vfprintf(stderr, fmt, ap);
  exit(code);
}

// udpc_flprintf
// file log.h line 17
signed int udpc_flprintf(const char *fmt, ...)
{
  void **ap = (void **)&fmt;
  signed int return_value_vlogprintf$1;
  if(!(udpc_log == ((struct _IO_FILE *)NULL)))
  {
    return_value_vlogprintf$1=vlogprintf(udpc_log, fmt, ap);
    return return_value_vlogprintf$1;
  }

  else
  {
    printNewlineIfNeeded();
    signed int return_value_vfprintf$2;
    return_value_vfprintf$2=vfprintf(stderr, fmt, ap);
    return return_value_vfprintf$2;
  }
}

// udpc_getBroadCastAddress
// file socklib.c line 250
signed int udpc_getBroadCastAddress(struct net_if *net_if, struct sockaddr_in *addr, signed short int port)
{
  signed int r;
  r=initSockAddress((enum addr_type_t)ADDR_TYPE_BCAST, net_if, (unsigned int)0x00000000, (unsigned short int)port, addr);
  if(addr->sin_addr.s_addr == 0u)
  {
    struct sockaddr_in ucast;
    initSockAddress((enum addr_type_t)ADDR_TYPE_UCAST, net_if, (unsigned int)0x00000000, (unsigned short int)port, &ucast);
    unsigned int return_value___bswap_32$1;
    return_value___bswap_32$1=__bswap_32(ucast.sin_addr.s_addr);
    if((0xff000000 & return_value___bswap_32$1) == 2130706432u)
      addr->sin_addr.s_addr = ucast.sin_addr.s_addr;

  }

  return r;
}

// udpc_getDefaultMcastAddress
// file socklib.c line 1005
void udpc_getDefaultMcastAddress(struct net_if *net_if, struct sockaddr_in *mcast)
{
  udpc_getMyAddress(net_if, mcast);
  unsigned int return_value___bswap_32$1;
  return_value___bswap_32$1=__bswap_32((unsigned int)0x07ffffff);
  mcast->sin_addr.s_addr = mcast->sin_addr.s_addr & return_value___bswap_32$1;
  unsigned int return_value___bswap_32$2;
  return_value___bswap_32$2=__bswap_32(0xe8000000);
  mcast->sin_addr.s_addr = mcast->sin_addr.s_addr | return_value___bswap_32$2;
}

// udpc_getIpString
// file socklib.c line 963
char * udpc_getIpString(struct sockaddr_in *addr, char *buffer)
{
  signed long int iaddr;
  unsigned int return_value___bswap_32$1;
  return_value___bswap_32$1=__bswap_32(((struct sockaddr_in *)addr)->sin_addr.s_addr);
  iaddr = (signed long int)return_value___bswap_32$1;
  sprintf(buffer, "%ld.%ld.%ld.%ld", iaddr >> 24 & (signed long int)0xff, iaddr >> 16 & (signed long int)0xff, iaddr >> 8 & (signed long int)0xff, iaddr & (signed long int)0xff);
  return buffer;
}

// udpc_getMcastAllAddress
// file socklib.c line 273
signed int udpc_getMcastAllAddress(struct sockaddr_in *addr, const char *address, signed short int port)
{
  struct in_addr ip;
  signed int ret;
  _Bool tmp_if_expr$1;
  if(address == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)address[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    safe_inet_aton("224.0.0.1", &ip);

  else
  {
    ret=safe_inet_aton(address, &ip);
    if(!(ret >= 0))
      return ret;

  }
  signed int return_value_initSockAddress$2;
  return_value_initSockAddress$2=initSockAddress((enum addr_type_t)ADDR_TYPE_MCAST, (struct net_if *)(void *)0, ip.s_addr, (unsigned short int)port, addr);
  return return_value_initSockAddress$2;
}

// udpc_getMyAddress
// file socklib.c line 245
signed int udpc_getMyAddress(struct net_if *net_if, struct sockaddr_in *addr)
{
  signed int return_value_initSockAddress$1;
  return_value_initSockAddress$1=initSockAddress((enum addr_type_t)ADDR_TYPE_UCAST, net_if, (unsigned int)0x00000000, (unsigned short int)0, addr);
  return return_value_initSockAddress$1;
}

// udpc_getNetIf
// file socklib.c line 557
struct net_if * udpc_getNetIf(const char *wanted)
{
  struct ifreq *ifrp;
  struct ifreq *ifend;
  struct ifreq *chosen;
  struct ifconf ifc;
  signed int s;
  signed int lastGoodness = 0;
  struct in_addr wantedAddress;
  signed int isAddress = 0;
  signed int wantedLen = 0;
  struct net_if *net_if;
  if(wanted == ((const char *)NULL))
    wanted=getenv("IFNAME");

  _Bool tmp_if_expr$2;
  signed int return_value_INET_ATON$1;
  if(!(wanted == ((const char *)NULL)))
  {
    return_value_INET_ATON$1=INET_ATON(wanted, &wantedAddress);
    tmp_if_expr$2 = return_value_INET_ATON$1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    isAddress = 1;

  else
    wantedAddress.s_addr = (unsigned int)0;
  unsigned long int return_value_strlen$3;
  if(!(wanted == ((const char *)NULL)))
  {
    return_value_strlen$3=strlen(wanted);
    wantedLen = (signed int)return_value_strlen$3;
  }

  void *return_value_calloc$4;
  return_value_calloc$4=calloc((unsigned long int)1, sizeof(struct net_if) /*24ul*/ );
  net_if = (struct net_if *)return_value_calloc$4;
  if(net_if == ((struct net_if *)NULL))
    udpc_fatal(1, "Out of memory error");

  s=socket(2, 2, 0);
  if(!(s >= 0))
  {
    perror("make socket");
    exit(1);
  }

  ifc.ifc_len = (signed int)(sizeof(struct ifreq) /*40ul*/  * (unsigned long int)10);
  while((_Bool)1)
  {
    signed int len = ifc.ifc_len;
    void *return_value_malloc$5;
    return_value_malloc$5=malloc((unsigned long int)ifc.ifc_len);
    ifc.ifc_ifcu.ifcu_buf = (char *)return_value_malloc$5;
    if(ifc.ifc_ifcu.ifcu_buf == ((char *)NULL))
      udpc_fatal(1, "Out of memory error");

    signed int return_value_ioctl$6;
    return_value_ioctl$6=ioctl(s, (unsigned long int)0x8912, (char *)&ifc);
    if(!(ifc.ifc_len >= (signed int)sizeof(struct ifreq) /*40*/ ) || !(return_value_ioctl$6 >= 0))
    {
      perror("udpcast: SIOCGIFCONF: ");
      exit(1);
    }

    if(len == ifc.ifc_len)
    {
      ifc.ifc_len = ifc.ifc_len + (signed int)(sizeof(struct ifreq) /*40ul*/  * (unsigned long int)10);
      free((void *)ifc.ifc_ifcu.ifcu_buf);
    }

    else
      break;
  }
  ifend = (struct ifreq *)((char *)ifc.ifc_ifcu.ifcu_buf + (signed long int)ifc.ifc_len);
  chosen = (struct ifreq *)(void *)0;
  ifrp = (struct ifreq *)ifc.ifc_ifcu.ifcu_buf;
  signed int tmp_statement_expression$9;
  _Bool tmp_if_expr$8;
  signed int return_value_strncmp$7;
  unsigned int return_value___bswap_32$20;
  signed int tmp_statement_expression$15;
  _Bool tmp_if_expr$19;
  signed int tmp_statement_expression$17;
  signed int return_value_strncmp$14;
  signed int return_value_strncmp$11;
  _Bool tmp_if_expr$13;
  signed int return_value_strncmp$12;
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  for( ; !(ifrp >= ifend); ifrp = ifrp + 1l)
  {
    unsigned long int iaddr = (unsigned long int)((struct sockaddr_in *)&ifrp->ifr_ifru.ifru_addr)->sin_addr.s_addr;
    signed int goodness;
    if((signed int)ifrp->ifr_ifru.ifru_addr.sa_family == 2)
    {
      if(!(wanted == ((const char *)NULL)))
      {
        if(iaddr == (unsigned long int)wantedAddress.s_addr && !(isAddress == 0))
          goodness = 8;

        else
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp$10;
          return_value___builtin_strcmp$10=__builtin_strcmp(wanted, ifrp->ifr_ifrn.ifrn_name);
          tmp_statement_expression$9 = return_value___builtin_strcmp$10;
          if(tmp_statement_expression$9 == 0)
            goodness = 12;

          else
          {
            if(!(wanted == ((const char *)NULL)))
            {
              return_value_strncmp$7=strncmp(wanted, ifrp->ifr_ifrn.ifrn_name, (unsigned long int)wantedLen);
              tmp_if_expr$8 = return_value_strncmp$7 == 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$8 = (_Bool)0;
            if(tmp_if_expr$8)
              goodness = 7;

            else
              goto __CPROVER_DUMP_L40;
          }
        }
      }

      else
        if(iaddr == 0ul)
          goodness = 1;

        else
        {
          return_value___bswap_32$20=__bswap_32((unsigned int)0x7f000001);
          if(iaddr == (unsigned long int)return_value___bswap_32$20)
            goodness = 2;

          else
          {
            unsigned long int udpc_getNetIf$$1$$4$$1$$2$$3$$__s1_len;
            unsigned long int udpc_getNetIf$$1$$4$$1$$2$$3$$__s2_len;
            signed int return_value___builtin_strcmp$16;
            return_value___builtin_strcmp$16=__builtin_strcmp("eth0", ifrp->ifr_ifrn.ifrn_name);
            tmp_statement_expression$15 = return_value___builtin_strcmp$16;
            if(tmp_statement_expression$15 == 0)
              tmp_if_expr$19 = (_Bool)1;

            else
            {
              unsigned long int udpc_getNetIf$$1$$4$$1$$2$$4$$__s1_len;
              unsigned long int udpc_getNetIf$$1$$4$$1$$2$$4$$__s2_len;
              signed int return_value___builtin_strcmp$18;
              return_value___builtin_strcmp$18=__builtin_strcmp("en0", ifrp->ifr_ifrn.ifrn_name);
              tmp_statement_expression$17 = return_value___builtin_strcmp$18;
              tmp_if_expr$19 = tmp_statement_expression$17 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$19)
              goodness = 6;

            else
            {
              return_value_strncmp$14=strncmp("eth0:", ifrp->ifr_ifrn.ifrn_name, (unsigned long int)5);
              if(return_value_strncmp$14 == 0)
                goodness = 5;

              else
              {
                return_value_strncmp$11=strncmp("eth", ifrp->ifr_ifrn.ifrn_name, (unsigned long int)3);
                if(return_value_strncmp$11 == 0)
                  tmp_if_expr$13 = (_Bool)1;

                else
                {
                  return_value_strncmp$12=strncmp("en", ifrp->ifr_ifrn.ifrn_name, (unsigned long int)2);
                  tmp_if_expr$13 = return_value_strncmp$12 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$13)
                  goodness = 4;

                else
                  goodness = 3;
              }
            }
          }
        }
      signed int return_value_hasLink$21;
      return_value_hasLink$21=hasLink(s, ifrp->ifr_ifrn.ifrn_name);
      if(!(return_value_hasLink$21 == 0))
        goodness = goodness + 3;

      goodness = goodness * 2;
      if(goodness >= lastGoodness)
      {
        signed int return_value_ioctl$24;
        return_value_ioctl$24=ioctl(s, (unsigned long int)0x8919, ifrp);
        if(!(return_value_ioctl$24 >= 0))
        {
          return_value___errno_location$22=__errno_location();
          return_value_strerror$23=strerror(*return_value___errno_location$22);
          udpc_fatal(-1, "Error getting broadcast address for %s: %s", (const void *)ifrp->ifr_ifrn.ifrn_name, return_value_strerror$23);
        }

        if(!(((struct sockaddr_in *)&ifrp->ifr_ifru.ifru_broadaddr)->sin_addr.s_addr == 0u))
          goodness = goodness + 1;

      }

      if(!(lastGoodness >= goodness))
      {
        chosen = ifrp;
        lastGoodness = goodness;
        net_if->addr.s_addr = (unsigned int)iaddr;
      }

    }


  __CPROVER_DUMP_L40:
    ;
  }
  if(chosen == ((struct ifreq *)NULL))
  {
    fprintf(stderr, "No suitable network interface found\n");
    fprintf(stderr, "The following interfaces are available:\n");
    ifrp = (struct ifreq *)ifc.ifc_ifcu.ifcu_buf;
    for( ; !(ifrp >= ifend); ifrp = ifrp + 1l)
    {
      char buffer[16l];
      if((signed int)ifrp->ifr_ifru.ifru_addr.sa_family == 2)
      {
        char *return_value_udpc_getIpString$25;
        return_value_udpc_getIpString$25=udpc_getIpString((struct sockaddr_in *)&ifrp->ifr_ifru.ifru_addr, buffer);
        fprintf(stderr, "\t%s\t%s\n", (const void *)ifrp->ifr_ifrn.ifrn_name, return_value_udpc_getIpString$25);
      }

    }
    exit(1);
  }

  char *return_value___strdup$26;
  return_value___strdup$26=__strdup(chosen->ifr_ifrn.ifrn_name);
  net_if->name = return_value___strdup$26;
  signed int return_value_ioctl$29;
  return_value_ioctl$29=ioctl(s, (unsigned long int)0x8933, chosen);
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  if(!(return_value_ioctl$29 >= 0))
  {
    return_value___errno_location$27=__errno_location();
    return_value_strerror$28=strerror(*return_value___errno_location$27);
    udpc_fatal(-1, "Error getting index for %s: %s", net_if->name, return_value_strerror$28);
  }

  net_if->index = chosen->ifr_ifru.ifru_ivalue;
  signed int return_value_ioctl$32;
  return_value_ioctl$32=ioctl(s, (unsigned long int)0x8919, chosen);
  signed int *return_value___errno_location$30;
  char *return_value_strerror$31;
  if(!(return_value_ioctl$32 >= 0))
  {
    return_value___errno_location$30=__errno_location();
    return_value_strerror$31=strerror(*return_value___errno_location$30);
    udpc_fatal(-1, "Error getting broadcast address for %s: %s", net_if->name, return_value_strerror$31);
  }

  net_if->bcast = ((struct sockaddr_in *)&chosen->ifr_ifru.ifru_broadaddr)->sin_addr;
  close(s);
  free((void *)ifc.ifc_ifcu.ifcu_buf);
  return net_if;
}

// udpc_getParticipantCapabilities
// file participants.h line 30
signed int udpc_getParticipantCapabilities(struct participantsDb *db, signed int i)
{
  return db->clientTable[(signed long int)i].capabilities;
}

// udpc_getParticipantIp
// file participants.h line 32
struct sockaddr_in * udpc_getParticipantIp(struct participantsDb *db, signed int i)
{
  return &db->clientTable[(signed long int)i].addr;
}

// udpc_getParticipantRcvBuf
// file participants.h line 31
unsigned int udpc_getParticipantRcvBuf(struct participantsDb *db, signed int i)
{
  return db->clientTable[(signed long int)i].rcvbuf;
}

// udpc_getPort
// file socklib.c line 981
unsigned short int udpc_getPort(struct sockaddr_in *addr)
{
  unsigned short int tmp_statement_expression$1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)((struct sockaddr_in *)addr)->sin_port;
  asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression$1 = __v;
  return tmp_statement_expression$1;
}

// udpc_getRcvBuf
// file socklib.c line 334
unsigned int udpc_getRcvBuf(signed int sock)
{
  unsigned int bufsize;
  unsigned int len = (unsigned int)sizeof(signed int) /*4ul*/ ;
  signed int return_value_getsockopt$1;
  return_value_getsockopt$1=getsockopt(sock, 1, 8, (void *)(char *)&bufsize, &len);
  if(!(return_value_getsockopt$1 >= 0))
    return (unsigned int)-1;

  else
    return bufsize;
}

// udpc_getSelectedSock
// file socklib.c line 1089
signed int udpc_getSelectedSock(signed int *socks, signed int nr, struct anonymous$4 *read_set)
{
  signed int i = 0;
  for( ; !(i >= nr); i = i + 1)
    if(!(socks[(signed long int)i] == -1))
    {
      if(!((read_set->__fds_bits[(signed long int)(socks[(signed long int)i] / 8)] & (signed long int)(1UL << socks[(signed long int)i] % 8)) == 0l))
        return socks[(signed long int)i];

    }

  return -1;
}

// udpc_getSendBuf
// file socklib.c line 321
signed int udpc_getSendBuf(signed int sock)
{
  signed int bufsize;
  unsigned int len = (unsigned int)sizeof(signed int) /*4ul*/ ;
  signed int return_value_getsockopt$1;
  return_value_getsockopt$1=getsockopt(sock, 1, 7, (void *)(char *)&bufsize, &len);
  if(!(return_value_getsockopt$1 >= 0))
    return -1;

  else
    return bufsize;
}

// udpc_initFifo
// file fifo.h line 20
void udpc_initFifo(struct fifo *fifo, signed int blockSize)
{
  fifo->dataBufSize = (unsigned int)(blockSize * 4096);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(fifo->dataBufSize + (unsigned int)4096));
  fifo->dataBuffer = (unsigned char *)return_value_malloc$1;
  fifo->dataBuffer = fifo->dataBuffer + (signed long int)((unsigned long int)4096 - (unsigned long int)fifo->dataBuffer % (unsigned long int)4096);
  fifo->freeMemQueue=pc_makeProduconsum((signed int)fifo->dataBufSize, "free mem");
  pc_produce(fifo->freeMemQueue, fifo->dataBufSize);
  fifo->data=pc_makeProduconsum((signed int)fifo->dataBufSize, "receive");
}

// udpc_ipIsEqual
// file socklib.c line 973
signed int udpc_ipIsEqual(struct sockaddr_in *left, struct sockaddr_in *right)
{
  return (signed int)(((struct sockaddr_in *)left)->sin_addr.s_addr == ((struct sockaddr_in *)right)->sin_addr.s_addr);
}

// udpc_ipIsZero
// file socklib.h line 171
signed int udpc_ipIsZero(struct sockaddr_in *ip)
{
  return (signed int)(((struct sockaddr_in *)ip)->sin_addr.s_addr == (unsigned int)0);
}

// udpc_isAddressEqual
// file socklib.c line 1022
signed int udpc_isAddressEqual(struct sockaddr_in *a, struct sockaddr_in *b)
{
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp((const void *)(char *)a, (const void *)(char *)b, (unsigned long int)8);
  return (signed int)!(return_value_memcmp$1 != 0);
}

// udpc_isFullDuplex
// file socklib.c line 523
signed int udpc_isFullDuplex(signed int s, const char *ifname)
{
  struct ifreq ifr;
  struct ethtool_cmd ecmd;
  ecmd.cmd = (unsigned int)0x00000001;
  __builtin_strncpy(ifr.ifr_ifrn.ifrn_name, ifname, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
  ifr.ifr_ifru.ifru_data = (char *)&ecmd;
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(s, (unsigned long int)0x8946, &ifr);
  if(return_value_ioctl$1 == -1)
    return -1;

  else
    return (signed int)ecmd.duplex;
}

// udpc_isParticipantValid
// file participants.h line 20
signed int udpc_isParticipantValid(struct participantsDb *db, signed int i)
{
  return db->clientTable[(signed long int)i].used;
}

// udpc_localReader
// file sender-diskio.c line 78
signed int udpc_localReader(struct fifo *fifo, signed int in)
{
  while((_Bool)1)
  {
    signed int pos;
    unsigned int return_value_pc_getConsumerPosition$1;
    return_value_pc_getConsumerPosition$1=pc_getConsumerPosition(fifo->freeMemQueue);
    pos = (signed int)return_value_pc_getConsumerPosition$1;
    signed int bytes;
    bytes=pc_consumeContiguousMinAmount(fifo->freeMemQueue, 4096);
    if(!((bytes + pos) % 4096 >= bytes))
      bytes = bytes - (pos + bytes) % 4096;

    if(bytes == 0)
      break;

    signed long int return_value_read$2;
    return_value_read$2=read(in, (void *)(fifo->dataBuffer + (signed long int)pos), (unsigned long int)bytes);
    bytes = (signed int)return_value_read$2;
    if(!(bytes >= 0))
    {
      perror("read");
      exit(1);
    }

    if(bytes == 0)
    {
      pc_produceEnd(fifo->data);
      break;
    }

    else
    {
      pc_consumed(fifo->freeMemQueue, bytes);
      pc_produce(fifo->data, (unsigned int)bytes);
    }
  }
  return 0;
}

// udpc_logprintf
// file log.h line 15
signed int udpc_logprintf(struct _IO_FILE *logfile, const char *fmt, ...)
{
  void **ap = (void **)&fmt;
  signed int return_value_vlogprintf$1;
  return_value_vlogprintf$1=vlogprintf(logfile, fmt, ap);
  return return_value_vlogprintf$1;
}

// udpc_lookupParticipant
// file participants.h line 22
signed int udpc_lookupParticipant(struct participantsDb *db, struct sockaddr_in *addr)
{
  signed int i = 0;
  signed int return_value_udpc_ipIsEqual$1;
  for( ; !(i >= 1024); i = i + 1)
    if(!(db->clientTable[(signed long int)i].used == 0))
    {
      return_value_udpc_ipIsEqual$1=udpc_ipIsEqual(&db->clientTable[(signed long int)i].addr, addr);
      if(!(return_value_udpc_ipIsEqual$1 == 0))
        return i;

    }

  return -1;
}

// udpc_makeParticipantsDb
// file participants.h line 29
struct participantsDb * udpc_makeParticipantsDb(void)
{
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct participantsDb) /*28676ul*/ );
  return (struct participantsDb *)return_value_calloc$1;
}

// udpc_makeSockAddr
// file socklib.c line 174
signed int udpc_makeSockAddr(char *hostname, signed short int port, struct sockaddr_in *addr)
{
  struct hostent *host;
  memset((void *)(char *)addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(hostname == ((char *)NULL)))
  {
    if(!(*hostname == 0))
    {
      char *inaddr;
      signed int len;
      host=gethostbyname(hostname);
      if(host == ((struct hostent *)NULL))
        udpc_fatal(1, "Unknown host %s\n", hostname);

      inaddr = host->h_addr_list[(signed long int)0];
      len = host->h_length;
      memcpy((void *)&((struct sockaddr_in *)addr)->sin_addr, (const void *)inaddr, (unsigned long int)len);
    }

  }

  ((struct sockaddr_in *)addr)->sin_family = (unsigned short int)2;
  unsigned short int tmp_statement_expression$1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)port;
  asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression$1 = __v;
  ((struct sockaddr_in *)addr)->sin_port = tmp_statement_expression$1;
  return 0;
}

// udpc_makeSocket
// file socklib.c line 899
signed int udpc_makeSocket(enum addr_type_t addr_type, struct net_if *net_if, struct sockaddr_in *tmpl, signed int port)
{
  signed int ret;
  signed int s;
  struct sockaddr_in myaddr;
  unsigned int ip = (unsigned int)0;
  s=socket(2, 2, 0);
  if(!(s >= 0))
  {
    perror("make socket");
    exit(1);
  }

  if((signed int)addr_type == ADDR_TYPE_MCAST && !(tmpl == ((struct sockaddr_in *)NULL)))
    ip = tmpl->sin_addr.s_addr;

  ret=initSockAddress(addr_type, net_if, ip, (unsigned short int)port, &myaddr);
  if(!(ret >= 0))
    udpc_fatal(1, "Could not get socket address fot %d/%s", addr_type, net_if->name);

  if(myaddr.sin_addr.s_addr == 0u && (signed int)addr_type == ADDR_TYPE_BCAST)
  {
    close(s);
    return -1;
  }

  else
  {
    ret=bind(s, (struct sockaddr *)&myaddr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(ret >= 0))
    {
      char buffer[16l];
      char *return_value_udpc_getIpString$1;
      return_value_udpc_getIpString$1=udpc_getIpString(&myaddr, buffer);
      unsigned short int return_value_udpc_getPort$2;
      return_value_udpc_getPort$2=udpc_getPort(&myaddr);
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      udpc_fatal(1, "bind socket to %s:%d (%s)\n", return_value_udpc_getIpString$1, return_value_udpc_getPort$2, return_value_strerror$4);
    }

    if((signed int)addr_type == ADDR_TYPE_MCAST)
      mcastListen(s, net_if, &myaddr);

    return s;
  }
}

// udpc_nrParticipants
// file participants.h line 23
signed int udpc_nrParticipants(struct participantsDb *db)
{
  return db->udpc_nrParticipants;
}

// udpc_openFile
// file sender-diskio.c line 24
signed int udpc_openFile(struct disk_config *config)
{
  if(!(config->fileName == ((const char *)NULL)))
  {
    signed int in;
    in=open(config->fileName, 00 | 0, 0);
    if(!(in >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      udpc_fatal(1, "Could not open file %s: %s\n", config->fileName, return_value_strerror$2);
    }

    return in;
  }

  else
    return 0;
}

// udpc_openMainSenderSock
// file udp-sender.h line 34
signed int udpc_openMainSenderSock(struct net_config *net_config, const char *ifName)
{
  net_config->net_if=udpc_getNetIf(ifName);
  signed int return_value_udpc_makeSocket$1;
  return_value_udpc_makeSocket$1=udpc_makeSocket((enum addr_type_t)ADDR_TYPE_UCAST, net_config->net_if, (struct sockaddr_in *)(void *)0, net_config->portBase + 1);
  return return_value_udpc_makeSocket$1;
}

// udpc_parseCommand
// file udpcast.c line 7
signed int udpc_parseCommand(char *pipeName, char **arg)
{
  char *ptr;
  signed int i;
  signed int haveSpace = 1;
  i = 0;
  ptr = pipeName;
  signed int tmp_post$1;
  for( ; !(*ptr == 0); ptr = ptr + 1l)
  {
    if((signed int)*ptr == 32)
    {
      haveSpace = 1;
      *ptr = (char)0;
    }

    else
      if(!(haveSpace == 0))
      {
        tmp_post$1 = i;
        i = i + 1;
        arg[(signed long int)tmp_post$1] = ptr;
        haveSpace = 0;
      }

    if(i == 256)
      udpc_fatal(1, "Too many arguments for pipe command\n");

  }
  arg[(signed long int)i] = ((char *)NULL);
  return 0;
}

// udpc_parseSize
// file socklib.h line 185
unsigned long int udpc_parseSize(char *sizeString)
{
  char *eptr;
  unsigned long int size;
  size=strtoul(sizeString, &eptr, 10);
  if(!(eptr == ((char *)NULL)))
  {
    if(!(*eptr == 0))
      switch((signed int)*eptr)
      {
        case 109:

        case 77:
        {
          size = size * (unsigned long int)(1024 * 1024);
          break;
        }
        case 107:

        case 75:
        {
          size = size * (unsigned long int)1024;
          break;
        }
        case 0:
          break;
        default:
          udpc_fatal(1, "Unit %c unsupported\n", *eptr);
      }

  }

  return size;
}

// udpc_prepareConsole
// file console.h line 20
struct console_t * udpc_prepareConsole(signed int fd)
{
  struct termios newtio;
  signed int needClose = 0;
  struct console_t *c;
  if(!(fd >= 0))
  {
    fd=open("/dev/tty", 02);
    if(!(fd >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      fprintf(stderr, "Could not open keyboard: %s\n", return_value_strerror$2);
      return (struct console_t *)(void *)0;
    }

    needClose = 1;
  }

  void *return_value_calloc$3;
  return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct console_t) /*72ul*/ );
  c = (struct console_t *)return_value_calloc$3;
  if(c == ((struct console_t *)NULL))
    return c;

  else
  {
    c->fd = fd;
    c->needClose = needClose;
    c->needRestore = 0;
    signed int return_value_tcgetattr$5;
    return_value_tcgetattr$5=tcgetattr(c->fd, &c->oldtio);
    if(return_value_tcgetattr$5 >= 0)
    {
      newtio = c->oldtio;
      newtio.c_lflag = newtio.c_lflag & (unsigned int)~0000010;
      newtio.c_lflag = newtio.c_lflag & (unsigned int)~0000002;
      newtio.c_cc[(signed long int)6] = (unsigned char)1;
      newtio.c_cc[(signed long int)5] = (unsigned char)0;
      signed int return_value_tcsetattr$4;
      return_value_tcsetattr$4=tcsetattr(c->fd, 2, &newtio);
      if(!(return_value_tcsetattr$4 >= 0))
        perror("Set terminal to raw");

      else
        c->needRestore = 1;
    }

    return c;
  }
}

// udpc_prepareForSelect
// file socklib.c line 1074
signed int udpc_prepareForSelect(signed int *socks, signed int nr, struct anonymous$4 *read_set)
{
  signed int i;
  signed int maxFd;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$4) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&read_set->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  maxFd = -1;
  i = 0;
  for( ; !(i >= nr); i = i + 1)
    if(!(socks[(signed long int)i] == -1))
    {
      read_set->__fds_bits[(signed long int)(socks[(signed long int)i] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = read_set->__fds_bits[(signed long int)(socks[(signed long int)i] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << socks[(signed long int)i] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      if(!(maxFd >= socks[(signed long int)i]))
        maxFd = socks[(signed long int)i];

    }

  return maxFd;
}

// udpc_printLongNum
// file log.c line 96
signed int udpc_printLongNum(unsigned long long int x)
{
  signed long long int divisor;
  signed long long int minDivisor;
  signed int nonzero;
  char suffix = (char)32;
  if(x >= 1000000000001ul)
  {
    minDivisor = 1048576L;
    suffix = (char)77;
  }

  else
    if(x >= 1000000000ul)
    {
      minDivisor = 1024L;
      suffix = (char)75;
    }

    else
    {
      minDivisor = (signed long long int)1;
      suffix = (char)32;
    }
  divisor = minDivisor * 1000000LL;
  nonzero = 0;
  while(divisor >= minDivisor)
  {
    signed int digits;
    const char *format;
    digits = (signed int)((x / (unsigned long int)divisor) % (unsigned long int)1000);
    if(!(nonzero == 0))
      format = "%03d";

    else
      format = "%3d";
    if(!(digits == 0) || !(nonzero == 0))
      fprintf(stderr, format, digits);

    else
      fprintf(stderr, "    ");
    if(!(digits == 0))
      nonzero = 1;

    divisor = divisor / (signed long int)1000;
    if(divisor >= minDivisor)
      fprintf(stderr, " ");

    else
      fprintf(stderr, "%c", suffix);
  }
  needNewline = 1;
  return 0;
}

// udpc_printMyIp
// file socklib.c line 954
void udpc_printMyIp(struct net_if *net_if)
{
  char buffer[16l];
  struct sockaddr_in myaddr;
  udpc_getMyAddress(net_if, &myaddr);
  char *return_value_udpc_getIpString$1;
  return_value_udpc_getIpString$1=udpc_getIpString(&myaddr, buffer);
  udpc_flprintf("%s", return_value_udpc_getIpString$1);
}

// udpc_printNotSet
// file participants.h line 33
void udpc_printNotSet(struct participantsDb *db, char *d)
{
  signed int first = 1;
  signed int i;
  udpc_flprintf("[");
  i = 0;
  for( ; !(i >= 1024); i = i + 1)
    if(!(db->clientTable[(signed long int)i].used == 0))
    {
      if((1 << (unsigned long int)i % sizeof(char) * 8 /*8ul*/  & (signed int)d[(signed long int)((unsigned long int)i / sizeof(char) * 8 /*8ul*/ )]) == 0)
      {
        if(first == 0)
          udpc_flprintf(",");

        first = 0;
        udpc_flprintf("%d", i);
      }

    }

  udpc_flprintf("]");
}

// udpc_printSet
// file participants.c line 133
void udpc_printSet(struct participantsDb *db, char *d)
{
  signed int first = 1;
  signed int i;
  udpc_flprintf("[");
  i = 0;
  for( ; !(i >= 1024); i = i + 1)
    if(!(db->clientTable[(signed long int)i].used == 0))
    {
      if(!((1 << (unsigned long int)i % sizeof(char) * 8 /*8ul*/  & (signed int)d[(signed long int)((unsigned long int)i / sizeof(char) * 8 /*8ul*/ )]) == 0))
      {
        if(first == 0)
          udpc_flprintf(",");

        first = 0;
        udpc_flprintf("%d", i);
      }

    }

  udpc_flprintf("]");
}

// udpc_receiverStatsAddBytes
// file statistics.c line 82
void udpc_receiverStatsAddBytes(struct receiver_stats *rs, signed long int bytes)
{
  if(!(rs == ((struct receiver_stats *)NULL)))
    rs->totalBytes = rs->totalBytes + bytes;

}

// udpc_receiverStatsStartTimer
// file statistics.c line 87
void udpc_receiverStatsStartTimer(struct receiver_stats *rs)
{
  if(!(rs == ((struct receiver_stats *)NULL)))
  {
    if(rs->timerStarted == 0)
    {
      gettimeofday(&rs->tv_start, ((struct timezone *)NULL));
      rs->timerStarted = 1;
    }

  }

}

// udpc_removeParticipant
// file participants.h line 21
signed int udpc_removeParticipant(struct participantsDb *db, signed int i)
{
  if(!(db->clientTable[(signed long int)i].used == 0))
  {
    char ipBuffer[16l];
    char *return_value_udpc_getIpString$1;
    return_value_udpc_getIpString$1=udpc_getIpString(&db->clientTable[(signed long int)i].addr, ipBuffer);
    udpc_flprintf("Disconnecting #%d (%s)\n", i, return_value_udpc_getIpString$1);
    char *return_value_udpc_getIpString$2;
    return_value_udpc_getIpString$2=udpc_getIpString(&db->clientTable[(signed long int)i].addr, ipBuffer);
    syslog(6, "Disconnecting #%d (%s)\n", i, return_value_udpc_getIpString$2);
    db->clientTable[(signed long int)i].used = 0;
    db->udpc_nrParticipants = db->udpc_nrParticipants - 1;
  }

  return 0;
}

// udpc_restoreConsole
// file console.h line 34
void udpc_restoreConsole(struct console_t **cp, signed int doConsume)
{
  struct console_t *c = *cp;
  signed int ch = 0;
  signed int r;
  signed int return_value_tcsetattr$2;
  if(!(c == ((struct console_t *)NULL)))
  {
    if(!(doConsume == 0))
    {
      signed long int return_value_read$1;
      return_value_read$1=read(c->fd, (void *)&ch, (unsigned long int)1);
      r = (signed int)return_value_read$1;
    }

    if(!(c->needRestore == 0))
    {
      return_value_tcsetattr$2=tcsetattr(c->fd, 2, &c->oldtio);
      if(!(return_value_tcsetattr$2 >= 0))
        perror("Restore terminal settings");

    }

    *cp = (struct console_t *)(void *)0;
    if(!(c->needClose == 0))
      close(c->fd);

    free((void *)c);
    if(ch == 113)
      exit(1);

  }

}

// udpc_selectSock
// file socklib.c line 1055
signed int udpc_selectSock(signed int *socks, signed int nr, signed int startTimeout)
{
  struct anonymous$4 read_set;
  signed int r;
  signed int maxFd;
  struct timeval tv;
  struct timeval *tvp;
  if(!(startTimeout == 0))
  {
    tv.tv_sec = (signed long int)startTimeout;
    tv.tv_usec = (signed long int)0;
    tvp = &tv;
  }

  else
    tvp = (struct timeval *)(void *)0;
  maxFd=udpc_prepareForSelect(socks, nr, &read_set);
  r=select(maxFd + 1, &read_set, (struct anonymous$4 *)(void *)0, (struct anonymous$4 *)(void *)0, tvp);
  if(!(r >= 0))
    return r;

  else
  {
    signed int return_value_udpc_getSelectedSock$1;
    return_value_udpc_getSelectedSock$1=udpc_getSelectedSock(socks, nr, &read_set);
    return return_value_udpc_getSelectedSock$1;
  }
}

// udpc_sendHello
// file udp-sender.h line 32
void udpc_sendHello(struct net_config *net_config, signed int sock, signed int streaming)
{
  struct hello hello;
  unsigned short int tmp_statement_expression$1;
  unsigned short int tmp_statement_expression$2;
  if(!(streaming == 0))
  {
    unsigned short int __v;
    unsigned short int udpc_sendHello$$1$$1$$__x = (unsigned short int)11;
    asm("rorw $8, %w0" : "=r"(__v) : "0"(udpc_sendHello$$1$$1$$__x) : "cc");
    tmp_statement_expression$1 = __v;
    hello.opCode = tmp_statement_expression$1;
  }

  else
  {
    unsigned short int udpc_sendHello$$1$$2$$__v;
    unsigned short int udpc_sendHello$$1$$2$$__x = (unsigned short int)0x0500;
    asm("rorw $8, %w0" : "=r"(udpc_sendHello$$1$$2$$__v) : "0"(udpc_sendHello$$1$$2$$__x) : "cc");
    tmp_statement_expression$2 = udpc_sendHello$$1$$2$$__v;
    hello.opCode = tmp_statement_expression$2;
  }
  hello.reserved = (signed short int)0;
  unsigned int return_value___bswap_32$3;
  return_value___bswap_32$3=__bswap_32$link2((unsigned int)net_config->capabilities);
  hello.capabilities = (signed int)return_value___bswap_32$3;
  udpc_copyToMessage(hello.mcastAddr, &net_config->dataMcastAddr);
  unsigned short int tmp_statement_expression$4;
  unsigned short int udpc_sendHello$$1$$3$$__v;
  unsigned short int __x = (unsigned short int)net_config->blockSize;
  asm("rorw $8, %w0" : "=r"(udpc_sendHello$$1$$3$$__v) : "0"(__x) : "cc");
  tmp_statement_expression$4 = udpc_sendHello$$1$$3$$__v;
  hello.blockSize = (signed short int)tmp_statement_expression$4;
  rgWaitAll(net_config, sock, net_config->controlMcastAddr.sin_addr.s_addr, (signed int)sizeof(struct hello) /*28ul*/ );
  udpc_doSend(sock, (void *)&hello, sizeof(struct hello) /*28ul*/ , &net_config->controlMcastAddr);
}

// udpc_senderSetAnswered
// file statistics.h line 34
void udpc_senderSetAnswered(struct sender_stats *ss, signed int clNo)
{
  if(!(ss == ((struct sender_stats *)NULL)))
    ss->clNo = clNo;

}

// udpc_senderStatsAddBytes
// file statistics.h line 29
void udpc_senderStatsAddBytes(struct sender_stats *ss, signed long int bytes)
{
  if(!(ss == ((struct sender_stats *)NULL)))
  {
    ss->totalBytes = ss->totalBytes + (unsigned long long int)bytes;
    if(!(ss->bwPeriod == 0l))
    {
      double tdiff;
      double bw;
      struct timeval tv;
      gettimeofday(&tv, ((struct timezone *)NULL));
      ss->periodBytes = ss->periodBytes + (unsigned long int)bytes;
      if(tv.tv_sec + -ss->periodStart.tv_sec >= -1l + ss->bwPeriod)
      {
        tdiff = ((double)(tv.tv_sec - ss->periodStart.tv_sec) * 1000000.0 + (double)tv.tv_usec) - (double)ss->periodStart.tv_usec;
        if(!(tdiff < (double)ss->bwPeriod * 1000000.0))
        {
          bw = ((double)ss->periodBytes * 8.0) / tdiff;
          ss->periodBytes = (unsigned long int)0;
          ss->periodStart = tv;
          udpc_logprintf(ss->log, "Inst BW=%f\n", bw);
          fflush(ss->log);
        }

      }

    }

  }

}

// udpc_senderStatsAddRetransmissions
// file statistics.h line 30
void udpc_senderStatsAddRetransmissions(struct sender_stats *ss, signed int retransmissions)
{
  if(!(ss == ((struct sender_stats *)NULL)))
  {
    ss->retransmissions = ss->retransmissions + (unsigned long long int)retransmissions;
    udpc_logprintf(ss->log, "RETX %9lld %4d\n", ss->retransmissions, retransmissions);
  }

}

// udpc_setIpFromString
// file socklib.h line 174
void udpc_setIpFromString(struct sockaddr_in *addr, char *ip)
{
  safe_inet_aton(ip, &addr->sin_addr);
  addr->sin_family = (unsigned short int)2;
}

// udpc_setMcastDestination
// file socklib.c line 424
signed int udpc_setMcastDestination(signed int sock, struct net_if *net_if, struct sockaddr_in *addr)
{
  signed int return_value_mcastOp$1;
  return_value_mcastOp$1=mcastOp(sock, net_if, ((struct sockaddr_in *)addr)->sin_addr, 32, "Set multicast send interface");
  return return_value_mcastOp$1;
}

// udpc_setPort
// file socklib.c line 985
void udpc_setPort(struct sockaddr_in *addr, unsigned short int port)
{
  unsigned short int tmp_statement_expression$1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)port;
  asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression$1 = __v;
  ((struct sockaddr_in *)addr)->sin_port = tmp_statement_expression$1;
}

// udpc_setRcvBuf
// file socklib.c line 342
void udpc_setRcvBuf(signed int sock, unsigned int bufsize)
{
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(sock, 1, 8, (const void *)(char *)&bufsize, (unsigned int)sizeof(unsigned int) /*4ul*/ );
  if(!(return_value_setsockopt$1 >= 0))
    perror("Set receiver buffer");

}

// udpc_setSendBuf
// file socklib.c line 329
void udpc_setSendBuf(signed int sock, unsigned int bufsize)
{
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(sock, 1, 7, (const void *)(char *)&bufsize, (unsigned int)sizeof(unsigned int) /*4ul*/ );
  if(!(return_value_setsockopt$1 >= 0))
    perror("Set send buffer");

}

// udpc_setSocketToBroadcast
// file socklib.c line 348
signed int udpc_setSocketToBroadcast(signed int sock)
{
  signed int p = 1;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(sock, 1, 6, (const void *)(char *)&p, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt$1;
}

// udpc_setTtl
// file socklib.c line 354
signed int udpc_setTtl(signed int sock, signed int ttl)
{
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(sock, 0, 33, (const void *)(char *)&ttl, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt$1;
}

// udpc_shouldPrintUncompressedPos
// file udpcast.h line 125
signed int udpc_shouldPrintUncompressedPos(signed int deflt, signed int fd, signed int ref)
{
  if(!(deflt == -1))
    return deflt;

  else
    if(ref == fd)
      return 0;

    else
    {
      signed long int offset;
      offset=lseek64(fd, (signed long int)0, 1);
      if(!(offset == -1l))
        return 1;

      else
        return 0;
    }
}

// udpc_spawnNetSender
// file senddata.c line 1019
signed int udpc_spawnNetSender(struct fifo *fifo, signed int sock, struct net_config *config, struct participantsDb *db, struct sender_stats *stats)
{
  signed int i;
  struct senderState *sendst;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct senderState) /*38144ul*/ );
  sendst = (struct senderState *)return_value_calloc$1;
  sendst->fifo = fifo;
  sendst->socket = sock;
  sendst->config = config;
  sendst->stats = stats;
  void *return_value_malloc$2;
  if(!((0x0010 & sendst->config->flags) == 0))
  {
    return_value_malloc$2=malloc((unsigned long int)(2 * config->fec_stripes * config->fec_redundancy * config->blockSize));
    sendst->fec_data = (unsigned char *)return_value_malloc$2;
  }

  sendst->rc.participantsDb = db;
  initReturnChannel(&sendst->rc, sendst->config, sendst->socket);
  sendst->free_slices_pc=pc_makeProduconsum(2, "free slices");
  pc_produce(sendst->free_slices_pc, (unsigned int)2);
  i = 0;
  for( ; !(i >= 2); i = i + 1)
    sendst->slices[(signed long int)i].state = (volatile enum anonymous$10)SLICE_FREE;
  if(!((0x0010 & sendst->config->flags) == 0))
  {
    fec_init();
    sendst->fec_data_pc=pc_makeProduconsum(2, "fec data");
    pthread_create(&sendst->fec_thread, (const union pthread_attr_t *)(void *)0, fecMain, (void *)sendst);
  }

  pthread_create(&fifo->thread, (const union pthread_attr_t *)(void *)0, netSenderMain, (void *)sendst);
  return 0;
}

// udpc_startSender
// file udp-sender.h line 37
signed int udpc_startSender(struct disk_config *disk_config, struct net_config *net_config, struct stat_config *stat_config, signed int mainSock)
{
  char ipBuffer[16l];
  signed int tries;
  signed int r;
  signed int j;
  signed long int firstConnected = (signed long int)0;
  signed long int *firstConnectedP;
  struct console_t *console = (struct console_t *)(void *)0;
  struct participantsDb *db;
  signed int sock[3l];
  signed int nr = 0;
  signed int fd;
  struct anonymous$3 sig;
  struct anonymous$3 oldsig;
  signed int shouldRestoreSig;
  signed int tmp_post$1 = nr;
  nr = nr + 1;
  sock[(signed long int)tmp_post$1] = mainSock;
  if((3 & net_config->flags) == 0)
  {
    signed int return_value_udpc_isFullDuplex$2;
    return_value_udpc_isFullDuplex$2=udpc_isFullDuplex(sock[(signed long int)0], net_config->net_if->name);
    if(return_value_udpc_isFullDuplex$2 == 1)
    {
      fprintf(stderr, "Using full duplex mode\n");
      net_config->flags = net_config->flags | 0x0001;
    }

  }

  fd=udpc_makeSocket((enum addr_type_t)ADDR_TYPE_BCAST, net_config->net_if, (struct sockaddr_in *)(void *)0, net_config->portBase + 1);
  signed int tmp_post$3;
  if(fd >= 0)
  {
    tmp_post$3 = nr;
    nr = nr + 1;
    sock[(signed long int)tmp_post$3] = fd;
  }

  if(!(net_config->requestedBufSize == 0))
    udpc_setSendBuf(sock[(signed long int)0], (unsigned int)net_config->requestedBufSize);

  net_config->controlMcastAddr.sin_addr.s_addr = (unsigned int)0;
  if(net_config->ttl == 1)
  {
    if(net_config->mcastRdv == ((const char *)NULL))
    {
      udpc_getBroadCastAddress(net_config->net_if, &net_config->controlMcastAddr, (signed short int)net_config->portBase);
      udpc_setSocketToBroadcast(sock[(signed long int)0]);
    }

  }

  signed int tmp_post$4;
  if(net_config->controlMcastAddr.sin_addr.s_addr == 0u)
  {
    udpc_getMcastAllAddress(&net_config->controlMcastAddr, net_config->mcastRdv, (signed short int)net_config->portBase);
    signed int return_value_isMcastAddress$5;
    return_value_isMcastAddress$5=isMcastAddress(&net_config->controlMcastAddr);
    if(!(return_value_isMcastAddress$5 == 0))
    {
      udpc_setMcastDestination(sock[(signed long int)0], net_config->net_if, &net_config->controlMcastAddr);
      udpc_setTtl(sock[(signed long int)0], net_config->ttl);
      tmp_post$4 = nr;
      nr = nr + 1;
      sock[(signed long int)tmp_post$4]=udpc_makeSocket((enum addr_type_t)ADDR_TYPE_MCAST, net_config->net_if, &net_config->controlMcastAddr, net_config->portBase + 1);
    }

  }

  signed int return_value_udpc_ipIsZero$7;
  if((0x0008 & net_config->flags) == 0)
  {
    return_value_udpc_ipIsZero$7=udpc_ipIsZero(&net_config->dataMcastAddr);
    if(!(return_value_udpc_ipIsZero$7 == 0))
    {
      udpc_getDefaultMcastAddress(net_config->net_if, &net_config->dataMcastAddr);
      char *return_value_udpc_getIpString$6;
      return_value_udpc_getIpString$6=udpc_getIpString(&net_config->dataMcastAddr, ipBuffer);
      udpc_flprintf("Using mcast address %s\n", return_value_udpc_getIpString$6);
    }

  }

  if(!((0x0008 & net_config->flags) == 0))
    udpc_clearIp(&net_config->dataMcastAddr);

  udpc_setPort(&net_config->dataMcastAddr, (unsigned short int)net_config->portBase);
  char *tmp_if_expr$8;
  if(disk_config->fileName == ((const char *)NULL))
    tmp_if_expr$8 = "(stdin)";

  else
    tmp_if_expr$8 = disk_config->fileName;
  udpc_flprintf("%sUDP sender for %s at ", disk_config->pipeName == (char *)(void *)0 ? "" : "Compressed ", tmp_if_expr$8);
  udpc_printMyIp(net_config->net_if);
  udpc_flprintf(" on %s \n", net_config->net_if->name);
  char *return_value_udpc_getIpString$9;
  return_value_udpc_getIpString$9=udpc_getIpString(&net_config->controlMcastAddr, ipBuffer);
  udpc_flprintf("Broadcasting control to %s\n", return_value_udpc_getIpString$9);
  net_config->capabilities = 0x0001 | 0x0008;
  if(!((0x0004 & net_config->flags) == 0))
    net_config->capabilities = net_config->capabilities | 0x0020;

  udpc_sendHello(net_config, sock[(signed long int)0], 0);
  db=udpc_makeParticipantsDb();
  tries = 0;
  if((0x0080 & net_config->flags) == 0)
    console=udpc_prepareConsole(disk_config->fileName != (const char *)(void *)0 ? 0 : -1);

  _Bool tmp_if_expr$10;
  if(!(net_config->min_receivers == 0))
    tmp_if_expr$10 = (_Bool)1;

  else
    tmp_if_expr$10 = net_config->min_receivers_wait != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$11;
  if(tmp_if_expr$10)
    tmp_if_expr$11 = (_Bool)1;

  else
    tmp_if_expr$11 = net_config->max_receivers_wait != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$11)
    firstConnectedP = &firstConnected;

  else
    firstConnectedP = (signed long int *)(void *)0;
  do
  {
    r=mainDispatcher(sock, nr, db, net_config, &console, &tries, firstConnectedP);
    if(!(r == 0))
      break;

  }
  while((_Bool)1);
  j = 1;
  for( ; !(j >= nr); j = j + 1)
    if(!(sock[(signed long int)j] == sock[0l]))
      close(sock[(signed long int)j]);

  sigemptyset(&sig);
  sigaddset(&sig, 15);
  signed int return_value_sigprocmask$12;
  return_value_sigprocmask$12=sigprocmask(0, &sig, &oldsig);
  if(return_value_sigprocmask$12 == 0)
    shouldRestoreSig = 1;

  udpc_restoreConsole(&console, 0);
  _Bool tmp_if_expr$14;
  signed int return_value_udpc_nrParticipants$13;
  if(r == 1)
  {
    signed int i = 1;
    for( ; !(i >= nr); i = i + 1)
      udpc_closeSock(sock, nr, i);
    if(!((0x0004 & net_config->flags) == 0))
      tmp_if_expr$14 = (_Bool)1;

    else
    {
      return_value_udpc_nrParticipants$13=udpc_nrParticipants(db);
      tmp_if_expr$14 = return_value_udpc_nrParticipants$13 > 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$14)
      doTransfer(sock[(signed long int)0], db, disk_config, net_config, stat_config);

    else
      fprintf(stderr, "No participants... exiting\n");
  }

  free((void *)db);
  if(!(shouldRestoreSig == 0))
    sigprocmask(2, &oldsig, (struct anonymous$3 *)(void *)0);

  return 0;
}

// udpc_waitForProcess
// file udpcast.c line 59
signed int udpc_waitForProcess(signed int pid, const char *message)
{
  signed int status;
  signed int return_value_waitpid$1;
  return_value_waitpid$1=waitpid(pid, &status, 0);
  if(!(return_value_waitpid$1 >= 0))
    return 0;

  else
  {
    signed int return_value_printProcessStatus$2;
    return_value_printProcessStatus$2=printProcessStatus(message, status);
    return return_value_printProcessStatus$2;
  }
}

// udpc_zeroSockArray
// file socklib.c line 1048
void udpc_zeroSockArray(signed int *socks, signed int nr)
{
  signed int i = 0;
  for( ; !(i >= nr); i = i + 1)
    socks[(signed long int)i] = -1;
}

// udpcs_openPipe
// file sender-diskio.c line 47
signed int udpcs_openPipe(struct disk_config *config, signed int in, signed int *pidp)
{
  *pidp = 0;
  if(!(config->pipeName == ((char *)NULL)))
  {
    char *arg[256l];
    signed int filedes[2l];
    udpc_parseCommand(config->pipeName, arg);
    signed int return_value_pipe$1;
    return_value_pipe$1=pipe(filedes);
    if(!(return_value_pipe$1 >= 0))
    {
      perror("pipe");
      exit(1);
    }

    *pidp=open2(in, filedes[(signed long int)1], arg, filedes[(signed long int)0]);
    close(filedes[(signed long int)1]);
    in = filedes[(signed long int)0];
  }

  return in;
}

// usage
// file udp-sender.c line 142
static void usage(char *progname)
{
  fprintf(stderr, "%s [--file file] [--full-duplex] [--pipe pipe] [--portbase portbase] [--blocksize size] [--interface net-interface] [--mcast-data-address data-mcast-address] [--mcast-rdv-address mcast-rdv-address] [--max-bitrate bitrate] [--pointopoint] [--async] [--log file] [--no-progress] [--min-slice-size min] [--max-slice-size max] [--slice-size] [--ttl time-to-live] [--fec <stripes>x<redundancy>/<stripesize>] [--print-seed] [--rexmit-hello-interval interval] [--autostart autostart] [--broadcast] [--min-receivers receivers] [--min-wait sec] [--max-wait sec] [--start-timeout n] [--retries-until-drop n] [--nokbd] [--bw-period n] [--streaming] [--rehello-offset offs] [--rate-governor module:parameters] [--autorate][--license]\n", progname);
  exit(1);
}

// vlogprintf
// file log.c line 34
static signed int vlogprintf(struct _IO_FILE *logfile, const char *fmt, void **ap)
{
  if(!(logfile == ((struct _IO_FILE *)NULL)))
  {
    char buf[9l];
    struct timeval tv;
    signed int r;
    if(!(newlineSeen == 0))
    {
      gettimeofday(&tv, (struct timezone *)(void *)0);
      struct tm *return_value_localtime$1;
      return_value_localtime$1=localtime(&tv.tv_sec);
      strftime(buf, sizeof(char [9l]) /*9ul*/ , "%H:%M:%S", return_value_localtime$1);
      fprintf(logfile, "%s.%06ld ", (const void *)buf, tv.tv_usec);
    }

    char *return_value___builtin_strchr$2;
    return_value___builtin_strchr$2=__builtin_strchr(fmt, 10);
    newlineSeen = (signed int)(return_value___builtin_strchr$2 != (char *)(void *)0);
    r=vfprintf(logfile, fmt, ap);
    if(!(newlineSeen == 0))
      fflush(logfile);

    return r;
  }

  else
    return -1;
}

// wakeConsumer
// file produconsum.c line 39
static void wakeConsumer(struct produconsum *pc)
{
  if(!(pc->consumerIsWaiting == 0))
  {
    pthread_mutex_lock(&pc->mutex);
    pthread_cond_signal(&pc->cond);
    pthread_mutex_unlock(&pc->mutex);
  }

}

