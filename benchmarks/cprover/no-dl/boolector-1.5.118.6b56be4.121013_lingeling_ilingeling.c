// tag-#anon#ST[*{*{S32}_S32_(*{V}_V_)->*{S32}_S32_}_*{S32}_S32_(*{V}_V_)->*{S32}_S32__'fun'||*{V}_V_'state'|]
// file lglib.c line 838
struct anonymous_93;

// tag-#anon#ST[*{S32(*{V}_V_)->S32}_S32(*{V}_V_)->S32_'fun'||*{V}_V_'state'||S32'done'||U32'_pad0'|]
// file lglib.c line 832
struct anonymous_89;

// tag-#anon#ST[*{S32}_S32_'cls'||S32'origlhs'||U32'_pad0'|]
// file lglib.c line 723
struct anonymous_56;

// tag-#anon#ST[*{SYM#tag-LGL#}_SYM#tag-LGL#_'lgl'||S32'count'||S32'bcount'||S64'decs'||S64'confs'||S64'props'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'lock'|]
// file ilingeling.c line 82
struct anonymous_1;

// tag-#anon#ST[*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'lock'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'unlock'||*{V}_V_'state'|]
// file lglib.c line 841
struct anonymous_96;

// tag-#anon#ST[*{V(*{V}_V_|*{*{S32}_S32_}_*{S32}_S32__|*{*{S32}_S32_}_*{S32}_S32__)->V}_V(*{V}_V_|*{*{S32}_S32_}_*{S32}_S32__|*{*{S32}_S32_}_*{S32}_S32__)->V_'fun'||*{V}_V_'state'|]
// file lglib.c line 835
struct anonymous_91;

// tag-#anon#ST[*{V(*{V}_V_|S32)->V}_V(*{V}_V_|S32)->V_'fun'||*{V}_V_'state'|]
// file lglib.c line 834
struct anonymous_90;

// tag-#anon#ST[*{V(*{V}_V_|S32|S32)->V}_V(*{V}_V_|S32|S32)->V_'fun'||*{V}_V_'state'|]
// file lglib.c line 839
struct anonymous_94;

// tag-#anon#ST[F64'all'||F64'basic'|]
// file lglib.c line 808
struct anonymous_76;

// tag-#anon#ST[S32'all'||S32'and'||S32'xor'||S32'ite'|]
// file lglib.c line 756
struct anonymous_63;

// tag-#anon#ST[S32'all'||S32'and'||S32'xor'||S32'ite'||S32'org'|]
// file lglib.c line 848
struct anonymous_98;

// tag-#anon#ST[S32'basic'|]
// file lglib.c line 822
struct anonymous_83;

// tag-#anon#ST[S32'bin'||S32'trn'||S32'lrg'|]
// file lglib.c line 750
struct anonymous_15;

// tag-#anon#ST[S32'bin'||S32'trn'||S32'lrg'||S32'red'|]
// file lglib.c line 768
struct anonymous_68;

// tag-#anon#ST[S32'clauses'|]
// file lglib.c line 733
struct anonymous_6;

// tag-#anon#ST[S32'clauses'||U32'_pad0'||S64'added'||S64'reduced'||S64'resolved'||S64'forcing'||S64'conflicts'||S64'saved'|]
// file lglib.c line 782
struct anonymous_30;

// tag-#anon#ST[S32'cnt'||S32'trn'||S32'lrg'||S32'sub'|]
// file lglib.c line 751
struct anonymous_16;

// tag-#anon#ST[S32'cond'||S32'pos'||S32'neg'|]
// file lglib.c line 724
struct anonymous_57;

// tag-#anon#ST[S32'count'||S32'bin'||S32'trn'||U32'_pad0'||S64'steps'|]
// file lglib.c line 753
struct anonymous_18;

// tag-#anon#ST[S32'count'||S32'clauses'||S32'lits'||S32'pure'||S64'res'||S64'steps'|]
// file lglib.c line 754
struct anonymous_19;

// tag-#anon#ST[S32'count'||S32'eliminated'||S32'ate'||S32'abce'||S32'failed'||S32'lifted'||S64'steps'||S64'probed'|]
// file lglib.c line 796
struct anonymous_37;

// tag-#anon#ST[S32'count'||S32'elmd'||S32'large'||S32'sub'||S32'str'||S32'blkd'||SYM#tag-#anon#ST[S32'elm'||S32'tried'||S32'failed'|]#'small'||U32'_pad0'||S64'resolutions'||S64'copies'||S64'subchks'||S64'strchks'||S64'ipos'||S64'steps'|]
// file lglib.c line 773
struct anonymous_26;

// tag-#anon#ST[S32'count'||S32'eq'||S32'units'||U32'_pad0'||S64'esteps'||S64'csteps'||SYM#tag-#anon#ST[S32'all'||S32'and'||S32'xor'||S32'ite'|]#'matched'||SYM#tag-#anon#ST[S32'all'||S32'and'||S32'xor'||S32'ite'|]#'simplified'||SYM#tag-#anon#ST[S64'all'||S64'and'||S64'xor'||S64'ite'|]#'extracted'|]
// file lglib.c line 755
struct anonymous_20;

// tag-#anon#ST[S32'count'||S32'eqs'||S32'units'||S32'impls'||S64'probed0'||S64'probed1'|]
// file lglib.c line 762
struct anonymous_22;

// tag-#anon#ST[S32'count'||S32'failed'||S32'lifted'||U32'_pad0'||S64'decisions'||S64'steps'|]
// file lglib.c line 798
struct anonymous_38;

// tag-#anon#ST[S32'count'||S32'failed'||S32'lifted'||U32'_pad0'||S64'probed'||S64'steps'|]
// file lglib.c line 760
struct anonymous_65;

// tag-#anon#ST[S32'count'||S32'gcs'||S32'units'||S32'equivs'||S32'trneqs'||U32'_pad0'||SYM#tag-#anon#ST[S32'max'||U32'_pad0'||S64'sum'|]#'arity'||SYM#tag-#anon#ST[S64'extr'||S64'elim'|]#'steps'||S64'extracted'|]
// file lglib.c line 792
struct anonymous_36;

// tag-#anon#ST[S32'count'||S32'plimhit'||S32'ilimhit'||S32'climhit'|]
// file lglib.c line 788
struct anonymous_33;

// tag-#anon#ST[S32'count'||S32'red'||S32'failed'||U32'_pad0'||S64'lits'||S64'bins'||S64'steps'|]
// file lglib.c line 763
struct anonymous_23;

// tag-#anon#ST[S32'count'||S32'reset'||S32'geom'||S32'arith'||S32'arith2'|]
// file lglib.c line 736
struct anonymous_8;

// tag-#anon#ST[S32'count'||S32'rounds'||SYM#tag-#anon#ST[S32'trds'||S32'failed'||S32'sccs'||U32'_pad0'||S64'sumsccsizes'|]#'stamp'||SYM#tag-#anon#ST[S32'lits'||S32'bin'||S32'trn'||S32'lrg'|]#'failed'||SYM#tag-#anon#ST[S32'bin'||S32'trn'||S32'lrg'||S32'red'|]#'tauts'||SYM#tag-#anon#ST[S32'bin'||S32'trn'||S32'lrg'|]#'units'||SYM#tag-#anon#ST[S32'trn'||S32'lrg'||S32'red'|]#'hbrs'||SYM#tag-#anon#ST[S32'trn'||S32'lrg'||S32'red'|]#'str'||U32'_pad0'||S64'steps'|]
// file lglib.c line 765
struct anonymous_25;

// tag-#anon#ST[S32'count'||S32'skipped'||SYM#tag-#anon#ST[S32'count'||U32'_pad0'||S64'sum'|]#'kept'|]
// file lglib.c line 734
struct anonymous_7;

// tag-#anon#ST[S32'count'||U32'_pad0'||S64'set'||S64'pos'||S64'neg'|]
// file lglib.c line 787
struct anonymous_32;

// tag-#anon#ST[S32'count'||U32'_pad0'||S64'steps'|]
// file lglib.c line 789
struct anonymous_34;

// tag-#anon#ST[S32'count'||U32'_pad0'||S64'sum'|]
// file lglib.c line 699
struct anonymous_4;

// tag-#anon#ST[S32'cur'||S32'max'||S64'add'|]
// file lglib.c line 739
struct anonymous_40;

// tag-#anon#ST[S32'current'||S32'sum'|]
// file lglib.c line 752
struct anonymous_17;

// tag-#anon#ST[S32'elm'||S32'tried'||S32'failed'|]
// file lglib.c line 775
struct anonymous_70;

// tag-#anon#ST[S32'inner'||S32'outer'||S32'extra'|]
// file lglib.c line 816
struct anonymous_77;

// tag-#anon#ST[S32'irr'||S32'red'|]
// file lglib.c line 778
struct anonymous_75;

// tag-#anon#ST[S32'lits'||S32'bin'||S32'trn'||S32'lrg'|]
// file lglib.c line 767
struct anonymous_67;

// tag-#anon#ST[S32'max'||S32'min'|]
// file lglib.c line 732
struct anonymous_59;

// tag-#anon#ST[S32'max'||U32'_pad0'||S64'sum'|]
// file lglib.c line 793
struct anonymous_72;

// tag-#anon#ST[S32'min'||S32'avg'||S32'max'|]
// file lglib.c line 745
struct anonymous_74;

// tag-#anon#ST[S32'pen'||U32'_pad0'||S64'esteps'||S64'csteps'|]
// file lglib.c line 817
struct anonymous_78;

// tag-#anon#ST[S32'pen'||U32'_pad0'||S64'steps'|]
// file lglib.c line 819
struct anonymous_80;

// tag-#anon#ST[S32'pen'||U32'_pad0'||S64'steps'||S64'irrprgss'|]
// file lglib.c line 818
struct anonymous_79;

// tag-#anon#ST[S32'pen'||U32'_pad0'||SYM#tag-#anon#ST[S64'extr'||S64'elim'|]#'steps'|]
// file lglib.c line 820
struct anonymous_81;

// tag-#anon#ST[S32'removed'||S32'red'|]
// file lglib.c line 764
struct anonymous_24;

// tag-#anon#ST[S32'total'||S32'pos'||S32'neg'|]
// file lglib.c line 743
struct anonymous_60;

// tag-#anon#ST[S32'total'||S32'unit'||S32'bin'||S32'trn'||S32'lrg'|]
// file lglib.c line 744
struct anonymous_61;

// tag-#anon#ST[S32'trds'||S32'failed'||S32'sccs'||U32'_pad0'||S64'sumsccsizes'|]
// file lglib.c line 766
struct anonymous_66;

// tag-#anon#ST[S32'trn'||S32'lrg'||S32'red'|]
// file lglib.c line 770
struct anonymous_69;

// tag-#anon#ST[S32'units'||S32'eq'||S32'all'||S32'and'||S32'xor'||S32'ite'||S32'org'|]
// file lglib.c line 847
struct anonymous_97;

// tag-#anon#ST[S32'vars'||SYM#tag-#anon#ST[S32'total'||S32'pos'||S32'neg'|]#'lits'||SYM#tag-#anon#ST[S32'total'||S32'unit'||S32'bin'||S32'trn'||S32'lrg'|]#'clauses'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32'min'||S32'avg'||S32'max'|]#'val'||SYM#tag-#anon#ST[S32'min'||S32'avg'||S32'max'|]#'var'|]#'cog'|]
// file lglib.c line 742
struct anonymous_11;

// tag-#anon#ST[S64'all'||S64'and'||S64'xor'||S64'ite'|]
// file lglib.c line 758
struct anonymous_64;

// tag-#anon#ST[S64'bin'||S64'trn'|]
// file lglib.c line 799
struct anonymous_39;

// tag-#anon#ST[S64'confs'||S32'wasmaxdelta'||S32'maxdelta'||S32'luby'||S32'inout'|]
// file lglib.c line 821
struct anonymous_82;

// tag-#anon#ST[S64'count'||SYM#tag-#anon#ST[S32'max'||S32'min'|]#'mincut'|]
// file lglib.c line 732
struct anonymous_5;

// tag-#anon#ST[S64'extr'||S64'elim'|]
// file lglib.c line 794
struct anonymous_73;

// tag-#anon#ST[S64'fixed'|]
// file lglib.c line 826
struct anonymous_88;

// tag-#anon#ST[S64'irr'||S64'prgss'||S64'confs'||S64'cinc'||S32'pen'||U32'_pad0'|]
// file lglib.c line 823
struct anonymous_85;

// tag-#anon#ST[S64'learned'||S64'glue'||S64'nonmaxglue'||S64'maxglue'||S64'scglue'|]
// file lglib.c line 781
struct anonymous_29;

// tag-#anon#ST[S64'new'||S64'del'||S64'merged'||S64'col'||S64'gcs'||SYM#tag-#anon#ST[S64'sum'||S32'count'||U32'_pad0'|]#'deprior'||S32'max'||U32'_pad0'|]
// file lglib.c line 790
struct anonymous_35;

// tag-#anon#ST[S64'nonmin'||S64'learned'|]
// file lglib.c line 780
struct anonymous_28;

// tag-#anon#ST[S64'pshwchs'||S64'prgss'|]
// file lglib.c line 824
struct anonymous_86;

// tag-#anon#ST[S64'sat'||S64'mosat'||S64'simp'||S64'deref'||S64'fixed'||S64'freeze'||S64'melt'||S64'add'||S64'assume'||S64'cassume'||S64'failed'||S64'repr'|]
// file lglib.c line 740
struct anonymous_10;

// tag-#anon#ST[S64'search'||S64'hits'|]
// file lglib.c line 747
struct anonymous_12;

// tag-#anon#ST[S64'search'||S64'simp'||S64'lkhd'|]
// file lglib.c line 748
struct anonymous_13;

// tag-#anon#ST[S64'steps'|]
// file lglib.c line 825
struct anonymous_87;

// tag-#anon#ST[S64'steps'||SYM#tag-#anon#ST[S32'basic'|]#'pen'||U32'_pad0'|]
// file lglib.c line 822
struct anonymous_84;

// tag-#anon#ST[S64'sum'||S32'count'||U32'_pad0'|]
// file lglib.c line 786
struct anonymous_31;

// tag-#anon#ST[SYM#tag-#anon#ST[*{*{S32}_S32_(*{V}_V_)->*{S32}_S32_}_*{S32}_S32_(*{V}_V_)->*{S32}_S32__'fun'||*{V}_V_'state'|]#'lock'||SYM#tag-#anon#ST[*{V(*{V}_V_|S32|S32)->V}_V(*{V}_V_|S32|S32)->V_'fun'||*{V}_V_'state'|]#'unlock'|]
// file lglib.c line 837
struct anonymous_95;

// tag-#anon#ST[SYM#tag-#anon#ST[*{V(*{V}_V_|S32)->V}_V(*{V}_V_|S32)->V_'fun'||*{V}_V_'state'|]#'produce'||SYM#tag-#anon#ST[*{V(*{V}_V_|S32)->V}_V(*{V}_V_|S32)->V_'fun'||*{V}_V_'state'|]#'consumed'||SYM#tag-#anon#ST[*{V(*{V}_V_|*{*{S32}_S32_}_*{S32}_S32__|*{*{S32}_S32_}_*{S32}_S32__)->V}_V(*{V}_V_|*{*{S32}_S32_}_*{S32}_S32__|*{*{S32}_S32_}_*{S32}_S32__)->V_'fun'||*{V}_V_'state'|]#'consume'|]
// file lglib.c line 833
struct anonymous_92;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'count'||S32'failed'||S32'lifted'||U32'_pad0'||S64'probed'||S64'steps'|]#'basic'|]
// file lglib.c line 759
struct anonymous_21;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'cur'||S32'max'||S64'add'|]#'clauses'||SYM#tag-#anon#ST[S32'cur'||S32'max'||S64'add'|]#'lits'|]
// file lglib.c line 739
struct anonymous_9;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'irr'||S32'red'|]#'dyn'|]
// file lglib.c line 778
struct anonymous_71;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'min'||S32'avg'||S32'max'|]#'val'||SYM#tag-#anon#ST[S32'min'||S32'avg'||S32'max'|]#'var'|]
// file lglib.c line 745
struct anonymous_62;

// tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32'irr'||S32'red'|]#'dyn'|]#'sub'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32'irr'||S32'red'|]#'dyn'|]#'str'||S32'driving'||S32'restarting'|]
// file lglib.c line 777
struct anonymous_27;

// tag-#anon#ST[SYM#tag-Stk#'bin'||SYM#tag-Stk#'trn'|]
// file lglib.c line 855
struct anonymous_99;

// tag-#anon#ST[U64'current'||U64'max'|]
// file lglib.c line 749
struct anonymous_14;

// tag-#anon#UN[*{SYM#tag-Elm#}_SYM#tag-Elm#_'elm'||*{SYM#tag-Cgr#}_SYM#tag-Cgr#_'cgr'||*{SYM#tag-Gauss#}_SYM#tag-Gauss#_'gauss'||*{SYM#tag-CCE#}_SYM#tag-CCE#_'cce'||*{SYM#tag-Cliff#}_SYM#tag-Cliff#_'cliff'|]
// file lglib.c line 930
union anonymous;

// tag-#anon#UN[ARR2{S32}_S32_'lits'||SYM#tag-#anon#ST[*{S32}_S32_'cls'||S32'origlhs'||U32'_pad0'|]#'_anon0'||SYM#tag-#anon#ST[S32'cond'||S32'pos'||S32'neg'|]#'_anon1'|]
// file lglib.c line 721
union anonymous_55;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_3;

// tag-#anon#UN[S32'lit'||S32'sign'|]
// file lglib.c line 710
union anonymous_58;

// tag-#anon#UN[S64'ru_idrss'||S64'__ru_idrss_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 208
union anonymous_43;

// tag-#anon#UN[S64'ru_inblock'||S64'__ru_inblock_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 240
union anonymous_48;

// tag-#anon#UN[S64'ru_isrss'||S64'__ru_isrss_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 214
union anonymous_44;

// tag-#anon#UN[S64'ru_ixrss'||S64'__ru_ixrss_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 202
union anonymous_42;

// tag-#anon#UN[S64'ru_majflt'||S64'__ru_majflt_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 227
union anonymous_46;

// tag-#anon#UN[S64'ru_maxrss'||S64'__ru_maxrss_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 194
union anonymous_41;

// tag-#anon#UN[S64'ru_minflt'||S64'__ru_minflt_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 221
union anonymous_45;

// tag-#anon#UN[S64'ru_msgrcv'||S64'__ru_msgrcv_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 258
union anonymous_51;

// tag-#anon#UN[S64'ru_msgsnd'||S64'__ru_msgsnd_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 252
union anonymous_50;

// tag-#anon#UN[S64'ru_nivcsw'||S64'__ru_nivcsw_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 279
union anonymous_54;

// tag-#anon#UN[S64'ru_nsignals'||S64'__ru_nsignals_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 264
union anonymous_52;

// tag-#anon#UN[S64'ru_nswap'||S64'__ru_nswap_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 233
union anonymous_47;

// tag-#anon#UN[S64'ru_nvcsw'||S64'__ru_nvcsw_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 272
union anonymous_53;

// tag-#anon#UN[S64'ru_oublock'||S64'__ru_oublock_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 246
union anonymous_49;

// tag-#anon#UN[SYM#tag-Stk#'lcaseen'||SYM#tag-Stk#'sortstk'||SYM#tag-Stk#'resolvent'|]
// file lglib.c line 932
union anonymous_0;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_2;

// tag-ASL
// file lglib.c line 637
struct ASL;

// tag-AVar
// file lglib.c line 681
struct AVar;

// tag-CCE
// file lglib.c line 872
struct CCE;

// tag-Cbs
// file lglib.c line 831
struct Cbs;

// tag-Cgr
// file lglib.c line 846
struct Cgr;

// tag-Cliff
// file lglib.c line 853
struct Cliff;

// tag-Conf
// file lglib.c line 638
struct Conf;

// tag-Ctk
// file lglib.c line 639
struct Ctk;

// tag-Ctr
// file lglib.c line 639
struct Ctr;

// tag-DFL
// file lglib.c line 708
struct DFL;

// tag-DFOPF
// file lglib.c line 640
struct DFOPF;

// tag-DFPR
// file lglib.c line 641
struct DFPR;

// tag-DVar
// file lglib.c line 662
struct DVar;

// tag-Dis
// file lglib.c line 855
struct Dis;

// tag-EVar
// file lglib.c line 642
struct EVar;

// tag-Elm
// file lglib.c line 857
struct Elm;

// tag-Ext
// file lglib.c line 694
struct Ext;

// tag-FltStr
// file lglib.c line 862
struct FltStr;

// tag-ForceData
// file lglib.c line 7432
struct ForceData;

// tag-GTag
// file lglib.c line 466
enum GTag { ANDTAG=0, ITETAG=1, XORTAG=2 };

// tag-Gat
// file lglib.c line 716
struct Gat;

// tag-Gauss
// file lglib.c line 866
struct Gauss;

// tag-HTS
// file lglib.c line 643
struct HTS;

// tag-ITEC
// file lglib.c line 644
struct ITEC;

// tag-LGL
// file lglib.h line 19
struct LGL;

// tag-Lim
// file lglib.c line 645
struct Lim;

// tag-Limits
// file lglib.c line 813
struct Limits;

// tag-Mem
// file lglib.c line 874
struct Mem;

// tag-Opt
// file lglib.c line 470
struct Opt;

// tag-Opts
// file lglib.c line 476
struct Opts;

// tag-Qln
// file lglib.c line 647
struct Qln;

// tag-Qnd
// file lglib.c line 647
struct Qnd;

// tag-Queue
// file lglib.c line 669
struct Queue;

// tag-RNG
// file lglib.c line 648
struct RNG;

// tag-State
// file lglib.c line 445
enum State { UNUSED=1, OPTSET=2, USED=4, READY=8, UNKNOWN=16, SATISFIED=32, EXTENDED=64, UNSATISFIED=128, FAILED=256, LOOKED=512, RESET=1024 };

// tag-Stats
// file lglib.c line 730
struct Stats;

// tag-Stk
// file lglib.c line 649
struct Stk;

// tag-TD
// file lglib.c line 675
struct TD;

// tag-Tag
// file lglib.c line 427
enum Tag { FREEVAR=0, FIXEDVAR=1, EQUIVAR=2, ELIMVAR=3, DECISION=0, UNITCS=1, OCCS=1, BINCS=2, TRNCS=3, LRGCS=4, MASKCS=7, REDCS=8, RMSHFT=4 };

// tag-Times
// file lglib.c line 804
struct Times;

// tag-Tmrs
// file lglib.c line 650
struct Tmrs;

// tag-Trv
// file lglib.c line 651
struct Trv;

// tag-Wchs
// file lglib.c line 879
struct Wchs;

// tag-Work
// file lglib.c line 653
struct Work;

// tag-Worker
// file ilingeling.c line 80
struct Worker;

// tag-Wrag
// file lglib.c line 459
enum Wrag { PREFIX=0, BEFORE=1, AFTER=2, POSTFIX=3 };

// tag-Wrk
// file lglib.c line 881
struct Wrk;

// tag-Wtk
// file lglib.c line 653
struct Wtk;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rusage
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 187
struct rusage;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// _IO_getc
// file /usr/include/libio.h line 434
extern signed int _IO_getc(struct _IO_FILE *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __ctype_tolower_loc
// file /usr/include/ctype.h line 81
extern const signed int ** __ctype_tolower_loc(void);
// __ctype_toupper_loc
// file /usr/include/ctype.h line 83
extern const signed int ** __ctype_toupper_loc(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// add
// file ilingeling.c line 471
static void add(signed int lit);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// atoi_link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link1(const char *__nptr_link1);
// catchsig
// file ilingeling.c line 737
static void catchsig(signed int sig);
// caughtsigmsg
// file ilingeling.c line 731
static void caughtsigmsg(signed int sig);
// cmpdblptr
// file ilingeling.c line 619
static signed int cmpdblptr(const void *p, const void *q);
// currentime
// file ilingeling.c line 167
static double currentime(void);
// die
// file ilingeling.c line 146
static void die(const char *fmt, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeze
// file ilingeling.c line 579
static void freeze(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getime
// file ilingeling.c line 174
static double getime();
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getrusage
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 87
extern signed int getrusage(signed int, struct rusage *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// hist
// file ilingeling.c line 710
static void hist(void);
// init
// file ilingeling.c line 423
static void init(void);
// initlgl
// file ilingeling.c line 240
static void initlgl(struct LGL *lgl, struct Worker *w, signed int opts);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// isnum
// file ilingeling.c line 176
static signed int isnum(const char *str);
// justreturn
// file ilingeling.c line 253
static signed int justreturn(struct Worker *w);
// lgl2manyoccs4blk
// file lglib.c line 11134
static signed int lgl2manyoccs4blk(struct LGL *lgl, signed int lit);
// lgl2manyoccs4elm
// file lglib.c line 11014
static signed int lgl2manyoccs4elm(struct LGL *lgl, signed int lit);
// lglabce
// file lglib.c line 11516
static signed int lglabce(struct LGL *lgl, signed int lit);
// lglabcecls
// file lglib.c line 11506
static signed int lglabcecls(struct LGL *lgl, signed int lit, const signed int *c);
// lglabort
// file lglib.c line 1171
static void lglabort(struct LGL *lgl);
// lgladd
// file lglib.h line 180
void lgladd(struct LGL *lgl, signed int elit);
// lgladdcls
// file lglib.c line 3511
static signed int lgladdcls(struct LGL *lgl, signed int red, signed int origlue, signed int force);
// lgladdecl
// file lglib.c line 9309
static void lgladdecl(struct LGL *lgl, const signed int *c);
// lgladdflt
// file lglib.c line 1108
static signed long int lgladdflt(signed long int a, signed long int b);
// lgladdliftbincls
// file lglib.c line 13914
static void lgladdliftbincls(struct LGL *lgl, signed int a, signed int b);
// lgladdunits
// file lglib.c line 13703
static signed int lgladdunits(struct LGL *lgl);
// lgladecide
// file lglib.c line 7716
static signed int lgladecide(struct LGL *lgl);
// lgladjext
// file lglib.c line 2490
static void lgladjext(struct LGL *lgl, signed int eidx);
// lglagile
// file lglib.c line 5178
static signed int lglagile(struct LGL *lgl);
// lglagility
// file lglib.c line 5012
static double lglagility(struct LGL *lgl);
// lglana
// file lglib.c line 6027
static signed int lglana(struct LGL *lgl);
// lglanafailed
// file lglib.c line 14447
static void lglanafailed(struct LGL *lgl);
// lglanalit
// file lglib.c line 14399
static signed int lglanalit(struct LGL *lgl, signed int lit);
// lgland3fun
// file lglib.c line 10575
static void lgland3fun(unsigned long int *a, unsigned long int *b, unsigned long int *c);
// lgland3negfun
// file lglib.c line 10581
static void lgland3negfun(unsigned long int *a, unsigned long int *b, unsigned long int *c);
// lglandfun
// file lglib.c line 10569
static void lglandfun(unsigned long int *a, unsigned long int *b);
// lglandornegfun
// file lglib.c line 10563
static void lglandornegfun(unsigned long int *a, unsigned long int *b, unsigned long int *c);
// lglassign
// file lglib.c line 2611
static void lglassign(struct LGL *lgl, signed int lit, signed int r0, signed int r1);
// lglassume
// file lglib.h line 181
void lglassume(struct LGL *lgl, signed int elit);
// lglassumption
// file lglib.c line 4805
static signed int lglassumption(struct LGL *lgl, signed int lit);
// lglavar
// file lglib.c line 2318
static struct AVar * lglavar(struct LGL *lgl, signed int lit);
// lglavg
// file lglib.c line 5014
static double lglavg(double n, double d);
// lglavglue
// file lglib.c line 5022
static signed long int lglavglue(struct LGL *lgl);
// lglbacksub
// file lglib.c line 9546
static signed int lglbacksub(struct LGL *lgl, signed int *c, signed int str);
// lglbacktrack
// file lglib.c line 2801
static void lglbacktrack(struct LGL *lgl, signed int level);
// lglbasicprobe
// file lglib.c line 8966
static signed int lglbasicprobe(struct LGL *lgl);
// lglbasicprobelit
// file lglib.c line 8735
static void lglbasicprobelit(struct LGL *lgl, signed int root);
// lglbcp
// file lglib.c line 4732
static signed int lglbcp(struct LGL *lgl);
// lglbcpsearch
// file lglib.c line 4756
static signed int lglbcpsearch(struct LGL *lgl);
// lglbcptop
// file lglib.c line 17200
static signed int lglbcptop(struct LGL *lgl);
// lglblock
// file lglib.c line 11378
static void lglblock(struct LGL *lgl);
// lglblockcls
// file lglib.c line 11069
static signed int lglblockcls(struct LGL *lgl, signed int lit);
// lglblocking
// file lglib.c line 16961
static signed int lglblocking(struct LGL *lgl);
// lglblockinglit
// file lglib.c line 10012
static void lglblockinglit(struct LGL *lgl, signed int ilit);
// lglblocklit
// file lglib.c line 11180
static signed int lglblocklit(struct LGL *lgl, signed int lit, struct Stk *stk);
// lglbnr
// file lglib.h line 100
void lglbnr(const char *name, const char *prefix, struct _IO_FILE *file);
// lglbonflict
// file lglib.c line 4011
static void lglbonflict(struct LGL *lgl, signed int lit, signed int blit);
// lglboundredl
// file lglib.c line 5182
static void lglboundredl(struct LGL *lgl);
// lglbrutefork
// file lglib.h line 79
struct LGL * lglbrutefork(struct LGL *lgl, signed int complete);
// lglbumplidx
// file lglib.c line 3491
static signed int lglbumplidx(struct LGL *lgl, signed int lidx);
// lglbumplits
// file lglib.c line 5994
static void lglbumplits(struct LGL *lgl);
// lglbytes
// file lglib.c line 5002
unsigned long int lglbytes(struct LGL *lgl);
// lglca
// file lglib.c line 4161
static signed int lglca(struct LGL *lgl, signed int a, signed int b);
// lglcamark
// file lglib.c line 4147
static void lglcamark(struct LGL *lgl, signed int lit, signed int mark);
// lglcamarked
// file lglib.c line 4137
static signed int lglcamarked(struct LGL *lgl, signed int lit);
// lglcard
// file lglib.c line 16873
static void lglcard(struct LGL *lgl);
// lglcassume
// file lglib.c line 3980
void lglcassume(struct LGL *lgl, signed int elit);
// lglcce
// file lglib.c line 11856
static signed int lglcce(struct LGL *lgl);
// lglcceclause
// file lglib.c line 11542
static signed int lglcceclause(struct LGL *lgl, const signed int *c, const signed int *ignwch, signed int igntag);
// lglcceing
// file lglib.c line 11478
static signed int lglcceing(struct LGL *lgl);
// lglccelit
// file lglib.c line 11808
static void lglccelit(struct LGL *lgl, signed int lit);
// lglceilld
// file lglib.c line 984
static signed int lglceilld(signed int n);
// lglceilsqrt32
// file lglib.c line 990
static signed int lglceilsqrt32(signed int x);
// lglceilsqrt64
// file lglib.c line 1014
static signed int lglceilsqrt64(signed int x);
// lglcgeq
// file lglib.c line 12379
static signed int lglcgeq(struct LGL *lgl, signed int a, signed int b);
// lglcgextractands
// file lglib.c line 12613
static signed int lglcgextractands(struct LGL *lgl, signed int lit);
// lglcgextractidx
// file lglib.c line 12937
static signed int lglcgextractidx(struct LGL *lgl, signed int idx);
// lglcgextractitecands
// file lglib.c line 12834
static void lglcgextractitecands(struct LGL *lgl, signed int lhs, struct ITEC *cands, signed int ncands);
// lglcgextractites
// file lglib.c line 12865
static signed int lglcgextractites(struct LGL *lgl, signed int lit);
// lglcgextractlimhit
// file lglib.c line 12576
static signed int lglcgextractlimhit(struct LGL *lgl);
// lglcgextractxors
// file lglib.c line 12748
static signed int lglcgextractxors(struct LGL *lgl, signed int lit);
// lglcginit
// file lglib.c line 13002
static void lglcginit(struct LGL *lgl);
// lglcgmerge
// file lglib.c line 12520
static void lglcgmerge(struct LGL *lgl, signed int other, signed int repr);
// lglcgmergelhsrhs
// file lglib.c line 12816
static signed int lglcgmergelhsrhs(struct LGL *lgl, signed int lhs, signed int rhs);
// lglcgrclosing
// file lglib.c line 16955
static signed int lglcgrclosing(struct LGL *lgl);
// lglcgrclsr
// file lglib.c line 13782
static signed int lglcgrclsr(struct LGL *lgl);
// lglcgrepr
// file lglib.c line 12319
static signed int lglcgrepr(struct LGL *lgl, signed int lit);
// lglcgreprnotconst
// file lglib.c line 12341
static signed int lglcgreprnotconst(struct LGL *lgl, signed int lit);
// lglcgreset
// file lglib.c line 13031
static void lglcgreset(struct LGL *lgl);
// lglcgrlimhit
// file lglib.c line 13330
static signed int lglcgrlimhit(struct LGL *lgl);
// lglcgrlit
// file lglib.c line 13614
static void lglcgrlit(struct LGL *lgl, signed int lit);
// lglcgunit
// file lglib.c line 12585
static signed int lglcgunit(struct LGL *lgl, signed int lit);
// lglchanged
// file lglib.c line 17865
signed int lglchanged(struct LGL *lgl);
// lglchkassumeclean
// file lglib.c line 3726
static void lglchkassumeclean(struct LGL *lgl);
// lglchkbcpclean
// file lglib.c line 6871
static void lglchkbcpclean(struct LGL *lgl, const char *where);
// lglchkclone
// file lglib.c line 2076
void lglchkclone(struct LGL *lgl);
// lglchkclonesamestats
// file lglib.c line 17640
static void lglchkclonesamestats(struct LGL *orig);
// lglchkeassumeclean
// file lglib.c line 3714
static void lglchkeassumeclean(struct LGL *lgl);
// lglchkenv
// file lglib.c line 1632
static void lglchkenv(struct LGL *lgl);
// lglchkflt
// file lglib.c line 1038
static void lglchkflt(signed long int a);
// lglchkirrstats
// file lglib.c line 3421
static void lglchkirrstats(struct LGL *lgl);
// lglchkoccs4elm
// file lglib.c line 11052
static signed int lglchkoccs4elm(struct LGL *lgl, signed int idx);
// lglchkoccs4elmlit
// file lglib.c line 11018
static signed int lglchkoccs4elmlit(struct LGL *lgl, signed int lit);
// lglchkqueue
// file lglib.c line 2346
static void lglchkqueue(struct LGL *lgl);
// lglchkred
// file lglib.c line 5076
static void lglchkred(struct LGL *lgl);
// lglchksimpcls
// file lglib.c line 2945
static void lglchksimpcls(struct LGL *lgl);
// lglclass
// file lglib.c line 17518
static void lglclass(struct LGL *lgl, struct LGL *from);
// lglcleanrepr
// file lglib.c line 13904
static void lglcleanrepr(struct LGL *lgl, struct Stk *represented, signed int *repr);
// lglcliff
// file lglib.c line 12065
static signed int lglcliff(struct LGL *lgl);
// lglcliffclause
// file lglib.c line 11924
static void lglcliffclause(struct LGL *lgl, const signed int *c);
// lglcliffclauses
// file lglib.c line 11987
static signed int lglcliffclauses(struct LGL *lgl, struct Stk *stk);
// lglcliffing
// file lglib.c line 17015
static signed int lglcliffing(struct LGL *lgl);
// lglclifflit
// file lglib.c line 12000
static signed int lglclifflit(struct LGL *lgl, signed int lit);
// lglclnana
// file lglib.c line 5830
static void lglclnana(struct LGL *lgl);
// lglclnframes
// file lglib.c line 5813
static void lglclnframes(struct LGL *lgl);
// lglclnpoisoned
// file lglib.c line 5818
static void lglclnpoisoned(struct LGL *lgl);
// lglclnstk
// file lglib.c line 1472
static void lglclnstk(struct Stk *s);
// lglclone
// file lglib.c line 1990
struct LGL * lglclone(struct LGL *orig);
// lglclsr
// file lglib.c line 13663
static void lglclsr(struct LGL *lgl);
// lglcmpagsl
// file lglib.c line 5128
static signed int lglcmpagsl(struct ASL *a, struct ASL *b);
// lglcmpasgl
// file lglib.c line 5136
static signed int lglcmpasgl(struct ASL *a, struct ASL *b);
// lglcmpdfl
// file lglib.c line 15489
static signed int lglcmpdfl(const struct DFL *a, const struct DFL *b);
// lglcmpfdat
// file lglib.c line 7440
static signed int lglcmpfdat(struct ForceData *fdat, signed int l, signed int k);
// lglcmpgauss
// file lglib.c line 16499
static signed int lglcmpgauss(struct LGL *lgl, signed int a, signed int b);
// lglcmpgoccs
// file lglib.c line 13081
static signed int lglcmpgoccs(struct LGL *lgl, signed int a, signed int b);
// lglcmphase
// file lglib.c line 6484
static signed int lglcmphase(struct LGL *lgl, signed int a, signed int b);
// lglcmpitecands
// file lglib.c line 12808
static signed int lglcmpitecands(const struct ITEC *c, const struct ITEC *d);
// lglcmpocc
// file lglib.c line 12570
static signed int lglcmpocc(struct LGL *lgl, signed int a, signed int b);
// lglcmprepr
// file lglib.c line 8187
static signed int lglcmprepr(struct LGL *lgl, signed int a, signed int b);
// lglcnf
// file lglib.c line 10734
static signed long int lglcnf(signed int pos, signed int size);
// lglcnf2pos
// file lglib.c line 10731
static signed int lglcnf2pos(signed long int cnf);
// lglcnf2size
// file lglib.c line 10732
static signed int lglcnf2size(signed long int cnf);
// lglcntctk
// file lglib.c line 1544
static signed int lglcntctk(struct Ctk *ctk);
// lglcntstk
// file lglib.c line 1388
static unsigned long int lglcntstk(struct Stk *s);
// lglcntwtk
// file lglib.c line 14993
static signed int lglcntwtk(struct Wtk *wtk);
// lglcompact
// file lglib.c line 7609
static void lglcompact(struct LGL *lgl);
// lglcompactify
// file lglib.c line 17573
static signed int lglcompactify(struct LGL *lgl, signed int res);
// lglcompletefork
// file lglib.c line 18926
static void lglcompletefork(struct LGL *dst, struct LGL *src);
// lglcomputechanged
// file lglib.c line 17371
static void lglcomputechanged(struct LGL *lgl);
// lglcomputecog
// file lglib.c line 18522
static void lglcomputecog(struct LGL *lgl);
// lglcon
// file lglib.c line 6572
static void lglcon(struct LGL *lgl);
// lglconnaux
// file lglib.c line 6490
static void lglconnaux(struct LGL *lgl, signed int glue);
// lglcount
// file lglib.c line 6578
static void lglcount(struct LGL *lgl);
// lglcpyopts
// file lglib.c line 18907
static void lglcpyopts(struct LGL *dst, const struct LGL *src);
// lglcpystk
// file lglib.c line 16551
static void lglcpystk(struct LGL *lgl, struct Stk *dst, struct Stk *src);
// lglctrav
// file lglib.c line 18746
void lglctrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int));
// lglctrav::trav_object
//
void trav_object(void *, signed int);
// lglcutwidth
// file lglib.c line 6877
static signed int lglcutwidth(struct LGL *lgl);
// lglcval
// file lglib.c line 2961
static signed int lglcval(struct LGL *lgl, signed int litorval);
// lgldassume
// file lglib.c line 7730
static void lgldassume(struct LGL *lgl, signed int lit);
// lgldcpcln
// file lglib.c line 8043
static void lgldcpcln(struct LGL *lgl);
// lgldcpclnstk
// file lglib.c line 7904
static void lgldcpclnstk(struct LGL *lgl, signed int red, struct Stk *s);
// lgldcpcon
// file lglib.c line 8023
static void lgldcpcon(struct LGL *lgl);
// lgldcpconnaux
// file lglib.c line 7982
static void lgldcpconnaux(struct LGL *lgl, signed int red, signed int glue, struct Stk *s);
// lgldcpdis
// file lglib.c line 7852
static void lgldcpdis(struct LGL *lgl);
// lgldec
// file lglib.c line 1253
static void lgldec(struct LGL *lgl, unsigned long int bytes);
// lgldec64
// file lglib.c line 16230
static unsigned long int lgldec64(unsigned long int i);
// lgldecide
// file lglib.c line 7832
static signed int lgldecide(struct LGL *lgl);
// lgldecidephase
// file lglib.c line 7758
static signed int lgldecidephase(struct LGL *lgl, signed int lit);
// lgldecirr
// file lglib.c line 3481
static void lgldecirr(struct LGL *lgl, signed int size);
// lgldecision
// file lglib.c line 4799
static signed int lgldecision(struct LGL *lgl, signed int lit);
// lgldeclscnt
// file lglib.c line 4071
static void lgldeclscnt(struct LGL *lgl, signed int size, signed int red, signed int glue);
// lgldecocc
// file lglib.c line 5650
static void lgldecocc(struct LGL *lgl, signed int lit);
// lgldecomp
// file lglib.c line 12274
static signed int lgldecomp(struct LGL *lgl);
// lgldecomposing
// file lglib.c line 16953
static signed int lgldecomposing(struct LGL *lgl);
// lgldefphase
// file lglib.c line 7738
static signed int lgldefphase(struct LGL *lgl, signed int idx);
// lgldefrag
// file lglib.c line 6362
static void lgldefrag(struct LGL *lgl);
// lgldefragmenting
// file lglib.c line 16988
static signed int lgldefragmenting(struct LGL *lgl);
// lgldel
// file lglib.c line 1271
static void lgldel(struct LGL *lgl, void *ptr, unsigned long int bytes);
// lgldelstr
// file lglib.c line 1306
static void lgldelstr(struct LGL *lgl, char *str);
// lgldense
// file lglib.c line 9121
static void lgldense(struct LGL *lgl, signed int occstoo);
// lgldeprioritize
// file lglib.c line 5862
static void lgldeprioritize(struct LGL *lgl);
// lglderef
// file lglib.h line 192
signed int lglderef(struct LGL *lgl, signed int elit);
// lgldie
// file lglib.c line 1160
static void lgldie(struct LGL *lgl, const char *msg, ...);
// lgldis
// file lglib.c line 6408
static void lgldis(struct LGL *lgl);
// lgldstpull
// file lglib.c line 14382
static signed int lgldstpull(struct LGL *lgl, signed int lit);
// lgldvar
// file lglib.c line 2313
static struct DVar * lgldvar(struct LGL *lgl, signed int lit);
// lgldynstr
// file lglib.c line 5725
static void lgldynstr(struct LGL *lgl, signed int del, signed int lit, signed int r0, signed int r1);
// lgldynsub
// file lglib.c line 5707
static void lgldynsub(struct LGL *lgl, signed int lit, signed int r0, signed int r1);
// lgleadd
// file lglib.c line 3850
static void lgleadd(struct LGL *lgl, signed int elit);
// lgleassign
// file lglib.c line 17364
static void lgleassign(struct LGL *lgl, signed int lit);
// lgleassume
// file lglib.c line 3916
static void lgleassume(struct LGL *lgl, signed int elit);
// lglecalc
// file lglib.c line 3362
static signed int lglecalc(struct LGL *lgl, struct EVar *ev);
// lglecassume
// file lglib.c line 3959
static void lglecassume(struct LGL *lgl, signed int elit);
// lglecls
// file lglib.c line 9371
static signed int lglecls(struct LGL *lgl, signed int lit);
// lglecmp
// file lglib.c line 3194
static signed int lglecmp(struct LGL *lgl, signed int l, signed int k);
// lglederef
// file lglib.c line 8448
static signed int lglederef(struct LGL *lgl, signed int elit);
// lgledown
// file lglib.c line 3250
static void lgledown(struct LGL *lgl, signed int lit);
// lglefixed
// file lglib.c line 17958
static signed int lglefixed(struct LGL *lgl, signed int elit);
// lglelim
// file lglib.c line 12128
static signed int lglelim(struct LGL *lgl);
// lgleliminated
// file lglib.c line 10121
static void lgleliminated(struct LGL *lgl, signed int pivot);
// lgleliminating
// file lglib.c line 16970
static signed int lgleliminating(struct LGL *lgl);
// lglelimlit
// file lglib.c line 11059
static void lglelimlit(struct LGL *lgl, signed int idx);
// lglelimlitaux
// file lglib.c line 10453
static void lglelimlitaux(struct LGL *lgl, signed int idx);
// lglelit2ext
// file lglib.c line 2461
static struct Ext * lglelit2ext(struct LGL *lgl, signed int elit);
// lglelitblockingoreliminated
// file lglib.c line 12199
static signed int lglelitblockingoreliminated(struct LGL *lgl, signed int elit);
// lglelmfre
// file lglib.c line 10111
static void lglelmfre(struct LGL *lgl);
// lglelmfrelit
// file lglib.c line 10024
static void lglelmfrelit(struct LGL *lgl, signed int mpivot, signed int *sop, signed int *eop, signed int *son, signed int *eon);
// lglelmstr
// file lglib.c line 9658
static signed int lglelmstr(struct LGL *lgl);
// lglelmsub
// file lglib.c line 9635
static void lglelmsub(struct LGL *lgl);
// lglelrmcls
// file lglib.c line 9481
static void lglelrmcls(struct LGL *lgl, signed int lit, signed int *c, signed int clidx);
// lglemerge
// file lglib.c line 8068
static void lglemerge(struct LGL *lgl, signed int ilit0, signed int ilit1);
// lglenlargegates
// file lglib.c line 12334
static void lglenlargegates(struct LGL *lgl);
// lglenlctk
// file lglib.c line 1551
static void lglenlctk(struct LGL *lgl, struct Ctk *ctk);
// lglenlstk
// file lglib.c line 1401
static void lglenlstk(struct LGL *lgl, struct Stk *s);
// lglenlvars
// file lglib.c line 2292
static void lglenlvars(struct LGL *lgl);
// lglenlwchs
// file lglib.c line 3041
static signed long int lglenlwchs(struct LGL *lgl, struct HTS *hts);
// lglenlwtk
// file lglib.c line 15000
static void lglenlwtk(struct LGL *lgl, struct Wtk *wtk);
// lglepos
// file lglib.c line 3186
static signed int * lglepos(struct LGL *lgl, signed int lit);
// lglepush
// file lglib.c line 8062
static void lglepush(struct LGL *lgl, signed int ilit);
// lglepusheliminated
// file lglib.c line 10141
static void lglepusheliminated(struct LGL *lgl, signed int idx);
// lglerepr
// file lglib.c line 2467
static signed int lglerepr(struct LGL *lgl, signed int elit);
// lglesched
// file lglib.c line 3294
static void lglesched(struct LGL *lgl, signed int lit);
// lgleschedrem
// file lglib.c line 11318
static signed int lgleschedrem(struct LGL *lgl, signed int this_time);
// lglesetphase
// file lglib.c line 3891
static void lglesetphase(struct LGL *lgl, signed int elit, signed int phase);
// lgletrav
// file lglib.c line 18731
void lgletrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int, signed int));
// lgletrav::trav_object
//
void trav_object(void *, signed int, signed int);
// lgleunassignall
// file lglib.c line 3708
static void lgleunassignall(struct LGL *lgl);
// lgleup
// file lglib.c line 3220
static void lgleup(struct LGL *lgl, signed int lit);
// lglevar
// file lglib.c line 3180
static struct EVar * lglevar(struct LGL *lgl, signed int lit);
// lglevel
// file lglib.c line 2340
static signed int lglevel(struct LGL *lgl, signed int lit);
// lglevelused
// file lglib.c line 1579
static signed int lglevelused(struct LGL *lgl, signed int level);
// lglexp
// file lglib.c line 1047
static signed int lglexp(signed long int a);
// lglexport
// file lglib.c line 2573
static signed int lglexport(struct LGL *lgl, signed int ilit);
// lglextend
// file lglib.c line 17383
static void lglextend(struct LGL *lgl);
// lglf2rce
// file lglib.c line 2713
static void lglf2rce(struct LGL *lgl, signed int lit, signed int other, signed int red);
// lglf3rce
// file lglib.c line 2720
static void lglf3rce(struct LGL *lgl, signed int lit, signed int other, signed int other2, signed int red);
// lglfadd
// file lglib.c line 3812
static void lglfadd(struct LGL *lgl, signed int elit);
// lglfailed
// file lglib.h line 195
signed int lglfailed(struct LGL *lgl, signed int elit);
// lglfailedass
// file lglib.c line 14442
static signed int lglfailedass(struct LGL *lgl);
// lglfalsefun
// file lglib.c line 10513
static void lglfalsefun(unsigned long int *res);
// lglfirstopt
// file lglib.c line 2142
void * lglfirstopt(struct LGL *lgl);
// lglfitlir
// file lglib.c line 5072
static void lglfitlir(struct LGL *lgl, struct Stk *lir);
// lglfitstk
// file lglib.c line 1427
static void lglfitstk(struct LGL *lgl, struct Stk *s);
// lglfixate
// file lglib.c line 3995
void lglfixate(struct LGL *lgl);
// lglfixed
// file lglib.c line 17969
signed int lglfixed(struct LGL *lgl, signed int elit);
// lglfixlrgwchs
// file lglib.c line 15880
static void lglfixlrgwchs(struct LGL *lgl);
// lglfjadd
// file lglib.c line 18891
static void lglfjadd(struct LGL *lgl, signed int elit);
// lglfjradd
// file lglib.c line 18899
static void lglfjradd(struct LGL *lgl, signed int elit, signed int glue);
// lglfloorld
// file lglib.c line 971
static signed int lglfloorld(signed int n);
// lglflrce
// file lglib.c line 2729
static void lglflrce(struct LGL *lgl, signed int lit, signed int red, signed int lidx);
// lglflshrep
// file lglib.c line 5066
static void lglflshrep(struct LGL *lgl);
// lglflt
// file lglib.c line 1061
static signed long int lglflt(signed int e, unsigned long int m);
// lglflt2str
// file lglib.c line 1094
static const char * lglflt2str(struct LGL *lgl, signed long int a);
// lglflush
// file lglib.c line 9991
static signed int lglflush(struct LGL *lgl);
// lglflushcache
// file lglib.h line 198
void lglflushcache(struct LGL *lgl);
// lglflushclauses
// file lglib.c line 9711
static signed int lglflushclauses(struct LGL *lgl, signed int lit);
// lglflushlits
// file lglib.c line 9813
static signed int lglflushlits(struct LGL *lgl, signed int lit);
// lglflushphases
// file lglib.c line 6830
static void lglflushphases(struct LGL *lgl);
// lglflushqmerged
// file lglib.c line 5839
static void lglflushqmerged(struct LGL *lgl);
// lglflushremovedoccs
// file lglib.c line 4392
static void lglflushremovedoccs(struct LGL *lgl, signed int lit);
// lglflushtimers
// file lglib.h line 278
void lglflushtimers(struct LGL *lgl);
// lglforce
// file lglib.c line 7455
static void lglforce(struct LGL *lgl, signed int *map);
// lglfork
// file lglib.h line 72
struct LGL * lglfork(struct LGL *lgl, signed int complete);
// lglforkaux
// file lglib.c line 18955
static struct LGL * lglforkaux(struct LGL *lgl, signed int brutefork, signed int complete);
// lglforkmerge
// file lglib.c line 18996
static void lglforkmerge(struct LGL *to, struct LGL *from);
// lglfreewch
// file lglib.c line 3018
static void lglfreewch(struct LGL *lgl, signed int oldoffset, signed int oldhcount);
// lglfreeze
// file lglib.h line 262
void lglfreeze(struct LGL *lgl, signed int elit);
// lglfreezer
// file lglib.c line 8118
static void lglfreezer(struct LGL *lgl);
// lglfullctk
// file lglib.c line 1540
static signed int lglfullctk(struct Ctk *ctk);
// lglfullstk
// file lglib.c line 1386
static signed int lglfullstk(struct Stk *s);
// lglfullwtk
// file lglib.c line 14989
static signed int lglfullwtk(struct Wtk *wtk);
// lglfullyconnected
// file lglib.c line 6566
static void lglfullyconnected(struct LGL *lgl);
// lglfuncpy
// file lglib.c line 10507
static void lglfuncpy(unsigned long int *dst, unsigned long int *src);
// lglgat2idx
// file lglib.c line 12373
static signed int lglgat2idx(struct LGL *lgl, struct Gat *g);
// lglgateextract
// file lglib.c line 12951
static void lglgateextract(struct LGL *lgl);
// lglgauss
// file lglib.c line 16810
static signed int lglgauss(struct LGL *lgl);
// lglgaussaddeqn
// file lglib.c line 16557
static signed int lglgaussaddeqn(struct LGL *lgl, signed int eqn);
// lglgausschkeliminated
// file lglib.c line 16606
static void lglgausschkeliminated(struct LGL *lgl);
// lglgaussconeqn
// file lglib.c line 16413
static void lglgaussconeqn(struct LGL *lgl, signed int eqn);
// lglgaussconnect
// file lglib.c line 16433
static void lglgaussconnect(struct LGL *lgl);
// lglgaussdisconnect
// file lglib.c line 16467
static void lglgaussdisconnect(struct LGL *lgl);
// lglgaussdiseqn
// file lglib.c line 16421
static void lglgaussdiseqn(struct LGL *lgl, signed int eqn);
// lglgausselim
// file lglib.c line 16667
static void lglgausselim(struct LGL *lgl);
// lglgausselimvar
// file lglib.c line 16637
static signed int lglgausselimvar(struct LGL *lgl, signed int pivot);
// lglgaussexp2
// file lglib.c line 16692
static signed int lglgaussexp2(struct LGL *lgl, signed int a, signed int b);
// lglgaussexp3
// file lglib.c line 16708
static signed int lglgaussexp3(struct LGL *lgl, signed int a, signed int b, signed int c);
// lglgaussexport
// file lglib.c line 16725
static signed int lglgaussexport(struct LGL *lgl);
// lglgaussextract
// file lglib.c line 16477
static void lglgaussextract(struct LGL *lgl);
// lglgaussextractlarge
// file lglib.c line 16401
static signed int lglgaussextractlarge(struct LGL *lgl);
// lglgaussextractsmall
// file lglib.c line 16391
static signed int lglgaussextractsmall(struct LGL *lgl);
// lglgaussextractsmallit
// file lglib.c line 16357
static signed int lglgaussextractsmallit(struct LGL *lgl, signed int lit);
// lglgaussextractxor
// file lglib.c line 16350
static signed int lglgaussextractxor(struct LGL *lgl, const signed int *c);
// lglgaussextractxoraux
// file lglib.c line 16308
static signed int lglgaussextractxoraux(struct LGL *lgl, const signed int *c);
// lglgaussgc
// file lglib.c line 16619
static void lglgaussgc(struct LGL *lgl);
// lglgaussing
// file lglib.c line 17010
static signed int lglgaussing(struct LGL *lgl);
// lglgaussinit
// file lglib.c line 16678
static void lglgaussinit(struct LGL *lgl);
// lglgaussoccs
// file lglib.c line 16495
static signed int lglgaussoccs(struct LGL *lgl, signed int a);
// lglgaussorder
// file lglib.c line 16462
static void lglgaussorder(struct LGL *lgl);
// lglgaussorderidx
// file lglib.c line 16455
static signed int lglgaussorderidx(struct LGL *lgl, signed int var);
// lglgaussort
// file lglib.c line 16507
static void lglgaussort(struct LGL *lgl);
// lglgausspickeqn
// file lglib.c line 16519
static signed int lglgausspickeqn(struct LGL *lgl, signed int pivot);
// lglgaussreset
// file lglib.c line 16683
static void lglgaussreset(struct LGL *lgl);
// lglgaussubcls
// file lglib.c line 16301
static signed int lglgaussubcls(struct LGL *lgl, unsigned long int signs, const signed int *c);
// lglgaussubclsaux
// file lglib.c line 16251
static signed int lglgaussubclsaux(struct LGL *lgl, unsigned long int signs, const signed int *c);
// lglgaussubst
// file lglib.c line 16569
static void lglgaussubst(struct LGL *lgl, signed int pivot, signed int subst);
// lglgc
// file lglib.c line 7634
static void lglgc(struct LGL *lgl);
// lglgcd
// file lglib.c line 3319
static unsigned int lglgcd(unsigned int a, unsigned int b);
// lglgcnotnecessary
// file lglib.c line 7603
static signed int lglgcnotnecessary(struct LGL *lgl);
// lglgdump
// file lglib.c line 16237
static void lglgdump(struct LGL *lgl);
// lglgetconfs
// file lglib.h line 282
signed long int lglgetconfs(struct LGL *lgl);
// lglgetdecs
// file lglib.h line 283
signed long int lglgetdecs(struct LGL *lgl);
// lglgetdom
// file lglib.c line 2591
static signed int lglgetdom(struct LGL *lgl, signed int lit);
// lglgetenv
// file lglib.c line 1606
static void lglgetenv(struct LGL *lgl, struct Opt *opt, const char *lname);
// lglgetime
// file lglib.c line 4956
static double lglgetime(struct LGL *lgl);
// lglgetopt
// file lglib.c line 2263
signed int lglgetopt(struct LGL *lgl, const char *opt);
// lglgetoptminmax
// file lglib.c line 2268
signed int lglgetoptminmax(struct LGL *lgl, const char *opt, signed int *min_ptr, signed int *max_ptr);
// lglgetout
// file lglib.c line 2244
struct _IO_FILE * lglgetout(struct LGL *lgl);
// lglgetprefix
// file lglib.c line 2251
const char * lglgetprefix(struct LGL *lgl);
// lglgetprops
// file lglib.h line 284
signed long int lglgetprops(struct LGL *lgl);
// lglgidx2gat
// file lglib.c line 12368
static struct Gat * lglgidx2gat(struct LGL *lgl, signed int gidx);
// lglgluestats
// file lglib.c line 18095
static void lglgluestats(struct LGL *lgl);
// lglgoccsmatchcand
// file lglib.c line 13092
static signed int lglgoccsmatchcand(struct LGL *lgl, signed int a, signed int b);
// lglhasbin
// file lglib.c line 8465
static signed int lglhasbin(struct LGL *lgl, signed int a, signed int b);
// lglhasbingate
// file lglib.c line 12431
static signed int lglhasbingate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int rhs0, signed int rhs1);
// lglhasbins
// file lglib.c line 7787
static signed int lglhasbins(struct LGL *lgl, signed int lit);
// lglhasitegate
// file lglib.c line 12383
static signed int lglhasitegate(struct LGL *lgl, signed int lhs, signed int cond, signed int pos, signed int neg);
// lglhasopt
// file lglib.h line 121
signed int lglhasopt(struct LGL *lgl, const char *opt);
// lglhastrn
// file lglib.c line 10204
static signed int lglhastrn(struct LGL *lgl, signed int a, signed int b, signed int c);
// lglhbred
// file lglib.c line 4355
static signed int lglhbred(struct LGL *lgl, signed int subsumed, signed int red);
// lglheight
// file lglib.c line 5018
static double lglheight(struct LGL *lgl);
// lglhts
// file lglib.c line 2599
static struct HTS * lglhts(struct LGL *lgl, signed int lit);
// lglhts2wchs
// file lglib.c line 2603
static signed int * lglhts2wchs(struct LGL *lgl, struct HTS *hts);
// lgli2m
// file lglib.c line 9273
static signed int lgli2m(struct LGL *lgl, signed int ilit);
// lgliadd
// file lglib.c line 3685
static void lgliadd(struct LGL *lgl, signed int ilit);
// lgliassume
// file lglib.c line 7678
static void lgliassume(struct LGL *lgl, signed int lit);
// lglidx2lits
// file lglib.c line 2537
static signed int * lglidx2lits(struct LGL *lgl, signed int tag, signed int red, signed int lidx);
// lglifixed
// file lglib.c line 2794
static signed char lglifixed(struct LGL *lgl, signed int lit);
// lglifrozen
// file lglib.c line 3288
static signed int lglifrozen(struct LGL *lgl, signed int ilit);
// lglift
// file lglib.c line 14342
static signed int lglift(struct LGL *lgl);
// lgliftaux
// file lglib.c line 13973
static signed int lgliftaux(struct LGL *lgl);
// lglifting
// file lglib.c line 16959
static signed int lglifting(struct LGL *lgl);
// lgligetopt
// file lglib.c line 2253
static struct Opt * lgligetopt(struct LGL *lgl, const char *opt);
// lglilit
// file lglib.c line 6651
static signed int lglilit(signed int ulit);
// lglimerge
// file lglib.c line 8096
static void lglimerge(struct LGL *lgl, signed int lit, signed int repr);
// lglimhit
// file lglib.c line 17218
static signed int lglimhit(struct LGL *lgl, struct Lim *lim);
// lglimport
// file lglib.c line 2510
static signed int lglimport(struct LGL *lgl, signed int elit);
// lglinc
// file lglib.c line 1245
static void lglinc(struct LGL *lgl, unsigned long int bytes);
// lglincextractlimhit
// file lglib.c line 12580
static signed int lglincextractlimhit(struct LGL *lgl);
// lglincfdat
// file lglib.c line 7434
static void lglincfdat(struct ForceData *fdat, signed int lit, double cog);
// lglincirr
// file lglib.c line 3468
static void lglincirr(struct LGL *lgl, signed int size);
// lglincjwh
// file lglib.c line 6658
static void lglincjwh(struct LGL *lgl, signed int lit, signed long int inc);
// lglinclause
// file lglib.c line 12709
static void lglinclause(struct LGL *lgl, signed int parity);
// lglincocc
// file lglib.c line 3372
static void lglincocc(struct LGL *lgl, signed int lit);
// lglinconsistent
// file lglib.c line 17950
signed int lglinconsistent(struct LGL *lgl);
// lglincrestartaux
// file lglib.c line 6267
static void lglincrestartaux(struct LGL *lgl, signed int skip);
// lglincrestartl
// file lglib.c line 6287
static void lglincrestartl(struct LGL *lgl, signed int skip);
// lglincrestartlfixed
// file lglib.c line 6261
static void lglincrestartlfixed(struct LGL *lgl);
// lglincvar
// file lglib.c line 17902
signed int lglincvar(struct LGL *lgl);
// lglinit
// file lglib.h line 23
struct LGL * lglinit(void);
// lglinitcbs
// file lglib.c line 1312
static void lglinitcbs(struct LGL *lgl);
// lglinitecls
// file lglib.c line 9435
static void lglinitecls(struct LGL *lgl, signed int idx);
// lglinitsmallve
// file lglib.c line 10633
static signed int lglinitsmallve(struct LGL *lgl, signed int lit, unsigned long int *res);
// lglinitsolve
// file lglib.c line 17331
static void lglinitsolve(struct LGL *lgl);
// lglinnerprobe
// file lglib.c line 13860
static signed int lglinnerprobe(struct LGL *lgl, signed int old, struct Stk *outer, struct Stk *tmp);
// lglinout
// file lglib.c line 5262
static signed long int lglinout(struct LGL *lgl, signed int c, signed int relincpcnt);
// lglinprocessing
// file lglib.c line 17186
static signed int lglinprocessing(struct LGL *lgl);
// lgliphase
// file lglib.c line 6478
static signed char lgliphase(struct LGL *lgl, signed int lit);
// lglirepr
// file lglib.c line 7181
static signed int lglirepr(struct LGL *lgl, signed int lit);
// lglis
// file lglib.c line 6735
static signed int * lglis(struct LGL *lgl);
// lglisact
// file lglib.c line 3390
static signed int lglisact(signed int act);
// lglisat
// file lglib.c line 17581
static signed int lglisat(struct LGL *lgl, struct Lim *lim, signed int simpits);
// lgliselim
// file lglib.c line 2568
static signed int lgliselim(struct LGL *lgl, signed int lit);
// lglisetphase
// file lglib.c line 3883
static void lglisetphase(struct LGL *lgl, signed int lit, signed int phase);
// lglisfalsefun
// file lglib.c line 10525
static signed int lglisfalsefun(unsigned long int *f);
// lglisfree
// file lglib.c line 2342
static signed int lglisfree(struct LGL *lgl, signed int lit);
// lglisimp
// file lglib.c line 17019
static signed int lglisimp(struct LGL *lgl);
// lglislook
// file lglib.c line 8841
static signed int lglislook(struct LGL *lgl);
// lglispow2
// file lglib.c line 979
static signed int lglispow2(signed int n);
// lglistruefun
// file lglib.c line 10532
static signed int lglistruefun(unsigned long int *f);
// lglitcanbemelted
// file lglib.c line 18027
signed int lglitcanbemelted(struct LGL *lgl, signed int elit);
// lglitgone
// file lglib.c line 18014
signed int lglitgone(struct LGL *lgl, signed int elit);
// lgljoin
// file lglib.h line 83
signed int lgljoin(struct LGL *to, struct LGL *from);
// lgljwh
// file lglib.c line 6665
static void lgljwh(struct LGL *lgl);
// lgljwhlook
// file lglib.c line 8804
static signed int lgljwhlook(struct LGL *lgl);
// lglm2i
// file lglib.c line 9265
static signed int lglm2i(struct LGL *lgl, signed int mlit);
// lglmap
// file lglib.c line 7574
static void lglmap(struct LGL *lgl);
// lglmapass
// file lglib.c line 7230
static void lglmapass(struct LGL *lgl, signed int *map);
// lglmapequiv
// file lglib.c line 7413
static void lglmapequiv(struct LGL *lgl, signed int *map);
// lglmapext
// file lglib.c line 7186
static void lglmapext(struct LGL *lgl, signed int *map);
// lglmapglue
// file lglib.c line 6973
static void lglmapglue(struct LGL *lgl, signed int *map, struct Stk *lits);
// lglmaphts
// file lglib.c line 7054
static void lglmaphts(struct LGL *lgl, signed int *map);
// lglmaplit
// file lglib.c line 6962
static signed int lglmaplit(signed int *map, signed int lit);
// lglmaplits
// file lglib.c line 6980
static void lglmaplits(struct LGL *lgl, signed int *map);
// lglmapnonequiv
// file lglib.c line 7382
static void lglmapnonequiv(struct LGL *lgl, signed int *map, signed int size);
// lglmapqln
// file lglib.c line 7098
static void lglmapqln(struct LGL *lgl, struct Qln *line, signed int *map);
// lglmapqueue
// file lglib.c line 7125
static void lglmapqueue(struct LGL *lgl, signed int *map);
// lglmapsize
// file lglib.c line 7374
static signed int lglmapsize(struct LGL *lgl);
// lglmapstk
// file lglib.c line 6966
static void lglmapstk(struct LGL *lgl, signed int *map, struct Stk *lits);
// lglmaptrail
// file lglib.c line 7084
static void lglmaptrail(struct LGL *lgl, signed int *map);
// lglmapvars
// file lglib.c line 6987
static void lglmapvars(struct LGL *lgl, signed int *map, signed int nvars);
// lglmark
// file lglib.c line 2939
static void lglmark(struct LGL *lgl, signed int lit);
// lglmarked
// file lglib.c line 2843
static signed int lglmarked(struct LGL *lgl, signed int lit);
// lglmatchbingate
// file lglib.c line 13124
static signed int lglmatchbingate(struct LGL *lgl, struct Gat *g, struct Gat *h);
// lglmatchgate
// file lglib.c line 13295
static signed int lglmatchgate(struct LGL *lgl, signed int fixed, struct Gat *g, struct Gat *h);
// lglmatchitegate
// file lglib.c line 13098
static signed int lglmatchitegate(struct LGL *lgl, struct Gat *g, struct Gat *h);
// lglmatchlrgand
// file lglib.c line 13216
static signed int lglmatchlrgand(struct LGL *lgl, struct Gat *g, struct Gat *h);
// lglmatchlrgandaux
// file lglib.c line 13144
static signed int lglmatchlrgandaux(struct LGL *lgl, struct Gat *g, struct Gat *h);
// lglmatchlrgxor
// file lglib.c line 13223
static signed int lglmatchlrgxor(struct LGL *lgl, struct Gat *g, struct Gat *h);
// lglmax
// file lglib.c line 2309
static signed int lglmax(signed int a, signed int b);
// lglmaxmb
// file lglib.c line 4997
double lglmaxmb(struct LGL *lgl);
// lglmaxoptnamelen
// file lglib.c line 2087
static signed int lglmaxoptnamelen(struct LGL *lgl);
// lglmaxvar
// file lglib.c line 17893
signed int lglmaxvar(struct LGL *lgl);
// lglmb
// file lglib.h line 287
double lglmb(struct LGL *lgl);
// lglmelt
// file lglib.h line 263
void lglmelt(struct LGL *lgl, signed int elit);
// lglmeltall
// file lglib.c line 18043
void lglmeltall(struct LGL *lgl);
// lglmelter
// file lglib.c line 2504
static void lglmelter(struct LGL *lgl);
// lglmin
// file lglib.c line 2311
static signed int lglmin(signed int a, signed int b);
// lglmincls
// file lglib.c line 6003
static void lglmincls(struct LGL *lgl, signed int uip);
// lglminclslit
// file lglib.c line 4873
static signed int lglminclslit(struct LGL *lgl, signed int start);
// lglminit
// file lglib.c line 1700
struct LGL * lglminit(void *mem, void * (*alloc)(void *, unsigned long int), void * (*realloc)(void *, void *, unsigned long int, unsigned long int), void (*dealloc)(void *, void *, unsigned long int));
// lglminit::alloc_object
//
void * alloc_object(void *, unsigned long int);
// lglminit::dealloc_object
//
void dealloc_object(void *, void *, unsigned long int);
// lglminit::realloc_object
//
void * realloc_object(void *, void *, unsigned long int, unsigned long int);
// lglmnt
// file lglib.c line 1054
static unsigned long int lglmnt(signed long int a);
// lglmosat
// file lglib.c line 17745
signed int lglmosat(struct LGL *lgl, void *state, signed int (*f)(void *, signed int, signed int), signed int *targets);
// lglmosat::f_object
//
signed int f_object(void *, signed int, signed int);
// lglmsgend
// file lglib.c line 1199
static void lglmsgend(struct LGL *lgl);
// lglmsgstart
// file lglib.c line 1190
static signed int lglmsgstart(struct LGL *lgl, signed int level);
// lglmtstk
// file lglib.c line 1387
static signed int lglmtstk(struct Stk *s);
// lglmtwtk
// file lglib.c line 14987
static signed int lglmtwtk(struct Wtk *wtk);
// lglmulflt
// file lglib.c line 1126
static signed long int lglmulflt(signed long int a, signed long int b);
// lglmvbcls
// file lglib.c line 11138
static void lglmvbcls(struct LGL *lgl, signed int a, signed int b);
// lglmvtcls
// file lglib.c line 11157
static void lglmvtcls(struct LGL *lgl, signed int a, signed int b, signed int c);
// lglneedacts
// file lglib.c line 5144
static signed int lglneedacts(struct LGL *lgl, signed int *glueuselessptr, signed int *needmoreglueptr);
// lglnegass
// file lglib.c line 17554
static void lglnegass(struct LGL *lgl);
// lglnegcofactorfun
// file lglib.c line 10751
static void lglnegcofactorfun(unsigned long int *f, signed int v, unsigned long int *res);
// lglnegvar2fun
// file lglib.c line 10503
static void lglnegvar2fun(signed int v, unsigned long int *res);
// lglnew
// file lglib.c line 1258
static void * lglnew(struct LGL *lgl, unsigned long int bytes);
// lglnewbingate
// file lglib.c line 12451
static signed int lglnewbingate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int rhs0, signed int rhs1);
// lglnewgate
// file lglib.c line 12349
static struct Gat * lglnewgate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int size);
// lglnewirrlim
// file lglib.c line 6799
static signed long int lglnewirrlim(struct LGL *lgl);
// lglnewitegate
// file lglib.c line 12406
static void lglnewitegate(struct LGL *lgl, signed int lhs, signed int cond, signed int pos, signed int neg);
// lglnewlgl
// file lglib.c line 1669
static struct LGL * lglnewlgl(void *mem, void * (*alloc)(void *, unsigned long int), void * (*realloc)(void *, void *, unsigned long int, unsigned long int), void (*dealloc)(void *, void *, unsigned long int));
// lglnewlgl::alloc_object
//
void * alloc_object(void *, unsigned long int);
// lglnewlgl::dealloc_object
//
void dealloc_object(void *, void *, unsigned long int);
// lglnewlgl::realloc_object
//
void * realloc_object(void *, void *, unsigned long int, unsigned long int);
// lglnewlrgate
// file lglib.c line 12478
static void lglnewlrgate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int *cls, signed int size);
// lglnewvar
// file lglib.c line 2435
static signed int lglnewvar(struct LGL *lgl);
// lglnextdecision
// file lglib.c line 6295
static signed int lglnextdecision(struct LGL *lgl);
// lglnextopt
// file lglib.c line 2144
void * lglnextopt(struct LGL *lgl, void *current, const char **nameptr, signed int *valptr, signed int *minptr, signed int *maxptr);
// lglnvars
// file lglib.c line 12317
signed int lglnvars(struct LGL *lgl);
// lglobalftlim
// file lglib.c line 13929
static signed long int lglobalftlim(struct LGL *lgl);
// lglocc
// file lglib.c line 3368
static signed int lglocc(struct LGL *lgl, signed int lit);
// lglonabort
// file lglib.c line 1316
void lglonabort(struct LGL *lgl, void *abortstate, void (*onabort)(void *));
// lglonabort::onabort_object
//
void onabort_object(void *);
// lglonflict
// file lglib.c line 4035
static void lglonflict(struct LGL *lgl, signed int check, signed int lit, signed int red, signed int lidx);
// lglookahead
// file lglib.c line 17832
signed int lglookahead(struct LGL *lgl);
// lgloop
// file lglib.c line 17233
static signed int lgloop(struct LGL *lgl, struct Lim *lim);
// lglopenapitrace
// file lglib.c line 1485
static void lglopenapitrace(struct LGL *lgl, const char *name);
// lglopts
// file lglib.c line 2111
void lglopts(struct LGL *lgl, const char *prefix, signed int ignsome);
// lglor3fun
// file lglib.c line 10551
static void lglor3fun(unsigned long int *a, unsigned long int *b, unsigned long int *c);
// lglor3negfun
// file lglib.c line 10557
static void lglor3negfun(unsigned long int *a, unsigned long int *b, unsigned long int *c);
// lglordercls
// file lglib.c line 3007
static void lglordercls(struct LGL *lgl);
// lglorderclsaux
// file lglib.c line 2995
static void lglorderclsaux(struct LGL *lgl, signed int *start);
// lglorfun
// file lglib.c line 10539
static void lglorfun(unsigned long int *a, unsigned long int *b);
// lglornegfun
// file lglib.c line 10545
static void lglornegfun(unsigned long int *a, unsigned long int *b);
// lglpar64
// file lglib.c line 16222
static signed int lglpar64(unsigned long int i);
// lglparity
// file lglib.c line 12701
static signed int lglparity(struct LGL *lgl);
// lglpcnt
// file lglib.c line 3357
static double lglpcnt(double n, double d);
// lglpeek
// file lglib.c line 1391
static signed int lglpeek(struct Stk *s, signed int pos);
// lglphase
// file lglib.c line 6846
static void lglphase(struct LGL *lgl);
// lglpicosatchkall
// file lglib.c line 7337
static void lglpicosatchkall(struct LGL *lgl);
// lglpicosatrestart
// file lglib.c line 7356
static void lglpicosatrestart(struct LGL *lgl);
// lglpoison
// file lglib.c line 4841
static signed int lglpoison(struct LGL *lgl, signed int lit, struct Stk *stk);
// lglpoke
// file lglib.c line 1396
static void lglpoke(struct Stk *s, signed int pos, signed int val);
// lglpopcontrol
// file lglib.c line 1569
static void lglpopcontrol(struct LGL *lgl);
// lglpopesched
// file lglib.c line 5628
static signed int lglpopesched(struct LGL *lgl);
// lglpopnunlcamarkstk
// file lglib.c line 4132
static void lglpopnunlcamarkstk(struct LGL *lgl, struct Stk *stk);
// lglpopnunmarkstk
// file lglib.c line 4127
static void lglpopnunmarkstk(struct LGL *lgl, struct Stk *stk);
// lglpopstk
// file lglib.c line 1447
static signed int lglpopstk(struct Stk *s);
// lglpos2cnf
// file lglib.c line 10729
static signed long int lglpos2cnf(signed int pos);
// lglposcofactorfun
// file lglib.c line 10760
static void lglposcofactorfun(unsigned long int *f, signed int v, unsigned long int *res);
// lglprbana
// file lglib.c line 8406
static signed int lglprbana(struct LGL *lgl, signed int probe);
// lglprbpull
// file lglib.c line 8393
static signed int lglprbpull(struct LGL *lgl, signed int lit, signed int probe);
// lglprefix
// file lglib.c line 1186
static const char * lglprefix(struct LGL *lgl);
// lglpreprocessing
// file lglib.c line 17151
static signed int lglpreprocessing(struct LGL *lgl, signed int forced);
// lglprint
// file lglib.c line 18806
void lglprint(struct LGL *lgl, struct _IO_FILE *file);
// lglprintfeatures
// file lglib.c line 18556
void lglprintfeatures(struct LGL *lgl);
// lglprobe
// file lglib.c line 9113
static signed int lglprobe(struct LGL *lgl);
// lglprobing
// file lglib.c line 16864
static signed int lglprobing(struct LGL *lgl);
// lglprocesstime
// file lglib.h line 290
double lglprocesstime(void);
// lglprop
// file lglib.c line 4420
static void lglprop(struct LGL *lgl, signed int lit);
// lglprop2
// file lglib.c line 4697
static void lglprop2(struct LGL *lgl, signed int lit);
// lglpropsearch
// file lglib.c line 4245
static void lglpropsearch(struct LGL *lgl, signed int lit);
// lglpropunits
// file lglib.c line 13725
static signed int lglpropunits(struct LGL *lgl);
// lglprs
// file lglib.c line 18084
static void lglprs(struct LGL *lgl, const char *fmt, ...);
// lglprstart
// file lglib.c line 18078
static void lglprstart(struct LGL *lgl);
// lglprt
// file lglib.c line 1206
static void lglprt(struct LGL *lgl, signed int level, const char *msg, ...);
// lglprtcgrem
// file lglib.c line 12985
static void lglprtcgrem(struct LGL *lgl);
// lglprternresrem
// file lglib.c line 14689
static void lglprternresrem(struct LGL *lgl);
// lglprtlftrem
// file lglib.c line 13956
static void lglprtlftrem(struct LGL *lgl);
// lglptrjmp
// file lglib.c line 7151
static signed int lglptrjmp(signed int *repr, signed int max, signed int start);
// lglpull
// file lglib.c line 4809
static signed int lglpull(struct LGL *lgl, signed int lit);
// lglpurelit
// file lglib.c line 11122
static signed int lglpurelit(struct LGL *lgl, signed int lit);
// lglpushcontrol
// file lglib.c line 1560
static void lglpushcontrol(struct LGL *lgl, signed int decision);
// lglpushgocc
// file lglib.c line 12323
static void lglpushgocc(struct LGL *lgl, signed int lit, signed int gidx);
// lglpushnmarkseen
// file lglib.c line 11116
static void lglpushnmarkseen(struct LGL *lgl, signed int lit);
// lglpushstk
// file lglib.c line 1431
static void lglpushstk(struct LGL *lgl, struct Stk *s, signed int elem);
// lglpushwch
// file lglib.c line 3115
static signed long int lglpushwch(struct LGL *lgl, struct HTS *hts, signed int wch);
// lglpushwtk
// file lglib.c line 15009
static void lglpushwtk(struct LGL *lgl, struct Wtk *wtk, enum Wrag wrag, signed int lit, signed int other, signed int red);
// lglqclone
// file lglib.c line 1906
static void lglqclone(struct LGL *lgl, struct LGL *orig);
// lglqcmp
// file lglib.c line 2753
static signed int lglqcmp(struct LGL *lgl, signed int l, signed int k);
// lglqdump
// file lglib.c line 2421
static void lglqdump(struct LGL *lgl);
// lglqln
// file lglib.c line 2741
static struct Qln * lglqln(struct LGL *lgl, signed int lit);
// lglqnd
// file lglib.c line 1900
static struct Qnd * lglqnd(struct LGL *lgl, signed int lit);
// lglqsched
// file lglib.c line 2372
static void lglqsched(struct LGL *lgl, signed int idx);
// lglqschedall
// file lglib.c line 17259
static void lglqschedall(struct LGL *lgl);
// lglrand
// file lglib.c line 1529
static unsigned int lglrand(struct LGL *lgl);
// lglrandec
// file lglib.c line 7686
static signed int lglrandec(struct LGL *lgl);
// lglrandidxtrav
// file lglib.c line 3327
static signed int lglrandidxtrav(struct LGL *lgl, signed int (*fun)(struct LGL *, signed int));
// lglrandidxtrav::fun_object
//
signed int fun_object(struct LGL *, signed int);
// lglrandlitrav
// file lglib.c line 8594
static signed int lglrandlitrav(struct LGL *lgl, signed int (*fun)(struct LGL *, signed int));
// lglrandlitrav::fun_object
//
signed int fun_object(struct LGL *, signed int);
// lglrandomprobe
// file lglib.c line 13848
static signed int lglrandomprobe(struct LGL *lgl, struct Stk *outer);
// lglreadopts
// file lglib.c line 2203
signed int lglreadopts(struct LGL *lgl, struct _IO_FILE *file);
// lglredstk
// file lglib.c line 1456
static void lglredstk(struct LGL *lgl, struct Stk *s, signed int minsize, signed int pow2smaller);
// lglreduce
// file lglib.c line 5281
static void lglreduce(struct LGL *lgl, signed int forced);
// lglreducing
// file lglib.c line 16979
static signed int lglreducing(struct LGL *lgl);
// lglredvars
// file lglib.c line 2300
static void lglredvars(struct LGL *lgl);
// lglregularly
// file lglib.c line 17087
static void lglregularly(struct LGL *lgl);
// lglrelctk
// file lglib.c line 1546
static void lglrelctk(struct LGL *lgl, struct Ctk *ctk);
// lglrelease
// file lglib.h line 24
void lglrelease(struct LGL *lgl);
// lglrelease::1::dealloc_object
//
void dealloc_object(void *, void *, unsigned long int);
// lglrelecls
// file lglib.c line 9422
static void lglrelecls(struct LGL *lgl);
// lglrelqueue
// file lglib.c line 18614
static void lglrelqueue(struct LGL *lgl);
// lglrelstk
// file lglib.c line 1410
static void lglrelstk(struct LGL *lgl, struct Stk *s);
// lglrelwtk
// file lglib.c line 14995
static void lglrelwtk(struct LGL *lgl, struct Wtk *wtk);
// lglrem
// file lglib.c line 3348
static signed int lglrem(struct LGL *lgl);
// lglrep
// file lglib.c line 5046
static void lglrep(struct LGL *lgl, signed int level, char type);
// lglrephead
// file lglib.c line 5028
static void lglrephead(struct LGL *lgl);
// lglrepr
// file lglib.c line 17980
signed int lglrepr(struct LGL *lgl, signed int elit);
// lglreqinit
// file lglib.c line 18994
static void lglreqinit(struct LGL *lgl);
// lglrescoreclauses
// file lglib.c line 3414
static void lglrescoreclauses(struct LGL *lgl);
// lglrescoreglue
// file lglib.c line 3392
static void lglrescoreglue(struct LGL *lgl, signed int glue);
// lglreset
// file lglib.c line 3744
static void lglreset(struct LGL *lgl);
// lglresetforked
// file lglib.c line 18920
void lglresetforked(struct LGL *lgl);
// lglresetphase
// file lglib.c line 3908
void lglresetphase(struct LGL *lgl, signed int elit);
// lglresetsmallve
// file lglib.c line 10708
static void lglresetsmallve(struct LGL *lgl);
// lglrestart
// file lglib.c line 6334
static void lglrestart(struct LGL *lgl);
// lglrestarting
// file lglib.c line 16996
static signed int lglrestarting(struct LGL *lgl);
// lglreusetrail
// file lglib.c line 6315
static signed int lglreusetrail(struct LGL *lgl);
// lglrgopts
// file lglib.c line 2125
void lglrgopts(struct LGL *lgl);
// lglrmbcls
// file lglib.c line 5668
static void lglrmbcls(struct LGL *lgl, signed int a, signed int b, signed int red);
// lglrmbindup
// file lglib.c line 15958
static void lglrmbindup(struct LGL *lgl);
// lglrmbwch
// file lglib.c line 5603
static void lglrmbwch(struct LGL *lgl, signed int lit, signed int other, signed int red);
// lglrminc
// file lglib.c line 4086
static void lglrminc(struct LGL *lgl, const signed int *w, const signed int *eow);
// lglrmlcls
// file lglib.c line 5686
static void lglrmlcls(struct LGL *lgl, signed int lidx, signed int red);
// lglrmlocc
// file lglib.c line 4363
static void lglrmlocc(struct LGL *lgl, signed int lit, signed int red, signed int lidx);
// lglrmlwch
// file lglib.c line 4210
static void lglrmlwch(struct LGL *lgl, signed int lit, signed int red, signed int lidx);
// lglrmstk
// file lglib.c line 1436
static void lglrmstk(struct Stk *s, signed int elem);
// lglrmtcls
// file lglib.c line 5676
static void lglrmtcls(struct LGL *lgl, signed int a, signed int b, signed int c, signed int red);
// lglrmtwch
// file lglib.c line 4099
static void lglrmtwch(struct LGL *lgl, signed int lit, signed int other1, signed int other2, signed int red);
// lglrmvbcls
// file lglib.c line 11792
static void lglrmvbcls(struct LGL *lgl, signed int a, signed int b);
// lglrmvtcls
// file lglib.c line 11797
static void lglrmvtcls(struct LGL *lgl, signed int a, signed int b, signed int c);
// lglrsn
// file lglib.c line 2578
static signed int * lglrsn(struct LGL *lgl, signed int lit);
// lglrstcontrol
// file lglib.c line 1574
static void lglrstcontrol(struct LGL *lgl, signed int count);
// lglrstecls
// file lglib.c line 9407
static void lglrstecls(struct LGL *lgl);
// lglrststk
// file lglib.c line 1451
static void lglrststk(struct Stk *s, signed int newsz);
// lglrsz
// file lglib.c line 1279
static void * lglrsz(struct LGL *lgl, void *ptr, unsigned long int old, unsigned long int new);
// lglrszvars
// file lglib.c line 2279
static void lglrszvars(struct LGL *lgl, signed int new_size);
// lglrtrav
// file lglib.c line 18813
void lglrtrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int, signed int));
// lglrtrav::trav_object
//
void trav_object(void *, signed int, signed int);
// lgls2fun
// file lglib.c line 10626
static void lgls2fun(signed int mlit, unsigned long int *res);
// lgls2m
// file lglib.c line 10460
static signed int lgls2m(struct LGL *lgl, signed int ilit);
// lglsat
// file lglib.h line 189
signed int lglsat(struct LGL *lgl);
// lglschedbasicprobe
// file lglib.c line 8877
static signed int lglschedbasicprobe(struct LGL *lgl, struct Stk *probes, signed int round);
// lglsearch
// file lglib.c line 17247
static signed int lglsearch(struct LGL *lgl, struct Lim *lim);
// lglsec
// file lglib.c line 4985
double lglsec(struct LGL *lgl);
// lglsetallphases
// file lglib.c line 6823
static void lglsetallphases(struct LGL *lgl);
// lglsetbinminrhs
// file lglib.c line 13045
static void lglsetbinminrhs(struct LGL *lgl, struct Gat *g);
// lglsetblklim
// file lglib.c line 11284
static void lglsetblklim(struct LGL *lgl);
// lglsetccelim
// file lglib.c line 11450
static void lglsetccelim(struct LGL *lgl);
// lglsetcgrclsrlim
// file lglib.c line 13759
static void lglsetcgrclsrlim(struct LGL *lgl);
// lglsetclifflim
// file lglib.c line 12037
static void lglsetclifflim(struct LGL *lgl);
// lglsetconsumedunits
// file lglib.c line 1360
void lglsetconsumedunits(struct LGL *lgl, void (*fun)(void *, signed int), void *state);
// lglsetconsumedunits::fun_object
//
void fun_object(void *, signed int);
// lglsetconsumeunits
// file lglib.c line 1337
void lglsetconsumeunits(struct LGL *lgl, void (*fun)(void *, signed int **, signed int **), void *state);
// lglsetconsumeunits::fun_object
//
void fun_object(void *, signed int **, signed int **);
// lglsetdom
// file lglib.c line 2582
static void lglsetdom(struct LGL *lgl, signed int lit, signed int dom);
// lglsetdonotesched
// file lglib.c line 11356
static void lglsetdonotesched(struct LGL *lgl, signed int completed);
// lglsetelmlim
// file lglib.c line 12095
static void lglsetelmlim(struct LGL *lgl);
// lglseterm
// file lglib.h line 295
void lglseterm(struct LGL *lgl, signed int (*fun)(void *), void *state);
// lglseterm::fun_object
//
signed int fun_object(void *);
// lglseternreslim
// file lglib.c line 14656
static void lglseternreslim(struct LGL *lgl);
// lglsetgausslim
// file lglib.c line 16781
static void lglsetgausslim(struct LGL *lgl);
// lglsetid
// file lglib.h line 134
void lglsetid(struct LGL *lgl, signed int tid, signed int tids);
// lglsetime
// file lglib.h line 306
void lglsetime(struct LGL *lgl, double (*time)(void));
// lglsetime::time_object
//
double time_object(void);
// lglsetiteminrhs
// file lglib.c line 13069
static void lglsetiteminrhs(struct LGL *lgl, struct Gat *g);
// lglsetjwhbias
// file lglib.c line 6809
static signed int lglsetjwhbias(struct LGL *lgl, signed int idx);
// lglsetlim
// file lglib.c line 17705
static void lglsetlim(struct LGL *lgl, struct Lim *lim);
// lglsetlockeq
// file lglib.c line 1346
void lglsetlockeq(struct LGL *lgl, signed int * (*fun)(void *), void *state);
// lglsetlockeq::fun_object
//
signed int * fun_object(void *);
// lglsetlrgminrhs
// file lglib.c line 13056
static void lglsetlrgminrhs(struct LGL *lgl, struct Gat *g);
// lglsetminrhs
// file lglib.c line 13074
static void lglsetminrhs(struct LGL *lgl, struct Gat *g);
// lglsetmsglock
// file lglib.h line 305
void lglsetmsglock(struct LGL *lgl, void (*lock)(void *), void (*unlock)(void *), void *state);
// lglsetmsglock::lock_object
//
void lock_object(void *);
// lglsetmsglock::unlock_object
//
void unlock_object(void *);
// lglsetopt
// file lglib.h line 118
void lglsetopt(struct LGL *lgl, const char *opt, signed int val);
// lglsetout
// file lglib.h line 112
void lglsetout(struct LGL *lgl, struct _IO_FILE *out);
// lglsetphase
// file lglib.c line 3899
void lglsetphase(struct LGL *lgl, signed int elit);
// lglsetphases
// file lglib.c line 17463
void lglsetphases(struct LGL *lgl);
// lglsetplain
// file lglib.c line 1652
static void lglsetplain(struct LGL *lgl, signed int val);
// lglsetprbasiclim
// file lglib.c line 8941
static void lglsetprbasiclim(struct LGL *lgl);
// lglsetprefix
// file lglib.h line 113
void lglsetprefix(struct LGL *lgl, const char *prefix);
// lglsetproduceunit
// file lglib.c line 1330
void lglsetproduceunit(struct LGL *lgl, void (*fun)(void *, signed int), void *state);
// lglsetproduceunit::fun_object
//
void fun_object(void *, signed int);
// lglsetrdlim
// file lglib.c line 14886
static void lglsetrdlim(struct LGL *lgl);
// lglsetunhdlim
// file lglib.c line 16124
static void lglsetunhdlim(struct LGL *lgl);
// lglsetunlockeq
// file lglib.c line 1353
void lglsetunlockeq(struct LGL *lgl, void (*fun)(void *, signed int, signed int), void *state);
// lglsetunlockeq::fun_object
//
void fun_object(void *, signed int, signed int);
// lglsetup
// file lglib.c line 17294
static void lglsetup(struct LGL *lgl);
// lglsgn
// file lglib.c line 2459
static signed int lglsgn(signed int lit);
// lglshrinkhts
// file lglib.c line 3029
static void lglshrinkhts(struct LGL *lgl, struct HTS *hts, signed int newcount);
// lglshrstk
// file lglib.c line 1415
static void lglshrstk(struct LGL *lgl, struct Stk *s, signed int new_size);
// lglsig
// file lglib.c line 9301
static unsigned int lglsig(signed int lit);
// lglsignedmark
// file lglib.c line 7205
static void lglsignedmark(struct LGL *lgl, signed int lit);
// lglsignedmark2
// file lglib.c line 11486
static void lglsignedmark2(struct LGL *lgl, signed int lit);
// lglsignedmarked
// file lglib.c line 7224
static signed int lglsignedmarked(struct LGL *lgl, signed int lit);
// lglsignedmarked2
// file lglib.c line 11500
static signed int lglsignedmarked2(struct LGL *lgl, signed int lit);
// lglsignedmarknpushseen
// file lglib.c line 7219
static void lglsignedmarknpushseen(struct LGL *lgl, signed int lit);
// lglsignedunmark
// file lglib.c line 7212
static void lglsignedunmark(struct LGL *lgl, signed int lit);
// lglsignedunmark2
// file lglib.c line 11493
static void lglsignedunmark2(struct LGL *lgl, signed int lit);
// lglsimp
// file lglib.c line 17875
signed int lglsimp(struct LGL *lgl, signed int iterations);
// lglsimpand
// file lglib.c line 13437
static signed int lglsimpand(struct LGL *lgl, struct Gat *g);
// lglsimpbinand
// file lglib.c line 13334
static signed int lglsimpbinand(struct LGL *lgl, struct Gat *g);
// lglsimpbinxor
// file lglib.c line 13443
static signed int lglsimpbinxor(struct LGL *lgl, struct Gat *g);
// lglsimpcls
// file lglib.c line 2969
static signed int lglsimpcls(struct LGL *lgl);
// lglsimpcntrem
// file lglib.c line 17137
static signed int lglsimpcntrem(struct LGL *lgl, signed int oldrem);
// lglsimpgate
// file lglib.c line 13608
static signed int lglsimpgate(struct LGL *lgl, struct Gat *g);
// lglsimpite
// file lglib.c line 13523
static signed int lglsimpite(struct LGL *lgl, struct Gat *g);
// lglsimpleprobebinexists
// file lglib.c line 8617
static signed int lglsimpleprobebinexists(struct LGL *lgl, signed int a, signed int b);
// lglsimpleprobeclausexists
// file lglib.c line 8703
static signed int lglsimpleprobeclausexists(struct LGL *lgl);
// lglsimpleprobelrgexists
// file lglib.c line 8663
static signed int lglsimpleprobelrgexists(struct LGL *lgl, signed int a);
// lglsimpleprobetrnexists
// file lglib.c line 8637
static signed int lglsimpleprobetrnexists(struct LGL *lgl, signed int a, signed int b, signed int c);
// lglsimplimhit
// file lglib.c line 17165
static signed int lglsimplimhit(struct LGL *lgl);
// lglsimplrgand
// file lglib.c line 13375
static signed int lglsimplrgand(struct LGL *lgl, struct Gat *g);
// lglsimplrgxor
// file lglib.c line 13479
static signed int lglsimplrgxor(struct LGL *lgl, struct Gat *g);
// lglsimpxor
// file lglib.c line 13517
static signed int lglsimpxor(struct LGL *lgl, struct Gat *g);
// lglsize2cnf
// file lglib.c line 10730
static signed long int lglsize2cnf(signed int s);
// lglsizectk
// file lglib.c line 1542
static signed int lglsizectk(struct Ctk *ctk);
// lglsizes
// file lglib.c line 18590
void lglsizes(struct LGL *lgl);
// lglsizewtk
// file lglib.c line 14991
static signed int lglsizewtk(struct Wtk *wtk);
// lglslfun
// file lglib.c line 10607
static void lglslfun(unsigned long int *a, signed int shift);
// lglsmalladdlit2cnf
// file lglib.c line 10842
static signed long int lglsmalladdlit2cnf(struct LGL *lgl, signed long int cnf, signed int lit);
// lglsmallcnfunits
// file lglib.c line 10957
static signed int lglsmallcnfunits(struct LGL *lgl, signed long int cnf);
// lglsmallevalcls
// file lglib.c line 10714
static void lglsmallevalcls(unsigned int cls, unsigned long int *res);
// lglsmallevalcnf
// file lglib.c line 10738
static void lglsmallevalcnf(struct LGL *lgl, signed long int cnf, unsigned long int *res);
// lglsmallfundeps0
// file lglib.c line 10769
static signed int lglsmallfundeps0(unsigned long int *f);
// lglsmallfundeps1
// file lglib.c line 10777
static signed int lglsmallfundeps1(unsigned long int *f);
// lglsmallfundeps2
// file lglib.c line 10785
static signed int lglsmallfundeps2(unsigned long int *f);
// lglsmallfundeps3
// file lglib.c line 10793
static signed int lglsmallfundeps3(unsigned long int *f);
// lglsmallfundeps4
// file lglib.c line 10801
static signed int lglsmallfundeps4(unsigned long int *f);
// lglsmallfundeps5
// file lglib.c line 10809
static signed int lglsmallfundeps5(unsigned long int *f);
// lglsmallfundepsgen
// file lglib.c line 10817
static signed int lglsmallfundepsgen(unsigned long int *f, signed int min);
// lglsmallipos
// file lglib.c line 10874
static signed long int lglsmallipos(struct LGL *lgl, unsigned long int *U, unsigned long int *L, signed int min);
// lglsmallirr
// file lglib.c line 9103
static signed int lglsmallirr(struct LGL *lgl);
// lglsmallisunitcls
// file lglib.c line 10943
static signed int lglsmallisunitcls(struct LGL *lgl, signed int cls);
// lglsmalltopvar
// file lglib.c line 10827
static signed int lglsmalltopvar(unsigned long int *f, signed int min);
// lglsmallve
// file lglib.c line 10911
static void lglsmallve(struct LGL *lgl, signed long int cnf);
// lglsolve
// file lglib.c line 17284
static signed int lglsolve(struct LGL *lgl, struct Lim *lim, signed int forcesimp);
// lglsparse
// file lglib.c line 9229
static void lglsparse(struct LGL *lgl);
// lglsqr
// file lglib.c line 18093
static double lglsqr(double a);
// lglsrfun
// file lglib.c line 10587
static void lglsrfun(unsigned long int *a, signed int shift);
// lglstamp
// file lglib.c line 15021
static signed int lglstamp(struct LGL *lgl, signed int root, struct DFPR *dfpr, struct DFOPF *dfopf, struct Wtk *work, struct Stk *units, struct Stk *sccs, struct Stk *trds, signed int *visitedptr, signed int stamp, signed int irronly);
// lglstampall
// file lglib.c line 16012
static struct DFPR * lglstampall(struct LGL *lgl, signed int irronly);
// lglstart
// file lglib.c line 4961
static void lglstart(struct LGL *lgl, double *timestatsptr);
// lglstats
// file lglib.h line 280
void lglstats(struct LGL *lgl);
// lglsteps
// file lglib.c line 8309
static signed long int lglsteps(struct LGL *lgl);
// lglstop
// file lglib.c line 4991
static void lglstop(struct LGL *lgl);
// lglstrdup
// file lglib.c line 1300
static char * lglstrdup(struct LGL *lgl, const char *str);
// lglsynceqs
// file lglib.c line 12204
static signed int lglsynceqs(struct LGL *lgl);
// lglsyncunits
// file lglib.c line 8333
static signed int lglsyncunits(struct LGL *lgl);
// lglsyncunits::1::produce_object
//
void produce_object(void *, signed int);
// lglszpen
// file lglib.c line 8728
static signed int lglszpen(struct LGL *lgl);
// lglszstk
// file lglib.c line 1389
static unsigned long int lglszstk(struct Stk *s);
// lgltarjan
// file lglib.c line 8194
static signed int lgltarjan(struct LGL *lgl);
// lgltd
// file lglib.c line 2334
static struct TD * lgltd(struct LGL *lgl, signed int lit);
// lglterminate
// file lglib.c line 8319
static signed int lglterminate(struct LGL *lgl);
// lglternres
// file lglib.c line 14734
static signed int lglternres(struct LGL *lgl);
// lglternresidx
// file lglib.c line 14651
static void lglternresidx(struct LGL *lgl, signed int idx);
// lglternresinit
// file lglib.c line 14706
static void lglternresinit(struct LGL *lgl);
// lglternreslit
// file lglib.c line 14550
static void lglternreslit(struct LGL *lgl, signed int lit);
// lglternresolving
// file lglib.c line 17008
static signed int lglternresolving(struct LGL *lgl);
// lgltonflict
// file lglib.c line 4021
static void lgltonflict(struct LGL *lgl, signed int lit, signed int blit, signed int other2);
// lgltopgc
// file lglib.c line 7668
static signed int lgltopgc(struct LGL *lgl);
// lgltopsimp
// file lglib.c line 17267
static signed int lgltopsimp(struct LGL *lgl, signed int forcesimp);
// lgltopstk
// file lglib.c line 1449
static signed int lgltopstk(struct Stk *s);
// lgltrail
// file lglib.c line 2332
static signed int lgltrail(struct LGL *lgl, signed int lit);
// lgltrapi
// file lglib.c line 1476
static void lgltrapi(struct LGL *lgl, const char *msg, ...);
// lgltravall
// file lglib.c line 18882
void lgltravall(struct LGL *lgl, void *state, void (*trav)(void *, signed int));
// lgltravall::trav_object
//
void trav_object(void *, signed int);
// lgltravalle
// file lglib.c line 18872
static void lgltravalle(void *voidptr, signed int lit, signed int repr);
// lgltravallu
// file lglib.c line 18866
static void lgltravallu(void *voidptr, signed int unit);
// lgltravcounter
// file lglib.c line 18795
static void lgltravcounter(void *voidptr, signed int lit);
// lgltravprinter
// file lglib.c line 18800
static void lgltravprinter(void *voidptr, signed int lit);
// lgltrd
// file lglib.c line 14908
static signed int lgltrd(struct LGL *lgl);
// lgltrdbin
// file lglib.c line 14784
static signed int lgltrdbin(struct LGL *lgl, signed int start, signed int target, signed int irr);
// lgltrdlit
// file lglib.c line 14845
static void lgltrdlit(struct LGL *lgl, signed int start);
// lgltreducing
// file lglib.c line 16949
static signed int lgltreducing(struct LGL *lgl);
// lgltruefun
// file lglib.c line 10519
static void lgltruefun(unsigned long int *res);
// lgltrylargeve
// file lglib.c line 10247
static signed int lgltrylargeve(struct LGL *lgl);
// lgltrysmallve
// file lglib.c line 10973
static signed int lgltrysmallve(struct LGL *lgl, signed int idx);
// lgluby
// file lglib.c line 5256
static signed long int lgluby(struct LGL *lgl, signed int i);
// lglubyrec
// file lglib.c line 5237
static signed long int lglubyrec(struct LGL *lgl, signed int i);
// lglulit
// file lglib.c line 2580
static signed int lglulit(signed int lit);
// lglunassign
// file lglib.c line 2759
static void lglunassign(struct LGL *lgl, signed int lit);
// lglunclone
// file lglib.c line 17616
signed int lglunclone(struct LGL *lgl, struct LGL *from);
// lglunflict
// file lglib.c line 5719
static void lglunflict(struct LGL *lgl, signed int lit);
// lglunhdfailed
// file lglib.c line 15928
static signed int lglunhdfailed(struct LGL *lgl);
// lglunhdhasbins
// file lglib.c line 14955
static signed int lglunhdhasbins(struct LGL *lgl, const struct DFPR *dfpr, signed int lit, signed int irronly);
// lglunhdhbrs
// file lglib.c line 15937
static signed int lglunhdhbrs(struct LGL *lgl);
// lglunhdisroot
// file lglib.c line 14981
static signed int lglunhdisroot(struct LGL *lgl, signed int lit, struct DFPR *dfpr, signed int irronly);
// lglunhdstrd
// file lglib.c line 15951
static signed int lglunhdstrd(struct LGL *lgl);
// lglunhdtauts
// file lglib.c line 15943
static signed int lglunhdtauts(struct LGL *lgl);
// lglunhdunits
// file lglib.c line 15921
static signed int lglunhdunits(struct LGL *lgl);
// lglunhide
// file lglib.c line 16151
static signed int lglunhide(struct LGL *lgl);
// lglunhidebintrn
// file lglib.c line 15283
static signed int lglunhidebintrn(struct LGL *lgl, const struct DFPR *dfpr, signed int irronly);
// lglunhidefailed
// file lglib.c line 15247
static signed int lglunhidefailed(struct LGL *lgl, const struct DFPR *dfpr);
// lglunhideglue
// file lglib.c line 15493
static signed int lglunhideglue(struct LGL *lgl, const struct DFPR *dfpr, signed int glue, signed int irronly);
// lglunhidelrg
// file lglib.c line 15913
static signed int lglunhidelrg(struct LGL *lgl, const struct DFPR *dfpr, signed int irronly);
// lglunhiding
// file lglib.c line 16951
static signed int lglunhiding(struct LGL *lgl);
// lglunhimpl
// file lglib.c line 10176
static signed int lglunhimpl(const struct DFPR *dfpr, signed int a, signed int b);
// lglunhimplies2
// file lglib.c line 10186
static signed int lglunhimplies2(const struct DFPR *dfpr, signed int a, signed int b);
// lglunhimplies2incl
// file lglib.c line 10200
static signed int lglunhimplies2incl(const struct DFPR *dfpr, signed int a, signed int b);
// lglunhimplincl
// file lglib.c line 10190
static signed int lglunhimplincl(const struct DFPR *dfpr, signed int a, signed int b);
// lglunhlca
// file lglib.c line 15222
static signed int lglunhlca(struct LGL *lgl, const struct DFPR *dfpr, signed int a, signed int b);
// lglunhroot
// file lglib.c line 15279
static signed int lglunhroot(const struct DFPR *dfpr, signed int lit);
// lglunit
// file lglib.c line 2932
static void lglunit(struct LGL *lgl, signed int lit);
// lglunitnocheck
// file lglib.c line 2926
static void lglunitnocheck(struct LGL *lgl, signed int lit);
// lglunmark
// file lglib.c line 2943
static void lglunmark(struct LGL *lgl, signed int lit);
// lglunuselevel
// file lglib.c line 1595
static void lglunuselevel(struct LGL *lgl, signed int level);
// lglupdblkint
// file lglib.c line 11312
static void lglupdblkint(struct LGL *lgl, signed int success);
// lglupdcceint
// file lglib.c line 11473
static void lglupdcceint(struct LGL *lgl, signed int success);
// lglupdcgrpen
// file lglib.c line 13754
static void lglupdcgrpen(struct LGL *lgl, signed int success);
// lglupdcliffint
// file lglib.c line 12059
static void lglupdcliffint(struct LGL *lgl, signed int success);
// lglupdelmint
// file lglib.c line 12122
static void lglupdelmint(struct LGL *lgl, signed int success);
// lglupdflipint
// file lglib.c line 7752
static void lglupdflipint(struct LGL *lgl);
// lglupdgausspen
// file lglib.c line 16803
static void lglupdgausspen(struct LGL *lgl, signed int success);
// lglupdlftpen
// file lglib.c line 13951
static void lglupdlftpen(struct LGL *lgl, signed int success);
// lglupdprbasicpen
// file lglib.c line 8934
static void lglupdprbasicpen(struct LGL *lgl, signed int success);
// lglupdprepint
// file lglib.c line 17092
static void lglupdprepint(struct LGL *lgl, signed int red);
// lglupdternrespen
// file lglib.c line 14684
static void lglupdternrespen(struct LGL *lgl, signed int success);
// lglupdunhdpen
// file lglib.c line 16146
static void lglupdunhdpen(struct LGL *lgl, signed int success);
// lglusage
// file lglib.c line 2096
void lglusage(struct LGL *lgl);
// lgluse
// file lglib.c line 3806
static void lgluse(struct LGL *lgl);
// lgluselevel
// file lglib.c line 1587
static void lgluselevel(struct LGL *lgl, signed int level);
// lglutrav
// file lglib.c line 18718
void lglutrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int));
// lglutrav::trav_object
//
void trav_object(void *, signed int);
// lglval
// file lglib.c line 2323
static signed char lglval(struct LGL *lgl, signed int lit);
// lglvar2fun
// file lglib.c line 10499
static void lglvar2fun(signed int v, unsigned long int *res);
// lglvar2funaux
// file lglib.c line 10477
static void lglvar2funaux(signed int v, unsigned long int *res, signed int negate);
// lglversion
// file lglbnr.c line 52
const char * lglversion(void);
// lglvmtf
// file lglib.c line 5915
static void lglvmtf(struct LGL *lgl, signed int lit);
// lglwchbin
// file lglib.c line 3132
static signed long int lglwchbin(struct LGL *lgl, signed int lit, signed int other, signed int red);
// lglwchlrg
// file lglib.c line 3153
static signed long int lglwchlrg(struct LGL *lgl, signed int lit, signed int other, signed int red, signed int lidx);
// lglwchtrn
// file lglib.c line 3142
static signed long int lglwchtrn(struct LGL *lgl, signed int a, signed int b, signed int c, signed int red);
// lglwrkcompact
// file lglib.c line 8514
static void lglwrkcompact(struct LGL *lgl);
// lglwrkdeq
// file lglib.c line 8557
static signed int lglwrkdeq(struct LGL *lgl);
// lglwrkinit
// file lglib.c line 8488
static void lglwrkinit(struct LGL *lgl, signed int posonly, signed int fifo);
// lglwrknext
// file lglib.c line 8590
static signed int lglwrknext(struct LGL *lgl);
// lglwrkpop
// file lglib.c line 8573
static signed int lglwrkpop(struct LGL *lgl);
// lglwrkreset
// file lglib.c line 8504
static void lglwrkreset(struct LGL *lgl);
// lglwrktouch
// file lglib.c line 8535
static signed int lglwrktouch(struct LGL *lgl, signed int lit);
// lglwrn
// file lglib.c line 1150
static void lglwrn(struct LGL *lgl, const char *msg, ...);
// lglws
// file lglib.c line 2199
static signed int lglws(signed int ch);
// lglwtrapi
// file lglib.c line 1506
void lglwtrapi(struct LGL *lgl, struct _IO_FILE *apitrace);
// lglxorhascls
// file lglib.c line 12718
static signed int lglxorhascls(struct LGL *lgl);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// msg
// file ilingeling.c line 133
static void msg(struct Worker *w, signed int level, const char *fmt, ...);
// msglock
// file ilingeling.c line 123
static void msglock(void *voidptr);
// msgunlock
// file ilingeling.c line 128
static void msgunlock(void *voidptr);
// next
// file ilingeling.c line 464
static signed int next(void);
// parse
// file ilingeling.c line 476
static void parse(void);
// pclose
// file /usr/include/stdio.h line 878
extern signed int pclose(struct _IO_FILE *);
// perr
// file ilingeling.c line 454
static void perr(const char *fmt, ...);
// popen
// file /usr/include/stdio.h line 872
extern struct _IO_FILE * popen(const char *, const char *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// progress
// file ilingeling.c line 196
static void progress(signed int pmille, signed int total, signed int max, double avg, signed int nl);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_2 *, const union anonymous_3 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_2 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_2 *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// raise
// file /usr/include/signal.h line 139
extern signed int raise(signed int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reset
// file ilingeling.c line 436
static void reset(void);
// resetsighandlers
// file ilingeling.c line 724
static void resetsighandlers(void);
// sat
// file ilingeling.c line 263
static signed int sat(struct Worker *w);
// setsighandlers
// file ilingeling.c line 751
static void setsighandlers(void);
// sig_abrt_handler_object
//
void sig_abrt_handler_object(signed int);
// sig_int_handler_object
//
void sig_int_handler_object(signed int);
// sig_segv_handler_object
//
void sig_segv_handler_object(signed int);
// sig_term_handler_object
//
void sig_term_handler_object(signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// start
// file ilingeling.c line 587
static void start(void);
// stats
// file ilingeling.c line 627
static void stats(void);
// statsps
// file ilingeling.c line 608
static void statsps(struct _IO_FILE *file, const char *name, signed long long int stats, double time);
// stop
// file ilingeling.c line 595
static void stop(void);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// term
// file ilingeling.c line 183
static signed int term(void *voidptr);
// tolower
// file /usr/include/ctype.h line 215
static inline signed int tolower(signed int __c);
// toupper
// file /usr/include/ctype.h line 221
static inline signed int toupper(signed int __c);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 36
static inline signed int vprintf(const char * restrict __fmt, void **__arg);
// warn
// file ilingeling.c line 157
static void warn(const char *fmt, ...);
// work
// file ilingeling.c line 350
static void * work(void *voidptr);

struct anonymous_93
{
  // fun
  signed int * (*fun)(void *);
  // state
  void *state;
};

struct anonymous_89
{
  // fun
  signed int (*fun)(void *);
  // state
  void *state;
  // done
  signed int done;
};

struct anonymous_56
{
  // cls
  signed int *cls;
  // origlhs
  signed int origlhs;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_2
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_1
{
  // lgl
  struct LGL *lgl;
  // count
  signed int count;
  // bcount
  signed int bcount;
  // decs
  signed long int decs;
  // confs
  signed long int confs;
  // props
  signed long int props;
  // lock
  union anonymous_2 lock;
};

struct anonymous_96
{
  // lock
  void (*lock)(void *);
  // unlock
  void (*unlock)(void *);
  // state
  void *state;
};

struct anonymous_91
{
  // fun
  void (*fun)(void *, signed int **, signed int **);
  // state
  void *state;
};

struct anonymous_90
{
  // fun
  void (*fun)(void *, signed int);
  // state
  void *state;
};

struct anonymous_94
{
  // fun
  void (*fun)(void *, signed int, signed int);
  // state
  void *state;
};

struct anonymous_76
{
  // all
  double all;
  // basic
  double basic;
};

struct anonymous_63
{
  // all
  signed int all;
  // and
  signed int and;
  // xor
  signed int xor;
  // ite
  signed int ite;
};

struct anonymous_98
{
  // all
  signed int all;
  // and
  signed int and;
  // xor
  signed int xor;
  // ite
  signed int ite;
  // org
  signed int org;
};

struct anonymous_83
{
  // basic
  signed int basic;
};

struct anonymous_15
{
  // bin
  signed int bin;
  // trn
  signed int trn;
  // lrg
  signed int lrg;
};

struct anonymous_68
{
  // bin
  signed int bin;
  // trn
  signed int trn;
  // lrg
  signed int lrg;
  // red
  signed int red;
};

struct anonymous_6
{
  // clauses
  signed int clauses;
};

struct anonymous_30
{
  // clauses
  signed int clauses;
  // added
  signed long int added;
  // reduced
  signed long int reduced;
  // resolved
  signed long int resolved;
  // forcing
  signed long int forcing;
  // conflicts
  signed long int conflicts;
  // saved
  signed long int saved;
};

struct anonymous_16
{
  // cnt
  signed int cnt;
  // trn
  signed int trn;
  // lrg
  signed int lrg;
  // sub
  signed int sub;
};

struct anonymous_57
{
  // cond
  signed int cond;
  // pos
  signed int pos;
  // neg
  signed int neg;
};

struct anonymous_18
{
  // count
  signed int count;
  // bin
  signed int bin;
  // trn
  signed int trn;
  // steps
  signed long int steps;
};

struct anonymous_19
{
  // count
  signed int count;
  // clauses
  signed int clauses;
  // lits
  signed int lits;
  // pure
  signed int pure;
  // res
  signed long int res;
  // steps
  signed long int steps;
};

struct anonymous_37
{
  // count
  signed int count;
  // eliminated
  signed int eliminated;
  // ate
  signed int ate;
  // abce
  signed int abce;
  // failed
  signed int failed;
  // lifted
  signed int lifted;
  // steps
  signed long int steps;
  // probed
  signed long int probed;
};

struct anonymous_70
{
  // elm
  signed int elm;
  // tried
  signed int tried;
  // failed
  signed int failed;
};

struct anonymous_26
{
  // count
  signed int count;
  // elmd
  signed int elmd;
  // large
  signed int large;
  // sub
  signed int sub;
  // str
  signed int str;
  // blkd
  signed int blkd;
  // small
  struct anonymous_70 small;
  // resolutions
  signed long int resolutions;
  // copies
  signed long int copies;
  // subchks
  signed long int subchks;
  // strchks
  signed long int strchks;
  // ipos
  signed long int ipos;
  // steps
  signed long int steps;
};

struct anonymous_64
{
  // all
  signed long int all;
  // and
  signed long int and;
  // xor
  signed long int xor;
  // ite
  signed long int ite;
};

struct anonymous_20
{
  // count
  signed int count;
  // eq
  signed int eq;
  // units
  signed int units;
  // esteps
  signed long int esteps;
  // csteps
  signed long int csteps;
  // matched
  struct anonymous_63 matched;
  // simplified
  struct anonymous_63 simplified;
  // extracted
  struct anonymous_64 extracted;
};

struct anonymous_22
{
  // count
  signed int count;
  // eqs
  signed int eqs;
  // units
  signed int units;
  // impls
  signed int impls;
  // probed0
  signed long int probed0;
  // probed1
  signed long int probed1;
};

struct anonymous_38
{
  // count
  signed int count;
  // failed
  signed int failed;
  // lifted
  signed int lifted;
  // decisions
  signed long int decisions;
  // steps
  signed long int steps;
};

struct anonymous_65
{
  // count
  signed int count;
  // failed
  signed int failed;
  // lifted
  signed int lifted;
  // probed
  signed long int probed;
  // steps
  signed long int steps;
};

struct anonymous_72
{
  // max
  signed int max;
  // sum
  signed long int sum;
};

struct anonymous_73
{
  // extr
  signed long int extr;
  // elim
  signed long int elim;
};

struct anonymous_36
{
  // count
  signed int count;
  // gcs
  signed int gcs;
  // units
  signed int units;
  // equivs
  signed int equivs;
  // trneqs
  signed int trneqs;
  // arity
  struct anonymous_72 arity;
  // steps
  struct anonymous_73 steps;
  // extracted
  signed long int extracted;
};

struct anonymous_33
{
  // count
  signed int count;
  // plimhit
  signed int plimhit;
  // ilimhit
  signed int ilimhit;
  // climhit
  signed int climhit;
};

struct anonymous_23
{
  // count
  signed int count;
  // red
  signed int red;
  // failed
  signed int failed;
  // lits
  signed long int lits;
  // bins
  signed long int bins;
  // steps
  signed long int steps;
};

struct anonymous_8
{
  // count
  signed int count;
  // reset
  signed int reset;
  // geom
  signed int geom;
  // arith
  signed int arith;
  // arith2
  signed int arith2;
};

struct anonymous_66
{
  // trds
  signed int trds;
  // failed
  signed int failed;
  // sccs
  signed int sccs;
  // sumsccsizes
  signed long int sumsccsizes;
};

struct anonymous_67
{
  // lits
  signed int lits;
  // bin
  signed int bin;
  // trn
  signed int trn;
  // lrg
  signed int lrg;
};

struct anonymous_69
{
  // trn
  signed int trn;
  // lrg
  signed int lrg;
  // red
  signed int red;
};

struct anonymous_25
{
  // count
  signed int count;
  // rounds
  signed int rounds;
  // stamp
  struct anonymous_66 stamp;
  // failed
  struct anonymous_67 failed;
  // tauts
  struct anonymous_68 tauts;
  // units
  struct anonymous_15 units;
  // hbrs
  struct anonymous_69 hbrs;
  // str
  struct anonymous_69 str;
  // steps
  signed long int steps;
};

struct anonymous_4
{
  // count
  signed int count;
  // sum
  signed long int sum;
};

struct anonymous_7
{
  // count
  signed int count;
  // skipped
  signed int skipped;
  // kept
  struct anonymous_4 kept;
};

struct anonymous_32
{
  // count
  signed int count;
  // set
  signed long int set;
  // pos
  signed long int pos;
  // neg
  signed long int neg;
};

struct anonymous_34
{
  // count
  signed int count;
  // steps
  signed long int steps;
};

struct anonymous_40
{
  // cur
  signed int cur;
  // max
  signed int max;
  // add
  signed long int add;
};

struct anonymous_17
{
  // current
  signed int current;
  // sum
  signed int sum;
};

struct anonymous_77
{
  // inner
  signed int inner;
  // outer
  signed int outer;
  // extra
  signed int extra;
};

struct anonymous_75
{
  // irr
  signed int irr;
  // red
  signed int red;
};

struct anonymous_59
{
  // max
  signed int max;
  // min
  signed int min;
};

struct anonymous_74
{
  // min
  signed int min;
  // avg
  signed int avg;
  // max
  signed int max;
};

struct anonymous_78
{
  // pen
  signed int pen;
  // esteps
  signed long int esteps;
  // csteps
  signed long int csteps;
};

struct anonymous_80
{
  // pen
  signed int pen;
  // steps
  signed long int steps;
};

struct anonymous_79
{
  // pen
  signed int pen;
  // steps
  signed long int steps;
  // irrprgss
  signed long int irrprgss;
};

struct anonymous_81
{
  // pen
  signed int pen;
  // steps
  struct anonymous_73 steps;
};

struct anonymous_24
{
  // removed
  signed int removed;
  // red
  signed int red;
};

struct anonymous_60
{
  // total
  signed int total;
  // pos
  signed int pos;
  // neg
  signed int neg;
};

struct anonymous_61
{
  // total
  signed int total;
  // unit
  signed int unit;
  // bin
  signed int bin;
  // trn
  signed int trn;
  // lrg
  signed int lrg;
};

struct anonymous_97
{
  // units
  signed int units;
  // eq
  signed int eq;
  // all
  signed int all;
  // and
  signed int and;
  // xor
  signed int xor;
  // ite
  signed int ite;
  // org
  signed int org;
};

struct anonymous_62
{
  // val
  struct anonymous_74 val;
  // var
  struct anonymous_74 var;
};

struct anonymous_11
{
  // vars
  signed int vars;
  // lits
  struct anonymous_60 lits;
  // clauses
  struct anonymous_61 clauses;
  // cog
  struct anonymous_62 cog;
};

struct anonymous_39
{
  // bin
  signed long int bin;
  // trn
  signed long int trn;
};

struct anonymous_82
{
  // confs
  signed long int confs;
  // wasmaxdelta
  signed int wasmaxdelta;
  // maxdelta
  signed int maxdelta;
  // luby
  signed int luby;
  // inout
  signed int inout;
};

struct anonymous_5
{
  // count
  signed long int count;
  // mincut
  struct anonymous_59 mincut;
};

struct anonymous_88
{
  // fixed
  signed long int fixed;
};

struct anonymous_85
{
  // irr
  signed long int irr;
  // prgss
  signed long int prgss;
  // confs
  signed long int confs;
  // cinc
  signed long int cinc;
  // pen
  signed int pen;
};

struct anonymous_29
{
  // learned
  signed long int learned;
  // glue
  signed long int glue;
  // nonmaxglue
  signed long int nonmaxglue;
  // maxglue
  signed long int maxglue;
  // scglue
  signed long int scglue;
};

struct anonymous_31
{
  // sum
  signed long int sum;
  // count
  signed int count;
};

struct anonymous_35
{
  // new
  signed long int new;
  // del
  signed long int del;
  // merged
  signed long int merged;
  // col
  signed long int col;
  // gcs
  signed long int gcs;
  // deprior
  struct anonymous_31 deprior;
  // max
  signed int max;
};

struct anonymous_28
{
  // nonmin
  signed long int nonmin;
  // learned
  signed long int learned;
};

struct anonymous_86
{
  // pshwchs
  signed long int pshwchs;
  // prgss
  signed long int prgss;
};

struct anonymous_10
{
  // sat
  signed long int sat;
  // mosat
  signed long int mosat;
  // simp
  signed long int simp;
  // deref
  signed long int deref;
  // fixed
  signed long int fixed;
  // freeze
  signed long int freeze;
  // melt
  signed long int melt;
  // add
  signed long int add;
  // assume
  signed long int assume;
  // cassume
  signed long int cassume;
  // failed
  signed long int failed;
  // repr
  signed long int repr;
};

struct anonymous_12
{
  // search
  signed long int search;
  // hits
  signed long int hits;
};

struct anonymous_13
{
  // search
  signed long int search;
  // simp
  signed long int simp;
  // lkhd
  signed long int lkhd;
};

struct anonymous_87
{
  // steps
  signed long int steps;
};

struct anonymous_84
{
  // steps
  signed long int steps;
  // pen
  struct anonymous_83 pen;
};

struct anonymous_95
{
  // lock
  struct anonymous_93 lock;
  // unlock
  struct anonymous_94 unlock;
};

struct anonymous_92
{
  // produce
  struct anonymous_90 produce;
  // consumed
  struct anonymous_90 consumed;
  // consume
  struct anonymous_91 consume;
};

struct anonymous_21
{
  // basic
  struct anonymous_65 basic;
};

struct anonymous_9
{
  // clauses
  struct anonymous_40 clauses;
  // lits
  struct anonymous_40 lits;
};

struct anonymous_71
{
  // dyn
  struct anonymous_75 dyn;
};

struct anonymous_27
{
  // sub
  struct anonymous_71 sub;
  // str
  struct anonymous_71 str;
  // driving
  signed int driving;
  // restarting
  signed int restarting;
};

struct Stk
{
  // start
  signed int *start;
  // top
  signed int *top;
  // end
  signed int *end;
};

struct anonymous_99
{
  // bin
  struct Stk bin;
  // trn
  struct Stk trn;
};

struct anonymous_14
{
  // current
  unsigned long int current;
  // max
  unsigned long int max;
};

union anonymous
{
  // elm
  struct Elm *elm;
  // cgr
  struct Cgr *cgr;
  // gauss
  struct Gauss *gauss;
  // cce
  struct CCE *cce;
  // cliff
  struct Cliff *cliff;
};

union anonymous_55
{
  // lits
  signed int lits[2l];
  // _anon0
  struct anonymous_56 _anon0;
  // _anon1
  struct anonymous_57 _anon1;
};

union anonymous_3
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_58
{
  // lit
  signed int lit;
  // sign
  signed int sign;
};

union anonymous_43
{
  // ru_idrss
  signed long int ru_idrss;
  // __ru_idrss_word
  signed long int __ru_idrss_word;
};

union anonymous_48
{
  // ru_inblock
  signed long int ru_inblock;
  // __ru_inblock_word
  signed long int __ru_inblock_word;
};

union anonymous_44
{
  // ru_isrss
  signed long int ru_isrss;
  // __ru_isrss_word
  signed long int __ru_isrss_word;
};

union anonymous_42
{
  // ru_ixrss
  signed long int ru_ixrss;
  // __ru_ixrss_word
  signed long int __ru_ixrss_word;
};

union anonymous_46
{
  // ru_majflt
  signed long int ru_majflt;
  // __ru_majflt_word
  signed long int __ru_majflt_word;
};

union anonymous_41
{
  // ru_maxrss
  signed long int ru_maxrss;
  // __ru_maxrss_word
  signed long int __ru_maxrss_word;
};

union anonymous_45
{
  // ru_minflt
  signed long int ru_minflt;
  // __ru_minflt_word
  signed long int __ru_minflt_word;
};

union anonymous_51
{
  // ru_msgrcv
  signed long int ru_msgrcv;
  // __ru_msgrcv_word
  signed long int __ru_msgrcv_word;
};

union anonymous_50
{
  // ru_msgsnd
  signed long int ru_msgsnd;
  // __ru_msgsnd_word
  signed long int __ru_msgsnd_word;
};

union anonymous_54
{
  // ru_nivcsw
  signed long int ru_nivcsw;
  // __ru_nivcsw_word
  signed long int __ru_nivcsw_word;
};

union anonymous_52
{
  // ru_nsignals
  signed long int ru_nsignals;
  // __ru_nsignals_word
  signed long int __ru_nsignals_word;
};

union anonymous_47
{
  // ru_nswap
  signed long int ru_nswap;
  // __ru_nswap_word
  signed long int __ru_nswap_word;
};

union anonymous_53
{
  // ru_nvcsw
  signed long int ru_nvcsw;
  // __ru_nvcsw_word
  signed long int __ru_nvcsw_word;
};

union anonymous_49
{
  // ru_oublock
  signed long int ru_oublock;
  // __ru_oublock_word
  signed long int __ru_oublock_word;
};

union anonymous_0
{
  // lcaseen
  struct Stk lcaseen;
  // sortstk
  struct Stk sortstk;
  // resolvent
  struct Stk resolvent;
};

struct ASL
{
  // act
  signed int act;
  // size
  signed int size;
  // lidx
  signed int lidx;
};

struct AVar
{
  // type
  unsigned int type : 4;
  // equiv
  unsigned int equiv : 1;
  // lcamark
  unsigned int lcamark : 4;
  // phase
  signed int phase : 2;
  // bias
  signed int bias : 2;
  // fase
  signed int fase : 2;
  // poisoned
  unsigned int poisoned : 1;
  // assumed
  unsigned int assumed : 2;
  // failed
  unsigned int failed : 2;
  // gate
  unsigned int gate : 1;
  // donotelm
  unsigned int donotelm : 1;
  // donotblk
  unsigned int donotblk : 1;
  // donotcgrcls
  unsigned int donotcgrcls : 1;
  // donotlft
  unsigned int donotlft : 1;
  // donoternres
  unsigned int donoternres : 1;
  // donotbasicprobe
  unsigned int donotbasicprobe : 1;
  // donotcce
  unsigned int donotcce : 1;
  // mark
  signed int mark;
  // trail
  signed int trail;
};

struct CCE
{
  // cla
  struct Stk cla;
  // extend
  struct Stk extend;
  // rem
  signed int *rem;
};

struct Cbs
{
  // term
  struct anonymous_89 term;
  // units
  struct anonymous_92 units;
  // eqs
  struct anonymous_95 eqs;
  // msglock
  struct anonymous_96 msglock;
  // getime
  double (*getime)(void);
  // onabort
  void (*onabort)(void *);
  // abortstate
  void *abortstate;
};

struct Cgr
{
  // extracted
  struct anonymous_97 extracted;
  // simplified
  struct anonymous_98 simplified;
  // matched
  struct anonymous_98 matched;
  // goccs
  struct Stk *goccs;
  // units
  struct Stk units;
  // gates
  struct Gat *gates;
  // szgates
  signed int szgates;
};

struct Cliff
{
  // lift
  struct Stk lift;
  // lits
  struct Stk lits;
};

struct Conf
{
  // lit
  signed int lit;
  // rsn
  signed int rsn[2l];
};

struct Ctk
{
  // start
  struct Ctr *start;
  // top
  struct Ctr *top;
  // end
  struct Ctr *end;
};

struct Ctr
{
  // decision
  signed int decision : 31;
  // used
  unsigned int used : 1;
};

struct DFL
{
  // discovered
  signed int discovered;
  // finished
  signed int finished;
  // _anon0
  union anonymous_58 _anon0;
};

struct DFOPF
{
  // observed
  signed int observed;
  // pushed
  signed int pushed;
  // flag
  signed int flag;
};

struct DFPR
{
  // discovered
  signed int discovered;
  // finished
  signed int finished;
  // parent
  signed int parent;
  // root
  signed int root;
};

struct HTS
{
  // offset
  signed int offset;
  // count
  signed int count;
};

struct DVar
{
  // hts
  struct HTS hts[2l];
};

struct Dis
{
  // red
  struct anonymous_99 red;
  // irr
  struct anonymous_99 irr;
};

struct EVar
{
  // occ
  signed int occ[2l];
  // pos
  signed int pos;
  // score
  signed int score;
};

struct Elm
{
  // pivot
  signed int pivot;
  // negcls
  signed int negcls;
  // necls
  signed int necls;
  // neglidx
  signed int neglidx;
  // lits
  struct Stk lits;
  // next
  struct Stk next;
  // clv
  struct Stk clv;
  // csigs
  struct Stk csigs;
  // lsigs
  struct Stk lsigs;
  // sizes
  struct Stk sizes;
  // occs
  struct Stk occs;
  // noccs
  struct Stk noccs;
  // mark
  struct Stk mark;
  // m2i
  struct Stk m2i;
};

struct Ext
{
  // equiv
  unsigned int equiv : 1;
  // melted
  unsigned int melted : 1;
  // blocking
  unsigned int blocking : 2;
  // eliminated
  unsigned int eliminated : 1;
  // tmpfrozen
  unsigned int tmpfrozen : 1;
  // imported
  unsigned int imported : 1;
  // assumed
  unsigned int assumed : 2;
  // failed
  unsigned int failed : 2;
  // val
  signed int val : 2;
  // oldval
  signed int oldval : 2;
  // repr
  signed int repr;
  // frozen
  signed int frozen;
  // cog
  struct anonymous_4 cog;
};

struct FltStr
{
  // current
  signed int current;
  // str
  char str[6l][100l];
};

struct ForceData
{
  // pos
  signed int pos;
  // count
  signed int count;
  // sum
  double sum;
};

struct Gat
{
  // lhs
  signed int lhs;
  // minrhs
  signed int minrhs;
  // tag
  unsigned int tag : 2;
  // mark
  unsigned int mark : 1;
  // size
  signed int size : 29;
  // _anon0
  union anonymous_55 _anon0;
};

struct Gauss
{
  // xors
  struct Stk xors;
  // order
  struct Stk order;
  // occs
  struct Stk *occs;
  // eliminated
  signed char *eliminated;
  // garbage
  signed int garbage;
  // next
  signed int next;
};

struct ITEC
{
  // other
  signed int other;
  // other2
  signed int other2;
};

struct RNG
{
  // z
  unsigned int z;
  // w
  unsigned int w;
};

struct Queue
{
  // bottom
  struct Qln *bottom;
  // top
  struct Qln *top;
  // unassigned
  struct Qln *unassigned;
  // merged
  struct Qln *merged;
  // free
  struct Qln *free;
  // nodes
  struct Qnd *nodes;
  // nmerged
  signed int nmerged;
  // nlines
  signed int nlines;
};

struct LGL
{
  // state
  enum State state;
  // probing
  signed int probing;
  // flipping
  signed int flipping;
  // notflipped
  signed int notflipped;
  // tid
  signed int tid;
  // tids
  signed int tids;
  // bias
  signed int bias;
  // phaseneg
  signed int phaseneg;
  // nvars
  signed int nvars;
  // szvars
  signed int szvars;
  // maxext
  signed int maxext;
  // szext
  signed int szext;
  // changed
  signed int changed;
  // mt
  signed int mt;
  // szdrail
  signed int szdrail;
  // bnext
  signed int bnext;
  // next
  signed int next;
  // next2
  signed int next2;
  // flushed
  signed int flushed;
  // level
  signed int level;
  // alevel
  signed int alevel;
  // unassigned
  signed int unassigned;
  // lrgluereasons
  signed int lrgluereasons;
  // failed
  signed int failed;
  // assumed
  signed int assumed;
  // cassumed
  signed int cassumed;
  // ncassumed
  signed int ncassumed;
  // cgrclosing
  char cgrclosing;
  // searching
  char searching;
  // simp
  char simp;
  // allphaseset
  char allphaseset;
  // flushphases
  char flushphases;
  // forked
  char forked;
  // bruteforked
  char bruteforked;
  // qscheduling
  char qscheduling;
  // decomposing
  char decomposing;
  // lifting
  char lifting;
  // cceing
  char cceing;
  // gaussing
  char gaussing;
  // cliffing
  char cliffing;
  // unhiding
  char unhiding;
  // basicprobing
  char basicprobing;
  // eliminating
  char eliminating;
  // donotsched
  char donotsched;
  // blocking
  char blocking;
  // ternresing
  char ternresing;
  // lkhd
  char lkhd;
  // blkall
  char blkall;
  // blkrem
  char blkrem;
  // elmall
  char elmall;
  // elmrem
  char elmrem;
  // cceall
  char cceall;
  // ccerem
  char ccerem;
  // frozen
  char frozen;
  // dense
  char dense;
  // notfullyconnected
  char notfullyconnected;
  // forcegc
  char forcegc;
  // allowforce
  char allowforce;
  // flips
  unsigned long long int flips;
  // conf
  struct Conf conf;
  // rng
  struct RNG rng;
  // mem
  struct Mem *mem;
  // opts
  struct Opts *opts;
  // stats
  struct Stats *stats;
  // times
  struct Times *times;
  // timers
  struct Tmrs *timers;
  // limits
  struct Limits *limits;
  // ext
  struct Ext *ext;
  // i2e
  signed int *i2e;
  // doms
  signed int *doms;
  // dvars
  struct DVar *dvars;
  // avars
  struct AVar *avars;
  // vals
  signed char *vals;
  // jwh
  signed long int *jwh;
  // drail
  struct TD *drail;
  // queue
  struct Queue queue;
  // red
  struct Stk *red;
  // wchs
  struct Wchs *wchs;
  // control
  struct Ctk control;
  // clause
  struct Stk clause;
  // eclause
  struct Stk eclause;
  // extend
  struct Stk extend;
  // irr
  struct Stk irr;
  // trail
  struct Stk trail;
  // frames
  struct Stk frames;
  // eassume
  struct Stk eassume;
  // assume
  struct Stk assume;
  // cassume
  struct Stk cassume;
  // fassume
  struct Stk fassume;
  // _anon0
  union anonymous _anon0;
  // _anon1
  union anonymous_0 _anon1;
  // poisoned
  struct Stk poisoned;
  // seen
  struct Stk seen;
  // esched
  struct Stk esched;
  // evars
  struct EVar *evars;
  // dis
  struct Dis *dis;
  // wrk
  struct Wrk *wrk;
  // repr
  signed int *repr;
  // closeapitrace
  char closeapitrace;
  // out
  struct _IO_FILE *out;
  // apitrace
  struct _IO_FILE *apitrace;
  // prefix
  char *prefix;
  // cbs
  struct Cbs *cbs;
  // clone
  struct LGL *clone;
  // fltstr
  struct FltStr *fltstr;
};

struct Lim
{
  // confs
  signed long int confs;
  // decs
  signed long int decs;
};

struct Limits
{
  // flipint
  signed int flipint;
  // lkhdpen
  signed int lkhdpen;
  // randec
  signed long int randec;
  // reduce
  struct anonymous_77 reduce;
  // cgr
  struct anonymous_78 cgr;
  // elm
  struct anonymous_79 elm;
  // blk
  struct anonymous_79 blk;
  // cliff
  struct anonymous_79 cliff;
  // trd
  struct anonymous_80 trd;
  // unhd
  struct anonymous_80 unhd;
  // trnr
  struct anonymous_80 trnr;
  // lft
  struct anonymous_80 lft;
  // cce
  struct anonymous_80 cce;
  // gauss
  struct anonymous_81 gauss;
  // restart
  struct anonymous_82 restart;
  // prb
  struct anonymous_84 prb;
  // simp
  struct anonymous_85 simp;
  // dfg
  struct anonymous_86 dfg;
  // term
  struct anonymous_87 term;
  // sync
  struct anonymous_87 sync;
  // gc
  struct anonymous_88 gc;
};

struct Mem
{
  // state
  void *state;
  // alloc
  void * (*alloc)(void *, unsigned long int);
  // realloc
  void * (*realloc)(void *, void *, unsigned long int, unsigned long int);
  // dealloc
  void (*dealloc)(void *, void *, unsigned long int);
};

struct Opt
{
  // shrt
  char shrt;
  // lng
  const char *lng;
  // descrp
  const char *descrp;
  // val
  signed int val;
  // min
  signed int min;
  // max
  signed int max;
};

struct Opts
{
  // beforefirst
  struct Opt beforefirst;
  // abstime
  struct Opt abstime;
  // acts
  struct Opt acts;
  // actavgmax
  struct Opt actavgmax;
  // actstdmin
  struct Opt actstdmin;
  // actstdmax
  struct Opt actstdmax;
  // agile
  struct Opt agile;
  // bias
  struct Opt bias;
  // block
  struct Opt block;
  // blkrtc
  struct Opt blkrtc;
  // blkclslim
  struct Opt blkclslim;
  // blkocclim
  struct Opt blkocclim;
  // blkmaxeff
  struct Opt blkmaxeff;
  // blkmineff
  struct Opt blkmineff;
  // blkreleff
  struct Opt blkreleff;
  // card
  struct Opt card;
  // cce
  struct Opt cce;
  // ccemaxeff
  struct Opt ccemaxeff;
  // ccemineff
  struct Opt ccemineff;
  // ccereleff
  struct Opt ccereleff;
  // check
  struct Opt check;
  // cgrclsr
  struct Opt cgrclsr;
  // cgrmaxority
  struct Opt cgrmaxority;
  // cgrmaxeff
  struct Opt cgrmaxeff;
  // cgrmineff
  struct Opt cgrmineff;
  // cgreleff
  struct Opt cgreleff;
  // cgrexteq
  struct Opt cgrexteq;
  // cgrextand
  struct Opt cgrextand;
  // cgrextunits
  struct Opt cgrextunits;
  // cgrextite
  struct Opt cgrextite;
  // cgrextxor
  struct Opt cgrextxor;
  // cliff
  struct Opt cliff;
  // cliffreleff
  struct Opt cliffreleff;
  // cliffmineff
  struct Opt cliffmineff;
  // cliffmaxeff
  struct Opt cliffmaxeff;
  // compact
  struct Opt compact;
  // decompose
  struct Opt decompose;
  // defragint
  struct Opt defragint;
  // defragfree
  struct Opt defragfree;
  // elim
  struct Opt elim;
  // elmrtc
  struct Opt elmrtc;
  // elmblk
  struct Opt elmblk;
  // elmclslim
  struct Opt elmclslim;
  // elmocclim
  struct Opt elmocclim;
  // elmaxeff
  struct Opt elmaxeff;
  // elmineff
  struct Opt elmineff;
  // elmreleff
  struct Opt elmreleff;
  // sleeponabort
  struct Opt sleeponabort;
  // exitonabort
  struct Opt exitonabort;
  // flipping
  struct Opt flipping;
  // flipint
  struct Opt flipint;
  // flipdur
  struct Opt flipdur;
  // fliptop
  struct Opt fliptop;
  // force
  struct Opt force;
  // gauss
  struct Opt gauss;
  // gaussextrall
  struct Opt gaussextrall;
  // gaussmaxor
  struct Opt gaussmaxor;
  // gaussexptrn
  struct Opt gaussexptrn;
  // gaussmaxeff
  struct Opt gaussmaxeff;
  // gaussmineff
  struct Opt gaussmineff;
  // gaussreleff
  struct Opt gaussreleff;
  // gluescale
  struct Opt gluescale;
  // gluekeep
  struct Opt gluekeep;
  // inprocessing
  struct Opt inprocessing;
  // cintinc
  struct Opt cintinc;
  // irrlim
  struct Opt irrlim;
  // lift
  struct Opt lift;
  // lftmaxeff
  struct Opt lftmaxeff;
  // lftmineff
  struct Opt lftmineff;
  // lftreleff
  struct Opt lftreleff;
  // lhbr
  struct Opt lhbr;
  // lkhd
  struct Opt lkhd;
  // clim
  struct Opt clim;
  // mocint
  struct Opt mocint;
  // move
  struct Opt move;
  // log
  struct Opt log;
  // otfs
  struct Opt otfs;
  // phase
  struct Opt phase;
  // phaseneginit
  struct Opt phaseneginit;
  // plain
  struct Opt plain;
  // probe
  struct Opt probe;
  // prbasicmaxeff
  struct Opt prbasicmaxeff;
  // prbasicmineff
  struct Opt prbasicmineff;
  // prbasicreleff
  struct Opt prbasicreleff;
  // prbasic
  struct Opt prbasic;
  // prbasicroundlim
  struct Opt prbasicroundlim;
  // queuemergelim
  struct Opt queuemergelim;
  // queuefactor
  struct Opt queuefactor;
  // queueinc
  struct Opt queueinc;
  // rmincpen
  struct Opt rmincpen;
  // seed
  struct Opt seed;
  // smallirr
  struct Opt smallirr;
  // smallve
  struct Opt smallve;
  // smallvevars
  struct Opt smallvevars;
  // randec
  struct Opt randec;
  // randecint
  struct Opt randecint;
  // redfixed
  struct Opt redfixed;
  // redlbound
  struct Opt redlbound;
  // redlexpfac
  struct Opt redlexpfac;
  // redldoutfac
  struct Opt redldoutfac;
  // redloutinc
  struct Opt redloutinc;
  // redlinit
  struct Opt redlinit;
  // redlinc
  struct Opt redlinc;
  // redinoutinc
  struct Opt redinoutinc;
  // redlmininc
  struct Opt redlmininc;
  // redlmaxinc
  struct Opt redlmaxinc;
  // redlminrel
  struct Opt redlminrel;
  // redlmaxrel
  struct Opt redlmaxrel;
  // redlminabs
  struct Opt redlminabs;
  // redlmaxabs
  struct Opt redlmaxabs;
  // reduce
  struct Opt reduce;
  // restart
  struct Opt restart;
  // restartint
  struct Opt restartint;
  // rstinoutinc
  struct Opt rstinoutinc;
  // simplify
  struct Opt simplify;
  // simpdelay
  struct Opt simpdelay;
  // simpen
  struct Opt simpen;
  // sizepen
  struct Opt sizepen;
  // sizemaxpen
  struct Opt sizemaxpen;
  // sortlits
  struct Opt sortlits;
  // syncint
  struct Opt syncint;
  // termint
  struct Opt termint;
  // ternres
  struct Opt ternres;
  // ternresrtc
  struct Opt ternresrtc;
  // trnrmineff
  struct Opt trnrmineff;
  // trnrmaxeff
  struct Opt trnrmaxeff;
  // trnreleff
  struct Opt trnreleff;
  // transred
  struct Opt transred;
  // trdmineff
  struct Opt trdmineff;
  // trdmaxeff
  struct Opt trdmaxeff;
  // trdreleff
  struct Opt trdreleff;
  // unhide
  struct Opt unhide;
  // unhdextstamp
  struct Opt unhdextstamp;
  // unhdhbr
  struct Opt unhdhbr;
  // unhdmaxeff
  struct Opt unhdmaxeff;
  // unhdmineff
  struct Opt unhdmineff;
  // unhdreleff
  struct Opt unhdreleff;
  // unhdlnpr
  struct Opt unhdlnpr;
  // unhdroundlim
  struct Opt unhdroundlim;
  // verbose
  struct Opt verbose;
  // witness
  struct Opt witness;
  // afterlast
  struct Opt afterlast;
};

struct Qln
{
  // prior
  signed int prior;
  // first
  signed int first;
  // last
  signed int last;
  // unassigned
  signed int unassigned;
  // up
  struct Qln *up;
  // down
  struct Qln *down;
  // repr
  struct Qln *repr;
};

struct Qnd
{
  // prev
  signed int prev;
  // next
  signed int next;
  // line
  struct Qln *line;
};

struct Stats
{
  // defrags
  signed int defrags;
  // iterations
  signed int iterations;
  // acts
  signed int acts;
  // reported
  signed int reported;
  // gcs
  signed int gcs;
  // decomps
  signed int decomps;
  // force
  struct anonymous_5 force;
  // rescored
  struct anonymous_6 rescored;
  // restarts
  struct anonymous_7 restarts;
  // reduced
  struct anonymous_8 reduced;
  // prgss
  signed long int prgss;
  // irrprgss
  signed long int irrprgss;
  // enlwchs
  signed long int enlwchs;
  // pshwchs
  signed long int pshwchs;
  // height
  signed long int height;
  // dense
  signed long int dense;
  // sparse
  signed long int sparse;
  // confs
  signed long int confs;
  // decisions
  signed long int decisions;
  // randecs
  signed long int randecs;
  // flipped
  signed long int flipped;
  // fliphases
  signed long int fliphases;
  // uips
  signed long int uips;
  // irr
  struct anonymous_9 irr;
  // calls
  struct anonymous_10 calls;
  // features
  struct anonymous_11 features;
  // poison
  struct anonymous_12 poison;
  // props
  struct anonymous_13 props;
  // visits
  struct anonymous_13 visits;
  // bytes
  struct anonymous_14 bytes;
  // red
  struct anonymous_15 red;
  // hbr
  struct anonymous_16 hbr;
  // fixed
  struct anonymous_17 fixed;
  // equiv
  struct anonymous_17 equiv;
  // trnr
  struct anonymous_18 trnr;
  // blk
  struct anonymous_19 blk;
  // cgr
  struct anonymous_20 cgr;
  // prb
  struct anonymous_21 prb;
  // lift
  struct anonymous_22 lift;
  // trd
  struct anonymous_23 trd;
  // bindup
  struct anonymous_24 bindup;
  // unhd
  struct anonymous_25 unhd;
  // elm
  struct anonymous_26 elm;
  // otfs
  struct anonymous_27 otfs;
  // lits
  struct anonymous_28 lits;
  // clauses
  struct anonymous_29 clauses;
  // lir
  struct anonymous_30 lir[16l];
  // glues
  struct anonymous_31 glues;
  // phase
  struct anonymous_32 phase;
  // simp
  struct anonymous_33 simp;
  // luby
  struct anonymous_34 luby;
  // inout
  struct anonymous_34 inout;
  // queue
  struct anonymous_35 queue;
  // gauss
  struct anonymous_36 gauss;
  // cce
  struct anonymous_37 cce;
  // cliff
  struct anonymous_38 cliff;
  // moved
  struct anonymous_39 moved;
};

struct TD
{
  // level
  signed int level : 30;
  // lrglue
  unsigned int lrglue : 1;
  // rsn
  signed int rsn[2l];
};

struct Times
{
  // all
  double all;
  // dcp
  double dcp;
  // elm
  double elm;
  // trd
  double trd;
  // gc
  double gc;
  // dfg
  double dfg;
  // red
  double red;
  // blk
  double blk;
  // ana
  double ana;
  // unhd
  double unhd;
  // dec
  double dec;
  // lkhd
  double lkhd;
  // rsts
  double rsts;
  // lft
  double lft;
  // trn
  double trn;
  // cgr
  double cgr;
  // phs
  double phs;
  // srch
  double srch;
  // prep
  double prep;
  // inpr
  double inpr;
  // bump
  double bump;
  // mcls
  double mcls;
  // gauss
  double gauss;
  // card
  double card;
  // cce
  double cce;
  // cliff
  double cliff;
  // ctw
  double ctw;
  // force
  double force;
  // prb
  struct anonymous_76 prb;
};

struct Tmrs
{
  // phase
  double phase[10l];
  // idx
  signed int idx[10l];
  // nest
  signed int nest;
};

struct Trv
{
  // state
  void *state;
  // trav
  void (*trav)(void *, signed int);
};

struct Wchs
{
  // stk
  struct Stk stk;
  // start
  signed int start[31l];
  // free
  signed int free;
};

struct Work
{
  // wrag
  unsigned int wrag : 2;
  // lit
  signed int lit : 30;
  // other
  signed int other : 30;
  // red
  unsigned int red : 1;
  // removed
  unsigned int removed : 1;
};

struct Worker
{
  // lgl
  struct LGL *lgl;
  // forked
  struct anonymous_1 forked;
  // last
  signed int last;
  // res
  signed int res;
  // thread
  unsigned long int thread;
};

struct Wrk
{
  // queue
  struct Stk queue;
  // count
  signed int count;
  // head
  signed int head;
  // size
  signed int size;
  // posonly
  signed int posonly;
  // fifo
  signed int fifo;
  // pos
  signed int *pos;
};

struct Wtk
{
  // start
  struct Work *start;
  // top
  struct Work *top;
  // end
  struct Work *end;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct rusage
{
  // ru_utime
  struct timeval ru_utime;
  // ru_stime
  struct timeval ru_stime;
  // _anon0
  union anonymous_41 _anon0;
  // _anon1
  union anonymous_42 _anon1;
  // _anon2
  union anonymous_43 _anon2;
  // _anon3
  union anonymous_44 _anon3;
  // _anon4
  union anonymous_45 _anon4;
  // _anon5
  union anonymous_46 _anon5;
  // _anon6
  union anonymous_47 _anon6;
  // _anon7
  union anonymous_48 _anon7;
  // _anon8
  union anonymous_49 _anon8;
  // _anon9
  union anonymous_50 _anon9;
  // _anon10
  union anonymous_51 _anon10;
  // _anon11
  union anonymous_52 _anon11;
  // _anon12
  union anonymous_53 _anon12;
  // _anon13
  union anonymous_54 _anon13;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};


// addassumptions
// file ilingeling.c line 108
static signed int addassumptions;
// allocated
// file ilingeling.c line 17
static unsigned long int allocated;
// assumptions
// file ilingeling.c line 101
static signed int **assumptions;
// bar
// file ilingeling.c line 108
static signed int bar;
// catchedsig
// file ilingeling.c line 718
static signed int catchedsig;
// dofork
// file ilingeling.c line 108
static signed int dofork = 2;
// done
// file ilingeling.c line 114
static signed int done;
// donemutex
// file ilingeling.c line 117
static union anonymous_2 donemutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// environ
// file lglib.c line 1633 function lglchkenv
extern char **environ;
// finished
// file ilingeling.c line 121
static signed int finished;
// finishedmutex
// file ilingeling.c line 119
static union anonymous_2 finishedmutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// histfile
// file ilingeling.c line 18
static struct _IO_FILE *histfile;
// inputfile
// file ilingeling.c line 112
static struct _IO_FILE *inputfile;
// inputname
// file ilingeling.c line 111
static char *inputname;
// lglbasevar2funtab
// file lglib.c line 964
static const unsigned long int lglbasevar2funtab[6l] = { 0xaaaaaaaaaaaaaaaaull, 0xccccccccccccccccull, 0xf0f0f0f0f0f0f0f0ull, 0xff00ff00ff00ff00ull, 0xffff0000ffff0000ull, 0xffffffff00000000ull };
// lglfloorldtab
// file lglib.c line 956
static const char lglfloorldtab[256l] = { (const char)-1, (const char)0, (const char)1, (const char)1, (const char)2, (const char)2, (const char)2, (const char)2, (const char)3, (const char)3, (const char)3, (const char)3, (const char)3, (const char)3, (const char)3, (const char)3, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7 };
// lineno
// file ilingeling.c line 110
static signed int lineno = 1;
// lits
// file ilingeling.c line 106
static signed int *lits;
// maxallocated
// file ilingeling.c line 17
static unsigned long int maxallocated;
// msgmutex
// file ilingeling.c line 116
static union anonymous_2 msgmutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// nassumptions
// file ilingeling.c line 98
static signed int nassumptions;
// nclauses
// file ilingeling.c line 103
static signed int nclauses;
// nlits
// file ilingeling.c line 105
static signed int nlits;
// nowitness
// file ilingeling.c line 108
static signed int nowitness;
// nused
// file ilingeling.c line 103
static signed int nused;
// nvars
// file ilingeling.c line 103
static signed int nvars;
// nworkers
// file ilingeling.c line 93
static signed int nworkers;
// plain
// file ilingeling.c line 108
static signed int plain;
// queue
// file ilingeling.c line 98
static signed int queue;
// queuemutex
// file ilingeling.c line 118
static union anonymous_2 queuemutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// redassumptions
// file ilingeling.c line 99
static signed int redassumptions;
// sig_abrt_handler
// file ilingeling.c line 721
static void (*sig_abrt_handler)(signed int);
// sig_int_handler
// file ilingeling.c line 719
static void (*sig_int_handler)(signed int);
// sig_segv_handler
// file ilingeling.c line 720
static void (*sig_segv_handler)(signed int);
// sig_term_handler
// file ilingeling.c line 722
static void (*sig_term_handler)(signed int);
// startime
// file ilingeling.c line 16
static double startime;
// statsfile
// file ilingeling.c line 18
static struct _IO_FILE *statsfile;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// sumassumptions
// file ilingeling.c line 99
static signed int sumassumptions;
// sumtimes
// file ilingeling.c line 100
static double sumtimes;
// szassumptions
// file ilingeling.c line 98
static signed int szassumptions;
// szlits
// file ilingeling.c line 105
static signed int szlits;
// szvars
// file ilingeling.c line 103
static signed int szvars;
// times
// file ilingeling.c line 100
static double *times;
// used
// file ilingeling.c line 103
static signed int *used;
// vals
// file ilingeling.c line 104
static signed char *vals;
// verbose
// file ilingeling.c line 108
static signed int verbose;
// workers
// file ilingeling.c line 92
static struct Worker *workers;

// add
// file ilingeling.c line 471
static void add(signed int lit)
{
  signed int i = 0;
  for( ; !(i >= nworkers); i = i + 1)
    lgladd((workers + (signed long int)i)->lgl, lit);
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1;
}

// atoi_link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link1(const char *__nptr_link1)
{
  signed long int return_value_strtol_1_link1;
  return_value_strtol_1_link1=strtol(__nptr_link1, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1_link1;
}

// catchsig
// file ilingeling.c line 737
static void catchsig(signed int sig)
{
  if(catchedsig == 0)
  {
    fputs("s UNKNOWN\n", stdout);
    fflush(stdout);
    catchedsig = 1;
    caughtsigmsg(sig);
    if(!(statsfile == ((struct _IO_FILE *)NULL)))
      stats();

    if(!(histfile == ((struct _IO_FILE *)NULL)))
      hist();

    if(!(histfile == ((struct _IO_FILE *)NULL)) || !(statsfile == ((struct _IO_FILE *)NULL)))
      caughtsigmsg(sig);

  }

  resetsighandlers();
  char *return_value_getenv_1;
  return_value_getenv_1=getenv("LGLNABORT");
  if(return_value_getenv_1 == ((char *)NULL))
    raise(sig);

  else
    exit(1);
}

// caughtsigmsg
// file ilingeling.c line 731
static void caughtsigmsg(signed int sig)
{
  if(!(verbose == 0))
  {
    printf("c\nc CAUGHT SIGNAL %d\nc\n", sig);
    fflush(stdout);
  }

}

// cmpdblptr
// file ilingeling.c line 619
static signed int cmpdblptr(const void *p, const void *q)
{
  double a = *((double *)p);
  double b = *((double *)q);
  if(a < b)
    return -1;

  else
    if(a > b)
      return 1;

    else
      return 0;
}

// currentime
// file ilingeling.c line 167
static double currentime(void)
{
  double res = (double)0;
  struct timeval tv;
  signed int return_value_gettimeofday_1;
  return_value_gettimeofday_1=gettimeofday(&tv, ((struct timezone *)NULL));
  if(return_value_gettimeofday_1 == 0)
  {
    res = 1e-6 * (double)tv.tv_usec;
    res = res + (double)tv.tv_sec;
  }

  return res;
}

// die
// file ilingeling.c line 146
static void die(const char *fmt, ...)
{
  void **ap;
  fputs("*** [ilingeling] ", stderr);
  ap = (void **)&fmt;
  vfprintf(stderr, fmt, ap);
  ap = ((void **)NULL);
  fputc(10, stderr);
  fflush(stderr);
  exit(1);
}

// freeze
// file ilingeling.c line 579
static void freeze(void)
{
  signed int idx;
  signed int i;
  idx = 1;
  for( ; !(idx >= nvars); idx = idx + 1)
    if(used[(signed long int)idx] >= 0)
    {
      i = 0;
      for( ; !(i >= nworkers); i = i + 1)
        lglfreeze((workers + (signed long int)i)->lgl, idx);
    }

}

// getime
// file ilingeling.c line 174
static double getime()
{
  double return_value_currentime_1;
  return_value_currentime_1=currentime();
  return return_value_currentime_1 - startime;
}

// hist
// file ilingeling.c line 710
static void hist(void)
{
  struct _IO_FILE *file = histfile != ((struct _IO_FILE *)NULL) ? histfile : stdout;
  signed int i = 0;
  for( ; !(i >= nassumptions); i = i + 1)
    fprintf(file, "%.3f\n", times[(signed long int)i]);
  fflush(file);
}

// init
// file ilingeling.c line 423
static void init(void)
{
  struct Worker *w;
  do
  {
    unsigned long int BYTES = (unsigned long int)nworkers * sizeof(struct Worker) /*104ul*/ ;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(BYTES);
    workers = (struct Worker *)return_value_malloc_1;
    if(workers == ((struct Worker *)NULL))
    {
      die("out of memory");
      exit(1);
    }

    memset((void *)workers, 0, BYTES);
    do
    {
      allocated = allocated + BYTES;
      if(!(maxallocated >= allocated))
        maxallocated = allocated;

    }
    while((_Bool)0);
  }
  while((_Bool)0);
  w = workers;
  for( ; !(w >= workers + (signed long int)nworkers); w = w + 1l)
  {
    w->last = -1;
    w->lgl=lglinit();
    pthread_mutex_init(&w->forked.lock, ((const union anonymous_3 *)NULL));
    initlgl(w->lgl, w, 1);
  }
  msg(((struct Worker *)NULL), 1, "allocated %d workers", nworkers);
}

// initlgl
// file ilingeling.c line 240
static void initlgl(struct LGL *lgl, struct Worker *w, signed int opts)
{
  lglsetid(lgl, (signed int)(w - workers), nworkers);
  lglsetime(lgl, (double (*)(void))getime);
  lglseterm(lgl, term, (void *)w);
  lglsetmsglock(lgl, msglock, msgunlock, (void *)w);
  if(!(opts == 0))
  {
    signed int return_value_lglhasopt_1;
    return_value_lglhasopt_1=lglhasopt(lgl, "boost");
    if(!(return_value_lglhasopt_1 == 0))
      lglsetopt(lgl, "boost", 0);

    signed int return_value_lglhasopt_2;
    return_value_lglhasopt_2=lglhasopt(lgl, "cgrboost");
    if(!(return_value_lglhasopt_2 == 0))
      lglsetopt(lgl, "cgrboost", 0);

    signed int return_value_lglhasopt_3;
    return_value_lglhasopt_3=lglhasopt(lgl, "restartint");
    if(!(return_value_lglhasopt_3 == 0))
      lglsetopt(lgl, "restartint", 100);

    if(!(verbose == 0))
      lglsetopt(lgl, "verbose", verbose - 1);

    if(!(plain == 0))
      lglsetopt(lgl, "plain", 1);

  }

}

// isnum
// file ilingeling.c line 176
static signed int isnum(const char *str)
{
  const char *p = str;
  const unsigned short int **return_value___ctype_b_loc_1;
  return_value___ctype_b_loc_1=__ctype_b_loc();
  const char *tmp_post_2 = p;
  p = p + 1l;
  const unsigned short int **return_value___ctype_b_loc_3;
  if((2048 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*tmp_post_2]) == 0)
    return 0;

  else
  {
    for( ; !(*p == 0); p = p + 1l)
    {
      return_value___ctype_b_loc_3=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*p]) == 0)
        break;

    }
    return (signed int)!(*p != 0);
  }
}

// justreturn
// file ilingeling.c line 253
static signed int justreturn(struct Worker *w)
{
  signed int res;
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&donemutex);
  if(!(return_value_pthread_mutex_lock_1 == 0))
    warn("worker %d failed to lock 'done' mutex", (signed int)(w - workers));

  res = done;
  signed int return_value_pthread_mutex_unlock_2;
  return_value_pthread_mutex_unlock_2=pthread_mutex_unlock(&donemutex);
  if(!(return_value_pthread_mutex_unlock_2 == 0))
    warn("worker %d failed to unlock 'done' mutex", (signed int)(w - workers));

  return res;
}

// lgl2manyoccs4blk
// file lglib.c line 11134
static signed int lgl2manyoccs4blk(struct LGL *lgl, signed int lit)
{
  struct HTS *return_value_lglhts_1;
  return_value_lglhts_1=lglhts(lgl, lit);
  return (signed int)(return_value_lglhts_1->count > lgl->opts->blkocclim.val);
}

// lgl2manyoccs4elm
// file lglib.c line 11014
static signed int lgl2manyoccs4elm(struct LGL *lgl, signed int lit)
{
  signed int return_value_lglocc_1;
  return_value_lglocc_1=lglocc(lgl, lit);
  return (signed int)(return_value_lglocc_1 > lgl->opts->elmocclim.val);
}

// lglabce
// file lglib.c line 11516
static signed int lglabce(struct LGL *lgl, signed int lit)
{
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  signed int blit;
  signed int tag;
  signed int other;
  signed int cls[4l];
  struct HTS *hts;
  hts=lglhts(lgl, -lit);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  cls[(signed long int)0] = -lit;
  cls[(signed long int)3] = 0;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    lgl->stats->cce.steps = lgl->stats->cce.steps + 1l;
    if(lgl->stats->cce.steps >= lgl->limits->cce.steps)
      return 0;

    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if((REDCS & blit) == 0)
    {
      if(!(tag == LRGCS))
      {
        other = blit >> RMSHFT;
        cls[(signed long int)1] = other;
        if(tag == BINCS)
        {
          cls[(signed long int)2] = 0;
          c = cls;
        }

        else
          if(tag == TRNCS)
          {
            cls[(signed long int)2] = *p;
            c = cls;
          }

          else
            c=lglidx2lits(lgl, OCCS, 0, other);
        signed int return_value_lglabcecls_1;
        return_value_lglabcecls_1=lglabcecls(lgl, lit, c);
        if(return_value_lglabcecls_1 == 0)
          return 0;

      }

    }

  }
  return 1;
}

// lglabcecls
// file lglib.c line 11506
static signed int lglabcecls(struct LGL *lgl, signed int lit, const signed int *c)
{
  signed int other;
  signed int found = 0;
  const signed int *p = c;
  signed int return_value_lglsignedmarked_1;
  do
  {
    other = *p;
    if(other == 0)
      break;

    if(other == -lit)
      found = found + 1;

    else
    {
      return_value_lglsignedmarked_1=lglsignedmarked(lgl, -other);
      if(!(return_value_lglsignedmarked_1 == 0))
        return 1;

    }
    p = p + 1l;
  }
  while((_Bool)1);
  return 0;
}

// lglabort
// file lglib.c line 1171
static void lglabort(struct LGL *lgl)
{
  if(lgl == ((struct LGL *)NULL))
    exit(1);

  if(!(lgl->opts == ((struct Opts *)NULL)))
  {
    if(!(lgl->opts->sleeponabort.val == 0))
    {
      signed int return_value_getpid_1;
      return_value_getpid_1=getpid();
      fprintf(stderr, "liblgl.a: Process %d will sleep for %d seconds  before continuing with 'lglabort' procedure.\n", return_value_getpid_1, lgl->opts->sleeponabort.val);
      sleep((unsigned int)lgl->opts->sleeponabort.val);
    }

  }

  if(!(lgl->cbs == ((struct Cbs *)NULL)))
  {
    if(!(lgl->cbs->onabort == ((void (*)(void *))NULL)))
      lgl->cbs->onabort(lgl->cbs->abortstate);

  }

  if(!(lgl->opts == ((struct Opts *)NULL)))
  {
    if(!(lgl->opts->exitonabort.val == 0))
      exit(1);

  }

  abort();
}

// lgladd
// file lglib.h line 180
void lgladd(struct LGL *lgl, signed int elit)
{
  signed int eidx;
  eidx=abs(elit);
  struct Ext *ext;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lgladd");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "add %d", elit);
    break;
  }
  while(!(lgl->forked == 0))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lgladd");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not add literal to forked instance");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  if(eidx >= 1)
  {
    if(lgl->maxext >= eidx)
    {
      ext=lglelit2ext(lgl, elit);
      while(!(ext->melted == 0u))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lgladd");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "adding melted literal %d", elit);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
    }

  }

  lgl->stats->calls.add = lgl->stats->calls.add + 1l;
  lgleadd(lgl, elit);
  lgluse(lgl);
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lgladd(lgl->clone, elit);

}

// lgladdcls
// file lglib.c line 3511
static signed int lgladdcls(struct LGL *lgl, signed int red, signed int origlue, signed int force)
{
  signed int size;
  signed int lit;
  signed int other;
  signed int other2;
  signed int *p;
  signed int lidx;
  signed int unit;
  signed int blit;
  signed int scaledglue;
  signed int redglue;
  signed int prevglue;
  signed char val;
  struct Stk *w;
  lgl->stats->prgss = lgl->stats->prgss + 1l;
  unsigned long int return_value_lglcntstk_1;
  if(!(lgl->eliminating == 0))
  {
    return_value_lglcntstk_1=lglcntstk(&lgl->clause);
    lgl->stats->elm.steps = lgl->stats->elm.steps + (signed long int)return_value_lglcntstk_1;
  }

  if(red == 0)
    lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;

  if(!(force == 0))
    lglchksimpcls(lgl);

  unsigned long int return_value_lglcntstk_2;
  return_value_lglcntstk_2=lglcntstk(&lgl->clause);
  size = (signed int)(return_value_lglcntstk_2 - (unsigned long int)1);
  if(red == 0)
    lglincirr(lgl, size);

  else
    if(size == 2)
      lgl->stats->red.bin = lgl->stats->red.bin + 1;

    else
      if(size == 3)
        lgl->stats->red.trn = lgl->stats->red.trn + 1;

  signed char return_value_lglval_4;
  signed char return_value_lglval_5;
  signed char return_value_lglval_7;
  signed char return_value_lglval_6;
  signed char return_value_lglval_9;
  signed char return_value_lglval_8;
  signed char return_value_lglval_11;
  signed char return_value_lglval_10;
  signed int return_value_lglceilld_12;
  signed int return_value_lglmtstk_19;
  if(size == 0)
  {

  __CPROVER_DUMP_L7:
    ;
    lgl->mt = 1;
    return 0;
  }

  else
  {
    lit = lgl->clause.start[(signed long int)0];
    if(size == 1)
    {
      signed char return_value_lglval_3;
      return_value_lglval_3=lglval(lgl, lit);
      if(return_value_lglval_3 == 0)
      {
        if(!(red == 0))
          lglunit(lgl, lit);

        else
          lglunitnocheck(lgl, lit);
      }

      return 0;
    }

    other = lgl->clause.start[(signed long int)1];
    if(size == 2)
    {
      lglwchbin(lgl, lit, other, red);
      lglwchbin(lgl, other, lit, red);
      if(!(red == 0))
      {
        if(!(force == 0))
        {
          return_value_lglval_4=lglval(lgl, lit);
          if(!((signed int)return_value_lglval_4 >= 0))
            lglf2rce(lgl, other, lit, REDCS);

        }

        if(!(force == 0))
        {
          return_value_lglval_5=lglval(lgl, other);
          if(!((signed int)return_value_lglval_5 >= 0))
            lglf2rce(lgl, lit, other, REDCS);

        }

      }

      else
        if(!(lgl->dense == 0))
        {
          lglincocc(lgl, lit);
          lglincocc(lgl, other);
        }

      return 0;
    }

    else
    {
      lglordercls(lgl);
      lit = lgl->clause.start[(signed long int)0];
      other = lgl->clause.start[(signed long int)1];
      if(size == 3)
      {
        other2 = lgl->clause.start[(signed long int)2];
        lglwchtrn(lgl, lit, other, other2, red);
        lglwchtrn(lgl, other, lit, other2, red);
        lglwchtrn(lgl, other2, lit, other, red);
        if(!(red == 0))
        {
          if(!(force == 0))
          {
            return_value_lglval_7=lglval(lgl, lit);
            if(!((signed int)return_value_lglval_7 >= 0))
            {
              return_value_lglval_6=lglval(lgl, other);
              if(!((signed int)return_value_lglval_6 >= 0))
                lglf3rce(lgl, other2, lit, other, REDCS);

            }

          }

          if(!(force == 0))
          {
            return_value_lglval_9=lglval(lgl, lit);
            if(!((signed int)return_value_lglval_9 >= 0))
            {
              return_value_lglval_8=lglval(lgl, other2);
              if(!((signed int)return_value_lglval_8 >= 0))
                lglf3rce(lgl, other, lit, other2, REDCS);

            }

          }

          if(!(force == 0))
          {
            return_value_lglval_11=lglval(lgl, other);
            if(!((signed int)return_value_lglval_11 >= 0))
            {
              return_value_lglval_10=lglval(lgl, other2);
              if(!((signed int)return_value_lglval_10 >= 0))
                lglf3rce(lgl, lit, other, other2, REDCS);

            }

          }

        }

        else
          if(!(lgl->dense == 0))
          {
            lglincocc(lgl, lit);
            lglincocc(lgl, other);
            lglincocc(lgl, other2);
          }

        return 0;
      }

      else
      {
        if(!(red == 0))
        {
          if(lgl->opts->gluekeep.val >= origlue)
            scaledglue = 0;

          else
          {
            redglue = origlue - lgl->opts->gluekeep.val;
            scaledglue = redglue;
            switch(lgl->opts->gluescale.val)
            {
              case 3:
              {
                return_value_lglceilld_12=lglceilld(redglue);
                scaledglue = 1 + return_value_lglceilld_12;
                break;
              }
              case 2:
                scaledglue=lglceilsqrt32(redglue);
            }
          }
          if(scaledglue >= 15)
            scaledglue = (1 << 4) - 1;

          lgl->stats->clauses.scglue = lgl->stats->clauses.scglue + (signed long int)scaledglue;
          if(scaledglue == 15)
            lgl->stats->clauses.maxglue = lgl->stats->clauses.maxglue + 1l;

          else
            lgl->stats->clauses.nonmaxglue = lgl->stats->clauses.nonmaxglue + 1l;
          w = lgl->red + (signed long int)scaledglue;
          unsigned long int return_value_lglcntstk_13;
          return_value_lglcntstk_13=lglcntstk(w);
          lidx = (signed int)(return_value_lglcntstk_13 + (unsigned long int)1);
          if(lidx >= 134217727)
          {
            prevglue = scaledglue;
            if(lidx >= 134217727)
            {
              scaledglue = prevglue;
              while(lidx >= 134217727 && !(1 + scaledglue >= 15))
              {
                scaledglue = scaledglue + 1;
                w = lgl->red + (signed long int)scaledglue;
                unsigned long int return_value_lglcntstk_14;
                return_value_lglcntstk_14=lglcntstk(w);
                lidx = (signed int)(return_value_lglcntstk_14 + (unsigned long int)1);
              }
            }

            if(lidx >= 134217727)
            {
              scaledglue = prevglue;
              while(lidx >= 134217727 && scaledglue >= 1)
              {
                scaledglue = scaledglue - 1;
                w = lgl->red + (signed long int)scaledglue;
                unsigned long int return_value_lglcntstk_15;
                return_value_lglcntstk_15=lglcntstk(w);
                lidx = (signed int)(return_value_lglcntstk_15 + (unsigned long int)1);
              }
            }

            if(lidx >= 134217727 && !(scaledglue >= 15))
            {
              scaledglue = (1 << 4) - 1;
              w = lgl->red + (signed long int)scaledglue;
              unsigned long int return_value_lglcntstk_16;
              return_value_lglcntstk_16=lglcntstk(w);
              lidx = (signed int)(return_value_lglcntstk_16 + (unsigned long int)1);
            }

            if(scaledglue == 15 && lidx >= 134217727)
            {
              lglbacktrack(lgl, 0);
              unsigned long int return_value_lglcntstk_17;
              return_value_lglcntstk_17=lglcntstk(w);
              lidx = (signed int)return_value_lglcntstk_17;
            }

            if(lidx >= 134217727)
              lgldie(lgl, "number of redundant large clause literals exhausted");

          }

          lglpushstk(lgl, w, 0x7fffffff >> RMSHFT);
          lidx = lidx << 4;
          lidx = lidx | scaledglue;
          lgl->stats->lir[(signed long int)scaledglue].clauses = lgl->stats->lir[(signed long int)scaledglue].clauses + 1;
          lgl->stats->lir[(signed long int)scaledglue].added = lgl->stats->lir[(signed long int)scaledglue].added + 1l;
        }

        else
        {
          w = &lgl->irr;
          unsigned long int return_value_lglcntstk_18;
          return_value_lglcntstk_18=lglcntstk(w);
          lidx = (signed int)return_value_lglcntstk_18;
          scaledglue = 0;
          if(!(lidx >= 1))
          {
            return_value_lglmtstk_19=lglmtstk(w);
            if(return_value_lglmtstk_19 == 0)
              lgldie(lgl, "number of irredundant large clause literals exhausted");

          }

        }
        p = lgl->clause.start;
        do
        {
          other2 = *p;
          if(other2 == 0)
            break;

          lglpushstk(lgl, w, other2);
          p = p + 1l;
        }
        while((_Bool)1);
        lglpushstk(lgl, w, 0);
        if(!(red == 0))
        {
          unit = 0;
          p = lgl->clause.start;
          do
          {
            other2 = *p;
            if(other2 == 0)
              break;

            val=lglval(lgl, other2);
            if((signed int)val >= 0)
            {
              if(!(unit == 0))
                unit = 0x7fffffff;

              else
                unit = other2;
            }

            p = p + 1l;
          }
          while((_Bool)1);
          if(!(unit == 0) && !(unit == 0x7fffffff) && !(force == 0))
            lglflrce(lgl, unit, red, lidx);

        }

        if(red == 0 || !(red == 0) && !(scaledglue >= 15))
        {
          lglwchlrg(lgl, lit, other, red, lidx);
          lglwchlrg(lgl, other, lit, red, lidx);
        }

        if(!(scaledglue == 15) && !(red == 0))
        {
          lglbumplidx(lgl, lidx);
          lgl->stats->red.lrg = lgl->stats->red.lrg + 1;
        }

        if(red == 0)
        {
          if((signed int)lgl->dense >= 2)
          {
            if(lidx >= 134217727)
              lgldie(lgl, "number of irredundant large clause literals exhausted");

            blit = lidx << RMSHFT | OCCS;
            p = lgl->clause.start;
            do
            {
              other2 = *p;
              if(other2 == 0)
                break;

              lglincocc(lgl, other2);
              struct HTS *return_value_lglhts_20;
              return_value_lglhts_20=lglhts(lgl, other2);
              lglpushwch(lgl, return_value_lglhts_20, blit);
              p = p + 1l;
            }
            while((_Bool)1);
          }

        }

        lglchkirrstats(lgl);
        return lidx;
      }
    }
  }
}

// lgladdecl
// file lglib.c line 9309
static void lgladdecl(struct LGL *lgl, const signed int *c)
{
  signed int ilit;
  signed int mlit;
  signed int umlit;
  signed int size = 0;
  signed int lgladdecl__1__next;
  signed int prev;
  unsigned int csig = (unsigned int)0;
  const signed int *p;
  signed char val;

__CPROVER_DUMP_L1:
  ;
  lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
  lgl->stats->elm.copies = lgl->stats->elm.copies + 1l;
  size = 0;
  p = c;
  do
  {
    ilit = *p;
    if(ilit == 0)
      break;

    val=lglval(lgl, ilit);
    if((signed int)val >= 0)
    {
      size = size + 1;
      signed int return_value_abs_1;
      return_value_abs_1=abs(ilit);
      if(!(return_value_abs_1 == lgl->_anon0.elm->pivot))
      {
        mlit=lgli2m(lgl, ilit);
        unsigned int return_value_lglsig_2;
        return_value_lglsig_2=lglsig(mlit);
        csig = csig | return_value_lglsig_2;
      }

    }

    p = p + 1l;
  }
  while((_Bool)1);
  unsigned long int return_value_lglcntstk_3;
  return_value_lglcntstk_3=lglcntstk(&lgl->_anon0.elm->lits);
  lgladdecl__1__next = (signed int)return_value_lglcntstk_3;
  p = c;
  signed int tmp_post_4;
  do
  {
    ilit = *p;
    if(ilit == 0)
      break;

    val=lglval(lgl, ilit);
    if((signed int)val >= 0)
    {
      mlit=lgli2m(lgl, ilit);
      lglpushstk(lgl, &lgl->_anon0.elm->lits, mlit);
      umlit=lglulit(mlit);
      prev=lglpeek(&lgl->_anon0.elm->occs, umlit);
      lglpushstk(lgl, &lgl->_anon0.elm->next, prev);
      tmp_post_4 = lgladdecl__1__next;
      lgladdecl__1__next = lgladdecl__1__next + 1;
      lglpoke(&lgl->_anon0.elm->occs, umlit, tmp_post_4);
      lglpushstk(lgl, &lgl->_anon0.elm->csigs, (signed int)csig);
      lglpushstk(lgl, &lgl->_anon0.elm->sizes, size);
      lgl->_anon0.elm->noccs.start[(signed long int)umlit] = lgl->_anon0.elm->noccs.start[(signed long int)umlit] + 1;
      lgl->_anon0.elm->lsigs.start[(signed long int)umlit] = lgl->_anon0.elm->lsigs.start[(signed long int)umlit] | (signed int)csig;
    }

    p = p + 1l;
  }
  while((_Bool)1);
  lglpushstk(lgl, &lgl->_anon0.elm->lits, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->next, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->csigs, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->sizes, 0);
  lgl->_anon0.elm->necls = lgl->_anon0.elm->necls + 1;

__CPROVER_DUMP_L8:
  ;
}

// lgladdflt
// file lglib.c line 1108
static signed long int lgladdflt(signed long int a, signed long int b)
{
  signed int e;
  signed int f;
  signed int g;
  unsigned long int m;
  unsigned long int n;
  unsigned long int o;
  lglchkflt(a);
  lglchkflt(b);
  if(a == 0x7fffffffffffffffll)
    return 0x7fffffffffffffffll;

  else
    if(b == 0x7fffffffffffffffll)
      return 0x7fffffffffffffffll;

    else
      if(a == 0x0000000000000000ll)
        return b;

      else
        if(b == 0x0000000000000000ll)
          return a;

        else
        {
          e=lglexp(a);
          f=lglexp(b);
          if(!(e >= f))
          {
            g = e;
            e = f;
            f = g;
            o = (unsigned long int)a;
            a = b;
            b = (signed long int)o;
          }

          m=lglmnt(a);
          n=lglmnt(b);
          m = m + (n >> e - f);
          signed long int return_value_lglflt_1;
          return_value_lglflt_1=lglflt(e, m);
          return return_value_lglflt_1;
        }
}

// lgladdliftbincls
// file lglib.c line 13914
static void lgladdliftbincls(struct LGL *lgl, signed int a, signed int b)
{
  lglpushstk(lgl, &lgl->clause, a);
  lglpushstk(lgl, &lgl->clause, b);
  lglpushstk(lgl, &lgl->clause, 0);

__CPROVER_DUMP_L1:
  ;
  lgladdcls(lgl, REDCS, 0, 1);
  lglclnstk(&lgl->clause);
  lgl->stats->lift.impls = lgl->stats->lift.impls + 1;
}

// lgladdunits
// file lglib.c line 13703
static signed int lgladdunits(struct LGL *lgl)
{
  signed int idx;
  signed int lit;
  signed int repr;
  signed char val;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    repr=lglcgrepr(lgl, idx);
    signed int return_value_abs_1;
    return_value_abs_1=abs(repr);
    if(!(return_value_abs_1 >= 2))
    {
      lit = repr > 0 ? idx : -idx;
      val=lglval(lgl, lit);
      if(!((signed int)val >= 1))
      {
        if(!((signed int)val >= 0))
        {

        __CPROVER_DUMP_L3:
          ;
          lgl->mt = 1;
          return 0;
        }


      __CPROVER_DUMP_L4:
        ;
        lglpushstk(lgl, &lgl->_anon0.cgr->units, lit);
      }

    }

  }
  return 1;
}

// lgladecide
// file lglib.c line 7716
static signed int lgladecide(struct LGL *lgl)
{
  signed int res;
  signed int val;
  unsigned long int return_value_lglcntstk_1;
  do
  {
    return_value_lglcntstk_1=lglcntstk(&lgl->assume);
    if((unsigned long int)lgl->assumed >= return_value_lglcntstk_1)
      break;

    res=lglpeek(&lgl->assume, lgl->assumed);
    val=lglcval(lgl, res);
    if(val >= 1)

      __CPROVER_DUMP_L2:
        ;

    lgl->assumed = lgl->assumed + 1;

  __CPROVER_DUMP_L4:
    ;
    if(val == 0)
      return res;

  }
  while((_Bool)1);
  return 0;
}

// lgladjext
// file lglib.c line 2490
static void lgladjext(struct LGL *lgl, signed int eidx)
{
  unsigned long int old;
  unsigned long int new;
  old = (unsigned long int)lgl->szext;
  new = old != 0ul ? (unsigned long int)2 * old : (unsigned long int)2;
  for( ; (unsigned long int)eidx >= new; new = new * (unsigned long int)2)
    ;

__CPROVER_DUMP_L2:
  ;
  do
  {
    void *return_value_lglrsz_1;
    return_value_lglrsz_1=lglrsz(lgl, (void *)lgl->ext, old * sizeof(struct Ext) /*32ul*/ , new * sizeof(struct Ext) /*32ul*/ );
    lgl->ext = (struct Ext *)return_value_lglrsz_1;
  }
  while((_Bool)0);
  lgl->szext = (signed int)new;
}

// lglagile
// file lglib.c line 5178
static signed int lglagile(struct LGL *lgl)
{
  return (signed int)(lgl->flips >= (unsigned long int)lgl->opts->agile.val * 10000000ull);
}

// lglagility
// file lglib.c line 5012
static double lglagility(struct LGL *lgl)
{
  return (double)lgl->flips / 1e7;
}

// lglana
// file lglib.c line 6027
static signed int lglana(struct LGL *lgl)
{
  signed int size;
  signed int savedsize;
  signed int resolventsize;
  signed int level;
  signed int mlevel;
  signed int jlevel;
  signed int red;
  signed int glue;
  signed int open;
  signed int resolved;
  signed int tag;
  signed int lit;
  signed int uip;
  signed int r0;
  signed int r1;
  signed int other;
  signed int *p;
  signed int del;
  signed int cl;
  signed int c0;
  signed int c1;
  signed int sl;
  signed int s0;
  signed int s1;
  signed int rescore_clauses;
  signed int len;
  signed int *rsn;
  signed int return_value_lglpull_1;
  signed int tmp_post_2;
  signed int *tmp_post_7;
  signed int return_value_lglbumplidx_10;
  unsigned long int return_value_lglcntstk_11;
  signed int *tmp_post_12;
  signed int return_value_lglbumplidx_13;
  signed int return_value_lglmarked_14;
  if(!(lgl->mt == 0))
    return 0;

  else
    if(!(lgl->failed == 0))
      return 0;

    else
      if(lgl->conf.lit == 0)
        return 1;

      else
        if(lgl->level == 0)
        {
          lgl->mt = 1;
          return 0;
        }

        else
        {
          if(!(lgl->flipping == 0))
          {
            if(lgl->flipping == 1)

              __CPROVER_DUMP_L5:
                ;

            lgl->flipping = lgl->flipping - 1;
          }

          if(!(lgl->phaseneg == 0))
          {
            if(lgl->phaseneg == 1)

              __CPROVER_DUMP_L8:
                ;

            lgl->phaseneg = lgl->phaseneg - 1;
          }

          lglstart(lgl, &lgl->times->ana);
          lgl->stats->confs = lgl->stats->confs + 1l;
          do
          {

          RESTART:
            ;
            (void)0;
            open = 0;
            lit = lgl->conf.lit;
            r0 = lgl->conf.rsn[(signed long int)0];
            r1 = lgl->conf.rsn[(signed long int)1];
            rescore_clauses = 0;
            resolved = 0;
            savedsize = resolved;
            return_value_lglpull_1=lglpull(lgl, lit);
            open = open + return_value_lglpull_1;

          __CPROVER_DUMP_L12:
            ;

          __CPROVER_DUMP_L13:
            ;
            tmp_post_2 = resolved;
            resolved = resolved + 1;
            tag = r0 & MASKCS;
            if(tag == BINCS || tag == TRNCS)
            {
              other = r0 >> RMSHFT;
              signed int return_value_lglevel_3;
              return_value_lglevel_3=lglevel(lgl, other);
              size = return_value_lglevel_3 != 0 ? 2 : 1;
              signed int return_value_lglpull_4;
              return_value_lglpull_4=lglpull(lgl, other);
              if(!(return_value_lglpull_4 == 0))
                open = open + 1;

              if(tag == TRNCS)
              {
                signed int return_value_lglevel_5;
                return_value_lglevel_5=lglevel(lgl, r1);
                if(!(return_value_lglevel_5 == 0))
                  size = size + 1;

                signed int return_value_lglpull_6;
                return_value_lglpull_6=lglpull(lgl, r1);
                if(!(return_value_lglpull_6 == 0))
                  open = open + 1;

              }

            }

            else
            {
              red = r0 & REDCS;
              p=lglidx2lits(lgl, LRGCS, red, r1);
              size = 0;
              do
              {
                tmp_post_7 = p;
                p = p + 1l;
                other = *tmp_post_7;
                if(other == 0)
                  break;

                signed int return_value_lglevel_8;
                return_value_lglevel_8=lglevel(lgl, other);
                if(!(return_value_lglevel_8 == 0))
                  size = size + 1;

                signed int return_value_lglpull_9;
                return_value_lglpull_9=lglpull(lgl, other);
                if(!(return_value_lglpull_9 == 0))
                  open = open + 1;

              }
              while((_Bool)1);
              if(!(red == 0))
              {
                return_value_lglbumplidx_10=lglbumplidx(lgl, r1);
                if(!(return_value_lglbumplidx_10 == 0))
                  rescore_clauses = 1;

              }

            }

          __CPROVER_DUMP_L24:
            ;
            return_value_lglcntstk_11=lglcntstk(&lgl->clause);
            resolventsize = (signed int)((unsigned long int)open + return_value_lglcntstk_11);
            if(lgl->opts->otfs.val == 0)
              goto __CPROVER_DUMP_L45;

            if(!(resolved >= 2))
              goto __CPROVER_DUMP_L45;

            if((!(resolved == 2) || resolventsize >= savedsize) && resolventsize >= size)
              goto __CPROVER_DUMP_L45;

            cl = lgl->conf.lit;
            c0 = lgl->conf.rsn[(signed long int)0];
            c1 = lgl->conf.rsn[(signed long int)1];
            del = lit;
            if(!(resolved >= 3))
            {
              if(resolventsize >= size)
              {
                del = -lit;
                lit = cl;
                r0 = c0;
                r1 = c1;
              }

              else
                if(!(resolventsize >= savedsize))
                {
                  if(!((REDCS & r0) == 0))
                  {
                    sl = lit;
                    s0 = r0;
                    s1 = r1;
                    del = -lit;
                    lit = cl;
                    r0 = c0;
                    r1 = c1;
                  }

                  else
                  {
                    sl = cl;
                    s0 = c0;
                    s1 = c1;
                  }
                  lgldynsub(lgl, sl, s0, s1);
                }

            }

            lgldynstr(lgl, del, lit, r0, r1);
            lit = lgl->conf.lit;
            r0 = lgl->conf.rsn[(signed long int)0];
            r1 = lgl->conf.rsn[(signed long int)1];
            jlevel = 0;
            tag = r0 & MASKCS;
            if(!(tag == UNITCS))
            {
              if(tag == BINCS)
              {
                other = r0 >> RMSHFT;
                level=lglevel(lgl, other);
                if(!(jlevel >= level))
                  jlevel = level;

              }

              else
                if(tag == TRNCS)
                {
                  other = r0 >> RMSHFT;
                  level=lglevel(lgl, other);
                  if(!(jlevel >= level))
                    jlevel = level;

                  if(!(jlevel >= lgl->level))
                  {
                    other = r1;
                    level=lglevel(lgl, other);
                    if(!(jlevel >= level))
                      jlevel = level;

                  }

                }

                else
                {
                  red = r0 & REDCS;
                  p=lglidx2lits(lgl, LRGCS, red, r1);
                  while(!(jlevel >= lgl->level))
                  {
                    tmp_post_12 = p;
                    p = p + 1l;
                    other = *tmp_post_12;
                    if(other == 0)
                      break;

                    level=lglevel(lgl, other);
                    if(!(jlevel >= level))
                      jlevel = level;

                  }
                  if(!(red == 0))
                  {
                    return_value_lglbumplidx_13=lglbumplidx(lgl, r1);
                    if(!(return_value_lglbumplidx_13 == 0))
                      rescore_clauses = 1;

                  }

                }
            }

            if(!(jlevel >= lgl->level))
              break;


          __CPROVER_DUMP_L42:
            ;
            lgl->stats->otfs.restarting = lgl->stats->otfs.restarting + 1;
            lglbumplits(lgl);
            if(!(rescore_clauses == 0))
              lglrescoreclauses(lgl);

            lglclnana(lgl);
          }
          while((_Bool)1);

        __CPROVER_DUMP_L44:
          ;
          lgl->stats->otfs.driving = lgl->stats->otfs.driving + 1;
          lglbacktrack(lgl, jlevel);
          lglassign(lgl, lit, r0, r1);
          lglbumplits(lgl);
          goto DONE;

        __CPROVER_DUMP_L45:
          ;
          savedsize = size;
          do
          {
            lit=lglpopstk(&lgl->trail);
            return_value_lglmarked_14=lglmarked(lgl, lit);
            if(!(return_value_lglmarked_14 == 0))
              break;

            lglunassign(lgl, lit);
          }
          while((_Bool)1);
          lglunassign(lgl, lit);
          open = open - 1;
          if(open == 0)
            uip = -lit;

          else
          {

          __CPROVER_DUMP_L48:
            ;
            rsn=lglrsn(lgl, lit);
            r0 = rsn[(signed long int)0];
            r1 = rsn[(signed long int)1];
            goto __CPROVER_DUMP_L13;
          }

        __CPROVER_DUMP_L49:
          ;
          lglpushstk(lgl, &lgl->clause, uip);
          lglpushstk(lgl, &lgl->clause, 0);

        __CPROVER_DUMP_L50:
          ;
          unsigned long int return_value_lglcntstk_15;
          return_value_lglcntstk_15=lglcntstk(&lgl->frames);
          glue = (signed int)return_value_lglcntstk_15;
          lgl->stats->glues.count = lgl->stats->glues.count + 1;
          lgl->stats->glues.sum = lgl->stats->glues.sum + (signed long int)glue;
          lglbumplits(lgl);
          lglmincls(lgl, uip);
          mlevel = lgl->level;
          jlevel = 0;
          p = lgl->frames.start;
          for( ; !(p >= lgl->frames.top); p = p + 1l)
          {
            level = *p;
            if(!(level >= mlevel))
              mlevel = level;

            if(!(jlevel >= level))
              jlevel = level;

          }

        __CPROVER_DUMP_L54:
          ;

        __CPROVER_DUMP_L55:
          ;

        __CPROVER_DUMP_L56:
          ;
          signed int *return_value_lglrsn_16;
          return_value_lglrsn_16=lglrsn(lgl, uip);
          if(!(*return_value_lglrsn_16 == 0))
            lgl->stats->uips = lgl->stats->uips + 1l;

          lglbacktrack(lgl, jlevel);
          unsigned long int return_value_lglcntstk_17;
          return_value_lglcntstk_17=lglcntstk(&lgl->clause);
          len = (signed int)(return_value_lglcntstk_17 - (unsigned long int)1);
          lgl->stats->clauses.glue = lgl->stats->clauses.glue + (signed long int)glue;
          lgl->stats->lits.learned = lgl->stats->lits.learned + (signed long int)len;
          lgl->stats->clauses.learned = lgl->stats->clauses.learned + 1l;
          lgladdcls(lgl, REDCS, glue, 1);

        DONE:
          ;
          lglclnana(lgl);
          if(lgl->level == 0)
          {
            if(lgl->simp == 0)
            {
              lgl->stats->iterations = lgl->stats->iterations + 1;
              lglrep(lgl, 1, (char)105);
            }

          }

          if(!(rescore_clauses == 0))
            lglrescoreclauses(lgl);

          lglstop(lgl);
          return 1;
        }
}

// lglanafailed
// file lglib.c line 14447
static void lglanafailed(struct LGL *lgl)
{
  signed int ilit;
  signed int elit;
  signed int erepr;
  signed int failed;
  signed int size;
  unsigned int bit;
  unsigned int rbit;
  unsigned int ibit;
  unsigned int count;
  struct Ext *ext;
  struct Ext *rext;
  const signed int *p;
  struct AVar *av;
  _Bool tmp_if_expr_1;
  if(!(lgl->mt == 0))

    __CPROVER_DUMP_L1:
      ;

  else
  {
    failed = lgl->failed;
    if(failed == -1)
    {
      elit = 0;
      p = lgl->eassume.start;
      do
      {
        if(elit == 0)
          tmp_if_expr_1 = p < lgl->eassume.top ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(!tmp_if_expr_1)
          break;

        erepr=lglerepr(lgl, *p);
        signed int return_value_lglederef_2;
        return_value_lglederef_2=lglederef(lgl, erepr);
        if(!(return_value_lglederef_2 >= 0))
          elit = *p;

        p = p + 1l;
      }
      while((_Bool)1);

    __CPROVER_DUMP_L7:
      ;
      ext=lglelit2ext(lgl, elit);
      bit = 1u << (signed int)(elit < 0);
      ext->failed = (unsigned int)ext->failed | bit;
    }

    else
    {
      av=lglavar(lgl, failed);
      if((signed int)av->assumed == 3)
      {

      __CPROVER_DUMP_L9:
        ;
        av->failed = (unsigned int)3;
      }

      else
      {
        lglanalit(lgl, -failed);
        p = lgl->clause.start;
        for( ; !(p >= lgl->clause.top); p = p + 1l)
        {
          ilit = *p;
          av=lglavar(lgl, ilit);
          bit = 1u << (signed int)(ilit > 0);
          av->failed = (unsigned int)av->failed | bit;
        }
        unsigned long int return_value_lglcntstk_3;
        return_value_lglcntstk_3=lglcntstk(&lgl->clause);
        size = (signed int)return_value_lglcntstk_3;
        lglpushstk(lgl, &lgl->clause, 0);
        unsigned long int return_value_lglcntstk_4;
        return_value_lglcntstk_4=lglcntstk(&lgl->eassume);
        lglprt(lgl, 2, "[analyze-final] learned clause with size %d out of %d", size, return_value_lglcntstk_4);

      __CPROVER_DUMP_L13:
        ;
        lgladdcls(lgl, REDCS, size, 0);
        lglpopstk(&lgl->clause);
        lglpopnunmarkstk(lgl, &lgl->clause);
      }
      count = (unsigned int)0;
      p = lgl->eassume.start;
      for( ; !(p >= lgl->eassume.top); p = p + 1l)
      {
        elit = *p;
        bit = 1u << (signed int)(elit < 0);
        ext=lglelit2ext(lgl, elit);
        if((bit & (unsigned int)ext->failed) == 0u)
        {
          if(!(ext->equiv == 0u))
          {
            erepr = ext->repr;
            rbit = bit;
            if(!(erepr >= 0))
              rbit = rbit ^ (unsigned int)3;

            if(!(elit >= 0))
              erepr = -erepr;

            rext=lglelit2ext(lgl, erepr);
            if(!((rbit & (unsigned int)rext->failed) == 0u))
              goto __CPROVER_DUMP_L25;

            ilit = rext->repr;
            ibit = rbit;
            if(!(ilit >= 0))
            {
              ilit = -ilit;
              ibit = ibit ^ (unsigned int)3;
            }

            if(ilit == 1)
              goto __CPROVER_DUMP_L25;

            av=lglavar(lgl, ilit);
            if((ibit & (unsigned int)av->failed) == 0u)
              goto __CPROVER_DUMP_L25;

            rext->failed = (unsigned int)rext->failed | rbit;
            count = count + 1u;
            if(!((rbit & (unsigned int)rext->assumed) == 0u))

              __CPROVER_DUMP_L19:
                ;

            else
            {

            __CPROVER_DUMP_L20:
              ;
              ext->failed = (unsigned int)ext->failed | bit;
            }
          }

          else
          {
            ilit = ext->repr;
            ibit = bit;
            if(!(ilit >= 0))
            {
              ilit = -ilit;
              ibit = ibit ^ (unsigned int)3;
            }

            if(!(ilit == 1))
            {
              av=lglavar(lgl, ilit);
              if(!((ibit & (unsigned int)av->failed) == 0u))
              {

              __CPROVER_DUMP_L24:
                ;
                ext->failed = (unsigned int)ext->failed | bit;
                count = count + 1u;
              }

            }

          }
        }


      __CPROVER_DUMP_L25:
        ;
      }
    }
  }

__CPROVER_DUMP_L26:
  ;

__CPROVER_DUMP_L27:
  ;
  do
    lgl->state = (enum State)FAILED;
  while((_Bool)0);
}

// lglanalit
// file lglib.c line 14399
static signed int lglanalit(struct LGL *lgl, signed int lit)
{
  signed int r0;
  signed int r1;
  signed int antecedents;
  signed int other;
  signed int lglanalit__1__next;
  signed int tag;
  signed int *p;
  signed int *rsn;
  struct AVar *av;
  antecedents = 1;
  av=lglavar(lgl, lit);
  rsn=lglrsn(lgl, lit);
  r0 = rsn[(signed long int)0];
  r1 = rsn[(signed long int)1];

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;
  lglpushstk(lgl, &lgl->clause, lit);
  av->mark = 1;
  lglanalit__1__next = 0;
  signed int tmp_post_2;
  do
  {
    tag = r0 & MASKCS;
    if(tag == BINCS || tag == TRNCS)
    {
      other = r0 >> RMSHFT;
      lgldstpull(lgl, other);
      if(tag == TRNCS)
        lgldstpull(lgl, r1);

    }

    else
      if(!(tag == UNITCS))
      {
        if(!(tag == DECISION))
        {
          p=lglidx2lits(lgl, LRGCS, r0 & REDCS, r1);
          do
          {
            other = *p;
            if(other == 0)
              break;

            if(!(other == lit))
              lgldstpull(lgl, *p);

            p = p + 1l;
          }
          while((_Bool)1);
        }

      }

    unsigned long int return_value_lglcntstk_1;
    return_value_lglcntstk_1=lglcntstk(&lgl->seen);
    if((unsigned long int)lglanalit__1__next == return_value_lglcntstk_1)
      break;

    tmp_post_2 = lglanalit__1__next;
    lglanalit__1__next = lglanalit__1__next + 1;
    lit=lglpeek(&lgl->seen, tmp_post_2);
    rsn=lglrsn(lgl, lit);
    r0 = rsn[(signed long int)0];
    r1 = rsn[(signed long int)1];

  __CPROVER_DUMP_L11:
    ;
    antecedents = antecedents + 1;
  }
  while((_Bool)1);
  lglpopnunmarkstk(lgl, &lgl->seen);

__CPROVER_DUMP_L13:
  ;
  return antecedents;
}

// lgland3fun
// file lglib.c line 10575
static void lgland3fun(unsigned long int *a, unsigned long int *b, unsigned long int *c)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = b[(signed long int)i] & c[(signed long int)i];
}

// lgland3negfun
// file lglib.c line 10581
static void lgland3negfun(unsigned long int *a, unsigned long int *b, unsigned long int *c)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = b[(signed long int)i] & ~c[(signed long int)i];
}

// lglandfun
// file lglib.c line 10569
static void lglandfun(unsigned long int *a, unsigned long int *b)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = a[(signed long int)i] & b[(signed long int)i];
}

// lglandornegfun
// file lglib.c line 10563
static void lglandornegfun(unsigned long int *a, unsigned long int *b, unsigned long int *c)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = a[(signed long int)i] & (b[(signed long int)i] | ~c[(signed long int)i]);
}

// lglassign
// file lglib.c line 2611
static void lglassign(struct LGL *lgl, signed int lit, signed int r0, signed int r1)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int idx;
  signed int phase;
  signed int glue;
  signed int tag;
  signed int dom;
  struct TD *td;

__CPROVER_DUMP_L1:
  ;
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(&lgl->trail);
  av->trail = (signed int)return_value_lglcntstk_1;
  signed int tmp_if_expr_2;
  if(av->trail >= lgl->szdrail)
  {
    signed int newszdrail;
    if(!(lgl->szdrail == 0))
      tmp_if_expr_2 = 2 * lgl->szdrail;

    else
      tmp_if_expr_2 = 1;
    newszdrail = tmp_if_expr_2;
    do
    {
      void *return_value_lglrsz_3;
      return_value_lglrsz_3=lglrsz(lgl, (void *)lgl->drail, (unsigned long int)lgl->szdrail * sizeof(struct TD) /*12ul*/ , (unsigned long int)newszdrail * sizeof(struct TD) /*12ul*/ );
      lgl->drail = (struct TD *)return_value_lglrsz_3;
    }
    while((_Bool)0);
    lgl->szdrail = newszdrail;
  }

  td=lgltd(lgl, lit);
  tag = r0 & MASKCS;
  signed int tmp_if_expr_5;
  signed int return_value_lglgetdom_4;
  if(tag == BINCS)
  {
    return_value_lglgetdom_4=lglgetdom(lgl, -(r0 >> RMSHFT));
    tmp_if_expr_5 = return_value_lglgetdom_4;
  }

  else
    tmp_if_expr_5 = lit;
  dom = tmp_if_expr_5;
  lglsetdom(lgl, lit, dom);
  idx=abs(lit);
  phase=lglsgn(lit);
  lgl->vals[(signed long int)idx] = (signed char)phase;
  if(lgl->simp == 0)
  {
    if(lgl->flipping == 0)
    {
      if(lgl->phaseneg == 0)
      {
        lgl->flips = lgl->flips - lgl->flips / 100000ull;
        if(!((signed int)av->phase == phase))
          lgl->flips = lgl->flips + 10000ull;

        av->phase = phase;
      }

    }

  }

  td->level = lgl->level;
  if(lgl->level == 0)
  {
    if((signed int)av->type == EQUIVAR)
    {
      lgl->stats->equiv.current = lgl->stats->equiv.current - 1;
      lgl->stats->equiv.sum = lgl->stats->equiv.sum - 1;
    }

    else
      av->type = (unsigned int)FIXEDVAR;
    lgl->stats->fixed.sum = lgl->stats->fixed.sum + 1;
    lgl->stats->fixed.current = lgl->stats->fixed.current + 1;
    lgl->stats->prgss = lgl->stats->prgss + 1l;
    lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;
    td->rsn[(signed long int)0] = UNITCS | lit << RMSHFT;
    td->rsn[(signed long int)1] = 0;
    if(!(lgl->cbs == ((struct Cbs *)NULL)))
    {
      if(!(lgl->cbs->units.produce.fun == ((void (*)(void *, signed int))NULL)))
      {

      __CPROVER_DUMP_L12:
        ;
        signed int return_value_lglexport_6;
        return_value_lglexport_6=lglexport(lgl, lit);
        lgl->cbs->units.produce.fun(lgl->cbs->units.produce.state, return_value_lglexport_6);
      }

    }

  }

  else
  {
    td->rsn[(signed long int)0] = r0;
    td->rsn[(signed long int)1] = r1;
  }
  lglpushstk(lgl, &lgl->trail, lit);
  if(lgl->failed == 0)
  {
    if(!((1u << (signed int)(lit >= 1) & (unsigned int)av->assumed) == 0u))
    {

    __CPROVER_DUMP_L17:
      ;
      lgl->failed = -lit;
    }

  }

  lgl->unassigned = lgl->unassigned - 1;
  td->lrglue = (unsigned int)0;
  if((MASKCS & r0) == LRGCS && !((REDCS & r0) == 0))
  {
    glue = r1 & (1 << 4) - 1;
    lgl->stats->lir[(signed long int)glue].forcing = lgl->stats->lir[(signed long int)glue].forcing + 1l;
    if(!(lgl->level == 0))
    {
      if(glue >= 1)
      {
        if(!(glue >= 15))
        {
          lgl->lrgluereasons = lgl->lrgluereasons + 1;
          td->lrglue = (unsigned int)1;
        }

      }

    }

  }

  struct HTS *return_value_lglhts_7;
  return_value_lglhts_7=lglhts(lgl, -lit);
  signed int *return_value_lglhts2wchs_8;
  return_value_lglhts2wchs_8=lglhts2wchs(lgl, return_value_lglhts_7);
}

// lglassume
// file lglib.h line 181
void lglassume(struct LGL *lgl, signed int elit)
{
  signed int eidx;
  eidx=abs(elit);
  struct Ext *ext;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglassume");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "assume %d", elit);
    break;
  }
  while(!(lgl->forked == 0))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglassume");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not assume literal in forked instance");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lgl->stats->calls.assume = lgl->stats->calls.assume + 1l;
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglassume");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not assume invalid literal 0");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  if(eidx >= 1)
  {
    if(lgl->maxext >= eidx)
    {
      ext=lglelit2ext(lgl, elit);
      while(!(ext->melted == 0u))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglassume");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "assuming melted literal %d", elit);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
    }

  }

  lgleassume(lgl, elit);
  lgluse(lgl);
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglassume(lgl->clone, elit);

}

// lglassumption
// file lglib.c line 4805
static signed int lglassumption(struct LGL *lgl, signed int lit)
{
  struct AVar *return_value_lglavar_1;
  return_value_lglavar_1=lglavar(lgl, lit);
  return (signed int)return_value_lglavar_1->assumed;
}

// lglavar
// file lglib.c line 2318
static struct AVar * lglavar(struct LGL *lgl, signed int lit)
{
  signed int return_value_abs_1;
  return_value_abs_1=abs(lit);
  return lgl->avars + (signed long int)return_value_abs_1;
}

// lglavg
// file lglib.c line 5014
static double lglavg(double n, double d)
{
  return IEEE_FLOAT_NOTEQUAL(d, (double)0) ? n / d : 0.0;
}

// lglavglue
// file lglib.c line 5022
static signed long int lglavglue(struct LGL *lgl)
{
  signed int count = lgl->stats->glues.count;
  if(count == 0)
    return (signed long int)0;

  else
    return ((signed long int)100 * lgl->stats->glues.sum) / (signed long int)count;
}

// lglbacksub
// file lglib.c line 9546
static signed int lglbacksub(struct LGL *lgl, signed int *c, signed int str)
{
  signed int *lglbacksub__1__start = lgl->_anon0.elm->lits.start;
  signed int *p;
  signed int *q;
  signed int marked = 0;
  signed int res;
  signed int *d;
  signed int lit;
  signed int ulit;
  signed int occ;
  signed int lglbacksub__1__next;
  signed int osize;
  signed int other;
  signed int uolit;
  signed int size;
  signed int plit;
  signed int phase;
  signed int clidx;
  unsigned int ocsig;
  unsigned int lsig;
  unsigned int csig = (unsigned int)0;

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;
  phase = (signed int)(c - lglbacksub__1__start >= (signed long int)lgl->_anon0.elm->neglidx);
  p = c;
  signed int return_value_abs_2;
  unsigned int return_value_lglsig_1;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    return_value_abs_2=abs(lit);
    if(!(return_value_abs_2 == 1))
    {
      return_value_lglsig_1=lglsig(lit);
      csig = csig | return_value_lglsig_1;
    }

    p = p + 1l;
  }
  while((_Bool)1);
  size = (signed int)(p - c);
  res = 0;
  if(!(str == 0))
    phase = (signed int)!(phase != 0);

  lit = phase != 0 ? -1 : 1;
  ulit=lglulit(lit);
  occ=lglpeek(&lgl->_anon0.elm->noccs, ulit);
  signed int return_value_abs_5;
  _Bool tmp_if_expr_6;
  signed int *tmp_post_7;
  signed int *tmp_post_8;
  signed int return_value_abs_9;
  if(str == 0 && !(occ >= 2))
    return 0;

  else
    if(occ == 0 && !(str == 0))
      return 0;

    else
    {
      signed int return_value_lglpeek_3;
      return_value_lglpeek_3=lglpeek(&lgl->_anon0.elm->lsigs, ulit);
      lsig = (unsigned int)return_value_lglpeek_3;
      if(!((~lsig & csig) == 0u))
        return 0;

      else
      {
        lglbacksub__1__next=lglpeek(&lgl->_anon0.elm->occs, ulit);
        while(res == 0 && !(lglbacksub__1__next == 0))
        {
          lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
          if(!((signed long int)lglbacksub__1__next == p - lglbacksub__1__start))
          {
            if(phase == (signed int)(lglbacksub__1__next >= lgl->_anon0.elm->neglidx))
            {
              plit=lglpeek(&lgl->_anon0.elm->lits, lglbacksub__1__next);
              if(!(plit >= 134217727))
              {
                osize=lglpeek(&lgl->_anon0.elm->sizes, lglbacksub__1__next);
                if(size >= osize)
                {
                  signed int return_value_lglpeek_4;
                  return_value_lglpeek_4=lglpeek(&lgl->_anon0.elm->csigs, lglbacksub__1__next);
                  ocsig = (unsigned int)return_value_lglpeek_4;
                  if((~csig & ocsig) == 0u)
                  {
                    if(marked == 0)
                    {
                      q = c;
                      do
                      {
                        other = *q;
                        if(other == 0)
                          break;

                        if(!(str == 0))
                        {
                          return_value_abs_5=abs(other);
                          if(return_value_abs_5 == 1)
                            other = -other;

                        }

                        uolit=lglulit(other);
                        lglpoke(&lgl->_anon0.elm->mark, uolit, 1);
                        q = q + 1l;
                      }
                      while((_Bool)1);
                      marked = 1;
                    }

                    d = lgl->_anon0.elm->lits.start + (signed long int)lglbacksub__1__next;
                    if(!(d >= c) || d >= c + (signed long int)size)
                    {
                      if(!(str == 0))
                        lgl->stats->elm.strchks = lgl->stats->elm.strchks + 1l;

                      else
                        lgl->stats->elm.subchks = lgl->stats->elm.subchks + 1l;
                      for( ; !(d[-1l] == 0); d = d - 1l)
                        ;

                    __CPROVER_DUMP_L18:
                      ;
                      res = 1;
                      q = d;
                      do
                      {
                        if(!(res == 0))
                        {
                          other = *q;
                          tmp_if_expr_6 = other != 0 ? (_Bool)1 : (_Bool)0;
                        }

                        else
                          tmp_if_expr_6 = (_Bool)0;
                        if(!tmp_if_expr_6)
                          break;

                        uolit=lglulit(other);
                        res=lglpeek(&lgl->_anon0.elm->mark, uolit);
                        q = q + 1l;
                      }
                      while((_Bool)1);
                      if(!(res == 0) && !(str == 0) && osize >= size)
                      {

                      __CPROVER_DUMP_L23:
                        ;
                        clidx = 0;
                        q = lgl->_anon0.elm->lits.start + (signed long int)lgl->_anon0.elm->neglidx;
                        while(!(q >= d))
                        {
                          tmp_post_7 = q;
                          q = q + 1l;
                          other = *tmp_post_7;
                          if(other >= 134217727)
                            do
                            {
                              tmp_post_8 = q;
                              q = q + 1l;
                              if(*tmp_post_8 == 0)
                                break;

                            }
                            while((_Bool)1);

                          else
                            if(other == 0)
                              clidx = clidx + 1;

                        }

                      __CPROVER_DUMP_L29:
                        ;

                      __CPROVER_DUMP_L30:
                        ;
                        lglelrmcls(lgl, -lgl->_anon0.elm->pivot, d, clidx);
                      }

                    }

                  }

                }

              }

            }

          }

          lglbacksub__1__next=lglpeek(&lgl->_anon0.elm->next, lglbacksub__1__next);
        }
        if(!(marked == 0))
        {
          p = c;
          do
          {
            lit = *p;
            if(lit == 0)
              break;

            if(!(str == 0))
            {
              return_value_abs_9=abs(lit);
              if(return_value_abs_9 == 1)
                lit = -lit;

            }

            ulit=lglulit(lit);
            lglpoke(&lgl->_anon0.elm->mark, ulit, 0);
            p = p + 1l;
          }
          while((_Bool)1);
        }

        return res;
      }
    }
}

// lglbacktrack
// file lglib.c line 2801
static void lglbacktrack(struct LGL *lgl, signed int level)
{
  signed int lit;

__CPROVER_DUMP_L1:
  ;
  signed int return_value_lglevel_1;
  if(!(lgl->failed == 0))
  {
    if(!(lgl->failed == -1))
    {
      return_value_lglevel_1=lglevel(lgl, lgl->failed);
      if(!(level >= return_value_lglevel_1))
      {

      __CPROVER_DUMP_L2:
        ;
        lgl->failed = 0;
      }

    }

  }

  signed int return_value_lglmtstk_2;
  do
  {
    return_value_lglmtstk_2=lglmtstk(&lgl->trail);
    if(!(return_value_lglmtstk_2 == 0))
      break;

    lit=lgltopstk(&lgl->trail);
    signed int return_value_lglevel_3;
    return_value_lglevel_3=lglevel(lgl, lit);
    if(level >= return_value_lglevel_3)
      break;

    lglunassign(lgl, lit);
    lgl->trail.top = lgl->trail.top - 1l;
  }
  while((_Bool)1);
  if(!(level >= lgl->alevel))
  {

  __CPROVER_DUMP_L5:
    ;
    lgl->alevel = level;
    if(!(lgl->assumed == 0))
    {

    __CPROVER_DUMP_L6:
      ;
      lgl->assumed = 0;
    }

  }

  lgl->level = level;
  lglrstcontrol(lgl, level + 1);
  lgl->conf.lit = 0;
  lgl->conf.rsn[(signed long int)1] = 0;
  lgl->conf.rsn[(signed long int)0] = lgl->conf.rsn[(signed long int)1];
  unsigned long int return_value_lglcntstk_4;
  return_value_lglcntstk_4=lglcntstk(&lgl->trail);
  lgl->next = (signed int)return_value_lglcntstk_4;
  lgl->next2 = lgl->next;

__CPROVER_DUMP_L8:
  ;
}

// lglbasicprobe
// file lglib.c line 8966
static signed int lglbasicprobe(struct LGL *lgl)
{
  signed int origfailed = lgl->stats->prb.basic.failed;
  signed int origlifted = lgl->stats->prb.basic.lifted;
  signed int orighbr = lgl->stats->hbr.cnt;
  signed int root;
  signed int failed;
  signed int lifted;
  signed int units;
  signed int first;
  signed int idx;
  signed int oldrem;
  signed int deltarem;
  signed int deltahbr;
  signed int remprobes;
  signed int oldhbr;
  signed int oldfailed;
  signed int oldlifted;
  signed int nprobes;
  signed int success;
  signed int round;
  struct Stk probes;
  struct Stk lift;
  struct Stk saved;
  unsigned int pos;
  unsigned int delta;
  unsigned int return_value_lglrand_1;
  unsigned int return_value_lglrand_2;
  unsigned int return_value_lglgcd_3;
  struct AVar *return_value_lglavar_8;
  signed int return_value_lglmtstk_11;
  signed int return_value_lglisfree_12;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_18;
  signed int return_value_lgldecomp_15;
  struct AVar *return_value_lglavar_16;
  if(lgl->nvars == 0)
    return 1;

  else
    if(lgl->opts->probe.val == 0)
      return 1;

    else
    {
      lglstart(lgl, &lgl->times->prb.basic);
      lgl->stats->prb.basic.count = lgl->stats->prb.basic.count + 1;
      if(lgl->level >= 1)
        lglbacktrack(lgl, 0);

      lgl->basicprobing = (char)1;
      lgl->probing = (signed int)lgl->basicprobing;
      lgl->simp = (char)lgl->probing;
      do
        memset((void *)&lift, 0, sizeof(struct Stk) /*24ul*/ );
      while((_Bool)0);
      do
        memset((void *)&probes, 0, sizeof(struct Stk) /*24ul*/ );
      while((_Bool)0);
      do
        memset((void *)&saved, 0, sizeof(struct Stk) /*24ul*/ );
      while((_Bool)0);
      lglsetprbasiclim(lgl);
      oldfailed = origfailed;
      oldlifted = origlifted;
      oldhbr = lgl->stats->hbr.cnt;
      oldrem=lglrem(lgl);
      round = 0;
      do
      {

      RESTART:
        ;
        nprobes=lglschedbasicprobe(lgl, &probes, round);
        remprobes = 0;
        if(nprobes == 0)
          goto DONE;

        return_value_lglrand_1=lglrand(lgl);
        pos = return_value_lglrand_1 % (unsigned int)nprobes;
        return_value_lglrand_2=lglrand(lgl);
        delta = return_value_lglrand_2 % (unsigned int)nprobes;
        if(delta == 0u)
          delta = delta + 1u;

        do
        {
          return_value_lglgcd_3=lglgcd(delta, (unsigned int)nprobes);
          if(!(return_value_lglgcd_3 >= 2u))
            break;

          delta = delta + 1u;
          if(delta == (unsigned int)nprobes)
            delta = (unsigned int)1;

        }
        while((_Bool)1);

      __CPROVER_DUMP_L10:
        ;
        first = 0;
        while(lgl->mt == 0)
        {
          if(lgl->stats->prb.basic.steps >= lgl->limits->prb.steps)
            break;

          signed int return_value_lglterminate_4;
          return_value_lglterminate_4=lglterminate(lgl);
          if(!(return_value_lglterminate_4 == 0))
            break;

          signed int return_value_lglsyncunits_5;
          return_value_lglsyncunits_5=lglsyncunits(lgl);
          if(return_value_lglsyncunits_5 == 0)
            break;

          root = probes.start[(signed long int)pos];
          probes.start[(signed long int)pos] = 0;
          if(root == 0 || root == first)
          {
            signed int return_value_lglrem_6;
            return_value_lglrem_6=lglrem(lgl);
            double return_value_lglpcnt_7;
            return_value_lglpcnt_7=lglpcnt((double)nprobes, (double)return_value_lglrem_6);
            lglprt(lgl, 1, "[basicprobe-%d-%d] %d sched %.0f%%, %d failed, %d lifted, %d hbrs", lgl->stats->prb.basic.count, round, nprobes, return_value_lglpcnt_7, lgl->stats->prb.basic.failed - oldfailed, lgl->stats->prb.basic.lifted - oldlifted, lgl->stats->hbr.cnt - oldhbr);
            idx = 2;
            for( ; !(idx >= lgl->nvars); idx = idx + 1)
            {
              return_value_lglavar_8=lglavar(lgl, idx);
              return_value_lglavar_8->donotbasicprobe = (unsigned int)0;
            }
            break;
          }

          struct AVar *return_value_lglavar_9;
          return_value_lglavar_9=lglavar(lgl, root);
          return_value_lglavar_9->donotbasicprobe = (unsigned int)1;
          if(first == 0)
            first = root;

          pos = pos + delta;
          if(pos >= (unsigned int)nprobes)
            pos = pos - (unsigned int)nprobes;

          signed int return_value_lglisfree_10;
          return_value_lglisfree_10=lglisfree(lgl, root);
          if(!(return_value_lglisfree_10 == 0))
            lglbasicprobelit(lgl, root);

        }
        if(!(lgl->mt == 0))
          goto DONE;

        if(lgl->stats->prb.basic.steps >= lgl->limits->prb.steps)
        {
          do
          {
            return_value_lglmtstk_11=lglmtstk(&probes);
            if(!(return_value_lglmtstk_11 == 0))
              break;

            idx=lglpopstk(&probes);
            if(!(idx == 0))
            {
              return_value_lglisfree_12=lglisfree(lgl, idx);
              if(!(return_value_lglisfree_12 == 0))
                remprobes = remprobes + 1;

            }

          }
          while((_Bool)1);
          signed int return_value_lglrem_13;
          return_value_lglrem_13=lglrem(lgl);
          double return_value_lglpcnt_14;
          return_value_lglpcnt_14=lglpcnt((double)remprobes, (double)return_value_lglrem_13);
          lglprt(lgl, 1, "[basicprobe-%d-%d] %d probes remain %.0f%% after last round", lgl->stats->prb.basic.count, round, remprobes, return_value_lglpcnt_14);
          goto DONE;
        }

        if(round >= lgl->opts->prbasicroundlim.val)
        {
          lglprt(lgl, 1, "[basicprobe-%d-%d] round limit %d hit", lgl->stats->prb.basic.count, round, lgl->opts->prbasicroundlim.val);
          goto DONE;
        }

        if(!(oldfailed >= lgl->stats->prb.basic.failed))
          tmp_if_expr_17 = (_Bool)1;

        else
          tmp_if_expr_17 = lgl->stats->prb.basic.lifted > oldlifted ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_17)
          tmp_if_expr_18 = (_Bool)1;

        else
          tmp_if_expr_18 = lgl->stats->hbr.cnt > oldhbr ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_18)
          break;

        oldfailed = lgl->stats->prb.basic.failed;
        oldlifted = lgl->stats->prb.basic.lifted;
        lglclnstk(&probes);
        if(!(oldhbr >= lgl->stats->hbr.cnt))
        {
          return_value_lgldecomp_15=lgldecomp(lgl);
          if(return_value_lgldecomp_15 == 0)
            goto DONE;

        }

        oldhbr = lgl->stats->hbr.cnt;
        round = round + 1;
      }
      while((_Bool)1);
      lglprt(lgl, 1, "[basicprobe-%d-%d] fully completed probing", lgl->stats->prb.basic.count, round);
      idx = 2;
      for( ; !(idx >= lgl->nvars); idx = idx + 1)
      {
        return_value_lglavar_16=lglavar(lgl, idx);
        return_value_lglavar_16->donotbasicprobe = (unsigned int)0;
      }

    DONE:
      ;
      lglrelstk(lgl, &lift);
      lglrelstk(lgl, &probes);
      lglrelstk(lgl, &saved);
      signed int return_value_lglrem_19;
      return_value_lglrem_19=lglrem(lgl);
      deltarem = oldrem - return_value_lglrem_19;
      deltahbr = lgl->stats->hbr.cnt - orighbr;
      success = (signed int)(deltarem != 0 || deltahbr != 0);
      lglupdprbasicpen(lgl, deltarem);
      failed = lgl->stats->prb.basic.failed - origfailed;
      lifted = lgl->stats->prb.basic.lifted - origlifted;
      lgl->basicprobing = (char)0;
      lgl->probing = (signed int)lgl->basicprobing;
      lgl->simp = (char)lgl->probing;
      units = failed + lifted;
      double return_value_lglpcnt_20;
      return_value_lglpcnt_20=lglpcnt((double)failed, (double)units);
      double return_value_lglpcnt_21;
      return_value_lglpcnt_21=lglpcnt((double)lifted, (double)units);
      lglprt(lgl, 1 + (signed int)!(units != 0), "[basicprobe-%d-%d] %d units = %d failed (%.0f%%) + %d lifted (%.0f%%)", lgl->stats->prb.basic.count, round, units, failed, return_value_lglpcnt_20, lifted, return_value_lglpcnt_21);
      lglprt(lgl, 1 + (signed int)!(success != 0), "[basicprobe-%d-%d] removed %d variables, found %d hbrs", lgl->stats->prb.basic.count, round, deltarem, deltahbr);
      lglrep(lgl, 1 + (signed int)!(success != 0), (char)112);
      lglstop(lgl);
      return (signed int)!(lgl->mt != 0);
    }
}

// lglbasicprobelit
// file lglib.c line 8735
static void lglbasicprobelit(struct LGL *lgl, signed int root)
{
  signed int old;
  signed int ok;
  signed int dom;
  signed int lit;
  signed int val;
  struct Stk lift;
  struct Stk saved;
  const signed int *p;
  do
    memset((void *)&lift, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  do
    memset((void *)&saved, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  if(!(lgl->cceing == 0))
    lgl->stats->cce.probed = lgl->stats->cce.probed + 1l;

  else
    lgl->stats->prb.basic.probed = lgl->stats->prb.basic.probed + 1l;
  lgliassume(lgl, root);
  old = lgl->next;
  ok=lglbcp(lgl);
  dom = 0;
  if(!(ok == 0))
  {
    lglclnstk(&saved);
    p = lgl->trail.start + (signed long int)old;
    for( ; !(p >= lgl->trail.top); p = p + 1l)
    {
      lit = *p;
      if(!(lit == root))
        lglpushstk(lgl, &saved, lit);

    }
  }

  else
    dom=lglprbana(lgl, root);
  lglbacktrack(lgl, 0);
  if(ok == 0)
  {

  __CPROVER_DUMP_L11:
    ;
    lglpushstk(lgl, &lift, -dom);
  }

  else
  {

  __CPROVER_DUMP_L12:
    ;
    if(!(lgl->cceing == 0))
      lgl->stats->cce.probed = lgl->stats->cce.probed + 1l;

    else
      lgl->stats->prb.basic.probed = lgl->stats->prb.basic.probed + 1l;
    lgliassume(lgl, -root);
    ok=lglbcp(lgl);
    if(!(ok == 0))
    {
      p = saved.start;
      for( ; !(p >= saved.top); p = p + 1l)
      {
        lit = *p;
        signed char return_value_lglval_1;
        return_value_lglval_1=lglval(lgl, lit);
        val = (signed int)return_value_lglval_1;
        if(val >= 1)
        {
          if(!(lgl->cceing == 0))
            lgl->stats->cce.lifted = lgl->stats->cce.lifted + 1;

          else
            lgl->stats->prb.basic.lifted = lgl->stats->prb.basic.lifted + 1;
          lglpushstk(lgl, &lift, lit);
        }


      __CPROVER_DUMP_L19:
        ;
      }
    }

    else
      dom=lglprbana(lgl, -root);
    lglbacktrack(lgl, 0);
    if(ok == 0)
    {

    __CPROVER_DUMP_L24:
      ;
      lglpushstk(lgl, &lift, -dom);
    }

  }
  signed int return_value_lglmtstk_2;
  signed int return_value_lglbcp_4;
  do
  {

  MERGE:
    ;
    return_value_lglmtstk_2=lglmtstk(&lift);
    if(!(return_value_lglmtstk_2 == 0))
      break;

    lit=lglpopstk(&lift);
    signed char return_value_lglval_3;
    return_value_lglval_3=lglval(lgl, lit);
    val = (signed int)return_value_lglval_3;
    if(!(val >= 1))
    {
      if(val >= 0)
      {
        lglunit(lgl, lit);
        if(!(lgl->cceing == 0))
          lgl->stats->cce.failed = lgl->stats->cce.failed + 1;

        else
          lgl->stats->prb.basic.failed = lgl->stats->prb.basic.failed + 1;
        return_value_lglbcp_4=lglbcp(lgl);
        if(return_value_lglbcp_4 == 0)
          goto EMPTY;

      }

      else
      {
        do

          EMPTY:
            ;
        while((_Bool)0);
        lgl->mt = 1;
      }
    }

  }
  while((_Bool)1);
  lglrelstk(lgl, &lift);
  lglrelstk(lgl, &saved);
}

// lglbcp
// file lglib.c line 4732
static signed int lglbcp(struct LGL *lgl)
{
  signed int lit;
  signed int trail;
  signed int count = 0;
  signed int tmp_post_2;
  signed int tmp_post_3;
  while(lgl->conf.lit == 0)
  {
    unsigned long int return_value_lglcntstk_1;
    return_value_lglcntstk_1=lglcntstk(&lgl->trail);
    trail = (signed int)return_value_lglcntstk_1;
    if(!(lgl->next2 >= trail))
    {
      tmp_post_2 = lgl->next2;
      lgl->next2 = lgl->next2 + 1;
      lit=lglpeek(&lgl->trail, tmp_post_2);
      lglprop2(lgl, lit);
    }

    else
    {
      if(lgl->next >= trail)
        break;

      count = count + 1;
      tmp_post_3 = lgl->next;
      lgl->next = lgl->next + 1;
      lit=lglpeek(&lgl->trail, tmp_post_3);
      lglprop(lgl, lit);
    }
  }
  if(!(lgl->lkhd == 0))
    lgl->stats->props.lkhd = lgl->stats->props.lkhd + (signed long int)count;

  else
    if(!(lgl->simp == 0))
      lgl->stats->props.simp = lgl->stats->props.simp + (signed long int)count;

    else
      lgl->stats->props.search = lgl->stats->props.search + (signed long int)count;
  return (signed int)!(lgl->conf.lit != 0);
}

// lglbcpsearch
// file lglib.c line 4756
static signed int lglbcpsearch(struct LGL *lgl)
{
  signed int lit;
  signed int count = 0;
  unsigned long int return_value_lglcntstk_1;
  signed int tmp_post_2;
  for( ; (_Bool)1; count = count + 1)
  {
    if(!(lgl->failed == 0))
    {
      if(!(lgl->level == 0))
        goto __CPROVER_DUMP_L3;

    }

    if(!(lgl->conf.lit == 0))
      break;

    return_value_lglcntstk_1=lglcntstk(&lgl->trail);
    if((unsigned long int)lgl->next >= return_value_lglcntstk_1)
      break;

    tmp_post_2 = lgl->next;
    lgl->next = lgl->next + 1;
    lit=lglpeek(&lgl->trail, tmp_post_2);
    lglpropsearch(lgl, lit);
  }

__CPROVER_DUMP_L3:
  ;
  lgl->stats->props.search = lgl->stats->props.search + (signed long int)count;
  lgl->next2 = lgl->next;
  if(!(lgl->conf.lit == 0))
  {
    if(!(lgl->failed == 0))
    {

    __CPROVER_DUMP_L4:
      ;
      lgl->failed = 0;
    }

  }

  _Bool tmp_if_expr_3;
  if(lgl->conf.lit == 0)
    tmp_if_expr_3 = !(lgl->failed != 0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  return (signed int)tmp_if_expr_3;
}

// lglbcptop
// file lglib.c line 17200
static signed int lglbcptop(struct LGL *lgl)
{
  signed int res;
  signed int return_value_lglbcp_1;
  return_value_lglbcp_1=lglbcp(lgl);
  if(!(return_value_lglbcp_1 == 0))
    res = 1;

  else
  {
    lglana(lgl);
    if(!(lgl->conf.lit == 0))
    {

    __CPROVER_DUMP_L2:
      ;
      if(lgl->mt == 0)
        lgl->mt = 1;

    }

    res = 0;
  }
  return res;
}

// lglblock
// file lglib.c line 11378
static void lglblock(struct LGL *lgl)
{
  signed int oldrem = (signed int)lgl->blkrem;
  signed int oldall = (signed int)lgl->blkall;
  signed int idx;
  signed int count;
  signed int frozen;
  signed int all;
  signed int rem;
  struct Stk blocked[5l];
  lglstart(lgl, &lgl->times->blk);
  if(!(lgl->level == 0))
    lglbacktrack(lgl, 0);

  lgl->blocking = (char)1;
  lgl->simp = lgl->blocking;
  lgl->stats->blk.count = lgl->stats->blk.count + 1;
  lglgc(lgl);
  lglfreezer(lgl);
  all = (signed int)(!(oldrem != 0) || !(oldall != 0));
  signed int return_value_lgleschedrem_1;
  if(!(all == 0))
    lglprt(lgl, 1, "[block-%d] scheduling all variables this time", lgl->stats->blk.count);

  else
  {
    return_value_lgleschedrem_1=lgleschedrem(lgl, 1);
    if(return_value_lgleschedrem_1 == 0)
    {
      all = 1;
      oldrem = 0;
    }

  }
  if(all == 0)
    lgl->donotsched = (char)1;

  lgldense(lgl, 1);
  if(all == 0)
    lgl->donotsched = (char)0;

  lglsetblklim(lgl);
  do
    memset((void *)&blocked, 0, sizeof(struct Stk [5l]) /*120ul*/ );
  while((_Bool)0);
  count = 0;
  signed int return_value_lglterminate_2;
  signed int return_value_lglmtstk_3;
  _Bool tmp_if_expr_13;
  signed int return_value_lglocc_12;
  signed int return_value_lglpurelit_6;
  _Bool tmp_if_expr_11;
  signed int return_value_lglocc_10;
  signed int return_value_lglpurelit_7;
  do
  {
    return_value_lglterminate_2=lglterminate(lgl);
    if(!(return_value_lglterminate_2 == 0))
      break;

    if(lgl->stats->blk.steps >= lgl->limits->blk.steps)
      break;

    return_value_lglmtstk_3=lglmtstk(&lgl->esched);
    if(!(return_value_lglmtstk_3 == 0))
      break;

    idx=lglpopesched(lgl);
    struct AVar *return_value_lglavar_4;
    return_value_lglavar_4=lglavar(lgl, idx);
    return_value_lglavar_4->donotblk = (unsigned int)1;
    frozen=lglifrozen(lgl, idx);
    signed int return_value_lglisfree_5;
    return_value_lglisfree_5=lglisfree(lgl, idx);
    if(!(return_value_lglisfree_5 == 0))
    {
      if(frozen == 0)
      {
        return_value_lglocc_12=lglocc(lgl, idx);
        tmp_if_expr_13 = !(return_value_lglocc_12 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_13 = (_Bool)0;
      if(tmp_if_expr_13)
      {
        return_value_lglpurelit_6=lglpurelit(lgl, -idx);
        count = count + return_value_lglpurelit_6;
      }

      else
      {
        if(frozen == 0)
        {
          return_value_lglocc_10=lglocc(lgl, -idx);
          tmp_if_expr_11 = !(return_value_lglocc_10 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_11 = (_Bool)0;
        if(tmp_if_expr_11)
        {
          return_value_lglpurelit_7=lglpurelit(lgl, idx);
          count = count + return_value_lglpurelit_7;
        }

        else
        {
          signed int return_value_lglblocklit_8;
          return_value_lglblocklit_8=lglblocklit(lgl, idx, blocked);
          count = count + return_value_lglblocklit_8;
          signed int return_value_lglblocklit_9;
          return_value_lglblocklit_9=lglblocklit(lgl, -idx, blocked);
          count = count + return_value_lglblocklit_9;
        }
      }
    }

  }
  while((_Bool)1);
  unsigned long int return_value_lglcntstk_14;
  return_value_lglcntstk_14=lglcntstk(&lgl->esched);
  rem = (signed int)return_value_lglcntstk_14;
  double return_value_lglpcnt_15;
  if(rem == 0)
    lglprt(lgl, 1, "[block-%d] fully completed blocked clause elimination", lgl->stats->blk.count);

  else
    if(oldrem == 0)
    {
      return_value_lglpcnt_15=lglpcnt((double)rem, (double)(lgl->nvars - 2));
      lglprt(lgl, 1, "[block-%d] incomplete blocked clause elimination %d not tried %.0f%%", lgl->stats->blk.count, rem, return_value_lglpcnt_15);
    }

    else
      rem=lgleschedrem(lgl, 0);
  lglsetdonotesched(lgl, (signed int)!(rem != 0));
  lglrelstk(lgl, &lgl->esched);
  lglsparse(lgl);
  lglgc(lgl);
  lglrelstk(lgl, blocked + (signed long int)2);
  lglrelstk(lgl, blocked + (signed long int)3);
  lglrelstk(lgl, blocked + (signed long int)4);
  lgl->blkrem = (char)(rem > 0);
  lgl->blkall = (char)(all != 0 && rem != 0);
  lglprt(lgl, 1, "[block-%d] transition to [ all %d rem %d ] state", lgl->stats->blk.count, lgl->blkall, lgl->blkrem);
  lgl->simp = (char)0;
  lgl->blocking = lgl->simp;
  lgl->stats->irrprgss = lgl->stats->irrprgss + (signed long int)count;
  lglupdblkint(lgl, count);
  lglprt(lgl, 1, "[block-%d] eliminated %d blocked clauses", lgl->stats->blk.count, count);
  lglrep(lgl, 1 + (signed int)!(count != 0), (char)107);
  lglstop(lgl);
}

// lglblockcls
// file lglib.c line 11069
static signed int lglblockcls(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int lidx;
  signed int val;
  signed int count;
  signed int size;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  const signed int *l;
  struct HTS *hts;
  lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;
  hts=lglhts(lgl, lit);
  if(hts->count == 0)
    return 1;

  else
  {
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    count = 0;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      blit = *p;
      tag = blit & MASKCS;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      if(!(tag == LRGCS))
      {
        red = blit & REDCS;
        if(red == 0)
        {
          count = count + 1;
          lgl->stats->blk.res = lgl->stats->blk.res + 1l;
          lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;
          if(tag == BINCS || tag == TRNCS)
          {
            other = blit >> RMSHFT;
            val=lglmarked(lgl, other);
            if(!(val >= 0))
              goto __CPROVER_DUMP_L10;

            if(tag == TRNCS)
            {
              other2 = *p;
              val=lglmarked(lgl, other2);
              if(!(val >= 0))
                goto __CPROVER_DUMP_L10;

            }

          }

          else
          {
            lidx = blit >> RMSHFT;
            c=lglidx2lits(lgl, OCCS, 0, lidx);
            size = 0;
            l = c;
            do
            {
              other = *l;
              if(other == 0)
                break;

              val=lglmarked(lgl, other);
              size = size + 1;
              if(!(lgl->opts->blkclslim.val >= size))
                return 0;

              if(!(val >= 0))
                break;

              l = l + 1l;
            }
            while((_Bool)1);
            if(!(other == 0))
              goto __CPROVER_DUMP_L10;

          }
          return 0;
        }

      }


    __CPROVER_DUMP_L10:
      ;
    }

  __CPROVER_DUMP_L11:
    ;
    return 1;
  }
}

// lglblocking
// file lglib.c line 16961
static signed int lglblocking(struct LGL *lgl)
{
  if(lgl->opts->block.val == 0)
    return 0;

  else
  {
    signed int return_value_lglsmallirr_1;
    return_value_lglsmallirr_1=lglsmallirr(lgl);
    if(return_value_lglsmallirr_1 == 0)
      return 0;

    else
      if(!(lgl->nvars >= 3))
        return 0;

      else
        if(!(lgl->mt == 0))
          return 0;

        else
          if(!(lgl->blkrem == 0))
            return 1;

          else
            return (signed int)(lgl->stats->irrprgss > lgl->limits->blk.irrprgss);
  }
}

// lglblockinglit
// file lglib.c line 10012
static void lglblockinglit(struct LGL *lgl, signed int ilit)
{
  signed int elit;
  elit=lglexport(lgl, ilit);
  signed int sgnbit = 1 << (signed int)(elit < 0);
  struct Ext *ext;
  ext=lglelit2ext(lgl, elit);
  if((sgnbit & (signed int)ext->blocking) == 0)
  {
    ext->blocking = (unsigned int)ext->blocking | (unsigned int)sgnbit;

  __CPROVER_DUMP_L2:
    ;
    lgl->stats->blk.lits = lgl->stats->blk.lits + 1;
  }

}

// lglblocklit
// file lglib.c line 11180
static signed int lglblocklit(struct LGL *lgl, signed int lit, struct Stk *stk)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int blocked;
  signed int other;
  signed int other2;
  signed int lidx;
  signed int count;
  signed int size;
  signed int *p;
  signed int *w;
  signed int *eow;
  signed int *c;
  signed int *l;
  struct HTS *hts;
  signed char return_value_lglval_1;
  return_value_lglval_1=lglval(lgl, lit);
  signed long int tmp_post_3;
  signed int return_value_lglmtstk_7;
  signed long int tmp_post_8;
  signed int return_value_lglmtstk_9;
  signed long int tmp_post_10;
  signed int return_value_lglmtstk_11;
  signed long int tmp_post_12;
  if(!(return_value_lglval_1 == 0))
    return 0;

  else
  {
    signed int return_value_lgl2manyoccs4blk_2;
    return_value_lgl2manyoccs4blk_2=lgl2manyoccs4blk(lgl, lit);
    if(!(return_value_lgl2manyoccs4blk_2 == 0))
      return 0;

    else
    {
      hts=lglhts(lgl, lit);
      w=lglhts2wchs(lgl, hts);
      eow = w + (signed long int)hts->count;
      count = 0;
      p = w;
      for( ; !(p >= eow); p = p + 1l)
      {
        tmp_post_3 = lgl->stats->blk.steps;
        lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;
        if(tmp_post_3 >= lgl->limits->blk.steps)
          break;

        blit = *p;
        tag = blit & MASKCS;
        if(tag == TRNCS || tag == LRGCS)
          p = p + 1l;

        if(!(tag == LRGCS))
        {
          red = blit & REDCS;
          if(red == 0)
          {
            blocked = 0;
            if(tag == BINCS || tag == TRNCS)
            {
              other = blit >> RMSHFT;
              signed int return_value_lgl2manyoccs4blk_4;
              return_value_lgl2manyoccs4blk_4=lgl2manyoccs4blk(lgl, other);
              if(!(return_value_lgl2manyoccs4blk_4 == 0))
                goto __CPROVER_DUMP_L13;

              lglpushnmarkseen(lgl, other);
              if(tag == TRNCS)
              {
                other2 = *p;
                signed int return_value_lgl2manyoccs4blk_5;
                return_value_lgl2manyoccs4blk_5=lgl2manyoccs4blk(lgl, other2);
                if(!(return_value_lgl2manyoccs4blk_5 == 0))
                  goto CONTINUE;

                lglpushnmarkseen(lgl, other2);
              }

            }

            else
            {
              lidx = blit >> RMSHFT;
              c=lglidx2lits(lgl, OCCS, 0, lidx);
              size = 0;
              l = c;
              do
              {
                other = *l;
                if(other == 0)
                  break;

                if(!(other == lit))
                {
                  signed int return_value_lgl2manyoccs4blk_6;
                  return_value_lgl2manyoccs4blk_6=lgl2manyoccs4blk(lgl, other);
                  if(!(return_value_lgl2manyoccs4blk_6 == 0))
                    goto CONTINUE;

                  size = size + 1;
                  if(!(lgl->opts->blkclslim.val >= size))
                    goto CONTINUE;

                  lglpushnmarkseen(lgl, other);
                }

                l = l + 1l;
              }
              while((_Bool)1);
            }
            blocked=lglblockcls(lgl, -lit);

          CONTINUE:
            ;
            lglpopnunmarkstk(lgl, &lgl->seen);
            if(!(blocked == 0))
            {
              if(tag == BINCS)
              {
                other = blit >> RMSHFT;
                lglpushstk(lgl, stk + (signed long int)2, other);
              }

              else
                if(tag == TRNCS)
                {
                  other = blit >> RMSHFT;
                  lglpushstk(lgl, stk + (signed long int)3, other);
                  other2 = *p;
                  lglpushstk(lgl, stk + (signed long int)3, other2);
                }

                else
                {
                  lidx = blit >> RMSHFT;
                  lglpushstk(lgl, stk + (signed long int)4, lidx);
                }
            }

          }

        }


      __CPROVER_DUMP_L13:
        ;
      }
      do
      {
        return_value_lglmtstk_7=lglmtstk(stk + (signed long int)2);
        if(!(return_value_lglmtstk_7 == 0))
          break;

        tmp_post_8 = lgl->stats->blk.steps;
        lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;
        if(tmp_post_8 >= lgl->limits->blk.steps)
          break;

        count = count + 1;
        other=lglpopstk(stk + (signed long int)2);

      __CPROVER_DUMP_L15:
        ;
        lglrmbcls(lgl, lit, other, 0);
        lglepush(lgl, 0);
        lglepush(lgl, lit);
        lglepush(lgl, other);
        if(!(lgl->opts->move.val == 0))
          lglmvbcls(lgl, lit, other);

      }
      while((_Bool)1);
      do
      {
        return_value_lglmtstk_9=lglmtstk(stk + (signed long int)3);
        if(!(return_value_lglmtstk_9 == 0))
          break;

        tmp_post_10 = lgl->stats->blk.steps;
        lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;
        if(tmp_post_10 >= lgl->limits->blk.steps)
          break;

        count = count + 1;
        other2=lglpopstk(stk + (signed long int)3);
        other=lglpopstk(stk + (signed long int)3);

      __CPROVER_DUMP_L18:
        ;
        lglrmtcls(lgl, lit, other, other2, 0);
        lglepush(lgl, 0);
        lglepush(lgl, lit);
        lglepush(lgl, other);
        lglepush(lgl, other2);
        if(lgl->opts->move.val >= 2)
          lglmvtcls(lgl, lit, other, other2);

      }
      while((_Bool)1);
      do
      {
        return_value_lglmtstk_11=lglmtstk(stk + (signed long int)4);
        if(!(return_value_lglmtstk_11 == 0))
          break;

        tmp_post_12 = lgl->stats->blk.steps;
        lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;
        if(tmp_post_12 >= lgl->limits->blk.steps)
          break;

        lidx=lglpopstk(stk + (signed long int)4);
        count = count + 1;
        c=lglidx2lits(lgl, LRGCS, 0, lidx);

      __CPROVER_DUMP_L21:
        ;
        lglepush(lgl, 0);
        lglepush(lgl, lit);
        l = c;
        do
        {
          other = *l;
          if(other == 0)
            break;

          if(!(other == lit))
            lglepush(lgl, other);

          l = l + 1l;
        }
        while((_Bool)1);
        lglrmlcls(lgl, lidx, 0);
      }
      while((_Bool)1);

    __CPROVER_DUMP_L25:
      ;
      lgl->stats->blk.clauses = lgl->stats->blk.clauses + count;
      if(count >= 1)
        lglblockinglit(lgl, lit);

      lglclnstk(stk + (signed long int)2);
      lglclnstk(stk + (signed long int)3);
      lglclnstk(stk + (signed long int)4);
      return count;
    }
  }
}

// lglbnr
// file lglib.h line 100
void lglbnr(const char *name, const char *prefix, struct _IO_FILE *file)
{
  const char *p = "-Wall -O3 -DNLGLOG -DNDEBUG -DNCHKSOL -DNLGLPICOSAT ";
  const char *q;
  const char *n;
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(prefix);
  len = (signed int)((unsigned long int)78 - return_value_strlen_1);
  fprintf(file, "%s%s\n", prefix, name);
  fprintf(file, "%s\n", prefix);
  fprintf(file, "%sVersion %s %s\n", prefix, (const void *)"ala", (const void *)"b02aa1a04343558c4252b5f4a723be021964f652");
  fprintf(file, "%s\n", prefix);
  fprintf(file, "%sCopyright (C) 2010-2012 Armin Biere JKU Linz Austria.\n", prefix);
  fprintf(file, "%sAll rights reserved.\n", prefix);
  fprintf(file, "%s\n", prefix);
  fprintf(file, "%sreleased %s\n", prefix, (const void *)"Sat Oct 13 14:05:26 CEST 2012");
  fprintf(file, "%scompiled %s\n", prefix, (const void *)"Sat Jan 23 21:15:39 UTC 2016");
  fprintf(file, "%s\n", prefix);
  fprintf(file, "%s%s\n", prefix, (const void *)"gcc-5.orig (Debian 5.3.1-7) 5.3.1 20160121");
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  const char *tmp_post_4;
  do
  {
    fputs(prefix, file);
    q = p;
    do
    {
      if(!(*q == 0))
        tmp_if_expr_2 = (signed int)*q != 32 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        break;

      q = q + 1l;
    }
    while((_Bool)1);
    if(!(*q == 0))
    {
      if(!(q - p >= (signed long int)len))
        do
        {
          n = q + (signed long int)1;
          do
          {
            if(!(*n == 0))
              tmp_if_expr_3 = (signed int)*n != 32 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_3 = (_Bool)0;
            if(!tmp_if_expr_3)
              break;

            n = n + 1l;
          }
          while((_Bool)1);
          if(n - p >= (signed long int)len)
            break;

          q = n;
          if(*n == 0)
            break;

        }
        while((_Bool)1);

    }

    while(!(p >= q))
    {
      tmp_post_4 = p;
      p = p + 1l;
      fputc((signed int)*tmp_post_4, file);
    }
    fputc(10, file);
    if(*p == 0)
      break;

    p = p + 1l;
  }
  while((_Bool)1);
  fprintf(file, "%s%s\n", prefix, (const void *)"Linux mt-farm05 3.16.0-4-amd64 x86_64");
  fprintf(file, "%s\n", prefix);
  fflush(file);
}

// lglbonflict
// file lglib.c line 4011
static void lglbonflict(struct LGL *lgl, signed int lit, signed int blit)
{
  lgl->conf.lit = lit;
  lgl->conf.rsn[(signed long int)0] = blit;

__CPROVER_DUMP_L1:
  ;
}

// lglboundredl
// file lglib.c line 5182
static void lglboundredl(struct LGL *lgl)
{
  signed long int minabs;
  signed long int minrel;
  signed long int maxabs;
  signed long int maxrel;
  signed long int oldlim;
  signed long int newlim;
  oldlim = (signed long int)lgl->limits->reduce.inner;
  newlim = oldlim;
  if(!(lgl->opts->redlbound.val == 0))
  {
    lglprt(lgl, 2, "preliminary reduce limit %d before bounding", oldlim);
    minrel = (signed long int)lgl->opts->redlminrel.val;
    minrel = minrel * (((signed long int)lgl->stats->irr.clauses.cur + 99ll) / 100ll);
    minabs = (signed long int)lgl->opts->redlminabs.val;
    lglprt(lgl, 2, "minrel = %d, minabs = %d", minrel, minabs);
    if(!(minrel >= minabs))
    {
      if(!((signed long int)lgl->limits->reduce.inner >= minrel))
      {
        lglprt(lgl, 2, "relative minimum reduce limit %d hit", minrel);
        newlim = minrel;
      }

    }

    else
      if(!((signed long int)lgl->limits->reduce.inner >= minabs))
      {
        lglprt(lgl, 2, "absolute minimum reduce limit of %d hit", minabs);
        newlim = minabs;
      }

    maxrel = (signed long int)lgl->opts->redlmaxrel.val;
    maxrel = maxrel * (((signed long int)lgl->stats->irr.clauses.cur + 99ll) / 100ll);
    maxrel = maxrel + (signed long int)lgl->opts->redlmininc.val * (signed long int)lgl->limits->reduce.extra;
    maxabs = (signed long int)lgl->opts->redlmaxabs.val;
    lglprt(lgl, 2, "maxrel = %d, maxabs = %d", maxrel, maxabs);
    if(!(maxrel >= maxabs))
    {
      lgl->limits->reduce.extra = lgl->limits->reduce.extra + 1;
      if(!(maxrel >= (signed long int)lgl->limits->reduce.inner))
      {
        lglprt(lgl, 2, "relative maximum reduce limit %d hit", maxrel);
        newlim = maxrel;
      }

    }

    else
      if(!(maxabs >= (signed long int)lgl->limits->reduce.inner))
      {
        lglprt(lgl, 2, "absolute maximum reduce limit of %d hit", maxabs);
        newlim = maxabs;
      }

  }


SKIP:
  ;
  lgl->limits->reduce.inner = (signed int)newlim;
  lglprt(lgl, 2, "new reduce limit of %d redundant clauses after %lld conflicts", lgl->limits->reduce.inner, (signed long long int)lgl->stats->confs);
}

// lglbrutefork
// file lglib.h line 79
struct LGL * lglbrutefork(struct LGL *lgl, signed int complete)
{
  struct LGL *return_value_lglforkaux_1;
  return_value_lglforkaux_1=lglforkaux(lgl, 1, complete);
  return return_value_lglforkaux_1;
}

// lglbumplidx
// file lglib.c line 3491
static signed int lglbumplidx(struct LGL *lgl, signed int lidx)
{
  signed int glue = lidx & (1 << 4) - 1;
  signed int *c;
  signed int *ap;
  signed int act;
  struct Stk *lir = lgl->red + (signed long int)glue;
  lidx = lidx >> 4;
  c = lir->start + (signed long int)lidx;
  ap = c - (signed long int)1;
  act = *ap;
  if(!(act >= 0x7fffffff))
  {

  __CPROVER_DUMP_L1:
    ;
    act = act + 1;

  __CPROVER_DUMP_L2:
    ;
    *ap = act;
  }


__CPROVER_DUMP_L3:
  ;
  lgl->stats->lir[(signed long int)glue].resolved = lgl->stats->lir[(signed long int)glue].resolved + 1l;
  return (signed int)(act >= 0x7fffffff - 1);
}

// lglbumplits
// file lglib.c line 5994
static void lglbumplits(struct LGL *lgl)
{
  const signed int *p;
  lglstart(lgl, &lgl->times->bump);
  p = lgl->seen.start;
  for( ; !(p >= lgl->seen.top); p = p + 1l)
    lglvmtf(lgl, *p);
  lgldeprioritize(lgl);
  lglstop(lgl);
}

// lglbytes
// file lglib.c line 5002
unsigned long int lglbytes(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglbytes");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  return lgl->stats->bytes.current;
}

// lglca
// file lglib.c line 4161
static signed int lglca(struct LGL *lgl, signed int a, signed int b)
{
  signed int blit;
  signed int tag;
  signed int mark;
  signed int negmark;
  signed int prevmark;
  signed int c;
  signed int res;
  signed int prev;
  signed int lglca__1__next;
  signed int al;
  signed int bl;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  struct HTS *hts;
  unsigned long int return_value_lglcntstk_1;
  signed int tmp_post_2;
  if(a == 0)
    return b;

  else
    if(b == 0)
      return a;

    else
      if(a == b)
        return a;

      else
        if(a == -b)
          return 0;

        else
        {
          al=lglevel(lgl, a);
          bl=lglevel(lgl, b);
          if(al == 0)
            return b;

          else
            if(bl == 0)
              return a;

            else
            {
              lglcamark(lgl, a, 1);
              lglcamark(lgl, b, 2);
              lglca__1__next = 0;
              res = lglca__1__next;
              do
              {
                return_value_lglcntstk_1=lglcntstk(&lgl->_anon1.lcaseen);
                if((unsigned long int)lglca__1__next >= return_value_lglcntstk_1)
                  break;

                tmp_post_2 = lglca__1__next;
                lglca__1__next = lglca__1__next + 1;
                c=lglpeek(&lgl->_anon1.lcaseen, tmp_post_2);
                mark=lglcamarked(lgl, c);
                negmark = mark ^ 3;
                hts=lglhts(lgl, c);
                if(!(hts->count == 0))
                {
                  w=lglhts2wchs(lgl, hts);
                  eow = w + (signed long int)hts->count;
                  p = w;
                  for( ; !(p >= eow); p = p + 1l)
                  {
                    blit = *p;
                    tag = blit & MASKCS;
                    if(tag == TRNCS || tag == LRGCS)
                      p = p + 1l;

                    if(tag == BINCS)
                    {
                      prev = -(blit >> RMSHFT);
                      signed int return_value_lglevel_3;
                      return_value_lglevel_3=lglevel(lgl, prev);
                      if(!(return_value_lglevel_3 == 0))
                      {
                        signed char return_value_lglval_4;
                        return_value_lglval_4=lglval(lgl, prev);
                        if((signed int)return_value_lglval_4 >= 1)
                        {
                          prevmark=lglcamarked(lgl, prev);
                          if(prevmark >= 0)
                          {
                            if(!(mark == prevmark))
                            {
                              if(prevmark == negmark)
                              {
                                res = prev;
                                goto DONE;
                              }

                              lglcamark(lgl, prev, mark);
                            }

                          }

                        }

                      }

                    }

                  }
                }

              }
              while((_Bool)1);

            DONE:
              ;
              lglpopnunlcamarkstk(lgl, &lgl->_anon1.lcaseen);

            __CPROVER_DUMP_L17:
              ;
              return res;
            }
        }
}

// lglcamark
// file lglib.c line 4147
static void lglcamark(struct LGL *lgl, signed int lit, signed int mark)
{
  signed int newmark;
  struct AVar *av;
  av=lglavar(lgl, lit);
  newmark = mark;
  if(!(lit >= 0))
    newmark = newmark << 2;

  av->lcamark = (unsigned int)newmark;
  lglpushstk(lgl, &lgl->_anon1.lcaseen, lit);
}

// lglcamarked
// file lglib.c line 4137
static signed int lglcamarked(struct LGL *lgl, signed int lit)
{
  struct AVar *return_value_lglavar_1;
  return_value_lglavar_1=lglavar(lgl, lit);
  switch((signed int)return_value_lglavar_1->lcamark)
  {
    case 1:
      return lit < 0 ? -1 : 1;
    case 2:
      return lit < 0 ? -2 : 2;
    case 4:
      return lit < 0 ? 1 : -1;
    case 8:
      return lit < 0 ? 2 : -2;
    default:
      return 0;
  }
}

// lglcard
// file lglib.c line 16873
static void lglcard(struct LGL *lgl)
{
  signed int *card;
  signed int idx;
  signed int sign;
  signed int lit;
  signed int lglcard__1__start;
  signed int size;
  signed int count;
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  signed int i;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  struct Stk atmostone;
  signed long int sum;
  struct HTS *hts;
  lglstart(lgl, &lgl->times->card);
  do
    memset((void *)&atmostone, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  lglpushstk(lgl, &atmostone, 0);
  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
    card = (signed int *)return_value_lglnew_1;
  }
  while((_Bool)0);
  card = card + (signed long int)lgl->nvars;
  count = 0;
  sum = (signed long int)0;
  idx = 2;
  unsigned long int return_value_lglcntstk_3;
  unsigned long int return_value_lglcntstk_7;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = idx * sign;
      if(card[(signed long int)lit] == 0)
      {
        unsigned long int return_value_lglcntstk_2;
        return_value_lglcntstk_2=lglcntstk(&atmostone);
        lglcard__1__start = (signed int)return_value_lglcntstk_2;

      __CPROVER_DUMP_L5:
        ;
        lglpushstk(lgl, &atmostone, lit);
        card[(signed long int)lit] = lglcard__1__start;
        hts=lglhts(lgl, -lit);
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          tag = blit & MASKCS;
          if(tag == TRNCS || tag == LRGCS)
            p = p + 1l;

          if(tag == BINCS)
          {
            other = -(blit >> RMSHFT);
            if(card[(signed long int)other] == 0)
            {
              i = lglcard__1__start + 1;
              do
              {
                return_value_lglcntstk_3=lglcntstk(&atmostone);
                if((unsigned long int)i >= return_value_lglcntstk_3)
                  break;

                other2=lglpeek(&atmostone, i);
                signed int return_value_lglhasbin_4;
                return_value_lglhasbin_4=lglhasbin(lgl, -other, -other2);
                if(return_value_lglhasbin_4 == 0)
                  break;

                i = i + 1;
              }
              while((_Bool)1);
              unsigned long int return_value_lglcntstk_5;
              return_value_lglcntstk_5=lglcntstk(&atmostone);
              if((unsigned long int)i >= return_value_lglcntstk_5)
              {
                card[(signed long int)other] = lglcard__1__start;
                lglpushstk(lgl, &atmostone, other);
              }

            }

          }


        __CPROVER_DUMP_L10:
          ;
        }
        unsigned long int return_value_lglcntstk_6;
        return_value_lglcntstk_6=lglcntstk(&atmostone);
        size = (signed int)(return_value_lglcntstk_6 - (unsigned long int)lglcard__1__start);
        if(!(size >= 3))
        {

        __CPROVER_DUMP_L13:
          ;
          do
          {
            return_value_lglcntstk_7=lglcntstk(&atmostone);
            if((unsigned long int)lglcard__1__start >= return_value_lglcntstk_7)
              break;

            other=lglpopstk(&atmostone);
            card[(signed long int)other] = 0;
          }
          while((_Bool)1);
        }

        else
        {
          lglpushstk(lgl, &atmostone, 0);
          sum = sum + (signed long int)size;
          count = count + 1;
        }
      }

    }
  }
  card = card - (signed long int)lgl->nvars;
  do
  {
    lgldel(lgl, (void *)card, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
    card = ((signed int *)NULL);
  }
  while((_Bool)0);
  lglrelstk(lgl, &atmostone);
  double return_value_lglavg_8;
  return_value_lglavg_8=lglavg((double)sum, (double)count);
  lglprt(lgl, 1, "[card] found %d at-most-one constraints of average size %.1f", count, return_value_lglavg_8);
  lglstop(lgl);
}

// lglcassume
// file lglib.c line 3980
void lglcassume(struct LGL *lgl, signed int elit)
{
  signed int eidx;
  eidx=abs(elit);
  struct Ext *ext;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglcassume");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "cassume %d", elit);
    break;
  }
  lgl->stats->calls.cassume = lgl->stats->calls.cassume + 1l;
  if(eidx >= 1)
  {
    if(lgl->maxext >= eidx)
    {
      ext=lglelit2ext(lgl, elit);
      while(!(ext->melted == 0u))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglcassume");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "assuming melted literal %d", elit);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
    }

  }

  lglecassume(lgl, elit);
  lgluse(lgl);
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglcassume(lgl->clone, elit);

}

// lglcce
// file lglib.c line 11856
static signed int lglcce(struct LGL *lgl)
{
  signed int oldrem = (signed int)lgl->ccerem;
  signed int oldall = (signed int)lgl->cceall;
  signed int oldirr;
  signed int eliminated;
  signed int idx;
  signed int all;
  signed int rem;
  signed int oldvars = lgl->nvars;
  lglstart(lgl, &lgl->times->cce);
  lgl->stats->cce.count = lgl->stats->cce.count + 1;
  lgl->simp = (char)1;
  lgl->cceing = lgl->simp;
  if(lgl->level >= 1)
    lglbacktrack(lgl, 0);

  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)1 * sizeof(struct CCE) /*56ul*/ );
    lgl->_anon0.cce = (struct CCE *)return_value_lglnew_1;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew_2;
    return_value_lglnew_2=lglnew(lgl, (unsigned long int)oldvars * sizeof(signed int) /*4ul*/ );
    lgl->_anon0.cce->rem = (signed int *)return_value_lglnew_2;
  }
  while((_Bool)0);
  idx = 2;
  for( ; !(idx >= oldvars); idx = idx + 1)
    lgl->_anon0.cce->rem[(signed long int)idx] = 0x7fffffff;
  lglgc(lgl);
  lglfreezer(lgl);
  all = (signed int)(!(oldrem != 0) || !(oldall != 0));
  signed int return_value_lgleschedrem_3;
  if(!(all == 0))
    lglprt(lgl, 1, "[cce-%d] scheduling all variables this time", lgl->stats->cce.count);

  else
  {
    return_value_lgleschedrem_3=lgleschedrem(lgl, 1);
    if(return_value_lgleschedrem_3 == 0)
    {
      all = 1;
      oldrem = 0;
    }

  }
  if(all == 0)
    lgl->donotsched = (char)1;

  lgldense(lgl, 1);
  if(all == 0)
    lgl->donotsched = (char)0;

  lglsetccelim(lgl);
  oldirr = lgl->stats->irr.clauses.cur;
  signed int return_value_lglmtstk_4;
  while(lgl->mt == 0)
  {
    return_value_lglmtstk_4=lglmtstk(&lgl->esched);
    if(!(return_value_lglmtstk_4 == 0))
      break;

    if(lgl->stats->cce.steps >= lgl->limits->cce.steps)
      break;

    idx=lglpopesched(lgl);
    struct AVar *return_value_lglavar_5;
    return_value_lglavar_5=lglavar(lgl, idx);
    return_value_lglavar_5->donotcce = (unsigned int)1;
    signed int return_value_lglocc_6;
    return_value_lglocc_6=lglocc(lgl, -idx);
    signed int return_value_lglocc_7;
    return_value_lglocc_7=lglocc(lgl, idx);
    if(!(return_value_lglocc_6 >= return_value_lglocc_7))
      idx = -idx;

    lglccelit(lgl, idx);
    if(!(lgl->mt == 0))
      break;

    lglccelit(lgl, -idx);
    lgl->stats->cce.steps = lgl->stats->cce.steps + 1l;
  }
  unsigned long int return_value_lglcntstk_8;
  return_value_lglcntstk_8=lglcntstk(&lgl->esched);
  rem = (signed int)return_value_lglcntstk_8;
  double return_value_lglpcnt_9;
  if(rem == 0)
    lglprt(lgl, 1, "[cce-%d] fully completed covered clause elimination", lgl->stats->cce.count);

  else
    if(oldrem == 0)
    {
      return_value_lglpcnt_9=lglpcnt((double)rem, (double)(lgl->nvars - 2));
      lglprt(lgl, 1, "[cce-%d] incomplete covered clause elimination %d not tried %.0f%%", lgl->stats->cce.count, rem, return_value_lglpcnt_9);
    }

    else
      rem=lgleschedrem(lgl, 0);
  lglsetdonotesched(lgl, (signed int)!(rem != 0));
  lglsparse(lgl);
  lglgc(lgl);
  lglrelstk(lgl, &lgl->_anon0.cce->extend);
  lglrelstk(lgl, &lgl->_anon0.cce->cla);
  do
  {
    lgldel(lgl, (void *)lgl->_anon0.cce->rem, (unsigned long int)oldvars * sizeof(signed int) /*4ul*/ );
    lgl->_anon0.cce->rem = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->_anon0.cce, (unsigned long int)1 * sizeof(struct CCE) /*56ul*/ );
    lgl->_anon0.cce = ((struct CCE *)NULL);
  }
  while((_Bool)0);
  lgl->ccerem = (char)(rem > 0);
  lgl->cceall = (char)(all != 0 && rem != 0);
  lglprt(lgl, 1, "[cce-%d] transition to [ all %d rem %d ] state", lgl->stats->cce.count, lgl->cceall, lgl->ccerem);
  eliminated = oldirr - lgl->stats->irr.clauses.cur;
  lglprt(lgl, 1, "[cce-%d] eliminated %d covered clauses", lgl->stats->cce.count, eliminated);
  lglupdcceint(lgl, eliminated);
  lgl->simp = (char)0;
  lgl->cceing = lgl->simp;
  lglrep(lgl, 1 + (signed int)!(eliminated != 0), (char)69);
  lglstop(lgl);
  return (signed int)!(lgl->mt != 0);
}

// lglcceclause
// file lglib.c line 11542
static signed int lglcceclause(struct LGL *lgl, const signed int *c, const signed int *ignwch, signed int igntag)
{
  signed int other;
  signed int res;
  signed int nextala;
  signed int nextcla;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int other2;
  const signed int *p;
  const signed int *eow;
  const signed int *w;
  const signed int *d;
  const signed int *q;
  signed int unit;
  signed int first;
  signed int old;
  signed int prev;
  struct HTS *hts;
  signed int *r;

__CPROVER_DUMP_L1:
  ;
  p = c;
  do
  {
    other = *p;
    if(other == 0)
      break;

    lglpushstk(lgl, &lgl->seen, other);
    lglpushstk(lgl, &lgl->_anon0.cce->cla, other);
    lglsignedmark(lgl, other);
    p = p + 1l;
  }
  while((_Bool)1);
  res = 0;
  nextala = res;
  nextcla = nextala;

ALA:
  ;
  unsigned long int return_value_lglcntstk_1;
  signed int tmp_post_2;
  signed int return_value_lglsignedmarked_3;
  signed int return_value_lglsignedmarked_8;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_13;
  unsigned long int return_value_lglcntstk_14;
  signed int tmp_post_15;
  signed int return_value_lglifrozen_16;
  unsigned long int return_value_lglcntstk_17;
  signed int return_value_lglsignedmarked_24;
  signed int return_value_lglsignedmarked_25;
  signed int *tmp_post_27;
  _Bool tmp_if_expr_31;
  signed int *tmp_post_30;
  signed int return_value_lglsignedmarked_32;
  signed int return_value_lglsignedmarked2_34;
  signed int *tmp_post_33;
  unsigned long int return_value_lglcntstk_35;
  _Bool tmp_if_expr_36;
  unsigned long int return_value_lglcntstk_38;
  while((_Bool)1)
  {
    if(res == 0)
    {
      return_value_lglcntstk_1=lglcntstk(&lgl->seen);
      if(!((unsigned long int)nextala >= return_value_lglcntstk_1))
      {
        tmp_post_2 = nextala;
        nextala = nextala + 1;
        lit=lglpeek(&lgl->seen, tmp_post_2);
        hts=lglhts(lgl, lit);
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; res == 0 && !(p >= eow); p = p + 1l)
        {
          lgl->stats->cce.steps = lgl->stats->cce.steps + 1l;
          if(lgl->stats->cce.steps >= lgl->limits->cce.steps)
            goto DONE;

          blit = *p;
          tag = blit & MASKCS;
          if(tag == TRNCS || tag == LRGCS)
            p = p + 1l;

          if(!(p == ignwch))
          {
            if(!(tag == LRGCS))
            {
              if((REDCS & blit) == 0)
              {
                other = blit >> RMSHFT;
                if(tag == BINCS)
                {
                  signed int return_value_lglsignedmarked_4;
                  return_value_lglsignedmarked_4=lglsignedmarked(lgl, -other);
                  if(!(return_value_lglsignedmarked_4 == 0))
                    goto __CPROVER_DUMP_L33;

                  else
                  {
                    return_value_lglsignedmarked_3=lglsignedmarked(lgl, other);
                    if(!(return_value_lglsignedmarked_3 == 0))
                    {
                      if(igntag == BINCS)
                      {
                        if(*c == lit)
                        {
                          if(c[1l] == other)
                            goto __CPROVER_DUMP_L33;

                        }

                        if(c[1l] == lit)
                        {
                          if(*c == other)
                            goto __CPROVER_DUMP_L33;

                        }

                      }


                    __CPROVER_DUMP_L9:
                      ;
                      res = 1;
                    }

                    else
                    {

                    __CPROVER_DUMP_L10:
                      ;
                      lglsignedmark(lgl, -other);
                      lglpushstk(lgl, &lgl->seen, -other);
                    }
                  }
                }

                else
                  if(tag == TRNCS)
                  {
                    signed int return_value_lglsignedmarked_5;
                    return_value_lglsignedmarked_5=lglsignedmarked(lgl, -other);
                    if(!(return_value_lglsignedmarked_5 == 0))
                      goto __CPROVER_DUMP_L33;

                    other2 = *p;
                    signed int return_value_lglsignedmarked_6;
                    return_value_lglsignedmarked_6=lglsignedmarked(lgl, -other2);
                    if(!(return_value_lglsignedmarked_6 == 0))
                      goto __CPROVER_DUMP_L33;

                    signed int return_value_lglsignedmarked_9;
                    return_value_lglsignedmarked_9=lglsignedmarked(lgl, other);
                    if(!(return_value_lglsignedmarked_9 == 0))
                    {
                      signed int return_value_lglsignedmarked_7;
                      return_value_lglsignedmarked_7=lglsignedmarked(lgl, other2);
                      if(!(return_value_lglsignedmarked_7 == 0))
                      {
                        if(igntag == TRNCS)
                        {
                          if(*c == lit)
                          {
                            if(c[1l] == other)
                            {
                              if(c[2l] == other2)
                                goto __CPROVER_DUMP_L33;

                            }

                          }

                          if(*c == lit)
                          {
                            if(c[2l] == other)
                            {
                              if(c[1l] == other2)
                                goto __CPROVER_DUMP_L33;

                            }

                          }

                          if(c[1l] == lit)
                          {
                            if(*c == other)
                            {
                              if(c[2l] == other2)
                                goto __CPROVER_DUMP_L33;

                            }

                          }

                          if(c[1l] == lit)
                          {
                            if(c[2l] == other)
                            {
                              if(*c == other2)
                                goto __CPROVER_DUMP_L33;

                            }

                          }

                          if(c[2l] == lit)
                          {
                            if(*c == other)
                            {
                              if(c[1l] == other2)
                                goto __CPROVER_DUMP_L33;

                            }

                          }

                          if(c[2l] == lit)
                          {
                            if(c[1l] == other)
                            {
                              if(*c == other2)
                                goto __CPROVER_DUMP_L33;

                            }

                          }

                        }


                      __CPROVER_DUMP_L19:
                        ;
                        res = 1;
                      }

                      else
                      {

                      __CPROVER_DUMP_L20:
                        ;
                        lglsignedmark(lgl, -other2);
                        lglpushstk(lgl, &lgl->seen, -other2);
                      }
                    }

                    else
                    {
                      return_value_lglsignedmarked_8=lglsignedmarked(lgl, other2);
                      if(!(return_value_lglsignedmarked_8 == 0))
                      {

                      __CPROVER_DUMP_L23:
                        ;
                        lglsignedmark(lgl, -other);
                        lglpushstk(lgl, &lgl->seen, -other);
                      }

                    }
                  }

                  else
                  {
                    d=lglidx2lits(lgl, OCCS, 0, other);
                    if(!(d == c))
                    {
                      unit = 0;
                      q = d;
                      do
                      {
                        other = *q;
                        if(other == 0)
                          break;

                        if(!(other == lit))
                        {
                          signed int return_value_lglsignedmarked_10;
                          return_value_lglsignedmarked_10=lglsignedmarked(lgl, -other);
                          if(!(return_value_lglsignedmarked_10 == 0))
                            break;

                          signed int return_value_lglsignedmarked_11;
                          return_value_lglsignedmarked_11=lglsignedmarked(lgl, other);
                          if(return_value_lglsignedmarked_11 == 0)
                          {
                            if(!(unit == 0))
                              break;

                            unit = -other;
                          }

                        }

                        q = q + 1l;
                      }
                      while((_Bool)1);
                      if(other == 0)
                      {
                        if(unit == 0)
                        {

                        __CPROVER_DUMP_L31:
                          ;
                          res = 1;
                        }

                        else
                        {

                        __CPROVER_DUMP_L32:
                          ;
                          lglsignedmark(lgl, unit);
                          lglpushstk(lgl, &lgl->seen, unit);
                        }
                      }

                    }

                  }
              }

            }

          }


        __CPROVER_DUMP_L33:
          ;
        }
        goto ALA;
      }

    }

    if(!(res == 0))
      tmp_if_expr_12 = (_Bool)1;

    else
      tmp_if_expr_12 = !(lgl->opts->block.val != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_12)
      tmp_if_expr_13 = (_Bool)1;

    else
      tmp_if_expr_13 = lgl->opts->cce.val < 3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_13)
      goto SKIPCLA;


  __CPROVER_DUMP_L40:
    ;
    if(!(res == 0))
      goto SKIPCLA;

    return_value_lglcntstk_14=lglcntstk(&lgl->_anon0.cce->cla);
    if((unsigned long int)nextcla >= return_value_lglcntstk_14)
      goto SKIPCLA;

    tmp_post_15 = nextcla;
    nextcla = nextcla + 1;
    lit=lglpeek(&lgl->_anon0.cce->cla, tmp_post_15);
    return_value_lglifrozen_16=lglifrozen(lgl, lit);
    if(!(return_value_lglifrozen_16 == 0))
      goto __CPROVER_DUMP_L92;

    hts=lglhts(lgl, -lit);
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    return_value_lglcntstk_17=lglcntstk(&lgl->_anon0.cce->cla);
    old = (signed int)return_value_lglcntstk_17;
    first = 1;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      lgl->stats->cce.steps = lgl->stats->cce.steps + 1l;
      if(lgl->stats->cce.steps >= lgl->limits->cce.steps)
        goto DONE;

      blit = *p;
      tag = blit & MASKCS;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      if(!(tag == LRGCS))
      {
        if((REDCS & blit) == 0)
        {
          other = blit >> RMSHFT;
          if(!(first == 0))
          {
            if(tag == BINCS)
            {
              signed int return_value_lglsignedmarked_18;
              return_value_lglsignedmarked_18=lglsignedmarked(lgl, -other);
              if(!(return_value_lglsignedmarked_18 == 0))
                goto __CPROVER_DUMP_L79;

              signed int return_value_lglsignedmarked_19;
              return_value_lglsignedmarked_19=lglsignedmarked(lgl, other);
              if(return_value_lglsignedmarked_19 == 0)
                lglpushstk(lgl, &lgl->_anon0.cce->cla, other);

            }

            else
              if(tag == TRNCS)
              {
                signed int return_value_lglsignedmarked_20;
                return_value_lglsignedmarked_20=lglsignedmarked(lgl, -other);
                if(!(return_value_lglsignedmarked_20 == 0))
                  goto __CPROVER_DUMP_L79;

                signed int return_value_lglsignedmarked_21;
                return_value_lglsignedmarked_21=lglsignedmarked(lgl, -(*p));
                if(!(return_value_lglsignedmarked_21 == 0))
                  goto __CPROVER_DUMP_L79;

                signed int return_value_lglsignedmarked_22;
                return_value_lglsignedmarked_22=lglsignedmarked(lgl, other);
                if(return_value_lglsignedmarked_22 == 0)
                  lglpushstk(lgl, &lgl->_anon0.cce->cla, other);

                signed int return_value_lglsignedmarked_23;
                return_value_lglsignedmarked_23=lglsignedmarked(lgl, *p);
                if(return_value_lglsignedmarked_23 == 0)
                  lglpushstk(lgl, &lgl->_anon0.cce->cla, *p);

              }

              else
              {
                d=lglidx2lits(lgl, OCCS, 0, other);
                q = d;
                do
                {
                  other = *q;
                  if(other == 0)
                    break;

                  if(!(other == -lit))
                  {
                    return_value_lglsignedmarked_24=lglsignedmarked(lgl, -other);
                    if(!(return_value_lglsignedmarked_24 == 0))
                      break;

                  }

                  q = q + 1l;
                }
                while((_Bool)1);
                if(!(other == 0))
                  goto __CPROVER_DUMP_L79;

                q = d;
                do
                {
                  other = *q;
                  if(other == 0)
                    break;

                  if(!(other == -lit))
                  {
                    return_value_lglsignedmarked_25=lglsignedmarked(lgl, other);
                    if(return_value_lglsignedmarked_25 == 0)
                      lglpushstk(lgl, &lgl->_anon0.cce->cla, other);

                  }

                  q = q + 1l;
                }
                while((_Bool)1);
              }
            first = 0;
          }

          else
          {
            r = lgl->_anon0.cce->cla.start + (signed long int)old;
            if(tag == BINCS)
            {
              signed int return_value_lglsignedmarked_26;
              return_value_lglsignedmarked_26=lglsignedmarked(lgl, -other);
              if(!(return_value_lglsignedmarked_26 == 0))
                goto __CPROVER_DUMP_L79;

              q = r;
              for( ; !(q >= lgl->_anon0.cce->cla.top); q = q + 1l)
                if(*q == other)
                {
                  tmp_post_27 = r;
                  r = r + 1l;
                  *tmp_post_27 = *q;
                }

            }

            else
              if(tag == TRNCS)
              {
                signed int return_value_lglsignedmarked_28;
                return_value_lglsignedmarked_28=lglsignedmarked(lgl, -other);
                if(!(return_value_lglsignedmarked_28 == 0))
                  goto __CPROVER_DUMP_L79;

                other2 = *p;
                signed int return_value_lglsignedmarked_29;
                return_value_lglsignedmarked_29=lglsignedmarked(lgl, -other2);
                if(!(return_value_lglsignedmarked_29 == 0))
                  goto __CPROVER_DUMP_L79;

                q = r;
                for( ; !(q >= lgl->_anon0.cce->cla.top); q = q + 1l)
                {
                  if(*q == other)
                    tmp_if_expr_31 = (_Bool)1;

                  else
                    tmp_if_expr_31 = *q == other2 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_31)
                  {
                    tmp_post_30 = r;
                    r = r + 1l;
                    *tmp_post_30 = *q;
                  }

                }
              }

              else
              {
                d=lglidx2lits(lgl, OCCS, 0, other);
                q = d;
                do
                {
                  other = *q;
                  if(other == 0)
                    break;

                  if(!(other == -lit))
                  {
                    return_value_lglsignedmarked_32=lglsignedmarked(lgl, -other);
                    if(!(return_value_lglsignedmarked_32 == 0))
                      break;

                  }

                  q = q + 1l;
                }
                while((_Bool)1);
                if(!(other == 0))
                  goto __CPROVER_DUMP_L79;

                q = d;
                do
                {
                  other = *q;
                  if(other == 0)
                    break;

                  if(!(other == -lit))
                    lglsignedmark2(lgl, other);

                  q = q + 1l;
                }
                while((_Bool)1);
                q = r;
                for( ; !(q >= lgl->_anon0.cce->cla.top); q = q + 1l)
                {
                  other = *q;
                  return_value_lglsignedmarked2_34=lglsignedmarked2(lgl, other);
                  if(!(return_value_lglsignedmarked2_34 == 0))
                  {
                    tmp_post_33 = r;
                    r = r + 1l;
                    *tmp_post_33 = other;
                  }

                }
                q = d;
                do
                {
                  other = *q;
                  if(other == 0)
                    break;

                  if(!(other == -lit))
                    lglsignedunmark2(lgl, other);

                  q = q + 1l;
                }
                while((_Bool)1);
              }
            lgl->_anon0.cce->cla.top = r;
            if(lgl->_anon0.cce->cla.top == lgl->_anon0.cce->cla.start + (signed long int)old)
              break;

          }
        }

      }


    __CPROVER_DUMP_L79:
      ;
    }
    return_value_lglcntstk_35=lglcntstk(&lgl->_anon0.cce->cla);
    if(!((unsigned long int)old >= return_value_lglcntstk_35))
    {
      nextcla = 0;
      lglpushstk(lgl, &lgl->_anon0.cce->extend, 0);
      lglpushstk(lgl, &lgl->_anon0.cce->extend, lit);
      q = lgl->_anon0.cce->cla.start;
      for( ; !(q >= lgl->_anon0.cce->cla.start + (signed long int)old); q = q + 1l)
        if(!(*q == lit))
          lglpushstk(lgl, &lgl->_anon0.cce->extend, *q);

    }

    q = lgl->_anon0.cce->cla.start + (signed long int)old;
    do
    {
      if(res == 0)
        tmp_if_expr_36 = q < lgl->_anon0.cce->cla.top ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_36 = (_Bool)0;
      if(!tmp_if_expr_36)
        break;

      signed int return_value_lglsignedmarked_37;
      return_value_lglsignedmarked_37=lglsignedmarked(lgl, -(*q));
      if(!(return_value_lglsignedmarked_37 == 0))
      {

      __CPROVER_DUMP_L87:
        ;
        res = 1;
      }

      else
      {

      __CPROVER_DUMP_L88:
        ;
        lglpushstk(lgl, &lgl->seen, *q);
        lglsignedmark(lgl, *q);
      }
      q = q + 1l;
    }
    while((_Bool)1);
    if(!(p == eow) || !(res == 0))
      break;

    return_value_lglcntstk_38=lglcntstk(&lgl->seen);
    if((unsigned long int)nextala >= return_value_lglcntstk_38)
      break;

  }

__CPROVER_DUMP_L92:
  ;
  goto __CPROVER_DUMP_L40;

SKIPCLA:
  ;
  signed int return_value_lglifrozen_39;
  if(!(res == 0))
  {

  __CPROVER_DUMP_L94:
    ;
    lgl->stats->cce.ate = lgl->stats->cce.ate + 1;
  }

  else
    if(!(lgl->opts->block.val == 0))
    {
      if(lgl->opts->cce.val >= 2)
      {
        p = lgl->_anon0.cce->cla.start;
        for( ; !(p >= lgl->_anon0.cce->cla.top); p = p + 1l)
        {
          other = *p;
          return_value_lglifrozen_39=lglifrozen(lgl, other);
          if(return_value_lglifrozen_39 == 0)
          {
            res=lglabce(lgl, other);
            if(!(res == 0))
              break;

          }

        }
        if(!(res == 0))
        {

        __CPROVER_DUMP_L99:
          ;
          lglpushstk(lgl, &lgl->_anon0.cce->extend, 0);
          lglpushstk(lgl, &lgl->_anon0.cce->extend, other);
          p = lgl->_anon0.cce->cla.start;
          for( ; !(p >= lgl->_anon0.cce->cla.top); p = p + 1l)
            if(!(*p == other))
              lglpushstk(lgl, &lgl->_anon0.cce->extend, *p);

          lgl->stats->cce.abce = lgl->stats->cce.abce + 1;
        }

      }

    }

  if(!(res == 0))
    lgl->stats->cce.eliminated = lgl->stats->cce.eliminated + 1;


DONE:
  ;
  lglpopnunmarkstk(lgl, &lgl->seen);
  lglclnstk(&lgl->_anon0.cce->cla);
  signed int return_value_lglmtstk_40;
  if(!(res == 0))
  {
    return_value_lglmtstk_40=lglmtstk(&lgl->_anon0.cce->extend);
    if(return_value_lglmtstk_40 == 0)
    {
      prev = 0x7fffffff;
      p = lgl->_anon0.cce->extend.start;
      for( ; !(p >= lgl->_anon0.cce->extend.top); p = p + 1l)
      {
        lit = *p;
        lglepush(lgl, lit);
        if(prev == 0)
          lglblockinglit(lgl, lit);

        prev = lit;
      }
    }

  }

  lglclnstk(&lgl->_anon0.cce->extend);
  return res;
}

// lglcceing
// file lglib.c line 11478
static signed int lglcceing(struct LGL *lgl)
{
  if(lgl->opts->cce.val == 0)
    return 0;

  else
  {
    signed int return_value_lglsmallirr_1;
    return_value_lglsmallirr_1=lglsmallirr(lgl);
    if(return_value_lglsmallirr_1 == 0)
      return 0;

    else
      return 1;
  }
}

// lglccelit
// file lglib.c line 11808
static void lglccelit(struct LGL *lgl, signed int lit)
{
  signed int cls[4l];
  signed int blit;
  signed int tag;
  signed int *c;
  signed int other;
  signed int lidx;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *l;
  struct HTS *hts;
  signed int return_value_lglisfree_1;
  return_value_lglisfree_1=lglisfree(lgl, lit);
  signed int return_value_abs_12;
  signed int return_value_abs_13;
  if(!(return_value_lglisfree_1 == 0))
  {
    signed int return_value_lglrem_4;
    return_value_lglrem_4=lglrem(lgl);
    signed int return_value_abs_5;
    return_value_abs_5=abs(lit);
    if(!(return_value_lglrem_4 >= lgl->_anon0.cce->rem[(signed long int)return_value_abs_5]))
    {

    __CPROVER_DUMP_L2:
      ;
      lglbasicprobelit(lgl, -lit);
      signed int return_value_lglflush_2;
      return_value_lglflush_2=lglflush(lgl);
      if(return_value_lglflush_2 == 0)
        goto __CPROVER_DUMP_L18;

      signed int return_value_abs_3;
      return_value_abs_3=abs(lit);
      lgl->_anon0.cce->rem[(signed long int)return_value_abs_3]=lglrem(lgl);
    }


  __CPROVER_DUMP_L4:
    ;
    hts=lglhts(lgl, lit);
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    cls[(signed long int)0] = lit;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      lgl->stats->cce.steps = lgl->stats->cce.steps + 1l;
      if(lgl->stats->cce.steps >= lgl->limits->cce.steps)
        break;

      blit = *p;
      tag = blit & MASKCS;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      if(!(tag == LRGCS))
      {
        if((REDCS & blit) == 0)
        {
          other = blit >> RMSHFT;
          lidx = other;
          c = cls;
          if(tag == BINCS)
          {
            signed int return_value_abs_6;
            return_value_abs_6=abs(other);
            signed int return_value_abs_7;
            return_value_abs_7=abs(lit);
            if(!(return_value_abs_6 >= return_value_abs_7))
              goto __CPROVER_DUMP_L16;

            cls[(signed long int)1] = other;
            cls[(signed long int)2] = 0;
          }

          else
            if(tag == TRNCS)
            {
              signed int return_value_abs_8;
              return_value_abs_8=abs(other);
              signed int return_value_abs_9;
              return_value_abs_9=abs(lit);
              if(!(return_value_abs_8 >= return_value_abs_9))
                goto __CPROVER_DUMP_L16;

              signed int return_value_abs_10;
              return_value_abs_10=abs(*p);
              signed int return_value_abs_11;
              return_value_abs_11=abs(lit);
              if(!(return_value_abs_10 >= return_value_abs_11))
                goto __CPROVER_DUMP_L16;

              cls[(signed long int)1] = other;
              cls[(signed long int)2] = *p;
              cls[(signed long int)3] = 0;
            }

            else
            {
              c=lglidx2lits(lgl, OCCS, 0, lidx);
              l = c;
              do
              {
                other = *l;
                if(other == 0)
                  break;

                return_value_abs_12=abs(other);
                return_value_abs_13=abs(lit);
                if(!(return_value_abs_12 >= return_value_abs_13))
                  break;

                l = l + 1l;
              }
              while((_Bool)1);
              if(!(other == 0))
                goto __CPROVER_DUMP_L16;

            }
          signed int return_value_lglcceclause_14;
          return_value_lglcceclause_14=lglcceclause(lgl, c, p, tag);
          if(!(return_value_lglcceclause_14 == 0))
          {
            if(tag == BINCS)
              lglrmvbcls(lgl, lit, other);

            else
              if(tag == TRNCS)
                lglrmvtcls(lgl, lit, other, *p);

              else
                lglrmlcls(lgl, lidx, 0);
            goto __CPROVER_DUMP_L18;
          }

        }

      }


    __CPROVER_DUMP_L16:
      ;
    }
  }


__CPROVER_DUMP_L17:
  ;

__CPROVER_DUMP_L18:
  ;
}

// lglceilld
// file lglib.c line 984
static signed int lglceilld(signed int n)
{
  signed int res;
  res=lglfloorld(n);
  signed int return_value_lglispow2_1;
  return_value_lglispow2_1=lglispow2(n);
  if(return_value_lglispow2_1 == 0)
    res = res + 1;

  return res;
}

// lglceilsqrt32
// file lglib.c line 990
static signed int lglceilsqrt32(signed int x)
{
  signed int l = 0;
  signed int m;
  signed int r;
  signed int mm;
  signed int rr;
  if(!(x >= 1))
    return 0;

  else
  {
    r = 46340;
    rr = r * r;
    if(x >= rr)
      return r;

    else
      while((_Bool)1)
      {
        if(r + -l == 1)
          return r;

        m = (l + r) / 2;
        mm = m * m;
        if(mm == x)
          return m;

        if(!(mm >= x))
          l = m;

        else
        {
          r = m;
          rr = mm;
        }
      }
  }
}

// lglceilsqrt64
// file lglib.c line 1014
static signed int lglceilsqrt64(signed int x)
{
  signed long int l = (signed long int)0;
  signed long int m;
  signed long int r;
  signed long int mm;
  signed long int rr;
  if(!(x >= 1))
    return 0;

  else
  {
    r = 3037000499ll;
    rr = r * r;
    if((signed long int)x >= rr)
      return (signed int)r;

    else
      while((_Bool)1)
      {
        if(r + -l == 1l)
          return (signed int)r;

        m = (l + r) / (signed long int)2;
        mm = m * m;
        if(mm == (signed long int)x)
          return (signed int)m;

        if(!(mm >= (signed long int)x))
          l = m;

        else
        {
          r = m;
          rr = mm;
        }
      }
  }
}

// lglcgeq
// file lglib.c line 12379
static signed int lglcgeq(struct LGL *lgl, signed int a, signed int b)
{
  signed int return_value_lglcgrepr_1;
  return_value_lglcgrepr_1=lglcgrepr(lgl, a);
  signed int return_value_lglcgrepr_2;
  return_value_lglcgrepr_2=lglcgrepr(lgl, b);
  return (signed int)(return_value_lglcgrepr_1 == return_value_lglcgrepr_2);
}

// lglcgextractands
// file lglib.c line 12613
static signed int lglcgextractands(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  signed int lidx;
  signed int size;
  signed int tmp;
  signed int repr;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *l;
  struct HTS *hts;
  signed char val;
  signed int *c;
  _Bool tmp_if_expr_9;
  signed int return_value_lglhasbin_8;
  signed int return_value_lglhasbin_7;
  signed int return_value_lglcmpocc_21;
  signed int return_value_lglmtstk_22;
  signed int return_value_lglcmpocc_24;
  if(lgl->opts->cgrextand.val == 0)
    return 1;

  else
  {
    repr=lglcgrepr(lgl, lit);
    signed char return_value_lglval_1;
    return_value_lglval_1=lglval(lgl, lit);
    if(!(return_value_lglval_1 == 0))
      return 1;

    else
    {
      signed int return_value_abs_2;
      return_value_abs_2=abs(repr);
      if(return_value_abs_2 == 1)
        return 1;

      else
      {
        hts=lglhts(lgl, lit);
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          signed int return_value_lglincextractlimhit_3;
          return_value_lglincextractlimhit_3=lglincextractlimhit(lgl);
          if(!(return_value_lglincextractlimhit_3 == 0))
            return 0;

          blit = *p;
          tag = blit & MASKCS;
          if(tag == BINCS)
          {
            if(lgl->opts->cgrexteq.val == 0)
            {
              if(lgl->opts->cgrextunits.val == 0)
                goto __CPROVER_DUMP_L78;

            }

            tmp = blit >> RMSHFT;
            val=lglval(lgl, tmp);
            if(!(val == 0))
              goto __CPROVER_DUMP_L78;

            repr=lglcgrepr(lgl, lit);
            other=lglcgrepr(lgl, -tmp);
            if(repr == other)
              goto __CPROVER_DUMP_L78;

            signed int return_value_lglincextractlimhit_4;
            return_value_lglincextractlimhit_4=lglincextractlimhit(lgl);
            if(!(return_value_lglincextractlimhit_4 == 0))
              return 0;

            if(!(lgl->opts->cgrextunits.val == 0) && !(repr == 1))
            {
              return_value_lglhasbin_8=lglhasbin(lgl, lit, -tmp);
              tmp_if_expr_9 = return_value_lglhasbin_8 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_9 = (_Bool)0;
            if(tmp_if_expr_9)
            {

            __CPROVER_DUMP_L12:
              ;
              lgl->_anon0.cgr->extracted.units = lgl->_anon0.cgr->extracted.units + 1;
              lgl->stats->cgr.units = lgl->stats->cgr.units + 1;
              if(repr == -1)
              {

              __CPROVER_DUMP_L13:
                ;
                lgl->mt = 1;
                return 0;
              }

              signed int return_value_lglcgunit_5;
              return_value_lglcgunit_5=lglcgunit(lgl, repr);
              if(return_value_lglcgunit_5 == 0)
                return 0;

              signed char return_value_lglval_6;
              return_value_lglval_6=lglval(lgl, lit);
              if(!(return_value_lglval_6 == 0))
                return 1;

            }

            else
              if(!(lgl->opts->cgrexteq.val == 0))
              {
                return_value_lglhasbin_7=lglhasbin(lgl, -lit, -tmp);
                if(!(return_value_lglhasbin_7 == 0))
                {
                  lgl->_anon0.cgr->extracted.eq = lgl->_anon0.cgr->extracted.eq + 1;
                  lgl->stats->cgr.eq = lgl->stats->cgr.eq + 1;

                __CPROVER_DUMP_L18:
                  ;
                  if(repr == -other)
                  {

                  __CPROVER_DUMP_L19:
                    ;
                    lgl->mt = 1;
                    return 0;
                  }

                  lglcgmerge(lgl, other, repr);
                }

              }

            goto __CPROVER_DUMP_L78;
          }

          if(tag == TRNCS || tag == LRGCS)
            p = p + 1l;

          if(!(tag == LRGCS))
          {
            if(tag == TRNCS)
            {
              other = blit >> RMSHFT;
              other2 = *p;
              signed int return_value_lglocc_10;
              return_value_lglocc_10=lglocc(lgl, other);
              signed int return_value_lglocc_11;
              return_value_lglocc_11=lglocc(lgl, other2);
              if(!(return_value_lglocc_11 >= return_value_lglocc_10))
                do
                {
                  signed int lglcgextractands__1__2__1__2__1__TMP = other;
                  other = other2;
                  other2 = lglcgextractands__1__2__1__2__1__TMP;
                }
                while((_Bool)0);

              signed int return_value_lglincextractlimhit_12;
              return_value_lglincextractlimhit_12=lglincextractlimhit(lgl);
              if(!(return_value_lglincextractlimhit_12 == 0))
                return 0;

              signed int return_value_lglhasbin_13;
              return_value_lglhasbin_13=lglhasbin(lgl, -lit, -other);
              if(return_value_lglhasbin_13 == 0)
                goto __CPROVER_DUMP_L78;

              signed int return_value_lglincextractlimhit_14;
              return_value_lglincextractlimhit_14=lglincextractlimhit(lgl);
              if(!(return_value_lglincextractlimhit_14 == 0))
                return 0;

              signed int return_value_lglhasbin_15;
              return_value_lglhasbin_15=lglhasbin(lgl, -lit, -other2);
              if(return_value_lglhasbin_15 == 0)
                goto __CPROVER_DUMP_L78;

              lglnewbingate(lgl, (enum GTag)ANDTAG, lit, other, other2);
            }

            else
            {
              signed int return_value_lglincextractlimhit_16;
              return_value_lglincextractlimhit_16=lglincextractlimhit(lgl);
              if(!(return_value_lglincextractlimhit_16 == 0))
                return 0;

              lidx = blit >> RMSHFT;
              c=lglidx2lits(lgl, OCCS, blit & REDCS, lidx);
              l = c;
              do
              {
                other = *l;
                if(other == 0)
                  break;

                if(!(other == lit))
                  lglpushstk(lgl, &lgl->clause, other);

                l = l + 1l;
              }
              while((_Bool)1);
              size = (signed int)((l - c) - (signed long int)1);
              do
              {
                signed int *AA = lgl->clause.start;
                signed int NN = size;
                do
                {
                  signed int L = 0;
                  signed int R = NN - 1;
                  signed int M;
                  signed int LL;
                  signed int RR;
                  signed int I;
                  if(!(R + -L >= 11))
                    break;

                  do
                  {
                    M = (L + R) / 2;
                    do
                    {
                      signed int TMP = AA[(signed long int)M];
                      AA[(signed long int)M] = AA[(signed long int)(R - 1)];
                      AA[(signed long int)(R - 1)] = TMP;
                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpocc_17;
                      return_value_lglcmpocc_17=lglcmpocc(lgl, *(&AA[(signed long int)L]), *(&AA[(signed long int)(R - 1)]));
                      if(return_value_lglcmpocc_17 >= 1)
                        do
                        {
                          signed int lglcgextractands__1__2__1__3__2__1__1__1__2__1__TMP = AA[(signed long int)L];
                          AA[(signed long int)L] = AA[(signed long int)(R - 1)];
                          AA[(signed long int)(R - 1)] = lglcgextractands__1__2__1__3__2__1__1__1__2__1__TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpocc_18;
                      return_value_lglcmpocc_18=lglcmpocc(lgl, *(&AA[(signed long int)L]), *(&AA[(signed long int)R]));
                      if(return_value_lglcmpocc_18 >= 1)
                        do
                        {
                          signed int lglcgextractands__1__2__1__3__2__1__1__1__3__1__TMP = AA[(signed long int)L];
                          AA[(signed long int)L] = AA[(signed long int)R];
                          AA[(signed long int)R] = lglcgextractands__1__2__1__3__2__1__1__1__3__1__TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpocc_19;
                      return_value_lglcmpocc_19=lglcmpocc(lgl, *(&AA[(signed long int)(R - 1)]), *(&AA[(signed long int)R]));
                      if(return_value_lglcmpocc_19 >= 1)
                        do
                        {
                          signed int lglcgextractands__1__2__1__3__2__1__1__1__4__1__TMP = AA[(signed long int)(R - 1)];
                          AA[(signed long int)(R - 1)] = AA[(signed long int)R];
                          AA[(signed long int)R] = lglcgextractands__1__2__1__3__2__1__1__1__4__1__TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      signed int PIVOT;
                      signed int J = R - 1;
                      I = (L + 1) - 1;
                      PIVOT = AA[(signed long int)J];
                      do
                      {

                      __CPROVER_DUMP_L49:
                        ;
                        I = I + 1;
                        signed int return_value_lglcmpocc_20;
                        return_value_lglcmpocc_20=lglcmpocc(lgl, *(&AA[(signed long int)I]), *(&PIVOT));
                        if(!(return_value_lglcmpocc_20 >= 0))
                          goto __CPROVER_DUMP_L49;

                        do
                        {
                          J = J - 1;
                          return_value_lglcmpocc_21=lglcmpocc(lgl, *(&PIVOT), *(&AA[(signed long int)J]));
                          if(return_value_lglcmpocc_21 >= 0)
                            break;

                          if(J == 1 + L)
                            break;

                        }
                        while((_Bool)1);
                        if(I >= J)
                          break;

                        do
                        {
                          signed int lglcgextractands__1__2__1__3__2__1__1__1__5__1__1__1__TMP = AA[(signed long int)I];
                          AA[(signed long int)I] = AA[(signed long int)J];
                          AA[(signed long int)J] = lglcgextractands__1__2__1__3__2__1__1__1__5__1__1__1__TMP;
                        }
                        while((_Bool)0);
                      }
                      while((_Bool)1);
                      do
                      {
                        signed int lglcgextractands__1__2__1__3__2__1__1__1__5__2__TMP = AA[(signed long int)I];
                        AA[(signed long int)I] = AA[(signed long int)(R - 1)];
                        AA[(signed long int)(R - 1)] = lglcgextractands__1__2__1__3__2__1__1__1__5__2__TMP;
                      }
                      while((_Bool)0);
                    }
                    while((_Bool)0);
                    if(!(I + -L >= R + -I))
                    {
                      LL = I + 1;
                      RR = R;
                      R = I - 1;
                    }

                    else
                    {
                      LL = L;
                      RR = I - 1;
                      L = I + 1;
                    }
                    if(R + -L >= 11)
                    {
                      lglpushstk(lgl, &lgl->_anon1.sortstk, LL);
                      lglpushstk(lgl, &lgl->_anon1.sortstk, RR);
                    }

                    else
                      if(RR + -LL >= 11)
                      {
                        L = LL;
                        R = RR;
                      }

                      else
                      {
                        return_value_lglmtstk_22=lglmtstk(&lgl->_anon1.sortstk);
                        if(return_value_lglmtstk_22 == 0)
                        {
                          R=lglpopstk(&lgl->_anon1.sortstk);
                          L=lglpopstk(&lgl->_anon1.sortstk);
                        }

                        else
                          break;
                      }
                  }
                  while((_Bool)1);
                }
                while((_Bool)0);
                do
                {
                  signed int lglcgextractands__1__2__1__3__2__2__PIVOT;
                  signed int lglcgextractands__1__2__1__3__2__2__L = 0;
                  signed int lglcgextractands__1__2__1__3__2__2__R = NN - 1;
                  signed int lglcgextractands__1__2__1__3__2__2__I;
                  signed int lglcgextractands__1__2__1__3__2__2__J;
                  lglcgextractands__1__2__1__3__2__2__I = lglcgextractands__1__2__1__3__2__2__R;
                  for( ; !(lglcgextractands__1__2__1__3__2__2__L >= lglcgextractands__1__2__1__3__2__2__I); lglcgextractands__1__2__1__3__2__2__I = lglcgextractands__1__2__1__3__2__2__I - 1)
                    do
                    {
                      signed int return_value_lglcmpocc_23;
                      return_value_lglcmpocc_23=lglcmpocc(lgl, *(&AA[(signed long int)(lglcgextractands__1__2__1__3__2__2__I - 1)]), *(&AA[(signed long int)lglcgextractands__1__2__1__3__2__2__I]));
                      if(return_value_lglcmpocc_23 >= 1)
                        do
                        {
                          signed int lglcgextractands__1__2__1__3__2__2__1__1__1__TMP = AA[(signed long int)(lglcgextractands__1__2__1__3__2__2__I - 1)];
                          AA[(signed long int)(lglcgextractands__1__2__1__3__2__2__I - 1)] = AA[(signed long int)lglcgextractands__1__2__1__3__2__2__I];
                          AA[(signed long int)lglcgextractands__1__2__1__3__2__2__I] = lglcgextractands__1__2__1__3__2__2__1__1__1__TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                  lglcgextractands__1__2__1__3__2__2__I = lglcgextractands__1__2__1__3__2__2__L + 2;
                  for( ; lglcgextractands__1__2__1__3__2__2__R >= lglcgextractands__1__2__1__3__2__2__I; lglcgextractands__1__2__1__3__2__2__I = lglcgextractands__1__2__1__3__2__2__I + 1)
                  {
                    lglcgextractands__1__2__1__3__2__2__J = lglcgextractands__1__2__1__3__2__2__I;
                    lglcgextractands__1__2__1__3__2__2__PIVOT = AA[(signed long int)lglcgextractands__1__2__1__3__2__2__I];
                    do
                    {
                      return_value_lglcmpocc_24=lglcmpocc(lgl, *(&lglcgextractands__1__2__1__3__2__2__PIVOT), *(&AA[(signed long int)(lglcgextractands__1__2__1__3__2__2__J - 1)]));
                      if(return_value_lglcmpocc_24 >= 0)
                        break;

                      AA[(signed long int)lglcgextractands__1__2__1__3__2__2__J] = AA[(signed long int)(lglcgextractands__1__2__1__3__2__2__J - 1)];
                      lglcgextractands__1__2__1__3__2__2__J = lglcgextractands__1__2__1__3__2__2__J - 1;
                    }
                    while((_Bool)1);
                    AA[(signed long int)lglcgextractands__1__2__1__3__2__2__J] = lglcgextractands__1__2__1__3__2__2__PIVOT;
                  }
                }
                while((_Bool)0);

              __CPROVER_DUMP_L71:
                ;
              }
              while((_Bool)0);
              l = lgl->clause.start;
              for( ; !(l >= lgl->clause.top); l = l + 1l)
              {
                signed int return_value_lglincextractlimhit_25;
                return_value_lglincextractlimhit_25=lglincextractlimhit(lgl);
                if(!(return_value_lglincextractlimhit_25 == 0))
                {
                  lglclnstk(&lgl->clause);
                  return 0;
                }

                signed int return_value_lglhasbin_26;
                return_value_lglhasbin_26=lglhasbin(lgl, -lit, -(*l));
                if(return_value_lglhasbin_26 == 0)
                  break;

              }
              if(l == lgl->clause.top)
                lglnewlrgate(lgl, (enum GTag)ANDTAG, lit, c, size);

              lglclnstk(&lgl->clause);
            }
          }


        __CPROVER_DUMP_L78:
          ;
        }
        return 1;
      }
    }
  }
}

// lglcgextractidx
// file lglib.c line 12937
static signed int lglcgextractidx(struct LGL *lgl, signed int idx)
{
  signed int return_value_lglisfree_1;
  return_value_lglisfree_1=lglisfree(lgl, idx);
  signed int return_value_lglcgextractands_5;
  signed int return_value_lglcgextractands_6;
  signed int return_value_lglcgextractxors_7;
  signed int return_value_lglcgextractxors_8;
  signed int return_value_lglcgextractites_9;
  signed int return_value_lglcgextractites_10;
  if(return_value_lglisfree_1 == 0)
    return 1;

  else
  {
    struct AVar *return_value_lglavar_2;
    return_value_lglavar_2=lglavar(lgl, idx);
    if(!(return_value_lglavar_2->donotcgrcls == 0u))
      return 1;

    else
    {
      signed int return_value_lglcgextractlimhit_3;
      return_value_lglcgextractlimhit_3=lglcgextractlimhit(lgl);
      if(!(return_value_lglcgextractlimhit_3 == 0))
        return 0;

      else
      {
        signed int return_value_lglterminate_4;
        return_value_lglterminate_4=lglterminate(lgl);
        if(!(return_value_lglterminate_4 == 0))
          return 0;

        else
          if(lgl->mt == 0)
          {
            return_value_lglcgextractands_5=lglcgextractands(lgl, idx);
            if(!(return_value_lglcgextractands_5 == 0))
              goto __CPROVER_DUMP_L5;

            return 0;
          }

          else
          {

          __CPROVER_DUMP_L5:
            ;
            if(lgl->mt == 0)
            {
              return_value_lglcgextractands_6=lglcgextractands(lgl, -idx);
              if(!(return_value_lglcgextractands_6 == 0))
                goto __CPROVER_DUMP_L6;

              return 0;
            }

            else
            {

            __CPROVER_DUMP_L6:
              ;
              if(lgl->mt == 0)
              {
                return_value_lglcgextractxors_7=lglcgextractxors(lgl, idx);
                if(!(return_value_lglcgextractxors_7 == 0))
                  goto __CPROVER_DUMP_L7;

                return 0;
              }

              else
              {

              __CPROVER_DUMP_L7:
                ;
                if(lgl->mt == 0)
                {
                  return_value_lglcgextractxors_8=lglcgextractxors(lgl, -idx);
                  if(!(return_value_lglcgextractxors_8 == 0))
                    goto __CPROVER_DUMP_L8;

                  return 0;
                }

                else
                {

                __CPROVER_DUMP_L8:
                  ;
                  if(lgl->mt == 0)
                  {
                    return_value_lglcgextractites_9=lglcgextractites(lgl, idx);
                    if(!(return_value_lglcgextractites_9 == 0))
                      goto __CPROVER_DUMP_L9;

                    return 0;
                  }

                  else
                  {

                  __CPROVER_DUMP_L9:
                    ;
                    if(lgl->mt == 0)
                    {
                      return_value_lglcgextractites_10=lglcgextractites(lgl, -idx);
                      if(!(return_value_lglcgextractites_10 == 0))
                        goto __CPROVER_DUMP_L10;

                      return 0;
                    }

                    else
                    {

                    __CPROVER_DUMP_L10:
                      ;
                      return 1;
                    }
                  }
                }
              }
            }
          }
      }
    }
  }
}

// lglcgextractitecands
// file lglib.c line 12834
static void lglcgextractitecands(struct LGL *lgl, signed int lhs, struct ITEC *cands, signed int ncands)
{
  signed int cond;
  signed int pos;
  signed int neg;
  signed int l;
  signed int m;
  signed int r;
  signed int i;
  signed int j;
  l = 0;
  signed int return_value_abs_1;
  signed int return_value_abs_2;
  signed int return_value_lglcgmergelhsrhs_3;
  for( ; !(l >= ncands); l = r)
  {
    r = l + 1;
    for( ; !(r >= ncands); r = r + 1)
    {
      return_value_abs_1=abs((cands + (signed long int)l)->other);
      return_value_abs_2=abs((cands + (signed long int)r)->other);
      if(!(return_value_abs_1 == return_value_abs_2))
        break;

    }
    if(!((cands + (signed long int)l)->other == (cands + (signed long int)(r + -1))->other))
    {
      m = l + 1;
      for( ; !((cands + (signed long int)m)->other >= 0); m = m + 1)
        ;
      i = l;
      for( ; !(1 + i >= m); i = i + 1)
        ;
      i = m;
      for( ; !(1 + i >= r); i = i + 1)
        ;
      i = l;
      for( ; !(i >= m); i = i + 1)
      {
        j = m;
        for( ; !(j >= r); j = j + 1)
        {
          lhs=lglcgreprnotconst(lgl, lhs);
          lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
          cond = -(cands + (signed long int)l)->other;
          pos = -(cands + (signed long int)l)->other2;
          neg = -(cands + (signed long int)m)->other2;
          pos=lglcgreprnotconst(lgl, pos);
          neg=lglcgreprnotconst(lgl, neg);
          if(!(pos == -neg))
          {
            if(pos == neg)
            {
              if(!(lhs == pos))
              {
                return_value_lglcgmergelhsrhs_3=lglcgmergelhsrhs(lgl, lhs, pos);
                if(!(return_value_lglcgmergelhsrhs_3 == 0))
                  goto __CPROVER_DUMP_L18;

              }

            }

            else
              lglnewitegate(lgl, lhs, cond, pos, neg);
          }

        }
      }
    }

  }

__CPROVER_DUMP_L18:
  ;
}

// lglcgextractites
// file lglib.c line 12865
static signed int lglcgextractites(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  struct ITEC *cands;
  signed int ncands;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  struct HTS *hts;
  signed int return_value_lglcmpitecands_9;
  signed int return_value_lglmtstk_10;
  signed int return_value_lglcmpitecands_12;
  if(lgl->opts->cgrextite.val == 0)
    return 1;

  else
  {
    hts=lglhts(lgl, lit);
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
      blit = *p;
      tag = blit & MASKCS;
      if(!(tag == OCCS) && !(tag == BINCS))
      {
        p = p + 1l;
        if(!(tag == LRGCS))
        {
          other = blit >> RMSHFT;
          other2 = *p;
          lglsignedmark(lgl, other);
          lglsignedmark(lgl, other2);
        }

      }

    }
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      blit = *p;
      tag = blit & MASKCS;
      if(!(tag == OCCS) && !(tag == BINCS))
      {
        p = p + 1l;
        if(!(tag == LRGCS))
        {
          lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
          other = blit >> RMSHFT;
          other2 = *p;
          signed int return_value_lglsignedmarked_2;
          return_value_lglsignedmarked_2=lglsignedmarked(lgl, -other);
          if(!(return_value_lglsignedmarked_2 == 0))
          {
            lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
            signed int return_value_lglhastrn_1;
            return_value_lglhastrn_1=lglhastrn(lgl, -lit, other, -other2);
            if(!(return_value_lglhastrn_1 == 0))
            {
              lglpushstk(lgl, &lgl->seen, other);
              lglpushstk(lgl, &lgl->seen, other2);
            }

          }

          signed int return_value_lglsignedmarked_4;
          return_value_lglsignedmarked_4=lglsignedmarked(lgl, -other2);
          if(!(return_value_lglsignedmarked_4 == 0))
          {
            lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
            signed int return_value_lglhastrn_3;
            return_value_lglhastrn_3=lglhastrn(lgl, -lit, -other, other2);
            if(!(return_value_lglhastrn_3 == 0))
            {
              lglpushstk(lgl, &lgl->seen, other2);
              lglpushstk(lgl, &lgl->seen, other);
            }

          }

        }

      }

    }
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
      blit = *p;
      tag = blit & MASKCS;
      if(!(tag == OCCS) && !(tag == BINCS))
      {
        p = p + 1l;
        if(!(tag == LRGCS))
        {
          other = blit >> RMSHFT;
          other2 = *p;
          lglunmark(lgl, other);
          lglunmark(lgl, other2);
        }

      }

    }
    unsigned long int return_value_lglcntstk_13;
    return_value_lglcntstk_13=lglcntstk(&lgl->seen);
    ncands = (signed int)return_value_lglcntstk_13;
    if(!(ncands == 0))
    {
      cands = (struct ITEC *)lgl->seen.start;
      ncands = ncands / 2;
      do
      {
        struct ITEC *AA = cands;
        signed int NN = ncands;
        do
        {
          signed int L = 0;
          signed int R = NN - 1;
          signed int M;
          signed int LL;
          signed int RR;
          signed int I;
          if(!(R + -L >= 11))
            break;

          do
          {
            M = (L + R) / 2;
            do
            {
              struct ITEC TMP = AA[(signed long int)M];
              AA[(signed long int)M] = AA[(signed long int)(R - 1)];
              AA[(signed long int)(R - 1)] = TMP;
            }
            while((_Bool)0);
            do
            {
              signed int return_value_lglcmpitecands_5;
              return_value_lglcmpitecands_5=lglcmpitecands(&AA[(signed long int)L], &AA[(signed long int)(R - 1)]);
              if(return_value_lglcmpitecands_5 >= 1)
                do
                {
                  struct ITEC lglcgextractites__1__4__1__1__1__1__2__1__TMP = AA[(signed long int)L];
                  AA[(signed long int)L] = AA[(signed long int)(R - 1)];
                  AA[(signed long int)(R - 1)] = lglcgextractites__1__4__1__1__1__1__2__1__TMP;
                }
                while((_Bool)0);

            }
            while((_Bool)0);
            do
            {
              signed int return_value_lglcmpitecands_6;
              return_value_lglcmpitecands_6=lglcmpitecands(&AA[(signed long int)L], &AA[(signed long int)R]);
              if(return_value_lglcmpitecands_6 >= 1)
                do
                {
                  struct ITEC lglcgextractites__1__4__1__1__1__1__3__1__TMP = AA[(signed long int)L];
                  AA[(signed long int)L] = AA[(signed long int)R];
                  AA[(signed long int)R] = lglcgextractites__1__4__1__1__1__1__3__1__TMP;
                }
                while((_Bool)0);

            }
            while((_Bool)0);
            do
            {
              signed int return_value_lglcmpitecands_7;
              return_value_lglcmpitecands_7=lglcmpitecands(&AA[(signed long int)(R - 1)], &AA[(signed long int)R]);
              if(return_value_lglcmpitecands_7 >= 1)
                do
                {
                  struct ITEC lglcgextractites__1__4__1__1__1__1__4__1__TMP = AA[(signed long int)(R - 1)];
                  AA[(signed long int)(R - 1)] = AA[(signed long int)R];
                  AA[(signed long int)R] = lglcgextractites__1__4__1__1__1__1__4__1__TMP;
                }
                while((_Bool)0);

            }
            while((_Bool)0);
            do
            {
              struct ITEC PIVOT;
              signed int J = R - 1;
              I = (L + 1) - 1;
              PIVOT = AA[(signed long int)J];
              do
              {

              __CPROVER_DUMP_L29:
                ;
                I = I + 1;
                signed int return_value_lglcmpitecands_8;
                return_value_lglcmpitecands_8=lglcmpitecands(&AA[(signed long int)I], &PIVOT);
                if(!(return_value_lglcmpitecands_8 >= 0))
                  goto __CPROVER_DUMP_L29;

                do
                {
                  J = J - 1;
                  return_value_lglcmpitecands_9=lglcmpitecands(&PIVOT, &AA[(signed long int)J]);
                  if(return_value_lglcmpitecands_9 >= 0)
                    break;

                  if(J == 1 + L)
                    break;

                }
                while((_Bool)1);
                if(I >= J)
                  break;

                do
                {
                  struct ITEC lglcgextractites__1__4__1__1__1__1__5__1__1__1__TMP = AA[(signed long int)I];
                  AA[(signed long int)I] = AA[(signed long int)J];
                  AA[(signed long int)J] = lglcgextractites__1__4__1__1__1__1__5__1__1__1__TMP;
                }
                while((_Bool)0);
              }
              while((_Bool)1);
              do
              {
                struct ITEC lglcgextractites__1__4__1__1__1__1__5__2__TMP = AA[(signed long int)I];
                AA[(signed long int)I] = AA[(signed long int)(R - 1)];
                AA[(signed long int)(R - 1)] = lglcgextractites__1__4__1__1__1__1__5__2__TMP;
              }
              while((_Bool)0);
            }
            while((_Bool)0);
            if(!(I + -L >= R + -I))
            {
              LL = I + 1;
              RR = R;
              R = I - 1;
            }

            else
            {
              LL = L;
              RR = I - 1;
              L = I + 1;
            }
            if(R + -L >= 11)
            {
              lglpushstk(lgl, &lgl->_anon1.sortstk, LL);
              lglpushstk(lgl, &lgl->_anon1.sortstk, RR);
            }

            else
              if(RR + -LL >= 11)
              {
                L = LL;
                R = RR;
              }

              else
              {
                return_value_lglmtstk_10=lglmtstk(&lgl->_anon1.sortstk);
                if(return_value_lglmtstk_10 == 0)
                {
                  R=lglpopstk(&lgl->_anon1.sortstk);
                  L=lglpopstk(&lgl->_anon1.sortstk);
                }

                else
                  break;
              }
          }
          while((_Bool)1);
        }
        while((_Bool)0);
        do
        {
          struct ITEC lglcgextractites__1__4__1__2__PIVOT;
          signed int lglcgextractites__1__4__1__2__L = 0;
          signed int lglcgextractites__1__4__1__2__R = NN - 1;
          signed int lglcgextractites__1__4__1__2__I;
          signed int lglcgextractites__1__4__1__2__J;
          lglcgextractites__1__4__1__2__I = lglcgextractites__1__4__1__2__R;
          for( ; !(lglcgextractites__1__4__1__2__L >= lglcgextractites__1__4__1__2__I); lglcgextractites__1__4__1__2__I = lglcgextractites__1__4__1__2__I - 1)
            do
            {
              signed int return_value_lglcmpitecands_11;
              return_value_lglcmpitecands_11=lglcmpitecands(&AA[(signed long int)(lglcgextractites__1__4__1__2__I - 1)], &AA[(signed long int)lglcgextractites__1__4__1__2__I]);
              if(return_value_lglcmpitecands_11 >= 1)
                do
                {
                  struct ITEC lglcgextractites__1__4__1__2__1__1__1__TMP = AA[(signed long int)(lglcgextractites__1__4__1__2__I - 1)];
                  AA[(signed long int)(lglcgextractites__1__4__1__2__I - 1)] = AA[(signed long int)lglcgextractites__1__4__1__2__I];
                  AA[(signed long int)lglcgextractites__1__4__1__2__I] = lglcgextractites__1__4__1__2__1__1__1__TMP;
                }
                while((_Bool)0);

            }
            while((_Bool)0);
          lglcgextractites__1__4__1__2__I = lglcgextractites__1__4__1__2__L + 2;
          for( ; lglcgextractites__1__4__1__2__R >= lglcgextractites__1__4__1__2__I; lglcgextractites__1__4__1__2__I = lglcgextractites__1__4__1__2__I + 1)
          {
            lglcgextractites__1__4__1__2__J = lglcgextractites__1__4__1__2__I;
            lglcgextractites__1__4__1__2__PIVOT = AA[(signed long int)lglcgextractites__1__4__1__2__I];
            do
            {
              return_value_lglcmpitecands_12=lglcmpitecands(&lglcgextractites__1__4__1__2__PIVOT, &AA[(signed long int)(lglcgextractites__1__4__1__2__J - 1)]);
              if(return_value_lglcmpitecands_12 >= 0)
                break;

              AA[(signed long int)lglcgextractites__1__4__1__2__J] = AA[(signed long int)(lglcgextractites__1__4__1__2__J - 1)];
              lglcgextractites__1__4__1__2__J = lglcgextractites__1__4__1__2__J - 1;
            }
            while((_Bool)1);
            AA[(signed long int)lglcgextractites__1__4__1__2__J] = lglcgextractites__1__4__1__2__PIVOT;
          }
        }
        while((_Bool)0);

      __CPROVER_DUMP_L51:
        ;
      }
      while((_Bool)0);
      lglcgextractitecands(lgl, lit, cands, ncands);
    }

    lglclnstk(&lgl->seen);
    signed int return_value_lglcgextractlimhit_14;
    return_value_lglcgextractlimhit_14=lglcgextractlimhit(lgl);
    return (signed int)!(return_value_lglcgextractlimhit_14 != 0);
  }
}

// lglcgextractlimhit
// file lglib.c line 12576
static signed int lglcgextractlimhit(struct LGL *lgl)
{
  return (signed int)(lgl->stats->cgr.esteps >= lgl->limits->cgr.esteps);
}

// lglcgextractxors
// file lglib.c line 12748
static signed int lglcgextractxors(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  signed int lidx;
  signed int size;
  signed int count;
  signed int parity;
  signed int *c;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *l;
  struct HTS *hts;
  if(lgl->opts->cgrextxor.val == 0)
    return 1;

  else
  {
    hts=lglhts(lgl, lit);
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      signed int return_value_lglincextractlimhit_1;
      return_value_lglincextractlimhit_1=lglincextractlimhit(lgl);
      if(!(return_value_lglincextractlimhit_1 == 0))
        return 0;

      blit = *p;
      tag = blit & MASKCS;
      if(!(tag == BINCS))
      {
        if(tag == TRNCS || tag == LRGCS)
          p = p + 1l;

        if(!(tag == LRGCS))
        {
          if(tag == TRNCS)
          {
            other = blit >> RMSHFT;
            if(!(other >= 0))
              goto __CPROVER_DUMP_L20;

            other2 = *p;
            if(!(other2 >= 0))
              goto __CPROVER_DUMP_L20;

            lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
            signed int return_value_lglhastrn_2;
            return_value_lglhastrn_2=lglhastrn(lgl, lit, -other, -other2);
            if(return_value_lglhastrn_2 == 0)
              goto __CPROVER_DUMP_L20;

            lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
            signed int return_value_lglhastrn_3;
            return_value_lglhastrn_3=lglhastrn(lgl, -lit, other, -other2);
            if(return_value_lglhastrn_3 == 0)
              goto __CPROVER_DUMP_L20;

            lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
            signed int return_value_lglhastrn_4;
            return_value_lglhastrn_4=lglhastrn(lgl, -lit, -other, other2);
            if(return_value_lglhastrn_4 == 0)
              goto __CPROVER_DUMP_L20;

            lglnewbingate(lgl, (enum GTag)XORTAG, lit, other, other2);
          }

          else
          {
            signed int return_value_lglincextractlimhit_5;
            return_value_lglincextractlimhit_5=lglincextractlimhit(lgl);
            if(!(return_value_lglincextractlimhit_5 == 0))
              return 0;

            lidx = blit >> RMSHFT;
            c=lglidx2lits(lgl, OCCS, blit & REDCS, lidx);
            l = c;
            do
            {
              other = *l;
              if(other == 0)
                break;

              if(!(other == lit) && !(other >= 0))
                break;

              lglpushstk(lgl, &lgl->clause, other);
              l = l + 1l;
            }
            while((_Bool)1);
            if(other == 0)
            {
              size = (signed int)((l - c) - (signed long int)1);
              if(lgl->opts->cgrmaxority.val >= size)
              {
                count = 1 << size;
                parity = (signed int)(lit < 0);
                do
                {
                  count = count - 1;
                  if(count == 0)
                    break;

                  lglinclause(lgl, parity);
                  lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
                  signed int return_value_lglxorhascls_6;
                  return_value_lglxorhascls_6=lglxorhascls(lgl);
                  if(return_value_lglxorhascls_6 == 0)
                    break;

                }
                while((_Bool)1);
                if(count == 0)
                  lglnewlrgate(lgl, (enum GTag)XORTAG, lit, c, size);

              }

            }

            lglclnstk(&lgl->clause);
          }
        }

      }


    __CPROVER_DUMP_L20:
      ;
    }
    signed int return_value_lglcgextractlimhit_7;
    return_value_lglcgextractlimhit_7=lglcgextractlimhit(lgl);
    return (signed int)!(return_value_lglcgextractlimhit_7 != 0);
  }
}

// lglcginit
// file lglib.c line 13002
static void lglcginit(struct LGL *lgl)
{
  signed int idx;
  signed int schedulable = 0;
  signed int donotcgrcls = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree_1;
    return_value_lglisfree_1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree_1 == 0))
    {
      struct AVar *return_value_lglavar_2;
      return_value_lglavar_2=lglavar(lgl, idx);
      if(!(return_value_lglavar_2->donotcgrcls == 0u))
        donotcgrcls = donotcgrcls + 1;

      else
        schedulable = schedulable + 1;
    }

  }
  if(schedulable == 0)
  {
    donotcgrcls = 0;
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      signed int return_value_lglisfree_3;
      return_value_lglisfree_3=lglisfree(lgl, idx);
      if(!(return_value_lglisfree_3 == 0))
      {
        struct AVar *return_value_lglavar_4;
        return_value_lglavar_4=lglavar(lgl, idx);
        return_value_lglavar_4->donotcgrcls = (unsigned int)0;
        schedulable = schedulable + 1;
      }

    }
  }

  signed int return_value_lglrem_5;
  double return_value_lglpcnt_6;
  if(donotcgrcls == 0)
    lglprt(lgl, 1, "[cgrclsr-%d] all %d free variables schedulable", lgl->stats->cgr.count, schedulable);

  else
  {
    return_value_lglrem_5=lglrem(lgl);
    return_value_lglpcnt_6=lglpcnt((double)schedulable, (double)return_value_lglrem_5);
    lglprt(lgl, 1, "[cgrclsr-%d] %d schedulable variables %.0f%%", lgl->stats->cgr.count, schedulable, return_value_lglpcnt_6);
  }
  lglwrkinit(lgl, 1, 1);
  lgl->donotsched = (char)1;
  lglrandidxtrav(lgl, lglwrktouch);
  lgl->donotsched = (char)0;
  do
  {
    void *return_value_lglnew_7;
    return_value_lglnew_7=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(struct Stk) /*24ul*/ );
    lgl->_anon0.cgr->goccs = (struct Stk *)return_value_lglnew_7;
  }
  while((_Bool)0);
}

// lglcgmerge
// file lglib.c line 12520
static void lglcgmerge(struct LGL *lgl, signed int other, signed int repr)
{
  signed int *p;
  signed int *q;
  signed int gidx;
  struct Stk *from;
  struct Stk *to;
  struct Gat *g;
  signed int return_value_abs_1;
  return_value_abs_1=abs(other);
  if(return_value_abs_1 == 1)
    do
    {
      signed int TMP = other;
      other = repr;
      repr = TMP;
    }
    while((_Bool)0);

  if(repr == -1)
  {
    other = -other;
    repr = 1;
  }

  signed int *tmp_post_5;
  if(repr == 1)
  {
    if(!(other >= 0))
    {
      other = -other;
      repr = -repr;
    }

    lgl->repr[(signed long int)other] = repr;
    lglwrktouch(lgl, other);
  }

  else
  {
    signed int return_value_lglcmprepr_2;
    return_value_lglcmprepr_2=lglcmprepr(lgl, other, repr);
    if(!(return_value_lglcmprepr_2 >= 0))
      do
      {
        signed int lglcgmerge__1__3__1__TMP = repr;
        repr = other;
        other = lglcgmerge__1__3__1__TMP;
      }
      while((_Bool)0);

    if(!(other >= 0))
    {
      other = -other;
      repr = -repr;
    }

    lglimerge(lgl, other, repr);
    signed int return_value_abs_3;
    return_value_abs_3=abs(other);
    from = lgl->_anon0.cgr->goccs + (signed long int)return_value_abs_3;
    signed int return_value_abs_4;
    return_value_abs_4=abs(repr);
    to = lgl->_anon0.cgr->goccs + (signed long int)return_value_abs_4;
    q = to->start;
    p = q;
    for( ; !(p >= to->top); p = p + 1l)
    {
      gidx = *p;
      g=lglgidx2gat(lgl, gidx);
      if(g->mark == 0u)
      {
        tmp_post_5 = q;
        q = q + 1l;
        *tmp_post_5 = gidx;
        g->mark = (unsigned int)1;
      }

    }
    to->top = q;

  __CPROVER_DUMP_L12:
    ;
    p = from->start;
    for( ; !(p >= from->top); p = p + 1l)
    {
      gidx = *p;
      g=lglgidx2gat(lgl, gidx);
      if(g->mark == 0u)
      {
        g->mark = (unsigned int)1;
        lglpushstk(lgl, to, gidx);
      }

    }
    lglrelstk(lgl, from);
    p = to->start;
    for( ; !(p >= to->top); p = p + 1l)
    {
      g=lglgidx2gat(lgl, *p);
      g->mark = (unsigned int)0;
    }
    lglwrktouch(lgl, repr);
  }
}

// lglcgmergelhsrhs
// file lglib.c line 12816
static signed int lglcgmergelhsrhs(struct LGL *lgl, signed int lhs, signed int rhs)
{
  signed int conflict = 0;
  lhs=lglcgrepr(lgl, lhs);
  rhs=lglcgrepr(lgl, rhs);
  signed int return_value_lglcgunit_1;
  signed int return_value_lglcgunit_2;
  signed int return_value_lglcgunit_3;
  signed int return_value_lglcgunit_4;
  if(lhs == rhs)
    return 0;

  else
  {
    if(lhs == -rhs)
      conflict = 1;

    else
      if(lhs == 1)
      {
        if(rhs == -1)
          conflict = 1;

        else
        {
          return_value_lglcgunit_1=lglcgunit(lgl, rhs);
          conflict = (signed int)!(return_value_lglcgunit_1 != 0);
        }
      }

      else
        if(lhs == -1)
        {
          if(rhs == 1)
            conflict = 1;

          else
          {
            return_value_lglcgunit_2=lglcgunit(lgl, -rhs);
            conflict = (signed int)!(return_value_lglcgunit_2 != 0);
          }
        }

        else
          if(rhs == 1)
          {
            return_value_lglcgunit_3=lglcgunit(lgl, lhs);
            conflict = (signed int)!(return_value_lglcgunit_3 != 0);
          }

          else
            if(rhs == -1)
            {
              return_value_lglcgunit_4=lglcgunit(lgl, -lhs);
              conflict = (signed int)!(return_value_lglcgunit_4 != 0);
            }

            else
              lglcgmerge(lgl, lhs, rhs);
    return conflict;
  }
}

// lglcgrclosing
// file lglib.c line 16955
static signed int lglcgrclosing(struct LGL *lgl)
{
  _Bool tmp_if_expr_2;
  signed int return_value_lglsmallirr_1;
  if(!(lgl->opts->cgrclsr.val == 0))
  {
    return_value_lglsmallirr_1=lglsmallirr(lgl);
    tmp_if_expr_2 = return_value_lglsmallirr_1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  return (signed int)tmp_if_expr_2;
}

// lglcgrclsr
// file lglib.c line 13782
static signed int lglcgrclsr(struct LGL *lgl)
{
  signed int lglcgrclsr__1__nvars;
  signed int oldrem;
  signed int removed;
  lglstart(lgl, &lgl->times->cgr);
  oldrem=lglrem(lgl);
  lgl->stats->cgr.count = lgl->stats->cgr.count + 1;
  lgl->simp = (char)1;
  lgl->cgrclosing = lgl->simp;
  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Cgr) /*120ul*/ );
    lgl->_anon0.cgr = (struct Cgr *)return_value_lglnew_1;
  }
  while((_Bool)0);
  if(lgl->level >= 1)
    lglbacktrack(lgl, 0);

  lglgc(lgl);
  lglfreezer(lgl);
  lgldense(lgl, 1);
  lglcgrclsr__1__nvars = lgl->nvars;
  do
  {
    void *return_value_lglnew_2;
    return_value_lglnew_2=lglnew(lgl, (unsigned long int)lglcgrclsr__1__nvars * sizeof(signed int) /*4ul*/ );
    lgl->repr = (signed int *)return_value_lglnew_2;
  }
  while((_Bool)0);
  lglsetcgrclsrlim(lgl);
  lglcginit(lgl);
  lglgateextract(lgl);
  if(lgl->mt == 0)
    lglclsr(lgl);

  lglcgreset(lgl);
  lglsparse(lgl);
  signed int return_value_lgladdunits_3;
  signed int return_value_lglbcp_4;
  signed int return_value_lglpropunits_5;
  if(lgl->mt == 0)
  {
    return_value_lgladdunits_3=lgladdunits(lgl);
    if(!(return_value_lgladdunits_3 == 0))
    {
      lglchkred(lgl);
      lgldcpdis(lgl);
      lgldcpcln(lgl);
      lgldcpcon(lgl);
      lglcompact(lgl);
      lglmap(lgl);
      if(lgl->mt == 0)
      {
        return_value_lglbcp_4=lglbcp(lgl);
        if(!(return_value_lglbcp_4 == 0))
        {
          return_value_lglpropunits_5=lglpropunits(lgl);
          if(!(return_value_lglpropunits_5 == 0))
          {
            lglcount(lgl);
            lglgc(lgl);
            if(lgl->mt == 0)
            {
              if(lgl->mt == 0)
              {
                lglpicosatchkall(lgl);
                lglpicosatrestart(lgl);
              }

            }

          }

        }

      }

    }

  }


DONE:
  ;
  lglrelstk(lgl, &lgl->_anon0.cgr->units);
  if(!(lgl->repr == ((signed int *)NULL)))
    do
    {
      lgldel(lgl, (void *)lgl->repr, (unsigned long int)lglcgrclsr__1__nvars * sizeof(signed int) /*4ul*/ );
      lgl->repr = ((signed int *)NULL);
    }
    while((_Bool)0);

  signed int return_value_lglrem_6;
  return_value_lglrem_6=lglrem(lgl);
  removed = oldrem - return_value_lglrem_6;
  lglupdcgrpen(lgl, removed);
  do
  {
    lgldel(lgl, (void *)lgl->_anon0.cgr, (unsigned long int)1 * sizeof(struct Cgr) /*120ul*/ );
    lgl->_anon0.cgr = ((struct Cgr *)NULL);
  }
  while((_Bool)0);
  lgl->simp = (char)0;
  lgl->cgrclosing = lgl->simp;
  lglprtcgrem(lgl);
  lglprt(lgl, 1 + (signed int)!(removed != 0), "[cgrclsr-%d] removed %d variables", lgl->stats->cgr.count, removed);
  lglrep(lgl, 1 + (signed int)!(removed != 0), (char)67);
  lglstop(lgl);
  return (signed int)!(lgl->mt != 0);
}

// lglcgrepr
// file lglib.c line 12319
static signed int lglcgrepr(struct LGL *lgl, signed int lit)
{
  signed int return_value_lglptrjmp_1;
  return_value_lglptrjmp_1=lglptrjmp(lgl->repr, lgl->nvars - 1, lit);
  return return_value_lglptrjmp_1;
}

// lglcgreprnotconst
// file lglib.c line 12341
static signed int lglcgreprnotconst(struct LGL *lgl, signed int lit)
{
  signed int res;
  res=lglcgrepr(lgl, lit);
  signed int return_value_abs_1;
  return_value_abs_1=abs(res);
  if(return_value_abs_1 == 1)
    res = lit;

  return res;
}

// lglcgreset
// file lglib.c line 13031
static void lglcgreset(struct LGL *lgl)
{
  const signed int *p;
  signed int idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
    (lgl->avars + (signed long int)idx)->donotcgrcls = (unsigned int)1;
  p = lgl->wrk->queue.start;
  signed int return_value_abs_1;
  for( ; !(p >= lgl->wrk->queue.top); p = p + 1l)
  {
    return_value_abs_1=abs(*p);
    (lgl->avars + (signed long int)return_value_abs_1)->donotcgrcls = (unsigned int)0;
  }
  lglwrkreset(lgl);
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
    (lgl->avars + (signed long int)idx)->gate = (unsigned int)0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
    lglrelstk(lgl, lgl->_anon0.cgr->goccs + (signed long int)idx);
  do
  {
    lgldel(lgl, (void *)lgl->_anon0.cgr->goccs, (unsigned long int)lgl->nvars * sizeof(struct Stk) /*24ul*/ );
    lgl->_anon0.cgr->goccs = ((struct Stk *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->_anon0.cgr->gates, (unsigned long int)lgl->_anon0.cgr->szgates * sizeof(struct Gat) /*32ul*/ );
    lgl->_anon0.cgr->gates = ((struct Gat *)NULL);
  }
  while((_Bool)0);
  lgl->_anon0.cgr->szgates = 0;
}

// lglcgrlimhit
// file lglib.c line 13330
static signed int lglcgrlimhit(struct LGL *lgl)
{
  return (signed int)(lgl->stats->cgr.csteps >= lgl->limits->cgr.csteps);
}

// lglcgrlit
// file lglib.c line 13614
static void lglcgrlit(struct LGL *lgl, signed int lit)
{
  signed int *p;
  signed int *q;
  signed int *l;
  signed int *r;
  signed int round;
  struct Gat *g;
  struct Gat *h;
  struct Stk *goccs;
  round = 0;

RESTART:
  ;
  signed int return_value_abs_1;
  signed int return_value_lglmtstk_2;
  _Bool tmp_if_expr_3;
  signed int return_value_lglcmpgoccs_12;
  signed int return_value_lglmtstk_13;
  signed int return_value_lglcmpgoccs_15;
  signed int *tmp_post_16;
  _Bool tmp_if_expr_17;
  signed int return_value_lglcgrlimhit_18;
  _Bool tmp_if_expr_20;
  signed int return_value_lglgoccsmatchcand_19;
  signed int return_value_lglcgrepr_21;
  signed int return_value_abs_22;
  signed int return_value_lglcgrepr_23;
  signed int return_value_abs_24;
  signed int return_value_lglsimpgate_25;
  signed int return_value_lglmatchgate_26;
  while((_Bool)1)
  {
    if(!(lgl->mt == 0))
      goto __CPROVER_DUMP_L67;

    return_value_abs_1=abs(lit);
    goccs = lgl->_anon0.cgr->goccs + (signed long int)return_value_abs_1;
    return_value_lglmtstk_2=lglmtstk(goccs);
    if(!(return_value_lglmtstk_2 == 0))
      goto __CPROVER_DUMP_L67;

    round = round + 1;

  __CPROVER_DUMP_L4:
    ;
    l = goccs->start;
    do
    {
      if(lgl->mt == 0)
        tmp_if_expr_3 = l < goccs->top ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        break;

      lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
      signed int return_value_lglcgrlimhit_4;
      return_value_lglcgrlimhit_4=lglcgrlimhit(lgl);
      if(!(return_value_lglcgrlimhit_4 == 0))
        goto __CPROVER_DUMP_L67;

      g=lglgidx2gat(lgl, *l);
      signed int return_value_lglsimpgate_5;
      return_value_lglsimpgate_5=lglsimpgate(lgl, g);
      if(!(return_value_lglsimpgate_5 == 0))
        goto RESTART;

      l = l + 1l;
    }
    while((_Bool)1);

  __CPROVER_DUMP_L9:
    ;
    p = goccs->start;
    for( ; !(p >= goccs->top); p = p + 1l)
    {
      lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
      signed int return_value_lglcgrlimhit_6;
      return_value_lglcgrlimhit_6=lglcgrlimhit(lgl);
      if(!(return_value_lglcgrlimhit_6 == 0))
        goto __CPROVER_DUMP_L67;

      g=lglgidx2gat(lgl, *p);
      lglsetminrhs(lgl, g);
    }
    do
    {
      signed int *AA = goccs->start;
      signed int NN;
      unsigned long int return_value_lglcntstk_7;
      return_value_lglcntstk_7=lglcntstk(goccs);
      NN = (signed int)return_value_lglcntstk_7;
      do
      {
        signed int L = 0;
        signed int R = NN - 1;
        signed int M;
        signed int LL;
        signed int RR;
        signed int I;
        if(!(R + -L >= 11))
          break;

        do
        {
          M = (L + R) / 2;
          do
          {
            signed int TMP = AA[(signed long int)M];
            AA[(signed long int)M] = AA[(signed long int)(R - 1)];
            AA[(signed long int)(R - 1)] = TMP;
          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpgoccs_8;
            return_value_lglcmpgoccs_8=lglcmpgoccs(lgl, *(&AA[(signed long int)L]), *(&AA[(signed long int)(R - 1)]));
            if(return_value_lglcmpgoccs_8 >= 1)
              do
              {
                signed int lglcgrlit__1__5__1__1__1__2__1__TMP = AA[(signed long int)L];
                AA[(signed long int)L] = AA[(signed long int)(R - 1)];
                AA[(signed long int)(R - 1)] = lglcgrlit__1__5__1__1__1__2__1__TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpgoccs_9;
            return_value_lglcmpgoccs_9=lglcmpgoccs(lgl, *(&AA[(signed long int)L]), *(&AA[(signed long int)R]));
            if(return_value_lglcmpgoccs_9 >= 1)
              do
              {
                signed int lglcgrlit__1__5__1__1__1__3__1__TMP = AA[(signed long int)L];
                AA[(signed long int)L] = AA[(signed long int)R];
                AA[(signed long int)R] = lglcgrlit__1__5__1__1__1__3__1__TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpgoccs_10;
            return_value_lglcmpgoccs_10=lglcmpgoccs(lgl, *(&AA[(signed long int)(R - 1)]), *(&AA[(signed long int)R]));
            if(return_value_lglcmpgoccs_10 >= 1)
              do
              {
                signed int lglcgrlit__1__5__1__1__1__4__1__TMP = AA[(signed long int)(R - 1)];
                AA[(signed long int)(R - 1)] = AA[(signed long int)R];
                AA[(signed long int)R] = lglcgrlit__1__5__1__1__1__4__1__TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            signed int PIVOT;
            signed int J = R - 1;
            I = (L + 1) - 1;
            PIVOT = AA[(signed long int)J];
            do
            {

            __CPROVER_DUMP_L26:
              ;
              I = I + 1;
              signed int return_value_lglcmpgoccs_11;
              return_value_lglcmpgoccs_11=lglcmpgoccs(lgl, *(&AA[(signed long int)I]), *(&PIVOT));
              if(!(return_value_lglcmpgoccs_11 >= 0))
                goto __CPROVER_DUMP_L26;

              do
              {
                J = J - 1;
                return_value_lglcmpgoccs_12=lglcmpgoccs(lgl, *(&PIVOT), *(&AA[(signed long int)J]));
                if(return_value_lglcmpgoccs_12 >= 0)
                  break;

                if(J == 1 + L)
                  break;

              }
              while((_Bool)1);
              if(I >= J)
                break;

              do
              {
                signed int lglcgrlit__1__5__1__1__1__5__1__1__1__TMP = AA[(signed long int)I];
                AA[(signed long int)I] = AA[(signed long int)J];
                AA[(signed long int)J] = lglcgrlit__1__5__1__1__1__5__1__1__1__TMP;
              }
              while((_Bool)0);
            }
            while((_Bool)1);
            do
            {
              signed int lglcgrlit__1__5__1__1__1__5__2__TMP = AA[(signed long int)I];
              AA[(signed long int)I] = AA[(signed long int)(R - 1)];
              AA[(signed long int)(R - 1)] = lglcgrlit__1__5__1__1__1__5__2__TMP;
            }
            while((_Bool)0);
          }
          while((_Bool)0);
          if(!(I + -L >= R + -I))
          {
            LL = I + 1;
            RR = R;
            R = I - 1;
          }

          else
          {
            LL = L;
            RR = I - 1;
            L = I + 1;
          }
          if(R + -L >= 11)
          {
            lglpushstk(lgl, &lgl->_anon1.sortstk, LL);
            lglpushstk(lgl, &lgl->_anon1.sortstk, RR);
          }

          else
            if(RR + -LL >= 11)
            {
              L = LL;
              R = RR;
            }

            else
            {
              return_value_lglmtstk_13=lglmtstk(&lgl->_anon1.sortstk);
              if(return_value_lglmtstk_13 == 0)
              {
                R=lglpopstk(&lgl->_anon1.sortstk);
                L=lglpopstk(&lgl->_anon1.sortstk);
              }

              else
                break;
            }
        }
        while((_Bool)1);
      }
      while((_Bool)0);
      do
      {
        signed int lglcgrlit__1__5__2__PIVOT;
        signed int lglcgrlit__1__5__2__L = 0;
        signed int lglcgrlit__1__5__2__R = NN - 1;
        signed int lglcgrlit__1__5__2__I;
        signed int lglcgrlit__1__5__2__J;
        lglcgrlit__1__5__2__I = lglcgrlit__1__5__2__R;
        for( ; !(lglcgrlit__1__5__2__L >= lglcgrlit__1__5__2__I); lglcgrlit__1__5__2__I = lglcgrlit__1__5__2__I - 1)
          do
          {
            signed int return_value_lglcmpgoccs_14;
            return_value_lglcmpgoccs_14=lglcmpgoccs(lgl, *(&AA[(signed long int)(lglcgrlit__1__5__2__I - 1)]), *(&AA[(signed long int)lglcgrlit__1__5__2__I]));
            if(return_value_lglcmpgoccs_14 >= 1)
              do
              {
                signed int lglcgrlit__1__5__2__1__1__1__TMP = AA[(signed long int)(lglcgrlit__1__5__2__I - 1)];
                AA[(signed long int)(lglcgrlit__1__5__2__I - 1)] = AA[(signed long int)lglcgrlit__1__5__2__I];
                AA[(signed long int)lglcgrlit__1__5__2__I] = lglcgrlit__1__5__2__1__1__1__TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
        lglcgrlit__1__5__2__I = lglcgrlit__1__5__2__L + 2;
        for( ; lglcgrlit__1__5__2__R >= lglcgrlit__1__5__2__I; lglcgrlit__1__5__2__I = lglcgrlit__1__5__2__I + 1)
        {
          lglcgrlit__1__5__2__J = lglcgrlit__1__5__2__I;
          lglcgrlit__1__5__2__PIVOT = AA[(signed long int)lglcgrlit__1__5__2__I];
          do
          {
            return_value_lglcmpgoccs_15=lglcmpgoccs(lgl, *(&lglcgrlit__1__5__2__PIVOT), *(&AA[(signed long int)(lglcgrlit__1__5__2__J - 1)]));
            if(return_value_lglcmpgoccs_15 >= 0)
              break;

            AA[(signed long int)lglcgrlit__1__5__2__J] = AA[(signed long int)(lglcgrlit__1__5__2__J - 1)];
            lglcgrlit__1__5__2__J = lglcgrlit__1__5__2__J - 1;
          }
          while((_Bool)1);
          AA[(signed long int)lglcgrlit__1__5__2__J] = lglcgrlit__1__5__2__PIVOT;
        }
      }
      while((_Bool)0);

    __CPROVER_DUMP_L48:
      ;
    }
    while((_Bool)0);
    q = goccs->start + (signed long int)1;
    p = q;
    for( ; !(p >= goccs->top); p = p + 1l)
      if(!(*p == q[-1l]))
      {
        tmp_post_16 = q;
        q = q + 1l;
        *tmp_post_16 = *p;
      }

    goccs->top = q;
    l = goccs->start;

  __CPROVER_DUMP_L52:
    ;
    if(lgl->mt == 0)
      tmp_if_expr_17 = l < goccs->top ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_17 = (_Bool)0;
    if(!tmp_if_expr_17)
      goto __CPROVER_DUMP_L66;

    lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
    return_value_lglcgrlimhit_18=lglcgrlimhit(lgl);
    if(!(return_value_lglcgrlimhit_18 == 0))
      goto __CPROVER_DUMP_L67;

    r = l + (signed long int)1;
    do
    {
      if(!(r >= goccs->top))
      {
        return_value_lglgoccsmatchcand_19=lglgoccsmatchcand(lgl, *l, *r);
        tmp_if_expr_20 = return_value_lglgoccsmatchcand_19 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_20 = (_Bool)0;
      if(!tmp_if_expr_20)
        break;

      r = r + 1l;
    }
    while((_Bool)1);
    p = l;

  __CPROVER_DUMP_L60:
    ;
    if(!(lgl->mt == 0) || p + 1l >= r)
      goto __CPROVER_DUMP_L65;

    g=lglgidx2gat(lgl, *p);
    return_value_lglcgrepr_21=lglcgrepr(lgl, g->lhs);
    return_value_abs_22=abs(return_value_lglcgrepr_21);
    if(return_value_abs_22 == 1)
      goto __CPROVER_DUMP_L64;

    q = p + (signed long int)1;

  __CPROVER_DUMP_L61:
    ;
    if(!(lgl->mt == 0) || q >= r)
      goto __CPROVER_DUMP_L63;

    h=lglgidx2gat(lgl, *q);
    return_value_lglcgrepr_23=lglcgrepr(lgl, h->lhs);
    return_value_abs_24=abs(return_value_lglcgrepr_23);
    if(return_value_abs_24 == 1)
      goto __CPROVER_DUMP_L62;

    return_value_lglsimpgate_25=lglsimpgate(lgl, h);
    if(!(return_value_lglsimpgate_25 == 0))
      goto RESTART;

    return_value_lglmatchgate_26=lglmatchgate(lgl, lit, g, h);
    if(return_value_lglmatchgate_26 == 0)
      break;

  }

__CPROVER_DUMP_L62:
  ;
  q = q + 1l;
  goto __CPROVER_DUMP_L61;

__CPROVER_DUMP_L63:
  ;

__CPROVER_DUMP_L64:
  ;
  p = p + 1l;
  goto __CPROVER_DUMP_L60;

__CPROVER_DUMP_L65:
  ;
  l = r;
  goto __CPROVER_DUMP_L52;

__CPROVER_DUMP_L66:
  ;

__CPROVER_DUMP_L67:
  ;
}

// lglcgunit
// file lglib.c line 12585
static signed int lglcgunit(struct LGL *lgl, signed int lit)
{
  signed int lglcgunit__1__next;
  signed int repr;
  signed int other;
  signed int ok;
  signed char val;
  val=lglval(lgl, lit);
  signed int tmp_post_1;
  if((signed int)val >= 1)
    return 1;

  else
    if(!((signed int)val >= 0))
    {

    __CPROVER_DUMP_L2:
      ;
      lgl->mt = 1;
      return 0;
    }

    else
    {
      lglcgunit__1__next = lgl->next;
      lglunit(lgl, lit);
      ok=lglbcp(lgl);
      if(!(ok == 0))
        while(!(lglcgunit__1__next >= lgl->next))
        {
          tmp_post_1 = lglcgunit__1__next;
          lglcgunit__1__next = lglcgunit__1__next + 1;
          other=lglpeek(&lgl->trail, tmp_post_1);
          repr=lglcgrepr(lgl, other);
          if(!(repr == 1))
          {
            if(repr == -1)
            {
              ok = 0;
              break;
            }

            lglcgmerge(lgl, repr, 1);
          }

        }

      if(ok == 0)
      {

      __CPROVER_DUMP_L8:
        ;
        lgl->mt = 1;
      }

      return ok;
    }
}

// lglchanged
// file lglib.c line 17865
signed int lglchanged(struct LGL *lgl)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglchanged");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "changed");
    break;
  }

__CPROVER_DUMP_L5:
  ;
  do
  {
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglchanged");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

    while((EXTENDED & (signed int)lgl->state) == 0)
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglchanged");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "!(%s)", (const void *)"EXTENDED");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
  }
  while((_Bool)0);
  res = lgl->changed;

__CPROVER_DUMP_L11:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglchanged(lgl->clone);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglchanged");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone) = %d differs from %s (lgl) = %d", (const void *)"lglchanged", CLONERES, (const void *)"lglchanged", res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglchkassumeclean
// file lglib.c line 3726
static void lglchkassumeclean(struct LGL *lgl)
{
  ;
}

// lglchkbcpclean
// file lglib.c line 6871
static void lglchkbcpclean(struct LGL *lgl, const char *where)
{

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;

__CPROVER_DUMP_L3:
  ;
}

// lglchkclone
// file lglib.c line 2076
void lglchkclone(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglchkclone");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "chkclone");
    break;
  }
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglrelease(lgl->clone);

  lgl->clone=lglclone(lgl);
}

// lglchkclonesamestats
// file lglib.c line 17640
static void lglchkclonesamestats(struct LGL *orig)
{
  ;
}

// lglchkeassumeclean
// file lglib.c line 3714
static void lglchkeassumeclean(struct LGL *lgl)
{
  ;
}

// lglchkenv
// file lglib.c line 1632
static void lglchkenv(struct LGL *lgl)
{
  char *src;
  char *eos;
  char *dst;
  char **p;
  char *s;
  char *d;
  signed int len;
  p = environ;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  char *tmp_post_5;
  signed int tmp_statement_expression_6;
  signed int tmp_if_expr_8;
  const signed int **return_value___ctype_tolower_loc_7;
  const signed int **return_value___ctype_tolower_loc_9;
  signed int tmp_statement_expression_10;
  do
  {
    src = *p;
    if(src == ((char *)NULL))
      break;

    if(!((signed int)*src == 76))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)src[(signed long int)1] != 71 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)src[(signed long int)2] != 76 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
    {
      eos = src;
      do
      {
        if(!(*eos == 0))
          tmp_if_expr_3 = (signed int)*eos != 61 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(!tmp_if_expr_3)
          break;

        eos = eos + 1l;
      }
      while((_Bool)1);
      len = (signed int)(eos - (src + (signed long int)3));
      do
      {
        void *return_value_lglnew_4;
        return_value_lglnew_4=lglnew(lgl, (unsigned long int)(len + 1) * sizeof(char) /*1ul*/ );
        dst = (char *)return_value_lglnew_4;
      }
      while((_Bool)0);
      d = dst;
      s = src + (signed long int)3;
      for( ; !(s >= eos); s = s + 1l)
      {
        tmp_post_5 = d;
        d = d + 1l;
        signed int __res;
        return_value___ctype_tolower_loc_9=__ctype_tolower_loc();
        __res = (*return_value___ctype_tolower_loc_9)[(signed long int)(signed int)*s];
        tmp_statement_expression_6 = __res;
        *tmp_post_5 = (char)tmp_statement_expression_6;
      }
      *d = (char)0;
      signed int return_value_lglhasopt_12;
      return_value_lglhasopt_12=lglhasopt(lgl, dst);
      if(return_value_lglhasopt_12 == 0)
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp_11;
        return_value___builtin_strcmp_11=__builtin_strcmp(dst, "apitrace");
        tmp_statement_expression_10 = return_value___builtin_strcmp_11;
        if(!(tmp_statement_expression_10 == 0))
          lglwrn(lgl, "invalid 'LGL...' environment '%s'", src);

      }

      do
      {
        lgldel(lgl, (void *)dst, (unsigned long int)(len + 1) * sizeof(char) /*1ul*/ );
        dst = ((char *)NULL);
      }
      while((_Bool)0);
    }

    p = p + 1l;
  }
  while((_Bool)1);
}

// lglchkflt
// file lglib.c line 1038
static void lglchkflt(signed long int a)
{
  (void)a;
}

// lglchkirrstats
// file lglib.c line 3421
static void lglchkirrstats(struct LGL *lgl)
{
  (void)lgl;
}

// lglchkoccs4elm
// file lglib.c line 11052
static signed int lglchkoccs4elm(struct LGL *lgl, signed int idx)
{
  signed int return_value_lgl2manyoccs4elm_1;
  return_value_lgl2manyoccs4elm_1=lgl2manyoccs4elm(lgl, idx);
  if(!(return_value_lgl2manyoccs4elm_1 == 0))
    return 0;

  else
  {
    signed int return_value_lgl2manyoccs4elm_2;
    return_value_lgl2manyoccs4elm_2=lgl2manyoccs4elm(lgl, -idx);
    if(!(return_value_lgl2manyoccs4elm_2 == 0))
      return 0;

    else
    {
      signed int return_value_lglchkoccs4elmlit_3;
      return_value_lglchkoccs4elmlit_3=lglchkoccs4elmlit(lgl, idx);
      if(return_value_lglchkoccs4elmlit_3 == 0)
        return 0;

      else
      {
        signed int return_value_lglchkoccs4elmlit_4;
        return_value_lglchkoccs4elmlit_4=lglchkoccs4elmlit(lgl, -idx);
        return return_value_lglchkoccs4elmlit_4;
      }
    }
  }
}

// lglchkoccs4elmlit
// file lglib.c line 11018
static signed int lglchkoccs4elmlit(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int lidx;
  signed int size;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  const signed int *l;
  struct HTS *hts;
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    red = blit & REDCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(!(tag == LRGCS) && red == 0)
    {
      if(tag == BINCS || tag == TRNCS)
      {
        other = blit >> RMSHFT;
        signed int return_value_lgl2manyoccs4elm_1;
        return_value_lgl2manyoccs4elm_1=lgl2manyoccs4elm(lgl, other);
        if(!(return_value_lgl2manyoccs4elm_1 == 0))
          return 0;

        if(tag == TRNCS)
        {
          other2 = *p;
          signed int return_value_lgl2manyoccs4elm_2;
          return_value_lgl2manyoccs4elm_2=lgl2manyoccs4elm(lgl, other2);
          if(!(return_value_lgl2manyoccs4elm_2 == 0))
            return 0;

        }

      }

      else
      {
        lidx = blit >> RMSHFT;
        c=lglidx2lits(lgl, OCCS, 0, lidx);
        size = 0;
        l = c;
        do
        {
          other = *l;
          if(other == 0)
            break;

          signed int return_value_lgl2manyoccs4elm_3;
          return_value_lgl2manyoccs4elm_3=lgl2manyoccs4elm(lgl, other);
          if(!(return_value_lgl2manyoccs4elm_3 == 0))
            return 0;

          size = size + 1;
          if(!(lgl->opts->elmclslim.val >= size))
            return 0;

          l = l + 1l;
        }
        while((_Bool)1);
      }
    }

  }
  return 1;
}

// lglchkqueue
// file lglib.c line 2346
static void lglchkqueue(struct LGL *lgl)
{
  ;
}

// lglchkred
// file lglib.c line 5076
static void lglchkred(struct LGL *lgl)
{
  ;
}

// lglchksimpcls
// file lglib.c line 2945
static void lglchksimpcls(struct LGL *lgl)
{
  ;
}

// lglclass
// file lglib.c line 17518
static void lglclass(struct LGL *lgl, struct LGL *from)
{
  struct Ext *extfrom;
  struct Ext *extlgl;
  signed int eidx;
  signed int cloned;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglclass");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->mt == 0))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglclass");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not clone assignment into inconsistent manager");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  while(from == ((struct LGL *)NULL))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglclass");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "uninitialized 'from' solver");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  while((96 & (signed int)from->state) == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglclass");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "require 'from' state to be (SATISFIED | EXTENDED)");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  while(!(from->maxext == lgl->maxext))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglclass");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not clone assignments for different sets of variables");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  if((EXTENDED & (signed int)from->state) == 0)
    lglextend(from);

  lglreset(lgl);
  lgleunassignall(lgl);
  lgl->changed = 0;
  cloned = lgl->changed;
  eidx = 1;
  for( ; lgl->maxext >= eidx; eidx = eidx + 1)
  {
    extlgl=lglelit2ext(lgl, eidx);
    if(!(extlgl->imported == 0u))
    {
      extfrom=lglelit2ext(from, eidx);
      while(extfrom->imported == 0u)
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglclass");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "can not clone assignment of literal imported only by 'to'");
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      lgleassign(lgl, (signed int)extfrom->val * eidx);
      cloned = cloned + 1;
    }

  }
  lglcomputechanged(lgl);
  lglprt(lgl, 1, "[class] cloned %d assignments (%d changed)", cloned, lgl->changed);

__CPROVER_DUMP_L20:
  ;
  do
    lgl->state = (enum State)EXTENDED;
  while((_Bool)0);
}

// lglcleanrepr
// file lglib.c line 13904
static void lglcleanrepr(struct LGL *lgl, struct Stk *represented, signed int *repr)
{
  signed int idx;
  signed int return_value_lglmtstk_1;
  do
  {
    return_value_lglmtstk_1=lglmtstk(represented);
    if(!(return_value_lglmtstk_1 == 0))
      break;

    idx=lglpopstk(represented);
    repr[(signed long int)idx] = 0;
  }
  while((_Bool)1);
}

// lglcliff
// file lglib.c line 12065
static signed int lglcliff(struct LGL *lgl)
{
  signed int lifted;
  signed int failed;
  signed int oldlifted;
  signed int oldfailed;
  signed int success;
  lglstart(lgl, &lgl->times->cliff);
  lgl->stats->cliff.count = lgl->stats->cliff.count + 1;
  lgl->cliffing = (char)1;
  lgl->simp = lgl->cliffing;
  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Cliff) /*48ul*/ );
    lgl->_anon0.cliff = (struct Cliff *)return_value_lglnew_1;
  }
  while((_Bool)0);
  if(lgl->level >= 1)
    lglbacktrack(lgl, 0);

  oldlifted = lgl->stats->cliff.lifted;
  oldfailed = lgl->stats->cliff.failed;
  lglsetclifflim(lgl);
  signed int return_value_lglrandlitrav_2;
  return_value_lglrandlitrav_2=lglrandlitrav(lgl, lglclifflit);
  if(!(return_value_lglrandlitrav_2 == 0))
    lglcliffclauses(lgl, &lgl->irr);

  lifted = lgl->stats->cliff.lifted - oldlifted;
  failed = lgl->stats->cliff.failed - oldfailed;
  lglprt(lgl, 1, "[cliff-%d] failed %d, lifted %d", lgl->stats->cliff.count, failed, lifted);
  lgl->cliffing = (char)0;
  lgl->simp = lgl->cliffing;
  lglrelstk(lgl, &lgl->_anon0.cliff->lift);
  lglrelstk(lgl, &lgl->_anon0.cliff->lits);
  do
  {
    lgldel(lgl, (void *)lgl->_anon0.cliff, (unsigned long int)1 * sizeof(struct Cliff) /*48ul*/ );
    lgl->_anon0.cliff = ((struct Cliff *)NULL);
  }
  while((_Bool)0);
  success = (signed int)(failed != 0 || lifted != 0);
  lglupdcliffint(lgl, success);
  lglrep(lgl, 1 + (signed int)!(success != 0), (char)75);
  lglstop(lgl);
  return (signed int)!(lgl->mt != 0);
}

// lglcliffclause
// file lglib.c line 11924
static void lglcliffclause(struct LGL *lgl, const signed int *c)
{
  signed int lit;
  signed int lglcliffclause__1__start;
  signed int i;
  signed int first;
  signed int dom;
  signed int other;
  signed int *r;
  const signed int *p;
  const signed int *q;
  p = c;
  signed char return_value_lglval_1;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    return_value_lglval_1=lglval(lgl, lit);
    if((signed int)return_value_lglval_1 >= 1)
      goto __CPROVER_DUMP_L27;

    p = p + 1l;
  }
  while((_Bool)1);

__CPROVER_DUMP_L4:
  ;
  unsigned long int return_value_lglcntstk_2;
  return_value_lglcntstk_2=lglcntstk(&lgl->trail);
  lglcliffclause__1__start = (signed int)return_value_lglcntstk_2;
  first = 1;
  p = c;
  unsigned long int return_value_lglcntstk_6;
  signed char return_value_lglval_8;
  signed int *tmp_post_7;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    signed char return_value_lglval_3;
    return_value_lglval_3=lglval(lgl, lit);
    if((signed int)return_value_lglval_3 >= 0)
    {
      lgl->stats->cliff.decisions = lgl->stats->cliff.decisions + 1l;
      lgliassume(lgl, lit);
      signed int return_value_lglbcp_5;
      return_value_lglbcp_5=lglbcp(lgl);
      if(return_value_lglbcp_5 == 0)
      {

      __CPROVER_DUMP_L6:
        ;
        dom=lglprbana(lgl, lit);
        lglbacktrack(lgl, 0);
        lgl->stats->cliff.failed = lgl->stats->cliff.failed + 1;
        lglunit(lgl, -dom);
        signed int return_value_lglbcp_4;
        return_value_lglbcp_4=lglbcp(lgl);
        if(return_value_lglbcp_4 == 0)
        {

        __CPROVER_DUMP_L7:
          ;
          lgl->mt = 1;
        }

        goto DONE;
      }

      if(!(first == 0))
      {
        i = lglcliffclause__1__start;
        do
        {
          return_value_lglcntstk_6=lglcntstk(&lgl->trail);
          if((unsigned long int)i >= return_value_lglcntstk_6)
            break;

          other=lglpeek(&lgl->trail, i);
          lglpushstk(lgl, &lgl->_anon0.cliff->lift, other);
          i = i + 1;
        }
        while((_Bool)1);
        first = 0;
      }

      else
      {
        r = lgl->_anon0.cliff->lift.start;
        q = r;
        for( ; !(q >= lgl->_anon0.cliff->lift.top); q = q + 1l)
        {
          other = *q;
          return_value_lglval_8=lglval(lgl, other);
          if((signed int)return_value_lglval_8 >= 1)
          {
            tmp_post_7 = r;
            r = r + 1l;
            *tmp_post_7 = other;
          }

        }
        lgl->_anon0.cliff->lift.top = r;
      }
      lglbacktrack(lgl, 0);
      signed int return_value_lglmtstk_9;
      return_value_lglmtstk_9=lglmtstk(&lgl->_anon0.cliff->lift);
      if(!(return_value_lglmtstk_9 == 0))
        goto __CPROVER_DUMP_L27;

    }

    p = p + 1l;
  }
  while((_Bool)1);
  signed int return_value_lglmtstk_10;
  do
  {
    return_value_lglmtstk_10=lglmtstk(&lgl->_anon0.cliff->lift);
    if(!(return_value_lglmtstk_10 == 0))
      break;

    lit=lglpopstk(&lgl->_anon0.cliff->lift);

  __CPROVER_DUMP_L20:
    ;
    lgl->stats->cliff.lifted = lgl->stats->cliff.lifted + 1;
    signed char return_value_lglval_11;
    return_value_lglval_11=lglval(lgl, lit);
    if(!((signed int)return_value_lglval_11 >= 1))
    {
      signed char return_value_lglval_12;
      return_value_lglval_12=lglval(lgl, lit);
      if(!((signed int)return_value_lglval_12 >= 0))
      {

      __CPROVER_DUMP_L21:
        ;
        lgl->mt = 1;
        break;
      }

      lglunit(lgl, lit);
      signed int return_value_lglbcp_13;
      return_value_lglbcp_13=lglbcp(lgl);
      if(return_value_lglbcp_13 == 0)
      {

      __CPROVER_DUMP_L23:
        ;
        lgl->mt = 1;
        break;
      }

    }

  }
  while((_Bool)1);

DONE:
  ;
  lglclnstk(&lgl->_anon0.cliff->lift);

__CPROVER_DUMP_L27:
  ;
}

// lglcliffclauses
// file lglib.c line 11987
static signed int lglcliffclauses(struct LGL *lgl, struct Stk *stk)
{
  const signed int *c;
  const signed int *p;
  c = stk->start;
  signed long int tmp_post_1;
  for( ; !(c >= stk->top); c = p + (signed long int)1)
  {
    p = c;
    if(!(*p >= 0x7fffffff))
    {
      tmp_post_1 = lgl->stats->cliff.steps;
      lgl->stats->cliff.steps = lgl->stats->cliff.steps + 1l;
      if(tmp_post_1 >= lgl->limits->cliff.steps)
        return 0;

      lglcliffclause(lgl, c);
      if(!(lgl->mt == 0))
        return 0;

      p = c;
      for( ; !(*p == 0); p = p + 1l)
        ;
    }

  }
  return 1;
}

// lglcliffing
// file lglib.c line 17015
static signed int lglcliffing(struct LGL *lgl)
{
  return lgl->opts->cliff.val;
}

// lglclifflit
// file lglib.c line 12000
static signed int lglclifflit(struct LGL *lgl, signed int lit)
{
  const signed int *w;
  const signed int *eow;
  const signed int *p;
  const signed int *c;
  const signed int *l;
  signed int res;
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  struct HTS *hts;
  signed int return_value_lglisfree_1;
  return_value_lglisfree_1=lglisfree(lgl, lit);
  signed long int tmp_post_2;
  _Bool tmp_if_expr_7;
  if(return_value_lglisfree_1 == 0)
    return 1;

  else
  {
    tmp_post_2 = lgl->stats->cliff.steps;
    lgl->stats->cliff.steps = lgl->stats->cliff.steps + 1l;
    if(tmp_post_2 >= lgl->limits->cliff.steps)
      return 0;

    else
    {
      hts=lglhts(lgl, lit);
      w=lglhts2wchs(lgl, hts);
      eow = w + (signed long int)hts->count;
      p = w;
      for( ; !(p >= eow); p = p + 1l)
      {
        blit = *p;
        tag = blit & MASKCS;
        if(tag == TRNCS || tag == LRGCS)
          p = p + 1l;

        if(!(tag == BINCS))
        {
          if(tag == TRNCS)
          {
            other = blit >> RMSHFT;
            signed int return_value_abs_3;
            return_value_abs_3=abs(other);
            signed int return_value_abs_4;
            return_value_abs_4=abs(lit);
            if(!(return_value_abs_3 >= return_value_abs_4))
              goto __CPROVER_DUMP_L9;

            other2 = *p;
            signed int return_value_abs_5;
            return_value_abs_5=abs(other2);
            signed int return_value_abs_6;
            return_value_abs_6=abs(lit);
            if(!(return_value_abs_5 >= return_value_abs_6))
              goto __CPROVER_DUMP_L9;

            lglpushstk(lgl, &lgl->_anon0.cliff->lits, lit);
            lglpushstk(lgl, &lgl->_anon0.cliff->lits, other);
            lglpushstk(lgl, &lgl->_anon0.cliff->lits, other2);
          }

          else
          {
            c=lglidx2lits(lgl, LRGCS, blit & REDCS, *p);
            if(!(*c == lit))
              goto __CPROVER_DUMP_L9;

            l = c;
            do
            {
              other = *l;
              if(other == 0)
                break;

              lglpushstk(lgl, &lgl->_anon0.cliff->lits, other);
              l = l + 1l;
            }
            while((_Bool)1);
          }
          lglpushstk(lgl, &lgl->_anon0.cliff->lits, 0);
        }


      __CPROVER_DUMP_L9:
        ;
      }
      res=lglcliffclauses(lgl, &lgl->_anon0.cliff->lits);
      lglclnstk(&lgl->_anon0.cliff->lits);
      if(!(res == 0))
        tmp_if_expr_7 = !(lgl->mt != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_7 = (_Bool)0;
      return (signed int)tmp_if_expr_7;
    }
  }
}

// lglclnana
// file lglib.c line 5830
static void lglclnana(struct LGL *lgl)
{
  lglclnstk(&lgl->clause);
  lglpopnunmarkstk(lgl, &lgl->seen);
  lglclnframes(lgl);
}

// lglclnframes
// file lglib.c line 5813
static void lglclnframes(struct LGL *lgl)
{
  signed int return_value_lglmtstk_1;
  signed int return_value_lglpopstk_2;
  do
  {
    return_value_lglmtstk_1=lglmtstk(&lgl->frames);
    if(!(return_value_lglmtstk_1 == 0))
      break;

    return_value_lglpopstk_2=lglpopstk(&lgl->frames);
    lglunuselevel(lgl, return_value_lglpopstk_2);
  }
  while((_Bool)1);
}

// lglclnpoisoned
// file lglib.c line 5818
static void lglclnpoisoned(struct LGL *lgl)
{
  struct AVar *av;
  signed int lit;
  signed int return_value_lglmtstk_1;
  do
  {
    return_value_lglmtstk_1=lglmtstk(&lgl->poisoned);
    if(!(return_value_lglmtstk_1 == 0))
      break;

    lit=lglpopstk(&lgl->poisoned);
    av=lglavar(lgl, lit);
    av->poisoned = (unsigned int)0;
  }
  while((_Bool)1);
}

// lglclnstk
// file lglib.c line 1472
static void lglclnstk(struct Stk *s)
{
  lglrststk(s, 0);
}

// lglclone
// file lglib.c line 1990
struct LGL * lglclone(struct LGL *orig)
{
  unsigned long int max_bytes;
  unsigned long int current_bytes;
  struct LGL *lgl = orig;
  signed int glue;
  if(orig == ((struct LGL *)NULL))
    return ((struct LGL *)NULL);

  else
  {
    lglcompact(orig);

  __CPROVER_DUMP_L2:
    ;
    lgl=lglnewlgl(orig->mem->state, orig->mem->alloc, orig->mem->realloc, orig->mem->dealloc);
    memcpy((void *)lgl, (const void *)orig, (unsigned long int)((char *)&orig->mem - (char *)orig));
    max_bytes = lgl->stats->bytes.max;
    current_bytes = lgl->stats->bytes.current;
    memcpy((void *)lgl->stats, (const void *)orig->stats, sizeof(struct Stats) /*2272ul*/ );
    lgl->stats->bytes.current = current_bytes;
    lgl->stats->bytes.max = max_bytes;
    memcpy((void *)lgl->opts, (const void *)orig->opts, sizeof(struct Opts) /*5680ul*/ );
    lgl->out = orig->out;
    lgl->prefix=lglstrdup(lgl, orig->prefix);
    if(!(orig->cbs == ((struct Cbs *)NULL)))
    {
      lglinitcbs(lgl);
      if(!(orig->cbs->onabort == ((void (*)(void *))NULL)))
      {
        lgl->cbs->abortstate = orig->cbs->abortstate;
        lgl->cbs->onabort = orig->cbs->onabort;
      }

      if(!(orig->cbs->getime == ((double (*)(void))NULL)))
        lgl->cbs->getime = orig->cbs->getime;

    }

    do
    {

    __CPROVER_DUMP_L4:
      ;
      void *return_value_lglnew_1;
      return_value_lglnew_1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Limits) /*352ul*/ );
      lgl->limits = (struct Limits *)return_value_lglnew_1;
      memcpy((void *)lgl->limits, (const void *)orig->limits, (unsigned long int)1 * sizeof(struct Limits) /*352ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L5:
      ;
      void *return_value_lglnew_2;
      return_value_lglnew_2=lglnew(lgl, (unsigned long int)1 * sizeof(struct Times) /*240ul*/ );
      lgl->times = (struct Times *)return_value_lglnew_2;
      memcpy((void *)lgl->times, (const void *)orig->times, (unsigned long int)1 * sizeof(struct Times) /*240ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L6:
      ;
      void *return_value_lglnew_3;
      return_value_lglnew_3=lglnew(lgl, (unsigned long int)1 * sizeof(struct Tmrs) /*128ul*/ );
      lgl->timers = (struct Tmrs *)return_value_lglnew_3;
      memcpy((void *)lgl->timers, (const void *)orig->timers, (unsigned long int)1 * sizeof(struct Tmrs) /*128ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L7:
      ;
      void *return_value_lglnew_4;
      return_value_lglnew_4=lglnew(lgl, (unsigned long int)1 * sizeof(struct FltStr) /*604ul*/ );
      lgl->fltstr = (struct FltStr *)return_value_lglnew_4;
      memcpy((void *)lgl->fltstr, (const void *)orig->fltstr, (unsigned long int)1 * sizeof(struct FltStr) /*604ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L8:
      ;
      void *return_value_lglnew_5;
      return_value_lglnew_5=lglnew(lgl, (unsigned long int)orig->szext * sizeof(struct Ext) /*32ul*/ );
      lgl->ext = (struct Ext *)return_value_lglnew_5;
      memcpy((void *)lgl->ext, (const void *)orig->ext, (unsigned long int)orig->szext * sizeof(struct Ext) /*32ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L9:
      ;
      void *return_value_lglnew_6;
      return_value_lglnew_6=lglnew(lgl, (unsigned long int)orig->szvars * sizeof(signed int) /*4ul*/ );
      lgl->i2e = (signed int *)return_value_lglnew_6;
      memcpy((void *)lgl->i2e, (const void *)orig->i2e, (unsigned long int)orig->szvars * sizeof(signed int) /*4ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L10:
      ;
      void *return_value_lglnew_7;
      return_value_lglnew_7=lglnew(lgl, (unsigned long int)(2 * orig->szvars) * sizeof(signed int) /*4ul*/ );
      lgl->doms = (signed int *)return_value_lglnew_7;
      memcpy((void *)lgl->doms, (const void *)orig->doms, (unsigned long int)(2 * orig->szvars) * sizeof(signed int) /*4ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L11:
      ;
      void *return_value_lglnew_8;
      return_value_lglnew_8=lglnew(lgl, (unsigned long int)orig->szvars * sizeof(struct DVar) /*16ul*/ );
      lgl->dvars = (struct DVar *)return_value_lglnew_8;
      memcpy((void *)lgl->dvars, (const void *)orig->dvars, (unsigned long int)orig->szvars * sizeof(struct DVar) /*16ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L12:
      ;
      void *return_value_lglnew_9;
      return_value_lglnew_9=lglnew(lgl, (unsigned long int)orig->szvars * sizeof(struct AVar) /*12ul*/ );
      lgl->avars = (struct AVar *)return_value_lglnew_9;
      memcpy((void *)lgl->avars, (const void *)orig->avars, (unsigned long int)orig->szvars * sizeof(struct AVar) /*12ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L13:
      ;
      void *return_value_lglnew_10;
      return_value_lglnew_10=lglnew(lgl, (unsigned long int)orig->szvars * sizeof(signed char) /*1ul*/ );
      lgl->vals = (signed char *)return_value_lglnew_10;
      memcpy((void *)lgl->vals, (const void *)orig->vals, (unsigned long int)orig->szvars * sizeof(signed char) /*1ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L14:
      ;
      void *return_value_lglnew_11;
      return_value_lglnew_11=lglnew(lgl, (unsigned long int)(2 * orig->szvars) * sizeof(signed long int) /*8ul*/ );
      lgl->jwh = (signed long int *)return_value_lglnew_11;
      memcpy((void *)lgl->jwh, (const void *)orig->jwh, (unsigned long int)(2 * orig->szvars) * sizeof(signed long int) /*8ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L15:
      ;
      void *return_value_lglnew_12;
      return_value_lglnew_12=lglnew(lgl, (unsigned long int)orig->szdrail * sizeof(struct TD) /*12ul*/ );
      lgl->drail = (struct TD *)return_value_lglnew_12;
      memcpy((void *)lgl->drail, (const void *)orig->drail, (unsigned long int)orig->szdrail * sizeof(struct TD) /*12ul*/ );
    }
    while((_Bool)0);
    lglqclone(lgl, orig);
    do
    {
      void *return_value_lglnew_13;
      return_value_lglnew_13=lglnew(lgl, (unsigned long int)(((1 << 4) - 1) + 1) * sizeof(struct Stk) /*24ul*/ );
      lgl->red = (struct Stk *)return_value_lglnew_13;
    }
    while((_Bool)0);
    glue = 0;
    for( ; !(glue >= 16); glue = glue + 1)
      do
      {
        unsigned long int lglclone__1__16__1__COUNT = (unsigned long int)((orig->red + (signed long int)glue)->top - (orig->red + (signed long int)glue)->start);
        unsigned long int lglclone__1__16__1__SIZE = (unsigned long int)((orig->red + (signed long int)glue)->end - (orig->red + (signed long int)glue)->start);
        unsigned long int lglclone__1__16__1__BYTES = lglclone__1__16__1__SIZE * sizeof(signed int) /*4ul*/ ;
        do
        {
          void *return_value_lglnew_14;
          return_value_lglnew_14=lglnew(lgl, lglclone__1__16__1__SIZE * sizeof(signed int) /*4ul*/ );
          (lgl->red + (signed long int)glue)->start = (signed int *)return_value_lglnew_14;
        }
        while((_Bool)0);
        memcpy((void *)(lgl->red + (signed long int)glue)->start, (const void *)(orig->red + (signed long int)glue)->start, lglclone__1__16__1__BYTES);
        (lgl->red + (signed long int)glue)->top = (lgl->red + (signed long int)glue)->start + (signed long int)lglclone__1__16__1__COUNT;
        (lgl->red + (signed long int)glue)->end = (lgl->red + (signed long int)glue)->start + (signed long int)lglclone__1__16__1__SIZE;
      }
      while((_Bool)0);
    do
    {
      void *return_value_lglnew_15;
      return_value_lglnew_15=lglnew(lgl, (unsigned long int)1 * sizeof(struct Wchs) /*152ul*/ );
      lgl->wchs = (struct Wchs *)return_value_lglnew_15;
    }
    while((_Bool)0);
    memcpy((void *)lgl->wchs, (const void *)orig->wchs, sizeof(struct Wchs) /*152ul*/ );
    do
    {
      unsigned long int lglclone__1__18__COUNT = (unsigned long int)(orig->wchs->stk.top - orig->wchs->stk.start);
      unsigned long int lglclone__1__18__SIZE = (unsigned long int)(orig->wchs->stk.end - orig->wchs->stk.start);
      unsigned long int lglclone__1__18__BYTES = lglclone__1__18__SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew_16;
        return_value_lglnew_16=lglnew(lgl, lglclone__1__18__SIZE * sizeof(signed int) /*4ul*/ );
        lgl->wchs->stk.start = (signed int *)return_value_lglnew_16;
      }
      while((_Bool)0);
      memcpy((void *)lgl->wchs->stk.start, (const void *)orig->wchs->stk.start, lglclone__1__18__BYTES);
      lgl->wchs->stk.top = lgl->wchs->stk.start + (signed long int)lglclone__1__18__COUNT;
      lgl->wchs->stk.end = lgl->wchs->stk.start + (signed long int)lglclone__1__18__SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone__1__19__COUNT = (unsigned long int)(orig->control.top - orig->control.start);
      unsigned long int lglclone__1__19__SIZE = (unsigned long int)(orig->control.end - orig->control.start);
      unsigned long int lglclone__1__19__BYTES = lglclone__1__19__SIZE * sizeof(struct Ctr) /*4ul*/ ;
      do
      {
        void *return_value_lglnew_17;
        return_value_lglnew_17=lglnew(lgl, lglclone__1__19__SIZE * sizeof(struct Ctr) /*4ul*/ );
        lgl->control.start = (struct Ctr *)return_value_lglnew_17;
      }
      while((_Bool)0);
      memcpy((void *)lgl->control.start, (const void *)orig->control.start, lglclone__1__19__BYTES);
      lgl->control.top = lgl->control.start + (signed long int)lglclone__1__19__COUNT;
      lgl->control.end = lgl->control.start + (signed long int)lglclone__1__19__SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int COUNT = (unsigned long int)(orig->clause.top - orig->clause.start);
      unsigned long int SIZE = (unsigned long int)(orig->clause.end - orig->clause.start);
      unsigned long int lglclone__1__20__BYTES = SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew_18;
        return_value_lglnew_18=lglnew(lgl, SIZE * sizeof(signed int) /*4ul*/ );
        lgl->clause.start = (signed int *)return_value_lglnew_18;
      }
      while((_Bool)0);
      memcpy((void *)lgl->clause.start, (const void *)orig->clause.start, lglclone__1__20__BYTES);
      lgl->clause.top = lgl->clause.start + (signed long int)COUNT;
      lgl->clause.end = lgl->clause.start + (signed long int)SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone__1__21__COUNT = (unsigned long int)(orig->eclause.top - orig->eclause.start);
      unsigned long int lglclone__1__21__SIZE = (unsigned long int)(orig->eclause.end - orig->eclause.start);
      unsigned long int lglclone__1__21__BYTES = lglclone__1__21__SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew_19;
        return_value_lglnew_19=lglnew(lgl, lglclone__1__21__SIZE * sizeof(signed int) /*4ul*/ );
        lgl->eclause.start = (signed int *)return_value_lglnew_19;
      }
      while((_Bool)0);
      memcpy((void *)lgl->eclause.start, (const void *)orig->eclause.start, lglclone__1__21__BYTES);
      lgl->eclause.top = lgl->eclause.start + (signed long int)lglclone__1__21__COUNT;
      lgl->eclause.end = lgl->eclause.start + (signed long int)lglclone__1__21__SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone__1__22__COUNT = (unsigned long int)(orig->extend.top - orig->extend.start);
      unsigned long int lglclone__1__22__SIZE = (unsigned long int)(orig->extend.end - orig->extend.start);
      unsigned long int lglclone__1__22__BYTES = lglclone__1__22__SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew_20;
        return_value_lglnew_20=lglnew(lgl, lglclone__1__22__SIZE * sizeof(signed int) /*4ul*/ );
        lgl->extend.start = (signed int *)return_value_lglnew_20;
      }
      while((_Bool)0);
      memcpy((void *)lgl->extend.start, (const void *)orig->extend.start, lglclone__1__22__BYTES);
      lgl->extend.top = lgl->extend.start + (signed long int)lglclone__1__22__COUNT;
      lgl->extend.end = lgl->extend.start + (signed long int)lglclone__1__22__SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone__1__23__COUNT = (unsigned long int)(orig->irr.top - orig->irr.start);
      unsigned long int lglclone__1__23__SIZE = (unsigned long int)(orig->irr.end - orig->irr.start);
      unsigned long int lglclone__1__23__BYTES = lglclone__1__23__SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew_21;
        return_value_lglnew_21=lglnew(lgl, lglclone__1__23__SIZE * sizeof(signed int) /*4ul*/ );
        lgl->irr.start = (signed int *)return_value_lglnew_21;
      }
      while((_Bool)0);
      memcpy((void *)lgl->irr.start, (const void *)orig->irr.start, lglclone__1__23__BYTES);
      lgl->irr.top = lgl->irr.start + (signed long int)lglclone__1__23__COUNT;
      lgl->irr.end = lgl->irr.start + (signed long int)lglclone__1__23__SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone__1__24__COUNT = (unsigned long int)(orig->trail.top - orig->trail.start);
      unsigned long int lglclone__1__24__SIZE = (unsigned long int)(orig->trail.end - orig->trail.start);
      unsigned long int lglclone__1__24__BYTES = lglclone__1__24__SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew_22;
        return_value_lglnew_22=lglnew(lgl, lglclone__1__24__SIZE * sizeof(signed int) /*4ul*/ );
        lgl->trail.start = (signed int *)return_value_lglnew_22;
      }
      while((_Bool)0);
      memcpy((void *)lgl->trail.start, (const void *)orig->trail.start, lglclone__1__24__BYTES);
      lgl->trail.top = lgl->trail.start + (signed long int)lglclone__1__24__COUNT;
      lgl->trail.end = lgl->trail.start + (signed long int)lglclone__1__24__SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone__1__25__COUNT = (unsigned long int)(orig->frames.top - orig->frames.start);
      unsigned long int lglclone__1__25__SIZE = (unsigned long int)(orig->frames.end - orig->frames.start);
      unsigned long int lglclone__1__25__BYTES = lglclone__1__25__SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew_23;
        return_value_lglnew_23=lglnew(lgl, lglclone__1__25__SIZE * sizeof(signed int) /*4ul*/ );
        lgl->frames.start = (signed int *)return_value_lglnew_23;
      }
      while((_Bool)0);
      memcpy((void *)lgl->frames.start, (const void *)orig->frames.start, lglclone__1__25__BYTES);
      lgl->frames.top = lgl->frames.start + (signed long int)lglclone__1__25__COUNT;
      lgl->frames.end = lgl->frames.start + (signed long int)lglclone__1__25__SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone__1__26__COUNT = (unsigned long int)(orig->eassume.top - orig->eassume.start);
      unsigned long int lglclone__1__26__SIZE = (unsigned long int)(orig->eassume.end - orig->eassume.start);
      unsigned long int lglclone__1__26__BYTES = lglclone__1__26__SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew_24;
        return_value_lglnew_24=lglnew(lgl, lglclone__1__26__SIZE * sizeof(signed int) /*4ul*/ );
        lgl->eassume.start = (signed int *)return_value_lglnew_24;
      }
      while((_Bool)0);
      memcpy((void *)lgl->eassume.start, (const void *)orig->eassume.start, lglclone__1__26__BYTES);
      lgl->eassume.top = lgl->eassume.start + (signed long int)lglclone__1__26__COUNT;
      lgl->eassume.end = lgl->eassume.start + (signed long int)lglclone__1__26__SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone__1__27__COUNT = (unsigned long int)(orig->assume.top - orig->assume.start);
      unsigned long int lglclone__1__27__SIZE = (unsigned long int)(orig->assume.end - orig->assume.start);
      unsigned long int lglclone__1__27__BYTES = lglclone__1__27__SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew_25;
        return_value_lglnew_25=lglnew(lgl, lglclone__1__27__SIZE * sizeof(signed int) /*4ul*/ );
        lgl->assume.start = (signed int *)return_value_lglnew_25;
      }
      while((_Bool)0);
      memcpy((void *)lgl->assume.start, (const void *)orig->assume.start, lglclone__1__27__BYTES);
      lgl->assume.top = lgl->assume.start + (signed long int)lglclone__1__27__COUNT;
      lgl->assume.end = lgl->assume.start + (signed long int)lglclone__1__27__SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone__1__28__COUNT = (unsigned long int)(orig->fassume.top - orig->fassume.start);
      unsigned long int lglclone__1__28__SIZE = (unsigned long int)(orig->fassume.end - orig->fassume.start);
      unsigned long int BYTES = lglclone__1__28__SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew_26;
        return_value_lglnew_26=lglnew(lgl, lglclone__1__28__SIZE * sizeof(signed int) /*4ul*/ );
        lgl->fassume.start = (signed int *)return_value_lglnew_26;
      }
      while((_Bool)0);
      memcpy((void *)lgl->fassume.start, (const void *)orig->fassume.start, BYTES);
      lgl->fassume.top = lgl->fassume.start + (signed long int)lglclone__1__28__COUNT;
      lgl->fassume.end = lgl->fassume.start + (signed long int)lglclone__1__28__SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone__1__29__COUNT = (unsigned long int)(orig->cassume.top - orig->cassume.start);
      unsigned long int lglclone__1__29__SIZE = (unsigned long int)(orig->cassume.end - orig->cassume.start);
      unsigned long int lglclone__1__29__BYTES = lglclone__1__29__SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew_27;
        return_value_lglnew_27=lglnew(lgl, lglclone__1__29__SIZE * sizeof(signed int) /*4ul*/ );
        lgl->cassume.start = (signed int *)return_value_lglnew_27;
      }
      while((_Bool)0);
      memcpy((void *)lgl->cassume.start, (const void *)orig->cassume.start, lglclone__1__29__BYTES);
      lgl->cassume.top = lgl->cassume.start + (signed long int)lglclone__1__29__COUNT;
      lgl->cassume.end = lgl->cassume.start + (signed long int)lglclone__1__29__SIZE;
    }
    while((_Bool)0);
    lgl->stats->bytes.max = orig->stats->bytes.max;
    return lgl;
  }
}

// lglclsr
// file lglib.c line 13663
static void lglclsr(struct LGL *lgl)
{
  signed int lit;
  signed int return_value_lglterminate_1;
  signed int return_value_lglcgrlimhit_2;
  signed int return_value_lglcgrlimhit_3;
  while(lgl->mt == 0)
  {
    return_value_lglterminate_1=lglterminate(lgl);
    if(!(return_value_lglterminate_1 == 0))
      break;

    lit=lglwrknext(lgl);
    if(lit == 0)
      break;

    return_value_lglcgrlimhit_2=lglcgrlimhit(lgl);
    if(!(return_value_lglcgrlimhit_2 == 0))
      break;

    lglcgrlit(lgl, lit);
    if(lgl->mt == 0)
    {
      return_value_lglcgrlimhit_3=lglcgrlimhit(lgl);
      if(return_value_lglcgrlimhit_3 == 0)
        lglcgrlit(lgl, -lit);

    }

  }
  if(!(lgl->_anon0.cgr->simplified.all == 0))
    lglprt(lgl, 2, "[closure-%d] simplified %d gates", lgl->stats->cgr.count, lgl->_anon0.cgr->simplified.all);

  if(!(lgl->_anon0.cgr->simplified.and == 0))
    lglprt(lgl, 2, "[closure-%d] simplified %d and gates", lgl->stats->cgr.count, lgl->_anon0.cgr->simplified.and);

  if(!(lgl->_anon0.cgr->simplified.xor == 0))
    lglprt(lgl, 2, "[closure-%d] simplified %d xor gates", lgl->stats->cgr.count, lgl->_anon0.cgr->simplified.xor);

  if(!(lgl->_anon0.cgr->simplified.ite == 0))
    lglprt(lgl, 2, "[closure-%d] simplified %d ite gates", lgl->stats->cgr.count, lgl->_anon0.cgr->simplified.ite);

  if(!(lgl->_anon0.cgr->matched.all == 0))
    lglprt(lgl, 2, "[closure-%d] matched %d gates", lgl->stats->cgr.count, lgl->_anon0.cgr->matched.all);

  double return_value_lglpcnt_4;
  if(!(lgl->_anon0.cgr->matched.and == 0))
  {
    return_value_lglpcnt_4=lglpcnt((double)lgl->_anon0.cgr->matched.and, (double)lgl->_anon0.cgr->matched.all);
    lglprt(lgl, 2, "[closure-%d] matched %d and gates %.0f%%", lgl->stats->cgr.count, lgl->_anon0.cgr->matched.and, return_value_lglpcnt_4);
  }

  double return_value_lglpcnt_5;
  if(!(lgl->_anon0.cgr->matched.xor == 0))
  {
    return_value_lglpcnt_5=lglpcnt((double)lgl->_anon0.cgr->matched.xor, (double)lgl->_anon0.cgr->matched.all);
    lglprt(lgl, 2, "[closure-%d] matched %d xor gates %.0f%%", lgl->stats->cgr.count, lgl->_anon0.cgr->matched.xor, return_value_lglpcnt_5);
  }

  double return_value_lglpcnt_6;
  if(!(lgl->_anon0.cgr->matched.ite == 0))
  {
    return_value_lglpcnt_6=lglpcnt((double)lgl->_anon0.cgr->matched.ite, (double)lgl->_anon0.cgr->matched.all);
    lglprt(lgl, 2, "[closure-%d] matched %d ite gates %.0f%%", lgl->stats->cgr.count, lgl->_anon0.cgr->matched.ite, return_value_lglpcnt_6);
  }

}

// lglcmpagsl
// file lglib.c line 5128
static signed int lglcmpagsl(struct ASL *a, struct ASL *b)
{
  signed int res = a->act - b->act;
  if(!(res == 0))
    return res;

  else
  {
    res = (b->lidx & (1 << 4) - 1) - (a->lidx & (1 << 4) - 1);
    if(!(res == 0))
      return res;

    else
    {
      res = b->size - a->size;
      if(!(res == 0))
        return res;

      else
        return a->lidx - b->lidx;
    }
  }
}

// lglcmpasgl
// file lglib.c line 5136
static signed int lglcmpasgl(struct ASL *a, struct ASL *b)
{
  signed int res = a->act - b->act;
  if(!(res == 0))
    return res;

  else
  {
    res = b->size - a->size;
    if(!(res == 0))
      return res;

    else
    {
      res = (b->lidx & (1 << 4) - 1) - (a->lidx & (1 << 4) - 1);
      if(!(res == 0))
        return res;

      else
        return a->lidx - b->lidx;
    }
  }
}

// lglcmpdfl
// file lglib.c line 15489
static signed int lglcmpdfl(const struct DFL *a, const struct DFL *b)
{
  return a->discovered - b->discovered;
}

// lglcmpfdat
// file lglib.c line 7440
static signed int lglcmpfdat(struct ForceData *fdat, signed int l, signed int k)
{
  struct ForceData *d;
  struct ForceData *e;
  l=abs(l);
  k=abs(k);
  d = fdat + (signed long int)l;
  e = fdat + (signed long int)k;
  if(d->sum < e->sum)
    return -1;

  else
    if(d->sum > e->sum)
      return 1;

    else
      if(!(d->pos >= e->pos))
        return -1;

      else
        if(!(e->pos >= d->pos))
          return 1;

        else
          return l - k;
}

// lglcmpgauss
// file lglib.c line 16499
static signed int lglcmpgauss(struct LGL *lgl, signed int a, signed int b)
{
  signed int res;
  signed int return_value_lglgaussoccs_1;
  return_value_lglgaussoccs_1=lglgaussoccs(lgl, a);
  signed int return_value_lglgaussoccs_2;
  return_value_lglgaussoccs_2=lglgaussoccs(lgl, b);
  res = return_value_lglgaussoccs_1 - return_value_lglgaussoccs_2;
  if(res == 0)
    res = a - b;

  return res;
}

// lglcmpgoccs
// file lglib.c line 13081
static signed int lglcmpgoccs(struct LGL *lgl, signed int a, signed int b)
{
  struct Gat *g;
  g=lglgidx2gat(lgl, a);
  struct Gat *h;
  h=lglgidx2gat(lgl, b);
  signed int res = (signed int)g->tag - (signed int)h->tag;
  if(!(res == 0))
    return res;

  else
  {
    res = (signed int)g->size - (signed int)h->size;
    if(!(res == 0))
      return res;

    else
    {
      res = g->minrhs - h->minrhs;
      if(!(res == 0))
        return res;

      else
        return a - b;
    }
  }
}

// lglcmphase
// file lglib.c line 6484
static signed int lglcmphase(struct LGL *lgl, signed int a, signed int b)
{
  signed char return_value_lgliphase_1;
  return_value_lgliphase_1=lgliphase(lgl, b);
  signed char return_value_lgliphase_2;
  return_value_lgliphase_2=lgliphase(lgl, a);
  return (signed int)return_value_lgliphase_1 - (signed int)return_value_lgliphase_2;
}

// lglcmpitecands
// file lglib.c line 12808
static signed int lglcmpitecands(const struct ITEC *c, const struct ITEC *d)
{
  signed int a = c->other;
  signed int b = d->other;
  signed int res;
  signed int return_value_abs_1;
  return_value_abs_1=abs(a);
  signed int return_value_abs_2;
  return_value_abs_2=abs(b);
  res = return_value_abs_1 - return_value_abs_2;
  if(!(res == 0))
    return res;

  else
  {
    res = a - b;
    if(!(res == 0))
      return res;

    else
      return c->other2 - d->other2;
  }
}

// lglcmpocc
// file lglib.c line 12570
static signed int lglcmpocc(struct LGL *lgl, signed int a, signed int b)
{
  signed int return_value_lglocc_1;
  return_value_lglocc_1=lglocc(lgl, a);
  signed int return_value_lglocc_2;
  return_value_lglocc_2=lglocc(lgl, b);
  return return_value_lglocc_1 - return_value_lglocc_2;
}

// lglcmprepr
// file lglib.c line 8187
static signed int lglcmprepr(struct LGL *lgl, signed int a, signed int b)
{
  signed int f;
  f=lglifrozen(lgl, a);
  signed int g;
  g=lglifrozen(lgl, b);
  signed int res = g - f;
  if(!(res == 0))
    return res;

  else
  {
    signed int return_value_abs_1;
    return_value_abs_1=abs(a);
    signed int return_value_abs_2;
    return_value_abs_2=abs(b);
    res = return_value_abs_1 - return_value_abs_2;
    if(!(res == 0))
      return res;

    else
      return a - b;
  }
}

// lglcnf
// file lglib.c line 10734
static signed long int lglcnf(signed int pos, signed int size)
{
  signed long int return_value_lglpos2cnf_1;
  return_value_lglpos2cnf_1=lglpos2cnf(pos);
  signed long int return_value_lglsize2cnf_2;
  return_value_lglsize2cnf_2=lglsize2cnf(size);
  return return_value_lglpos2cnf_1 | return_value_lglsize2cnf_2;
}

// lglcnf2pos
// file lglib.c line 10731
static signed int lglcnf2pos(signed long int cnf)
{
  return (signed int)(cnf & 0xfffffll);
}

// lglcnf2size
// file lglib.c line 10732
static signed int lglcnf2size(signed long int cnf)
{
  return (signed int)(cnf >> 32);
}

// lglcntctk
// file lglib.c line 1544
static signed int lglcntctk(struct Ctk *ctk)
{
  return (signed int)(ctk->top - ctk->start);
}

// lglcntstk
// file lglib.c line 1388
static unsigned long int lglcntstk(struct Stk *s)
{
  return (unsigned long int)(s->top - s->start);
}

// lglcntwtk
// file lglib.c line 14993
static signed int lglcntwtk(struct Wtk *wtk)
{
  return (signed int)(wtk->top - wtk->start);
}

// lglcompact
// file lglib.c line 7609
static void lglcompact(struct LGL *lgl)
{
  signed int glue;
  lglfitstk(lgl, &lgl->assume);
  lglfitstk(lgl, &lgl->clause);
  lglfitstk(lgl, &lgl->eassume);
  lglfitstk(lgl, &lgl->extend);
  lglfitstk(lgl, &lgl->fassume);
  lglfitstk(lgl, &lgl->cassume);
  lglfitstk(lgl, &lgl->frames);
  lglfitstk(lgl, &lgl->trail);
  lgldefrag(lgl);
  lglfitstk(lgl, &lgl->wchs->stk);
  lglfitstk(lgl, &lgl->irr);
  glue = 0;
  for( ; !(glue >= 15); glue = glue + 1)
    lglfitlir(lgl, lgl->red + (signed long int)glue);
  lglrelstk(lgl, &lgl->_anon1.lcaseen);
  lglrelstk(lgl, &lgl->poisoned);
  lglrelstk(lgl, &lgl->seen);
  lglrelstk(lgl, &lgl->esched);
}

// lglcompactify
// file lglib.c line 17573
static signed int lglcompactify(struct LGL *lgl, signed int res)
{
  if(lgl->opts->compact.val == 0)
    return 0;

  else
    if(res == 0)
      return 1;

    else
      if(res == 20)
        return 1;

      else
        return (signed int)(lgl->opts->compact.val >= 2);
}

// lglcompletefork
// file lglib.c line 18926
static void lglcompletefork(struct LGL *dst, struct LGL *src)
{
  signed int eidx;
  signed int erepr;
  signed int val;
  struct Ext *dext;
  struct Ext *rext;
  eidx = 1;
  signed int return_value_abs_1;
  for( ; src->maxext >= eidx; eidx = eidx + 1)
  {
    erepr=lglerepr(src, eidx);
    if(eidx >= dst->szext)
      lgladjext(dst, eidx);

    if(!(dst->maxext >= eidx))
    {
      dst->maxext = eidx;
      lglmelter(dst);
    }

    rext=lglelit2ext(src, erepr);
    dext=lglelit2ext(dst, eidx);
    if(!(erepr == eidx))
    {
      dext->repr = erepr;
      dext->equiv = (unsigned int)1;
      dext->imported = (unsigned int)1;
    }

    else
    {
      return_value_abs_1=abs(rext->repr);
      if(return_value_abs_1 >= 2)
        goto __CPROVER_DUMP_L7;

      else
      {
        val = rext->repr;
        dext->repr = val;
        dext->imported = (unsigned int)1;
      }
    }

  __CPROVER_DUMP_L7:
    ;
  }
}

// lglcomputechanged
// file lglib.c line 17371
static void lglcomputechanged(struct LGL *lgl)
{
  struct Ext *ext;
  signed int eidx;
  lgl->changed = 0;
  eidx = 1;
  for( ; lgl->maxext >= eidx; eidx = eidx + 1)
  {
    ext=lglelit2ext(lgl, eidx);
    if(!(ext->oldval == 0))
    {
      if(!(ext->oldval == ext->val))
        lgl->changed = lgl->changed + 1;

    }

    ext->oldval = (signed int)ext->val;
  }

__CPROVER_DUMP_L3:
  ;
}

// lglcomputecog
// file lglib.c line 18522
static void lglcomputecog(struct LGL *lgl)
{
  signed int eidx;
  signed int minval;
  signed int maxval;
  signed int minvar;
  signed int maxvar;
  signed int count;
  signed long int tmp;
  signed long int avgval;
  signed long int avgvar;
  struct Ext *ext;
  maxvar = 0;
  minvar = maxvar;
  count = minvar;
  avgvar = (signed long int)0;
  avgval = avgvar;
  minval = 0x7fffffff;
  maxval = -1;
  eidx = 1;
  for( ; lgl->maxext >= eidx; eidx = eidx + 1)
  {
    ext=lglelit2ext(lgl, eidx);
    if(!(ext->cog.count == 0))
    {
      tmp = (signed long int)10 * ext->cog.sum;
      tmp = tmp / (signed long int)ext->cog.count;
      tmp = tmp + (signed long int)5;
      tmp = tmp / (signed long int)10;
      if(!(tmp >= (signed long int)minval))
      {
        minval = (signed int)tmp;
        minvar = eidx;
      }

      if(!((signed long int)maxval >= tmp))
      {
        maxval = (signed int)tmp;
        maxvar = eidx;
      }

      avgval = avgval + tmp;
      avgvar = avgvar + (signed long int)eidx;
      count = count + 1;
    }

  }
  if(!(count == 0))
  {
    avgval = avgval * (signed long int)10;
    avgval = avgval / (signed long int)count;
    avgval = avgval + (signed long int)5;
    avgval = avgval / (signed long int)10;
    avgvar = avgvar * (signed long int)10;
    avgvar = avgvar / (signed long int)count;
    avgvar = avgvar + (signed long int)5;
    avgvar = avgvar / (signed long int)10;
  }

  lgl->stats->features.cog.val.min = minval;
  lgl->stats->features.cog.val.avg = (signed int)avgval;
  lgl->stats->features.cog.val.max = maxval;
  lgl->stats->features.cog.var.min = minvar;
  lgl->stats->features.cog.var.avg = (signed int)avgvar;
  lgl->stats->features.cog.var.max = maxvar;
}

// lglcon
// file lglib.c line 6572
static void lglcon(struct LGL *lgl)
{
  signed int glue = -1;
  for( ; !(glue >= 15); glue = glue + 1)
    lglconnaux(lgl, glue);
  lglfullyconnected(lgl);
}

// lglconnaux
// file lglib.c line 6490
static void lglconnaux(struct LGL *lgl, signed int glue)
{
  signed int lit;
  signed int satisfied;
  signed int lidx;
  signed int size;
  signed int red;
  signed int act;
  const signed int *p;
  const signed int *c;
  const signed int *lglconnaux__1__start;
  const signed int *top;
  signed int *q;
  signed int *d;
  struct Stk *stk;
  signed char val;
  if(glue >= 0)
  {
    red = REDCS;
    stk = lgl->red + (signed long int)glue;
  }

  else
  {
    red = 0;
    stk = &lgl->irr;
  }
  q = stk->start;
  lglconnaux__1__start = q;
  c = lglconnaux__1__start;
  top = stk->top;
  _Bool tmp_if_expr_1;
  signed int *tmp_post_2;
  const signed int *tmp_post_3;
  const signed int *tmp_post_5;
  signed int *tmp_post_6;
  signed int return_value_lglcmphase_12;
  signed int return_value_lglmtstk_13;
  signed int return_value_lglcmphase_15;
  signed int *tmp_post_16;
  while(!(c >= top))
  {
    act = *c;
    if(act == 0x7fffffff)
    {
      p = c + (signed long int)1;
      do
      {
        if(!(p >= top))
          tmp_if_expr_1 = *p == 0x7fffffff ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(!tmp_if_expr_1)
          break;

        p = p + 1l;
      }
      while((_Bool)1);
      c = p;
    }

    else
    {
      signed int return_value_lglisact_4;
      return_value_lglisact_4=lglisact(act);
      if(!(return_value_lglisact_4 == 0))
      {
        tmp_post_2 = q;
        q = q + 1l;
        tmp_post_3 = c;
        c = c + 1l;
        *tmp_post_2 = *tmp_post_3;
      }

      else
        act = -1;
      p = c;
      d = q;
      satisfied = 0;
      do
      {
        tmp_post_5 = p;
        p = p + 1l;
        lit = *tmp_post_5;
        if(lit == 0)
          break;

        if(satisfied == 0)
        {
          val=lglval(lgl, lit);
          signed int return_value_lgliselim_7;
          return_value_lgliselim_7=lgliselim(lgl, lit);
          if(!(return_value_lgliselim_7 == 0))
            satisfied = 1;

          else
            if((signed int)val >= 1)
              satisfied = 1;

            else
              if(val == 0)
              {
                tmp_post_6 = q;
                q = q + 1l;
                *tmp_post_6 = lit;
              }

        }

      }
      while((_Bool)1);
      if(p == c + 1l || !(satisfied == 0))
        q = d - (signed long int)(act >= 0);

      else
      {
        size = (signed int)(q - d);
        if(size == 0)
        {
          q = d - (signed long int)(act >= 0);
          if(lgl->mt == 0)
          {

          __CPROVER_DUMP_L18:
            ;
            lgl->mt = 1;
          }

        }

        else
          if(size == 1)
          {
            q = d - (signed long int)(act >= 0);

          __CPROVER_DUMP_L21:
            ;
            lglunit(lgl, d[(signed long int)0]);
          }

          else
            if(size == 2)
            {
              q = d - (signed long int)(act >= 0);
              lglwchbin(lgl, d[(signed long int)0], d[(signed long int)1], red);
              lglwchbin(lgl, d[(signed long int)1], d[(signed long int)0], red);
            }

            else
              if(size == 3)
              {
                q = d - (signed long int)(act >= 0);
                lglwchtrn(lgl, d[(signed long int)0], d[(signed long int)1], d[(signed long int)2], red);
                lglwchtrn(lgl, d[(signed long int)1], d[(signed long int)0], d[(signed long int)2], red);
                lglwchtrn(lgl, d[(signed long int)2], d[(signed long int)0], d[(signed long int)1], red);
              }

              else
              {
                if(!(lgl->opts->sortlits.val == 0))
                  do
                  {
                    signed int *AA = d;
                    signed int NN = size;
                    do
                    {
                      signed int L = 0;
                      signed int R = NN - 1;
                      signed int M;
                      signed int LL;
                      signed int RR;
                      signed int I;
                      if(!(R + -L >= 11))
                        break;

                      do
                      {
                        M = (L + R) / 2;
                        do
                        {
                          signed int TMP = AA[(signed long int)M];
                          AA[(signed long int)M] = AA[(signed long int)(R - 1)];
                          AA[(signed long int)(R - 1)] = TMP;
                        }
                        while((_Bool)0);
                        do
                        {
                          signed int return_value_lglcmphase_8;
                          return_value_lglcmphase_8=lglcmphase(lgl, *(&AA[(signed long int)L]), *(&AA[(signed long int)(R - 1)]));
                          if(return_value_lglcmphase_8 >= 1)
                            do
                            {
                              signed int lglconnaux__1__2__8__1__1__1__1__2__1__TMP = AA[(signed long int)L];
                              AA[(signed long int)L] = AA[(signed long int)(R - 1)];
                              AA[(signed long int)(R - 1)] = lglconnaux__1__2__8__1__1__1__1__2__1__TMP;
                            }
                            while((_Bool)0);

                        }
                        while((_Bool)0);
                        do
                        {
                          signed int return_value_lglcmphase_9;
                          return_value_lglcmphase_9=lglcmphase(lgl, *(&AA[(signed long int)L]), *(&AA[(signed long int)R]));
                          if(return_value_lglcmphase_9 >= 1)
                            do
                            {
                              signed int lglconnaux__1__2__8__1__1__1__1__3__1__TMP = AA[(signed long int)L];
                              AA[(signed long int)L] = AA[(signed long int)R];
                              AA[(signed long int)R] = lglconnaux__1__2__8__1__1__1__1__3__1__TMP;
                            }
                            while((_Bool)0);

                        }
                        while((_Bool)0);
                        do
                        {
                          signed int return_value_lglcmphase_10;
                          return_value_lglcmphase_10=lglcmphase(lgl, *(&AA[(signed long int)(R - 1)]), *(&AA[(signed long int)R]));
                          if(return_value_lglcmphase_10 >= 1)
                            do
                            {
                              signed int lglconnaux__1__2__8__1__1__1__1__4__1__TMP = AA[(signed long int)(R - 1)];
                              AA[(signed long int)(R - 1)] = AA[(signed long int)R];
                              AA[(signed long int)R] = lglconnaux__1__2__8__1__1__1__1__4__1__TMP;
                            }
                            while((_Bool)0);

                        }
                        while((_Bool)0);
                        do
                        {
                          signed int PIVOT;
                          signed int J = R - 1;
                          I = (L + 1) - 1;
                          PIVOT = AA[(signed long int)J];
                          do
                          {

                          __CPROVER_DUMP_L39:
                            ;
                            I = I + 1;
                            signed int return_value_lglcmphase_11;
                            return_value_lglcmphase_11=lglcmphase(lgl, *(&AA[(signed long int)I]), *(&PIVOT));
                            if(!(return_value_lglcmphase_11 >= 0))
                              goto __CPROVER_DUMP_L39;

                            do
                            {
                              J = J - 1;
                              return_value_lglcmphase_12=lglcmphase(lgl, *(&PIVOT), *(&AA[(signed long int)J]));
                              if(return_value_lglcmphase_12 >= 0)
                                break;

                              if(J == 1 + L)
                                break;

                            }
                            while((_Bool)1);
                            if(I >= J)
                              break;

                            do
                            {
                              signed int lglconnaux__1__2__8__1__1__1__1__5__1__1__1__TMP = AA[(signed long int)I];
                              AA[(signed long int)I] = AA[(signed long int)J];
                              AA[(signed long int)J] = lglconnaux__1__2__8__1__1__1__1__5__1__1__1__TMP;
                            }
                            while((_Bool)0);
                          }
                          while((_Bool)1);
                          do
                          {
                            signed int lglconnaux__1__2__8__1__1__1__1__5__2__TMP = AA[(signed long int)I];
                            AA[(signed long int)I] = AA[(signed long int)(R - 1)];
                            AA[(signed long int)(R - 1)] = lglconnaux__1__2__8__1__1__1__1__5__2__TMP;
                          }
                          while((_Bool)0);
                        }
                        while((_Bool)0);
                        if(!(I + -L >= R + -I))
                        {
                          LL = I + 1;
                          RR = R;
                          R = I - 1;
                        }

                        else
                        {
                          LL = L;
                          RR = I - 1;
                          L = I + 1;
                        }
                        if(R + -L >= 11)
                        {
                          lglpushstk(lgl, &lgl->_anon1.sortstk, LL);
                          lglpushstk(lgl, &lgl->_anon1.sortstk, RR);
                        }

                        else
                          if(RR + -LL >= 11)
                          {
                            L = LL;
                            R = RR;
                          }

                          else
                          {
                            return_value_lglmtstk_13=lglmtstk(&lgl->_anon1.sortstk);
                            if(return_value_lglmtstk_13 == 0)
                            {
                              R=lglpopstk(&lgl->_anon1.sortstk);
                              L=lglpopstk(&lgl->_anon1.sortstk);
                            }

                            else
                              break;
                          }
                      }
                      while((_Bool)1);
                    }
                    while((_Bool)0);
                    do
                    {
                      signed int lglconnaux__1__2__8__1__2__PIVOT;
                      signed int lglconnaux__1__2__8__1__2__L = 0;
                      signed int lglconnaux__1__2__8__1__2__R = NN - 1;
                      signed int lglconnaux__1__2__8__1__2__I;
                      signed int lglconnaux__1__2__8__1__2__J;
                      lglconnaux__1__2__8__1__2__I = lglconnaux__1__2__8__1__2__R;
                      for( ; !(lglconnaux__1__2__8__1__2__L >= lglconnaux__1__2__8__1__2__I); lglconnaux__1__2__8__1__2__I = lglconnaux__1__2__8__1__2__I - 1)
                        do
                        {
                          signed int return_value_lglcmphase_14;
                          return_value_lglcmphase_14=lglcmphase(lgl, *(&AA[(signed long int)(lglconnaux__1__2__8__1__2__I - 1)]), *(&AA[(signed long int)lglconnaux__1__2__8__1__2__I]));
                          if(return_value_lglcmphase_14 >= 1)
                            do
                            {
                              signed int lglconnaux__1__2__8__1__2__1__1__1__TMP = AA[(signed long int)(lglconnaux__1__2__8__1__2__I - 1)];
                              AA[(signed long int)(lglconnaux__1__2__8__1__2__I - 1)] = AA[(signed long int)lglconnaux__1__2__8__1__2__I];
                              AA[(signed long int)lglconnaux__1__2__8__1__2__I] = lglconnaux__1__2__8__1__2__1__1__1__TMP;
                            }
                            while((_Bool)0);

                        }
                        while((_Bool)0);
                      lglconnaux__1__2__8__1__2__I = lglconnaux__1__2__8__1__2__L + 2;
                      for( ; lglconnaux__1__2__8__1__2__R >= lglconnaux__1__2__8__1__2__I; lglconnaux__1__2__8__1__2__I = lglconnaux__1__2__8__1__2__I + 1)
                      {
                        lglconnaux__1__2__8__1__2__J = lglconnaux__1__2__8__1__2__I;
                        lglconnaux__1__2__8__1__2__PIVOT = AA[(signed long int)lglconnaux__1__2__8__1__2__I];
                        do
                        {
                          return_value_lglcmphase_15=lglcmphase(lgl, *(&lglconnaux__1__2__8__1__2__PIVOT), *(&AA[(signed long int)(lglconnaux__1__2__8__1__2__J - 1)]));
                          if(return_value_lglcmphase_15 >= 0)
                            break;

                          AA[(signed long int)lglconnaux__1__2__8__1__2__J] = AA[(signed long int)(lglconnaux__1__2__8__1__2__J - 1)];
                          lglconnaux__1__2__8__1__2__J = lglconnaux__1__2__8__1__2__J - 1;
                        }
                        while((_Bool)1);
                        AA[(signed long int)lglconnaux__1__2__8__1__2__J] = lglconnaux__1__2__8__1__2__PIVOT;
                      }
                    }
                    while((_Bool)0);

                  __CPROVER_DUMP_L61:
                    ;
                  }
                  while((_Bool)0);

                tmp_post_16 = q;
                q = q + 1l;
                *tmp_post_16 = 0;
                lidx = (signed int)(d - lglconnaux__1__start);
                if(!(red == 0))
                {
                  lidx = lidx << 4;
                  lidx = lidx | glue;
                }

                lglwchlrg(lgl, d[(signed long int)0], d[(signed long int)1], red, lidx);
                lglwchlrg(lgl, d[(signed long int)1], d[(signed long int)0], red, lidx);
              }
      }
      c = p;
    }
  }
  stk->top = q;
}

// lglcount
// file lglib.c line 6578
static void lglcount(struct LGL *lgl)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int tag;
  signed int blit;
  signed int red;
  signed int other;
  signed int other2;
  signed int glue;
  signed int count;
  const signed int *p;
  const signed int *w;
  const signed int *c;
  const signed int *eow;
  struct HTS *hts;
  struct Stk *lir;
  lgl->stats->irr.clauses.cur = 0;
  lgl->stats->irr.lits.cur = 0;
  lgl->stats->red.bin = 0;
  lgl->stats->red.trn = 0;
  lgl->stats->red.lrg = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      hts=lglhts(lgl, lit);
      if(!(hts->offset == 0))
      {
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          red = blit & REDCS;
          tag = blit & MASKCS;
          if(tag == TRNCS || tag == LRGCS)
            p = p + 1l;

          if(!(tag == LRGCS))
          {
            other = blit >> RMSHFT;
            signed int return_value_abs_1;
            return_value_abs_1=abs(lit);
            signed int return_value_abs_2;
            return_value_abs_2=abs(other);
            if(!(return_value_abs_1 >= return_value_abs_2))
            {
              if(tag == TRNCS)
              {
                other2 = *p;
                signed int return_value_abs_3;
                return_value_abs_3=abs(lit);
                signed int return_value_abs_4;
                return_value_abs_4=abs(other2);
                if(return_value_abs_3 >= return_value_abs_4)
                  goto __CPROVER_DUMP_L12;

              }

              if(red == 0)
              {
                lgl->stats->irr.clauses.cur = lgl->stats->irr.clauses.cur + 1;
                if(tag == BINCS)
                  lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur + 2;

                else
                  lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur + 3;
              }

              else
                if(tag == BINCS)
                  lgl->stats->red.bin = lgl->stats->red.bin + 1;

                else
                  lgl->stats->red.trn = lgl->stats->red.trn + 1;
            }

          }


        __CPROVER_DUMP_L12:
          ;
        }
      }

    }
  }
  c = lgl->irr.start;
  for( ; !(c >= lgl->irr.top); c = p + (signed long int)1)
  {
    p = c;
    if(!(*p >= 0x7fffffff))
    {
      for( ; !(*p == 0); p = p + 1l)
        ;
      lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur + (signed int)(p - c);
      lgl->stats->irr.clauses.cur = lgl->stats->irr.clauses.cur + 1;
    }

  }

__CPROVER_DUMP_L20:
  ;
  glue = 0;
  for( ; !(glue >= 15); glue = glue + 1)
  {
    lir = lgl->red + (signed long int)glue;
    count = 0;
    c = lir->start;
    for( ; !(c >= lir->top); c = c + 1l)
      if(*c == 0)
        count = count + 1;

    if(!(count == 0))

      __CPROVER_DUMP_L25:
        ;

    lgl->stats->red.lrg = lgl->stats->red.lrg + count;
    lgl->stats->lir[(signed long int)glue].clauses = count;
  }
  if(!(lgl->stats->red.bin == 0))

    __CPROVER_DUMP_L28:
      ;

  if(!(lgl->stats->red.trn == 0))

    __CPROVER_DUMP_L30:
      ;

  if(!(lgl->stats->red.lrg == 0))

    __CPROVER_DUMP_L32:
      ;

}

// lglcpyopts
// file lglib.c line 18907
static void lglcpyopts(struct LGL *dst, const struct LGL *src)
{
  const struct Opt *s;
  struct Opt *d;
  s = &src->opts->beforefirst + (signed long int)1;
  d = &dst->opts->beforefirst + (signed long int)1;
  signed int tmp_statement_expression_1;
  signed int tmp_statement_expression_3;
  for( ; &src->opts->afterlast + -1l >= s; d = d + 1l)
  {
    unsigned long int lglcpyopts__1__1__1__1____s1_len;
    unsigned long int lglcpyopts__1__1__1__1____s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(s->lng, "clim");
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    if(!(tmp_statement_expression_1 == 0))
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_4;
      return_value___builtin_strcmp_4=__builtin_strcmp(s->lng, "dlim");
      tmp_statement_expression_3 = return_value___builtin_strcmp_4;
      if(!(tmp_statement_expression_3 == 0))
      {
        if(!(d->val == s->val))
          lglsetopt(dst, s->lng, s->val);

      }

    }

    s = s + 1l;
  }
}

// lglcpystk
// file lglib.c line 16551
static void lglcpystk(struct LGL *lgl, struct Stk *dst, struct Stk *src)
{
  const signed int *p = src->start;
  for( ; !(p >= src->top); p = p + 1l)
    lglpushstk(lgl, dst, *p);
}

// lglctrav
// file lglib.c line 18746
void lglctrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int))
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglctrav");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  signed int return_value_lglbcp_1;
  if(lgl->mt == 0)
  {
    return_value_lglbcp_1=lglbcp(lgl);
    if(return_value_lglbcp_1 == 0)
      lgl->mt = 1;

  }

  if(lgl->mt == 0)
    lglgc(lgl);

  signed int return_value_lglexport_6;
  if(!(lgl->mt == 0))
    trav(state, 0);

  else
  {
    if(lgl->level >= 1)
      lglbacktrack(lgl, 0);

    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      sign = -1;
      for( ; !(sign >= 2); sign = sign + 2)
      {
        lit = sign * idx;
        hts=lglhts(lgl, lit);
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          tag = blit & MASKCS;
          red = blit & REDCS;
          if(tag == TRNCS || tag == LRGCS)
            p = p + 1l;

          if(red == 0)
          {
            if(tag == BINCS || tag == TRNCS)
            {
              other = blit >> RMSHFT;
              signed int return_value_abs_2;
              return_value_abs_2=abs(other);
              if(return_value_abs_2 >= idx)
              {
                if(tag == TRNCS)
                {
                  other2 = *p;
                  signed int return_value_abs_3;
                  return_value_abs_3=abs(other2);
                  if(!(return_value_abs_3 >= idx))
                    goto __CPROVER_DUMP_L16;

                }

                else
                  other2 = 0;
                signed int return_value_lglexport_4;
                return_value_lglexport_4=lglexport(lgl, lit);
                trav(state, return_value_lglexport_4);
                signed int return_value_lglexport_5;
                return_value_lglexport_5=lglexport(lgl, other);
                trav(state, return_value_lglexport_5);
                if(!(other2 == 0))
                {
                  return_value_lglexport_6=lglexport(lgl, other2);
                  trav(state, return_value_lglexport_6);
                }

                trav(state, 0);
              }

            }

          }


        __CPROVER_DUMP_L16:
          ;
        }
      }
    }
    c = lgl->irr.start;
    for( ; !(c >= lgl->irr.top); c = p + (signed long int)1)
    {
      p = c;
      if(!(*p >= 134217727))
      {
        other = *p;
        if(!(other == 0))
        {
          signed int return_value_lglexport_7;
          return_value_lglexport_7=lglexport(lgl, other);
          trav(state, return_value_lglexport_7);
          p = p + 1l;
        }

        trav(state, 0);
      }

    }
  }
}

// lglcutwidth
// file lglib.c line 6877
static signed int lglcutwidth(struct LGL *lgl)
{
  signed int lidx;
  signed int res;
  signed int l4;
  signed int r4;
  signed int b4;
  signed int l10;
  signed int r10;
  signed int b10;
  signed int m;
  signed int oldbias;
  signed int idx;
  signed int sign;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  const signed int *q;
  signed int *widths;
  signed int max;
  signed int cut;
  signed int min4;
  signed int min10;
  signed long int sum;
  signed long int avg;
  struct HTS *hts;
  double return_value_lglpcnt_3;
  double return_value_lglpcnt_4;
  if(!(lgl->nvars >= 3))
    return 0;

  else
  {
    lglstart(lgl, &lgl->times->ctw);
    oldbias = lgl->bias;
    signed int return_value_abs_1;
    return_value_abs_1=abs(lgl->opts->bias.val);
    if(!(return_value_abs_1 >= 2))
      lgl->bias = lgl->opts->bias.val;

    else
    {
      min10 = 0x7fffffff;
      min4 = min10;
      cut = 0;
      max = cut;
      sum = (signed long int)max;
      do
      {
        void *return_value_lglnew_2;
        return_value_lglnew_2=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
        widths = (signed int *)return_value_lglnew_2;
      }
      while((_Bool)0);
      l4 = 2 + ((lgl->nvars - 2) + 3) / 4;
      r4 = 2 + (3 * (lgl->nvars - 2) + 3) / 4;
      l10 = 2 + ((lgl->nvars - 2) + 9) / 10;
      r10 = 2 + (9 * (lgl->nvars - 2) + 9) / 10;
      b10 = 0;
      b4 = b10;
      idx = 2;
      for( ; !(idx >= lgl->nvars); idx = idx + 1)
      {
        sign = -1;
        for( ; !(sign >= 2); sign = sign + 2)
        {
          lit = idx * sign;
          hts=lglhts(lgl, lit);
          w=lglhts2wchs(lgl, hts);
          eow = w + (signed long int)hts->count;
          p = w;
          for( ; !(p >= eow); p = p + 1l)
          {
            blit = *p;
            red = blit & REDCS;
            tag = blit & MASKCS;
            other=abs(blit >> RMSHFT);
            if(tag == BINCS)
            {
              if(!(red == 0))
                goto __CPROVER_DUMP_L14;

              if(!(idx >= other))
              {
                widths[(signed long int)other] = widths[(signed long int)other] + 1;
                cut = cut + 1;
              }

            }

            else
              if(tag == TRNCS)
              {
                p = p + 1l;
                other2=abs(*p);
                if(!(red == 0))
                  goto __CPROVER_DUMP_L14;

                if(!(idx >= other))
                {
                  widths[(signed long int)other] = widths[(signed long int)other] + 1;
                  cut = cut + 1;
                }

                if(!(idx >= other2))
                {
                  widths[(signed long int)other2] = widths[(signed long int)other2] + 1;
                  cut = cut + 1;
                }

              }

              else
              {
                p = p + 1l;
                lidx = *p;
                if(red == 0)
                {
                  c=lglidx2lits(lgl, LRGCS, 0, lidx);
                  q = c;
                  do
                  {
                    other=abs(*q);
                    if(other == 0)
                      break;

                    if(!(other == idx))
                    {
                      if(!(idx >= other))
                      {
                        widths[(signed long int)other] = widths[(signed long int)other] + 1;
                        cut = cut + 1;
                      }

                    }

                    q = q + 1l;
                  }
                  while((_Bool)1);
                }

              }

          __CPROVER_DUMP_L14:
            ;
          }
        }
        cut = cut - widths[(signed long int)idx];
        if(!(max >= cut))
          max = cut;

        if(idx >= l4 && r4 >= idx && !(cut >= min4))
        {
          b4 = idx;
          min4 = cut;
        }

        if(idx >= l10 && r10 >= idx && !(cut >= min10))
        {
          b10 = idx;
          min10 = cut;
        }

        sum = sum + (signed long int)cut;
      }
      do
      {
        lgldel(lgl, (void *)widths, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
        widths = ((signed int *)NULL);
      }
      while((_Bool)0);
      avg = sum / (signed long long int)lgl->nvars;
      res = (signed int)avg;
      return_value_lglpcnt_3=lglpcnt((double)(b4 - 2), (double)(lgl->nvars - 2));
      return_value_lglpcnt_4=lglpcnt((double)(b10 - 2), (double)(lgl->nvars - 2));
      lglprt(lgl, 1, "[cut-width] %d, max %d, min4 %d at %.0f%%, min10 %d at %.0f%%", res, max, min4, return_value_lglpcnt_3, min10, return_value_lglpcnt_4);
      m = (lgl->nvars + 2) / 2;
      if(!(b10 >= m) && !(b4 >= m))
        lgl->bias = -1;

      if(!(m >= b10) && !(m >= b4))
        lgl->bias = 1;

    }

  DONE:
    ;
    (void)0;
    lglprt(lgl, 1, "[decision-order] bias %d, old %d", lgl->bias, oldbias);
    lglstop(lgl);
    return res;
  }
}

// lglcval
// file lglib.c line 2961
static signed int lglcval(struct LGL *lgl, signed int litorval)
{
  if(litorval == 1 || litorval == -1)
    return litorval;

  else
  {
    signed char return_value_lglval_1;
    return_value_lglval_1=lglval(lgl, litorval);
    return (signed int)return_value_lglval_1;
  }
}

// lgldassume
// file lglib.c line 7730
static void lgldassume(struct LGL *lgl, signed int lit)
{

__CPROVER_DUMP_L1:
  ;
  lgl->stats->decisions = lgl->stats->decisions + 1l;
  lgl->stats->height = lgl->stats->height + (signed long int)lgl->level;
  lgliassume(lgl, lit);
}

// lgldcpcln
// file lglib.c line 8043
static void lgldcpcln(struct LGL *lgl)
{
  signed int glue;
  signed int old;
  signed int rounds = 0;
  struct Stk *lir;
  do
  {
    rounds = rounds + 1;
    old = lgl->stats->fixed.current;
    lgldcpclnstk(lgl, 0, &lgl->irr);
    lgldcpclnstk(lgl, 0, &lgl->dis->irr.bin);
    lgldcpclnstk(lgl, 0, &lgl->dis->irr.trn);
    lgldcpclnstk(lgl, REDCS, &lgl->dis->red.bin);
    lgldcpclnstk(lgl, REDCS, &lgl->dis->red.trn);
    glue = 0;
    for( ; !(glue >= 15); glue = glue + 1)
    {
      lir = lgl->red + (signed long int)glue;
      lgldcpclnstk(lgl, REDCS, lir);
    }
  }
  while(!(old >= lgl->stats->fixed.current));

__CPROVER_DUMP_L4:
  ;
}

// lgldcpclnstk
// file lglib.c line 7904
static void lgldcpclnstk(struct LGL *lgl, signed int red, struct Stk *s)
{
  signed int oldsz;
  signed int newsz;
  signed int lit;
  signed int mark;
  signed int satisfied;
  signed int repr;
  signed int act;
  const signed int *p;
  const signed int *c;
  const signed int *eos = s->top;
  signed int *lgldcpclnstk__1__start;
  signed int *q;
  signed int *r;
  signed int *d;
  struct Stk *t;
  signed char val;
  lgldcpclnstk__1__start = s->start;
  q = lgldcpclnstk__1__start;
  c = q;
  _Bool tmp_if_expr_1;
  signed int *tmp_post_2;
  const signed int *tmp_post_3;
  signed int *tmp_post_6;
  signed int *tmp_post_7;
  struct Stk *tmp_if_expr_8;
  signed int *tmp_post_9;
  struct Stk *tmp_if_expr_10;
  signed int *tmp_post_11;
  for( ; !(c >= eos); c = p + (signed long int)1)
  {
    act = *c;
    if(act == 0x7fffffff)
    {
      p = c + (signed long int)1;
      do
      {
        if(!(p >= eos))
          tmp_if_expr_1 = *p == 0x7fffffff ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(!tmp_if_expr_1)
          break;

        p = p + 1l;
      }
      while((_Bool)1);
      p = p - 1l;
    }

    else
    {
      signed int return_value_lglisact_4;
      return_value_lglisact_4=lglisact(act);
      if(!(return_value_lglisact_4 == 0))
      {
        tmp_post_2 = q;
        q = q + 1l;
        tmp_post_3 = c;
        c = c + 1l;
        *tmp_post_2 = *tmp_post_3;
      }

      else
        act = -1;
      d = q;
      satisfied = 0;
      p = c;
      do
      {
        lit = *p;
        if(lit == 0)
          break;

        if(satisfied == 0)
        {
          repr=lglirepr(lgl, lit);
          signed int return_value_lglcval_5;
          return_value_lglcval_5=lglcval(lgl, repr);
          val = (signed char)return_value_lglcval_5;
          if((signed int)val >= 1)
            satisfied = 1;

          else
            if((signed int)val >= 0)
            {
              mark=lglmarked(lgl, repr);
              if(!(mark >= 0))
                satisfied = 1;

              else
                if(!(mark >= 1))
                {
                  lglmark(lgl, repr);
                  tmp_post_6 = q;
                  q = q + 1l;
                  *tmp_post_6 = repr;
                }

            }

        }

        p = p + 1l;
      }
      while((_Bool)1);
      oldsz = (signed int)(p - c);
      r = d;
      for( ; !(r >= q); r = r + 1l)
        lglunmark(lgl, *r);
      if(oldsz == 0 || !(satisfied == 0))
        q = d - (signed long int)(act >= 0);

      else
      {
        newsz = (signed int)(q - d);
        if(newsz >= 4)
        {
          tmp_post_7 = q;
          q = q + 1l;
          *tmp_post_7 = 0;
        }

        else
          if(newsz == 0)
          {

          __CPROVER_DUMP_L20:
            ;
            lgl->mt = 1;
            q = d - (signed long int)(act >= 0);
          }

          else
            if(newsz == 1)
            {

            __CPROVER_DUMP_L22:
              ;
              lglunit(lgl, d[(signed long int)0]);
              q = d - (signed long int)(act >= 0);
            }

            else
              if(newsz == 2)
              {
                if(!(red == 0))
                  tmp_if_expr_8 = &lgl->dis->red.bin;

                else
                  tmp_if_expr_8 = &lgl->dis->irr.bin;
                t = tmp_if_expr_8;
                if(!(s == t))
                {
                  lglpushstk(lgl, t, d[(signed long int)0]);
                  lglpushstk(lgl, t, d[(signed long int)1]);
                  lglpushstk(lgl, t, 0);
                  q = d - (signed long int)(act >= 0);
                }

                else
                {
                  tmp_post_9 = q;
                  q = q + 1l;
                  *tmp_post_9 = 0;
                }
              }

              else
              {
                if(!(red == 0))
                  tmp_if_expr_10 = &lgl->dis->red.trn;

                else
                  tmp_if_expr_10 = &lgl->dis->irr.trn;
                t = tmp_if_expr_10;
                if(!(s == t))
                {
                  lglpushstk(lgl, t, d[(signed long int)0]);
                  lglpushstk(lgl, t, d[(signed long int)1]);
                  lglpushstk(lgl, t, d[(signed long int)2]);
                  lglpushstk(lgl, t, 0);
                  q = d - (signed long int)(act >= 0);
                }

                else
                {
                  tmp_post_11 = q;
                  q = q + 1l;
                  *tmp_post_11 = 0;
                }
              }
      }
    }
  }
  s->top = q;
}

// lgldcpcon
// file lglib.c line 8023
static void lgldcpcon(struct LGL *lgl)
{
  struct Stk *lir;
  signed int glue;
  lgldcpconnaux(lgl, 0, 0, &lgl->dis->irr.bin);
  lgldcpconnaux(lgl, REDCS, 0, &lgl->dis->red.bin);
  lgldcpconnaux(lgl, 0, 0, &lgl->dis->irr.trn);
  lgldcpconnaux(lgl, REDCS, 0, &lgl->dis->red.trn);
  lglrelstk(lgl, &lgl->dis->irr.bin);
  lglrelstk(lgl, &lgl->dis->irr.trn);
  lglrelstk(lgl, &lgl->dis->red.bin);
  lglrelstk(lgl, &lgl->dis->red.trn);
  do
  {
    lgldel(lgl, (void *)lgl->dis, (unsigned long int)1 * sizeof(struct Dis) /*96ul*/ );
    lgl->dis = ((struct Dis *)NULL);
  }
  while((_Bool)0);
  lgldcpconnaux(lgl, 0, 0, &lgl->irr);
  glue = 0;
  for( ; !(glue >= 15); glue = glue + 1)
  {
    lir = lgl->red + (signed long int)glue;
    lgldcpconnaux(lgl, REDCS, glue, lir);
  }
  lglfullyconnected(lgl);
}

// lgldcpconnaux
// file lglib.c line 7982
static void lgldcpconnaux(struct LGL *lgl, signed int red, signed int glue, struct Stk *s)
{
  signed int *lgldcpconnaux__1__start = s->start;
  signed int *q;
  signed int *d;
  signed int lit;
  signed int size;
  signed int lidx;
  signed int act;
  const signed int *p;
  const signed int *c;
  const signed int *eos = s->top;
  q = lgldcpconnaux__1__start;
  c = q;
  signed int *tmp_post_1;
  const signed int *tmp_post_2;
  signed int *tmp_post_4;
  signed int *tmp_post_5;
  for( ; !(c >= eos); c = p + (signed long int)1)
  {
    act = *c;
    signed int return_value_lglisact_3;
    return_value_lglisact_3=lglisact(act);
    if(!(return_value_lglisact_3 == 0))
    {
      tmp_post_1 = q;
      q = q + 1l;
      tmp_post_2 = c;
      c = c + 1l;
      *tmp_post_1 = *tmp_post_2;
    }

    else
      act = -1;
    d = q;
    p = c;
    do
    {
      lit = *p;
      if(lit == 0)
        break;

      tmp_post_4 = q;
      q = q + 1l;
      *tmp_post_4 = lit;
      p = p + 1l;
    }
    while((_Bool)1);
    size = (signed int)(q - d);
    if(size == 2)
    {
      q = d - (signed long int)(act >= 0);
      lglwchbin(lgl, d[(signed long int)0], d[(signed long int)1], red);
      lglwchbin(lgl, d[(signed long int)1], d[(signed long int)0], red);
    }

    else
      if(size == 3)
      {
        q = d - (signed long int)(act >= 0);
        lglwchtrn(lgl, d[(signed long int)0], d[(signed long int)1], d[(signed long int)2], red);
        lglwchtrn(lgl, d[(signed long int)1], d[(signed long int)0], d[(signed long int)2], red);
        lglwchtrn(lgl, d[(signed long int)2], d[(signed long int)0], d[(signed long int)1], red);
      }

      else
      {
        tmp_post_5 = q;
        q = q + 1l;
        *tmp_post_5 = 0;
        lidx = (signed int)(d - lgldcpconnaux__1__start);
        if(!(red == 0))
        {
          lidx = lidx << 4;
          lidx = lidx | glue;
        }

        lglwchlrg(lgl, d[(signed long int)0], d[(signed long int)1], red, lidx);
        lglwchlrg(lgl, d[(signed long int)1], d[(signed long int)0], red, lidx);
      }
  }
  s->top = q;
}

// lgldcpdis
// file lglib.c line 7852
static void lgldcpdis(struct LGL *lgl)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int tag;
  signed int blit;
  signed int red;
  signed int other;
  signed int other2;
  signed int i;
  const signed int *w;
  const signed int *p;
  const signed int *eow;
  signed char val;
  struct HTS *hts;
  struct Stk *s;
  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Dis) /*96ul*/ );
    lgl->dis = (struct Dis *)return_value_lglnew_1;
  }
  while((_Bool)0);
  idx = 2;
  signed int return_value_lglisfree_3;
  struct Stk *tmp_if_expr_4;
  signed int return_value_lglisfree_6;
  struct Stk *tmp_if_expr_7;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      hts=lglhts(lgl, lit);
      if(!(hts->offset == 0))
      {
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        hts->offset = 0;
        hts->count = hts->offset;
        val=lglval(lgl, lit);
        if(!((signed int)val >= 1))
        {
          p = w;
          for( ; !(p >= eow); p = p + 1l)
          {
            blit = *p;
            tag = blit & MASKCS;
            if(tag == TRNCS || tag == LRGCS)
              p = p + 1l;

            if(!(tag == LRGCS))
            {
              other = blit >> RMSHFT;
              signed int return_value_abs_2;
              return_value_abs_2=abs(other);
              if(return_value_abs_2 >= idx)
              {
                val=lglval(lgl, other);
                if(!((signed int)val >= 1))
                {
                  red = blit & REDCS;
                  if(!(red == 0))
                  {
                    return_value_lglisfree_3=lglisfree(lgl, other);
                    if(!(return_value_lglisfree_3 == 0))
                      goto __CPROVER_DUMP_L7;

                  }

                  else
                  {

                  __CPROVER_DUMP_L7:
                    ;
                    if(tag == BINCS)
                    {
                      if(!(red == 0))
                        tmp_if_expr_4 = &lgl->dis->red.bin;

                      else
                        tmp_if_expr_4 = &lgl->dis->irr.bin;
                      s = tmp_if_expr_4;
                    }

                    else
                    {
                      other2 = *p;
                      signed int return_value_abs_5;
                      return_value_abs_5=abs(other2);
                      if(!(return_value_abs_5 >= idx))
                        goto __CPROVER_DUMP_L17;

                      val=lglval(lgl, other2);
                      if((signed int)val >= 1)
                        goto __CPROVER_DUMP_L17;

                      if(!(red == 0))
                      {
                        return_value_lglisfree_6=lglisfree(lgl, other2);
                        if(return_value_lglisfree_6 == 0)
                          goto __CPROVER_DUMP_L17;

                      }

                      if(!(red == 0))
                        tmp_if_expr_7 = &lgl->dis->red.trn;

                      else
                        tmp_if_expr_7 = &lgl->dis->irr.trn;
                      s = tmp_if_expr_7;
                      lglpushstk(lgl, s, other2);
                    }
                    lglpushstk(lgl, s, other);
                    lglpushstk(lgl, s, lit);
                    lglpushstk(lgl, s, 0);
                  }
                }

              }

            }


          __CPROVER_DUMP_L17:
            ;
          }
        }

      }

    }
  }
  lglrststk(&lgl->wchs->stk, 2);
  lgl->wchs->stk.top[(signed long int)-1] = 0x7fffffff;
  i = 0;
  for( ; !(i >= 31); i = i + 1)
    lgl->wchs->start[(signed long int)i] = 0x7fffffff;
  lgl->wchs->free = 0;
}

// lgldec
// file lglib.c line 1253
static void lgldec(struct LGL *lgl, unsigned long int bytes)
{
  lgl->stats->bytes.current = lgl->stats->bytes.current - bytes;
}

// lgldec64
// file lglib.c line 16230
static unsigned long int lgldec64(unsigned long int i)
{
  unsigned long int res = i - (unsigned long int)1;
  signed int return_value_lglpar64_1;
  do
  {
    return_value_lglpar64_1=lglpar64(res);
    if(return_value_lglpar64_1 == 0)
      break;

    res = res - 1ul;
  }
  while((_Bool)1);
  return res;
}

// lgldecide
// file lglib.c line 7832
static signed int lgldecide(struct LGL *lgl)
{
  signed int lit;
  lglchkbcpclean(lgl, "decide");
  _Bool tmp_if_expr_1;
  if(lgl->unassigned == 0)
    return 0;

  else
  {
    lit=lgladecide(lgl);
    if(!(lit == 0))
    {

    __CPROVER_DUMP_L2:
      ;
      lgl->alevel = lgl->level + 1;
    }

    else
    {
      if(!(lgl->opts->randec.val == 0))
        tmp_if_expr_1 = lgl->limits->randec <= lgl->stats->decisions ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        lit=lglrandec(lgl);

      else
        lit=lglnextdecision(lgl);

    __CPROVER_DUMP_L7:
      ;
      lit=lgldecidephase(lgl, lit);
    }

  __CPROVER_DUMP_L3:
    ;
    if(!(lit == 0))
      lgldassume(lgl, lit);

    return 1;
  }
}

// lgldecidephase
// file lglib.c line 7758
static signed int lgldecidephase(struct LGL *lgl, signed int lit)
{
  signed int res;
  res=abs(lit);
  signed int flipped;
  struct AVar *av;
  av=lglavar(lgl, lit);
  _Bool tmp_if_expr_2;
  signed int return_value_lgldefphase_1;
  unsigned long int return_value_lglcntstk_4;
  _Bool tmp_if_expr_3;
  if(!(av->fase == 0))
    return (signed int)av->fase * res;

  else
  {
    if(!(lgl->phaseneg == 0))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_lgldefphase_1=lgldefphase(lgl, res);
      tmp_if_expr_2 = return_value_lgldefphase_1 <= 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      res = -res;

    if(lgl->flipping == 0)
    {
      if(lgl->phaseneg == 0)
      {
        if(!(lgl->opts->flipping.val == 0))
        {
          if(lgl->level >= lgl->alevel)
          {
            return_value_lglcntstk_4=lglcntstk(&lgl->assume);
            if((unsigned long int)lgl->assumed == return_value_lglcntstk_4)
            {
              if(lgl->opts->fliptop.val == 0)
                tmp_if_expr_3 = (_Bool)1;

              else
                tmp_if_expr_3 = lgl->level == lgl->alevel ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_3)
              {
                if(lgl->notflipped >= lgl->limits->flipint)
                {

                __CPROVER_DUMP_L7:
                  ;
                  lgl->stats->fliphases = lgl->stats->fliphases + 1l;
                  lglupdflipint(lgl);
                  lgl->flipping = lgl->opts->flipdur.val;
                  lgl->notflipped = 0;
                }

                else
                  lgl->notflipped = lgl->notflipped + 1;
              }

            }

          }

        }

      }

    }

    if(!(lgl->flipping == 0))
    {
      flipped = -res;

    __CPROVER_DUMP_L10:
      ;
      lgl->stats->flipped = lgl->stats->flipped + 1l;
      res = flipped;
    }

    return res;
  }
}

// lgldecirr
// file lglib.c line 3481
static void lgldecirr(struct LGL *lgl, signed int size)
{
  lgl->stats->irr.clauses.cur = lgl->stats->irr.clauses.cur - 1;
  lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur - size;
  lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;
}

// lgldecision
// file lglib.c line 4799
static signed int lgldecision(struct LGL *lgl, signed int lit)
{
  signed int *rsn;
  rsn=lglrsn(lgl, lit);
  signed int tag = rsn[(signed long int)0] & MASKCS;
  return (signed int)(tag == DECISION);
}

// lgldeclscnt
// file lglib.c line 4071
static void lgldeclscnt(struct LGL *lgl, signed int size, signed int red, signed int glue)
{
  if(red == 0)
    lgldecirr(lgl, size);

  else
    if(size == 2)
      lgl->stats->red.bin = lgl->stats->red.bin - 1;

    else
      if(size == 3)
        lgl->stats->red.trn = lgl->stats->red.trn - 1;

      else
      {
        lgl->stats->red.lrg = lgl->stats->red.lrg - 1;
        lgl->stats->lir[(signed long int)glue].clauses = lgl->stats->lir[(signed long int)glue].clauses - 1;
      }
}

// lgldecocc
// file lglib.c line 5650
static void lgldecocc(struct LGL *lgl, signed int lit)
{
  signed int idx;
  signed int sign;
  signed int change;
  struct EVar *ev;
  _Bool tmp_if_expr_1;
  if(!(lgl->cgrclosing == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = lgl->probing != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = lgl->gaussing != 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_2)
  {
    idx=abs(lit);
    sign = (signed int)(lit < 0);
    ev=lglevar(lgl, lit);
    ev->occ[(signed long int)sign] = ev->occ[(signed long int)sign] - 1;
    signed int return_value_lglisfree_3;
    return_value_lglisfree_3=lglisfree(lgl, lit);
    if(!(return_value_lglisfree_3 == 0))
    {
      change=lglecalc(lgl, ev);

    __CPROVER_DUMP_L7:
      ;
      if(!(ev->pos >= 0))
        lglesched(lgl, idx);

      else
        if(!(change >= 0))
          lgleup(lgl, idx);

        else
          if(change >= 1)
            lgledown(lgl, idx);

    }

  }

}

// lgldecomp
// file lglib.c line 12274
static signed int lgldecomp(struct LGL *lgl)
{
  signed int res = 1;
  signed int oldnvars = lgl->nvars;
  signed int success;
  lglstart(lgl, &lgl->times->dcp);
  lgl->stats->decomps = lgl->stats->decomps + 1;
  lgl->decomposing = (char)1;
  lgl->simp = lgl->simp + 1;
  if(lgl->level >= 1)
    lglbacktrack(lgl, 0);

  res = 0;
  lglgc(lgl);
  signed int return_value_lglsyncunits_1;
  return_value_lglsyncunits_1=lglsyncunits(lgl);
  signed int return_value_lglbcp_2;
  signed int return_value_lgltarjan_3;
  signed int return_value_lglsynceqs_4;
  signed int return_value_lglbcp_5;
  if(!(return_value_lglsyncunits_1 == 0))
  {
    return_value_lglbcp_2=lglbcp(lgl);
    if(!(return_value_lglbcp_2 == 0))
    {
      lglgc(lgl);
      if(lgl->mt == 0)
      {
        return_value_lgltarjan_3=lgltarjan(lgl);
        if(!(return_value_lgltarjan_3 == 0))
        {
          return_value_lglsynceqs_4=lglsynceqs(lgl);
          if(!(return_value_lglsynceqs_4 == 0))
          {
            lglchkred(lgl);
            lgldcpdis(lgl);
            lgldcpcln(lgl);
            lgldcpcon(lgl);
            lglcompact(lgl);
            lglmap(lgl);
            if(lgl->mt == 0)
            {
              return_value_lglbcp_5=lglbcp(lgl);
              if(return_value_lglbcp_5 == 0)
              {
                if(lgl->mt == 0)
                  lgl->mt = 1;

              }

              else
              {
                lglcount(lgl);
                lglgc(lgl);
                if(lgl->mt == 0)
                {
                  if(lgl->mt == 0)
                  {
                    lglpicosatchkall(lgl);
                    lglpicosatrestart(lgl);
                  }

                  res = 1;
                }

              }
            }

          }

        }

      }

    }

  }


DONE:
  ;
  if(!(lgl->repr == ((signed int *)NULL)))
    do
    {
      lgldel(lgl, (void *)lgl->repr, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
      lgl->repr = ((signed int *)NULL);
    }
    while((_Bool)0);

  lgl->decomposing = (char)0;

__CPROVER_DUMP_L8:
  ;
  lgl->simp = lgl->simp - 1;
  success = (signed int)(lgl->nvars < oldnvars);
  _Bool tmp_if_expr_6;
  if(success == 0)
    tmp_if_expr_6 = (_Bool)1;

  else
    tmp_if_expr_6 = lgl->probing != 0 ? (_Bool)1 : (_Bool)0;
  lglrep(lgl, 1 + (signed int)tmp_if_expr_6, (char)100);
  lglstop(lgl);
  return res;
}

// lgldecomposing
// file lglib.c line 16953
static signed int lgldecomposing(struct LGL *lgl)
{
  return lgl->opts->decompose.val;
}

// lgldefphase
// file lglib.c line 7738
static signed int lgldefphase(struct LGL *lgl, signed int idx)
{
  struct AVar *av;
  signed int bias;
  av=lglavar(lgl, idx);
  if(av->phase == 0)
  {
    bias = lgl->opts->phase.val;
    if(bias == 0)
      bias = (signed int)av->bias;

    if(bias == 0)
      bias=lglsetjwhbias(lgl, idx);

    av->phase = bias;
  }

  return (signed int)av->phase;
}

// lgldefrag
// file lglib.c line 6362
static void lgldefrag(struct LGL *lgl)
{
  signed int *wchs;
  signed int nwchs;
  signed int i;
  signed int idx;
  signed int bit;
  signed int ldsize;
  signed int size;
  signed int offset;
  signed int *lgldefrag__1__start;
  signed int *q;
  signed int *end;
  const signed int *p;
  const signed int *eow;
  const signed int *w;
  struct HTS *hts;
  struct Qln *line;
  signed int *tmp_post_4;
  signed int *tmp_post_5;
  struct Qnd *return_value_lglqnd_3;
  signed int *tmp_post_6;
  if(!(lgl->qscheduling == 0))
  {
    lglstart(lgl, &lgl->times->dfg);
    lgl->stats->defrags = lgl->stats->defrags + 1;
    unsigned long int return_value_lglcntstk_1;
    return_value_lglcntstk_1=lglcntstk(&lgl->wchs->stk);
    nwchs = (signed int)return_value_lglcntstk_1;
    do
    {
      void *return_value_lglnew_2;
      return_value_lglnew_2=lglnew(lgl, (unsigned long int)nwchs * sizeof(signed int) /*4ul*/ );
      wchs = (signed int *)return_value_lglnew_2;
    }
    while((_Bool)0);
    memcpy((void *)wchs, (const void *)lgl->wchs->stk.start, (unsigned long int)nwchs * sizeof(signed int) /*4ul*/ );
    i = 0;
    for( ; !(i >= 31); i = i + 1)
      lgl->wchs->start[(signed long int)i] = 0x7fffffff;
    lgl->wchs->free = 0;
    lgldefrag__1__start = lgl->wchs->stk.start;
    offset = 1;
    line = lgl->queue.bottom;
    for( ; !(line == ((struct Qln *)NULL)); line = line->up)
    {
      idx = line->last;
      for( ; !(idx == 0); idx = return_value_lglqnd_3->prev)
      {
        bit = 0;
        for( ; !(bit >= 2); bit = bit + 1)
        {
          hts = (lgl->dvars + (signed long int)idx)->hts + (signed long int)bit;
          if(!(hts->offset == 0))
          {
            ldsize=lglceilld(hts->count);
            size = 1 << ldsize;
            w = wchs + (signed long int)hts->offset;
            hts->offset = offset;
            eow = w + (signed long int)hts->count;
            q = lgldefrag__1__start + (signed long int)offset;
            p = w;
            for( ; !(p >= eow); p = p + 1l)
            {
              tmp_post_4 = q;
              q = q + 1l;
              *tmp_post_4 = *p;
            }
            offset = offset + size;
            end = lgldefrag__1__start + (signed long int)offset;
            for( ; !(q >= end); *tmp_post_5 = 0)
            {
              tmp_post_5 = q;
              q = q + 1l;
            }
          }

        }
        return_value_lglqnd_3=lglqnd(lgl, idx);
      }
    }
    do
    {
      lgldel(lgl, (void *)wchs, (unsigned long int)nwchs * sizeof(signed int) /*4ul*/ );
      wchs = ((signed int *)NULL);
    }
    while((_Bool)0);
    q = lgldefrag__1__start + (signed long int)offset;
    tmp_post_6 = q;
    q = q + 1l;
    *tmp_post_6 = 0x7fffffff;
    lgl->wchs->stk.top = q;
    lglfitstk(lgl, &lgl->wchs->stk);
    lgl->limits->dfg.pshwchs = lgl->stats->pshwchs + (signed long int)lgl->opts->defragint.val;
    lgl->limits->dfg.prgss = lgl->stats->prgss;
    lglrep(lgl, 2, (char)70);
    lglstop(lgl);
  }

}

// lgldefragmenting
// file lglib.c line 16988
static signed int lgldefragmenting(struct LGL *lgl)
{
  signed int relfree;
  if(!(lgl->stats->pshwchs >= lgl->limits->dfg.pshwchs))
    return 0;

  else
    if(lgl->nvars == 0)
      return 0;

    else
    {
      relfree = (100 * lgl->wchs->free + 99) / lgl->nvars;
      return (signed int)(relfree >= lgl->opts->defragfree.val);
    }
}

// lgldel
// file lglib.c line 1271
static void lgldel(struct LGL *lgl, void *ptr, unsigned long int bytes)
{
  if(!(ptr == NULL))
  {
    lgldec(lgl, bytes);

  __CPROVER_DUMP_L2:
    ;
    if(!(lgl->mem->dealloc == ((void (*)(void *, void *, unsigned long int))NULL)))
      lgl->mem->dealloc(lgl->mem->state, ptr, bytes);

    else
      free(ptr);
  }

}

// lgldelstr
// file lglib.c line 1306
static void lgldelstr(struct LGL *lgl, char *str)
{
  do
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(str);
    lgldel(lgl, (void *)str, (return_value_strlen_1 + (unsigned long int)1) * sizeof(char) /*1ul*/ );
    str = ((char *)NULL);
  }
  while((_Bool)0);
}

// lgldense
// file lglib.c line 9121
static void lgldense(struct LGL *lgl, signed int occstoo)
{
  signed int lit;
  signed int lidx;
  signed int count;
  signed int idx;
  signed int other;
  signed int other2;
  signed int blit;
  signed int sign;
  signed int tag;
  signed int red;
  const signed int *lgldense__1__start;
  const signed int *top;
  const signed int *c;
  const signed int *p;
  const signed int *eow;
  signed int *q;
  signed int *w;
  struct EVar *ev;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  lgl->stats->dense = lgl->stats->dense + 1l;
  count = 0;
  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(struct EVar) /*16ul*/ );
    lgl->evars = (struct EVar *)return_value_lglnew_1;
  }
  while((_Bool)0);
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    ev = lgl->evars + (signed long int)idx;
    ev->pos = -1;
  }
  idx = 2;
  signed int *tmp_post_2;
  signed int *tmp_post_3;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      hts=lglhts(lgl, lit);
      if(!(hts->count == 0))
      {
        w=lglhts2wchs(lgl, hts);
        q = w;
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          tag = blit & MASKCS;
          if(tag == TRNCS || tag == LRGCS)
            p = p + 1l;

          red = blit & REDCS;
          if(!(tag == LRGCS) || red == 0)
          {
            tmp_post_2 = q;
            q = q + 1l;
            *tmp_post_2 = blit;
            if(tag == TRNCS || tag == LRGCS)
            {
              tmp_post_3 = q;
              q = q + 1l;
              *tmp_post_3 = *p;
            }

            if(red == 0)
            {
              if(tag == BINCS || tag == TRNCS)
              {
                other = blit >> RMSHFT;
                signed int return_value_abs_4;
                return_value_abs_4=abs(other);
                if(return_value_abs_4 >= idx)
                {
                  if(tag == TRNCS)
                  {
                    other2 = *p;
                    signed int return_value_abs_5;
                    return_value_abs_5=abs(other2);
                    if(!(return_value_abs_5 >= idx))
                      goto __CPROVER_DUMP_L12;

                    lglincocc(lgl, other2);
                    count = count + 1;
                  }

                  lglincocc(lgl, lit);
                  count = count + 1;
                  lglincocc(lgl, other);
                  count = count + 1;
                }

              }

            }

          }


        __CPROVER_DUMP_L12:
          ;
        }
        lglshrinkhts(lgl, hts, (signed int)(q - w));
      }

    }
  }
  if(!(count == 0))

    __CPROVER_DUMP_L17:
      ;

  if(!(occstoo == 0))
  {
    count = 0;
    lgldense__1__start = lgl->irr.start;
    top = lgl->irr.top;
    c = lgldense__1__start;
    for( ; !(c >= top); c = p + (signed long int)1)
    {
      p = c;
      if(!(*c >= 134217727))
      {
        lidx = (signed int)(c - lgldense__1__start);
        blit = lidx << RMSHFT | OCCS;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          hts=lglhts(lgl, lit);
          lglpushwch(lgl, hts, blit);
          lglincocc(lgl, lit);
          count = count + 1;
          p = p + 1l;
        }
        while((_Bool)1);
      }

    }
  }

  if(!(count == 0))

    __CPROVER_DUMP_L23:
      ;

  count = 0;
  if(lgl->cgrclosing == 0)
  {
    if(lgl->probing == 0)
    {
      if(lgl->gaussing == 0)
      {
        if(lgl->cceing == 0)
        {
          idx = 2;
          for( ; !(idx >= lgl->nvars); idx = idx + 1)
          {
            ev=lglevar(lgl, idx);
            if(!(ev->pos >= 0))
            {
              signed int return_value_lglifrozen_6;
              return_value_lglifrozen_6=lglifrozen(lgl, idx);
              if(return_value_lglifrozen_6 == 0)
              {
                if(!(lgl->donotsched == 0))
                {
                  struct AVar *av;
                  av=lglavar(lgl, idx);
                  if(!(lgl->eliminating == 0))
                  {
                    if(!(av->donotelm == 0u))
                      goto __CPROVER_DUMP_L30;

                  }

                  if(!(lgl->blocking == 0))
                  {
                    if(!(av->donotblk == 0u))
                      goto __CPROVER_DUMP_L30;

                  }

                  if(!(lgl->cceing == 0))
                  {
                    if(!(av->donotcce == 0u))
                      goto __CPROVER_DUMP_L30;

                  }

                }

                lglesched(lgl, idx);
                count = count + 1;
              }

            }


          __CPROVER_DUMP_L30:
            ;
          }
          if(!(count == 0))

            __CPROVER_DUMP_L32:
              ;

        }

      }

    }

  }


__CPROVER_DUMP_L33:
  ;
  lgl->dense = (char)(1 + occstoo);
  lglfullyconnected(lgl);
  struct EVar *return_value_lglevar_7;
  if(lgl->opts->verbose.val >= 1)
  {
    const char *str;
    signed int inst;
    signed int vl;
    count = 0;
    if(!(lgl->eliminating == 0))
    {
      str = "elim";
      inst = lgl->stats->elm.count;
      vl = 1;
    }

    else
      if(!(lgl->blocking == 0))
      {
        str = "block";
        inst = lgl->stats->blk.count;
        vl = 1;
      }

      else
      {
        str = "dense";
        inst = (signed int)lgl->stats->dense;
        vl = 2;
      }
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      return_value_lglevar_7=lglevar(lgl, idx);
      if(return_value_lglevar_7->pos >= 0)
        count = count + 1;

    }
    double return_value_lglpcnt_8;
    return_value_lglpcnt_8=lglpcnt((double)count, (double)(lgl->nvars - 2));
    lglprt(lgl, vl, "[%s-%d] scheduled %d variables %.0f%%", str, inst, count, return_value_lglpcnt_8);
  }

}

// lgldeprioritize
// file lglib.c line 5862
static void lgldeprioritize(struct LGL *lgl)
{
  signed int old_prior;
  signed int new_prior;
  signed int first;
  signed int last;
  struct Qln *p;
  struct Qln *down;
  struct Qln *up;
  signed long int new_prior64;
  lgl->stats->queue.deprior.count = lgl->stats->queue.deprior.count + 1;
  p = lgl->queue.bottom;
  for( ; !(p == ((struct Qln *)NULL)); p = p->up)
  {
    old_prior = p->prior;
    lgl->stats->queue.deprior.sum = lgl->stats->queue.deprior.sum + 1l;
    if(!(old_prior == 0))
    {
      new_prior64 = (signed long int)old_prior;
      new_prior64 = new_prior64 * (signed long int)lgl->opts->queuefactor.val;
      new_prior64 = new_prior64 + (signed long int)999;
      new_prior64 = new_prior64 / (signed long int)1000;
      new_prior = (signed int)new_prior64;
      if(!(new_prior == old_prior))
      {

      __CPROVER_DUMP_L2:
        ;
        p->prior = new_prior;
      }

    }

  }
  p = lgl->queue.bottom;
  for( ; !(p == ((struct Qln *)NULL)); p = up)
  {
    up = p->up;
    down = p->down;
    if(!(down == ((struct Qln *)NULL)))
    {
      if(down->prior >= p->prior)
      {

      __CPROVER_DUMP_L6:
        ;
        down->up = up;
        if(!(up == ((struct Qln *)NULL)))
          up->down = down;

        else
          lgl->queue.top = down;
        first = down->first;
        down->first = p->first;
        if(!(p->unassigned == 0))
          down->unassigned = p->unassigned;

        if(lgl->queue.unassigned == p)
          lgl->queue.unassigned = down;

        last = p->last;
        p->last = 0;
        p->first = p->last;
        struct Qnd *return_value_lglqnd_1;
        return_value_lglqnd_1=lglqnd(lgl, first);
        return_value_lglqnd_1->prev = last;
        struct Qnd *return_value_lglqnd_2;
        return_value_lglqnd_2=lglqnd(lgl, last);
        return_value_lglqnd_2->next = first;
        p->repr = down;
        p->down = ((struct Qln *)NULL);
        p->up = lgl->queue.merged;
        lgl->queue.merged = p;
        lgl->queue.nmerged = lgl->queue.nmerged + 1;
        lgl->stats->queue.merged = lgl->stats->queue.merged + 1l;
        if(lgl->queue.nmerged >= lgl->opts->queuemergelim.val)
          lglflushqmerged(lgl);

      }

    }

  }
  lglchkqueue(lgl);
  if(lgl->opts->log.val >= 5)
    lglqdump(lgl);

}

// lglderef
// file lglib.h line 192
signed int lglderef(struct LGL *lgl, signed int elit)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglderef");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "deref %d", elit);
    break;
  }
  lgl->stats->calls.deref = lgl->stats->calls.deref + 1l;
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglderef");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not deref zero literal");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }

__CPROVER_DUMP_L8:
  ;
  do
  {
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglderef");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

    while((96 & (signed int)lgl->state) == 0)
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglderef");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "!(%s)", (const void *)"SATISFIED | EXTENDED");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
  }
  while((_Bool)0);
  if((EXTENDED & (signed int)lgl->state) == 0)
    lglextend(lgl);

  res=lglederef(lgl, elit);

__CPROVER_DUMP_L15:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglderef(lgl->clone, elit);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglderef");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d", (const void *)"lglderef", elit, CLONERES, (const void *)"lglderef", elit, res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lgldie
// file lglib.c line 1160
static void lgldie(struct LGL *lgl, const char *msg, ...)
{
  void **ap;
  fprintf(lgl->out, "*** internal error in '%s': ", (const void *)"lglib.c");
  ap = (void **)&msg;
  vfprintf(lgl->out, msg, ap);
  ap = ((void **)NULL);
  fputc(10, lgl->out);
  fflush(lgl->out);
  exit(0);
}

// lgldis
// file lglib.c line 6408
static void lgldis(struct LGL *lgl)
{
  signed int blit;
  signed int nblit;
  signed int tag;
  signed int red;
  signed int *p;
  signed int *q;
  signed int *eow;
  signed int *w;
  signed int idx;
  signed int sign;
  signed int lit;
  signed int other;
  signed int other2;
  struct Stk bins;
  struct Stk trns;
  signed char val;
  signed char val2;
  struct HTS *hts;
  do
    memset((void *)&bins, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  do
    memset((void *)&trns, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  idx = 2;
  _Bool tmp_if_expr_2;
  signed int return_value_lgliselim_1;
  signed int *tmp_post_5;
  signed int *tmp_post_6;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = idx * sign;
      hts=lglhts(lgl, lit);
      if(!(hts->offset == 0))
      {
        val=lglval(lgl, lit);
        if(!(val == 0))
          tmp_if_expr_2 = (_Bool)1;

        else
        {
          return_value_lgliselim_1=lgliselim(lgl, lit);
          tmp_if_expr_2 = return_value_lgliselim_1 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_2)
          lglshrinkhts(lgl, hts, 0);

        else
        {
          w=lglhts2wchs(lgl, hts);
          eow = w + (signed long int)hts->count;
          p = w;
          for( ; !(p >= eow); p = p + 1l)
          {
            blit = *p;
            tag = blit & MASKCS;
            red = blit & REDCS;
            if(!(tag == OCCS))
            {
              if(tag == TRNCS || tag == LRGCS)
                p = p + 1l;

              if(!(tag == LRGCS))
              {
                other = blit >> RMSHFT;
                val=lglval(lgl, other);
                if(!((signed int)val >= 1))
                {
                  signed int return_value_lgliselim_3;
                  return_value_lgliselim_3=lgliselim(lgl, other);
                  if(return_value_lgliselim_3 == 0)
                  {
                    if(tag == BINCS)
                      lglpushstk(lgl, &bins, blit);

                    else
                    {
                      other2 = *p;
                      val2=lglval(lgl, other2);
                      if(!((signed int)val2 >= 1))
                      {
                        signed int return_value_lgliselim_4;
                        return_value_lgliselim_4=lgliselim(lgl, other2);
                        if(return_value_lgliselim_4 == 0)
                        {
                          if(!((signed int)val >= 0))
                          {
                            nblit = red | other2 << RMSHFT | BINCS;
                            lglpushstk(lgl, &bins, nblit);
                          }

                          else
                            if(!((signed int)val2 >= 0))
                            {
                              nblit = red | other << RMSHFT | BINCS;
                              lglpushstk(lgl, &bins, nblit);
                            }

                            else
                            {
                              lglpushstk(lgl, &trns, blit);
                              lglpushstk(lgl, &trns, other2);
                            }
                        }

                      }

                    }
                  }

                }

              }

            }

          }
          q = w;
          p = bins.start;
          for( ; !(p == bins.top); p = p + 1l)
          {
            tmp_post_5 = q;
            q = q + 1l;
            *tmp_post_5 = *p;
          }
          p = trns.start;
          for( ; !(p == trns.top); p = p + 1l)
          {
            tmp_post_6 = q;
            q = q + 1l;
            *tmp_post_6 = *p;
          }
          lglshrinkhts(lgl, hts, (signed int)(q - w));
          lglclnstk(&bins);
          lglclnstk(&trns);
        }
      }

    }
  }
  lglrelstk(lgl, &bins);
  lglrelstk(lgl, &trns);
}

// lgldstpull
// file lglib.c line 14382
static signed int lgldstpull(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  if(!(av->mark == 0))
    return 0;

  else
  {
    signed int return_value_lglevel_1;
    return_value_lglevel_1=lglevel(lgl, lit);
    if(return_value_lglevel_1 == 0)
      return 0;

    else
    {
      av->mark = 1;
      signed int return_value_lgldecision_2;
      return_value_lgldecision_2=lgldecision(lgl, lit);
      if(!(return_value_lgldecision_2 == 0))
        lglpushstk(lgl, &lgl->clause, lit);

      else
        lglpushstk(lgl, &lgl->seen, -lit);

    __CPROVER_DUMP_L3:
      ;

    __CPROVER_DUMP_L5:
      ;
      return 1;
    }
  }
}

// lgldvar
// file lglib.c line 2313
static struct DVar * lgldvar(struct LGL *lgl, signed int lit)
{
  signed int return_value_abs_1;
  return_value_abs_1=abs(lit);
  return lgl->dvars + (signed long int)return_value_abs_1;
}

// lgldynstr
// file lglib.c line 5725
static void lgldynstr(struct LGL *lgl, signed int del, signed int lit, signed int r0, signed int r1)
{
  signed int *p;
  signed int *c;
  signed int lidx;
  signed int other;
  signed int red;
  signed int tag;
  signed int glue;
  signed int other2;
  signed int other3;
  signed int blit;
  tag = r0 & MASKCS;

__CPROVER_DUMP_L1:
  ;
  red = r0 & REDCS;
  if(!(red == 0))
    lgl->stats->otfs.str.dyn.red = lgl->stats->otfs.str.dyn.red + 1;

  else
    lgl->stats->otfs.str.dyn.irr = lgl->stats->otfs.str.dyn.irr + 1;
  lgl->stats->prgss = lgl->stats->prgss + 1l;
  if(red == 0)
    lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;

  if(tag == BINCS)
  {
    other = del == lit ? r0 >> RMSHFT : lit;
    lglrmbcls(lgl, del, other, red);
    lglunflict(lgl, other);
  }

  else
  {
    if(tag == TRNCS)
    {
      if(lit == del)
      {
        other = r0 >> RMSHFT;
        other2 = r1;
      }

      else
        if(del == r1)
        {
          other = lit;
          other2 = r0 >> RMSHFT;
        }

        else
        {
          other = lit;
          other2 = r1;
        }
      lglrmtcls(lgl, del, other, other2, red);
      if(red == 0)
        lglincirr(lgl, 2);

      else
        lgl->stats->red.bin = lgl->stats->red.bin + 1;
      lglwchbin(lgl, other, other2, red);
      lglwchbin(lgl, other2, other, red);
      signed int return_value_lglevel_1;
      return_value_lglevel_1=lglevel(lgl, other);
      signed int return_value_lglevel_2;
      return_value_lglevel_2=lglevel(lgl, other2);
      if(!(return_value_lglevel_1 >= return_value_lglevel_2))
        do
        {
          signed int TMP = other;
          other = other2;
          other2 = TMP;
        }
        while((_Bool)0);

      blit = other2 << RMSHFT | BINCS | red;
      lglbonflict(lgl, other, blit);
      goto __CPROVER_DUMP_L31;
    }

    lidx = r1;
    glue = red != 0 ? lidx & (1 << 4) - 1 : 0;
    c=lglidx2lits(lgl, LRGCS, red, lidx);
    p = c;
    for( ; !(*p == del); p = p + 1l)
      ;
    if(!(glue >= 15))
    {
      lglrmlwch(lgl, c[(signed long int)0], red, lidx);
      lglrmlwch(lgl, c[(signed long int)1], red, lidx);
    }

    do
    {
      p = p + 1l;
      other = *p;
      if(other == 0)
        break;

      p[(signed long int)-1] = other;
    }
    while((_Bool)1);
    p[(signed long int)-1] = 0;
    *p = 0x7fffffff;
    if(red == 0)
      lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur - 1;

    lglorderclsaux(lgl, c + (signed long int)0);
    lglorderclsaux(lgl, c + (signed long int)1);
    if(p - c == 4l)
    {
      other = c[(signed long int)0];
      other2 = c[(signed long int)1];
      other3 = c[(signed long int)2];
      if(!(red == 0) && !(glue >= 15))
      {

      __CPROVER_DUMP_L19:
        ;
        c[(signed long int)-1] = 0x7fffffff;
      }

      c[(signed long int)3] = 0x7fffffff;
      c[(signed long int)2] = c[(signed long int)3];
      c[(signed long int)1] = c[(signed long int)2];
      c[(signed long int)0] = c[(signed long int)1];
      signed int return_value_lglevel_3;
      return_value_lglevel_3=lglevel(lgl, other2);
      signed int return_value_lglevel_4;
      return_value_lglevel_4=lglevel(lgl, other3);
      if(!(return_value_lglevel_3 >= return_value_lglevel_4))
        do
        {
          signed int lgldynstr__1__6__2__TMP = other2;
          other2 = other3;
          other3 = lgldynstr__1__6__2__TMP;
        }
        while((_Bool)0);

      signed int return_value_lglevel_5;
      return_value_lglevel_5=lglevel(lgl, other);
      signed int return_value_lglevel_6;
      return_value_lglevel_6=lglevel(lgl, other2);
      if(!(return_value_lglevel_5 >= return_value_lglevel_6))
        do
        {
          signed int lgldynstr__1__6__3__TMP = other;
          other = other2;
          other2 = lgldynstr__1__6__3__TMP;
        }
        while((_Bool)0);

      lglwchtrn(lgl, other, other2, other3, red);
      lglwchtrn(lgl, other2, other, other3, red);
      lglwchtrn(lgl, other3, other, other2, red);
      if(!(red == 0))
      {
        lgl->stats->red.lrg = lgl->stats->red.lrg - 1;
        lgl->stats->lir[(signed long int)glue].clauses = lgl->stats->lir[(signed long int)glue].clauses - 1;
        lgl->stats->red.trn = lgl->stats->red.trn + 1;
      }

      lgltonflict(lgl, other, other2 << RMSHFT | red | TRNCS, other3);
    }

    else
    {
      if(!(glue >= 15))
      {

      __CPROVER_DUMP_L27:
        ;
        lglwchlrg(lgl, c[(signed long int)0], c[(signed long int)1], red, lidx);

      __CPROVER_DUMP_L28:
        ;
        lglwchlrg(lgl, c[(signed long int)1], c[(signed long int)0], red, lidx);
      }

      lglonflict(lgl, 0, c[(signed long int)0], red, lidx);
    }
  }

__CPROVER_DUMP_L31:
  ;
}

// lgldynsub
// file lglib.c line 5707
static void lgldynsub(struct LGL *lgl, signed int lit, signed int r0, signed int r1)
{
  signed int red;
  signed int tag = r0 & MASKCS;

__CPROVER_DUMP_L1:
  ;
  red = r0 & REDCS;
  if(!(red == 0))
    lgl->stats->otfs.sub.dyn.red = lgl->stats->otfs.sub.dyn.red + 1;

  else
    lgl->stats->otfs.sub.dyn.irr = lgl->stats->otfs.sub.dyn.irr + 1;
  if(tag == BINCS)
    lglrmbcls(lgl, lit, r0 >> RMSHFT, red);

  else
    if(tag == TRNCS)
      lglrmtcls(lgl, lit, r0 >> RMSHFT, r1, red);

    else
      lglrmlcls(lgl, r1, red);
}

// lgleadd
// file lglib.c line 3850
static void lgleadd(struct LGL *lgl, signed int elit)
{
  signed int ilit;
  lglreset(lgl);
  if(!(elit == 0))
    ilit=lglimport(lgl, elit);

  else
    ilit = 0;

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L3:
  ;
  lglfadd(lgl, elit);
  lgliadd(lgl, ilit);
}

// lgleassign
// file lglib.c line 17364
static void lgleassign(struct LGL *lgl, signed int lit)
{
  struct Ext *ext;
  ext=lglelit2ext(lgl, lit);

__CPROVER_DUMP_L1:
  ;
  ext->val=lglsgn(lit);
}

// lgleassume
// file lglib.c line 3916
static void lgleassume(struct LGL *lgl, signed int elit)
{
  signed int ilit;
  signed int val;
  unsigned int bit;
  struct AVar *av;
  struct Ext *ext;
  lglreset(lgl);
  ilit=lglimport(lgl, elit);

__CPROVER_DUMP_L1:
  ;
  bit = 1u << (signed int)(elit < 0);
  ext=lglelit2ext(lgl, elit);
  if((bit & (unsigned int)ext->assumed) == 0u)
  {
    ext->assumed = (unsigned int)ext->assumed | bit;
    lglpushstk(lgl, &lgl->eassume, elit);
  }

  val=lglcval(lgl, ilit);
  if(val == 0)
  {
    av=lglavar(lgl, ilit);
    bit = 1u << (signed int)(ilit < 0);
    if(!((bit & (unsigned int)av->assumed) == 0u))

      __CPROVER_DUMP_L3:
        ;

    else
    {
      av->assumed = (unsigned int)av->assumed | bit;
      if(!(((3u ^ bit) & (unsigned int)av->assumed) == 0u))

        __CPROVER_DUMP_L5:
          ;

      lglpushstk(lgl, &lgl->assume, ilit);
    }
  }

  else
    if(val >= 1)

      __CPROVER_DUMP_L9:
        ;

    else
    {

    __CPROVER_DUMP_L10:
      ;
      if(!(ilit == -1))
      {
        av=lglavar(lgl, ilit);
        bit = 1u << (signed int)(ilit < 0);
        if((bit & (unsigned int)av->assumed) == 0u)
        {
          av->assumed = (unsigned int)av->assumed | bit;
          lglpushstk(lgl, &lgl->assume, ilit);
        }

      }

      if(lgl->failed == 0)
        lgl->failed = ilit;

    }
}

// lglecalc
// file lglib.c line 3362
static signed int lglecalc(struct LGL *lgl, struct EVar *ev)
{
  signed int oldscore = ev->score;
  ev->score = ev->occ[(signed long int)0] + ev->occ[(signed long int)1];
  return ev->score - oldscore;
}

// lglecassume
// file lglib.c line 3959
static void lglecassume(struct LGL *lgl, signed int elit)
{

__CPROVER_DUMP_L1:
  ;
}

// lglecls
// file lglib.c line 9371
static signed int lglecls(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int lidx;
  signed int count;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  signed int d[4l];
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  count = 0;
  hts=lglhts(lgl, lit);
  signed int tmp_if_expr_1;
  if(hts->count == 0)
    return 0;

  else
  {
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      blit = *p;
      tag = blit & MASKCS;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      if(!(tag == LRGCS))
      {
        red = blit & REDCS;
        if(red == 0)
        {
          if(tag == BINCS || tag == TRNCS)
          {
            d[(signed long int)0] = lit;
            other = blit >> RMSHFT;
            d[(signed long int)1] = other;
            if(tag == TRNCS)
            {
              d[(signed long int)2] = *p;
              d[(signed long int)3] = 0;
            }

            else
              d[(signed long int)2] = 0;
            c = d;
          }

          else
          {
            if(tag == OCCS)
              tmp_if_expr_1 = blit >> RMSHFT;

            else
              tmp_if_expr_1 = *p;
            lidx = tmp_if_expr_1;
            c=lglidx2lits(lgl, OCCS, 0, lidx);
          }
          lgladdecl(lgl, c);
          count = count + 1;
        }

      }

    }
    return count;
  }
}

// lglecmp
// file lglib.c line 3194
static signed int lglecmp(struct LGL *lgl, signed int l, signed int k)
{
  struct EVar *return_value_lglevar_1;
  return_value_lglevar_1=lglevar(lgl, k);
  struct EVar *return_value_lglevar_2;
  return_value_lglevar_2=lglevar(lgl, l);
  return return_value_lglevar_1->score - return_value_lglevar_2->score;
}

// lglederef
// file lglib.c line 8448
static signed int lglederef(struct LGL *lgl, signed int elit)
{
  signed int ilit;
  signed int res;
  struct Ext *ext;
  signed int return_value_abs_1;
  return_value_abs_1=abs(elit);
  signed int tmp_if_expr_3;
  signed int return_value_lglcval_2;
  if(!(lgl->maxext >= return_value_abs_1))
    return -1;

  else
  {
    ext=lglelit2ext(lgl, elit);
    res = (signed int)ext->val;
    if(res == 0)
    {
      ilit = ext->repr;
      if(!(ilit == 0))
      {
        return_value_lglcval_2=lglcval(lgl, ilit);
        tmp_if_expr_3 = return_value_lglcval_2;
      }

      else
        tmp_if_expr_3 = -1;
      res = tmp_if_expr_3;
    }

    if(!(elit >= 0))
      res = -res;

    return res;
  }
}

// lgledown
// file lglib.c line 3250
static void lgledown(struct LGL *lgl, signed int lit)
{
  signed int parent = lit;
  signed int child;
  signed int right;
  signed int ppos;
  signed int cpos;
  signed int *p;
  signed int *pposptr;
  signed int *cposptr;
  signed int size;
  struct Stk *s = &lgl->esched;
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(s);
  size = (signed int)return_value_lglcntstk_1;
  p = s->start;
  pposptr=lglepos(lgl, parent);
  ppos = *pposptr;
  do
  {
    cpos = 2 * ppos + 1;
    if(cpos >= size)
      break;

    child = p[(signed long int)cpos];
    if(!(1 + cpos >= size))
    {
      right = p[(signed long int)(cpos + 1)];
      signed int return_value_lglecmp_2;
      return_value_lglecmp_2=lglecmp(lgl, child, right);
      if(!(return_value_lglecmp_2 >= 0))
      {
        cpos = cpos + 1;
        child = right;
      }

    }

    signed int return_value_lglecmp_3;
    return_value_lglecmp_3=lglecmp(lgl, child, lit);
    if(!(return_value_lglecmp_3 >= 1))
      break;

    cposptr=lglepos(lgl, child);
    p[(signed long int)ppos] = child;
    *cposptr = ppos;

  __CPROVER_DUMP_L4:
    ;
    ppos = cpos;
  }
  while((_Bool)1);
  if(!(*pposptr == ppos))
  {
    *pposptr = ppos;
    p[(signed long int)ppos] = lit;
  }


__CPROVER_DUMP_L7:
  ;
}

// lglefixed
// file lglib.c line 17958
static signed int lglefixed(struct LGL *lgl, signed int elit)
{
  signed int res;
  signed int ilit;
  signed int return_value_abs_1;
  return_value_abs_1=abs(elit);
  signed int return_value_abs_3;
  signed char return_value_lglifixed_2;
  if(!(lgl->maxext >= return_value_abs_1))
    return 0;

  else
  {
    ilit=lglimport(lgl, elit);
    if(ilit == 0)
      res = 0;

    else
    {
      return_value_abs_3=abs(ilit);
      if(return_value_abs_3 == 1)
        res = ilit;

      else
      {
        return_value_lglifixed_2=lglifixed(lgl, ilit);
        res = (signed int)return_value_lglifixed_2;
      }
    }
    return res;
  }
}

// lglelim
// file lglib.c line 12128
static signed int lglelim(struct LGL *lgl)
{
  signed int res = 1;
  signed int idx;
  signed int elmd;
  signed int oldnvars;
  signed int success;
  signed int all;
  signed int rem;
  signed int oldrem = (signed int)lgl->elmrem;
  signed int oldall = (signed int)lgl->elmall;
  signed long int oldprgss;
  lglstart(lgl, &lgl->times->elm);
  lgl->stats->elm.count = lgl->stats->elm.count + 1;
  lgl->simp = (char)1;
  lgl->eliminating = lgl->simp;
  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Elm) /*256ul*/ );
    lgl->_anon0.elm = (struct Elm *)return_value_lglnew_1;
  }
  while((_Bool)0);
  if(lgl->level >= 1)
    lglbacktrack(lgl, 0);

  oldnvars=lglrem(lgl);
  lglgc(lgl);
  lglfreezer(lgl);
  all = (signed int)(!(oldrem != 0) || !(oldall != 0));
  signed int return_value_lgleschedrem_2;
  if(!(all == 0))
    lglprt(lgl, 1, "[elim-%d] scheduling all variables this time", lgl->stats->elm.count);

  else
  {
    return_value_lgleschedrem_2=lgleschedrem(lgl, 1);
    if(return_value_lgleschedrem_2 == 0)
    {
      all = 1;
      oldrem = 0;
    }

  }
  if(all == 0)
    lgl->donotsched = (char)1;

  lgldense(lgl, 1);
  if(all == 0)
    lgl->donotsched = (char)0;

  lglsetelmlim(lgl);
  oldprgss = lgl->stats->prgss;
  signed int return_value_lglsmallirr_3;
  signed int return_value_lglterminate_4;
  signed int return_value_lglmtstk_5;
  while(!(res == 0))
  {
    return_value_lglsmallirr_3=lglsmallirr(lgl);
    if(return_value_lglsmallirr_3 == 0)
      break;

    return_value_lglterminate_4=lglterminate(lgl);
    if(!(return_value_lglterminate_4 == 0))
      break;

    return_value_lglmtstk_5=lglmtstk(&lgl->esched);
    if(!(return_value_lglmtstk_5 == 0))
      break;

    if(lgl->stats->elm.steps >= lgl->limits->elm.steps)
      break;

    idx=lglpopesched(lgl);
    struct AVar *return_value_lglavar_6;
    return_value_lglavar_6=lglavar(lgl, idx);
    return_value_lglavar_6->donotelm = (unsigned int)1;
    lglelimlit(lgl, idx);
    res=lglflush(lgl);
  }
  unsigned long int return_value_lglcntstk_7;
  return_value_lglcntstk_7=lglcntstk(&lgl->esched);
  rem = (signed int)return_value_lglcntstk_7;
  double return_value_lglpcnt_8;
  if(rem == 0)
    lglprt(lgl, 1, "[elim-%d] fully completed variable elimination", lgl->stats->elm.count);

  else
    if(oldrem == 0)
    {
      return_value_lglpcnt_8=lglpcnt((double)rem, (double)(lgl->nvars - 2));
      lglprt(lgl, 1, "[elim-%d] incomplete variable elimination %d not tried %.0f%%", lgl->stats->elm.count, rem, return_value_lglpcnt_8);
    }

    else
      rem=lgleschedrem(lgl, 0);
  lglsetdonotesched(lgl, (signed int)!(rem != 0));
  lglrelstk(lgl, &lgl->esched);
  lglrelecls(lgl);
  lglsparse(lgl);
  lglgc(lgl);
  lgl->elmrem = (char)(rem > 0);
  lgl->elmall = (char)(all != 0 && rem != 0);
  lglprt(lgl, 1, "[elim-%d] transition to [ all %d rem %d ] state", lgl->stats->elm.count, lgl->elmall, lgl->elmrem);
  signed int return_value_lglrem_9;
  return_value_lglrem_9=lglrem(lgl);
  elmd = oldnvars - return_value_lglrem_9;
  success = (signed int)(oldprgss < lgl->stats->prgss);
  lgl->stats->irrprgss = lgl->stats->irrprgss + (signed long int)elmd;
  lglupdelmint(lgl, success);
  double return_value_lglpcnt_10;
  return_value_lglpcnt_10=lglpcnt((double)elmd, (double)oldnvars);
  lglprt(lgl, 1, "[elim-%d] eliminated %d = %.0f%% variables out of %d", lgl->stats->elm.count, elmd, return_value_lglpcnt_10, oldnvars);
  do
  {
    lgldel(lgl, (void *)lgl->_anon0.elm, (unsigned long int)1 * sizeof(struct Elm) /*256ul*/ );
    lgl->_anon0.elm = ((struct Elm *)NULL);
  }
  while((_Bool)0);
  lglrep(lgl, 1 + (signed int)!(success != 0), (char)101);
  lgl->simp = (char)0;
  lgl->eliminating = lgl->simp;
  lglstop(lgl);
  return (signed int)!(lgl->mt != 0);
}

// lgleliminated
// file lglib.c line 10121
static void lgleliminated(struct LGL *lgl, signed int pivot)
{
  struct AVar *av;
  signed int elit;
  struct Ext *e;
  av=lglavar(lgl, pivot);
  av->type = (unsigned int)ELIMVAR;
  lgl->stats->elm.elmd = lgl->stats->elm.elmd + 1;
  lglflushclauses(lgl, pivot);
  lglflushclauses(lgl, -pivot);

__CPROVER_DUMP_L1:
  ;
  elit=lglexport(lgl, pivot);
  e=lglelit2ext(lgl, elit);
  e->eliminated = (unsigned int)1;
}

// lgleliminating
// file lglib.c line 16970
static signed int lgleliminating(struct LGL *lgl)
{
  if(lgl->opts->elim.val == 0)
    return 0;

  else
  {
    signed int return_value_lglsmallirr_1;
    return_value_lglsmallirr_1=lglsmallirr(lgl);
    if(return_value_lglsmallirr_1 == 0)
      return 0;

    else
      if(!(lgl->nvars >= 3))
        return 0;

      else
        if(!(lgl->mt == 0))
          return 0;

        else
          if(!(lgl->elmrem == 0))
            return 1;

          else
            return (signed int)(lgl->stats->irrprgss > lgl->limits->elm.irrprgss);
  }
}

// lglelimlit
// file lglib.c line 11059
static void lglelimlit(struct LGL *lgl, signed int idx)
{
  signed int return_value_lglisfree_1;
  return_value_lglisfree_1=lglisfree(lgl, idx);
  signed int return_value_lgltrysmallve_3;
  if(!(return_value_lglisfree_1 == 0))
  {
    signed int return_value_lglchkoccs4elm_2;
    return_value_lglchkoccs4elm_2=lglchkoccs4elm(lgl, idx);
    if(!(return_value_lglchkoccs4elm_2 == 0))
    {

    __CPROVER_DUMP_L1:
      ;
      if(!(lgl->opts->smallve.val == 0))
      {
        return_value_lgltrysmallve_3=lgltrysmallve(lgl, idx);
        if(return_value_lgltrysmallve_3 == 0)
          goto __CPROVER_DUMP_L2;

      }

      else
      {

      __CPROVER_DUMP_L2:
        ;
        lglinitecls(lgl, idx);
        lglelimlitaux(lgl, idx);
        if(!(lgl->_anon0.elm->pivot == 0))
          lglrstecls(lgl);

      }
    }

  }

}

// lglelimlitaux
// file lglib.c line 10453
static void lglelimlitaux(struct LGL *lgl, signed int idx)
{
  lglelmsub(lgl);
  signed int return_value_lglelmstr_1;
  return_value_lglelmstr_1=lglelmstr(lgl);
  if(return_value_lglelmstr_1 == 0)
  {
    lglelmfre(lgl);
    lgltrylargeve(lgl);
  }

}

// lglelit2ext
// file lglib.c line 2461
static struct Ext * lglelit2ext(struct LGL *lgl, signed int elit)
{
  signed int idx;
  idx=abs(elit);
  return lgl->ext + (signed long int)idx;
}

// lglelitblockingoreliminated
// file lglib.c line 12199
static signed int lglelitblockingoreliminated(struct LGL *lgl, signed int elit)
{
  struct Ext *ext;
  ext=lglelit2ext(lgl, elit);
  _Bool tmp_if_expr_1;
  if(!(ext->blocking == 0u))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ext->eliminated != 0u ? (_Bool)1 : (_Bool)0;
  return (signed int)tmp_if_expr_1;
}

// lglelmfre
// file lglib.c line 10111
static void lglelmfre(struct LGL *lgl)
{
  signed int *sop;
  signed int *eop;
  signed int *son;
  signed int *eon;
  sop = lgl->_anon0.elm->lits.start + (signed long int)1;
  son = lgl->_anon0.elm->lits.start + (signed long int)lgl->_anon0.elm->neglidx;
  eop = son;
  eon = lgl->_anon0.elm->lits.top;
  lglelmfrelit(lgl, 1, sop, eop, son, eon);
  lglelmfrelit(lgl, -1, son, eon, sop, eop);
}

// lglelmfrelit
// file lglib.c line 10024
static void lglelmfrelit(struct LGL *lgl, signed int mpivot, signed int *sop, signed int *eop, signed int *son, signed int *eon)
{
  signed int ipivot = mpivot * lgl->_anon0.elm->pivot;
  signed int clidx;
  signed int ilit;
  signed int tmp;
  signed int cover;
  signed int maxcover;
  signed int *c;
  signed int *d;
  signed int *p;
  signed int *q;
  signed int lit;
  signed int nontrivial;
  signed int idx;
  signed int sgn;
  signed int clen;
  signed int reslen;

__CPROVER_DUMP_L1:
  ;
  clidx = 0;
  signed int return_value_lglulit_1;
  return_value_lglulit_1=lglulit(-mpivot);
  cover=lglpeek(&lgl->_anon0.elm->noccs, return_value_lglulit_1);
  c = sop;
  for( ; !(c >= eop); c = p + (signed long int)1)
  {
    if(!(lgl->eliminating == 0))
      lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;

    if(*c == 0x7fffffff)
    {
      p = c + (signed long int)1;
      for( ; !(*p == 0); p = p + 1l)
        ;
    }

    else
    {
      maxcover = 0;
      p = c;
      do
      {
        lit = *p;
        if(lit == 0)
          break;

        if(!(lit == mpivot))
        {
          signed int return_value_lglulit_2;
          return_value_lglulit_2=lglulit(-lit);
          signed int return_value_lglpeek_3;
          return_value_lglpeek_3=lglpeek(&lgl->_anon0.elm->noccs, return_value_lglulit_2);
          maxcover = maxcover + return_value_lglpeek_3;
        }

        p = p + 1l;
      }
      while((_Bool)1);
      if(!(maxcover >= cover + -1))
        clidx = clidx + 1;

      else
      {
        p = c;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          if(!(lit == mpivot))
          {
            idx=abs(lit);
            sgn=lglsgn(lit);
            lglpoke(&lgl->_anon0.elm->mark, idx, sgn);
          }

          p = p + 1l;
        }
        while((_Bool)1);
        nontrivial = 0;
        clen = (signed int)(p - c);
        d = son;
        for( ; nontrivial == 0 && !(d >= eon); d = q + (signed long int)1)
        {
          lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
          if(*d == 0x7fffffff)
          {
            q = d + (signed long int)1;
            for( ; !(*q == 0); q = q + 1l)
              ;
          }

          else
          {
            lgl->stats->elm.resolutions = lgl->stats->elm.resolutions + 1l;

          __CPROVER_DUMP_L18:
            ;

          __CPROVER_DUMP_L19:
            ;
            reslen = clen - 1;
            q = d;
            do
            {
              lit = *q;
              if(lit == 0)
                break;

              if(!(lit == -mpivot))
              {
                idx=abs(lit);
                sgn=lglsgn(lit);
                tmp=lglpeek(&lgl->_anon0.elm->mark, idx);
                if(tmp == -sgn)
                  break;

                if(!(tmp == sgn))
                  reslen = reslen + 1;

              }

              q = q + 1l;
            }
            while((_Bool)1);
            if(!(lit == 0))
              do
              {
                q = q + 1l;
                if(*q == 0)
                  break;

              }
              while((_Bool)1);

            else
            {

            __CPROVER_DUMP_L25:
              ;
              nontrivial = 0x7fffffff;
            }
          }

        __CPROVER_DUMP_L24:
          ;
        }
        p = c;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          if(!(lit == mpivot))
          {
            idx=abs(lit);
            lglpoke(&lgl->_anon0.elm->mark, idx, 0);
          }

          p = p + 1l;
        }
        while((_Bool)1);
        if(!(lgl->opts->block.val == 0))
        {
          if(lgl->opts->elmblk.val == 0)
            goto __CPROVER_DUMP_L35;

          if(!(nontrivial == 0))
            goto __CPROVER_DUMP_L35;

          lgl->stats->elm.blkd = lgl->stats->elm.blkd + 1;

        __CPROVER_DUMP_L31:
          ;
          lglepush(lgl, 0);
          lglepush(lgl, ipivot);
          p = c;
          do
          {
            lit = *p;
            if(lit == 0)
              break;

            if(!(lit == mpivot))
            {
              ilit=lglm2i(lgl, lit);
              lglepush(lgl, ilit);
            }

            p = p + 1l;
          }
          while((_Bool)1);
          lglelrmcls(lgl, ipivot, c, clidx);
          lglblockinglit(lgl, ipivot);
        }

        else
        {

        __CPROVER_DUMP_L35:
          ;
          clidx = clidx + 1;
          if(lgl->stats->elm.steps >= lgl->limits->elm.steps)
          {

          __CPROVER_DUMP_L36:
            ;
            goto __CPROVER_DUMP_L39;
          }

        }
      }
    }
  }

__CPROVER_DUMP_L39:
  ;
}

// lglelmstr
// file lglib.c line 9658
static signed int lglelmstr(struct LGL *lgl)
{
  signed int clidx;
  signed int count;
  signed int strengthened;
  signed int pivot;
  signed int *c;
  signed int *p;
  signed int mlit;
  signed int ilit;
  signed int res;
  signed int found;
  signed int size;
  strengthened = 0;
  clidx = strengthened;
  count = clidx;
  pivot = lgl->_anon0.elm->pivot;
  res = 0;

__CPROVER_DUMP_L1:
  ;
  c = lgl->_anon0.elm->lits.start + (signed long int)1;
  _Bool tmp_if_expr_1;
  signed int tmp_post_2;
  do
  {
    if(!(c >= lgl->_anon0.elm->lits.top))
      tmp_if_expr_1 = lgl->limits->elm.steps > lgl->stats->elm.steps ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
    tmp_post_2 = count;
    count = count + 1;
    if(tmp_post_2 == lgl->_anon0.elm->negcls)
    {
      clidx = 0;
      pivot = -pivot;
    }


  __CPROVER_DUMP_L5:
    ;
    if(*c == 0x7fffffff)
      for( ; !(*c == 0); c = c + 1l)
        ;

    else
    {
      signed int return_value_lglbacksub_3;
      return_value_lglbacksub_3=lglbacksub(lgl, c, 1);
      if(!(return_value_lglbacksub_3 == 0))
      {
        strengthened = strengthened + 1;
        lgl->stats->elm.str = lgl->stats->elm.str + 1;

      __CPROVER_DUMP_L10:
        ;

      __CPROVER_DUMP_L11:
        ;
        found = 0;
        size = 0;
        p = c;
        do
        {
          mlit = *p;
          if(mlit == 0)
            break;

          ilit=lglm2i(lgl, *p);
          if(ilit == pivot)
            found = found + 1;

          else
          {
            lglpushstk(lgl, &lgl->clause, ilit);
            size = size + 1;
          }
          p = p + 1l;
        }
        while((_Bool)1);
        lglpushstk(lgl, &lgl->clause, 0);

      __CPROVER_DUMP_L16:
        ;
        lglelrmcls(lgl, pivot, c, clidx);
        lgladdcls(lgl, 0, 0, 1);
        lglclnstk(&lgl->clause);
        if(size == 1)
        {
          res = 1;
          break;
        }

      }

      else
        clidx = clidx + 1;
      for( ; !(*c == 0); c = c + 1l)
        ;
    }
    c = c + 1l;
  }
  while((_Bool)1);

__CPROVER_DUMP_L22:
  ;
  return res;
}

// lglelmsub
// file lglib.c line 9635
static void lglelmsub(struct LGL *lgl)
{
  signed int clidx;
  signed int count;
  signed int subsumed;
  signed int pivot;
  signed int *c;
  subsumed = 0;
  clidx = subsumed;
  count = clidx;
  pivot = lgl->_anon0.elm->pivot;
  c = lgl->_anon0.elm->lits.start + (signed long int)1;
  _Bool tmp_if_expr_1;
  signed int tmp_post_2;
  do
  {
    if(!(c >= lgl->_anon0.elm->lits.top))
      tmp_if_expr_1 = lgl->limits->elm.steps > lgl->stats->elm.steps ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
    tmp_post_2 = count;
    count = count + 1;
    if(tmp_post_2 == lgl->_anon0.elm->negcls)
    {
      clidx = 0;
      pivot = -pivot;
    }

    signed int return_value_lglbacksub_3;
    return_value_lglbacksub_3=lglbacksub(lgl, c, 0);
    if(!(return_value_lglbacksub_3 == 0))
    {
      subsumed = subsumed + 1;
      lgl->stats->elm.sub = lgl->stats->elm.sub + 1;

    __CPROVER_DUMP_L5:
      ;

    __CPROVER_DUMP_L6:
      ;
      lglelrmcls(lgl, pivot, c, clidx);
    }

    else
      clidx = clidx + 1;
    for( ; !(*c == 0); c = c + 1l)
      ;
    c = c + 1l;
  }
  while((_Bool)1);

__CPROVER_DUMP_L10:
  ;
}

// lglelrmcls
// file lglib.c line 9481
static void lglelrmcls(struct LGL *lgl, signed int lit, signed int *c, signed int clidx)
{
  signed int lidx;
  signed int i;
  signed int other;
  signed int ulit;
  signed int *lglelrmcls__1__lits;
  signed int *csigs;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other2;
  signed int *p;
  signed int *eow;
  signed int *w;
  signed int count;
  struct HTS *hts;
  lglelrmcls__1__lits = lgl->_anon0.elm->lits.start;
  csigs = lgl->_anon0.elm->csigs.start;
  lidx = (signed int)(c - lglelrmcls__1__lits);

__CPROVER_DUMP_L1:
  ;
  i = lidx;
  do
  {
    other = lglelrmcls__1__lits[(signed long int)i];
    if(other == 0)
      break;

    lglelrmcls__1__lits[(signed long int)i] = 0x7fffffff;
    csigs[(signed long int)i] = 0;
    ulit=lglulit(other);
    lgl->_anon0.elm->noccs.start[(signed long int)ulit] = lgl->_anon0.elm->noccs.start[(signed long int)ulit] - 1;
    i = i + 1;
  }
  while((_Bool)1);
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  count = 0;
  tag = count;
  blit = tag;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(!(tag == LRGCS))
    {
      red = blit & REDCS;
      if(red == 0)
      {
        if(count == clidx)
          break;

        count = count + 1;
      }

    }

  }
  signed int tmp_if_expr_1;
  if(tag == BINCS)
  {
    other = blit >> RMSHFT;
    lglrmbcls(lgl, lit, other, 0);
  }

  else
    if(tag == TRNCS)
    {
      other = blit >> RMSHFT;
      other2 = *p;
      lglrmtcls(lgl, lit, other, other2, 0);
    }

    else
    {
      if(tag == OCCS)
        tmp_if_expr_1 = blit >> RMSHFT;

      else
        tmp_if_expr_1 = *p;
      lidx = tmp_if_expr_1;
      lglrmlcls(lgl, lidx, 0);
    }
}

// lglemerge
// file lglib.c line 8068
static void lglemerge(struct LGL *lgl, signed int ilit0, signed int ilit1)
{
  signed int elit0;
  signed int return_value_abs_1;
  return_value_abs_1=abs(ilit0);
  signed int return_value_lglsgn_2;
  return_value_lglsgn_2=lglsgn(ilit0);
  elit0 = lgl->i2e[(signed long int)return_value_abs_1] * return_value_lglsgn_2;
  signed int elit1;
  signed int return_value_abs_3;
  return_value_abs_3=abs(ilit1);
  signed int return_value_lglsgn_4;
  return_value_lglsgn_4=lglsgn(ilit1);
  elit1 = lgl->i2e[(signed long int)return_value_abs_3] * return_value_lglsgn_4;
  signed int repr0;
  repr0=lglerepr(lgl, elit0);
  signed int repr1;
  repr1=lglerepr(lgl, elit1);
  struct Ext *ext0;
  ext0=lglelit2ext(lgl, repr0);
  if(!(repr0 >= 0))
    repr1 = repr1 * -1;

  ext0->equiv = (unsigned int)1;
  ext0->repr = repr1;

__CPROVER_DUMP_L2:
  ;
  lglepush(lgl, 0);
  lglepush(lgl, -ilit0);
  lglepush(lgl, ilit1);
  lglepush(lgl, 0);
  lglepush(lgl, ilit0);
  lglepush(lgl, -ilit1);
}

// lglenlargegates
// file lglib.c line 12334
static void lglenlargegates(struct LGL *lgl)
{
  signed int oldsize = lgl->_anon0.cgr->szgates;
  signed int newsize = oldsize != 0 ? 2 * oldsize : 1;
  do
  {
    void *return_value_lglrsz_1;
    return_value_lglrsz_1=lglrsz(lgl, (void *)lgl->_anon0.cgr->gates, (unsigned long int)oldsize * sizeof(struct Gat) /*32ul*/ , (unsigned long int)newsize * sizeof(struct Gat) /*32ul*/ );
    lgl->_anon0.cgr->gates = (struct Gat *)return_value_lglrsz_1;
  }
  while((_Bool)0);
  lgl->_anon0.cgr->szgates = newsize;
}

// lglenlctk
// file lglib.c line 1551
static void lglenlctk(struct LGL *lgl, struct Ctk *ctk)
{
  signed int oldsize;
  oldsize=lglsizectk(ctk);
  signed int newsize = oldsize != 0 ? 2 * oldsize : 1;
  signed int count;
  count=lglcntctk(ctk);
  do
  {
    void *return_value_lglrsz_1;
    return_value_lglrsz_1=lglrsz(lgl, (void *)ctk->start, (unsigned long int)oldsize * sizeof(struct Ctr) /*4ul*/ , (unsigned long int)newsize * sizeof(struct Ctr) /*4ul*/ );
    ctk->start = (struct Ctr *)return_value_lglrsz_1;
  }
  while((_Bool)0);
  ctk->top = ctk->start + (signed long int)count;
  ctk->end = ctk->start + (signed long int)newsize;
}

// lglenlstk
// file lglib.c line 1401
static void lglenlstk(struct LGL *lgl, struct Stk *s)
{
  unsigned long int old_size;
  old_size=lglszstk(s);
  unsigned long int new_size = old_size != 0ul ? (unsigned long int)2 * old_size : (unsigned long int)1;
  unsigned long int count;
  count=lglcntstk(s);
  do
  {
    void *return_value_lglrsz_1;
    return_value_lglrsz_1=lglrsz(lgl, (void *)s->start, old_size * sizeof(signed int) /*4ul*/ , new_size * sizeof(signed int) /*4ul*/ );
    s->start = (signed int *)return_value_lglrsz_1;
  }
  while((_Bool)0);
  s->top = s->start + (signed long int)count;
  s->end = s->start + (signed long int)new_size;
}

// lglenlvars
// file lglib.c line 2292
static void lglenlvars(struct LGL *lgl)
{
  unsigned long int old_size;
  unsigned long int new_size;
  old_size = (unsigned long int)lgl->szvars;
  new_size = old_size != 0ul ? (unsigned long int)2 * old_size : (unsigned long int)4;

__CPROVER_DUMP_L1:
  ;
  lglrszvars(lgl, (signed int)new_size);
}

// lglenlwchs
// file lglib.c line 3041
static signed long int lglenlwchs(struct LGL *lgl, struct HTS *hts)
{
  signed int oldhcount = hts->count;
  signed int oldoffset = hts->offset;
  signed int newoffset;
  signed int oldwcount;
  signed int newwcount;
  signed int oldwsize;
  signed int newwsize;
  signed int i;
  signed int j;
  signed int newhcount = oldhcount != 0 ? 2 * oldhcount : 1;
  signed int *oldwstart;
  signed int *newwstart;
  signed int *lglenlwchs__1__start;
  signed int ldnewhcount;
  ldnewhcount=lglfloorld(newhcount);
  signed long int res = (signed long int)0;
  newhcount = 1 << ldnewhcount;

__CPROVER_DUMP_L1:
  ;
  lgl->stats->enlwchs = lgl->stats->enlwchs + 1l;
  newoffset = lgl->wchs->start[(signed long int)ldnewhcount];
  lglenlwchs__1__start = lgl->wchs->stk.start;
  if(!(newoffset == 0x7fffffff))
  {
    lgl->wchs->start[(signed long int)ldnewhcount] = lglenlwchs__1__start[(signed long int)newoffset];
    lglenlwchs__1__start[(signed long int)newoffset] = 0;
    lgl->wchs->free = lgl->wchs->free - 1;
  }

  else
  {
    unsigned long int return_value_lglcntstk_1;
    return_value_lglcntstk_1=lglcntstk(&lgl->wchs->stk);
    oldwcount = (signed int)return_value_lglcntstk_1;
    newwcount = oldwcount + newhcount;
    unsigned long int return_value_lglszstk_2;
    return_value_lglszstk_2=lglszstk(&lgl->wchs->stk);
    oldwsize = (signed int)return_value_lglszstk_2;
    newwsize = oldwsize;
    for( ; !(newwsize >= newwcount); newwsize = newwsize * 2)
      ;
    if(!(oldwsize >= newwsize))
    {
      oldwstart = lgl->wchs->stk.start;
      newwstart = oldwstart;
      do
      {
        void *return_value_lglrsz_3;
        return_value_lglrsz_3=lglrsz(lgl, (void *)newwstart, (unsigned long int)oldwsize * sizeof(signed int) /*4ul*/ , (unsigned long int)newwsize * sizeof(signed int) /*4ul*/ );
        newwstart = (signed int *)return_value_lglrsz_3;
      }
      while((_Bool)0);

    __CPROVER_DUMP_L7:
      ;
      res = newwstart - oldwstart;
      if(!(res == 0l))
      {

      __CPROVER_DUMP_L8:
        ;
        lgl->wchs->stk.start = newwstart;
        lglenlwchs__1__start = lgl->wchs->stk.start;
      }

      lgl->wchs->stk.end = lglenlwchs__1__start + (signed long int)newwsize;
    }

    lgl->wchs->stk.top = lglenlwchs__1__start + (signed long int)newwcount;
    lgl->wchs->stk.top[(signed long int)-1] = 0x7fffffff;
    newoffset = oldwcount - 1;
  }

__CPROVER_DUMP_L2:
  ;

__CPROVER_DUMP_L11:
  ;
  j = newoffset;
  i = oldoffset;
  signed int tmp_post_4;
  for( ; !(i >= oldhcount + oldoffset); i = i + 1)
  {
    tmp_post_4 = j;
    j = j + 1;
    lglenlwchs__1__start[(signed long int)tmp_post_4] = lglenlwchs__1__start[(signed long int)i];
    lglenlwchs__1__start[(signed long int)i] = 0;
  }
  signed int tmp_post_5;
  for( ; !(j >= newhcount + newoffset); lglenlwchs__1__start[(signed long int)tmp_post_5] = 0)
  {
    tmp_post_5 = j;
    j = j + 1;
  }
  hts->offset = newoffset;
  if(oldhcount >= 1)
    lglfreewch(lgl, oldoffset, oldhcount);

  return res;
}

// lglenlwtk
// file lglib.c line 15000
static void lglenlwtk(struct LGL *lgl, struct Wtk *wtk)
{
  signed int oldsize;
  oldsize=lglsizewtk(wtk);
  signed int newsize = oldsize != 0 ? 2 * oldsize : 1;
  signed int count;
  count=lglcntwtk(wtk);
  do
  {
    void *return_value_lglrsz_1;
    return_value_lglrsz_1=lglrsz(lgl, (void *)wtk->start, (unsigned long int)oldsize * sizeof(struct Work) /*8ul*/ , (unsigned long int)newsize * sizeof(struct Work) /*8ul*/ );
    wtk->start = (struct Work *)return_value_lglrsz_1;
  }
  while((_Bool)0);
  wtk->top = wtk->start + (signed long int)count;
  wtk->end = wtk->start + (signed long int)newsize;
}

// lglepos
// file lglib.c line 3186
static signed int * lglepos(struct LGL *lgl, signed int lit)
{
  struct EVar *ev;
  signed int *res;
  ev=lglevar(lgl, lit);
  res = &ev->pos;
  return res;
}

// lglepush
// file lglib.c line 8062
static void lglepush(struct LGL *lgl, signed int ilit)
{
  signed int elit;
  signed int tmp_if_expr_2;
  signed int return_value_lglexport_1;
  if(!(ilit == 0))
  {
    return_value_lglexport_1=lglexport(lgl, ilit);
    tmp_if_expr_2 = return_value_lglexport_1;
  }

  else
    tmp_if_expr_2 = 0;
  elit = tmp_if_expr_2;
  lglpushstk(lgl, &lgl->extend, elit);

__CPROVER_DUMP_L3:
  ;
}

// lglepusheliminated
// file lglib.c line 10141
static void lglepusheliminated(struct LGL *lgl, signed int idx)
{
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  const signed int *l;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  struct HTS *hts;
  signed int return_value_lglocc_1;
  return_value_lglocc_1=lglocc(lgl, idx);
  signed int return_value_lglocc_2;
  return_value_lglocc_2=lglocc(lgl, -idx);
  lit = return_value_lglocc_1 < return_value_lglocc_2 ? idx : -idx;

__CPROVER_DUMP_L1:
  ;
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(!(tag == LRGCS))
    {
      red = blit & REDCS;
      if(red == 0)
      {
        lglepush(lgl, 0);
        lglepush(lgl, lit);
        if(tag == BINCS || tag == TRNCS)
        {
          lglepush(lgl, blit >> RMSHFT);
          if(tag == TRNCS)
            lglepush(lgl, *p);

        }

        else
        {
          c=lglidx2lits(lgl, OCCS, 0, blit >> RMSHFT);
          l = c;
          do
          {
            other = *l;
            if(other == 0)
              break;

            if(!(other == lit))
              lglepush(lgl, other);

            l = l + 1l;
          }
          while((_Bool)1);
        }
      }

    }

  }
  lglepush(lgl, 0);
  lglepush(lgl, -lit);
  lgleliminated(lgl, idx);
}

// lglerepr
// file lglib.c line 2467
static signed int lglerepr(struct LGL *lgl, signed int elit)
{
  signed int res;
  signed int lglerepr__1__next;
  signed int tmp;
  struct Ext *ext;
  res = elit;
  do
  {
    ext=lglelit2ext(lgl, res);
    if(ext->equiv == 0u)
      break;

    lglerepr__1__next = ext->repr;
    if(!(res >= 0))
      lglerepr__1__next = -lglerepr__1__next;

    res = lglerepr__1__next;
  }
  while((_Bool)1);
  tmp = elit;
  do
  {
    ext=lglelit2ext(lgl, tmp);
    if(ext->equiv == 0u)
      break;

    lglerepr__1__next = ext->repr;
    ext->repr = tmp < 0 ? -res : res;
    if(!(tmp >= 0))
      lglerepr__1__next = -lglerepr__1__next;

    tmp = lglerepr__1__next;
  }
  while((_Bool)1);
  return res;
}

// lglesched
// file lglib.c line 3294
static void lglesched(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  signed int *p;
  struct Stk *s;
  if(lgl->cgrclosing == 0)
  {
    signed int return_value_lglifrozen_1;
    return_value_lglifrozen_1=lglifrozen(lgl, lit);
    if(return_value_lglifrozen_1 == 0)
    {
      signed int return_value_lglisfree_2;
      return_value_lglisfree_2=lglisfree(lgl, lit);
      if(!(return_value_lglisfree_2 == 0))
      {
        if(!(lgl->donotsched == 0))
        {
          av=lglavar(lgl, lit);
          if(!(lgl->eliminating == 0))
          {
            if(!(av->donotelm == 0u))
              goto __CPROVER_DUMP_L9;

          }

          if(!(lgl->blocking == 0))
          {
            if(!(av->donotblk == 0u))
              goto __CPROVER_DUMP_L9;

          }

          if(lgl->cceing == 0)
            goto __CPROVER_DUMP_L6;

          if(av->donotcce == 0u)
            goto __CPROVER_DUMP_L6;

        }

        else
        {

        __CPROVER_DUMP_L6:
          ;
          p=lglepos(lgl, lit);
          s = &lgl->esched;
          if(!(*p >= 0))
          {
            unsigned long int return_value_lglcntstk_3;
            return_value_lglcntstk_3=lglcntstk(s);
            *p = (signed int)return_value_lglcntstk_3;
            lglpushstk(lgl, s, lit);
            lgleup(lgl, lit);
            lgledown(lgl, lit);
          }

        }
      }

    }

  }


__CPROVER_DUMP_L8:
  ;

__CPROVER_DUMP_L9:
  ;
}

// lgleschedrem
// file lglib.c line 11318
static signed int lgleschedrem(struct LGL *lgl, signed int this_time)
{
  signed int idx;
  signed int res = 0;
  signed int count;
  const char *str;
  struct AVar *av;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglifrozen_1;
    return_value_lglifrozen_1=lglifrozen(lgl, idx);
    if(return_value_lglifrozen_1 == 0)
    {
      signed int return_value_lglisfree_2;
      return_value_lglisfree_2=lglisfree(lgl, idx);
      if(!(return_value_lglisfree_2 == 0))
      {
        av=lglavar(lgl, idx);
        if(!(lgl->eliminating == 0))
        {
          if(av->donotelm == 0u)
            goto __CPROVER_DUMP_L3;

        }

        else
        {

        __CPROVER_DUMP_L3:
          ;
          if(!(lgl->blocking == 0))
          {
            if(av->donotblk == 0u)
              goto __CPROVER_DUMP_L4;

          }

          else
          {

          __CPROVER_DUMP_L4:
            ;
            if(!(lgl->cceing == 0))
            {
              if(av->donotcce == 0u)
                goto __CPROVER_DUMP_L5;

            }

            else
            {

            __CPROVER_DUMP_L5:
              ;
              res = res + 1;
            }
          }
        }
      }

    }

  }
  if(!(lgl->eliminating == 0))
  {
    count = lgl->stats->elm.count;
    str = "elim";
  }

  else
    if(!(lgl->blocking == 0))
    {
      count = lgl->stats->blk.count;
      str = "block";
    }

    else
    {
      count = lgl->stats->cce.count;
      str = "cce";
    }
  signed int return_value_lglrem_3;
  double return_value_lglpcnt_4;
  if(!(res == 0))
  {
    return_value_lglrem_3=lglrem(lgl);
    return_value_lglpcnt_4=lglpcnt((double)res, (double)return_value_lglrem_3);
    lglprt(lgl, 1, "[%s-%d] %d variables %.0f%% %s time", str, count, res, return_value_lglpcnt_4, this_time != 0 ? "will be scheduled this" : "remain to be tried next");
  }

  else
  {
    lglprt(lgl, 1, "[%s-%d] no untried remaining variables left", str, count);
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      av=lglavar(lgl, idx);
      if(!(lgl->eliminating == 0))
        av->donotelm = (unsigned int)0;

      if(!(lgl->blocking == 0))
        av->donotblk = (unsigned int)0;

      if(!(lgl->cceing == 0))
        av->donotcce = (unsigned int)0;

    }
  }
  return res;
}

// lglesetphase
// file lglib.c line 3891
static void lglesetphase(struct LGL *lgl, signed int elit, signed int phase)
{
  signed int ilit;
  ilit=lglimport(lgl, elit);
  signed int return_value_abs_1;
  return_value_abs_1=abs(ilit);
  if(return_value_abs_1 >= 2)
  {

  __CPROVER_DUMP_L1:
    ;
    lglisetphase(lgl, ilit, phase);
  }

  else

    __CPROVER_DUMP_L2:
      ;
}

// lgletrav
// file lglib.c line 18731
void lgletrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int, signed int))
{
  signed int elit;
  signed int erepr;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lgletrav");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  signed int return_value_lglbcp_1;
  if(lgl->mt == 0)
  {
    return_value_lglbcp_1=lglbcp(lgl);
    if(return_value_lglbcp_1 == 0)
      lgl->mt = 1;

  }

  if(lgl->mt == 0)
    lglgc(lgl);

  if(lgl->mt == 0)
  {
    if(lgl->level >= 1)
      lglbacktrack(lgl, 0);

    elit = 1;
    for( ; lgl->maxext >= elit; elit = elit + 1)
    {
      signed int return_value_lglefixed_2;
      return_value_lglefixed_2=lglefixed(lgl, elit);
      if(return_value_lglefixed_2 == 0)
      {
        erepr=lglerepr(lgl, elit);
        if(!(erepr == elit))
          trav(state, elit, erepr);

      }

    }
  }

}

// lgleunassignall
// file lglib.c line 3708
static void lgleunassignall(struct LGL *lgl)
{
  signed int eidx = 1;
  struct Ext *return_value_lglelit2ext_1;
  for( ; lgl->maxext >= eidx; eidx = eidx + 1)
  {
    return_value_lglelit2ext_1=lglelit2ext(lgl, eidx);
    return_value_lglelit2ext_1->val = 0;
  }
}

// lgleup
// file lglib.c line 3220
static void lgleup(struct LGL *lgl, signed int lit)
{
  signed int child = lit;
  signed int parent;
  signed int cpos;
  signed int ppos;
  signed int *p;
  signed int *cposptr;
  signed int *pposptr;
  struct Stk *s = &lgl->esched;
  p = s->start;
  cposptr=lglepos(lgl, child);
  cpos = *cposptr;
  while(cpos >= 1)
  {
    ppos = (cpos - 1) / 2;
    parent = p[(signed long int)ppos];
    signed int return_value_lglecmp_1;
    return_value_lglecmp_1=lglecmp(lgl, parent, lit);
    if(return_value_lglecmp_1 >= 0)
      break;

    pposptr=lglepos(lgl, parent);
    p[(signed long int)cpos] = parent;
    *pposptr = cpos;

  __CPROVER_DUMP_L2:
    ;
    cpos = ppos;
  }
  if(!(*cposptr == cpos))
  {
    *cposptr = cpos;
    p[(signed long int)cpos] = lit;
  }


__CPROVER_DUMP_L5:
  ;
}

// lglevar
// file lglib.c line 3180
static struct EVar * lglevar(struct LGL *lgl, signed int lit)
{
  signed int idx;
  idx=abs(lit);
  return lgl->evars + (signed long int)idx;
}

// lglevel
// file lglib.c line 2340
static signed int lglevel(struct LGL *lgl, signed int lit)
{
  struct TD *return_value_lgltd_1;
  return_value_lgltd_1=lgltd(lgl, lit);
  return (signed int)return_value_lgltd_1->level;
}

// lglevelused
// file lglib.c line 1579
static signed int lglevelused(struct LGL *lgl, signed int level)
{
  struct Ctk *ctk = &lgl->control;
  struct Ctr *ctr = ctk->start + (signed long int)level;
  return (signed int)ctr->used;
}

// lglexp
// file lglib.c line 1047
static signed int lglexp(signed long int a)
{
  signed int res = (signed int)(a >> 32);
  res = res - 0x10000000;
  return res;
}

// lglexport
// file lglib.c line 2573
static signed int lglexport(struct LGL *lgl, signed int ilit)
{
  signed int return_value_abs_1;
  return_value_abs_1=abs(ilit);
  signed int return_value_lglsgn_2;
  return_value_lglsgn_2=lglsgn(ilit);
  return lgl->i2e[(signed long int)return_value_abs_1] * return_value_lglsgn_2;
}

// lglextend
// file lglib.c line 17383
static void lglextend(struct LGL *lgl)
{
  signed int *p;
  signed int lit;
  signed int eidx;
  signed int ilit;
  signed int lglextend__1__next;
  signed int satisfied;
  signed int val;
  signed int *lglextend__1__start;
  signed int erepr;
  signed int equiv;
  struct Ext *ext;
  struct Ext *extrepr;
  lgleunassignall(lgl);
  equiv = 0;
  for( ; !(equiv >= 2); equiv = equiv + 1)
  {
    if(!(equiv == 0))

      __CPROVER_DUMP_L2:
        ;

    else

      __CPROVER_DUMP_L3:
        ;
    eidx = 1;
    for( ; lgl->maxext >= eidx; eidx = eidx + 1)
    {
      ext=lglelit2ext(lgl, eidx);
      if(!(ext->imported == 0u))
      {
        if(equiv == (signed int)ext->equiv)
        {
          if(!(ext->equiv == 0u))
          {
            erepr=lglerepr(lgl, eidx);

          __CPROVER_DUMP_L6:
            ;
            extrepr=lglelit2ext(lgl, erepr);
            val = (signed int)extrepr->val;
            if(val == 0)
            {
              ilit = extrepr->repr;
              if(!(ilit == 0))
              {

              __CPROVER_DUMP_L7:
                ;
                val=lglcval(lgl, ilit);
              }

              else

                __CPROVER_DUMP_L8:
                  ;
            }

            if(!(erepr >= 0))
              val = -val;

          }

          else
          {
            ilit = ext->repr;
            if(!(ilit == 0))
            {

            __CPROVER_DUMP_L12:
              ;
              val=lglcval(lgl, ilit);
            }

            else
            {

            __CPROVER_DUMP_L13:
              ;
              val = 0;
            }
          }
          lit = val > 0 ? eidx : -eidx;
          lgleassign(lgl, lit);
        }

      }

    }
  }
  lglextend__1__start = lgl->extend.start;
  p = lgl->extend.top;
  while(!(lglextend__1__start >= p))
  {
    satisfied = 0;
    lglextend__1__next = 0;
    do
    {
      lit = lglextend__1__next;
      p = p - 1l;
      lglextend__1__next = *p;
      if(!(lit == 0) && satisfied == 0)
      {
        val=lglederef(lgl, lit);
        if(val >= 1)
        {

        __CPROVER_DUMP_L20:
          ;
          satisfied = 1;
        }

      }

    }
    while(!(lglextend__1__next == 0));
    if(satisfied == 0)
      lgleassign(lgl, lit);

  }
  lglcomputechanged(lgl);

__CPROVER_DUMP_L24:
  ;
  do
    lgl->state = (enum State)EXTENDED;
  while((_Bool)0);
}

// lglf2rce
// file lglib.c line 2713
static void lglf2rce(struct LGL *lgl, signed int lit, signed int other, signed int red)
{
  lglassign(lgl, lit, other << RMSHFT | BINCS | red, 0);
}

// lglf3rce
// file lglib.c line 2720
static void lglf3rce(struct LGL *lgl, signed int lit, signed int other, signed int other2, signed int red)
{
  lglassign(lgl, lit, other << RMSHFT | TRNCS | red, other2);
}

// lglfadd
// file lglib.c line 3812
static void lglfadd(struct LGL *lgl, signed int elit)
{
  signed int eidx;
  signed int size;
  const signed int *p;
  signed long int sum;
  struct Ext *ext;
  signed int return_value_abs_2;
  if(!(elit == 0))
  {
    eidx=abs(elit);
    if(!(lgl->stats->features.vars >= eidx))
      lgl->stats->features.vars = eidx;

    lgl->stats->features.lits.total = lgl->stats->features.lits.total + 1;
    if(elit >= 1)
      lgl->stats->features.lits.pos = lgl->stats->features.lits.pos + 1;

    if(!(elit >= 0))
      lgl->stats->features.lits.neg = lgl->stats->features.lits.neg + 1;

    lglpushstk(lgl, &lgl->eclause, elit);
  }

  else
  {
    unsigned long int return_value_lglcntstk_1;
    return_value_lglcntstk_1=lglcntstk(&lgl->eclause);
    size = (signed int)return_value_lglcntstk_1;
    lgl->stats->features.clauses.total = lgl->stats->features.clauses.total + 1;
    if(size >= 1)
    {
      if(size == 1)
        lgl->stats->features.clauses.unit = lgl->stats->features.clauses.unit + 1;

      if(size == 2)
        lgl->stats->features.clauses.bin = lgl->stats->features.clauses.bin + 1;

      if(size == 3)
        lgl->stats->features.clauses.trn = lgl->stats->features.clauses.trn + 1;

      if(size >= 4)
        lgl->stats->features.clauses.lrg = lgl->stats->features.clauses.lrg + 1;

      sum = (signed long int)0;
      p = lgl->eclause.start;
      for( ; !(p >= lgl->eclause.top); p = p + 1l)
      {
        return_value_abs_2=abs(*p);
        sum = sum + (signed long int)return_value_abs_2;
      }
      sum = sum * (signed long int)10;
      sum = sum / (signed long int)size;
      sum = sum + (signed long int)5;
      sum = sum / (signed long int)10;
      p = lgl->eclause.start;
      for( ; !(p >= lgl->eclause.top); p = p + 1l)
      {
        ext=lglelit2ext(lgl, *p);
        ext->cog.sum = ext->cog.sum + sum;
        ext->cog.count = ext->cog.count + 1;
      }
      lglclnstk(&lgl->eclause);
    }

  }
}

// lglfailed
// file lglib.h line 195
signed int lglfailed(struct LGL *lgl, signed int elit)
{
  unsigned int bit;
  struct Ext *ext;
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfailed");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "failed %d", elit);
    break;
  }
  lgl->stats->calls.failed = lgl->stats->calls.failed + 1l;
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfailed");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not check zero failed literal");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }

__CPROVER_DUMP_L8:
  ;
  do
  {
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfailed");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

    while((384 & (signed int)lgl->state) == 0)
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfailed");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "!(%s)", (const void *)"UNSATISFIED | FAILED");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
  }
  while((_Bool)0);
  do
  {
    signed int return_value_abs_1;
    return_value_abs_1=abs(elit);
    if(lgl->maxext >= return_value_abs_1)
      break;

    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfailed");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not check unimported failed literal");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
  }
  while((_Bool)0);
  ext=lglelit2ext(lgl, elit);
  bit = 1u << (signed int)(elit < 0);
  while((bit & (unsigned int)ext->assumed) == 0u)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfailed");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not check unassumed failed literal");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  if((FAILED & (signed int)lgl->state) == 0)
  {
    lglstart(lgl, &lgl->times->all);
    lglanafailed(lgl);
    lglstop(lgl);
  }

  res = (signed int)(((unsigned int)ext->failed & bit) != (unsigned int)0);

__CPROVER_DUMP_L21:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglfailed(lgl->clone, elit);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfailed");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d", (const void *)"lglfailed", elit, CLONERES, (const void *)"lglfailed", elit, res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglfailedass
// file lglib.c line 14442
static signed int lglfailedass(struct LGL *lgl)
{
  _Bool tmp_if_expr_1;
  if(lgl->level == lgl->alevel)
    tmp_if_expr_1 = lgl->failed != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return (signed int)tmp_if_expr_1;
}

// lglfalsefun
// file lglib.c line 10513
static void lglfalsefun(unsigned long int *res)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    res[(signed long int)i] = (unsigned long int)0ll;
}

// lglfirstopt
// file lglib.c line 2142
void * lglfirstopt(struct LGL *lgl)
{
  return (void *)(&lgl->opts->beforefirst + (signed long int)1);
}

// lglfitlir
// file lglib.c line 5072
static void lglfitlir(struct LGL *lgl, struct Stk *lir)
{
  lglfitstk(lgl, lir);
}

// lglfitstk
// file lglib.c line 1427
static void lglfitstk(struct LGL *lgl, struct Stk *s)
{
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(s);
  lglshrstk(lgl, s, (signed int)return_value_lglcntstk_1);
}

// lglfixate
// file lglib.c line 3995
void lglfixate(struct LGL *lgl)
{
  const signed int *p;
  struct Stk eassume;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfixate");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "fixate");
    break;
  }
  if(lgl->mt == 0)
  {
    do
      memset((void *)&eassume, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    p = lgl->eassume.start;
    for( ; !(p >= lgl->eassume.top); p = p + 1l)
      lglpushstk(lgl, &eassume, *p);
    p = eassume.start;
    for( ; !(p >= eassume.top); p = p + 1l)
    {
      lgleadd(lgl, *p);
      lgleadd(lgl, 0);
    }
    lglrelstk(lgl, &eassume);
    lgluse(lgl);
    if(!(lgl->clone == ((struct LGL *)NULL)))
      lglfixate(lgl->clone);

  }

}

// lglfixed
// file lglib.c line 17969
signed int lglfixed(struct LGL *lgl, signed int elit)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfixed");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "fixed %d", elit);
    break;
  }
  lgl->stats->calls.fixed = lgl->stats->calls.fixed + 1l;
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfixed");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not deref zero literal");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  res=lglefixed(lgl, elit);

__CPROVER_DUMP_L9:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglfixed(lgl->clone, elit);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfixed");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d", (const void *)"lglfixed", elit, CLONERES, (const void *)"lglfixed", elit, res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglfixlrgwchs
// file lglib.c line 15880
static void lglfixlrgwchs(struct LGL *lgl)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int lidx;
  signed int fixed;
  const signed int *p;
  const signed int *eow;
  const signed int *c;
  signed int *q;
  signed int *w;
  struct HTS *hts;
  fixed = 0;
  idx = 2;
  signed int *tmp_post_1;
  signed int *tmp_post_2;
  signed int *tmp_post_3;
  signed int *tmp_post_4;
  signed int *tmp_post_5;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      hts=lglhts(lgl, lit);
      w=lglhts2wchs(lgl, hts);
      eow = w + (signed long int)hts->count;
      q = w;
      p = w;
      for( ; !(p >= eow); p = p + 1l)
      {
        blit = *p;
        tag = blit & MASKCS;
        if(tag == BINCS)
        {
          tmp_post_1 = q;
          q = q + 1l;
          *tmp_post_1 = blit;
        }

        else
        {
          p = p + 1l;
          lidx = *p;
          if(tag == TRNCS)
          {
            tmp_post_2 = q;
            q = q + 1l;
            *tmp_post_2 = blit;
            tmp_post_3 = q;
            q = q + 1l;
            *tmp_post_3 = lidx;
          }

          else
          {
            red = blit & REDCS;
            c=lglidx2lits(lgl, LRGCS, red, lidx);
            if(*c >= 134217727)
              fixed = fixed + 1;

            else
            {
              tmp_post_4 = q;
              q = q + 1l;
              *tmp_post_4 = blit;
              tmp_post_5 = q;
              q = q + 1l;
              *tmp_post_5 = lidx;
            }
          }
        }
      }
      lglshrinkhts(lgl, hts, (signed int)((signed long int)hts->count - (p - q)));
    }
  }
  if(!(fixed == 0))

    __CPROVER_DUMP_L11:
      ;

}

// lglfjadd
// file lglib.c line 18891
static void lglfjadd(struct LGL *lgl, signed int elit)
{
  signed int ilit;
  signed int tmp_if_expr_2;
  signed int return_value_lglimport_1;
  if(!(elit == 0))
  {
    return_value_lglimport_1=lglimport(lgl, elit);
    tmp_if_expr_2 = return_value_lglimport_1;
  }

  else
    tmp_if_expr_2 = 0;
  ilit = tmp_if_expr_2;
  lglpushstk(lgl, &lgl->clause, ilit);
  if(ilit == 0)
  {
    signed int return_value_lglsimpcls_3;
    return_value_lglsimpcls_3=lglsimpcls(lgl);
    if(return_value_lglsimpcls_3 == 0)
      lgladdcls(lgl, REDCS, 0, 1);

    lglclnstk(&lgl->clause);
  }

}

// lglfjradd
// file lglib.c line 18899
static void lglfjradd(struct LGL *lgl, signed int elit, signed int glue)
{
  signed int ilit;
  signed int tmp_if_expr_2;
  signed int return_value_lglimport_1;
  if(!(elit == 0))
  {
    return_value_lglimport_1=lglimport(lgl, elit);
    tmp_if_expr_2 = return_value_lglimport_1;
  }

  else
    tmp_if_expr_2 = 0;
  ilit = tmp_if_expr_2;
  lglpushstk(lgl, &lgl->clause, ilit);
  if(ilit == 0)
  {
    signed int return_value_lglsimpcls_3;
    return_value_lglsimpcls_3=lglsimpcls(lgl);
    if(return_value_lglsimpcls_3 == 0)
      lgladdcls(lgl, REDCS, glue, 1);

    lglclnstk(&lgl->clause);
  }

}

// lglfloorld
// file lglib.c line 971
static signed int lglfloorld(signed int n)
{
  if(!(n >= 256))
    return (signed int)lglfloorldtab[(signed long int)n];

  else
    if(!(n >= 65536))
      return 8 + (signed int)lglfloorldtab[(signed long int)(n >> 8)];

    else
      if(!(n >= 16777216))
        return 16 + (signed int)lglfloorldtab[(signed long int)(n >> 16)];

      else
        return 24 + (signed int)lglfloorldtab[(signed long int)(n >> 24)];
}

// lglflrce
// file lglib.c line 2729
static void lglflrce(struct LGL *lgl, signed int lit, signed int red, signed int lidx)
{
  lglassign(lgl, lit, red | LRGCS, lidx);
}

// lglflshrep
// file lglib.c line 5066
static void lglflshrep(struct LGL *lgl)
{
  if(!(lgl->stats->reported == 0))
  {
    if(!(lgl->stats->reported % 23 == 0))
      lglrephead(lgl);

    else
      lglprt(lgl, 1, "");
  }

}

// lglflt
// file lglib.c line 1061
static signed long int lglflt(signed int e, unsigned long int m)
{
  signed long int res;
  if(m == 0ul)
    return 0x0000000000000000ll;

  else
  {
    if(!(m >= 0x0000000100000000ull))
      while((0x0000000100000000ull & m) == 0ul)
      {
        m = m << 1;
        if(e >= -2147483647)
          e = e - 1;

        else
          break;
      }

    else
      while(m >= 8589934592ull)
      {
        m = m >> 1;
        if(e >= -2147483647)
          e = e + 1;

        else
          break;
      }
    if(!(e >= -268435456))
      return 0x0000000000000000ll;

    else
      if(e >= 1879048192)
        return 0x7fffffffffffffffll;

      else
      {
        e = e + 0x10000000;
        res = (signed long int)(m & ~0x0000000100000000ull);
        res = res | (signed long int)e << 32;
        return res;
      }
  }
}

// lglflt2str
// file lglib.c line 1094
static const char * lglflt2str(struct LGL *lgl, signed long int a)
{
  double d;
  double e;
  if(a == 0x0000000000000000ll)
    return "0";

  else
    if(a == 0x7fffffffffffffffll)
      return "inf";

    else
    {
      unsigned long int return_value_lglmnt_1;
      return_value_lglmnt_1=lglmnt(a);
      d = (double)return_value_lglmnt_1;
      d = d / (double)4294967296ll;
      signed int return_value_lglexp_2;
      return_value_lglexp_2=lglexp(a);
      e = (double)return_value_lglexp_2;
      e = e + (double)32;
      lgl->fltstr->current = lgl->fltstr->current + 1;
      if(lgl->fltstr->current == 6)
        lgl->fltstr->current = 0;

      sprintf(lgl->fltstr->str[(signed long int)lgl->fltstr->current], "%.6fd%+03.0f", d, e);
      return lgl->fltstr->str[(signed long int)lgl->fltstr->current];
    }
}

// lglflush
// file lglib.c line 9991
static signed int lglflush(struct LGL *lgl)
{
  signed int lit;
  signed int count;
  unsigned long int return_value_lglcntstk_4;
  signed int tmp_post_5;
  if(!(lgl->mt == 0))
    return 0;

  else
  {
    lglchkirrstats(lgl);
    unsigned long int return_value_lglcntstk_1;
    return_value_lglcntstk_1=lglcntstk(&lgl->trail);
    if((unsigned long int)lgl->flushed == return_value_lglcntstk_1)
      return 1;

    else
    {
      signed int return_value_lglbcp_2;
      return_value_lglbcp_2=lglbcp(lgl);
      if(return_value_lglbcp_2 == 0)
      {
        lgl->mt = 1;
        return 0;
      }

      else
      {
        signed int return_value_lglsyncunits_3;
        return_value_lglsyncunits_3=lglsyncunits(lgl);
        if(return_value_lglsyncunits_3 == 0)
          return 0;

        else
        {
          count = 0;
          do
          {
            return_value_lglcntstk_4=lglcntstk(&lgl->trail);
            if((unsigned long int)lgl->flushed >= return_value_lglcntstk_4)
              break;

            tmp_post_5 = lgl->flushed;
            lgl->flushed = lgl->flushed + 1;
            lit=lglpeek(&lgl->trail, tmp_post_5);
            lglflushclauses(lgl, lit);
            lglflushlits(lgl, -lit);
            count = count + 1;
          }
          while((_Bool)1);

        __CPROVER_DUMP_L6:
          ;
          return 1;
        }
      }
    }
  }
}

// lglflushcache
// file lglib.h line 198
void lglflushcache(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglflushcache");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "flush");
    break;
  }
  if(lgl->mt == 0)
  {
    lgl->limits->reduce.inner = lgl->opts->redlinit.val;
    lglboundredl(lgl);
    lglreduce(lgl, 1);
    lgl->limits->reduce.inner = lgl->opts->redlinit.val;
    lglboundredl(lgl);
    lgl->limits->reduce.outer = 2 * lgl->limits->reduce.inner;
    lglprt(lgl, 1, "[flush-cache] new limit %d", lgl->limits->reduce.inner);
    if(!(lgl->clone == ((struct LGL *)NULL)))
      lglflushcache(lgl->clone);

  }

}

// lglflushclauses
// file lglib.c line 9711
static signed int lglflushclauses(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int count;
  signed int glue;
  signed int res;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  signed int lidx;
  signed int glidx;
  signed int slidx;
  signed int *c;
  signed int *q;
  struct HTS *hts;
  lglchkirrstats(lgl);
  hts=lglhts(lgl, lit);
  if(hts->count == 0)
    return 0;

  else
  {
    res = 0;

  __CPROVER_DUMP_L2:
    ;
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    count = 0;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      if(!(lgl->blocking == 0))
        lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;

      if(!(lgl->eliminating == 0))
        lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;

      blit = *p;
      tag = blit & MASKCS;
      red = blit & REDCS;
      other = blit >> RMSHFT;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      if(tag == BINCS)
      {
        lglrmbwch(lgl, other, lit, red);

      __CPROVER_DUMP_L7:
        ;
        lgldeclscnt(lgl, 2, red, 0);
        if(red == 0)
        {
          lgldecocc(lgl, lit);
          lgldecocc(lgl, other);
          res = res + 1;
        }

        count = count + 1;
      }

      else
        if(tag == TRNCS)
        {
          other2 = *p;
          lglrmtwch(lgl, other2, lit, other, red);
          lglrmtwch(lgl, other, lit, other2, red);

        __CPROVER_DUMP_L10:
          ;
          lgldeclscnt(lgl, 3, red, 0);
          if(red == 0)
          {
            lgldecocc(lgl, lit);
            lgldecocc(lgl, other);
            lgldecocc(lgl, other2);
            res = res + 1;
          }

          count = count + 1;
        }

        else
        {
          if(tag == LRGCS)
          {
            lidx = *p;
            c=lglidx2lits(lgl, LRGCS, red, lidx);
            glue = red != 0 ? lidx & (1 << 4) - 1 : 0;
          }

          else
          {
            lidx = blit >> RMSHFT;
            c=lglidx2lits(lgl, OCCS, red, lidx);
            glue = 0;
          }
          other = c[(signed long int)0];
          if(!(other >= 134217727))
          {

          __CPROVER_DUMP_L15:
            ;
            if(tag == LRGCS)
            {
              if(other == lit)
                other = c[(signed long int)1];

              lglrmlwch(lgl, other, red, lidx);
            }

            else
            {
              glidx = lidx;
              if(!(red == 0))
                glidx = glidx << 4;

              if(!(c[1l] == lit))
                lglrmlwch(lgl, c[(signed long int)1], red, glidx);

              if(!(other == lit))
                lglrmlwch(lgl, other, red, glidx);

            }
            if(!(red == 0))
            {

            __CPROVER_DUMP_L21:
              ;
              c[(signed long int)-1] = 0x7fffffff;
            }

            else
              lgldecocc(lgl, lit);
            q = c;
            do
            {
              other = *q;
              if(other == 0)
                break;

              *q = 0x7fffffff;
              if(!(other == lit))
              {
                if(glue == 0 || red == 0)
                {
                  slidx = lidx;
                  if(tag == LRGCS && !(red == 0))
                    slidx = slidx >> 4;

                  lglrmlocc(lgl, other, red, slidx);
                  if(red == 0)
                    lgldecocc(lgl, other);

                }

              }

              q = q + 1l;
            }
            while((_Bool)1);
            *q = 0x7fffffff;
            lgldeclscnt(lgl, (signed int)(q - c), red, glue);
            if(red == 0)
              res = res + 1;

            count = count + 1;
          }

        }
    }
    lglshrinkhts(lgl, hts, 0);

  __CPROVER_DUMP_L31:
    ;
    lglchkirrstats(lgl);
    return res;
  }
}

// lglflushlits
// file lglib.c line 9813
static signed int lglflushlits(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int size;
  signed int satisfied;
  signed int d[3l];
  signed int glue;
  signed int *p;
  signed int *w;
  signed int *eow;
  signed int *c;
  signed int *l;
  signed int *k;
  signed int lidx;
  signed int slidx;
  signed int glidx;
  signed int count;
  signed int res;
  signed char val;
  signed char val2;
  signed long int delta;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  lglchkirrstats(lgl);
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  count = 0;
  res = count;
  p = w;
  signed int tmp_if_expr_2;
  _Bool tmp_if_expr_7;
  signed char return_value_lglval_6;
  signed int *tmp_post_8;
  signed int *tmp_post_9;
  signed int *tmp_post_10;
  for( ; !(p >= eow); p = p + 1l)
  {
    if(!(lgl->blocking == 0))
      lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;

    if(!(lgl->eliminating == 0))
      lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;

    count = count + 1;
    blit = *p;
    tag = blit & MASKCS;
    red = blit & REDCS;
    if(tag == BINCS)
    {
      other = blit >> RMSHFT;
      lglrmbwch(lgl, other, lit, red);

    __CPROVER_DUMP_L5:
      ;
      lgldeclscnt(lgl, 2, red, 0);
      if(red == 0)
      {
        if(!(lgl->dense == 0))
        {
          lgldecocc(lgl, lit);
          lgldecocc(lgl, other);
        }

        res = res + 1;
      }

    }

    else
      if(tag == TRNCS)
      {
        other = blit >> RMSHFT;
        p = p + 1l;
        other2 = *p;
        lglrmtwch(lgl, other2, lit, other, red);
        lglrmtwch(lgl, other, lit, other2, red);

      __CPROVER_DUMP_L9:
        ;
        lgldeclscnt(lgl, 3, red, 0);
        if(red == 0)
        {
          if(!(lgl->dense == 0))
          {
            lgldecocc(lgl, lit);
            lgldecocc(lgl, other);
            lgldecocc(lgl, other2);
          }

          res = res + 1;
        }

        val=lglval(lgl, other);
        val2=lglval(lgl, other2);
        if(val == 0 && val2 == 0)
        {

        __CPROVER_DUMP_L12:
          ;
          delta=lglwchbin(lgl, other, other2, red);
          signed long int return_value_lglwchbin_1;
          return_value_lglwchbin_1=lglwchbin(lgl, other2, other, red);
          delta = delta + return_value_lglwchbin_1;
          if(!(delta == 0l))
            do
            {
              p = p + delta;
              w = w + delta;
              eow = eow + delta;
            }
            while((_Bool)0);

          if(!(red == 0))
            lgl->stats->red.bin = lgl->stats->red.bin + 1;

          else
          {
            lglincirr(lgl, 2);
            if(!(lgl->dense == 0))
            {
              lglincocc(lgl, other);
              lglincocc(lgl, other2);
            }

          }
        }

      }

      else
      {
        if(tag == LRGCS)
        {
          p = p + 1l;
          tmp_if_expr_2 = *p;
        }

        else
          tmp_if_expr_2 = blit >> RMSHFT;
        lidx = tmp_if_expr_2;
        c=lglidx2lits(lgl, tag, red, lidx);
        if(!(*c >= 134217727))
        {
          satisfied = 0;
          size = satisfied;
          l = c;
          do
          {
            other = *l;
            if(other == 0)
              break;

            if(!(other == lit))
            {
              val=lglval(lgl, other);
              if((signed int)val >= 0)
              {
                if((signed int)val >= 1)
                {
                  satisfied = 1;
                  break;
                }

                if(!(size >= 3))
                  d[(signed long int)size] = other;

                size = size + 1;
              }

            }

            l = l + 1l;
          }
          while((_Bool)1);
          if(satisfied == 0 && size == 2)
          {

          __CPROVER_DUMP_L26:
            ;
            delta=lglwchbin(lgl, d[(signed long int)0], d[(signed long int)1], red);
            signed long int return_value_lglwchbin_3;
            return_value_lglwchbin_3=lglwchbin(lgl, d[(signed long int)1], d[(signed long int)0], red);
            delta = delta + return_value_lglwchbin_3;
            if(!(delta == 0l))
              do
              {
                p = p + delta;
                w = w + delta;
                eow = eow + delta;
              }
              while((_Bool)0);

            if(!(red == 0))
              lgl->stats->red.bin = lgl->stats->red.bin + 1;

            else
            {
              lglincirr(lgl, 2);
              if(!(lgl->dense == 0))
              {
                lglincocc(lgl, d[(signed long int)0]);
                lglincocc(lgl, d[(signed long int)1]);
              }

            }
          }

          if(satisfied == 0 && size == 3)
          {

          __CPROVER_DUMP_L32:
            ;
            delta=lglwchtrn(lgl, d[(signed long int)0], d[(signed long int)1], d[(signed long int)2], red);
            signed long int return_value_lglwchtrn_4;
            return_value_lglwchtrn_4=lglwchtrn(lgl, d[(signed long int)1], d[(signed long int)0], d[(signed long int)2], red);
            delta = delta + return_value_lglwchtrn_4;
            signed long int return_value_lglwchtrn_5;
            return_value_lglwchtrn_5=lglwchtrn(lgl, d[(signed long int)2], d[(signed long int)0], d[(signed long int)1], red);
            delta = delta + return_value_lglwchtrn_5;
            if(!(delta == 0l))
              do
              {
                p = p + delta;
                w = w + delta;
                eow = eow + delta;
              }
              while((_Bool)0);

            if(!(red == 0))
              lgl->stats->red.trn = lgl->stats->red.trn + 1;

            else
            {
              lglincirr(lgl, 3);
              if(!(lgl->dense == 0))
              {
                lglincocc(lgl, d[(signed long int)0]);
                lglincocc(lgl, d[(signed long int)1]);
                lglincocc(lgl, d[(signed long int)2]);
              }

            }
          }

          if(!(lgl->dense == 0))
          {
            if(red == 0)
            {
              l = c;
              do
              {
                other = *l;
                if(other == 0)
                  break;

                if(!(satisfied == 0) || !(size >= 4))
                  tmp_if_expr_7 = (_Bool)1;

                else
                {
                  return_value_lglval_6=lglval(lgl, other);
                  tmp_if_expr_7 = (signed int)return_value_lglval_6 < 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_7)
                {
                  if(red == 0)
                    lgldecocc(lgl, other);

                  if(!(other == lit))
                  {
                    slidx = lidx;
                    if(tag == LRGCS && !(red == 0))
                      slidx = slidx >> 4;

                    lglrmlocc(lgl, other, red, slidx);
                  }

                }

                l = l + 1l;
              }
              while((_Bool)1);
            }

          }

          glidx = lidx;
          if(tag == OCCS && !(red == 0))
            glidx = glidx << 4;

          if(!(*c == lit))
            lglrmlwch(lgl, c[(signed long int)0], red, glidx);

          if(!(c[1l] == lit))
            lglrmlwch(lgl, c[(signed long int)1], red, glidx);

          if(!(satisfied == 0) || !(size >= 4))
          {
            if(!(red == 0))
            {

            __CPROVER_DUMP_L48:
              ;
              c[(signed long int)-1] = 0x7fffffff;
            }

            k = c;
            do
            {
              other = *k;
              if(other == 0)
                break;

              *k = 0x7fffffff;
              k = k + 1l;
            }
            while((_Bool)1);
            *k = 0x7fffffff;
            if(!(red == 0))
            {
              glue = tag == LRGCS ? lidx & (1 << 4) - 1 : 0;
              lgl->stats->lir[(signed long int)glue].clauses = lgl->stats->lir[(signed long int)glue].clauses - 1;
              lgl->stats->red.lrg = lgl->stats->red.lrg - 1;
            }

            else
              lgldecirr(lgl, (signed int)(k - c));
          }

          else
          {
            k = c;
            l = k;
            do
            {
              other = *l;
              if(other == 0)
                break;

              val=lglval(lgl, other);
              if((signed int)val >= 0)
              {
                tmp_post_8 = k;
                k = k + 1l;
                *tmp_post_8 = other;
              }

              l = l + 1l;
            }
            while((_Bool)1);
            if(red == 0 && !(k >= l))
              lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur - (signed int)(l - k);

            tmp_post_9 = k;
            k = k + 1l;
            *tmp_post_9 = 0;
            for( ; l >= k; *tmp_post_10 = 0x7fffffff)
            {
              tmp_post_10 = k;
              k = k + 1l;
            }
            delta=lglwchlrg(lgl, c[(signed long int)0], c[(signed long int)1], red, glidx);
            signed long int return_value_lglwchlrg_11;
            return_value_lglwchlrg_11=lglwchlrg(lgl, c[(signed long int)1], c[(signed long int)0], red, glidx);
            delta = delta + return_value_lglwchlrg_11;
            if(!(delta == 0l))
              do
              {
                p = p + delta;
                w = w + delta;
                eow = eow + delta;
              }
              while((_Bool)0);

          }
        }

      }
  }
  hts=lglhts(lgl, lit);
  lglshrinkhts(lgl, hts, 0);

__CPROVER_DUMP_L65:
  ;
  lglchkirrstats(lgl);
  return res;
}

// lglflushphases
// file lglib.c line 6830
static void lglflushphases(struct LGL *lgl)
{
  signed int idx;
  signed int flushed = 0;
  struct AVar *av;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree_1;
    return_value_lglisfree_1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree_1 == 0))
    {
      av=lglavar(lgl, idx);
      if(!(av->phase == 0))
      {
        av->phase = 0;
        flushed = flushed + 1;
      }

    }

  }
  lglprt(lgl, 1, "[flushphases] %d saved phases reset", flushed);
  lgl->allphaseset = (char)!(flushed != 0);
  lgl->flushphases = (char)0;
}

// lglflushqmerged
// file lglib.c line 5839
static void lglflushqmerged(struct LGL *lgl)
{
  struct Qln *p;
  struct Qln *up;
  signed int i;
  if(!(lgl->qscheduling == 0))
  {
    if(!(lgl->queue.merged == ((struct Qln *)NULL)))
    {
      lgl->stats->queue.gcs = lgl->stats->queue.gcs + 1l;

    __CPROVER_DUMP_L3:
      ;
      i = 2;
      for( ; !(i >= lgl->nvars); i = i + 1)
        lglqln(lgl, i);
      p = lgl->queue.merged;
      for( ; !(p == ((struct Qln *)NULL)); p = up)
      {
        up = p->up;
        lgl->stats->queue.col = lgl->stats->queue.col + 1l;
        lgl->queue.nmerged = lgl->queue.nmerged - 1;
        lgl->queue.nlines = lgl->queue.nlines - 1;
        do
        {
          lgldel(lgl, (void *)p, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
          p = ((struct Qln *)NULL);
        }
        while((_Bool)0);
      }
      lgl->queue.merged = ((struct Qln *)NULL);
    }

  }

}

// lglflushremovedoccs
// file lglib.c line 4392
static void lglflushremovedoccs(struct LGL *lgl, signed int lit)
{
  struct HTS *hts;
  hts=lglhts(lgl, lit);
  signed int *w;
  w=lglhts2wchs(lgl, hts);
  signed int *eow = w + (signed long int)hts->count;
  signed int blit;
  signed int tag;
  signed int red;
  signed int lidx;
  signed int *p;
  signed int *q;
  signed int *c;
  lglrminc(lgl, w, eow);
  q = w;
  p = q;
  signed int *tmp_post_1;
  signed int *tmp_post_2;
  signed int *tmp_post_3;
  signed int tmp_if_expr_4;
  signed int *tmp_post_5;
  signed int *tmp_post_6;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    red = blit & REDCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(tag == BINCS)
    {
      tmp_post_1 = q;
      q = q + 1l;
      *tmp_post_1 = blit;
    }

    else
      if(tag == TRNCS)
      {
        tmp_post_2 = q;
        q = q + 1l;
        *tmp_post_2 = blit;
        tmp_post_3 = q;
        q = q + 1l;
        *tmp_post_3 = *p;
      }

      else
      {
        if(red == 0)
        {
          if(tag == LRGCS)
            tmp_if_expr_4 = *p;

          else
            tmp_if_expr_4 = blit >> RMSHFT;
          lidx = tmp_if_expr_4;
          c=lglidx2lits(lgl, tag, red, lidx);
          if(*c == 0x7fffffff)
            goto __CPROVER_DUMP_L8;

        }

        tmp_post_5 = q;
        q = q + 1l;
        *tmp_post_5 = blit;
        if(tag == LRGCS)
        {
          tmp_post_6 = q;
          q = q + 1l;
          *tmp_post_6 = *p;
        }

      }

  __CPROVER_DUMP_L8:
    ;
  }
  lglshrinkhts(lgl, hts, (signed int)(q - w));
}

// lglflushtimers
// file lglib.h line 278
void lglflushtimers(struct LGL *lgl)
{
  double time;
  time=lglgetime(lgl);
  double delta;
  double entered;
  double *ptr;
  signed int nest = 0;
  for( ; !(nest >= lgl->timers->nest); nest = nest + 1)
  {
    entered = lgl->timers->phase[(signed long int)nest];
    lgl->timers->phase[(signed long int)nest] = time;
    delta = time - entered;
    if(delta < 0.000000)
      delta = (double)0;

    ptr = (signed long int)lgl->timers->idx[(signed long int)nest] + (double *)lgl->times;
    *ptr = *ptr + delta;
  }
}

// lglforce
// file lglib.c line 7455
static void lglforce(struct LGL *lgl, signed int *map)
{
  signed int idx;
  signed int lit;
  signed int sign;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int size;
  signed int C;
  signed int V;
  signed int o;
  signed int min;
  signed int max;
  signed int round = 1;
  signed int first = (signed int)!(lgl->stats->force.count != 0l);
  double cog;
  double span;
  double oldspan;
  double mincut;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  struct ForceData *fdat;
  struct HTS *hts;
  struct Stk order;
  signed int return_value_lglcmpfdat_9;
  signed int return_value_lglmtstk_10;
  signed int return_value_lglcmpfdat_12;
  signed int tmp_post_13;
  signed int tmp_post_14;
  signed int return_value_lglrem_15;
  signed int return_value_lglceilld_16;
  if(!(lgl->allowforce == 0))
  {
    if(!(lgl->opts->force.val == 0))
    {
      lglstart(lgl, &lgl->times->force);
      span = (double)0x7fffffff;
      do
      {

      RESTART:
        ;
        oldspan = span;
        lgl->stats->force.count = lgl->stats->force.count + 1l;
        do
        {
          void *return_value_lglnew_1;
          return_value_lglnew_1=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(struct ForceData) /*16ul*/ );
          fdat = (struct ForceData *)return_value_lglnew_1;
        }
        while((_Bool)0);
        do
          memset((void *)&order, 0, sizeof(struct Stk) /*24ul*/ );
        while((_Bool)0);
        V = 0;
        idx = 2;
        for( ; !(idx >= lgl->nvars); idx = idx + 1)
        {
          signed int return_value_lglisfree_2;
          return_value_lglisfree_2=lglisfree(lgl, idx);
          if(!(return_value_lglisfree_2 == 0))
          {
            (fdat + (signed long int)idx)->pos = map[(signed long int)idx];
            lglpushstk(lgl, &order, idx);
            V = V + 1;
          }

        }
        if(V >= 2)
        {
          C = 0;
          span = (double)0;
          idx = 2;
          for( ; !(idx >= lgl->nvars); idx = idx + 1)
          {
            sign = -1;
            for( ; !(sign >= 2); sign = sign + 2)
            {
              lit = sign * idx;
              hts=lglhts(lgl, lit);
              w=lglhts2wchs(lgl, hts);
              eow = w + (signed long int)hts->count;
              p = w;
              for( ; !(p >= eow); p = p + 1l)
              {
                blit = *p;
                tag = blit & MASKCS;
                if(tag == TRNCS || tag == LRGCS)
                  p = p + 1l;

                if(!(tag == LRGCS))
                {
                  red = blit & REDCS;
                  if(red == 0)
                  {
                    other=abs(blit >> RMSHFT);
                    if(other >= idx)
                    {
                      if(tag == BINCS)
                      {
                        cog = (double)((fdat + (signed long int)idx)->pos + (fdat + (signed long int)other)->pos);
                        cog = cog / (double)2;
                        lglincfdat(fdat, idx, cog);
                        lglincfdat(fdat, other, cog);
                        o = (fdat + (signed long int)idx)->pos;
                        min = o;
                        max = o;
                        o = (fdat + (signed long int)other)->pos;
                        min=lglmin(min, o);
                        max=lglmax(max, o);
                        span = span + (double)(max - min);
                        C = C + 1;
                      }

                      else
                        if(tag == TRNCS)
                        {
                          other2=abs(*p);
                          if(other2 >= idx)
                          {
                            cog = (double)((fdat + (signed long int)idx)->pos + (fdat + (signed long int)other)->pos + (fdat + (signed long int)other2)->pos);
                            cog = cog / (double)3;
                            lglincfdat(fdat, idx, cog);
                            lglincfdat(fdat, other, cog);
                            lglincfdat(fdat, other2, cog);
                            o = (fdat + (signed long int)idx)->pos;
                            min = o;
                            max = o;
                            o = (fdat + (signed long int)other)->pos;
                            min=lglmin(min, o);
                            max=lglmax(max, o);
                            o = (fdat + (signed long int)other2)->pos;
                            min=lglmin(min, o);
                            max=lglmax(max, o);
                            span = span + (double)(max - min);
                            C = C + 1;
                          }

                        }

                    }

                  }

                }

              }
            }
          }
          c = lgl->irr.start;
          for( ; !(c >= lgl->irr.top); c = p + (signed long int)1)
          {
            p = c;
            if(!(*p >= 134217727))
            {
              cog = (double)0;
              do
              {
                idx=abs(*p);
                if(idx == 0)
                  break;

                cog = cog + (double)(fdat + (signed long int)idx)->pos;
                p = p + 1l;
              }
              while((_Bool)1);
              size = (signed int)(p - c);
              cog = cog / (double)size;
              min = 0x7fffffff;
              max = -0x7fffffff - 1;
              p = c;
              do
              {
                idx=abs(*p);
                if(idx == 0)
                  break;

                o = (fdat + (signed long int)idx)->pos;
                min=lglmin(min, o);
                max=lglmax(max, o);
                lglincfdat(fdat, idx, cog);
                p = p + 1l;
              }
              while((_Bool)1);
              span = span + (double)(max - min);
              C = C + 1;
            }

          }
          idx = 2;
          for( ; !(idx >= lgl->nvars); idx = idx + 1)
          {
            signed int return_value_lglisfree_3;
            return_value_lglisfree_3=lglisfree(lgl, idx);
            if(!(return_value_lglisfree_3 == 0))
            {
              size = (fdat + (signed long int)idx)->count;
              if(!(size == 0))
                (fdat + (signed long int)idx)->sum = (fdat + (signed long int)idx)->sum / (double)size;

            }

          }
          mincut = span / (double)(V - 1);
          if(C >= 1)
            span = span / (double)C;

          else
            span = (double)0;
          if(lgl->stats->force.count >= 2l)
          {
            if((double)lgl->stats->force.mincut.min > mincut)
              lgl->stats->force.mincut.min = (signed int)mincut;

            if((double)lgl->stats->force.mincut.max < mincut)
              lgl->stats->force.mincut.max = (signed int)mincut;

          }

          else
          {
            lgl->stats->force.mincut.max = (signed int)mincut;
            lgl->stats->force.mincut.min = lgl->stats->force.mincut.max;
          }
          lglprt(lgl, 1, "[force-%lld] mincut %.1f, span %.1f, %d variables, %d clauses", (signed long long int)lgl->stats->force.count, mincut, span, V, C);
          do
          {
            signed int *AA = order.start;
            signed int NN;
            unsigned long int return_value_lglcntstk_4;
            return_value_lglcntstk_4=lglcntstk(&order);
            NN = (signed int)return_value_lglcntstk_4;
            do
            {
              signed int L = 0;
              signed int R = NN - 1;
              signed int M;
              signed int LL;
              signed int RR;
              signed int I;
              if(!(R + -L >= 11))
                break;

              do
              {
                M = (L + R) / 2;
                do
                {
                  signed int TMP = AA[(signed long int)M];
                  AA[(signed long int)M] = AA[(signed long int)(R - 1)];
                  AA[(signed long int)(R - 1)] = TMP;
                }
                while((_Bool)0);
                do
                {
                  signed int return_value_lglcmpfdat_5;
                  return_value_lglcmpfdat_5=lglcmpfdat(fdat, *(&AA[(signed long int)L]), *(&AA[(signed long int)(R - 1)]));
                  if(return_value_lglcmpfdat_5 >= 1)
                    do
                    {
                      signed int lglforce__1__8__1__1__1__2__1__TMP = AA[(signed long int)L];
                      AA[(signed long int)L] = AA[(signed long int)(R - 1)];
                      AA[(signed long int)(R - 1)] = lglforce__1__8__1__1__1__2__1__TMP;
                    }
                    while((_Bool)0);

                }
                while((_Bool)0);
                do
                {
                  signed int return_value_lglcmpfdat_6;
                  return_value_lglcmpfdat_6=lglcmpfdat(fdat, *(&AA[(signed long int)L]), *(&AA[(signed long int)R]));
                  if(return_value_lglcmpfdat_6 >= 1)
                    do
                    {
                      signed int lglforce__1__8__1__1__1__3__1__TMP = AA[(signed long int)L];
                      AA[(signed long int)L] = AA[(signed long int)R];
                      AA[(signed long int)R] = lglforce__1__8__1__1__1__3__1__TMP;
                    }
                    while((_Bool)0);

                }
                while((_Bool)0);
                do
                {
                  signed int return_value_lglcmpfdat_7;
                  return_value_lglcmpfdat_7=lglcmpfdat(fdat, *(&AA[(signed long int)(R - 1)]), *(&AA[(signed long int)R]));
                  if(return_value_lglcmpfdat_7 >= 1)
                    do
                    {
                      signed int lglforce__1__8__1__1__1__4__1__TMP = AA[(signed long int)(R - 1)];
                      AA[(signed long int)(R - 1)] = AA[(signed long int)R];
                      AA[(signed long int)R] = lglforce__1__8__1__1__1__4__1__TMP;
                    }
                    while((_Bool)0);

                }
                while((_Bool)0);
                do
                {
                  signed int PIVOT;
                  signed int J = R - 1;
                  I = (L + 1) - 1;
                  PIVOT = AA[(signed long int)J];
                  do
                  {

                  __CPROVER_DUMP_L49:
                    ;
                    I = I + 1;
                    signed int return_value_lglcmpfdat_8;
                    return_value_lglcmpfdat_8=lglcmpfdat(fdat, *(&AA[(signed long int)I]), *(&PIVOT));
                    if(!(return_value_lglcmpfdat_8 >= 0))
                      goto __CPROVER_DUMP_L49;

                    do
                    {
                      J = J - 1;
                      return_value_lglcmpfdat_9=lglcmpfdat(fdat, *(&PIVOT), *(&AA[(signed long int)J]));
                      if(return_value_lglcmpfdat_9 >= 0)
                        break;

                      if(J == 1 + L)
                        break;

                    }
                    while((_Bool)1);
                    if(I >= J)
                      break;

                    do
                    {
                      signed int lglforce__1__8__1__1__1__5__1__1__1__TMP = AA[(signed long int)I];
                      AA[(signed long int)I] = AA[(signed long int)J];
                      AA[(signed long int)J] = lglforce__1__8__1__1__1__5__1__1__1__TMP;
                    }
                    while((_Bool)0);
                  }
                  while((_Bool)1);
                  do
                  {
                    signed int lglforce__1__8__1__1__1__5__2__TMP = AA[(signed long int)I];
                    AA[(signed long int)I] = AA[(signed long int)(R - 1)];
                    AA[(signed long int)(R - 1)] = lglforce__1__8__1__1__1__5__2__TMP;
                  }
                  while((_Bool)0);
                }
                while((_Bool)0);
                if(!(I + -L >= R + -I))
                {
                  LL = I + 1;
                  RR = R;
                  R = I - 1;
                }

                else
                {
                  LL = L;
                  RR = I - 1;
                  L = I + 1;
                }
                if(R + -L >= 11)
                {
                  lglpushstk(lgl, &lgl->_anon1.sortstk, LL);
                  lglpushstk(lgl, &lgl->_anon1.sortstk, RR);
                }

                else
                  if(RR + -LL >= 11)
                  {
                    L = LL;
                    R = RR;
                  }

                  else
                  {
                    return_value_lglmtstk_10=lglmtstk(&lgl->_anon1.sortstk);
                    if(return_value_lglmtstk_10 == 0)
                    {
                      R=lglpopstk(&lgl->_anon1.sortstk);
                      L=lglpopstk(&lgl->_anon1.sortstk);
                    }

                    else
                      break;
                  }
              }
              while((_Bool)1);
            }
            while((_Bool)0);
            do
            {
              signed int lglforce__1__8__2__PIVOT;
              signed int lglforce__1__8__2__L = 0;
              signed int lglforce__1__8__2__R = NN - 1;
              signed int lglforce__1__8__2__I;
              signed int lglforce__1__8__2__J;
              lglforce__1__8__2__I = lglforce__1__8__2__R;
              for( ; !(lglforce__1__8__2__L >= lglforce__1__8__2__I); lglforce__1__8__2__I = lglforce__1__8__2__I - 1)
                do
                {
                  signed int return_value_lglcmpfdat_11;
                  return_value_lglcmpfdat_11=lglcmpfdat(fdat, *(&AA[(signed long int)(lglforce__1__8__2__I - 1)]), *(&AA[(signed long int)lglforce__1__8__2__I]));
                  if(return_value_lglcmpfdat_11 >= 1)
                    do
                    {
                      signed int lglforce__1__8__2__1__1__1__TMP = AA[(signed long int)(lglforce__1__8__2__I - 1)];
                      AA[(signed long int)(lglforce__1__8__2__I - 1)] = AA[(signed long int)lglforce__1__8__2__I];
                      AA[(signed long int)lglforce__1__8__2__I] = lglforce__1__8__2__1__1__1__TMP;
                    }
                    while((_Bool)0);

                }
                while((_Bool)0);
              lglforce__1__8__2__I = lglforce__1__8__2__L + 2;
              for( ; lglforce__1__8__2__R >= lglforce__1__8__2__I; lglforce__1__8__2__I = lglforce__1__8__2__I + 1)
              {
                lglforce__1__8__2__J = lglforce__1__8__2__I;
                lglforce__1__8__2__PIVOT = AA[(signed long int)lglforce__1__8__2__I];
                do
                {
                  return_value_lglcmpfdat_12=lglcmpfdat(fdat, *(&lglforce__1__8__2__PIVOT), *(&AA[(signed long int)(lglforce__1__8__2__J - 1)]));
                  if(return_value_lglcmpfdat_12 >= 0)
                    break;

                  AA[(signed long int)lglforce__1__8__2__J] = AA[(signed long int)(lglforce__1__8__2__J - 1)];
                  lglforce__1__8__2__J = lglforce__1__8__2__J - 1;
                }
                while((_Bool)1);
                AA[(signed long int)lglforce__1__8__2__J] = lglforce__1__8__2__PIVOT;
              }
            }
            while((_Bool)0);

          __CPROVER_DUMP_L71:
            ;
          }
          while((_Bool)0);
          o = 2;
          p = order.start;
          for( ; !(p >= order.top); p = p + 1l)
          {
            idx = *p;

          __CPROVER_DUMP_L73:
            ;
            tmp_post_13 = o;
            o = o + 1;
            map[(signed long int)idx] = tmp_post_13;
          }
        }

        do
        {

        DONE:
          ;
          lgldel(lgl, (void *)fdat, (unsigned long int)lgl->nvars * sizeof(struct ForceData) /*16ul*/ );
          fdat = ((struct ForceData *)NULL);
        }
        while((_Bool)0);
        lglrelstk(lgl, &order);
        if(first == 0)
          goto __CPROVER_DUMP_L75;

        tmp_post_14 = round;
        round = round + 1;
        if(!(tmp_post_14 >= lgl->opts->force.val))
          goto RESTART;

        return_value_lglrem_15=lglrem(lgl);
        return_value_lglceilld_16=lglceilld(return_value_lglrem_15);
        if(!(round >= return_value_lglceilld_16))
          goto RESTART;

      }
      while(oldspan + -span > oldspan / 100.0 && oldspan > span);

    __CPROVER_DUMP_L75:
      ;
      lglstop(lgl);
    }

  }

}

// lglfork
// file lglib.h line 72
struct LGL * lglfork(struct LGL *lgl, signed int complete)
{
  struct LGL *return_value_lglforkaux_1;
  return_value_lglforkaux_1=lglforkaux(lgl, 0, complete);
  return return_value_lglforkaux_1;
}

// lglforkaux
// file lglib.c line 18955
static struct LGL * lglforkaux(struct LGL *lgl, signed int brutefork, signed int complete)
{
  signed int nass;
  signed int elit;
  const signed int *p;
  struct LGL *res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglforkaux");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->forked == 0))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglforkaux");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not fork twice yet");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lglstart(lgl, &lgl->times->all);
  lglrep(lgl, 1, (char)102);
  signed int return_value_lglbcp_1;
  if(lgl->mt == 0)
  {
    return_value_lglbcp_1=lglbcp(lgl);
    if(return_value_lglbcp_1 == 0)
      lgl->mt = 1;

  }

  if(lgl->mt == 0)
    lglgc(lgl);

  res=lglminit(lgl->mem->state, lgl->mem->alloc, lgl->mem->realloc, lgl->mem->dealloc);
  lglcpyopts(res, lgl);
  lglctrav(lgl, (void *)res, (void (*)(void *, signed int))lgleadd);
  if(res->mt == 0)
    lglrtrav(lgl, (void *)res, (void (*)(void *, signed int, signed int))lglfjradd);

  if(!(complete == 0))
    lglcompletefork(res, lgl);

  unsigned long int return_value_lglcntstk_2;
  return_value_lglcntstk_2=lglcntstk(&lgl->assume);
  nass = (signed int)return_value_lglcntstk_2;
  res->bruteforked = (char)(nass != 0 && brutefork != 0);
  if(!(res->bruteforked == 0))

    __CPROVER_DUMP_L11:
      ;

  else

    __CPROVER_DUMP_L12:
      ;
  p = lgl->eassume.start;
  for( ; !(p >= lgl->eassume.top); p = p + 1l)
  {
    elit = *p;
    lglpushstk(res, &res->fassume, elit);
    if(res->bruteforked == 0)
      lglassume(res, elit);

    else
    {
      lglfjadd(res, elit);
      lglfjadd(res, 0);
    }
  }
  lgl->forked = (char)1;
  lglstop(lgl);
  return res;
}

// lglforkmerge
// file lglib.c line 18996
static void lglforkmerge(struct LGL *to, struct LGL *from)
{
  const signed int *p;
  struct Trv travstate;
  if(from->bruteforked == 0)
  {
    travstate.state = (void *)to;
    travstate.trav = (void (*)(void *, signed int))lgleadd;
    lglutrav(from, (void *)&travstate, lgltravallu);
    lgletrav(from, (void *)&travstate, lgltravalle);
  }

  p = from->fassume.start;
  for( ; !(p >= from->fassume.top); p = p + 1l)
    lgleassume(to, *p);
}

// lglfreewch
// file lglib.c line 3018
static void lglfreewch(struct LGL *lgl, signed int oldoffset, signed int oldhcount)
{
  signed int ldoldhcount;
  ldoldhcount=lglceilld(oldhcount);
  lgl->wchs->stk.start[(signed long int)oldoffset] = lgl->wchs->start[(signed long int)ldoldhcount];
  lgl->wchs->start[(signed long int)ldoldhcount] = oldoffset;
  lgl->wchs->free = lgl->wchs->free + 1;

__CPROVER_DUMP_L1:
  ;
}

// lglfreeze
// file lglib.h line 262
void lglfreeze(struct LGL *lgl, signed int elit)
{
  struct Ext *ext;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfreeze");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "freeze %d", elit);
    break;
  }
  lgl->stats->calls.freeze = lgl->stats->calls.freeze + 1l;
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfreeze");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not freeze zero literal");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }

__CPROVER_DUMP_L8:
  ;
  do
  {
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfreeze");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

    while((2039 & (signed int)lgl->state) == 0)
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfreeze");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "!(%s)", (const void *)"UNUSED|OPTSET|USED|RESET|SATISFIED|UNSATISFIED|FAILED|LOOKED| UNKNOWN|EXTENDED");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
  }
  while((_Bool)0);

__CPROVER_DUMP_L14:
  ;
  lglimport(lgl, elit);
  ext=lglelit2ext(lgl, elit);
  while(!(ext->melted == 0u))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfreeze");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "freezing melted literal %d", elit);
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  while(ext->frozen == 0x7fffffff)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfreeze");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "literal %d frozen too often", elit);
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  ext->frozen = ext->frozen + 1;
  if(ext->frozen == 0)
    lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;

  lglmelter(lgl);
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglfreeze(lgl->clone, elit);

}

// lglfreezer
// file lglib.c line 8118
static void lglfreezer(struct LGL *lgl)
{
  signed int frozen;
  signed int melted;
  signed int tmpfrozen;
  signed int elit;
  signed int erepr;
  struct Ext *ext;
  struct Ext *rext;
  signed int *p;
  signed int eass;
  if(lgl->frozen == 0)
  {
    elit = 1;
    for( ; lgl->maxext >= elit; elit = elit + 1)
      (lgl->ext + (signed long int)elit)->tmpfrozen = (unsigned int)0;
    frozen = 0;
    tmpfrozen = frozen;
    signed int return_value_lglmtstk_1;
    return_value_lglmtstk_1=lglmtstk(&lgl->eassume);
    if(return_value_lglmtstk_1 == 0)
    {
      p = lgl->eassume.start;
      for( ; !(p >= lgl->eassume.top); p = p + 1l)
      {
        eass = *p;
        ext=lglelit2ext(lgl, eass);
        if(ext->frozen == 0)
        {
          if(ext->tmpfrozen == 0u)
          {
            ext->tmpfrozen = (unsigned int)1;
            tmpfrozen = tmpfrozen + 1;

          __CPROVER_DUMP_L5:
            ;
            erepr=lglerepr(lgl, eass);
            rext=lglelit2ext(lgl, erepr);
            if(!(ext == rext))
            {
              if(rext->frozen == 0)
              {
                if(rext->tmpfrozen == 0u)
                {

                __CPROVER_DUMP_L6:
                  ;
                  rext->tmpfrozen = (unsigned int)1;
                  tmpfrozen = tmpfrozen + 1;
                }

              }

            }

          }

        }

      }
    }

    elit = 1;
    for( ; lgl->maxext >= elit; elit = elit + 1)
    {
      ext=lglelit2ext(lgl, elit);
      if(!(ext->frozen == 0))
      {
        frozen = frozen + 1;
        erepr=lglerepr(lgl, elit);
        rext=lglelit2ext(lgl, erepr);
        if(!(ext == rext))
        {
          if(rext->frozen == 0)
          {
            if(rext->tmpfrozen == 0u)
            {

            __CPROVER_DUMP_L10:
              ;
              rext->tmpfrozen = (unsigned int)1;
              tmpfrozen = tmpfrozen + 1;
            }

          }

        }

      }

    }
    melted = 0;
    elit = 1;
    for( ; lgl->maxext >= elit; elit = elit + 1)
    {
      ext=lglelit2ext(lgl, elit);
      if(ext->frozen == 0)
      {
        if(ext->melted == 0u)
        {
          if(ext->tmpfrozen == 0u)
          {

          __CPROVER_DUMP_L14:
            ;
            ext->melted = (unsigned int)1;
            melted = melted + 1;
          }

        }

      }

    }

  __CPROVER_DUMP_L16:
    ;

  __CPROVER_DUMP_L17:
    ;

  __CPROVER_DUMP_L18:
    ;
    lgl->frozen = (char)1;
  }


__CPROVER_DUMP_L19:
  ;
}

// lglfullctk
// file lglib.c line 1540
static signed int lglfullctk(struct Ctk *ctk)
{
  return (signed int)(ctk->top == ctk->end);
}

// lglfullstk
// file lglib.c line 1386
static signed int lglfullstk(struct Stk *s)
{
  return (signed int)(s->top == s->end);
}

// lglfullwtk
// file lglib.c line 14989
static signed int lglfullwtk(struct Wtk *wtk)
{
  return (signed int)(wtk->top == wtk->end);
}

// lglfullyconnected
// file lglib.c line 6566
static void lglfullyconnected(struct LGL *lgl)
{
  if(!(lgl->notfullyconnected == 0))
  {

  __CPROVER_DUMP_L1:
    ;
    lgl->notfullyconnected = (char)0;
  }

}

// lglfuncpy
// file lglib.c line 10507
static void lglfuncpy(unsigned long int *dst, unsigned long int *src)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    dst[(signed long int)i] = src[(signed long int)i];
}

// lglgat2idx
// file lglib.c line 12373
static signed int lglgat2idx(struct LGL *lgl, struct Gat *g)
{
  return (signed int)(g - lgl->_anon0.cgr->gates);
}

// lglgateextract
// file lglib.c line 12951
static void lglgateextract(struct LGL *lgl)
{
  signed int idx;
  signed int count;

__CPROVER_DUMP_L1:
  ;
  lglrandidxtrav(lgl, lglcgextractidx);
  count = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
    count = count + (signed int)(lgl->avars + (signed long int)idx)->gate;
  if(!(lgl->_anon0.cgr->extracted.units == 0))
    lglprt(lgl, 2, "[extract-%d] extracted %d units", lgl->stats->cgr.count, lgl->_anon0.cgr->extracted.units);

  if(!(lgl->_anon0.cgr->extracted.eq == 0))
    lglprt(lgl, 2, "[extract-%d] extracted %d equivalences", lgl->stats->cgr.count, lgl->_anon0.cgr->extracted.eq);

  double return_value_lglpcnt_1;
  if(!(lgl->_anon0.cgr->extracted.all == 0))
  {
    return_value_lglpcnt_1=lglpcnt((double)count, (double)lgl->nvars);
    lglprt(lgl, 2, "[extract-%d] extracted %d gates for %d variables %.0f%%", lgl->stats->cgr.count, lgl->_anon0.cgr->extracted.all, count, return_value_lglpcnt_1);
  }

  double return_value_lglpcnt_2;
  if(!(lgl->_anon0.cgr->extracted.and == 0))
  {
    return_value_lglpcnt_2=lglpcnt((double)lgl->_anon0.cgr->extracted.and, (double)lgl->_anon0.cgr->extracted.all);
    lglprt(lgl, 2, "[extract-%d] %d and gates %.0f%% of all extracted gates", lgl->stats->cgr.count, lgl->_anon0.cgr->extracted.and, return_value_lglpcnt_2);
  }

  double return_value_lglpcnt_3;
  if(!(lgl->_anon0.cgr->extracted.xor == 0))
  {
    return_value_lglpcnt_3=lglpcnt((double)lgl->_anon0.cgr->extracted.xor, (double)lgl->_anon0.cgr->extracted.all);
    lglprt(lgl, 2, "[extract-%d] %d xor gates %.0f%% of all extracted gates", lgl->stats->cgr.count, lgl->_anon0.cgr->extracted.xor, return_value_lglpcnt_3);
  }

  double return_value_lglpcnt_4;
  if(!(lgl->_anon0.cgr->extracted.ite == 0))
  {
    return_value_lglpcnt_4=lglpcnt((double)lgl->_anon0.cgr->extracted.ite, (double)lgl->_anon0.cgr->extracted.all);
    lglprt(lgl, 2, "[extract-%d] %d ite gates %.0f%% of all extracted gates", lgl->stats->cgr.count, lgl->_anon0.cgr->extracted.ite, return_value_lglpcnt_4);
  }

}

// lglgauss
// file lglib.c line 16810
static signed int lglgauss(struct LGL *lgl)
{
  signed int oldunits;
  signed int oldequivs;
  signed int oldtrneqs;
  signed int units;
  signed int equivs;
  signed int trneqs;
  signed int success;
  signed int return_value_lglterminate_4;
  _Bool tmp_if_expr_3;
  signed int return_value_lglbcp_2;
  signed int return_value_lglterminate_6;
  if(!(lgl->mt == 0))
    return 0;

  else
    if(!(lgl->nvars >= 3))
      return 1;

    else
    {
      lglstart(lgl, &lgl->times->gauss);
      lgl->gaussing = (char)1;
      lgl->simp = lgl->gaussing;
      lgl->stats->gauss.count = lgl->stats->gauss.count + 1;
      lglsetgausslim(lgl);
      lglgaussinit(lgl);
      lglgaussextract(lgl);
      oldunits = lgl->stats->gauss.units;
      oldequivs = lgl->stats->gauss.equivs;
      oldtrneqs = lgl->stats->gauss.trneqs;
      signed int return_value_lglmtstk_5;
      return_value_lglmtstk_5=lglmtstk(&lgl->_anon0.gauss->xors);
      if(return_value_lglmtstk_5 == 0)
      {
        lglgaussconnect(lgl);
        lglgaussorder(lgl);
        lglsetgausslim(lgl);
        lglgausselim(lgl);
        if(lgl->mt == 0)
        {
          return_value_lglterminate_4=lglterminate(lgl);
          if(return_value_lglterminate_4 == 0)
          {
            if(lgl->opts->verbose.val >= 3)
              lglgdump(lgl);

            lglgaussdisconnect(lgl);
            signed int return_value_lglgaussexport_1;
            return_value_lglgaussexport_1=lglgaussexport(lgl);
            if(return_value_lglgaussexport_1 == 0)
              tmp_if_expr_3 = (_Bool)1;

            else
            {
              return_value_lglbcp_2=lglbcp(lgl);
              tmp_if_expr_3 = !(return_value_lglbcp_2 != 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_3)
              lgl->mt = 1;

            else
              if(!(lgl->stats->gauss.steps.extr >= lgl->limits->gauss.steps.extr))
              {
                if(!(lgl->stats->gauss.steps.elim >= lgl->limits->gauss.steps.elim))
                  lglprt(lgl, 1, "[gauss-%d] fully completed", lgl->stats->gauss.count);

              }

          }

        }

      }

      lglgaussreset(lgl);
      units = lgl->stats->gauss.units - oldunits;
      equivs = lgl->stats->gauss.equivs - oldequivs;
      trneqs = lgl->stats->gauss.trneqs - oldtrneqs;
      success = (signed int)(units != 0 || equivs != 0);
      if(lgl->mt == 0)
      {
        if(!(success == 0))
        {
          return_value_lglterminate_6=lglterminate(lgl);
          if(return_value_lglterminate_6 == 0)
            lgldecomp(lgl);

        }

      }

      if(!(trneqs == 0))
        success = 1;

      if(!(lgl->mt == 0))
        lglprt(lgl, 1, "[gauss-%d] proved unsatisfiability", lgl->stats->gauss.count);

      else
        lglprt(lgl, 1, "[gauss-%d] exported %d unary, %d binary and %d ternary equations", lgl->stats->gauss.count, units, equivs, trneqs);
      lglupdgausspen(lgl, success);
      lglrep(lgl, 1, (char)71);
      lgl->gaussing = (char)0;
      lgl->simp = lgl->gaussing;
      lglstop(lgl);
      return (signed int)!(lgl->mt != 0);
    }
}

// lglgaussaddeqn
// file lglib.c line 16557
static signed int lglgaussaddeqn(struct LGL *lgl, signed int eqn)
{
  const signed int *p;
  struct AVar *av;
  signed int var;
  p = lgl->_anon0.gauss->xors.start + (signed long int)eqn;
  do
  {
    var = *p;
    if(!(var >= 2))
      break;

    av=lglavar(lgl, var);
    if(av->mark == 0)
      lglpushstk(lgl, &lgl->clause, var);

    av->mark = (signed int)!(av->mark != 0);
    p = p + 1l;
  }
  while((_Bool)1);
  return var;
}

// lglgausschkeliminated
// file lglib.c line 16606
static void lglgausschkeliminated(struct LGL *lgl)
{
  ;
}

// lglgaussconeqn
// file lglib.c line 16413
static void lglgaussconeqn(struct LGL *lgl, signed int eqn)
{
  const signed int *xors = lgl->_anon0.gauss->xors.start;
  signed int i;
  signed int var;
  lgl->stats->gauss.steps.elim = lgl->stats->gauss.steps.elim + 1l;
  i = eqn;
  do
  {
    var = xors[(signed long int)i];
    if(!(var >= 2))
      break;

    lglpushstk(lgl, lgl->_anon0.gauss->occs + (signed long int)var, eqn);
    i = i + 1;
  }
  while((_Bool)1);
}

// lglgaussconnect
// file lglib.c line 16433
static void lglgaussconnect(struct LGL *lgl)
{
  signed int c;
  signed int i;
  signed int eox;
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(&lgl->_anon0.gauss->xors);
  eox = (signed int)return_value_lglcntstk_1;
  signed int connected;
  signed int var;
  signed int vars;
  const signed int *xors = lgl->_anon0.gauss->xors.start;
  struct Stk *occs;

__CPROVER_DUMP_L1:
  ;
  do
  {
    void *return_value_lglnew_2;
    return_value_lglnew_2=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(struct Stk) /*24ul*/ );
    lgl->_anon0.gauss->occs = (struct Stk *)return_value_lglnew_2;
  }
  while((_Bool)0);
  connected = 0;
  vars = connected;
  c = 0;
  for( ; !(c >= eox); c = i + 1)
  {
    lgl->stats->gauss.steps.elim = lgl->stats->gauss.steps.elim + 1l;
    i = c;
    do
    {
      var = xors[(signed long int)i];
      if(!(var >= 2))
        break;

      occs = lgl->_anon0.gauss->occs + (signed long int)var;
      signed int return_value_lglmtstk_3;
      return_value_lglmtstk_3=lglmtstk(occs);
      if(!(return_value_lglmtstk_3 == 0))
        vars = vars + 1;

      lglpushstk(lgl, lgl->_anon0.gauss->occs + (signed long int)var, c);
      connected = connected + 1;
      i = i + 1;
    }
    while((_Bool)1);
  }
  double return_value_lglavg_4;
  return_value_lglavg_4=lglavg((double)connected, (double)vars);
  lglprt(lgl, 1, "[gauss-%d] connected %d occurrences of %d variables (average %.1f)", lgl->stats->gauss.count, connected, vars, return_value_lglavg_4);
}

// lglgaussdisconnect
// file lglib.c line 16467
static void lglgaussdisconnect(struct LGL *lgl)
{
  signed int idx;

__CPROVER_DUMP_L1:
  ;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
    lglrelstk(lgl, lgl->_anon0.gauss->occs + (signed long int)idx);
  do
  {
    lgldel(lgl, (void *)lgl->_anon0.gauss->occs, (unsigned long int)lgl->nvars * sizeof(struct Stk) /*24ul*/ );
    lgl->_anon0.gauss->occs = ((struct Stk *)NULL);
  }
  while((_Bool)0);
}

// lglgaussdiseqn
// file lglib.c line 16421
static void lglgaussdiseqn(struct LGL *lgl, signed int eqn)
{
  signed int *xors = lgl->_anon0.gauss->xors.start;
  signed int i;
  signed int var;
  i = eqn;
  do
  {
    var = xors[(signed long int)i];
    if(!(var >= 2))
      break;

    xors[(signed long int)i] = 0x7fffffff >> RMSHFT;
    lgl->_anon0.gauss->garbage = lgl->_anon0.gauss->garbage + 1;
    lgl->stats->gauss.steps.elim = lgl->stats->gauss.steps.elim + 1l;
    lglrmstk(lgl->_anon0.gauss->occs + (signed long int)var, eqn);
    i = i + 1;
  }
  while((_Bool)1);
  xors[(signed long int)i] = 0x7fffffff >> RMSHFT;
  lgl->_anon0.gauss->garbage = lgl->_anon0.gauss->garbage + 1;
}

// lglgausselim
// file lglib.c line 16667
static void lglgausselim(struct LGL *lgl)
{
  signed int pivot;
  signed int changed = 1;
  unsigned long int return_value_lglcntstk_1;
  signed int tmp_post_3;
  while(lgl->mt == 0)
  {
    return_value_lglcntstk_1=lglcntstk(&lgl->_anon0.gauss->order);
    if((unsigned long int)lgl->_anon0.gauss->next >= return_value_lglcntstk_1)
      break;

    if(lgl->stats->gauss.steps.elim >= lgl->limits->gauss.steps.elim)
      break;

    signed int return_value_lglterminate_2;
    return_value_lglterminate_2=lglterminate(lgl);
    if(!(return_value_lglterminate_2 == 0))
      break;

    if(!(changed == 0))
      lglgaussort(lgl);

    tmp_post_3 = lgl->_anon0.gauss->next;
    lgl->_anon0.gauss->next = lgl->_anon0.gauss->next + 1;
    pivot=lglpeek(&lgl->_anon0.gauss->order, tmp_post_3);
    changed=lglgausselimvar(lgl, pivot);
  }
}

// lglgausselimvar
// file lglib.c line 16637
static signed int lglgausselimvar(struct LGL *lgl, signed int pivot)
{
  signed int subst;
  signed int changed;
  signed int occs;
  signed int eliminated;

__CPROVER_DUMP_L1:
  ;
  occs=lglgaussoccs(lgl, pivot);
  if(occs == 0)
  {

  __CPROVER_DUMP_L2:
    ;
    eliminated = 2;
    changed = 0;
  }

  else
    if(occs == 1)
    {

    __CPROVER_DUMP_L4:
      ;
      eliminated = 1;
      changed = 0;
    }

    else
    {
      lglgaussgc(lgl);
      subst=lglgausspickeqn(lgl, pivot);
      if(subst >= 0)
      {
        lglgaussubst(lgl, pivot, subst);
        eliminated = 1;
        changed = 1;
      }

      else
      {
        eliminated = 3;
        changed = 0;
      }
    }
  lgl->_anon0.gauss->eliminated[(signed long int)pivot] = (signed char)eliminated;
  lglgausschkeliminated(lgl);
  return changed;
}

// lglgaussexp2
// file lglib.c line 16692
static signed int lglgaussexp2(struct LGL *lgl, signed int a, signed int b)
{
  signed int return_value_lglhasbin_1;
  return_value_lglhasbin_1=lglhasbin(lgl, a, b);
  if(!(return_value_lglhasbin_1 == 0))
    return 0;

  else
  {
    lglpushstk(lgl, &lgl->clause, a);
    lglpushstk(lgl, &lgl->clause, b);
    lglpushstk(lgl, &lgl->clause, 0);

  __CPROVER_DUMP_L2:
    ;
    lgladdcls(lgl, REDCS, 0, 0);
    lglclnstk(&lgl->clause);
    return 1;
  }
}

// lglgaussexp3
// file lglib.c line 16708
static signed int lglgaussexp3(struct LGL *lgl, signed int a, signed int b, signed int c)
{
  signed int return_value_lglhastrn_1;
  return_value_lglhastrn_1=lglhastrn(lgl, a, b, c);
  if(!(return_value_lglhastrn_1 == 0))
    return 0;

  else
  {
    lglpushstk(lgl, &lgl->clause, a);
    lglpushstk(lgl, &lgl->clause, b);
    lglpushstk(lgl, &lgl->clause, c);
    lglpushstk(lgl, &lgl->clause, 0);

  __CPROVER_DUMP_L2:
    ;
    lgladdcls(lgl, REDCS, 0, 0);
    lglclnstk(&lgl->clause);
    return 1;
  }
}

// lglgaussexport
// file lglib.c line 16725
static signed int lglgaussexport(struct LGL *lgl)
{
  signed int var;
  signed int size;
  signed int val;
  signed int rhs;
  signed int unit;
  signed int a;
  signed int b;
  signed int c;
  signed int exported;
  const signed int *e;
  const signed int *p;
  const signed int *q;
  e = lgl->_anon0.gauss->xors.start;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_5;
  for( ; !(e >= lgl->_anon0.gauss->xors.top); e = p + (signed long int)1)
  {
    p = e;
    if(!(*p >= 134217727))
    {
      do
      {
        var = *p;
        if(!(var >= 2))
          break;

        p = p + 1l;
      }
      while((_Bool)1);
      rhs = *p;
      q = e;
      for( ; !(q >= p); q = q + 1l)
      {
        var = *q;
        signed char return_value_lglval_1;
        return_value_lglval_1=lglval(lgl, var);
        val = (signed int)return_value_lglval_1;
        if(val >= 0)
        {
          if(val >= 1)
            rhs = (signed int)!(rhs != 0);

          else
            lglpushstk(lgl, &lgl->clause, var);
        }

      }
      unsigned long int return_value_lglcntstk_2;
      return_value_lglcntstk_2=lglcntstk(&lgl->clause);
      size = (signed int)return_value_lglcntstk_2;
      if(!(rhs == 0) || !(size == 0))
      {
        if(size == 0 && !(rhs == 0))
        {

        __CPROVER_DUMP_L10:
          ;
          return 0;
        }

        if(size >= 1)
          tmp_if_expr_3 = lgl->clause.start[(signed long int)0];

        else
          tmp_if_expr_3 = 0;
        a = tmp_if_expr_3;
        if(size >= 2)
          tmp_if_expr_4 = lgl->clause.start[(signed long int)1];

        else
          tmp_if_expr_4 = 0;
        b = tmp_if_expr_4;
        if(size >= 3)
          tmp_if_expr_5 = lgl->clause.start[(signed long int)2];

        else
          tmp_if_expr_5 = 0;
        c = tmp_if_expr_5;
        lglclnstk(&lgl->clause);
        if(size == 1)
        {
          unit = a;
          if(rhs == 0)
            unit = -unit;


        __CPROVER_DUMP_L18:
          ;
          lgl->stats->gauss.units = lgl->stats->gauss.units + 1;
          lglunit(lgl, unit);
        }

        else
          if(size == 2)
          {
            if(!(rhs == 0))
              b = -b;

            exported=lglgaussexp2(lgl, -a, b);
            signed int return_value_lglgaussexp2_6;
            return_value_lglgaussexp2_6=lglgaussexp2(lgl, a, -b);
            exported = exported | return_value_lglgaussexp2_6;
            if(!(exported == 0))
            {

            __CPROVER_DUMP_L21:
              ;
              lgl->stats->gauss.equivs = lgl->stats->gauss.equivs + 1;
            }

          }

          else
            if(size == 3)
            {
              if(!(lgl->opts->gaussexptrn.val == 0))
              {
                if(rhs == 0)
                  c = -c;

                exported=lglgaussexp3(lgl, a, b, c);
                signed int return_value_lglgaussexp3_7;
                return_value_lglgaussexp3_7=lglgaussexp3(lgl, a, -b, -c);
                exported = exported | return_value_lglgaussexp3_7;
                signed int return_value_lglgaussexp3_8;
                return_value_lglgaussexp3_8=lglgaussexp3(lgl, -a, b, -c);
                exported = exported | return_value_lglgaussexp3_8;
                signed int return_value_lglgaussexp3_9;
                return_value_lglgaussexp3_9=lglgaussexp3(lgl, -a, -b, c);
                exported = exported | return_value_lglgaussexp3_9;
                if(!(exported == 0))
                {

                __CPROVER_DUMP_L25:
                  ;
                  lgl->stats->gauss.trneqs = lgl->stats->gauss.trneqs + 1;
                }

              }

            }

      }

    }

  }
  return 1;
}

// lglgaussextract
// file lglib.c line 16477
static void lglgaussextract(struct LGL *lgl)
{
  signed int extracted;
  signed int lglgaussextract__1__lits;
  if(!(lgl->level == 0))
    lglbacktrack(lgl, 0);

  lglgc(lgl);
  if(lgl->mt == 0)
  {
    lgldense(lgl, 1);
    extracted=lglgaussextractsmall(lgl);
    signed int return_value_lglgaussextractlarge_1;
    return_value_lglgaussextractlarge_1=lglgaussextractlarge(lgl);
    extracted = extracted + return_value_lglgaussextractlarge_1;
    unsigned long int return_value_lglcntstk_2;
    return_value_lglcntstk_2=lglcntstk(&lgl->_anon0.gauss->xors);
    lglgaussextract__1__lits = (signed int)(return_value_lglcntstk_2 - (unsigned long int)extracted);
    double return_value_lglavg_3;
    return_value_lglavg_3=lglavg((double)lglgaussextract__1__lits, (double)extracted);
    lglprt(lgl, 1, "[gauss-%d] extracted %d xors of average arity %.1f", lgl->stats->gauss.count, extracted, return_value_lglavg_3);
    lglsparse(lgl);
    lglgc(lgl);
    if(lgl->mt == 0)
      lglfitstk(lgl, &lgl->_anon0.gauss->xors);

  }

}

// lglgaussextractlarge
// file lglib.c line 16401
static signed int lglgaussextractlarge(struct LGL *lgl)
{
  const signed int *p;
  const signed int *c;
  signed int res = 0;
  c = lgl->irr.start;
  for( ; !(c >= lgl->irr.top); c = p + (signed long int)1)
  {
    if(lgl->stats->gauss.steps.extr >= lgl->limits->gauss.steps.extr)
      break;

    p = c;
    if(!(*p >= 134217727))
    {
      signed int return_value_lglgaussextractxor_1;
      return_value_lglgaussextractxor_1=lglgaussextractxor(lgl, c);
      res = res + return_value_lglgaussextractxor_1;
      for( ; !(*p == 0); p = p + 1l)
        ;
    }

  }
  return res;
}

// lglgaussextractsmall
// file lglib.c line 16391
static signed int lglgaussextractsmall(struct LGL *lgl)
{
  signed long int before = lgl->stats->gauss.extracted;
  signed long int after;
  signed long int delta;
  signed int res;
  lglrandlitrav(lgl, lglgaussextractsmallit);
  after = lgl->stats->gauss.extracted;
  delta = after - before;
  res = (signed int)(delta > (signed long int)0x7fffffff ? (signed long int)0x7fffffff : delta);
  return res;
}

// lglgaussextractsmallit
// file lglib.c line 16357
static signed int lglgaussextractsmallit(struct LGL *lgl, signed int lit)
{
  signed int allxors = lgl->opts->gaussextrall.val;
  signed int cls[4l];
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  const signed int *w;
  const signed int *eow;
  const signed int *p;
  struct HTS *hts;
  signed int return_value_abs_2;
  signed int return_value_abs_3;
  if(lgl->stats->gauss.steps.extr >= lgl->limits->gauss.steps.extr)
    return 0;

  else
  {
    signed char return_value_lglval_1;
    return_value_lglval_1=lglval(lgl, lit);
    if((signed int)return_value_lglval_1 >= 1)
      return 1;

    else
    {
      hts=lglhts(lgl, lit);
      w=lglhts2wchs(lgl, hts);
      eow = w + (signed long int)hts->count;
      p = w;
      for( ; !(p >= eow); p = p + 1l)
      {
        blit = *p;
        tag = blit & MASKCS;
        if(tag == TRNCS || tag == LRGCS)
          p = p + 1l;

        if(!(tag == OCCS) && !(tag == LRGCS))
        {
          other = blit >> RMSHFT;
          if(allxors == 0)
          {
            return_value_abs_2=abs(other);
            if(!(return_value_abs_2 >= lit))
              goto __CPROVER_DUMP_L9;

          }

          cls[(signed long int)0] = lit;
          cls[(signed long int)1] = other;
          if(tag == TRNCS)
          {
            other2 = *p;
            if(allxors == 0)
            {
              return_value_abs_3=abs(other2);
              if(!(return_value_abs_3 >= lit))
                goto __CPROVER_DUMP_L9;

            }

            cls[(signed long int)2] = other2;
            cls[(signed long int)3] = 0;
          }

          else
            cls[(signed long int)2] = 0;
          lglgaussextractxor(lgl, cls);
        }


      __CPROVER_DUMP_L9:
        ;
      }
      return 1;
    }
  }
}

// lglgaussextractxor
// file lglib.c line 16350
static signed int lglgaussextractxor(struct LGL *lgl, const signed int *c)
{
  signed int old;
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(&lgl->_anon0.gauss->xors);
  old = (signed int)return_value_lglcntstk_1;
  signed int res;
  res=lglgaussextractxoraux(lgl, c);
  if(res == 0)
    lglrststk(&lgl->_anon0.gauss->xors, old);

  return res;
}

// lglgaussextractxoraux
// file lglib.c line 16308
static signed int lglgaussextractxoraux(struct LGL *lgl, const signed int *c)
{
  signed int lit;
  signed int val;
  signed int size;
  signed int maxsize;
  signed int negs;
  signed int lglgaussextractxoraux__1__start;
  signed int max;
  signed int *d;
  signed int *q;
  signed int allxors = lgl->opts->gaussextrall.val;
  unsigned long int signs;
  const signed int *p;
  maxsize = lgl->opts->gaussmaxor.val;
  size = 0;
  negs = size;
  max = negs;
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(&lgl->_anon0.gauss->xors);
  lglgaussextractxoraux__1__start = (signed int)return_value_lglcntstk_1;
  p = c;
  _Bool tmp_if_expr_5;
  signed int return_value_abs_3;
  signed int return_value_abs_4;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    signed char return_value_lglval_2;
    return_value_lglval_2=lglval(lgl, lit);
    val = (signed int)return_value_lglval_2;
    if(val >= 1)
      return 0;

    if(val >= 0)
    {
      if(!(lit >= 0))
      {
        if(allxors == 0 && !(negs == 0))
          return 0;

        negs = (signed int)!(negs != 0);
      }

      if(max == 0)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_abs_3=abs(max);
        return_value_abs_4=abs(lit);
        tmp_if_expr_5 = return_value_abs_3 < return_value_abs_4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        max = lit;

      lglpushstk(lgl, &lgl->_anon0.gauss->xors, lit);
      size = size + 1;
      if(!(maxsize >= size))
        return 0;

    }

    p = p + 1l;
  }
  while((_Bool)1);
  _Bool tmp_if_expr_6;
  if(!(size >= 2))
    return 0;

  else
    if(allxors == 0 && max >= 1 && !(negs == 0))
      return 0;

    else
    {
      lglpushstk(lgl, &lgl->_anon0.gauss->xors, 0);
      d = lgl->_anon0.gauss->xors.start + (signed long int)lglgaussextractxoraux__1__start;
      signs=lgldec64(1ull << size);
      do
      {
        signed int return_value_lglgaussubcls_7;
        return_value_lglgaussubcls_7=lglgaussubcls(lgl, signs, d);
        if(return_value_lglgaussubcls_7 == 0)
          break;

        signs=lgldec64(signs);
        if(!(signs == 0ul))
          tmp_if_expr_6 = lgl->stats->gauss.steps.extr < lgl->limits->gauss.steps.extr ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_6 = (_Bool)0;
      }
      while(tmp_if_expr_6);
      if(!(signs == 0ul))
        return 0;

      else
      {
        q = d;
        do
        {
          lit = *q;
          if(lit == 0)
            break;

          *q=abs(lit);
          q = q + 1l;
        }
        while((_Bool)1);
        *q = (signed int)!(negs != 0);

      __CPROVER_DUMP_L21:
        ;
        lgl->stats->gauss.arity.sum = lgl->stats->gauss.arity.sum + (signed long int)size;
        if(!(lgl->stats->gauss.arity.max >= size))
          lgl->stats->gauss.arity.max = size;

        lgl->stats->gauss.extracted = lgl->stats->gauss.extracted + 1l;
        return 1;
      }
    }
}

// lglgaussgc
// file lglib.c line 16619
static void lglgaussgc(struct LGL *lgl)
{
  signed int count;
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(&lgl->_anon0.gauss->xors);
  count = (signed int)return_value_lglcntstk_1;
  signed int *q;
  const signed int *p;
  signed int *tmp_post_2;
  if(lgl->_anon0.gauss->garbage >= count / 2 + 10000)
  {
    lgl->stats->gauss.gcs = lgl->stats->gauss.gcs + 1;
    lglprt(lgl, 2, "[gauss-%d] collecting %d garbage out of %d", lgl->stats->gauss.count, lgl->_anon0.gauss->garbage, count);
    lglgaussdisconnect(lgl);
    q = lgl->_anon0.gauss->xors.start;
    p = q;
    for( ; !(p >= lgl->_anon0.gauss->xors.top); p = p + 1l)
      if(!(*p == 134217727))
      {
        tmp_post_2 = q;
        q = q + 1l;
        *tmp_post_2 = *p;
      }

    lgl->_anon0.gauss->xors.top = q;
    lglfitstk(lgl, &lgl->_anon0.gauss->xors);
    lglgaussconnect(lgl);
    lgl->_anon0.gauss->garbage = 0;
  }

}

// lglgaussing
// file lglib.c line 17010
static signed int lglgaussing(struct LGL *lgl)
{
  signed int return_value_lglsmallirr_1;
  return_value_lglsmallirr_1=lglsmallirr(lgl);
  if(return_value_lglsmallirr_1 == 0)
    return 0;

  else
    return lgl->opts->gauss.val;
}

// lglgaussinit
// file lglib.c line 16678
static void lglgaussinit(struct LGL *lgl)
{
  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Gauss) /*72ul*/ );
    lgl->_anon0.gauss = (struct Gauss *)return_value_lglnew_1;
  }
  while((_Bool)0);
}

// lglgaussoccs
// file lglib.c line 16495
static signed int lglgaussoccs(struct LGL *lgl, signed int a)
{
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(lgl->_anon0.gauss->occs + (signed long int)a);
  return (signed int)return_value_lglcntstk_1;
}

// lglgaussorder
// file lglib.c line 16462
static void lglgaussorder(struct LGL *lgl)
{
  lglrandidxtrav(lgl, lglgaussorderidx);
  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(signed char) /*1ul*/ );
    lgl->_anon0.gauss->eliminated = (signed char *)return_value_lglnew_1;
  }
  while((_Bool)0);
}

// lglgaussorderidx
// file lglib.c line 16455
static signed int lglgaussorderidx(struct LGL *lgl, signed int var)
{
  signed int return_value_lglmtstk_1;
  return_value_lglmtstk_1=lglmtstk(lgl->_anon0.gauss->occs + (signed long int)var);
  if(return_value_lglmtstk_1 == 0)
    lglpushstk(lgl, &lgl->_anon0.gauss->order, var);

  return 1;
}

// lglgaussort
// file lglib.c line 16507
static void lglgaussort(struct LGL *lgl)
{
  signed int max;
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(&lgl->_anon0.gauss->order);
  max = (signed int)return_value_lglcntstk_1;
  signed int rest;
  signed int *lglgaussort__1__start;
  rest = max - lgl->_anon0.gauss->next;
  lglgaussort__1__start = lgl->_anon0.gauss->order.start + (signed long int)lgl->_anon0.gauss->next;
  lgl->stats->gauss.steps.elim = lgl->stats->gauss.steps.elim + (signed long int)rest;
  signed int return_value_lglcmpgauss_6;
  signed int return_value_lglmtstk_7;
  signed int return_value_lglcmpgauss_9;
  do
  {
    signed int *AA = lglgaussort__1__start;
    signed int NN = rest;
    do
    {
      signed int lglgaussort__1__1__1__L = 0;
      signed int lglgaussort__1__1__1__R = NN - 1;
      signed int M;
      signed int LL;
      signed int RR;
      signed int lglgaussort__1__1__1__I;
      if(!(lglgaussort__1__1__1__R + -lglgaussort__1__1__1__L >= 11))
        break;

      do
      {
        M = (lglgaussort__1__1__1__L + lglgaussort__1__1__1__R) / 2;
        do
        {
          signed int lglgaussort__1__1__1__1__1__1__TMP = AA[(signed long int)M];
          AA[(signed long int)M] = AA[(signed long int)(lglgaussort__1__1__1__R - 1)];
          AA[(signed long int)(lglgaussort__1__1__1__R - 1)] = lglgaussort__1__1__1__1__1__1__TMP;
        }
        while((_Bool)0);
        do
        {
          signed int return_value_lglcmpgauss_2;
          return_value_lglcmpgauss_2=lglcmpgauss(lgl, *(&AA[(signed long int)lglgaussort__1__1__1__L]), *(&AA[(signed long int)(lglgaussort__1__1__1__R - 1)]));
          if(return_value_lglcmpgauss_2 >= 1)
            do
            {
              signed int lglgaussort__1__1__1__1__1__2__1__TMP = AA[(signed long int)lglgaussort__1__1__1__L];
              AA[(signed long int)lglgaussort__1__1__1__L] = AA[(signed long int)(lglgaussort__1__1__1__R - 1)];
              AA[(signed long int)(lglgaussort__1__1__1__R - 1)] = lglgaussort__1__1__1__1__1__2__1__TMP;
            }
            while((_Bool)0);

        }
        while((_Bool)0);
        do
        {
          signed int return_value_lglcmpgauss_3;
          return_value_lglcmpgauss_3=lglcmpgauss(lgl, *(&AA[(signed long int)lglgaussort__1__1__1__L]), *(&AA[(signed long int)lglgaussort__1__1__1__R]));
          if(return_value_lglcmpgauss_3 >= 1)
            do
            {
              signed int lglgaussort__1__1__1__1__1__3__1__TMP = AA[(signed long int)lglgaussort__1__1__1__L];
              AA[(signed long int)lglgaussort__1__1__1__L] = AA[(signed long int)lglgaussort__1__1__1__R];
              AA[(signed long int)lglgaussort__1__1__1__R] = lglgaussort__1__1__1__1__1__3__1__TMP;
            }
            while((_Bool)0);

        }
        while((_Bool)0);
        do
        {
          signed int return_value_lglcmpgauss_4;
          return_value_lglcmpgauss_4=lglcmpgauss(lgl, *(&AA[(signed long int)(lglgaussort__1__1__1__R - 1)]), *(&AA[(signed long int)lglgaussort__1__1__1__R]));
          if(return_value_lglcmpgauss_4 >= 1)
            do
            {
              signed int lglgaussort__1__1__1__1__1__4__1__TMP = AA[(signed long int)(lglgaussort__1__1__1__R - 1)];
              AA[(signed long int)(lglgaussort__1__1__1__R - 1)] = AA[(signed long int)lglgaussort__1__1__1__R];
              AA[(signed long int)lglgaussort__1__1__1__R] = lglgaussort__1__1__1__1__1__4__1__TMP;
            }
            while((_Bool)0);

        }
        while((_Bool)0);
        do
        {
          signed int lglgaussort__1__1__1__1__1__5__PIVOT;
          signed int lglgaussort__1__1__1__1__1__5__J = lglgaussort__1__1__1__R - 1;
          lglgaussort__1__1__1__I = (lglgaussort__1__1__1__L + 1) - 1;
          lglgaussort__1__1__1__1__1__5__PIVOT = AA[(signed long int)lglgaussort__1__1__1__1__1__5__J];
          do
          {

          __CPROVER_DUMP_L15:
            ;
            lglgaussort__1__1__1__I = lglgaussort__1__1__1__I + 1;
            signed int return_value_lglcmpgauss_5;
            return_value_lglcmpgauss_5=lglcmpgauss(lgl, *(&AA[(signed long int)lglgaussort__1__1__1__I]), *(&lglgaussort__1__1__1__1__1__5__PIVOT));
            if(!(return_value_lglcmpgauss_5 >= 0))
              goto __CPROVER_DUMP_L15;

            do
            {
              lglgaussort__1__1__1__1__1__5__J = lglgaussort__1__1__1__1__1__5__J - 1;
              return_value_lglcmpgauss_6=lglcmpgauss(lgl, *(&lglgaussort__1__1__1__1__1__5__PIVOT), *(&AA[(signed long int)lglgaussort__1__1__1__1__1__5__J]));
              if(return_value_lglcmpgauss_6 >= 0)
                break;

              if(lglgaussort__1__1__1__1__1__5__J == 1 + lglgaussort__1__1__1__L)
                break;

            }
            while((_Bool)1);
            if(lglgaussort__1__1__1__I >= lglgaussort__1__1__1__1__1__5__J)
              break;

            do
            {
              signed int lglgaussort__1__1__1__1__1__5__1__1__1__TMP = AA[(signed long int)lglgaussort__1__1__1__I];
              AA[(signed long int)lglgaussort__1__1__1__I] = AA[(signed long int)lglgaussort__1__1__1__1__1__5__J];
              AA[(signed long int)lglgaussort__1__1__1__1__1__5__J] = lglgaussort__1__1__1__1__1__5__1__1__1__TMP;
            }
            while((_Bool)0);
          }
          while((_Bool)1);
          do
          {
            signed int TMP = AA[(signed long int)lglgaussort__1__1__1__I];
            AA[(signed long int)lglgaussort__1__1__1__I] = AA[(signed long int)(lglgaussort__1__1__1__R - 1)];
            AA[(signed long int)(lglgaussort__1__1__1__R - 1)] = TMP;
          }
          while((_Bool)0);
        }
        while((_Bool)0);
        if(!(lglgaussort__1__1__1__I + -lglgaussort__1__1__1__L >= lglgaussort__1__1__1__R + -lglgaussort__1__1__1__I))
        {
          LL = lglgaussort__1__1__1__I + 1;
          RR = lglgaussort__1__1__1__R;
          lglgaussort__1__1__1__R = lglgaussort__1__1__1__I - 1;
        }

        else
        {
          LL = lglgaussort__1__1__1__L;
          RR = lglgaussort__1__1__1__I - 1;
          lglgaussort__1__1__1__L = lglgaussort__1__1__1__I + 1;
        }
        if(lglgaussort__1__1__1__R + -lglgaussort__1__1__1__L >= 11)
        {
          lglpushstk(lgl, &lgl->_anon1.sortstk, LL);
          lglpushstk(lgl, &lgl->_anon1.sortstk, RR);
        }

        else
          if(RR + -LL >= 11)
          {
            lglgaussort__1__1__1__L = LL;
            lglgaussort__1__1__1__R = RR;
          }

          else
          {
            return_value_lglmtstk_7=lglmtstk(&lgl->_anon1.sortstk);
            if(return_value_lglmtstk_7 == 0)
            {
              lglgaussort__1__1__1__R=lglpopstk(&lgl->_anon1.sortstk);
              lglgaussort__1__1__1__L=lglpopstk(&lgl->_anon1.sortstk);
            }

            else
              break;
          }
      }
      while((_Bool)1);
    }
    while((_Bool)0);
    do
    {
      signed int PIVOT;
      signed int L = 0;
      signed int R = NN - 1;
      signed int I;
      signed int J;
      I = R;
      for( ; !(L >= I); I = I - 1)
        do
        {
          signed int return_value_lglcmpgauss_8;
          return_value_lglcmpgauss_8=lglcmpgauss(lgl, *(&AA[(signed long int)(I - 1)]), *(&AA[(signed long int)I]));
          if(return_value_lglcmpgauss_8 >= 1)
            do
            {
              signed int lglgaussort__1__1__2__1__1__1__TMP = AA[(signed long int)(I - 1)];
              AA[(signed long int)(I - 1)] = AA[(signed long int)I];
              AA[(signed long int)I] = lglgaussort__1__1__2__1__1__1__TMP;
            }
            while((_Bool)0);

        }
        while((_Bool)0);
      I = L + 2;
      for( ; R >= I; I = I + 1)
      {
        J = I;
        PIVOT = AA[(signed long int)I];
        do
        {
          return_value_lglcmpgauss_9=lglcmpgauss(lgl, *(&PIVOT), *(&AA[(signed long int)(J - 1)]));
          if(return_value_lglcmpgauss_9 >= 0)
            break;

          AA[(signed long int)J] = AA[(signed long int)(J - 1)];
          J = J - 1;
        }
        while((_Bool)1);
        AA[(signed long int)J] = PIVOT;
      }
    }
    while((_Bool)0);

  __CPROVER_DUMP_L37:
    ;
  }
  while((_Bool)0);
  lglprt(lgl, 3, "[gauss-%d] sorted %d remaining variables", lgl->stats->gauss.count, rest);
}

// lglgausspickeqn
// file lglib.c line 16519
static signed int lglgausspickeqn(struct LGL *lgl, signed int pivot)
{
  signed int res;
  signed int cand;
  signed int weight;
  signed int size;
  signed int tmp;
  signed int other;
  signed int found;
  const signed int *p;
  const signed int *e;
  const signed int *q;
  struct Stk *occs;
  res = -1;
  weight = 0x7fffffff;
  size = 0x7fffffff;
  occs = lgl->_anon0.gauss->occs + (signed long int)pivot;
  p = occs->start;
  for( ; !(p >= occs->top); p = p + 1l)
  {
    cand = *p;
    e = lgl->_anon0.gauss->xors.start + (signed long int)cand;
    tmp = 0;
    found = tmp;
    lgl->stats->gauss.steps.elim = lgl->stats->gauss.steps.elim + 1l;
    q = e;
    do
    {
      other = *q;
      if(!(other >= 2))
        break;

      if(!(lgl->_anon0.gauss->eliminated[(signed long int)other] == 0))
        break;

      if(other == pivot)
        found = found + 1;

      else
      {
        signed int return_value_lglgaussoccs_1;
        return_value_lglgaussoccs_1=lglgaussoccs(lgl, other);
        tmp = tmp + (return_value_lglgaussoccs_1 - 1);
      }
      q = q + 1l;
    }
    while((_Bool)1);
    if(!(other >= 2))
    {
      if(!(q - e >= (signed long int)size) || !(res >= 0))
      {
        if(!(q - e == (signed long int)size) || !(res >= 0) || !(tmp >= weight))
        {
          weight = tmp;
          size = (signed int)(q - e);
          res = cand;
        }

      }

    }

  }
  if(res >= 0)

    __CPROVER_DUMP_L8:
      ;

  else

    __CPROVER_DUMP_L9:
      ;
  return res;
}

// lglgaussreset
// file lglib.c line 16683
static void lglgaussreset(struct LGL *lgl)
{
  if(!(lgl->_anon0.gauss->occs == ((struct Stk *)NULL)))
    lglgaussdisconnect(lgl);

  if(!(lgl->_anon0.gauss->eliminated == ((signed char *)NULL)))
    do
    {
      lgldel(lgl, (void *)lgl->_anon0.gauss->eliminated, (unsigned long int)lgl->nvars * sizeof(signed char) /*1ul*/ );
      lgl->_anon0.gauss->eliminated = ((signed char *)NULL);
    }
    while((_Bool)0);

  lglrelstk(lgl, &lgl->_anon0.gauss->xors);
  lglrelstk(lgl, &lgl->_anon0.gauss->order);
  do
  {
    lgldel(lgl, (void *)lgl->_anon0.gauss, (unsigned long int)1 * sizeof(struct Gauss) /*72ul*/ );
    lgl->_anon0.gauss = ((struct Gauss *)NULL);
  }
  while((_Bool)0);
}

// lglgaussubcls
// file lglib.c line 16301
static signed int lglgaussubcls(struct LGL *lgl, unsigned long int signs, const signed int *c)
{
  signed int res;
  res=lglgaussubclsaux(lgl, signs, c);
  signed int lit;
  const signed int *p = c;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    lglunmark(lgl, lit);
    p = p + 1l;
  }
  while((_Bool)1);
  return res;
}

// lglgaussubclsaux
// file lglib.c line 16251
static signed int lglgaussubclsaux(struct LGL *lgl, unsigned long int signs, const signed int *c)
{
  signed int lit;
  signed int i;
  signed int min;
  signed int minocc;
  signed int tmpocc;
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  signed int red;
  signed int lidx;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *d;
  const signed int *q;
  struct HTS *hts;
  minocc = 0x7fffffff;
  i = 0;
  min = i;
  lgl->stats->gauss.steps.extr = lgl->stats->gauss.steps.extr + 1l;
  p = c;
  signed int tmp_post_2;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    signed int return_value_lglmarked_1;
    return_value_lglmarked_1=lglmarked(lgl, lit);
    if(!(return_value_lglmarked_1 == 0))
      return 0;

    tmp_post_2 = i;
    i = i + 1;
    if(!((1ull << tmp_post_2 & signs) == 0ul))
      lit = -lit;

    lglsignedmark(lgl, lit);
    signed int return_value_lglocc_3;
    return_value_lglocc_3=lglocc(lgl, lit);
    struct HTS *return_value_lglhts_4;
    return_value_lglhts_4=lglhts(lgl, lit);
    tmpocc = return_value_lglocc_3 + return_value_lglhts_4->count;
    if(!(tmpocc >= minocc))
    {
      minocc = tmpocc;
      min = lit;
    }

    p = p + 1l;
  }
  while((_Bool)1);
  hts=lglhts(lgl, min);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  p = w;
  signed int return_value_lglsignedmarked_8;
  for( ; !(p >= eow); p = p + 1l)
  {
    lgl->stats->gauss.steps.extr = lgl->stats->gauss.steps.extr + 1l;
    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(!(tag == LRGCS))
    {
      if(tag == BINCS)
      {
        other = blit >> RMSHFT;
        signed int return_value_lglsignedmarked_5;
        return_value_lglsignedmarked_5=lglsignedmarked(lgl, other);
        if(!(return_value_lglsignedmarked_5 == 0))
          return 1;

      }

      else
        if(tag == TRNCS)
        {
          other = blit >> RMSHFT;
          signed int return_value_lglsignedmarked_6;
          return_value_lglsignedmarked_6=lglsignedmarked(lgl, other);
          if(return_value_lglsignedmarked_6 == 0)
            goto __CPROVER_DUMP_L15;

          other2 = *p;
          signed int return_value_lglsignedmarked_7;
          return_value_lglsignedmarked_7=lglsignedmarked(lgl, other2);
          if(!(return_value_lglsignedmarked_7 == 0))
            return 1;

        }

        else
        {
          red = blit & REDCS;
          lidx = blit >> RMSHFT;
          d=lglidx2lits(lgl, OCCS, red, lidx);
          q = d;
          do
          {
            other = *q;
            if(other == 0)
              break;

            return_value_lglsignedmarked_8=lglsignedmarked(lgl, other);
            if(return_value_lglsignedmarked_8 == 0)
              break;

            q = q + 1l;
          }
          while((_Bool)1);
          if(other == 0)
            return 1;

        }
    }


  __CPROVER_DUMP_L15:
    ;
  }
  return 0;
}

// lglgaussubst
// file lglib.c line 16569
static void lglgaussubst(struct LGL *lgl, signed int pivot, signed int subst)
{
  struct Stk *occs = lgl->_anon0.gauss->occs + (signed long int)pivot;
  signed int eqn;
  signed int rhs;
  signed int res;
  const signed int *p;
  signed int *q;
  unsigned long int return_value_lglcntstk_1;
  signed int return_value_lglmarked_5;
  signed int *tmp_post_4;
  do
  {
    return_value_lglcntstk_1=lglcntstk(occs);
    if(!(return_value_lglcntstk_1 >= 2ul))
      break;

    signed int return_value_lglterminate_2;
    return_value_lglterminate_2=lglterminate(lgl);
    if(!(return_value_lglterminate_2 == 0))
      goto __CPROVER_DUMP_L15;

    eqn = occs->start[(signed long int)0];
    if(eqn == subst)
      eqn = occs->start[(signed long int)1];


  __CPROVER_DUMP_L3:
    ;
    rhs=lglgaussaddeqn(lgl, eqn);

  __CPROVER_DUMP_L4:
    ;
    signed int return_value_lglgaussaddeqn_3;
    return_value_lglgaussaddeqn_3=lglgaussaddeqn(lgl, subst);
    if(!(return_value_lglgaussaddeqn_3 == 0))
      rhs = (signed int)!(rhs != 0);

    lglgaussdiseqn(lgl, eqn);
    q = lgl->clause.start;
    p = q;
    for( ; !(p >= lgl->clause.top); p = p + 1l)
    {
      return_value_lglmarked_5=lglmarked(lgl, *p);
      if(!(return_value_lglmarked_5 == 0))
      {
        tmp_post_4 = q;
        q = q + 1l;
        *tmp_post_4 = *p;
      }

    }
    lgl->clause.top = q;
    signed int return_value_lglmtstk_7;
    return_value_lglmtstk_7=lglmtstk(&lgl->clause);
    if(return_value_lglmtstk_7 == 0)
    {
      unsigned long int return_value_lglcntstk_6;
      return_value_lglcntstk_6=lglcntstk(&lgl->_anon0.gauss->xors);
      res = (signed int)return_value_lglcntstk_6;
      lglcpystk(lgl, &lgl->_anon0.gauss->xors, &lgl->clause);
      lglpushstk(lgl, &lgl->_anon0.gauss->xors, rhs);

    __CPROVER_DUMP_L9:
      ;
      lglgaussconeqn(lgl, res);
    }

    else
      if(rhs == 0)

        __CPROVER_DUMP_L11:
          ;

      else
      {

      __CPROVER_DUMP_L12:
        ;
        lgl->mt = 1;
      }
    lglpopnunmarkstk(lgl, &lgl->clause);
  }
  while((_Bool)1);

__CPROVER_DUMP_L15:
  ;
}

// lglgc
// file lglib.c line 7634
static void lglgc(struct LGL *lgl)
{
  unsigned long int return_value_lglcntstk_2;
  if(lgl->mt == 0)
  {
    lglchkred(lgl);
    signed int return_value_lglgcnotnecessary_1;
    return_value_lglgcnotnecessary_1=lglgcnotnecessary(lgl);
    if(return_value_lglgcnotnecessary_1 == 0)
    {
      lglstart(lgl, &lgl->times->gc);
      lglchkbcpclean(lgl, "gc");
      lglrep(lgl, 2, (char)103);
      lgl->stats->gcs = lgl->stats->gcs + 1;
      if(lgl->level >= 1)
        lglbacktrack(lgl, 0);

      do
      {
        lgldis(lgl);
        lglcon(lgl);
        if(!(lgl->mt == 0))
          break;

        if(lgl->next2 == lgl->next)
        {
          return_value_lglcntstk_2=lglcntstk(&lgl->trail);
          if((unsigned long int)lgl->next == return_value_lglcntstk_2)
            break;

        }

        signed int return_value_lglbcp_3;
        return_value_lglbcp_3=lglbcp(lgl);
        if(return_value_lglbcp_3 == 0)
        {

        __CPROVER_DUMP_L3:
          ;
          lgl->mt = 1;
          break;
        }

      }
      while((_Bool)1);
      lglcount(lgl);
      lglmap(lgl);
      lglcompact(lgl);
      lgl->limits->gc.fixed = (signed long int)lgl->stats->fixed.sum;
      lglchkred(lgl);
      lglrep(lgl, 2, (char)99);
      lglstop(lgl);
    }

  }

}

// lglgcd
// file lglib.c line 3319
static unsigned int lglgcd(unsigned int a, unsigned int b)
{
  unsigned int tmp;
  if(!(a >= b))
    do
    {
      unsigned int TMP = a;
      a = b;
      b = TMP;
    }
    while((_Bool)0);

  for( ; !(b == 0u); a = tmp)
  {
    tmp = b;
    b = a % b;
  }
  return a;
}

// lglgcnotnecessary
// file lglib.c line 7603
static signed int lglgcnotnecessary(struct LGL *lgl)
{
  if(!(lgl->forcegc == 0))
    return 0;

  else
    if(!(lgl->notfullyconnected == 0))
      return 0;

    else
      return (signed int)((signed long int)lgl->stats->fixed.sum <= lgl->limits->gc.fixed);
}

// lglgdump
// file lglib.c line 16237
static void lglgdump(struct LGL *lgl)
{
  ;
}

// lglgetconfs
// file lglib.h line 282
signed long int lglgetconfs(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglgetconfs");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  return lgl->stats->confs;
}

// lglgetdecs
// file lglib.h line 283
signed long int lglgetdecs(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglgetdecs");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  return lgl->stats->decisions;
}

// lglgetdom
// file lglib.c line 2591
static signed int lglgetdom(struct LGL *lgl, signed int lit)
{
  signed int res;
  signed int return_value_lglulit_1;
  return_value_lglulit_1=lglulit(lit);
  res = lgl->doms[(signed long int)return_value_lglulit_1];
  return res;
}

// lglgetenv
// file lglib.c line 1606
static void lglgetenv(struct LGL *lgl, struct Opt *opt, const char *lname)
{
  const char *q;
  const char *valstr;
  char uname[40l];
  char *p;
  signed int newval;
  signed int oldval;
  uname[(signed long int)0] = (char)76;
  uname[(signed long int)1] = (char)71;
  uname[(signed long int)2] = (char)76;
  p = uname + (signed long int)3;
  q = lname;
  char *tmp_post_1;
  signed int tmp_statement_expression_2;
  signed int tmp_if_expr_4;
  const signed int **return_value___ctype_toupper_loc_3;
  const signed int **return_value___ctype_toupper_loc_5;
  for( ; !(*q == 0); q = q + 1l)
  {
    tmp_post_1 = p;
    p = p + 1l;
    signed int __res;
    return_value___ctype_toupper_loc_5=__ctype_toupper_loc();
    __res = (*return_value___ctype_toupper_loc_5)[(signed long int)(signed int)*q];
    tmp_statement_expression_2 = __res;
    *tmp_post_1 = (char)tmp_statement_expression_2;
  }
  *p = (char)0;
  valstr=getenv(uname);
  if(!(valstr == ((const char *)NULL)))
  {
    oldval = opt->val;
    newval=atoi_link1(valstr);
    if(!(newval >= opt->min))
      newval = opt->min;

    if(!(opt->max >= newval))
      newval = opt->max;

    if(!(newval == oldval))
    {
      opt->val = newval;
      while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      {
        lgltrapi(lgl, "option %s %d", lname, newval);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        fprintf(stderr, "liblgl.a: %s:%d: %s: Coverage target `%s' reached.", (const void *)"lglgetenv", 1628, (const void *)"lglib.c", (const void *)"lgl->clone");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputc(10, stderr);
        fflush(stderr);
        abort();
        break;
      }
      if(!(lgl->clone == ((struct LGL *)NULL)))
        lglsetopt(lgl->clone, lname, newval);

    }

  }

}

// lglgetime
// file lglib.c line 4956
static double lglgetime(struct LGL *lgl)
{
  _Bool tmp_if_expr_2;
  if(!(lgl->cbs == ((struct Cbs *)NULL)))
    tmp_if_expr_2 = lgl->cbs->getime != ((double (*)(void))NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  double return_value;
  double return_value_lglprocesstime_1;
  if(tmp_if_expr_2)
  {
    return_value=lgl->cbs->getime();
    return return_value;
  }

  else
  {
    return_value_lglprocesstime_1=lglprocesstime();
    return return_value_lglprocesstime_1;
  }
}

// lglgetopt
// file lglib.c line 2263
signed int lglgetopt(struct LGL *lgl, const char *opt)
{
  struct Opt *o;
  o=lgligetopt(lgl, opt);
  signed int tmp_if_expr_1;
  if(!(o == ((struct Opt *)NULL)))
    tmp_if_expr_1 = o->val;

  else
    tmp_if_expr_1 = 0;
  return tmp_if_expr_1;
}

// lglgetoptminmax
// file lglib.c line 2268
signed int lglgetoptminmax(struct LGL *lgl, const char *opt, signed int *min_ptr, signed int *max_ptr)
{
  struct Opt *o;
  o=lgligetopt(lgl, opt);
  if(o == ((struct Opt *)NULL))
    return 0;

  else
  {
    if(!(min_ptr == ((signed int *)NULL)))
      *min_ptr = o->min;

    if(!(max_ptr == ((signed int *)NULL)))
      *max_ptr = o->max;

    return o->val;
  }
}

// lglgetout
// file lglib.c line 2244
struct _IO_FILE * lglgetout(struct LGL *lgl)
{
  return lgl->out;
}

// lglgetprefix
// file lglib.c line 2251
const char * lglgetprefix(struct LGL *lgl)
{
  return lgl->prefix;
}

// lglgetprops
// file lglib.h line 284
signed long int lglgetprops(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglgetprops");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  return lgl->stats->props.search + lgl->stats->props.simp;
}

// lglgidx2gat
// file lglib.c line 12368
static struct Gat * lglgidx2gat(struct LGL *lgl, signed int gidx)
{
  return lgl->_anon0.cgr->gates + (signed long int)gidx;
}

// lglgluestats
// file lglib.c line 18095
static void lglgluestats(struct LGL *lgl)
{
  signed long int added;
  signed long int reduced;
  signed long int forcing;
  signed long int resolved;
  signed long int conflicts;
  signed long int wadded;
  signed long int wreduced;
  signed long int wforcing;
  signed long int wresolved;
  signed long int wconflicts;
  signed long int avgadded;
  signed long int avgreduced;
  signed long int avgforcing;
  signed long int avgresolved;
  signed long int avgconflicts;
  double madded;
  double mreduced;
  double mforcing;
  double mresolved;
  double mconflicts;
  double vadded;
  double vreduced;
  double vforcing;
  double vresolved;
  double vconflicts;
  double sadded;
  double sreduced;
  double sforcing;
  double sresolved;
  double sconflicts;
  struct Stats *s = lgl->stats;
  signed int glue;
  lglprs(lgl, "");
  lglprs(lgl, "scaledglue%7s %3s %9s %3s %9s %3s %9s %3s %9s", (const void *)"added", (const void *)"", (const void *)"reduced", (const void *)"", (const void *)"forcing", (const void *)"", (const void *)"resolved", (const void *)"", (const void *)"conflicts");
  conflicts = (signed long int)0;
  resolved = conflicts;
  forcing = resolved;
  reduced = forcing;
  added = reduced;
  wconflicts = (signed long int)0;
  wresolved = wconflicts;
  wforcing = wresolved;
  wreduced = wforcing;
  wadded = wreduced;
  glue = 0;
  for( ; !(glue >= 16); glue = glue + 1)
  {
    added = added + s->lir[(signed long int)glue].added;
    reduced = reduced + s->lir[(signed long int)glue].reduced;
    forcing = forcing + s->lir[(signed long int)glue].forcing;
    resolved = resolved + s->lir[(signed long int)glue].resolved;
    conflicts = conflicts + s->lir[(signed long int)glue].conflicts;
    wadded = wadded + (signed long int)glue * s->lir[(signed long int)glue].added;
    wreduced = wreduced + (signed long int)glue * s->lir[(signed long int)glue].reduced;
    wforcing = wforcing + (signed long int)glue * s->lir[(signed long int)glue].forcing;
    wresolved = wresolved + (signed long int)glue * s->lir[(signed long int)glue].resolved;
    wconflicts = wconflicts + (signed long int)glue * s->lir[(signed long int)glue].conflicts;
  }
  avgadded = added != 0l ? (((signed long int)10 * wadded) / added + (signed long int)5) / (signed long int)10 : (signed long int)0;
  avgreduced = reduced != 0l ? (((signed long int)10 * wreduced) / reduced + (signed long int)5) / (signed long int)10 : (signed long int)0;
  avgforcing = forcing != 0l ? (((signed long int)10 * wforcing) / forcing + (signed long int)5) / (signed long int)10 : (signed long int)0;
  avgresolved = resolved != 0l ? (((signed long int)10 * wresolved) / resolved + (signed long int)5) / (signed long int)10 : (signed long int)0;
  avgconflicts = conflicts != 0l ? (((signed long int)10 * wconflicts) / conflicts + (signed long int)5) / (signed long int)10 : (signed long int)0;
  lglprs(lgl, "");
  lglprs(lgl, "all %9lld %3.0f %9lld %3.0f %9lld %3.0f %9lld %3.0f %9lld %3.0f", (signed long long int)added, 100.0, (signed long long int)reduced, 100.0, (signed long long int)forcing, 100.0, (signed long long int)resolved, 100.0, (signed long long int)conflicts, 100.0);
  lglprs(lgl, "");
  glue = 0;
  for( ; !(glue >= 16); glue = glue + 1)
  {
    double return_value_lglpcnt_1;
    return_value_lglpcnt_1=lglpcnt((double)s->lir[(signed long int)glue].added, (double)added);
    double return_value_lglpcnt_2;
    return_value_lglpcnt_2=lglpcnt((double)s->lir[(signed long int)glue].reduced, (double)reduced);
    double return_value_lglpcnt_3;
    return_value_lglpcnt_3=lglpcnt((double)s->lir[(signed long int)glue].forcing, (double)forcing);
    double return_value_lglpcnt_4;
    return_value_lglpcnt_4=lglpcnt((double)s->lir[(signed long int)glue].resolved, (double)resolved);
    double return_value_lglpcnt_5;
    return_value_lglpcnt_5=lglpcnt((double)s->lir[(signed long int)glue].conflicts, (double)conflicts);
    lglprs(lgl, "%2d  %9lld %3.0f%c%9lld %3.0f%c%9lld %3.0f%c%9lld %3.0f%c%9lld %3.0f%c", glue, (signed long long int)s->lir[(signed long int)glue].added, return_value_lglpcnt_1, (signed long int)glue == avgadded ? 60 : 32, (signed long long int)s->lir[(signed long int)glue].reduced, return_value_lglpcnt_2, (signed long int)glue == avgreduced ? 60 : 32, (signed long long int)s->lir[(signed long int)glue].forcing, return_value_lglpcnt_3, (signed long int)glue == avgforcing ? 60 : 32, (signed long long int)s->lir[(signed long int)glue].resolved, return_value_lglpcnt_4, (signed long int)glue == avgresolved ? 60 : 32, (signed long long int)s->lir[(signed long int)glue].conflicts, return_value_lglpcnt_5, (signed long int)glue == avgconflicts ? 60 : 32);
  }
  lglprs(lgl, "");
  madded=lglavg((double)wadded, (double)added);
  mreduced=lglavg((double)wreduced, (double)reduced);
  mforcing=lglavg((double)wforcing, (double)forcing);
  mresolved=lglavg((double)wresolved, (double)resolved);
  mconflicts=lglavg((double)wconflicts, (double)conflicts);
  lglprs(lgl, "avg  %14.1f%14.1f%14.1f%14.1f%14.1f", madded, mreduced, mforcing, mresolved, mconflicts);
  vconflicts = (double)0;
  vresolved = vconflicts;
  vforcing = vresolved;
  vreduced = vforcing;
  vadded = vreduced;
  glue = 0;
  for( ; !(glue >= 16); glue = glue + 1)
  {
    double return_value_lglsqr_6;
    return_value_lglsqr_6=lglsqr((double)glue - madded);
    vadded = vadded + (double)s->lir[(signed long int)glue].added * return_value_lglsqr_6;
    double return_value_lglsqr_7;
    return_value_lglsqr_7=lglsqr((double)glue - mreduced);
    vreduced = vreduced + (double)s->lir[(signed long int)glue].reduced * return_value_lglsqr_7;
    double return_value_lglsqr_8;
    return_value_lglsqr_8=lglsqr((double)glue - mforcing);
    vforcing = vforcing + (double)s->lir[(signed long int)glue].forcing * return_value_lglsqr_8;
    double return_value_lglsqr_9;
    return_value_lglsqr_9=lglsqr((double)glue - mresolved);
    vresolved = vresolved + (double)s->lir[(signed long int)glue].resolved * return_value_lglsqr_9;
    double return_value_lglsqr_10;
    return_value_lglsqr_10=lglsqr((double)glue - mconflicts);
    vconflicts = vconflicts + (double)s->lir[(signed long int)glue].conflicts * return_value_lglsqr_10;
  }
  double return_value_lglavg_11;
  return_value_lglavg_11=lglavg(vadded, (double)added);
  sadded=sqrt(return_value_lglavg_11);
  double return_value_lglavg_12;
  return_value_lglavg_12=lglavg(vreduced, (double)reduced);
  sreduced=sqrt(return_value_lglavg_12);
  double return_value_lglavg_13;
  return_value_lglavg_13=lglavg(vforcing, (double)forcing);
  sforcing=sqrt(return_value_lglavg_13);
  double return_value_lglavg_14;
  return_value_lglavg_14=lglavg(vresolved, (double)resolved);
  sresolved=sqrt(return_value_lglavg_14);
  double return_value_lglavg_15;
  return_value_lglavg_15=lglavg(vconflicts, (double)conflicts);
  sconflicts=sqrt(return_value_lglavg_15);
  lglprs(lgl, "std  %14.1f%14.1f%14.1f%14.1f%14.1f", sadded, sreduced, sforcing, sresolved, sconflicts);
}

// lglgoccsmatchcand
// file lglib.c line 13092
static signed int lglgoccsmatchcand(struct LGL *lgl, signed int a, signed int b)
{
  struct Gat *g;
  g=lglgidx2gat(lgl, a);
  struct Gat *h;
  h=lglgidx2gat(lgl, b);
  _Bool tmp_if_expr_1;
  if(g->tag == h->tag)
    tmp_if_expr_1 = g->size == h->size ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = g->minrhs == h->minrhs ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  return (signed int)tmp_if_expr_2;
}

// lglhasbin
// file lglib.c line 8465
static signed int lglhasbin(struct LGL *lgl, signed int a, signed int b)
{
  const signed int *w;
  const signed int *eow;
  const signed int *p;
  signed int blit;
  signed int tag;
  signed int other;
  struct HTS *ha;
  struct HTS *hb;
  ha=lglhts(lgl, a);
  hb=lglhts(lgl, b);
  if(!(hb->count >= ha->count))
  {
    do
    {
      signed int TMP = a;
      a = b;
      b = TMP;
    }
    while((_Bool)0);
    do
    {
      struct HTS *lglhasbin__1__1__2__TMP = ha;
      ha = hb;
      hb = lglhasbin__1__1__2__TMP;
    }
    while((_Bool)0);
  }

  w=lglhts2wchs(lgl, ha);
  eow = w + (signed long int)ha->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(!(tag == OCCS))
    {
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      else
      {
        other = blit >> RMSHFT;
        if(other == b)
          return 1;

      }
    }

  }
  return 0;
}

// lglhasbingate
// file lglib.c line 12431
static signed int lglhasbingate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int rhs0, signed int rhs1)
{
  const signed int *p;
  struct Stk *s;
  struct Gat *g;
  lhs=lglcgreprnotconst(lgl, lhs);
  rhs0=lglcgreprnotconst(lgl, rhs0);
  rhs1=lglcgreprnotconst(lgl, rhs1);
  signed int return_value_abs_1;
  return_value_abs_1=abs(lhs);
  s = lgl->_anon0.cgr->goccs + (signed long int)return_value_abs_1;
  p = s->start;
  for( ; !(p >= s->top); p = p + 1l)
  {
    g=lglgidx2gat(lgl, *p);
    if((signed int)g->tag == (signed int)tag)
    {
      if((signed int)g->size == 2)
      {
        if(g->lhs == lhs)
        {
          signed int return_value_lglcgeq_2;
          return_value_lglcgeq_2=lglcgeq(lgl, g->_anon0.lits[(signed long int)0], rhs0);
          if(!(return_value_lglcgeq_2 == 0))
          {
            signed int return_value_lglcgeq_3;
            return_value_lglcgeq_3=lglcgeq(lgl, g->_anon0.lits[(signed long int)1], rhs1);
            if(!(return_value_lglcgeq_3 == 0))
              return 1;

          }

        }

      }

    }

  }
  return 0;
}

// lglhasbins
// file lglib.c line 7787
static signed int lglhasbins(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  signed int val;
  signed int val2;
  signed int implied;
  const signed int *p;
  const signed int *w;
  const signed int *eos;
  const signed int *q;
  struct HTS *hts;
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  eos = w + (signed long int)hts->count;
  p = w;
  const signed int *tmp_post_4;
  for( ; !(p >= eos); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(tag == BINCS)
    {
      other = blit >> RMSHFT;
      signed char return_value_lglval_1;
      return_value_lglval_1=lglval(lgl, other);
      val = (signed int)return_value_lglval_1;
      if(val == 0)
        return 1;

    }

    else
      if(tag == TRNCS)
      {
        other = blit >> RMSHFT;
        p = p + 1l;
        other2 = *p;
        signed char return_value_lglval_2;
        return_value_lglval_2=lglval(lgl, other);
        val = (signed int)return_value_lglval_2;
        signed char return_value_lglval_3;
        return_value_lglval_3=lglval(lgl, other2);
        val2 = (signed int)return_value_lglval_3;
        if(val >= 1 || val2 >= 1)
          goto __CPROVER_DUMP_L14;

        if(val == 0 && !(val2 >= 0))
          return 1;

        if(val2 == 0 && !(val >= 0))
          return 1;

      }

      else
      {
        p = p + 1l;
        q=lglidx2lits(lgl, LRGCS, blit & REDCS, *p);
        implied = 0;
        do
        {
          tmp_post_4 = q;
          q = q + 1l;
          other = *tmp_post_4;
          if(other == 0)
            break;

          if(!(other == lit))
          {
            signed char return_value_lglval_5;
            return_value_lglval_5=lglval(lgl, other);
            val = (signed int)return_value_lglval_5;
            if(val >= 1)
              break;

            if(val >= 0)
            {
              if(!(implied == 0))
                break;

              implied = other;
            }

          }

        }
        while((_Bool)1);
        if(other == 0)
        {
          if(!(implied == 0))
            return 1;

        }

      }

  __CPROVER_DUMP_L14:
    ;
  }
  return 0;
}

// lglhasitegate
// file lglib.c line 12383
static signed int lglhasitegate(struct LGL *lgl, signed int lhs, signed int cond, signed int pos, signed int neg)
{
  const signed int *p;
  signed int repr;
  struct Stk *s;
  repr=lglcgrepr(lgl, lhs);
  signed int return_value_abs_1;
  return_value_abs_1=abs(repr);
  if(return_value_abs_1 == 1)
    repr = lhs;

  signed int return_value_abs_2;
  return_value_abs_2=abs(repr);
  s = lgl->_anon0.cgr->goccs + (signed long int)return_value_abs_2;
  struct Gat *g;
  p = s->start;
  for( ; !(p >= s->top); p = p + 1l)
  {
    g=lglgidx2gat(lgl, *p);
    if((signed int)g->tag == ITETAG)
    {
      if(g->lhs == lhs)
      {
        signed int return_value_lglcgeq_3;
        return_value_lglcgeq_3=lglcgeq(lgl, g->_anon0._anon1.cond, cond);
        if(!(return_value_lglcgeq_3 == 0))
        {
          signed int return_value_lglcgeq_4;
          return_value_lglcgeq_4=lglcgeq(lgl, g->_anon0._anon1.pos, pos);
          if(!(return_value_lglcgeq_4 == 0))
          {
            signed int return_value_lglcgeq_5;
            return_value_lglcgeq_5=lglcgeq(lgl, g->_anon0._anon1.neg, neg);
            if(!(return_value_lglcgeq_5 == 0))
              return 1;

          }

        }

      }

    }

  }
  return 0;
}

// lglhasopt
// file lglib.h line 121
signed int lglhasopt(struct LGL *lgl, const char *opt)
{
  struct Opt *o;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglhasopt");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  o = &lgl->opts->beforefirst + (signed long int)1;
  signed int tmp_statement_expression_1;
  for( ; &lgl->opts->afterlast + -1l >= o; o = o + 1l)
  {
    if(opt[1l] == 0)
    {
      if(o->shrt == *opt)
        return 1;

    }

    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(o->lng, opt);
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    if(tmp_statement_expression_1 == 0)
      return 1;

  }
  return 0;
}

// lglhastrn
// file lglib.c line 10204
static signed int lglhastrn(struct LGL *lgl, signed int a, signed int b, signed int c)
{
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  const signed int *w;
  const signed int *eow;
  const signed int *p;
  struct HTS *ha;
  struct HTS *hb;
  struct HTS *hc;
  ha=lglhts(lgl, a);
  hb=lglhts(lgl, b);
  if(!(hb->count >= ha->count))
  {
    do
    {
      signed int lglhastrn__1__1__1__TMP = a;
      a = b;
      b = lglhastrn__1__1__1__TMP;
    }
    while((_Bool)0);
    do
    {
      struct HTS *lglhastrn__1__1__2__TMP = ha;
      ha = hb;
      hb = lglhastrn__1__1__2__TMP;
    }
    while((_Bool)0);
  }

  hc=lglhts(lgl, c);
  if(!(hc->count >= ha->count))
  {
    do
    {
      signed int TMP = a;
      a = c;
      c = TMP;
    }
    while((_Bool)0);
    do
    {
      struct HTS *lglhastrn__1__2__2__TMP = ha;
      ha = hc;
      hc = lglhastrn__1__2__2__TMP;
    }
    while((_Bool)0);
  }

  w=lglhts2wchs(lgl, ha);
  eow = w + (signed long int)ha->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(!(tag == OCCS))
    {
      if(tag == BINCS)
      {
        other = blit >> RMSHFT;
        if(other == b || other == c)
          return 1;

      }

      else
      {
        if(tag == TRNCS || tag == LRGCS)
          p = p + 1l;

        if(!(tag == LRGCS))
        {
          other = blit >> RMSHFT;
          if(other == b || other == c)
          {
            other2 = *p;
            if(other2 == b || other2 == c)
              return 1;

          }

        }

      }
    }

  }
  if(!(hc->count >= hb->count))
  {
    do
    {
      signed int lglhastrn__1__4__1__TMP = b;
      b = c;
      c = lglhastrn__1__4__1__TMP;
    }
    while((_Bool)0);
    do
    {
      struct HTS *lglhastrn__1__4__2__TMP = hb;
      hb = hc;
      hc = lglhastrn__1__4__2__TMP;
    }
    while((_Bool)0);
  }

  w=lglhts2wchs(lgl, hb);
  eow = w + (signed long int)hb->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(!(tag == OCCS))
    {
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      else
      {
        other = blit >> RMSHFT;
        if(other == c)
          return 1;

      }
    }

  }
  return 0;
}

// lglhbred
// file lglib.c line 4355
static signed int lglhbred(struct LGL *lgl, signed int subsumed, signed int red)
{
  signed int res = subsumed != 0 ? red : REDCS;

__CPROVER_DUMP_L1:
  ;
  return res;
}

// lglheight
// file lglib.c line 5018
static double lglheight(struct LGL *lgl)
{
  double return_value_lglavg_1;
  return_value_lglavg_1=lglavg((double)lgl->stats->height, (double)lgl->stats->decisions);
  return return_value_lglavg_1;
}

// lglhts
// file lglib.c line 2599
static struct HTS * lglhts(struct LGL *lgl, signed int lit)
{
  struct DVar *return_value_lgldvar_1;
  return_value_lgldvar_1=lgldvar(lgl, lit);
  return return_value_lgldvar_1->hts + (signed long int)(lit < 0);
}

// lglhts2wchs
// file lglib.c line 2603
static signed int * lglhts2wchs(struct LGL *lgl, struct HTS *hts)
{
  signed int *res = lgl->wchs->stk.start + (signed long int)hts->offset;
  return res;
}

// lgli2m
// file lglib.c line 9273
static signed int lgli2m(struct LGL *lgl, signed int ilit)
{
  struct AVar *av;
  av=lglavar(lgl, ilit);
  signed int res = av->mark;
  if(res == 0)
  {
    unsigned long int return_value_lglcntstk_1;
    return_value_lglcntstk_1=lglcntstk(&lgl->seen);
    res = (signed int)(return_value_lglcntstk_1 + (unsigned long int)1);
    av->mark = res;
    signed int return_value_abs_2;
    return_value_abs_2=abs(ilit);
    lglpushstk(lgl, &lgl->seen, return_value_abs_2);
    lglpushstk(lgl, &lgl->_anon0.elm->lsigs, 0);
    lglpushstk(lgl, &lgl->_anon0.elm->lsigs, 0);
    lglpushstk(lgl, &lgl->_anon0.elm->noccs, 0);
    lglpushstk(lgl, &lgl->_anon0.elm->noccs, 0);
    lglpushstk(lgl, &lgl->_anon0.elm->mark, 0);
    lglpushstk(lgl, &lgl->_anon0.elm->mark, 0);
    lglpushstk(lgl, &lgl->_anon0.elm->occs, 0);
    lglpushstk(lgl, &lgl->_anon0.elm->occs, 0);
    signed int return_value_abs_3;
    return_value_abs_3=abs(ilit);
    lglpushstk(lgl, &lgl->_anon0.elm->m2i, return_value_abs_3);
  }


__CPROVER_DUMP_L1:
  ;
  if(!(ilit >= 0))
    res = -res;

  return res;
}

// lgliadd
// file lglib.c line 3685
static void lgliadd(struct LGL *lgl, signed int ilit)
{
  signed int size;
  lglpushstk(lgl, &lgl->clause, ilit);
  if(!(ilit == 0))

    __CPROVER_DUMP_L1:
      ;

  else
  {

  __CPROVER_DUMP_L2:
    ;

  __CPROVER_DUMP_L3:
    ;
    signed int return_value_lglsimpcls_2;
    return_value_lglsimpcls_2=lglsimpcls(lgl);
    if(return_value_lglsimpcls_2 == 0)
    {
      lgladdcls(lgl, 0, 0, 1);
      lgl->stats->irr.clauses.add = lgl->stats->irr.clauses.add + 1l;
      unsigned long int return_value_lglcntstk_1;
      return_value_lglcntstk_1=lglcntstk(&lgl->clause);
      size = (signed int)(return_value_lglcntstk_1 - (unsigned long int)1);
      lgl->stats->irr.clauses.add = lgl->stats->irr.clauses.add + (signed long int)size;
    }

    lglclnstk(&lgl->clause);
  }
}

// lgliassume
// file lglib.c line 7678
static void lgliassume(struct LGL *lgl, signed int lit)
{
  lgl->level = lgl->level + 1;
  lglpushcontrol(lgl, lit);

__CPROVER_DUMP_L1:
  ;
  lglassign(lgl, lit, DECISION, 0);
}

// lglidx2lits
// file lglib.c line 2537
static signed int * lglidx2lits(struct LGL *lgl, signed int tag, signed int red, signed int lidx)
{
  signed int *res;
  signed int glue = 0;
  struct Stk *s;
  while(tag == OCCS && !(red == 0))
  {
    fprintf(stderr, "liblgl.a: %s:%d: %s: Coverage target `%s' reached.", (const void *)"lglidx2lits", 2543, (const void *)"lglib.c", (const void *)"red && tag == OCCS");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputc(10, stderr);
    fflush(stderr);
    abort();
    break;
  }
  if(red == 0)
    s = &lgl->irr;

  else
    if(tag == OCCS)
      s = &lgl->red[(signed long int)0];

    else
    {
      glue = lidx & (1 << 4) - 1;
      lidx = lidx >> 4;
      s = &lgl->red[(signed long int)glue];
    }
  res = s->start + (signed long int)lidx;
  return res;
}

// lglifixed
// file lglib.c line 2794
static signed char lglifixed(struct LGL *lgl, signed int lit)
{
  signed int res;
  signed char return_value_lglval_1;
  return_value_lglval_1=lglval(lgl, lit);
  res = (signed int)return_value_lglval_1;
  if(res == 0)
    return (signed char)0;

  else
  {
    signed int return_value_lglevel_2;
    return_value_lglevel_2=lglevel(lgl, lit);
    if(return_value_lglevel_2 >= 1)
      return (signed char)0;

    else
      return (signed char)res;
  }
}

// lglifrozen
// file lglib.c line 3288
static signed int lglifrozen(struct LGL *lgl, signed int ilit)
{
  signed int elit;
  elit=lglexport(lgl, ilit);
  struct Ext *ext;
  ext=lglelit2ext(lgl, elit);
  _Bool tmp_if_expr_1;
  if(!(ext->frozen == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ext->tmpfrozen != 0u ? (_Bool)1 : (_Bool)0;
  return (signed int)tmp_if_expr_1;
}

// lglift
// file lglib.c line 14342
static signed int lglift(struct LGL *lgl)
{
  signed int oldrem;
  oldrem=lglrem(lgl);
  signed int removed;
  lglstart(lgl, &lgl->times->lft);
  lgl->lifting = (char)1;
  lgl->stats->lift.count = lgl->stats->lift.count + 1;
  lgl->simp = (char)1;
  if(lgl->level >= 1)
    lglbacktrack(lgl, 0);

  signed int return_value_lglbcp_1;
  return_value_lglbcp_1=lglbcp(lgl);
  signed int return_value_lgliftaux_2;
  signed int return_value_lglsynceqs_3;
  signed int return_value_lglbcp_4;
  if(!(return_value_lglbcp_1 == 0))
  {
    lglgc(lgl);
    if(lgl->mt == 0)
    {
      return_value_lgliftaux_2=lgliftaux(lgl);
      if(!(return_value_lgliftaux_2 == 0))
      {
        return_value_lglsynceqs_3=lglsynceqs(lgl);
        if(!(return_value_lglsynceqs_3 == 0))
        {
          lglchkred(lgl);
          lgldcpdis(lgl);
          lgldcpcln(lgl);
          lgldcpcon(lgl);
          lglcompact(lgl);
          lglmap(lgl);
          if(lgl->mt == 0)
          {
            return_value_lglbcp_4=lglbcp(lgl);
            if(!(return_value_lglbcp_4 == 0))
            {
              lglcount(lgl);
              lglgc(lgl);
              if(lgl->mt == 0)
              {
                if(lgl->mt == 0)
                {
                  lglpicosatchkall(lgl);
                  lglpicosatrestart(lgl);
                }

              }

            }

          }

        }

      }

    }

  }


DONE:
  ;
  signed int return_value_lglrem_5;
  return_value_lglrem_5=lglrem(lgl);
  removed = oldrem - return_value_lglrem_5;
  lglupdlftpen(lgl, removed);
  lgl->simp = (char)0;
  lgl->lifting = lgl->simp;
  lglprtlftrem(lgl);
  lglprt(lgl, 1 + (signed int)!(removed != 0), "[lift-%d] removed %d variables", lgl->stats->lift.count, removed);
  lglrep(lgl, 1 + (signed int)!(removed != 0), (char)94);
  lglstop(lgl);
  return (signed int)!(lgl->mt != 0);
}

// lgliftaux
// file lglib.c line 13973
static signed int lgliftaux(struct LGL *lgl)
{
  signed int lit1;
  signed int lit2;
  signed int repr1;
  signed int repr2;
  signed int orepr1;
  signed int orepr2;
  signed int tobeprobed;
  signed int notobeprobed;
  signed int i;
  signed int idx;
  signed int lit;
  signed int *reprs[3l];
  signed int first;
  signed int outer;
  signed int inner;
  signed int changed;
  signed int branch;
  struct Stk probes;
  struct Stk represented[2l];
  struct Stk saved;
  struct Stk tmp;
  signed int ok;
  signed int oldouter;
  signed int dom;
  signed int repr;
  signed int other;
  unsigned int pos;
  unsigned int delta;
  unsigned int mod;
  signed char val;
  signed char val1;
  signed char val2;
  signed long int global;
  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
    lgl->repr = (signed int *)return_value_lglnew_1;
  }
  while((_Bool)0);
  do
    memset((void *)&probes, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  do
    memset((void *)&saved, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  do
    memset((void *)&tmp, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  do
    memset((void *)&represented[(signed long int)0], 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  do
    memset((void *)&represented[(signed long int)1], 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  do
  {
    void *return_value_lglnew_2;
    return_value_lglnew_2=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
    reprs[(signed long int)0] = (signed int *)return_value_lglnew_2;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew_3;
    return_value_lglnew_3=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
    reprs[(signed long int)1] = (signed int *)return_value_lglnew_3;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew_4;
    return_value_lglnew_4=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
    reprs[(signed long int)2] = (signed int *)return_value_lglnew_4;
  }
  while((_Bool)0);
  signed long int return_value_lglobalftlim_5;
  return_value_lglobalftlim_5=lglobalftlim(lgl);
  global = lgl->stats->visits.simp + return_value_lglobalftlim_5;
  notobeprobed = 0;
  tobeprobed = notobeprobed;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree_6;
    return_value_lglisfree_6=lglisfree(lgl, idx);
    if(!(return_value_lglisfree_6 == 0))
    {
      struct AVar *return_value_lglavar_7;
      return_value_lglavar_7=lglavar(lgl, idx);
      if(!(return_value_lglavar_7->donotlft == 0u))
        notobeprobed = notobeprobed + 1;

      else
        tobeprobed = tobeprobed + 1;
    }

  }
  double return_value_lglpcnt_10;
  if(tobeprobed == 0)
  {
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      signed int return_value_lglisfree_8;
      return_value_lglisfree_8=lglisfree(lgl, idx);
      if(!(return_value_lglisfree_8 == 0))
      {
        struct AVar *return_value_lglavar_9;
        return_value_lglavar_9=lglavar(lgl, idx);
        return_value_lglavar_9->donotlft = (unsigned int)0;
        tobeprobed = tobeprobed + 1;
      }

    }
    lglprt(lgl, 1, "[lift-%d] using all %d probes", lgl->stats->lift.count, tobeprobed);
  }

  else
  {
    return_value_lglpcnt_10=lglpcnt((double)tobeprobed, (double)(notobeprobed + tobeprobed));
    lglprt(lgl, 1, "[lift-%d] using %d probes %.0f%%", lgl->stats->lift.count, tobeprobed, return_value_lglpcnt_10);
  }
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree_11;
    return_value_lglisfree_11=lglisfree(lgl, idx);
    if(!(return_value_lglisfree_11 == 0))
    {
      struct AVar *return_value_lglavar_12;
      return_value_lglavar_12=lglavar(lgl, idx);
      if(return_value_lglavar_12->donotlft == 0u)
      {

      __CPROVER_DUMP_L21:
        ;
        lglpushstk(lgl, &probes, idx);
      }

    }

  }
  unsigned long int return_value_lglcntstk_13;
  return_value_lglcntstk_13=lglcntstk(&probes);
  mod = (unsigned int)return_value_lglcntstk_13;
  unsigned int return_value_lglrand_14;
  unsigned int return_value_lglrand_15;
  unsigned int return_value_lglgcd_16;
  unsigned long int return_value_lglcntstk_23;
  unsigned long int return_value_lglcntstk_24;
  signed int return_value_lglpeek_25;
  signed int return_value_lglmtstk_26;
  _Bool tmp_if_expr_31;
  signed char return_value_lglval_30;
  unsigned long int return_value_lglcntstk_32;
  unsigned long int return_value_lglcntstk_33;
  signed int return_value_lglpeek_34;
  signed int return_value_lglmtstk_35;
  unsigned long int return_value_lglcntstk_38;
  if(!(mod == 0u))
  {

  __CPROVER_DUMP_L24:
    ;
    return_value_lglrand_14=lglrand(lgl);
    pos = return_value_lglrand_14 % mod;
    return_value_lglrand_15=lglrand(lgl);
    delta = return_value_lglrand_15 % mod;
    if(delta == 0u)
      delta = delta + 1u;

    do
    {
      return_value_lglgcd_16=lglgcd(delta, mod);
      if(!(return_value_lglgcd_16 >= 2u))
        break;

      delta = delta + 1u;
      if(delta == mod)
        delta = (unsigned int)1;

    }
    while((_Bool)1);

  __CPROVER_DUMP_L27:
    ;
    first = 0;
    changed = first;
    while(lgl->mt == 0)
    {
      if(lgl->stats->visits.simp >= global)
        break;

      signed int return_value_lglterminate_17;
      return_value_lglterminate_17=lglterminate(lgl);
      if(!(return_value_lglterminate_17 == 0))
        break;

      signed int return_value_lglsyncunits_18;
      return_value_lglsyncunits_18=lglsyncunits(lgl);
      if(return_value_lglsyncunits_18 == 0)
        break;

      outer = probes.start[(signed long int)pos];
      struct AVar *return_value_lglavar_19;
      return_value_lglavar_19=lglavar(lgl, outer);
      return_value_lglavar_19->donotlft = (unsigned int)1;
      if(outer == first)
      {
        if(!(changed == 0))
          changed = 0;

        else
          break;
      }

      if(first == 0)
        first = outer;

      pos = pos + delta;
      if(pos >= mod)
        pos = pos - mod;

      signed char return_value_lglval_20;
      return_value_lglval_20=lglval(lgl, outer);
      if(return_value_lglval_20 == 0)
      {
        lgl->stats->lift.probed0 = lgl->stats->lift.probed0 + 1l;

      __CPROVER_DUMP_L35:
        ;
        unsigned long int return_value_lglcntstk_21;
        return_value_lglcntstk_21=lglcntstk(&lgl->trail);
        oldouter = (signed int)return_value_lglcntstk_21;
        lgliassume(lgl, outer);
        ok=lglbcp(lgl);
        if(ok == 0)
        {

        FIRST_OUTER_BRANCH_FAILED:
          ;
          dom=lglprbana(lgl, outer);

        __CPROVER_DUMP_L37:
          ;
          lgl->stats->lift.units = lgl->stats->lift.units + 1;
          lglbacktrack(lgl, 0);
          lglunit(lgl, -dom);
          signed int return_value_lglbcp_22;
          return_value_lglbcp_22=lglbcp(lgl);
          if(!(return_value_lglbcp_22 == 0))
            continue;


        __CPROVER_DUMP_L38:
          ;
          lgl->mt = 1;
          break;
        }

        inner=lglinnerprobe(lgl, oldouter, &probes, &tmp);
        if(inner == 0)
        {
          do

            FIRST_OUTER_BRANCH_WIHOUT_INNER_PROBE:
              ;
          while((_Bool)0);
          i = oldouter;
          do
          {
            return_value_lglcntstk_23=lglcntstk(&lgl->trail);
            if((unsigned long int)i >= return_value_lglcntstk_23)
              break;

            lit=lglpeek(&lgl->trail, i);
            idx=abs(lit);
            reprs[(signed long int)0][(signed long int)idx]=lglsgn(lit);
            lglpushstk(lgl, &represented[(signed long int)0], idx);
            i = i + 1;
          }
          while((_Bool)1);
        }

        else
        {

        __CPROVER_DUMP_L43:
          ;
          lgl->stats->lift.probed1 = lgl->stats->lift.probed1 + 1l;
          lgliassume(lgl, inner);
          ok=lglbcp(lgl);
          if(ok == 0)
          {

          __CPROVER_DUMP_L44:
            ;
            lglbacktrack(lgl, 1);
            lgladdliftbincls(lgl, -inner, -outer);
            ok=lglbcp(lgl);
            if(!(ok == 0))
              goto FIRST_OUTER_BRANCH_WIHOUT_INNER_PROBE;


          __CPROVER_DUMP_L45:
            ;
            goto FIRST_OUTER_BRANCH_FAILED;
          }

          lglclnstk(&saved);
          i = oldouter;
          do
          {
            return_value_lglcntstk_24=lglcntstk(&lgl->trail);
            if((unsigned long int)i >= return_value_lglcntstk_24)
              break;

            return_value_lglpeek_25=lglpeek(&lgl->trail, i);
            lglpushstk(lgl, &saved, return_value_lglpeek_25);
            i = i + 1;
          }
          while((_Bool)1);

        __CPROVER_DUMP_L49:
          ;
          lglbacktrack(lgl, 1);

        __CPROVER_DUMP_L50:
          ;
          lgl->stats->lift.probed1 = lgl->stats->lift.probed1 + 1l;
          lgliassume(lgl, -inner);
          ok=lglbcp(lgl);
          if(ok == 0)
          {

          __CPROVER_DUMP_L51:
            ;
            lglbacktrack(lgl, 1);
            lgladdliftbincls(lgl, inner, -outer);
            ok=lglbcp(lgl);
            if(!(ok == 0))
              goto FIRST_OUTER_BRANCH_WIHOUT_INNER_PROBE;


          __CPROVER_DUMP_L52:
            ;
            goto FIRST_OUTER_BRANCH_FAILED;
          }

          do
          {
            return_value_lglmtstk_26=lglmtstk(&saved);
            if(!(return_value_lglmtstk_26 == 0))
              break;

            lit=lglpopstk(&saved);
            idx=abs(lit);
            signed int return_value_lglsgn_27;
            return_value_lglsgn_27=lglsgn(lit);
            val1 = (signed char)return_value_lglsgn_27;
            val2=lglval(lgl, idx);
            if(val1 == val2)
            {
              reprs[(signed long int)0][(signed long int)idx] = (signed int)val1;
              lglpushstk(lgl, &represented[(signed long int)0], idx);
            }

            else
              if((signed int)val1 == -((signed int)val2) && !(lit == inner))
              {
                repr=lglptrjmp(reprs[(signed long int)0], lgl->nvars - 1, inner);
                other=lglptrjmp(reprs[(signed long int)0], lgl->nvars - 1, lit);
                signed int return_value_lglcmprepr_28;
                return_value_lglcmprepr_28=lglcmprepr(lgl, other, repr);
                if(!(return_value_lglcmprepr_28 >= 0))
                  do
                  {
                    signed int lgliftaux__1__15__11__2__1__TMP = repr;
                    repr = other;
                    other = lgliftaux__1__15__11__2__1__TMP;
                  }
                  while((_Bool)0);

                if(!(other >= 0))
                {
                  other = -other;
                  repr = -repr;
                }

                reprs[(signed long int)0][(signed long int)other] = repr;
                lglpushstk(lgl, &represented[(signed long int)0], other);
              }

          }
          while((_Bool)1);
          lglbacktrack(lgl, 1);
        }

      END_OF_FIRST_OUTER_BRANCH:
        ;
        (void)0;
        lglbacktrack(lgl, 0);
        lgl->stats->lift.probed0 = lgl->stats->lift.probed0 + 1l;

      __CPROVER_DUMP_L61:
        ;
        lgliassume(lgl, -outer);
        ok=lglbcp(lgl);
        if(ok == 0)
        {

        SECOND_OUTER_BRANCH_FAILED:
          ;
          dom=lglprbana(lgl, -outer);

        __CPROVER_DUMP_L63:
          ;
          lgl->stats->lift.units = lgl->stats->lift.units + 1;
          lglbacktrack(lgl, 0);
          lglunit(lgl, -dom);
          signed int return_value_lglbcp_29;
          return_value_lglbcp_29=lglbcp(lgl);
          if(!(return_value_lglbcp_29 == 0))
            goto CONTINUE;

          lgl->mt = 1;
          goto CONTINUE;
        }

        if(inner == 0)
          tmp_if_expr_31 = (_Bool)1;

        else
        {
          return_value_lglval_30=lglval(lgl, inner);
          tmp_if_expr_31 = return_value_lglval_30 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_31)
          inner=lglinnerprobe(lgl, oldouter, &probes, &tmp);

        if(inner == 0)
        {
          do

            SECOND_OUTER_BRANCH_WIHOUT_INNER_PROBE:
              ;
          while((_Bool)0);
          i = oldouter;
          do
          {
            return_value_lglcntstk_32=lglcntstk(&lgl->trail);
            if((unsigned long int)i >= return_value_lglcntstk_32)
              break;

            lit=lglpeek(&lgl->trail, i);
            idx=abs(lit);
            reprs[(signed long int)1][(signed long int)idx]=lglsgn(lit);
            lglpushstk(lgl, &represented[(signed long int)1], idx);
            i = i + 1;
          }
          while((_Bool)1);
        }

        else
        {

        __CPROVER_DUMP_L71:
          ;
          lgl->stats->lift.probed1 = lgl->stats->lift.probed1 + 1l;
          lgliassume(lgl, inner);
          ok=lglbcp(lgl);
          if(ok == 0)
          {

          __CPROVER_DUMP_L72:
            ;
            lglbacktrack(lgl, 1);
            lgladdliftbincls(lgl, -inner, outer);
            ok=lglbcp(lgl);
            if(!(ok == 0))
              goto SECOND_OUTER_BRANCH_WIHOUT_INNER_PROBE;


          __CPROVER_DUMP_L73:
            ;
            goto SECOND_OUTER_BRANCH_FAILED;
          }

          lglclnstk(&saved);
          i = oldouter;
          do
          {
            return_value_lglcntstk_33=lglcntstk(&lgl->trail);
            if((unsigned long int)i >= return_value_lglcntstk_33)
              break;

            return_value_lglpeek_34=lglpeek(&lgl->trail, i);
            lglpushstk(lgl, &saved, return_value_lglpeek_34);
            i = i + 1;
          }
          while((_Bool)1);

        __CPROVER_DUMP_L77:
          ;
          lglbacktrack(lgl, 1);

        __CPROVER_DUMP_L78:
          ;
          lgl->stats->lift.probed1 = lgl->stats->lift.probed1 + 1l;
          lgliassume(lgl, -inner);
          ok=lglbcp(lgl);
          if(ok == 0)
          {

          __CPROVER_DUMP_L79:
            ;
            lglbacktrack(lgl, 1);
            lgladdliftbincls(lgl, inner, outer);
            ok=lglbcp(lgl);
            if(!(ok == 0))
              goto SECOND_OUTER_BRANCH_WIHOUT_INNER_PROBE;


          __CPROVER_DUMP_L80:
            ;
            goto SECOND_OUTER_BRANCH_FAILED;
          }

          do
          {
            return_value_lglmtstk_35=lglmtstk(&saved);
            if(!(return_value_lglmtstk_35 == 0))
              break;

            lit=lglpopstk(&saved);
            idx=abs(lit);
            signed int return_value_lglsgn_36;
            return_value_lglsgn_36=lglsgn(lit);
            val1 = (signed char)return_value_lglsgn_36;
            val2=lglval(lgl, idx);
            if(val1 == val2)
            {
              reprs[(signed long int)1][(signed long int)idx] = (signed int)val1;
              lglpushstk(lgl, &represented[(signed long int)1], idx);
            }

            else
              if((signed int)val1 == -((signed int)val2) && !(lit == inner))
              {
                repr=lglptrjmp(reprs[(signed long int)1], lgl->nvars - 1, inner);
                other=lglptrjmp(reprs[(signed long int)1], lgl->nvars - 1, lit);
                signed int return_value_lglcmprepr_37;
                return_value_lglcmprepr_37=lglcmprepr(lgl, other, repr);
                if(!(return_value_lglcmprepr_37 >= 0))
                  do
                  {
                    signed int TMP = repr;
                    repr = other;
                    other = TMP;
                  }
                  while((_Bool)0);

                if(!(other >= 0))
                {
                  other = -other;
                  repr = -repr;
                }

                reprs[(signed long int)1][(signed long int)other] = repr;
                lglpushstk(lgl, &represented[(signed long int)1], other);
              }

          }
          while((_Bool)1);
          lglbacktrack(lgl, 1);
        }

      END_OF_SECOND_BRANCH:
        ;
        (void)0;
        lglbacktrack(lgl, 0);
        branch = 0;
        for( ; !(branch >= 2); branch = branch + 1)
        {
          i = 0;
          do
          {
            return_value_lglcntstk_38=lglcntstk(&represented[(signed long int)branch]);
            if((unsigned long int)i >= return_value_lglcntstk_38)
              break;

            lit1=lglpeek(&represented[(signed long int)branch], i);
            lit2 = reprs[(signed long int)branch][(signed long int)lit1];
            signed int return_value_abs_40;
            return_value_abs_40=abs(lit2);
            if(return_value_abs_40 == 1)
            {
              val=lglval(lgl, lit1);
              if(!(val == 0))
                goto __CPROVER_DUMP_L97;

              repr1=lglptrjmp(reprs[(signed long int)!(branch != 0)], lgl->nvars - 1, lit1);
              if(!(repr1 == lit2))
                goto __CPROVER_DUMP_L97;


            __CPROVER_DUMP_L91:
              ;
              lglunit(lgl, lit2 * lit1);
              lgl->stats->lift.units = lgl->stats->lift.units + 1;
            }

            else
            {
              repr1=lglptrjmp(reprs[(signed long int)2], lgl->nvars - 1, lit1);
              repr2=lglptrjmp(reprs[(signed long int)2], lgl->nvars - 1, lit2);
              if(repr1 == repr2)
                goto __CPROVER_DUMP_L97;

              orepr1=lglptrjmp(reprs[(signed long int)!(branch != 0)], lgl->nvars - 1, lit1);
              orepr2=lglptrjmp(reprs[(signed long int)!(branch != 0)], lgl->nvars - 1, lit2);
              if(!(orepr1 == orepr2))
                goto __CPROVER_DUMP_L97;

              signed int return_value_lglcmprepr_39;
              return_value_lglcmprepr_39=lglcmprepr(lgl, repr2, repr1);
              if(!(return_value_lglcmprepr_39 >= 0))
                do
                {
                  signed int lgliftaux__1__15__22__1__1__1__2__1__TMP = repr1;
                  repr1 = repr2;
                  repr2 = lgliftaux__1__15__22__1__1__1__2__1__TMP;
                }
                while((_Bool)0);

              if(!(repr2 >= 0))
              {
                repr2 = -repr2;
                repr1 = -repr1;
              }


            __CPROVER_DUMP_L95:
              ;
              reprs[(signed long int)2][(signed long int)repr2] = repr1;
            }

          __CPROVER_DUMP_L97:
            ;
            i = i + 1;
          }
          while((_Bool)1);
        }
        signed int return_value_lglbcp_41;
        return_value_lglbcp_41=lglbcp(lgl);
        if(return_value_lglbcp_41 == 0)
          lgl->mt = 1;


      CONTINUE:
        ;
        (void)0;
        lglcleanrepr(lgl, &represented[(signed long int)0], reprs[(signed long int)0]);
        lglcleanrepr(lgl, &represented[(signed long int)1], reprs[(signed long int)1]);
      }

    }
    if(lgl->mt == 0)
    {
      idx = 2;
      for( ; !(idx >= lgl->nvars); idx = idx + 1)
        lglptrjmp(reprs[(signed long int)2], lgl->nvars - 1, idx);
      idx = 2;
      for( ; !(idx >= lgl->nvars); idx = idx + 1)
      {
        repr=lglptrjmp(reprs[(signed long int)2], lgl->nvars - 1, idx);
        val=lglval(lgl, idx);
        if(!(val == 0))
        {
          if(repr == -((signed int)val))
          {

          __CPROVER_DUMP_L106:
            ;
            lgl->mt = 1;
            goto DONE;
          }

          if(!(repr >= 0))
          {
            repr = -repr;
            val = (signed char)-((signed int)val);
          }

          if(!(repr == 1))
            reprs[(signed long int)2][(signed long int)repr] = (signed int)val;

        }

      }
      idx = 2;
      for( ; !(idx >= lgl->nvars); idx = idx + 1)
      {
        repr=lglptrjmp(reprs[(signed long int)2], lgl->nvars - 1, idx);
        if(!(repr == idx))
        {
          signed int return_value_abs_42;
          return_value_abs_42=abs(repr);
          if(!(return_value_abs_42 == 1))
          {
            lgl->stats->lift.eqs = lgl->stats->lift.eqs + 1;

          __CPROVER_DUMP_L113:
            ;
            lglimerge(lgl, idx, repr);
          }

        }

      }
    }

  }


DONE:
  ;
  (void)0;
  do
  {
    lgldel(lgl, (void *)reprs[(signed long int)0], (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
    reprs[(signed long int)0] = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)reprs[(signed long int)1], (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
    reprs[(signed long int)1] = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)reprs[(signed long int)2], (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
    reprs[(signed long int)2] = ((signed int *)NULL);
  }
  while((_Bool)0);
  lglrelstk(lgl, &probes);
  lglrelstk(lgl, &represented[(signed long int)0]);
  lglrelstk(lgl, &represented[(signed long int)1]);
  lglrelstk(lgl, &saved);
  lglrelstk(lgl, &tmp);
  if(!(lgl->mt == 0))
    do
    {
      lgldel(lgl, (void *)lgl->repr, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
      lgl->repr = ((signed int *)NULL);
    }
    while((_Bool)0);

  return (signed int)!(lgl->mt != 0);
}

// lglifting
// file lglib.c line 16959
static signed int lglifting(struct LGL *lgl)
{
  return lgl->opts->lift.val;
}

// lgligetopt
// file lglib.c line 2253
static struct Opt * lgligetopt(struct LGL *lgl, const char *opt)
{
  struct Opt *o;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lgligetopt");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  o = &lgl->opts->beforefirst + (signed long int)1;
  signed int tmp_statement_expression_1;
  for( ; &lgl->opts->afterlast + -1l >= o; o = o + 1l)
  {
    if(opt[1l] == 0)
    {
      if(o->shrt == *opt)
        return o;

    }

    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(o->lng, opt);
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    if(tmp_statement_expression_1 == 0)
      return o;

  }
  return ((struct Opt *)NULL);
}

// lglilit
// file lglib.c line 6651
static signed int lglilit(signed int ulit)
{
  signed int res = ulit / 2;
  if(!((1 & ulit) == 0))
    res = -res;

  return res;
}

// lglimerge
// file lglib.c line 8096
static void lglimerge(struct LGL *lgl, signed int lit, signed int repr)
{
  signed int idx;
  idx=abs(lit);
  struct AVar *av;
  av=lglavar(lgl, idx);
  if(!(lit >= 0))
    repr = -repr;

  av->type = (unsigned int)EQUIVAR;
  lgl->repr[(signed long int)idx] = repr;
  lgl->stats->prgss = lgl->stats->prgss + 1l;
  lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;
  lgl->stats->equiv.sum = lgl->stats->equiv.sum + 1;
  lgl->stats->equiv.current = lgl->stats->equiv.current + 1;
  lglemerge(lgl, idx, repr);
}

// lglimhit
// file lglib.c line 17218
static signed int lglimhit(struct LGL *lgl, struct Lim *lim)
{
  if(lim == ((struct Lim *)NULL))
    return 0;

  else
    if(lim->decs >= lgl->stats->decisions)
    {
      lglprt(lgl, 1, "[limits] decision limit %lld hit at %lld decisions", (signed long long int)lim->decs, (signed long long int)lgl->stats->decisions);
      return 1;
    }

    else
      if(lim->confs >= 0l)
      {
        if(!(lgl->stats->confs >= lim->confs))
          goto __CPROVER_DUMP_L3;

        lglprt(lgl, 1, "[limits] conflict limit %lld hit at %lld conflicts", (signed long long int)lim->confs, (signed long long int)lgl->stats->confs);
        return 1;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        return 0;
      }
}

// lglimport
// file lglib.c line 2510
static signed int lglimport(struct LGL *lgl, signed int elit)
{
  signed int res;
  signed int repr;
  signed int eidx;
  eidx=abs(elit);
  struct Ext *ext;
  if(eidx >= lgl->szext)
    lgladjext(lgl, eidx);

  if(!(lgl->maxext >= eidx))
  {
    lgl->maxext = eidx;
    lglmelter(lgl);
  }

  repr=lglerepr(lgl, elit);
  ext=lglelit2ext(lgl, repr);
  res = ext->repr;
  if(ext->imported == 0u)
  {
    res=lglnewvar(lgl);
    ext->repr = res;
    ext->imported = (unsigned int)1;
    lgl->i2e[(signed long int)res] = eidx;
  }


__CPROVER_DUMP_L3:
  ;
  if(!(repr >= 0))
    res = -res;


__CPROVER_DUMP_L5:
  ;
  return res;
}

// lglinc
// file lglib.c line 1245
static void lglinc(struct LGL *lgl, unsigned long int bytes)
{
  lgl->stats->bytes.current = lgl->stats->bytes.current + bytes;
  if(!(lgl->stats->bytes.max >= lgl->stats->bytes.current))
    lgl->stats->bytes.max = lgl->stats->bytes.current;


__CPROVER_DUMP_L1:
  ;
}

// lglincextractlimhit
// file lglib.c line 12580
static signed int lglincextractlimhit(struct LGL *lgl)
{
  lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
  signed int return_value_lglcgextractlimhit_1;
  return_value_lglcgextractlimhit_1=lglcgextractlimhit(lgl);
  return return_value_lglcgextractlimhit_1;
}

// lglincfdat
// file lglib.c line 7434
static void lglincfdat(struct ForceData *fdat, signed int lit, double cog)
{
  signed int idx;
  idx=abs(lit);
  (fdat + (signed long int)idx)->count = (fdat + (signed long int)idx)->count + 1;
  (fdat + (signed long int)idx)->sum = (fdat + (signed long int)idx)->sum + cog;
}

// lglincirr
// file lglib.c line 3468
static void lglincirr(struct LGL *lgl, signed int size)
{
  if(size >= 2)
  {
    lgl->stats->irr.clauses.cur = lgl->stats->irr.clauses.cur + 1;
    if(!(lgl->stats->irr.clauses.max >= lgl->stats->irr.clauses.cur))
      lgl->stats->irr.clauses.max = lgl->stats->irr.clauses.cur;

    lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur + size;
    if(!(lgl->stats->irr.lits.max >= lgl->stats->irr.lits.cur))
      lgl->stats->irr.lits.max = lgl->stats->irr.lits.cur;

    lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;
  }

}

// lglincjwh
// file lglib.c line 6658
static void lglincjwh(struct LGL *lgl, signed int lit, signed long int inc)
{
  signed int ulit;
  ulit=lglulit(lit);
  signed long int old = lgl->jwh[(signed long int)ulit];
  signed long int new;
  new=lgladdflt(old, inc);
  lgl->jwh[(signed long int)ulit] = new;
}

// lglinclause
// file lglib.c line 12709
static void lglinclause(struct LGL *lgl, signed int parity)
{
  signed int *p;
  signed int return_value_lglparity_1;
  do
  {
    p = lgl->clause.start;
    for( ; !(p >= lgl->clause.top); p = p + 1l)
    {
      *p = -(*p);
      if(!(*p >= 0))
        break;

    }
    return_value_lglparity_1=lglparity(lgl);
  }
  while(!(return_value_lglparity_1 == parity));
}

// lglincocc
// file lglib.c line 3372
static void lglincocc(struct LGL *lgl, signed int lit)
{
  signed int idx;
  signed int sign;
  signed int change;
  struct EVar *ev;
  _Bool tmp_if_expr_1;
  if(!(lgl->cgrclosing == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = lgl->probing != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = lgl->gaussing != 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_2)
  {
    idx=abs(lit);
    sign = (signed int)(lit < 0);
    ev=lglevar(lgl, lit);
    ev->occ[(signed long int)sign] = ev->occ[(signed long int)sign] + 1;
    change=lglecalc(lgl, ev);

  __CPROVER_DUMP_L6:
    ;
    if(!(ev->pos >= 0))
      lglesched(lgl, idx);

    else
      if(change >= 1)
        lgledown(lgl, idx);

      else
        if(!(change >= 0))
          lgleup(lgl, idx);

  }

}

// lglinconsistent
// file lglib.c line 17950
signed int lglinconsistent(struct LGL *lgl)
{
  signed int res;
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "inconsistent");
    break;
  }
  res = (signed int)(lgl->mt != 0);

__CPROVER_DUMP_L3:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglinconsistent(lgl->clone);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglinconsistent");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone) = %d differs from %s (lgl) = %d", (const void *)"lglinconsistent", CLONERES, (const void *)"lglinconsistent", res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglincrestartaux
// file lglib.c line 6267
static void lglincrestartaux(struct LGL *lgl, signed int skip)
{
  signed int delta = lgl->opts->restartint.val;
  signed int count;
  if(lgl->opts->restart.val == 2)
  {
    lgl->limits->restart.luby = lgl->limits->restart.luby + 1;
    count = lgl->limits->restart.luby;
    signed long int return_value_lgluby_1;
    return_value_lgluby_1=lgluby(lgl, count);
    delta = delta * (signed int)return_value_lgluby_1;
  }

  else
  {
    lgl->limits->restart.inout = lgl->limits->restart.inout + 1;
    count = lgl->limits->restart.inout;
    signed long int return_value_lglinout_2;
    return_value_lglinout_2=lglinout(lgl, count, lgl->opts->rstinoutinc.val);
    delta = delta * (signed int)return_value_lglinout_2;
  }
  lgl->limits->restart.confs = lgl->stats->confs + (signed long int)delta;
  if(!(lgl->limits->restart.wasmaxdelta == 0))
    lglrep(lgl, 1 + skip, (char)(skip != 0 ? 78 : 82));

  else
    lglrep(lgl, 2, (char)(skip != 0 ? 110 : 114));
  if(!(lgl->limits->restart.maxdelta >= delta))
  {
    lgl->limits->restart.wasmaxdelta = 1;
    lgl->limits->restart.maxdelta = delta;
  }

  else
    lgl->limits->restart.wasmaxdelta = 0;
}

// lglincrestartl
// file lglib.c line 6287
static void lglincrestartl(struct LGL *lgl, signed int skip)
{
  switch(lgl->opts->restart.val)
  {
    case 1:
    {
      lglincrestartlfixed(lgl);
      break;
    }
    case 2:

    case 3:
      lglincrestartaux(lgl, skip);
    default:
      ;
  }
}

// lglincrestartlfixed
// file lglib.c line 6261
static void lglincrestartlfixed(struct LGL *lgl)
{
  signed int delta = lgl->opts->restartint.val;
  lgl->limits->restart.confs = lgl->stats->confs + (signed long int)delta;
  lglrep(lgl, 1, (char)82);
}

// lglincvar
// file lglib.c line 17902
signed int lglincvar(struct LGL *lgl)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglincvar");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "incvar");
    break;
  }
  res = lgl->maxext + 1;
  lglimport(lgl, res);

__CPROVER_DUMP_L6:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglincvar(lgl->clone);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglincvar");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone) = %d differs from %s (lgl) = %d", (const void *)"lglincvar", CLONERES, (const void *)"lglincvar", res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglinit
// file lglib.h line 23
struct LGL * lglinit(void)
{
  struct LGL *return_value_lglminit_1;
  return_value_lglminit_1=lglminit(NULL, ((void * (*)(void *, unsigned long int))NULL), ((void * (*)(void *, void *, unsigned long int, unsigned long int))NULL), ((void (*)(void *, void *, unsigned long int))NULL));
  return return_value_lglminit_1;
}

// lglinitcbs
// file lglib.c line 1312
static void lglinitcbs(struct LGL *lgl)
{
  if(lgl->cbs == ((struct Cbs *)NULL))
    do
    {
      void *return_value_lglnew_1;
      return_value_lglnew_1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Cbs) /*152ul*/ );
      lgl->cbs = (struct Cbs *)return_value_lglnew_1;
    }
    while((_Bool)0);

}

// lglinitecls
// file lglib.c line 9435
static void lglinitecls(struct LGL *lgl, signed int idx)
{
  lgl->_anon0.elm->pivot = idx;
  lglpushstk(lgl, &lgl->_anon0.elm->mark, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->mark, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->occs, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->occs, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->noccs, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->noccs, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->lsigs, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->lsigs, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->m2i, 0);
  lgli2m(lgl, idx);
  lglpushstk(lgl, &lgl->_anon0.elm->lits, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->next, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->csigs, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->sizes, 0);
  lgl->_anon0.elm->necls = 0;
  lglecls(lgl, idx);
  lgl->_anon0.elm->negcls = lgl->_anon0.elm->necls;
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(&lgl->_anon0.elm->lits);
  lgl->_anon0.elm->neglidx = (signed int)return_value_lglcntstk_1;
  lglecls(lgl, -idx);

__CPROVER_DUMP_L1:
  ;
}

// lglinitsmallve
// file lglib.c line 10633
static signed int lglinitsmallve(struct LGL *lgl, signed int lit, unsigned long int *res)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int lidx;
  signed int mlit;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  const signed int *q;
  unsigned long int cls[64l];
  unsigned long int tmp[64l];
  struct HTS *hts;
  signed char val;

__CPROVER_DUMP_L1:
  ;
  lgls2m(lgl, lit);
  hts=lglhts(lgl, lit);
  lgltruefun(res);
  if(!(hts->count == 0))
  {
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
      blit = *p;
      tag = blit & MASKCS;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      if(!(tag == LRGCS))
      {
        red = blit & REDCS;
        if(red == 0)
        {
          lglfalsefun(cls);
          if(tag == BINCS || tag == TRNCS)
          {
            other = blit >> RMSHFT;
            val=lglval(lgl, other);
            if(val == 0)
            {
              mlit=lgls2m(lgl, other);
              if(mlit == 0)
                return 0;

              lgls2fun(mlit, tmp);
              lglorfun(cls, tmp);
            }

            if(tag == TRNCS)
            {
              other2 = *p;
              val=lglval(lgl, other2);
              if(val == 0)
              {
                mlit=lgls2m(lgl, other2);
                if(mlit == 0)
                  return 0;

                lgls2fun(mlit, tmp);
                lglorfun(cls, tmp);
              }

            }

          }

          else
          {
            lidx = blit >> RMSHFT;
            c=lglidx2lits(lgl, OCCS, 0, lidx);
            q = c;
            do
            {
              other = *q;
              if(other == 0)
                break;

              if(!(other == lit))
              {
                val=lglval(lgl, other);
                if(val == 0)
                {
                  mlit=lgls2m(lgl, other);
                  if(mlit == 0)
                    return 0;

                  lgls2fun(mlit, tmp);
                  lglorfun(cls, tmp);
                }

              }

              q = q + 1l;
            }
            while((_Bool)1);
          }
          lglandfun(res, cls);
          lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
          lgl->stats->elm.copies = lgl->stats->elm.copies + 1l;
        }

      }

    }
  }


DONE:
  ;
  return 1;
}

// lglinitsolve
// file lglib.c line 17331
static void lglinitsolve(struct LGL *lgl)
{
  if(!((signed int)lgl->state == READY))
    lglsetup(lgl);

  lglredvars(lgl);
  lglfitstk(lgl, &lgl->irr);
  lglrep(lgl, 1, (char)42);
}

// lglinnerprobe
// file lglib.c line 13860
static signed int lglinnerprobe(struct LGL *lgl, signed int old, struct Stk *outer, struct Stk *tmp)
{
  signed int i;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  signed int res;
  const signed int *w;
  const signed int *eow;
  const signed int *p;
  struct HTS *hts;
  i = old;
  unsigned long int return_value_lglcntstk_1;
  do
  {
    return_value_lglcntstk_1=lglcntstk(&lgl->trail);
    if((unsigned long int)i >= return_value_lglcntstk_1)
      break;

    lit=lglpeek(&lgl->trail, i);
    hts=lglhts(lgl, -lit);
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      blit = *p;
      tag = blit & MASKCS;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      if(!(tag == BINCS) && !(tag == LRGCS))
      {
        other = blit >> RMSHFT;
        signed char return_value_lglval_2;
        return_value_lglval_2=lglval(lgl, other);
        if(!((signed int)return_value_lglval_2 >= 1))
        {
          other2 = *p;
          signed char return_value_lglval_3;
          return_value_lglval_3=lglval(lgl, other2);
          if(!((signed int)return_value_lglval_3 >= 1))
          {
            other=abs(other);
            signed int return_value_lglmarked_4;
            return_value_lglmarked_4=lglmarked(lgl, other);
            if(return_value_lglmarked_4 == 0)
            {
              lglmark(lgl, other);
              lglpushstk(lgl, tmp, other);
            }


          __CPROVER_DUMP_L5:
            ;
            other2=abs(other2);
            signed int return_value_lglmarked_5;
            return_value_lglmarked_5=lglmarked(lgl, other2);
            if(return_value_lglmarked_5 == 0)
            {
              lglmark(lgl, other2);
              lglpushstk(lgl, tmp, other2);
            }

          }

        }

      }


    __CPROVER_DUMP_L7:
      ;
    }
    i = i + 1;
  }
  while((_Bool)1);

__CPROVER_DUMP_L12:
  ;
  res=lglrandomprobe(lgl, tmp);
  lglpopnunmarkstk(lgl, tmp);
  if(res == 0)
    res=lglrandomprobe(lgl, outer);

  return res;
}

// lglinout
// file lglib.c line 5262
static signed long int lglinout(struct LGL *lgl, signed int c, signed int relincpcnt)
{
  signed long int i = (signed long int)1;
  signed long int o = (signed long int)1;
  lgl->stats->inout.count = lgl->stats->inout.count + 1;
  lgl->stats->inout.steps = lgl->stats->inout.steps + (signed long int)c;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = c;
    c = c - 1;
    if(!(tmp_post_1 >= 1))
      break;

    i = ((signed long int)(100 + relincpcnt) * i + (signed long int)99) / (signed long int)100;
    if(i >= o)
    {
      i = (signed long int)1;
      o = ((signed long int)(100 + relincpcnt) * o + (signed long int)99) / (signed long int)100;
    }

  }
  while((_Bool)1);
  return i;
}

// lglinprocessing
// file lglib.c line 17186
static signed int lglinprocessing(struct LGL *lgl)
{
  signed int res;
  signed int oldrem;
  signed int return_value_lglsimplimhit_1;
  return_value_lglsimplimhit_1=lglsimplimhit(lgl);
  if(return_value_lglsimplimhit_1 == 0)
    return (signed int)!(lgl->mt != 0);

  else
  {
    lgl->stats->simp.count = lgl->stats->simp.count + 1;
    lglstart(lgl, &lgl->times->inpr);
    oldrem=lglrem(lgl);
    res=lglisimp(lgl);
    signed int return_value_lglsimpcntrem_2;
    return_value_lglsimpcntrem_2=lglsimpcntrem(lgl, oldrem);
    lglupdprepint(lgl, return_value_lglsimpcntrem_2);
    lglstop(lgl);
    return res;
  }
}

// lgliphase
// file lglib.c line 6478
static signed char lgliphase(struct LGL *lgl, signed int lit)
{
  signed char res;
  struct AVar *return_value_lglavar_1;
  return_value_lglavar_1=lglavar(lgl, lit);
  res = (signed char)return_value_lglavar_1->phase;
  if(!(lit >= 0))
    res = (signed char)-((signed int)res);

  return res;
}

// lglirepr
// file lglib.c line 7181
static signed int lglirepr(struct LGL *lgl, signed int lit)
{
  signed int return_value_lglptrjmp_1;
  return_value_lglptrjmp_1=lglptrjmp(lgl->repr, lgl->nvars - 1, lit);
  return return_value_lglptrjmp_1;
}

// lglis
// file lglib.c line 6735
static signed int * lglis(struct LGL *lgl)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int tag;
  signed int blit;
  signed int other;
  signed int other2;
  signed int red;
  signed int *res;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  signed char val;
  signed char tmp;
  signed char tmp2;
  struct HTS *hts;
  struct Stk *s;
  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
    res = (signed int *)return_value_lglnew_1;
  }
  while((_Bool)0);
  res = res + (signed long int)lgl->nvars;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      val=lglval(lgl, lit);
      if(!((signed int)val >= 1))
      {
        hts=lglhts(lgl, lit);
        if(!(hts->offset == 0))
        {
          w=lglhts2wchs(lgl, hts);
          eow = w + (signed long int)hts->count;
          p = w;
          for( ; !(p >= eow); p = p + 1l)
          {
            blit = *p;
            tag = blit & MASKCS;
            if(tag == TRNCS || tag == LRGCS)
              p = p + 1l;

            if(!(tag == LRGCS))
            {
              red = blit & REDCS;
              if(red == 0)
              {
                other = blit >> RMSHFT;
                signed int return_value_abs_2;
                return_value_abs_2=abs(other);
                signed int return_value_abs_3;
                return_value_abs_3=abs(lit);
                if(return_value_abs_2 >= return_value_abs_3)
                {
                  tmp=lglval(lgl, other);
                  if(!((signed int)tmp >= 1))
                  {
                    if(tag == BINCS)
                    {
                      res[(signed long int)lit] = res[(signed long int)lit] + 1;
                      res[(signed long int)other] = res[(signed long int)other] + 1;
                    }

                    else
                    {
                      other2 = *p;
                      signed int return_value_abs_4;
                      return_value_abs_4=abs(other2);
                      signed int return_value_abs_5;
                      return_value_abs_5=abs(lit);
                      if(!(return_value_abs_4 >= return_value_abs_5))
                        goto __CPROVER_DUMP_L14;

                      tmp2=lglval(lgl, other2);
                      if((signed int)tmp2 >= 1)
                        goto __CPROVER_DUMP_L14;

                      if(val == 0)
                        res[(signed long int)lit] = res[(signed long int)lit] + 1;

                      if(tmp == 0)
                        res[(signed long int)other] = res[(signed long int)other] + 1;

                      if(tmp2 == 0)
                        res[(signed long int)other2] = res[(signed long int)other2] + 1;

                    }
                  }

                }

              }

            }


          __CPROVER_DUMP_L14:
            ;
          }
        }

      }

    }
  }
  s = &lgl->irr;
  c = s->start;
  signed char return_value_lglval_6;
  for( ; !(c >= s->top); c = p + (signed long int)1)
  {
    p = c;
    if(!(*p >= 134217727))
    {
      val = (signed char)-1;
      do
      {
        other = *p;
        if(other == 0)
          break;

        tmp=lglval(lgl, other);
        if(!((signed int)val >= (signed int)tmp))
          val = tmp;

        p = p + 1l;
      }
      while((_Bool)1);
      if(!((signed int)val >= 1))
      {
        p = c;
        do
        {
          other = *p;
          if(other == 0)
            break;

          return_value_lglval_6=lglval(lgl, other);
          if(return_value_lglval_6 == 0)
            res[(signed long int)other] = res[(signed long int)other] + 1;

          p = p + 1l;
        }
        while((_Bool)1);
      }

    }

  }
  return res;
}

// lglisact
// file lglib.c line 3390
static signed int lglisact(signed int act)
{
  return (signed int)(0x7fffffff >> RMSHFT <= act && act < 0x7fffffff - 1);
}

// lglisat
// file lglib.c line 17581
static signed int lglisat(struct LGL *lgl, struct Lim *lim, signed int simpits)
{
  signed int res;
  signed int count;
  lglreset(lgl);
  lglinitsolve(lgl);
  res=lglsolve(lgl, lim, 0);
  count = 0;
  for( ; res == 0 && !(count >= simpits); count = count + 1)
  {
    lglprt(lgl, 1, "next forced simplification iteration %d", count);
    res=lglsolve(lgl, lim, 1);
  }
  signed int return_value_lglcompactify_1;
  return_value_lglcompactify_1=lglcompactify(lgl, res);
  if(!(return_value_lglcompactify_1 == 0))
    lglcompact(lgl);

  if(res == 0)
  {

  __CPROVER_DUMP_L4:
    ;
    do
      lgl->state = (enum State)UNKNOWN;
    while((_Bool)0);
    lglrep(lgl, 1, (char)63);
  }

  if(res == 10)
  {

  __CPROVER_DUMP_L6:
    ;
    do
      lgl->state = (enum State)SATISFIED;
    while((_Bool)0);
    lglrep(lgl, 1, (char)49);
  }

  if(res == 20)
  {

  __CPROVER_DUMP_L8:
    ;
    do
      lgl->state = (enum State)UNSATISFIED;
    while((_Bool)0);
    lglrep(lgl, 1, (char)48);
  }

  lglflshrep(lgl);
  if(res == 10)
    lglextend(lgl);

  return res;
}

// lgliselim
// file lglib.c line 2568
static signed int lgliselim(struct LGL *lgl, signed int lit)
{
  enum Tag tag;
  struct AVar *return_value_lglavar_1;
  return_value_lglavar_1=lglavar(lgl, lit);
  tag = (enum Tag)return_value_lglavar_1->type;
  return (signed int)((signed int)tag == ELIMVAR);
}

// lglisetphase
// file lglib.c line 3883
static void lglisetphase(struct LGL *lgl, signed int lit, signed int phase)
{
  struct AVar *av;
  if(!(lit >= 0))
  {
    lit = -lit;
    phase = -phase;
  }

  av=lglavar(lgl, lit);
  av->fase = phase;

__CPROVER_DUMP_L2:
  ;
}

// lglisfalsefun
// file lglib.c line 10525
static signed int lglisfalsefun(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!(f[(signed long int)i] == 0ul))
      return 0;

  return 1;
}

// lglisfree
// file lglib.c line 2342
static signed int lglisfree(struct LGL *lgl, signed int lit)
{
  struct AVar *return_value_lglavar_1;
  return_value_lglavar_1=lglavar(lgl, lit);
  return (signed int)((signed int)return_value_lglavar_1->type == FREEVAR);
}

// lglisimp
// file lglib.c line 17019
static signed int lglisimp(struct LGL *lgl)
{
  signed int return_value_lglternres_1;
  signed int return_value_lglgauss_4;
  signed int return_value_lgldecomp_7;
  signed int return_value_lglprobe_10;
  signed int return_value_lglcgrclsr_13;
  signed int return_value_lglift_16;
  signed int return_value_lglcliff_19;
  signed int return_value_lglunhide_22;
  signed int return_value_lgltrd_25;
  signed int return_value_lglcce_30;
  signed int return_value_lglelim_33;
  if(lgl->opts->simplify.val == 0)
    return 1;

  else
  {
    signed int return_value_lglternresolving_2;
    return_value_lglternresolving_2=lglternresolving(lgl);
    if(!(return_value_lglternresolving_2 == 0))
    {
      return_value_lglternres_1=lglternres(lgl);
      if(!(return_value_lglternres_1 == 0))
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      signed int return_value_lglterminate_3;
      return_value_lglterminate_3=lglterminate(lgl);
      if(!(return_value_lglterminate_3 == 0))
        return 1;

      else
      {
        signed int return_value_lglgaussing_5;
        return_value_lglgaussing_5=lglgaussing(lgl);
        if(!(return_value_lglgaussing_5 == 0))
        {
          return_value_lglgauss_4=lglgauss(lgl);
          if(!(return_value_lglgauss_4 == 0))
            goto __CPROVER_DUMP_L4;

          return 0;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          signed int return_value_lglterminate_6;
          return_value_lglterminate_6=lglterminate(lgl);
          if(!(return_value_lglterminate_6 == 0))
            return 1;

          else
          {
            signed int return_value_lgldecomposing_8;
            return_value_lgldecomposing_8=lgldecomposing(lgl);
            if(!(return_value_lgldecomposing_8 == 0))
            {
              return_value_lgldecomp_7=lgldecomp(lgl);
              if(!(return_value_lgldecomp_7 == 0))
                goto __CPROVER_DUMP_L6;

              return 0;
            }

            else
            {

            __CPROVER_DUMP_L6:
              ;
              signed int return_value_lglterminate_9;
              return_value_lglterminate_9=lglterminate(lgl);
              if(!(return_value_lglterminate_9 == 0))
                return 1;

              else
              {
                signed int return_value_lglprobing_11;
                return_value_lglprobing_11=lglprobing(lgl);
                if(!(return_value_lglprobing_11 == 0))
                {
                  return_value_lglprobe_10=lglprobe(lgl);
                  if(!(return_value_lglprobe_10 == 0))
                    goto __CPROVER_DUMP_L8;

                  return 0;
                }

                else
                {

                __CPROVER_DUMP_L8:
                  ;
                  signed int return_value_lglterminate_12;
                  return_value_lglterminate_12=lglterminate(lgl);
                  if(!(return_value_lglterminate_12 == 0))
                    return 1;

                  else
                  {
                    signed int return_value_lglcgrclosing_14;
                    return_value_lglcgrclosing_14=lglcgrclosing(lgl);
                    if(!(return_value_lglcgrclosing_14 == 0))
                    {
                      return_value_lglcgrclsr_13=lglcgrclsr(lgl);
                      if(!(return_value_lglcgrclsr_13 == 0))
                        goto __CPROVER_DUMP_L10;

                      return 0;
                    }

                    else
                    {

                    __CPROVER_DUMP_L10:
                      ;
                      signed int return_value_lglterminate_15;
                      return_value_lglterminate_15=lglterminate(lgl);
                      if(!(return_value_lglterminate_15 == 0))
                        return 1;

                      else
                      {
                        signed int return_value_lglifting_17;
                        return_value_lglifting_17=lglifting(lgl);
                        if(!(return_value_lglifting_17 == 0))
                        {
                          return_value_lglift_16=lglift(lgl);
                          if(!(return_value_lglift_16 == 0))
                            goto __CPROVER_DUMP_L12;

                          return 0;
                        }

                        else
                        {

                        __CPROVER_DUMP_L12:
                          ;
                          signed int return_value_lglterminate_18;
                          return_value_lglterminate_18=lglterminate(lgl);
                          if(!(return_value_lglterminate_18 == 0))
                            return 1;

                          else
                          {
                            signed int return_value_lglcliffing_20;
                            return_value_lglcliffing_20=lglcliffing(lgl);
                            if(!(return_value_lglcliffing_20 == 0))
                            {
                              return_value_lglcliff_19=lglcliff(lgl);
                              if(!(return_value_lglcliff_19 == 0))
                                goto __CPROVER_DUMP_L14;

                              return 0;
                            }

                            else
                            {

                            __CPROVER_DUMP_L14:
                              ;
                              signed int return_value_lglterminate_21;
                              return_value_lglterminate_21=lglterminate(lgl);
                              if(!(return_value_lglterminate_21 == 0))
                                return 1;

                              else
                              {
                                if(!(lgl->opts->card.val == 0))
                                  lglcard(lgl);

                                signed int return_value_lglunhiding_23;
                                return_value_lglunhiding_23=lglunhiding(lgl);
                                if(!(return_value_lglunhiding_23 == 0))
                                {
                                  return_value_lglunhide_22=lglunhide(lgl);
                                  if(!(return_value_lglunhide_22 == 0))
                                    goto __CPROVER_DUMP_L17;

                                  return 0;
                                }

                                else
                                {

                                __CPROVER_DUMP_L17:
                                  ;
                                  signed int return_value_lglterminate_24;
                                  return_value_lglterminate_24=lglterminate(lgl);
                                  if(!(return_value_lglterminate_24 == 0))
                                    return 1;

                                  else
                                  {
                                    signed int return_value_lgltreducing_26;
                                    return_value_lgltreducing_26=lgltreducing(lgl);
                                    if(!(return_value_lgltreducing_26 == 0))
                                    {
                                      return_value_lgltrd_25=lgltrd(lgl);
                                      if(!(return_value_lgltrd_25 == 0))
                                        goto __CPROVER_DUMP_L19;

                                      return 0;
                                    }

                                    else
                                    {

                                    __CPROVER_DUMP_L19:
                                      ;
                                      signed int return_value_lglterminate_27;
                                      return_value_lglterminate_27=lglterminate(lgl);
                                      if(!(return_value_lglterminate_27 == 0))
                                        return 1;

                                      else
                                      {
                                        signed int return_value_lglblocking_28;
                                        return_value_lglblocking_28=lglblocking(lgl);
                                        if(!(return_value_lglblocking_28 == 0))
                                          lglblock(lgl);

                                        signed int return_value_lglterminate_29;
                                        return_value_lglterminate_29=lglterminate(lgl);
                                        if(!(return_value_lglterminate_29 == 0))
                                          return 1;

                                        else
                                        {
                                          signed int return_value_lglcceing_31;
                                          return_value_lglcceing_31=lglcceing(lgl);
                                          if(!(return_value_lglcceing_31 == 0))
                                          {
                                            return_value_lglcce_30=lglcce(lgl);
                                            if(!(return_value_lglcce_30 == 0))
                                              goto __CPROVER_DUMP_L23;

                                            return 0;
                                          }

                                          else
                                          {

                                          __CPROVER_DUMP_L23:
                                            ;
                                            signed int return_value_lglterminate_32;
                                            return_value_lglterminate_32=lglterminate(lgl);
                                            if(!(return_value_lglterminate_32 == 0))
                                              return 1;

                                            else
                                            {
                                              signed int return_value_lgleliminating_34;
                                              return_value_lgleliminating_34=lgleliminating(lgl);
                                              if(!(return_value_lgleliminating_34 == 0))
                                              {
                                                return_value_lglelim_33=lglelim(lgl);
                                                if(!(return_value_lglelim_33 == 0))
                                                  goto __CPROVER_DUMP_L25;

                                                return 0;
                                              }

                                              else
                                              {

                                              __CPROVER_DUMP_L25:
                                                ;
                                                signed int return_value_lglterminate_35;
                                                return_value_lglterminate_35=lglterminate(lgl);
                                                if(!(return_value_lglterminate_35 == 0))
                                                  return 1;

                                                else
                                                {
                                                  if(!(lgl->opts->card.val == 0))
                                                    lglcard(lgl);

                                                  signed int return_value_lgltopgc_36;
                                                  return_value_lgltopgc_36=lgltopgc(lgl);
                                                  if(return_value_lgltopgc_36 == 0)
                                                    return 0;

                                                  else
                                                  {
                                                    signed int return_value_lglterminate_37;
                                                    return_value_lglterminate_37=lglterminate(lgl);
                                                    if(!(return_value_lglterminate_37 == 0))
                                                      return 1;

                                                    else
                                                    {
                                                      if(lgl->allphaseset == 0)
                                                        lglphase(lgl);

                                                      signed int return_value_lglterminate_38;
                                                      return_value_lglterminate_38=lglterminate(lgl);
                                                      if(!(return_value_lglterminate_38 == 0))
                                                        return 1;

                                                      else
                                                      {
                                                        lgldefrag(lgl);
                                                        return 1;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// lglislook
// file lglib.c line 8841
static signed int lglislook(struct LGL *lgl)
{
  signed long int best;
  signed long int pos;
  signed long int neg;
  signed long int score;
  signed int res;
  signed int idx;
  signed int elit;
  signed int *scores;
  struct Ext *ext;
  scores=lglis(lgl);
  res = 0;
  best = (signed long int)res;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree_1;
    return_value_lglisfree_1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree_1 == 0))
    {
      signed int return_value_lglexport_2;
      return_value_lglexport_2=lglexport(lgl, idx);
      struct Ext *return_value_lglelit2ext_3;
      return_value_lglelit2ext_3=lglelit2ext(lgl, return_value_lglexport_2);
      if(return_value_lglelit2ext_3->blocking == 0u)
      {
        pos = (signed long int)scores[(signed long int)idx];
        neg = (signed long int)scores[(signed long int)-idx];
        score = pos * neg + pos + neg;
        if(!(best >= score) || res == 0)
        {

        __CPROVER_DUMP_L3:
          ;
          res = pos > neg ? idx : -idx;
          best = score;
        }

      }

    }

  }
  scores = scores - (signed long int)lgl->nvars;
  do
  {
    lgldel(lgl, (void *)scores, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
    scores = ((signed int *)NULL);
  }
  while((_Bool)0);
  if(!(res == 0))
  {
    elit=lglexport(lgl, res);
    ext=lglelit2ext(lgl, elit);
    lglprt(lgl, 1, "[lislook] best look-ahead %ld score %d", res, (signed long long int)best);
    if(!(ext->melted == 0u))
      ext->melted = (unsigned int)0;

    else

      __CPROVER_DUMP_L8:
        ;
  }

  else

    __CPROVER_DUMP_L10:
      ;

__CPROVER_DUMP_L7:
  ;
  return res;
}

// lglispow2
// file lglib.c line 979
static signed int lglispow2(signed int n)
{
  return (signed int)!((n & n - 1) != 0);
}

// lglistruefun
// file lglib.c line 10532
static signed int lglistruefun(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!(f[(signed long int)i] == 18446744073709551615ul))
      return 0;

  return 1;
}

// lglitcanbemelted
// file lglib.c line 18027
signed int lglitcanbemelted(struct LGL *lgl, signed int elit)
{
  signed int res;
  struct Ext *ext;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglitcanbemelted");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "litcanbemelted %d", elit);
    break;
  }
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglitcanbemelted");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not check zero literal for being frozen");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  signed int return_value_abs_3;
  return_value_abs_3=abs(elit);
  signed int return_value_lglfixed_2;
  signed int return_value_lglerepr_1;
  if(!(lgl->maxext >= return_value_abs_3))
    res = 0;

  else
  {
    return_value_lglfixed_2=lglfixed(lgl, elit);
    if(!(return_value_lglfixed_2 == 0))
      res = 0;

    else
    {
      return_value_lglerepr_1=lglerepr(lgl, elit);
      if(!(return_value_lglerepr_1 == elit))
        res = 0;

      else
      {
        ext=lglelit2ext(lgl, elit);
        if(ext->frozen == 0)
          res = 0;

        else
          if(!(ext->melted == 0u))
            res = 0;

          else
            res = 1;
      }
    }
  }

__CPROVER_DUMP_L13:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglitcanbemelted(lgl->clone, elit);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglitcanbemelted");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d", (const void *)"lglitcanbemelted", elit, CLONERES, (const void *)"lglitcanbemelted", elit, res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglitgone
// file lglib.c line 18014
signed int lglitgone(struct LGL *lgl, signed int elit)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglitgone");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "litgone %d", elit);
    break;
  }
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglitgone");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not check zero literal for being gone");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  signed int return_value_abs_4;
  return_value_abs_4=abs(elit);
  signed int return_value_lglfixed_3;
  signed int return_value_lglerepr_2;
  struct Ext *return_value_lglelit2ext_1;
  if(!(lgl->maxext >= return_value_abs_4))
    res = 1;

  else
  {
    return_value_lglfixed_3=lglfixed(lgl, elit);
    if(!(return_value_lglfixed_3 == 0))
      res = 1;

    else
    {
      return_value_lglerepr_2=lglerepr(lgl, elit);
      if(!(return_value_lglerepr_2 == elit))
        res = 1;

      else
      {
        return_value_lglelit2ext_1=lglelit2ext(lgl, elit);
        res = (signed int)return_value_lglelit2ext_1->eliminated;
      }
    }
  }

__CPROVER_DUMP_L11:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglitgone(lgl->clone, elit);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglitgone");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d", (const void *)"lglitgone", elit, CLONERES, (const void *)"lglitgone", elit, res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lgljoin
// file lglib.h line 83
signed int lgljoin(struct LGL *to, struct LGL *from)
{
  signed int elit;
  signed int ok;
  signed int ilit;
  signed int val;
  signed int res;
  signed int expected;
  struct LGL *lgl = to;
  const signed int *p;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lgljoin");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(to->forked == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lgljoin");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "expected forked state");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lglreqinit(from);
  lglstart(to, &to->times->all);
  if(to->level >= 1)
    lglbacktrack(to, 0);

  _Bool tmp_if_expr_2;
  signed int return_value_lglfailed_1;
  _Bool tmp_if_expr_4;
  if(!((384 & (signed int)from->state) == 0))
  {
    expected = 20;
    signed int return_value_lglmtstk_3;
    return_value_lglmtstk_3=lglmtstk(&from->fassume);
    if(!(return_value_lglmtstk_3 == 0))
    {

    __CPROVER_DUMP_L8:
      ;
      to->mt = 1;
    }

    else
    {
      p = from->fassume.start;
      for( ; !(p >= from->fassume.top); p = p + 1l)
      {
        elit = *p;
        if(!(from->bruteforked == 0))
          tmp_if_expr_2 = (_Bool)1;

        else
        {
          return_value_lglfailed_1=lglfailed(from, elit);
          tmp_if_expr_2 = return_value_lglfailed_1 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_2)
          lglfjadd(to, -elit);

      }
      lglfjadd(to, 0);
      lglforkmerge(to, from);
    }
  }

  else
    if(!((96 & (signed int)from->state) == 0))
    {
      expected = 10;
      lglforkmerge(to, from);
      ok=lglbcp(to);
      if(!(ok == 0))
      {
        elit = 1;
        do
        {
          if(!(ok == 0))
            tmp_if_expr_4 = elit <= to->maxext ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(!tmp_if_expr_4)
            break;

          if(from->maxext >= elit)
          {
            struct Ext *return_value_lglelit2ext_5;
            return_value_lglelit2ext_5=lglelit2ext(from, elit);
            if(!(return_value_lglelit2ext_5->imported == 0u))
            {
              val=lglderef(from, elit);
              if(!(val == 0))
              {
                ilit=lglimport(to, elit);
                signed int return_value_abs_6;
                return_value_abs_6=abs(ilit);
                if(!(return_value_abs_6 == 1))
                {
                  signed char return_value_lglval_7;
                  return_value_lglval_7=lglval(to, ilit);
                  if(return_value_lglval_7 == 0)
                  {
                    lgldassume(to, val < 0 ? -ilit : ilit);
                    ok=lglbcp(to);
                  }

                }

              }

            }

          }

          elit = elit + 1;
        }
        while((_Bool)1);
      }

    }

    else
    {
      expected = 0;
      lglforkmerge(to, from);
    }
  lglrelease(from);
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_10;
  unsigned long int return_value_lglcntstk_9;
  if(!(to->mt == 0))
    res = 20;

  else
    if(!(expected == 0))
      res=lglisat(to, ((struct Lim *)NULL), 0);

    else
    {
      if(!(to->conf.lit == 0))
        tmp_if_expr_8 = (_Bool)1;

      else
        tmp_if_expr_8 = to->next2 < to->next ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_8)
        tmp_if_expr_10 = (_Bool)1;

      else
      {
        return_value_lglcntstk_9=lglcntstk(&to->trail);
        tmp_if_expr_10 = (unsigned long int)to->next < return_value_lglcntstk_9 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_10)
      {
        if(to->level >= 1)
        {
          lglbacktrack(to, 0);
          res = 0;
        }

        else
        {
          if(to->conf.lit == 0)
            lglbcp(to);

          if(!(to->conf.lit == 0))
          {
            if(to->mt == 0)
            {

            __CPROVER_DUMP_L35:
              ;
              to->mt = 1;
            }

            res = 20;
          }

          else
            res = 0;
        }
      }

      else
        res = 0;
    }
  to->forked = (char)0;
  lglrep(to, 1, (char)106);
  lglstop(to);
  return res;
}

// lgljwh
// file lglib.c line 6665
static void lgljwh(struct LGL *lgl)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int tag;
  signed int blit;
  signed int other;
  signed int other2;
  signed int red;
  signed int size;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  signed char val;
  signed char tmp;
  signed char tmp2;
  struct HTS *hts;
  struct Stk *s;
  signed long int inc;
  do
    memset((void *)lgl->jwh, 0, (unsigned long int)(2 * lgl->nvars) * sizeof(signed long int) /*8ul*/ );
  while((_Bool)0);
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      val=lglval(lgl, lit);
      if(!((signed int)val >= 1))
      {
        hts=lglhts(lgl, lit);
        if(!(hts->offset == 0))
        {
          w=lglhts2wchs(lgl, hts);
          eow = w + (signed long int)hts->count;
          p = w;
          for( ; !(p >= eow); p = p + 1l)
          {
            blit = *p;
            tag = blit & MASKCS;
            if(tag == TRNCS || tag == LRGCS)
              p = p + 1l;

            if(!(tag == LRGCS))
            {
              red = blit & REDCS;
              if(red == 0)
              {
                other = blit >> RMSHFT;
                signed int return_value_abs_1;
                return_value_abs_1=abs(other);
                signed int return_value_abs_2;
                return_value_abs_2=abs(lit);
                if(return_value_abs_1 >= return_value_abs_2)
                {
                  tmp=lglval(lgl, other);
                  if(!((signed int)tmp >= 1))
                  {
                    if(tag == BINCS)
                    {
                      inc=lglflt(-2, (unsigned long int)1);
                      lglincjwh(lgl, lit, inc);
                      lglincjwh(lgl, other, inc);
                    }

                    else
                    {
                      other2 = *p;
                      signed int return_value_abs_3;
                      return_value_abs_3=abs(other2);
                      signed int return_value_abs_4;
                      return_value_abs_4=abs(lit);
                      if(!(return_value_abs_3 >= return_value_abs_4))
                        goto __CPROVER_DUMP_L11;

                      tmp2=lglval(lgl, other2);
                      if((signed int)tmp2 >= 1)
                        goto __CPROVER_DUMP_L11;

                      size = 3 + (signed int)val + (signed int)tmp + (signed int)tmp2;
                      inc=lglflt(-size, (unsigned long int)1);
                      lglincjwh(lgl, lit, inc);
                      lglincjwh(lgl, other, inc);
                      lglincjwh(lgl, other2, inc);
                    }
                  }

                }

              }

            }


          __CPROVER_DUMP_L11:
            ;
          }
        }

      }

    }
  }
  s = &lgl->irr;
  c = s->start;
  signed char return_value_lglval_5;
  for( ; !(c >= s->top); c = p + (signed long int)1)
  {
    p = c;
    if(!(*p >= 134217727))
    {
      val = (signed char)-1;
      size = 0;
      do
      {
        other = *p;
        if(other == 0)
          break;

        tmp=lglval(lgl, other);
        if(!((signed int)val >= (signed int)tmp))
          val = tmp;

        if(tmp == 0)
          size = size + 1;

        p = p + 1l;
      }
      while((_Bool)1);
      if(!((signed int)val >= 1))
      {
        inc=lglflt(-size, (unsigned long int)1);
        p = c;
        do
        {
          other = *p;
          if(other == 0)
            break;

          return_value_lglval_5=lglval(lgl, other);
          if(return_value_lglval_5 == 0)
            lglincjwh(lgl, other, inc);

          p = p + 1l;
        }
        while((_Bool)1);
      }

    }

  }
}

// lgljwhlook
// file lglib.c line 8804
static signed int lgljwhlook(struct LGL *lgl)
{
  signed long int best;
  signed long int pos;
  signed long int neg;
  signed long int score;
  signed int res;
  signed int idx;
  signed int elit;
  struct Ext *ext;
  lgljwh(lgl);
  best = 0x0000000000000000ll;
  res = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree_1;
    return_value_lglisfree_1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree_1 == 0))
    {
      signed int return_value_lglexport_2;
      return_value_lglexport_2=lglexport(lgl, idx);
      struct Ext *return_value_lglelit2ext_3;
      return_value_lglelit2ext_3=lglelit2ext(lgl, return_value_lglexport_2);
      if(return_value_lglelit2ext_3->blocking == 0u)
      {
        signed int return_value_lglulit_4;
        return_value_lglulit_4=lglulit(idx);
        pos = lgl->jwh[(signed long int)return_value_lglulit_4];
        signed int return_value_lglulit_5;
        return_value_lglulit_5=lglulit(-idx);
        neg = lgl->jwh[(signed long int)return_value_lglulit_5];
        score=lglmulflt(pos, neg);
        signed long int return_value_lgladdflt_6;
        return_value_lgladdflt_6=lgladdflt(pos, neg);
        score=lgladdflt(score, return_value_lgladdflt_6);
        if(!(best >= score) || res == 0)
        {

        __CPROVER_DUMP_L3:
          ;
          res = pos > neg ? idx : -idx;
          best = score;
        }

      }

    }

  }
  if(!(res == 0))
  {
    elit=lglexport(lgl, res);
    ext=lglelit2ext(lgl, elit);
    const char *return_value_lglflt2str_7;
    return_value_lglflt2str_7=lglflt2str(lgl, best);
    lglprt(lgl, 1, "[jwhlook] best look-ahead %d score %s", res, return_value_lglflt2str_7);
    if(!(ext->melted == 0u))
      ext->melted = (unsigned int)0;

    else

      __CPROVER_DUMP_L7:
        ;
  }

  else

    __CPROVER_DUMP_L9:
      ;

__CPROVER_DUMP_L6:
  ;
  return res;
}

// lglm2i
// file lglib.c line 9265
static signed int lglm2i(struct LGL *lgl, signed int mlit)
{
  signed int res;
  signed int midx;
  midx=abs(mlit);
  res=lglpeek(&lgl->_anon0.elm->m2i, midx);
  if(!(mlit >= 0))
    res = -res;

  return res;
}

// lglmap
// file lglib.c line 7574
static void lglmap(struct LGL *lgl)
{
  signed int size;
  signed int *map;
  signed int oldnvars;
  signed int mapsize;
  size=lglmapsize(lgl);
  oldnvars = lgl->nvars;
  mapsize=lglmax(oldnvars, 2);
  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)mapsize * sizeof(signed int) /*4ul*/ );
    map = (signed int *)return_value_lglnew_1;
  }
  while((_Bool)0);
  lglmapnonequiv(lgl, map, size);
  lglmapequiv(lgl, map);
  lglforce(lgl, map);
  lglmaptrail(lgl, map);
  lglflushqmerged(lgl);
  lglmapqueue(lgl, map);
  lglmapvars(lgl, map, size + 2);
  lglmaplits(lgl, map);
  if(!(lgl->cgrclosing == 0))
    lglmapstk(lgl, map, &lgl->_anon0.cgr->units);

  lglmapext(lgl, map);
  lglmapass(lgl, map);
  lglmaphts(lgl, map);
  do
  {
    lgldel(lgl, (void *)map, (unsigned long int)mapsize * sizeof(signed int) /*4ul*/ );
    map = ((signed int *)NULL);
  }
  while((_Bool)0);
  if(!(lgl->repr == ((signed int *)NULL)))
    do
    {
      lgldel(lgl, (void *)lgl->repr, (unsigned long int)oldnvars * sizeof(signed int) /*4ul*/ );
      lgl->repr = ((signed int *)NULL);
    }
    while((_Bool)0);

  lglpicosatrestart(lgl);
  lgl->unassigned = size;
}

// lglmapass
// file lglib.c line 7230
static void lglmapass(struct LGL *lgl, signed int *map)
{
  signed int *p;
  signed int *q;
  signed int iass;
  signed int mass;
  signed int flushed;
  unsigned int bit;
  struct AVar *av;
  signed int return_value_abs_1;
  return_value_abs_1=abs(lgl->failed);
  if(!(return_value_abs_1 == 1))
    lgl->failed=lglmaplit(map, lgl->failed);

  q = lgl->assume.start;
  p = q;
  signed int *tmp_post_2;
  for( ; !(p >= lgl->assume.top); p = p + 1l)
  {
    iass = *p;
    mass=lglmaplit(map, iass);
    if(!(mass == 1))
    {
      if(mass == -1)
      {
        if(!(lgl->failed == -1))
        {

        __CPROVER_DUMP_L3:
          ;
          lgl->failed = -1;
        }

      }

      else
      {

      __CPROVER_DUMP_L5:
        ;
        av=lglavar(lgl, mass);
        bit = 1u << (signed int)(mass < 0);
        if((bit & (unsigned int)av->assumed) == 0u)
        {

        __CPROVER_DUMP_L6:
          ;
          av->assumed = (unsigned int)av->assumed | bit;
        }

        tmp_post_2 = q;
        q = q + 1l;
        *tmp_post_2 = mass;
      }
    }

  }
  lgl->assume.top = q;
  flushed = 0;
  q = lgl->assume.start;
  p = q;
  signed int *tmp_post_4;
  for( ; !(p >= lgl->assume.top); p = p + 1l)
  {
    iass = *p;
    signed int return_value_lglsignedmarked_3;
    return_value_lglsignedmarked_3=lglsignedmarked(lgl, iass);
    if(!(return_value_lglsignedmarked_3 == 0))
      flushed = flushed + 1;

    else
    {
      lglsignedmark(lgl, iass);
      tmp_post_4 = q;
      q = q + 1l;
      *tmp_post_4 = iass;
    }
  }
  lgl->assume.top = q;
  p = lgl->assume.start;
  for( ; !(p >= lgl->assume.top); p = p + 1l)
  {
    iass = *p;
    lglsignedunmark(lgl, iass);
  }
  if(!(flushed == 0))

    __CPROVER_DUMP_L16:
      ;

}

// lglmapequiv
// file lglib.c line 7413
static void lglmapequiv(struct LGL *lgl, signed int *map)
{
  signed int idx;
  signed int repr;
  signed int dst;
  struct AVar *av;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
    if(map[(signed long int)idx] == 0)
    {
      av=lglavar(lgl, idx);
      if(!((signed int)av->type == ELIMVAR))
      {
        repr=lglirepr(lgl, idx);
        dst=lglmaplit(map, repr);

      __CPROVER_DUMP_L2:
        ;
        map[(signed long int)idx] = dst;
      }

    }

}

// lglmapext
// file lglib.c line 7186
static void lglmapext(struct LGL *lgl, signed int *map)
{
  signed int eidx;
  signed int ilit;
  signed int mlit;
  struct Ext *ext;
  eidx = 1;
  for( ; lgl->maxext >= eidx; eidx = eidx + 1)
    lglerepr(lgl, eidx);
  eidx = 1;
  for( ; lgl->maxext >= eidx; eidx = eidx + 1)
  {
    ext = lgl->ext + (signed long int)eidx;
    if(!(ext->imported == 0u))
    {
      if(!(ext->equiv == 0u))

        __CPROVER_DUMP_L4:
          ;

      else
      {
        ilit = ext->repr;
        mlit=lglmaplit(map, ilit);

      __CPROVER_DUMP_L6:
        ;
        ext->repr = mlit;
      }
    }

  }
}

// lglmapglue
// file lglib.c line 6973
static void lglmapglue(struct LGL *lgl, signed int *map, struct Stk *lits)
{
  signed int *p;
  signed int *eol = lits->top;
  p = lits->start;
  signed int return_value_lglisact_1;
  for( ; !(p >= eol); p = p + 1l)
  {
    return_value_lglisact_1=lglisact(*p);
    if(return_value_lglisact_1 == 0)
      *p=lglmaplit(map, *p);

  }
}

// lglmaphts
// file lglib.c line 7054
static void lglmaphts(struct LGL *lgl, signed int *map)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int *w;
  signed int *eow;
  signed int *p;
  signed int other;
  signed int other2;
  signed int blit;
  signed int tag;
  signed int red;
  signed int newblit;
  signed int newother;
  signed int newother2;
  struct HTS *hts;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      hts=lglhts(lgl, lit);
      if(!(hts->count == 0))
      {
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          tag = blit & MASKCS;
          red = blit & REDCS;
          other = blit >> RMSHFT;
          newother=lglmaplit(map, other);
          newblit = newother << RMSHFT | tag | red;
          *p = newblit;
          if(!(tag == BINCS))
          {
            p = p + 1l;
            other2 = *p;
            if(!(tag == LRGCS))
            {
              newother2=lglmaplit(map, other2);
              *p = newother2;
            }

          }

        }
      }

    }
  }
}

// lglmaplit
// file lglib.c line 6962
static signed int lglmaplit(signed int *map, signed int lit)
{
  signed int return_value_abs_1;
  return_value_abs_1=abs(lit);
  signed int return_value_lglsgn_2;
  return_value_lglsgn_2=lglsgn(lit);
  return map[(signed long int)return_value_abs_1] * return_value_lglsgn_2;
}

// lglmaplits
// file lglib.c line 6980
static void lglmaplits(struct LGL *lgl, signed int *map)
{
  signed int glue;
  lglmapstk(lgl, map, &lgl->irr);
  glue = 0;
  for( ; !(glue >= 15); glue = glue + 1)
    lglmapglue(lgl, map, &lgl->red[(signed long int)glue]);
}

// lglmapnonequiv
// file lglib.c line 7382
static void lglmapnonequiv(struct LGL *lgl, signed int *map, signed int size)
{
  signed int count = 0;
  signed int idx;
  struct AVar *av;
  signed char val;
  map[(signed long int)0] = 0;
  map[(signed long int)1] = 1;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    if(map[(signed long int)idx] == 0)
    {
      av=lglavar(lgl, idx);
      if((signed int)av->type == FREEVAR)
      {
        if(!(map[(signed long int)idx] == 0))
          goto __CPROVER_DUMP_L7;


      __CPROVER_DUMP_L2:
        ;
        map[(signed long int)idx] = count + 2;
        count = count + 1;
      }

      else
        if(!((signed int)av->type == EQUIVAR))
        {
          if((signed int)av->type == FIXEDVAR)
          {
            val = lgl->vals[(signed long int)idx];

          __CPROVER_DUMP_L5:
            ;
            map[(signed long int)idx] = (signed int)val;
          }

          else
            map[(signed long int)idx] = 0;
        }

    }


  __CPROVER_DUMP_L7:
    ;
  }
}

// lglmapqln
// file lglib.c line 7098
static void lglmapqln(struct LGL *lgl, struct Qln *line, signed int *map)
{
  signed int prev;
  signed int lglmapqln__1__next;
  signed int i;
  struct Qnd *n;
  struct Qnd *m;
  i = line->first;
  _Bool tmp_if_expr_2;
  signed int return_value_lglisfree_1;
  do
  {
    if(!(i == 0))
    {
      return_value_lglisfree_1=lglisfree(lgl, i);
      tmp_if_expr_2 = !(return_value_lglisfree_1 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    n=lglqnd(lgl, i);
    lglmapqln__1__next = n->next;
    do
      memset((void *)n, 0, sizeof(struct Qnd) /*16ul*/ );
    while((_Bool)0);
    i = lglmapqln__1__next;
  }
  while((_Bool)1);
  signed int return_value_lglisfree_4;
  signed int tmp_if_expr_7;
  signed int return_value_lglmaplit_5;
  signed int return_value_abs_6;
  signed int tmp_if_expr_10;
  signed int return_value_lglmaplit_8;
  signed int return_value_abs_9;
  if(!(i == 0))
  {
    signed int return_value_lglmaplit_3;
    return_value_lglmaplit_3=lglmaplit(map, i);
    line->first=abs(return_value_lglmaplit_3);
    prev = 0;
    for( ; !(i == 0); i = lglmapqln__1__next)
    {
      n=lglqnd(lgl, i);
      lglmapqln__1__next = n->next;
      while(!(lglmapqln__1__next == 0))
      {
        return_value_lglisfree_4=lglisfree(lgl, lglmapqln__1__next);
        if(!(return_value_lglisfree_4 == 0))
          break;

        m=lglqnd(lgl, lglmapqln__1__next);
        lglmapqln__1__next = m->next;
        do
          memset((void *)m, 0, sizeof(struct Qnd) /*16ul*/ );
        while((_Bool)0);
      }
      if(!(prev == 0))
      {
        return_value_lglmaplit_5=lglmaplit(map, prev);
        return_value_abs_6=abs(return_value_lglmaplit_5);
        tmp_if_expr_7 = return_value_abs_6;
      }

      else
        tmp_if_expr_7 = 0;
      n->prev = tmp_if_expr_7;
      if(!(lglmapqln__1__next == 0))
      {
        return_value_lglmaplit_8=lglmaplit(map, lglmapqln__1__next);
        return_value_abs_9=abs(return_value_lglmaplit_8);
        tmp_if_expr_10 = return_value_abs_9;
      }

      else
        tmp_if_expr_10 = 0;
      n->next = tmp_if_expr_10;
      prev = i;
    }
    signed int return_value_lglmaplit_11;
    return_value_lglmaplit_11=lglmaplit(map, prev);
    line->last=abs(return_value_lglmaplit_11);
  }

  else
  {
    line->last = 0;
    line->first = line->last;
  }
  line->unassigned = line->first;
}

// lglmapqueue
// file lglib.c line 7125
static void lglmapqueue(struct LGL *lgl, signed int *map)
{
  struct Qln *p;
  struct Qln *up;
  struct Qln *down = ((struct Qln *)NULL);
  p = lgl->queue.bottom;
  for( ; !(p == ((struct Qln *)NULL)); p = up)
  {
    up = p->up;
    lglmapqln(lgl, p, map);
    if(!(p->first == 0))
    {
      if(!(down == ((struct Qln *)NULL)))
        down->up = p;

      else
        lgl->queue.bottom = p;
      p->down = down;
      down = p;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      lgl->queue.nlines = lgl->queue.nlines - 1;
      lgl->stats->queue.del = lgl->stats->queue.del + 1l;
      p->up = lgl->queue.free;
      lgl->queue.free = p;
    }
  }
  if(!(down == ((struct Qln *)NULL)))
    down->up = ((struct Qln *)NULL);

  else
    lgl->queue.bottom = ((struct Qln *)NULL);
  lgl->queue.top = down;
  lgl->queue.unassigned = lgl->queue.top;
}

// lglmapsize
// file lglib.c line 7374
static signed int lglmapsize(struct LGL *lgl)
{
  signed int size = 0;
  signed int idx = 2;
  signed int return_value_lglisfree_1;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    return_value_lglisfree_1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree_1 == 0))
      size = size + 1;

  }

__CPROVER_DUMP_L4:
  ;
  return size;
}

// lglmapstk
// file lglib.c line 6966
static void lglmapstk(struct LGL *lgl, signed int *map, struct Stk *lits)
{
  signed int *p;
  signed int *eol = lits->top;
  p = lits->start;
  for( ; !(p >= eol); p = p + 1l)
    *p=lglmaplit(map, *p);
}

// lglmaptrail
// file lglib.c line 7084
static void lglmaptrail(struct LGL *lgl, signed int *map)
{
  signed int *p;
  signed int *q;
  signed int src;
  signed int dst;
  p = lgl->trail.start;
  signed int return_value_lglevel_1;
  for( ; !(p >= lgl->trail.top); p = p + 1l)
  {
    return_value_lglevel_1=lglevel(lgl, *p);
    if(return_value_lglevel_1 >= 1)
      break;

  }
  q = lgl->trail.start;
  signed int *tmp_post_2;
  for( ; !(p >= lgl->trail.top); p = p + 1l)
  {
    src = *p;
    dst=lglmaplit(map, src);
    tmp_post_2 = q;
    q = q + 1l;
    *tmp_post_2 = dst;
  }
  lgl->trail.top = q;
  unsigned long int return_value_lglcntstk_3;
  return_value_lglcntstk_3=lglcntstk(&lgl->trail);
  lgl->next = (signed int)return_value_lglcntstk_3;
  lgl->next2 = lgl->next;
  lgl->flushed = lgl->next2;
}

// lglmapvars
// file lglib.c line 6987
static void lglmapvars(struct LGL *lgl, signed int *map, signed int nvars)
{
  signed int i;
  signed int oldnvars = lgl->nvars;
  signed int sign;
  signed int udst;
  signed int idst;
  signed int usrc;
  signed int isrc;
  struct DVar *dvars;
  struct AVar *avars;
  struct Qnd *nodes;
  signed char *lglmapvars__1__vals;
  signed int *i2e;
  signed long int *jwh;
  if(!(nvars >= 3))
    nvars = 0;

  do
  {
    lgldel(lgl, (void *)lgl->doms, (unsigned long int)(2 * lgl->szvars) * sizeof(signed int) /*4ul*/ );
    lgl->doms = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)(2 * nvars) * sizeof(signed int) /*4ul*/ );
    lgl->doms = (signed int *)return_value_lglnew_1;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew_2;
    return_value_lglnew_2=lglnew(lgl, (unsigned long int)nvars * sizeof(signed char) /*1ul*/ );
    lglmapvars__1__vals = (signed char *)return_value_lglnew_2;
  }
  while((_Bool)0);
  i = 2;
  signed int return_value_lglisfree_3;
  for( ; !(i >= oldnvars); i = i + 1)
  {
    return_value_lglisfree_3=lglisfree(lgl, i);
    if(!(return_value_lglisfree_3 == 0))
      lglmapvars__1__vals[(signed long int)map[(signed long int)i]] = lgl->vals[(signed long int)i];

  }
  do
  {
    lgldel(lgl, (void *)lgl->vals, (unsigned long int)lgl->szvars * sizeof(signed char) /*1ul*/ );
    lgl->vals = ((signed char *)NULL);
  }
  while((_Bool)0);
  lgl->vals = lglmapvars__1__vals;
  do
  {
    void *return_value_lglnew_4;
    return_value_lglnew_4=lglnew(lgl, (unsigned long int)nvars * sizeof(signed int) /*4ul*/ );
    i2e = (signed int *)return_value_lglnew_4;
  }
  while((_Bool)0);
  i = 2;
  signed int return_value_lglisfree_5;
  for( ; !(i >= oldnvars); i = i + 1)
  {
    return_value_lglisfree_5=lglisfree(lgl, i);
    if(!(return_value_lglisfree_5 == 0))
      i2e[(signed long int)map[(signed long int)i]] = lgl->i2e[(signed long int)i];

  }
  do
  {
    lgldel(lgl, (void *)lgl->i2e, (unsigned long int)lgl->szvars * sizeof(signed int) /*4ul*/ );
    lgl->i2e = ((signed int *)NULL);
  }
  while((_Bool)0);
  lgl->i2e = i2e;
  do
  {
    void *return_value_lglnew_6;
    return_value_lglnew_6=lglnew(lgl, (unsigned long int)nvars * sizeof(struct DVar) /*16ul*/ );
    dvars = (struct DVar *)return_value_lglnew_6;
  }
  while((_Bool)0);
  i = 2;
  signed int return_value_lglisfree_7;
  for( ; !(i >= oldnvars); i = i + 1)
  {
    return_value_lglisfree_7=lglisfree(lgl, i);
    if(!(return_value_lglisfree_7 == 0))
      dvars[(signed long int)map[(signed long int)i]] = lgl->dvars[(signed long int)i];

  }
  do
  {
    lgldel(lgl, (void *)lgl->dvars, (unsigned long int)lgl->szvars * sizeof(struct DVar) /*16ul*/ );
    lgl->dvars = ((struct DVar *)NULL);
  }
  while((_Bool)0);
  lgl->dvars = dvars;
  do
  {
    void *return_value_lglnew_8;
    return_value_lglnew_8=lglnew(lgl, (unsigned long int)(2 * nvars) * sizeof(signed long int) /*8ul*/ );
    jwh = (signed long int *)return_value_lglnew_8;
  }
  while((_Bool)0);
  i = 2;
  signed int return_value_lglisfree_9;
  for( ; !(i >= oldnvars); i = i + 1)
  {
    return_value_lglisfree_9=lglisfree(lgl, i);
    if(!(return_value_lglisfree_9 == 0))
    {
      sign = -1;
      for( ; !(sign >= 2); sign = sign + 2)
      {
        isrc = sign * i;
        idst = sign * map[(signed long int)i];
        usrc=lglulit(isrc);
        udst=lglulit(idst);
        jwh[(signed long int)udst]=lgladdflt(jwh[(signed long int)udst], lgl->jwh[(signed long int)usrc]);
      }
    }

  }
  do
  {
    lgldel(lgl, (void *)lgl->jwh, (unsigned long int)(2 * lgl->szvars) * sizeof(signed long int) /*8ul*/ );
    lgl->jwh = ((signed long int *)NULL);
  }
  while((_Bool)0);
  lgl->jwh = jwh;
  do
  {
    void *return_value_lglnew_10;
    return_value_lglnew_10=lglnew(lgl, (unsigned long int)nvars * sizeof(struct Qnd) /*16ul*/ );
    nodes = (struct Qnd *)return_value_lglnew_10;
  }
  while((_Bool)0);
  i = 2;
  signed int return_value_lglisfree_11;
  for( ; !(i >= oldnvars); i = i + 1)
  {
    return_value_lglisfree_11=lglisfree(lgl, i);
    if(!(return_value_lglisfree_11 == 0))
      nodes[(signed long int)map[(signed long int)i]] = lgl->queue.nodes[(signed long int)i];

  }
  do
  {
    lgldel(lgl, (void *)lgl->queue.nodes, (unsigned long int)lgl->szvars * sizeof(struct Qnd) /*16ul*/ );
    lgl->queue.nodes = ((struct Qnd *)NULL);
  }
  while((_Bool)0);
  lgl->queue.nodes = nodes;
  do
  {
    void *return_value_lglnew_12;
    return_value_lglnew_12=lglnew(lgl, (unsigned long int)nvars * sizeof(struct AVar) /*12ul*/ );
    avars = (struct AVar *)return_value_lglnew_12;
  }
  while((_Bool)0);
  i = 2;
  signed int return_value_lglisfree_13;
  for( ; !(i >= oldnvars); i = i + 1)
  {
    return_value_lglisfree_13=lglisfree(lgl, i);
    if(!(return_value_lglisfree_13 == 0))
      avars[(signed long int)map[(signed long int)i]] = lgl->avars[(signed long int)i];

  }
  do
  {
    lgldel(lgl, (void *)lgl->avars, (unsigned long int)lgl->szvars * sizeof(struct AVar) /*12ul*/ );
    lgl->avars = ((struct AVar *)NULL);
  }
  while((_Bool)0);
  lgl->avars = avars;
  lgl->szvars = nvars;
  lgl->nvars = lgl->szvars;
  lgl->stats->fixed.current = 0;
}

// lglmark
// file lglib.c line 2939
static void lglmark(struct LGL *lgl, signed int lit)
{
  struct AVar *return_value_lglavar_1;
  return_value_lglavar_1=lglavar(lgl, lit);
  return_value_lglavar_1->mark=lglsgn(lit);
}

// lglmarked
// file lglib.c line 2843
static signed int lglmarked(struct LGL *lgl, signed int lit)
{
  signed int res;
  struct AVar *return_value_lglavar_1;
  return_value_lglavar_1=lglavar(lgl, lit);
  res = return_value_lglavar_1->mark;
  if(!(lit >= 0))
    res = -res;

  return res;
}

// lglmatchbingate
// file lglib.c line 13124
static signed int lglmatchbingate(struct LGL *lgl, struct Gat *g, struct Gat *h)
{
  signed int g0;
  g0=lglcgrepr(lgl, g->_anon0.lits[(signed long int)0]);
  signed int g1;
  g1=lglcgrepr(lgl, g->_anon0.lits[(signed long int)1]);
  signed int h0;
  h0=lglcgrepr(lgl, h->_anon0.lits[(signed long int)0]);
  signed int h1;
  h1=lglcgrepr(lgl, h->_anon0.lits[(signed long int)1]);
  signed int sign;
  lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
  if((signed int)g->tag == XORTAG)
  {
    sign = 1;
    if(!(g0 >= 0))
    {
      sign = -sign;
      g0 = -g0;
    }

    if(!(g1 >= 0))
    {
      sign = -sign;
      g1 = -g1;
    }

    if(!(h0 >= 0))
    {
      sign = -sign;
      h0 = -h0;
    }

    if(!(h1 >= 0))
    {
      sign = -sign;
      h1 = -h1;
    }

  }

  else
    sign = 1;
  if(g0 == h0 && g1 == h1)
    return sign;

  else
    if(g0 == h1 && g1 == h0)
      return sign;

    else
      return 0;
}

// lglmatchgate
// file lglib.c line 13295
static signed int lglmatchgate(struct LGL *lgl, signed int fixed, struct Gat *g, struct Gat *h)
{
  signed int l;
  l=lglcgrepr(lgl, g->lhs);
  signed int k;
  k=lglcgrepr(lgl, h->lhs);
  signed int repr;
  signed int other;
  signed int s;
  lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
  if((signed int)g->tag == ITETAG)
  {
    s=lglmatchitegate(lgl, g, h);
    if(s == 0)
      return 0;

  }

  else
    if((signed int)g->size == 2)
    {
      s=lglmatchbingate(lgl, g, h);
      if(s == 0)
        return 0;

    }

    else
      if((signed int)g->tag == ANDTAG)
      {
        s=lglmatchlrgand(lgl, g, h);
        if(s == 0)
          return 0;

      }

      else
        if((signed int)g->tag == XORTAG)
        {
          s=lglmatchlrgxor(lgl, g, h);
          if(s == 0)
            return 0;

        }

        else
          return 0;
  repr = s * l;
  other = k;
  if(repr == other)
    return 0;

  else
  {
    lgl->stats->cgr.matched.all = lgl->stats->cgr.matched.all + 1;
    lgl->_anon0.cgr->matched.all = lgl->_anon0.cgr->matched.all + 1;
    if((signed int)g->tag == ANDTAG)
    {
      lgl->_anon0.cgr->matched.and = lgl->_anon0.cgr->matched.and + 1;
      lgl->stats->cgr.matched.and = lgl->stats->cgr.matched.and + 1;
    }

    if((signed int)g->tag == XORTAG)
    {
      lgl->_anon0.cgr->matched.xor = lgl->_anon0.cgr->matched.xor + 1;
      lgl->stats->cgr.matched.xor = lgl->stats->cgr.matched.xor + 1;
    }

    if((signed int)g->tag == ITETAG)
    {
      lgl->_anon0.cgr->matched.ite = lgl->_anon0.cgr->matched.ite + 1;
      lgl->stats->cgr.matched.ite = lgl->stats->cgr.matched.ite + 1;
    }

    if(repr == -other)
    {

    __CPROVER_DUMP_L14:
      ;
      lgl->mt = 1;
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L15:
      ;
      lglcgmerge(lgl, other, repr);
      signed int return_value_abs_1;
      return_value_abs_1=abs(fixed);
      signed int return_value_abs_2;
      return_value_abs_2=abs(other);
      if(return_value_abs_1 == return_value_abs_2)
        return 1;

      else
      {
        signed int return_value_abs_3;
        return_value_abs_3=abs(fixed);
        signed int return_value_abs_4;
        return_value_abs_4=abs(repr);
        if(return_value_abs_3 == return_value_abs_4)
          return 1;

        else
          return 0;
      }
    }
  }
}

// lglmatchitegate
// file lglib.c line 13098
static signed int lglmatchitegate(struct LGL *lgl, struct Gat *g, struct Gat *h)
{
  signed int gc;
  gc=lglcgrepr(lgl, g->_anon0._anon1.cond);
  signed int gp;
  gp=lglcgrepr(lgl, g->_anon0._anon1.pos);
  signed int gn;
  gn=lglcgrepr(lgl, g->_anon0._anon1.neg);
  signed int hc;
  hc=lglcgrepr(lgl, h->_anon0._anon1.cond);
  signed int hp;
  hp=lglcgrepr(lgl, h->_anon0._anon1.pos);
  signed int hn;
  hn=lglcgrepr(lgl, h->_anon0._anon1.neg);
  lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
  if(gc == 1)
  {
    if(gp == hp && hc == 1)
      return 1;

    if(gp == hn && hc == -1)
      return 1;

  }

  else
    if(gc == -1)
    {
      if(gn == hp && hc == 1)
        return 1;

      if(gn == hn && hc == -1)
        return 1;

    }

    else
      if(gc == hc)
      {
        if(gn == hn && gp == hp)
          return 1;

        if(gn == -hn && gp == -hp)
          return -1;

      }

      else
        if(gc == -hc)
        {
          if(gn == hp && gp == hn)
            return 1;

          if(gn == -hp && gp == -hn)
            return -1;

        }

  return 0;
}

// lglmatchlrgand
// file lglib.c line 13216
static signed int lglmatchlrgand(struct LGL *lgl, struct Gat *g, struct Gat *h)
{
  signed int res;
  res=lglmatchlrgandaux(lgl, g, h);
  if(res >= 0)
    return res;

  else
  {
    res=lglmatchlrgandaux(lgl, h, g);
    signed int return_value_abs_1;
    return_value_abs_1=abs(res);
    return return_value_abs_1;
  }
}

// lglmatchlrgandaux
// file lglib.c line 13144
static signed int lglmatchlrgandaux(struct LGL *lgl, struct Gat *g, struct Gat *h)
{
  signed int *p;
  signed int other;
  signed int repr;
  signed int bit;
  signed int res;
  signed int jumped;
  signed int gfalse;
  signed int gtrue;
  signed int htrue;
  signed int hfalse;
  signed int found;
  struct AVar *u;
  jumped = 1;
  gtrue = 1;
  gfalse = 0;
  found = 0;
  p = g->_anon0._anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
    signed int return_value_abs_1;
    return_value_abs_1=abs(other);
    signed int return_value_abs_2;
    return_value_abs_2=abs(g->_anon0._anon0.origlhs);
    if(return_value_abs_1 == return_value_abs_2)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, -other);
      if(repr == -1)
      {
        gfalse = 1;
        break;
      }

      if(!(repr == 1))
      {
        gtrue = 0;
        if(!(repr == other))
          jumped = -1;

        u=lglavar(lgl, repr);
        bit = 1 << (signed int)(repr < 0);
        if(!(((3 ^ bit) & u->mark) == 0))
          gfalse = 1;

        if((u->mark & bit) == 0)
          u->mark = u->mark | bit;

      }

    }
    p = p + 1l;
  }
  while((_Bool)1);
  res = 1;
  htrue = 1;
  hfalse = 0;
  found = 0;
  p = h->_anon0._anon0.cls;
  _Bool tmp_if_expr_3;
  do
  {
    if(!(res == 0))
    {
      other = *p;
      tmp_if_expr_3 = other != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
      break;

    signed int return_value_abs_4;
    return_value_abs_4=abs(other);
    signed int return_value_abs_5;
    return_value_abs_5=abs(h->_anon0._anon0.origlhs);
    if(return_value_abs_4 == return_value_abs_5)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, -other);
      if(repr == -1)
      {
        hfalse = 1;
        break;
      }

      if(!(repr == 1))
      {
        htrue = 0;
        if(!(repr == other))
          jumped = -1;

        u=lglavar(lgl, repr);
        bit = 1 << (signed int)(repr < 0);
        if((u->mark & bit) == 0)
          res = 0;

      }

    }
    p = p + 1l;
  }
  while((_Bool)1);
  found = 0;
  p = g->_anon0._anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    signed int return_value_abs_6;
    return_value_abs_6=abs(other);
    signed int return_value_abs_7;
    return_value_abs_7=abs(g->_anon0._anon0.origlhs);
    if(return_value_abs_6 == return_value_abs_7)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, other);
      signed int return_value_abs_8;
      return_value_abs_8=abs(repr);
      if(!(return_value_abs_8 == 1))
      {
        u=lglavar(lgl, repr);
        u->mark = 0;
      }

    }
    p = p + 1l;
  }
  while((_Bool)1);
  if(!(gfalse == 0))
  {
    lglcgmergelhsrhs(lgl, g->lhs, -1);
    res = 0;
  }

  else
    if(!(gtrue == 0) && !(res == 0))
    {
      lglcgmergelhsrhs(lgl, g->lhs, 1);
      res = 0;
    }

  if(!(hfalse == 0))
  {
    lglcgmergelhsrhs(lgl, h->lhs, -1);
    res = 0;
  }

  else
    if(!(htrue == 0))
    {
      lglcgmergelhsrhs(lgl, h->lhs, 1);
      res = 0;
    }

  return jumped * res;
}

// lglmatchlrgxor
// file lglib.c line 13223
static signed int lglmatchlrgxor(struct LGL *lgl, struct Gat *g, struct Gat *h)
{
  signed int *p;
  signed int other;
  signed int repr;
  signed int res;
  signed int gconst;
  signed int hconst;
  signed int hpar;
  signed int gpar;
  signed int sign;
  signed int found;
  struct AVar *u;
  gconst = 1;
  gpar = -1;
  sign = 1;
  found = 0;
  p = g->_anon0._anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
    signed int return_value_abs_1;
    return_value_abs_1=abs(other);
    signed int return_value_abs_2;
    return_value_abs_2=abs(g->_anon0._anon0.origlhs);
    if(return_value_abs_1 == return_value_abs_2)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, other);
      if(!(repr >= 0))
      {
        sign = -sign;
        gpar = -gpar;
      }

      signed int return_value_abs_3;
      return_value_abs_3=abs(repr);
      if(return_value_abs_3 == 1)
        goto __CPROVER_DUMP_L6;

      else
        gconst = 0;
      u=lglavar(lgl, repr);
      u->mark = (signed int)!(u->mark != 0);
    }

  __CPROVER_DUMP_L6:
    ;
    p = p + 1l;
  }
  while((_Bool)1);
  hconst = 1;
  hpar = -1;
  found = 0;
  p = h->_anon0._anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    signed int return_value_abs_4;
    return_value_abs_4=abs(other);
    signed int return_value_abs_5;
    return_value_abs_5=abs(h->_anon0._anon0.origlhs);
    if(return_value_abs_4 == return_value_abs_5)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, other);
      signed int return_value_abs_6;
      return_value_abs_6=abs(repr);
      if(!(return_value_abs_6 == 1))
        hconst = 0;

      if(!(repr >= 0))
      {
        sign = -sign;
        hpar = -hpar;
      }

      signed int return_value_abs_7;
      return_value_abs_7=abs(repr);
      if(return_value_abs_7 == 1)
        goto __CPROVER_DUMP_L14;

      else
        gconst = 0;
      u=lglavar(lgl, repr);
      u->mark = (signed int)!(u->mark != 0);
    }

  __CPROVER_DUMP_L14:
    ;
    p = p + 1l;
  }
  while((_Bool)1);
  res = 1;
  found = 0;
  p = g->_anon0._anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    signed int return_value_abs_8;
    return_value_abs_8=abs(other);
    signed int return_value_abs_9;
    return_value_abs_9=abs(g->_anon0._anon0.origlhs);
    if(return_value_abs_8 == return_value_abs_9)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, other);
      signed int return_value_abs_10;
      return_value_abs_10=abs(repr);
      if(!(return_value_abs_10 == 1))
      {
        u=lglavar(lgl, repr);
        if(!(u->mark == 0))
        {
          u->mark = 0;
          res = 0;
        }

      }

    }
    p = p + 1l;
  }
  while((_Bool)1);
  found = 0;
  p = h->_anon0._anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    signed int return_value_abs_11;
    return_value_abs_11=abs(other);
    signed int return_value_abs_12;
    return_value_abs_12=abs(h->_anon0._anon0.origlhs);
    if(return_value_abs_11 == return_value_abs_12)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, other);
      signed int return_value_abs_13;
      return_value_abs_13=abs(repr);
      if(!(return_value_abs_13 == 1))
      {
        u=lglavar(lgl, repr);
        if(!(u->mark == 0))
        {
          u->mark = 0;
          res = 0;
        }

      }

    }
    p = p + 1l;
  }
  while((_Bool)1);
  if(!(gconst == 0))
  {
    lglcgmergelhsrhs(lgl, g->lhs, gpar);
    res = 0;
  }

  if(!(hconst == 0))
  {
    lglcgmergelhsrhs(lgl, h->lhs, hpar);
    res = 0;
  }

  return sign * res;
}

// lglmax
// file lglib.c line 2309
static signed int lglmax(signed int a, signed int b)
{
  return a > b ? a : b;
}

// lglmaxmb
// file lglib.c line 4997
double lglmaxmb(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmaxmb");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  return (double)(lgl->stats->bytes.max + sizeof(struct LGL) /*816ul*/ ) / (double)(1 << 20);
}

// lglmaxoptnamelen
// file lglib.c line 2087
static signed int lglmaxoptnamelen(struct LGL *lgl)
{
  signed int res = 0;
  signed int len;
  struct Opt *o = &lgl->opts->beforefirst + (signed long int)1;
  unsigned long int return_value_strlen_1;
  for( ; &lgl->opts->afterlast + -1l >= o; o = o + 1l)
  {
    return_value_strlen_1=strlen(o->lng);
    len = (signed int)return_value_strlen_1;
    if(!(res >= len))
      res = len;

  }
  return res;
}

// lglmaxvar
// file lglib.c line 17893
signed int lglmaxvar(struct LGL *lgl)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmaxvar");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "maxvar");
    break;
  }
  res = lgl->maxext;

__CPROVER_DUMP_L6:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglmaxvar(lgl->clone);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmaxvar");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone) = %d differs from %s (lgl) = %d", (const void *)"lglmaxvar", CLONERES, (const void *)"lglmaxvar", res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglmb
// file lglib.h line 287
double lglmb(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmb");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  return (double)(lgl->stats->bytes.current + sizeof(struct LGL) /*816ul*/ ) / (double)(1 << 20);
}

// lglmelt
// file lglib.h line 263
void lglmelt(struct LGL *lgl, signed int elit)
{
  struct Ext *ext;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmelt");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "melt %d", elit);
    break;
  }
  lgl->stats->calls.melt = lgl->stats->calls.melt + 1l;
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmelt");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not melt zero literal");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }

__CPROVER_DUMP_L8:
  ;
  do
  {
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmelt");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

    while((2039 & (signed int)lgl->state) == 0)
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmelt");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "!(%s)", (const void *)"UNUSED|OPTSET|USED|RESET| SATISFIED|UNSATISFIED|FAILED|UNKNOWN|LOOKED| EXTENDED");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
  }
  while((_Bool)0);

__CPROVER_DUMP_L14:
  ;
  lglimport(lgl, elit);
  ext=lglelit2ext(lgl, elit);
  while(ext->frozen == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmelt");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not melt fully unfrozen literal %d", elit);
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  ext->frozen = ext->frozen - 1;
  lglmelter(lgl);
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglmelt(lgl->clone, elit);

}

// lglmeltall
// file lglib.c line 18043
void lglmeltall(struct LGL *lgl)
{
  signed int idx;
  signed int melted;
  struct Ext *ext;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmeltall");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  melted = 0;
  idx = 1;
  for( ; lgl->maxext >= idx; idx = idx + 1)
  {
    ext=lglelit2ext(lgl, idx);
    ext->melted = (unsigned int)0;
    if(!(ext->frozen == 0))
    {
      lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;
      ext->frozen = 0;
      melted = melted + 1;
    }

  }
  lglprt(lgl, 1, "[meltall] melted %d frozen literals", melted);
}

// lglmelter
// file lglib.c line 2504
static void lglmelter(struct LGL *lgl)
{
  if(!(lgl->frozen == 0))
    lgl->frozen = (char)0;


__CPROVER_DUMP_L1:
  ;
}

// lglmin
// file lglib.c line 2311
static signed int lglmin(signed int a, signed int b)
{
  return a < b ? a : b;
}

// lglmincls
// file lglib.c line 6003
static void lglmincls(struct LGL *lgl, signed int uip)
{
  signed int *p;
  signed int *q;
  signed int other;
  signed int minimized;
  signed int size;
  lglstart(lgl, &lgl->times->mcls);
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(&lgl->clause);
  size = (signed int)(return_value_lglcntstk_1 - (unsigned long int)1);
  lgl->stats->lits.nonmin = lgl->stats->lits.nonmin + (signed long int)size;
  q = lgl->clause.start;
  minimized = 0;
  p = q;
  _Bool tmp_if_expr_4;
  signed int return_value_lglminclslit_3;
  signed int *tmp_post_2;
  do
  {
    other = *p;
    if(other == 0)
      break;

    if(!(other == uip))
    {
      return_value_lglminclslit_3=lglminclslit(lgl, other);
      tmp_if_expr_4 = return_value_lglminclslit_3 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {

    __CPROVER_DUMP_L4:
      ;
      minimized = minimized + 1;
    }

    else
    {
      tmp_post_2 = q;
      q = q + 1l;
      *tmp_post_2 = other;
    }
    p = p + 1l;
  }
  while((_Bool)1);
  signed int *tmp_post_5 = q;
  q = q + 1l;
  *tmp_post_5 = 0;
  lglclnpoisoned(lgl);

__CPROVER_DUMP_L8:
  ;

__CPROVER_DUMP_L9:
  ;
  lgl->clause.top = q;
  lglstop(lgl);
}

// lglminclslit
// file lglib.c line 4873
static signed int lglminclslit(struct LGL *lgl, signed int start)
{
  signed int lit;
  signed int tag;
  signed int r0;
  signed int r1;
  signed int other;
  signed int *p;
  signed int *q;
  signed int *top;
  signed int old;
  signed int poisoned;
  signed int *rsn;
  signed int found;
  struct AVar *av;
  struct AVar *bv;
  struct Stk stk;
  lit = start;
  rsn=lglrsn(lgl, lit);
  r0 = rsn[(signed long int)0];
  tag = r0 & MASKCS;
  signed int return_value_lglpoison_3;
  signed int *tmp_post_4;
  signed int return_value_lglpoison_5;
  signed int *tmp_post_7;
  struct AVar *return_value_lglavar_8;
  if(tag == DECISION)
    return 0;

  else
  {
    unsigned long int return_value_lglcntstk_1;
    return_value_lglcntstk_1=lglcntstk(&lgl->seen);
    old = (signed int)return_value_lglcntstk_1;
    do
      memset((void *)&stk, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    do
    {
      r1 = rsn[(signed long int)1];
      if(tag == BINCS || tag == TRNCS)
      {
        other = r0 >> RMSHFT;
        signed int return_value_lglpoison_2;
        return_value_lglpoison_2=lglpoison(lgl, other, &stk);
        if(!(return_value_lglpoison_2 == 0))
          break;

        if(tag == TRNCS)
        {
          return_value_lglpoison_3=lglpoison(lgl, r1, &stk);
          if(!(return_value_lglpoison_3 == 0))
            break;

        }

      }

      else
      {
        p=lglidx2lits(lgl, LRGCS, r0 & REDCS, r1);
        found = 0;
        do
        {
          tmp_post_4 = p;
          p = p + 1l;
          other = *tmp_post_4;
          if(other == 0)
            break;

          if(other == -lit)
            found = found + 1;

          else
          {
            return_value_lglpoison_5=lglpoison(lgl, other, &stk);
            if(!(return_value_lglpoison_5 == 0))
              goto FAILED;

          }
        }
        while((_Bool)1);
      }
      signed int return_value_lglmtstk_6;
      return_value_lglmtstk_6=lglmtstk(&stk);
      if(!(return_value_lglmtstk_6 == 0))
      {
        lglrelstk(lgl, &stk);
        return 1;
      }

      lit=lglpopstk(&stk);
      rsn=lglrsn(lgl, lit);
      r0 = rsn[(signed long int)0];
      tag = r0 & MASKCS;
    }
    while((_Bool)1);

  FAILED:
    ;
    lglrelstk(lgl, &stk);
    p = lgl->seen.top;
    lgl->seen.top = lgl->seen.start + (signed long int)old;
    top = lgl->seen.top;
    while(!(top >= p))
    {
      p = p - 1l;
      lit = *p;
      av=lglavar(lgl, lit);
      av->mark = 0;
      poisoned = (signed int)av->poisoned;
      if(poisoned == 0)
      {
        rsn=lglrsn(lgl, lit);
        r0 = rsn[(signed long int)0];
        tag = r0 & MASKCS;
        r1 = rsn[(signed long int)1];
        if(tag == BINCS || tag == TRNCS)
        {
          other = r0 >> RMSHFT;
          bv=lglavar(lgl, other);
          if(!(bv->poisoned == 0u))
            poisoned = 1;

          else
            if(tag == TRNCS)
            {
              bv=lglavar(lgl, r1);
              if(!(bv->poisoned == 0u))
                poisoned = 1;

            }

        }

        else
        {
          q=lglidx2lits(lgl, LRGCS, r0 & REDCS, r1);
          for( ; poisoned == 0; poisoned = (signed int)return_value_lglavar_8->poisoned)
          {
            tmp_post_7 = q;
            q = q + 1l;
            other = *tmp_post_7;
            if(other == 0)
              break;

            return_value_lglavar_8=lglavar(lgl, other);
          }
        }
        if(!(poisoned == 0))
        {
          av->poisoned = (unsigned int)1;
          lglpushstk(lgl, &lgl->poisoned, lit);
        }

      }

    }
    return 0;
  }
}

// lglminit
// file lglib.c line 1700
struct LGL * lglminit(void *mem, void * (*alloc)(void *, unsigned long int), void * (*realloc)(void *, void *, unsigned long int, unsigned long int), void (*dealloc)(void *, void *, unsigned long int))
{
  const signed int K = 1000;
  const signed int M = K * K;
  const signed int I = 0x7fffffff;
  const char *apitracename;
  struct LGL *lgl;
  signed int i;
  lgl = ((struct LGL *)NULL);
  while(!((signed int)(dealloc == ((void (*)(void *, void *, unsigned long int))NULL)) + (signed int)(alloc == ((void * (*)(void *, unsigned long int))NULL)) + (signed int)(realloc == ((void * (*)(void *, void *, unsigned long int, unsigned long int))NULL)) == 0) && !((signed int)(dealloc == ((void (*)(void *, void *, unsigned long int))NULL)) + (signed int)(alloc == ((void * (*)(void *, unsigned long int))NULL)) + (signed int)(realloc == ((void * (*)(void *, void *, unsigned long int, unsigned long int))NULL)) == 3))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglminit");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "inconsistent set of external memory handlers");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lgl=lglnewlgl(mem, alloc, realloc, dealloc);
  lgl->tid = -1;
  lglpushcontrol(lgl, 0);
  lgl->out = stdout;
  lgl->prefix=lglstrdup(lgl, "c ");
  apitracename=getenv("LGLAPITRACE");
  if(!(apitracename == ((const char *)NULL)))
    lglopenapitrace(lgl, apitracename);

  do
  {
    struct Opt *lglminit__1__2__opt = &lgl->opts->abstime;
    lglminit__1__2__opt->shrt = (char)0;
    lglminit__1__2__opt->lng = "abstime";
    lglminit__1__2__opt->val = 0;
    lglminit__1__2__opt->min = 0;
    lglminit__1__2__opt->max = 1;
    lglminit__1__2__opt->descrp = "print absolute time when reporting";
    lglgetenv(lgl, lglminit__1__2__opt, "abstime");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__3__opt = &lgl->opts->acts;
    lglminit__1__3__opt->shrt = (char)0;
    lglminit__1__3__opt->lng = "acts";
    lglminit__1__3__opt->val = 2;
    lglminit__1__3__opt->min = 0;
    lglminit__1__3__opt->max = 2;
    lglminit__1__3__opt->descrp = "activity based reduction: 0=disable,1=enable,2=dyn";
    lglgetenv(lgl, lglminit__1__3__opt, "acts");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__4__opt = &lgl->opts->actavgmax;
    lglminit__1__4__opt->shrt = (char)0;
    lglminit__1__4__opt->lng = "actavgmax";
    lglminit__1__4__opt->val = 120;
    lglminit__1__4__opt->min = 0;
    lglminit__1__4__opt->max = 200;
    lglminit__1__4__opt->descrp = "glue average max limit for dyn acts";
    lglgetenv(lgl, lglminit__1__4__opt, "actavgmax");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__5__opt = &lgl->opts->actstdmin;
    lglminit__1__5__opt->shrt = (char)0;
    lglminit__1__5__opt->lng = "actstdmin";
    lglminit__1__5__opt->val = 20;
    lglminit__1__5__opt->min = 0;
    lglminit__1__5__opt->max = 200;
    lglminit__1__5__opt->descrp = "glue standard deviation min limit for dyn acts";
    lglgetenv(lgl, lglminit__1__5__opt, "actstdmin");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__6__opt = &lgl->opts->actstdmax;
    lglminit__1__6__opt->shrt = (char)0;
    lglminit__1__6__opt->lng = "actstdmax";
    lglminit__1__6__opt->val = 80;
    lglminit__1__6__opt->min = 0;
    lglminit__1__6__opt->max = 200;
    lglminit__1__6__opt->descrp = "glue standard deviation max limit for dyn acts";
    lglgetenv(lgl, lglminit__1__6__opt, "actstdmax");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__7__opt = &lgl->opts->agile;
    lglminit__1__7__opt->shrt = (char)0;
    lglminit__1__7__opt->lng = "agile";
    lglminit__1__7__opt->val = 23;
    lglminit__1__7__opt->min = 0;
    lglminit__1__7__opt->max = 100;
    lglminit__1__7__opt->descrp = "agility limit for restarts";
    lglgetenv(lgl, lglminit__1__7__opt, "agile");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__8__opt = &lgl->opts->bias;
    lglminit__1__8__opt->shrt = (char)0;
    lglminit__1__8__opt->lng = "bias";
    lglminit__1__8__opt->val = 2;
    lglminit__1__8__opt->min = -1;
    lglminit__1__8__opt->max = 2;
    lglminit__1__8__opt->descrp = "decision order initial bias (0=nobias,2=cutwidth)";
    lglgetenv(lgl, lglminit__1__8__opt, "bias");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__9__opt = &lgl->opts->block;
    lglminit__1__9__opt->shrt = (char)0;
    lglminit__1__9__opt->lng = "block";
    lglminit__1__9__opt->val = 1;
    lglminit__1__9__opt->min = 0;
    lglminit__1__9__opt->max = 1;
    lglminit__1__9__opt->descrp = "blocked clause elimination (BCE)";
    lglgetenv(lgl, lglminit__1__9__opt, "block");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__10__opt = &lgl->opts->blkrtc;
    lglminit__1__10__opt->shrt = (char)0;
    lglminit__1__10__opt->lng = "blkrtc";
    lglminit__1__10__opt->val = 0;
    lglminit__1__10__opt->min = 0;
    lglminit__1__10__opt->max = 1;
    lglminit__1__10__opt->descrp = "run BCE until completion";
    lglgetenv(lgl, lglminit__1__10__opt, "blkrtc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__11__opt = &lgl->opts->blkclslim;
    lglminit__1__11__opt->shrt = (char)0;
    lglminit__1__11__opt->lng = "blkclslim";
    lglminit__1__11__opt->val = 2000;
    lglminit__1__11__opt->min = 3;
    lglminit__1__11__opt->max = I;
    lglminit__1__11__opt->descrp = "max blocked clause size";
    lglgetenv(lgl, lglminit__1__11__opt, "blkclslim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__12__opt = &lgl->opts->blkocclim;
    lglminit__1__12__opt->shrt = (char)0;
    lglminit__1__12__opt->lng = "blkocclim";
    lglminit__1__12__opt->val = 2000;
    lglminit__1__12__opt->min = 3;
    lglminit__1__12__opt->max = I;
    lglminit__1__12__opt->descrp = "max occurrences in blocked clause elimination";
    lglgetenv(lgl, lglminit__1__12__opt, "blkocclim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__13__opt = &lgl->opts->blkmaxeff;
    lglminit__1__13__opt->shrt = (char)0;
    lglminit__1__13__opt->lng = "blkmaxeff";
    lglminit__1__13__opt->val = I;
    lglminit__1__13__opt->min = -1;
    lglminit__1__13__opt->max = I;
    lglminit__1__13__opt->descrp = "max effort in BCE (-1=unlimited)";
    lglgetenv(lgl, lglminit__1__13__opt, "blkmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__14__opt = &lgl->opts->blkmineff;
    lglminit__1__14__opt->shrt = (char)0;
    lglminit__1__14__opt->lng = "blkmineff";
    lglminit__1__14__opt->val = 10 * M;
    lglminit__1__14__opt->min = 0;
    lglminit__1__14__opt->max = I;
    lglminit__1__14__opt->descrp = "min effort in BCE";
    lglgetenv(lgl, lglminit__1__14__opt, "blkmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__15__opt = &lgl->opts->blkreleff;
    lglminit__1__15__opt->shrt = (char)0;
    lglminit__1__15__opt->lng = "blkreleff";
    lglminit__1__15__opt->val = 20;
    lglminit__1__15__opt->min = 0;
    lglminit__1__15__opt->max = K;
    lglminit__1__15__opt->descrp = "rel effort in BCE";
    lglgetenv(lgl, lglminit__1__15__opt, "blkreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__16__opt = &lgl->opts->card;
    lglminit__1__16__opt->shrt = (char)0;
    lglminit__1__16__opt->lng = "card";
    lglminit__1__16__opt->val = 0;
    lglminit__1__16__opt->min = 0;
    lglminit__1__16__opt->max = 1;
    lglminit__1__16__opt->descrp = "extract cardinality constraints";
    lglgetenv(lgl, lglminit__1__16__opt, "card");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__17__opt = &lgl->opts->cce;
    lglminit__1__17__opt->shrt = (char)0;
    lglminit__1__17__opt->lng = "cce";
    lglminit__1__17__opt->val = 3;
    lglminit__1__17__opt->min = 0;
    lglminit__1__17__opt->max = 3;
    lglminit__1__17__opt->descrp = "covered clause elimination (1=ate,2=abce,3=cce)";
    lglgetenv(lgl, lglminit__1__17__opt, "cce");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__18__opt = &lgl->opts->ccemaxeff;
    lglminit__1__18__opt->shrt = (char)0;
    lglminit__1__18__opt->lng = "ccemaxeff";
    lglminit__1__18__opt->val = 100 * M;
    lglminit__1__18__opt->min = -1;
    lglminit__1__18__opt->max = I;
    lglminit__1__18__opt->descrp = "max effort in covered clause elimination";
    lglgetenv(lgl, lglminit__1__18__opt, "ccemaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__19__opt = &lgl->opts->ccemineff;
    lglminit__1__19__opt->shrt = (char)0;
    lglminit__1__19__opt->lng = "ccemineff";
    lglminit__1__19__opt->val = 5 * M;
    lglminit__1__19__opt->min = 0;
    lglminit__1__19__opt->max = I;
    lglminit__1__19__opt->descrp = "min effort in covered clause elimination";
    lglgetenv(lgl, lglminit__1__19__opt, "ccemineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__20__opt = &lgl->opts->ccereleff;
    lglminit__1__20__opt->shrt = (char)0;
    lglminit__1__20__opt->lng = "ccereleff";
    lglminit__1__20__opt->val = 3;
    lglminit__1__20__opt->min = 0;
    lglminit__1__20__opt->max = K;
    lglminit__1__20__opt->descrp = "rel effort in covered clause elimination";
    lglgetenv(lgl, lglminit__1__20__opt, "ccereleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__21__opt = &lgl->opts->check;
    lglminit__1__21__opt->shrt = (char)99;
    lglminit__1__21__opt->lng = "check";
    lglminit__1__21__opt->val = 0;
    lglminit__1__21__opt->min = 0;
    lglminit__1__21__opt->max = 3;
    lglminit__1__21__opt->descrp = "check level";
    lglgetenv(lgl, lglminit__1__21__opt, "check");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__22__opt = &lgl->opts->cgrclsr;
    lglminit__1__22__opt->shrt = (char)0;
    lglminit__1__22__opt->lng = "cgrclsr";
    lglminit__1__22__opt->val = 1;
    lglminit__1__22__opt->min = 0;
    lglminit__1__22__opt->max = 1;
    lglminit__1__22__opt->descrp = "gate extraction and congruence closure";
    lglgetenv(lgl, lglminit__1__22__opt, "cgrclsr");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__23__opt = &lgl->opts->cgrmaxority;
    lglminit__1__23__opt->shrt = (char)0;
    lglminit__1__23__opt->lng = "cgrmaxority";
    lglminit__1__23__opt->val = 20;
    lglminit__1__23__opt->min = 2;
    lglminit__1__23__opt->max = 30;
    lglminit__1__23__opt->descrp = "maximum xor arity to be extracted";
    lglgetenv(lgl, lglminit__1__23__opt, "cgrmaxority");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__24__opt = &lgl->opts->cgrmaxeff;
    lglminit__1__24__opt->shrt = (char)0;
    lglminit__1__24__opt->lng = "cgrmaxeff";
    lglminit__1__24__opt->val = 8 * M;
    lglminit__1__24__opt->min = -1;
    lglminit__1__24__opt->max = I;
    lglminit__1__24__opt->descrp = "max effort in congruence closure";
    lglgetenv(lgl, lglminit__1__24__opt, "cgrmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__25__opt = &lgl->opts->cgrmineff;
    lglminit__1__25__opt->shrt = (char)0;
    lglminit__1__25__opt->lng = "cgrmineff";
    lglminit__1__25__opt->val = 200 * K;
    lglminit__1__25__opt->min = 0;
    lglminit__1__25__opt->max = I;
    lglminit__1__25__opt->descrp = "min effort in congruence closure";
    lglgetenv(lgl, lglminit__1__25__opt, "cgrmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__26__opt = &lgl->opts->cgreleff;
    lglminit__1__26__opt->shrt = (char)0;
    lglminit__1__26__opt->lng = "cgreleff";
    lglminit__1__26__opt->val = 1;
    lglminit__1__26__opt->min = 0;
    lglminit__1__26__opt->max = 10 * K;
    lglminit__1__26__opt->descrp = "rel effort in congruence closure";
    lglgetenv(lgl, lglminit__1__26__opt, "cgreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__27__opt = &lgl->opts->cgrexteq;
    lglminit__1__27__opt->shrt = (char)0;
    lglminit__1__27__opt->lng = "cgrexteq";
    lglminit__1__27__opt->val = 1;
    lglminit__1__27__opt->min = 0;
    lglminit__1__27__opt->max = 1;
    lglminit__1__27__opt->descrp = "extract equivalences";
    lglgetenv(lgl, lglminit__1__27__opt, "cgrexteq");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__28__opt = &lgl->opts->cgrextand;
    lglminit__1__28__opt->shrt = (char)0;
    lglminit__1__28__opt->lng = "cgrextand";
    lglminit__1__28__opt->val = 1;
    lglminit__1__28__opt->min = 0;
    lglminit__1__28__opt->max = 1;
    lglminit__1__28__opt->descrp = "extract and gates";
    lglgetenv(lgl, lglminit__1__28__opt, "cgrextand");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__29__opt = &lgl->opts->cgrextxor;
    lglminit__1__29__opt->shrt = (char)0;
    lglminit__1__29__opt->lng = "cgrextxor";
    lglminit__1__29__opt->val = 1;
    lglminit__1__29__opt->min = 0;
    lglminit__1__29__opt->max = 1;
    lglminit__1__29__opt->descrp = "extract xor gates";
    lglgetenv(lgl, lglminit__1__29__opt, "cgrextxor");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__30__opt = &lgl->opts->cgrextite;
    lglminit__1__30__opt->shrt = (char)0;
    lglminit__1__30__opt->lng = "cgrextite";
    lglminit__1__30__opt->val = 1;
    lglminit__1__30__opt->min = 0;
    lglminit__1__30__opt->max = 1;
    lglminit__1__30__opt->descrp = "extract ite gates";
    lglgetenv(lgl, lglminit__1__30__opt, "cgrextite");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__31__opt = &lgl->opts->cgrextunits;
    lglminit__1__31__opt->shrt = (char)0;
    lglminit__1__31__opt->lng = "cgrextunits";
    lglminit__1__31__opt->val = 1;
    lglminit__1__31__opt->min = 0;
    lglminit__1__31__opt->max = 1;
    lglminit__1__31__opt->descrp = "extract units";
    lglgetenv(lgl, lglminit__1__31__opt, "cgrextunits");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__32__opt = &lgl->opts->cliff;
    lglminit__1__32__opt->shrt = (char)0;
    lglminit__1__32__opt->lng = "cliff";
    lglminit__1__32__opt->val = 1;
    lglminit__1__32__opt->min = 0;
    lglminit__1__32__opt->max = 1;
    lglminit__1__32__opt->descrp = "cliffing";
    lglgetenv(lgl, lglminit__1__32__opt, "cliff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__33__opt = &lgl->opts->cliffmaxeff;
    lglminit__1__33__opt->shrt = (char)0;
    lglminit__1__33__opt->lng = "cliffmaxeff";
    lglminit__1__33__opt->val = 100 * M;
    lglminit__1__33__opt->min = -1;
    lglminit__1__33__opt->max = I;
    lglminit__1__33__opt->descrp = "max effort in cliffing";
    lglgetenv(lgl, lglminit__1__33__opt, "cliffmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__34__opt = &lgl->opts->cliffmineff;
    lglminit__1__34__opt->shrt = (char)0;
    lglminit__1__34__opt->lng = "cliffmineff";
    lglminit__1__34__opt->val = 10 * M;
    lglminit__1__34__opt->min = 0;
    lglminit__1__34__opt->max = I;
    lglminit__1__34__opt->descrp = "min effort in cliffing";
    lglgetenv(lgl, lglminit__1__34__opt, "cliffmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__35__opt = &lgl->opts->cliffreleff;
    lglminit__1__35__opt->shrt = (char)0;
    lglminit__1__35__opt->lng = "cliffreleff";
    lglminit__1__35__opt->val = 8;
    lglminit__1__35__opt->min = 0;
    lglminit__1__35__opt->max = 10 * K;
    lglminit__1__35__opt->descrp = "rel effort in cliffing";
    lglgetenv(lgl, lglminit__1__35__opt, "cliffreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__36__opt = &lgl->opts->compact;
    lglminit__1__36__opt->shrt = (char)0;
    lglminit__1__36__opt->lng = "compact";
    lglminit__1__36__opt->val = 0;
    lglminit__1__36__opt->min = 0;
    lglminit__1__36__opt->max = 2;
    lglminit__1__36__opt->descrp = "compactify after 'lglsat' + 'lglsimp' (1=UNS,2=SAT)";
    lglgetenv(lgl, lglminit__1__36__opt, "compact");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__37__opt = &lgl->opts->decompose;
    lglminit__1__37__opt->shrt = (char)0;
    lglminit__1__37__opt->lng = "decompose";
    lglminit__1__37__opt->val = 1;
    lglminit__1__37__opt->min = 0;
    lglminit__1__37__opt->max = 1;
    lglminit__1__37__opt->descrp = "enable decompose";
    lglgetenv(lgl, lglminit__1__37__opt, "decompose");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__38__opt = &lgl->opts->defragfree;
    lglminit__1__38__opt->shrt = (char)0;
    lglminit__1__38__opt->lng = "defragfree";
    lglminit__1__38__opt->val = 50;
    lglminit__1__38__opt->min = 10;
    lglminit__1__38__opt->max = K;
    lglminit__1__38__opt->descrp = "defragmentation free watches limit";
    lglgetenv(lgl, lglminit__1__38__opt, "defragfree");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__39__opt = &lgl->opts->defragint;
    lglminit__1__39__opt->shrt = (char)0;
    lglminit__1__39__opt->lng = "defragint";
    lglminit__1__39__opt->val = 10 * M;
    lglminit__1__39__opt->min = 100;
    lglminit__1__39__opt->max = I;
    lglminit__1__39__opt->descrp = "defragmentation pushed watches interval";
    lglgetenv(lgl, lglminit__1__39__opt, "defragint");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__40__opt = &lgl->opts->elim;
    lglminit__1__40__opt->shrt = (char)0;
    lglminit__1__40__opt->lng = "elim";
    lglminit__1__40__opt->val = 1;
    lglminit__1__40__opt->min = 0;
    lglminit__1__40__opt->max = 1;
    lglminit__1__40__opt->descrp = "bounded variable eliminiation (BVE)";
    lglgetenv(lgl, lglminit__1__40__opt, "elim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__41__opt = &lgl->opts->elmrtc;
    lglminit__1__41__opt->shrt = (char)0;
    lglminit__1__41__opt->lng = "elmrtc";
    lglminit__1__41__opt->val = 0;
    lglminit__1__41__opt->min = 0;
    lglminit__1__41__opt->max = 1;
    lglminit__1__41__opt->descrp = "run BVE until completion";
    lglgetenv(lgl, lglminit__1__41__opt, "elmrtc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__42__opt = &lgl->opts->elmblk;
    lglminit__1__42__opt->shrt = (char)0;
    lglminit__1__42__opt->lng = "elmblk";
    lglminit__1__42__opt->val = 1;
    lglminit__1__42__opt->min = 0;
    lglminit__1__42__opt->max = 1;
    lglminit__1__42__opt->descrp = "enable BCE during BVE";
    lglgetenv(lgl, lglminit__1__42__opt, "elmblk");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__43__opt = &lgl->opts->elmclslim;
    lglminit__1__43__opt->shrt = (char)0;
    lglminit__1__43__opt->lng = "elmclslim";
    lglminit__1__43__opt->val = 1000;
    lglminit__1__43__opt->min = 3;
    lglminit__1__43__opt->max = I;
    lglminit__1__43__opt->descrp = "max antecendent size in elimination";
    lglgetenv(lgl, lglminit__1__43__opt, "elmclslim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__44__opt = &lgl->opts->elmocclim;
    lglminit__1__44__opt->shrt = (char)0;
    lglminit__1__44__opt->lng = "elmocclim";
    lglminit__1__44__opt->val = 1000;
    lglminit__1__44__opt->min = 3;
    lglminit__1__44__opt->max = I;
    lglminit__1__44__opt->descrp = "max occurences in elimination";
    lglgetenv(lgl, lglminit__1__44__opt, "elmocclim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__45__opt = &lgl->opts->elmaxeff;
    lglminit__1__45__opt->shrt = (char)0;
    lglminit__1__45__opt->lng = "elmaxeff";
    lglminit__1__45__opt->val = 100 * M;
    lglminit__1__45__opt->min = -1;
    lglminit__1__45__opt->max = I;
    lglminit__1__45__opt->descrp = "max effort in BVE (-1=unlimited)";
    lglgetenv(lgl, lglminit__1__45__opt, "elmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__46__opt = &lgl->opts->elmineff;
    lglminit__1__46__opt->shrt = (char)0;
    lglminit__1__46__opt->lng = "elmineff";
    lglminit__1__46__opt->val = 5 * M;
    lglminit__1__46__opt->min = 0;
    lglminit__1__46__opt->max = I;
    lglminit__1__46__opt->descrp = "min effort in BVE";
    lglgetenv(lgl, lglminit__1__46__opt, "elmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__47__opt = &lgl->opts->elmreleff;
    lglminit__1__47__opt->shrt = (char)0;
    lglminit__1__47__opt->lng = "elmreleff";
    lglminit__1__47__opt->val = 10;
    lglminit__1__47__opt->min = 0;
    lglminit__1__47__opt->max = 10 * K;
    lglminit__1__47__opt->descrp = "rel effort in BVE";
    lglgetenv(lgl, lglminit__1__47__opt, "elmreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__48__opt = &lgl->opts->sleeponabort;
    lglminit__1__48__opt->shrt = (char)0;
    lglminit__1__48__opt->lng = "sleeponabort";
    lglminit__1__48__opt->val = 0;
    lglminit__1__48__opt->min = 0;
    lglminit__1__48__opt->max = I;
    lglminit__1__48__opt->descrp = "sleep this seconds before abort/exit";
    lglgetenv(lgl, lglminit__1__48__opt, "sleeponabort");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__49__opt = &lgl->opts->exitonabort;
    lglminit__1__49__opt->shrt = (char)0;
    lglminit__1__49__opt->lng = "exitonabort";
    lglminit__1__49__opt->val = 0;
    lglminit__1__49__opt->min = 0;
    lglminit__1__49__opt->max = 1;
    lglminit__1__49__opt->descrp = "exit instead abort after internal error";
    lglgetenv(lgl, lglminit__1__49__opt, "exitonabort");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__50__opt = &lgl->opts->flipping;
    lglminit__1__50__opt->shrt = (char)0;
    lglminit__1__50__opt->lng = "flipping";
    lglminit__1__50__opt->val = 1;
    lglminit__1__50__opt->min = 0;
    lglminit__1__50__opt->max = 1;
    lglminit__1__50__opt->descrp = "enable point flipping";
    lglgetenv(lgl, lglminit__1__50__opt, "flipping");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__51__opt = &lgl->opts->flipint;
    lglminit__1__51__opt->shrt = (char)0;
    lglminit__1__51__opt->lng = "flipint";
    lglminit__1__51__opt->val = 2;
    lglminit__1__51__opt->min = 0;
    lglminit__1__51__opt->max = I;
    lglminit__1__51__opt->descrp = "flipping interval in number of top level decision";
    lglgetenv(lgl, lglminit__1__51__opt, "flipint");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__52__opt = &lgl->opts->flipdur;
    lglminit__1__52__opt->shrt = (char)0;
    lglminit__1__52__opt->lng = "flipdur";
    lglminit__1__52__opt->val = 50;
    lglminit__1__52__opt->min = 1;
    lglminit__1__52__opt->max = I;
    lglminit__1__52__opt->descrp = "flipping duration in number of conflicts";
    lglgetenv(lgl, lglminit__1__52__opt, "flipdur");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__53__opt = &lgl->opts->fliptop;
    lglminit__1__53__opt->shrt = (char)0;
    lglminit__1__53__opt->lng = "fliptop";
    lglminit__1__53__opt->val = 1;
    lglminit__1__53__opt->min = 0;
    lglminit__1__53__opt->max = 1;
    lglminit__1__53__opt->descrp = "flipping only at the top level";
    lglgetenv(lgl, lglminit__1__53__opt, "fliptop");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__54__opt = &lgl->opts->force;
    lglminit__1__54__opt->shrt = (char)0;
    lglminit__1__54__opt->lng = "force";
    lglminit__1__54__opt->val = 0;
    lglminit__1__54__opt->min = 0;
    lglminit__1__54__opt->max = I;
    lglminit__1__54__opt->descrp = "reorder variables with force algorithm";
    lglgetenv(lgl, lglminit__1__54__opt, "force");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__55__opt = &lgl->opts->gauss;
    lglminit__1__55__opt->shrt = (char)0;
    lglminit__1__55__opt->lng = "gauss";
    lglminit__1__55__opt->val = 1;
    lglminit__1__55__opt->min = 0;
    lglminit__1__55__opt->max = 1;
    lglminit__1__55__opt->descrp = "gaussion elimination";
    lglgetenv(lgl, lglminit__1__55__opt, "gauss");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__56__opt = &lgl->opts->gaussextrall;
    lglminit__1__56__opt->shrt = (char)0;
    lglminit__1__56__opt->lng = "gaussextrall";
    lglminit__1__56__opt->val = 1;
    lglminit__1__56__opt->min = 0;
    lglminit__1__56__opt->max = 1;
    lglminit__1__56__opt->descrp = "extract all xors (with duplicates)";
    lglgetenv(lgl, lglminit__1__56__opt, "gaussextrall");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__57__opt = &lgl->opts->gaussmaxor;
    lglminit__1__57__opt->shrt = (char)0;
    lglminit__1__57__opt->lng = "gaussmaxor";
    lglminit__1__57__opt->val = 20;
    lglminit__1__57__opt->min = 2;
    lglminit__1__57__opt->max = 64;
    lglminit__1__57__opt->descrp = "maximum xor size in gaussian elimination";
    lglgetenv(lgl, lglminit__1__57__opt, "gaussmaxor");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__58__opt = &lgl->opts->gaussexptrn;
    lglminit__1__58__opt->shrt = (char)0;
    lglminit__1__58__opt->lng = "gaussexptrn";
    lglminit__1__58__opt->val = 1;
    lglminit__1__58__opt->min = 0;
    lglminit__1__58__opt->max = 1;
    lglminit__1__58__opt->descrp = "export ternary clauses from gaussian elimination";
    lglgetenv(lgl, lglminit__1__58__opt, "gaussexptrn");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__59__opt = &lgl->opts->gaussmaxeff;
    lglminit__1__59__opt->shrt = (char)0;
    lglminit__1__59__opt->lng = "gaussmaxeff";
    lglminit__1__59__opt->val = 50 * M;
    lglminit__1__59__opt->min = -1;
    lglminit__1__59__opt->max = I;
    lglminit__1__59__opt->descrp = "max effort in gaussian elimination";
    lglgetenv(lgl, lglminit__1__59__opt, "gaussmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__60__opt = &lgl->opts->gaussmineff;
    lglminit__1__60__opt->shrt = (char)0;
    lglminit__1__60__opt->lng = "gaussmineff";
    lglminit__1__60__opt->val = 2 * M;
    lglminit__1__60__opt->min = 0;
    lglminit__1__60__opt->max = I;
    lglminit__1__60__opt->descrp = "min effort in gaussian elimination";
    lglgetenv(lgl, lglminit__1__60__opt, "gaussmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__61__opt = &lgl->opts->gaussreleff;
    lglminit__1__61__opt->shrt = (char)0;
    lglminit__1__61__opt->lng = "gaussreleff";
    lglminit__1__61__opt->val = 2;
    lglminit__1__61__opt->min = 0;
    lglminit__1__61__opt->max = 10 * K;
    lglminit__1__61__opt->descrp = "rel effort in gaussian elimination";
    lglgetenv(lgl, lglminit__1__61__opt, "gaussreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__62__opt = &lgl->opts->gluescale;
    lglminit__1__62__opt->shrt = (char)0;
    lglminit__1__62__opt->lng = "gluescale";
    lglminit__1__62__opt->val = 2;
    lglminit__1__62__opt->min = 1;
    lglminit__1__62__opt->max = 3;
    lglminit__1__62__opt->descrp = "glue scaling: 1=linear,2=sqrt,3=ld";
    lglgetenv(lgl, lglminit__1__62__opt, "gluescale");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__63__opt = &lgl->opts->gluekeep;
    lglminit__1__63__opt->shrt = (char)0;
    lglminit__1__63__opt->lng = "gluekeep";
    lglminit__1__63__opt->val = 0;
    lglminit__1__63__opt->min = 0;
    lglminit__1__63__opt->max = I;
    lglminit__1__63__opt->descrp = "keep clauses with this original glue";
    lglgetenv(lgl, lglminit__1__63__opt, "gluekeep");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__64__opt = &lgl->opts->inprocessing;
    lglminit__1__64__opt->shrt = (char)0;
    lglminit__1__64__opt->lng = "inprocessing";
    lglminit__1__64__opt->val = 1;
    lglminit__1__64__opt->min = 0;
    lglminit__1__64__opt->max = 1;
    lglminit__1__64__opt->descrp = "enable inprocessing";
    lglgetenv(lgl, lglminit__1__64__opt, "inprocessing");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__65__opt = &lgl->opts->cintinc;
    lglminit__1__65__opt->shrt = (char)0;
    lglminit__1__65__opt->lng = "cintinc";
    lglminit__1__65__opt->val = 10 * K;
    lglminit__1__65__opt->min = 10;
    lglminit__1__65__opt->max = M;
    lglminit__1__65__opt->descrp = "inprocessing conflict interval increment";
    lglgetenv(lgl, lglminit__1__65__opt, "cintinc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__66__opt = &lgl->opts->irrlim;
    lglminit__1__66__opt->shrt = (char)0;
    lglminit__1__66__opt->lng = "irrlim";
    lglminit__1__66__opt->val = 20;
    lglminit__1__66__opt->min = 1;
    lglminit__1__66__opt->max = 200;
    lglminit__1__66__opt->descrp = "general irredundant added literals limit";
    lglgetenv(lgl, lglminit__1__66__opt, "irrlim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__67__opt = &lgl->opts->lift;
    lglminit__1__67__opt->shrt = (char)0;
    lglminit__1__67__opt->lng = "lift";
    lglminit__1__67__opt->val = 1;
    lglminit__1__67__opt->min = 0;
    lglminit__1__67__opt->max = 1;
    lglminit__1__67__opt->descrp = "enable double lookahead lifting";
    lglgetenv(lgl, lglminit__1__67__opt, "lift");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__68__opt = &lgl->opts->lftmaxeff;
    lglminit__1__68__opt->shrt = (char)0;
    lglminit__1__68__opt->lng = "lftmaxeff";
    lglminit__1__68__opt->val = 20 * M;
    lglminit__1__68__opt->min = -1;
    lglminit__1__68__opt->max = I;
    lglminit__1__68__opt->descrp = "max effort in lifting";
    lglgetenv(lgl, lglminit__1__68__opt, "lftmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__69__opt = &lgl->opts->lftmineff;
    lglminit__1__69__opt->shrt = (char)0;
    lglminit__1__69__opt->lng = "lftmineff";
    lglminit__1__69__opt->val = 500 * K;
    lglminit__1__69__opt->min = 0;
    lglminit__1__69__opt->max = I;
    lglminit__1__69__opt->descrp = "min effort in lifting";
    lglgetenv(lgl, lglminit__1__69__opt, "lftmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__70__opt = &lgl->opts->lftreleff;
    lglminit__1__70__opt->shrt = (char)0;
    lglminit__1__70__opt->lng = "lftreleff";
    lglminit__1__70__opt->val = 6;
    lglminit__1__70__opt->min = 0;
    lglminit__1__70__opt->max = 10 * K;
    lglminit__1__70__opt->descrp = "rel effort in lifting";
    lglgetenv(lgl, lglminit__1__70__opt, "lftreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__71__opt = &lgl->opts->lhbr;
    lglminit__1__71__opt->shrt = (char)0;
    lglminit__1__71__opt->lng = "lhbr";
    lglminit__1__71__opt->val = 1;
    lglminit__1__71__opt->min = 0;
    lglminit__1__71__opt->max = 1;
    lglminit__1__71__opt->descrp = "enable lazy hyber binary reasoning";
    lglgetenv(lgl, lglminit__1__71__opt, "lhbr");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__72__opt = &lgl->opts->lkhd;
    lglminit__1__72__opt->shrt = (char)0;
    lglminit__1__72__opt->lng = "lkhd";
    lglminit__1__72__opt->val = 1;
    lglminit__1__72__opt->min = 0;
    lglminit__1__72__opt->max = 1;
    lglminit__1__72__opt->descrp = "0=LIS,1=JWH";
    lglgetenv(lgl, lglminit__1__72__opt, "lkhd");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__73__opt = &lgl->opts->clim;
    lglminit__1__73__opt->shrt = (char)0;
    lglminit__1__73__opt->lng = "clim";
    lglminit__1__73__opt->val = -1;
    lglminit__1__73__opt->min = -1;
    lglminit__1__73__opt->max = I;
    lglminit__1__73__opt->descrp = "conflict limit";
    lglgetenv(lgl, lglminit__1__73__opt, "clim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__74__opt = &lgl->opts->mocint;
    lglminit__1__74__opt->shrt = (char)0;
    lglminit__1__74__opt->lng = "mocint";
    lglminit__1__74__opt->val = 1000;
    lglminit__1__74__opt->min = 1;
    lglminit__1__74__opt->max = I;
    lglminit__1__74__opt->descrp = "multiple objectives conflict limit interval";
    lglgetenv(lgl, lglminit__1__74__opt, "mocint");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__75__opt = &lgl->opts->move;
    lglminit__1__75__opt->shrt = (char)0;
    lglminit__1__75__opt->lng = "move";
    lglminit__1__75__opt->val = 2;
    lglminit__1__75__opt->min = 0;
    lglminit__1__75__opt->max = 2;
    lglminit__1__75__opt->descrp = "move redundant clauses (1=only binary)";
    lglgetenv(lgl, lglminit__1__75__opt, "move");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__76__opt = &lgl->opts->log;
    lglminit__1__76__opt->shrt = (char)108;
    lglminit__1__76__opt->lng = "log";
    lglminit__1__76__opt->val = -1;
    lglminit__1__76__opt->min = -1;
    lglminit__1__76__opt->max = 5;
    lglminit__1__76__opt->descrp = "log level";
    lglgetenv(lgl, lglminit__1__76__opt, "log");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__77__opt = &lgl->opts->otfs;
    lglminit__1__77__opt->shrt = (char)0;
    lglminit__1__77__opt->lng = "otfs";
    lglminit__1__77__opt->val = 1;
    lglminit__1__77__opt->min = 0;
    lglminit__1__77__opt->max = 1;
    lglminit__1__77__opt->descrp = "enable on-the-fly subsumption";
    lglgetenv(lgl, lglminit__1__77__opt, "otfs");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__78__opt = &lgl->opts->phase;
    lglminit__1__78__opt->shrt = (char)0;
    lglminit__1__78__opt->lng = "phase";
    lglminit__1__78__opt->val = 0;
    lglminit__1__78__opt->min = -1;
    lglminit__1__78__opt->max = 1;
    lglminit__1__78__opt->descrp = "default phase (-1=neg,0=JeroslowWang,1=pos)";
    lglgetenv(lgl, lglminit__1__78__opt, "phase");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__79__opt = &lgl->opts->phaseneginit;
    lglminit__1__79__opt->shrt = (char)0;
    lglminit__1__79__opt->lng = "phaseneginit";
    lglminit__1__79__opt->val = 0;
    lglminit__1__79__opt->min = 0;
    lglminit__1__79__opt->max = I;
    lglminit__1__79__opt->descrp = "initial zero phase conflict interval";
    lglgetenv(lgl, lglminit__1__79__opt, "phaseneginit");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__80__opt = &lgl->opts->plain;
    lglminit__1__80__opt->shrt = (char)0;
    lglminit__1__80__opt->lng = "plain";
    lglminit__1__80__opt->val = 0;
    lglminit__1__80__opt->min = 0;
    lglminit__1__80__opt->max = 1;
    lglminit__1__80__opt->descrp = "plain mode disables all preprocessing";
    lglgetenv(lgl, lglminit__1__80__opt, "plain");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__81__opt = &lgl->opts->probe;
    lglminit__1__81__opt->shrt = (char)0;
    lglminit__1__81__opt->lng = "probe";
    lglminit__1__81__opt->val = 1;
    lglminit__1__81__opt->min = 0;
    lglminit__1__81__opt->max = 1;
    lglminit__1__81__opt->descrp = "enable probing";
    lglgetenv(lgl, lglminit__1__81__opt, "probe");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__82__opt = &lgl->opts->prbasic;
    lglminit__1__82__opt->shrt = (char)0;
    lglminit__1__82__opt->lng = "prbasic";
    lglminit__1__82__opt->val = 1;
    lglminit__1__82__opt->min = 0;
    lglminit__1__82__opt->max = 2;
    lglminit__1__82__opt->descrp = "enable basic probing procedure (1=roots only)";
    lglgetenv(lgl, lglminit__1__82__opt, "prbasic");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__83__opt = &lgl->opts->prbasicroundlim;
    lglminit__1__83__opt->shrt = (char)0;
    lglminit__1__83__opt->lng = "prbasicroundlim";
    lglminit__1__83__opt->val = 9;
    lglminit__1__83__opt->min = 1;
    lglminit__1__83__opt->max = I;
    lglminit__1__83__opt->descrp = "basic probing round limit";
    lglgetenv(lgl, lglminit__1__83__opt, "prbasicroundlim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__84__opt = &lgl->opts->prbasicmaxeff;
    lglminit__1__84__opt->shrt = (char)0;
    lglminit__1__84__opt->lng = "prbasicmaxeff";
    lglminit__1__84__opt->val = 100 * M;
    lglminit__1__84__opt->min = -1;
    lglminit__1__84__opt->max = I;
    lglminit__1__84__opt->descrp = "max effort in basic probing";
    lglgetenv(lgl, lglminit__1__84__opt, "prbasicmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__85__opt = &lgl->opts->prbasicmineff;
    lglminit__1__85__opt->shrt = (char)0;
    lglminit__1__85__opt->lng = "prbasicmineff";
    lglminit__1__85__opt->val = M;
    lglminit__1__85__opt->min = 0;
    lglminit__1__85__opt->max = I;
    lglminit__1__85__opt->descrp = "min effort in basic probing";
    lglgetenv(lgl, lglminit__1__85__opt, "prbasicmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__86__opt = &lgl->opts->prbasicreleff;
    lglminit__1__86__opt->shrt = (char)0;
    lglminit__1__86__opt->lng = "prbasicreleff";
    lglminit__1__86__opt->val = 10;
    lglminit__1__86__opt->min = 0;
    lglminit__1__86__opt->max = 10 * K;
    lglminit__1__86__opt->descrp = "rel effort in basic probing";
    lglgetenv(lgl, lglminit__1__86__opt, "prbasicreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__87__opt = &lgl->opts->queuemergelim;
    lglminit__1__87__opt->shrt = (char)0;
    lglminit__1__87__opt->lng = "queuemergelim";
    lglminit__1__87__opt->val = 10000;
    lglminit__1__87__opt->min = 1;
    lglminit__1__87__opt->max = I;
    lglminit__1__87__opt->descrp = "flush limit on garbage merged queue lines";
    lglgetenv(lgl, lglminit__1__87__opt, "queuemergelim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__88__opt = &lgl->opts->queuefactor;
    lglminit__1__88__opt->shrt = (char)0;
    lglminit__1__88__opt->lng = "queuefactor";
    lglminit__1__88__opt->val = 833;
    lglminit__1__88__opt->min = 1;
    lglminit__1__88__opt->max = 999;
    lglminit__1__88__opt->descrp = "queue unbump factor in per mille";
    lglgetenv(lgl, lglminit__1__88__opt, "queuefactor");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__89__opt = &lgl->opts->queueinc;
    lglminit__1__89__opt->shrt = (char)0;
    lglminit__1__89__opt->lng = "queueinc";
    lglminit__1__89__opt->val = 20;
    lglminit__1__89__opt->min = 1;
    lglminit__1__89__opt->max = 1000;
    lglminit__1__89__opt->descrp = "queue bump increment";
    lglgetenv(lgl, lglminit__1__89__opt, "queueinc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__90__opt = &lgl->opts->rmincpen;
    lglminit__1__90__opt->shrt = (char)0;
    lglminit__1__90__opt->lng = "rmincpen";
    lglminit__1__90__opt->val = 4;
    lglminit__1__90__opt->min = 0;
    lglminit__1__90__opt->max = 32;
    lglminit__1__90__opt->descrp = "logarithm of watcher removal penalty";
    lglgetenv(lgl, lglminit__1__90__opt, "rmincpen");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__91__opt = &lgl->opts->seed;
    lglminit__1__91__opt->shrt = (char)0;
    lglminit__1__91__opt->lng = "seed";
    lglminit__1__91__opt->val = 0;
    lglminit__1__91__opt->min = 0;
    lglminit__1__91__opt->max = I;
    lglminit__1__91__opt->descrp = "random number generator seed";
    lglgetenv(lgl, lglminit__1__91__opt, "seed");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__92__opt = &lgl->opts->smallirr;
    lglminit__1__92__opt->shrt = (char)0;
    lglminit__1__92__opt->lng = "smallirr";
    lglminit__1__92__opt->val = 90;
    lglminit__1__92__opt->min = 0;
    lglminit__1__92__opt->max = 100;
    lglminit__1__92__opt->descrp = "max percentage irr lits for BCE and VE";
    lglgetenv(lgl, lglminit__1__92__opt, "smallirr");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__93__opt = &lgl->opts->smallve;
    lglminit__1__93__opt->shrt = (char)0;
    lglminit__1__93__opt->lng = "smallve";
    lglminit__1__93__opt->val = 1;
    lglminit__1__93__opt->min = 0;
    lglminit__1__93__opt->max = 1;
    lglminit__1__93__opt->descrp = "enable small number variables elimination";
    lglgetenv(lgl, lglminit__1__93__opt, "smallve");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__94__opt = &lgl->opts->smallvevars;
    lglminit__1__94__opt->shrt = (char)0;
    lglminit__1__94__opt->lng = "smallvevars";
    lglminit__1__94__opt->val = 12;
    lglminit__1__94__opt->min = 4;
    lglminit__1__94__opt->max = 12;
    lglminit__1__94__opt->descrp = "variables small variable elimination";
    lglgetenv(lgl, lglminit__1__94__opt, "smallvevars");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__95__opt = &lgl->opts->randec;
    lglminit__1__95__opt->shrt = (char)0;
    lglminit__1__95__opt->lng = "randec";
    lglminit__1__95__opt->val = 1;
    lglminit__1__95__opt->min = 0;
    lglminit__1__95__opt->max = 1;
    lglminit__1__95__opt->descrp = "enable random decisions";
    lglgetenv(lgl, lglminit__1__95__opt, "randec");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__96__opt = &lgl->opts->randecint;
    lglminit__1__96__opt->shrt = (char)0;
    lglminit__1__96__opt->lng = "randecint";
    lglminit__1__96__opt->val = 1000;
    lglminit__1__96__opt->min = 2;
    lglminit__1__96__opt->max = I / 2;
    lglminit__1__96__opt->descrp = "random decision interval";
    lglgetenv(lgl, lglminit__1__96__opt, "randecint");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__97__opt = &lgl->opts->reduce;
    lglminit__1__97__opt->shrt = (char)0;
    lglminit__1__97__opt->lng = "reduce";
    lglminit__1__97__opt->val = 1;
    lglminit__1__97__opt->min = 0;
    lglminit__1__97__opt->max = 4;
    lglminit__1__97__opt->descrp = "clause reduction (1=noouter,2=luby,3=inout,4=arith)";
    lglgetenv(lgl, lglminit__1__97__opt, "reduce");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__98__opt = &lgl->opts->redfixed;
    lglminit__1__98__opt->shrt = (char)0;
    lglminit__1__98__opt->lng = "redfixed";
    lglminit__1__98__opt->val = 0;
    lglminit__1__98__opt->min = 0;
    lglminit__1__98__opt->max = 1;
    lglminit__1__98__opt->descrp = "keep a fixed size of learned clauses";
    lglgetenv(lgl, lglminit__1__98__opt, "redfixed");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__99__opt = &lgl->opts->redlbound;
    lglminit__1__99__opt->shrt = (char)0;
    lglminit__1__99__opt->lng = "redlbound";
    lglminit__1__99__opt->val = 0;
    lglminit__1__99__opt->min = 0;
    lglminit__1__99__opt->max = 1;
    lglminit__1__99__opt->descrp = "relative and absolute bounds on learned clauses";
    lglgetenv(lgl, lglminit__1__99__opt, "redlbound");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__100__opt = &lgl->opts->redlexpfac;
    lglminit__1__100__opt->shrt = (char)0;
    lglminit__1__100__opt->lng = "redlexpfac";
    lglminit__1__100__opt->val = 10;
    lglminit__1__100__opt->min = 0;
    lglminit__1__100__opt->max = 1000;
    lglminit__1__100__opt->descrp = "exponential reduce limit increment factor";
    lglgetenv(lgl, lglminit__1__100__opt, "redlexpfac");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__101__opt = &lgl->opts->redldoutfac;
    lglminit__1__101__opt->shrt = (char)0;
    lglminit__1__101__opt->lng = "redldoutfac";
    lglminit__1__101__opt->val = 0;
    lglminit__1__101__opt->min = 0;
    lglminit__1__101__opt->max = 32;
    lglminit__1__101__opt->descrp = "outer to inner factor";
    lglgetenv(lgl, lglminit__1__101__opt, "redldoutfac");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__102__opt = &lgl->opts->redloutinc;
    lglminit__1__102__opt->shrt = (char)0;
    lglminit__1__102__opt->lng = "redloutinc";
    lglminit__1__102__opt->val = 10000;
    lglminit__1__102__opt->min = 0;
    lglminit__1__102__opt->max = 1000000;
    lglminit__1__102__opt->descrp = "outer arithmetic reduce increment";
    lglgetenv(lgl, lglminit__1__102__opt, "redloutinc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *opt = &lgl->opts->redlinit;
    opt->shrt = (char)0;
    opt->lng = "redlinit";
    opt->val = 1 * K;
    opt->min = 1;
    opt->max = 100 * M;
    opt->descrp = "initial reduce limit";
    lglgetenv(lgl, opt, "redlinit");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__104__opt = &lgl->opts->redlinc;
    lglminit__1__104__opt->shrt = (char)0;
    lglminit__1__104__opt->lng = "redlinc";
    lglminit__1__104__opt->val = 1000;
    lglminit__1__104__opt->min = 1;
    lglminit__1__104__opt->max = 10 * M;
    lglminit__1__104__opt->descrp = "reduce limit increment";
    lglgetenv(lgl, lglminit__1__104__opt, "redlinc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__105__opt = &lgl->opts->redinoutinc;
    lglminit__1__105__opt->shrt = (char)0;
    lglminit__1__105__opt->lng = "redinoutinc";
    lglminit__1__105__opt->val = 100;
    lglminit__1__105__opt->min = 1;
    lglminit__1__105__opt->max = 1000;
    lglminit__1__105__opt->descrp = "reduce inner/outer relative increment";
    lglgetenv(lgl, lglminit__1__105__opt, "redinoutinc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__106__opt = &lgl->opts->redlmininc;
    lglminit__1__106__opt->shrt = (char)0;
    lglminit__1__106__opt->lng = "redlmininc";
    lglminit__1__106__opt->val = 10;
    lglminit__1__106__opt->min = 1;
    lglminit__1__106__opt->max = 100 * K;
    lglminit__1__106__opt->descrp = "rel min reduce limit increment";
    lglgetenv(lgl, lglminit__1__106__opt, "redlmininc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__107__opt = &lgl->opts->redlmaxinc;
    lglminit__1__107__opt->shrt = (char)0;
    lglminit__1__107__opt->lng = "redlmaxinc";
    lglminit__1__107__opt->val = 200;
    lglminit__1__107__opt->min = 1;
    lglminit__1__107__opt->max = 100 * K;
    lglminit__1__107__opt->descrp = "rel max reduce limit increment";
    lglgetenv(lgl, lglminit__1__107__opt, "redlmaxinc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__108__opt = &lgl->opts->redlminrel;
    lglminit__1__108__opt->shrt = (char)0;
    lglminit__1__108__opt->lng = "redlminrel";
    lglminit__1__108__opt->val = 10;
    lglminit__1__108__opt->min = 10;
    lglminit__1__108__opt->max = 1000;
    lglminit__1__108__opt->descrp = "minimum relative reduce limit";
    lglgetenv(lgl, lglminit__1__108__opt, "redlminrel");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__109__opt = &lgl->opts->redlmaxrel;
    lglminit__1__109__opt->shrt = (char)0;
    lglminit__1__109__opt->lng = "redlmaxrel";
    lglminit__1__109__opt->val = 300;
    lglminit__1__109__opt->min = 10;
    lglminit__1__109__opt->max = 10000;
    lglminit__1__109__opt->descrp = "maximum relative reduce limit";
    lglgetenv(lgl, lglminit__1__109__opt, "redlmaxrel");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__110__opt = &lgl->opts->redlminabs;
    lglminit__1__110__opt->shrt = (char)0;
    lglminit__1__110__opt->lng = "redlminabs";
    lglminit__1__110__opt->val = 500;
    lglminit__1__110__opt->min = 10;
    lglminit__1__110__opt->max = 1000000;
    lglminit__1__110__opt->descrp = "minimum absolute reduce limit";
    lglgetenv(lgl, lglminit__1__110__opt, "redlminabs");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__111__opt = &lgl->opts->redlmaxabs;
    lglminit__1__111__opt->shrt = (char)0;
    lglminit__1__111__opt->lng = "redlmaxabs";
    lglminit__1__111__opt->val = 1000000;
    lglminit__1__111__opt->min = 10;
    lglminit__1__111__opt->max = I / 2;
    lglminit__1__111__opt->descrp = "maximum absolute reduce limit";
    lglgetenv(lgl, lglminit__1__111__opt, "redlmaxabs");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__112__opt = &lgl->opts->restart;
    lglminit__1__112__opt->shrt = (char)0;
    lglminit__1__112__opt->lng = "restart";
    lglminit__1__112__opt->val = 2;
    lglminit__1__112__opt->min = 0;
    lglminit__1__112__opt->max = 3;
    lglminit__1__112__opt->descrp = "enable restarting (0=no,1=fixed,2=luby,3=inout)";
    lglgetenv(lgl, lglminit__1__112__opt, "restart");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__113__opt = &lgl->opts->restartint;
    lglminit__1__113__opt->shrt = (char)0;
    lglminit__1__113__opt->lng = "restartint";
    lglminit__1__113__opt->val = 5;
    lglminit__1__113__opt->min = 1;
    lglminit__1__113__opt->max = I;
    lglminit__1__113__opt->descrp = "restart interval";
    lglgetenv(lgl, lglminit__1__113__opt, "restartint");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__114__opt = &lgl->opts->rstinoutinc;
    lglminit__1__114__opt->shrt = (char)0;
    lglminit__1__114__opt->lng = "rstinoutinc";
    lglminit__1__114__opt->val = 110;
    lglminit__1__114__opt->min = 1;
    lglminit__1__114__opt->max = 1000;
    lglminit__1__114__opt->descrp = "restart inner/outer relative increment";
    lglgetenv(lgl, lglminit__1__114__opt, "rstinoutinc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__115__opt = &lgl->opts->simplify;
    lglminit__1__115__opt->shrt = (char)0;
    lglminit__1__115__opt->lng = "simplify";
    lglminit__1__115__opt->val = 1;
    lglminit__1__115__opt->min = 0;
    lglminit__1__115__opt->max = 1;
    lglminit__1__115__opt->descrp = "enable simplification";
    lglgetenv(lgl, lglminit__1__115__opt, "simplify");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__116__opt = &lgl->opts->simpdelay;
    lglminit__1__116__opt->shrt = (char)0;
    lglminit__1__116__opt->lng = "simpdelay";
    lglminit__1__116__opt->val = 100;
    lglminit__1__116__opt->min = 0;
    lglminit__1__116__opt->max = 0x7fffffff;
    lglminit__1__116__opt->descrp = "delay simplification";
    lglgetenv(lgl, lglminit__1__116__opt, "simpdelay");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__117__opt = &lgl->opts->simpen;
    lglminit__1__117__opt->shrt = (char)0;
    lglminit__1__117__opt->lng = "simpen";
    lglminit__1__117__opt->val = 4;
    lglminit__1__117__opt->min = 0;
    lglminit__1__117__opt->max = 24;
    lglminit__1__117__opt->descrp = "logarithmic initial simplification penalty";
    lglgetenv(lgl, lglminit__1__117__opt, "simpen");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__118__opt = &lgl->opts->sizepen;
    lglminit__1__118__opt->shrt = (char)0;
    lglminit__1__118__opt->lng = "sizepen";
    lglminit__1__118__opt->val = 1 * M;
    lglminit__1__118__opt->min = 1;
    lglminit__1__118__opt->max = I;
    lglminit__1__118__opt->descrp = "number of literals size penalty starting point";
    lglgetenv(lgl, lglminit__1__118__opt, "sizepen");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__119__opt = &lgl->opts->sizemaxpen;
    lglminit__1__119__opt->shrt = (char)0;
    lglminit__1__119__opt->lng = "sizemaxpen";
    lglminit__1__119__opt->val = 3;
    lglminit__1__119__opt->min = 0;
    lglminit__1__119__opt->max = 20;
    lglminit__1__119__opt->descrp = "maximum logarithmic size penalty";
    lglgetenv(lgl, lglminit__1__119__opt, "sizemaxpen");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__120__opt = &lgl->opts->sortlits;
    lglminit__1__120__opt->shrt = (char)0;
    lglminit__1__120__opt->lng = "sortlits";
    lglminit__1__120__opt->val = 0;
    lglminit__1__120__opt->min = 0;
    lglminit__1__120__opt->max = 1;
    lglminit__1__120__opt->descrp = "sort literals of clauses during garbage collection";
    lglgetenv(lgl, lglminit__1__120__opt, "sortlits");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__121__opt = &lgl->opts->syncint;
    lglminit__1__121__opt->shrt = (char)0;
    lglminit__1__121__opt->lng = "syncint";
    lglminit__1__121__opt->val = 111111;
    lglminit__1__121__opt->min = 0;
    lglminit__1__121__opt->max = M;
    lglminit__1__121__opt->descrp = "unit synchronization interval";
    lglgetenv(lgl, lglminit__1__121__opt, "syncint");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__122__opt = &lgl->opts->termint;
    lglminit__1__122__opt->shrt = (char)0;
    lglminit__1__122__opt->lng = "termint";
    lglminit__1__122__opt->val = 122222;
    lglminit__1__122__opt->min = 0;
    lglminit__1__122__opt->max = M;
    lglminit__1__122__opt->descrp = "termination check interval";
    lglgetenv(lgl, lglminit__1__122__opt, "termint");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__123__opt = &lgl->opts->ternres;
    lglminit__1__123__opt->shrt = (char)0;
    lglminit__1__123__opt->lng = "ternres";
    lglminit__1__123__opt->val = 1;
    lglminit__1__123__opt->min = 0;
    lglminit__1__123__opt->max = 1;
    lglminit__1__123__opt->descrp = "generate ternary resolvents";
    lglgetenv(lgl, lglminit__1__123__opt, "ternres");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__124__opt = &lgl->opts->ternresrtc;
    lglminit__1__124__opt->shrt = (char)0;
    lglminit__1__124__opt->lng = "ternresrtc";
    lglminit__1__124__opt->val = 0;
    lglminit__1__124__opt->min = 0;
    lglminit__1__124__opt->max = 1;
    lglminit__1__124__opt->descrp = "run ternary resolvents until completion";
    lglgetenv(lgl, lglminit__1__124__opt, "ternresrtc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__125__opt = &lgl->opts->trnrmaxeff;
    lglminit__1__125__opt->shrt = (char)0;
    lglminit__1__125__opt->lng = "trnrmaxeff";
    lglminit__1__125__opt->val = 40 * M;
    lglminit__1__125__opt->min = -1;
    lglminit__1__125__opt->max = I;
    lglminit__1__125__opt->descrp = "max effort in ternary resolutions";
    lglgetenv(lgl, lglminit__1__125__opt, "trnrmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__126__opt = &lgl->opts->trnrmineff;
    lglminit__1__126__opt->shrt = (char)0;
    lglminit__1__126__opt->lng = "trnrmineff";
    lglminit__1__126__opt->val = 4 * M;
    lglminit__1__126__opt->min = 0;
    lglminit__1__126__opt->max = I;
    lglminit__1__126__opt->descrp = "min effort in ternary resolutions";
    lglgetenv(lgl, lglminit__1__126__opt, "trnrmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__127__opt = &lgl->opts->trnreleff;
    lglminit__1__127__opt->shrt = (char)0;
    lglminit__1__127__opt->lng = "trnreleff";
    lglminit__1__127__opt->val = 10;
    lglminit__1__127__opt->min = 0;
    lglminit__1__127__opt->max = K;
    lglminit__1__127__opt->descrp = "rel effort in ternary resolutions";
    lglgetenv(lgl, lglminit__1__127__opt, "trnreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__128__opt = &lgl->opts->transred;
    lglminit__1__128__opt->shrt = (char)0;
    lglminit__1__128__opt->lng = "transred";
    lglminit__1__128__opt->val = 1;
    lglminit__1__128__opt->min = 0;
    lglminit__1__128__opt->max = 1;
    lglminit__1__128__opt->descrp = "enable transitive reduction";
    lglgetenv(lgl, lglminit__1__128__opt, "transred");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__129__opt = &lgl->opts->trdmaxeff;
    lglminit__1__129__opt->shrt = (char)0;
    lglminit__1__129__opt->lng = "trdmaxeff";
    lglminit__1__129__opt->val = 2 * M;
    lglminit__1__129__opt->min = -1;
    lglminit__1__129__opt->max = I;
    lglminit__1__129__opt->descrp = "max effort in transitive reduction";
    lglgetenv(lgl, lglminit__1__129__opt, "trdmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__130__opt = &lgl->opts->trdmineff;
    lglminit__1__130__opt->shrt = (char)0;
    lglminit__1__130__opt->lng = "trdmineff";
    lglminit__1__130__opt->val = 100 * K;
    lglminit__1__130__opt->min = 0;
    lglminit__1__130__opt->max = I;
    lglminit__1__130__opt->descrp = "min effort in transitive reduction";
    lglgetenv(lgl, lglminit__1__130__opt, "trdmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__131__opt = &lgl->opts->trdreleff;
    lglminit__1__131__opt->shrt = (char)0;
    lglminit__1__131__opt->lng = "trdreleff";
    lglminit__1__131__opt->val = 10;
    lglminit__1__131__opt->min = 0;
    lglminit__1__131__opt->max = 10 * K;
    lglminit__1__131__opt->descrp = "rel effort in transitive reduction";
    lglgetenv(lgl, lglminit__1__131__opt, "trdreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__132__opt = &lgl->opts->unhide;
    lglminit__1__132__opt->shrt = (char)0;
    lglminit__1__132__opt->lng = "unhide";
    lglminit__1__132__opt->val = 1;
    lglminit__1__132__opt->min = 0;
    lglminit__1__132__opt->max = 1;
    lglminit__1__132__opt->descrp = "enable unhiding";
    lglgetenv(lgl, lglminit__1__132__opt, "unhide");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__133__opt = &lgl->opts->unhdextstamp;
    lglminit__1__133__opt->shrt = (char)0;
    lglminit__1__133__opt->lng = "unhdextstamp";
    lglminit__1__133__opt->val = 1;
    lglminit__1__133__opt->min = 0;
    lglminit__1__133__opt->max = 1;
    lglminit__1__133__opt->descrp = "used extended stamping features";
    lglgetenv(lgl, lglminit__1__133__opt, "unhdextstamp");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__134__opt = &lgl->opts->unhdhbr;
    lglminit__1__134__opt->shrt = (char)0;
    lglminit__1__134__opt->lng = "unhdhbr";
    lglminit__1__134__opt->val = 0;
    lglminit__1__134__opt->min = 0;
    lglminit__1__134__opt->max = 1;
    lglminit__1__134__opt->descrp = "enable unhiding hidden binary resolution";
    lglgetenv(lgl, lglminit__1__134__opt, "unhdhbr");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__135__opt = &lgl->opts->unhdmaxeff;
    lglminit__1__135__opt->shrt = (char)0;
    lglminit__1__135__opt->lng = "unhdmaxeff";
    lglminit__1__135__opt->val = 20 * M;
    lglminit__1__135__opt->min = -1;
    lglminit__1__135__opt->max = I;
    lglminit__1__135__opt->descrp = "max effort in unhiding";
    lglgetenv(lgl, lglminit__1__135__opt, "unhdmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__136__opt = &lgl->opts->unhdmineff;
    lglminit__1__136__opt->shrt = (char)0;
    lglminit__1__136__opt->lng = "unhdmineff";
    lglminit__1__136__opt->val = 1 * M;
    lglminit__1__136__opt->min = 0;
    lglminit__1__136__opt->max = I;
    lglminit__1__136__opt->descrp = "min effort in unhiding";
    lglgetenv(lgl, lglminit__1__136__opt, "unhdmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__137__opt = &lgl->opts->unhdreleff;
    lglminit__1__137__opt->shrt = (char)0;
    lglminit__1__137__opt->lng = "unhdreleff";
    lglminit__1__137__opt->val = 4;
    lglminit__1__137__opt->min = 0;
    lglminit__1__137__opt->max = 10 * K;
    lglminit__1__137__opt->descrp = "rel effort in unhiding";
    lglgetenv(lgl, lglminit__1__137__opt, "unhdreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__138__opt = &lgl->opts->unhdlnpr;
    lglminit__1__138__opt->shrt = (char)0;
    lglminit__1__138__opt->lng = "unhdlnpr";
    lglminit__1__138__opt->val = 3;
    lglminit__1__138__opt->min = 0;
    lglminit__1__138__opt->max = I;
    lglminit__1__138__opt->descrp = "unhide no progress round limit";
    lglgetenv(lgl, lglminit__1__138__opt, "unhdlnpr");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__139__opt = &lgl->opts->unhdroundlim;
    lglminit__1__139__opt->shrt = (char)0;
    lglminit__1__139__opt->lng = "unhdroundlim";
    lglminit__1__139__opt->val = 5;
    lglminit__1__139__opt->min = 0;
    lglminit__1__139__opt->max = 100;
    lglminit__1__139__opt->descrp = "unhide round limit";
    lglgetenv(lgl, lglminit__1__139__opt, "unhdroundlim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__140__opt = &lgl->opts->verbose;
    lglminit__1__140__opt->shrt = (char)118;
    lglminit__1__140__opt->lng = "verbose";
    lglminit__1__140__opt->val = 0;
    lglminit__1__140__opt->min = 0;
    lglminit__1__140__opt->max = 3;
    lglminit__1__140__opt->descrp = "verbosity level";
    lglgetenv(lgl, lglminit__1__140__opt, "verbose");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit__1__141__opt = &lgl->opts->witness;
    lglminit__1__141__opt->shrt = (char)0;
    lglminit__1__141__opt->lng = "witness";
    lglminit__1__141__opt->val = 1;
    lglminit__1__141__opt->min = 0;
    lglminit__1__141__opt->max = 1;
    lglminit__1__141__opt->descrp = "print witness";
    lglgetenv(lgl, lglminit__1__141__opt, "witness");
  }
  while((_Bool)0);
  if(!(lgl->opts->plain.val == 0))
    lglsetplain(lgl, 1);

  signed int return_value_abs_1;
  return_value_abs_1=abs(lgl->opts->bias.val);
  if(!(return_value_abs_1 >= 2))
    lgl->bias = lgl->opts->bias.val;

  else
    lgl->bias = 1;
  do
  {
    void *return_value_lglnew_2;
    return_value_lglnew_2=lglnew(lgl, (unsigned long int)1 * sizeof(struct Times) /*240ul*/ );
    lgl->times = (struct Times *)return_value_lglnew_2;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew_3;
    return_value_lglnew_3=lglnew(lgl, (unsigned long int)1 * sizeof(struct Tmrs) /*128ul*/ );
    lgl->timers = (struct Tmrs *)return_value_lglnew_3;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew_4;
    return_value_lglnew_4=lglnew(lgl, (unsigned long int)1 * sizeof(struct Limits) /*352ul*/ );
    lgl->limits = (struct Limits *)return_value_lglnew_4;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew_5;
    return_value_lglnew_5=lglnew(lgl, (unsigned long int)1 * sizeof(struct FltStr) /*604ul*/ );
    lgl->fltstr = (struct FltStr *)return_value_lglnew_5;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew_6;
    return_value_lglnew_6=lglnew(lgl, (unsigned long int)(((1 << 4) - 1) + 1) * sizeof(struct Stk) /*24ul*/ );
    lgl->red = (struct Stk *)return_value_lglnew_6;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew_7;
    return_value_lglnew_7=lglnew(lgl, (unsigned long int)1 * sizeof(struct Wchs) /*152ul*/ );
    lgl->wchs = (struct Wchs *)return_value_lglnew_7;
  }
  while((_Bool)0);
  i = 0;
  for( ; !(i >= 31); i = i + 1)
    lgl->wchs->start[(signed long int)i] = 0x7fffffff;
  lglpushstk(lgl, &lgl->wchs->stk, 0x7fffffff);
  lglpushstk(lgl, &lgl->wchs->stk, 0x7fffffff);

__CPROVER_DUMP_L154:
  ;
  do
    lgl->state = (enum State)UNUSED;
  while((_Bool)0);
  return lgl;
}

// lglmnt
// file lglib.c line 1054
static unsigned long int lglmnt(signed long int a)
{
  unsigned long int res = (unsigned long int)a & 0x00000001ffffffffull;
  res = res | 0x0000000100000000ull;
  return res;
}

// lglmosat
// file lglib.c line 17745
signed int lglmosat(struct LGL *lgl, void *state, signed int (*f)(void *, signed int, signed int), signed int *targets)
{
  signed int cint;
  signed int clim;
  signed int target;
  signed int ntargets;
  signed int rtargets;
  signed int lglmosat__1__next;
  signed int round;
  signed int lglmosat__1__done;
  signed char *reported;
  signed char *r;
  signed long int confs;
  signed long int totalclim;
  const signed int *p;
  signed char val;
  struct Lim lim;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmosat");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  do
  {
    signed int return_value_lglmtstk_1;
    return_value_lglmtstk_1=lglmtstk(&lgl->clause);
    if(!(return_value_lglmtstk_1 == 0))
      break;

    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmosat");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "clause terminating zero missing");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
  }
  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "mosat");
    break;
  }
  lglstart(lgl, &lgl->times->all);
  lgl->stats->calls.mosat = lgl->stats->calls.mosat + 1l;
  ntargets = 0;
  p = targets;
  for( ; !(*p == 0); p = p + 1l)
    ntargets = ntargets + 1;
  do
  {
    void *return_value_lglnew_2;
    return_value_lglnew_2=lglnew(lgl, (unsigned long int)ntargets * sizeof(signed char) /*1ul*/ );
    reported = (signed char *)return_value_lglnew_2;
  }
  while((_Bool)0);
  rtargets = ntargets;
  cint = lgl->opts->mocint.val;
  signed long long int tmp_if_expr_3;
  if(!(lgl->opts->clim.val >= 0))
    tmp_if_expr_3 = 0x7fffffffffffffffll;

  else
    tmp_if_expr_3 = lgl->stats->confs + (signed long int)lgl->opts->clim.val;
  totalclim = tmp_if_expr_3;
  round = 1;
  lglmosat__1__next = 0;
  lglmosat__1__done = lglmosat__1__next;
  lglprt(lgl, 1, "[mosat-%lld] given %d targets", (signed long long int)lgl->stats->calls.mosat, ntargets);
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_7;
  signed char return_value_lglval_6;
  while(lgl->mt == 0)
  {
    p = targets;
    r = reported;
    do
    {
      if(lglmosat__1__done == 0)
      {
        target = *p;
        tmp_if_expr_4 = target != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(!tmp_if_expr_4)
        break;

      if(*r == 0)
      {
        signed int return_value_lglfixed_5;
        return_value_lglfixed_5=lglfixed(lgl, target);
        val = (signed char)return_value_lglfixed_5;
        if((signed int)val >= 0)
        {
          if((signed int)lgl->state == SATISFIED)
          {
            return_value_lglval_6=lglval(lgl, target);
            tmp_if_expr_7 = (signed int)return_value_lglval_6 > 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_7 = (_Bool)0;
          if(tmp_if_expr_7)
            val = (signed char)1;

          else
            val = (signed char)0;
        }

        if(!(val == 0))
        {

        __CPROVER_DUMP_L21:
          ;
          signed int return_value;
          return_value=f(state, target, (signed int)val);
          lglmosat__1__done = (signed int)!(return_value != 0);
          rtargets = rtargets - 1;
          *r = val;
        }

      }

      p = p + 1l;
      r = r + 1l;
    }
    while((_Bool)1);
    round = round + 1;
    double return_value_lglpcnt_8;
    return_value_lglpcnt_8=lglpcnt((double)rtargets, (double)ntargets);
    lglprt(lgl, 1, "[mosat-%lld-%d] %d targets remain out of %d (%.0f%%)", (signed long long int)lgl->stats->calls.mosat, round, rtargets, ntargets, return_value_lglpcnt_8);
    if(rtargets == 0)
      break;

    if(!(totalclim >= lgl->stats->confs))
      break;

    do
    {
      target = targets[(signed long int)lglmosat__1__next];
      signed int return_value_lglfixed_9;
      return_value_lglfixed_9=lglfixed(lgl, target);
      if(return_value_lglfixed_9 == 0)
        break;

      lglmosat__1__next = lglmosat__1__next + 1;
      if(lglmosat__1__next == ntargets)
        lglmosat__1__next = 0;

    }
    while((_Bool)1);

  __CPROVER_DUMP_L26:
    ;
    lglassume(lgl, target);
    confs = lgl->stats->confs;
    clim=lglmin(cint, lgl->opts->clim.val);
    lim.confs = confs >= 0x7fffffffffffffffll - (signed long int)clim ? 0x7fffffffffffffffll : confs + (signed long int)clim;
    lim.decs = (signed long int)-1;
    lglprt(lgl, 1, "[limits] conflict limit %lld after %lld conflicts", (signed long long int)lim.confs, (signed long long int)confs);
    lglisat(lgl, &lim, 0);
    cint = cint + lgl->opts->mocint.val;
  }
  do
  {
    lgldel(lgl, (void *)reported, (unsigned long int)ntargets * sizeof(signed char) /*1ul*/ );
    reported = ((signed char *)NULL);
  }
  while((_Bool)0);
  lglprt(lgl, 1, "[mosat-%lld] solved %d targets out of %d, %d remain", (signed long long int)lgl->stats->calls.mosat, ntargets - rtargets, ntargets, rtargets);
  lglstop(lgl);
  return (signed int)!(rtargets != 0);
}

// lglmsgend
// file lglib.c line 1199
static void lglmsgend(struct LGL *lgl)
{
  fputc(10, lgl->out);
  fflush(lgl->out);
  if(!(lgl->cbs == ((struct Cbs *)NULL)))
  {
    if(!(lgl->cbs->msglock.unlock == ((void (*)(void *))NULL)))
      lgl->cbs->msglock.unlock(lgl->cbs->msglock.state);

  }

}

// lglmsgstart
// file lglib.c line 1190
static signed int lglmsgstart(struct LGL *lgl, signed int level)
{
  if(!(lgl->opts->verbose.val >= level))
    return 0;

  else
  {
    if(!(lgl->cbs == ((struct Cbs *)NULL)))
    {
      if(!(lgl->cbs->msglock.lock == ((void (*)(void *))NULL)))
        lgl->cbs->msglock.lock(lgl->cbs->msglock.state);

    }

    const char *return_value_lglprefix_1;
    return_value_lglprefix_1=lglprefix(lgl);
    fputs(return_value_lglprefix_1, lgl->out);
    if(lgl->tid >= 0)
      fprintf(lgl->out, "%d ", lgl->tid);

    return 1;
  }
}

// lglmtstk
// file lglib.c line 1387
static signed int lglmtstk(struct Stk *s)
{
  return (signed int)(s->top == s->start);
}

// lglmtwtk
// file lglib.c line 14987
static signed int lglmtwtk(struct Wtk *wtk)
{
  return (signed int)(wtk->top == wtk->start);
}

// lglmulflt
// file lglib.c line 1126
static signed long int lglmulflt(signed long int a, signed long int b)
{
  signed int e;
  signed int ea;
  signed int eb;
  unsigned long int m;
  unsigned long int ma;
  unsigned long int mb;
  lglchkflt(a);
  lglchkflt(b);
  if(a == 0x7fffffffffffffffll)
    return 0x7fffffffffffffffll;

  else
    if(b == 0x7fffffffffffffffll)
      return 0x7fffffffffffffffll;

    else
      if(a == 0x0000000000000000ll)
        return 0x0000000000000000ll;

      else
        if(b == 0x0000000000000000ll)
          return 0x0000000000000000ll;

        else
        {
          ea=lglexp(a);
          eb=lglexp(b);
          if(ea >= 1 && eb >= 1 && !(0x7fffffff + -ea >= eb))
            return 0x7fffffffffffffffll;

          else
          {
            e = ea + eb;
            if(e >= 1879048160)
              return 0x7fffffffffffffffll;

            else
            {
              e = e + 32;
              ma=lglmnt(a);
              mb=lglmnt(b);
              ma = ma >> 1;
              mb = mb >> 1;
              m = ma * mb;
              m = m >> 30;
              signed long int return_value_lglflt_1;
              return_value_lglflt_1=lglflt(e, m);
              return return_value_lglflt_1;
            }
          }
        }
}

// lglmvbcls
// file lglib.c line 11138
static void lglmvbcls(struct LGL *lgl, signed int a, signed int b)
{
  lglpushstk(lgl, &lgl->clause, a);
  lglpushstk(lgl, &lgl->clause, b);
  lglpushstk(lgl, &lgl->clause, 0);
  signed int return_value_lglsimpleprobeclausexists_1;
  return_value_lglsimpleprobeclausexists_1=lglsimpleprobeclausexists(lgl);
  if(return_value_lglsimpleprobeclausexists_1 == 0)
  {

  __CPROVER_DUMP_L1:
    ;
    lgladdcls(lgl, REDCS, 0, 1);
  }

  lglclnstk(&lgl->clause);
  lgl->stats->moved.bin = lgl->stats->moved.bin + 1l;
}

// lglmvtcls
// file lglib.c line 11157
static void lglmvtcls(struct LGL *lgl, signed int a, signed int b, signed int c)
{
  lglpushstk(lgl, &lgl->clause, a);
  lglpushstk(lgl, &lgl->clause, b);
  lglpushstk(lgl, &lgl->clause, c);
  lglpushstk(lgl, &lgl->clause, 0);
  signed int return_value_lglsimpleprobeclausexists_1;
  return_value_lglsimpleprobeclausexists_1=lglsimpleprobeclausexists(lgl);
  if(return_value_lglsimpleprobeclausexists_1 == 0)
  {

  __CPROVER_DUMP_L1:
    ;
    lgladdcls(lgl, REDCS, 0, 1);
  }

  lglclnstk(&lgl->clause);
  lgl->stats->moved.trn = lgl->stats->moved.trn + 1l;
}

// lglneedacts
// file lglib.c line 5144
static signed int lglneedacts(struct LGL *lgl, signed int *glueuselessptr, signed int *needmoreglueptr)
{
  signed long int clauses = (signed long int)0;
  signed long int weighted = (signed long int)0;
  signed long int tmp;
  signed long int avg;
  signed long int var = (signed long int)0;
  signed long int std;
  signed long int delta;
  signed int glue;
  signed int maxglue = 0;
  glue = 0;
  for( ; !(glue >= 16); glue = glue + 1)
  {
    tmp = (signed long int)lgl->stats->lir[(signed long int)glue].clauses;
    if(!(tmp == 0l))
      maxglue = glue;

    clauses = clauses + tmp;
    weighted = weighted + (signed long int)glue * tmp;
  }
  avg = clauses != 0l ? ((signed long int)10 * weighted) / clauses : (signed long int)0;
  lglprt(lgl, 2, "[needacts-%d] existing clauses glue average %.1f", lgl->stats->reduced, (double)avg / 10.0);
  glue = 1;
  for( ; !(glue >= 16); glue = glue + 1)
  {
    delta = (signed long int)(10 * glue) - avg;
    var = var + delta * delta * (signed long int)lgl->stats->lir[(signed long int)glue].clauses;
  }
  var = clauses != 0l ? var / clauses : (signed long int)0;
  signed int return_value_lglceilsqrt64_1;
  return_value_lglceilsqrt64_1=lglceilsqrt64((signed int)var);
  std = (signed long int)return_value_lglceilsqrt64_1;
  lglprt(lgl, 2, "[needacts-%d] existing clauses glue standard deviation %.1f", lgl->stats->reduced, (double)std / 10.0);
  *glueuselessptr = (signed int)(std < (signed long int)10);
  if(!(maxglue >= 4))
    *needmoreglueptr = 2;

  else
    if(!(maxglue >= 6))
      *needmoreglueptr = 1;

    else
      *needmoreglueptr = 1;
  if(!((signed long int)lgl->opts->actavgmax.val >= avg))
    return 1;

  else
    if((signed long int)lgl->opts->actstdmin.val >= std)
      return 1;

    else
      if(!((signed long int)lgl->opts->actstdmax.val >= std))
        return 1;

      else
        return 0;
}

// lglnegass
// file lglib.c line 17554
static void lglnegass(struct LGL *lgl)
{
  const signed int *p;
  struct Stk eassume;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglnegass");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "negass");
    break;
  }
  if(lgl->mt == 0)
  {
    do
      memset((void *)&eassume, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    p = lgl->eassume.start;
    for( ; !(p >= lgl->eassume.top); p = p + 1l)
      lglpushstk(lgl, &eassume, *p);
    p = eassume.start;
    for( ; !(p >= eassume.top); p = p + 1l)
      lgleadd(lgl, -(*p));
    lgleadd(lgl, 0);
    p = eassume.start;
    for( ; !(p >= eassume.top); p = p + 1l)
      lglassume(lgl, *p);
    lglrelstk(lgl, &eassume);
    lgluse(lgl);
    if(!(lgl->clone == ((struct LGL *)NULL)))
      lglnegass(lgl->clone);

  }

}

// lglnegcofactorfun
// file lglib.c line 10751
static void lglnegcofactorfun(unsigned long int *f, signed int v, unsigned long int *res)
{
  unsigned long int mask[64l];
  unsigned long int masked[64l];
  lglvar2fun(v, mask);
  lgland3negfun(masked, f, mask);
  lglfuncpy(res, masked);
  lglslfun(masked, 1 << v);
  lglorfun(res, masked);
}

// lglnegvar2fun
// file lglib.c line 10503
static void lglnegvar2fun(signed int v, unsigned long int *res)
{
  lglvar2funaux(v, res, 1);
}

// lglnew
// file lglib.c line 1258
static void * lglnew(struct LGL *lgl, unsigned long int bytes)
{
  void *res;
  if(bytes == 0ul)
    return NULL;

  else
  {
    if(!(lgl->mem->alloc == ((void * (*)(void *, unsigned long int))NULL)))
      res=lgl->mem->alloc(lgl->mem->state, bytes);

    else
      res=malloc(bytes);
    if(res == NULL)
      lgldie(lgl, "out of memory allocating %ld bytes", bytes);


  __CPROVER_DUMP_L4:
    ;
    lglinc(lgl, bytes);
    if(!(res == NULL))
      memset(res, 0, bytes);

    return res;
  }
}

// lglnewbingate
// file lglib.c line 12451
static signed int lglnewbingate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int rhs0, signed int rhs1)
{
  signed int gidx;
  struct Gat *g;
  lhs=lglcgreprnotconst(lgl, lhs);
  rhs0=lglcgreprnotconst(lgl, rhs0);
  rhs1=lglcgreprnotconst(lgl, rhs1);
  signed int return_value_abs_1;
  return_value_abs_1=abs(rhs0);
  signed int return_value_abs_2;
  return_value_abs_2=abs(rhs1);
  if(!(return_value_abs_2 >= return_value_abs_1))
    do
    {
      signed int TMP = rhs0;
      rhs0 = rhs1;
      rhs1 = TMP;
    }
    while((_Bool)0);

  if((signed int)tag == XORTAG && !(lhs >= 0))
  {
    lhs = -lhs;
    rhs0 = -rhs0;
  }

  if((signed int)tag == XORTAG && !(rhs0 >= 0))
  {
    rhs0 = -rhs0;
    rhs1 = -rhs1;
  }

  signed int return_value_lglhasbingate_3;
  return_value_lglhasbingate_3=lglhasbingate(lgl, tag, lhs, rhs0, rhs1);
  if(!(return_value_lglhasbingate_3 == 0))
    return 0;

  else
  {
    g=lglnewgate(lgl, tag, lhs, 2);
    gidx=lglgat2idx(lgl, g);
    g->_anon0.lits[(signed long int)0] = rhs0;
    g->_anon0.lits[(signed long int)1] = rhs1;
    lglpushgocc(lgl, rhs0, gidx);
    lglpushgocc(lgl, rhs1, gidx);
    if((signed int)tag == ANDTAG)
    {
      lgl->_anon0.cgr->extracted.and = lgl->_anon0.cgr->extracted.and + 1;
      lgl->stats->cgr.extracted.and = lgl->stats->cgr.extracted.and + 1l;
    }

    else
      if((signed int)tag == XORTAG)
      {
        lgl->_anon0.cgr->extracted.xor = lgl->_anon0.cgr->extracted.xor + 1;
        lgl->stats->cgr.extracted.xor = lgl->stats->cgr.extracted.xor + 1l;
      }


  __CPROVER_DUMP_L6:
    ;

  __CPROVER_DUMP_L8:
    ;
    return 1;
  }
}

// lglnewgate
// file lglib.c line 12349
static struct Gat * lglnewgate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int size)
{
  struct Gat *res;
  signed int gidx;
  if(lgl->_anon0.cgr->extracted.all >= lgl->_anon0.cgr->szgates)
    lglenlargegates(lgl);

  lgl->stats->cgr.extracted.all = lgl->stats->cgr.extracted.all + 1l;
  signed int tmp_post_1 = lgl->_anon0.cgr->extracted.all;
  lgl->_anon0.cgr->extracted.all = lgl->_anon0.cgr->extracted.all + 1;
  gidx = tmp_post_1;
  res = lgl->_anon0.cgr->gates + (signed long int)gidx;
  do
    memset((void *)&(*res), 0, sizeof(struct Gat) /*32ul*/ );
  while((_Bool)0);
  lhs=lglcgreprnotconst(lgl, lhs);
  res->lhs = lhs;
  lglpushgocc(lgl, lhs, gidx);
  struct AVar *return_value_lglavar_2;
  return_value_lglavar_2=lglavar(lgl, lhs);
  return_value_lglavar_2->gate = (unsigned int)1;
  res->tag = (unsigned int)tag;
  res->size = size;
  return res;
}

// lglnewirrlim
// file lglib.c line 6799
static signed long int lglnewirrlim(struct LGL *lgl)
{
  signed long int lglnewirrlim__1__add = lgl->stats->irr.clauses.add;
  signed long int res = lglnewirrlim__1__add;
  res = res * (100ll + (signed long int)lgl->opts->irrlim.val);
  res = res + (signed long int)99;
  res = res / (signed long int)100;
  if(lglnewirrlim__1__add >= res)
    res = lglnewirrlim__1__add + (signed long int)1;

  lglprt(lgl, 2, "[irrlim] %lld", (signed long long int)res);
  return res;
}

// lglnewitegate
// file lglib.c line 12406
static void lglnewitegate(struct LGL *lgl, signed int lhs, signed int cond, signed int pos, signed int neg)
{
  signed int gidx;
  struct Gat *g;
  lhs=lglcgreprnotconst(lgl, lhs);
  if(!(lhs >= 0))
  {
    lhs = -lhs;
    pos = -pos;
    neg = -neg;
  }

  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  signed int return_value_lglsgn_1;
  signed int return_value_lglsgn_2;
  if(neg >= 1 && !(pos >= 0))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    if(!(cond >= 0))
    {
      return_value_lglsgn_1=lglsgn(pos);
      return_value_lglsgn_2=lglsgn(neg);
      tmp_if_expr_3 = return_value_lglsgn_1 == return_value_lglsgn_2 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_4)
  {
    do
    {
      signed int TMP = pos;
      pos = neg;
      neg = TMP;
    }
    while((_Bool)0);
    cond = -cond;
  }

  cond=lglcgreprnotconst(lgl, cond);
  pos=lglcgreprnotconst(lgl, pos);
  neg=lglcgreprnotconst(lgl, neg);
  signed int return_value_lglhasitegate_5;
  return_value_lglhasitegate_5=lglhasitegate(lgl, lhs, cond, pos, neg);
  if(return_value_lglhasitegate_5 == 0)
  {
    g=lglnewgate(lgl, (enum GTag)ITETAG, lhs, 2);
    gidx=lglgat2idx(lgl, g);
    g->_anon0._anon1.cond = cond;
    g->_anon0._anon1.pos = pos;
    g->_anon0._anon1.neg = neg;
    lglpushgocc(lgl, cond, gidx);
    lglpushgocc(lgl, pos, gidx);
    lglpushgocc(lgl, neg, gidx);

  __CPROVER_DUMP_L9:
    ;
    lgl->stats->cgr.extracted.ite = lgl->stats->cgr.extracted.ite + 1l;
    lgl->_anon0.cgr->extracted.ite = lgl->_anon0.cgr->extracted.ite + 1;
  }

}

// lglnewlgl
// file lglib.c line 1669
static struct LGL * lglnewlgl(void *mem, void * (*alloc)(void *, unsigned long int), void * (*realloc)(void *, void *, unsigned long int, unsigned long int), void (*dealloc)(void *, void *, unsigned long int))
{
  struct LGL *lgl;
  void *tmp_if_expr_2;
  void *return_value;
  void *return_value_malloc_1;
  if(!(alloc == ((void * (*)(void *, unsigned long int))NULL)))
  {
    return_value=alloc(mem, sizeof(struct LGL) /*816ul*/ );
    tmp_if_expr_2 = return_value;
  }

  else
  {
    return_value_malloc_1=malloc(sizeof(struct LGL) /*816ul*/ );
    tmp_if_expr_2 = return_value_malloc_1;
  }
  lgl = (struct LGL *)tmp_if_expr_2;
  while(lgl == ((struct LGL *)NULL))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglnewlgl");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "out of memory allocating main solver object");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  do
    memset((void *)lgl, 0, sizeof(struct LGL) /*816ul*/ );
  while((_Bool)0);
  void *tmp_if_expr_4;
  void *return_value_1;
  void *return_value_malloc_3;
  if(!(alloc == ((void * (*)(void *, unsigned long int))NULL)))
  {
    return_value_1=alloc(mem, sizeof(struct Mem) /*32ul*/ );
    tmp_if_expr_4 = return_value_1;
  }

  else
  {
    return_value_malloc_3=malloc(sizeof(struct Mem) /*32ul*/ );
    tmp_if_expr_4 = return_value_malloc_3;
  }
  lgl->mem = (struct Mem *)tmp_if_expr_4;
  while(lgl->mem == ((struct Mem *)NULL))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglnewlgl");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "out of memory allocating memory manager object");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lgl->mem->state = mem;
  lgl->mem->alloc = alloc;
  lgl->mem->realloc = realloc;
  lgl->mem->dealloc = dealloc;
  void *tmp_if_expr_6;
  void *return_value_2;
  void *return_value_malloc_5;
  if(!(alloc == ((void * (*)(void *, unsigned long int))NULL)))
  {
    return_value_2=alloc(mem, sizeof(struct Opts) /*5680ul*/ );
    tmp_if_expr_6 = return_value_2;
  }

  else
  {
    return_value_malloc_5=malloc(sizeof(struct Opts) /*5680ul*/ );
    tmp_if_expr_6 = return_value_malloc_5;
  }
  lgl->opts = (struct Opts *)tmp_if_expr_6;
  while(lgl->opts == ((struct Opts *)NULL))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglnewlgl");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "out of memory allocating option manager object");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  do
    memset((void *)lgl->opts, 0, sizeof(struct Opts) /*5680ul*/ );
  while((_Bool)0);
  void *tmp_if_expr_8;
  void *return_value_3;
  void *return_value_malloc_7;
  if(!(alloc == ((void * (*)(void *, unsigned long int))NULL)))
  {
    return_value_3=alloc(mem, sizeof(struct Stats) /*2272ul*/ );
    tmp_if_expr_8 = return_value_3;
  }

  else
  {
    return_value_malloc_7=malloc(sizeof(struct Stats) /*2272ul*/ );
    tmp_if_expr_8 = return_value_malloc_7;
  }
  lgl->stats = (struct Stats *)tmp_if_expr_8;
  while(lgl->stats == ((struct Stats *)NULL))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglnewlgl");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "out of memory allocating statistic counters");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  do
    memset((void *)lgl->stats, 0, sizeof(struct Stats) /*2272ul*/ );
  while((_Bool)0);
  lglinc(lgl, sizeof(struct LGL) /*816ul*/ );
  lglinc(lgl, sizeof(struct Mem) /*32ul*/ );
  lglinc(lgl, sizeof(struct Opts) /*5680ul*/ );
  lglinc(lgl, sizeof(struct Stats) /*2272ul*/ );
  return lgl;
}

// lglnewlrgate
// file lglib.c line 12478
static void lglnewlrgate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int *cls, signed int size)
{
  signed int gidx;
  signed int other;
  signed int lhsrepr;
  const signed int *p;
  struct Gat *g;
  lhsrepr=lglcgreprnotconst(lgl, lhs);
  g=lglnewgate(lgl, tag, lhsrepr, size);
  g->_anon0._anon0.origlhs = lhs;
  gidx=lglgat2idx(lgl, g);
  g->_anon0._anon0.cls = cls;
  p = cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    signed int return_value_abs_1;
    return_value_abs_1=abs(other);
    if(!(return_value_abs_1 == lhs))
    {
      other=lglcgreprnotconst(lgl, other);
      lglpushgocc(lgl, other, gidx);
    }

    p = p + 1l;
  }
  while((_Bool)1);
  if((signed int)tag == ANDTAG)
  {
    lgl->_anon0.cgr->extracted.and = lgl->_anon0.cgr->extracted.and + 1;
    lgl->stats->cgr.extracted.and = lgl->stats->cgr.extracted.and + 1l;
  }

  if((signed int)tag == XORTAG)
  {
    lgl->_anon0.cgr->extracted.xor = lgl->_anon0.cgr->extracted.xor + 1;
    lgl->stats->cgr.extracted.xor = lgl->stats->cgr.extracted.xor + 1l;
  }

}

// lglnewvar
// file lglib.c line 2435
static signed int lglnewvar(struct LGL *lgl)
{
  struct AVar *av;
  struct DVar *dv;
  signed int res;
  if(lgl->nvars == lgl->szvars)
    lglenlvars(lgl);

  signed int tmp_post_1;
  if(!(lgl->nvars == 0))
  {
    tmp_post_1 = lgl->nvars;
    lgl->nvars = lgl->nvars + 1;
    res = tmp_post_1;
  }

  else
  {
    res = 2;
    lgl->nvars = 3;
  }
  if(res >= 134217726)
    lgldie(lgl, "more than %d variables", ((0x7fffffff >> RMSHFT) - 2) - 1);


__CPROVER_DUMP_L4:
  ;
  dv = lgl->dvars + (signed long int)res;
  do
    memset((void *)dv, 0, sizeof(struct DVar) /*16ul*/ );
  while((_Bool)0);
  av = lgl->avars + (signed long int)res;
  do
    memset((void *)av, 0, sizeof(struct AVar) /*12ul*/ );
  while((_Bool)0);
  lglqsched(lgl, res);
  lgl->unassigned = lgl->unassigned + 1;
  lgl->allphaseset = (char)0;
  return res;
}

// lglnextdecision
// file lglib.c line 6295
static signed int lglnextdecision(struct LGL *lgl)
{
  signed int res = 0;
  struct Qln *line;
  _Bool tmp_if_expr_2;
  signed char return_value_lglval_1;
  if(lgl->unassigned == 0)
    return 0;

  else
  {
    lglstart(lgl, &lgl->times->dec);
    line = lgl->queue.unassigned;
    lglchkqueue(lgl);
    do
    {
      struct Qnd *n;
      res = line->unassigned;
      do
      {
        if(!(res == 0))
        {
          return_value_lglval_1=lglval(lgl, res);
          tmp_if_expr_2 = return_value_lglval_1 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_2 = (_Bool)0;
        if(!tmp_if_expr_2)
          break;

        n=lglqnd(lgl, res);
        res = n->next;
      }
      while((_Bool)1);
      line->unassigned = res;
      if(!(line->unassigned == 0))
        break;

      lgl->queue.unassigned = line->down;
      line = lgl->queue.unassigned;
    }
    while((_Bool)1);

  __CPROVER_DUMP_L7:
    ;
    lglstop(lgl);
    return res;
  }
}

// lglnextopt
// file lglib.c line 2144
void * lglnextopt(struct LGL *lgl, void *current, const char **nameptr, signed int *valptr, signed int *minptr, signed int *maxptr)
{
  struct Opt *opt = (struct Opt *)current;
  struct Opt *res = opt + (signed long int)1;
  if(!(&lgl->opts->afterlast + -1l >= res))
    return NULL;

  else
  {
    if(!(nameptr == ((const char **)NULL)))
      *nameptr = opt->lng;

    if(!(valptr == ((signed int *)NULL)))
      *valptr = opt->val;

    if(!(minptr == ((signed int *)NULL)))
      *minptr = opt->min;

    if(!(maxptr == ((signed int *)NULL)))
      *maxptr = opt->max;

    return (void *)res;
  }
}

// lglnvars
// file lglib.c line 12317
signed int lglnvars(struct LGL *lgl)
{
  signed int return_value_lglrem_1;
  return_value_lglrem_1=lglrem(lgl);
  return return_value_lglrem_1;
}

// lglobalftlim
// file lglib.c line 13929
static signed long int lglobalftlim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->lftreleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->lftmineff.val))
    limit = (signed long int)lgl->opts->lftmineff.val;

  if(lgl->opts->lftmaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->lftmaxeff.val >= limit))
      limit = (signed long int)lgl->opts->lftmaxeff.val;

  }

  signed int return_value_lglszpen_1;
  return_value_lglszpen_1=lglszpen(lgl);
  pen = lgl->limits->lft.pen + return_value_lglszpen_1;
  limit = limit >> pen;
  irrlim = (signed long int)(lgl->stats->irr.lits.cur / 4);
  irrlim = irrlim >> lgl->limits->simp.pen;
  signed int return_value_lglszpen_2;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    lglprt(lgl, 1, "[lift-%d] limit %lld based on %d irredundant literals", lgl->stats->lift.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    return_value_lglszpen_2=lglszpen(lgl);
    lglprt(lgl, 1, "[lift-%d] limit %lld with penalty %d = %d + %d", lgl->stats->lift.count, (signed long long int)limit, pen, lgl->limits->lft.pen, return_value_lglszpen_2);
  }
  return limit;
}

// lglocc
// file lglib.c line 3368
static signed int lglocc(struct LGL *lgl, signed int lit)
{
  struct EVar *return_value_lglevar_1;
  return_value_lglevar_1=lglevar(lgl, lit);
  return return_value_lglevar_1->occ[(signed long int)(lit < 0)];
}

// lglonabort
// file lglib.c line 1316
void lglonabort(struct LGL *lgl, void *abortstate, void (*onabort)(void *))
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglonabort");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->abortstate = abortstate;
  lgl->cbs->onabort = onabort;
}

// lglonflict
// file lglib.c line 4035
static void lglonflict(struct LGL *lgl, signed int check, signed int lit, signed int red, signed int lidx)
{
  signed int glue;
  lgl->conf.lit = lit;
  lgl->conf.rsn[(signed long int)0] = red | LRGCS;
  lgl->conf.rsn[(signed long int)1] = lidx;
  if(!(red == 0))
  {
    glue = lidx & (1 << 4) - 1;
    lgl->stats->lir[(signed long int)glue].conflicts = lgl->stats->lir[(signed long int)glue].conflicts + 1l;
  }

}

// lglookahead
// file lglib.c line 17832
signed int lglookahead(struct LGL *lgl)
{
  signed int ilit;
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglookahead");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "lkhd");
    break;
  }
  do
  {
    signed int return_value_lglmtstk_1;
    return_value_lglmtstk_1=lglmtstk(&lgl->eassume);
    if(!(return_value_lglmtstk_1 == 0))
      break;

    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglookahead");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "imcompatible with 'lglassume'");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
  }
  while((_Bool)0);
  do
  {
    signed int return_value_lglmtstk_2;
    return_value_lglmtstk_2=lglmtstk(&lgl->clause);
    if(!(return_value_lglmtstk_2 == 0))
      break;

    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglookahead");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "clause terminating zero missing");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
  }
  while((_Bool)0);
  lglstart(lgl, &lgl->times->all);
  lglstart(lgl, &lgl->times->lkhd);
  lglreset(lgl);
  lgl->lkhd = (char)1;
  if(!(lgl->level == 0))
    lglbacktrack(lgl, 0);

  _Bool tmp_if_expr_8;
  signed int return_value_lglbcp_7;
  if(lgl->mt == 0)
  {
    return_value_lglbcp_7=lglbcp(lgl);
    tmp_if_expr_8 = return_value_lglbcp_7 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_8 = (_Bool)0;
  _Bool tmp_if_expr_4;
  signed int return_value_lglsmallirr_3;
  signed int tmp_if_expr_6;
  signed int return_value_lglexport_5;
  if(tmp_if_expr_8)
  {
    ilit = 0;
    if(lgl->opts->lkhd.val == 2)
    {
      return_value_lglsmallirr_3=lglsmallirr(lgl);
      tmp_if_expr_4 = !(return_value_lglsmallirr_3 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      ilit=lgljwhlook(lgl);

    else
    {
      if(!(lgl->opts->lkhd.val == 0))
      {
        if(lgl->opts->lkhd.val == 1)
          goto __CPROVER_DUMP_L17;

      }

      else
      {
        ilit=lglislook(lgl);
        goto __CPROVER_DUMP_L18;
      }

    __CPROVER_DUMP_L17:
      ;
      ilit=lgljwhlook(lgl);
    }

  __CPROVER_DUMP_L18:
    ;
    if(lgl->mt == 0 && !(ilit == 0))
    {
      return_value_lglexport_5=lglexport(lgl, ilit);
      tmp_if_expr_6 = return_value_lglexport_5;
    }

    else
      tmp_if_expr_6 = 0;
    res = tmp_if_expr_6;
  }

  else
  {
    lgl->mt = 1;
    res = 0;
  }
  lgl->lkhd = (char)0;
  lglstop(lgl);
  lglstop(lgl);

__CPROVER_DUMP_L23:
  ;
  do
    lgl->state = (enum State)LOOKED;
  while((_Bool)0);

__CPROVER_DUMP_L24:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglookahead(lgl->clone);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglookahead");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone) = %d differs from %s (lgl) = %d", (const void *)"lglookahead", CLONERES, (const void *)"lglookahead", res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lgloop
// file lglib.c line 17233
static signed int lgloop(struct LGL *lgl, struct Lim *lim)
{
  _Bool tmp_if_expr_10;
  signed int return_value_lglinprocessing_9;
  signed int return_value_lglana_7;
  do
  {
    signed int return_value_lglbcpsearch_8;
    return_value_lglbcpsearch_8=lglbcpsearch(lgl);
    if(!(return_value_lglbcpsearch_8 == 0))
    {
      return_value_lglinprocessing_9=lglinprocessing(lgl);
      tmp_if_expr_10 = return_value_lglinprocessing_9 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_10 = (_Bool)0;
    if(tmp_if_expr_10)
    {
      signed int return_value_lglterminate_1;
      return_value_lglterminate_1=lglterminate(lgl);
      if(!(return_value_lglterminate_1 == 0))
        return 0;

      signed int return_value_lglsyncunits_2;
      return_value_lglsyncunits_2=lglsyncunits(lgl);
      if(return_value_lglsyncunits_2 == 0)
        return 20;

      signed int return_value_lglfailedass_3;
      return_value_lglfailedass_3=lglfailedass(lgl);
      if(!(return_value_lglfailedass_3 == 0))
        return 20;

      lglregularly(lgl);
      signed int return_value_lglimhit_4;
      return_value_lglimhit_4=lglimhit(lgl, lim);
      if(!(return_value_lglimhit_4 == 0))
        return 0;

      signed int return_value_lglrestarting_5;
      return_value_lglrestarting_5=lglrestarting(lgl);
      if(!(return_value_lglrestarting_5 == 0))
      {
        lglrestart(lgl);
        continue;
      }

      signed int return_value_lgldecide_6;
      return_value_lgldecide_6=lgldecide(lgl);
      if(return_value_lgldecide_6 == 0)
        return 10;

    }

    else
    {
      return_value_lglana_7=lglana(lgl);
      if(return_value_lglana_7 == 0)
        return 20;

    }
  }
  while((_Bool)1);
}

// lglopenapitrace
// file lglib.c line 1485
static void lglopenapitrace(struct LGL *lgl, const char *name)
{
  struct _IO_FILE *file;
  char *cmd;
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  len = (signed int)return_value_strlen_1;
  _Bool tmp_if_expr_5;
  signed int tmp_statement_expression_3;
  if(len >= 3)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_4;
    return_value___builtin_strcmp_4=__builtin_strcmp((name + (signed long int)len) - (signed long int)3, ".gz");
    tmp_statement_expression_3 = return_value___builtin_strcmp_4;
    tmp_if_expr_5 = !(tmp_statement_expression_3 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_5 = (_Bool)0;
  if(tmp_if_expr_5)
  {
    len = len + 20;
    do
    {
      void *return_value_lglnew_2;
      return_value_lglnew_2=lglnew(lgl, (unsigned long int)len * sizeof(char) /*1ul*/ );
      cmd = (char *)return_value_lglnew_2;
    }
    while((_Bool)0);
    sprintf(cmd, "gzip -c > %s", name);
    file=popen(cmd, "w");
    do
    {
      lgldel(lgl, (void *)cmd, (unsigned long int)len * sizeof(char) /*1ul*/ );
      cmd = ((char *)NULL);
    }
    while((_Bool)0);
    if(!(file == ((struct _IO_FILE *)NULL)))
      lgl->closeapitrace = (char)2;

  }

  else
  {
    file=fopen(name, "w");
    if(!(file == ((struct _IO_FILE *)NULL)))
      lgl->closeapitrace = (char)1;

  }
  if(!(file == ((struct _IO_FILE *)NULL)))
    lgl->apitrace = file;

  else
    lglwrn(lgl, "can not write API trace to '%s'", name);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "init");
    break;
  }
}

// lglopts
// file lglib.c line 2111
void lglopts(struct LGL *lgl, const char *prefix, signed int ignsome)
{
  struct Opt *o;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglopts");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  o = &lgl->opts->beforefirst + (signed long int)1;
  signed int tmp_statement_expression_1;
  signed int tmp_statement_expression_3;
  signed int tmp_statement_expression_5;
  signed int tmp_statement_expression_7;
  for( ; &lgl->opts->afterlast + -1l >= o; o = o + 1l)
  {
    if(!(ignsome == 0))
    {
      unsigned long int __s1_len;
      unsigned long int lglopts__1__2__1__1__1____s2_len;
      signed int return_value___builtin_strcmp_2;
      return_value___builtin_strcmp_2=__builtin_strcmp(o->lng, "check");
      tmp_statement_expression_1 = return_value___builtin_strcmp_2;
      if(tmp_statement_expression_1 == 0)
        goto __CPROVER_DUMP_L6;

      unsigned long int lglopts__1__2__1__1__2____s1_len;
      unsigned long int lglopts__1__2__1__1__2____s2_len;
      signed int return_value___builtin_strcmp_4;
      return_value___builtin_strcmp_4=__builtin_strcmp(o->lng, "log");
      tmp_statement_expression_3 = return_value___builtin_strcmp_4;
      if(tmp_statement_expression_3 == 0)
        goto __CPROVER_DUMP_L6;

      unsigned long int lglopts__1__2__1__1__3____s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_6;
      return_value___builtin_strcmp_6=__builtin_strcmp(o->lng, "verbose");
      tmp_statement_expression_5 = return_value___builtin_strcmp_6;
      if(tmp_statement_expression_5 == 0)
        goto __CPROVER_DUMP_L6;

      unsigned long int lglopts__1__2__1__1__4____s1_len;
      unsigned long int lglopts__1__2__1__1__4____s2_len;
      signed int return_value___builtin_strcmp_8;
      return_value___builtin_strcmp_8=__builtin_strcmp(o->lng, "witness");
      tmp_statement_expression_7 = return_value___builtin_strcmp_8;
      if(tmp_statement_expression_7 == 0)
        goto __CPROVER_DUMP_L6;

    }

    fprintf(lgl->out, "%s--%s=%d\n", prefix, o->lng, o->val);

  __CPROVER_DUMP_L6:
    ;
  }
}

// lglor3fun
// file lglib.c line 10551
static void lglor3fun(unsigned long int *a, unsigned long int *b, unsigned long int *c)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = b[(signed long int)i] | c[(signed long int)i];
}

// lglor3negfun
// file lglib.c line 10557
static void lglor3negfun(unsigned long int *a, unsigned long int *b, unsigned long int *c)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = b[(signed long int)i] | ~c[(signed long int)i];
}

// lglordercls
// file lglib.c line 3007
static void lglordercls(struct LGL *lgl)
{
  lglorderclsaux(lgl, lgl->clause.start);

__CPROVER_DUMP_L1:
  ;
  lglorderclsaux(lgl, lgl->clause.start + (signed long int)1);

__CPROVER_DUMP_L2:
  ;

__CPROVER_DUMP_L3:
  ;
}

// lglorderclsaux
// file lglib.c line 2995
static void lglorderclsaux(struct LGL *lgl, signed int *start)
{
  signed int *p;
  signed int max = 0;
  signed int level;
  signed int lit;
  p = start;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    signed char return_value_lglval_1;
    return_value_lglval_1=lglval(lgl, lit);
    if(!(return_value_lglval_1 == 0))
    {
      level=lglevel(lgl, lit);
      if(!(max >= level))
      {
        max = level;
        *p = start[(signed long int)0];
        start[(signed long int)0] = lit;
      }

    }

    p = p + 1l;
  }
  while((_Bool)1);
}

// lglorfun
// file lglib.c line 10539
static void lglorfun(unsigned long int *a, unsigned long int *b)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = a[(signed long int)i] | b[(signed long int)i];
}

// lglornegfun
// file lglib.c line 10545
static void lglornegfun(unsigned long int *a, unsigned long int *b)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = a[(signed long int)i] | ~b[(signed long int)i];
}

// lglpar64
// file lglib.c line 16222
static signed int lglpar64(unsigned long int i)
{
  unsigned int x;
  signed int res = 0;
  x = (unsigned int)i;
  for( ; !(x == 0u); x = x & x - (unsigned int)1)
    res = (signed int)!(res != 0);
  return res;
}

// lglparity
// file lglib.c line 12701
static signed int lglparity(struct LGL *lgl)
{
  const signed int *p;
  signed int res = 0;
  p = lgl->clause.start;
  for( ; !(p >= lgl->clause.top); p = p + 1l)
    if(!(*p >= 0))
      res = (signed int)!(res != 0);

  return res;
}

// lglpcnt
// file lglib.c line 3357
static double lglpcnt(double n, double d)
{
  if(d <= 0.000000 || !IEEE_FLOAT_NOTEQUAL(n, 0.000000))
    return 0.0;

  else
    return (100.0 * n) / d;
}

// lglpeek
// file lglib.c line 1391
static signed int lglpeek(struct Stk *s, signed int pos)
{
  return s->start[(signed long int)pos];
}

// lglphase
// file lglib.c line 6846
static void lglphase(struct LGL *lgl)
{
  signed long int set = lgl->stats->phase.set;
  signed long int pos = lgl->stats->phase.pos;
  signed long int neg = lgl->stats->phase.neg;
  signed int idx;
  lglstart(lgl, &lgl->times->phs);
  if(!(lgl->flushphases == 0))
    lglflushphases(lgl);

  double return_value_lglpcnt_1;
  double return_value_lglpcnt_2;
  if(lgl->opts->phase.val == 0)
  {
    lglsetallphases(lgl);
    if(lgl->allphaseset == 0)
    {
      lgl->stats->phase.count = lgl->stats->phase.count + 1;
      lgljwh(lgl);
      idx = 2;
      for( ; !(idx >= lgl->nvars); idx = idx + 1)
        lglsetjwhbias(lgl, idx);
      set = lgl->stats->phase.set - set;
      pos = lgl->stats->phase.pos - pos;
      neg = lgl->stats->phase.neg - neg;
      return_value_lglpcnt_1=lglpcnt((double)pos, (double)set);
      return_value_lglpcnt_2=lglpcnt((double)neg, (double)set);
      lglprt(lgl, 1, "[phase-%d] phase bias: %lld positive %.0f%%, %lld negative %.0f%%", lgl->stats->phase.count, (signed long long int)pos, return_value_lglpcnt_1, (signed long long int)neg, return_value_lglpcnt_2);
    }

  }


DONE:
  ;
  lglstop(lgl);
}

// lglpicosatchkall
// file lglib.c line 7337
static void lglpicosatchkall(struct LGL *lgl)
{
  ;
}

// lglpicosatrestart
// file lglib.c line 7356
static void lglpicosatrestart(struct LGL *lgl)
{
  ;
}

// lglpoison
// file lglib.c line 4841
static signed int lglpoison(struct LGL *lgl, signed int lit, struct Stk *stk)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int level;
  signed int res;
  signed int return_value_lglevelused_1;
  if(!(av->mark == 0))
    res = 0;

  else
  {
    level=lglevel(lgl, lit);
    if(level == 0)
      res = 0;

    else
    {
      signed int return_value_lgldecision_2;
      return_value_lgldecision_2=lgldecision(lgl, lit);
      if(!(return_value_lgldecision_2 == 0))
        res = 1;

      else
      {
        return_value_lglevelused_1=lglevelused(lgl, level);
        if(return_value_lglevelused_1 == 0)
          res = 1;

        else
        {
          lgl->stats->poison.search = lgl->stats->poison.search + 1l;
          if(!(av->poisoned == 0u))
          {
            lgl->stats->poison.hits = lgl->stats->poison.hits + 1l;
            res = 1;
          }

          else
          {
            av->mark = 1;
            lglpushstk(lgl, &lgl->seen, lit);
            lglpushstk(lgl, stk, lit);
            res = 0;
          }
        }
      }
    }
  }
  if(!(res == 0))
  {
    if(av->poisoned == 0u)
    {
      av->poisoned = (unsigned int)1;
      lglpushstk(lgl, &lgl->poisoned, lit);
    }

  }

  return res;
}

// lglpoke
// file lglib.c line 1396
static void lglpoke(struct Stk *s, signed int pos, signed int val)
{
  s->start[(signed long int)pos] = val;
}

// lglpopcontrol
// file lglib.c line 1569
static void lglpopcontrol(struct LGL *lgl)
{
  lgl->control.top = lgl->control.top - 1l;
}

// lglpopesched
// file lglib.c line 5628
static signed int lglpopesched(struct LGL *lgl)
{
  struct Stk *s = &lgl->esched;
  signed int res;
  signed int last;
  signed int cnt;
  signed int *p;
  struct EVar *ev;
  res = *s->start;

__CPROVER_DUMP_L1:
  ;
  ev=lglevar(lgl, res);
  ev->pos = -1;
  last=lglpopstk(s);
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(s);
  cnt = (signed int)return_value_lglcntstk_1;
  if(cnt == 0)
    return res;

  else
  {
    p=lglepos(lgl, last);
    *p = 0;
    *s->start = last;
    lgledown(lgl, last);
    return res;
  }
}

// lglpopnunlcamarkstk
// file lglib.c line 4132
static void lglpopnunlcamarkstk(struct LGL *lgl, struct Stk *stk)
{
  signed int return_value_lglmtstk_1;
  signed int return_value_lglpopstk_2;
  struct AVar *return_value_lglavar_3;
  do
  {
    return_value_lglmtstk_1=lglmtstk(stk);
    if(!(return_value_lglmtstk_1 == 0))
      break;

    return_value_lglpopstk_2=lglpopstk(stk);
    return_value_lglavar_3=lglavar(lgl, return_value_lglpopstk_2);
    return_value_lglavar_3->lcamark = (unsigned int)0;
  }
  while((_Bool)1);
}

// lglpopnunmarkstk
// file lglib.c line 4127
static void lglpopnunmarkstk(struct LGL *lgl, struct Stk *stk)
{
  signed int return_value_lglmtstk_1;
  signed int return_value_lglpopstk_2;
  struct AVar *return_value_lglavar_3;
  do
  {
    return_value_lglmtstk_1=lglmtstk(stk);
    if(!(return_value_lglmtstk_1 == 0))
      break;

    return_value_lglpopstk_2=lglpopstk(stk);
    return_value_lglavar_3=lglavar(lgl, return_value_lglpopstk_2);
    return_value_lglavar_3->mark = 0;
  }
  while((_Bool)1);
}

// lglpopstk
// file lglib.c line 1447
static signed int lglpopstk(struct Stk *s)
{
  s->top = s->top - 1l;
  return *s->top;
}

// lglpos2cnf
// file lglib.c line 10729
static signed long int lglpos2cnf(signed int pos)
{
  return (signed long int)pos;
}

// lglposcofactorfun
// file lglib.c line 10760
static void lglposcofactorfun(unsigned long int *f, signed int v, unsigned long int *res)
{
  unsigned long int mask[64l];
  unsigned long int masked[64l];
  lglvar2fun(v, mask);
  lgland3fun(masked, f, mask);
  lglfuncpy(res, masked);
  lglsrfun(masked, 1 << v);
  lglorfun(res, masked);
}

// lglprbana
// file lglib.c line 8406
static signed int lglprbana(struct LGL *lgl, signed int probe)
{
  signed int open;
  signed int lit;
  signed int r0;
  signed int r1;
  signed int tag;
  signed int red;
  signed int other;
  signed int res;
  signed int *p;
  signed int *rsn;
  lit = lgl->conf.lit;
  r0 = lgl->conf.rsn[(signed long int)0];
  r1 = lgl->conf.rsn[(signed long int)1];
  open=lglprbpull(lgl, lit, probe);

__CPROVER_DUMP_L1:
  ;
  signed int return_value_lglprbpull_2;
  signed int *tmp_post_3;
  signed int return_value_lglprbpull_4;
  signed int return_value_lglmarked_5;
  do
  {
    tag = r0 & MASKCS;
    if(tag == BINCS || tag == TRNCS)
    {
      other = r0 >> RMSHFT;
      signed int return_value_lglprbpull_1;
      return_value_lglprbpull_1=lglprbpull(lgl, other, probe);
      if(!(return_value_lglprbpull_1 == 0))
        open = open + 1;

      if(tag == TRNCS)
      {
        return_value_lglprbpull_2=lglprbpull(lgl, r1, probe);
        if(!(return_value_lglprbpull_2 == 0))
          open = open + 1;

      }

    }

    else
    {
      red = r0 & REDCS;
      p=lglidx2lits(lgl, LRGCS, red, r1);
      do
      {
        tmp_post_3 = p;
        p = p + 1l;
        other = *tmp_post_3;
        if(other == 0)
          break;

        return_value_lglprbpull_4=lglprbpull(lgl, other, probe);
        open = open + return_value_lglprbpull_4;
      }
      while((_Bool)1);
    }

  __CPROVER_DUMP_L8:
    ;
    do
    {
      lit=lglpopstk(&lgl->trail);
      return_value_lglmarked_5=lglmarked(lgl, lit);
      if(!(return_value_lglmarked_5 == 0))
        break;

      lglunassign(lgl, lit);
    }
    while((_Bool)1);
    lglunassign(lgl, lit);
    open = open - 1;
    if(open == 0)
    {
      res = lit;
      break;
    }


  __CPROVER_DUMP_L11:
    ;
    rsn=lglrsn(lgl, lit);
    r0 = rsn[(signed long int)0];
    r1 = rsn[(signed long int)1];
  }
  while((_Bool)1);
  if(res == probe)

    __CPROVER_DUMP_L13:
      ;

  else

    __CPROVER_DUMP_L14:
      ;
  lglpopnunmarkstk(lgl, &lgl->seen);
  return res;
}

// lglprbpull
// file lglib.c line 8393
static signed int lglprbpull(struct LGL *lgl, signed int lit, signed int probe)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  if(!(av->mark == 0))
    return 0;

  else
  {
    signed int return_value_lglevel_1;
    return_value_lglevel_1=lglevel(lgl, lit);
    if(return_value_lglevel_1 == 0)
      return 0;

    else
    {
      av->mark = 1;
      lglpushstk(lgl, &lgl->seen, -lit);

    __CPROVER_DUMP_L3:
      ;
      return 1;
    }
  }
}

// lglprefix
// file lglib.c line 1186
static const char * lglprefix(struct LGL *lgl)
{
  _Bool tmp_if_expr_1;
  if(!(lgl == ((struct LGL *)NULL)))
    tmp_if_expr_1 = lgl->prefix != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  char *tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = lgl->prefix;

  else
    tmp_if_expr_2 = "c (LGL HAS NO PREFIX YET) ";
  return tmp_if_expr_2;
}

// lglpreprocessing
// file lglib.c line 17151
static signed int lglpreprocessing(struct LGL *lgl, signed int forced)
{
  signed int res = (signed int)!(lgl->mt != 0);
  signed int oldrem;
  signed int pcntremoved;
  _Bool tmp_if_expr_1;
  if(!(forced == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(lgl->stats->simp.count != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    lgl->stats->simp.count = lgl->stats->simp.count + 1;
    oldrem=lglrem(lgl);
    res=lglisimp(lgl);
    pcntremoved=lglsimpcntrem(lgl, oldrem);
    lglupdprepint(lgl, forced != 0 ? 0x7fffffff : pcntremoved);
  }

  return res;
}

// lglprint
// file lglib.c line 18806
void lglprint(struct LGL *lgl, struct _IO_FILE *file)
{
  signed int count = 0;
  lglctrav(lgl, (void *)&count, lgltravcounter);
  signed int return_value_lglmaxvar_1;
  return_value_lglmaxvar_1=lglmaxvar(lgl);
  fprintf(file, "p cnf %d %d\n", return_value_lglmaxvar_1, count);
  lglctrav(lgl, (void *)file, lgltravprinter);
}

// lglprintfeatures
// file lglib.c line 18556
void lglprintfeatures(struct LGL *lgl)
{
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"vars", lgl->stats->features.vars);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"lits.total", lgl->stats->features.lits.total);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"lits.pos", lgl->stats->features.lits.pos);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"lits.neg", lgl->stats->features.lits.neg);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"clauses.total", lgl->stats->features.clauses.total);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"clauses.unit", lgl->stats->features.clauses.unit);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"clauses.bin", lgl->stats->features.clauses.bin);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"clauses.trn", lgl->stats->features.clauses.trn);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"clauses.lrg", lgl->stats->features.clauses.lrg);
  while((_Bool)0);
  lglcomputecog(lgl);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"cog.val.min", lgl->stats->features.cog.val.min);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"cog.val.avg", lgl->stats->features.cog.val.avg);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"cog.val.max", lgl->stats->features.cog.val.max);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"cog.var.min", lgl->stats->features.cog.var.min);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"cog.var.avg", lgl->stats->features.cog.var.avg);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"cog.var.max", lgl->stats->features.cog.var.max);
  while((_Bool)0);
}

// lglprobe
// file lglib.c line 9113
static signed int lglprobe(struct LGL *lgl)
{
  signed int res = 1;
  lglstart(lgl, &lgl->times->prb.all);
  res=lglbasicprobe(lgl);
  lglstop(lgl);
  return res;
}

// lglprobing
// file lglib.c line 16864
static signed int lglprobing(struct LGL *lgl)
{
  if(lgl->opts->probe.val == 0)
    return 0;

  else
    if(!(lgl->opts->prbasic.val == 0))
      return 1;

    else
    {
      signed int return_value_lglsmallirr_1;
      return_value_lglsmallirr_1=lglsmallirr(lgl);
      if(return_value_lglsmallirr_1 == 0)
        return 0;

      else
        return 0;
    }
}

// lglprocesstime
// file lglib.h line 290
double lglprocesstime(void)
{
  struct rusage u;
  double res;
  signed int return_value_getrusage_1;
  return_value_getrusage_1=getrusage(0, &u);
  if(!(return_value_getrusage_1 == 0))
    return (double)0;

  else
  {
    res = (double)u.ru_utime.tv_sec + 1e-6 * (double)u.ru_utime.tv_usec;
    res = res + (double)u.ru_stime.tv_sec + 1e-6 * (double)u.ru_stime.tv_usec;
    return res;
  }
}

// lglprop
// file lglib.c line 4420
static void lglprop(struct LGL *lgl, signed int lit)
{
  signed int *p;
  signed int *q;
  signed int *eos;
  signed int blit;
  signed int other;
  signed int other2;
  signed int other3;
  signed int red;
  signed int prev;
  signed int tag;
  signed int val;
  signed int val2;
  signed int lidx;
  signed int *c;
  signed int *l;
  signed int dom;
  signed int hbred;
  signed int subsumed;
  signed int glue;
  signed int flushoccs;
  signed long int delta;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  hts=lglhts(lgl, -lit);
  signed int *tmp_post_1;
  signed int *tmp_post_3;
  signed int return_value_lgliselim_4;
  signed int *tmp_post_5;
  signed int *tmp_post_6;
  signed int return_value_lgliselim_7;
  signed int return_value_lgliselim_9;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_15;
  signed int return_value_lgliselim_17;
  signed int return_value_lgliselim_19;
  _Bool tmp_if_expr_27;
  _Bool tmp_if_expr_28;
  _Bool tmp_if_expr_29;
  _Bool tmp_if_expr_23;
  signed int *tmp_post_24;
  signed int *tmp_post_30;
  signed int *tmp_post_31;
  signed int *tmp_post_32;
  signed int *tmp_post_33;
  if(!(hts->offset == 0))
  {
    flushoccs = 0;
    q=lglhts2wchs(lgl, hts);
    eos = q + (signed long int)hts->count;
    p = q;
    for( ; !(p >= eos); p = p + 1l)
    {
      blit = *p;
      tag = blit & MASKCS;
      red = blit & REDCS;
      if(tag == OCCS)
      {
        tmp_post_1 = q;
        q = q + 1l;
        *tmp_post_1 = blit;
      }

      else
      {
        other = blit >> RMSHFT;
        signed char return_value_lglval_2;
        return_value_lglval_2=lglval(lgl, other);
        val = (signed int)return_value_lglval_2;
        if(tag == BINCS)
        {
          tmp_post_3 = q;
          q = q + 1l;
          *tmp_post_3 = blit;
          if(val >= 1)
            goto __CPROVER_DUMP_L97;

          if(!(red == 0))
          {
            return_value_lgliselim_4=lgliselim(lgl, other);
            if(!(return_value_lgliselim_4 == 0))
              goto __CPROVER_DUMP_L97;

          }

          if(!(val >= 0))
          {
            lglbonflict(lgl, -lit, blit);
            p = p + 1l;
            break;
          }

          lglf2rce(lgl, other, -lit, red);
        }

        else
          if(tag == TRNCS)
          {
            tmp_post_5 = q;
            q = q + 1l;
            *tmp_post_5 = blit;
            p = p + 1l;
            other2 = *p;
            tmp_post_6 = q;
            q = q + 1l;
            *tmp_post_6 = other2;
            if(val >= 1)
              goto __CPROVER_DUMP_L97;

            if(!(red == 0))
            {
              return_value_lgliselim_7=lgliselim(lgl, other);
              if(!(return_value_lgliselim_7 == 0))
                goto __CPROVER_DUMP_L97;

            }

            signed char return_value_lglval_8;
            return_value_lglval_8=lglval(lgl, other2);
            val2 = (signed int)return_value_lglval_8;
            if(val2 >= 1)
              goto __CPROVER_DUMP_L97;

            if(val == 0 && val2 == 0)
              goto __CPROVER_DUMP_L97;

            if(!(red == 0))
            {
              return_value_lgliselim_9=lgliselim(lgl, other2);
              if(!(return_value_lgliselim_9 == 0))
                goto __CPROVER_DUMP_L97;

            }

            if(!(val >= 0) && !(val2 >= 0))
            {
              lgltonflict(lgl, -lit, blit, other2);
              p = p + 1l;
              break;
            }

            if(val == 0)
              do
              {
                signed int TMP = other;
                other = other2;
                other2 = TMP;
              }
              while((_Bool)0);

            if(!(lgl->level == 0))
              tmp_if_expr_13 = lgl->simp != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_13 = (_Bool)0;
            if(tmp_if_expr_13)
              tmp_if_expr_14 = lgl->opts->lhbr.val != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_14 = (_Bool)0;
            if(tmp_if_expr_14)
              tmp_if_expr_15 = !(lgl->cgrclosing != 0) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_15 = (_Bool)0;
            if(tmp_if_expr_15)
            {
              dom=lglgetdom(lgl, lit);
              signed int return_value_lglgetdom_10;
              return_value_lglgetdom_10=lglgetdom(lgl, -other);
              if(!(return_value_lglgetdom_10 == dom))
                goto NO_HBR_JUST_F3RCE;

              dom=lglca(lgl, lit, -other);
              if(dom == 0)
                goto NO_HBR_JUST_F3RCE;

              subsumed = (signed int)(dom == lit || dom == -other);
              hbred=lglhbred(lgl, subsumed, red);

            __CPROVER_DUMP_L23:
              ;
              if(!(subsumed == 0))
              {

              __CPROVER_DUMP_L24:
                ;
                lglrmtwch(lgl, other2, other, -lit, red);
                lglrmtwch(lgl, other, other2, -lit, red);
                lgl->stats->hbr.sub = lgl->stats->hbr.sub + 1;
                if(!(red == 0))
                  lgl->stats->red.trn = lgl->stats->red.trn - 1;

                else
                {
                  lgldecirr(lgl, 3);
                  if(!(lgl->dense == 0))
                  {
                    if(-dom == -lit)
                      lgldecocc(lgl, other);

                    else
                      lgldecocc(lgl, -lit);
                  }

                }
              }

              delta = (signed long int)0;
              if(dom == lit)
              {

              __CPROVER_DUMP_L28:
                ;
                blit = other2 << RMSHFT | BINCS | hbred;
                q[(signed long int)-2] = blit;
                q = q - 1l;
              }

              else
              {
                if(dom == -other)
                {

                __CPROVER_DUMP_L30:
                  ;
                  q = q - (signed long int)2;
                }

                else

                  __CPROVER_DUMP_L31:
                    ;
                signed long int return_value_lglwchbin_11;
                return_value_lglwchbin_11=lglwchbin(lgl, -dom, other2, hbred);
                delta = delta + return_value_lglwchbin_11;
              }
              signed long int return_value_lglwchbin_12;
              return_value_lglwchbin_12=lglwchbin(lgl, other2, -dom, hbred);
              delta = delta + return_value_lglwchbin_12;
              if(!(delta == 0l))
              {
                p = p + delta;
                q = q + delta;
                eos = eos + delta;
              }

              if(!(hbred == 0))
                lgl->stats->red.bin = lgl->stats->red.bin + 1;

              else
                lglincirr(lgl, 2);
              lglf2rce(lgl, other2, -dom, hbred);
              lgl->stats->hbr.trn = lgl->stats->hbr.trn + 1;
              lgl->stats->hbr.cnt = lgl->stats->hbr.cnt + 1;
              lgl->stats->prgss = lgl->stats->prgss + 1l;
            }

            else
            {

            NO_HBR_JUST_F3RCE:
              ;
              lglf3rce(lgl, other2, -lit, other, red);
            }
          }

          else
          {
            if(!(val >= 1))
            {
              lidx = p[(signed long int)1];
              c=lglidx2lits(lgl, LRGCS, red, lidx);
              other2 = c[(signed long int)0];
              if(other2 >= 134217727)
              {
                p = p + 1l;
                goto __CPROVER_DUMP_L97;
              }

              if(other2 == -lit)
              {
                c[(signed long int)0] = c[(signed long int)1];
                other2 = c[(signed long int)0];
                c[(signed long int)1] = -lit;
              }

              if(!(other2 == other))
              {
                other = other2;
                signed char return_value_lglval_16;
                return_value_lglval_16=lglval(lgl, other);
                val = (signed int)return_value_lglval_16;
                blit = red;
                blit = blit | LRGCS;
                blit = blit | other2 << RMSHFT;
                if(val >= 1)
                  goto COPYL;

              }

              if(!(red == 0))
              {
                return_value_lgliselim_17=lgliselim(lgl, other);
                if(!(return_value_lgliselim_17 == 0))
                  goto COPYL;

              }

              val2 = 0x7fffffff;
              prev = -lit;
              l = c + (signed long int)2;
              do
              {
                other2 = *l;
                if(other2 == 0)
                  break;

                *l = prev;
                signed char return_value_lglval_18;
                return_value_lglval_18=lglval(lgl, other2);
                val2 = (signed int)return_value_lglval_18;
                if(val2 >= 0)
                  break;

                if(!(red == 0))
                {
                  return_value_lgliselim_19=lgliselim(lgl, other2);
                  if(!(return_value_lgliselim_19 == 0))
                    break;

                }

                prev = other2;
                l = l + 1l;
              }
              while((_Bool)1);
              if(val2 >= 0 && !(other2 == 0))
              {
                c[(signed long int)1] = other2;
                delta=lglwchlrg(lgl, other2, other, red, lidx);
                if(!(delta == 0l))
                {
                  p = p + delta;
                  q = q + delta;
                  eos = eos + delta;
                }

                p = p + 1l;
                goto __CPROVER_DUMP_L97;
              }

              for( ; !(c + 2l >= l); prev = other3)
              {
                l = l - 1l;
                other3 = *l;
                *l = prev;
              }
              if(other2 == 0 || val2 >= 0)
              {
                if(!(val >= 0))
                {
                  lglonflict(lgl, 1, -lit, red, lidx);
                  break;
                }

                if(!(lgl->level == 0))
                  tmp_if_expr_27 = lgl->simp != 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_27 = (_Bool)0;
                if(tmp_if_expr_27)
                  tmp_if_expr_28 = lgl->opts->lhbr.val != 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_28 = (_Bool)0;
                if(tmp_if_expr_28)
                  tmp_if_expr_29 = !(lgl->cgrclosing != 0) ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_29 = (_Bool)0;
                if(tmp_if_expr_29)
                {
                  dom = 0;
                  l = c;
                  do
                  {
                    other2 = *l;
                    if(other2 == 0)
                      break;

                    if(!(other2 == other))
                    {
                      signed int return_value_lglevel_20;
                      return_value_lglevel_20=lglevel(lgl, other2);
                      if(!(return_value_lglevel_20 == 0))
                      {
                        if(dom == 0)
                          dom=lglgetdom(lgl, -other);

                        signed int return_value_lglgetdom_21;
                        return_value_lglgetdom_21=lglgetdom(lgl, -other2);
                        if(!(dom == return_value_lglgetdom_21))
                          goto NO_HBR_JUST_FLRCE;

                      }

                    }

                    l = l + 1l;
                  }
                  while((_Bool)1);

                __CPROVER_DUMP_L61:
                  ;
                  dom = 0;
                  l = c;
                  do
                  {
                    other2 = *l;
                    if(other2 == 0)
                      break;

                    if(!(other2 == other))
                    {
                      signed int return_value_lglevel_22;
                      return_value_lglevel_22=lglevel(lgl, other2);
                      if(!(return_value_lglevel_22 == 0))
                        dom=lglca(lgl, dom, -other2);

                    }

                    l = l + 1l;
                  }
                  while((_Bool)1);
                  if(dom == 0)
                    goto NO_HBR_JUST_FLRCE;


                __CPROVER_DUMP_L65:
                  ;
                  subsumed = 0;
                  l = c;
                  do
                  {
                    if(subsumed == 0)
                    {
                      other2 = *l;
                      tmp_if_expr_23 = other2 != 0 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_23 = (_Bool)0;
                    if(!tmp_if_expr_23)
                      break;

                    subsumed = (signed int)(dom == -other2);
                    l = l + 1l;
                  }
                  while((_Bool)1);
                  hbred=lglhbred(lgl, subsumed, red);

                __CPROVER_DUMP_L70:
                  ;
                  if(!(subsumed == 0))
                  {

                  __CPROVER_DUMP_L71:
                    ;
                    lglrmlwch(lgl, other, red, lidx);
                    lgl->stats->hbr.sub = lgl->stats->hbr.sub + 1;
                    if(!(red == 0))
                    {
                      glue = lidx & (1 << 4) - 1;
                      if(!(glue == 15))
                      {
                        lgl->stats->red.lrg = lgl->stats->red.lrg - 1;
                        lgl->stats->lir[(signed long int)glue].clauses = lgl->stats->lir[(signed long int)glue].clauses - 1;
                      }

                    }

                    if(red == 0)
                    {
                      if(!(lgl->dense == 0))
                      {
                        l = c;
                        do
                        {
                          other2 = *l;
                          if(other2 == 0)
                            break;

                          if(!(other2 == -lit))
                            lglrmlocc(lgl, other2, 0, lidx);

                          if(!(other2 == -dom))
                          {
                            if(!(other2 == other))
                              lgldecocc(lgl, other2);

                          }

                          l = l + 1l;
                        }
                        while((_Bool)1);
                        flushoccs = flushoccs + 1;
                      }

                    }

                    if(!(red == 0) && !(glue >= 15))
                    {

                    __CPROVER_DUMP_L78:
                      ;
                      c[(signed long int)-1] = 0x7fffffff;
                    }

                    l = c;
                    for( ; !(*l == 0); l = l + 1l)
                      *l = 0x7fffffff;
                    if(red == 0)
                      lgldecirr(lgl, (signed int)(l - c));

                    *l = 0x7fffffff;
                  }

                  delta = (signed long int)0;
                  if(dom == lit)
                  {

                  __CPROVER_DUMP_L84:
                    ;
                    blit = other << RMSHFT | BINCS | hbred;
                    tmp_post_24 = q;
                    q = q + 1l;
                    *tmp_post_24 = blit;
                    p = p + 1l;
                  }

                  else
                  {
                    if(!(subsumed == 0))
                    {

                    __CPROVER_DUMP_L86:
                      ;
                      p = p + 1l;
                    }

                    else

                      __CPROVER_DUMP_L87:
                        ;
                    signed long int return_value_lglwchbin_25;
                    return_value_lglwchbin_25=lglwchbin(lgl, -dom, other, hbred);
                    delta = delta + return_value_lglwchbin_25;
                  }
                  signed long int return_value_lglwchbin_26;
                  return_value_lglwchbin_26=lglwchbin(lgl, other, -dom, hbred);
                  delta = delta + return_value_lglwchbin_26;
                  if(!(delta == 0l))
                  {
                    p = p + delta;
                    q = q + delta;
                    eos = eos + delta;
                  }

                  if(!(hbred == 0))
                    lgl->stats->red.bin = lgl->stats->red.bin + 1;

                  else
                    lglincirr(lgl, 2);
                  lglf2rce(lgl, other, -dom, hbred);
                  lgl->stats->hbr.lrg = lgl->stats->hbr.lrg + 1;
                  lgl->stats->hbr.cnt = lgl->stats->hbr.cnt + 1;
                  lgl->stats->prgss = lgl->stats->prgss + 1l;
                  if(!(subsumed == 0))
                    goto __CPROVER_DUMP_L97;

                }

                else
                {

                NO_HBR_JUST_FLRCE:
                  ;
                  lglflrce(lgl, other, red, lidx);
                }
              }

            }


          COPYL:
            ;
            tmp_post_30 = q;
            q = q + 1l;
            *tmp_post_30 = blit;
            tmp_post_31 = q;
            q = q + 1l;
            p = p + 1l;
            *tmp_post_31 = *p;
          }
      }

    __CPROVER_DUMP_L97:
      ;
    }
    for( ; !(p >= eos); *tmp_post_32 = *tmp_post_33)
    {
      tmp_post_32 = q;
      q = q + 1l;
      tmp_post_33 = p;
      p = p + 1l;
    }
    lglshrinkhts(lgl, hts, (signed int)((signed long int)hts->count - (p - q)));
    if(!(flushoccs == 0))
      lglflushremovedoccs(lgl, -lit);

  }

}

// lglprop2
// file lglib.c line 4697
static void lglprop2(struct LGL *lgl, signed int lit)
{
  signed int other;
  signed int blit;
  signed int tag;
  signed int val;
  signed int red;
  signed int visits;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  visits = 0;
  hts=lglhts(lgl, -lit);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    visits = visits + 1;
    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(tag == BINCS)
    {
      red = blit & REDCS;
      other = blit >> RMSHFT;
      signed int return_value_lgliselim_1;
      return_value_lgliselim_1=lgliselim(lgl, other);
      if(return_value_lgliselim_1 == 0)
      {
        signed char return_value_lglval_2;
        return_value_lglval_2=lglval(lgl, other);
        val = (signed int)return_value_lglval_2;
        if(!(val >= 1))
        {
          if(!(val >= 0))
          {
            lglbonflict(lgl, -lit, blit);
            break;
          }

          lglf2rce(lgl, other, -lit, red);
        }

      }

    }

  }
  if(!(lgl->lkhd == 0))
    lgl->stats->visits.lkhd = lgl->stats->visits.lkhd + (signed long int)visits;

  else
    if(!(lgl->simp == 0))
      lgl->stats->visits.simp = lgl->stats->visits.simp + (signed long int)visits;

    else
      lgl->stats->visits.search = lgl->stats->visits.search + (signed long int)visits;
  if(!(lgl->basicprobing == 0))
    lgl->stats->prb.basic.steps = lgl->stats->prb.basic.steps + (signed long int)visits;

  if(!(lgl->cceing == 0))
    lgl->stats->cce.steps = lgl->stats->cce.steps + (signed long int)visits;

  if(!(lgl->cliffing == 0))
    lgl->stats->cliff.steps = lgl->stats->cliff.steps + (signed long int)visits;

}

// lglpropsearch
// file lglib.c line 4245
static void lglpropsearch(struct LGL *lgl, signed int lit)
{
  signed int *q;
  signed int *eos;
  signed int blit;
  signed int other;
  signed int other2;
  signed int other3;
  signed int red;
  signed int prev;
  signed int tag;
  signed int val;
  signed int val2;
  signed int lidx;
  signed int *c;
  signed int *l;
  const signed int *p;
  signed int visits;
  signed long int delta;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  hts=lglhts(lgl, -lit);
  signed int *tmp_post_1;
  signed int *tmp_post_2;
  signed int *tmp_post_7;
  const signed int *tmp_post_8;
  if(!(hts->offset == 0))
  {
    q=lglhts2wchs(lgl, hts);
    eos = q + (signed long int)hts->count;
    visits = 0;
    p = q;
    for( ; !(p >= eos); p = p + 1l)
    {
      visits = visits + 1;
      tmp_post_1 = q;
      q = q + 1l;
      blit = *p;
      *tmp_post_1 = blit;
      tag = blit & MASKCS;
      if(!(tag == BINCS))
      {
        tmp_post_2 = q;
        q = q + 1l;
        p = p + 1l;
        *tmp_post_2 = *p;
      }

      other = blit >> RMSHFT;
      signed char return_value_lglval_3;
      return_value_lglval_3=lglval(lgl, other);
      val = (signed int)return_value_lglval_3;
      if(!(val >= 1))
      {
        red = blit & REDCS;
        if(tag == BINCS)
        {
          if(!(val >= 0))
          {
            lglbonflict(lgl, -lit, blit);
            p = p + 1l;
            break;
          }

          lglf2rce(lgl, other, -lit, red);
        }

        else
          if(tag == TRNCS)
          {
            other2 = *p;
            signed char return_value_lglval_4;
            return_value_lglval_4=lglval(lgl, other2);
            val2 = (signed int)return_value_lglval_4;
            if(val2 >= 1)
              goto __CPROVER_DUMP_L25;

            if(val == 0 && val2 == 0)
              goto __CPROVER_DUMP_L25;

            if(!(val >= 0) && !(val2 >= 0))
            {
              lgltonflict(lgl, -lit, blit, other2);
              p = p + 1l;
              break;
            }

            if(val == 0)
              do
              {
                signed int TMP = other;
                other = other2;
                other2 = TMP;
              }
              while((_Bool)0);

            lglf3rce(lgl, other2, -lit, other, red);
          }

          else
          {
            lidx = *p;
            c=lglidx2lits(lgl, LRGCS, red, lidx);
            other2 = c[(signed long int)0];
            if(other2 == -lit)
            {
              c[(signed long int)0] = c[(signed long int)1];
              other2 = c[(signed long int)0];
              c[(signed long int)1] = -lit;
            }

            if(!(other2 == other))
            {
              other = other2;
              signed char return_value_lglval_5;
              return_value_lglval_5=lglval(lgl, other);
              val = (signed int)return_value_lglval_5;
              if(val >= 1)
              {
                q[(signed long int)-2] = LRGCS | other2 << RMSHFT | red;
                goto __CPROVER_DUMP_L25;
              }

            }

            val2 = 0x7fffffff;
            prev = -lit;
            l = c + (signed long int)2;
            do
            {
              other2 = *l;
              if(other2 == 0)
                break;

              *l = prev;
              signed char return_value_lglval_6;
              return_value_lglval_6=lglval(lgl, other2);
              val2 = (signed int)return_value_lglval_6;
              if(val2 >= 0)
                break;

              prev = other2;
              l = l + 1l;
            }
            while((_Bool)1);
            if(val2 >= 0 && !(other2 == 0))
            {
              c[(signed long int)1] = other2;
              delta=lglwchlrg(lgl, other2, other, red, lidx);
              if(!(delta == 0l))
              {
                p = p + delta;
                q = q + delta;
                eos = eos + delta;
              }

              q = q - (signed long int)2;
              goto __CPROVER_DUMP_L25;
            }

            for( ; !(c + 2l >= l); prev = other3)
            {
              l = l - 1l;
              other3 = *l;
              *l = prev;
            }
            if(!(val >= 0))
            {
              lglonflict(lgl, 1, -lit, red, lidx);
              p = p + 1l;
              break;
            }

            lglflrce(lgl, other, red, lidx);
          }
      }


    __CPROVER_DUMP_L25:
      ;
    }
    for( ; !(p >= eos); *tmp_post_7 = *tmp_post_8)
    {
      tmp_post_7 = q;
      q = q + 1l;
      tmp_post_8 = p;
      p = p + 1l;
    }
    lglshrinkhts(lgl, hts, (signed int)((signed long int)hts->count - (p - q)));
    lgl->stats->visits.search = lgl->stats->visits.search + (signed long int)visits;
  }

}

// lglpropunits
// file lglib.c line 13725
static signed int lglpropunits(struct LGL *lgl)
{
  signed int lit;
  signed char val;
  signed int return_value_lglmtstk_1;
  do
  {
    return_value_lglmtstk_1=lglmtstk(&lgl->_anon0.cgr->units);
    if(!(return_value_lglmtstk_1 == 0))
      break;

    lit=lglpopstk(&lgl->_anon0.cgr->units);
    signed int return_value_lglcval_2;
    return_value_lglcval_2=lglcval(lgl, lit);
    val = (signed char)return_value_lglcval_2;
    if(!((signed int)val >= 1))
    {
      if(!((signed int)val >= 0))
      {

      __CPROVER_DUMP_L3:
        ;
        lgl->mt = 1;
      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        lglunitnocheck(lgl, lit);
        signed int return_value_lglbcp_3;
        return_value_lglbcp_3=lglbcp(lgl);
        if(!(return_value_lglbcp_3 == 0))
          continue;


      __CPROVER_DUMP_L5:
        ;
        lgl->mt = 1;
      }
    }

  }
  while((_Bool)1);
  return (signed int)!(lgl->mt != 0);
}

// lglprs
// file lglib.c line 18084
static void lglprs(struct LGL *lgl, const char *fmt, ...)
{
  void **ap;
  lglprstart(lgl);
  ap = (void **)&fmt;
  vfprintf(lgl->out, fmt, ap);
  ap = ((void **)NULL);
  fputc(10, lgl->out);
}

// lglprstart
// file lglib.c line 18078
static void lglprstart(struct LGL *lgl)
{
  fputs(lgl->prefix, lgl->out);
  if(lgl->tid >= 0)
    fprintf(lgl->out, "%d ", lgl->tid);

}

// lglprt
// file lglib.c line 1206
static void lglprt(struct LGL *lgl, signed int level, const char *msg, ...)
{
  void **ap;
  if(lgl->opts->verbose.val >= level)
  {
    lglmsgstart(lgl, level);
    ap = (void **)&msg;
    vfprintf(lgl->out, msg, ap);
    ap = ((void **)NULL);
    lglmsgend(lgl);
  }

}

// lglprtcgrem
// file lglib.c line 12985
static void lglprtcgrem(struct LGL *lgl)
{
  signed int idx;
  signed int ret = 0;
  signed int rem = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree_1;
    return_value_lglisfree_1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree_1 == 0))
    {
      struct AVar *return_value_lglavar_2;
      return_value_lglavar_2=lglavar(lgl, idx);
      if(!(return_value_lglavar_2->donotcgrcls == 0u))
        ret = ret + 1;

      else
        rem = rem + 1;
    }

  }
  signed int return_value_lglrem_3;
  double return_value_lglpcnt_4;
  struct AVar *return_value_lglavar_5;
  if(!(rem == 0))
  {
    return_value_lglrem_3=lglrem(lgl);
    return_value_lglpcnt_4=lglpcnt((double)rem, (double)return_value_lglrem_3);
    lglprt(lgl, 1, "[cgrclsr-%d] %d variables remain %.0f%% (%d retained)", lgl->stats->cgr.count, rem, return_value_lglpcnt_4, ret);
  }

  else
  {
    lglprt(lgl, 1, "[cgrclsr-%d] fully completed congruence closure", lgl->stats->cgr.count);
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      return_value_lglavar_5=lglavar(lgl, idx);
      return_value_lglavar_5->donotcgrcls = (unsigned int)0;
    }
  }
}

// lglprternresrem
// file lglib.c line 14689
static void lglprternresrem(struct LGL *lgl)
{
  signed int idx;
  signed int ret = 0;
  signed int rem = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree_1;
    return_value_lglisfree_1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree_1 == 0))
    {
      struct AVar *return_value_lglavar_2;
      return_value_lglavar_2=lglavar(lgl, idx);
      if(!(return_value_lglavar_2->donoternres == 0u))
        ret = ret + 1;

      else
        rem = rem + 1;
    }

  }
  signed int return_value_lglrem_3;
  double return_value_lglpcnt_4;
  struct AVar *return_value_lglavar_5;
  if(!(rem == 0))
  {
    return_value_lglrem_3=lglrem(lgl);
    return_value_lglpcnt_4=lglpcnt((double)rem, (double)return_value_lglrem_3);
    lglprt(lgl, 1, "[ternres-%d] %d variables remain %.0f%% (%d retained)", lgl->stats->trnr.count, rem, return_value_lglpcnt_4, ret);
  }

  else
  {
    lglprt(lgl, 1, "[ternres-%d] fully completed ternary resolution", lgl->stats->trnr.count);
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      return_value_lglavar_5=lglavar(lgl, idx);
      return_value_lglavar_5->donoternres = (unsigned int)0;
    }
  }
}

// lglprtlftrem
// file lglib.c line 13956
static void lglprtlftrem(struct LGL *lgl)
{
  signed int idx;
  signed int ret = 0;
  signed int rem = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree_1;
    return_value_lglisfree_1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree_1 == 0))
    {
      struct AVar *return_value_lglavar_2;
      return_value_lglavar_2=lglavar(lgl, idx);
      if(!(return_value_lglavar_2->donotlft == 0u))
        ret = ret + 1;

      else
        rem = rem + 1;
    }

  }
  signed int return_value_lglrem_3;
  double return_value_lglpcnt_4;
  struct AVar *return_value_lglavar_5;
  if(!(rem == 0))
  {
    return_value_lglrem_3=lglrem(lgl);
    return_value_lglpcnt_4=lglpcnt((double)rem, (double)return_value_lglrem_3);
    lglprt(lgl, 1, "[lift-%d] %d variables remain %.0f%% (%d retained)", lgl->stats->lift.count, rem, return_value_lglpcnt_4, ret);
  }

  else
  {
    lglprt(lgl, 1, "[lift-%d] fully completed lifting", lgl->stats->lift.count);
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      return_value_lglavar_5=lglavar(lgl, idx);
      return_value_lglavar_5->donotlft = (unsigned int)0;
    }
  }
}

// lglptrjmp
// file lglib.c line 7151
static signed int lglptrjmp(signed int *repr, signed int max, signed int start)
{
  signed int lglptrjmp__1__next;
  signed int idx;
  signed int res;
  signed int sgn;
  signed int tmp;
  lglptrjmp__1__next = start;
  do
  {
    res = lglptrjmp__1__next;
    idx=abs(res);
    sgn=lglsgn(res);
    lglptrjmp__1__next = repr[(signed long int)idx];
    lglptrjmp__1__next = lglptrjmp__1__next * sgn;
  }
  while(!(lglptrjmp__1__next == 0));
  tmp = start;
  for( ; !(tmp == res); tmp = lglptrjmp__1__next)
  {
    idx=abs(tmp);
    sgn=lglsgn(tmp);
    lglptrjmp__1__next = repr[(signed long int)idx] * sgn;
    repr[(signed long int)idx] = sgn * res;
  }
  return res;
}

// lglpull
// file lglib.c line 4809
static signed int lglpull(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int level;
  signed int res;
  level=lglevel(lgl, lit);
  if(level == 0)
    return 0;

  else
    if(!(av->mark == 0))
      return 0;

    else
    {
      av->mark = 1;
      lglpushstk(lgl, &lgl->seen, lit);
      if(level == lgl->level)
      {

      __CPROVER_DUMP_L3:
        ;
        res = 1;
      }

      else
      {
        lglpushstk(lgl, &lgl->clause, lit);

      __CPROVER_DUMP_L5:
        ;
        signed int return_value_lglevelused_1;
        return_value_lglevelused_1=lglevelused(lgl, level);
        if(return_value_lglevelused_1 == 0)
        {
          lgluselevel(lgl, level);
          lglpushstk(lgl, &lgl->frames, level);
        }


      __CPROVER_DUMP_L6:
        ;
        res = 0;
      }
      return res;
    }
}

// lglpurelit
// file lglib.c line 11122
static signed int lglpurelit(struct LGL *lgl, signed int lit)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  lgl->stats->blk.pure = lgl->stats->blk.pure + 1;
  res=lglflushclauses(lgl, lit);
  lgl->stats->blk.clauses = lgl->stats->blk.clauses + res;
  if(!(lgl->blocking == 0))
    lgl->stats->blk.steps = lgl->stats->blk.steps + (signed long int)res;

  lglepusheliminated(lgl, lit);
  return res;
}

// lglpushcontrol
// file lglib.c line 1560
static void lglpushcontrol(struct LGL *lgl, signed int decision)
{
  struct Ctk *ctk = &lgl->control;
  struct Ctr *ctr;
  signed int return_value_lglfullctk_1;
  return_value_lglfullctk_1=lglfullctk(ctk);
  if(!(return_value_lglfullctk_1 == 0))
    lglenlctk(lgl, ctk);

  struct Ctr *tmp_post_2 = ctk->top;
  ctk->top = ctk->top + 1l;
  ctr = tmp_post_2;
  ctr->decision = decision;
  ctr->used = (unsigned int)0;
}

// lglpushgocc
// file lglib.c line 12323
static void lglpushgocc(struct LGL *lgl, signed int lit, signed int gidx)
{
  signed int idx;
  signed int repr;
  struct Stk *goccs;
  repr=lglcgrepr(lgl, lit);
  signed int return_value_abs_1;
  return_value_abs_1=abs(repr);
  if(return_value_abs_1 == 1)
    repr = lit;

  idx=abs(repr);
  goccs = lgl->_anon0.cgr->goccs + (signed long int)idx;
  lglpushstk(lgl, goccs, gidx);
}

// lglpushnmarkseen
// file lglib.c line 11116
static void lglpushnmarkseen(struct LGL *lgl, signed int lit)
{
  lglpushstk(lgl, &lgl->seen, lit);
  lglmark(lgl, lit);
}

// lglpushstk
// file lglib.c line 1431
static void lglpushstk(struct LGL *lgl, struct Stk *s, signed int elem)
{
  signed int return_value_lglfullstk_1;
  return_value_lglfullstk_1=lglfullstk(s);
  if(!(return_value_lglfullstk_1 == 0))
    lglenlstk(lgl, s);

  signed int *tmp_post_2 = s->top;
  s->top = s->top + 1l;
  *tmp_post_2 = elem;
}

// lglpushwch
// file lglib.c line 3115
static signed long int lglpushwch(struct LGL *lgl, struct HTS *hts, signed int wch)
{
  signed long int res = (signed long int)0;
  signed int *wchs;
  wchs=lglhts2wchs(lgl, hts);
  if(!(wchs[(signed long int)hts->count] == 0))
  {
    res=lglenlwchs(lgl, hts);
    wchs=lglhts2wchs(lgl, hts);
  }

  signed int tmp_post_1 = hts->count;
  hts->count = hts->count + 1;
  wchs[(signed long int)tmp_post_1] = wch;
  lgl->stats->pshwchs = lgl->stats->pshwchs + 1l;
  return res;
}

// lglpushwtk
// file lglib.c line 15009
static void lglpushwtk(struct LGL *lgl, struct Wtk *wtk, enum Wrag wrag, signed int lit, signed int other, signed int red)
{
  struct Work w;
  signed int return_value_lglfullwtk_1;
  return_value_lglfullwtk_1=lglfullwtk(wtk);
  if(!(return_value_lglfullwtk_1 == 0))
    lglenlwtk(lgl, wtk);

  w.wrag = (unsigned int)wrag;
  w.other = other;
  w.red = (unsigned int)(red != 0 ? 1 : 0);
  w.removed = (unsigned int)0;
  w.lit = lit;
  struct Work *tmp_post_2 = wtk->top;
  wtk->top = wtk->top + 1l;
  *tmp_post_2 = w;
}

// lglqclone
// file lglib.c line 1906
static void lglqclone(struct LGL *lgl, struct LGL *orig)
{
  struct LGL *to = lgl;
  struct LGL *from = orig;
  struct Qln *pl;
  struct Qln *fl;
  struct Qln *tl;
  struct Qnd *fn;
  struct Qnd *tn;
  signed int idx;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)from->szvars * sizeof(struct Qnd) /*16ul*/ );
    lgl->queue.nodes = (struct Qnd *)return_value_lglnew_1;
    memcpy((void *)lgl->queue.nodes, (const void *)orig->queue.nodes, (unsigned long int)from->szvars * sizeof(struct Qnd) /*16ul*/ );
  }
  while((_Bool)0);
  struct Qln *tmp_if_expr_4;
  if(!(lgl->qscheduling == 0))
  {
    pl = ((struct Qln *)NULL);
    fl = from->queue.bottom;
    for( ; !(fl == ((struct Qln *)NULL)); fl = fl->up)
    {
      do
      {
        void *return_value_lglnew_2;
        return_value_lglnew_2=lglnew(lgl, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
        tl = (struct Qln *)return_value_lglnew_2;
      }
      while((_Bool)0);
      tl->prior = fl->prior;
      tl->first = fl->first;
      tl->last = fl->last;
      tl->unassigned = fl->unassigned;
      fl->down = tl;
      if(!(pl == ((struct Qln *)NULL)))
        pl->up = tl;

      else
        to->queue.bottom = tl;
      tl->down = pl;
      tl->repr = tl;
      pl = tl;
    }
    to->queue.top = pl;
    pl = ((struct Qln *)NULL);
    fl = from->queue.merged;
    for( ; !(fl == ((struct Qln *)NULL)); fl = fl->up)
    {
      do
      {
        void *return_value_lglnew_3;
        return_value_lglnew_3=lglnew(lgl, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
        tl = (struct Qln *)return_value_lglnew_3;
      }
      while((_Bool)0);
      fl->down = tl;
      if(!(pl == ((struct Qln *)NULL)))
        pl->up = tl;

      else
        to->queue.merged = tl;
      pl = tl;
    }
    fl = from->queue.merged;
    for( ; !(fl == ((struct Qln *)NULL)); fl = fl->up)
    {
      tl = fl->down;
      while(fl->repr == ((struct Qln *)NULL))
      {
        fprintf(stderr, "liblgl.a: %s:%d: %s: Coverage target `%s' reached.", (const void *)"lglqclone", 1951, (const void *)"lglib.c", (const void *)"!fl->repr");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputc(10, stderr);
        fflush(stderr);
        abort();
        break;
      }
      while(tl == ((struct Qln *)NULL))
      {
        fprintf(stderr, "liblgl.a: %s:%d: %s: Coverage target `%s' reached.", (const void *)"lglqclone", 1958, (const void *)"lglib.c", (const void *)"!tl");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputc(10, stderr);
        fflush(stderr);
        abort();
        break;
      }
      if(!(fl->repr == ((struct Qln *)NULL)))
        tmp_if_expr_4 = fl->repr->down;

      else
        tmp_if_expr_4 = ((struct Qln *)NULL);
      tl->repr = tmp_if_expr_4;
    }
    idx = 2;
    for( ; !(idx >= from->nvars); idx = idx + 1)
    {
      fn=lglqnd(from, idx);
      tn=lglqnd(to, idx);
      tn->line = fn->line->down;
    }
    pl = ((struct Qln *)NULL);
    fl = from->queue.bottom;
    for( ; !(fl == ((struct Qln *)NULL)); fl = fl->up)
    {
      if(fl == from->queue.unassigned)
        to->queue.unassigned = fl->down;

      fl->down = pl;
      pl = fl;
    }
    fl = from->queue.merged;
    for( ; !(fl == ((struct Qln *)NULL)); fl = fl->up)
      fl->down = ((struct Qln *)NULL);
    to->queue.nmerged = from->queue.nmerged;
    to->queue.nlines = from->queue.nlines;
    fl = from->queue.free;
    for( ; !(fl == ((struct Qln *)NULL)); fl = fl->up)
    {
      do
      {
        void *return_value_lglnew_5;
        return_value_lglnew_5=lglnew(lgl, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
        tl = (struct Qln *)return_value_lglnew_5;
      }
      while((_Bool)0);
      tl->up = to->queue.free;
      to->queue.free = tl;
    }
  }

}

// lglqcmp
// file lglib.c line 2753
static signed int lglqcmp(struct LGL *lgl, signed int l, signed int k)
{
  struct Qln *ln;
  ln=lglqln(lgl, l);
  struct Qln *kn;
  kn=lglqln(lgl, k);
  return ln->prior - kn->prior;
}

// lglqdump
// file lglib.c line 2421
static void lglqdump(struct LGL *lgl)
{
  struct Qln *p;
  struct Qnd *n;
  signed int i;
  p = lgl->queue.top;
  for( ; !(p == ((struct Qln *)NULL)); p = p->down)
  {
    printf("c queue[%d]", p->prior);
    i = p->first;
    for( ; !(i == 0); i = n->next)
    {
      n=lglqnd(lgl, i);
      printf(" %d", i);
    }
    printf("\n");
  }
}

// lglqln
// file lglib.c line 2741
static struct Qln * lglqln(struct LGL *lgl, signed int lit)
{
  struct Qln *res;
  struct Qln *line;
  struct Qln *lglqln__1__next;
  struct Qnd *node;
  node=lglqnd(lgl, lit);
  res = node->line;
  do
  {
    line = res->repr;
    if(line == res)
      break;

    res = line;
  }
  while((_Bool)1);
  line = node->line;
  for( ; !(line == res); line = lglqln__1__next)
  {
    lglqln__1__next = line->repr;
    line->repr = res;
  }
  node->line = res;
  return res;
}

// lglqnd
// file lglib.c line 1900
static struct Qnd * lglqnd(struct LGL *lgl, signed int lit)
{
  signed int idx;
  idx=abs(lit);
  return lgl->queue.nodes + (signed long int)idx;
}

// lglqsched
// file lglib.c line 2372
static void lglqsched(struct LGL *lgl, signed int idx)
{
  struct Qnd *n;
  n=lglqnd(lgl, idx);
  struct Qnd *m;
  struct Qln *l;
  if(!(lgl->qscheduling == 0))
  {
    l = lgl->queue.bottom;
    if(l == ((struct Qln *)NULL))
    {
      l = lgl->queue.free;
      if(!(l == ((struct Qln *)NULL)))
      {
        lgl->queue.free = l->up;
        do
          memset((void *)l, 0, sizeof(struct Qln) /*40ul*/ );
        while((_Bool)0);
      }

      else
        do
        {
          void *return_value_lglnew_1;
          return_value_lglnew_1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
          l = (struct Qln *)return_value_lglnew_1;
        }
        while((_Bool)0);
      l->repr = l;
      lgl->queue.unassigned = l->repr;
      lgl->queue.top = lgl->queue.unassigned;
      lgl->queue.bottom = lgl->queue.top;
      lgl->queue.nlines = lgl->queue.nlines + 1;
      lgl->stats->queue.new = lgl->stats->queue.new + 1l;
    }

    else
      if(!(l->prior == 0))
      {
        l = lgl->queue.free;
        if(!(l == ((struct Qln *)NULL)))
        {
          lgl->queue.free = l->up;
          do
            memset((void *)l, 0, sizeof(struct Qln) /*40ul*/ );
          while((_Bool)0);
        }

        else
          do
          {
            void *return_value_lglnew_2;
            return_value_lglnew_2=lglnew(lgl, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
            l = (struct Qln *)return_value_lglnew_2;
          }
          while((_Bool)0);
        lgl->queue.bottom->down = l;
        l->up = lgl->queue.bottom;
        lgl->queue.bottom = l;
        l->repr = l;
        lgl->queue.nlines = lgl->queue.nlines + 1;
        lgl->stats->queue.new = lgl->stats->queue.new + 1l;
      }


  __CPROVER_DUMP_L5:
    ;

  __CPROVER_DUMP_L10:
    ;
    if(!(lgl->bias >= 0))
    {
      n->prev = l->last;
      if(!(n->prev == 0))
      {
        m=lglqnd(lgl, l->last);
        m->next = idx;
      }

      else
      {
        l->unassigned = idx;
        l->first = l->unassigned;
      }
      l->last = idx;
    }

    else
    {
      n->next = l->first;
      if(!(n->next == 0))
      {
        m=lglqnd(lgl, l->first);
        m->prev = idx;
      }

      else
        l->last = idx;
      l->unassigned = idx;
      l->first = l->unassigned;
    }
    n->line = l;
    if(lgl->opts->check.val >= 3)
      lglchkqueue(lgl);

  }

}

// lglqschedall
// file lglib.c line 17259
static void lglqschedall(struct LGL *lgl)
{
  signed int idx;
  lgl->qscheduling = (char)1;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
    lglqsched(lgl, idx);
  lglprt(lgl, 1, "[queue-schedule-all-variables]");
}

// lglrand
// file lglib.c line 1529
static unsigned int lglrand(struct LGL *lgl)
{
  unsigned int res;
  lgl->rng.z = (unsigned int)36969 * (lgl->rng.z & (unsigned int)65535) + (lgl->rng.z >> 16);
  lgl->rng.w = (unsigned int)18000 * (lgl->rng.w & (unsigned int)65535) + (lgl->rng.w >> 16);
  res = (lgl->rng.z << 16) + lgl->rng.w;

__CPROVER_DUMP_L1:
  ;
  return res;
}

// lglrandec
// file lglib.c line 7686
static signed int lglrandec(struct LGL *lgl)
{
  unsigned int size;
  unsigned int pos;
  unsigned int lglrandec__1__start;
  unsigned int delta;
  signed int lit;
  lgl->limits->randec = lgl->stats->decisions;
  lgl->limits->randec = lgl->limits->randec + (signed long int)(lgl->opts->randecint.val / 2);
  unsigned int return_value_lglrand_1;
  return_value_lglrand_1=lglrand(lgl);
  lgl->limits->randec = lgl->limits->randec + (signed long int)(return_value_lglrand_1 % (unsigned int)lgl->opts->randecint.val);
  size = (unsigned int)(lgl->nvars - 2);
  unsigned int return_value_lglgcd_4;
  signed char return_value_lglval_5;
  if(size == 0u)
    return 0;

  else
  {
    unsigned int return_value_lglrand_2;
    return_value_lglrand_2=lglrand(lgl);
    lglrandec__1__start = return_value_lglrand_2 % size;
    pos = lglrandec__1__start;
    lit = (signed int)((unsigned int)2 + pos);
    signed char return_value_lglval_6;
    return_value_lglval_6=lglval(lgl, lit);
    if(!(return_value_lglval_6 == 0))
    {
      unsigned int return_value_lglrand_3;
      return_value_lglrand_3=lglrand(lgl);
      delta = return_value_lglrand_3 % size;
      if(size == 1u)
        return 0;

      if(delta == 0u)
        delta = delta + 1u;

      do
      {
        return_value_lglgcd_4=lglgcd(delta, size);
        if(return_value_lglgcd_4 == 1u)
          break;

        delta = delta + 1u;
        if(delta == size)
          delta = (unsigned int)1;

      }
      while((_Bool)1);
      do
      {
        pos = pos + delta;
        if(pos >= size)
          pos = pos - size;

        if(pos == lglrandec__1__start)
          return 0;

        lit = (signed int)(pos + (unsigned int)2);
        return_value_lglval_5=lglval(lgl, lit);
      }
      while(!(return_value_lglval_5 == 0));
    }

    lgl->stats->randecs = lgl->stats->randecs + 1l;
    return lit;
  }
}

// lglrandidxtrav
// file lglib.c line 3327
static signed int lglrandidxtrav(struct LGL *lgl, signed int (*fun)(struct LGL *, signed int))
{
  signed int idx;
  signed int delta;
  signed int mod;
  signed int prev;
  signed int first;
  signed int res;
  mod=lglmax(lgl->nvars, 2);
  first = mod;
  unsigned int return_value_lglrand_1;
  return_value_lglrand_1=lglrand(lgl);
  idx = (signed int)(return_value_lglrand_1 % (unsigned int)mod);
  unsigned int return_value_lglrand_2;
  return_value_lglrand_2=lglrand(lgl);
  delta = (signed int)(return_value_lglrand_2 % (unsigned int)mod);
  if(delta == 0)
    delta = delta + 1;

  unsigned int return_value_lglgcd_3;
  do
  {
    return_value_lglgcd_3=lglgcd((unsigned int)delta, (unsigned int)mod);
    if(!(return_value_lglgcd_3 >= 2u))
      break;

    delta = delta + 1;
    if(delta == mod)
      delta = 1;

  }
  while((_Bool)1);
  res = 1;
  _Bool tmp_if_expr_4;
  signed int return_value;
  while(!(res == 0))
  {
    if(idx >= 2)
    {
      return_value=fun(lgl, idx);
      tmp_if_expr_4 = !(return_value != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      res = 0;

    else
    {
      prev = idx;
      idx = idx + delta;
      if(idx >= mod)
        idx = idx - mod;

      if(idx == first)
        break;

      if(first == mod)
        first = prev;

    }
  }
  return res;
}

// lglrandlitrav
// file lglib.c line 8594
static signed int lglrandlitrav(struct LGL *lgl, signed int (*fun)(struct LGL *, signed int))
{
  signed int delta;
  signed int mod;
  signed int prev;
  signed int first;
  signed int ulit;
  signed int count;
  unsigned int return_value_lglgcd_3;
  signed int return_value_lglilit_4;
  signed int return_value;
  if(!(lgl->nvars >= 2))
    return 0;

  else
  {
    mod = 2 * lgl->nvars;
    first = mod;
    unsigned int return_value_lglrand_1;
    return_value_lglrand_1=lglrand(lgl);
    ulit = (signed int)(return_value_lglrand_1 % (unsigned int)mod);
    unsigned int return_value_lglrand_2;
    return_value_lglrand_2=lglrand(lgl);
    delta = (signed int)(return_value_lglrand_2 % (unsigned int)mod);
    if(delta == 0)
      delta = delta + 1;

    do
    {
      return_value_lglgcd_3=lglgcd((unsigned int)delta, (unsigned int)mod);
      if(!(return_value_lglgcd_3 >= 2u))
        break;

      delta = delta + 1;
      if(delta == mod)
        delta = 1;

    }
    while((_Bool)1);
    count = mod;
    do
    {
      count = count - 1;
      if(ulit >= 4)
      {
        return_value_lglilit_4=lglilit(ulit);
        return_value=fun(lgl, return_value_lglilit_4);
        if(return_value == 0)
          return 0;

      }

      prev = ulit;
      ulit = ulit + delta;
      if(ulit >= mod)
        ulit = ulit - mod;

      if(ulit == first)
        break;

      if(first == mod)
        first = prev;

    }
    while((_Bool)1);
    return 1;
  }
}

// lglrandomprobe
// file lglib.c line 13848
static signed int lglrandomprobe(struct LGL *lgl, struct Stk *outer)
{
  unsigned int pos;
  unsigned int mod;
  signed int res;
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(outer);
  mod = (unsigned int)return_value_lglcntstk_1;
  if(mod == 0u)
    return 0;

  else
  {
    unsigned int return_value_lglrand_2;
    return_value_lglrand_2=lglrand(lgl);
    pos = return_value_lglrand_2 % mod;
    res=lglpeek(outer, (signed int)pos);
    signed char return_value_lglval_3;
    return_value_lglval_3=lglval(lgl, res);
    if(!(return_value_lglval_3 == 0))
      return 0;

    else
      return res;
  }
}

// lglreadopts
// file lglib.c line 2203
signed int lglreadopts(struct LGL *lgl, struct _IO_FILE *file)
{
  signed int res;
  signed int ch;
  signed int val;
  signed int nvalbuf;
  signed int noptbuf;
  char optbuf[40l];
  char valbuf[40l];
  const char *opt;
  res = 0;
  signed int tmp_post_2;
  signed int return_value_lglws_3;
  signed int tmp_post_4;
  signed int tmp_post_5;
  signed int return_value_lglws_6;
  signed int tmp_post_7;
  signed int return_value_lglws_8;
  signed int tmp_post_9;
  signed int tmp_post_10;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    ch=_IO_getc(file);
    signed int return_value_lglws_1;
    return_value_lglws_1=lglws(ch);
    if(!(return_value_lglws_1 == 0))
      goto __CPROVER_DUMP_L1;

    if(ch == -1)
      break;

    noptbuf = 0;
    tmp_post_2 = noptbuf;
    noptbuf = noptbuf + 1;
    optbuf[(signed long int)tmp_post_2] = (char)ch;
    do
    {
      ch=_IO_getc(file);
      if(ch == -1)
        break;

      return_value_lglws_3=lglws(ch);
      if(!(return_value_lglws_3 == 0))
        break;

      if((unsigned long int)(1 + noptbuf) >= sizeof(char [40l]) /*40ul*/ )
      {
        ch = -1;
        break;
      }

      tmp_post_4 = noptbuf;
      noptbuf = noptbuf + 1;
      optbuf[(signed long int)tmp_post_4] = (char)ch;
    }
    while((_Bool)1);
    if(ch == -1)
      break;

    tmp_post_5 = noptbuf;
    noptbuf = noptbuf + 1;
    optbuf[(signed long int)tmp_post_5] = (char)0;
    do
    {
      ch=_IO_getc(file);
      return_value_lglws_6=lglws(ch);
      if(return_value_lglws_6 == 0)
        break;

    }
    while((_Bool)1);
    if(ch == -1)
      break;

    nvalbuf = 0;
    tmp_post_7 = nvalbuf;
    nvalbuf = nvalbuf + 1;
    valbuf[(signed long int)tmp_post_7] = (char)ch;
    do
    {
      ch=_IO_getc(file);
      if(ch == -1)
        break;

      return_value_lglws_8=lglws(ch);
      if(!(return_value_lglws_8 == 0))
        break;

      if((unsigned long int)(1 + nvalbuf) >= sizeof(char [40l]) /*40ul*/ )
      {
        ch = -1;
        break;
      }

      tmp_post_9 = nvalbuf;
      nvalbuf = nvalbuf + 1;
      valbuf[(signed long int)tmp_post_9] = (char)ch;
    }
    while((_Bool)1);
    tmp_post_10 = nvalbuf;
    nvalbuf = nvalbuf + 1;
    valbuf[(signed long int)tmp_post_10] = (char)0;
    opt = optbuf;
    val=atoi_link1(valbuf);
    lglprt(lgl, 1, "read option --%s=%d", opt, val);
    lglsetopt(lgl, opt, val);
    res = res + 1;
  }
  while((_Bool)1);
  return res;
}

// lglredstk
// file lglib.c line 1456
static void lglredstk(struct LGL *lgl, struct Stk *s, signed int minsize, signed int pow2smaller)
{
  unsigned long int oldsize;
  unsigned long int count;
  unsigned long int limit;
  unsigned long int newsize;
  oldsize=lglszstk(s);
  if(!((unsigned long int)minsize >= oldsize))
  {
    count=lglcntstk(s);
    limit = oldsize >> pow2smaller;
    if(limit >= count)
    {
      newsize = oldsize / (unsigned long int)2;
      if(newsize >= 1ul)
      {
        do
        {
          void *return_value_lglrsz_1;
          return_value_lglrsz_1=lglrsz(lgl, (void *)s->start, oldsize * sizeof(signed int) /*4ul*/ , newsize * sizeof(signed int) /*4ul*/ );
          s->start = (signed int *)return_value_lglrsz_1;
        }
        while((_Bool)0);
        s->top = s->start + (signed long int)count;
        s->end = s->start + (signed long int)newsize;
      }

      else
        lglrelstk(lgl, s);
    }

  }

}

// lglreduce
// file lglib.c line 5281
static void lglreduce(struct LGL *lgl, signed int forced)
{
  signed int *p;
  signed int *q;
  signed int *lglreduce__1__start;
  signed int *c;
  signed int **maps;
  signed int *sizes;
  signed int *map;
  signed int *eow;
  signed int *rsn;
  signed int nlocked;
  signed int collected;
  signed int sumcollected;
  signed int nunlocked;
  signed int moved;
  signed int act;
  signed int glue;
  signed int minredglue;
  signed int maxredglue;
  signed int target;
  signed int rem;
  signed int nkeep;
  signed int inc;
  signed int acts;
  signed int glueuseless;
  signed int needmoreclauses;
  signed int delta;
  struct ASL *asls;
  struct ASL *asl;
  signed int nasls;
  signed int szasls;
  signed int size;
  signed int idx;
  signed int tag;
  signed int red;
  signed int i;
  signed int blit;
  signed int r0;
  signed int lidx;
  signed int src;
  signed int dst;
  signed int lit;
  char type = (char)45;
  signed long int outer;
  struct HTS *hts;
  struct DVar *dv;
  struct Stk *lir;
  lglchkred(lgl);
  lglstart(lgl, &lgl->times->red);
  lgl->stats->reduced.count = lgl->stats->reduced.count + 1;

__CPROVER_DUMP_L1:
  ;
  acts=lglneedacts(lgl, &glueuseless, &needmoreclauses);
  delta = lgl->stats->red.lrg;
  delta = delta - lgl->lrgluereasons;
  if(!((3 * lgl->limits->reduce.inner) / 2 >= delta))
    target = delta - lgl->limits->reduce.inner / 2;

  else
    target = delta / 2;
  rem = target;

__CPROVER_DUMP_L4:
  ;
  maxredglue = ((1 << 4) - 1) - 1;
  for( ; maxredglue >= 0; maxredglue = maxredglue - 1)
    if(lgl->stats->lir[(signed long int)maxredglue].clauses >= 1)
      break;


__CPROVER_DUMP_L6:
  ;
  if(!(lgl->opts->acts.val >= 2))
    acts = lgl->opts->acts.val;

  if(!(acts == 0))
  {
    lgl->stats->acts = lgl->stats->acts + 1;
    lglprt(lgl, 2, "[needacts-%d] using primarily activities for reduction", lgl->stats->reduced);
    szasls = lgl->stats->red.lrg;
    minredglue = 1;
  }

  else
  {
    lglprt(lgl, 2, "[needacts-%d] using primarily glues for reduction", lgl->stats->reduced);
    asls = ((struct ASL *)NULL);
    if(maxredglue >= 1)
    {
      minredglue = maxredglue;
      for( ; minredglue >= 2; minredglue = minredglue - 1)
      {

      __CPROVER_DUMP_L10:
        ;
        if(lgl->stats->lir[(signed long int)minredglue].clauses >= rem)
          break;

        rem = rem - lgl->stats->lir[(signed long int)minredglue].clauses;
      }
    }

    else
      minredglue = 1;
    szasls = lgl->stats->lir[(signed long int)minredglue].clauses;
  }

__CPROVER_DUMP_L14:
  ;
  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)(maxredglue + 1) * sizeof(signed int *) /*8ul*/ );
    maps = (signed int **)return_value_lglnew_1;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew_2;
    return_value_lglnew_2=lglnew(lgl, (unsigned long int)(maxredglue + 1) * sizeof(signed int) /*4ul*/ );
    sizes = (signed int *)return_value_lglnew_2;
  }
  while((_Bool)0);
  glue = minredglue;
  for( ; maxredglue >= glue; glue = glue + 1)
  {
    lir = lgl->red + (signed long int)glue;
    unsigned long int return_value_lglcntstk_3;
    return_value_lglcntstk_3=lglcntstk(lir);
    size = (signed int)return_value_lglcntstk_3;
    size = (size + 5) / 6;
    sizes[(signed long int)glue] = size;
    lglfitstk(lgl, lir);
    do
    {
      void *return_value_lglnew_4;
      return_value_lglnew_4=lglnew(lgl, (unsigned long int)size * sizeof(signed int) /*4ul*/ );
      maps[(signed long int)glue] = (signed int *)return_value_lglnew_4;
    }
    while((_Bool)0);
    map = maps[(signed long int)glue];
    i = 0;
    for( ; !(i >= size); i = i + 1)
      map[(signed long int)i] = -2;
  }
  nlocked = 0;
  i = 0;
  unsigned long int return_value_lglcntstk_5;
  do
  {
    return_value_lglcntstk_5=lglcntstk(&lgl->trail);
    if((unsigned long int)i >= return_value_lglcntstk_5)
      break;

    lit=lglpeek(&lgl->trail, i);
    idx=abs(lit);
    rsn=lglrsn(lgl, idx);
    r0 = rsn[(signed long int)0];
    red = r0 & REDCS;
    if(!(red == 0))
    {
      tag = r0 & MASKCS;
      if(tag == LRGCS)
      {
        lidx = rsn[(signed long int)1];
        glue = lidx & (1 << 4) - 1;
        if(!(glue == 15))
        {
          if(glue >= minredglue)
          {
            if(maxredglue >= glue)
            {
              lidx = lidx >> 4;
              lidx = lidx / 6;
              maps[(signed long int)glue][(signed long int)lidx] = -1;
              nlocked = nlocked + 1;
            }

          }

        }

      }

    }

    i = i + 1;
  }
  while((_Bool)1);

__CPROVER_DUMP_L25:
  ;
  do
  {
    void *return_value_lglnew_6;
    return_value_lglnew_6=lglnew(lgl, (unsigned long int)szasls * sizeof(struct ASL) /*12ul*/ );
    asls = (struct ASL *)return_value_lglnew_6;
  }
  while((_Bool)0);
  nasls = 0;
  glue = minredglue;
  _Bool tmp_if_expr_7;
  signed int tmp_post_8;
  for( ; maxredglue >= glue; glue = glue + 1)
  {
    lir = lgl->red + (signed long int)glue;
    lglreduce__1__start = lir->start;
    c = lglreduce__1__start;
    for( ; !(c >= lir->top); c = p + (signed long int)1)
    {
      act = *c;
      if(act == 0x7fffffff)
      {
        p = c + (signed long int)1;
        do
        {
          if(!(p >= lir->top))
            tmp_if_expr_7 = *p == 0x7fffffff ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_7 = (_Bool)0;
          if(!tmp_if_expr_7)
            break;

          p = p + 1l;
        }
        while((_Bool)1);
        p = p - 1l;
      }

      else
      {
        c = c + 1l;
        p = c;
        for( ; !(*p == 0); p = p + 1l)
          ;
        tmp_post_8 = nasls;
        nasls = nasls + 1;
        asl = asls + (signed long int)tmp_post_8;
        asl->act = act;
        asl->size = (signed int)(p - c);
        asl->lidx = (signed int)(c - lglreduce__1__start << 4 | (signed long int)glue);
      }
    }
    if(acts == 0)
      break;

  }
  signed int return_value_lglcmpasgl_13;
  signed int return_value_lglmtstk_14;
  signed int return_value_lglcmpasgl_16;
  signed int return_value_lglcmpagsl_21;
  signed int return_value_lglmtstk_22;
  signed int return_value_lglcmpagsl_24;
  if(!(glueuseless == 0))
    do
    {
      struct ASL *lglreduce__1__15__AA = asls;
      signed int lglreduce__1__15__NN = nasls;
      do
      {
        signed int lglreduce__1__15__1__L = 0;
        signed int lglreduce__1__15__1__R = lglreduce__1__15__NN - 1;
        signed int lglreduce__1__15__1__M;
        signed int LL;
        signed int RR;
        signed int I;
        if(!(lglreduce__1__15__1__R + -lglreduce__1__15__1__L >= 11))
          break;

        do
        {
          lglreduce__1__15__1__M = (lglreduce__1__15__1__L + lglreduce__1__15__1__R) / 2;
          do
          {
            struct ASL TMP = lglreduce__1__15__AA[(signed long int)lglreduce__1__15__1__M];
            lglreduce__1__15__AA[(signed long int)lglreduce__1__15__1__M] = lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__1__R - 1)];
            lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__1__R - 1)] = TMP;
          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpasgl_9;
            return_value_lglcmpasgl_9=lglcmpasgl(&lglreduce__1__15__AA[(signed long int)lglreduce__1__15__1__L], &lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__1__R - 1)]);
            if(return_value_lglcmpasgl_9 >= 1)
              do
              {
                struct ASL lglreduce__1__15__1__1__1__2__1__TMP = lglreduce__1__15__AA[(signed long int)lglreduce__1__15__1__L];
                lglreduce__1__15__AA[(signed long int)lglreduce__1__15__1__L] = lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__1__R - 1)];
                lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__1__R - 1)] = lglreduce__1__15__1__1__1__2__1__TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpasgl_10;
            return_value_lglcmpasgl_10=lglcmpasgl(&lglreduce__1__15__AA[(signed long int)lglreduce__1__15__1__L], &lglreduce__1__15__AA[(signed long int)lglreduce__1__15__1__R]);
            if(return_value_lglcmpasgl_10 >= 1)
              do
              {
                struct ASL lglreduce__1__15__1__1__1__3__1__TMP = lglreduce__1__15__AA[(signed long int)lglreduce__1__15__1__L];
                lglreduce__1__15__AA[(signed long int)lglreduce__1__15__1__L] = lglreduce__1__15__AA[(signed long int)lglreduce__1__15__1__R];
                lglreduce__1__15__AA[(signed long int)lglreduce__1__15__1__R] = lglreduce__1__15__1__1__1__3__1__TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpasgl_11;
            return_value_lglcmpasgl_11=lglcmpasgl(&lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__1__R - 1)], &lglreduce__1__15__AA[(signed long int)lglreduce__1__15__1__R]);
            if(return_value_lglcmpasgl_11 >= 1)
              do
              {
                struct ASL lglreduce__1__15__1__1__1__4__1__TMP = lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__1__R - 1)];
                lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__1__R - 1)] = lglreduce__1__15__AA[(signed long int)lglreduce__1__15__1__R];
                lglreduce__1__15__AA[(signed long int)lglreduce__1__15__1__R] = lglreduce__1__15__1__1__1__4__1__TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            struct ASL PIVOT;
            signed int J = lglreduce__1__15__1__R - 1;
            I = (lglreduce__1__15__1__L + 1) - 1;
            PIVOT = lglreduce__1__15__AA[(signed long int)J];
            do
            {

            __CPROVER_DUMP_L54:
              ;
              I = I + 1;
              signed int return_value_lglcmpasgl_12;
              return_value_lglcmpasgl_12=lglcmpasgl(&lglreduce__1__15__AA[(signed long int)I], &PIVOT);
              if(!(return_value_lglcmpasgl_12 >= 0))
                goto __CPROVER_DUMP_L54;

              do
              {
                J = J - 1;
                return_value_lglcmpasgl_13=lglcmpasgl(&PIVOT, &lglreduce__1__15__AA[(signed long int)J]);
                if(return_value_lglcmpasgl_13 >= 0)
                  break;

                if(J == 1 + lglreduce__1__15__1__L)
                  break;

              }
              while((_Bool)1);
              if(I >= J)
                break;

              do
              {
                struct ASL lglreduce__1__15__1__1__1__5__1__1__1__TMP = lglreduce__1__15__AA[(signed long int)I];
                lglreduce__1__15__AA[(signed long int)I] = lglreduce__1__15__AA[(signed long int)J];
                lglreduce__1__15__AA[(signed long int)J] = lglreduce__1__15__1__1__1__5__1__1__1__TMP;
              }
              while((_Bool)0);
            }
            while((_Bool)1);
            do
            {
              struct ASL lglreduce__1__15__1__1__1__5__2__TMP = lglreduce__1__15__AA[(signed long int)I];
              lglreduce__1__15__AA[(signed long int)I] = lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__1__R - 1)];
              lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__1__R - 1)] = lglreduce__1__15__1__1__1__5__2__TMP;
            }
            while((_Bool)0);
          }
          while((_Bool)0);
          if(!(I + -lglreduce__1__15__1__L >= lglreduce__1__15__1__R + -I))
          {
            LL = I + 1;
            RR = lglreduce__1__15__1__R;
            lglreduce__1__15__1__R = I - 1;
          }

          else
          {
            LL = lglreduce__1__15__1__L;
            RR = I - 1;
            lglreduce__1__15__1__L = I + 1;
          }
          if(lglreduce__1__15__1__R + -lglreduce__1__15__1__L >= 11)
          {
            lglpushstk(lgl, &lgl->_anon1.sortstk, LL);
            lglpushstk(lgl, &lgl->_anon1.sortstk, RR);
          }

          else
            if(RR + -LL >= 11)
            {
              lglreduce__1__15__1__L = LL;
              lglreduce__1__15__1__R = RR;
            }

            else
            {
              return_value_lglmtstk_14=lglmtstk(&lgl->_anon1.sortstk);
              if(return_value_lglmtstk_14 == 0)
              {
                lglreduce__1__15__1__R=lglpopstk(&lgl->_anon1.sortstk);
                lglreduce__1__15__1__L=lglpopstk(&lgl->_anon1.sortstk);
              }

              else
                break;
            }
        }
        while((_Bool)1);
      }
      while((_Bool)0);
      do
      {
        struct ASL lglreduce__1__15__2__PIVOT;
        signed int L = 0;
        signed int R = lglreduce__1__15__NN - 1;
        signed int lglreduce__1__15__2__I;
        signed int lglreduce__1__15__2__J;
        lglreduce__1__15__2__I = R;
        for( ; !(L >= lglreduce__1__15__2__I); lglreduce__1__15__2__I = lglreduce__1__15__2__I - 1)
          do
          {
            signed int return_value_lglcmpasgl_15;
            return_value_lglcmpasgl_15=lglcmpasgl(&lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__2__I - 1)], &lglreduce__1__15__AA[(signed long int)lglreduce__1__15__2__I]);
            if(return_value_lglcmpasgl_15 >= 1)
              do
              {
                struct ASL lglreduce__1__15__2__1__1__1__TMP = lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__2__I - 1)];
                lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__2__I - 1)] = lglreduce__1__15__AA[(signed long int)lglreduce__1__15__2__I];
                lglreduce__1__15__AA[(signed long int)lglreduce__1__15__2__I] = lglreduce__1__15__2__1__1__1__TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
        lglreduce__1__15__2__I = L + 2;
        for( ; R >= lglreduce__1__15__2__I; lglreduce__1__15__2__I = lglreduce__1__15__2__I + 1)
        {
          lglreduce__1__15__2__J = lglreduce__1__15__2__I;
          lglreduce__1__15__2__PIVOT = lglreduce__1__15__AA[(signed long int)lglreduce__1__15__2__I];
          do
          {
            return_value_lglcmpasgl_16=lglcmpasgl(&lglreduce__1__15__2__PIVOT, &lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__2__J - 1)]);
            if(return_value_lglcmpasgl_16 >= 0)
              break;

            lglreduce__1__15__AA[(signed long int)lglreduce__1__15__2__J] = lglreduce__1__15__AA[(signed long int)(lglreduce__1__15__2__J - 1)];
            lglreduce__1__15__2__J = lglreduce__1__15__2__J - 1;
          }
          while((_Bool)1);
          lglreduce__1__15__AA[(signed long int)lglreduce__1__15__2__J] = lglreduce__1__15__2__PIVOT;
        }
      }
      while((_Bool)0);

    __CPROVER_DUMP_L76:
      ;
    }
    while((_Bool)0);

  else
    do
    {
      struct ASL *AA = asls;
      signed int NN = nasls;
      do
      {
        signed int lglreduce__1__16__1__L = 0;
        signed int lglreduce__1__16__1__R = NN - 1;
        signed int M;
        signed int lglreduce__1__16__1__LL;
        signed int lglreduce__1__16__1__RR;
        signed int lglreduce__1__16__1__I;
        if(!(lglreduce__1__16__1__R + -lglreduce__1__16__1__L >= 11))
          break;

        do
        {
          M = (lglreduce__1__16__1__L + lglreduce__1__16__1__R) / 2;
          do
          {
            struct ASL lglreduce__1__16__1__1__1__1__TMP = AA[(signed long int)M];
            AA[(signed long int)M] = AA[(signed long int)(lglreduce__1__16__1__R - 1)];
            AA[(signed long int)(lglreduce__1__16__1__R - 1)] = lglreduce__1__16__1__1__1__1__TMP;
          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpagsl_17;
            return_value_lglcmpagsl_17=lglcmpagsl(&AA[(signed long int)lglreduce__1__16__1__L], &AA[(signed long int)(lglreduce__1__16__1__R - 1)]);
            if(return_value_lglcmpagsl_17 >= 1)
              do
              {
                struct ASL lglreduce__1__16__1__1__1__2__1__TMP = AA[(signed long int)lglreduce__1__16__1__L];
                AA[(signed long int)lglreduce__1__16__1__L] = AA[(signed long int)(lglreduce__1__16__1__R - 1)];
                AA[(signed long int)(lglreduce__1__16__1__R - 1)] = lglreduce__1__16__1__1__1__2__1__TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpagsl_18;
            return_value_lglcmpagsl_18=lglcmpagsl(&AA[(signed long int)lglreduce__1__16__1__L], &AA[(signed long int)lglreduce__1__16__1__R]);
            if(return_value_lglcmpagsl_18 >= 1)
              do
              {
                struct ASL lglreduce__1__16__1__1__1__3__1__TMP = AA[(signed long int)lglreduce__1__16__1__L];
                AA[(signed long int)lglreduce__1__16__1__L] = AA[(signed long int)lglreduce__1__16__1__R];
                AA[(signed long int)lglreduce__1__16__1__R] = lglreduce__1__16__1__1__1__3__1__TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpagsl_19;
            return_value_lglcmpagsl_19=lglcmpagsl(&AA[(signed long int)(lglreduce__1__16__1__R - 1)], &AA[(signed long int)lglreduce__1__16__1__R]);
            if(return_value_lglcmpagsl_19 >= 1)
              do
              {
                struct ASL lglreduce__1__16__1__1__1__4__1__TMP = AA[(signed long int)(lglreduce__1__16__1__R - 1)];
                AA[(signed long int)(lglreduce__1__16__1__R - 1)] = AA[(signed long int)lglreduce__1__16__1__R];
                AA[(signed long int)lglreduce__1__16__1__R] = lglreduce__1__16__1__1__1__4__1__TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            struct ASL lglreduce__1__16__1__1__1__5__PIVOT;
            signed int lglreduce__1__16__1__1__1__5__J = lglreduce__1__16__1__R - 1;
            lglreduce__1__16__1__I = (lglreduce__1__16__1__L + 1) - 1;
            lglreduce__1__16__1__1__1__5__PIVOT = AA[(signed long int)lglreduce__1__16__1__1__1__5__J];
            do
            {

            __CPROVER_DUMP_L91:
              ;
              lglreduce__1__16__1__I = lglreduce__1__16__1__I + 1;
              signed int return_value_lglcmpagsl_20;
              return_value_lglcmpagsl_20=lglcmpagsl(&AA[(signed long int)lglreduce__1__16__1__I], &lglreduce__1__16__1__1__1__5__PIVOT);
              if(!(return_value_lglcmpagsl_20 >= 0))
                goto __CPROVER_DUMP_L91;

              do
              {
                lglreduce__1__16__1__1__1__5__J = lglreduce__1__16__1__1__1__5__J - 1;
                return_value_lglcmpagsl_21=lglcmpagsl(&lglreduce__1__16__1__1__1__5__PIVOT, &AA[(signed long int)lglreduce__1__16__1__1__1__5__J]);
                if(return_value_lglcmpagsl_21 >= 0)
                  break;

                if(lglreduce__1__16__1__1__1__5__J == 1 + lglreduce__1__16__1__L)
                  break;

              }
              while((_Bool)1);
              if(lglreduce__1__16__1__I >= lglreduce__1__16__1__1__1__5__J)
                break;

              do
              {
                struct ASL lglreduce__1__16__1__1__1__5__1__1__1__TMP = AA[(signed long int)lglreduce__1__16__1__I];
                AA[(signed long int)lglreduce__1__16__1__I] = AA[(signed long int)lglreduce__1__16__1__1__1__5__J];
                AA[(signed long int)lglreduce__1__16__1__1__1__5__J] = lglreduce__1__16__1__1__1__5__1__1__1__TMP;
              }
              while((_Bool)0);
            }
            while((_Bool)1);
            do
            {
              struct ASL lglreduce__1__16__1__1__1__5__2__TMP = AA[(signed long int)lglreduce__1__16__1__I];
              AA[(signed long int)lglreduce__1__16__1__I] = AA[(signed long int)(lglreduce__1__16__1__R - 1)];
              AA[(signed long int)(lglreduce__1__16__1__R - 1)] = lglreduce__1__16__1__1__1__5__2__TMP;
            }
            while((_Bool)0);
          }
          while((_Bool)0);
          if(!(lglreduce__1__16__1__I + -lglreduce__1__16__1__L >= lglreduce__1__16__1__R + -lglreduce__1__16__1__I))
          {
            lglreduce__1__16__1__LL = lglreduce__1__16__1__I + 1;
            lglreduce__1__16__1__RR = lglreduce__1__16__1__R;
            lglreduce__1__16__1__R = lglreduce__1__16__1__I - 1;
          }

          else
          {
            lglreduce__1__16__1__LL = lglreduce__1__16__1__L;
            lglreduce__1__16__1__RR = lglreduce__1__16__1__I - 1;
            lglreduce__1__16__1__L = lglreduce__1__16__1__I + 1;
          }
          if(lglreduce__1__16__1__R + -lglreduce__1__16__1__L >= 11)
          {
            lglpushstk(lgl, &lgl->_anon1.sortstk, lglreduce__1__16__1__LL);
            lglpushstk(lgl, &lgl->_anon1.sortstk, lglreduce__1__16__1__RR);
          }

          else
            if(lglreduce__1__16__1__RR + -lglreduce__1__16__1__LL >= 11)
            {
              lglreduce__1__16__1__L = lglreduce__1__16__1__LL;
              lglreduce__1__16__1__R = lglreduce__1__16__1__RR;
            }

            else
            {
              return_value_lglmtstk_22=lglmtstk(&lgl->_anon1.sortstk);
              if(return_value_lglmtstk_22 == 0)
              {
                lglreduce__1__16__1__R=lglpopstk(&lgl->_anon1.sortstk);
                lglreduce__1__16__1__L=lglpopstk(&lgl->_anon1.sortstk);
              }

              else
                break;
            }
        }
        while((_Bool)1);
      }
      while((_Bool)0);
      do
      {
        struct ASL lglreduce__1__16__2__PIVOT;
        signed int lglreduce__1__16__2__L = 0;
        signed int lglreduce__1__16__2__R = NN - 1;
        signed int lglreduce__1__16__2__I;
        signed int lglreduce__1__16__2__J;
        lglreduce__1__16__2__I = lglreduce__1__16__2__R;
        for( ; !(lglreduce__1__16__2__L >= lglreduce__1__16__2__I); lglreduce__1__16__2__I = lglreduce__1__16__2__I - 1)
          do
          {
            signed int return_value_lglcmpagsl_23;
            return_value_lglcmpagsl_23=lglcmpagsl(&AA[(signed long int)(lglreduce__1__16__2__I - 1)], &AA[(signed long int)lglreduce__1__16__2__I]);
            if(return_value_lglcmpagsl_23 >= 1)
              do
              {
                struct ASL lglreduce__1__16__2__1__1__1__TMP = AA[(signed long int)(lglreduce__1__16__2__I - 1)];
                AA[(signed long int)(lglreduce__1__16__2__I - 1)] = AA[(signed long int)lglreduce__1__16__2__I];
                AA[(signed long int)lglreduce__1__16__2__I] = lglreduce__1__16__2__1__1__1__TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
        lglreduce__1__16__2__I = lglreduce__1__16__2__L + 2;
        for( ; lglreduce__1__16__2__R >= lglreduce__1__16__2__I; lglreduce__1__16__2__I = lglreduce__1__16__2__I + 1)
        {
          lglreduce__1__16__2__J = lglreduce__1__16__2__I;
          lglreduce__1__16__2__PIVOT = AA[(signed long int)lglreduce__1__16__2__I];
          do
          {
            return_value_lglcmpagsl_24=lglcmpagsl(&lglreduce__1__16__2__PIVOT, &AA[(signed long int)(lglreduce__1__16__2__J - 1)]);
            if(return_value_lglcmpagsl_24 >= 0)
              break;

            AA[(signed long int)lglreduce__1__16__2__J] = AA[(signed long int)(lglreduce__1__16__2__J - 1)];
            lglreduce__1__16__2__J = lglreduce__1__16__2__J - 1;
          }
          while((_Bool)1);
          AA[(signed long int)lglreduce__1__16__2__J] = lglreduce__1__16__2__PIVOT;
        }
      }
      while((_Bool)0);

    __CPROVER_DUMP_L113:
      ;
    }
    while((_Bool)0);

__CPROVER_DUMP_L114:
  ;
  nkeep = 0;
  idx = rem;
  for( ; !(idx >= nasls); idx = idx + 1)
  {
    asl = asls + (signed long int)idx;
    lidx = asl->lidx;
    glue = lidx & (1 << 4) - 1;
    lidx = lidx >> 4;
    lidx = lidx / 6;
    maps[(signed long int)glue][(signed long int)lidx] = -1;
    nkeep = nkeep + 1;
  }
  do
  {
    lgldel(lgl, (void *)asls, (unsigned long int)szasls * sizeof(struct ASL) /*12ul*/ );
    asls = ((struct ASL *)NULL);
  }
  while((_Bool)0);

__CPROVER_DUMP_L117:
  ;
  sumcollected = 0;
  glue = minredglue;
  signed int *tmp_post_25;
  _Bool tmp_if_expr_26;
  signed int *tmp_post_27;
  signed int *tmp_post_28;
  signed int *tmp_post_29;
  signed int *tmp_post_30;
  for( ; maxredglue >= glue; glue = glue + 1)
  {
    lir = lgl->red + (signed long int)glue;
    map = maps[(signed long int)glue];
    lglreduce__1__start = lir->start;
    q = lglreduce__1__start;
    collected = 0;
    c = lglreduce__1__start;
    for( ; !(c >= lir->top); c = p + (signed long int)1)
    {
      tmp_post_25 = c;
      c = c + 1l;
      act = *tmp_post_25;
      if(act == 0x7fffffff)
      {
        p = c;
        do
        {
          if(!(p >= lir->top))
            tmp_if_expr_26 = *p == 0x7fffffff ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_26 = (_Bool)0;
          if(!tmp_if_expr_26)
            break;

          p = p + 1l;
        }
        while((_Bool)1);
        p = p - 1l;
      }

      else
      {
        p = c;

      __CPROVER_DUMP_L125:
        ;
        src = (signed int)((c - lglreduce__1__start) / (signed long int)6);
        if(map[(signed long int)src] == -2)
        {
          collected = collected + 1;

        __CPROVER_DUMP_L126:
          ;
          for( ; !(*p == 0); p = p + 1l)
            ;
        }

        else
        {
          dst = (signed int)((q - lglreduce__1__start) + (signed long int)1);
          map[(signed long int)src] = dst;
          if(p == q)
          {
            for( ; !(*p == 0); p = p + 1l)
              ;
            q = p + (signed long int)1;
          }

          else
          {
            tmp_post_27 = q;
            q = q + 1l;
            *tmp_post_27 = act;

          __CPROVER_DUMP_L133:
            ;
            for( ; !(*p == 0); *tmp_post_28 = *tmp_post_29)
            {
              tmp_post_28 = q;
              q = q + 1l;
              tmp_post_29 = p;
              p = p + 1l;
            }
            tmp_post_30 = q;
            q = q + 1l;
            *tmp_post_30 = 0;
          }
        }
      }
    }

  __CPROVER_DUMP_L137:
    ;
    sumcollected = sumcollected + collected;
    lgl->stats->lir[(signed long int)glue].clauses = lgl->stats->lir[(signed long int)glue].clauses - collected;
    lgl->stats->lir[(signed long int)glue].reduced = lgl->stats->lir[(signed long int)glue].reduced + (signed long int)collected;
    lir->top = q;
    lglfitlir(lgl, lir);
  }

__CPROVER_DUMP_L138:
  ;
  lgl->stats->red.lrg = lgl->stats->red.lrg - sumcollected;
  nunlocked = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed char return_value_lglval_31;
    return_value_lglval_31=lglval(lgl, idx);
    if(!(return_value_lglval_31 == 0))
    {
      rsn=lglrsn(lgl, idx);
      r0 = rsn[(signed long int)0];
      red = r0 & REDCS;
      if(!(red == 0))
      {
        tag = r0 & MASKCS;
        if(tag == LRGCS)
        {
          lidx = rsn[(signed long int)1];
          glue = lidx & (1 << 4) - 1;
          if(glue >= minredglue)
          {
            if(maxredglue >= glue)
            {
              src = lidx >> 4;
              dst = maps[(signed long int)glue][(signed long int)(src / 6)];
              dst = dst << 4;
              dst = dst | lidx & (1 << 4) - 1;
              rsn[(signed long int)1] = dst;
              nunlocked = nunlocked + 1;
            }

          }

        }

      }

    }

  }

__CPROVER_DUMP_L145:
  ;
  moved = 0;
  collected = moved;
  idx = 2;
  signed int *tmp_post_32;
  signed int *tmp_post_33;
  signed int *tmp_post_34;
  signed int *tmp_post_35;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    dv=lgldvar(lgl, idx);
    i = 0;
    for( ; !(i >= 2); i = i + 1)
    {
      hts = dv->hts + (signed long int)i;
      if(!(hts->offset == 0))
      {
        q=lglhts2wchs(lgl, hts);
        eow = q + (signed long int)hts->count;
        p = q;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          red = blit & REDCS;
          tag = blit & MASKCS;
          if(tag == LRGCS && !(red == 0))
          {
            p = p + 1l;
            lidx = *p;
            glue = lidx & (1 << 4) - 1;
            if(!(glue >= minredglue) || !(maxredglue >= glue))
              dst = lidx >> 4;

            else
            {
              src = lidx >> 4;
              dst = maps[(signed long int)glue][(signed long int)(src / 6)];
            }
            if(dst >= 0)
            {
              moved = moved + 1;
              tmp_post_32 = q;
              q = q + 1l;
              *tmp_post_32 = blit;
              tmp_post_33 = q;
              q = q + 1l;
              *tmp_post_33 = dst << 4 | lidx & (1 << 4) - 1;
            }

            else
              collected = collected + 1;
          }

          else
          {
            tmp_post_34 = q;
            q = q + 1l;
            *tmp_post_34 = blit;
            if(!(tag == BINCS))
            {
              tmp_post_35 = q;
              q = q + 1l;
              p = p + 1l;
              *tmp_post_35 = *p;
            }

          }
        }
        lglshrinkhts(lgl, hts, (signed int)((signed long int)hts->count - (p - q)));
      }

    }
  }

__CPROVER_DUMP_L158:
  ;
  glue = minredglue;
  for( ; maxredglue >= glue; glue = glue + 1)
    do
    {
      lgldel(lgl, (void *)maps[(signed long int)glue], (unsigned long int)sizes[(signed long int)glue] * sizeof(signed int) /*4ul*/ );
      maps[(signed long int)glue] = ((signed int *)NULL);
    }
    while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)sizes, (unsigned long int)(maxredglue + 1) * sizeof(signed int) /*4ul*/ );
    sizes = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)maps, (unsigned long int)(maxredglue + 1) * sizeof(signed int *) /*8ul*/ );
    maps = ((signed int **)NULL);
  }
  while((_Bool)0);
  _Bool tmp_if_expr_38;
  if(lgl->opts->redfixed.val == 0)
  {
    if(needmoreclauses == 0)
    {
      inc = lgl->opts->redlinc.val;
      lglprt(lgl, 2, "arithmetic increase of reduce limit");
      lgl->stats->reduced.arith = lgl->stats->reduced.arith + 1;
    }

    else
      if(needmoreclauses == 1)
      {
        inc = 2 * lgl->opts->redlinc.val;
        lglprt(lgl, 2, "double arithmetic increase of reduce limit");
        lgl->stats->reduced.arith2 = lgl->stats->reduced.arith2 + 1;
        lgl->stats->reduced.arith = lgl->stats->reduced.arith + 1;
      }

      else
      {
        inc = (lgl->opts->redlexpfac.val * lgl->limits->reduce.inner + 99) / 100;
        if(inc == 0)
          inc = inc + 1;

        lglprt(lgl, 2, "exponential increase of reduce limit");
        lgl->stats->reduced.geom = lgl->stats->reduced.geom + 1;
      }

  __CPROVER_DUMP_L166:
    ;
    lgl->limits->reduce.inner = lgl->limits->reduce.inner + inc;
    if(lgl->opts->reduce.val >= 2)
      tmp_if_expr_38 = lgl->limits->reduce.inner >= lgl->limits->reduce.outer ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_38 = (_Bool)0;
    if(tmp_if_expr_38)
    {
      type = (char)47;
      lgl->stats->reduced.reset = lgl->stats->reduced.reset + 1;
      lgl->limits->reduce.inner = lgl->opts->redlinit.val;
      lglboundredl(lgl);
      if(lgl->opts->reduce.val == 2)
      {
        outer = (signed long int)lgl->limits->reduce.inner;
        outer = outer << lgl->opts->redldoutfac.val;
        signed long int return_value_lgluby_36;
        return_value_lgluby_36=lgluby(lgl, lgl->stats->reduced.reset);
        outer = outer * return_value_lgluby_36;
      }

      else
        if(lgl->opts->reduce.val == 3)
        {
          outer = (signed long int)lgl->limits->reduce.inner;
          outer = outer << lgl->opts->redldoutfac.val;
          signed long int return_value_lglinout_37;
          return_value_lglinout_37=lglinout(lgl, lgl->stats->reduced.reset, lgl->opts->redinoutinc.val);
          outer = outer * return_value_lglinout_37;
        }

        else
        {
          outer = (signed long int)(lgl->limits->reduce.outer + lgl->opts->redloutinc.val);
          if(!(outer >= (signed long int)lgl->limits->reduce.inner))
            outer = (signed long int)lgl->limits->reduce.inner;

        }
      if(outer >= 2147483648l)
        outer = (signed long int)0x7fffffff;

      lgl->limits->reduce.outer = (signed int)outer;
    }

    else
      lglboundredl(lgl);
  }


NOINC:
  ;
  lglrep(lgl, 1, type);
  lglchkred(lgl);
  lglstop(lgl);
}

// lglreducing
// file lglib.c line 16979
static signed int lglreducing(struct LGL *lgl)
{
  signed int lrg;
  signed int lrglue;
  if(lgl->opts->reduce.val == 0)
    return 0;

  else
  {
    lrg = lgl->stats->red.lrg;
    lrglue = lgl->lrgluereasons;
    return (signed int)(lrg - lrglue >= lgl->limits->reduce.inner);
  }
}

// lglredvars
// file lglib.c line 2300
static void lglredvars(struct LGL *lgl)
{
  unsigned long int old_size;
  unsigned long int new_size;
  old_size = (unsigned long int)lgl->szvars;
  new_size = (unsigned long int)lgl->nvars;
  if(!(new_size == old_size))
  {

  __CPROVER_DUMP_L1:
    ;
    lglrszvars(lgl, (signed int)new_size);
  }

}

// lglregularly
// file lglib.c line 17087
static void lglregularly(struct LGL *lgl)
{
  signed int return_value_lglreducing_1;
  return_value_lglreducing_1=lglreducing(lgl);
  if(!(return_value_lglreducing_1 == 0))
    lglreduce(lgl, 0);

  signed int return_value_lgldefragmenting_2;
  return_value_lgldefragmenting_2=lgldefragmenting(lgl);
  if(!(return_value_lgldefragmenting_2 == 0))
    lgldefrag(lgl);

}

// lglrelctk
// file lglib.c line 1546
static void lglrelctk(struct LGL *lgl, struct Ctk *ctk)
{
  do
  {
    signed int return_value_lglsizectk_1;
    return_value_lglsizectk_1=lglsizectk(ctk);
    lgldel(lgl, (void *)ctk->start, (unsigned long int)return_value_lglsizectk_1 * sizeof(struct Ctr) /*4ul*/ );
    ctk->start = ((struct Ctr *)NULL);
  }
  while((_Bool)0);
  memset((void *)ctk, 0, sizeof(struct Ctk) /*24ul*/ );
}

// lglrelease
// file lglib.h line 24
void lglrelease(struct LGL *lgl)
{
  void (*dealloc)(void *, void *, unsigned long int);
  signed int i;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglrelease");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  if(!(lgl->clone == ((struct LGL *)NULL)))
  {
    lglrelease(lgl->clone);
    lgl->clone = ((struct LGL *)NULL);
  }

  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "release");
    break;
  }
  do
  {
    lgldel(lgl, (void *)lgl->avars, (unsigned long int)lgl->szvars * sizeof(struct AVar) /*12ul*/ );
    lgl->avars = ((struct AVar *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->drail, (unsigned long int)lgl->szdrail * sizeof(struct TD) /*12ul*/ );
    lgl->drail = ((struct TD *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->dvars, (unsigned long int)lgl->szvars * sizeof(struct DVar) /*16ul*/ );
    lgl->dvars = ((struct DVar *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->ext, (unsigned long int)lgl->szext * sizeof(struct Ext) /*32ul*/ );
    lgl->ext = ((struct Ext *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->i2e, (unsigned long int)lgl->szvars * sizeof(signed int) /*4ul*/ );
    lgl->i2e = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->doms, (unsigned long int)(2 * lgl->szvars) * sizeof(signed int) /*4ul*/ );
    lgl->doms = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->jwh, (unsigned long int)(2 * lgl->szvars) * sizeof(signed long int) /*8ul*/ );
    lgl->jwh = ((signed long int *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->queue.nodes, (unsigned long int)lgl->szvars * sizeof(struct Qnd) /*16ul*/ );
    lgl->queue.nodes = ((struct Qnd *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->vals, (unsigned long int)lgl->szvars * sizeof(signed char) /*1ul*/ );
    lgl->vals = ((signed char *)NULL);
  }
  while((_Bool)0);
  lglrelqueue(lgl);
  lglrelctk(lgl, &lgl->control);
  lglrelstk(lgl, &lgl->assume);
  lglrelstk(lgl, &lgl->clause);
  lglrelstk(lgl, &lgl->eclause);
  lglrelstk(lgl, &lgl->eassume);
  lglrelstk(lgl, &lgl->extend);
  lglrelstk(lgl, &lgl->fassume);
  lglrelstk(lgl, &lgl->cassume);
  lglrelstk(lgl, &lgl->frames);
  lglrelstk(lgl, &lgl->trail);
  lglrelstk(lgl, &lgl->wchs->stk);
  lglrelstk(lgl, &lgl->irr);
  i = 0;
  for( ; !(i >= 16); i = i + 1)
    lglrelstk(lgl, &lgl->red[(signed long int)i]);
  do
    lglrelstk(lgl, &lgl->seen);
  while((_Bool)0);
  do
    lglrelstk(lgl, &lgl->_anon1.lcaseen);
  while((_Bool)0);
  do
    lglrelstk(lgl, &lgl->poisoned);
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->limits, (unsigned long int)1 * sizeof(struct Limits) /*352ul*/ );
    lgl->limits = ((struct Limits *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->times, (unsigned long int)1 * sizeof(struct Times) /*240ul*/ );
    lgl->times = ((struct Times *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->timers, (unsigned long int)1 * sizeof(struct Tmrs) /*128ul*/ );
    lgl->timers = ((struct Tmrs *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->red, (unsigned long int)(((1 << 4) - 1) + 1) * sizeof(struct Stk) /*24ul*/ );
    lgl->red = ((struct Stk *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->wchs, (unsigned long int)1 * sizeof(struct Wchs) /*152ul*/ );
    lgl->wchs = ((struct Wchs *)NULL);
  }
  while((_Bool)0);
  if(!(lgl->fltstr == ((struct FltStr *)NULL)))
    do
    {
      lgldel(lgl, (void *)lgl->fltstr, (unsigned long int)1 * sizeof(struct FltStr) /*604ul*/ );
      lgl->fltstr = ((struct FltStr *)NULL);
    }
    while((_Bool)0);

  if(!(lgl->cbs == ((struct Cbs *)NULL)))
    do
    {
      lgldel(lgl, (void *)lgl->cbs, (unsigned long int)1 * sizeof(struct Cbs) /*152ul*/ );
      lgl->cbs = ((struct Cbs *)NULL);
    }
    while((_Bool)0);

  lgldelstr(lgl, lgl->prefix);
  lgldec(lgl, sizeof(struct Stats) /*2272ul*/ );
  lgldec(lgl, sizeof(struct Opts) /*5680ul*/ );
  lgldec(lgl, sizeof(struct Mem) /*32ul*/ );
  lgldec(lgl, sizeof(struct LGL) /*816ul*/ );
  if((signed int)lgl->closeapitrace == 1)
    fclose(lgl->apitrace);

  if((signed int)lgl->closeapitrace == 2)
    pclose(lgl->apitrace);

  dealloc = lgl->mem->dealloc;
  if(!(dealloc == ((void (*)(void *, void *, unsigned long int))NULL)))
  {
    void *memstate = lgl->mem->state;
    if(!(lgl->stats == ((struct Stats *)NULL)))
      dealloc(memstate, (void *)lgl->stats, sizeof(struct Stats) /*2272ul*/ );

    if(!(lgl->times == ((struct Times *)NULL)))
      dealloc(memstate, (void *)lgl->times, sizeof(struct Times) /*240ul*/ );

    if(!(lgl->opts == ((struct Opts *)NULL)))
      dealloc(memstate, (void *)lgl->opts, sizeof(struct Opts) /*5680ul*/ );

    dealloc(memstate, (void *)lgl->mem, sizeof(struct Mem) /*32ul*/ );
    dealloc(memstate, (void *)lgl, sizeof(struct LGL) /*816ul*/ );
  }

  else
  {
    free((void *)lgl->stats);
    free((void *)lgl->times);
    free((void *)lgl->opts);
    free((void *)lgl->mem);
    free((void *)lgl);
  }
}

// lglrelecls
// file lglib.c line 9422
static void lglrelecls(struct LGL *lgl)
{
  lglrelstk(lgl, &lgl->_anon0.elm->lits);
  lglrelstk(lgl, &lgl->_anon0.elm->next);
  lglrelstk(lgl, &lgl->_anon0.elm->csigs);
  lglrelstk(lgl, &lgl->_anon0.elm->lsigs);
  lglrelstk(lgl, &lgl->_anon0.elm->sizes);
  lglrelstk(lgl, &lgl->_anon0.elm->occs);
  lglrelstk(lgl, &lgl->_anon0.elm->noccs);
  lglrelstk(lgl, &lgl->_anon0.elm->mark);
  lglrelstk(lgl, &lgl->_anon0.elm->m2i);
  lglrelstk(lgl, &lgl->_anon0.elm->clv);
}

// lglrelqueue
// file lglib.c line 18614
static void lglrelqueue(struct LGL *lgl)
{
  struct Qln *p;
  struct Qln *up;
  p = lgl->queue.bottom;
  for( ; !(p == ((struct Qln *)NULL)); p = up)
  {
    up = p->up;
    do
    {
      lgldel(lgl, (void *)p, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
      p = ((struct Qln *)NULL);
    }
    while((_Bool)0);
  }
  p = lgl->queue.merged;
  for( ; !(p == ((struct Qln *)NULL)); p = up)
  {
    up = p->up;
    do
    {
      lgldel(lgl, (void *)p, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
      p = ((struct Qln *)NULL);
    }
    while((_Bool)0);
  }
  p = lgl->queue.free;
  for( ; !(p == ((struct Qln *)NULL)); p = up)
  {
    up = p->up;
    do
    {
      lgldel(lgl, (void *)p, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
      p = ((struct Qln *)NULL);
    }
    while((_Bool)0);
  }
  do
    memset((void *)&lgl->queue, 0, sizeof(struct Queue) /*56ul*/ );
  while((_Bool)0);
}

// lglrelstk
// file lglib.c line 1410
static void lglrelstk(struct LGL *lgl, struct Stk *s)
{
  do
  {
    unsigned long int return_value_lglszstk_1;
    return_value_lglszstk_1=lglszstk(s);
    lgldel(lgl, (void *)s->start, return_value_lglszstk_1 * sizeof(signed int) /*4ul*/ );
    s->start = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
    memset((void *)s, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
}

// lglrelwtk
// file lglib.c line 14995
static void lglrelwtk(struct LGL *lgl, struct Wtk *wtk)
{
  do
  {
    signed int return_value_lglsizewtk_1;
    return_value_lglsizewtk_1=lglsizewtk(wtk);
    lgldel(lgl, (void *)wtk->start, (unsigned long int)return_value_lglsizewtk_1 * sizeof(struct Work) /*8ul*/ );
    wtk->start = ((struct Work *)NULL);
  }
  while((_Bool)0);
  memset((void *)wtk, 0, sizeof(struct Wtk) /*24ul*/ );
}

// lglrem
// file lglib.c line 3348
static signed int lglrem(struct LGL *lgl)
{
  signed int res = lgl->nvars;
  if(res == 0)
    return 0;

  else
  {
    res = res - (lgl->stats->fixed.current + 2);
    return res;
  }
}

// lglrep
// file lglib.c line 5046
static void lglrep(struct LGL *lgl, signed int level, char type)
{
  double tmp_if_expr_3;
  double return_value_lglgetime_1;
  double return_value_lglsec_2;
  if(lgl->opts->verbose.val >= level)
  {
    if(lgl->stats->reported % 23 == 0)
      lglrephead(lgl);

    if(!(lgl->opts->abstime.val == 0))
    {
      return_value_lglgetime_1=lglgetime(lgl);
      tmp_if_expr_3 = return_value_lglgetime_1;
    }

    else
    {
      return_value_lglsec_2=lglsec(lgl);
      tmp_if_expr_3 = return_value_lglsec_2;
    }
    signed int return_value_lglrem_4;
    return_value_lglrem_4=lglrem(lgl);
    double return_value_lglagility_5;
    return_value_lglagility_5=lglagility(lgl);
    signed long int return_value_lglavglue_6;
    return_value_lglavglue_6=lglavglue(lgl);
    double return_value_lglheight_7;
    return_value_lglheight_7=lglheight(lgl);
    double return_value_lglmb_8;
    return_value_lglmb_8=lglmb(lgl);
    lglprt(lgl, 1, "%c %6.1f %7d %8d %9lld %7d %6d %5d %3.0f %4.1f %5.1f %4.0f", type, tmp_if_expr_3, return_value_lglrem_4, lgl->stats->irr.clauses.cur, (signed long long int)lgl->stats->confs, lgl->stats->red.lrg, lgl->stats->red.bin, lgl->stats->red.trn, return_value_lglagility_5, (double)return_value_lglavglue_6 / 100.0, return_value_lglheight_7, return_value_lglmb_8);
    lgl->stats->reported = lgl->stats->reported + 1;
  }

}

// lglrephead
// file lglib.c line 5028
static void lglrephead(struct LGL *lgl)
{
  if(!(lgl->tid >= 1))
  {
    if(!(lgl->cbs == ((struct Cbs *)NULL)))
    {
      if(!(lgl->cbs->msglock.lock == ((void (*)(void *))NULL)))
        lgl->cbs->msglock.lock(lgl->cbs->msglock.state);

    }

    fprintf(lgl->out, "%s\n", lgl->prefix);
    fprintf(lgl->out, "%s%s seconds         irredundant          redundant clauses agility   height\n", lgl->prefix, !(lgl->tid != 0) ? "  " : "");
    fprintf(lgl->out, "%s%s         variables clauses conflicts large binary ternary    glue         MB\n", lgl->prefix, !(lgl->tid != 0) ? "  " : "");
    fprintf(lgl->out, "%s\n", lgl->prefix);
    fflush(lgl->out);
    if(!(lgl->cbs == ((struct Cbs *)NULL)))
    {
      if(!(lgl->cbs->msglock.unlock == ((void (*)(void *))NULL)))
        lgl->cbs->msglock.unlock(lgl->cbs->msglock.state);

    }

  }

}

// lglrepr
// file lglib.c line 17980
signed int lglrepr(struct LGL *lgl, signed int elit)
{
  signed int res;
  signed int eidx;
  eidx=abs(elit);

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglrepr");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "repr %d", elit);
    break;
  }
  lgl->stats->calls.repr = lgl->stats->calls.repr + 1l;
  if(!(lgl->maxext >= eidx))
    res = elit;

  else
  {
    res=lglerepr(lgl, elit);
    signed int return_value_abs_1;
    return_value_abs_1=abs(res);
    if(!(return_value_abs_1 >= 2))
      res = elit;

  }

__CPROVER_DUMP_L8:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglrepr(lgl->clone, elit);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglrepr");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d", (const void *)"lglrepr", elit, CLONERES, (const void *)"lglrepr", elit, res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglreqinit
// file lglib.c line 18994
static void lglreqinit(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglreqinit");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
}

// lglrescoreclauses
// file lglib.c line 3414
static void lglrescoreclauses(struct LGL *lgl)
{
  signed int glue;
  lgl->stats->rescored.clauses = lgl->stats->rescored.clauses + 1;
  glue = 0;
  for( ; !(glue >= 15); glue = glue + 1)
    lglrescoreglue(lgl, glue);
}

// lglrescoreglue
// file lglib.c line 3392
static void lglrescoreglue(struct LGL *lgl, signed int glue)
{
  signed int *c;
  signed int *p;
  signed int oldact;
  signed int newact;
  struct Stk *lir = lgl->red + (signed long int)glue;
  c = lir->start;
  _Bool tmp_if_expr_1;
  signed int *tmp_post_2;
  for( ; !(c >= lir->top); c = p + (signed long int)1)
  {
    oldact = *c;
    if(oldact == 0x7fffffff)
    {
      p = c + (signed long int)1;
      do
      {
        if(!(p >= lir->top))
          tmp_if_expr_1 = *p == 0x7fffffff ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(!tmp_if_expr_1)
          break;

        p = p + 1l;
      }
      while((_Bool)1);
      p = p - 1l;
    }

    else
    {
      newact = (0x7fffffff >> RMSHFT) + ((oldact - (0x7fffffff >> RMSHFT)) + 1) / 2;
      tmp_post_2 = c;
      c = c + 1l;
      *tmp_post_2 = newact;

    __CPROVER_DUMP_L7:
      ;
      p = c;
      for( ; !(*p == 0); p = p + 1l)
        ;
    }
  }
}

// lglreset
// file lglib.c line 3744
static void lglreset(struct LGL *lgl)
{
  signed int elit;
  signed int ilit;
  signed int erepr;
  struct Ext *ext;
  struct Ext *rext;
  unsigned int bit;
  struct AVar *av;
  signed int return_value_lglmtstk_1;
  signed int return_value_lglmtstk_3;
  if(!((signed int)lgl->state == RESET))
  {
    if((signed int)lgl->state >= 5)
    {
      if(lgl->level >= 1)
        lglbacktrack(lgl, 0);

      signed int return_value_lglmtstk_2;
      return_value_lglmtstk_2=lglmtstk(&lgl->eassume);
      if(return_value_lglmtstk_2 == 0)
      {

      __CPROVER_DUMP_L4:
        ;
        do
        {
          return_value_lglmtstk_1=lglmtstk(&lgl->eassume);
          if(!(return_value_lglmtstk_1 == 0))
            break;

          elit=lglpopstk(&lgl->eassume);
          ext=lglelit2ext(lgl, elit);
          ext->assumed = (unsigned int)0;
          if(!(ext->failed == 0u))
          {
            ext->failed = (unsigned int)0;
            erepr=lglerepr(lgl, elit);
            if(!(erepr == elit))
            {
              rext=lglelit2ext(lgl, erepr);
              rext->failed = (unsigned int)0;
            }

          }

        }
        while((_Bool)1);
      }

      lglchkeassumeclean(lgl);
      signed int return_value_lglmtstk_4;
      return_value_lglmtstk_4=lglmtstk(&lgl->assume);
      if(return_value_lglmtstk_4 == 0)
      {

      __CPROVER_DUMP_L9:
        ;
        do
        {
          return_value_lglmtstk_3=lglmtstk(&lgl->assume);
          if(!(return_value_lglmtstk_3 == 0))
            break;

          ilit=lglpopstk(&lgl->assume);
          av=lglavar(lgl, ilit);
          bit = 1u << (signed int)(ilit < 0);
          av->assumed = (unsigned int)av->assumed & ~bit;
          av->failed = (unsigned int)av->failed & ~bit;
        }
        while((_Bool)1);
      }

      signed int return_value_lglmtstk_5;
      return_value_lglmtstk_5=lglmtstk(&lgl->cassume);
      if(return_value_lglmtstk_5 == 0)
      {

      __CPROVER_DUMP_L13:
        ;
        lglclnstk(&lgl->cassume);
        lgl->ncassumed = 0;
        lgl->cassumed = lgl->ncassumed;
      }

      if(!(lgl->failed == 0))
      {

      __CPROVER_DUMP_L15:
        ;
        lgl->failed = 0;
      }

      if(!(lgl->assumed == 0))
      {

      __CPROVER_DUMP_L17:
        ;
        lgl->assumed = 0;
      }

      lglchkassumeclean(lgl);
      lgleunassignall(lgl);

    __CPROVER_DUMP_L19:
      ;
      do
        lgl->state = (enum State)RESET;
      while((_Bool)0);
    }

  }

}

// lglresetforked
// file lglib.c line 18920
void lglresetforked(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglresetforked");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(lgl->forked == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglresetforked");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "not forked");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lgl->bruteforked = (char)0;
  lgl->forked = lgl->bruteforked;
}

// lglresetphase
// file lglib.c line 3908
void lglresetphase(struct LGL *lgl, signed int elit)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglresetphase");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(elit == 0))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglresetphase");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "invalid literal argument");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "resetphase %d", elit);
    break;
  }
  lglesetphase(lgl, elit, 0);
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglresetphase(lgl->clone, elit);

}

// lglresetsmallve
// file lglib.c line 10708
static void lglresetsmallve(struct LGL *lgl)
{
  lglclnstk(&lgl->_anon0.elm->m2i);
  lglclnstk(&lgl->_anon0.elm->clv);
  lglpopnunmarkstk(lgl, &lgl->seen);
}

// lglrestart
// file lglib.c line 6334
static void lglrestart(struct LGL *lgl)
{
  signed int skip;
  signed int level;
  signed long int kept;
  lglstart(lgl, &lgl->times->rsts);
  skip=lglagile(lgl);
  if(!(skip == 0))
    lgl->stats->restarts.skipped = lgl->stats->restarts.skipped + 1;

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(!(lgl->opts->restart.val >= 2))
      level = 0;

    else
      level=lglreusetrail(lgl);
    if(!(level >= lgl->alevel))
      level = lgl->alevel;

    else
      if(!(lgl->alevel >= level))
      {
        kept = (signed long int)((100 * level) / lgl->level);
        lgl->stats->restarts.kept.sum = lgl->stats->restarts.kept.sum + kept;
        lgl->stats->restarts.kept.count = lgl->stats->restarts.kept.count + 1;
      }

    if(!(level >= lgl->level))
    {
      lglbacktrack(lgl, level);
      lgl->stats->restarts.count = lgl->stats->restarts.count + 1;
    }

    else
      lgl->stats->restarts.skipped = lgl->stats->restarts.skipped + 1;
  }

__CPROVER_DUMP_L1:
  ;
  lglincrestartl(lgl, skip);
  lglstop(lgl);
}

// lglrestarting
// file lglib.c line 16996
static signed int lglrestarting(struct LGL *lgl)
{
  signed int lglrestarting__1__assumptions;
  if(lgl->opts->restart.val == 0)
    return 0;

  else
    if(lgl->level == 0)
      return 0;

    else
    {
      unsigned long int return_value_lglcntstk_1;
      return_value_lglcntstk_1=lglcntstk(&lgl->assume);
      lglrestarting__1__assumptions = (signed int)return_value_lglcntstk_1;
      if(!(lglrestarting__1__assumptions == 0))
      {
        if(!(lgl->assumed >= lglrestarting__1__assumptions))
          return 0;

        if(!(lgl->alevel == lgl->level))
          goto __CPROVER_DUMP_L4;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        return (signed int)(lgl->stats->confs >= lgl->limits->restart.confs);
      }
    }
}

// lglreusetrail
// file lglib.c line 6315
static signed int lglreusetrail(struct LGL *lgl)
{
  signed int lglreusetrail__1__next = 0;
  signed int res = 0;
  signed int prev;
  signed int level;
  const struct Ctr *p;
  lglreusetrail__1__next=lglnextdecision(lgl);
  signed int return_value_lglqcmp_1;
  if(lglreusetrail__1__next == 0)
    return 0;

  else
  {
    p = lgl->control.start + (signed long int)1;
    for( ; !(p >= lgl->control.top); p = p + 1l)
    {
      prev = (signed int)p->decision;
      signed int return_value_lglassumption_2;
      return_value_lglassumption_2=lglassumption(lgl, prev);
      if(return_value_lglassumption_2 == 0)
      {
        return_value_lglqcmp_1=lglqcmp(lgl, prev, lglreusetrail__1__next);
        if(!(return_value_lglqcmp_1 >= 0))
          break;

      }

      level=lglevel(lgl, prev);
      res = level;
    }
    if(!(res == 0))
      lglprt(lgl, 2, "reuse trail level %d from current level %d", res, lgl->level);

    return res;
  }
}

// lglrgopts
// file lglib.c line 2125
void lglrgopts(struct LGL *lgl)
{
  struct Opt *o;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglrgopts");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  o = &lgl->opts->beforefirst + (signed long int)1;
  for( ; &lgl->opts->afterlast + -1l >= o; o = o + 1l)
    fprintf(lgl->out, "%s %d %d %d\n", o->lng, o->val, o->min, o->max);
}

// lglrmbcls
// file lglib.c line 5668
static void lglrmbcls(struct LGL *lgl, signed int a, signed int b, signed int red)
{
  lglrmbwch(lgl, a, b, red);
  lglrmbwch(lgl, b, a, red);

__CPROVER_DUMP_L1:
  ;
  lgldeclscnt(lgl, 2, red, 0);
  if(red == 0)
  {
    if(!(lgl->dense == 0))
    {
      lgldecocc(lgl, a);
      lgldecocc(lgl, b);
    }

  }

}

// lglrmbindup
// file lglib.c line 15958
static void lglrmbindup(struct LGL *lgl)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int round;
  signed int redrem;
  signed int irrem;
  signed int *w;
  signed int *eow;
  signed int *p;
  signed int *q;
  struct HTS *hts;
  irrem = 0;
  redrem = irrem;
  idx = 2;
  signed int *tmp_post_1;
  signed int *tmp_post_2;
  signed int *tmp_post_5;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      round = 0;
      for( ; !(round >= 2); round = round + 1)
      {
        hts=lglhts(lgl, lit);
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        q = w;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          tag = blit & MASKCS;
          if(!(tag == BINCS))
          {
            tmp_post_1 = q;
            q = q + 1l;
            *tmp_post_1 = blit;
          }

          if(tag == TRNCS || tag == LRGCS)
          {
            tmp_post_2 = q;
            q = q + 1l;
            p = p + 1l;
            *tmp_post_2 = *p;
          }

          if(tag == BINCS)
          {
            red = blit & REDCS;
            other = blit >> RMSHFT;
            signed int return_value_lglsignedmarked_6;
            return_value_lglsignedmarked_6=lglsignedmarked(lgl, other);
            if(!(return_value_lglsignedmarked_6 == 0))
            {
              if(red == 0 && !(round == 0))
                goto ONLYCOPY;

              if(!(red == 0))
                redrem = redrem + 1;

              else
                irrem = irrem + 1;
              signed int return_value_abs_3;
              return_value_abs_3=abs(lit);
              signed int return_value_abs_4;
              return_value_abs_4=abs(other);
              if(!(return_value_abs_4 >= return_value_abs_3))
              {

              __CPROVER_DUMP_L9:
                ;
                lgldeclscnt(lgl, 2, red, 0);
                if(red == 0)
                {
                  if(!(lgl->dense == 0))
                  {
                    lgldecocc(lgl, lit);
                    lgldecocc(lgl, other);
                  }

                }

                lgl->stats->bindup.removed = lgl->stats->bindup.removed + 1;
                if(!(red == 0))
                  lgl->stats->bindup.red = lgl->stats->bindup.red + 1;

              }

              else

                __CPROVER_DUMP_L12:
                  ;
            }

            else
            {
              if(red == 0 && round == 0 || !(red == 0) && !(round == 0))
                lglsignedmarknpushseen(lgl, other);


            ONLYCOPY:
              ;
              tmp_post_5 = q;
              q = q + 1l;
              *tmp_post_5 = blit;
            }
          }

        }
        lglshrinkhts(lgl, hts, (signed int)((signed long int)hts->count - (p - q)));
      }
      lglpopnunmarkstk(lgl, &lgl->seen);
    }
  }
}

// lglrmbwch
// file lglib.c line 5603
static void lglrmbwch(struct LGL *lgl, signed int lit, signed int other, signed int red)
{
  signed int *p;
  signed int blit;
  signed int blit1;
  signed int *w;
  signed int *eow;
  signed int tag;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  p = w;
  eow = w + (signed long int)hts->count;
  lglrminc(lgl, w, eow);
  blit1 = other << RMSHFT | red | BINCS;
  signed int *tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p + 1l;
    blit = *tmp_post_1;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    else
      if(!(tag == OCCS))
      {
        if(blit == blit1)
          break;

      }

  }
  while((_Bool)1);
  for( ; !(p >= eow); p = p + 1l)
    p[(signed long int)-1] = p[(signed long int)0];
  lglshrinkhts(lgl, hts, (signed int)((p - w) - (signed long int)1));
}

// lglrminc
// file lglib.c line 4086
static void lglrminc(struct LGL *lgl, const signed int *w, const signed int *eow)
{
  signed int inc = (signed int)(eow - w);
  inc = inc >> lgl->opts->rmincpen.val;
  inc = inc + 1;
  if(!(lgl->blocking == 0))
    lgl->stats->blk.steps = lgl->stats->blk.steps + (signed long int)inc;

  else
    if(!(lgl->eliminating == 0))
      lgl->stats->elm.steps = lgl->stats->elm.steps + (signed long int)inc;

}

// lglrmlcls
// file lglib.c line 5686
static void lglrmlcls(struct LGL *lgl, signed int lidx, signed int red)
{
  signed int *c;
  signed int *p;
  signed int glue;
  signed int lit;
  glue = red != 0 ? lidx & (1 << 4) - 1 : 0;
  c=lglidx2lits(lgl, LRGCS, red, lidx);
  if(red == 0 || !(glue >= 15))
  {
    lglrmlwch(lgl, c[(signed long int)0], red, lidx);
    lglrmlwch(lgl, c[(signed long int)1], red, lidx);
  }

  if(red == 0)
  {
    if(!(lgl->dense == 0))
    {
      p = c;
      do
      {
        lit = *p;
        if(lit == 0)
          break;

        lglrmlocc(lgl, lit, red, lidx);
        lgldecocc(lgl, lit);
        p = p + 1l;
      }
      while((_Bool)1);
    }

  }

  if(!(red == 0) && !(glue >= 15))
  {

  __CPROVER_DUMP_L4:
    ;
    c[(signed long int)-1] = 0x7fffffff;
  }

  p = c;
  for( ; !(*p == 0); p = p + 1l)
    *p = 0x7fffffff;
  *p = 0x7fffffff;
  if(!(glue == 15))
    lgldeclscnt(lgl, (signed int)(p - c), red, glue);

}

// lglrmlocc
// file lglib.c line 4363
static void lglrmlocc(struct LGL *lgl, signed int lit, signed int red, signed int lidx)
{
  signed int search;
  signed int blit;
  signed int tag;
  signed int *p;
  signed int *q;
  signed int *w;
  signed int *eow;
  struct HTS *hts;
  signed int *tmp_post_1;
  if((signed int)lgl->dense >= 2)
  {
    hts=lglhts(lgl, lit);
    search = lidx << RMSHFT | OCCS | red;
    w=lglhts2wchs(lgl, hts);
    p = w;
    eow = w + (signed long int)hts->count;
    lglrminc(lgl, w, eow);
    do
    {
      tmp_post_1 = p;
      p = p + 1l;
      blit = *tmp_post_1;
      tag = blit & MASKCS;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

    }
    while(!(blit == search));
    q = p;
    for( ; !(q >= eow); q = q + 1l)
      q[(signed long int)-1] = q[(signed long int)0];
    lglshrinkhts(lgl, hts, (signed int)((q - w) - (signed long int)1));
  }

}

// lglrmlwch
// file lglib.c line 4210
static void lglrmlwch(struct LGL *lgl, signed int lit, signed int red, signed int lidx)
{
  signed int blit;
  signed int tag;
  signed int *p;
  signed int *q;
  signed int *w;
  signed int *eow;
  signed int ored;
  signed int olidx;
  struct HTS *hts;
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  p = w;
  eow = w + (signed long int)hts->count;
  lglrminc(lgl, w, eow);
  signed int *tmp_post_1;
  signed int *tmp_post_2;
  do
  {
    tmp_post_1 = p;
    p = p + 1l;
    blit = *tmp_post_1;
    tag = blit & MASKCS;
    if(!(tag == BINCS))
    {
      if(!(tag == OCCS))
      {
        tmp_post_2 = p;
        p = p + 1l;
        olidx = *tmp_post_2;
        if(!(tag == TRNCS))
        {
          ored = blit & REDCS;
          if(ored == red)
          {
            if(olidx == lidx)
              break;

          }

        }

      }

    }

  }
  while((_Bool)1);
  q = p;
  for( ; !(q >= eow); q = q + 1l)
    q[(signed long int)-2] = q[(signed long int)0];
  lglshrinkhts(lgl, hts, (signed int)((q - w) - (signed long int)2));
}

// lglrmstk
// file lglib.c line 1436
static void lglrmstk(struct Stk *s, signed int elem)
{
  signed int *p;
  signed int *q;
  p = s->start;
  for( ; !(p >= s->top); p = p + 1l)
    if(*p == elem)
      break;

  signed int *tmp_post_1 = p;
  p = p + 1l;
  q = tmp_post_1;
  signed int *tmp_post_2;
  signed int *tmp_post_3;
  for( ; !(p >= s->top); *tmp_post_2 = *tmp_post_3)
  {
    tmp_post_2 = q;
    q = q + 1l;
    tmp_post_3 = p;
    p = p + 1l;
  }
  s->top = q;
}

// lglrmtcls
// file lglib.c line 5676
static void lglrmtcls(struct LGL *lgl, signed int a, signed int b, signed int c, signed int red)
{
  lglrmtwch(lgl, a, b, c, red);
  lglrmtwch(lgl, b, a, c, red);
  lglrmtwch(lgl, c, a, b, red);

__CPROVER_DUMP_L1:
  ;
  lgldeclscnt(lgl, 3, red, 0);
  if(red == 0)
  {
    if(!(lgl->dense == 0))
    {
      lgldecocc(lgl, a);
      lgldecocc(lgl, b);
      lgldecocc(lgl, c);
    }

  }

}

// lglrmtwch
// file lglib.c line 4099
static void lglrmtwch(struct LGL *lgl, signed int lit, signed int other1, signed int other2, signed int red)
{
  signed int *p;
  signed int blit;
  signed int other;
  signed int blit1;
  signed int blit2;
  signed int *w;
  signed int *eow;
  signed int tag;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  p = w;
  eow = w + (signed long int)hts->count;
  lglrminc(lgl, w, eow);
  blit1 = other1 << RMSHFT | red | TRNCS;
  blit2 = other2 << RMSHFT | red | TRNCS;
  signed int *tmp_post_1;
  signed int *tmp_post_2;
  do
  {
    tmp_post_1 = p;
    p = p + 1l;
    blit = *tmp_post_1;
    tag = blit & MASKCS;
    if(!(tag == OCCS) && !(tag == BINCS))
    {
      tmp_post_2 = p;
      p = p + 1l;
      other = *tmp_post_2;
      if(!(tag == LRGCS))
      {
        if(blit == blit1 && other == other2)
          break;

        if(blit == blit2 && other == other1)
          break;

      }

    }

  }
  while((_Bool)1);
  for( ; !(p >= eow); p = p + 1l)
    p[(signed long int)-2] = p[(signed long int)0];
  lglshrinkhts(lgl, hts, (signed int)((p - w) - (signed long int)2));
}

// lglrmvbcls
// file lglib.c line 11792
static void lglrmvbcls(struct LGL *lgl, signed int a, signed int b)
{
  lglrmbcls(lgl, a, b, 0);
  if(!(lgl->opts->move.val == 0))
    lglmvbcls(lgl, a, b);

}

// lglrmvtcls
// file lglib.c line 11797
static void lglrmvtcls(struct LGL *lgl, signed int a, signed int b, signed int c)
{
  lglrmtcls(lgl, a, b, c, 0);
  if(lgl->opts->move.val >= 2)
    lglmvtcls(lgl, a, b, c);

}

// lglrsn
// file lglib.c line 2578
static signed int * lglrsn(struct LGL *lgl, signed int lit)
{
  struct TD *return_value_lgltd_1;
  return_value_lgltd_1=lgltd(lgl, lit);
  return return_value_lgltd_1->rsn;
}

// lglrstcontrol
// file lglib.c line 1574
static void lglrstcontrol(struct LGL *lgl, signed int count)
{
  signed int return_value_lglcntctk_1;
  do
  {
    return_value_lglcntctk_1=lglcntctk(&lgl->control);
    if(count >= return_value_lglcntctk_1)
      break;

    lglpopcontrol(lgl);
  }
  while((_Bool)1);
}

// lglrstecls
// file lglib.c line 9407
static void lglrstecls(struct LGL *lgl)
{
  lglclnstk(&lgl->_anon0.elm->lits);
  lglclnstk(&lgl->_anon0.elm->next);
  lglclnstk(&lgl->_anon0.elm->csigs);
  lglclnstk(&lgl->_anon0.elm->lsigs);
  lglclnstk(&lgl->_anon0.elm->sizes);
  lglclnstk(&lgl->_anon0.elm->occs);
  lglclnstk(&lgl->_anon0.elm->noccs);
  lglclnstk(&lgl->_anon0.elm->mark);
  lglclnstk(&lgl->_anon0.elm->m2i);
  lglpopnunmarkstk(lgl, &lgl->seen);
  lgl->_anon0.elm->pivot = 0;
}

// lglrststk
// file lglib.c line 1451
static void lglrststk(struct Stk *s, signed int newsz)
{
  s->top = s->start + (signed long int)newsz;
}

// lglrsz
// file lglib.c line 1279
static void * lglrsz(struct LGL *lgl, void *ptr, unsigned long int old, unsigned long int new)
{
  void *res;
  void *return_value_lglnew_1;
  if(ptr == NULL)
  {
    return_value_lglnew_1=lglnew(lgl, new);
    return return_value_lglnew_1;
  }

  else
    if(new == 0ul)
    {
      lgldel(lgl, ptr, old);
      return NULL;
    }

    else
      if(old == new)
        return ptr;

      else
      {
        lgldec(lgl, old);
        if(!(lgl->mem->realloc == ((void * (*)(void *, void *, unsigned long int, unsigned long int))NULL)))
          res=lgl->mem->realloc(lgl->mem->state, ptr, old, new);

        else
          res=realloc(ptr, new);
        if(res == NULL)
          lgldie(lgl, "out of memory reallocating %ld to %ld bytes", old, new);


      __CPROVER_DUMP_L6:
        ;
        lglinc(lgl, new);
        if(!(old >= new))
          memset(res + (signed long int)old, 0, new - old);

        return res;
      }
}

// lglrszvars
// file lglib.c line 2279
static void lglrszvars(struct LGL *lgl, signed int new_size)
{
  signed int old_size = lgl->szvars;
  do
  {
    void *return_value_lglrsz_1;
    return_value_lglrsz_1=lglrsz(lgl, (void *)lgl->vals, (unsigned long int)old_size * sizeof(signed char) /*1ul*/ , (unsigned long int)new_size * sizeof(signed char) /*1ul*/ );
    lgl->vals = (signed char *)return_value_lglrsz_1;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglrsz_2;
    return_value_lglrsz_2=lglrsz(lgl, (void *)lgl->i2e, (unsigned long int)old_size * sizeof(signed int) /*4ul*/ , (unsigned long int)new_size * sizeof(signed int) /*4ul*/ );
    lgl->i2e = (signed int *)return_value_lglrsz_2;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglrsz_3;
    return_value_lglrsz_3=lglrsz(lgl, (void *)lgl->doms, (unsigned long int)(2 * old_size) * sizeof(signed int) /*4ul*/ , (unsigned long int)(2 * new_size) * sizeof(signed int) /*4ul*/ );
    lgl->doms = (signed int *)return_value_lglrsz_3;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglrsz_4;
    return_value_lglrsz_4=lglrsz(lgl, (void *)lgl->dvars, (unsigned long int)old_size * sizeof(struct DVar) /*16ul*/ , (unsigned long int)new_size * sizeof(struct DVar) /*16ul*/ );
    lgl->dvars = (struct DVar *)return_value_lglrsz_4;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglrsz_5;
    return_value_lglrsz_5=lglrsz(lgl, (void *)lgl->avars, (unsigned long int)old_size * sizeof(struct AVar) /*12ul*/ , (unsigned long int)new_size * sizeof(struct AVar) /*12ul*/ );
    lgl->avars = (struct AVar *)return_value_lglrsz_5;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglrsz_6;
    return_value_lglrsz_6=lglrsz(lgl, (void *)lgl->jwh, (unsigned long int)(2 * old_size) * sizeof(signed long int) /*8ul*/ , (unsigned long int)(2 * new_size) * sizeof(signed long int) /*8ul*/ );
    lgl->jwh = (signed long int *)return_value_lglrsz_6;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglrsz_7;
    return_value_lglrsz_7=lglrsz(lgl, (void *)lgl->queue.nodes, (unsigned long int)old_size * sizeof(struct Qnd) /*16ul*/ , (unsigned long int)new_size * sizeof(struct Qnd) /*16ul*/ );
    lgl->queue.nodes = (struct Qnd *)return_value_lglrsz_7;
  }
  while((_Bool)0);
  lgl->szvars = new_size;
}

// lglrtrav
// file lglib.c line 18813
void lglrtrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int, signed int))
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int glue;
  const signed int *p;
  const signed int *c;
  const signed int *w;
  const signed int *eow;
  struct Stk *lir;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglrtrav");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  signed int return_value_lglexport_6;
  if(lgl->mt == 0)
  {
    lglgc(lgl);
    if(lgl->level >= 1)
      lglbacktrack(lgl, 0);

    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      signed char return_value_lglval_1;
      return_value_lglval_1=lglval(lgl, idx);
      if(return_value_lglval_1 == 0)
      {
        sign = -1;
        for( ; !(sign >= 2); sign = sign + 2)
        {
          lit = sign * idx;
          hts=lglhts(lgl, lit);
          w=lglhts2wchs(lgl, hts);
          eow = w + (signed long int)hts->count;
          p = w;
          for( ; !(p >= eow); p = p + 1l)
          {
            blit = *p;
            tag = blit & MASKCS;
            red = blit & REDCS;
            if(tag == TRNCS || tag == LRGCS)
              p = p + 1l;

            if(!(red == 0))
            {
              if(tag == BINCS || tag == TRNCS)
              {
                other = blit >> RMSHFT;
                signed int return_value_abs_2;
                return_value_abs_2=abs(other);
                if(return_value_abs_2 >= idx)
                {
                  if(tag == TRNCS)
                  {
                    other2 = *p;
                    signed int return_value_abs_3;
                    return_value_abs_3=abs(other2);
                    if(!(return_value_abs_3 >= idx))
                      goto __CPROVER_DUMP_L14;

                  }

                  else
                    other2 = 0;
                  signed int return_value_lglexport_4;
                  return_value_lglexport_4=lglexport(lgl, lit);
                  trav(state, return_value_lglexport_4, 0);
                  signed int return_value_lglexport_5;
                  return_value_lglexport_5=lglexport(lgl, other);
                  trav(state, return_value_lglexport_5, 0);
                  if(!(other2 == 0))
                  {
                    return_value_lglexport_6=lglexport(lgl, other2);
                    trav(state, return_value_lglexport_6, 0);
                  }

                  trav(state, 0, 0);
                }

              }

            }


          __CPROVER_DUMP_L14:
            ;
          }
        }
      }

    }
    glue = 0;
    for( ; !(glue >= 15); glue = glue + 1)
    {
      lir = lgl->red + (signed long int)glue;
      c = lir->start;
      for( ; !(c >= lir->top); c = p + (signed long int)1)
      {
        p = c;
        if(!(*p >= 134217727))
        {
          other = *p;
          if(!(other == 0))
          {
            signed int return_value_lglexport_7;
            return_value_lglexport_7=lglexport(lgl, other);
            trav(state, return_value_lglexport_7, 0);
            p = p + 1l;
          }

          trav(state, 0, 0);
        }

      }
    }
  }

}

// lgls2fun
// file lglib.c line 10626
static void lgls2fun(signed int mlit, unsigned long int *res)
{
  signed int midx;
  midx=abs(mlit);
  signed int sidx = midx - 2;
  if(!(mlit >= 0))
    lglnegvar2fun(sidx, res);

  else
    lglvar2fun(sidx, res);
}

// lgls2m
// file lglib.c line 10460
static signed int lgls2m(struct LGL *lgl, signed int ilit)
{
  struct AVar *av;
  av=lglavar(lgl, ilit);
  signed int res = av->mark;
  if(res == 0)
  {
    unsigned long int return_value_lglcntstk_1;
    return_value_lglcntstk_1=lglcntstk(&lgl->seen);
    res = (signed int)(return_value_lglcntstk_1 + (unsigned long int)1);
    if(!(1 + lgl->opts->smallvevars.val >= res))
      return 0;

    av->mark = res;
    signed int return_value_abs_2;
    return_value_abs_2=abs(ilit);
    lglpushstk(lgl, &lgl->seen, return_value_abs_2);
    signed int return_value_abs_3;
    return_value_abs_3=abs(ilit);
    lglpushstk(lgl, &lgl->_anon0.elm->m2i, return_value_abs_3);
  }


__CPROVER_DUMP_L2:
  ;
  if(!(ilit >= 0))
    res = -res;

  return res;
}

// lglsat
// file lglib.h line 189
signed int lglsat(struct LGL *lgl)
{
  signed int res;
  struct Lim lim;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsat");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "sat");
    break;
  }
  lglstart(lgl, &lgl->times->all);
  lgl->stats->calls.sat = lgl->stats->calls.sat + 1l;
  do
  {
    signed int return_value_lglmtstk_1;
    return_value_lglmtstk_1=lglmtstk(&lgl->clause);
    if(!(return_value_lglmtstk_1 == 0))
      break;

    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsat");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "clause terminating zero missing");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
  }
  while((_Bool)0);
  lglsetlim(lgl, &lim);
  res=lglisat(lgl, &lim, 0);
  lglstop(lgl);

__CPROVER_DUMP_L9:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglsat(lgl->clone);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsat");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone) = %d differs from %s (lgl) = %d", (const void *)"lglsat", CLONERES, (const void *)"lglsat", res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglschedbasicprobe
// file lglib.c line 8877
static signed int lglschedbasicprobe(struct LGL *lgl, struct Stk *probes, signed int round)
{
  signed int idx;
  signed int res;
  signed int i;
  signed int j;
  signed int donotbasicprobes;
  signed int keepscheduled;
  idx = 2;
  signed int return_value_lglhasbins_3;
  signed int return_value_lglhasbins_2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree_1;
    return_value_lglisfree_1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree_1 == 0))
    {
      if(!(lgl->opts->prbasic.val >= 2))
      {
        return_value_lglhasbins_3=lglhasbins(lgl, idx);
        if(return_value_lglhasbins_3 == 0)
          goto __CPROVER_DUMP_L2;

        return_value_lglhasbins_2=lglhasbins(lgl, -idx);
        if(return_value_lglhasbins_2 == 0)
          goto __CPROVER_DUMP_L2;

      }

      else
      {

      __CPROVER_DUMP_L2:
        ;
        lglpushstk(lgl, probes, idx);
      }
    }

  }
  unsigned long int return_value_lglcntstk_4;
  return_value_lglcntstk_4=lglcntstk(probes);
  res = (signed int)return_value_lglcntstk_4;
  keepscheduled = 0;
  donotbasicprobes = keepscheduled;
  i = 0;
  for( ; !(i >= res); i = i + 1)
  {
    idx=lglpeek(probes, i);
    if(!(idx == 0))
    {
      struct AVar *return_value_lglavar_5;
      return_value_lglavar_5=lglavar(lgl, idx);
      if(!(return_value_lglavar_5->donotbasicprobe == 0u))
        donotbasicprobes = donotbasicprobes + 1;

      else
        keepscheduled = keepscheduled + 1;
    }

  }
  if(keepscheduled == 0)
  {
    i = 0;
    for( ; !(i >= res); i = i + 1)
    {
      idx=lglpeek(probes, i);
      if(!(idx == 0))
      {
        struct AVar *return_value_lglavar_6;
        return_value_lglavar_6=lglavar(lgl, idx);
        return_value_lglavar_6->donotbasicprobe = (unsigned int)0;
        keepscheduled = keepscheduled + 1;
      }

    }
    donotbasicprobes = 0;
  }

  i = 0;
  for( ; !(i >= res); i = i + 1)
  {
    idx=lglpeek(probes, i);
    if(!(idx == 0))
    {
      struct AVar *return_value_lglavar_7;
      return_value_lglavar_7=lglavar(lgl, idx);
      if(!(return_value_lglavar_7->donotbasicprobe == 0u))
        donotbasicprobes = donotbasicprobes + 1;

      else
        keepscheduled = keepscheduled + 1;
    }

  }
  j = 0;
  i = 0;
  signed int tmp_post_8;
  for( ; !(i >= res); i = i + 1)
  {
    idx=lglpeek(probes, i);
    if(!(idx == 0))
    {
      struct AVar *return_value_lglavar_9;
      return_value_lglavar_9=lglavar(lgl, idx);
      if(return_value_lglavar_9->donotbasicprobe == 0u)
      {
        tmp_post_8 = j;
        j = j + 1;
        lglpoke(probes, tmp_post_8, idx);
      }

    }

  }
  res = j;
  lglrststk(probes, res);
  signed int return_value_lglrem_10;
  double return_value_lglpcnt_11;
  if(res == 0)
    lglprt(lgl, 2, "[basicprobe-%d-%d] no potential probes found", lgl->stats->prb.basic.count, round);

  else
    if(donotbasicprobes == 0)
      lglprt(lgl, 2, "[basicprobe-%d-%d] scheduled all %d potential probes", lgl->stats->prb.basic.count, round, res);

    else
    {
      return_value_lglrem_10=lglrem(lgl);
      return_value_lglpcnt_11=lglpcnt((double)res, (double)return_value_lglrem_10);
      lglprt(lgl, 2, "[basicprobe-%d-%d] scheduled %d probes %.0f%%", lgl->stats->prb.basic.count, round, res, return_value_lglpcnt_11);
    }
  return res;
}

// lglsearch
// file lglib.c line 17247
static signed int lglsearch(struct LGL *lgl, struct Lim *lim)
{
  signed int res;
  lgl->searching = (char)1;
  lglstart(lgl, &lgl->times->srch);
  res=lgloop(lgl, lim);
  lgl->searching = (char)0;
  lglstop(lgl);
  return res;
}

// lglsec
// file lglib.c line 4985
double lglsec(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsec");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglflushtimers(lgl);
  return lgl->times->all;
}

// lglsetallphases
// file lglib.c line 6823
static void lglsetallphases(struct LGL *lgl)
{
  signed int res = 1;
  signed int idx = 2;
  _Bool tmp_if_expr_1;
  signed int return_value_lglisfree_2;
  _Bool tmp_if_expr_4;
  struct AVar *return_value_lglavar_3;
  do
  {
    if(!(res == 0))
      tmp_if_expr_1 = idx < lgl->nvars ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    return_value_lglisfree_2=lglisfree(lgl, idx);
    if(return_value_lglisfree_2 == 0)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_lglavar_3=lglavar(lgl, idx);
      tmp_if_expr_4 = return_value_lglavar_3->phase != 0 ? (_Bool)1 : (_Bool)0;
    }
    res = (signed int)tmp_if_expr_4;
    idx = idx + 1;
  }
  while((_Bool)1);
  lgl->allphaseset = (char)res;
}

// lglsetbinminrhs
// file lglib.c line 13045
static void lglsetbinminrhs(struct LGL *lgl, struct Gat *g)
{
  signed int a;
  a=lglcgrepr(lgl, g->_anon0.lits[(signed long int)0]);
  signed int b;
  b=lglcgrepr(lgl, g->_anon0.lits[(signed long int)1]);
  signed int return_value_abs_5;
  return_value_abs_5=abs(a);
  _Bool tmp_if_expr_7;
  signed int return_value_abs_6;
  if(return_value_abs_5 == 1)
  {
    return_value_abs_6=abs(b);
    tmp_if_expr_7 = return_value_abs_6 == 1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_7 = (_Bool)0;
  signed int return_value_abs_4;
  signed int return_value_abs_3;
  signed int return_value_abs_1;
  signed int return_value_abs_2;
  if(tmp_if_expr_7)
    g->minrhs = 0x7fffffff;

  else
  {
    return_value_abs_4=abs(a);
    if(return_value_abs_4 == 1)
      g->minrhs = b;

    else
    {
      return_value_abs_3=abs(b);
      if(return_value_abs_3 == 1)
        g->minrhs = a;

      else
      {
        return_value_abs_1=abs(a);
        return_value_abs_2=abs(b);
        g->minrhs = return_value_abs_1 < return_value_abs_2 ? a : b;
      }
    }
  }
}

// lglsetblklim
// file lglib.c line 11284
static void lglsetblklim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  signed int return_value_lglszpen_2;
  if(!(lgl->opts->blkrtc.val == 0))
  {
    lgl->limits->blk.steps = 0x7fffffffffffffffll;
    lglprt(lgl, 1, "[block-%d] no limit", lgl->stats->elm.count);
  }

  else
  {
    limit = ((signed long int)lgl->opts->blkreleff.val * lgl->stats->visits.search) / (signed long int)1000;
    if(!(limit >= (signed long int)lgl->opts->blkmineff.val))
      limit = (signed long int)lgl->opts->blkmineff.val;

    if(lgl->opts->blkmaxeff.val >= 0)
    {
      if(!((signed long int)lgl->opts->blkmaxeff.val >= limit))
        limit = (signed long int)lgl->opts->blkmaxeff.val;

    }

    signed int return_value_lglszpen_1;
    return_value_lglszpen_1=lglszpen(lgl);
    pen = lgl->limits->blk.pen + return_value_lglszpen_1;
    limit = limit >> pen;
    irrlim = (signed long int)lgl->stats->irr.lits.cur;
    irrlim = irrlim >> lgl->limits->simp.pen;
    if(!(limit >= irrlim))
    {
      limit = irrlim;
      lglprt(lgl, 1, "[block-%d] limit of %lld steps based on %d irredundant literals", lgl->stats->blk.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
    }

    else
    {
      return_value_lglszpen_2=lglszpen(lgl);
      lglprt(lgl, 1, "[block-%d] limit of %lld steps penalty %d = %d + %d", lgl->stats->blk.count, (signed long long int)limit, pen, lgl->limits->blk.pen, return_value_lglszpen_2);
    }
    lgl->limits->blk.steps = lgl->stats->blk.steps + limit;
  }
}

// lglsetccelim
// file lglib.c line 11450
static void lglsetccelim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->ccereleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->ccemineff.val))
    limit = (signed long int)lgl->opts->ccemineff.val;

  if(lgl->opts->ccemaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->ccemaxeff.val >= limit))
      limit = (signed long int)lgl->opts->ccemaxeff.val;

  }

  signed int return_value_lglszpen_1;
  return_value_lglszpen_1=lglszpen(lgl);
  pen = lgl->limits->cce.pen + return_value_lglszpen_1;
  limit = limit >> pen;
  irrlim = (signed long int)lgl->stats->irr.lits.cur;
  irrlim = irrlim >> lgl->limits->simp.pen;
  if(!(lgl->opts->block.val == 0))
  {
    if(lgl->blkrem == 0)
    {
      irrlim = irrlim * (signed long int)2;
      limit = limit * (signed long int)2;
    }

  }

  signed int return_value_lglszpen_2;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    lglprt(lgl, 1, "[cce-%d] limit of %lld steps based on %d irredundant literals", lgl->stats->cce.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    return_value_lglszpen_2=lglszpen(lgl);
    lglprt(lgl, 1, "[cce-%d] limit of %lld steps penalty %d = %d + %d", lgl->stats->cce.count, (signed long long int)limit, pen, lgl->limits->cce.pen, return_value_lglszpen_2);
  }
  lgl->limits->cce.steps = lgl->stats->cce.steps + limit;
}

// lglsetcgrclsrlim
// file lglib.c line 13759
static void lglsetcgrclsrlim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->cgreleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->cgrmineff.val))
    limit = (signed long int)lgl->opts->cgrmineff.val;

  if(lgl->opts->cgrmaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->cgrmaxeff.val >= limit))
      limit = (signed long int)lgl->opts->cgrmaxeff.val;

  }

  signed int return_value_lglszpen_1;
  return_value_lglszpen_1=lglszpen(lgl);
  pen = lgl->limits->cgr.pen + return_value_lglszpen_1;
  limit = limit >> pen;
  irrlim = (signed long int)(lgl->stats->irr.lits.cur / 2);
  irrlim = irrlim >> lgl->limits->simp.pen;
  signed int return_value_lglszpen_2;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    lglprt(lgl, 1, "[cgrclsr-%d] limit %lld based on %d irredundant literals", lgl->stats->cgr.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    return_value_lglszpen_2=lglszpen(lgl);
    lglprt(lgl, 1, "[cgrclsr-%d] limit %lld penalty %d = %d + %d", lgl->stats->cgr.count, (signed long long int)limit, pen, lgl->limits->cgr.pen, return_value_lglszpen_2);
  }
  lgl->limits->cgr.esteps = lgl->stats->cgr.esteps + limit;
  lgl->limits->cgr.csteps = lgl->stats->cgr.csteps + (signed long int)2 * limit;
}

// lglsetclifflim
// file lglib.c line 12037
static void lglsetclifflim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->cliffreleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->cliffmineff.val))
    limit = (signed long int)lgl->opts->cliffmineff.val;

  if(lgl->opts->cliffmaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->cliffmaxeff.val >= limit))
      limit = (signed long int)lgl->opts->cliffmaxeff.val;

  }

  signed int return_value_lglszpen_1;
  return_value_lglszpen_1=lglszpen(lgl);
  pen = lgl->limits->cliff.pen + return_value_lglszpen_1;
  limit = limit >> pen;
  irrlim = (signed long int)(2 * lgl->stats->irr.lits.cur);
  irrlim = irrlim >> lgl->limits->simp.pen;
  signed int return_value_lglszpen_2;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    lglprt(lgl, 1, "[cliff-%d] limit of %lld steps based on %d irredundant literals", lgl->stats->cliff.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    return_value_lglszpen_2=lglszpen(lgl);
    lglprt(lgl, 1, "[cliff-%d] limit of %lld steps penalty %d = %d + %d", lgl->stats->cliff.count, (signed long long int)limit, pen, lgl->limits->cliff.pen, return_value_lglszpen_2);
  }
  lgl->limits->cliff.steps = lgl->stats->cliff.steps + limit;
}

// lglsetconsumedunits
// file lglib.c line 1360
void lglsetconsumedunits(struct LGL *lgl, void (*fun)(void *, signed int), void *state)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetconsumedunits");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->units.consumed.fun = fun;
  lgl->cbs->units.consumed.state = state;
}

// lglsetconsumeunits
// file lglib.c line 1337
void lglsetconsumeunits(struct LGL *lgl, void (*fun)(void *, signed int **, signed int **), void *state)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetconsumeunits");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->units.consume.fun = fun;
  lgl->cbs->units.consume.state = state;
}

// lglsetdom
// file lglib.c line 2582
static void lglsetdom(struct LGL *lgl, signed int lit, signed int dom)
{
  signed int return_value_lglulit_1;
  return_value_lglulit_1=lglulit(lit);
  lgl->doms[(signed long int)return_value_lglulit_1] = dom;

__CPROVER_DUMP_L1:
  ;
}

// lglsetdonotesched
// file lglib.c line 11356
static void lglsetdonotesched(struct LGL *lgl, signed int completed)
{
  struct AVar *av;
  struct EVar *ev;
  signed int idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    av=lglavar(lgl, idx);
    ev=lglevar(lgl, idx);
    if(!(lgl->eliminating == 0))
    {
      if(!(completed == 0))
        av->donotelm = (unsigned int)0;

      else
        if(!(ev->pos >= 0))
          av->donotelm = (unsigned int)1;

    }

    if(!(lgl->blocking == 0))
    {
      if(!(completed == 0))
        av->donotblk = (unsigned int)0;

      else
        if(!(ev->pos >= 0))
          av->donotblk = (unsigned int)1;

    }

    if(!(lgl->cceing == 0))
    {
      if(!(completed == 0))
        av->donotcce = (unsigned int)0;

      else
        if(!(ev->pos >= 0))
          av->donotcce = (unsigned int)1;

    }

  }
}

// lglsetelmlim
// file lglib.c line 12095
static void lglsetelmlim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  signed int return_value_lglszpen_2;
  if(!(lgl->opts->elmrtc.val == 0))
  {
    lgl->limits->elm.steps = 0x7fffffffffffffffll;
    lglprt(lgl, 1, "[elim-%d] no limit", lgl->stats->elm.count);
  }

  else
  {
    limit = ((signed long int)lgl->opts->elmreleff.val * lgl->stats->visits.search) / (signed long int)1000;
    if(!(limit >= (signed long int)lgl->opts->elmineff.val))
      limit = (signed long int)lgl->opts->elmineff.val;

    if(lgl->opts->elmaxeff.val >= 0)
    {
      if(!((signed long int)lgl->opts->elmaxeff.val >= limit))
        limit = (signed long int)lgl->opts->elmaxeff.val;

    }

    signed int return_value_lglszpen_1;
    return_value_lglszpen_1=lglszpen(lgl);
    pen = lgl->limits->elm.pen + return_value_lglszpen_1;
    limit = limit >> pen;
    irrlim = (signed long int)lgl->stats->irr.lits.cur;
    irrlim = irrlim >> lgl->limits->simp.pen;
    if(!(limit >= irrlim))
    {
      limit = irrlim;
      lglprt(lgl, 1, "[elim-%d] limit of %lld steps based on %d irredundant literals", lgl->stats->elm.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
    }

    else
    {
      return_value_lglszpen_2=lglszpen(lgl);
      lglprt(lgl, 1, "[elim-%d] limit of %lld steps penalty %d = %d + %d", lgl->stats->elm.count, (signed long long int)limit, pen, lgl->limits->elm.pen, return_value_lglszpen_2);
    }
    lgl->limits->elm.steps = lgl->stats->elm.steps + limit;
  }
}

// lglseterm
// file lglib.h line 295
void lglseterm(struct LGL *lgl, signed int (*fun)(void *), void *state)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglseterm");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->term.fun = fun;
  lgl->cbs->term.state = state;
}

// lglseternreslim
// file lglib.c line 14656
static void lglseternreslim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  signed int return_value_lglszpen_2;
  if(!(lgl->opts->ternresrtc.val == 0))
  {
    limit = 0x7fffffffffffffffll;
    lglprt(lgl, 1, "[ternres-%d] no limit (run to completion)", lgl->stats->trnr.count);
  }

  else
  {
    limit = ((signed long int)lgl->opts->trnreleff.val * lgl->stats->visits.search) / (signed long int)1000;
    if(!(limit >= (signed long int)lgl->opts->trnrmineff.val))
      limit = (signed long int)lgl->opts->trnrmineff.val;

    if(lgl->opts->trnrmaxeff.val >= 0)
    {
      if(!((signed long int)lgl->opts->trnrmaxeff.val >= limit))
        limit = (signed long int)lgl->opts->trnrmaxeff.val;

    }

    signed int return_value_lglszpen_1;
    return_value_lglszpen_1=lglszpen(lgl);
    pen = lgl->limits->trnr.pen + return_value_lglszpen_1;
    limit = limit >> pen;
    irrlim = (signed long int)(4 * lgl->stats->irr.lits.cur);
    irrlim = irrlim >> lgl->limits->simp.pen;
    if(!(limit >= irrlim))
    {
      limit = irrlim;
      lglprt(lgl, 1, "[ternres-%d] limit %lld based on %d irredundant literals", lgl->stats->trnr.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
    }

    else
    {
      return_value_lglszpen_2=lglszpen(lgl);
      lglprt(lgl, 1, "[ternres-%d] limit %lld with penalty %d = %d + %d", lgl->stats->trnr.count, (signed long long int)limit, pen, lgl->limits->trnr.pen, return_value_lglszpen_2);
    }
  }
  lgl->limits->trnr.steps = lgl->stats->trnr.steps + limit;
}

// lglsetgausslim
// file lglib.c line 16781
static void lglsetgausslim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->gaussreleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->gaussmineff.val))
    limit = (signed long int)lgl->opts->gaussmineff.val;

  if(lgl->opts->gaussmaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->gaussmaxeff.val >= limit))
      limit = (signed long int)lgl->opts->gaussmaxeff.val;

  }

  signed int return_value_lglszpen_1;
  return_value_lglszpen_1=lglszpen(lgl);
  pen = lgl->limits->gauss.pen + return_value_lglszpen_1;
  limit = limit >> pen;
  irrlim = (signed long int)(lgl->stats->irr.lits.cur / 2);
  irrlim = irrlim >> lgl->limits->simp.pen;
  signed int return_value_lglszpen_2;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    lglprt(lgl, 1, "[gauss-%d] limit %lld based on %d irredundant literals", lgl->stats->gauss.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    return_value_lglszpen_2=lglszpen(lgl);
    lglprt(lgl, 1, "[gauss-%d] limit %lld penalty %d = %d + %d", lgl->stats->gauss.count, (signed long long int)limit, pen, lgl->limits->gauss.pen, return_value_lglszpen_2);
  }
  lgl->limits->gauss.steps.extr = lgl->stats->gauss.steps.extr + limit;
  lgl->limits->gauss.steps.elim = lgl->stats->gauss.steps.elim + limit;
}

// lglsetid
// file lglib.h line 134
void lglsetid(struct LGL *lgl, signed int tid, signed int tids)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetid");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(tid >= 0))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetid");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "negative id");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  while(tid >= tids)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetid");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "id exceed number of ids");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lgl->tid = tid;
  lgl->tids = tids;
}

// lglsetime
// file lglib.h line 306
void lglsetime(struct LGL *lgl, double (*time)(void))
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetime");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->getime = time;
}

// lglsetiteminrhs
// file lglib.c line 13069
static void lglsetiteminrhs(struct LGL *lgl, struct Gat *g)
{
  g->minrhs=lglcgrepr(lgl, g->_anon0._anon1.cond);
}

// lglsetjwhbias
// file lglib.c line 6809
static signed int lglsetjwhbias(struct LGL *lgl, signed int idx)
{
  signed long int pos;
  signed int return_value_lglulit_1;
  return_value_lglulit_1=lglulit(idx);
  pos = lgl->jwh[(signed long int)return_value_lglulit_1];
  signed long int neg;
  signed int return_value_lglulit_2;
  return_value_lglulit_2=lglulit(-idx);
  neg = lgl->jwh[(signed long int)return_value_lglulit_2];
  struct AVar *av;
  av=lglavar(lgl, idx);
  signed int bias;
  if(!(av->phase == 0))
    return (signed int)av->phase;

  else
  {
    bias = pos > neg ? 1 : -1;
    if((signed int)av->bias == bias)
      return bias;

    else
    {
      av->bias = bias;
      lgl->stats->phase.set = lgl->stats->phase.set + 1l;
      if(!(neg >= pos))
        lgl->stats->phase.pos = lgl->stats->phase.pos + 1l;

      else
        lgl->stats->phase.neg = lgl->stats->phase.neg + 1l;
      return bias;
    }
  }
}

// lglsetlim
// file lglib.c line 17705
static void lglsetlim(struct LGL *lgl, struct Lim *lim)
{
  signed long int clim;
  signed long int confs;
  signed long int delay;
  signed long int delayed;
  lim->decs = (signed long int)-1;
  clim = (signed long int)lgl->opts->clim.val;
  if(!(clim >= 0l))
  {
    lim->confs = (signed long int)-1;
    lglprt(lgl, 1, "[limits] no conflict limit");
  }

  else
  {
    confs = lgl->stats->confs;
    lim->confs = confs >= 0x7fffffffffffffffll - clim ? 0x7fffffffffffffffll : confs + clim;
    lglprt(lgl, 1, "[limits] conflict limit %lld after %lld conflicts", (signed long long int)lim->confs, (signed long long int)confs);
  }
  delay = (signed long int)lgl->opts->simpdelay.val;
  if(delay >= 1l)
  {
    delayed = lgl->stats->confs + delay;
    if(!(lgl->limits->simp.confs >= delayed))
    {
      lgl->limits->simp.confs = delayed;
      lglprt(lgl, 1, "[limits] simplification delayed by %lld to %lld conflicts", (signed long long int)delay, (signed long long int)lgl->limits->simp.confs);
    }

    else
      lglprt(lgl, 1, "[limits] simplification conflict limit already exceeds delay");
  }

  else
    lglprt(lgl, 1, "[limits] simplification not delayed since 'simpdelay == 0'");
}

// lglsetlockeq
// file lglib.c line 1346
void lglsetlockeq(struct LGL *lgl, signed int * (*fun)(void *), void *state)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetlockeq");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->eqs.lock.fun = fun;
  lgl->cbs->eqs.lock.state = state;
}

// lglsetlrgminrhs
// file lglib.c line 13056
static void lglsetlrgminrhs(struct LGL *lgl, struct Gat *g)
{
  signed int *p;
  signed int other;
  g->minrhs = 0x7fffffff;
  p = g->_anon0._anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    signed int return_value_abs_1;
    return_value_abs_1=abs(other);
    signed int return_value_abs_2;
    return_value_abs_2=abs(g->lhs);
    if(!(return_value_abs_1 == return_value_abs_2))
    {
      other=lglcgrepr(lgl, other);
      signed int return_value_abs_3;
      return_value_abs_3=abs(other);
      if(!(return_value_abs_3 == 1))
      {
        signed int return_value_abs_4;
        return_value_abs_4=abs(g->minrhs);
        signed int return_value_abs_5;
        return_value_abs_5=abs(other);
        if(!(return_value_abs_5 >= return_value_abs_4))
          g->minrhs = other;

      }

    }

    p = p + 1l;
  }
  while((_Bool)1);
}

// lglsetminrhs
// file lglib.c line 13074
static void lglsetminrhs(struct LGL *lgl, struct Gat *g)
{
  if((signed int)g->tag == ITETAG)
    lglsetiteminrhs(lgl, g);

  else
    if((signed int)g->size == 2)
      lglsetbinminrhs(lgl, g);

    else
      lglsetlrgminrhs(lgl, g);
  if(!((signed int)g->tag == ANDTAG))
  {
    if(!(g->minrhs >= 0))
      g->minrhs = -g->minrhs;

  }

}

// lglsetmsglock
// file lglib.h line 305
void lglsetmsglock(struct LGL *lgl, void (*lock)(void *), void (*unlock)(void *), void *state)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetmsglock");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->msglock.lock = lock;
  lgl->cbs->msglock.unlock = unlock;
  lgl->cbs->msglock.state = state;
}

// lglsetopt
// file lglib.h line 118
void lglsetopt(struct LGL *lgl, const char *opt, signed int val)
{
  signed int oldval;
  struct Opt *o = &lgl->opts->beforefirst + (signed long int)1;
  signed int tmp_statement_expression_1;
  for( ; &lgl->opts->afterlast + -1l >= o; o = o + 1l)
  {
    if(opt[1l] == 0)
    {
      if(o->shrt == *opt)
        break;

    }

    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(o->lng, opt);
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    if(tmp_statement_expression_1 == 0)
      break;

  }
  if(&lgl->opts->afterlast + -1l >= o)
  {
    if(!(val >= o->min))
      val = o->min;

    if(!(o->max >= val))
      val = o->max;

    oldval = o->val;
    o->val = val;
    if(o == &lgl->opts->flipping)
    {
      if(oldval == 0)
      {
        lgl->notflipped = 0;
        lgl->flipping = lgl->notflipped;
      }

    }

    if(o == &lgl->opts->plain)
    {
      if(oldval == 0 && val >= 1)
        lglsetplain(lgl, 1);

      if(val == 0 && !(oldval == 0))
        lglsetplain(lgl, 0);

    }

    if(o == &lgl->opts->phase)
    {
      if(!(val == oldval))
        lgl->flushphases = (char)1;

    }

    if((signed int)lgl->state == UNUSED)
    {

    __CPROVER_DUMP_L11:
      ;
      do
        lgl->state = (enum State)OPTSET;
      while((_Bool)0);
    }

    while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
    {
      lgltrapi(lgl, "option %s %d", opt, val);
      break;
    }
    if(!(lgl->clone == ((struct LGL *)NULL)))
      lglsetopt(lgl->clone, opt, val);

  }

}

// lglsetout
// file lglib.h line 112
void lglsetout(struct LGL *lgl, struct _IO_FILE *out)
{
  lgl->out = out;
}

// lglsetphase
// file lglib.c line 3899
void lglsetphase(struct LGL *lgl, signed int elit)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetphase");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetphase");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "invalid literal argument");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "setphase %d", elit);
    break;
  }
  if(!(elit >= 0))
    lglesetphase(lgl, -elit, -1);

  else
    lglesetphase(lgl, elit, 1);
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglsetphase(lgl->clone, elit);

}

// lglsetphases
// file lglib.c line 17463
void lglsetphases(struct LGL *lgl)
{
  signed int elit;
  signed int phase;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetphases");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "setphases");
    break;
  }

__CPROVER_DUMP_L5:
  ;
  do
  {
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetphases");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

    while((96 & (signed int)lgl->state) == 0)
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetphases");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "!(%s)", (const void *)"SATISFIED | EXTENDED");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
  }
  while((_Bool)0);
  if((EXTENDED & (signed int)lgl->state) == 0)
    lglextend(lgl);

  elit = 1;
  for( ; lgl->maxext >= elit; elit = elit + 1)
  {
    phase=lglederef(lgl, elit);
    lglesetphase(lgl, elit, phase);
  }
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglsetphases(lgl->clone);

}

// lglsetplain
// file lglib.c line 1652
static void lglsetplain(struct LGL *lgl, signed int val)
{
  lgl->opts->block.val = (signed int)!(val != 0);
  lgl->opts->card.val = (signed int)!(val != 0);
  lgl->opts->cce.val = (signed int)!(val != 0);
  lgl->opts->cliff.val = (signed int)!(val != 0);
  lgl->opts->cgrclsr.val = (signed int)!(val != 0);
  lgl->opts->decompose.val = (signed int)!(val != 0);
  lgl->opts->elim.val = (signed int)!(val != 0);
  lgl->opts->gauss.val = (signed int)!(val != 0);
  lgl->opts->lift.val = (signed int)!(val != 0);
  lgl->opts->probe.val = (signed int)!(val != 0);
  lgl->opts->ternres.val = (signed int)!(val != 0);
  lgl->opts->transred.val = (signed int)!(val != 0);
  lgl->opts->unhide.val = (signed int)!(val != 0);
  lglprt(lgl, 1, "[plain] plain solving switched %s", val != 0 ? "on" : "off");
}

// lglsetprbasiclim
// file lglib.c line 8941
static void lglsetprbasiclim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->prbasicreleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->prbasicmineff.val))
    limit = (signed long int)lgl->opts->prbasicmineff.val;

  if(lgl->opts->prbasicmaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->prbasicmaxeff.val >= limit))
      limit = (signed long int)lgl->opts->prbasicmaxeff.val;

  }

  signed int return_value_lglszpen_1;
  return_value_lglszpen_1=lglszpen(lgl);
  pen = lgl->limits->prb.pen.basic + return_value_lglszpen_1;
  limit = limit >> pen;
  irrlim = (signed long int)(lgl->stats->irr.lits.cur / 2);
  irrlim = irrlim >> lgl->limits->simp.pen;
  signed int return_value_lglszpen_2;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    lglprt(lgl, 1, "[basicprobe-%d] limit %lld based on %d irredundant litearls", lgl->stats->prb.basic.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    return_value_lglszpen_2=lglszpen(lgl);
    lglprt(lgl, 1, "[basicprobe-%d] limit %lld penalty %d = %d + %d", lgl->stats->prb.basic.count, (signed long long int)limit, pen, lgl->limits->prb.pen.basic, return_value_lglszpen_2);
  }
  lgl->limits->prb.steps = lgl->stats->prb.basic.steps + limit;
}

// lglsetprefix
// file lglib.h line 113
void lglsetprefix(struct LGL *lgl, const char *prefix)
{
  lgldelstr(lgl, lgl->prefix);
  lgl->prefix=lglstrdup(lgl, prefix);
}

// lglsetproduceunit
// file lglib.c line 1330
void lglsetproduceunit(struct LGL *lgl, void (*fun)(void *, signed int), void *state)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetproduceunit");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->units.produce.fun = fun;
  lgl->cbs->units.produce.state = state;
}

// lglsetrdlim
// file lglib.c line 14886
static void lglsetrdlim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->trdreleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->trdmineff.val))
    limit = (signed long int)lgl->opts->trdmineff.val;

  if(lgl->opts->trdmaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->trdmaxeff.val >= limit))
      limit = (signed long int)lgl->opts->trdmaxeff.val;

  }

  signed int return_value_lglszpen_1;
  return_value_lglszpen_1=lglszpen(lgl);
  pen = lgl->limits->trd.pen + return_value_lglszpen_1;
  limit = limit >> pen;
  irrlim = (signed long int)lgl->stats->irr.lits.cur;
  irrlim = irrlim >> lgl->limits->simp.pen;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int return_value_lglszpen_4;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    tmp_post_2 = lgl->stats->trd.count;
    lgl->stats->trd.count = lgl->stats->trd.count + 1;
    lglprt(lgl, 1, "[transred-%d] limit %lld based on %d irredundant literals", tmp_post_2, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    tmp_post_3 = lgl->stats->trd.count;
    lgl->stats->trd.count = lgl->stats->trd.count + 1;
    return_value_lglszpen_4=lglszpen(lgl);
    lglprt(lgl, 1, "[transred-%d] limit %lld with penalty %d = %d + %d", tmp_post_3, (signed long long int)limit, pen, lgl->limits->trd.pen, return_value_lglszpen_4);
  }
  lgl->limits->trd.steps = lgl->stats->trd.steps + limit;
}

// lglsetunhdlim
// file lglib.c line 16124
static void lglsetunhdlim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->unhdreleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->unhdmineff.val))
    limit = (signed long int)lgl->opts->unhdmineff.val;

  if(lgl->opts->unhdmaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->unhdmaxeff.val >= limit))
      limit = (signed long int)lgl->opts->unhdmaxeff.val;

  }

  signed int return_value_lglszpen_1;
  return_value_lglszpen_1=lglszpen(lgl);
  pen = lgl->limits->unhd.pen + return_value_lglszpen_1;
  limit = limit >> pen;
  irrlim = (signed long int)lgl->stats->irr.lits.cur;
  irrlim = irrlim >> lgl->limits->simp.pen;
  signed int return_value_lglszpen_2;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    lglprt(lgl, 1, "[unhide-%d] limit %lld based on %d irredundant literals", lgl->stats->unhd.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    return_value_lglszpen_2=lglszpen(lgl);
    lglprt(lgl, 1, "[unhide-%d] limit %lld with penalty %d = %d + %d", lgl->stats->unhd.count, (signed long long int)limit, pen, lgl->limits->unhd.pen, return_value_lglszpen_2);
  }
  lgl->limits->unhd.steps = lgl->stats->unhd.steps + limit;
}

// lglsetunlockeq
// file lglib.c line 1353
void lglsetunlockeq(struct LGL *lgl, void (*fun)(void *, signed int, signed int), void *state)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetunlockeq");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->eqs.unlock.fun = fun;
  lgl->cbs->eqs.unlock.state = state;
}

// lglsetup
// file lglib.c line 17294
static void lglsetup(struct LGL *lgl)
{
  unsigned int return_value_lglrand_1;
  if(!((signed int)lgl->state == RESET))
  {
    lgl->limits->dfg.pshwchs = lgl->stats->pshwchs + (signed long int)lgl->opts->defragint.val;
    lgl->limits->reduce.inner = lgl->opts->redlinit.val;
    lglboundredl(lgl);
    lgl->limits->reduce.outer = 2 * lgl->limits->reduce.inner;
    lgl->limits->blk.irrprgss = (signed long int)-1;
    lgl->limits->elm.irrprgss = (signed long int)-1;
    lgl->limits->simp.prgss = (signed long int)-1;
    lgl->limits->term.steps = (signed long int)-1;
    lgl->limits->flipint = lgl->opts->flipint.val;
    lgl->phaseneg = lgl->opts->phaseneginit.val;
    lglincrestartl(lgl, 0);
    lgl->rng.w = (unsigned int)lgl->opts->seed.val;
    lgl->rng.z = ~lgl->rng.w;
    lgl->rng.w = lgl->rng.w << 1;
    lgl->rng.z = lgl->rng.z << 1;
    lgl->rng.w = lgl->rng.w + (unsigned int)1;
    lgl->rng.z = lgl->rng.z + (unsigned int)1;
    lgl->rng.w = lgl->rng.w * 2019164533u;
    lgl->rng.z = lgl->rng.z * 1000632769u;
    lgl->limits->randec = lgl->limits->randec + (signed long int)(lgl->opts->randecint.val / 2);
    return_value_lglrand_1=lglrand(lgl);
    lgl->limits->randec = lgl->limits->randec + (signed long int)(return_value_lglrand_1 % (unsigned int)lgl->opts->randecint.val);
    lglchkenv(lgl);
  }

  do
  {

  DONE:
    ;
    (void)0;

  __CPROVER_DUMP_L2:
    ;
    lgl->state = (enum State)READY;
  }
  while((_Bool)0);
}

// lglsgn
// file lglib.c line 2459
static signed int lglsgn(signed int lit)
{
  return lit < 0 ? -1 : 1;
}

// lglshrinkhts
// file lglib.c line 3029
static void lglshrinkhts(struct LGL *lgl, struct HTS *hts, signed int newcount)
{
  signed int *p;
  signed int i;
  signed int oldcount = hts->count;
  if(!(newcount == oldcount))
  {
    p=lglhts2wchs(lgl, hts);
    i = newcount;
    for( ; !(i >= oldcount); i = i + 1)
      p[(signed long int)i] = 0;
    hts->count = newcount;
    if(newcount == 0)
    {
      lglfreewch(lgl, hts->offset, oldcount);
      hts->offset = 0;
    }

  }

}

// lglshrstk
// file lglib.c line 1415
static void lglshrstk(struct LGL *lgl, struct Stk *s, signed int new_size)
{
  unsigned long int old_size;
  unsigned long int count;
  count=lglcntstk(s);
  if(new_size >= 1)
  {
    old_size=lglszstk(s);
    do
    {
      void *return_value_lglrsz_1;
      return_value_lglrsz_1=lglrsz(lgl, (void *)s->start, old_size * sizeof(signed int) /*4ul*/ , (unsigned long int)new_size * sizeof(signed int) /*4ul*/ );
      s->start = (signed int *)return_value_lglrsz_1;
    }
    while((_Bool)0);
    s->top = s->start + (signed long int)count;
    s->end = s->start + (signed long int)new_size;
  }

  else
    lglrelstk(lgl, s);
}

// lglsig
// file lglib.c line 9301
static unsigned int lglsig(signed int lit)
{
  unsigned int ulit;
  signed int return_value_lglulit_1;
  return_value_lglulit_1=lglulit(lit);
  ulit = (unsigned int)return_value_lglulit_1;
  unsigned int res;
  ulit = ulit - (unsigned int)2;
  res = 1u << (ulit & (unsigned int)31);
  return res;
}

// lglsignedmark
// file lglib.c line 7205
static void lglsignedmark(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int bit = 1 << (signed int)(lit < 0);
  if((av->mark & bit) == 0)
    av->mark = av->mark | bit;

}

// lglsignedmark2
// file lglib.c line 11486
static void lglsignedmark2(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int bit = 1 << 2 + (signed int)(lit < 0);
  if((av->mark & bit) == 0)
    av->mark = av->mark | bit;

}

// lglsignedmarked
// file lglib.c line 7224
static signed int lglsignedmarked(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int bit = 1 << (signed int)(lit < 0);
  return av->mark & bit;
}

// lglsignedmarked2
// file lglib.c line 11500
static signed int lglsignedmarked2(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int bit = 1 << 2 + (signed int)(lit < 0);
  return av->mark & bit;
}

// lglsignedmarknpushseen
// file lglib.c line 7219
static void lglsignedmarknpushseen(struct LGL *lgl, signed int lit)
{
  lglsignedmark(lgl, lit);
  lglpushstk(lgl, &lgl->seen, lit);
}

// lglsignedunmark
// file lglib.c line 7212
static void lglsignedunmark(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int bit = 1 << (signed int)(lit < 0);
  if(!((av->mark & bit) == 0))
    av->mark = av->mark & ~bit;

}

// lglsignedunmark2
// file lglib.c line 11493
static void lglsignedunmark2(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int bit = 1 << 2 + (signed int)(lit < 0);
  if(!((av->mark & bit) == 0))
    av->mark = av->mark & ~bit;

}

// lglsimp
// file lglib.c line 17875
signed int lglsimp(struct LGL *lgl, signed int iterations)
{
  struct Lim lim;
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsimp");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "simp %d", iterations);
    break;
  }
  while(!(iterations >= 0))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsimp");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "negative number of simplification iterations");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  do
  {
    signed int return_value_lglmtstk_1;
    return_value_lglmtstk_1=lglmtstk(&lgl->clause);
    if(!(return_value_lglmtstk_1 == 0))
      break;

    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsimp");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "clause terminating zero missing");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
  }
  while((_Bool)0);
  lglstart(lgl, &lgl->times->all);
  lgl->stats->calls.simp = lgl->stats->calls.simp + 1l;
  do
    memset((void *)&lim, 0, sizeof(struct Lim) /*16ul*/ );
  while((_Bool)0);
  lim.decs = lgl->stats->decisions;
  res=lglisat(lgl, &lim, iterations);
  lglstop(lgl);

__CPROVER_DUMP_L11:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglsimp(lgl->clone, iterations);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsimp");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d", (const void *)"lglsimp", iterations, CLONERES, (const void *)"lglsimp", iterations, res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglsimpand
// file lglib.c line 13437
static signed int lglsimpand(struct LGL *lgl, struct Gat *g)
{
  signed int return_value_lglsimpbinand_1;
  signed int return_value_lglsimplrgand_2;
  if((signed int)g->size == 2)
  {
    return_value_lglsimpbinand_1=lglsimpbinand(lgl, g);
    return return_value_lglsimpbinand_1;
  }

  else
  {
    return_value_lglsimplrgand_2=lglsimplrgand(lgl, g);
    return return_value_lglsimplrgand_2;
  }
}

// lglsimpbinand
// file lglib.c line 13334
static signed int lglsimpbinand(struct LGL *lgl, struct Gat *g)
{
  signed int lhs;
  signed int a;
  signed int b;
  signed int res;
  signed int conflict;
  lhs=lglcgrepr(lgl, g->lhs);
  a=lglcgrepr(lgl, -g->_anon0.lits[(signed long int)0]);
  b=lglcgrepr(lgl, -g->_anon0.lits[(signed long int)1]);
  res = 0;
  conflict = res;
  signed int return_value_lglcgunit_1;
  signed int return_value_lglcgunit_2;
  if(a == 1 && b == 1)
  {
    if(lhs == 1)
      return 0;

    res = 1;

  __CPROVER_DUMP_L2:
    ;
    if(lhs == -1)
      conflict = 1;

    else
    {
      return_value_lglcgunit_1=lglcgunit(lgl, lhs);
      conflict = (signed int)!(return_value_lglcgunit_1 != 0);
    }
  }

  else
    if(a == -1 || a == -b || b == -1)
    {
      if(lhs == -1)
        return 0;

      res = 1;

    __CPROVER_DUMP_L7:
      ;
      if(lhs == 1)
        conflict = 1;

      else
      {
        return_value_lglcgunit_2=lglcgunit(lgl, -lhs);
        conflict = (signed int)!(return_value_lglcgunit_2 != 0);
      }
    }

    else
    {
      if(b == 1)
        do
        {
          signed int TMP = a;
          a = b;
          b = TMP;
        }
        while((_Bool)0);

      if(a == 1)
      {
        if(lhs == b)
          return 0;

        res = 1;

      __CPROVER_DUMP_L14:
        ;
        if(lhs == -b)
          conflict = 1;

        else
          lglcgmerge(lgl, lhs, b);
      }

    }
  if(!(res == 0))
  {
    lgl->_anon0.cgr->simplified.all = lgl->_anon0.cgr->simplified.all + 1;
    lgl->stats->cgr.simplified.all = lgl->stats->cgr.simplified.all + 1;
    lgl->_anon0.cgr->simplified.and = lgl->_anon0.cgr->simplified.and + 1;
    lgl->stats->cgr.simplified.and = lgl->stats->cgr.simplified.and + 1;
  }

  if(!(conflict == 0))
  {

  __CPROVER_DUMP_L18:
    ;
    lgl->mt = 1;
  }

  return res;
}

// lglsimpbinxor
// file lglib.c line 13443
static signed int lglsimpbinxor(struct LGL *lgl, struct Gat *g)
{
  signed int res;
  signed int conflict;
  signed int lhs;
  signed int rhs;
  signed int a;
  signed int b;
  signed int return_value_lglcgrepr_1;
  return_value_lglcgrepr_1=lglcgrepr(lgl, g->lhs);
  lhs = -return_value_lglcgrepr_1;
  a=lglcgrepr(lgl, g->_anon0.lits[(signed long int)0]);
  b=lglcgrepr(lgl, g->_anon0.lits[(signed long int)1]);
  res = 0;
  conflict = res;
  rhs = conflict;
  if(a == b)
    rhs = -1;

  else
    if(a == -b)
      rhs = 1;

    else
      if(a == 1)
        rhs = -b;

      else
        if(a == -1)
          rhs = b;

        else
          if(b == 1)
            rhs = -a;

          else
            if(b == -1)
              rhs = a;

            else
              if(lhs == 1)
              {
                lhs = a;
                rhs = -b;
              }

              else
                if(lhs == -1)
                {
                  lhs = a;
                  rhs = b;
                }

  if(!(rhs == 0) && !(rhs == lhs))
    res = 1;

  if(!(res == 0))
  {

  __CPROVER_DUMP_L10:
    ;
    lgl->_anon0.cgr->simplified.all = lgl->_anon0.cgr->simplified.all + 1;
    lgl->stats->cgr.simplified.all = lgl->stats->cgr.simplified.all + 1;
    lgl->_anon0.cgr->simplified.xor = lgl->_anon0.cgr->simplified.xor + 1;
    lgl->stats->cgr.simplified.xor = lgl->stats->cgr.simplified.xor + 1;
    conflict=lglcgmergelhsrhs(lgl, lhs, rhs);
  }

  if(!(conflict == 0))
  {

  __CPROVER_DUMP_L12:
    ;
    lgl->mt = 1;
  }

  return res;
}

// lglsimpcls
// file lglib.c line 2969
static signed int lglsimpcls(struct LGL *lgl)
{
  signed int *p;
  signed int *q = lgl->clause.start;
  signed int lit;
  signed int tmp;
  signed int mark;
  p = lgl->clause.start;
  signed int *tmp_post_1;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    tmp=lglcval(lgl, lit);
    if(tmp == 1)
    {

    __CPROVER_DUMP_L2:
      ;
      break;
    }

    if(tmp == -1)

      __CPROVER_DUMP_L4:
        ;

    else
    {
      mark=lglmarked(lgl, lit);
      if(mark >= 1)

        __CPROVER_DUMP_L6:
          ;

      else
      {
        if(!(mark >= 0))
        {

        __CPROVER_DUMP_L8:
          ;
          break;
        }

        tmp_post_1 = q;
        q = q + 1l;
        *tmp_post_1 = lit;
        lglmark(lgl, lit);
      }
    }
    p = p + 1l;
  }
  while((_Bool)1);
  *q = 0;
  lgl->clause.top = q + (signed long int)1;
  while(!(lgl->clause.start >= q))
  {
    q = q - 1l;
    lglunmark(lgl, *q);
  }
  if(!(lit == 0))

    __CPROVER_DUMP_L14:
      ;

  else

    __CPROVER_DUMP_L15:
      ;
  return lit;
}

// lglsimpcntrem
// file lglib.c line 17137
static signed int lglsimpcntrem(struct LGL *lgl, signed int oldrem)
{
  signed int rem;
  rem=lglrem(lgl);
  signed int removed = oldrem - rem;
  signed int pcnt;
  signed long int pcnt64;
  if(!(removed >= 1))
    pcnt = 0;

  else
  {
    pcnt64 = (signed long int)((100 * removed) / oldrem);
    pcnt = (signed int)pcnt64;
  }
  lglprt(lgl, 1, "[simplification-%d] removed %d variables %d%%", lgl->stats->simp.count, removed, pcnt);
  return pcnt;
}

// lglsimpgate
// file lglib.c line 13608
static signed int lglsimpgate(struct LGL *lgl, struct Gat *g)
{
  signed int return_value_lglsimpand_1;
  signed int return_value_lglsimpite_2;
  if((signed int)g->tag == ANDTAG)
  {
    return_value_lglsimpand_1=lglsimpand(lgl, g);
    return return_value_lglsimpand_1;
  }

  else
    if((signed int)g->tag == ITETAG)
    {
      return_value_lglsimpite_2=lglsimpite(lgl, g);
      return return_value_lglsimpite_2;
    }

    else
    {
      signed int return_value_lglsimpxor_3;
      return_value_lglsimpxor_3=lglsimpxor(lgl, g);
      return return_value_lglsimpxor_3;
    }
}

// lglsimpite
// file lglib.c line 13523
static signed int lglsimpite(struct LGL *lgl, struct Gat *g)
{
  signed int glhs = g->lhs;
  signed int lhs;
  lhs=lglcgrepr(lgl, glhs);
  signed int gc;
  gc=lglcgrepr(lgl, g->_anon0._anon1.cond);
  signed int gp;
  gp=lglcgrepr(lgl, g->_anon0._anon1.pos);
  signed int gn;
  gn=lglcgrepr(lgl, g->_anon0._anon1.neg);
  signed int res;
  signed int conflict;
  signed int rhs;
  signed int gate;
  res = 0;
  conflict = res;
  rhs = conflict;
  gate = rhs;
  if(gc == 1 || gp == gn)
  {
    res = 1;
    rhs = gp;
  }

  else
    if(gc == -1)
    {
      res = 1;
      rhs = gn;
    }

    else
      if(gn == -1 && gp == 1)
      {
        res = 1;
        rhs = gc;
      }

      else
        if(gn == 1 && gp == -1)
        {
          res = 1;
          rhs = -gc;
        }

        else
          if(gc == gn || gn == -1)
          {
            if(gp == 1)
            {
              res = 1;
              rhs = gc;
            }

            else
              if(gp == -1)
              {
                res = 1;
                rhs = -1;
              }

              else
              {
                res=lglnewbingate(lgl, (enum GTag)ANDTAG, glhs, -gc, -gp);
                gate = 1;
              }
          }

          else
            if(gc == -gp || gp == -1)
            {
              if(gn == 1)
              {
                res = 1;
                rhs = -gc;
              }

              else
              {
                res=lglnewbingate(lgl, (enum GTag)ANDTAG, glhs, gc, -gn);
                gate = 1;
              }
            }

            else
              if(gc == gp || gp == 1)
              {
                if(gn == 1)
                {
                  res = 1;
                  rhs = 1;
                }

                else
                {
                  res=lglnewbingate(lgl, (enum GTag)ANDTAG, -glhs, gc, gn);
                  gate = 1;
                }
              }

              else
                if(gc == -gn || gn == 1)
                {
                  if(gp == 1)
                  {
                    res = 1;
                    rhs = 1;
                  }

                  else
                  {
                    res=lglnewbingate(lgl, (enum GTag)ANDTAG, -glhs, gp, -gc);
                    gate = 1;
                  }
                }

                else
                  if(gp == -gn)
                  {
                    res=lglnewbingate(lgl, (enum GTag)XORTAG, -glhs, gc, gn);
                    gate = 1;
                  }

  if(gate == 0 && lhs == rhs && !(res == 0))
    res = 0;

  if(!(res == 0) && (!(gate == 0) || !(lhs == rhs)))
  {

  __CPROVER_DUMP_L20:
    ;
    lgl->_anon0.cgr->simplified.all = lgl->_anon0.cgr->simplified.all + 1;
    lgl->stats->cgr.simplified.all = lgl->stats->cgr.simplified.all + 1;
    lgl->_anon0.cgr->simplified.ite = lgl->_anon0.cgr->simplified.ite + 1;
    lgl->stats->cgr.simplified.ite = lgl->stats->cgr.simplified.ite + 1;
    if(gate == 0)
    {
      if(!(lhs == rhs))
        conflict=lglcgmergelhsrhs(lgl, lhs, rhs);

      else
        res = 0;
    }

  }

  if(!(conflict == 0))
  {

  __CPROVER_DUMP_L23:
    ;
    lgl->mt = 1;
  }

  return res;
}

// lglsimpleprobebinexists
// file lglib.c line 8617
static signed int lglsimpleprobebinexists(struct LGL *lgl, signed int a, signed int b)
{
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  struct HTS *hts;
  hts=lglhts(lgl, a);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(tag == BINCS)
    {
      red = blit & REDCS;
      if(red == 0)
      {
        other = blit >> RMSHFT;
        if(other == b)
          return 1;

      }

    }

  }
  return 0;
}

// lglsimpleprobeclausexists
// file lglib.c line 8703
static signed int lglsimpleprobeclausexists(struct LGL *lgl)
{
  signed int len;
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(&lgl->clause);
  len = (signed int)(return_value_lglcntstk_1 - (unsigned long int)1);
  signed int a;
  signed int b;
  signed int c;
  signed int *p;
  signed int *s;
  signed int res;
  s = lgl->clause.start;
  p = s + (signed long int)1;
  struct HTS *return_value_lglhts_2;
  struct HTS *return_value_lglhts_3;
  for( ; !(p + 1l >= lgl->clause.top); p = p + 1l)
  {
    return_value_lglhts_2=lglhts(lgl, *s);
    return_value_lglhts_3=lglhts(lgl, *p);
    if(!(return_value_lglhts_3->count >= return_value_lglhts_2->count))
      do
      {
        signed int TMP = *s;
        *s = *p;
        *p = TMP;
      }
      while((_Bool)0);

  }
  a = lgl->clause.start[(signed long int)0];
  if(len == 2)
  {
    b = lgl->clause.start[(signed long int)1];
    res=lglsimpleprobebinexists(lgl, a, b);
  }

  else
    if(len == 3)
    {
      b = lgl->clause.start[(signed long int)1];
      c = lgl->clause.start[(signed long int)2];
      res=lglsimpleprobetrnexists(lgl, a, b, c);
    }

    else
      if(len >= 4)
        res=lglsimpleprobelrgexists(lgl, a);

      else
        res = 0;
  if(!(res == 0))

    __CPROVER_DUMP_L9:
      ;

  return res;
}

// lglsimpleprobelrgexists
// file lglib.c line 8663
static signed int lglsimpleprobelrgexists(struct LGL *lgl, signed int a)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int lidx;
  signed int res;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  const signed int *q;
  struct HTS *hts;
  p = lgl->clause.start;
  for( ; !(p + 1l >= lgl->clause.top); p = p + 1l)
  {
    other = *p;
    lglsignedmark(lgl, other);
  }
  hts=lglhts(lgl, a);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  res = 0;
  p = w;
  _Bool tmp_if_expr_3;
  signed int return_value_lglsignedmarked_2;
  signed int return_value_lglsignedmarked_4;
  for( ; res == 0 && !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    red = blit & REDCS;
    if(!(tag == LRGCS) && red == 0)
    {
      other = blit >> RMSHFT;
      if(tag == BINCS)
        res=lglsignedmarked(lgl, other);

      else
        if(tag == TRNCS)
        {
          other2 = *p;
          signed int return_value_lglsignedmarked_1;
          return_value_lglsignedmarked_1=lglsignedmarked(lgl, other);
          if(!(return_value_lglsignedmarked_1 == 0))
          {
            return_value_lglsignedmarked_2=lglsignedmarked(lgl, other2);
            tmp_if_expr_3 = return_value_lglsignedmarked_2 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_3 = (_Bool)0;
          res = (signed int)tmp_if_expr_3;
        }

        else
        {
          lidx = other;
          c=lglidx2lits(lgl, OCCS, 0, lidx);
          q = c;
          do
          {
            other = *q;
            if(other == 0)
              break;

            return_value_lglsignedmarked_4=lglsignedmarked(lgl, other);
            if(return_value_lglsignedmarked_4 == 0)
              break;

            q = q + 1l;
          }
          while((_Bool)1);
          res = (signed int)!(other != 0);
        }
    }

  }
  p = lgl->clause.start;
  for( ; !(p + 1l >= lgl->clause.top); p = p + 1l)
    lglunmark(lgl, *p);
  return res;
}

// lglsimpleprobetrnexists
// file lglib.c line 8637
static signed int lglsimpleprobetrnexists(struct LGL *lgl, signed int a, signed int b, signed int c)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  struct HTS *hts;
  hts=lglhts(lgl, a);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    red = blit & REDCS;
    if(red == 0)
    {
      other = blit >> RMSHFT;
      if(tag == BINCS)
      {
        if(other == b)
          return 1;

        if(other == c)
          return 1;

      }

      else
        if(tag == TRNCS)
        {
          other2 = *p;
          if(other == b && other2 == c)
            return 1;

          if(other == c && other2 == b)
            return 1;

        }

    }

  }
  return 0;
}

// lglsimplimhit
// file lglib.c line 17165
static signed int lglsimplimhit(struct LGL *lgl)
{
  if(lgl->opts->inprocessing.val == 0)
  {
    if(lgl->stats->simp.count == 0)
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(lgl->stats->confs >= lgl->limits->simp.confs))
      return 0;

    else
    {
      lgl->stats->simp.climhit = lgl->stats->simp.climhit + 1;
      lglprt(lgl, 1, "[simplification-%d] limit hit at %lld conflicts", lgl->stats->simp.count + 1, (signed long long int)lgl->stats->confs);
      if(!(lgl->limits->simp.pen == 0))
        lglprt(lgl, 1, "[simplification-%d] simplification penalty of %d", lgl->stats->simp.count + 1, lgl->limits->simp.pen);

      else
        lglprt(lgl, 1, "[simplification-%d] no simplification penalty", lgl->stats->simp.count + 1);
      return 1;
    }
  }
}

// lglsimplrgand
// file lglib.c line 13375
static signed int lglsimplrgand(struct LGL *lgl, struct Gat *g)
{
  signed int *p;
  signed int lhs;
  signed int other;
  signed int repr;
  signed int conflict;
  signed int res;
  signed int foundfalse;
  signed int rhs;
  signed int bit;
  signed int found;
  struct AVar *u;
  lhs=lglcgrepr(lgl, g->lhs);
  foundfalse = 0;
  rhs = foundfalse;
  found = 0;
  p = g->_anon0._anon0.cls;
  _Bool tmp_if_expr_1;
  do
  {
    if(foundfalse == 0)
    {
      other = *p;
      tmp_if_expr_1 = other != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    if(other == g->_anon0._anon0.origlhs)
      found = found + 1;

    else
    {
      lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
      repr=lglcgrepr(lgl, -other);
      if(!(repr == 1))
      {
        if(repr == -1)
        {
          foundfalse = 1;
          break;
        }

        if(!(rhs == 0))
          rhs = 0x7fffffff;

        else
          rhs = repr;
        u=lglavar(lgl, repr);
        bit = 1 << (signed int)(repr < 0);
        if((u->mark & bit) == 0)
        {
          if(!(((3 ^ bit) & u->mark) == 0))
          {
            foundfalse = 1;
            break;
          }

          u->mark = u->mark | bit;
        }

      }

    }
    p = p + 1l;
  }
  while((_Bool)1);
  p = g->_anon0._anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    if(!(other == g->_anon0._anon0.origlhs))
    {
      repr=lglcgrepr(lgl, other);
      signed int return_value_abs_2;
      return_value_abs_2=abs(repr);
      if(!(return_value_abs_2 == 1))
      {
        struct AVar *return_value_lglavar_3;
        return_value_lglavar_3=lglavar(lgl, repr);
        return_value_lglavar_3->mark = 0;
      }

    }

    p = p + 1l;
  }
  while((_Bool)1);
  res = 0;
  conflict = res;
  signed int return_value_lglcgunit_4;
  signed int return_value_lglcgunit_5;
  if(!(foundfalse == 0))
  {
    if(!(lhs == -1))
    {
      res = 1;

    __CPROVER_DUMP_L14:
      ;
      if(lhs == 1)
        conflict = 1;

      else
      {
        return_value_lglcgunit_4=lglcgunit(lgl, -lhs);
        conflict = (signed int)!(return_value_lglcgunit_4 != 0);
      }
    }

  }

  else
    if(rhs == 0)
    {
      if(!(lhs == 1))
      {
        res = 1;

      __CPROVER_DUMP_L19:
        ;
        if(lhs == -1)
          conflict = 1;

        else
        {
          return_value_lglcgunit_5=lglcgunit(lgl, lhs);
          conflict = (signed int)!(return_value_lglcgunit_5 != 0);
        }
      }

    }

    else
      if(!(rhs == 0x7fffffff))
      {
        if(!(lhs == rhs))
        {
          res = 1;

        __CPROVER_DUMP_L24:
          ;
          if(lhs == -rhs)
            conflict = 1;

          else
            lglcgmerge(lgl, lhs, rhs);
        }

      }

  if(!(res == 0))
  {
    lgl->_anon0.cgr->simplified.all = lgl->_anon0.cgr->simplified.all + 1;
    lgl->stats->cgr.simplified.all = lgl->stats->cgr.simplified.all + 1;
    lgl->_anon0.cgr->simplified.and = lgl->_anon0.cgr->simplified.and + 1;
    lgl->stats->cgr.simplified.and = lgl->stats->cgr.simplified.and + 1;
  }

  if(!(conflict == 0))
  {

  __CPROVER_DUMP_L28:
    ;
    lgl->mt = 1;
  }

  return res;
}

// lglsimplrgxor
// file lglib.c line 13479
static signed int lglsimplrgxor(struct LGL *lgl, struct Gat *g)
{
  signed int conflict;
  signed int lhs;
  signed int rhs;
  signed int other;
  signed int repr;
  signed int *p;
  signed int found;
  signed int return_value_lglcgrepr_1;
  return_value_lglcgrepr_1=lglcgrepr(lgl, g->lhs);
  lhs = -return_value_lglcgrepr_1;
  rhs = -1;
  found = 0;
  p = g->_anon0._anon0.cls;
  signed int return_value_abs_2;
  do
  {
    other = *p;
    if(other == 0)
      break;

    if(other == g->_anon0._anon0.origlhs)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, other);
      if(repr == -1)
        goto __CPROVER_DUMP_L13;

      else
        if(repr == 1)
          rhs = -rhs;

        else
          if(repr == rhs)
            rhs = -1;

          else
            if(repr == lhs)
              lhs = -1;

            else
              if(repr == -lhs)
                lhs = 1;

              else
                if(lhs == -1)
                  lhs = repr;

                else
                  if(lhs == 1)
                    lhs = -repr;

                  else
                  {
                    return_value_abs_2=abs(rhs);
                    if(!(return_value_abs_2 == 1))
                      return 0;

                    else
                      if(rhs == -1)
                        rhs = repr;

                      else
                        rhs = -repr;
                  }
    }

  __CPROVER_DUMP_L13:
    ;
    p = p + 1l;
  }
  while((_Bool)1);
  if(lhs == rhs)
    return 0;

  else
  {

  __CPROVER_DUMP_L15:
    ;
    lgl->_anon0.cgr->simplified.all = lgl->_anon0.cgr->simplified.all + 1;
    lgl->stats->cgr.simplified.all = lgl->stats->cgr.simplified.all + 1;
    lgl->_anon0.cgr->simplified.xor = lgl->_anon0.cgr->simplified.xor + 1;
    lgl->stats->cgr.simplified.xor = lgl->stats->cgr.simplified.xor + 1;
    conflict=lglcgmergelhsrhs(lgl, lhs, rhs);
    if(!(conflict == 0))
    {

    __CPROVER_DUMP_L16:
      ;
      lgl->mt = 1;
    }

    return 1;
  }
}

// lglsimpxor
// file lglib.c line 13517
static signed int lglsimpxor(struct LGL *lgl, struct Gat *g)
{
  signed int return_value_lglsimpbinxor_1;
  signed int return_value_lglsimplrgxor_2;
  if((signed int)g->size == 2)
  {
    return_value_lglsimpbinxor_1=lglsimpbinxor(lgl, g);
    return return_value_lglsimpbinxor_1;
  }

  else
  {
    return_value_lglsimplrgxor_2=lglsimplrgxor(lgl, g);
    return return_value_lglsimplrgxor_2;
  }
}

// lglsize2cnf
// file lglib.c line 10730
static signed long int lglsize2cnf(signed int s)
{
  return (signed long int)s << 32;
}

// lglsizectk
// file lglib.c line 1542
static signed int lglsizectk(struct Ctk *ctk)
{
  return (signed int)(ctk->end - ctk->start);
}

// lglsizes
// file lglib.c line 18590
void lglsizes(struct LGL *lgl)
{
  lglprt(lgl, 0, "sizeof (int) == %ld", (signed long int)sizeof(signed int) /*4ul*/ );
  lglprt(lgl, 0, "sizeof (unsigned) == %ld", (signed long int)sizeof(unsigned int) /*4ul*/ );
  lglprt(lgl, 0, "sizeof (void*) == %ld", (signed long int)sizeof(void *) /*8ul*/ );
  lglprt(lgl, 0, "sizeof (Stk) == %ld", (signed long int)sizeof(struct Stk) /*24ul*/ );
  lglprt(lgl, 0, "sizeof (Fun) == %ld", (signed long int)sizeof(unsigned long int [64l]) /*512ul*/ );
  lglprt(lgl, 0, "sizeof (AVar) == %ld", (signed long int)sizeof(struct AVar) /*12ul*/ );
  lglprt(lgl, 0, "sizeof (DVar) == %ld", (signed long int)sizeof(struct DVar) /*16ul*/ );
  lglprt(lgl, 0, "sizeof (EVar) == %ld", (signed long int)sizeof(struct EVar) /*16ul*/ );
  lglprt(lgl, 0, "sizeof (Gat) == %ld", (signed long int)sizeof(struct Gat) /*32ul*/ );
  lglprt(lgl, 0, "sizeof (Stats.lir) == %ld", (signed long int)sizeof(struct anonymous_30 [16l]) /*896ul*/ );
  lglprt(lgl, 0, "sizeof (Stats) == %ld", (signed long int)sizeof(struct Stats) /*2272ul*/ );
  lglprt(lgl, 0, "sizeof (LGL) == %ld", (signed long int)sizeof(struct LGL) /*816ul*/ );
  lglprt(lgl, 0, "MAXVAR == %ld", (signed long int)((0x7fffffff >> RMSHFT) - 2));
  lglprt(lgl, 0, "MAXREDLIDX == %ld", (signed long int)((1 << 31 - 4) - 2));
  lglprt(lgl, 0, "MAXIRRLIDX == %ld", (signed long int)((1 << 31 - RMSHFT) - 2));
}

// lglsizewtk
// file lglib.c line 14991
static signed int lglsizewtk(struct Wtk *wtk)
{
  return (signed int)(wtk->end - wtk->start);
}

// lglslfun
// file lglib.c line 10607
static void lglslfun(unsigned long int *a, signed int shift)
{
  unsigned long int rest;
  unsigned long int tmp;
  signed int i;
  signed int j;
  signed int q;
  signed int b;
  signed int l;
  b = shift & 63;
  q = shift >> 6;
  j = (1 << 12 - 6) - 1;
  i = j - q;
  l = 64 - b;
  unsigned long int tmp_if_expr_1;
  for( ; j >= 0; j = j - 1)
  {
    if(i >= 0)
    {
      tmp = a[(signed long int)i] << b;
      if(i >= 1 && !(b == 0))
        tmp_if_expr_1 = a[(signed long int)(i - 1)] >> l;

      else
        tmp_if_expr_1 = (unsigned long int)0ll;
      rest = tmp_if_expr_1;
      a[(signed long int)j] = rest | tmp;
    }

    else
      a[(signed long int)j] = (unsigned long int)0ll;
    i = i - 1;
  }
}

// lglsmalladdlit2cnf
// file lglib.c line 10842
static signed long int lglsmalladdlit2cnf(struct LGL *lgl, signed long int cnf, signed int lit)
{
  signed int p;
  signed int m;
  signed int q;
  signed int n;
  signed int i;
  signed int cls;
  signed long int res;
  p=lglcnf2pos(cnf);
  m=lglcnf2size(cnf);
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(&lgl->_anon0.elm->clv);
  q = (signed int)return_value_lglcntstk_1;
  i = 0;
  for( ; !(i >= m); i = i + 1)
  {
    cls=lglpeek(&lgl->_anon0.elm->clv, p + i);
    cls = cls | lit;
    lglpushstk(lgl, &lgl->_anon0.elm->clv, cls);
  }
  unsigned long int return_value_lglcntstk_2;
  return_value_lglcntstk_2=lglcntstk(&lgl->_anon0.elm->clv);
  n = (signed int)(return_value_lglcntstk_2 - (unsigned long int)q);
  res=lglcnf(q, n);
  return res;
}

// lglsmallcnfunits
// file lglib.c line 10957
static signed int lglsmallcnfunits(struct LGL *lgl, signed long int cnf)
{
  signed int p;
  signed int m;
  signed int i;
  signed int res;
  signed int cls;
  signed int ilit;
  p=lglcnf2pos(cnf);
  m=lglcnf2size(cnf);
  res = 0;
  i = 0;
  for( ; !(i >= m); i = i + 1)
  {
    cls=lglpeek(&lgl->_anon0.elm->clv, p + i);
    ilit=lglsmallisunitcls(lgl, cls);
    if(!(ilit == 0))
    {
      lglunit(lgl, ilit);
      res = res + 1;
    }

  }
  return res;
}

// lglsmallevalcls
// file lglib.c line 10714
static void lglsmallevalcls(unsigned int cls, unsigned long int *res)
{
  unsigned long int tmp[64l];
  signed int v;
  lglfalsefun(res);
  v = 0;
  for( ; !(v >= 12); v = v + 1)
    if(!((cls & (unsigned int)(1 << 2 * v + 1)) == 0u))
    {
      lglvar2fun(v, tmp);
      lglornegfun(res, tmp);
    }

    else
      if(!((cls & (unsigned int)(1 << 2 * v)) == 0u))
      {
        lglvar2fun(v, tmp);
        lglorfun(res, tmp);
      }

}

// lglsmallevalcnf
// file lglib.c line 10738
static void lglsmallevalcnf(struct LGL *lgl, signed long int cnf, unsigned long int *res)
{
  unsigned long int tmp[64l];
  signed int i;
  signed int n;
  signed int p;
  signed int cls;
  p=lglcnf2pos(cnf);
  n=lglcnf2size(cnf);
  lgltruefun(res);
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    cls=lglpeek(&lgl->_anon0.elm->clv, p + i);
    lglsmallevalcls((unsigned int)cls, tmp);
    lglandfun(res, tmp);
  }
}

// lglsmallfundeps0
// file lglib.c line 10769
static signed int lglsmallfundeps0(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!((0xaaaaaaaaaaaaaaaaull & f[(signed long int)i]) >> 1 == (0x5555555555555555ull & f[(signed long int)i])))
      return 1;

  return 0;
}

// lglsmallfundeps1
// file lglib.c line 10777
static signed int lglsmallfundeps1(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!((0xccccccccccccccccull & f[(signed long int)i]) >> 2 == (0x3333333333333333ull & f[(signed long int)i])))
      return 1;

  return 0;
}

// lglsmallfundeps2
// file lglib.c line 10785
static signed int lglsmallfundeps2(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!((0xf0f0f0f0f0f0f0f0ull & f[(signed long int)i]) >> 4 == (0x0f0f0f0f0f0f0f0full & f[(signed long int)i])))
      return 1;

  return 0;
}

// lglsmallfundeps3
// file lglib.c line 10793
static signed int lglsmallfundeps3(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!((0xff00ff00ff00ff00ull & f[(signed long int)i]) >> 8 == (0x00ff00ff00ff00ffull & f[(signed long int)i])))
      return 1;

  return 0;
}

// lglsmallfundeps4
// file lglib.c line 10801
static signed int lglsmallfundeps4(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!((0xffff0000ffff0000ull & f[(signed long int)i]) >> 16 == (0x0000ffff0000ffffull & f[(signed long int)i])))
      return 1;

  return 0;
}

// lglsmallfundeps5
// file lglib.c line 10809
static signed int lglsmallfundeps5(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!((0xffffffff00000000ull & f[(signed long int)i]) >> 32 == (0x00000000ffffffffull & f[(signed long int)i])))
      return 1;

  return 0;
}

// lglsmallfundepsgen
// file lglib.c line 10817
static signed int lglsmallfundepsgen(unsigned long int *f, signed int min)
{
  const signed int c = 1 << min - 6;
  signed int i;
  signed int j;
  i = 0;
  for( ; !(i >= 64); i = i + (1 << min - 5))
  {
    j = 0;
    for( ; !(j >= c); j = j + 1)
      if(!(f[(signed long int)(i + j)] == f[(signed long int)(c + i + j)]))
        return 1;

  }
  return 0;
}

// lglsmallipos
// file lglib.c line 10874
static signed long int lglsmallipos(struct LGL *lgl, unsigned long int *U, unsigned long int *L, signed int min)
{
  unsigned long int U0[64l];
  unsigned long int U1[64l];
  unsigned long int L0[64l];
  unsigned long int L1[64l];
  unsigned long int Unew[64l];
  unsigned long int ftmp[64l];
  signed long int c0;
  signed long int c1;
  signed long int cstar;
  signed long int ctmp;
  signed long int res;
  signed int x;
  signed int y;
  signed int z;
  signed int return_value_lglistruefun_1;
  return_value_lglistruefun_1=lglistruefun(U);
  signed int return_value_lglcnf2pos_4;
  signed int return_value_lglcnf2pos_5;
  if(!(return_value_lglistruefun_1 == 0))
    return 0ll;

  else
  {
    signed int return_value_lglisfalsefun_2;
    return_value_lglisfalsefun_2=lglisfalsefun(L);
    if(!(return_value_lglisfalsefun_2 == 0))
      return 1ll << 32;

    else
    {
      lgl->stats->elm.ipos = lgl->stats->elm.ipos + 1l;
      y=lglsmalltopvar(U, min);
      z=lglsmalltopvar(L, min);
      lgl->stats->elm.steps = lgl->stats->elm.steps + (signed long int)12;
      x = y < z ? y : z;
      lglnegcofactorfun(U, x, U0);
      lglposcofactorfun(U, x, U1);
      lglnegcofactorfun(L, x, L0);
      lglposcofactorfun(L, x, L1);
      lglor3negfun(ftmp, U0, L1);
      c0=lglsmallipos(lgl, ftmp, L0, min + 1);
      lglor3negfun(ftmp, U1, L0);
      c1=lglsmallipos(lgl, ftmp, L1, min + 1);
      lglsmallevalcnf(lgl, c0, ftmp);
      lglor3negfun(Unew, U0, ftmp);
      lglsmallevalcnf(lgl, c1, ftmp);
      lglandornegfun(Unew, U1, ftmp);
      lglor3fun(ftmp, L0, L1);
      cstar=lglsmallipos(lgl, Unew, ftmp, min + 1);
      ctmp=lglsmalladdlit2cnf(lgl, c1, 1 << 2 * x + 1);
      signed int return_value_lglcnf2pos_3;
      return_value_lglcnf2pos_3=lglcnf2pos(ctmp);
      res = (signed long int)return_value_lglcnf2pos_3;
      ctmp=lglsmalladdlit2cnf(lgl, c0, 1 << 2 * x);
      if(res == 0ll)
      {
        return_value_lglcnf2pos_4=lglcnf2pos(ctmp);
        res = (signed long int)return_value_lglcnf2pos_4;
      }

      ctmp=lglsmalladdlit2cnf(lgl, cstar, 0);
      if(res == 0ll)
      {
        return_value_lglcnf2pos_5=lglcnf2pos(ctmp);
        res = (signed long int)return_value_lglcnf2pos_5;
      }

      unsigned long int return_value_lglcntstk_6;
      return_value_lglcntstk_6=lglcntstk(&lgl->_anon0.elm->clv);
      signed long int return_value_lglsize2cnf_7;
      return_value_lglsize2cnf_7=lglsize2cnf((signed int)(return_value_lglcntstk_6 - (unsigned long int)res));
      res = res | return_value_lglsize2cnf_7;
      return res;
    }
  }
}

// lglsmallirr
// file lglib.c line 9103
static signed int lglsmallirr(struct LGL *lgl)
{
  signed int maxirrlidx;
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(&lgl->irr);
  maxirrlidx = (signed int)return_value_lglcntstk_1;
  signed int limit;
  signed long int tmp = (signed long int)((1 << 31 - 4) - 2);
  tmp = tmp * (signed long int)lgl->opts->smallirr.val;
  tmp = tmp / (signed long int)100;
  limit = (signed int)(tmp < (signed long int)0x7fffffff ? tmp : (signed long int)0x7fffffff);
  if(maxirrlidx >= limit)
    return 0;

  else
    return 1;
}

// lglsmallisunitcls
// file lglib.c line 10943
static signed int lglsmallisunitcls(struct LGL *lgl, signed int cls)
{
  signed int fidx;
  signed int fsign;
  signed int flit;
  signed int mlit;
  signed int ilit = 0;
  fidx = 0;
  for( ; !(fidx >= 12); fidx = fidx + 1)
  {
    fsign = 0;
    for( ; !(fsign >= 2); fsign = fsign + 1)
    {
      flit = 1 << 2 * fidx + fsign;
      if(!((flit & cls) == 0))
      {
        if(!(ilit == 0))
          return 0;

        mlit = (fidx + 2) * (fsign != 0 ? -1 : 1);
        ilit=lglm2i(lgl, mlit);
      }

    }
  }
  return ilit;
}

// lglsmalltopvar
// file lglib.c line 10827
static signed int lglsmalltopvar(unsigned long int *f, signed int min)
{
  signed int i;
  signed int return_value_lglsmallfundeps0_1;
  signed int return_value_lglsmallfundeps1_2;
  signed int return_value_lglsmallfundeps2_3;
  signed int return_value_lglsmallfundeps3_4;
  signed int return_value_lglsmallfundeps4_5;
  signed int return_value_lglsmallfundepsgen_7;
  switch(min)
  {
    case 0:
    {
      return_value_lglsmallfundeps0_1=lglsmallfundeps0(f);
      if(!(return_value_lglsmallfundeps0_1 == 0))
        return 0;

    }
    case 1:
    {
      return_value_lglsmallfundeps1_2=lglsmallfundeps1(f);
      if(!(return_value_lglsmallfundeps1_2 == 0))
        return 1;

    }
    case 2:
    {
      return_value_lglsmallfundeps2_3=lglsmallfundeps2(f);
      if(!(return_value_lglsmallfundeps2_3 == 0))
        return 2;

    }
    case 3:
    {
      return_value_lglsmallfundeps3_4=lglsmallfundeps3(f);
      if(!(return_value_lglsmallfundeps3_4 == 0))
        return 3;

    }
    case 4:
    {
      return_value_lglsmallfundeps4_5=lglsmallfundeps4(f);
      if(!(return_value_lglsmallfundeps4_5 == 0))
        return 4;

    }
    case 5:
    {
      signed int return_value_lglsmallfundeps5_6;
      return_value_lglsmallfundeps5_6=lglsmallfundeps5(f);
      if(!(return_value_lglsmallfundeps5_6 == 0))
        return 5;

    }
    default:
    {
      i=lglmax(6, min);
      for( ; !(i >= 11); i = i + 1)
      {
        return_value_lglsmallfundepsgen_7=lglsmallfundepsgen(f, i);
        if(!(return_value_lglsmallfundepsgen_7 == 0))
          return i;

      }
      return i;
    }
  }
}

// lglsmallve
// file lglib.c line 10911
static void lglsmallve(struct LGL *lgl, signed long int cnf)
{
  signed int *soc;
  signed int return_value_lglcnf2pos_1;
  return_value_lglcnf2pos_1=lglcnf2pos(cnf);
  soc = lgl->_anon0.elm->clv.start + (signed long int)return_value_lglcnf2pos_1;
  signed int *eoc;
  signed int return_value_lglcnf2size_2;
  return_value_lglcnf2size_2=lglcnf2size(cnf);
  eoc = soc + (signed long int)return_value_lglcnf2size_2;
  signed int *p;
  signed int cls;
  signed int v;
  signed int lit;
  signed int trivial;
  signed char val;
  p = soc;
  signed int return_value_lglm2i_3;
  for( ; lgl->mt == 0 && !(p >= eoc); p = p + 1l)
  {
    cls = *p;
    trivial = 0;
    v = 0;
    for( ; !(v >= 12); v = v + 1)
    {
      if(!((1 << 2 * v + 1 & cls) == 0))
      {
        return_value_lglm2i_3=lglm2i(lgl, v + 2);
        lit = -return_value_lglm2i_3;
      }

      else
        if(!((1 << 2 * v & cls) == 0))
          lit=lglm2i(lgl, v + 2);

        else
          goto __CPROVER_DUMP_L8;
      val=lglval(lgl, lit);
      if((signed int)val >= 0)
      {
        if((signed int)val >= 1)
          trivial = 1;

        lglpushstk(lgl, &lgl->clause, lit);
      }


    __CPROVER_DUMP_L8:
      ;
    }
    if(trivial == 0)
    {
      lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
      lgl->stats->elm.resolutions = lgl->stats->elm.resolutions + 1l;
      lglpushstk(lgl, &lgl->clause, 0);

    __CPROVER_DUMP_L10:
      ;
      lgladdcls(lgl, 0, 0, 1);
    }

    lglclnstk(&lgl->clause);
  }
}

// lglsolve
// file lglib.c line 17284
static signed int lglsolve(struct LGL *lgl, struct Lim *lim, signed int forcesimp)
{
  signed int res;
  lgl->limits->simp.pen = lgl->opts->simpen.val;
  lglstart(lgl, &lgl->times->prep);
  res=lgltopsimp(lgl, forcesimp);
  lglstop(lgl);
  if(!(res == 0))
    return res;

  else
  {
    signed int return_value_lglsearch_1;
    return_value_lglsearch_1=lglsearch(lgl, lim);
    return return_value_lglsearch_1;
  }
}

// lglsparse
// file lglib.c line 9229
static void lglsparse(struct LGL *lgl)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int count;
  signed int blit;
  signed int tag;
  signed int *w;
  signed int *p;
  signed int *eow;
  signed int *q;
  struct HTS *hts;
  lgl->stats->sparse = lgl->stats->sparse + 1l;
  count = 0;
  idx = 2;
  signed int *tmp_post_1;
  signed int *tmp_post_2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      hts=lglhts(lgl, lit);
      if(!(hts->count == 0))
      {
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        q = w;
        p = q;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          tag = blit & MASKCS;
          if(tag == OCCS)
            count = count + 1;

          else
          {
            tmp_post_1 = q;
            q = q + 1l;
            *tmp_post_1 = blit;
            if(!(tag == BINCS))
            {
              tmp_post_2 = q;
              q = q + 1l;
              p = p + 1l;
              *tmp_post_2 = *p;
            }

          }
        }
        lglshrinkhts(lgl, hts, (signed int)(q - w));
      }

    }
  }
  do
  {
    lgldel(lgl, (void *)lgl->evars, (unsigned long int)lgl->nvars * sizeof(struct EVar) /*16ul*/ );
    lgl->evars = ((struct EVar *)NULL);
  }
  while((_Bool)0);
  lglrelstk(lgl, &lgl->esched);

__CPROVER_DUMP_L10:
  ;
  lgl->dense = (char)0;
  lgl->notfullyconnected = (char)1;

__CPROVER_DUMP_L11:
  ;
}

// lglsqr
// file lglib.c line 18093
static double lglsqr(double a)
{
  return a * a;
}

// lglsrfun
// file lglib.c line 10587
static void lglsrfun(unsigned long int *a, signed int shift)
{
  unsigned long int rest;
  unsigned long int tmp;
  signed int i;
  signed int j;
  signed int q;
  signed int b;
  signed int l;
  b = shift & 63;
  q = shift >> 6;
  j = 0;
  i = q;
  l = 64 - b;
  unsigned long int tmp_if_expr_1;
  for( ; !(j >= 64); j = j + 1)
  {
    if(!(i >= 64))
    {
      tmp = a[(signed long int)i] >> b;
      if(!(b == 0) && !(1 + i >= 64))
        tmp_if_expr_1 = a[(signed long int)(i + 1)] << l;

      else
        tmp_if_expr_1 = 0ull;
      rest = tmp_if_expr_1;
      a[(signed long int)j] = rest | tmp;
    }

    else
      a[(signed long int)j] = 0ull;
    i = i + 1;
  }
}

// lglstamp
// file lglib.c line 15021
static signed int lglstamp(struct LGL *lgl, signed int root, struct DFPR *dfpr, struct DFOPF *dfopf, struct Wtk *work, struct Stk *units, struct Stk *sccs, struct Stk *trds, signed int *visitedptr, signed int stamp, signed int irronly)
{
  signed int uroot;
  signed int lit;
  signed int ulit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int failed;
  signed int uother;
  signed int unotother;
  signed int observed;
  signed int discovered;
  signed int pos;
  signed int undiscovered;
  unsigned int lglstamp__1__start;
  unsigned int end;
  unsigned int mod;
  unsigned int i;
  unsigned int j;
  unsigned int sccsize;
  const signed int *p;
  const signed int *w;
  const signed int *eos;
  signed int startstamp;
  const struct Work *r;
  signed int removed;
  struct HTS *hts;
  enum Wrag wrag;
  signed char return_value_lglval_1;
  return_value_lglval_1=lglval(lgl, root);
  signed int return_value_lglmtwtk_2;
  unsigned int tmp_post_9;
  signed int return_value_lglcntwtk_10;
  signed int return_value_lglulit_11;
  signed int return_value_lglulit_12;
  if(!(return_value_lglval_1 == 0))
    return stamp;

  else
  {
    uroot=lglulit(root);
    if(!((dfpr + (signed long int)uroot)->discovered == 0))
      return stamp;

    else
    {

    __CPROVER_DUMP_L2:
      ;
      startstamp = 0;
      lglpushwtk(lgl, work, (enum Wrag)PREFIX, root, 0, 0);
      do
      {
        return_value_lglmtwtk_2=lglmtwtk(work);
        if(!(return_value_lglmtwtk_2 == 0))
          break;

        lgl->stats->unhd.steps = lgl->stats->unhd.steps + 1l;
        do
        {
          work->top = work->top - 1l;
          wrag = (enum Wrag)work->top->wrag;
          lit = (signed int)work->top->lit;
          other = (signed int)work->top->other;
          red = work->top->red != 0u ? REDCS : 0;
          removed = (signed int)work->top->removed;
        }
        while((_Bool)0);
        if(removed == 0)
        {
          if((signed int)wrag == PREFIX)
          {
            ulit=lglulit(lit);
            if(!((dfpr + (signed long int)ulit)->discovered == 0))
            {
              (dfopf + (signed long int)ulit)->observed = stamp;

            __CPROVER_DUMP_L5:
              ;
              continue;
            }

            stamp = stamp + 1;
            (dfpr + (signed long int)ulit)->discovered = stamp;
            (dfopf + (signed long int)ulit)->observed = stamp;

          __CPROVER_DUMP_L7:
            ;
            *visitedptr = *visitedptr + 1;
            if(startstamp == 0)
            {
              startstamp = stamp;

            __CPROVER_DUMP_L8:
              ;
              (dfpr + (signed long int)ulit)->root = lit;
            }


          __CPROVER_DUMP_L9:
            ;

          __CPROVER_DUMP_L10:
            ;

          __CPROVER_DUMP_L11:
            ;
            lglpushwtk(lgl, work, (enum Wrag)POSTFIX, lit, 0, 0);
            (dfopf + (signed long int)ulit)->pushed=lglcntwtk(work);
            (dfopf + (signed long int)ulit)->flag = 1;
            lglpushstk(lgl, sccs, lit);
            hts=lglhts(lgl, -lit);
            w=lglhts2wchs(lgl, hts);
            eos = w + (signed long int)hts->count;
            undiscovered = 0;
            for( ; !(undiscovered >= 2); undiscovered = undiscovered + 1)
            {
              signed int return_value_lglcntwtk_3;
              return_value_lglcntwtk_3=lglcntwtk(work);
              lglstamp__1__start = (unsigned int)return_value_lglcntwtk_3;
              p = w;
              for( ; !(p >= eos); p = p + 1l)
              {
                blit = *p;
                tag = blit & MASKCS;
                if(!(tag == OCCS))
                {
                  if(tag == TRNCS || tag == LRGCS)
                    p = p + 1l;

                  else
                  {
                    red = blit & REDCS;
                    if(red == 0 || irronly == 0)
                    {
                      other = blit >> RMSHFT;
                      signed char return_value_lglval_4;
                      return_value_lglval_4=lglval(lgl, other);
                      if(return_value_lglval_4 == 0)
                      {
                        uother=lglulit(other);
                        if(undiscovered == (signed int)((dfpr + (signed long int)uother)->discovered == 0))
                        {
                          do
                          {
                            signed int return_value_lglsignedmarked_5;
                            return_value_lglsignedmarked_5=lglsignedmarked(lgl, other);
                            if(!(return_value_lglsignedmarked_5 >= 1))
                              break;

                            fprintf(stderr, "liblgl.a: %s:%d: %s: Coverage target `%s' reached.", (const void *)"lglstamp", 15099, (const void *)"lglib.c", (const void *)"lglsignedmarked (lgl, other) > 0");
                            if(!(lgl == ((struct LGL *)NULL)))
                            {
                              if(lgl->tid >= 0)
                                fprintf(stderr, " (tid %d)", lgl->tid);

                            }

                            fputc(10, stderr);
                            fflush(stderr);
                            abort();
                          }
                          while((_Bool)0);
                          signed int return_value_lglsignedmarked_6;
                          return_value_lglsignedmarked_6=lglsignedmarked(lgl, other);
                          if(return_value_lglsignedmarked_6 >= 1)

                            __CPROVER_DUMP_L18:
                              ;

                          else
                          {
                            lglsignedmark(lgl, other);
                            lglpushwtk(lgl, work, (enum Wrag)BEFORE, lit, other, red);
                          }
                        }

                      }

                    }

                  }
                }

              }
              signed int return_value_lglcntwtk_7;
              return_value_lglcntwtk_7=lglcntwtk(work);
              end = (unsigned int)return_value_lglcntwtk_7;
              r = work->start + (signed long int)lglstamp__1__start;
              for( ; !(r >= work->top); r = r + 1l)
                lglunmark(lgl, (signed int)r->other);
              mod = end - lglstamp__1__start;
              if(mod >= 2u)
              {
                i = lglstamp__1__start;
                for( ; !(i >= end + 4294967295u); i = i + 1u)
                {
                  unsigned int return_value_lglrand_8;
                  return_value_lglrand_8=lglrand(lgl);
                  tmp_post_9 = mod;
                  mod = mod - 1u;
                  j = return_value_lglrand_8 % tmp_post_9;
                  if(!(j == 0u))
                  {
                    j = i + j;
                    do
                    {
                      struct Work TMP = work->start[(signed long int)i];
                      work->start[(signed long int)i] = work->start[(signed long int)j];
                      work->start[(signed long int)j] = TMP;
                    }
                    while((_Bool)0);
                  }

                }
              }

            }
          }

          else
            if((signed int)wrag == BEFORE)
            {

            __CPROVER_DUMP_L32:
              ;
              lglpushwtk(lgl, work, (enum Wrag)AFTER, lit, other, red);
              ulit=lglulit(lit);
              uother=lglulit(other);
              unotother=lglulit(-other);
              if(!(lgl->opts->unhdextstamp.val == 0))
              {
                if(!(red == 0) || !(irronly == 0))
                {
                  if(!((dfpr + (signed long int)ulit)->discovered >= (dfopf + (signed long int)uother)->observed))
                  {

                  __CPROVER_DUMP_L33:
                    ;
                    lgl->stats->unhd.stamp.trds = lgl->stats->unhd.stamp.trds + 1;
                    lgl->stats->prgss = lgl->stats->prgss + 1l;
                    if(!(red == 0))
                      lgl->stats->unhd.tauts.red = lgl->stats->unhd.tauts.red + 1;

                    lglrmbcls(lgl, -lit, other, red);
                    pos = (dfopf + (signed long int)unotother)->pushed;
                    if(pos >= 0)
                      do
                      {
                        return_value_lglcntwtk_10=lglcntwtk(work);
                        if(pos >= return_value_lglcntwtk_10)
                          break;

                        if(!((signed int)(work->start + (signed long int)pos)->lit == -other))
                          break;

                        if((signed int)(work->start + (signed long int)pos)->other == -lit)
                        {

                        __CPROVER_DUMP_L36:
                          ;
                          (work->start + (signed long int)pos)->removed = (unsigned int)1;
                        }

                        pos = pos + 1;
                      }
                      while((_Bool)1);

                    work->top = work->top - 1l;
                    continue;
                  }

                }

              }

              observed = (dfopf + (signed long int)unotother)->observed;
              if(!(lgl->opts->unhdextstamp.val == 0))
              {
                if(observed >= startstamp)
                {

                __CPROVER_DUMP_L41:
                  ;
                  failed = lit;
                  do
                  {
                    return_value_lglulit_11=lglulit(failed);
                    if(observed >= (dfpr + (signed long int)return_value_lglulit_11)->discovered)
                      break;

                    return_value_lglulit_12=lglulit(failed);
                    failed = (dfpr + (signed long int)return_value_lglulit_12)->parent;
                  }
                  while((_Bool)1);

                __CPROVER_DUMP_L44:
                  ;
                  lglpushstk(lgl, units, -failed);
                  lgl->stats->unhd.stamp.failed = lgl->stats->unhd.stamp.failed + 1;
                  if(!((dfpr + (signed long int)unotother)->discovered == 0))
                  {
                    if((dfpr + (signed long int)unotother)->finished == 0)
                    {

                    __CPROVER_DUMP_L45:
                      ;
                      work->top = work->top - 1l;
                      continue;
                    }

                  }

                }

              }

              if((dfpr + (signed long int)uother)->discovered == 0)
              {
                (dfpr + (signed long int)uother)->parent = lit;

              __CPROVER_DUMP_L47:
                ;
                (dfpr + (signed long int)uother)->root = root;

              __CPROVER_DUMP_L48:
                ;
                lglpushwtk(lgl, work, (enum Wrag)PREFIX, other, 0, 0);
              }

            }

            else
              if((signed int)wrag == AFTER)
              {

              __CPROVER_DUMP_L51:
                ;
                uother=lglulit(other);
                ulit=lglulit(lit);
                if(!(lgl->opts->unhdextstamp.val == 0))
                {
                  if((dfpr + (signed long int)uother)->finished == 0)
                  {
                    if(!((dfpr + (signed long int)uother)->discovered >= (dfpr + (signed long int)ulit)->discovered))
                    {

                    __CPROVER_DUMP_L52:
                      ;
                      (dfpr + (signed long int)ulit)->discovered = (dfpr + (signed long int)uother)->discovered;

                    __CPROVER_DUMP_L53:
                      ;
                      if(!((dfopf + (signed long int)ulit)->flag == 0))
                      {

                      __CPROVER_DUMP_L54:
                        ;
                        (dfopf + (signed long int)ulit)->flag = 0;
                      }

                    }

                  }

                }

                (dfopf + (signed long int)uother)->observed = stamp;
              }

              else
              {

              __CPROVER_DUMP_L57:
                ;
                ulit=lglulit(lit);
                if(!((dfopf + (signed long int)ulit)->flag == 0))
                {
                  stamp = stamp + 1;
                  sccsize = (unsigned int)0;
                  discovered = (dfpr + (signed long int)ulit)->discovered;
                  do
                  {
                    other=lglpopstk(sccs);
                    uother=lglulit(other);
                    (dfopf + (signed long int)uother)->pushed = -1;
                    (dfopf + (signed long int)uother)->flag = 0;
                    (dfpr + (signed long int)uother)->discovered = discovered;
                    (dfpr + (signed long int)uother)->finished = stamp;

                  __CPROVER_DUMP_L59:
                    ;
                    sccsize = sccsize + 1u;
                  }
                  while(!(other == lit));
                  if(sccsize >= 2u)
                  {

                  __CPROVER_DUMP_L60:
                    ;
                    lgl->stats->unhd.stamp.sumsccsizes = lgl->stats->unhd.stamp.sumsccsizes + (signed long int)sccsize;
                    lgl->stats->unhd.stamp.sccs = lgl->stats->unhd.stamp.sccs + 1;
                  }

                }

              }
        }


      __CPROVER_DUMP_L56:
        ;
      }
      while((_Bool)1);
      return stamp;
    }
  }
}

// lglstampall
// file lglib.c line 16012
static struct DFPR * lglstampall(struct LGL *lgl, signed int irronly)
{
  signed int roots;
  signed int searches;
  signed int noimpls;
  signed int unassigned;
  signed int visited;
  unsigned int pos;
  unsigned int delta;
  unsigned int mod;
  unsigned int ulit;
  unsigned int first;
  unsigned int last;
  unsigned int count;
  signed int root;
  signed int stamp;
  signed int rootsonly;
  signed int lit;
  struct Stk units;
  struct Stk sccs;
  struct Stk trds;
  struct DFOPF *dfopf;
  struct DFOPF *q;
  struct DFPR *dfpr;
  struct Wtk lglstampall__1__work;
  signed char val;
  unsigned int return_value_lglgcd_5;
  signed int return_value_lglulit_9;
  signed int return_value_lglunhdisroot_10;
  signed int return_value_lglunhdhasbins_11;
  signed int return_value_lglmtstk_12;
  _Bool tmp_if_expr_20;
  if(!(lgl->nvars >= 3))
    return ((struct DFPR *)NULL);

  else
  {
    lglrmbindup(lgl);
    do
    {
      void *return_value_lglnew_1;
      return_value_lglnew_1=lglnew(lgl, (unsigned long int)(2 * lgl->nvars) * sizeof(struct DFPR) /*16ul*/ );
      dfpr = (struct DFPR *)return_value_lglnew_1;
    }
    while((_Bool)0);
    do
    {
      void *return_value_lglnew_2;
      return_value_lglnew_2=lglnew(lgl, (unsigned long int)(2 * lgl->nvars) * sizeof(struct DFOPF) /*12ul*/ );
      dfopf = (struct DFOPF *)return_value_lglnew_2;
    }
    while((_Bool)0);
    do
      memset((void *)&lglstampall__1__work, 0, sizeof(struct Wtk) /*24ul*/ );
    while((_Bool)0);
    do
      memset((void *)&sccs, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    do
      memset((void *)&trds, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    do
      memset((void *)&units, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    q = dfopf;
    for( ; !(q >= dfopf + (signed long int)(2 * lgl->nvars)); q = q + 1l)
      q->pushed = -1;
    visited = 0;
    stamp = visited;
    unassigned = stamp;
    noimpls = unassigned;
    roots = noimpls;
    searches = roots;
    rootsonly = 1;
    for( ; rootsonly >= 0; rootsonly = rootsonly - 1)
    {
      count = (unsigned int)0;
      mod = (unsigned int)(2 * (lgl->nvars - 2));
      first = mod;
      unsigned int return_value_lglrand_3;
      return_value_lglrand_3=lglrand(lgl);
      pos = return_value_lglrand_3 % mod;
      unsigned int return_value_lglrand_4;
      return_value_lglrand_4=lglrand(lgl);
      delta = return_value_lglrand_4 % mod;
      if(delta == 0u)
        delta = delta + 1u;

      do
      {
        return_value_lglgcd_5=lglgcd(delta, mod);
        if(!(return_value_lglgcd_5 >= 2u))
          break;

        delta = delta + 1u;
        if(delta == mod)
          delta = (unsigned int)1;

      }
      while((_Bool)1);

    __CPROVER_DUMP_L13:
      ;
      do
      {
        signed int return_value_lglterminate_6;
        return_value_lglterminate_6=lglterminate(lgl);
        if(!(return_value_lglterminate_6 == 0))
        {
          searches = 0;
          goto DONE;
        }

        signed int return_value_lglsyncunits_7;
        return_value_lglsyncunits_7=lglsyncunits(lgl);
        if(return_value_lglsyncunits_7 == 0)
          goto DONE;

        ulit = pos + (unsigned int)4;
        root=lglilit((signed int)ulit);
        lgl->stats->unhd.steps = lgl->stats->unhd.steps + 1l;
        count = count + 1u;
        signed char return_value_lglval_8;
        return_value_lglval_8=lglval(lgl, root);
        if(return_value_lglval_8 == 0)
        {
          if(!(rootsonly == 0))
            unassigned = unassigned + 1;

          return_value_lglulit_9=lglulit(root);
          if((dfpr + (signed long int)return_value_lglulit_9)->discovered == 0)
          {
            if(!(rootsonly == 0))
            {
              return_value_lglunhdisroot_10=lglunhdisroot(lgl, root, dfpr, irronly);
              if(return_value_lglunhdisroot_10 == 0)
                goto CONTINUE;

            }

            return_value_lglunhdhasbins_11=lglunhdhasbins(lgl, dfpr, -root, irronly);
            if(return_value_lglunhdhasbins_11 == 0)
            {
              if(!(rootsonly == 0))
                noimpls = noimpls + 1;

            }

            else
            {
              if(!(rootsonly == 0))
                roots = roots + 1;

              searches = searches + 1;
              stamp=lglstamp(lgl, root, dfpr, dfopf, &lglstampall__1__work, &units, &sccs, &trds, &visited, stamp, irronly);
              do
              {
                return_value_lglmtstk_12=lglmtstk(&units);
                if(!(return_value_lglmtstk_12 == 0))
                  break;

                lit=lglpopstk(&units);
                val=lglval(lgl, lit);
                if(!((signed int)val >= 1))
                {
                  if(!((signed int)val >= 0))
                  {

                  __CPROVER_DUMP_L23:
                    ;
                    lgl->mt = 1;
                    goto DONE;
                  }

                  lglunit(lgl, lit);
                  signed int return_value_lglbcp_13;
                  return_value_lglbcp_13=lglbcp(lgl);
                  if(return_value_lglbcp_13 == 0)
                  {

                  __CPROVER_DUMP_L25:
                    ;
                    lgl->mt = 1;
                    goto DONE;
                  }

                }

              }
              while((_Bool)1);
            }
          }

        }


      CONTINUE:
        ;
        last = pos;
        pos = pos + delta;
        if(pos >= mod)
          pos = pos - mod;

        if(pos == first)
          break;

        if(mod == 1u)
          break;

        if(first == mod)
          first = last;

      }
      while((_Bool)1);
    }
    double return_value_lglpcnt_14;
    return_value_lglpcnt_14=lglpcnt((double)lgl->unassigned, (double)(lgl->nvars - 2));
    lglprt(lgl, 2, "[unhd-%d-%d] %d unassigned variables out of %d (%.0f%%)", lgl->stats->unhd.count, lgl->stats->unhd.rounds, lgl->unassigned, lgl->nvars - 2, return_value_lglpcnt_14);
    double return_value_lglpcnt_15;
    return_value_lglpcnt_15=lglpcnt((double)roots, (double)unassigned);
    lglprt(lgl, 2, "[unhd-%d-%d] %d root literals out of %d (%.0f%%)", lgl->stats->unhd.count, lgl->stats->unhd.rounds, roots, unassigned, return_value_lglpcnt_15);
    double return_value_lglpcnt_16;
    return_value_lglpcnt_16=lglpcnt((double)(searches - roots), (double)unassigned);
    lglprt(lgl, 2, "[unhd-%d-%d] %d additional non-root searches out of %d (%.0f%%)", lgl->stats->unhd.count, lgl->stats->unhd.rounds, searches - roots, unassigned, return_value_lglpcnt_16);
    double return_value_lglpcnt_17;
    return_value_lglpcnt_17=lglpcnt((double)noimpls, (double)unassigned);
    lglprt(lgl, 2, "[unhd-%d-%d] %d literals not in F2 out of %d (%.0f%%)", lgl->stats->unhd.count, lgl->stats->unhd.rounds, noimpls, unassigned, return_value_lglpcnt_17);
    double return_value_lglpcnt_18;
    return_value_lglpcnt_18=lglpcnt((double)visited, (double)unassigned);
    lglprt(lgl, 2, "[unhd-%d-%d] %d visited literals out of %d (%.0f%%)", lgl->stats->unhd.count, lgl->stats->unhd.rounds, visited, unassigned, return_value_lglpcnt_18);
    double return_value_lglavg_19;
    return_value_lglavg_19=lglavg((double)visited, (double)searches);
    lglprt(lgl, 2, "[unhd-%d-%d] %.2f average number visited literals per search", lgl->stats->unhd.count, lgl->stats->unhd.rounds, return_value_lglavg_19);

  DONE:
    ;
    if(searches == 0)
      tmp_if_expr_20 = (_Bool)1;

    else
      tmp_if_expr_20 = lgl->mt != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_20)
    {
      do
      {
        lgldel(lgl, (void *)dfpr, (unsigned long int)(2 * lgl->nvars) * sizeof(struct DFPR) /*16ul*/ );
        dfpr = ((struct DFPR *)NULL);
      }
      while((_Bool)0);
      dfpr = ((struct DFPR *)NULL);
    }

    lglrelwtk(lgl, &lglstampall__1__work);
    lglrelstk(lgl, &units);
    lglrelstk(lgl, &sccs);
    lglrelstk(lgl, &trds);
    do
    {
      lgldel(lgl, (void *)dfopf, (unsigned long int)(2 * lgl->nvars) * sizeof(struct DFOPF) /*12ul*/ );
      dfopf = ((struct DFOPF *)NULL);
    }
    while((_Bool)0);
    return dfpr;
  }
}

// lglstart
// file lglib.c line 4961
static void lglstart(struct LGL *lgl, double *timestatsptr)
{
  signed int nest = lgl->timers->nest;
  lgl->timers->idx[(signed long int)nest] = (signed int)(timestatsptr - (double *)lgl->times);
  lgl->timers->phase[(signed long int)nest]=lglgetime(lgl);
  lgl->timers->nest = lgl->timers->nest + 1;
}

// lglstats
// file lglib.h line 280
void lglstats(struct LGL *lgl)
{
  struct Times *ts = lgl->times;
  struct Stats *s = lgl->stats;
  double t = ts->all;
  double simp;
  double search;
  signed long long int p = s->props.search + s->props.simp + s->props.lkhd;
  signed int remaining;
  signed int removed;
  signed int sum;
  signed long long int v;
  signed long long int min;
  signed long int steps;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglstats");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglprs(lgl, "blkd: %d bces, %d removed, %lld resolutions, %lld steps", s->blk.count, s->blk.clauses, (signed long long int)s->blk.res, (signed long long int)s->blk.steps);
  double return_value_lglpcnt_1;
  return_value_lglpcnt_1=lglpcnt((double)s->blk.lits, (double)(2 * lgl->maxext));
  lglprs(lgl, "blkd: %d blocking literals %.0f%%, %d pure", s->blk.lits, return_value_lglpcnt_1, s->blk.pure);
  double return_value_lglpcnt_2;
  return_value_lglpcnt_2=lglpcnt((double)s->cce.ate, (double)s->cce.eliminated);
  double return_value_lglpcnt_3;
  return_value_lglpcnt_3=lglpcnt((double)s->cce.abce, (double)s->cce.eliminated);
  lglprs(lgl, "cces: %d cces, %d eliminated, %d ate %.0f%%, %d abce %.0f%%", s->cce.count, s->cce.eliminated, s->cce.ate, return_value_lglpcnt_2, s->cce.abce, return_value_lglpcnt_3);
  lglprs(lgl, "cces: %lld probed, %d lifted, %d failed", (signed long long int)s->cce.probed, s->cce.lifted, s->cce.failed);
  lglprs(lgl, "clff: %d cliffs, %d lifted, %d failed", s->cliff.count, s->cliff.lifted, s->cliff.failed);
  lglprs(lgl, "clff: %lld decisions, %lld steps", (signed long long int)s->cliff.decisions, (signed long long int)s->cliff.steps);
  lglprs(lgl, "clls: %lld sat, %lld simp, %lld freeze, %lld melt", (signed long long int)s->calls.sat, (signed long long int)s->calls.simp, (signed long long int)s->calls.freeze, (signed long long int)s->calls.melt);
  lglprs(lgl, "clls: %lld add, %lld assume,, %lld deref, %lld failed", (signed long long int)s->calls.add, (signed long long int)s->calls.assume, (signed long long int)s->calls.deref, (signed long long int)s->calls.failed);
  lglprs(lgl, "clls: %lld cassume, %lld mosat", (signed long long int)s->calls.cassume, (signed long long int)s->calls.mosat);
  lglprs(lgl, "coll: %d gcs, %d rescored clauses", s->gcs, s->rescored.clauses);
  lglprs(lgl, "cgrs: %d count, %lld esteps, %lld csteps", s->cgr.count, (signed long long int)s->cgr.esteps, (signed long long int)s->cgr.csteps);
  lglprs(lgl, "cgrs: %d eqs, %d units", s->cgr.eq, s->cgr.units);
  double return_value_lglpcnt_4;
  return_value_lglpcnt_4=lglpcnt((double)s->cgr.matched.and, (double)s->cgr.matched.all);
  double return_value_lglpcnt_5;
  return_value_lglpcnt_5=lglpcnt((double)s->cgr.matched.xor, (double)s->cgr.matched.all);
  double return_value_lglpcnt_6;
  return_value_lglpcnt_6=lglpcnt((double)s->cgr.matched.ite, (double)s->cgr.matched.all);
  lglprs(lgl, "cgrs: %d matched (%d ands %.0f%%, %d xors %.0f%%, %d ites %.0f%%)", s->cgr.matched.all, s->cgr.matched.and, return_value_lglpcnt_4, s->cgr.matched.xor, return_value_lglpcnt_5, s->cgr.matched.ite, return_value_lglpcnt_6);
  double return_value_lglpcnt_7;
  return_value_lglpcnt_7=lglpcnt((double)s->cgr.simplified.and, (double)s->cgr.simplified.all);
  double return_value_lglpcnt_8;
  return_value_lglpcnt_8=lglpcnt((double)s->cgr.simplified.xor, (double)s->cgr.simplified.all);
  double return_value_lglpcnt_9;
  return_value_lglpcnt_9=lglpcnt((double)s->cgr.simplified.ite, (double)s->cgr.simplified.all);
  lglprs(lgl, "cgrs: %d simplified (%d ands %.0f%%, %d xors %.0f%%, %d ites %.0f%%)", s->cgr.simplified.all, s->cgr.simplified.and, return_value_lglpcnt_7, s->cgr.simplified.xor, return_value_lglpcnt_8, s->cgr.simplified.ite, return_value_lglpcnt_9);
  double return_value_lglpcnt_10;
  return_value_lglpcnt_10=lglpcnt((double)s->cgr.extracted.and, (double)s->cgr.extracted.all);
  double return_value_lglpcnt_11;
  return_value_lglpcnt_11=lglpcnt((double)s->cgr.extracted.xor, (double)s->cgr.extracted.all);
  double return_value_lglpcnt_12;
  return_value_lglpcnt_12=lglpcnt((double)s->cgr.extracted.ite, (double)s->cgr.extracted.all);
  lglprs(lgl, "cgrs: %lld extracted (%lld ands %.0f%%, %lld xors %.0f%%, %lld ites %.0f%%)", (signed long long int)s->cgr.extracted.all, (signed long long int)s->cgr.extracted.and, return_value_lglpcnt_10, (signed long long int)s->cgr.extracted.xor, return_value_lglpcnt_11, (signed long long int)s->cgr.extracted.ite, return_value_lglpcnt_12);
  double return_value_lglpcnt_13;
  return_value_lglpcnt_13=lglpcnt((double)s->equiv.sum, (double)lgl->maxext);
  lglprs(lgl, "dcps: %d decompositions, %d equivalent %.0f%%", s->decomps, s->equiv.sum, return_value_lglpcnt_13);
  double return_value_lglpcnt_14;
  return_value_lglpcnt_14=lglpcnt((double)s->randecs, (double)s->decisions);
  lglprs(lgl, "decs: %lld decision, %lld random %.3f%%", (signed long long int)s->decisions, (signed long long int)s->randecs, return_value_lglpcnt_14);
  double return_value_lglpcnt_15;
  return_value_lglpcnt_15=lglpcnt((double)s->flipped, (double)s->decisions);
  lglprs(lgl, "decs: %lld flipped %.3f%% (in %lld phases)", (signed long long int)s->flipped, return_value_lglpcnt_15, (signed long long int)s->fliphases);
  double return_value_lglpcnt_16;
  return_value_lglpcnt_16=lglpcnt((double)s->elm.elmd, (double)lgl->maxext);
  lglprs(lgl, "elms: %d elims, %d eliminated %.0f%%", s->elm.count, s->elm.elmd, return_value_lglpcnt_16);
  double return_value_lglpcnt_17;
  return_value_lglpcnt_17=lglpcnt((double)s->elm.small.elm, (double)s->elm.elmd);
  double return_value_lglpcnt_18;
  return_value_lglpcnt_18=lglpcnt((double)s->elm.large, (double)s->elm.elmd);
  lglprs(lgl, "elms: %d small %.0f%%, %d large %.0f%%", s->elm.small.elm, return_value_lglpcnt_17, s->elm.large, return_value_lglpcnt_18);
  double return_value_lglpcnt_19;
  return_value_lglpcnt_19=lglpcnt((double)(s->elm.small.tried - s->elm.small.failed), (double)s->elm.small.tried);
  double return_value_lglpcnt_20;
  return_value_lglpcnt_20=lglpcnt((double)s->elm.small.failed, (double)s->elm.small.tried);
  lglprs(lgl, "elms: %d tried small, %d succeeded %.0f%%, %d failed %.0f%%", s->elm.small.tried, s->elm.small.tried - s->elm.small.failed, return_value_lglpcnt_19, s->elm.small.failed, return_value_lglpcnt_20);
  lglprs(lgl, "elms: %d subsumed, %d strengthened, %d blocked", s->elm.sub, s->elm.str, s->elm.blkd);
  lglprs(lgl, "elms: %lld copies, %lld resolutions, %lld ipos", (signed long long int)s->elm.copies, (signed long long int)s->elm.resolutions, (signed long long int)s->elm.ipos);
  lglprs(lgl, "elms: %lld subchks, %lld strchks", (signed long long int)s->elm.subchks, (signed long long int)s->elm.strchks);
  lglprs(lgl, "frcs: %lld computed, %.1f - %.1f average min-cut range", (signed long long int)s->force.count, s->force.mincut.min, s->force.mincut.max);
  double return_value_lglavg_21;
  return_value_lglavg_21=lglavg((double)s->gauss.arity.sum, (double)s->gauss.extracted);
  lglprs(lgl, "gaus: %lld extractions, %lld extracted, %.1f size, %d max", s->gauss.count, s->gauss.extracted, return_value_lglavg_21, s->gauss.arity.max);
  lglprs(lgl, "gaus: exported %d units, %d binary and %d ternary equations", s->gauss.units, s->gauss.equivs, s->gauss.trneqs);
  steps = s->gauss.steps.extr + s->gauss.steps.extr;
  double return_value_lglpcnt_22;
  return_value_lglpcnt_22=lglpcnt((double)s->gauss.steps.extr, (double)steps);
  double return_value_lglpcnt_23;
  return_value_lglpcnt_23=lglpcnt((double)s->gauss.steps.elim, (double)steps);
  lglprs(lgl, "gaus: %d gc, %lld steps, %lld extr %.0f%%, %lld elim %.0f%%", s->gauss.gcs, steps, s->gauss.steps.extr, return_value_lglpcnt_22, s->gauss.steps.elim, return_value_lglpcnt_23);
  double return_value_lglavg_24;
  return_value_lglavg_24=lglavg((double)s->clauses.glue, (double)s->clauses.learned);
  double return_value_lglavg_25;
  return_value_lglavg_25=lglavg((double)s->clauses.scglue, (double)s->clauses.learned);
  lglprs(lgl, "glue: %.1f avg, %.1f scaled avg", return_value_lglavg_24, return_value_lglavg_25);
  double return_value_lglpcnt_26;
  return_value_lglpcnt_26=lglpcnt((double)s->clauses.maxglue, (double)s->clauses.learned);
  lglprs(lgl, "glue: %lld maxredglue=%d (%.0f%%)", (signed long long int)s->clauses.maxglue, (1 << 4) - 1, return_value_lglpcnt_26);
  sum = (signed int)(s->lift.probed0 + s->lift.probed1);
  double return_value_lglpcnt_27;
  return_value_lglpcnt_27=lglpcnt((double)s->lift.probed0, (double)sum);
  double return_value_lglpcnt_28;
  return_value_lglpcnt_28=lglpcnt((double)s->lift.probed1, (double)sum);
  lglprs(lgl, "lift: %d phases, %d probed (%lld level1 %.0f%%, %lld level2 %.0f%%)", s->lift.count, sum, (signed long long int)s->lift.probed0, return_value_lglpcnt_27, (signed long long int)s->lift.probed1, return_value_lglpcnt_28);
  lglprs(lgl, "lift: %d units, %d equivalences, %d implications", s->lift.units, s->lift.eqs, s->lift.impls);
  double return_value_lglpcnt_29;
  return_value_lglpcnt_29=lglpcnt((double)s->hbr.trn, (double)s->hbr.cnt);
  double return_value_lglpcnt_30;
  return_value_lglpcnt_30=lglpcnt((double)s->hbr.lrg, (double)s->hbr.cnt);
  double return_value_lglpcnt_31;
  return_value_lglpcnt_31=lglpcnt((double)s->hbr.sub, (double)s->hbr.cnt);
  lglprs(lgl, "hbrs: %d hbrs = %d trn %.0f%% + %d lrg %.0f%%, %d sub %.0f%%", s->hbr.cnt, s->hbr.trn, return_value_lglpcnt_29, s->hbr.lrg, return_value_lglpcnt_30, s->hbr.sub, return_value_lglpcnt_31);
  double return_value_lglpcnt_32;
  return_value_lglpcnt_32=lglpcnt((double)s->uips, (double)s->clauses.learned);
  double return_value_lglavg_33;
  return_value_lglavg_33=lglavg((double)s->lits.learned, (double)s->clauses.learned);
  double return_value_lglavg_34;
  return_value_lglavg_34=lglavg((double)s->clauses.glue, (double)s->clauses.learned);
  lglprs(lgl, "lrnd: %lld clauses, %lld uips %.0f%%, %.1f length, %.1f glue", (signed long long int)s->clauses.learned, (signed long long int)s->uips, return_value_lglpcnt_32, return_value_lglavg_33, return_value_lglavg_34);
  lglprs(lgl, "ints: %lld luby (%lld steps), %lld inout (%lld steps)", (signed long long int)s->luby.count, (signed long long int)s->luby.steps, (signed long long int)s->inout.count, (signed long long int)s->inout.steps);
  min = s->lits.nonmin - s->lits.learned;
  sum = (signed int)(s->moved.bin + s->moved.trn);
  double return_value_lglpcnt_35;
  return_value_lglpcnt_35=lglpcnt((double)min, (double)s->lits.nonmin);
  lglprs(lgl, "mins: %lld learned lits, %.0f%% minimized", (signed long long int)s->lits.learned, return_value_lglpcnt_35);
  double return_value_lglpcnt_36;
  return_value_lglpcnt_36=lglpcnt((double)s->moved.bin, (double)sum);
  double return_value_lglpcnt_37;
  return_value_lglpcnt_37=lglpcnt((double)s->moved.trn, (double)sum);
  lglprs(lgl, "move: moved %lld, %lld binary %.0f%%, %lld ternary %.0f%%", sum, (signed long long int)s->moved.bin, return_value_lglpcnt_36, (signed long long int)s->moved.trn, return_value_lglpcnt_37);
  sum = s->otfs.str.dyn.red + s->otfs.str.dyn.irr;
  double return_value_lglpcnt_38;
  return_value_lglpcnt_38=lglpcnt((double)s->otfs.driving, (double)sum);
  double return_value_lglpcnt_39;
  return_value_lglpcnt_39=lglpcnt((double)s->otfs.restarting, (double)sum);
  lglprs(lgl, "otfs: str %d dyn (%d red, %d irr) %d drv %.0f%%, %d rst %.0f%%", sum, s->otfs.str.dyn.red, s->otfs.str.dyn.irr, s->otfs.driving, return_value_lglpcnt_38, s->otfs.restarting, return_value_lglpcnt_39);
  lglprs(lgl, "otfs: sub %d dyn (%d red, %d irr)", s->otfs.sub.dyn.red + s->otfs.sub.dyn.irr, s->otfs.sub.dyn.red, s->otfs.sub.dyn.irr);
  double return_value_lglpcnt_40;
  return_value_lglpcnt_40=lglpcnt((double)s->phase.pos, (double)s->phase.set);
  double return_value_lglpcnt_41;
  return_value_lglpcnt_41=lglpcnt((double)s->phase.neg, (double)s->phase.set);
  lglprs(lgl, "phas: %lld computed, %lld set, %lld pos (%.0f%%), %lld neg (%.0f%%)", (signed long long int)s->phase.count, (signed long long int)s->phase.set, (signed long long int)s->phase.pos, return_value_lglpcnt_40, (signed long long int)s->phase.neg, return_value_lglpcnt_41);
  lglprs(lgl, "prbs: %d basic, %lld probed, %d failed, %d lifted", s->prb.basic.count, (signed long long int)s->prb.basic.probed, s->prb.basic.failed, s->prb.basic.lifted);
  double return_value_lglavg_42;
  return_value_lglavg_42=lglavg((double)s->props.search, (double)s->decisions);
  lglprs(lgl, "prps: %lld props, %.0f props/dec", (signed long long int)p, return_value_lglavg_42);
  double return_value_lglpcnt_43;
  return_value_lglpcnt_43=lglpcnt((double)s->props.search, (double)p);
  double return_value_lglpcnt_44;
  return_value_lglpcnt_44=lglpcnt((double)s->props.simp, (double)p);
  double return_value_lglpcnt_45;
  return_value_lglpcnt_45=lglpcnt((double)s->props.lkhd, (double)p);
  lglprs(lgl, "prps: %.0f%% srch, %.0f%% simp, %.0f%% lkhd", return_value_lglpcnt_43, return_value_lglpcnt_44, return_value_lglpcnt_45);
  double return_value_lglpcnt_46;
  return_value_lglpcnt_46=lglpcnt((double)s->poison.hits, (double)s->poison.search);
  lglprs(lgl, "psns: %lld searches, %lld hits, %.0f%% hit rate", (signed long long int)s->poison.search, (signed long long int)s->poison.hits, return_value_lglpcnt_46);
  lglprs(lgl, "queu: %lld new, %lld del, %d maximum priority", (signed long long int)s->queue.new, (signed long long int)s->queue.del, s->queue.max);
  lglprs(lgl, "queu: %lld merged, %lld collected, %lld gcs", (signed long long int)s->queue.merged, (signed long long int)s->queue.col, (signed long long int)s->queue.gcs);
  double return_value_lglavg_47;
  return_value_lglavg_47=lglavg((double)s->queue.deprior.sum, (double)s->queue.deprior.count);
  lglprs(lgl, "queu: %lld deprioritized, %.1f lines on average", (signed long long int)s->queue.deprior.count, return_value_lglavg_47);
  double return_value_lglpcnt_48;
  return_value_lglpcnt_48=lglpcnt((double)s->acts, (double)s->reduced.count);
  double return_value_lglpcnt_49;
  return_value_lglpcnt_49=lglpcnt((double)s->reduced.geom, (double)s->reduced.count);
  lglprs(lgl, "reds: %d count, %d reset, %d acts %.0f%%, %d exp %.0f%%", s->reduced.count, s->reduced.reset, s->acts, return_value_lglpcnt_48, s->reduced.geom, return_value_lglpcnt_49);
  double return_value_lglpcnt_50;
  return_value_lglpcnt_50=lglpcnt((double)s->reduced.arith, (double)s->reduced.count);
  double return_value_lglpcnt_51;
  return_value_lglpcnt_51=lglpcnt((double)s->reduced.arith2, (double)s->reduced.arith);
  lglprs(lgl, "reds: %d arithmetic %.0f%%, %d double %.0f%%", s->reduced.arith, return_value_lglpcnt_50, s->reduced.arith2, return_value_lglpcnt_51);
  double return_value_lglpcnt_52;
  return_value_lglpcnt_52=lglpcnt((double)s->bindup.red, (double)s->bindup.removed);
  lglprs(lgl, "rmbd: %d removed, %d red %.0f%%", s->bindup.removed, s->bindup.red, return_value_lglpcnt_52);
  sum = s->restarts.count + s->restarts.skipped;
  double return_value_lglpcnt_53;
  return_value_lglpcnt_53=lglpcnt((double)s->restarts.count, (double)sum);
  double return_value_lglpcnt_54;
  return_value_lglpcnt_54=lglpcnt((double)s->restarts.skipped, (double)sum);
  lglprs(lgl, "rsts: %d restarts %.0f%%, %d skipped %.0f%%", s->restarts.count, return_value_lglpcnt_53, s->restarts.skipped, return_value_lglpcnt_54);
  double return_value_lglpcnt_55;
  return_value_lglpcnt_55=lglpcnt((double)s->restarts.kept.count, (double)s->restarts.count);
  double return_value_lglavg_56;
  return_value_lglavg_56=lglavg((double)s->restarts.kept.sum, (double)s->restarts.kept.count);
  lglprs(lgl, "rsts: %d kept %.1f%% average %.1f%%", s->restarts.kept.count, return_value_lglpcnt_55, return_value_lglavg_56);
  double return_value_lglpcnt_57;
  return_value_lglpcnt_57=lglpcnt((double)s->simp.ilimhit, (double)s->simp.count);
  double return_value_lglpcnt_58;
  return_value_lglpcnt_58=lglpcnt((double)s->simp.plimhit, (double)s->simp.count);
  double return_value_lglpcnt_59;
  return_value_lglpcnt_59=lglpcnt((double)s->simp.climhit, (double)s->simp.count);
  lglprs(lgl, "simp: %d count (%d ilim %.0f%%, %d plim %.0f%%, %d clim %0.f%%)", s->simp.count, s->simp.ilimhit, return_value_lglpcnt_57, s->simp.plimhit, return_value_lglpcnt_58, s->simp.climhit, return_value_lglpcnt_59);
  lglprs(lgl, "trnr: %d count, %d bin, %d trn, %lld steps", s->trnr.count, s->trnr.bin, s->trnr.trn, (signed long long int)s->trnr.steps);
  double return_value_lglpcnt_60;
  return_value_lglpcnt_60=lglpcnt((double)s->fixed.sum, (double)lgl->maxext);
  lglprs(lgl, "tops: %d fixed %.0f%%, %d iterations", s->fixed.sum, return_value_lglpcnt_60, s->iterations);
  lglprs(lgl, "trds: %d transitive reductions, %d removed, %d failed", s->trd.count, s->trd.red, s->trd.failed);
  lglprs(lgl, "trds: %lld nodes, %lld edges, %lld steps", (signed long long int)s->trd.lits, (signed long long int)s->trd.bins, (signed long long int)s->trd.steps);
  lglprs(lgl, "unhd: %d count, %d rounds, %lld steps", s->unhd.count, s->unhd.rounds, (signed long long int)s->unhd.steps);
  double return_value_lglavg_61;
  return_value_lglavg_61=lglavg((double)s->unhd.stamp.sumsccsizes, (double)s->unhd.stamp.sccs);
  lglprs(lgl, "unhd: %d non-trivial sccs of average size %.1f", s->unhd.stamp.sccs, return_value_lglavg_61);
  sum=lglunhdunits(lgl);
  lglprs(lgl, "unhd: %d units, %d bin, %d trn, %d lrg", sum, s->unhd.units.bin, s->unhd.units.trn, s->unhd.units.lrg);
  sum=lglunhdfailed(lgl);
  lglprs(lgl, "unhd: %d failed, %d stamp, %d lits, %d bin, %d trn, %d lrg", sum, s->unhd.stamp.failed, s->unhd.failed.lits, s->unhd.failed.bin, s->unhd.failed.trn, s->unhd.units.lrg);
  sum=lglunhdtauts(lgl);
  double return_value_lglpcnt_62;
  return_value_lglpcnt_62=lglpcnt((double)s->unhd.tauts.bin, (double)sum);
  double return_value_lglpcnt_63;
  return_value_lglpcnt_63=lglpcnt((double)s->unhd.tauts.trn, (double)sum);
  double return_value_lglpcnt_64;
  return_value_lglpcnt_64=lglpcnt((double)s->unhd.tauts.lrg, (double)sum);
  lglprs(lgl, "unhd: %d tauts, %d bin %.0f%%, %d trn %.0f%%, %d lrg %.0f%%", sum, s->unhd.tauts.bin, return_value_lglpcnt_62, s->unhd.tauts.trn, return_value_lglpcnt_63, s->unhd.tauts.lrg, return_value_lglpcnt_64);
  double return_value_lglpcnt_65;
  return_value_lglpcnt_65=lglpcnt((double)s->unhd.stamp.trds, (double)sum);
  double return_value_lglpcnt_66;
  return_value_lglpcnt_66=lglpcnt((double)s->unhd.tauts.red, (double)sum);
  lglprs(lgl, "unhd: %d tauts, %d stamp %.0f%%, %d red %.0f%%", sum, s->unhd.stamp.trds, return_value_lglpcnt_65, s->unhd.tauts.red, return_value_lglpcnt_66);
  sum=lglunhdhbrs(lgl);
  double return_value_lglpcnt_67;
  return_value_lglpcnt_67=lglpcnt((double)s->unhd.hbrs.trn, (double)sum);
  double return_value_lglpcnt_68;
  return_value_lglpcnt_68=lglpcnt((double)s->unhd.hbrs.lrg, (double)sum);
  double return_value_lglpcnt_69;
  return_value_lglpcnt_69=lglpcnt((double)s->unhd.hbrs.red, (double)sum);
  lglprs(lgl, "unhd: %d hbrs, %d trn %.0f%%, %d lrg %.0f%%, %d red %.0f%%", sum, s->unhd.hbrs.trn, return_value_lglpcnt_67, s->unhd.hbrs.lrg, return_value_lglpcnt_68, s->unhd.hbrs.red, return_value_lglpcnt_69);
  sum=lglunhdstrd(lgl);
  double return_value_lglpcnt_70;
  return_value_lglpcnt_70=lglpcnt((double)s->unhd.units.bin, (double)sum);
  double return_value_lglpcnt_71;
  return_value_lglpcnt_71=lglpcnt((double)s->unhd.str.trn, (double)sum);
  double return_value_lglpcnt_72;
  return_value_lglpcnt_72=lglpcnt((double)s->unhd.str.lrg, (double)sum);
  double return_value_lglpcnt_73;
  return_value_lglpcnt_73=lglpcnt((double)s->unhd.str.red, (double)sum);
  lglprs(lgl, "unhd: %d strd, %d bin %.0f%%, %d trn %.0f%%, %d lrg %.0f%%, %d red %.0f%%", sum, s->unhd.units.bin, return_value_lglpcnt_70, s->unhd.str.trn, return_value_lglpcnt_71, s->unhd.str.lrg, return_value_lglpcnt_72, s->unhd.str.red, return_value_lglpcnt_73);
  removed = s->fixed.sum + s->elm.elmd + s->equiv.sum;
  remaining = lgl->maxext - removed;
  double return_value_lglpcnt_74;
  return_value_lglpcnt_74=lglpcnt((double)remaining, (double)lgl->maxext);
  double return_value_lglpcnt_75;
  return_value_lglpcnt_75=lglpcnt((double)removed, (double)lgl->maxext);
  lglprs(lgl, "vars: %d remaining %.0f%% and %d removed %.0f%% out of %d", remaining, return_value_lglpcnt_74, removed, return_value_lglpcnt_75, lgl->maxext);
  double return_value_lglpcnt_76;
  return_value_lglpcnt_76=lglpcnt((double)s->fixed.sum, (double)lgl->maxext);
  double return_value_lglpcnt_77;
  return_value_lglpcnt_77=lglpcnt((double)s->elm.elmd, (double)lgl->maxext);
  double return_value_lglpcnt_78;
  return_value_lglpcnt_78=lglpcnt((double)s->equiv.sum, (double)lgl->maxext);
  lglprs(lgl, "vars: %d fixed %.0f%%, %d eliminated %.0f%%, %d equivalent %.0f%%", s->fixed.sum, return_value_lglpcnt_76, s->elm.elmd, return_value_lglpcnt_77, s->equiv.sum, return_value_lglpcnt_78);
  v = s->visits.search + s->visits.simp + s->visits.lkhd;
  double return_value_lglpcnt_79;
  return_value_lglpcnt_79=lglpcnt((double)s->visits.search, (double)v);
  double return_value_lglpcnt_80;
  return_value_lglpcnt_80=lglpcnt((double)s->visits.simp, (double)v);
  double return_value_lglpcnt_81;
  return_value_lglpcnt_81=lglpcnt((double)s->visits.lkhd, (double)v);
  lglprs(lgl, "vsts: %lld visits, %.0f%% srch, %.0f%% simp, %.0f%% lkhd", (signed long long int)v, return_value_lglpcnt_79, return_value_lglpcnt_80, return_value_lglpcnt_81);
  double return_value_lglavg_82;
  return_value_lglavg_82=lglavg((double)s->visits.search, (double)s->props.search);
  double return_value_lglavg_83;
  return_value_lglavg_83=lglavg((double)s->visits.search, (double)s->confs);
  lglprs(lgl, "vsts: %.1f search visits per propagation %.1f per conflict", return_value_lglavg_82, return_value_lglavg_83);
  lglprs(lgl, "wchs: %lld pushed, %lld enlarged, %d defrags", (signed long long int)s->pshwchs, (signed long long int)s->enlwchs, s->defrags);
  lglgluestats(lgl);
  lglprs(lgl, "");
  double return_value_lglavg_84;
  return_value_lglavg_84=lglavg((double)s->confs, t);
  lglprs(lgl, "%lld decisions, %lld conflicts, %.1f conflicts/sec", (signed long long int)s->decisions, (signed long long int)s->confs, return_value_lglavg_84);
  double return_value_lglavg_85;
  return_value_lglavg_85=lglavg((double)p / 1e6, t);
  lglprs(lgl, "%lld propagations, %.1f megaprops/sec", (signed long long int)p, return_value_lglavg_85);
  double return_value_lglmaxmb_86;
  return_value_lglmaxmb_86=lglmaxmb(lgl);
  lglprs(lgl, "%.1f seconds, %.1f MB", t, return_value_lglmaxmb_86);
  lglprs(lgl, "");
  double return_value_lglpcnt_87;
  return_value_lglpcnt_87=lglpcnt(ts->ana, t);
  lglprs(lgl, "%8.3f %3.0f%% analysis", ts->ana, return_value_lglpcnt_87);
  double return_value_lglpcnt_88;
  return_value_lglpcnt_88=lglpcnt(ts->blk, t);
  lglprs(lgl, "%8.3f %3.0f%% block", ts->blk, return_value_lglpcnt_88);
  double return_value_lglpcnt_89;
  return_value_lglpcnt_89=lglpcnt(ts->bump, t);
  lglprs(lgl, "%8.3f %3.0f%% bump", ts->bump, return_value_lglpcnt_89);
  double return_value_lglpcnt_90;
  return_value_lglpcnt_90=lglpcnt(ts->card, t);
  lglprs(lgl, "%8.3f %3.0f%% card", ts->card, return_value_lglpcnt_90);
  double return_value_lglpcnt_91;
  return_value_lglpcnt_91=lglpcnt(ts->cce, t);
  lglprs(lgl, "%8.3f %3.0f%% cce", ts->cce, return_value_lglpcnt_91);
  double return_value_lglpcnt_92;
  return_value_lglpcnt_92=lglpcnt(ts->cliff, t);
  lglprs(lgl, "%8.3f %3.0f%% cliff", ts->cliff, return_value_lglpcnt_92);
  double return_value_lglpcnt_93;
  return_value_lglpcnt_93=lglpcnt(ts->ctw, t);
  lglprs(lgl, "%8.3f %3.0f%% cutwidth", ts->ctw, return_value_lglpcnt_93);
  double return_value_lglpcnt_94;
  return_value_lglpcnt_94=lglpcnt(ts->dec, t);
  lglprs(lgl, "%8.3f %3.0f%% decide", ts->dec, return_value_lglpcnt_94);
  double return_value_lglpcnt_95;
  return_value_lglpcnt_95=lglpcnt(ts->force, t);
  lglprs(lgl, "%8.3f %3.0f%% force", ts->force, return_value_lglpcnt_95);
  double return_value_lglpcnt_96;
  return_value_lglpcnt_96=lglpcnt(ts->gc, t);
  lglprs(lgl, "%8.3f %3.0f%% gc", ts->gc, return_value_lglpcnt_96);
  double return_value_lglpcnt_97;
  return_value_lglpcnt_97=lglpcnt(ts->cgr, t);
  lglprs(lgl, "%8.3f %3.0f%% cgrclsr", ts->cgr, return_value_lglpcnt_97);
  double return_value_lglpcnt_98;
  return_value_lglpcnt_98=lglpcnt(ts->dcp, t);
  lglprs(lgl, "%8.3f %3.0f%% decomp", ts->dcp, return_value_lglpcnt_98);
  double return_value_lglpcnt_99;
  return_value_lglpcnt_99=lglpcnt(ts->dfg, t);
  lglprs(lgl, "%8.3f %3.0f%% defrag", ts->dfg, return_value_lglpcnt_99);
  double return_value_lglpcnt_100;
  return_value_lglpcnt_100=lglpcnt(ts->elm, t);
  lglprs(lgl, "%8.3f %3.0f%% elim", ts->elm, return_value_lglpcnt_100);
  double return_value_lglpcnt_101;
  return_value_lglpcnt_101=lglpcnt(ts->gauss, t);
  lglprs(lgl, "%8.3f %3.0f%% gauss", ts->gauss, return_value_lglpcnt_101);
  double return_value_lglpcnt_102;
  return_value_lglpcnt_102=lglpcnt(ts->lft, t);
  lglprs(lgl, "%8.3f %3.0f%% lift", ts->lft, return_value_lglpcnt_102);
  double return_value_lglpcnt_103;
  return_value_lglpcnt_103=lglpcnt(ts->mcls, t);
  lglprs(lgl, "%8.3f %3.0f%% mincls", ts->mcls, return_value_lglpcnt_103);
  double return_value_lglpcnt_104;
  return_value_lglpcnt_104=lglpcnt(ts->phs, t);
  lglprs(lgl, "%8.3f %3.0f%% phase", ts->phs, return_value_lglpcnt_104);
  double return_value_lglpcnt_105;
  return_value_lglpcnt_105=lglpcnt(ts->prb.all, t);
  lglprs(lgl, "%8.3f %3.0f%% probe", ts->prb.all, return_value_lglpcnt_105);
  double return_value_lglpcnt_106;
  return_value_lglpcnt_106=lglpcnt(ts->red, t);
  lglprs(lgl, "%8.3f %3.0f%% reduce", ts->red, return_value_lglpcnt_106);
  double return_value_lglpcnt_107;
  return_value_lglpcnt_107=lglpcnt(ts->rsts, t);
  lglprs(lgl, "%8.3f %3.0f%% restart", ts->rsts, return_value_lglpcnt_107);
  double return_value_lglpcnt_108;
  return_value_lglpcnt_108=lglpcnt(ts->trn, t);
  lglprs(lgl, "%8.3f %3.0f%% ternres", ts->trn, return_value_lglpcnt_108);
  double return_value_lglpcnt_109;
  return_value_lglpcnt_109=lglpcnt(ts->trd, t);
  lglprs(lgl, "%8.3f %3.0f%% transred", ts->trd, return_value_lglpcnt_109);
  double return_value_lglpcnt_110;
  return_value_lglpcnt_110=lglpcnt(ts->unhd, t);
  lglprs(lgl, "%8.3f %3.0f%% unhide", ts->unhd, return_value_lglpcnt_110);
  lglprs(lgl, "==================================");
  simp = ts->prep + ts->inpr;
  double return_value_lglpcnt_111;
  return_value_lglpcnt_111=lglpcnt(ts->prep, t);
  double return_value_lglpcnt_112;
  return_value_lglpcnt_112=lglpcnt(ts->prep, simp);
  lglprs(lgl, "%8.3f %3.0f%% preprocessing   %3.0f%%", ts->prep, return_value_lglpcnt_111, return_value_lglpcnt_112);
  double return_value_lglpcnt_113;
  return_value_lglpcnt_113=lglpcnt(ts->inpr, t);
  double return_value_lglpcnt_114;
  return_value_lglpcnt_114=lglpcnt(ts->inpr, simp);
  lglprs(lgl, "%8.3f %3.0f%% inprocessing    %3.0f%%", ts->inpr, return_value_lglpcnt_113, return_value_lglpcnt_114);
  lglprs(lgl, "==================================");
  double return_value_lglpcnt_115;
  return_value_lglpcnt_115=lglpcnt(simp, t);
  lglprs(lgl, "%8.3f %3.0f%% simplifying", simp, return_value_lglpcnt_115);
  double return_value_lglpcnt_116;
  return_value_lglpcnt_116=lglpcnt(ts->lkhd, t);
  lglprs(lgl, "%8.3f %3.0f%% lookahead", ts->lkhd, return_value_lglpcnt_116);
  search = ts->srch - ts->inpr;
  double return_value_lglpcnt_117;
  return_value_lglpcnt_117=lglpcnt(search, t);
  lglprs(lgl, "%8.3f %3.0f%% search", search, return_value_lglpcnt_117);
  lglprs(lgl, "==================================");
  lglprs(lgl, "%8.3f %3.0f%% all", t, 100.0);
  fflush(lgl->out);
}

// lglsteps
// file lglib.c line 8309
static signed long int lglsteps(struct LGL *lgl)
{
  signed long int steps = lgl->stats->props.simp;
  steps = steps + lgl->stats->props.search;
  steps = steps + lgl->stats->props.lkhd;
  steps = steps + lgl->stats->trd.steps;
  steps = steps + lgl->stats->unhd.steps;
  steps = steps + lgl->stats->elm.steps;
  return steps;
}

// lglstop
// file lglib.c line 4991
static void lglstop(struct LGL *lgl)
{
  lglflushtimers(lgl);
  lgl->timers->nest = lgl->timers->nest - 1;
}

// lglstrdup
// file lglib.c line 1300
static char * lglstrdup(struct LGL *lgl, const char *str)
{
  char *res;
  do
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(str);
    void *return_value_lglnew_2;
    return_value_lglnew_2=lglnew(lgl, (return_value_strlen_1 + (unsigned long int)1) * sizeof(char) /*1ul*/ );
    res = (char *)return_value_lglnew_2;
  }
  while((_Bool)0);
  char *return_value_strcpy_3;
  return_value_strcpy_3=strcpy(res, str);
  return return_value_strcpy_3;
}

// lglsynceqs
// file lglib.c line 12204
static signed int lglsynceqs(struct LGL *lgl)
{
  signed int *ereprs;
  signed int emax = lgl->maxext;
  signed int elit1;
  signed int erepr1;
  signed int elit2;
  signed int erepr2;
  signed int ilit1;
  signed int irepr1;
  signed int ilit2;
  signed int irepr2;
  signed int consumed = 0;
  signed int produced = 0;
  if(lgl->nvars == 0)
    return 1;

  else
    if(lgl->cbs == ((struct Cbs *)NULL))
      return 1;

    else
      if(lgl->cbs->eqs.lock.fun == ((signed int * (*)(void *))NULL))
        return 1;

      else
      {
        ereprs=lgl->cbs->eqs.lock.fun(lgl->cbs->eqs.lock.state);
        consumed = 0;
        produced = consumed;
        elit1 = 1;
        if(emax >= elit1)
        {
          signed int return_value_lglelitblockingoreliminated_1;
          return_value_lglelitblockingoreliminated_1=lglelitblockingoreliminated(lgl, elit1);
          if(return_value_lglelitblockingoreliminated_1 == 0)
          {
            elit2=lglptrjmp(ereprs, emax, elit1);
            if(!(elit2 == elit1))
            {
              signed int return_value_lglelitblockingoreliminated_2;
              return_value_lglelitblockingoreliminated_2=lglelitblockingoreliminated(lgl, elit2);
              if(return_value_lglelitblockingoreliminated_2 == 0)
              {
                erepr1=lglerepr(lgl, elit1);
                signed int return_value_lglelitblockingoreliminated_3;
                return_value_lglelitblockingoreliminated_3=lglelitblockingoreliminated(lgl, erepr1);
                if(return_value_lglelitblockingoreliminated_3 == 0)
                {
                  erepr2=lglerepr(lgl, elit2);
                  signed int return_value_lglelitblockingoreliminated_4;
                  return_value_lglelitblockingoreliminated_4=lglelitblockingoreliminated(lgl, erepr2);
                  if(return_value_lglelitblockingoreliminated_4 == 0)
                  {
                    if(!(erepr1 == erepr2))
                    {
                      if(erepr1 == -erepr2)
                      {

                      INCONSISTENT:
                        ;
                        lgl->mt = 1;
                      }

                      ilit1=lglimport(lgl, elit1);
                      ilit2=lglimport(lgl, elit2);
                      if(!(ilit1 == ilit2))
                      {
                        signed int return_value_abs_5;
                        return_value_abs_5=abs(ilit1);
                        if(return_value_abs_5 >= 2)
                        {
                          signed int return_value_abs_6;
                          return_value_abs_6=abs(ilit2);
                          if(return_value_abs_6 >= 2)
                          {
                            irepr1=lglirepr(lgl, ilit1);
                            irepr2=lglirepr(lgl, ilit2);
                            if(!(irepr1 == irepr2))
                            {
                              signed int return_value_abs_7;
                              return_value_abs_7=abs(irepr1);
                              if(return_value_abs_7 >= 2)
                              {
                                signed int return_value_abs_8;
                                return_value_abs_8=abs(irepr2);
                                if(return_value_abs_8 >= 2)
                                {
                                  signed int return_value_lglisfree_9;
                                  return_value_lglisfree_9=lglisfree(lgl, irepr1);
                                  if(!(return_value_lglisfree_9 == 0))
                                  {
                                    signed int return_value_lglisfree_10;
                                    return_value_lglisfree_10=lglisfree(lgl, irepr2);
                                    if(!(return_value_lglisfree_10 == 0))
                                    {
                                      consumed = consumed + 1;
                                      lglimerge(lgl, irepr1, irepr2);
                                    }

                                  }

                                }

                              }

                            }

                          }

                        }

                      }

                    }

                  }

                }

              }

            }

          }

          elit1 = elit1 + 1;
        }

        elit1 = 1;
        if(emax >= elit1)
        {
          elit2=lglerepr(lgl, elit1);
          if(!(elit1 == elit2))
          {
            erepr1=lglptrjmp(ereprs, emax, elit1);
            erepr2=lglptrjmp(ereprs, emax, elit2);
            if(!(erepr1 == erepr2))
            {
              produced = produced + 1;
              signed int return_value_abs_11;
              return_value_abs_11=abs(erepr1);
              ereprs[(signed long int)return_value_abs_11] = erepr1 < 0 ? -erepr2 : erepr2;
            }

          }

          elit1 = elit1 + 1;
        }


      DONE:
        ;
        if(!(lgl->cbs->eqs.unlock.fun == ((void (*)(void *, signed int, signed int))NULL)))
          lgl->cbs->eqs.unlock.fun(lgl->cbs->eqs.unlock.state, consumed, produced);

        return (signed int)!(lgl->mt != 0);
      }
}

// lglsyncunits
// file lglib.c line 8333
static signed int lglsyncunits(struct LGL *lgl)
{
  signed int *units;
  signed int *eou;
  signed int *p;
  signed int elit;
  signed int erepr;
  signed int ilit;
  signed int res;
  signed int count = 0;
  void (*produce)(void *, signed int);
  signed long int steps;
  struct Ext *ext;
  signed char val;
  signed int return_value_lglevel_1;
  signed int return_value_lglisfree_2;
  if(!(lgl->mt == 0))
    return 0;

  else
    if(lgl->cbs == ((struct Cbs *)NULL))
      return 1;

    else
      if(lgl->cbs->units.consume.fun == ((void (*)(void *, signed int **, signed int **))NULL))
        return 1;

      else
      {
        steps=lglsteps(lgl);
        if(!(steps >= lgl->limits->sync.steps))
          return 1;

        else
        {
          lgl->limits->sync.steps = steps + (signed long int)lgl->opts->syncint.val;
          lgl->cbs->units.consume.fun(lgl->cbs->units.consume.state, &units, &eou);
          if(units == eou)
            return 1;

          else
          {
            produce = lgl->cbs->units.produce.fun;
            lgl->cbs->units.produce.fun = ((void (*)(void *, signed int))NULL);
            p = units;
            if(lgl->mt == 0 && !(p >= eou))
            {
              elit = *p;
              erepr=lglerepr(lgl, elit);
              ext=lglelit2ext(lgl, erepr);
              ilit = ext->repr;
              if(!(ilit == 0))
              {
                if(!(erepr >= 0))
                  ilit = -ilit;

                if(!(ilit == 1))
                {
                  if(ilit == -1)
                    val = (signed char)-1;

                  else
                  {
                    val=lglval(lgl, ilit);
                    if(!(val == 0))
                    {
                      return_value_lglevel_1=lglevel(lgl, ilit);
                      if(!(return_value_lglevel_1 == 0))
                        val = (signed char)0;

                    }

                  }
                  if(!((signed int)val == 1))
                  {
                    if((signed int)val == -1)
                    {
                      if(lgl->level >= 1)
                        lglbacktrack(lgl, 0);

                      lgl->mt = 1;
                    }

                    else
                    {
                      return_value_lglisfree_2=lglisfree(lgl, ilit);
                      if(!(return_value_lglisfree_2 == 0))
                      {
                        if(lgl->level >= 1)
                          lglbacktrack(lgl, 0);

                        lglunit(lgl, ilit);
                        count = count + 1;
                      }

                    }
                  }

                }

              }

              p = p + 1l;
            }

            lgl->cbs->units.produce.fun = produce;
            if(!(lgl->cbs->units.consumed.fun == ((void (*)(void *, signed int))NULL)))
              lgl->cbs->units.consumed.fun(lgl->cbs->units.consumed.state, count);

            if(!(lgl->mt == 0))
              return 0;

            else
              if(count == 0)
                return 1;

              else
              {
                res=lglbcp(lgl);
                if(res == 0)
                {
                  if(lgl->mt == 0)
                    lgl->mt = 1;

                }

                return res;
              }
          }
        }
      }
}

// lglszpen
// file lglib.c line 8728
static signed int lglszpen(struct LGL *lgl)
{
  signed int res;
  res=lglceilld(lgl->stats->irr.lits.cur / lgl->opts->sizepen.val);
  if(!(res >= 0))
    res = 0;

  if(!(lgl->opts->sizemaxpen.val >= res))
    res = lgl->opts->sizemaxpen.val;

  return res;
}

// lglszstk
// file lglib.c line 1389
static unsigned long int lglszstk(struct Stk *s)
{
  return (unsigned long int)(s->end - s->start);
}

// lgltarjan
// file lglib.c line 8194
static signed int lgltarjan(struct LGL *lgl)
{
  signed int *dfsimap;
  signed int *mindfsimap;
  signed int idx;
  signed int oidx;
  signed int sign;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int other;
  signed int dfsi;
  signed int mindfsi;
  signed int ulit;
  signed int uother;
  signed int tmp;
  signed int repr;
  signed int res;
  signed int sgn;
  signed int frozen;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  struct Stk stk;
  struct Stk component;
  struct AVar *av;
  struct HTS *hts;
  signed int return_value_lglmtstk_4;
  signed int return_value_lglifrozen_6;
  if(lgl->nvars == 0)
    return 1;

  else
  {
    lglfreezer(lgl);
    dfsi = 0;
    do
    {
      void *return_value_lglnew_1;
      return_value_lglnew_1=lglnew(lgl, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
      dfsimap = (signed int *)return_value_lglnew_1;
    }
    while((_Bool)0);
    do
    {
      void *return_value_lglnew_2;
      return_value_lglnew_2=lglnew(lgl, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
      mindfsimap = (signed int *)return_value_lglnew_2;
    }
    while((_Bool)0);
    do
    {
      void *return_value_lglnew_3;
      return_value_lglnew_3=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
      lgl->repr = (signed int *)return_value_lglnew_3;
    }
    while((_Bool)0);
    do
      memset((void *)&stk, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    do
      memset((void *)&component, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    res = 1;
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      sign = -1;
      for( ; !(sign >= 2); sign = sign + 2)
      {
        lit = sign * idx;
        ulit=lglulit(lit);
        tmp = dfsimap[(signed long int)ulit];
        if(tmp == 0)
        {
          lglpushstk(lgl, &stk, lit);
          do
          {
            return_value_lglmtstk_4=lglmtstk(&stk);
            if(!(return_value_lglmtstk_4 == 0))
              break;

            lit=lglpopstk(&stk);
            if(!(lit == 0))
            {
              ulit=lglulit(lit);
              if(!(dfsimap[(signed long int)ulit] == 0))
                continue;

              dfsi = dfsi + 1;
              mindfsimap[(signed long int)ulit] = dfsi;
              dfsimap[(signed long int)ulit] = mindfsimap[(signed long int)ulit];
              lglpushstk(lgl, &component, lit);
              lglpushstk(lgl, &stk, lit);
              lglpushstk(lgl, &stk, 0);
              hts=lglhts(lgl, -lit);
              if(hts->offset == 0)
                continue;

              w=lglhts2wchs(lgl, hts);
              eow = w + (signed long int)hts->count;
              p = w;
              for( ; !(p >= eow); p = p + 1l)
              {
                blit = *p;
                tag = blit & MASKCS;
                if(!(tag == BINCS))
                  p = p + 1l;

                else
                {
                  other = blit >> RMSHFT;
                  uother=lglulit(other);
                  tmp = dfsimap[(signed long int)uother];
                  if(tmp == 0)
                    lglpushstk(lgl, &stk, other);

                }
              }
            }

            else
            {
              lit=lglpopstk(&stk);
              ulit=lglulit(lit);
              mindfsi = dfsimap[(signed long int)ulit];
              hts=lglhts(lgl, -lit);
              w=lglhts2wchs(lgl, hts);
              eow = w + (signed long int)hts->count;
              p = w;
              for( ; !(p >= eow); p = p + 1l)
              {
                blit = *p;
                tag = blit & MASKCS;
                if(!(tag == BINCS))
                  p = p + 1l;

                else
                {
                  other = blit >> RMSHFT;
                  uother=lglulit(other);
                  tmp = mindfsimap[(signed long int)uother];
                  if(!(tmp >= mindfsi))
                    mindfsi = tmp;

                }
              }
              if(mindfsi == dfsimap[(signed long int)ulit])
              {
                repr = lit;
                frozen=lglifrozen(lgl, repr);
                p = component.top - (signed long int)1;
                do
                {
                  other = *p;
                  if(other == lit)
                    break;

                  signed int return_value_lglcmprepr_5;
                  return_value_lglcmprepr_5=lglcmprepr(lgl, other, repr);
                  if(!(return_value_lglcmprepr_5 >= 0))
                    repr = other;

                  if(frozen == 0)
                  {
                    return_value_lglifrozen_6=lglifrozen(lgl, other);
                    if(!(return_value_lglifrozen_6 == 0))
                      frozen = 1;

                  }

                  p = p - 1l;
                }
                while((_Bool)1);
                do
                {
                  other=lglpopstk(&component);
                  if(other == lit)
                    break;

                  signed int return_value_lglulit_7;
                  return_value_lglulit_7=lglulit(other);
                  mindfsimap[(signed long int)return_value_lglulit_7] = 0x7fffffff;
                  if(!(other == repr))
                  {
                    if(other == -repr)
                    {

                    __CPROVER_DUMP_L24:
                      ;
                      lgl->mt = 1;
                      res = 0;
                      goto DONE;
                    }

                    sgn=lglsgn(other);
                    oidx=abs(other);
                    tmp = lgl->repr[(signed long int)oidx];
                    if(!(tmp == repr * sgn))
                    {

                    __CPROVER_DUMP_L26:
                      ;
                      if(!(tmp == 0))
                      {

                      __CPROVER_DUMP_L27:
                        ;
                        lgl->mt = 1;
                        res = 0;
                        goto DONE;
                      }

                      else
                      {
                        av=lglavar(lgl, oidx);
                        if((signed int)av->type == FREEVAR)
                          lglimerge(lgl, other, repr);

                      }
                    }

                  }

                }
                while((_Bool)1);
                signed int return_value_lglulit_8;
                return_value_lglulit_8=lglulit(lit);
                mindfsimap[(signed long int)return_value_lglulit_8] = 0x7fffffff;
                if(!(frozen == 0))

                  __CPROVER_DUMP_L32:
                    ;

              }

              else
                mindfsimap[(signed long int)ulit] = mindfsi;
            }
          }
          while((_Bool)1);
        }

      }
    }

  DONE:
    ;
    lglrelstk(lgl, &stk);
    lglrelstk(lgl, &component);
    do
    {
      lgldel(lgl, (void *)mindfsimap, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
      mindfsimap = ((signed int *)NULL);
    }
    while((_Bool)0);
    do
    {
      lgldel(lgl, (void *)dfsimap, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
      dfsimap = ((signed int *)NULL);
    }
    while((_Bool)0);
    if(res == 0)
      do
      {
        lgldel(lgl, (void *)lgl->repr, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
        lgl->repr = ((signed int *)NULL);
      }
      while((_Bool)0);

    return res;
  }
}

// lgltd
// file lglib.c line 2334
static struct TD * lgltd(struct LGL *lgl, signed int lit)
{
  signed int pos;
  pos=lgltrail(lgl, lit);
  return lgl->drail + (signed long int)pos;
}

// lglterminate
// file lglib.c line 8319
static signed int lglterminate(struct LGL *lgl)
{
  signed long int steps;
  signed int res;
  if(lgl->cbs == ((struct Cbs *)NULL))
    return 0;

  else
    if(lgl->cbs->term.fun == ((signed int (*)(void *))NULL))
      return 0;

    else
      if(!(lgl->cbs->term.done == 0))
        return 1;

      else
      {
        steps=lglsteps(lgl);
        if(!(steps >= lgl->limits->term.steps))
          return 0;

        else
        {
          res=lgl->cbs->term.fun(lgl->cbs->term.state);
          if(!(res == 0))
            lgl->cbs->term.done = res;

          else
            lgl->limits->term.steps = steps + (signed long int)lgl->opts->termint.val;
          return res;
        }
      }
}

// lglternres
// file lglib.c line 14734
static signed int lglternres(struct LGL *lgl)
{
  signed int before;
  signed int after;
  signed int delta;
  signed int before2;
  signed int after2;
  signed int delta2;
  signed int before3;
  signed int after3;
  signed int delta3;
  signed int success;
  signed int lit;
  if(!(lgl->nvars >= 3))
    return 1;

  else
  {
    lglstart(lgl, &lgl->times->trn);

  __CPROVER_DUMP_L2:
    ;
    lgl->ternresing = (char)1;
    lgl->simp = lgl->ternresing;
    lgl->stats->trnr.count = lgl->stats->trnr.count + 1;
    if(lgl->level >= 1)
      lglbacktrack(lgl, 0);

    lglseternreslim(lgl);
    lglternresinit(lgl);
    before2 = lgl->stats->trnr.bin;
    before3 = lgl->stats->trnr.trn;
    while(!(lgl->stats->trnr.steps >= lgl->limits->trnr.steps))
    {
      signed int return_value_lglterminate_1;
      return_value_lglterminate_1=lglterminate(lgl);
      if(!(return_value_lglterminate_1 == 0))
        break;

      signed int return_value_lglsyncunits_2;
      return_value_lglsyncunits_2=lglsyncunits(lgl);
      if(return_value_lglsyncunits_2 == 0)
        break;

      lit=lglwrknext(lgl);
      if(lit == 0)
      {
        lglprt(lgl, 2, "[ternres-%d] saturated", lgl->stats->trnr.count);
        break;
      }

      lgl->stats->trnr.steps = lgl->stats->trnr.steps + 1l;
      signed int return_value_lglisfree_3;
      return_value_lglisfree_3=lglisfree(lgl, lit);
      if(!(return_value_lglisfree_3 == 0))
      {
        struct AVar *return_value_lglavar_4;
        return_value_lglavar_4=lglavar(lgl, lit);
        return_value_lglavar_4->donoternres = (unsigned int)1;
        lglternresidx(lgl, lit);
      }

    }
    after2 = lgl->stats->trnr.bin;
    after3 = lgl->stats->trnr.trn;
    after = after2 + after3;
    before = before2 + before3;
    delta2 = after2 - before2;
    delta3 = after3 - before3;
    delta = after - before;
    success = (signed int)(before < after);
    lglprt(lgl, 1, "[ternres-%d] %d ternary resolvents (%d bin, %d trn)", lgl->stats->trnr.count, delta, delta2, delta3);
    lglupdternrespen(lgl, success);
    lgl->ternresing = (char)0;
    lgl->simp = lgl->ternresing;
    lglprternresrem(lgl);
    lglrep(lgl, 1 + (signed int)!(success != 0), (char)84);
    lglwrkreset(lgl);
    lglstop(lgl);
    return (signed int)!(lgl->mt != 0);
  }
}

// lglternresidx
// file lglib.c line 14651
static void lglternresidx(struct LGL *lgl, signed int idx)
{
  lglternreslit(lgl, idx);
  lglternreslit(lgl, -idx);
}

// lglternresinit
// file lglib.c line 14706
static void lglternresinit(struct LGL *lgl)
{
  signed int idx;
  signed int schedulable = 0;
  signed int donoternres = 0;
  lglwrkinit(lgl, 1, 1);
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree_1;
    return_value_lglisfree_1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree_1 == 0))
    {
      struct AVar *return_value_lglavar_2;
      return_value_lglavar_2=lglavar(lgl, idx);
      if(!(return_value_lglavar_2->donoternres == 0u))
        donoternres = donoternres + 1;

      else
        schedulable = schedulable + 1;
    }

  }
  if(schedulable == 0)
  {
    donoternres = 0;
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      signed int return_value_lglisfree_3;
      return_value_lglisfree_3=lglisfree(lgl, idx);
      if(!(return_value_lglisfree_3 == 0))
      {
        struct AVar *return_value_lglavar_4;
        return_value_lglavar_4=lglavar(lgl, idx);
        return_value_lglavar_4->donoternres = (unsigned int)0;
        schedulable = schedulable + 1;
      }

    }
  }

  double return_value_lglpcnt_5;
  if(donoternres == 0)
    lglprt(lgl, 1, "[ternres-%d] all %d free variables schedulable", lgl->stats->trnr.count, schedulable);

  else
  {
    return_value_lglpcnt_5=lglpcnt((double)schedulable, (double)(lgl->nvars - 2));
    lglprt(lgl, 1, "[ternres-%d] %d schedulable variables %.0f%%", lgl->stats->trnr.count, schedulable, return_value_lglpcnt_5);
  }
  lgl->donotsched = (char)1;
  lglrandidxtrav(lgl, lglwrktouch);
  lgl->donotsched = (char)0;
}

// lglternreslit
// file lglib.c line 14550
static void lglternreslit(struct LGL *lgl, signed int lit)
{
  signed int *pw;
  signed int *peow;
  signed int *nw;
  signed int *neow;
  signed int *p;
  signed int *n;
  signed int pblit;
  signed int ptag;
  signed int pother;
  signed int pother2;
  signed int pdelta;
  signed int nblit;
  signed int ntag;
  signed int nother;
  signed int nother2;
  signed int ndelta;
  struct HTS *phts;
  struct HTS *nhts;
  signed int a;
  signed int b;
  signed int c;
  phts=lglhts(lgl, lit);
  pw=lglhts2wchs(lgl, phts);
  peow = pw + (signed long int)phts->count;
  nhts=lglhts(lgl, -lit);
  nw=lglhts2wchs(lgl, nhts);
  neow = nw + (signed long int)nhts->count;
  n = nw;
  for( ; !(n >= neow); n = n + 1l)
  {
    lgl->stats->trnr.steps = lgl->stats->trnr.steps + 1l;
    if(lgl->stats->trnr.steps >= lgl->limits->trnr.steps)
      goto __CPROVER_DUMP_L28;

    nblit = *n;
    ntag = nblit & MASKCS;
    if(!(ntag == OCCS) && !(ntag == BINCS))
    {
      if(ntag == TRNCS)
        break;

      n = n + 1l;
    }

  }
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_4;
  if(!(n >= neow))
  {
    p = pw;
    do
    {
      if(!(p >= peow))
        tmp_if_expr_1 = lgl->stats->trnr.steps < lgl->limits->trnr.steps ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      lgl->stats->trnr.steps = lgl->stats->trnr.steps + 1l;
      pblit = *p;
      ptag = pblit & MASKCS;
      if(!(ptag == OCCS) && !(ptag == BINCS))
      {
        if(ptag == TRNCS || ptag == LRGCS)
          p = p + 1l;

        if(!(ptag == LRGCS))
        {
          pother = pblit >> RMSHFT;
          signed char return_value_lglval_2;
          return_value_lglval_2=lglval(lgl, pother);
          if(return_value_lglval_2 == 0)
          {
            pother2 = *p;
            signed char return_value_lglval_3;
            return_value_lglval_3=lglval(lgl, pother2);
            if(return_value_lglval_3 == 0)
            {
              n = nw;
              do
              {
                if(!(n >= neow))
                  tmp_if_expr_4 = lgl->stats->trnr.steps < lgl->limits->trnr.steps ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_4 = (_Bool)0;
                if(!tmp_if_expr_4)
                  break;

                lgl->stats->trnr.steps = lgl->stats->trnr.steps + 1l;
                nblit = *n;
                ntag = nblit & MASKCS;
                if(!(ntag == OCCS) && !(ntag == BINCS))
                {
                  if(ntag == TRNCS || ntag == LRGCS)
                    n = n + 1l;

                  if(!(ntag == LRGCS))
                  {
                    nother = nblit >> RMSHFT;
                    signed char return_value_lglval_5;
                    return_value_lglval_5=lglval(lgl, nother);
                    if(return_value_lglval_5 == 0)
                    {
                      nother2 = *n;
                      signed char return_value_lglval_6;
                      return_value_lglval_6=lglval(lgl, nother2);
                      if(return_value_lglval_6 == 0)
                      {
                        if(nother == pother && nother2 == pother2 || nother == pother2 && nother2 == pother)
                        {
                          a = nother;
                          b = nother2;
                          signed int return_value_lglhasbin_7;
                          return_value_lglhasbin_7=lglhasbin(lgl, a, b);
                          if(!(return_value_lglhasbin_7 == 0))
                            goto __CPROVER_DUMP_L24;

                          lgl->stats->trnr.bin = lgl->stats->trnr.bin + 1;

                        __CPROVER_DUMP_L17:
                          ;
                          lglwchbin(lgl, a, b, REDCS);
                          lglwchbin(lgl, b, a, REDCS);
                          lgl->stats->red.bin = lgl->stats->red.bin + 1;
                          lglwrktouch(lgl, a);
                          lglwrktouch(lgl, b);
                        }

                        else
                        {
                          a = nother;
                          b = nother2;
                          if(nother == pother || nother2 == pother)
                            c = pother2;

                          else
                            if(nother == pother2 || nother2 == pother2)
                              c = pother;

                            else
                              goto __CPROVER_DUMP_L24;
                          if(a == -c || b == -c)
                            goto __CPROVER_DUMP_L24;

                          signed int return_value_lglhastrn_8;
                          return_value_lglhastrn_8=lglhastrn(lgl, a, b, c);
                          if(!(return_value_lglhastrn_8 == 0))
                            goto __CPROVER_DUMP_L24;

                          lgl->stats->trnr.trn = lgl->stats->trnr.trn + 1;

                        __CPROVER_DUMP_L22:
                          ;
                          lglwchtrn(lgl, a, b, c, REDCS);
                          lglwchtrn(lgl, b, a, c, REDCS);
                          lglwchtrn(lgl, c, a, b, REDCS);
                          lgl->stats->red.trn = lgl->stats->red.trn + 1;
                          lglwrktouch(lgl, a);
                          lglwrktouch(lgl, b);
                          lglwrktouch(lgl, c);
                        }
                        pdelta = (signed int)(p - pw);
                        phts=lglhts(lgl, lit);
                        pw=lglhts2wchs(lgl, phts);
                        peow = pw + (signed long int)phts->count;
                        p = pw + (signed long int)pdelta;
                        ndelta = (signed int)(n - nw);
                        nhts=lglhts(lgl, -lit);
                        nw=lglhts2wchs(lgl, nhts);
                        neow = nw + (signed long int)nhts->count;
                        n = nw + (signed long int)ndelta;
                      }

                    }

                  }

                }


              __CPROVER_DUMP_L24:
                ;
                n = n + 1l;
              }
              while((_Bool)1);
            }

          }

        }

      }

      p = p + 1l;
    }
    while((_Bool)1);
  }


__CPROVER_DUMP_L28:
  ;
}

// lglternresolving
// file lglib.c line 17008
static signed int lglternresolving(struct LGL *lgl)
{
  return lgl->opts->ternres.val;
}

// lgltonflict
// file lglib.c line 4021
static void lgltonflict(struct LGL *lgl, signed int lit, signed int blit, signed int other2)
{
  lgl->conf.lit = lit;
  lgl->conf.rsn[(signed long int)0] = blit;
  lgl->conf.rsn[(signed long int)1] = other2;

__CPROVER_DUMP_L1:
  ;
}

// lgltopgc
// file lglib.c line 7668
static signed int lgltopgc(struct LGL *lgl)
{
  if(!(lgl->mt == 0))
    return 0;

  else
  {
    lgl->allowforce = (char)1;
    lgl->forcegc = lgl->allowforce;
    lglgc(lgl);
    lgl->allowforce = (char)0;
    lgl->forcegc = lgl->allowforce;
    return (signed int)!(lgl->mt != 0);
  }
}

// lgltopsimp
// file lglib.c line 17267
static signed int lgltopsimp(struct LGL *lgl, signed int forcesimp)
{
  _Bool tmp_if_expr_4;
  signed int return_value_lglfailedass_3;
  _Bool tmp_if_expr_8;
  signed int return_value_lglsimplimhit_7;
  signed int return_value_lglpreprocessing_6;
  if(!(lgl->mt == 0))
    return 20;

  else
  {
    signed int return_value_lglfailedass_1;
    return_value_lglfailedass_1=lglfailedass(lgl);
    if(!(return_value_lglfailedass_1 == 0))
      return 20;

    else
    {
      signed int return_value_lglbcptop_2;
      return_value_lglbcptop_2=lglbcptop(lgl);
      if(return_value_lglbcptop_2 == 0)
        return 20;

      else
      {
        if(!(lgl->mt == 0))
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_lglfailedass_3=lglfailedass(lgl);
          tmp_if_expr_4 = return_value_lglfailedass_3 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
          return 20;

        else
        {
          signed int return_value_lglterminate_5;
          return_value_lglterminate_5=lglterminate(lgl);
          if(!(return_value_lglterminate_5 == 0))
            return 0;

          else
          {
            if(!(forcesimp == 0))
              tmp_if_expr_8 = (_Bool)1;

            else
            {
              return_value_lglsimplimhit_7=lglsimplimhit(lgl);
              tmp_if_expr_8 = return_value_lglsimplimhit_7 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_8)
            {
              return_value_lglpreprocessing_6=lglpreprocessing(lgl, forcesimp);
              if(!(return_value_lglpreprocessing_6 == 0))
                goto __CPROVER_DUMP_L10;

              return 20;
            }

            else
            {

            __CPROVER_DUMP_L10:
              ;
              signed int return_value_lglfailedass_9;
              return_value_lglfailedass_9=lglfailedass(lgl);
              if(!(return_value_lglfailedass_9 == 0))
                return 20;

              else
              {
                if(lgl->qscheduling == 0)
                {
                  if(lgl->stats->confs == 0l)
                    lglcutwidth(lgl);

                  lglqschedall(lgl);
                }

                lglrep(lgl, 1, (char)115);
                return 0;
              }
            }
          }
        }
      }
    }
  }
}

// lgltopstk
// file lglib.c line 1449
static signed int lgltopstk(struct Stk *s)
{
  return s->top[(signed long int)-1];
}

// lgltrail
// file lglib.c line 2332
static signed int lgltrail(struct LGL *lgl, signed int lit)
{
  struct AVar *return_value_lglavar_1;
  return_value_lglavar_1=lglavar(lgl, lit);
  return return_value_lglavar_1->trail;
}

// lgltrapi
// file lglib.c line 1476
static void lgltrapi(struct LGL *lgl, const char *msg, ...)
{
  void **ap = (void **)&msg;
  vfprintf(lgl->apitrace, msg, ap);
  ap = ((void **)NULL);
  fputc(10, lgl->apitrace);
}

// lgltravall
// file lglib.c line 18882
void lgltravall(struct LGL *lgl, void *state, void (*trav)(void *, signed int))
{
  struct Trv travstate;
  travstate.state = state;
  travstate.trav = trav;
  lglutrav(lgl, (void *)&travstate, lgltravallu);
  lgletrav(lgl, (void *)&travstate, lgltravalle);
  lglctrav(lgl, state, trav);
}

// lgltravalle
// file lglib.c line 18872
static void lgltravalle(void *voidptr, signed int lit, signed int repr)
{
  struct Trv *state = (struct Trv *)voidptr;
  state->trav(state->state, -lit);
  state->trav(state->state, repr);
  state->trav(state->state, 0);
  state->trav(state->state, lit);
  state->trav(state->state, -repr);
  state->trav(state->state, 0);
}

// lgltravallu
// file lglib.c line 18866
static void lgltravallu(void *voidptr, signed int unit)
{
  struct Trv *state = (struct Trv *)voidptr;
  state->trav(state->state, unit);
  state->trav(state->state, 0);
}

// lgltravcounter
// file lglib.c line 18795
static void lgltravcounter(void *voidptr, signed int lit)
{
  signed int *cntptr = (signed int *)voidptr;
  if(lit == 0)
    *cntptr = *cntptr + 1;

}

// lgltravprinter
// file lglib.c line 18800
static void lgltravprinter(void *voidptr, signed int lit)
{
  struct _IO_FILE *out = (struct _IO_FILE *)voidptr;
  if(!(lit == 0))
    fprintf(out, "%d ", lit);

  else
    fprintf(out, "0\n");
}

// lgltrd
// file lglib.c line 14908
static signed int lgltrd(struct LGL *lgl)
{
  unsigned int pos;
  unsigned int delta;
  unsigned int mod;
  unsigned int ulit;
  unsigned int first;
  unsigned int last;
  signed long int oldprgss = lgl->stats->prgss;
  signed int lit;
  signed int count;
  signed int success;
  unsigned int return_value_lglgcd_3;
  if(!(lgl->nvars >= 3))
    return 1;

  else
  {
    lgl->stats->trd.count = lgl->stats->trd.count + 1;
    lglstart(lgl, &lgl->times->trd);
    lgl->simp = (char)1;
    if(lgl->level >= 1)
      lglbacktrack(lgl, 0);

    lglsetrdlim(lgl);
    mod = (unsigned int)(2 * (lgl->nvars - 2));
    unsigned int return_value_lglrand_1;
    return_value_lglrand_1=lglrand(lgl);
    pos = return_value_lglrand_1 % mod;
    unsigned int return_value_lglrand_2;
    return_value_lglrand_2=lglrand(lgl);
    delta = return_value_lglrand_2 % mod;
    if(delta == 0u)
      delta = delta + 1u;

    do
    {
      return_value_lglgcd_3=lglgcd(delta, mod);
      if(!(return_value_lglgcd_3 >= 2u))
        break;

      delta = delta + 1u;
      if(delta == mod)
        delta = (unsigned int)1;

    }
    while((_Bool)1);

  __CPROVER_DUMP_L5:
    ;
    first = mod;
    count = 0;
    while(!(lgl->stats->trd.steps >= lgl->limits->trd.steps))
    {
      signed int return_value_lglterminate_4;
      return_value_lglterminate_4=lglterminate(lgl);
      if(!(return_value_lglterminate_4 == 0))
        break;

      signed int return_value_lglsyncunits_5;
      return_value_lglsyncunits_5=lglsyncunits(lgl);
      if(return_value_lglsyncunits_5 == 0)
        break;

      ulit = pos + (unsigned int)4;
      lit=lglilit((signed int)ulit);
      lgltrdlit(lgl, lit);
      count = count + 1;
      if(!(lgl->mt == 0))
        break;

      last = pos;
      pos = pos + delta;
      if(pos >= mod)
        pos = pos - mod;

      if(pos == first)
        break;

      if(mod == 1u)
        break;

      if(first == mod)
        first = last;

    }
    success = (signed int)(oldprgss < lgl->stats->prgss);
    if(!(success == 0))
    {
      if(!(lgl->limits->trd.pen == 0))
        lgl->limits->trd.pen = lgl->limits->trd.pen - 1;

    }

    if(success == 0)
    {
      if(!(lgl->limits->trd.pen >= 4))
        lgl->limits->trd.pen = lgl->limits->trd.pen + 1;

    }

    lgl->simp = (char)0;
    lglrep(lgl, 1 + (signed int)!(success != 0), (char)116);
    lglstop(lgl);
    return (signed int)!(lgl->mt != 0);
  }
}

// lgltrdbin
// file lglib.c line 14784
static signed int lgltrdbin(struct LGL *lgl, signed int start, signed int target, signed int irr)
{
  signed int lit;
  signed int lgltrdbin__1__next;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int *p;
  signed int *w;
  signed int *eow;
  signed int res;
  signed int ign;
  signed int val;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  lgl->stats->trd.bins = lgl->stats->trd.bins + 1l;
  lglpushnmarkseen(lgl, -start);
  lgltrdbin__1__next = 0;
  res = 0;
  ign = 1;
  unsigned long int return_value_lglcntstk_1;
  signed int tmp_post_2;
  do
  {
    return_value_lglcntstk_1=lglcntstk(&lgl->seen);
    if((unsigned long int)lgltrdbin__1__next >= return_value_lglcntstk_1)
      break;

    tmp_post_2 = lgltrdbin__1__next;
    lgltrdbin__1__next = lgltrdbin__1__next + 1;
    lit=lglpeek(&lgl->seen, tmp_post_2);
    lgl->stats->trd.steps = lgl->stats->trd.steps + 1l;

  __CPROVER_DUMP_L3:
    ;
    signed char return_value_lglval_3;
    return_value_lglval_3=lglval(lgl, lit);
    val = (signed int)return_value_lglval_3;
    if(val == 0)
    {
      hts=lglhts(lgl, -lit);
      if(!(hts->count == 0))
      {
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          tag = blit & MASKCS;
          if(tag == TRNCS || tag == LRGCS)
            p = p + 1l;

          if(tag == BINCS)
          {
            red = blit & REDCS;
            if(red == 0 || irr == 0)
            {
              other = blit >> RMSHFT;
              if(!(other == start))
              {
                if(other == target)
                {
                  if(lit == -start && !(ign == 0))
                  {
                    ign = 0;
                    goto __CPROVER_DUMP_L14;
                  }


                __CPROVER_DUMP_L8:
                  ;
                  res = 1;
                  goto DONE;
                }

                val=lglmarked(lgl, other);
                if(!(val >= 1))
                {
                  if(!(val >= 0))
                  {
                    lgl->stats->trd.failed = lgl->stats->trd.failed + 1;

                  __CPROVER_DUMP_L10:
                    ;
                    lglunit(lgl, start);
                    val=lglbcp(lgl);
                    if(val == 0)
                    {
                      if(lgl->mt == 0)
                        lgl->mt = 1;

                    }

                    res = -1;
                    goto DONE;
                  }

                  lglpushnmarkseen(lgl, other);
                }

              }

            }

          }


        __CPROVER_DUMP_L13:
          ;

        __CPROVER_DUMP_L14:
          ;
        }
      }

    }

  }
  while((_Bool)1);

DONE:
  ;
  lglpopnunmarkstk(lgl, &lgl->seen);
  return res;
}

// lgltrdlit
// file lglib.c line 14845
static void lgltrdlit(struct LGL *lgl, signed int start)
{
  signed int target;
  signed int *w;
  signed int *p;
  signed int *eow;
  signed int blit;
  signed int tag;
  signed int red;
  signed int val;
  struct HTS *hts;
  signed char return_value_lglval_1;
  return_value_lglval_1=lglval(lgl, start);
  val = (signed int)return_value_lglval_1;
  _Bool tmp_if_expr_2;
  if(val == 0)
  {

  __CPROVER_DUMP_L1:
    ;
    hts=lglhts(lgl, start);
    if(!(hts->count == 0))
    {
      lgl->stats->trd.lits = lgl->stats->trd.lits + 1l;
      w=lglhts2wchs(lgl, hts);
      eow = w + (signed long int)hts->count;
      p = w;
      do
      {
        if(!(p >= eow))
          tmp_if_expr_2 = lgl->stats->trd.steps < lgl->limits->trd.steps ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(!tmp_if_expr_2)
          break;

        blit = *p;
        tag = blit & MASKCS;
        if(tag == TRNCS || tag == LRGCS)
          p = p + 1l;

        if(tag == BINCS)
        {
          target = blit >> RMSHFT;
          signed int return_value_abs_3;
          return_value_abs_3=abs(start);
          signed int return_value_abs_4;
          return_value_abs_4=abs(target);
          if(return_value_abs_4 >= return_value_abs_3)
          {
            red = blit & REDCS;
            val=lgltrdbin(lgl, start, target, red ^ REDCS);
            if(!(val == 0))
            {
              if(!(val >= 0))
                break;


            __CPROVER_DUMP_L8:
              ;
              lgl->stats->trd.red = lgl->stats->trd.red + 1;
              lgl->stats->prgss = lgl->stats->prgss + 1l;
              lglrmbwch(lgl, start, target, red);
              lglrmbwch(lgl, target, start, red);
              if(!(red == 0))
                lgl->stats->red.bin = lgl->stats->red.bin - 1;

              else
                lgldecirr(lgl, 2);
              break;
            }

          }

        }

        p = p + 1l;
      }
      while((_Bool)1);
    }

  }

}

// lgltreducing
// file lglib.c line 16949
static signed int lgltreducing(struct LGL *lgl)
{
  return lgl->opts->transred.val;
}

// lgltruefun
// file lglib.c line 10519
static void lgltruefun(unsigned long int *res)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    res[(signed long int)i] = (unsigned long int)~0ll;
}

// lgltrylargeve
// file lglib.c line 10247
static signed int lgltrylargeve(struct LGL *lgl)
{
  const signed int *c;
  const signed int *d;
  const signed int *sop;
  const signed int *eop;
  const signed int *son;
  const signed int *eon;
  const signed int *p;
  const signed int *q;
  const signed int *lgltrylargeve__1__start;
  const signed int *end;
  signed int lit;
  signed int idx;
  signed int sgn;
  signed int tmp;
  signed int ip;
  signed int mp;
  signed int ilit;
  signed int npocc;
  signed int nnocc;
  signed int limit;
  signed int count;
  signed int i;
  signed int clen;
  signed int dlen;
  signed int reslen;
  signed int maxreslen;
  signed char val;
  ip = lgl->_anon0.elm->pivot;
  sop = lgl->_anon0.elm->lits.start + (signed long int)1;
  son = lgl->_anon0.elm->lits.start + (signed long int)lgl->_anon0.elm->neglidx;
  eop = son;
  eon = lgl->_anon0.elm->lits.top;
  signed int return_value_lglulit_1;
  return_value_lglulit_1=lglulit(1);
  npocc=lglpeek(&lgl->_anon0.elm->noccs, return_value_lglulit_1);
  signed int return_value_lglulit_2;
  return_value_lglulit_2=lglulit(-1);
  nnocc=lglpeek(&lgl->_anon0.elm->noccs, return_value_lglulit_2);
  limit = npocc + nnocc;
  count = 0;
  i = 0;
  for( ; !(i >= 2); i = i + 1)
  {
    lgltrylargeve__1__start = i != 0 ? son : sop;
    end = i != 0 ? eon : eop;
    c = lgltrylargeve__1__start;
    for( ; !(c >= end); c = c + 1l)
    {
      lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
      if(*c == 0x7fffffff)
        for( ; !(*c == 0); c = c + 1l)
          ;

      else
      {
        do
        {
          lit = *c;
          if(lit == 0)
            break;

          lglm2i(lgl, lit);
          c = c + 1l;
        }
        while((_Bool)1);
        count = count + 1;
      }
    }
  }

__CPROVER_DUMP_L9:
  ;
  maxreslen = 0;
  c = sop;
  for( ; limit >= 0 && !(c >= eop); c = p + (signed long int)1)
  {
    lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
    if(*c == 0x7fffffff)
    {
      p = c + (signed long int)1;
      for( ; !(*p == 0); p = p + 1l)
        ;
    }

    else
    {
      clen = 0;
      p = c;
      do
      {
        lit = *p;
        if(lit == 0)
          break;

        if(!(lit == 1))
        {
          idx=abs(lit);
          sgn=lglsgn(lit);
          lglpoke(&lgl->_anon0.elm->mark, idx, sgn);
          ilit=lglm2i(lgl, lit);
          lglpushstk(lgl, &lgl->_anon1.resolvent, ilit);
          clen = clen + 1;
        }

        p = p + 1l;
      }
      while((_Bool)1);
      d = son;
      for( ; limit >= 0 && !(d >= eon); d = q + (signed long int)1)
      {
        lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
        if(*d == 0x7fffffff)
        {
          q = d + (signed long int)1;
          for( ; !(*q == 0); q = q + 1l)
            ;
        }

        else
        {
          lgl->stats->elm.resolutions = lgl->stats->elm.resolutions + 1l;

        __CPROVER_DUMP_L21:
          ;

        __CPROVER_DUMP_L22:
          ;
          dlen = 0;
          reslen = clen;
          q = d;
          do
          {
            lit = *q;
            if(lit == 0)
              break;

            if(!(lit == -1))
            {
              dlen = dlen + 1;
              idx=abs(lit);
              sgn=lglsgn(lit);
              tmp=lglpeek(&lgl->_anon0.elm->mark, idx);
              if(tmp == -sgn)
                break;

              if(!(tmp == sgn))
              {
                ilit=lglm2i(lgl, lit);
                lglpushstk(lgl, &lgl->_anon1.resolvent, ilit);
                reslen = reslen + 1;
              }

            }

            q = q + 1l;
          }
          while((_Bool)1);
          if(lit == 0 && reslen == 1)
          {

          __CPROVER_DUMP_L26:
            ;
            lit=lglpeek(&lgl->_anon1.resolvent, 0);
            struct EVar *return_value_lglevar_3;
            return_value_lglevar_3=lglevar(lgl, lit);
            limit = limit + return_value_lglevar_3->occ[(signed long int)(lit < 0)];
          }

          else
            if(!(lit == 0))
              do
              {
                q = q + 1l;
                if(*q == 0)
                  break;

              }
              while((_Bool)1);

            else
            {
              limit = limit - 1;

            __CPROVER_DUMP_L31:
              ;
              if(!(maxreslen >= reslen))
                maxreslen = reslen;

            }

        __CPROVER_DUMP_L29:
          ;
          lglrststk(&lgl->_anon1.resolvent, clen);
        }
      }
      lglclnstk(&lgl->_anon1.resolvent);
      p = c;
      do
      {
        lit = *p;
        if(lit == 0)
          break;

        if(!(lit == 1))
        {
          idx=abs(lit);
          lglpoke(&lgl->_anon0.elm->mark, idx, 0);
        }

        p = p + 1l;
      }
      while((_Bool)1);
      if(lgl->stats->elm.steps >= lgl->limits->elm.steps)
      {

      __CPROVER_DUMP_L38:
        ;
        return 0;
      }

    }
  }
  if(!(limit >= 0))
  {

  __CPROVER_DUMP_L41:
    ;
    return 0;
  }

  else
  {
    if(!(limit == 0))

      __CPROVER_DUMP_L43:
        ;

    else

      __CPROVER_DUMP_L44:
        ;

  __CPROVER_DUMP_L45:
    ;
    lglflushclauses(lgl, ip);
    lglflushclauses(lgl, -ip);
    if(!(npocc >= nnocc))
    {
      lgltrylargeve__1__start = sop;
      end = eop;
      mp = 1;
    }

    else
    {
      lgltrylargeve__1__start = son;
      end = eon;
      ip = -ip;
      mp = -1;
    }

  __CPROVER_DUMP_L47:
    ;
    c = lgltrylargeve__1__start;
    for( ; !(c >= end); c = p + (signed long int)1)
    {
      lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
      if(*c == 0x7fffffff)
      {
        p = c + (signed long int)1;
        for( ; !(*p == 0); p = p + 1l)
          ;
      }

      else
      {
        lglepush(lgl, 0);
        lglepush(lgl, ip);
        p = c;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          if(!(lit == mp))
          {
            ilit=lglm2i(lgl, lit);
            lglepush(lgl, ilit);
          }

          p = p + 1l;
        }
        while((_Bool)1);
      }
    }
    lglepush(lgl, 0);
    lglepush(lgl, -ip);
    c = sop;
    for( ; !(c >= eop); c = p + (signed long int)1)
    {
      lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
      if(*c == 0x7fffffff)
      {
        p = c + (signed long int)1;
        for( ; !(*p == 0); p = p + 1l)
          ;
      }

      else
      {
        clen = 0;
        p = c;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          if(!(lit == 1))
          {
            idx=abs(lit);
            sgn=lglsgn(lit);
            lglpoke(&lgl->_anon0.elm->mark, idx, sgn);
            ilit=lglm2i(lgl, lit);
            lglpushstk(lgl, &lgl->_anon1.resolvent, ilit);
            clen = clen + 1;
          }

          p = p + 1l;
        }
        while((_Bool)1);
        d = son;
        for( ; limit >= 0 && !(d >= eon); d = q + (signed long int)1)
        {
          lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
          if(*d == 0x7fffffff)
          {
            q = d + (signed long int)1;
            for( ; !(*q == 0); q = q + 1l)
              ;
          }

          else
          {
            lgl->stats->elm.resolutions = lgl->stats->elm.resolutions + 1l;
            dlen = 0;
            reslen = clen;
            q = d;
            do
            {
              lit = *q;
              if(lit == 0)
                break;

              if(!(lit == -1))
              {
                dlen = dlen + 1;
                idx=abs(lit);
                sgn=lglsgn(lit);
                tmp=lglpeek(&lgl->_anon0.elm->mark, idx);
                if(!(tmp == sgn))
                {
                  if(tmp == -sgn)
                    break;

                  ilit=lglm2i(lgl, lit);
                  val=lglval(lgl, ilit);
                  if((signed int)val >= 0)
                  {
                    if((signed int)val >= 1)
                      break;

                    lglpushstk(lgl, &lgl->clause, ilit);
                    ilit=lglm2i(lgl, lit);
                    lglpushstk(lgl, &lgl->_anon1.resolvent, ilit);
                    reslen = reslen + 1;
                  }

                }

              }

              q = q + 1l;
            }
            while((_Bool)1);
            if(!(lit == 0) || !(reslen == 1))
            {
              if(lit == 0)
                goto RESOLVE;

              do
              {
                q = q + 1l;
                if(*q == 0)
                  break;

              }
              while((_Bool)1);
            }

            else
            {
              do

                RESOLVE:
                  ;
              while((_Bool)0);

            __CPROVER_DUMP_L73:
              ;
              p = c;
              do
              {
                lit = *p;
                if(lit == 0)
                  break;

                if(!(lit == 1))
                {
                  ilit=lglm2i(lgl, lit);
                  val=lglval(lgl, ilit);
                  if((signed int)val >= 0)
                  {
                    if((signed int)val >= 1)
                      break;

                    lglpushstk(lgl, &lgl->clause, ilit);
                  }

                }

                p = p + 1l;
              }
              while((_Bool)1);
              if(lit == 0)
              {
                lglpushstk(lgl, &lgl->clause, 0);

              __CPROVER_DUMP_L77:
                ;
                lgladdcls(lgl, 0, 0, 1);
              }

            }
            lglclnstk(&lgl->clause);
            lglrststk(&lgl->_anon1.resolvent, clen);
          }
        }
        lglclnstk(&lgl->_anon1.resolvent);
        p = c;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          if(!(lit == 1))
          {
            idx=abs(lit);
            lglpoke(&lgl->_anon0.elm->mark, idx, 0);
          }

          p = p + 1l;
        }
        while((_Bool)1);
      }
    }
    lgleliminated(lgl, lgl->_anon0.elm->pivot);
    lgl->stats->elm.large = lgl->stats->elm.large + 1;
    return 1;
  }
}

// lgltrysmallve
// file lglib.c line 10973
static signed int lgltrysmallve(struct LGL *lgl, signed int idx)
{
  signed int res = 0;
  signed int new;
  signed int old;
  signed int units;
  unsigned long int pos[64l];
  unsigned long int neg[64l];
  unsigned long int fun[64l];
  struct EVar *ev;
  signed long int cnf;
  lglpushstk(lgl, &lgl->_anon0.elm->m2i, 0);
  lglpushstk(lgl, &lgl->_anon0.elm->clv, 0);
  signed int return_value_lglinitsmallve_1;
  return_value_lglinitsmallve_1=lglinitsmallve(lgl, idx, pos);
  _Bool tmp_if_expr_3;
  signed int return_value_lglinitsmallve_2;
  if(!(return_value_lglinitsmallve_1 == 0))
  {
    return_value_lglinitsmallve_2=lglinitsmallve(lgl, -idx, neg);
    tmp_if_expr_3 = return_value_lglinitsmallve_2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
  {
    lglor3fun(fun, pos, neg);
    cnf=lglsmallipos(lgl, fun, fun, 0);
    new=lglcnf2size(cnf);
    units=lglsmallcnfunits(lgl, cnf);
    new = new - units;
    ev=lglevar(lgl, idx);
    old = ev->occ[(signed long int)0] + ev->occ[(signed long int)1];

  __CPROVER_DUMP_L3:
    ;
    lgl->stats->elm.small.tried = lgl->stats->elm.small.tried + 1;
    if(old >= new)
    {

    __CPROVER_DUMP_L4:
      ;
      lglepusheliminated(lgl, idx);
      lglflushclauses(lgl, idx);
      lglflushclauses(lgl, -idx);
      lglsmallve(lgl, cnf);
      lgl->stats->elm.small.elm = lgl->stats->elm.small.elm + 1;
      res = 1;
    }

    else
    {

    __CPROVER_DUMP_L5:
      ;
      if(units >= 1)
        res = 1;

      else
        lgl->stats->elm.small.failed = lgl->stats->elm.small.failed + 1;
    }
  }

  else

    __CPROVER_DUMP_L8:
      ;
  lglresetsmallve(lgl);
  return res;
}

// lgluby
// file lglib.c line 5256
static signed long int lgluby(struct LGL *lgl, signed int i)
{
  lgl->stats->luby.count = lgl->stats->luby.count + 1;
  signed long int return_value_lglubyrec_1;
  return_value_lglubyrec_1=lglubyrec(lgl, i);
  return return_value_lglubyrec_1;
}

// lglubyrec
// file lglib.c line 5237
static signed long int lglubyrec(struct LGL *lgl, signed int i)
{
  signed long int res = (signed long int)0;
  signed long int s = (signed long int)0;
  signed int k = 1;
  for( ; res == 0l && !(k >= 32); k = k + 1)
  {
    if(i == (1 << k) + -1)
      res = (signed long int)(1 << k - 1);

    s = s + 1l;
  }
  k = 1;
  for( ; res == 0l; s = s + 1l)
  {
    if(i >= 1 << k + -1 && !(i >= (1 << k) + -1))
      res=lglubyrec(lgl, (i - (1 << k - 1)) + 1);

    k = k + 1;
  }
  lgl->stats->luby.steps = lgl->stats->luby.steps + s;
  return res;
}

// lglulit
// file lglib.c line 2580
static signed int lglulit(signed int lit)
{
  signed int return_value_abs_1;
  return_value_abs_1=abs(lit);
  return 2 * return_value_abs_1 + (signed int)(lit < 0);
}

// lglunassign
// file lglib.c line 2759
static void lglunassign(struct LGL *lgl, signed int lit)
{
  signed int idx;
  idx=abs(lit);
  signed int r0;
  signed int r1;
  signed int tag;
  signed int lidx;
  signed int glue;
  struct TD *td;
  struct Qln *n;

__CPROVER_DUMP_L1:
  ;
  lgl->vals[(signed long int)idx] = (signed char)0;
  lgl->unassigned = lgl->unassigned + 1;
  _Bool tmp_if_expr_1;
  if(!(lgl->qscheduling == 0))
  {
    n=lglqln(lgl, idx);
    n->unassigned = n->first;
    if(lgl->queue.unassigned == ((struct Qln *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = lgl->queue.unassigned->prior < n->prior ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      lgl->queue.unassigned = n;

  }

  td=lgltd(lgl, idx);
  r0 = td->rsn[(signed long int)0];
  if(!((REDCS & r0) == 0))
  {
    tag = r0 & MASKCS;
    if(tag == LRGCS)
    {
      r1 = td->rsn[(signed long int)1];
      glue = r1 & (1 << 4) - 1;
      if(!(td->lrglue == 0u))
        lgl->lrgluereasons = lgl->lrgluereasons - 1;

      if(glue >= 15)
      {
        lidx = r1 >> 4;

      __CPROVER_DUMP_L9:
        ;
        lglrststk(&lgl->red[(signed long int)glue], lidx);
        lglredstk(lgl, &lgl->red[(signed long int)glue], 1 << 20, 3);
      }

    }

  }

}

// lglunclone
// file lglib.c line 17616
signed int lglunclone(struct LGL *lgl, struct LGL *from)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglunclone");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  _Bool tmp_if_expr_1;
  if(!(lgl->mt == 0))
    return 20;

  else
  {
    while(from == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglunclone");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized 'from' solver");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
    if(!(from->mt == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = ((signed int)from->state & UNSATISFIED) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      lglnegass(lgl);
      res=lglisat(lgl, ((struct Lim *)NULL), 0);
    }

    else
      if(!((96 & (signed int)from->state) == 0))
      {
        lglclass(lgl, from);
        res = 10;
      }

      else
      {
        lglreset(lgl);

      __CPROVER_DUMP_L11:
        ;
        do
          lgl->state = (enum State)UNKNOWN;
        while((_Bool)0);
        res = 0;
      }
    return res;
  }
}

// lglunflict
// file lglib.c line 5719
static void lglunflict(struct LGL *lgl, signed int lit)
{
  lgl->conf.lit = lit;
  lgl->conf.rsn[(signed long int)0] = lit << RMSHFT | UNITCS;

__CPROVER_DUMP_L1:
  ;
}

// lglunhdfailed
// file lglib.c line 15928
static signed int lglunhdfailed(struct LGL *lgl)
{
  signed int res = lgl->stats->unhd.stamp.failed;
  res = res + lgl->stats->unhd.failed.lits;
  res = res + lgl->stats->unhd.failed.bin;
  res = res + lgl->stats->unhd.failed.trn;
  res = res + lgl->stats->unhd.failed.lrg;
  return res;
}

// lglunhdhasbins
// file lglib.c line 14955
static signed int lglunhdhasbins(struct LGL *lgl, const struct DFPR *dfpr, signed int lit, signed int irronly)
{
  signed int blit;
  signed int tag;
  signed int other;
  signed int val;
  signed int red;
  signed int ulit;
  const signed int *p;
  const signed int *w;
  const signed int *eos;
  struct HTS *hts;
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  eos = w + (signed long int)hts->count;
  p = w;
  for( ; !(p >= eos); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(!(tag == OCCS))
    {
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      else
      {
        red = blit & REDCS;
        if(red == 0 || irronly == 0)
        {
          other = blit >> RMSHFT;
          signed char return_value_lglval_1;
          return_value_lglval_1=lglval(lgl, other);
          val = (signed int)return_value_lglval_1;
          if(!(val >= 1))
          {
            ulit=lglulit(other);
            if((dfpr + (signed long int)ulit)->discovered == 0)
              return 1;

          }

        }

      }
    }

  }
  return 0;
}

// lglunhdhbrs
// file lglib.c line 15937
static signed int lglunhdhbrs(struct LGL *lgl)
{
  signed int res = lgl->stats->unhd.hbrs.trn;
  res = res + lgl->stats->unhd.hbrs.lrg;
  return res;
}

// lglunhdisroot
// file lglib.c line 14981
static signed int lglunhdisroot(struct LGL *lgl, signed int lit, struct DFPR *dfpr, signed int irronly)
{
  signed int res;
  signed int return_value_lglunhdhasbins_1;
  return_value_lglunhdhasbins_1=lglunhdhasbins(lgl, dfpr, lit, irronly);
  res = (signed int)!(return_value_lglunhdhasbins_1 != 0);
  return res;
}

// lglunhdstrd
// file lglib.c line 15951
static signed int lglunhdstrd(struct LGL *lgl)
{
  signed int res = lgl->stats->unhd.units.bin;
  res = res + lgl->stats->unhd.str.trn;
  res = res + lgl->stats->unhd.str.lrg;
  return res;
}

// lglunhdtauts
// file lglib.c line 15943
static signed int lglunhdtauts(struct LGL *lgl)
{
  signed int res = lgl->stats->unhd.stamp.trds;
  res = res + lgl->stats->unhd.tauts.bin;
  res = res + lgl->stats->unhd.tauts.trn;
  res = res + lgl->stats->unhd.tauts.lrg;
  return res;
}

// lglunhdunits
// file lglib.c line 15921
static signed int lglunhdunits(struct LGL *lgl)
{
  signed int res = lgl->stats->unhd.units.bin;
  res = res + lgl->stats->unhd.units.trn;
  res = res + lgl->stats->unhd.units.lrg;
  return res;
}

// lglunhide
// file lglib.c line 16151
static signed int lglunhide(struct LGL *lgl)
{
  signed long int oldprgss = lgl->stats->prgss;
  signed long int roundprgss = (signed long int)0;
  signed int irronly;
  signed int round;
  signed int maxrounds;
  signed int noprgssrounds;
  signed int success;
  signed int oldunits;
  signed int oldfailed;
  signed int oldtauts;
  signed int oldhbrs;
  signed int oldstrd;
  struct DFPR *dfpr = ((struct DFPR *)NULL);
  _Bool tmp_if_expr_1;
  signed int tmp_post_2;
  _Bool tmp_if_expr_3;
  if(!(lgl->nvars >= 3))
    return 1;

  else
  {
    lgl->stats->unhd.count = lgl->stats->unhd.count + 1;
    lgl->unhiding = (char)1;
    lgl->simp = (char)1;
    lglstart(lgl, &lgl->times->unhd);
    if(lgl->stats->red.bin == 0)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (lgl->stats->unhd.count & 1) != 0 ? (_Bool)1 : (_Bool)0;
    irronly = (signed int)tmp_if_expr_1;
    if(lgl->level >= 1)
      lglbacktrack(lgl, 0);

    maxrounds = lgl->opts->unhdroundlim.val;
    lglsetunhdlim(lgl);
    oldunits=lglunhdunits(lgl);
    oldfailed=lglunhdfailed(lgl);
    oldtauts=lglunhdtauts(lgl);
    oldhbrs=lglunhdhbrs(lgl);
    oldstrd=lglunhdstrd(lgl);
    round = 0;
    noprgssrounds = round;
    while(lgl->mt == 0)
    {
      if(round >= maxrounds)
        break;

      if(round >= 1)
      {
        if(roundprgss == lgl->stats->prgss)
        {
          tmp_post_2 = noprgssrounds;
          noprgssrounds = noprgssrounds + 1;
          if(tmp_post_2 == lgl->opts->unhdlnpr.val)
          {

          __CPROVER_DUMP_L6:
            ;
            break;
          }

        }

      }

      round = round + 1;
      roundprgss = lgl->stats->prgss;
      lgl->stats->unhd.rounds = lgl->stats->unhd.rounds + 1;
      lglgc(lgl);
      if(lgl->nvars == 0)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = lgl->mt != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        break;

      dfpr=lglstampall(lgl, irronly);
      if(dfpr == ((struct DFPR *)NULL))
        break;

      signed int return_value_lglunhidefailed_4;
      return_value_lglunhidefailed_4=lglunhidefailed(lgl, dfpr);
      if(return_value_lglunhidefailed_4 == 0)
        break;

      signed int return_value_lglunhidebintrn_5;
      return_value_lglunhidebintrn_5=lglunhidebintrn(lgl, dfpr, irronly);
      if(return_value_lglunhidebintrn_5 == 0)
        break;

      signed int return_value_lglunhidelrg_6;
      return_value_lglunhidelrg_6=lglunhidelrg(lgl, dfpr, irronly);
      if(return_value_lglunhidelrg_6 == 0)
        break;

      if(lgl->stats->unhd.steps >= lgl->limits->unhd.steps)
        break;

      irronly = (signed int)(!(lgl->stats->red.bin != 0) ? (_Bool)1 : (!(irronly != 0) ? (_Bool)1 : (_Bool)0));
      do
      {
        lgldel(lgl, (void *)dfpr, (unsigned long int)(2 * lgl->nvars) * sizeof(struct DFPR) /*16ul*/ );
        dfpr = ((struct DFPR *)NULL);
      }
      while((_Bool)0);
    }
    if(!(dfpr == ((struct DFPR *)NULL)))
      do
      {
        lgldel(lgl, (void *)dfpr, (unsigned long int)(2 * lgl->nvars) * sizeof(struct DFPR) /*16ul*/ );
        dfpr = ((struct DFPR *)NULL);
      }
      while((_Bool)0);

    signed int return_value_lglunhdunits_7;
    return_value_lglunhdunits_7=lglunhdunits(lgl);
    signed int return_value_lglunhdfailed_8;
    return_value_lglunhdfailed_8=lglunhdfailed(lgl);
    signed int return_value_lglunhdtauts_9;
    return_value_lglunhdtauts_9=lglunhdtauts(lgl);
    signed int return_value_lglunhdhbrs_10;
    return_value_lglunhdhbrs_10=lglunhdhbrs(lgl);
    signed int return_value_lglunhdstrd_11;
    return_value_lglunhdstrd_11=lglunhdstrd(lgl);
    lglprt(lgl, 1, "[unhide-%d-%d] %d units, %d failed, %d tauts, %d hbrs, %d literals", lgl->stats->unhd.count, lgl->stats->unhd.rounds, return_value_lglunhdunits_7 - oldunits, return_value_lglunhdfailed_8 - oldfailed, return_value_lglunhdtauts_9 - oldtauts, return_value_lglunhdhbrs_10 - oldhbrs, return_value_lglunhdstrd_11 - oldstrd);
    success = (signed int)(oldprgss < lgl->stats->prgss);
    lglupdunhdpen(lgl, success);
    lgl->simp = (char)0;
    lgl->unhiding = (char)0;
    lglrep(lgl, 1 + (signed int)!(success != 0), (char)117);
    lglstop(lgl);
    return (signed int)!(lgl->mt != 0);
  }
}

// lglunhidebintrn
// file lglib.c line 15283
static signed int lglunhidebintrn(struct LGL *lgl, const struct DFPR *dfpr, signed int irronly)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int unit;
  signed int root;
  signed int lca;
  signed int nbinred;
  signed int ntrnred;
  signed int nbinunits;
  signed int ntrnunits;
  signed int ntrnstr;
  signed int ntrnhbrs;
  const signed int *p;
  const signed int *eow;
  signed int ulit;
  signed int uother;
  signed int *w;
  signed int *q;
  signed long int delta;
  struct HTS *hts;
  ntrnhbrs = 0;
  ntrnstr = ntrnhbrs;
  ntrnunits = ntrnstr;
  nbinunits = ntrnunits;
  ntrnred = nbinunits;
  nbinred = ntrnred;
  idx = 2;
  signed int *tmp_post_4;
  signed int *tmp_post_5;
  signed int *tmp_post_7;
  const signed int *tmp_post_8;
  _Bool tmp_if_expr_12;
  signed char return_value_lglval_11;
  _Bool tmp_if_expr_14;
  signed int return_value_lglunhroot_13;
  _Bool tmp_if_expr_43;
  signed int return_value_lglunhimplies2incl_42;
  _Bool tmp_if_expr_36;
  signed char return_value_lglval_35;
  _Bool tmp_if_expr_38;
  signed int return_value_lglunhroot_37;
  _Bool tmp_if_expr_40;
  signed int return_value_lglunhroot_39;
  _Bool tmp_if_expr_34;
  signed int return_value_lglunhimplies2incl_31;
  _Bool tmp_if_expr_33;
  signed int return_value_lglunhimplies2incl_32;
  signed int return_value_lglunhimplies2incl_30;
  signed int return_value_lglunhimplies2incl_29;
  signed char return_value_lglval_28;
  signed int return_value_lglunhroot_19;
  signed int return_value_lglunhimplies2incl_18;
  signed int return_value_lglunhimplies2incl_17;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      signed int return_value_lglterminate_1;
      return_value_lglterminate_1=lglterminate(lgl);
      if(!(return_value_lglterminate_1 == 0))
        return 0;

      signed int return_value_lglsyncunits_2;
      return_value_lglsyncunits_2=lglsyncunits(lgl);
      if(return_value_lglsyncunits_2 == 0)
        return 0;

      lgl->stats->unhd.steps = lgl->stats->unhd.steps + 1l;
      lit = sign * idx;
      signed char return_value_lglval_3;
      return_value_lglval_3=lglval(lgl, lit);
      if(return_value_lglval_3 == 0)
      {
        ulit=lglulit(lit);
        if(!((dfpr + (signed long int)ulit)->discovered == 0))
        {
          hts=lglhts(lgl, lit);
          w=lglhts2wchs(lgl, hts);
          eow = w + (signed long int)hts->count;
          q = w;
          p = w;
          for( ; !(p >= eow); p = p + 1l)
          {
            blit = *p;
            tmp_post_4 = q;
            q = q + 1l;
            *tmp_post_4 = blit;
            tag = blit & MASKCS;
            if(tag == TRNCS || tag == LRGCS)
            {
              tmp_post_5 = q;
              q = q + 1l;
              p = p + 1l;
              *tmp_post_5 = *p;
            }

            if(!(tag == LRGCS))
            {
              red = blit & REDCS;
              other = blit >> RMSHFT;
              signed char return_value_lglval_6;
              return_value_lglval_6=lglval(lgl, other);
              if(return_value_lglval_6 == 0)
              {
                uother=lglulit(other);
                if(tag == BINCS)
                {
                  signed int return_value_lglunhimplies2_15;
                  return_value_lglunhimplies2_15=lglunhimplies2(dfpr, other, lit);
                  if(!(return_value_lglunhimplies2_15 == 0))
                  {

                  __CPROVER_DUMP_L9:
                    ;
                    lgl->stats->unhd.units.bin = lgl->stats->unhd.units.bin + 1;
                    nbinunits = nbinunits + 1;
                    unit = lit;

                  UNIT:
                    ;
                    lglunit(lgl, unit);
                    p = p + 1l;
                    for( ; !(p >= eow); *tmp_post_7 = *tmp_post_8)
                    {
                      tmp_post_7 = q;
                      q = q + 1l;
                      tmp_post_8 = p;
                      p = p + 1l;
                    }
                    lglshrinkhts(lgl, hts, (signed int)((signed long int)hts->count - (p - q)));
                    signed int return_value_lglbcp_9;
                    return_value_lglbcp_9=lglbcp(lgl);
                    if(!(return_value_lglbcp_9 == 0))
                      goto NEXTIDX;


                  __CPROVER_DUMP_L13:
                    ;
                    lgl->mt = 1;
                    return 0;
                  }

                  else
                  {
                    root=lglunhroot(dfpr, -lit);
                    if(!(root == 0))
                    {
                      return_value_lglval_11=lglval(lgl, root);
                      tmp_if_expr_12 = !(return_value_lglval_11 != 0) ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_12 = (_Bool)0;
                    if(tmp_if_expr_12)
                    {
                      return_value_lglunhroot_13=lglunhroot(dfpr, -other);
                      tmp_if_expr_14 = root == return_value_lglunhroot_13 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_14 = (_Bool)0;
                    if(tmp_if_expr_14)
                    {

                    __CPROVER_DUMP_L19:
                      ;
                      lgl->stats->unhd.failed.bin = lgl->stats->unhd.failed.bin + 1;
                      lca=lglunhlca(lgl, dfpr, -lit, -other);
                      unit = -lca;
                      goto UNIT;
                    }

                    else
                      if(red == 0 && irronly == 0)
                        goto __CPROVER_DUMP_L74;

                      else
                      {
                        if((dfpr + (signed long int)uother)->parent == -lit)
                          goto __CPROVER_DUMP_L74;

                        if((dfpr + (signed long int)ulit)->parent == -other)
                          goto __CPROVER_DUMP_L74;

                        signed int return_value_lglunhimplies2_10;
                        return_value_lglunhimplies2_10=lglunhimplies2(dfpr, -lit, other);
                        if(return_value_lglunhimplies2_10 == 0)
                          goto __CPROVER_DUMP_L74;


                      __CPROVER_DUMP_L22:
                        ;
                        lgl->stats->unhd.tauts.bin = lgl->stats->unhd.tauts.bin + 1;
                        lgl->stats->prgss = lgl->stats->prgss + 1l;
                        if(!(red == 0))
                          lgl->stats->unhd.tauts.red = lgl->stats->unhd.tauts.red + 1;

                        nbinred = nbinred + 1;
                        lglrmbwch(lgl, other, lit, red);

                      __CPROVER_DUMP_L24:
                        ;
                        lgldeclscnt(lgl, 2, red, 0);
                        q = q - 1l;
                      }
                  }
                }

                else
                {
                  other2 = *p;
                  signed char return_value_lglval_16;
                  return_value_lglval_16=lglval(lgl, other2);
                  if(!(return_value_lglval_16 == 0))
                    goto __CPROVER_DUMP_L74;

                  signed int return_value_lglunhimplies2incl_41;
                  return_value_lglunhimplies2incl_41=lglunhimplies2incl(dfpr, other, lit);
                  if(!(return_value_lglunhimplies2incl_41 == 0))
                  {
                    return_value_lglunhimplies2incl_42=lglunhimplies2incl(dfpr, other2, lit);
                    tmp_if_expr_43 = return_value_lglunhimplies2incl_42 != 0 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_43 = (_Bool)0;
                  if(tmp_if_expr_43)
                  {

                  __CPROVER_DUMP_L29:
                    ;
                    lgl->stats->unhd.str.trn = lgl->stats->unhd.str.trn + 2;
                    if(!(red == 0))
                      lgl->stats->unhd.str.red = lgl->stats->unhd.str.red + 2;

                    lgl->stats->unhd.units.trn = lgl->stats->unhd.units.trn + 1;
                    ntrnunits = ntrnunits + 1;
                    unit = lit;
                    goto UNIT;
                  }

                  else
                  {
                    root=lglunhroot(dfpr, -lit);
                    if(!(root == 0))
                    {
                      return_value_lglval_35=lglval(lgl, root);
                      tmp_if_expr_36 = !(return_value_lglval_35 != 0) ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_36 = (_Bool)0;
                    if(tmp_if_expr_36)
                    {
                      return_value_lglunhroot_37=lglunhroot(dfpr, -other);
                      tmp_if_expr_38 = root == return_value_lglunhroot_37 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_38 = (_Bool)0;
                    if(tmp_if_expr_38)
                    {
                      return_value_lglunhroot_39=lglunhroot(dfpr, -other2);
                      tmp_if_expr_40 = root == return_value_lglunhroot_39 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_40 = (_Bool)0;
                    if(tmp_if_expr_40)
                    {

                    __CPROVER_DUMP_L38:
                      ;
                      lgl->stats->unhd.failed.trn = lgl->stats->unhd.failed.trn + 1;
                      lca=lglunhlca(lgl, dfpr, -lit, -other);
                      lca=lglunhlca(lgl, dfpr, lca, -other2);
                      unit = -lca;
                      goto UNIT;
                    }

                    else
                    {
                      if(!(red == 0) || !(irronly == 0))
                      {
                        return_value_lglunhimplies2incl_31=lglunhimplies2incl(dfpr, -lit, other);
                        if(!(return_value_lglunhimplies2incl_31 == 0))
                          tmp_if_expr_33 = (_Bool)1;

                        else
                        {
                          return_value_lglunhimplies2incl_32=lglunhimplies2incl(dfpr, -lit, other2);
                          tmp_if_expr_33 = return_value_lglunhimplies2incl_32 != 0 ? (_Bool)1 : (_Bool)0;
                        }
                        tmp_if_expr_34 = tmp_if_expr_33 ? (_Bool)1 : (_Bool)0;
                      }

                      else
                        tmp_if_expr_34 = (_Bool)0;
                      if(tmp_if_expr_34)
                      {

                      __CPROVER_DUMP_L44:
                        ;
                        lgl->stats->unhd.tauts.trn = lgl->stats->unhd.tauts.trn + 1;
                        lgl->stats->prgss = lgl->stats->prgss + 1l;
                        if(!(red == 0))
                          lgl->stats->unhd.tauts.red = lgl->stats->unhd.tauts.red + 1;

                        ntrnred = ntrnred + 1;
                        lglrmtwch(lgl, other, lit, other2, red);
                        lglrmtwch(lgl, other2, lit, other, red);

                      __CPROVER_DUMP_L46:
                        ;
                        lgldeclscnt(lgl, 3, red, 0);
                        q = q - (signed long int)2;
                      }

                      else
                      {
                        return_value_lglunhimplies2incl_30=lglunhimplies2incl(dfpr, other2, lit);
                        if(!(return_value_lglunhimplies2incl_30 == 0))
                        {
                          do

                            TRNSTR:
                              ;
                          while((_Bool)0);
                          lgl->stats->unhd.str.trn = lgl->stats->unhd.str.trn + 1;
                          lgl->stats->prgss = lgl->stats->prgss + 1l;
                          if(!(red == 0))
                            lgl->stats->unhd.str.red = lgl->stats->unhd.str.red + 1;

                          ntrnstr = ntrnstr + 1;
                          lglrmtwch(lgl, other, lit, other2, red);
                          lglrmtwch(lgl, other2, lit, other, red);

                        __CPROVER_DUMP_L50:
                          ;
                          lgldeclscnt(lgl, 3, red, 0);
                          if(red == 0)
                            lglincirr(lgl, 2);

                          else
                            lgl->stats->red.bin = lgl->stats->red.bin + 1;
                          delta=lglwchbin(lgl, other, lit, red);
                          if(!(delta == 0l))
                          {
                            p = p + delta;
                            q = q + delta;
                            eow = eow + delta;
                            w = w + delta;
                          }

                          q = q - 1l;
                          q[(signed long int)-1] = red | BINCS | other << RMSHFT;
                          goto __CPROVER_DUMP_L74;
                        }

                        else
                        {
                          return_value_lglunhimplies2incl_29=lglunhimplies2incl(dfpr, other, lit);
                          if(!(return_value_lglunhimplies2incl_29 == 0))
                          {
                            do
                            {
                              signed int TMP = other;
                              other = other2;
                              other2 = TMP;
                            }
                            while((_Bool)0);
                            goto TRNSTR;
                          }

                          else
                            if(!(lgl->opts->unhdhbr.val == 0))
                            {
                              root=lglunhroot(dfpr, -lit);
                              if(!(root == 0))
                              {
                                return_value_lglval_28=lglval(lgl, root);
                                if(return_value_lglval_28 == 0)
                                {
                                  signed int return_value_lglunhroot_20;
                                  return_value_lglunhroot_20=lglunhroot(dfpr, -other2);
                                  if(root == return_value_lglunhroot_20)
                                    lca=lglunhlca(lgl, dfpr, -lit, -other2);

                                  else
                                  {
                                    return_value_lglunhroot_19=lglunhroot(dfpr, -other);
                                    if(root == return_value_lglunhroot_19)
                                    {
                                      lca=lglunhlca(lgl, dfpr, -lit, -other);
                                      do
                                      {
                                        signed int lglunhidebintrn__1__1__1__1__1__1__1__2__6__2__1__TMP = other;
                                        other = other2;
                                        other2 = lglunhidebintrn__1__1__1__1__1__1__1__2__6__2__1__TMP;
                                      }
                                      while((_Bool)0);
                                    }

                                    else
                                    {
                                      return_value_lglunhimplies2incl_18=lglunhimplies2incl(dfpr, root, -other2);
                                      if(!(return_value_lglunhimplies2incl_18 == 0))
                                        lca = root;

                                      else
                                      {
                                        return_value_lglunhimplies2incl_17=lglunhimplies2incl(dfpr, root, -other);
                                        if(!(return_value_lglunhimplies2incl_17 == 0))
                                        {
                                          lca = root;
                                          do
                                          {
                                            signed int lglunhidebintrn__1__1__1__1__1__1__1__2__6__3__1__TMP = other;
                                            other = other2;
                                            other2 = lglunhidebintrn__1__1__1__1__1__1__1__2__6__3__1__TMP;
                                          }
                                          while((_Bool)0);
                                        }

                                        else
                                          goto __CPROVER_DUMP_L74;
                                      }
                                    }
                                  }
                                  signed int return_value_abs_21;
                                  return_value_abs_21=abs(lca);
                                  signed int return_value_abs_22;
                                  return_value_abs_22=abs(lit);
                                  if(return_value_abs_21 == return_value_abs_22)
                                    goto __CPROVER_DUMP_L74;

                                  signed int return_value_abs_23;
                                  return_value_abs_23=abs(lca);
                                  signed int return_value_abs_24;
                                  return_value_abs_24=abs(other);
                                  if(return_value_abs_23 == return_value_abs_24)
                                    goto __CPROVER_DUMP_L74;

                                  signed int return_value_abs_25;
                                  return_value_abs_25=abs(lca);
                                  signed int return_value_abs_26;
                                  return_value_abs_26=abs(other2);
                                  if(return_value_abs_25 == return_value_abs_26)
                                    goto __CPROVER_DUMP_L74;

                                  signed int return_value_lglunhimplies2incl_27;
                                  return_value_lglunhimplies2incl_27=lglunhimplies2incl(dfpr, lca, other);
                                  if(!(return_value_lglunhimplies2incl_27 == 0))
                                    goto __CPROVER_DUMP_L74;


                                __CPROVER_DUMP_L67:
                                  ;
                                  lgl->stats->unhd.hbrs.trn = lgl->stats->unhd.hbrs.trn + 1;
                                  if(!(red == 0))
                                    lgl->stats->unhd.hbrs.red = lgl->stats->unhd.hbrs.red + 1;

                                  lgl->stats->prgss = lgl->stats->prgss + 1l;
                                  ntrnhbrs = ntrnhbrs + 1;

                                __CPROVER_DUMP_L69:
                                  ;
                                  lgl->stats->red.bin = lgl->stats->red.bin + 1;
                                  delta=lglwchbin(lgl, -lca, other, REDCS);
                                  if(!(delta == 0l))
                                  {
                                    p = p + delta;
                                    q = q + delta;
                                    eow = eow + delta;
                                    w = w + delta;
                                  }

                                  delta=lglwchbin(lgl, other, -lca, REDCS);
                                  if(!(delta == 0l))
                                  {
                                    p = p + delta;
                                    q = q + delta;
                                    eow = eow + delta;
                                    w = w + delta;
                                  }

                                }

                              }

                            }

                        }
                      }
                    }
                  }
                }
              }

            }


          __CPROVER_DUMP_L74:
            ;
          }
          lglshrinkhts(lgl, hts, (signed int)((signed long int)hts->count - (p - q)));
        }

      }

    }

  NEXTIDX:
    ;
  }
  if(!(nbinred == 0))

    __CPROVER_DUMP_L79:
      ;

  if(!(nbinunits == 0))

    __CPROVER_DUMP_L81:
      ;

  if(!(ntrnred == 0))

    __CPROVER_DUMP_L83:
      ;

  if(!(ntrnstr == 0))

    __CPROVER_DUMP_L85:
      ;

  if(!(ntrnunits == 0))

    __CPROVER_DUMP_L87:
      ;

  if(!(ntrnstr == 0))

    __CPROVER_DUMP_L89:
      ;

  return 1;
}

// lglunhidefailed
// file lglib.c line 15247
static signed int lglunhidefailed(struct LGL *lgl, const struct DFPR *dfpr)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int unit;
  signed int nfailed = 0;
  idx = 2;
  signed int return_value_lglunhimplincl_5;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      signed int return_value_lglterminate_1;
      return_value_lglterminate_1=lglterminate(lgl);
      if(!(return_value_lglterminate_1 == 0))
        return 0;

      signed int return_value_lglsyncunits_2;
      return_value_lglsyncunits_2=lglsyncunits(lgl);
      if(return_value_lglsyncunits_2 == 0)
        return 0;

      lgl->stats->unhd.steps = lgl->stats->unhd.steps + 1l;
      lit = sign * idx;
      signed char return_value_lglval_3;
      return_value_lglval_3=lglval(lgl, lit);
      if(return_value_lglval_3 == 0)
      {
        signed int return_value_lglulit_4;
        return_value_lglulit_4=lglulit(lit);
        if(!((dfpr + (signed long int)return_value_lglulit_4)->discovered == 0))
        {
          signed int return_value_lglunhimplincl_6;
          return_value_lglunhimplincl_6=lglunhimplincl(dfpr, lit, -lit);
          if(!(return_value_lglunhimplincl_6 == 0))
            unit = -lit;

          else
          {
            return_value_lglunhimplincl_5=lglunhimplincl(dfpr, -lit, lit);
            if(!(return_value_lglunhimplincl_5 == 0))
              unit = lit;

            else
              goto __CPROVER_DUMP_L13;
          }

        __CPROVER_DUMP_L7:
          ;

        __CPROVER_DUMP_L9:
          ;

        __CPROVER_DUMP_L11:
          ;
          lglunit(lgl, unit);
          lgl->stats->unhd.failed.lits = lgl->stats->unhd.failed.lits + 1;
          nfailed = nfailed + 1;
          signed int return_value_lglbcp_7;
          return_value_lglbcp_7=lglbcp(lgl);
          if(return_value_lglbcp_7 == 0)
          {

          __CPROVER_DUMP_L12:
            ;
            lgl->mt = 1;
            return 0;
          }

        }

      }


    __CPROVER_DUMP_L13:
      ;
    }
  }

__CPROVER_DUMP_L15:
  ;
  return 1;
}

// lglunhideglue
// file lglib.c line 15493
static signed int lglunhideglue(struct LGL *lgl, const struct DFPR *dfpr, signed int glue, signed int irronly)
{
  struct DFL *dfl;
  struct DFL *eodfl;
  struct DFL *d;
  struct DFL *e;
  signed int szdfl;
  signed int posdfl;
  signed int negdfl;
  signed int ndfl;
  signed int res;
  signed int oldsize;
  signed int newsize;
  signed int hastobesatisfied;
  signed int satisfied;
  signed int tautological;
  signed int watched;
  signed int lit;
  signed int ulit;
  signed int val;
  signed int sign;
  signed int nonfalse;
  signed int root;
  signed int lca;
  signed int unit;
  signed int ntaut = 0;
  signed int nstr = 0;
  signed int nunits = 0;
  signed int nhbrs = 0;
  signed int lidx;
  signed int *p;
  signed int *q;
  signed int *c;
  signed int *eoc;
  signed int red;
  signed int lca1;
  signed int lca2;
  signed int root1;
  signed int root2;
  struct Stk *lglunhideglue__1__lits;
  if(!(glue >= 0))
  {
    lglunhideglue__1__lits = &lgl->irr;
    red = 0;
  }

  else
  {
    lglunhideglue__1__lits = lgl->red + (signed long int)glue;
    red = REDCS;
  }
  res = 1;
  dfl = ((struct DFL *)NULL);
  szdfl = 0;
  c = lglunhideglue__1__lits->start;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_4;
  signed int return_value_lglsyncunits_3;
  signed int *tmp_post_6;
  signed int *tmp_post_7;
  signed char return_value_lglval_10;
  _Bool tmp_if_expr_12;
  signed int return_value_lglunhroot_11;
  signed int return_value_lglcmpdfl_18;
  signed int return_value_lglmtstk_19;
  signed int return_value_lglcmpdfl_21;
  _Bool tmp_if_expr_22;
  _Bool tmp_if_expr_23;
  signed int return_value_lglcmpdfl_29;
  signed int return_value_lglmtstk_30;
  signed int return_value_lglcmpdfl_32;
  _Bool tmp_if_expr_33;
  signed int *tmp_post_34;
  signed int *tmp_post_35;
  signed int return_value_lglcmpdfl_41;
  signed int return_value_lglmtstk_42;
  signed int return_value_lglcmpdfl_44;
  _Bool tmp_if_expr_45;
  signed int *tmp_post_46;
  signed int *tmp_post_47;
  signed int return_value_lglunhimplies2incl_50;
  signed int tmp_if_expr_52;
  signed int return_value_lglunhlca_51;
  signed int tmp_if_expr_54;
  signed int return_value_lglunhlca_53;
  signed int return_value_lglunhimplies2incl_55;
  signed int *tmp_post_56;
  do
  {
    if(lgl->mt == 0)
      tmp_if_expr_1 = c < lglunhideglue__1__lits->top ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    signed int return_value_lglterminate_2;
    return_value_lglterminate_2=lglterminate(lgl);
    if(!(return_value_lglterminate_2 == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_lglsyncunits_3=lglsyncunits(lgl);
      tmp_if_expr_4 = !(return_value_lglsyncunits_3 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      res = 0;
      break;
    }

    eoc = c;
    lit = *eoc;
    if(!(lit >= 134217727))
    {
      lgl->stats->unhd.steps = lgl->stats->unhd.steps + 1l;
      lidx = (signed int)(c - lglunhideglue__1__lits->start);
      if(!(red == 0))
      {
        lidx = lidx << 4;
        lidx = lidx | glue;
      }

      watched = 1;
      for( ; !(*eoc == 0); eoc = eoc + 1l)
        ;
      oldsize = (signed int)(eoc - c);
      ndfl = 0;
      tautological = ndfl;
      satisfied = tautological;
      hastobesatisfied = satisfied;
      unit = hastobesatisfied;
      q = c;
      negdfl = 0;
      posdfl = negdfl;
      nonfalse = posdfl;
      p = c;
      for( ; !(p >= eoc); p = p + 1l)
      {
        lit = *p;
        signed char return_value_lglval_5;
        return_value_lglval_5=lglval(lgl, lit);
        val = (signed int)return_value_lglval_5;
        if(val >= 1)
        {
          satisfied = 1;
          q = c + (signed long int)2;
          break;
        }

        if(!(val >= 0))
        {
          if(!(p >= c + 2l))
          {
            tmp_post_6 = q;
            q = q + 1l;
            *tmp_post_6 = lit;
            hastobesatisfied = 1;
          }

        }

        else
        {
          tmp_post_7 = q;
          q = q + 1l;
          *tmp_post_7 = lit;
          nonfalse = nonfalse + 1;
          signed int return_value_lglulit_8;
          return_value_lglulit_8=lglulit(lit);
          if(!((dfpr + (signed long int)return_value_lglulit_8)->discovered == 0))
            posdfl = posdfl + 1;

          signed int return_value_lglulit_9;
          return_value_lglulit_9=lglulit(-lit);
          if(!((dfpr + (signed long int)return_value_lglulit_9)->discovered == 0))
            negdfl = negdfl + 1;

        }
      }
      eoc = q;
      *eoc = 0;
      ndfl = posdfl + negdfl;
      if(satisfied == 0 && ndfl >= 2)
      {
        if(nonfalse == negdfl)
        {
          root=lglunhroot(dfpr, -(*c));
          return_value_lglval_10=lglval(lgl, root);
          if(!(return_value_lglval_10 == 0))
            goto HTE;

          p = c + (signed long int)1;
          do
          {
            if(!(p >= eoc))
            {
              return_value_lglunhroot_11=lglunhroot(dfpr, -(*p));
              tmp_if_expr_12 = return_value_lglunhroot_11 == root ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_12 = (_Bool)0;
            if(!tmp_if_expr_12)
              break;

            p = p + 1l;
          }
          while((_Bool)1);
          if(!(p >= eoc))
            goto HTE;


        __CPROVER_DUMP_L25:
          ;

        __CPROVER_DUMP_L26:
          ;
          lca = -(*c);
          p = c + (signed long int)1;
          for( ; !(p >= eoc); p = p + 1l)
            lca=lglunhlca(lgl, dfpr, -(*p), lca);

        __CPROVER_DUMP_L28:
          ;
          lgl->stats->unhd.failed.lrg = lgl->stats->unhd.failed.lrg + 1;
          unit = -lca;
        }

        else
        {

        HTE:
          ;
          if(!(irronly == 0) || glue >= 0)
          {
            if(negdfl >= 2 && posdfl >= 2)
            {
              if(!(szdfl >= ndfl))
              {
                do
                {
                  void *return_value_lglrsz_13;
                  return_value_lglrsz_13=lglrsz(lgl, (void *)dfl, (unsigned long int)szdfl * sizeof(struct DFL) /*12ul*/ , (unsigned long int)ndfl * sizeof(struct DFL) /*12ul*/ );
                  dfl = (struct DFL *)return_value_lglrsz_13;
                }
                while((_Bool)0);
                szdfl = ndfl;
              }

              ndfl = 0;
              p = c;
              for( ; !(p >= eoc); p = p + 1l)
              {
                sign = -1;
                for( ; !(sign >= 2); sign = sign + 2)
                {
                  lit = *p;
                  ulit=lglulit(sign * lit);
                  if(!((dfpr + (signed long int)ulit)->discovered == 0))
                  {
                    (dfl + (signed long int)ndfl)->discovered = (dfpr + (signed long int)ulit)->discovered;
                    (dfl + (signed long int)ndfl)->finished = (dfpr + (signed long int)ulit)->finished;
                    (dfl + (signed long int)ndfl)->_anon0.sign = sign;
                    ndfl = ndfl + 1;
                  }

                }
              }
              lgl->stats->unhd.steps = lgl->stats->unhd.steps + (signed long int)6;
              do
              {
                struct DFL *AA = dfl;
                signed int NN = ndfl;
                do
                {
                  signed int L = 0;
                  signed int R = NN - 1;
                  signed int M;
                  signed int LL;
                  signed int RR;
                  signed int I;
                  if(!(R + -L >= 11))
                    break;

                  do
                  {
                    M = (L + R) / 2;
                    do
                    {
                      struct DFL TMP = AA[(signed long int)M];
                      AA[(signed long int)M] = AA[(signed long int)(R - 1)];
                      AA[(signed long int)(R - 1)] = TMP;
                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpdfl_14;
                      return_value_lglcmpdfl_14=lglcmpdfl(&AA[(signed long int)L], &AA[(signed long int)(R - 1)]);
                      if(return_value_lglcmpdfl_14 >= 1)
                        do
                        {
                          struct DFL lglunhideglue__1__3__1__11__1__1__1__2__1__TMP = AA[(signed long int)L];
                          AA[(signed long int)L] = AA[(signed long int)(R - 1)];
                          AA[(signed long int)(R - 1)] = lglunhideglue__1__3__1__11__1__1__1__2__1__TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpdfl_15;
                      return_value_lglcmpdfl_15=lglcmpdfl(&AA[(signed long int)L], &AA[(signed long int)R]);
                      if(return_value_lglcmpdfl_15 >= 1)
                        do
                        {
                          struct DFL lglunhideglue__1__3__1__11__1__1__1__3__1__TMP = AA[(signed long int)L];
                          AA[(signed long int)L] = AA[(signed long int)R];
                          AA[(signed long int)R] = lglunhideglue__1__3__1__11__1__1__1__3__1__TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpdfl_16;
                      return_value_lglcmpdfl_16=lglcmpdfl(&AA[(signed long int)(R - 1)], &AA[(signed long int)R]);
                      if(return_value_lglcmpdfl_16 >= 1)
                        do
                        {
                          struct DFL lglunhideglue__1__3__1__11__1__1__1__4__1__TMP = AA[(signed long int)(R - 1)];
                          AA[(signed long int)(R - 1)] = AA[(signed long int)R];
                          AA[(signed long int)R] = lglunhideglue__1__3__1__11__1__1__1__4__1__TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      struct DFL PIVOT;
                      signed int J = R - 1;
                      I = (L + 1) - 1;
                      PIVOT = AA[(signed long int)J];
                      do
                      {

                      __CPROVER_DUMP_L51:
                        ;
                        I = I + 1;
                        signed int return_value_lglcmpdfl_17;
                        return_value_lglcmpdfl_17=lglcmpdfl(&AA[(signed long int)I], &PIVOT);
                        if(!(return_value_lglcmpdfl_17 >= 0))
                          goto __CPROVER_DUMP_L51;

                        do
                        {
                          J = J - 1;
                          return_value_lglcmpdfl_18=lglcmpdfl(&PIVOT, &AA[(signed long int)J]);
                          if(return_value_lglcmpdfl_18 >= 0)
                            break;

                          if(J == 1 + L)
                            break;

                        }
                        while((_Bool)1);
                        if(I >= J)
                          break;

                        do
                        {
                          struct DFL lglunhideglue__1__3__1__11__1__1__1__5__1__1__1__TMP = AA[(signed long int)I];
                          AA[(signed long int)I] = AA[(signed long int)J];
                          AA[(signed long int)J] = lglunhideglue__1__3__1__11__1__1__1__5__1__1__1__TMP;
                        }
                        while((_Bool)0);
                      }
                      while((_Bool)1);
                      do
                      {
                        struct DFL lglunhideglue__1__3__1__11__1__1__1__5__2__TMP = AA[(signed long int)I];
                        AA[(signed long int)I] = AA[(signed long int)(R - 1)];
                        AA[(signed long int)(R - 1)] = lglunhideglue__1__3__1__11__1__1__1__5__2__TMP;
                      }
                      while((_Bool)0);
                    }
                    while((_Bool)0);
                    if(!(I + -L >= R + -I))
                    {
                      LL = I + 1;
                      RR = R;
                      R = I - 1;
                    }

                    else
                    {
                      LL = L;
                      RR = I - 1;
                      L = I + 1;
                    }
                    if(R + -L >= 11)
                    {
                      lglpushstk(lgl, &lgl->_anon1.sortstk, LL);
                      lglpushstk(lgl, &lgl->_anon1.sortstk, RR);
                    }

                    else
                      if(RR + -LL >= 11)
                      {
                        L = LL;
                        R = RR;
                      }

                      else
                      {
                        return_value_lglmtstk_19=lglmtstk(&lgl->_anon1.sortstk);
                        if(return_value_lglmtstk_19 == 0)
                        {
                          R=lglpopstk(&lgl->_anon1.sortstk);
                          L=lglpopstk(&lgl->_anon1.sortstk);
                        }

                        else
                          break;
                      }
                  }
                  while((_Bool)1);
                }
                while((_Bool)0);
                do
                {
                  struct DFL lglunhideglue__1__3__1__11__2__PIVOT;
                  signed int lglunhideglue__1__3__1__11__2__L = 0;
                  signed int lglunhideglue__1__3__1__11__2__R = NN - 1;
                  signed int lglunhideglue__1__3__1__11__2__I;
                  signed int lglunhideglue__1__3__1__11__2__J;
                  lglunhideglue__1__3__1__11__2__I = lglunhideglue__1__3__1__11__2__R;
                  for( ; !(lglunhideglue__1__3__1__11__2__L >= lglunhideglue__1__3__1__11__2__I); lglunhideglue__1__3__1__11__2__I = lglunhideglue__1__3__1__11__2__I - 1)
                    do
                    {
                      signed int return_value_lglcmpdfl_20;
                      return_value_lglcmpdfl_20=lglcmpdfl(&AA[(signed long int)(lglunhideglue__1__3__1__11__2__I - 1)], &AA[(signed long int)lglunhideglue__1__3__1__11__2__I]);
                      if(return_value_lglcmpdfl_20 >= 1)
                        do
                        {
                          struct DFL lglunhideglue__1__3__1__11__2__1__1__1__TMP = AA[(signed long int)(lglunhideglue__1__3__1__11__2__I - 1)];
                          AA[(signed long int)(lglunhideglue__1__3__1__11__2__I - 1)] = AA[(signed long int)lglunhideglue__1__3__1__11__2__I];
                          AA[(signed long int)lglunhideglue__1__3__1__11__2__I] = lglunhideglue__1__3__1__11__2__1__1__1__TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                  lglunhideglue__1__3__1__11__2__I = lglunhideglue__1__3__1__11__2__L + 2;
                  for( ; lglunhideglue__1__3__1__11__2__R >= lglunhideglue__1__3__1__11__2__I; lglunhideglue__1__3__1__11__2__I = lglunhideglue__1__3__1__11__2__I + 1)
                  {
                    lglunhideglue__1__3__1__11__2__J = lglunhideglue__1__3__1__11__2__I;
                    lglunhideglue__1__3__1__11__2__PIVOT = AA[(signed long int)lglunhideglue__1__3__1__11__2__I];
                    do
                    {
                      return_value_lglcmpdfl_21=lglcmpdfl(&lglunhideglue__1__3__1__11__2__PIVOT, &AA[(signed long int)(lglunhideglue__1__3__1__11__2__J - 1)]);
                      if(return_value_lglcmpdfl_21 >= 0)
                        break;

                      AA[(signed long int)lglunhideglue__1__3__1__11__2__J] = AA[(signed long int)(lglunhideglue__1__3__1__11__2__J - 1)];
                      lglunhideglue__1__3__1__11__2__J = lglunhideglue__1__3__1__11__2__J - 1;
                    }
                    while((_Bool)1);
                    AA[(signed long int)lglunhideglue__1__3__1__11__2__J] = lglunhideglue__1__3__1__11__2__PIVOT;
                  }
                }
                while((_Bool)0);

              __CPROVER_DUMP_L73:
                ;
              }
              while((_Bool)0);
              eodfl = dfl + (signed long int)ndfl;
              d = dfl;
              for( ; !(d >= eodfl + -1l); d = d + 1l)
                if(!(d->_anon0.sign >= 0))
                  break;

              while(!(d >= eodfl + -1l))
              {
                e = d + (signed long int)1;
                do
                {
                  if(!(e >= eodfl))
                    tmp_if_expr_22 = e->finished < d->finished ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_22 = (_Bool)0;
                  if(!tmp_if_expr_22)
                    break;

                  if(e->_anon0.sign >= 0)
                  {

                  __CPROVER_DUMP_L79:
                    ;
                    ntaut = ntaut + 1;
                    lgl->stats->unhd.tauts.lrg = lgl->stats->unhd.tauts.lrg + 1;
                    if(!(red == 0))
                      lgl->stats->unhd.tauts.red = lgl->stats->unhd.tauts.red + 1;

                    lgl->stats->prgss = lgl->stats->prgss + 1l;
                    tautological = 1;
                    goto NEXT;
                  }

                  e = e + 1l;
                }
                while((_Bool)1);
                d = e;
                do
                {
                  if(!(d >= eodfl))
                    tmp_if_expr_23 = d->_anon0.sign > 0 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_23 = (_Bool)0;
                  if(!tmp_if_expr_23)
                    break;

                  d = d + 1l;
                }
                while((_Bool)1);
              }
            }

          }


        STRNEG:
          ;
          if(negdfl >= 2)
          {
            if(!(szdfl >= negdfl))
            {
              do
              {
                void *return_value_lglrsz_24;
                return_value_lglrsz_24=lglrsz(lgl, (void *)dfl, (unsigned long int)szdfl * sizeof(struct DFL) /*12ul*/ , (unsigned long int)negdfl * sizeof(struct DFL) /*12ul*/ );
                dfl = (struct DFL *)return_value_lglrsz_24;
              }
              while((_Bool)0);
              szdfl = negdfl;
            }

            lgl->stats->unhd.steps = lgl->stats->unhd.steps + 1l;
            ndfl = 0;
            p = c;
            for( ; !(p >= eoc); p = p + 1l)
            {
              lit = *p;
              ulit=lglulit(-lit);
              if(!((dfpr + (signed long int)ulit)->discovered == 0))
              {
                (dfl + (signed long int)ndfl)->discovered = (dfpr + (signed long int)ulit)->discovered;
                (dfl + (signed long int)ndfl)->finished = (dfpr + (signed long int)ulit)->finished;
                (dfl + (signed long int)ndfl)->_anon0.lit = lit;
                ndfl = ndfl + 1;
              }

            }
            if(ndfl >= 2)
            {
              lgl->stats->unhd.steps = lgl->stats->unhd.steps + (signed long int)3;
              do
              {
                struct DFL *lglunhideglue__1__3__1__16__AA = dfl;
                signed int lglunhideglue__1__3__1__16__NN = ndfl;
                do
                {
                  signed int lglunhideglue__1__3__1__16__1__L = 0;
                  signed int lglunhideglue__1__3__1__16__1__R = lglunhideglue__1__3__1__16__NN - 1;
                  signed int lglunhideglue__1__3__1__16__1__M;
                  signed int lglunhideglue__1__3__1__16__1__LL;
                  signed int lglunhideglue__1__3__1__16__1__RR;
                  signed int lglunhideglue__1__3__1__16__1__I;
                  if(!(lglunhideglue__1__3__1__16__1__R + -lglunhideglue__1__3__1__16__1__L >= 11))
                    break;

                  do
                  {
                    lglunhideglue__1__3__1__16__1__M = (lglunhideglue__1__3__1__16__1__L + lglunhideglue__1__3__1__16__1__R) / 2;
                    do
                    {
                      struct DFL lglunhideglue__1__3__1__16__1__1__1__1__TMP = lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__M];
                      lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__M] = lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__1__R - 1)];
                      lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__1__R - 1)] = lglunhideglue__1__3__1__16__1__1__1__1__TMP;
                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpdfl_25;
                      return_value_lglcmpdfl_25=lglcmpdfl(&lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__L], &lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__1__R - 1)]);
                      if(return_value_lglcmpdfl_25 >= 1)
                        do
                        {
                          struct DFL lglunhideglue__1__3__1__16__1__1__1__2__1__TMP = lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__L];
                          lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__L] = lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__1__R - 1)];
                          lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__1__R - 1)] = lglunhideglue__1__3__1__16__1__1__1__2__1__TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpdfl_26;
                      return_value_lglcmpdfl_26=lglcmpdfl(&lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__L], &lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__R]);
                      if(return_value_lglcmpdfl_26 >= 1)
                        do
                        {
                          struct DFL lglunhideglue__1__3__1__16__1__1__1__3__1__TMP = lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__L];
                          lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__L] = lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__R];
                          lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__R] = lglunhideglue__1__3__1__16__1__1__1__3__1__TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpdfl_27;
                      return_value_lglcmpdfl_27=lglcmpdfl(&lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__1__R - 1)], &lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__R]);
                      if(return_value_lglcmpdfl_27 >= 1)
                        do
                        {
                          struct DFL lglunhideglue__1__3__1__16__1__1__1__4__1__TMP = lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__1__R - 1)];
                          lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__1__R - 1)] = lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__R];
                          lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__R] = lglunhideglue__1__3__1__16__1__1__1__4__1__TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      struct DFL lglunhideglue__1__3__1__16__1__1__1__5__PIVOT;
                      signed int lglunhideglue__1__3__1__16__1__1__1__5__J = lglunhideglue__1__3__1__16__1__R - 1;
                      lglunhideglue__1__3__1__16__1__I = (lglunhideglue__1__3__1__16__1__L + 1) - 1;
                      lglunhideglue__1__3__1__16__1__1__1__5__PIVOT = lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__1__1__5__J];
                      do
                      {

                      __CPROVER_DUMP_L107:
                        ;
                        lglunhideglue__1__3__1__16__1__I = lglunhideglue__1__3__1__16__1__I + 1;
                        signed int return_value_lglcmpdfl_28;
                        return_value_lglcmpdfl_28=lglcmpdfl(&lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__I], &lglunhideglue__1__3__1__16__1__1__1__5__PIVOT);
                        if(!(return_value_lglcmpdfl_28 >= 0))
                          goto __CPROVER_DUMP_L107;

                        do
                        {
                          lglunhideglue__1__3__1__16__1__1__1__5__J = lglunhideglue__1__3__1__16__1__1__1__5__J - 1;
                          return_value_lglcmpdfl_29=lglcmpdfl(&lglunhideglue__1__3__1__16__1__1__1__5__PIVOT, &lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__1__1__5__J]);
                          if(return_value_lglcmpdfl_29 >= 0)
                            break;

                          if(lglunhideglue__1__3__1__16__1__1__1__5__J == 1 + lglunhideglue__1__3__1__16__1__L)
                            break;

                        }
                        while((_Bool)1);
                        if(lglunhideglue__1__3__1__16__1__I >= lglunhideglue__1__3__1__16__1__1__1__5__J)
                          break;

                        do
                        {
                          struct DFL lglunhideglue__1__3__1__16__1__1__1__5__1__1__1__TMP = lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__I];
                          lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__I] = lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__1__1__5__J];
                          lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__1__1__5__J] = lglunhideglue__1__3__1__16__1__1__1__5__1__1__1__TMP;
                        }
                        while((_Bool)0);
                      }
                      while((_Bool)1);
                      do
                      {
                        struct DFL lglunhideglue__1__3__1__16__1__1__1__5__2__TMP = lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__I];
                        lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__1__I] = lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__1__R - 1)];
                        lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__1__R - 1)] = lglunhideglue__1__3__1__16__1__1__1__5__2__TMP;
                      }
                      while((_Bool)0);
                    }
                    while((_Bool)0);
                    if(!(lglunhideglue__1__3__1__16__1__I + -lglunhideglue__1__3__1__16__1__L >= lglunhideglue__1__3__1__16__1__R + -lglunhideglue__1__3__1__16__1__I))
                    {
                      lglunhideglue__1__3__1__16__1__LL = lglunhideglue__1__3__1__16__1__I + 1;
                      lglunhideglue__1__3__1__16__1__RR = lglunhideglue__1__3__1__16__1__R;
                      lglunhideglue__1__3__1__16__1__R = lglunhideglue__1__3__1__16__1__I - 1;
                    }

                    else
                    {
                      lglunhideglue__1__3__1__16__1__LL = lglunhideglue__1__3__1__16__1__L;
                      lglunhideglue__1__3__1__16__1__RR = lglunhideglue__1__3__1__16__1__I - 1;
                      lglunhideglue__1__3__1__16__1__L = lglunhideglue__1__3__1__16__1__I + 1;
                    }
                    if(lglunhideglue__1__3__1__16__1__R + -lglunhideglue__1__3__1__16__1__L >= 11)
                    {
                      lglpushstk(lgl, &lgl->_anon1.sortstk, lglunhideglue__1__3__1__16__1__LL);
                      lglpushstk(lgl, &lgl->_anon1.sortstk, lglunhideglue__1__3__1__16__1__RR);
                    }

                    else
                      if(lglunhideglue__1__3__1__16__1__RR + -lglunhideglue__1__3__1__16__1__LL >= 11)
                      {
                        lglunhideglue__1__3__1__16__1__L = lglunhideglue__1__3__1__16__1__LL;
                        lglunhideglue__1__3__1__16__1__R = lglunhideglue__1__3__1__16__1__RR;
                      }

                      else
                      {
                        return_value_lglmtstk_30=lglmtstk(&lgl->_anon1.sortstk);
                        if(return_value_lglmtstk_30 == 0)
                        {
                          lglunhideglue__1__3__1__16__1__R=lglpopstk(&lgl->_anon1.sortstk);
                          lglunhideglue__1__3__1__16__1__L=lglpopstk(&lgl->_anon1.sortstk);
                        }

                        else
                          break;
                      }
                  }
                  while((_Bool)1);
                }
                while((_Bool)0);
                do
                {
                  struct DFL lglunhideglue__1__3__1__16__2__PIVOT;
                  signed int lglunhideglue__1__3__1__16__2__L = 0;
                  signed int lglunhideglue__1__3__1__16__2__R = lglunhideglue__1__3__1__16__NN - 1;
                  signed int lglunhideglue__1__3__1__16__2__I;
                  signed int lglunhideglue__1__3__1__16__2__J;
                  lglunhideglue__1__3__1__16__2__I = lglunhideglue__1__3__1__16__2__R;
                  for( ; !(lglunhideglue__1__3__1__16__2__L >= lglunhideglue__1__3__1__16__2__I); lglunhideglue__1__3__1__16__2__I = lglunhideglue__1__3__1__16__2__I - 1)
                    do
                    {
                      signed int return_value_lglcmpdfl_31;
                      return_value_lglcmpdfl_31=lglcmpdfl(&lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__2__I - 1)], &lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__2__I]);
                      if(return_value_lglcmpdfl_31 >= 1)
                        do
                        {
                          struct DFL lglunhideglue__1__3__1__16__2__1__1__1__TMP = lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__2__I - 1)];
                          lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__2__I - 1)] = lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__2__I];
                          lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__2__I] = lglunhideglue__1__3__1__16__2__1__1__1__TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                  lglunhideglue__1__3__1__16__2__I = lglunhideglue__1__3__1__16__2__L + 2;
                  for( ; lglunhideglue__1__3__1__16__2__R >= lglunhideglue__1__3__1__16__2__I; lglunhideglue__1__3__1__16__2__I = lglunhideglue__1__3__1__16__2__I + 1)
                  {
                    lglunhideglue__1__3__1__16__2__J = lglunhideglue__1__3__1__16__2__I;
                    lglunhideglue__1__3__1__16__2__PIVOT = lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__2__I];
                    do
                    {
                      return_value_lglcmpdfl_32=lglcmpdfl(&lglunhideglue__1__3__1__16__2__PIVOT, &lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__2__J - 1)]);
                      if(return_value_lglcmpdfl_32 >= 0)
                        break;

                      lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__2__J] = lglunhideglue__1__3__1__16__AA[(signed long int)(lglunhideglue__1__3__1__16__2__J - 1)];
                      lglunhideglue__1__3__1__16__2__J = lglunhideglue__1__3__1__16__2__J - 1;
                    }
                    while((_Bool)1);
                    lglunhideglue__1__3__1__16__AA[(signed long int)lglunhideglue__1__3__1__16__2__J] = lglunhideglue__1__3__1__16__2__PIVOT;
                  }
                }
                while((_Bool)0);

              __CPROVER_DUMP_L129:
                ;
              }
              while((_Bool)0);
              eodfl = dfl + (signed long int)ndfl;
              d = dfl;
              for( ; !(d >= eodfl + -1l); d = e)
              {
                e = d + (signed long int)1;
                do
                {
                  if(!(e >= eodfl))
                    tmp_if_expr_33 = d->finished >= e->finished ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_33 = (_Bool)0;
                  if(!tmp_if_expr_33)
                    break;

                  lit = e->_anon0.lit;

                __CPROVER_DUMP_L134:
                  ;
                  e->_anon0.lit = 0;
                  nstr = nstr + 1;
                  lgl->stats->unhd.str.lrg = lgl->stats->unhd.str.lrg + 1;
                  if(!(red == 0))
                    lgl->stats->unhd.str.red = lgl->stats->unhd.str.red + 1;

                  lgl->stats->prgss = lgl->stats->prgss + 1l;
                  if(!(watched == 0))
                  {
                    if(!(lit == *c))
                    {
                      if(!(lit == c[1l]))
                        goto __CPROVER_DUMP_L137;

                    }

                    lglrmlwch(lgl, c[(signed long int)0], red, lidx);
                    lglrmlwch(lgl, c[(signed long int)1], red, lidx);
                    watched = 0;
                  }


                __CPROVER_DUMP_L137:
                  ;
                  e = e + 1l;
                }
                while((_Bool)1);
              }
              q = c;
              if(!(watched == 0))
                q = q + (signed long int)2;

              p = q;
              for( ; !(p >= eoc); p = p + 1l)
              {
                lit = *p;
                ulit=lglulit(-lit);
                if((dfpr + (signed long int)ulit)->discovered == 0)
                {
                  tmp_post_34 = q;
                  q = q + 1l;
                  *tmp_post_34 = lit;
                }

              }
              d = dfl;
              for( ; !(d >= eodfl); d = d + 1l)
              {
                lit = d->_anon0.lit;
                if(!(lit == 0))
                {
                  if(!(watched == 0))
                  {
                    if(lit == *c)
                      goto __CPROVER_DUMP_L147;

                  }

                  if(!(watched == 0))
                  {
                    if(lit == c[1l])
                      goto __CPROVER_DUMP_L147;

                  }

                  tmp_post_35 = q;
                  q = q + 1l;
                  *tmp_post_35 = lit;
                }


              __CPROVER_DUMP_L147:
                ;
              }
              eoc = q;
              *eoc = 0;
            }

          }


        STRPOS:
          ;
          if(posdfl >= 2)
          {
            if(!(szdfl >= posdfl))
            {
              do
              {
                void *return_value_lglrsz_36;
                return_value_lglrsz_36=lglrsz(lgl, (void *)dfl, (unsigned long int)szdfl * sizeof(struct DFL) /*12ul*/ , (unsigned long int)posdfl * sizeof(struct DFL) /*12ul*/ );
                dfl = (struct DFL *)return_value_lglrsz_36;
              }
              while((_Bool)0);
              szdfl = posdfl;
            }

            ndfl = 0;
            p = c;
            for( ; !(p >= eoc); p = p + 1l)
            {
              lit = *p;
              ulit=lglulit(lit);
              if(!((dfpr + (signed long int)ulit)->discovered == 0))
              {
                (dfl + (signed long int)ndfl)->discovered = -(dfpr + (signed long int)ulit)->discovered;
                (dfl + (signed long int)ndfl)->finished = -(dfpr + (signed long int)ulit)->finished;
                (dfl + (signed long int)ndfl)->_anon0.lit = lit;
                ndfl = ndfl + 1;
              }

            }
            if(!(ndfl >= 2))
              goto NEXT;

            lgl->stats->unhd.steps = lgl->stats->unhd.steps + (signed long int)3;
            do
            {
              struct DFL *lglunhideglue__1__3__1__22__AA = dfl;
              signed int lglunhideglue__1__3__1__22__NN = ndfl;
              do
              {
                signed int lglunhideglue__1__3__1__22__1__L = 0;
                signed int lglunhideglue__1__3__1__22__1__R = lglunhideglue__1__3__1__22__NN - 1;
                signed int lglunhideglue__1__3__1__22__1__M;
                signed int lglunhideglue__1__3__1__22__1__LL;
                signed int lglunhideglue__1__3__1__22__1__RR;
                signed int lglunhideglue__1__3__1__22__1__I;
                if(!(lglunhideglue__1__3__1__22__1__R + -lglunhideglue__1__3__1__22__1__L >= 11))
                  break;

                do
                {
                  lglunhideglue__1__3__1__22__1__M = (lglunhideglue__1__3__1__22__1__L + lglunhideglue__1__3__1__22__1__R) / 2;
                  do
                  {
                    struct DFL lglunhideglue__1__3__1__22__1__1__1__1__TMP = lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__M];
                    lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__M] = lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__1__R - 1)];
                    lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__1__R - 1)] = lglunhideglue__1__3__1__22__1__1__1__1__TMP;
                  }
                  while((_Bool)0);
                  do
                  {
                    signed int return_value_lglcmpdfl_37;
                    return_value_lglcmpdfl_37=lglcmpdfl(&lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__L], &lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__1__R - 1)]);
                    if(return_value_lglcmpdfl_37 >= 1)
                      do
                      {
                        struct DFL lglunhideglue__1__3__1__22__1__1__1__2__1__TMP = lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__L];
                        lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__L] = lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__1__R - 1)];
                        lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__1__R - 1)] = lglunhideglue__1__3__1__22__1__1__1__2__1__TMP;
                      }
                      while((_Bool)0);

                  }
                  while((_Bool)0);
                  do
                  {
                    signed int return_value_lglcmpdfl_38;
                    return_value_lglcmpdfl_38=lglcmpdfl(&lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__L], &lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__R]);
                    if(return_value_lglcmpdfl_38 >= 1)
                      do
                      {
                        struct DFL lglunhideglue__1__3__1__22__1__1__1__3__1__TMP = lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__L];
                        lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__L] = lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__R];
                        lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__R] = lglunhideglue__1__3__1__22__1__1__1__3__1__TMP;
                      }
                      while((_Bool)0);

                  }
                  while((_Bool)0);
                  do
                  {
                    signed int return_value_lglcmpdfl_39;
                    return_value_lglcmpdfl_39=lglcmpdfl(&lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__1__R - 1)], &lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__R]);
                    if(return_value_lglcmpdfl_39 >= 1)
                      do
                      {
                        struct DFL lglunhideglue__1__3__1__22__1__1__1__4__1__TMP = lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__1__R - 1)];
                        lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__1__R - 1)] = lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__R];
                        lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__R] = lglunhideglue__1__3__1__22__1__1__1__4__1__TMP;
                      }
                      while((_Bool)0);

                  }
                  while((_Bool)0);
                  do
                  {
                    struct DFL lglunhideglue__1__3__1__22__1__1__1__5__PIVOT;
                    signed int lglunhideglue__1__3__1__22__1__1__1__5__J = lglunhideglue__1__3__1__22__1__R - 1;
                    lglunhideglue__1__3__1__22__1__I = (lglunhideglue__1__3__1__22__1__L + 1) - 1;
                    lglunhideglue__1__3__1__22__1__1__1__5__PIVOT = lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__1__1__5__J];
                    do
                    {

                    __CPROVER_DUMP_L169:
                      ;
                      lglunhideglue__1__3__1__22__1__I = lglunhideglue__1__3__1__22__1__I + 1;
                      signed int return_value_lglcmpdfl_40;
                      return_value_lglcmpdfl_40=lglcmpdfl(&lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__I], &lglunhideglue__1__3__1__22__1__1__1__5__PIVOT);
                      if(!(return_value_lglcmpdfl_40 >= 0))
                        goto __CPROVER_DUMP_L169;

                      do
                      {
                        lglunhideglue__1__3__1__22__1__1__1__5__J = lglunhideglue__1__3__1__22__1__1__1__5__J - 1;
                        return_value_lglcmpdfl_41=lglcmpdfl(&lglunhideglue__1__3__1__22__1__1__1__5__PIVOT, &lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__1__1__5__J]);
                        if(return_value_lglcmpdfl_41 >= 0)
                          break;

                        if(lglunhideglue__1__3__1__22__1__1__1__5__J == 1 + lglunhideglue__1__3__1__22__1__L)
                          break;

                      }
                      while((_Bool)1);
                      if(lglunhideglue__1__3__1__22__1__I >= lglunhideglue__1__3__1__22__1__1__1__5__J)
                        break;

                      do
                      {
                        struct DFL lglunhideglue__1__3__1__22__1__1__1__5__1__1__1__TMP = lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__I];
                        lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__I] = lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__1__1__5__J];
                        lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__1__1__5__J] = lglunhideglue__1__3__1__22__1__1__1__5__1__1__1__TMP;
                      }
                      while((_Bool)0);
                    }
                    while((_Bool)1);
                    do
                    {
                      struct DFL lglunhideglue__1__3__1__22__1__1__1__5__2__TMP = lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__I];
                      lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__1__I] = lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__1__R - 1)];
                      lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__1__R - 1)] = lglunhideglue__1__3__1__22__1__1__1__5__2__TMP;
                    }
                    while((_Bool)0);
                  }
                  while((_Bool)0);
                  if(!(lglunhideglue__1__3__1__22__1__I + -lglunhideglue__1__3__1__22__1__L >= lglunhideglue__1__3__1__22__1__R + -lglunhideglue__1__3__1__22__1__I))
                  {
                    lglunhideglue__1__3__1__22__1__LL = lglunhideglue__1__3__1__22__1__I + 1;
                    lglunhideglue__1__3__1__22__1__RR = lglunhideglue__1__3__1__22__1__R;
                    lglunhideglue__1__3__1__22__1__R = lglunhideglue__1__3__1__22__1__I - 1;
                  }

                  else
                  {
                    lglunhideglue__1__3__1__22__1__LL = lglunhideglue__1__3__1__22__1__L;
                    lglunhideglue__1__3__1__22__1__RR = lglunhideglue__1__3__1__22__1__I - 1;
                    lglunhideglue__1__3__1__22__1__L = lglunhideglue__1__3__1__22__1__I + 1;
                  }
                  if(lglunhideglue__1__3__1__22__1__R + -lglunhideglue__1__3__1__22__1__L >= 11)
                  {
                    lglpushstk(lgl, &lgl->_anon1.sortstk, lglunhideglue__1__3__1__22__1__LL);
                    lglpushstk(lgl, &lgl->_anon1.sortstk, lglunhideglue__1__3__1__22__1__RR);
                  }

                  else
                    if(lglunhideglue__1__3__1__22__1__RR + -lglunhideglue__1__3__1__22__1__LL >= 11)
                    {
                      lglunhideglue__1__3__1__22__1__L = lglunhideglue__1__3__1__22__1__LL;
                      lglunhideglue__1__3__1__22__1__R = lglunhideglue__1__3__1__22__1__RR;
                    }

                    else
                    {
                      return_value_lglmtstk_42=lglmtstk(&lgl->_anon1.sortstk);
                      if(return_value_lglmtstk_42 == 0)
                      {
                        lglunhideglue__1__3__1__22__1__R=lglpopstk(&lgl->_anon1.sortstk);
                        lglunhideglue__1__3__1__22__1__L=lglpopstk(&lgl->_anon1.sortstk);
                      }

                      else
                        break;
                    }
                }
                while((_Bool)1);
              }
              while((_Bool)0);
              do
              {
                struct DFL lglunhideglue__1__3__1__22__2__PIVOT;
                signed int lglunhideglue__1__3__1__22__2__L = 0;
                signed int lglunhideglue__1__3__1__22__2__R = lglunhideglue__1__3__1__22__NN - 1;
                signed int lglunhideglue__1__3__1__22__2__I;
                signed int lglunhideglue__1__3__1__22__2__J;
                lglunhideglue__1__3__1__22__2__I = lglunhideglue__1__3__1__22__2__R;
                for( ; !(lglunhideglue__1__3__1__22__2__L >= lglunhideglue__1__3__1__22__2__I); lglunhideglue__1__3__1__22__2__I = lglunhideglue__1__3__1__22__2__I - 1)
                  do
                  {
                    signed int return_value_lglcmpdfl_43;
                    return_value_lglcmpdfl_43=lglcmpdfl(&lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__2__I - 1)], &lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__2__I]);
                    if(return_value_lglcmpdfl_43 >= 1)
                      do
                      {
                        struct DFL lglunhideglue__1__3__1__22__2__1__1__1__TMP = lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__2__I - 1)];
                        lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__2__I - 1)] = lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__2__I];
                        lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__2__I] = lglunhideglue__1__3__1__22__2__1__1__1__TMP;
                      }
                      while((_Bool)0);

                  }
                  while((_Bool)0);
                lglunhideglue__1__3__1__22__2__I = lglunhideglue__1__3__1__22__2__L + 2;
                for( ; lglunhideglue__1__3__1__22__2__R >= lglunhideglue__1__3__1__22__2__I; lglunhideglue__1__3__1__22__2__I = lglunhideglue__1__3__1__22__2__I + 1)
                {
                  lglunhideglue__1__3__1__22__2__J = lglunhideglue__1__3__1__22__2__I;
                  lglunhideglue__1__3__1__22__2__PIVOT = lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__2__I];
                  do
                  {
                    return_value_lglcmpdfl_44=lglcmpdfl(&lglunhideglue__1__3__1__22__2__PIVOT, &lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__2__J - 1)]);
                    if(return_value_lglcmpdfl_44 >= 0)
                      break;

                    lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__2__J] = lglunhideglue__1__3__1__22__AA[(signed long int)(lglunhideglue__1__3__1__22__2__J - 1)];
                    lglunhideglue__1__3__1__22__2__J = lglunhideglue__1__3__1__22__2__J - 1;
                  }
                  while((_Bool)1);
                  lglunhideglue__1__3__1__22__AA[(signed long int)lglunhideglue__1__3__1__22__2__J] = lglunhideglue__1__3__1__22__2__PIVOT;
                }
              }
              while((_Bool)0);

            __CPROVER_DUMP_L191:
              ;
            }
            while((_Bool)0);
            eodfl = dfl + (signed long int)ndfl;
            d = dfl;
            for( ; !(d >= eodfl + -1l); d = e)
            {
              e = d + (signed long int)1;
              do
              {
                if(!(e >= eodfl))
                  tmp_if_expr_45 = d->finished >= e->finished ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_45 = (_Bool)0;
                if(!tmp_if_expr_45)
                  break;

                lit = e->_anon0.lit;

              __CPROVER_DUMP_L196:
                ;
                e->_anon0.lit = 0;
                nstr = nstr + 1;
                lgl->stats->unhd.str.lrg = lgl->stats->unhd.str.lrg + 1;
                if(!(red == 0))
                  lgl->stats->unhd.str.red = lgl->stats->unhd.str.red + 1;

                lgl->stats->prgss = lgl->stats->prgss + 1l;
                if(!(watched == 0))
                {
                  if(!(lit == *c))
                  {
                    if(!(lit == c[1l]))
                      goto __CPROVER_DUMP_L199;

                  }

                  lglrmlwch(lgl, c[(signed long int)0], red, lidx);
                  lglrmlwch(lgl, c[(signed long int)1], red, lidx);
                  watched = 0;
                }


              __CPROVER_DUMP_L199:
                ;
                e = e + 1l;
              }
              while((_Bool)1);
            }
            q = c;
            if(!(watched == 0))
              q = q + (signed long int)2;

            p = q;
            for( ; !(p >= eoc); p = p + 1l)
            {
              lit = *p;
              ulit=lglulit(lit);
              if((dfpr + (signed long int)ulit)->discovered == 0)
              {
                tmp_post_46 = q;
                q = q + 1l;
                *tmp_post_46 = lit;
              }

            }
            d = dfl;
            for( ; !(d >= eodfl); d = d + 1l)
            {
              lit = d->_anon0.lit;
              if(!(lit == 0))
              {
                if(!(watched == 0))
                {
                  if(lit == *c)
                    goto __CPROVER_DUMP_L209;

                }

                if(!(watched == 0))
                {
                  if(lit == c[1l])
                    goto __CPROVER_DUMP_L209;

                }

                tmp_post_47 = q;
                q = q + 1l;
                *tmp_post_47 = lit;
              }


            __CPROVER_DUMP_L209:
              ;
            }
            eoc = q;
            *eoc = 0;
          }


        HBR:
          ;
          if(!(lgl->opts->unhdhbr.val == 0))
          {
            if(eoc - c >= 3l)
            {
              lca2 = 0;
              lca1 = lca2;
              root2 = lca1;
              root1 = root2;
              p = c;
              do
              {
                lit = *p;
                if(lit == 0)
                  break;

                root=lglunhroot(dfpr, -lit);
                if(root == 0)
                  root = -lit;

                if(root1 == 0)
                  root1 = root;

                else
                  if(!(root1 == root))
                  {
                    if(root2 == 0)
                      root2 = root;

                    else
                      if(!(root2 == root))
                      {
                        signed int return_value_lglunhimplies2incl_48;
                        return_value_lglunhimplies2incl_48=lglunhimplies2incl(dfpr, root1, -lit);
                        if(!(return_value_lglunhimplies2incl_48 == 0))
                          lca1 = root1;

                        else
                        {
                          signed int return_value_lglunhimplies2incl_49;
                          return_value_lglunhimplies2incl_49=lglunhimplies2incl(dfpr, root2, -lit);
                          if(!(return_value_lglunhimplies2incl_49 == 0))
                            lca2 = root2;

                          else
                            goto NEXT;
                        }
                      }

                  }

                p = p + 1l;
              }
              while((_Bool)1);
              if(!(root2 == 0))
              {
                if(!(root1 == -root2))
                {
                  return_value_lglunhimplies2incl_50=lglunhimplies2incl(dfpr, root1, -root2);
                  if(return_value_lglunhimplies2incl_50 == 0)
                  {

                  __CPROVER_DUMP_L220:
                    ;
                    if(lca1 == 0 && lca2 == 0)
                    {
                      p = c;
                      do
                      {
                        lit = *p;
                        if(lit == 0)
                          break;

                        root=lglunhroot(dfpr, -lit);
                        if(!(root == 0))
                        {
                          if(root == root1)
                          {
                            if(!(lca1 == 0))
                            {
                              return_value_lglunhlca_51=lglunhlca(lgl, dfpr, lca1, -lit);
                              tmp_if_expr_52 = return_value_lglunhlca_51;
                            }

                            else
                              tmp_if_expr_52 = -lit;
                            lca1 = tmp_if_expr_52;
                          }

                          if(root == root2)
                          {
                            if(!(lca2 == 0))
                            {
                              return_value_lglunhlca_53=lglunhlca(lgl, dfpr, lca2, -lit);
                              tmp_if_expr_54 = return_value_lglunhlca_53;
                            }

                            else
                              tmp_if_expr_54 = -lit;
                            lca2 = tmp_if_expr_54;
                          }

                        }

                        else
                          if(!(lca1 == 0))
                            lca2 = -lit;

                          else
                            lca1 = -lit;
                        p = p + 1l;
                      }
                      while((_Bool)1);
                    }

                    else
                    {
                      if(lca1 == 0)
                        lca1 = root1;

                      if(lca2 == 0)
                        lca2 = root2;

                    }
                    if(!(lca1 == -lca2))
                    {
                      return_value_lglunhimplies2incl_55=lglunhimplies2incl(dfpr, lca1, -lca2);
                      if(return_value_lglunhimplies2incl_55 == 0)
                      {

                      __CPROVER_DUMP_L235:
                        ;
                        lgl->stats->unhd.hbrs.lrg = lgl->stats->unhd.hbrs.lrg + 1;
                        if(!(red == 0))
                          lgl->stats->unhd.hbrs.red = lgl->stats->unhd.hbrs.red + 1;

                        lglwchbin(lgl, -lca1, -lca2, REDCS);
                        lglwchbin(lgl, -lca2, -lca1, REDCS);
                        lgl->stats->red.bin = lgl->stats->red.bin + 1;
                      }

                    }

                  }

                }

              }

            }

          }

        }
      }


    NEXT:
      ;
      newsize = (signed int)(eoc - c);
      if(!(satisfied == 0) || !(tautological == 0) || !(newsize >= 4))
      {
        lgldeclscnt(lgl, oldsize, red, glue);
        if(!(watched == 0))
        {
          lglrmlwch(lgl, c[(signed long int)0], red, lidx);
          lglrmlwch(lgl, c[(signed long int)1], red, lidx);
        }

      }

      else
        if(red == 0)
          lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur - (signed int)((c + (signed long int)oldsize) - eoc);

      p = c + (signed long int)oldsize;
      for( ; !(eoc >= p); p = p - 1l)
        *p = 0x7fffffff;
      if(!(satisfied == 0) || !(tautological == 0))
      {
        for( ; p >= c; *tmp_post_56 = 0x7fffffff)
        {
          tmp_post_56 = p;
          p = p - 1l;
        }
        if(!(red == 0))
        {

        __CPROVER_DUMP_L245:
          ;
          c[(signed long int)-1] = 0x7fffffff;
        }

        eoc = c + (signed long int)oldsize;
      }

      else
      {
        if(!(red == 0) && !(newsize >= 4))
        {

        __CPROVER_DUMP_L248:
          ;
          c[(signed long int)-1] = 0x7fffffff;
        }

        if(watched == 0 && newsize >= 4)
        {
          lglwchlrg(lgl, c[(signed long int)0], c[(signed long int)1], red, lidx);
          lglwchlrg(lgl, c[(signed long int)1], c[(signed long int)0], red, lidx);
        }

        else
          if(newsize == 3)
          {

          __CPROVER_DUMP_L251:
            ;
            lglwchtrn(lgl, c[(signed long int)0], c[(signed long int)1], c[(signed long int)2], red);
            lglwchtrn(lgl, c[(signed long int)1], c[(signed long int)0], c[(signed long int)2], red);
            lglwchtrn(lgl, c[(signed long int)2], c[(signed long int)0], c[(signed long int)1], red);
            if(red == 0)
              lglincirr(lgl, 3);

            else
              lgl->stats->red.trn = lgl->stats->red.trn + 1;
            *eoc = 0x7fffffff;
            c[(signed long int)2] = *eoc;
            c[(signed long int)1] = c[(signed long int)2];
            c[(signed long int)0] = c[(signed long int)1];
          }

          else
            if(newsize == 2)
            {

            __CPROVER_DUMP_L255:
              ;
              lglwchbin(lgl, c[(signed long int)0], c[(signed long int)1], red);
              lglwchbin(lgl, c[(signed long int)1], c[(signed long int)0], red);
              if(red == 0)
                lglincirr(lgl, 2);

              else
                lgl->stats->red.bin = lgl->stats->red.bin + 1;
              *eoc = 0x7fffffff;
              c[(signed long int)1] = *eoc;
              c[(signed long int)0] = c[(signed long int)1];
            }

            else
              if(newsize == 1)
              {

              __CPROVER_DUMP_L259:
                ;
                unit = c[(signed long int)0];
                *eoc = 0x7fffffff;
                c[(signed long int)0] = *eoc;
                lgl->stats->unhd.units.lrg = lgl->stats->unhd.units.lrg + 1;
                nunits = nunits + 1;
              }

        if(!(unit == 0))
        {
          lglunit(lgl, unit);
          signed int return_value_lglbcp_57;
          return_value_lglbcp_57=lglbcp(lgl);
          if(return_value_lglbcp_57 == 0)
          {
            lgl->mt = 1;

          __CPROVER_DUMP_L261:
            ;
            res = 0;
          }

        }

      }
    }

    c = eoc + (signed long int)1;
  }
  while((_Bool)1);
  if(!(nunits == 0))

    __CPROVER_DUMP_L264:
      ;

  if(!(ntaut == 0))

    __CPROVER_DUMP_L266:
      ;

  if(!(nstr == 0))

    __CPROVER_DUMP_L268:
      ;

  if(!(nhbrs == 0))

    __CPROVER_DUMP_L270:
      ;

  if(!(dfl == ((struct DFL *)NULL)))
    do
    {
      lgldel(lgl, (void *)dfl, (unsigned long int)szdfl * sizeof(struct DFL) /*12ul*/ );
      dfl = ((struct DFL *)NULL);
    }
    while((_Bool)0);

  return res;
}

// lglunhidelrg
// file lglib.c line 15913
static signed int lglunhidelrg(struct LGL *lgl, const struct DFPR *dfpr, signed int irronly)
{
  signed int glue;
  signed int res = 1;
  glue = -1;
  for( ; !(res == 0) && !(glue >= 15); glue = glue + 1)
    res=lglunhideglue(lgl, dfpr, glue, irronly);
  lglfixlrgwchs(lgl);
  return res;
}

// lglunhiding
// file lglib.c line 16951
static signed int lglunhiding(struct LGL *lgl)
{
  return lgl->opts->unhide.val;
}

// lglunhimpl
// file lglib.c line 10176
static signed int lglunhimpl(const struct DFPR *dfpr, signed int a, signed int b)
{
  signed int u;
  u=lglulit(a);
  signed int v;
  v=lglulit(b);
  signed int c;
  signed int d;
  signed int f;
  signed int g;
  c = (dfpr + (signed long int)u)->discovered;
  if(c == 0)
    return 0;

  else
  {
    d = (dfpr + (signed long int)v)->discovered;
    if(d == 0)
      return 0;

    else
    {
      f = (dfpr + (signed long int)u)->finished;
      g = (dfpr + (signed long int)v)->finished;
      return (signed int)(c < d && g < f);
    }
  }
}

// lglunhimplies2
// file lglib.c line 10186
static signed int lglunhimplies2(const struct DFPR *dfpr, signed int a, signed int b)
{
  signed int return_value_lglunhimpl_1;
  return_value_lglunhimpl_1=lglunhimpl(dfpr, a, b);
  _Bool tmp_if_expr_3;
  signed int return_value_lglunhimpl_2;
  if(!(return_value_lglunhimpl_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_lglunhimpl_2=lglunhimpl(dfpr, -b, -a);
    tmp_if_expr_3 = return_value_lglunhimpl_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr_3;
}

// lglunhimplies2incl
// file lglib.c line 10200
static signed int lglunhimplies2incl(const struct DFPR *dfpr, signed int a, signed int b)
{
  signed int return_value_lglunhimplincl_1;
  return_value_lglunhimplincl_1=lglunhimplincl(dfpr, a, b);
  _Bool tmp_if_expr_3;
  signed int return_value_lglunhimplincl_2;
  if(!(return_value_lglunhimplincl_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_lglunhimplincl_2=lglunhimplincl(dfpr, -b, -a);
    tmp_if_expr_3 = return_value_lglunhimplincl_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr_3;
}

// lglunhimplincl
// file lglib.c line 10190
static signed int lglunhimplincl(const struct DFPR *dfpr, signed int a, signed int b)
{
  signed int u;
  u=lglulit(a);
  signed int v;
  v=lglulit(b);
  signed int c;
  signed int d;
  signed int f;
  signed int g;
  c = (dfpr + (signed long int)u)->discovered;
  if(c == 0)
    return 0;

  else
  {
    d = (dfpr + (signed long int)v)->discovered;
    if(d == 0)
      return 0;

    else
    {
      f = (dfpr + (signed long int)u)->finished;
      g = (dfpr + (signed long int)v)->finished;
      return (signed int)(c <= d && g <= f);
    }
  }
}

// lglunhlca
// file lglib.c line 15222
static signed int lglunhlca(struct LGL *lgl, const struct DFPR *dfpr, signed int a, signed int b)
{
  const struct DFPR *c;
  const struct DFPR *d;
  signed int u;
  signed int v;
  signed int p;
  if(a == b)
    return a;

  else
  {
    u=lglulit(a);
    v=lglulit(b);
    c = dfpr + (signed long int)u;
    d = dfpr + (signed long int)v;
    if(d->discovered >= c->discovered)
      p = a;

    else
    {
      p = b;
      do
      {
        const struct DFPR *TMP = c;
        c = d;
        d = TMP;
      }
      while((_Bool)0);
    }
    for( ; !(c->finished >= d->finished); c = dfpr + (signed long int)u)
    {
      p = c->parent;
      if(p == 0)
        break;

      u=lglulit(p);
    }

  __CPROVER_DUMP_L5:
    ;
    return p;
  }
}

// lglunhroot
// file lglib.c line 15279
static signed int lglunhroot(const struct DFPR *dfpr, signed int lit)
{
  signed int return_value_lglulit_1;
  return_value_lglulit_1=lglulit(lit);
  return (dfpr + (signed long int)return_value_lglulit_1)->root;
}

// lglunit
// file lglib.c line 2932
static void lglunit(struct LGL *lgl, signed int lit)
{
  lglunitnocheck(lgl, lit);
}

// lglunitnocheck
// file lglib.c line 2926
static void lglunitnocheck(struct LGL *lgl, signed int lit)
{

__CPROVER_DUMP_L1:
  ;
  lglassign(lgl, lit, lit << RMSHFT | UNITCS, 0);
}

// lglunmark
// file lglib.c line 2943
static void lglunmark(struct LGL *lgl, signed int lit)
{
  struct AVar *return_value_lglavar_1;
  return_value_lglavar_1=lglavar(lgl, lit);
  return_value_lglavar_1->mark = 0;
}

// lglunuselevel
// file lglib.c line 1595
static void lglunuselevel(struct LGL *lgl, signed int level)
{
  struct Ctk *ctk = &lgl->control;
  struct Ctr *ctr = ctk->start + (signed long int)level;
  ctr->used = (unsigned int)0;
}

// lglupdblkint
// file lglib.c line 11312
static void lglupdblkint(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->blk.pen == 0))
      lgl->limits->blk.pen = lgl->limits->blk.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->blk.pen >= 4))
      lgl->limits->blk.pen = lgl->limits->blk.pen + 1;

  }

  lgl->limits->blk.irrprgss = lgl->stats->irrprgss;
}

// lglupdcceint
// file lglib.c line 11473
static void lglupdcceint(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->cce.pen == 0))
      lgl->limits->cce.pen = lgl->limits->cce.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->cce.pen >= 4))
      lgl->limits->cce.pen = lgl->limits->cce.pen + 1;

  }

}

// lglupdcgrpen
// file lglib.c line 13754
static void lglupdcgrpen(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->cgr.pen == 0))
      lgl->limits->cgr.pen = lgl->limits->cgr.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->cgr.pen >= 4))
      lgl->limits->cgr.pen = lgl->limits->cgr.pen + 1;

  }

}

// lglupdcliffint
// file lglib.c line 12059
static void lglupdcliffint(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->cliff.pen == 0))
      lgl->limits->cliff.pen = lgl->limits->cliff.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->cliff.pen >= 4))
      lgl->limits->cliff.pen = lgl->limits->cliff.pen + 1;

  }

  lgl->limits->cliff.irrprgss = lgl->stats->irrprgss;
}

// lglupdelmint
// file lglib.c line 12122
static void lglupdelmint(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->elm.pen == 0))
      lgl->limits->elm.pen = lgl->limits->elm.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->elm.pen >= 4))
      lgl->limits->elm.pen = lgl->limits->elm.pen + 1;

  }

  lgl->limits->elm.irrprgss = lgl->stats->irrprgss;
}

// lglupdflipint
// file lglib.c line 7752
static void lglupdflipint(struct LGL *lgl)
{
  signed long int limit = (signed long int)lgl->opts->flipint.val;
  if(limit >= 2147483648l)
    limit = (signed long int)0x7fffffff;

  lgl->limits->flipint = (signed int)limit;
}

// lglupdgausspen
// file lglib.c line 16803
static void lglupdgausspen(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->gauss.pen == 0))
      lgl->limits->gauss.pen = lgl->limits->gauss.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->gauss.pen >= 4))
      lgl->limits->gauss.pen = lgl->limits->gauss.pen + 1;

  }

}

// lglupdlftpen
// file lglib.c line 13951
static void lglupdlftpen(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->lft.pen == 0))
      lgl->limits->lft.pen = lgl->limits->lft.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->lft.pen >= 4))
      lgl->limits->lft.pen = lgl->limits->lft.pen + 1;

  }

}

// lglupdprbasicpen
// file lglib.c line 8934
static void lglupdprbasicpen(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->prb.pen.basic == 0))
      lgl->limits->prb.pen.basic = lgl->limits->prb.pen.basic - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->prb.pen.basic >= 4))
      lgl->limits->prb.pen.basic = lgl->limits->prb.pen.basic + 1;

  }

}

// lglupdprepint
// file lglib.c line 17092
static void lglupdprepint(struct LGL *lgl, signed int red)
{
  signed int div;
  signed int return_value_abs_1;
  return_value_abs_1=abs(red);
  div = return_value_abs_1 / 2 + 1;
  signed long int inc;
  if(red >= 101)
    lglprt(lgl, 1, "[simplification-%d] no increase of limit increments", lgl->stats->simp.count);

  else
  {
    if(div == 1)
      lglprt(lgl, 1, "[simplification-%d] no reduction of limit increments", lgl->stats->simp.count, div);

    else
      lglprt(lgl, 1, "[simplification-%d] limit increments divided by %d", lgl->stats->simp.count, div);
    if(!(lgl->opts->simplify.val == 0))
    {
      inc = (signed long int)(lgl->opts->cintinc.val / div);
      lgl->limits->simp.cinc = lgl->limits->simp.cinc + inc;
      lglprt(lgl, 1, "[simplification-%d] arithmetic increase of conflict limit interval by %lld", lgl->stats->simp.count, (signed long long int)inc);
    }

    else
      lglprt(lgl, 1, "[simplification-%d] limit does not change", lgl->stats->simp.count);
  }
  lgl->limits->simp.confs = lgl->stats->confs + lgl->limits->simp.cinc;
  lgl->limits->simp.irr=lglnewirrlim(lgl);
  lglprt(lgl, 1, "[simplification-%d] new irredundant limit %lld", lgl->stats->simp.count, (signed long long int)lgl->limits->simp.irr);
  lglprt(lgl, 1, "[simplification-%d] new conflict limit %lld", lgl->stats->simp.count, (signed long long int)lgl->limits->simp.confs);
  lgl->limits->simp.prgss = lgl->stats->prgss;
  if(lgl->limits->simp.pen >= 1)
  {
    lgl->limits->simp.pen = lgl->limits->simp.pen - 1;
    lglprt(lgl, 1, "[simplification-%d] simplification penalty reduced to %d", lgl->stats->simp.count, lgl->limits->simp.pen);
  }

}

// lglupdternrespen
// file lglib.c line 14684
static void lglupdternrespen(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->trnr.pen == 0))
      lgl->limits->trnr.pen = lgl->limits->trnr.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->trnr.pen >= 4))
      lgl->limits->trnr.pen = lgl->limits->trnr.pen + 1;

  }

}

// lglupdunhdpen
// file lglib.c line 16146
static void lglupdunhdpen(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->unhd.pen == 0))
      lgl->limits->unhd.pen = lgl->limits->unhd.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->unhd.pen >= 4))
      lgl->limits->unhd.pen = lgl->limits->unhd.pen + 1;

  }

}

// lglusage
// file lglib.c line 2096
void lglusage(struct LGL *lgl)
{
  char fmt[20l];
  signed int len;
  struct Opt *o;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglusage");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  len=lglmaxoptnamelen(lgl);
  sprintf(fmt, "--%%-%ds", len);
  o = &lgl->opts->beforefirst + (signed long int)1;
  for( ; &lgl->opts->afterlast + -1l >= o; o = o + 1l)
  {
    if(!(o->shrt == 0))
      fprintf(lgl->out, "-%c|", o->shrt);

    else
      fprintf(lgl->out, "   ");
    fprintf(lgl->out, fmt, o->lng);
    fprintf(lgl->out, " %s [%d]\n", o->descrp, o->val);
  }
}

// lgluse
// file lglib.c line 3806
static void lgluse(struct LGL *lgl)
{
  if(!((signed int)lgl->state >= USED))
  {

  __CPROVER_DUMP_L1:
    ;
    do
      lgl->state = (enum State)USED;
    while((_Bool)0);
  }

}

// lgluselevel
// file lglib.c line 1587
static void lgluselevel(struct LGL *lgl, signed int level)
{
  struct Ctk *ctk = &lgl->control;
  struct Ctr *ctr = ctk->start + (signed long int)level;
  ctr->used = (unsigned int)1;
}

// lglutrav
// file lglib.c line 18718
void lglutrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int))
{
  signed int elit;
  signed int val;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglutrav");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  signed int return_value_lglbcp_1;
  if(lgl->mt == 0)
  {
    return_value_lglbcp_1=lglbcp(lgl);
    if(return_value_lglbcp_1 == 0)
      lgl->mt = 1;

  }

  if(lgl->mt == 0)
    lglgc(lgl);

  if(lgl->mt == 0)
  {
    if(lgl->level >= 1)
      lglbacktrack(lgl, 0);

    elit = 1;
    for( ; lgl->maxext >= elit; elit = elit + 1)
    {
      val=lglefixed(lgl, elit);
      if(!(val == 0))
        trav(state, val < 0 ? -elit : elit);

    }
  }

}

// lglval
// file lglib.c line 2323
static signed char lglval(struct LGL *lgl, signed int lit)
{
  signed int idx;
  idx=abs(lit);
  signed char res = lgl->vals[(signed long int)idx];
  if(!(lit >= 0))
    res = (signed char)-((signed int)res);

  return res;
}

// lglvar2fun
// file lglib.c line 10499
static void lglvar2fun(signed int v, unsigned long int *res)
{
  lglvar2funaux(v, res, 0);
}

// lglvar2funaux
// file lglib.c line 10477
static void lglvar2funaux(signed int v, unsigned long int *res, signed int negate)
{
  unsigned long int tmp;
  signed int i;
  signed int j;
  signed int p;
  if(!(v >= 6))
  {
    tmp = lglbasevar2funtab[(signed long int)v];
    if(!(negate == 0))
      tmp = ~tmp;

    i = 0;
    for( ; !(i >= 64); i = i + 1)
      res[(signed long int)i] = tmp;
  }

  else
  {
    tmp = negate != 0 ? ~0ull : 0ull;
    p = 1 << v - 6;
    j = 0;
    i = 0;
    for( ; !(i >= 64); i = i + 1)
    {
      res[(signed long int)i] = tmp;
      j = j + 1;
      if(j >= p)
      {
        tmp = ~tmp;
        j = 0;
      }

    }
  }
}

// lglversion
// file lglbnr.c line 52
const char * lglversion(void)
{
  return "ala b02aa1a04343558c4252b5f4a723be021964f652";
}

// lglvmtf
// file lglib.c line 5915
static void lglvmtf(struct LGL *lgl, signed int lit)
{
  signed int oldprior;
  signed int newprior;
  signed int inc;
  struct Qln *src;
  struct Qln *dst;
  struct Qln *l;
  struct Qnd *node;
  lit=abs(lit);
  src=lglqln(lgl, lit);
  oldprior = src->prior;
  inc = lgl->opts->queueinc.val;
  newprior = oldprior + inc;
  if(!(lgl->stats->queue.max >= newprior))
  {
    lgl->stats->queue.max = newprior;
    lglprt(lgl, 2, "[queue] maximum priority %d", newprior);
  }

  dst = src->up;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(dst == ((struct Qln *)NULL)))
      tmp_if_expr_1 = dst->prior < newprior ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    dst = dst->up;
  }
  while((_Bool)1);
  _Bool tmp_if_expr_3;
  if(dst == ((struct Qln *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = newprior < dst->prior ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
  {
    l = lgl->queue.free;
    if(!(l == ((struct Qln *)NULL)))
    {
      lgl->queue.free = l->up;
      do
        memset((void *)l, 0, sizeof(struct Qln) /*40ul*/ );
      while((_Bool)0);
    }

    else
      do
      {
        void *return_value_lglnew_2;
        return_value_lglnew_2=lglnew(lgl, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
        l = (struct Qln *)return_value_lglnew_2;
      }
      while((_Bool)0);

  __CPROVER_DUMP_L10:
    ;
    lgl->stats->queue.new = lgl->stats->queue.new + 1l;
    lgl->queue.nlines = lgl->queue.nlines + 1;
    l->prior = newprior;
    l->repr = l;
    if(!(dst == ((struct Qln *)NULL)))
    {
      if(!(dst->down == ((struct Qln *)NULL)))
        dst->down->up = l;

      else
        lgl->queue.bottom = l;
      l->down = dst->down;
      l->up = dst;
      dst->down = l;
    }

    else
    {
      lgl->queue.top->up = l;
      l->down = lgl->queue.top;
      lgl->queue.top = l;
    }
    dst = l;
  }


__CPROVER_DUMP_L15:
  ;
  node=lglqnd(lgl, lit);
  struct Qnd *return_value_lglqnd_4;
  if(!(node->prev == 0))
  {
    return_value_lglqnd_4=lglqnd(lgl, node->prev);
    return_value_lglqnd_4->next = node->next;
  }

  else
    src->first = node->next;
  struct Qnd *return_value_lglqnd_5;
  if(!(node->next == 0))
  {
    return_value_lglqnd_5=lglqnd(lgl, node->next);
    return_value_lglqnd_5->prev = node->prev;
  }

  else
    src->last = node->prev;
  if(src->unassigned == lit)
    src->unassigned = node->next;


__CPROVER_DUMP_L20:
  ;
  struct Qnd *return_value_lglqnd_6;
  if(!(dst->last == 0))
  {
    return_value_lglqnd_6=lglqnd(lgl, dst->last);
    return_value_lglqnd_6->next = lit;
  }

  else
    dst->first = lit;
  node->prev = dst->last;
  node->next = 0;
  node->line = dst;
  dst->last = lit;
  signed char return_value_lglval_8;
  return_value_lglval_8=lglval(lgl, lit);
  _Bool tmp_if_expr_7;
  if(return_value_lglval_8 == 0)
  {
    if(lgl->queue.unassigned == ((struct Qln *)NULL))
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = lgl->queue.unassigned->prior < newprior ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_7)
      lgl->queue.unassigned = dst;

  }

  if(dst->unassigned == 0)
    dst->unassigned = lit;

  if(src->first == 0)
  {

  __CPROVER_DUMP_L27:
    ;
    if(!(src->down == ((struct Qln *)NULL)))
      src->down->up = src->up;

    else
      lgl->queue.bottom = src->up;
    if(!(src->up == ((struct Qln *)NULL)))
      src->up->down = src->down;

    else
      lgl->queue.top = src->down;
    if(lgl->queue.unassigned == src)
      lgl->queue.unassigned = src->down;

    lgl->queue.nlines = lgl->queue.nlines - 1;
    lgl->stats->queue.del = lgl->stats->queue.del + 1l;
    src->up = lgl->queue.free;
    lgl->queue.free = src;
  }

  if(lgl->opts->check.val >= 3)
    lglchkqueue(lgl);

}

// lglwchbin
// file lglib.c line 3132
static signed long int lglwchbin(struct LGL *lgl, signed int lit, signed int other, signed int red)
{
  struct HTS *hts;
  hts=lglhts(lgl, lit);
  signed int cs = other << RMSHFT | BINCS | red;
  signed long int res;
  res=lglpushwch(lgl, hts, cs);

__CPROVER_DUMP_L1:
  ;
  return res;
}

// lglwchlrg
// file lglib.c line 3153
static signed long int lglwchlrg(struct LGL *lgl, signed int lit, signed int other, signed int red, signed int lidx)
{
  struct HTS *hts;
  hts=lglhts(lgl, lit);
  signed int blit = other << RMSHFT | LRGCS | red;
  signed long int res = (signed long int)0;
  signed long int return_value_lglpushwch_1;
  return_value_lglpushwch_1=lglpushwch(lgl, hts, blit);
  res = res + return_value_lglpushwch_1;
  signed long int return_value_lglpushwch_2;
  return_value_lglpushwch_2=lglpushwch(lgl, hts, lidx);
  res = res + return_value_lglpushwch_2;
  return res;
}

// lglwchtrn
// file lglib.c line 3142
static signed long int lglwchtrn(struct LGL *lgl, signed int a, signed int b, signed int c, signed int red)
{
  struct HTS *hts;
  hts=lglhts(lgl, a);
  signed int cs = b << RMSHFT | TRNCS | red;
  signed long int res;
  res=lglpushwch(lgl, hts, cs);
  signed long int return_value_lglpushwch_1;
  return_value_lglpushwch_1=lglpushwch(lgl, hts, c);
  res = res + return_value_lglpushwch_1;

__CPROVER_DUMP_L1:
  ;
  return res;
}

// lglwrkcompact
// file lglib.c line 8514
static void lglwrkcompact(struct LGL *lgl)
{
  signed int i;
  signed int j = 0;
  signed int lit;
  signed int tail;
  unsigned long int return_value_lglcntstk_1;
  return_value_lglcntstk_1=lglcntstk(&lgl->wrk->queue);
  tail = (signed int)return_value_lglcntstk_1;
  i = lgl->wrk->head;
  signed int tmp_post_2;
  for( ; !(i >= tail); i = i + 1)
  {
    lit = lgl->wrk->queue.start[(signed long int)i];
    if(!(lit == 0))
    {
      signed int return_value_lglisfree_3;
      return_value_lglisfree_3=lglisfree(lgl, lit);
      if(return_value_lglisfree_3 == 0)
      {
        lgl->wrk->pos[(signed long int)lit] = -1;
        lgl->wrk->count = lgl->wrk->count - 1;
      }

      else
      {
        lgl->wrk->queue.start[(signed long int)j] = lit;
        tmp_post_2 = j;
        j = j + 1;
        lgl->wrk->pos[(signed long int)lit] = tmp_post_2;
      }
    }

  }
  lglrststk(&lgl->wrk->queue, j);
  lgl->wrk->head = 0;
}

// lglwrkdeq
// file lglib.c line 8557
static signed int lglwrkdeq(struct LGL *lgl)
{
  signed int res;
  signed int pos;
  unsigned long int return_value_lglcntstk_1;
  do
  {
    pos = lgl->wrk->head;
    return_value_lglcntstk_1=lglcntstk(&lgl->wrk->queue);
    if((unsigned long int)pos >= return_value_lglcntstk_1)
      break;

    lgl->wrk->head = lgl->wrk->head + 1;
    res = lgl->wrk->queue.start[(signed long int)pos];
    if(!(res == 0))
    {
      lgl->wrk->queue.start[(signed long int)pos] = 0;
      lgl->wrk->count = lgl->wrk->count - 1;
      lgl->wrk->pos[(signed long int)res] = -1;
      signed int return_value_lglisfree_2;
      return_value_lglisfree_2=lglisfree(lgl, res);
      if(!(return_value_lglisfree_2 == 0))
        return res;

    }

  }
  while((_Bool)1);
  return 0;
}

// lglwrkinit
// file lglib.c line 8488
static void lglwrkinit(struct LGL *lgl, signed int posonly, signed int fifo)
{
  signed int size;
  signed int lit;
  do
  {
    void *return_value_lglnew_1;
    return_value_lglnew_1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Wrk) /*56ul*/ );
    lgl->wrk = (struct Wrk *)return_value_lglnew_1;
  }
  while((_Bool)0);
  lgl->wrk->fifo = fifo;
  lgl->wrk->size = lgl->nvars;
  size = lgl->wrk->size;
  if(!(posonly == 0))
  {
    do
    {
      void *return_value_lglnew_2;
      return_value_lglnew_2=lglnew(lgl, (unsigned long int)size * sizeof(signed int) /*4ul*/ );
      lgl->wrk->pos = (signed int *)return_value_lglnew_2;
    }
    while((_Bool)0);
    lgl->wrk->posonly = 1;
  }

  else
  {
    do
    {
      void *return_value_lglnew_3;
      return_value_lglnew_3=lglnew(lgl, (unsigned long int)(2 * size) * sizeof(signed int) /*4ul*/ );
      lgl->wrk->pos = (signed int *)return_value_lglnew_3;
    }
    while((_Bool)0);
    lgl->wrk->pos = lgl->wrk->pos + (signed long int)size;
    lit = -size + 1;
    for( ; !(lit >= -1); lit = lit + 1)
      lgl->wrk->pos[(signed long int)lit] = -1;
  }
  lit = 2;
  for( ; !(lit >= size); lit = lit + 1)
    lgl->wrk->pos[(signed long int)lit] = -1;
}

// lglwrknext
// file lglib.c line 8590
static signed int lglwrknext(struct LGL *lgl)
{
  signed int tmp_if_expr_3;
  signed int return_value_lglwrkdeq_1;
  signed int return_value_lglwrkpop_2;
  if(!(lgl->wrk->fifo == 0))
  {
    return_value_lglwrkdeq_1=lglwrkdeq(lgl);
    tmp_if_expr_3 = return_value_lglwrkdeq_1;
  }

  else
  {
    return_value_lglwrkpop_2=lglwrkpop(lgl);
    tmp_if_expr_3 = return_value_lglwrkpop_2;
  }
  return tmp_if_expr_3;
}

// lglwrkpop
// file lglib.c line 8573
static signed int lglwrkpop(struct LGL *lgl)
{
  signed int res;
  unsigned long int return_value_lglcntstk_1;
  do
  {
    return_value_lglcntstk_1=lglcntstk(&lgl->wrk->queue);
    if((unsigned long int)lgl->wrk->head >= return_value_lglcntstk_1)
      break;

    res=lglpopstk(&lgl->wrk->queue);
    if(!(res == 0))
    {
      lgl->wrk->pos[(signed long int)res] = -1;
      signed int return_value_lglisfree_2;
      return_value_lglisfree_2=lglisfree(lgl, res);
      if(!(return_value_lglisfree_2 == 0))
        return res;

    }

  }
  while((_Bool)1);
  return 0;
}

// lglwrkreset
// file lglib.c line 8504
static void lglwrkreset(struct LGL *lgl)
{
  lglrelstk(lgl, &lgl->wrk->queue);
  if(!(lgl->wrk->posonly == 0))
    do
    {
      lgldel(lgl, (void *)lgl->wrk->pos, (unsigned long int)lgl->wrk->size * sizeof(signed int) /*4ul*/ );
      lgl->wrk->pos = ((signed int *)NULL);
    }
    while((_Bool)0);

  else
  {
    lgl->wrk->pos = lgl->wrk->pos - (signed long int)lgl->wrk->size;
    do
    {
      lgldel(lgl, (void *)lgl->wrk->pos, (unsigned long int)(2 * lgl->wrk->size) * sizeof(signed int) /*4ul*/ );
      lgl->wrk->pos = ((signed int *)NULL);
    }
    while((_Bool)0);
  }
  do
  {
    lgldel(lgl, (void *)lgl->wrk, (unsigned long int)1 * sizeof(struct Wrk) /*56ul*/ );
    lgl->wrk = ((struct Wrk *)NULL);
  }
  while((_Bool)0);
}

// lglwrktouch
// file lglib.c line 8535
static signed int lglwrktouch(struct LGL *lgl, signed int lit)
{
  signed int tail;
  signed int pos;
  signed int return_value_lglisfree_1;
  return_value_lglisfree_1=lglisfree(lgl, lit);
  struct AVar *return_value_lglavar_2;
  struct AVar *return_value_lglavar_3;
  if(return_value_lglisfree_1 == 0)
    return 1;

  else
  {
    if(!(lgl->donotsched == 0))
    {
      if(!(lgl->cgrclosing == 0))
      {
        return_value_lglavar_2=lglavar(lgl, lit);
        if(!(return_value_lglavar_2->donotcgrcls == 0u))
          return 1;

      }

      if(!(lgl->ternresing == 0))
      {
        return_value_lglavar_3=lglavar(lgl, lit);
        if(!(return_value_lglavar_3->donoternres == 0u))
          return 1;

      }

    }

    if(!(lgl->wrk->posonly == 0))
      lit=abs(lit);

    unsigned long int return_value_lglcntstk_4;
    return_value_lglcntstk_4=lglcntstk(&lgl->wrk->queue);
    tail = (signed int)return_value_lglcntstk_4;

  __CPROVER_DUMP_L6:
    ;
    pos = lgl->wrk->pos[(signed long int)lit];
    if(pos >= 0)
      lgl->wrk->queue.start[(signed long int)pos] = 0;

    lgl->wrk->count = lgl->wrk->count + 1;
    lgl->wrk->pos[(signed long int)lit] = tail;
    lglpushstk(lgl, &lgl->wrk->queue, lit);
    if(!(lgl->wrk->count >= tail / 2))
      lglwrkcompact(lgl);

    return 1;
  }
}

// lglwrn
// file lglib.c line 1150
static void lglwrn(struct LGL *lgl, const char *msg, ...)
{
  void **ap;
  fprintf(lgl->out, "*** warning in '%s': ", (const void *)"lglib.c");
  ap = (void **)&msg;
  vfprintf(lgl->out, msg, ap);
  ap = ((void **)NULL);
  fputc(10, lgl->out);
  fflush(lgl->out);
}

// lglws
// file lglib.c line 2199
static signed int lglws(signed int ch)
{
  return (signed int)(ch == 32 || ch == 9 || ch == 10 || ch == 13);
}

// lglwtrapi
// file lglib.c line 1506
void lglwtrapi(struct LGL *lgl, struct _IO_FILE *apitrace)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglwtrapi");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

    while((UNUSED & (signed int)lgl->state) == 0)
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglwtrapi");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "!(%s)", (const void *)"UNUSED");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
  }
  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglwtrapi");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can only write one API trace");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lgl->apitrace = apitrace;
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "init");
    break;
  }
}

// lglxorhascls
// file lglib.c line 12718
static signed int lglxorhascls(struct LGL *lgl)
{
  signed int lit;
  signed int res;
  signed int minlit = 0;
  signed int minoccs = 0x7fffffff;
  signed int litoccs;
  signed int blit;
  signed int tag;
  signed int lidx;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *l;
  const signed int *c;
  struct HTS *hts;
  p = lgl->clause.start;
  for( ; !(p >= lgl->clause.top); p = p + 1l)
  {
    lit = *p;
    litoccs=lglocc(lgl, lit);
    if(!(litoccs >= minoccs))
    {
      minlit = lit;
      minoccs = litoccs;
    }

    lglsignedmark(lgl, lit);
  }
  res = 0;
  hts=lglhts(lgl, minlit);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  p = w;
  signed int return_value_lglsignedmarked_3;
  for( ; res == 0 && !(p >= eow); p = p + 1l)
  {
    blit = *p;
    signed int return_value_lglincextractlimhit_1;
    return_value_lglincextractlimhit_1=lglincextractlimhit(lgl);
    if(!(return_value_lglincextractlimhit_1 == 0))
      break;

    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(tag == OCCS)
    {
      lidx = blit >> RMSHFT;
      signed int return_value_lglincextractlimhit_2;
      return_value_lglincextractlimhit_2=lglincextractlimhit(lgl);
      if(!(return_value_lglincextractlimhit_2 == 0))
        break;

      c=lglidx2lits(lgl, OCCS, blit & REDCS, lidx);
      l = c;
      do
      {
        lit = *l;
        if(lit == 0)
          break;

        return_value_lglsignedmarked_3=lglsignedmarked(lgl, lit);
        if(return_value_lglsignedmarked_3 == 0)
          break;

        l = l + 1l;
      }
      while((_Bool)1);
      if(lit == 0)
        res = 1;

    }

  }
  p = lgl->clause.start;
  for( ; !(p >= lgl->clause.top); p = p + 1l)
    lglunmark(lgl, *p);
  return res;
}

// main
// file ilingeling.c line 758
signed int main(signed int argc, char **argv)
{
  const char *statsfilename = ((const char *)NULL);
  const char *histfilename = ((const char *)NULL);
  signed int i;
  signed int closeinputfile;
  signed int res = 0;
  struct Worker *winner;
  struct Worker *w;
  startime=currentime();
  i = 1;
  signed int tmp_statement_expression_20;
  signed int tmp_statement_expression_18;
  signed int tmp_statement_expression_16;
  signed int tmp_statement_expression_14;
  signed int tmp_statement_expression_12;
  signed int tmp_statement_expression_10;
  signed int tmp_statement_expression_8;
  signed int tmp_statement_expression_6;
  signed int tmp_statement_expression_4;
  signed int tmp_statement_expression_2;
  signed int return_value_isnum_1;
  for( ; !(i >= argc); i = i + 1)
  {
    unsigned long int main__1__1__1__1____s1_len;
    unsigned long int main__1__1__1__1____s2_len;
    signed int return_value___builtin_strcmp_21;
    return_value___builtin_strcmp_21=__builtin_strcmp(argv[(signed long int)i], "-h");
    tmp_statement_expression_20 = return_value___builtin_strcmp_21;
    if(tmp_statement_expression_20 == 0)
    {
      printf("usage: ilingeling [<option> ...][<inccnf>][<nworkers>]\n\nwhere <option> is one of the following:\n\n  -h  print this command line option summary\n\n  -v  increase verbose level\n  -q  do not print 'c job ...' lines (requires verbosity < 2)\n  -b  progress bar (implies '-q')\n\n  -s  <stats> output statistics to separate file\n  -t  <hist> output job run time histogram to separate file\n\n  --no-fork         disabling forking after %d conflicts\n  --no-brute-fork   do not brute-fork after additional %d conflicts\n\n  -a  add previous assumptions as don't care\n\n  <inccnf>    'p inccnf' + '<lit*> 0' clauses + 'a <lit>* 0' assumptions\n  <nworkers>  number of workers defaults to 1\n", 20000, 100000);
      exit(0);
    }

    else
    {
      unsigned long int main__1__1__1__3____s1_len;
      unsigned long int main__1__1__1__3____s2_len;
      signed int return_value___builtin_strcmp_19;
      return_value___builtin_strcmp_19=__builtin_strcmp(argv[(signed long int)i], "-v");
      tmp_statement_expression_18 = return_value___builtin_strcmp_19;
      if(tmp_statement_expression_18 == 0)
        verbose = verbose + 1;

      else
      {
        unsigned long int main__1__1__1__4____s1_len;
        unsigned long int main__1__1__1__4____s2_len;
        signed int return_value___builtin_strcmp_17;
        return_value___builtin_strcmp_17=__builtin_strcmp(argv[(signed long int)i], "-b");
        tmp_statement_expression_16 = return_value___builtin_strcmp_17;
        if(tmp_statement_expression_16 == 0)
          bar = 1;

        else
        {
          unsigned long int main__1__1__1__5____s1_len;
          unsigned long int main__1__1__1__5____s2_len;
          signed int return_value___builtin_strcmp_15;
          return_value___builtin_strcmp_15=__builtin_strcmp(argv[(signed long int)i], "-n");
          tmp_statement_expression_14 = return_value___builtin_strcmp_15;
          if(tmp_statement_expression_14 == 0)
            nowitness = 1;

          else
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp_13;
            return_value___builtin_strcmp_13=__builtin_strcmp(argv[(signed long int)i], "-a");
            tmp_statement_expression_12 = return_value___builtin_strcmp_13;
            if(tmp_statement_expression_12 == 0)
              addassumptions = 1;

            else
            {
              unsigned long int main__1__1__1__7____s1_len;
              unsigned long int main__1__1__1__7____s2_len;
              signed int return_value___builtin_strcmp_11;
              return_value___builtin_strcmp_11=__builtin_strcmp(argv[(signed long int)i], "-p");
              tmp_statement_expression_10 = return_value___builtin_strcmp_11;
              if(tmp_statement_expression_10 == 0)
                plain = 1;

              else
              {
                unsigned long int main__1__1__1__8____s1_len;
                unsigned long int main__1__1__1__8____s2_len;
                signed int return_value___builtin_strcmp_9;
                return_value___builtin_strcmp_9=__builtin_strcmp(argv[(signed long int)i], "-s");
                tmp_statement_expression_8 = return_value___builtin_strcmp_9;
                if(tmp_statement_expression_8 == 0)
                {
                  if(!(statsfilename == ((const char *)NULL)))
                    die("two '-s' options");

                  i = i + 1;
                  if(i == argc)
                    die("argument to '-s' missing");

                  statsfilename = argv[(signed long int)i];
                }

                else
                {
                  unsigned long int main__1__1__1__10____s1_len;
                  unsigned long int main__1__1__1__10____s2_len;
                  signed int return_value___builtin_strcmp_7;
                  return_value___builtin_strcmp_7=__builtin_strcmp(argv[(signed long int)i], "-t");
                  tmp_statement_expression_6 = return_value___builtin_strcmp_7;
                  if(tmp_statement_expression_6 == 0)
                  {
                    if(!(histfilename == ((const char *)NULL)))
                      die("two '-t' options");

                    i = i + 1;
                    if(i == argc)
                      die("argument to '-t' missing");

                    histfilename = argv[(signed long int)i];
                  }

                  else
                  {
                    unsigned long int main__1__1__1__12____s1_len;
                    unsigned long int main__1__1__1__12____s2_len;
                    signed int return_value___builtin_strcmp_5;
                    return_value___builtin_strcmp_5=__builtin_strcmp(argv[(signed long int)i], "--no-fork");
                    tmp_statement_expression_4 = return_value___builtin_strcmp_5;
                    if(tmp_statement_expression_4 == 0)
                      dofork = 0;

                    else
                    {
                      unsigned long int main__1__1__1__13____s1_len;
                      unsigned long int main__1__1__1__13____s2_len;
                      signed int return_value___builtin_strcmp_3;
                      return_value___builtin_strcmp_3=__builtin_strcmp(argv[(signed long int)i], "--no-brute-fork");
                      tmp_statement_expression_2 = return_value___builtin_strcmp_3;
                      if(tmp_statement_expression_2 == 0)
                        dofork = dofork != 0 ? 1 : 0;

                      else
                        if((signed int)*argv[(signed long int)i] == 45)
                          die("invalid option '%s'", argv[(signed long int)i]);

                        else
                        {
                          return_value_isnum_1=isnum(argv[(signed long int)i]);
                          if(!(return_value_isnum_1 == 0))
                          {
                            if(!(nworkers == 0))
                              die("number of workers specified twice: '%d' and '%s'", nworkers, argv[(signed long int)i]);

                            nworkers=atoi(argv[(signed long int)i]);
                            if(!(nworkers >= 1))
                              die("invalid number of workers argument: '%s'", argv[(signed long int)i]);

                          }

                          else
                            if(!(inputname == ((char *)NULL)))
                              die("two files given: '%s' and '%s'", inputname, argv[(signed long int)i]);

                            else
                              inputname = argv[(signed long int)i];
                        }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  signed int return_value_isatty_22;
  if(!(bar == 0))
  {
    return_value_isatty_22=isatty(1);
    if(return_value_isatty_22 == 0)
      die("progress bar requested but <stdout> not connected to terminal");

  }

  if(verbose >= 2 && !(bar == 0))
    die("verbosity %d > 1 with '-b'", verbose);

  if(!(statsfilename == ((const char *)NULL)))
  {
    statsfile=fopen(statsfilename, "w");
    if(statsfile == ((struct _IO_FILE *)NULL))
      die("can not write to stats file '%s'", statsfilename);

  }

  if(!(histfilename == ((const char *)NULL)))
  {
    histfile=fopen(histfilename, "w");
    if(histfile == ((struct _IO_FILE *)NULL))
      die("can not write to job run time histogram file '%s'", histfilename);

  }

  if(statsfile == ((struct _IO_FILE *)NULL) && !(verbose == 0))
    statsfile = stdout;

  if(!(verbose == 0))
  {
    lglbnr("iLingeling Incremental Parallel Lingeling", "c ", stdout);
    printf("c\n");
    fflush(stdout);
  }

  if(nworkers == 0)
    nworkers = 1;

  msg(((struct Worker *)NULL), 1, "using %d workers", nworkers);
  if(!(inputname == ((char *)NULL)))
  {
    inputfile=fopen(inputname, "r");
    if(inputfile == ((struct _IO_FILE *)NULL))
      die("can not read '%s'", inputname);

    closeinputfile = 1;
  }

  else
  {
    inputname = "<stdin>";
    inputfile = stdin;
    closeinputfile = 0;
  }
  init();
  setsighandlers();
  msg(((struct Worker *)NULL), 1, "parsing %s", inputname);
  parse();
  if(!(closeinputfile == 0))
    fclose(inputfile);

  msg(((struct Worker *)NULL), 1, "%d variables out of %d used in assumptions which is %.0f%%", nused, nvars, nvars != 0 ? 100.0 * ((double)nused / (double)nvars) : 0.0);
  freeze();
  start();
  stop();
  winner = ((struct Worker *)NULL);
  w = workers;
  for( ; !(w >= workers + (signed long int)nworkers); w = w + 1l)
    if(!(w->res == 0))
    {
      winner = w;
      if(w->res == 10)
        break;

    }

  signed int return_value_lglderef_24;
  if(!(winner == ((struct Worker *)NULL)))
  {
    res = winner->res;
    if(res == 10)
    {
      if(nowitness == 0)
      {
        do
        {
          unsigned long int BYTES = (unsigned long int)nvars * sizeof(signed char) /*1ul*/ ;
          void *return_value_malloc_23;
          return_value_malloc_23=malloc(BYTES);
          vals = (signed char *)return_value_malloc_23;
          if(vals == ((signed char *)NULL))
          {
            die("out of memory");
            exit(1);
          }

          memset((void *)vals, 0, BYTES);
          do
          {
            allocated = allocated + BYTES;
            if(!(maxallocated >= allocated))
              maxallocated = allocated;

          }
          while((_Bool)0);
        }
        while((_Bool)0);
        i = 1;
        for( ; !(i >= nvars); i = i + 1)
        {
          return_value_lglderef_24=lglderef(winner->lgl, i);
          vals[(signed long int)i] = (signed char)return_value_lglderef_24;
        }
      }

    }

  }

  resetsighandlers();
  if(!(statsfile == ((struct _IO_FILE *)NULL)))
    stats();

  if(!(statsfilename == ((const char *)NULL)))
    fclose(statsfile);

  if(!(histfile == ((struct _IO_FILE *)NULL)))
    hist();

  if(!(histfile == ((struct _IO_FILE *)NULL)))
    fclose(histfile);

  if(res == 10)
    printf("s SATISFIABLE\n");

  else
    if(res == 20)
      printf("s UNSATISFIABLE\n");

    else
      printf("s UNKNOWN\n");
  fflush(stdout);
  if(!(vals == ((signed char *)NULL)))
  {
    i = 1;
    for( ; !(i >= nvars); i = i + 1)
    {
      fputs("v ", stdout);
      if(!((signed int)vals[(signed long int)i] >= 0))
        fputc(45, stdout);

      printf("%d\n", i);
    }
    fputs("v 0\n", stdout);
    fflush(stdout);
  }

  reset();
  return res;
}

// msg
// file ilingeling.c line 133
static void msg(struct Worker *w, signed int level, const char *fmt, ...)
{
  void **ap;
  if(verbose >= level)
  {
    msglock(NULL);
    if(!(w == ((struct Worker *)NULL)))
      printf("c %d ", (signed int)(w - workers));

    else
      printf("c - ");
    ap = (void **)&fmt;
    vprintf(fmt, ap);
    ap = ((void **)NULL);
    fputc(10, stdout);
    fflush(stdout);
    msgunlock(NULL);
  }

}

// msglock
// file ilingeling.c line 123
static void msglock(void *voidptr)
{
  (void)voidptr;
  pthread_mutex_lock(&msgmutex);
}

// msgunlock
// file ilingeling.c line 128
static void msgunlock(void *voidptr)
{
  (void)voidptr;
  pthread_mutex_unlock(&msgmutex);
}

// next
// file ilingeling.c line 464
static signed int next(void)
{
  signed int res;
  res=_IO_getc(inputfile);
  if(res == 10)
    lineno = lineno + 1;

  return res;
}

// parse
// file ilingeling.c line 476
static void parse(void)
{
  signed int ch;
  signed int lit;
  signed int sign;
  signed int *assumption;
  signed int i;
  do
  {

  HEADER:
    ;
    ch=next();
    if(ch == -1)
      perr("unexpected end-of-file in header");

    if(!(ch == 99))
      break;

    do
    {
      ch=next();
      if(ch == 10)
        break;

      if(ch == -1)
        perr("unexpected end-of-file in comment");

    }
    while((_Bool)1);
  }
  while((_Bool)1);
  _Bool tmp_if_expr_2;
  signed int return_value_next_1;
  if(!(ch == 112))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_next_1=next();
    tmp_if_expr_2 = return_value_next_1 != 32 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  signed int return_value_next_3;
  if(tmp_if_expr_2)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_next_3=next();
    tmp_if_expr_4 = return_value_next_3 != 105 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_6;
  signed int return_value_next_5;
  if(tmp_if_expr_4)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_next_5=next();
    tmp_if_expr_6 = return_value_next_5 != 110 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_8;
  signed int return_value_next_7;
  if(tmp_if_expr_6)
    tmp_if_expr_8 = (_Bool)1;

  else
  {
    return_value_next_7=next();
    tmp_if_expr_8 = return_value_next_7 != 99 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_10;
  signed int return_value_next_9;
  if(tmp_if_expr_8)
    tmp_if_expr_10 = (_Bool)1;

  else
  {
    return_value_next_9=next();
    tmp_if_expr_10 = return_value_next_9 != 99 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_12;
  signed int return_value_next_11;
  if(tmp_if_expr_10)
    tmp_if_expr_12 = (_Bool)1;

  else
  {
    return_value_next_11=next();
    tmp_if_expr_12 = return_value_next_11 != 110 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_14;
  signed int return_value_next_13;
  if(tmp_if_expr_12)
    tmp_if_expr_14 = (_Bool)1;

  else
  {
    return_value_next_13=next();
    tmp_if_expr_14 = return_value_next_13 != 102 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_14)
    perr("invalid header (expected 'p inccnf')");

  ch=next();

CLAUSES:
  ;
  const unsigned short int **return_value___ctype_b_loc_16;
  const unsigned short int **return_value___ctype_b_loc_17;
  const unsigned short int **return_value___ctype_b_loc_20;
  const unsigned short int **return_value___ctype_b_loc_21;
  signed int tmp_post_23;
  signed int tmp_post_26;
  _Bool tmp_if_expr_28;
  const unsigned short int **return_value___ctype_b_loc_27;
  while((_Bool)1)
  {
    if(ch == 9 || ch == 10 || ch == 13 || ch == 32)
    {
      ch=next();
      goto CLAUSES;
    }

    if(ch == -1 && !(nlits == 0))
      perr("unexpected end-of-file in clause");

    if(ch == 97 && !(nlits == 0))
      perr("unexpected 'a' in clause");

    if(!(ch == 97))
    {
      if(ch == -1)
        goto DONE;

      if(!(ch == 97))
      {
        if(ch == 45)
        {
          sign = -1;
          ch=next();
          const unsigned short int **return_value___ctype_b_loc_15;
          return_value___ctype_b_loc_15=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc_15)[(signed long int)ch]) == 0)
            perr("expected digit after '-'");

        }

        else
          sign = 1;
        return_value___ctype_b_loc_16=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc_16)[(signed long int)ch]) == 0)
          perr("expected literal");

        lit = ch - 48;
        do
        {
          return_value___ctype_b_loc_17=__ctype_b_loc();
          ch=next();
          if((2048 & (signed int)(*return_value___ctype_b_loc_17)[(signed long int)ch]) == 0)
            break;

          lit = (10 * lit + ch) - 48;
        }
        while((_Bool)1);
        if(!(nvars >= lit))
        {
          if(lit >= szvars)
          {
            signed int oldszvars = szvars;
            szvars = szvars != 0 ? 2 * szvars : 1;
            for( ; lit >= szvars; szvars = szvars * 2)
              ;
            do
            {
              unsigned long int OBYTES = (unsigned long int)oldszvars * sizeof(signed int) /*4ul*/ ;
              unsigned long int NBYTES = (unsigned long int)szvars * sizeof(signed int) /*4ul*/ ;
              do
                allocated = allocated - OBYTES;
              while((_Bool)0);
              void *return_value_realloc_18;
              return_value_realloc_18=realloc((void *)used, NBYTES);
              used = (signed int *)return_value_realloc_18;
              if(used == ((signed int *)NULL))
                die("out of memory");

              do
              {
                allocated = allocated + NBYTES;
                if(!(maxallocated >= allocated))
                  maxallocated = allocated;

              }
              while((_Bool)0);
            }
            while((_Bool)0);
            i = oldszvars;
            for( ; !(i >= szvars); i = i + 1)
              used[(signed long int)i] = -1;
          }

          nvars = lit;
        }

        lit = lit * sign;
        if(!(lit == 0))
          nlits = nlits + 1;

        else
        {
          nlits = 0;
          nclauses = nclauses + 1;
        }
        add(lit);
        goto CLAUSES;
      }

    }


  ASSUMPTIONS:
    ;
    (void)0;
    ch=next();
    if(!(ch == 32))
      perr("expected space after 'a'");

    do
    {

    LITS:
      ;
      ch=next();
      if(ch == 9 || ch == 10 || ch == 13 || ch == 32)
        goto LITS;

      if(ch == -1 && !(nlits == 0))
        perr("unexpected end-of-file in assumptions");

      if(ch == 45)
      {
        sign = -1;
        ch=next();
        const unsigned short int **return_value___ctype_b_loc_19;
        return_value___ctype_b_loc_19=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc_19)[(signed long int)ch]) == 0)
          perr("expected digit after '-'");

      }

      else
        sign = 1;
      return_value___ctype_b_loc_20=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc_20)[(signed long int)ch]) == 0)
        perr("expected literal");

      lit = ch - 48;
      do
      {
        return_value___ctype_b_loc_21=__ctype_b_loc();
        ch=next();
        if((2048 & (signed int)(*return_value___ctype_b_loc_21)[(signed long int)ch]) == 0)
          break;

        lit = (10 * lit + ch) - 48;
      }
      while((_Bool)1);
      if(!(nvars >= lit))
        perr("assumption %d exceeds maximum variables %d", lit, nvars);

      if(!(used[(signed long int)lit] >= 0))
        nused = nused + 1;

      used[(signed long int)lit] = nassumptions;
      lit = lit * sign;
      if(!(ch == 9) && !(ch == 10) && !(ch == 13) && !(ch == 32))
        perr("expected white space after '%l'", lit);

      if(lit == 0)
        break;

      do
      {
        if(nlits >= szlits)
          do
          {
            unsigned long int oldbytes;
            unsigned long int newbytes;
            oldbytes = (unsigned long int)szlits * sizeof(signed int) /*4ul*/ ;
            do
              allocated = allocated - oldbytes;
            while((_Bool)0);
            szlits = szlits != 0 ? 2 * szlits : 1;
            newbytes = (unsigned long int)szlits * sizeof(signed int) /*4ul*/ ;
            void *return_value_realloc_22;
            return_value_realloc_22=realloc((void *)lits, newbytes);
            lits = (signed int *)return_value_realloc_22;
            if(lits == ((signed int *)NULL))
              die("out of memory");

            do
            {
              allocated = allocated + newbytes;
              if(!(maxallocated >= allocated))
                maxallocated = allocated;

            }
            while((_Bool)0);
          }
          while((_Bool)0);

        tmp_post_23 = nlits;
        nlits = nlits + 1;
        lits[(signed long int)tmp_post_23] = lit;
      }
      while((_Bool)0);
    }
    while((_Bool)1);
    do
    {
      unsigned long int BYTES = (unsigned long int)(nlits + 1) * sizeof(signed int) /*4ul*/ ;
      void *return_value_malloc_24;
      return_value_malloc_24=malloc(BYTES);
      assumption = (signed int *)return_value_malloc_24;
      if(assumption == ((signed int *)NULL))
      {
        die("out of memory");
        exit(1);
      }

      memset((void *)assumption, 0, BYTES);
      do
      {
        allocated = allocated + BYTES;
        if(!(maxallocated >= allocated))
          maxallocated = allocated;

      }
      while((_Bool)0);
    }
    while((_Bool)0);
    i = 0;
    for( ; !(i >= nlits); i = i + 1)
      assumption[(signed long int)i] = lits[(signed long int)i];
    do
    {
      if(nassumptions >= szassumptions)
        do
        {
          unsigned long int parse__1__9__1__oldbytes;
          unsigned long int parse__1__9__1__newbytes;
          parse__1__9__1__oldbytes = (unsigned long int)szassumptions * sizeof(signed int *) /*8ul*/ ;
          do
            allocated = allocated - parse__1__9__1__oldbytes;
          while((_Bool)0);
          szassumptions = szassumptions != 0 ? 2 * szassumptions : 1;
          parse__1__9__1__newbytes = (unsigned long int)szassumptions * sizeof(signed int *) /*8ul*/ ;
          void *return_value_realloc_25;
          return_value_realloc_25=realloc((void *)assumptions, parse__1__9__1__newbytes);
          assumptions = (signed int **)return_value_realloc_25;
          if(assumptions == ((signed int **)NULL))
            die("out of memory");

          do
          {
            allocated = allocated + parse__1__9__1__newbytes;
            if(!(maxallocated >= allocated))
              maxallocated = allocated;

          }
          while((_Bool)0);
        }
        while((_Bool)0);

      tmp_post_26 = nassumptions;
      nassumptions = nassumptions + 1;
      assumptions[(signed long int)tmp_post_26] = assumption;
    }
    while((_Bool)0);
    nlits = 0;
    do
    {

    NEXT:
      ;
      ch=next();
    }
    while(ch == 9 || ch == 10 || ch == 13 || ch == 32);
    if(ch == -1)
      goto DONE;

    if(ch == 45)
      tmp_if_expr_28 = (_Bool)1;

    else
    {
      return_value___ctype_b_loc_27=__ctype_b_loc();
      tmp_if_expr_28 = ((signed int)(*return_value___ctype_b_loc_27)[(signed long int)(signed int)ch] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_28)
      break;

  }
  if(!(ch == 97))
    perr("expected literal, 'a' or end-of-file");

  goto ASSUMPTIONS;

DONE:
  ;
  msg(((struct Worker *)NULL), 1, "maximum variable %d in %d clauses", nvars, nclauses);
  msg(((struct Worker *)NULL), 1, "parsed %d assumptions", nassumptions);
  nvars = nvars + 1;
  do
  {
    unsigned long int parse__1__10__BYTES = (unsigned long int)nassumptions * sizeof(double) /*8ul*/ ;
    void *return_value_malloc_29;
    return_value_malloc_29=malloc(parse__1__10__BYTES);
    times = (double *)return_value_malloc_29;
    if(times == ((double *)NULL))
    {
      die("out of memory");
      exit(1);
    }

    memset((void *)times, 0, parse__1__10__BYTES);
    do
    {
      allocated = allocated + parse__1__10__BYTES;
      if(!(maxallocated >= allocated))
        maxallocated = allocated;

    }
    while((_Bool)0);
  }
  while((_Bool)0);
  i = 0;
  for( ; !(i >= nassumptions); i = i + 1)
    times[(signed long int)i] = (double)-1;
}

// perr
// file ilingeling.c line 454
static void perr(const char *fmt, ...)
{
  void **ap;
  fprintf(stderr, "%s:%d: ", inputname, lineno);
  ap = (void **)&fmt;
  vfprintf(stderr, fmt, ap);
  fputc(10, stderr);
  fflush(stderr);
  exit(1);
}

// progress
// file ilingeling.c line 196
static void progress(signed int pmille, signed int total, signed int max, double avg, signed int nl)
{
  signed int ch;
  signed int i;
  signed int lim;
  signed int eta;
  char fmt[10l];
  double rem;
  msglock(NULL);
  signed int return_value_isatty_1;
  return_value_isatty_1=isatty(1);
  if(!(return_value_isatty_1 == 0))
    fputc(13, stdout);

  lim = 10;
  i = 1;
  for( ; !(i >= 11) && !(lim >= max); i = i + 1)
    lim = lim * 10;
  sprintf(fmt, "c %%0%dd", i);
  printf(fmt, total);
  printf(" / %d |", max);
  i = 0;
  for( ; !(i >= pmille / 50); i = i + 1)
    fputc(61, stdout);
  if(total == max)
    ch = 61;

  else
    switch(pmille % 4)
    {
      case 1:
      {
        ch = 92;
        break;
      }
      case 2:
      {
        ch = 124;
        break;
      }
      case 3:
      {
        ch = 47;
        break;
      }
      default:
        ch = 45;
    }
  signed int tmp_post_2 = i;
  i = i + 1;
  if(!(tmp_post_2 >= 20))
    fputc(ch, stdout);

  signed int tmp_post_3;
  do
  {
    tmp_post_3 = i;
    i = i + 1;
    if(tmp_post_3 >= 20)
      break;

    fputc(45, stdout);
  }
  while((_Bool)1);
  printf("| %3d%%", pmille / 10);
  printf(" %.4f sec/cube", avg);
  if(total >= max)
    eta = 0;

  else
  {
    rem = (double)(max - total) * avg;
    if(rem >= 3.600000e+5)
      eta = 0x7fffffff;

    else
      eta = (signed int)rem;
  }
  if(!(eta >= 0x7fffffff))
  {
    if(eta >= 3601)
    {
      printf("%02d:", eta / 3600);
      eta = eta % 3600;
    }

    else
      printf("   ");
    printf("%02d:%02d ETS", eta / 60, eta % 60);
  }

  else
    printf("   --:-- ETS");
  _Bool tmp_if_expr_5;
  signed int return_value_isatty_4;
  if(!(nl == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_isatty_4=isatty(1);
    tmp_if_expr_5 = !(return_value_isatty_4 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    fputc(10, stdout);

  fflush(stdout);
  msgunlock(NULL);
}

// reset
// file ilingeling.c line 436
static void reset(void)
{
  signed int i;
  signed int *p;
  signed int *a;
  if(!(vals == ((signed char *)NULL)))
    do
    {
      unsigned long int reset__1__1__BYTES = (unsigned long int)nvars * sizeof(signed char) /*1ul*/ ;
      do
        allocated = allocated - reset__1__1__BYTES;
      while((_Bool)0);
      free((void *)vals);
      vals = ((signed char *)NULL);
    }
    while((_Bool)0);

  i = 0;
  for( ; !(i >= nworkers); i = i + 1)
    lglrelease((workers + (signed long int)i)->lgl);
  do
  {
    unsigned long int reset__1__3__BYTES = (unsigned long int)nworkers * sizeof(struct Worker) /*104ul*/ ;
    do
      allocated = allocated - reset__1__3__BYTES;
    while((_Bool)0);
    free((void *)workers);
    workers = ((struct Worker *)NULL);
  }
  while((_Bool)0);
  i = 0;
  for( ; !(i >= nassumptions); i = i + 1)
  {
    a = assumptions[(signed long int)i];
    p = a;
    for( ; !(*p == 0); p = p + 1l)
      ;
    do
    {
      unsigned long int reset__1__4__1__2__BYTES = (unsigned long int)((p - a) + (signed long int)1) * sizeof(signed int) /*4ul*/ ;
      do
        allocated = allocated - reset__1__4__1__2__BYTES;
      while((_Bool)0);
      free((void *)a);
      a = ((signed int *)NULL);
    }
    while((_Bool)0);
  }
  do
  {
    unsigned long int reset__1__5__BYTES = (unsigned long int)szassumptions * sizeof(signed int *) /*8ul*/ ;
    do
      allocated = allocated - reset__1__5__BYTES;
    while((_Bool)0);
    free((void *)assumptions);
    assumptions = ((signed int **)NULL);
  }
  while((_Bool)0);
  do
  {
    unsigned long int reset__1__6__BYTES = (unsigned long int)nassumptions * sizeof(double) /*8ul*/ ;
    do
      allocated = allocated - reset__1__6__BYTES;
    while((_Bool)0);
    free((void *)times);
    times = ((double *)NULL);
  }
  while((_Bool)0);
  do
  {
    unsigned long int reset__1__7__BYTES = (unsigned long int)szlits * sizeof(signed int) /*4ul*/ ;
    do
      allocated = allocated - reset__1__7__BYTES;
    while((_Bool)0);
    free((void *)lits);
    lits = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    unsigned long int BYTES = (unsigned long int)szvars * sizeof(signed int) /*4ul*/ ;
    do
      allocated = allocated - BYTES;
    while((_Bool)0);
    free((void *)used);
    used = ((signed int *)NULL);
  }
  while((_Bool)0);
  if(!(allocated == 0ul))
    warn("internal memory leak of %lld bytes", (signed long long int)allocated);

}

// resetsighandlers
// file ilingeling.c line 724
static void resetsighandlers(void)
{
  signal(2, sig_int_handler);
  signal(11, sig_segv_handler);
  signal(6, sig_abrt_handler);
  signal(15, sig_term_handler);
}

// sat
// file ilingeling.c line 263
static signed int sat(struct Worker *w)
{
  signed int res;
  char name[100l];
  struct LGL *forked;
  if(dofork >= 1)
    lglsetopt(w->lgl, "clim", 20000);

  res=lglsat(w->lgl);
  signed int return_value_justreturn_18;
  signed int tmp_post_1;
  signed int return_value_justreturn_17;
  signed int tmp_post_9;
  if(res == 0)
  {
    return_value_justreturn_18=justreturn(w);
    if(return_value_justreturn_18 == 0)
    {
      msg(w, 1, "forking after %d conflicts", 20000);
      forked=lglfork(w->lgl, 0);
      initlgl(forked, w, 0);
      if(dofork >= 2)
        lglsetopt(forked, "clim", 100000);

      tmp_post_1 = w->forked.count;
      w->forked.count = w->forked.count + 1;
      sprintf(name, "c F%d ", tmp_post_1);
      lglsetprefix(forked, name);
      signed int return_value_pthread_mutex_lock_2;
      return_value_pthread_mutex_lock_2=pthread_mutex_lock(&w->forked.lock);
      if(!(return_value_pthread_mutex_lock_2 == 0))
        warn("worker %d failed to lock 'forked' mutex", (signed int)(w - workers));

      w->forked.lgl = forked;
      signed int return_value_pthread_mutex_unlock_3;
      return_value_pthread_mutex_unlock_3=pthread_mutex_unlock(&w->forked.lock);
      if(!(return_value_pthread_mutex_unlock_3 == 0))
        warn("worker %d failed to unlock 'forked' mutex", (signed int)(w - workers));

      lglsat(forked);
      signed int return_value_pthread_mutex_lock_4;
      return_value_pthread_mutex_lock_4=pthread_mutex_lock(&w->forked.lock);
      if(!(return_value_pthread_mutex_lock_4 == 0))
        warn("worker %d failed to lock 'forked' mutex", (signed int)(w - workers));

      w->forked.lgl = ((struct LGL *)NULL);
      signed long int return_value_lglgetdecs_5;
      return_value_lglgetdecs_5=lglgetdecs(forked);
      w->forked.decs = w->forked.decs + return_value_lglgetdecs_5;
      signed long int return_value_lglgetconfs_6;
      return_value_lglgetconfs_6=lglgetconfs(forked);
      w->forked.confs = w->forked.confs + return_value_lglgetconfs_6;
      signed long int return_value_lglgetprops_7;
      return_value_lglgetprops_7=lglgetprops(forked);
      w->forked.props = w->forked.props + return_value_lglgetprops_7;
      signed int return_value_pthread_mutex_unlock_8;
      return_value_pthread_mutex_unlock_8=pthread_mutex_unlock(&w->forked.lock);
      if(!(return_value_pthread_mutex_unlock_8 == 0))
        warn("worker %d failed to unlock 'forked' mutex", (signed int)(w - workers));

      if(!(statsfile == ((struct _IO_FILE *)NULL)))
      {
        lglsetout(forked, statsfile);
        lglstats(forked);
        lglsetout(forked, stdout);
      }

      msg(w, 1, "joining forked solver");
      res=lgljoin(w->lgl, forked);
      if(res == 0)
      {
        return_value_justreturn_17=justreturn(w);
        if(return_value_justreturn_17 == 0)
        {
          msg(w, 1, "brute forking after %d conflicts", 100000);
          forked=lglbrutefork(w->lgl, 0);
          lglsetid(forked, (signed int)(w - workers), nworkers);
          initlgl(forked, w, 0);
          tmp_post_9 = w->forked.bcount;
          w->forked.bcount = w->forked.bcount + 1;
          sprintf(name, "c B%d ", tmp_post_9);
          lglsetprefix(forked, name);
          signed int return_value_pthread_mutex_lock_10;
          return_value_pthread_mutex_lock_10=pthread_mutex_lock(&w->forked.lock);
          if(!(return_value_pthread_mutex_lock_10 == 0))
            warn("worker %d failed to lock '(brute) forked' mutex", (signed int)(w - workers));

          w->forked.lgl = forked;
          signed int return_value_pthread_mutex_unlock_11;
          return_value_pthread_mutex_unlock_11=pthread_mutex_unlock(&w->forked.lock);
          if(!(return_value_pthread_mutex_unlock_11 == 0))
            warn("worker %d failed to unlock '(brute) forked' mutex", (signed int)(w - workers));

          lglsat(forked);
          signed int return_value_pthread_mutex_lock_12;
          return_value_pthread_mutex_lock_12=pthread_mutex_lock(&w->forked.lock);
          if(!(return_value_pthread_mutex_lock_12 == 0))
            warn("worker %d failed to lock '(brute) forked' mutex", (signed int)(w - workers));

          w->forked.lgl = ((struct LGL *)NULL);
          signed long int return_value_lglgetdecs_13;
          return_value_lglgetdecs_13=lglgetdecs(forked);
          w->forked.decs = w->forked.decs + return_value_lglgetdecs_13;
          signed long int return_value_lglgetconfs_14;
          return_value_lglgetconfs_14=lglgetconfs(forked);
          w->forked.confs = w->forked.confs + return_value_lglgetconfs_14;
          signed long int return_value_lglgetprops_15;
          return_value_lglgetprops_15=lglgetprops(forked);
          w->forked.props = w->forked.props + return_value_lglgetprops_15;
          signed int return_value_pthread_mutex_unlock_16;
          return_value_pthread_mutex_unlock_16=pthread_mutex_unlock(&w->forked.lock);
          if(!(return_value_pthread_mutex_unlock_16 == 0))
            warn("worker %d failed to unlock '(brute) forked' mutex", (signed int)(w - workers));

          if(!(statsfile == ((struct _IO_FILE *)NULL)))
          {
            lglsetout(forked, statsfile);
            lglstats(forked);
            lglsetout(forked, stdout);
          }

          msg(w, 1, "joining brute forked solver");
          res=lgljoin(w->lgl, forked);
        }

      }

    }

  }

  return res;
}

// setsighandlers
// file ilingeling.c line 751
static void setsighandlers(void)
{
  sig_int_handler=signal(2, catchsig);
  sig_segv_handler=signal(11, catchsig);
  sig_abrt_handler=signal(6, catchsig);
  sig_term_handler=signal(15, catchsig);
}

// start
// file ilingeling.c line 587
static void start(void)
{
  struct Worker *w = workers;
  for( ; !(w >= workers + (signed long int)nworkers); w = w + 1l)
  {
    signed int return_value_pthread_create_1;
    return_value_pthread_create_1=pthread_create(&w->thread, ((const union pthread_attr_t *)NULL), work, (void *)w);
    if(!(return_value_pthread_create_1 == 0))
      die("failed to create worker thread %d", (signed int)(w - workers));

  }
}

// stats
// file ilingeling.c line 627
static void stats(void)
{
  signed long int decs = (signed long int)0;
  signed long int confs = (signed long int)0;
  signed long int props = (signed long int)0;
  double mb = (double)maxallocated / (double)(1 << 20);
  double wct;
  wct=getime();
  double prt;
  prt=lglprocesstime();
  struct _IO_FILE *file = statsfile != ((struct _IO_FILE *)NULL) ? statsfile : stdout;
  double sum;
  double t;
  double min;
  double max;
  double avg;
  double std;
  signed int i;
  signed int n;
  i = 0;
  for( ; !(i >= nworkers); i = i + 1)
    lglflushtimers((workers + (signed long int)i)->lgl);
  i = 0;
  for( ; !(i >= nworkers); i = i + 1)
  {
    lglflushtimers((workers + (signed long int)i)->lgl);
    fprintf(file, "c\n");
    fprintf(file, "c ---------[worker %d stats]------------------\n", i);
    fprintf(file, "c\n");
    lglsetout((workers + (signed long int)i)->lgl, file);
    lglstats((workers + (signed long int)i)->lgl);
    lglsetout((workers + (signed long int)i)->lgl, stdout);
    double return_value_lglmb_1;
    return_value_lglmb_1=lglmb((workers + (signed long int)i)->lgl);
    mb = mb + return_value_lglmb_1;
    signed long int return_value_lglgetdecs_2;
    return_value_lglgetdecs_2=lglgetdecs((workers + (signed long int)i)->lgl);
    decs = decs + return_value_lglgetdecs_2;
    signed long int return_value_lglgetconfs_3;
    return_value_lglgetconfs_3=lglgetconfs((workers + (signed long int)i)->lgl);
    confs = confs + return_value_lglgetconfs_3;
    signed long int return_value_lglgetprops_4;
    return_value_lglgetprops_4=lglgetprops((workers + (signed long int)i)->lgl);
    props = props + return_value_lglgetprops_4;
    signed int return_value_pthread_mutex_lock_5;
    return_value_pthread_mutex_lock_5=pthread_mutex_lock(&(workers + (signed long int)i)->forked.lock);
    if(!(return_value_pthread_mutex_lock_5 == 0))
      warn("worker failed to lock 'forked' mutex");

    if(!((workers + (signed long int)i)->forked.lgl == ((struct LGL *)NULL)))
    {
      fprintf(file, "c ---------[forked worker %d dstats]----------\n", i);
      fprintf(file, "c\n");
      lglsetout((workers + (signed long int)i)->forked.lgl, file);
      lglstats((workers + (signed long int)i)->forked.lgl);
      lglsetout((workers + (signed long int)i)->forked.lgl, stdout);
      double return_value_lglmb_6;
      return_value_lglmb_6=lglmb((workers + (signed long int)i)->forked.lgl);
      mb = mb + return_value_lglmb_6;
      signed long int return_value_lglgetdecs_7;
      return_value_lglgetdecs_7=lglgetdecs((workers + (signed long int)i)->forked.lgl);
      decs = decs + return_value_lglgetdecs_7;
      signed long int return_value_lglgetconfs_8;
      return_value_lglgetconfs_8=lglgetconfs((workers + (signed long int)i)->forked.lgl);
      confs = confs + return_value_lglgetconfs_8;
      signed long int return_value_lglgetprops_9;
      return_value_lglgetprops_9=lglgetprops((workers + (signed long int)i)->forked.lgl);
      props = props + return_value_lglgetprops_9;
    }

    decs = decs + (workers + (signed long int)i)->forked.decs;
    confs = confs + (workers + (signed long int)i)->forked.confs;
    props = props + (workers + (signed long int)i)->forked.props;
    signed int return_value_pthread_mutex_unlock_10;
    return_value_pthread_mutex_unlock_10=pthread_mutex_unlock(&(workers + (signed long int)i)->forked.lock);
    if(!(return_value_pthread_mutex_unlock_10 == 0))
      warn("worker failed to lock 'forked' mutex");

  }
  fprintf(file, "c\n");
  fprintf(file, "c ---------[global-stats]-------------------------\n");
  fprintf(file, "c\n");
  statsps(file, "scheduled jobs", (signed long long int)queue, wct);
  fprintf(file, "c %d failed assumptions %.0f%% out of %d\n", redassumptions, sumassumptions != 0 ? (100.0 * (double)redassumptions) / (double)sumassumptions : (double)0, sumassumptions);
  fprintf(file, "c\n");
  statsps(file, "conflicts", confs, wct);
  statsps(file, "decisions", decs, wct);
  statsps(file, "propagations", props, wct);
  fprintf(file, "c wall clock time %.1f seconds\n", wct);
  fprintf(file, "c process time %.1f seconds\n", prt);
  fprintf(file, "c utilization %.0f%%\n", wct > (double)0 ? 100.0 * ((prt / wct) / (double)nworkers) : 0.0);
  fflush(file);
  n = 0;
  sum = (double)0;
  min = (double)-1;
  max = min;
  i = 0;
  signed int tmp_post_11;
  for( ; !(i >= nassumptions); i = i + 1)
  {
    t = times[(signed long int)i];
    if(!(t < 0.000000))
    {
      sum = sum + t;
      tmp_post_11 = n;
      n = n + 1;
      times[(signed long int)tmp_post_11] = t;
      if(min < 0.000000 || t < min)
        min = t;

      if(max < 0.000000 || t > max)
        max = t;

    }

  }
  if(!(n == 0))
  {
    fprintf(file, "c\n");
    avg = sum / (double)n;
    fprintf(file, "c %d finished jobs in average time %.3f\n", n, avg);
    fprintf(file, "c time: sum %.3f, min %.3f, max %.3f\n", sum, min, max);
    std = (double)0;
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      t = times[(signed long int)i] - avg;
      std = std + t * t;
    }
    std=sqrt(std);
    qsort((void *)times, (unsigned long int)n, sizeof(double *) /*8ul*/ , cmpdblptr);
    fprintf(file, "c time: median %.3f, std dve %.3f\n", times[(signed long int)(n / 2)], std);
  }

  fflush(file);
}

// statsps
// file ilingeling.c line 608
static void statsps(struct _IO_FILE *file, const char *name, signed long long int stats, double time)
{
  const char *scale;
  if(stats >= 10000001l)
  {
    scale = " million";
    stats = stats / (signed long long int)1000000;
  }

  else
    if(stats >= 10001l)
    {
      scale = " thousand";
      stats = stats / (signed long long int)1000;
    }

    else
      scale = "";
  fprintf(file, "c %lld%s %s, %.1f%s per second\n", stats, scale, name, time > (double)0 ? (double)stats / time : 0.0, scale);
}

// stop
// file ilingeling.c line 595
static void stop(void)
{
  struct Worker *w;
  double avg;
  w = workers;
  signed int return_value_pthread_join_1;
  for( ; !(w >= workers + (signed long int)nworkers); w = w + 1l)
  {
    return_value_pthread_join_1=pthread_join(w->thread, ((void **)NULL));
    if(!(return_value_pthread_join_1 == 0))
      die("failed to join worker %d", (signed int)(w - workers));

  }
  if(!(bar == 0))
  {
    avg = finished != 0 ? sumtimes / (double)finished : 0.0;
    progress((1000 * finished) / nassumptions, finished, nassumptions, avg, 1);
  }

  msg(((struct Worker *)NULL), 1, "joined all %d workers", nworkers);
}

// term
// file ilingeling.c line 183
static signed int term(void *voidptr)
{
  struct Worker *w = (struct Worker *)voidptr;
  signed int res;
  msg(w, 3, "checking early termination");
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&donemutex);
  if(!(return_value_pthread_mutex_lock_1 == 0))
    warn("failed to lock 'done' mutex in termination check");

  res = done;
  signed int return_value_pthread_mutex_unlock_2;
  return_value_pthread_mutex_unlock_2=pthread_mutex_unlock(&donemutex);
  if(!(return_value_pthread_mutex_unlock_2 == 0))
    warn("failed to unlock 'done' mutex in termination check");

  msg(w, 3, "early termination check %s", res != 0 ? "succeeded" : "failed");
  return res;
}

// tolower
// file /usr/include/ctype.h line 215
static inline signed int tolower(signed int __c)
{
  signed int tmp_if_expr_2;
  const signed int **return_value___ctype_tolower_loc_1;
  if(__c >= -128 && !(__c >= 256))
  {
    return_value___ctype_tolower_loc_1=__ctype_tolower_loc();
    tmp_if_expr_2 = (*return_value___ctype_tolower_loc_1)[(signed long int)__c];
  }

  else
    tmp_if_expr_2 = __c;
  return tmp_if_expr_2;
}

// toupper
// file /usr/include/ctype.h line 221
static inline signed int toupper(signed int __c)
{
  signed int tmp_if_expr_2;
  const signed int **return_value___ctype_toupper_loc_1;
  if(__c >= -128 && !(__c >= 256))
  {
    return_value___ctype_toupper_loc_1=__ctype_toupper_loc();
    tmp_if_expr_2 = (*return_value___ctype_toupper_loc_1)[(signed long int)__c];
  }

  else
    tmp_if_expr_2 = __c;
  return tmp_if_expr_2;
}

// vprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 36
static inline signed int vprintf(const char * restrict __fmt, void **__arg)
{
  signed int return_value_vfprintf_1;
  return_value_vfprintf_1=vfprintf(stdout, __fmt, __arg);
  return return_value_vfprintf_1;
}

// warn
// file ilingeling.c line 157
static void warn(const char *fmt, ...)
{
  void **ap;
  fputs("*** [ilingeling] warning: ", stderr);
  ap = (void **)&fmt;
  vfprintf(stderr, fmt, ap);
  ap = ((void **)NULL);
  fputc(10, stderr);
  fflush(stderr);
}

// work
// file ilingeling.c line 350
static void * work(void *voidptr)
{
  signed int i;
  signed int last;
  signed int pm;
  signed int lm;
  signed int count;
  signed int lit;
  signed int idx;
  signed int *a;
  signed int *p;
  signed int size;
  signed int red;
  signed int fin;
  double work__1__start;
  double end;
  double delta;
  double avg;
  struct Worker *w = (struct Worker *)voidptr;
  msg(w, 1, "running");
  signed int return_value_lglfailed_5;
  do
  {
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&queuemutex);
    if(!(return_value_pthread_mutex_lock_1 == 0))
      die("worker %d failed to lock 'queue' mutex", (signed int)(w - workers));

    last = queue;
    if(!(last >= nassumptions))
      queue = queue + 1;

    signed int return_value_pthread_mutex_unlock_2;
    return_value_pthread_mutex_unlock_2=pthread_mutex_unlock(&queuemutex);
    if(!(return_value_pthread_mutex_unlock_2 == 0))
      die("worker %d failed to unlock 'queue' mutex", (signed int)(w - workers));

    if(last == nassumptions)
    {

    DONE:
      ;
      if(bar == 0)
        msg(w, 1, "done");

      return NULL;
    }

    msg(w, 2, "got job %d", last);
    count = 0;
    i = w->last + 1;
    for( ; last >= i; i = i + 1)
    {
      a = assumptions[(signed long int)i];
      if(!(addassumptions == 0) && !(i >= last))
      {
        p = a;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          lgladd(w->lgl, -lit);
          p = p + 1l;
        }
        while((_Bool)1);
        lgladd(w->lgl, 0);
      }

      p = a;
      do
      {
        lit = *p;
        if(lit == 0)
          break;

        idx=abs(lit);
        if(used[(signed long int)idx] == i)
        {
          lglmelt(w->lgl, idx);
          count = count + 1;
        }

        p = p + 1l;
      }
      while((_Bool)1);
    }
    msg(w, 2, "melted %d variables", count);
    w->last = last;
    a = assumptions[(signed long int)w->last];
    p = a;
    do
    {
      lit = *p;
      if(lit == 0)
        break;

      lglassume(w->lgl, lit);
      p = p + 1l;
    }
    while((_Bool)1);
    work__1__start=getime();
    w->res=sat(w);
    end=getime();
    delta = end - work__1__start;
    delta = delta <= (double)0 ? (double)0 : delta;
    times[(signed long int)last] = delta;
    if(!(bar == 0))
    {
      pthread_mutex_lock(&finishedmutex);
      finished = finished + 1;
      fin = finished;
      sumtimes = sumtimes + delta;
      avg = sumtimes / (double)fin;
      pthread_mutex_unlock(&finishedmutex);
      pm = (1000 * (fin - 1)) / nassumptions;
      lm = (1000 * fin) / nassumptions;
      if(!(pm >= lm))
        progress(lm, fin, nassumptions, avg, 0);

    }

    if(w->res == 10)
    {
      if(bar == 0)
        msg(w, 1, "job %d SATISFIABLE", last);

      signed int return_value_pthread_mutex_lock_3;
      return_value_pthread_mutex_lock_3=pthread_mutex_lock(&donemutex);
      if(!(return_value_pthread_mutex_lock_3 == 0))
        warn("worker %d failed to lock 'done' mutex", (signed int)(w - workers));

      done = 1;
      signed int return_value_pthread_mutex_unlock_4;
      return_value_pthread_mutex_unlock_4=pthread_mutex_unlock(&donemutex);
      if(!(return_value_pthread_mutex_unlock_4 == 0))
        warn("worker %d failed to unlock 'done' mutex", (signed int)(w - workers));

      goto DONE;
    }

    else
      if(w->res == 20)
      {
        red = 0;
        p = a;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          return_value_lglfailed_5=lglfailed(w->lgl, lit);
          if(!(return_value_lglfailed_5 == 0))
            red = red + 1;

          p = p + 1l;
        }
        while((_Bool)1);
        size = (signed int)(p - a);
        sumassumptions = sumassumptions + size;
        redassumptions = redassumptions + red;
        if(bar == 0)
          msg(w, 1, "job %d UNSATISFIABLE (%d failed / %d) in %.3f seconds", last, red, size, delta);

        lglflushcache(w->lgl);
      }

      else
      {
        if(bar == 0)
          msg(w, 1, "job %d UNKNOWN", last);

        goto DONE;
      }
  }
  while((_Bool)1);
}

