// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$18;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$16;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$3;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$21;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$2;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$10;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$14;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$12;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$20;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$11;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$17;

// tag-#anon#ST[SYM#tag-ip#'idi_ip'|]
// file /usr/include/netinet/ip_icmp.h line 185
struct anonymous$15;

// tag-#anon#ST[U16'source'||U16'dest'||U16'len'||U16'check'|]
// file /usr/include/netinet/udp.h line 67
struct anonymous$9;

// tag-#anon#ST[U16'uh_sport'||U16'uh_dport'||U16'uh_ulen'||U16'uh_sum'|]
// file /usr/include/netinet/udp.h line 60
struct anonymous$8;

// tag-#anon#ST[U32'its_otime'||U32'its_rtime'||U32'its_ttime'|]
// file /usr/include/netinet/ip_icmp.h line 179
struct anonymous$13;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$19;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$4;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$1;

// tag-#anon#UN[SYM#tag-#anon#ST[U16'uh_sport'||U16'uh_dport'||U16'uh_ulen'||U16'uh_sum'|]#'$anon0'||SYM#tag-#anon#ST[U16'source'||U16'dest'||U16'len'||U16'check'|]#'$anon1'|]
// file /usr/include/netinet/udp.h line 58
union anonymous$5;

// tag-#anon#UN[SYM#tag-#anon#ST[U32'its_otime'||U32'its_rtime'||U32'its_ttime'|]#'id_ts'||SYM#tag-#anon#ST[SYM#tag-ip#'idi_ip'|]#'id_ip'||SYM#tag-icmp_ra_addr#'id_radv'||U32'id_mask'||ARR1{U8}$U8$'id_data'|]
// file /usr/include/netinet/ip_icmp.h line 177
union anonymous$7;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$0;

// tag-#anon#UN[U8'ih_pptr'||SYM#tag-in_addr#'ih_gwaddr'||SYM#tag-ih_idseq#'ih_idseq'||U32'ih_void'||SYM#tag-ih_pmtu#'ih_pmtu'||SYM#tag-ih_rtradv#'ih_rtradv'|]
// file /usr/include/netinet/ip_icmp.h line 142
union anonymous$6;

// tag-DLT
// file ./fprobe.h line 26
struct DLT;

// tag-Flow
// file ./fprobe.h line 39
struct Flow;

// tag-Flow_F
// file ./fprobe.h line 77
struct Flow_F;

// tag-Flow_TL
// file ./fprobe.h line 88
struct Flow_TL;

// tag-Mem
// file ./mem.h line 37
struct Mem;

// tag-NetFlow
// file ./netflow.h line 233
struct NetFlow;

// tag-Time
// file ./fprobe.h line 34
struct Time;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-bpf_insn
// file /usr/include/pcap/bpf.h line 108
struct bpf_insn;

// tag-bpf_program
// file /usr/include/pcap/bpf.h line 106
struct bpf_program;

// tag-getopt_parms
// file ./my_getopt.h line 19
struct getopt_parms;

// tag-icmp
// file /usr/include/netinet/ip_icmp.h line 137
struct icmp;

// tag-icmp_ra_addr
// file /usr/include/netinet/ip_icmp.h line 131
struct icmp_ra_addr;

// tag-ih_idseq
// file /usr/include/netinet/ip_icmp.h line 146
struct ih_idseq;

// tag-ih_pmtu
// file /usr/include/netinet/ip_icmp.h line 154
struct ih_pmtu;

// tag-ih_rtradv
// file /usr/include/netinet/ip_icmp.h line 160
struct ih_rtradv;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-ip
// file /usr/include/netinet/ip.h line 107
struct ip;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pcap
// file /usr/include/pcap/pcap.h line 79
struct pcap;

// tag-pcap_pkthdr
// file /usr/include/pcap/pcap.h line 160
struct pcap_pkthdr;

// tag-peer
// file ./fprobe.h line 107
struct peer;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sched_param
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 72
struct sched_param;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/pcap/pcap.h line 231
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-udphdr
// file /usr/include/netinet/udp.h line 56
struct udphdr;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __fprintf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 85
extern signed int __fprintf_chk(struct _IO_FILE *, signed int, const char *, ...);
// __fread_alias
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 269
extern unsigned long int __fread_alias(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// __fread_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 266
extern unsigned long int __fread_chk(void *, unsigned long int, unsigned long int, unsigned long int, struct _IO_FILE *);
// __fread_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 273
extern unsigned long int __fread_chk_warn(void *, unsigned long int, unsigned long int, unsigned long int, struct _IO_FILE *);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __syslog_chk
// file /usr/include/x86_64-linux-gnu/bits/syslog.h line 24
extern void __syslog_chk(signed int, signed int, const char *, ...);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// chroot
// file /usr/include/unistd.h line 944
extern signed int chroot(const char *);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// cmpmtime
// file fprobe.c line 396
inline signed long int cmpmtime(struct Time *t1, struct Time *t2);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// copy_flow
// file fprobe.c line 414
inline void copy_flow(struct Flow *src, struct Flow *dst);
// crc16
// file hash.c line 26
unsigned short int crc16(unsigned short int crc, unsigned char val);
// emit_thread
// file fprobe.c line 731
void * emit_thread();
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// fill
// file fprobe.c line 572
void * fill(signed int fields, unsigned short int *format, struct Flow *flow, void *p);
// find
// file fprobe.c line 433
struct Flow * find(struct Flow *where, struct Flow *what, struct Flow ***prev);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf(struct _IO_FILE * restrict __stream, const char * restrict __fmt, ...);
// fprintf$link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf$link1(struct _IO_FILE * restrict __stream$link1, const char * restrict __fmt$link1, ...);
// fprintf$link2
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf$link2(struct _IO_FILE * restrict __stream$link2, const char * restrict __fmt$link2, ...);
// fread
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 282
static inline unsigned long int fread(void * restrict __ptr, unsigned long int __size, unsigned long int __n, struct _IO_FILE * restrict __stream);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// freopen
// file /usr/include/stdio.h line 278
extern struct _IO_FILE * freopen(const char *, const char *, struct _IO_FILE *);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// gettime
// file fprobe.c line 387
void gettime(struct Time *now);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuptime
// file fprobe.c line 402
unsigned int getuptime(struct Time *t);
// hash
// file ./hash.h line 49
unsigned short int hash(void *p, signed int size);
// hash_flow
// file fprobe.c line 408
unsigned short int hash_flow(struct Flow *flow);
// hash_init
// file ./hash.h line 50
void hash_init();
// inet_ntoa
// file /usr/include/arpa/inet.h line 53
extern char * inet_ntoa(struct in_addr);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mem_alloc
// file ./mem.h line 33
void * mem_alloc();
// mem_free
// file ./mem.h line 34
void mem_free(void *eptr);
// mem_init
// file ./mem.h line 35
signed int mem_init(unsigned int element, unsigned int bulk, unsigned int limit);
// memset
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 78
static inline void * memset(void *__dest, signed int __ch, unsigned long int __len);
// my_getopt
// file ./my_getopt.h line 26
signed int my_getopt(signed int argc, char * const *argv, struct getopt_parms *parms);
// my_log
// file ./my_log.h line 22
void my_log(unsigned int level, const char *format, ...);
// my_log_close
// file my_log.c line 35
void my_log_close(void);
// my_log_open
// file ./my_log.h line 20
void my_log_open(char *indent, unsigned int min_level, unsigned int flags);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// pcap_callback
// file fprobe.c line 966
void pcap_callback(unsigned char *useless, struct pcap_pkthdr *pkthdr, const unsigned char *packet);
// pcap_compile
// file /usr/include/pcap/pcap.h line 389
signed int pcap_compile(struct pcap *, struct bpf_program *, const char *, signed int, unsigned int);
// pcap_datalink
// file /usr/include/pcap/pcap.h line 396
signed int pcap_datalink(struct pcap *);
// pcap_fileno
// file /usr/include/pcap/pcap.h line 411
signed int pcap_fileno(struct pcap *);
// pcap_geterr
// file /usr/include/pcap/pcap.h line 387
char * pcap_geterr(struct pcap *);
// pcap_lookupdev
// file /usr/include/pcap/pcap.h line 274
char * pcap_lookupdev(char *);
// pcap_loop
// file /usr/include/pcap/pcap.h line 372
signed int pcap_loop(struct pcap *, signed int, void (*)(unsigned char *, struct pcap_pkthdr *, const unsigned char *), unsigned char *);
// pcap_open_live
// file /usr/include/pcap/pcap.h line 349
struct pcap * pcap_open_live(const char *, signed int, signed int, signed int, char *);
// pcap_open_offline
// file /usr/include/pcap/pcap.h line 353
struct pcap * pcap_open_offline(const char *, char *);
// pcap_setfilter
// file /usr/include/pcap/pcap.h line 379
signed int pcap_setfilter(struct pcap *, struct bpf_program *);
// pcap_thread
// file fprobe.c line 1165
void * pcap_thread();
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setschedparam
// file /usr/include/pthread.h line 323
extern signed int pthread_attr_setschedparam(union pthread_attr_t *, struct sched_param *);
// pthread_attr_setschedpolicy
// file /usr/include/pthread.h line 333
extern signed int pthread_attr_setschedpolicy(union pthread_attr_t *, signed int);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$1 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$1 *, union anonymous$0 *, struct timespec *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$0 *, const union anonymous$4 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$0 *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$21 *, struct anonymous$21 *);
// put_into
// file fprobe.c line 467
signed int put_into(struct Flow *flow, signed int flag);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// remove
// file /usr/include/stdio.h line 178
extern signed int remove(const char *);
// scan_thread
// file fprobe.c line 871
void * scan_thread();
// sched_get_priority_max
// file /usr/include/sched.h line 68
extern signed int sched_get_priority_max(signed int);
// sched_get_priority_min
// file /usr/include/sched.h line 71
extern signed int sched_get_priority_min(signed int);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$3 *, struct anonymous$3 *, struct anonymous$3 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// setgroups
// file /usr/include/grp.h line 179
extern signed int setgroups(unsigned long int, const unsigned int *);
// setregid
// file /usr/include/unistd.h line 722
extern signed int setregid(unsigned int, unsigned int);
// setreuid
// file /usr/include/unistd.h line 705
extern signed int setreuid(unsigned int, unsigned int);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuser
// file fprobe.c line 718
void setuser();
// setvbuf
// file /usr/include/stdio.h line 336
extern signed int setvbuf(struct _IO_FILE *, char *, signed int, unsigned long int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous$21 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$21 *);
// sighandler
// file fprobe.c line 373
void sighandler(signed int sig);
// snprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
static inline signed int snprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, ...);
// snprintf$link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
static inline signed int snprintf$link1(char * restrict __s$link1, unsigned long int __n$link1, const char * restrict __fmt$link1, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 31
static inline signed int sprintf(char * restrict __s, const char * restrict __fmt, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strcat
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 146
static inline char * strcat(char * restrict __dest, const char * restrict __src);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/bits/syslog.h line 29
static inline void syslog(signed int __pri, const char *__fmt, ...);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// unpending_thread
// file fprobe.c line 824
void * unpending_thread();
// usage
// file fprobe.c line 321
void usage();
// vsnprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 74
static inline signed int vsnprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, void **__ap);

struct anonymous$18
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$16
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$3
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$21
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$2
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$10
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$14
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$12
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$11
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$17
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$19
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$10 _kill;
  // _timer
  struct anonymous$11 _timer;
  // _rt
  struct anonymous$12 _rt;
  // _sigchld
  struct anonymous$14 _sigchld;
  // _sigfault
  struct anonymous$16 _sigfault;
  // _sigpoll
  struct anonymous$17 _sigpoll;
  // _sigsys
  struct anonymous$18 _sigsys;
};

struct anonymous$20
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$19 _sifields;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct ip
{
  // ip_hl
  unsigned int ip_hl : 4;
  // ip_v
  unsigned int ip_v : 4;
  // ip_tos
  unsigned char ip_tos;
  // ip_len
  unsigned short int ip_len;
  // ip_id
  unsigned short int ip_id;
  // ip_off
  unsigned short int ip_off;
  // ip_ttl
  unsigned char ip_ttl;
  // ip_p
  unsigned char ip_p;
  // ip_sum
  unsigned short int ip_sum;
  // ip_src
  struct in_addr ip_src;
  // ip_dst
  struct in_addr ip_dst;
};

struct anonymous$15
{
  // idi_ip
  struct ip idi_ip;
};

struct anonymous$9
{
  // source
  unsigned short int source;
  // dest
  unsigned short int dest;
  // len
  unsigned short int len;
  // check
  unsigned short int check;
};

struct anonymous$8
{
  // uh_sport
  unsigned short int uh_sport;
  // uh_dport
  unsigned short int uh_dport;
  // uh_ulen
  unsigned short int uh_ulen;
  // uh_sum
  unsigned short int uh_sum;
};

struct anonymous$13
{
  // its_otime
  unsigned int its_otime;
  // its_rtime
  unsigned int its_rtime;
  // its_ttime
  unsigned int its_ttime;
};

union anonymous
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$20 *, void *);
};

union anonymous$4
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$1
{
  // __data
  struct anonymous$2 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous$5
{
  // $anon0
  struct anonymous$8 $anon0;
  // $anon1
  struct anonymous$9 $anon1;
};

struct icmp_ra_addr
{
  // ira_addr
  unsigned int ira_addr;
  // ira_preference
  unsigned int ira_preference;
};

union anonymous$7
{
  // id_ts
  struct anonymous$13 id_ts;
  // id_ip
  struct anonymous$15 id_ip;
  // id_radv
  struct icmp_ra_addr id_radv;
  // id_mask
  unsigned int id_mask;
  // id_data
  unsigned char id_data[1l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ih_idseq
{
  // icd_id
  unsigned short int icd_id;
  // icd_seq
  unsigned short int icd_seq;
};

struct ih_pmtu
{
  // ipm_void
  unsigned short int ipm_void;
  // ipm_nextmtu
  unsigned short int ipm_nextmtu;
};

struct ih_rtradv
{
  // irt_num_addrs
  unsigned char irt_num_addrs;
  // irt_wpa
  unsigned char irt_wpa;
  // irt_lifetime
  unsigned short int irt_lifetime;
};

union anonymous$6
{
  // ih_pptr
  unsigned char ih_pptr;
  // ih_gwaddr
  struct in_addr ih_gwaddr;
  // ih_idseq
  struct ih_idseq ih_idseq;
  // ih_void
  unsigned int ih_void;
  // ih_pmtu
  struct ih_pmtu ih_pmtu;
  // ih_rtradv
  struct ih_rtradv ih_rtradv;
};

struct DLT
{
  // linktype
  signed int linktype;
  // offset_link
  unsigned int offset_link;
  // offset_nl
  unsigned int offset_nl;
  // offset_nl_nosnap
  unsigned int offset_nl_nosnap;
  // descr
  char *descr;
};

struct Time
{
  // sec
  signed long int sec;
  // usec
  signed long int usec;
};

struct Flow
{
  // sip
  struct in_addr sip;
  // dip
  struct in_addr dip;
  // proto
  unsigned char proto;
  // id
  unsigned short int id;
  // sp
  unsigned short int sp;
  // dp
  unsigned short int dp;
  // tos
  unsigned char tos;
  // tcp_flags
  unsigned char tcp_flags;
  // pkts
  unsigned long int pkts;
  // size
  unsigned long int size;
  // sizeF
  unsigned long int sizeF;
  // sizeP
  unsigned long int sizeP;
  // ctime
  struct Time ctime;
  // mtime
  struct Time mtime;
  // flags
  signed int flags;
  // next
  struct Flow *next;
};

struct Flow_F
{
  // sip
  struct in_addr sip;
  // dip
  struct in_addr dip;
  // proto
  unsigned char proto;
  // id
  unsigned short int id;
};

struct Flow_TL
{
  // sip
  struct in_addr sip;
  // dip
  struct in_addr dip;
  // proto
  unsigned char proto;
  // id
  unsigned short int id;
  // sp
  unsigned short int sp;
  // dp
  unsigned short int dp;
};

struct Mem
{
  // next
  struct Mem *next;
  // free
  unsigned int free;
  // first
  void *first;
  // last
  void *last;
};

struct NetFlow
{
  // Version
  unsigned int Version;
  // HeaderSize
  unsigned int HeaderSize;
  // MaxFlows
  unsigned int MaxFlows;
  // FlowSize
  unsigned int FlowSize;
  // SeqOffset
  unsigned int SeqOffset;
  // HeaderFields
  unsigned int HeaderFields;
  // HeaderFormat
  unsigned short int *HeaderFormat;
  // FlowFields
  unsigned int FlowFields;
  // FlowFormat
  unsigned short int *FlowFormat;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct bpf_insn
{
  // code
  unsigned short int code;
  // jt
  unsigned char jt;
  // jf
  unsigned char jf;
  // k
  unsigned int k;
};

struct bpf_program
{
  // bf_len
  unsigned int bf_len;
  // bf_insns
  struct bpf_insn *bf_insns;
};

struct getopt_parms
{
  // name
  char name;
  // flag
  signed int flag;
  // count
  signed int count;
  // arg
  char *arg;
};

struct icmp
{
  // icmp_type
  unsigned char icmp_type;
  // icmp_code
  unsigned char icmp_code;
  // icmp_cksum
  unsigned short int icmp_cksum;
  // icmp_hun
  union anonymous$6 icmp_hun;
  // icmp_dun
  union anonymous$7 icmp_dun;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct pcap_pkthdr
{
  // ts
  struct timeval ts;
  // caplen
  unsigned int caplen;
  // len
  unsigned int len;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct peer
{
  // sock
  signed int sock;
  // addr
  struct sockaddr_in addr;
  // laddr
  struct sockaddr_in laddr;
  // type
  signed int type;
  // seq
  unsigned int seq;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sched_param
{
  // __sched_priority
  signed int __sched_priority;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous __sigaction_handler;
  // sa_mask
  struct anonymous$21 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct udphdr
{
  // $anon0
  union anonymous$5 $anon0;
};


// NetFlow1
// file netflow.c line 111
struct NetFlow NetFlow1;
// NetFlow1_Flow
// file netflow.c line 22
static unsigned short int NetFlow1_Flow[19l] = { (unsigned short int)8, (unsigned short int)12, (unsigned short int)15, (unsigned short int)10, (unsigned short int)14, (unsigned short int)2, (unsigned short int)1, (unsigned short int)22, (unsigned short int)21, (unsigned short int)7, (unsigned short int)11, (unsigned short int)9002, (unsigned short int)4, (unsigned short int)5, (unsigned short int)6, (unsigned short int)9001, (unsigned short int)9001, (unsigned short int)9001, (unsigned short int)9003 };
// NetFlow1_Header
// file netflow.c line 14
static unsigned short int NetFlow1_Header[5l] = { (unsigned short int)1001, (unsigned short int)1002, (unsigned short int)1003, (unsigned short int)1004, (unsigned short int)1005 };
// NetFlow1
// file netflow.c line 111
struct NetFlow NetFlow1 = { .Version=(unsigned int)1, .HeaderSize=(unsigned int)16, .MaxFlows=(unsigned int)24,
    .FlowSize=(unsigned int)48, .SeqOffset=(unsigned int)0,
    .HeaderFields=(unsigned int)(sizeof(unsigned short int [5l]) /*10ul*/  / sizeof(unsigned short int) /*2ul*/ ), .HeaderFormat=NetFlow1_Header,
    .FlowFields=(unsigned int)(sizeof(unsigned short int [19l]) /*38ul*/  / sizeof(unsigned short int) /*2ul*/ ), .FlowFormat=NetFlow1_Flow };
// NetFlow5
// file netflow.c line 123
struct NetFlow NetFlow5;
// NetFlow5_Flow
// file netflow.c line 54
static unsigned short int NetFlow5_Flow[20l] = { (unsigned short int)8, (unsigned short int)12, (unsigned short int)15, (unsigned short int)10, (unsigned short int)14, (unsigned short int)2, (unsigned short int)1, (unsigned short int)22, (unsigned short int)21, (unsigned short int)7, (unsigned short int)11, (unsigned short int)9001, (unsigned short int)6, (unsigned short int)4, (unsigned short int)5, (unsigned short int)16, (unsigned short int)17, (unsigned short int)9, (unsigned short int)13, (unsigned short int)9002 };
// NetFlow5_Header
// file netflow.c line 42
static unsigned short int NetFlow5_Header[9l] = { (unsigned short int)1001, (unsigned short int)1002, (unsigned short int)1003, (unsigned short int)1004, (unsigned short int)1005, (unsigned short int)1006, (unsigned short int)38, (unsigned short int)39, (unsigned short int)9002 };
// NetFlow5
// file netflow.c line 123
struct NetFlow NetFlow5 = { .Version=(unsigned int)5, .HeaderSize=(unsigned int)24, .MaxFlows=(unsigned int)30,
    .FlowSize=(unsigned int)48, .SeqOffset=(unsigned int)16,
    .HeaderFields=(unsigned int)(sizeof(unsigned short int [9l]) /*18ul*/  / sizeof(unsigned short int) /*2ul*/ ), .HeaderFormat=NetFlow5_Header,
    .FlowFields=(unsigned int)(sizeof(unsigned short int [20l]) /*40ul*/  / sizeof(unsigned short int) /*2ul*/ ), .FlowFormat=NetFlow5_Flow };
// NetFlow7
// file netflow.c line 135
struct NetFlow NetFlow7;
// NetFlow7_Flow
// file netflow.c line 87
static unsigned short int NetFlow7_Flow[21l] = { (unsigned short int)8, (unsigned short int)12, (unsigned short int)15, (unsigned short int)10, (unsigned short int)14, (unsigned short int)2, (unsigned short int)1, (unsigned short int)22, (unsigned short int)21, (unsigned short int)7, (unsigned short int)11, (unsigned short int)1010, (unsigned short int)6, (unsigned short int)4, (unsigned short int)5, (unsigned short int)16, (unsigned short int)17, (unsigned short int)9, (unsigned short int)13, (unsigned short int)1011, (unsigned short int)1012 };
// NetFlow7_Header
// file netflow.c line 77
static unsigned short int NetFlow7_Header[7l] = { (unsigned short int)1001, (unsigned short int)1002, (unsigned short int)1003, (unsigned short int)1004, (unsigned short int)1005, (unsigned short int)1006, (unsigned short int)9003 };
// NetFlow7
// file netflow.c line 135
struct NetFlow NetFlow7 = { .Version=(unsigned int)7, .HeaderSize=(unsigned int)24, .MaxFlows=(unsigned int)27,
    .FlowSize=(unsigned int)52, .SeqOffset=(unsigned int)16,
    .HeaderFields=(unsigned int)(sizeof(unsigned short int [7l]) /*14ul*/  / sizeof(unsigned short int) /*2ul*/ ), .HeaderFormat=NetFlow7_Header,
    .FlowFields=(unsigned int)(sizeof(unsigned short int [21l]) /*42ul*/  / sizeof(unsigned short int) /*2ul*/ ), .FlowFormat=NetFlow7_Flow };
// active_lifetime
// file fprobe.c line 249
static signed int active_lifetime = 300;
// bulk_quantity
// file fprobe.c line 257
static unsigned int bulk_quantity = (unsigned int)10000;
// bulk_quantity$link1
// file mem.c line 29
static unsigned int bulk_quantity$link1;
// crc16_poly
// file hash.c line 22
static unsigned short int crc16_poly;
// crc16_table
// file hash.c line 24
static unsigned short int crc16_table[256l];
// dev
// file fprobe.c line 244
static char *dev;
// dlt
// file fprobe.c line 79
struct DLT dlt[32l] = { { .linktype=0, .offset_link=(unsigned int)0, .offset_nl=(unsigned int)4,
    .offset_nl_nosnap=(unsigned int)4, .descr="NULL" },
    { .linktype=1, .offset_link=(unsigned int)12, .offset_nl=(unsigned int)14,
    .offset_nl_nosnap=(unsigned int)17, .descr="EN10MB" },
    { .linktype=6, .offset_link=(unsigned int)14, .offset_nl=(unsigned int)22,
    .offset_nl_nosnap=(unsigned int)17, .descr="IEEE802" },
    { .linktype=7, .offset_link=(unsigned int)2, .offset_nl=(unsigned int)6,
    .offset_nl_nosnap=(unsigned int)6, .descr="ARCNET" },
    { .linktype=8, .offset_link=(unsigned int)-1, .offset_nl=(unsigned int)16,
    .offset_nl_nosnap=(unsigned int)16, .descr="SLIP" },
    { .linktype=9, .offset_link=(unsigned int)2, .offset_nl=(unsigned int)4,
    .offset_nl_nosnap=(unsigned int)4, .descr="PPP" },
    { .linktype=10, .offset_link=(unsigned int)13, .offset_nl=(unsigned int)21,
    .offset_nl_nosnap=(unsigned int)16, .descr="FDDI" },
    { .linktype=11, .offset_link=(unsigned int)0, .offset_nl=(unsigned int)8,
    .offset_nl_nosnap=(unsigned int)3, .descr="ATM_RFC1483" },
    { .linktype=12, .offset_link=(unsigned int)-1, .offset_nl=(unsigned int)0,
    .offset_nl_nosnap=(unsigned int)0, .descr="RAW" },
    { .linktype=15, .offset_link=(unsigned int)-1, .offset_nl=(unsigned int)24,
    .offset_nl_nosnap=(unsigned int)24, .descr="SLIP_BSDOS" },
    { .linktype=16, .offset_link=(unsigned int)5, .offset_nl=(unsigned int)24,
    .offset_nl_nosnap=(unsigned int)24, .descr="PPP_BSDOS" },
    { .linktype=19, .offset_link=(unsigned int)0, .offset_nl=(unsigned int)8,
    .offset_nl_nosnap=(unsigned int)3, .descr="ATM_CLIP" },
    { .linktype=50, .offset_link=(unsigned int)2, .offset_nl=(unsigned int)4,
    .offset_nl_nosnap=(unsigned int)4, .descr="PPP_SERIAL" },
    { .linktype=51, .offset_link=(unsigned int)6, .offset_nl=(unsigned int)8,
    .offset_nl_nosnap=(unsigned int)8, .descr="PPP_ETHER" },
    { .linktype=104, .offset_link=(unsigned int)2, .offset_nl=(unsigned int)4,
    .offset_nl_nosnap=(unsigned int)4, .descr="C_HDLC" },
    { .linktype=105, .offset_link=(unsigned int)24, .offset_nl=(unsigned int)32,
    .offset_nl_nosnap=(unsigned int)27, .descr="IEEE802_11" },
    { .linktype=108, .offset_link=(unsigned int)0, .offset_nl=(unsigned int)4,
    .offset_nl_nosnap=(unsigned int)4, .descr="LOOP" },
    { .linktype=113, .offset_link=(unsigned int)14, .offset_nl=(unsigned int)16,
    .offset_nl_nosnap=(unsigned int)16, .descr="LINUX_SLL" },
    { .linktype=114, .offset_link=(unsigned int)-1, .offset_nl=(unsigned int)0,
    .offset_nl_nosnap=(unsigned int)0, .descr="LTALK" },
    { .linktype=119, .offset_link=(unsigned int)(144 + 24), .offset_nl=(unsigned int)(144 + 30),
    .offset_nl_nosnap=(unsigned int)(144 + 27),
    .descr="PRISM_HEADER" },
    { .linktype=122, .offset_link=(unsigned int)16, .offset_nl=(unsigned int)24,
    .offset_nl_nosnap=(unsigned int)19, .descr="IP_OVER_FC" },
    { .linktype=123, .offset_link=(unsigned int)4, .offset_nl=(unsigned int)(4 + 8),
    .offset_nl_nosnap=(unsigned int)(4 + 3), .descr="SUNATM" },
    { .linktype=129, .offset_link=(unsigned int)4, .offset_nl=(unsigned int)8,
    .offset_nl_nosnap=(unsigned int)8, .descr="ARCNET_LINUX" },
    { .linktype=109, .offset_link=(unsigned int)0, .offset_nl=(unsigned int)12,
    .offset_nl_nosnap=(unsigned int)12, .descr="ENC" },
    { .linktype=107, .offset_link=(unsigned int)-1, .offset_nl=(unsigned int)0,
    .offset_nl_nosnap=(unsigned int)0, .descr="FRELAY" },
    { .linktype=127, .offset_link=(unsigned int)(64 + 24), .offset_nl=(unsigned int)(64 + 32),
    .offset_nl_nosnap=(unsigned int)(64 + 27), .descr="IEEE802_11_RADIO" },
    { .linktype=117, .offset_link=(unsigned int)0, .offset_nl=(unsigned int)28,
    .offset_nl_nosnap=(unsigned int)28, .descr="PFLOG" },
    { .linktype=144, .offset_link=(unsigned int)-1, .offset_nl=(unsigned int)-1,
    .offset_nl_nosnap=(unsigned int)-1, .descr="LINUX_IRDA" },
    { .linktype=138, .offset_link=(unsigned int)16, .offset_nl=(unsigned int)18,
    .offset_nl_nosnap=(unsigned int)0, .descr="APPLE_IP_OVER_IEEE1394" },
    { .linktype=163, .offset_link=(unsigned int)(64 + 24), .offset_nl=(unsigned int)(64 + 32),
    .offset_nl_nosnap=(unsigned int)(64 + 27), .descr="IEEE802_11_RADIO_AVS" },
    { .linktype=246, .offset_link=(unsigned int)-1, .offset_nl=(unsigned int)4,
    .offset_nl_nosnap=(unsigned int)4, .descr="PFSYNC" },
    { .linktype=-1, .offset_link=(unsigned int)-1, .offset_nl=(unsigned int)-1,
    .offset_nl_nosnap=(unsigned int)-1, .descr="UNKNOWN" } };
// element_size
// file mem.c line 28
static unsigned int element_size;
// element_table_size
// file mem.c line 33
static unsigned int element_table_size;
// emit_cond
// file fprobe.c line 309
static union anonymous$1 emit_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// emit_count
// file fprobe.c line 283
static unsigned int emit_count;
// emit_mutex
// file fprobe.c line 308
static union anonymous$0 emit_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// emit_packet
// file fprobe.c line 287
static unsigned char emit_packet[1500l];
// emit_rate_bytes
// file fprobe.c line 285
static unsigned int emit_rate_bytes;
// emit_rate_delay
// file fprobe.c line 285
static unsigned int emit_rate_delay;
// emit_sequence
// file fprobe.c line 284
static unsigned int emit_sequence;
// emit_time
// file fprobe.c line 286
static struct Time emit_time;
// emit_timeout
// file fprobe.c line 317
static signed int emit_timeout = 5;
// filter
// file fprobe.c line 245
static char *filter = "";
// flows
// file fprobe.c line 297
static struct Flow *flows[65536l];
// flows_emit
// file fprobe.c line 310
static struct Flow *flows_emit;
// flows_mutex
// file fprobe.c line 298
static union anonymous$0 flows_mutex[65536l];
// frag_lifetime
// file fprobe.c line 247
static signed int frag_lifetime = 30;
// free_elements
// file mem.c line 27
unsigned int free_elements;
// ident
// file fprobe.c line 312
static char ident[256l] = { 'f', 'p', 'r', 'o', 'b', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// inactive_lifetime
// file fprobe.c line 248
static signed int inactive_lifetime = 60;
// killed
// file fprobe.c line 316
static signed int killed;
// limit_memory
// file mem.c line 30
static unsigned int limit_memory;
// link_layer
// file fprobe.c line 264
static signed int link_layer;
// link_layer_size
// file fprobe.c line 264
static signed int link_layer_size = -1;
// log_dest
// file fprobe.c line 261
static unsigned int log_dest = (unsigned int)0x01;
// malloc_size
// file mem.c line 34
static unsigned int malloc_size;
// mem_index_table_size
// file mem.c line 32
static unsigned int mem_index_table_size;
// mem_mutex
// file mem.c line 23
static union anonymous$0 mem_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// my_log_flags
// file my_log.c line 21
static unsigned int my_log_flags;
// my_log_indent
// file my_log.c line 19
static char *my_log_indent;
// my_log_min_level
// file my_log.c line 20
static unsigned int my_log_min_level;
// my_log_names
// file my_log.c line 22
static char *my_log_names[8l] = { "EMERG", "ALERT", "CRIT", "ERR", "WARNING", "NOTICE", "INFO", "DEBUG" };
// netflow
// file fprobe.c line 259
static struct NetFlow *netflow;
// netflow
// file fprobe.c line 259
static struct NetFlow *netflow = &NetFlow5;
// npeers
// file fprobe.c line 293
static signed int npeers;
// npeers_rot
// file fprobe.c line 293
static signed int npeers_rot;
// off_nl
// file fprobe.c line 267
static signed int off_nl;
// off_tl
// file fprobe.c line 267
static signed int off_tl;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// opterr
// file /usr/include/getopt.h line 76
extern signed int opterr;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// parms
// file fprobe.c line 207
static struct getopt_parms parms[25l] = { { .name=(char)97, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)66, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)98, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)99, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)100, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)101, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)102, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)103, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)104, .flag=0, .count=0, .arg=((char *)NULL) },
    { .name=(char)105, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)75, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)107, .flag=0, .count=0, .arg=((char *)NULL) },
    { .name=(char)108, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)109, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)110, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)112, .flag=0, .count=0, .arg=((char *)NULL) },
    { .name=(char)113, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)114, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)83, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)115, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)116, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)117, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)118, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)120, .flag=0x1, .count=0, .arg=((char *)NULL) },
    { .name=(char)0, .flag=0, .count=0, .arg=((char *)NULL) } };
// pcap_handle
// file fprobe.c line 288
static struct pcap *pcap_handle;
// peers
// file fprobe.c line 294
static struct peer *peers;
// pending_head
// file fprobe.c line 305
static struct Flow *pending_head;
// pending_queue_length
// file fprobe.c line 258
static unsigned int pending_queue_length = (unsigned int)100;
// pending_tail
// file fprobe.c line 305
static struct Flow *pending_tail;
// pid
// file fprobe.c line 315
static signed int pid;
// pidfile
// file fprobe.c line 313
static struct _IO_FILE *pidfile;
// pidfilepath
// file fprobe.c line 314
static char *pidfilepath;
// promisc
// file fprobe.c line 243
static unsigned int promisc;
// pw
// file fprobe.c line 319
static struct passwd *pw = ((struct passwd *)NULL);
// root
// file mem.c line 25
static struct Mem *root;
// scan_cond
// file fprobe.c line 304
static union anonymous$1 scan_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// scan_frag_dreg
// file fprobe.c line 306
static struct Flow *scan_frag_dreg;
// scan_interval
// file fprobe.c line 246
static unsigned int scan_interval = (unsigned int)5;
// scan_mutex
// file fprobe.c line 303
static union anonymous$0 scan_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// sched_max
// file fprobe.c line 292
static signed int sched_max;
// sched_min
// file fprobe.c line 292
static signed int sched_min;
// schedp
// file fprobe.c line 291
static struct sched_param schedp;
// shuffle_table
// file hash.c line 23
static unsigned char shuffle_table[256l];
// sig_mask
// file fprobe.c line 290
static struct anonymous$21 sig_mask;
// sigs
// file fprobe.c line 295
static signed int sigs;
// snmp_input_index
// file fprobe.c line 262
static unsigned int snmp_input_index;
// snmp_output_index
// file fprobe.c line 263
static unsigned int snmp_output_index;
// sockbufsize
// file fprobe.c line 250
static signed int sockbufsize;
// start_time
// file fprobe.c line 265
static struct Time start_time;
// start_time_offset
// file fprobe.c line 266
static signed long int start_time_offset;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// thid
// file fprobe.c line 289
static unsigned long int thid;
// total_elements
// file mem.c line 26
unsigned int total_elements;
// total_memory
// file mem.c line 31
unsigned int total_memory;
// unpending_cond
// file fprobe.c line 301
static union anonymous$1 unpending_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// unpending_mutex
// file fprobe.c line 300
static union anonymous$0 unpending_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// unpending_timeout
// file fprobe.c line 317
static signed int unpending_timeout = 5;
// verbosity
// file fprobe.c line 260
static unsigned int verbosity = (unsigned int)6;

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32$1;
  return_value___builtin_bswap32$1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32$1;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1;
}

// cmpmtime
// file fprobe.c line 396
inline signed long int cmpmtime(struct Time *t1, struct Time *t2)
{
  return (t1->sec - t2->sec) * (signed long int)1000 + (t1->usec - t2->usec) / (signed long int)1000;
}

// copy_flow
// file fprobe.c line 414
inline void copy_flow(struct Flow *src, struct Flow *dst)
{
  dst->sip = src->sip;
  dst->dip = src->dip;
  dst->tos = src->tos;
  dst->proto = src->proto;
  dst->tcp_flags = src->tcp_flags;
  dst->id = src->id;
  dst->sp = src->sp;
  dst->dp = src->dp;
  dst->pkts = src->pkts;
  dst->size = src->size;
  dst->sizeF = src->sizeF;
  dst->sizeP = src->sizeP;
  dst->ctime = src->ctime;
  dst->mtime = src->mtime;
  dst->flags = src->flags;
}

// crc16
// file hash.c line 26
unsigned short int crc16(unsigned short int crc, unsigned char val)
{
  signed int i;
  crc = crc ^ (unsigned short int)((signed int)val << 8);
  i = 8;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = i;
    i = i - 1;
    if(tmp_post$1 == 0)
      break;

    crc = (unsigned short int)(((signed int)crc & 0x8000) != 0 ? (signed int)crc << 1 ^ (signed int)crc16_poly : (signed int)crc << 1);
  }
  while((_Bool)1);
  return crc;
}

// emit_thread
// file fprobe.c line 731
void * emit_thread()
{
  struct Flow *flow;
  void *p;
  struct timeval now;
  struct timespec timeout;
  signed int i;
  signed int ret;
  signed int sent = 0;
  signed int size;
  signed int delay;
  signed int peer_rot_cur;
  signed int peer_rot_work = 0;
  setuser();
  p = (void *)&emit_packet + (signed long int)netflow->HeaderSize;
  timeout.tv_nsec = (signed long int)0;
  signed int tmp_post$5;
  signed int return_value_nanosleep$3;
  signed int *return_value___errno_location$4;
  do
  {
    pthread_mutex_lock(&emit_mutex);
    while(flows_emit == ((struct Flow *)NULL))
    {
      gettimeofday(&now, ((struct timezone *)NULL));
      timeout.tv_sec = now.tv_sec + (signed long int)emit_timeout;
      signed int return_value_pthread_cond_timedwait$1;
      return_value_pthread_cond_timedwait$1=pthread_cond_timedwait(&emit_cond, &emit_mutex, &timeout);
      if(!(return_value_pthread_cond_timedwait$1 == 0))
      {
        if(!(emit_count == 0u))
        {
          pthread_mutex_unlock(&emit_mutex);
          goto sendit;
        }

      }

    }
    flow = flows_emit;
    flows_emit = flows_emit->next;
    pthread_mutex_unlock(&emit_mutex);
    if(emit_count == 0u)
    {
      gettime(&start_time);
      start_time.sec = start_time.sec - start_time_offset;
    }

    p=fill((signed int)netflow->FlowFields, netflow->FlowFormat, flow, p);
    mem_free((void *)flow);
    emit_count = emit_count + 1u;
    if(emit_count == netflow->MaxFlows)
    {

    sendit:
      ;
      gettime(&emit_time);
      p=fill((signed int)netflow->HeaderFields, netflow->HeaderFormat, ((struct Flow *)NULL), (void *)&emit_packet);
      size = (signed int)(netflow->HeaderSize + emit_count * netflow->FlowSize);
      peer_rot_cur = 0;
      i = 0;
      for( ; !(i >= npeers); i = i + 1)
      {
        if(!((peers + (signed long int)i)->type == 0))
        {
          if(!((peers + (signed long int)i)->type == 1))
            goto __CPROVER_DUMP_L13;

          tmp_post$5 = peer_rot_cur;
          peer_rot_cur = peer_rot_cur + 1;
          if(!(tmp_post$5 == peer_rot_work))
            goto __CPROVER_DUMP_L13;

        }


      sendreal:
        ;
        if(!(netflow->SeqOffset == 0u))
          *((unsigned int *)(emit_packet + (signed long int)netflow->SeqOffset))=__bswap_32((peers + (signed long int)i)->seq);

        signed long int return_value_send$2;
        return_value_send$2=send((peers + (signed long int)i)->sock, (const void *)emit_packet, (unsigned long int)size, 0);
        ret = (signed int)return_value_send$2;
        (peers + (signed long int)i)->seq = (peers + (signed long int)i)->seq + emit_count;
        if(!(emit_rate_bytes == 0u))
        {
          sent = sent + size;
          delay = (signed int)((unsigned int)sent / emit_rate_bytes);
          if(!(delay == 0))
          {
            sent = sent % (signed int)emit_rate_bytes;
            timeout.tv_sec = (signed long int)0;
            timeout.tv_nsec = (signed long int)(emit_rate_delay * (unsigned int)delay);
            do
            {
              return_value_nanosleep$3=nanosleep(&timeout, &timeout);
              if(!(return_value_nanosleep$3 == -1))
                break;

              return_value___errno_location$4=__errno_location();
              if(!(*return_value___errno_location$4 == 4))
                break;

            }
            while((_Bool)1);
          }

        }


      __CPROVER_DUMP_L13:
        ;
      }
      if(!(npeers_rot == 0))
        peer_rot_work = (peer_rot_work + 1) % npeers_rot;

      emit_sequence = emit_sequence + emit_count;
      emit_count = (unsigned int)0;
    }

  }
  while((_Bool)1);
}

// fill
// file fprobe.c line 572
void * fill(signed int fields, unsigned short int *format, struct Flow *flow, void *p)
{
  signed int i = 0;
  unsigned int return_value_getuptime$1;
  unsigned int return_value_getuptime$2;
  unsigned short int tmp_statement_expression$3;
  unsigned short int tmp_statement_expression$4;
  unsigned int return_value_getuptime$5;
  for( ; !(i >= fields); i = i + 1)
    switch((signed int)format[(signed long int)i])
    {
      case 8:
      {
        ((struct in_addr *)p)->s_addr = flow->sip.s_addr;
        p = p + (signed long int)4;
        break;
      }
      case 12:
      {
        ((struct in_addr *)p)->s_addr = flow->dip.s_addr;
        p = p + (signed long int)4;
        break;
      }
      case 10:
      {
        *((unsigned short int *)p) = (unsigned short int)snmp_input_index;
        p = p + (signed long int)2;
        break;
      }
      case 14:
      {
        *((unsigned short int *)p) = (unsigned short int)snmp_output_index;
        p = p + (signed long int)2;
        break;
      }
      case 2:
      {
        *((unsigned int *)p)=__bswap_32((unsigned int)flow->pkts);
        p = p + (signed long int)4;
        break;
      }
      case 1:
      {
        *((unsigned int *)p)=__bswap_32((unsigned int)flow->size);
        p = p + (signed long int)4;
        break;
      }
      case 22:
      {
        return_value_getuptime$1=getuptime(&flow->ctime);
        *((unsigned int *)p)=__bswap_32(return_value_getuptime$1);
        p = p + (signed long int)4;
        break;
      }
      case 21:
      {
        return_value_getuptime$2=getuptime(&flow->mtime);
        *((unsigned int *)p)=__bswap_32(return_value_getuptime$2);
        p = p + (signed long int)4;
        break;
      }
      case 7:
      {
        *((unsigned short int *)p) = flow->sp;
        p = p + (signed long int)2;
        break;
      }
      case 11:
      {
        *((unsigned short int *)p) = flow->dp;
        p = p + (signed long int)2;
        break;
      }
      case 4:
      {
        *((unsigned char *)p) = flow->proto;
        p = p + (signed long int)1;
        break;
      }
      case 5:
      {
        *((unsigned char *)p) = flow->tos;
        p = p + (signed long int)1;
        break;
      }
      case 6:
      {
        *((unsigned char *)p) = flow->tcp_flags;
        p = p + (signed long int)1;
        break;
      }
      case 1001:
      {
        unsigned short int fill$$1$$1$$1$$1$$1$$__v;
        unsigned short int __x = (unsigned short int)netflow->Version;
        asm("rorw $8, %w0" : "=r"(fill$$1$$1$$1$$1$$1$$__v) : "0"(__x) : "cc");
        tmp_statement_expression$3 = fill$$1$$1$$1$$1$$1$$__v;
        *((unsigned short int *)p) = tmp_statement_expression$3;
        p = p + (signed long int)2;
        break;
      }
      case 1002:
      {
        unsigned short int __v;
        unsigned short int fill$$1$$1$$1$$1$$2$$__x = (unsigned short int)emit_count;
        asm("rorw $8, %w0" : "=r"(__v) : "0"(fill$$1$$1$$1$$1$$2$$__x) : "cc");
        tmp_statement_expression$4 = __v;
        *((unsigned short int *)p) = tmp_statement_expression$4;
        p = p + (signed long int)2;
        break;
      }
      case 1003:
      {
        return_value_getuptime$5=getuptime(&emit_time);
        *((unsigned int *)p)=__bswap_32(return_value_getuptime$5);
        p = p + (signed long int)4;
        break;
      }
      case 1004:
      {
        *((unsigned int *)p)=__bswap_32((unsigned int)emit_time.sec);
        p = p + (signed long int)4;
        break;
      }
      case 1005:
      {
        *((unsigned int *)p)=__bswap_32((unsigned int)(emit_time.usec * (signed long int)1000));
        p = p + (signed long int)4;
        break;
      }
      case 1006:
      {
        *((unsigned int *)p) = (unsigned int)0;
        p = p + (signed long int)4;
        break;
      }
      case 9001:

      case 38:

      case 39:

      case 1010:

      case 9:

      case 13:
      {
        *((unsigned char *)p) = (unsigned char)0;
        p = p + (signed long int)1;
        break;
      }
      case 9002:

      case 16:

      case 17:

      case 1011:
      {
        *((unsigned short int *)p) = (unsigned short int)0;
        p = p + (signed long int)2;
        break;
      }
      case 9003:

      case 15:

      case 1012:
      {
        *((unsigned int *)p) = (unsigned int)0;
        p = p + (signed long int)4;
        break;
      }
      default:
      {
        my_log((unsigned int)2, "fill(): Unknown format at %x[%d]: %d", format, i, format[(signed long int)i]);
        exit(1);
      }
    }
  return p;
}

// find
// file fprobe.c line 433
struct Flow * find(struct Flow *where, struct Flow *what, struct Flow ***prev)
{
  struct Flow **flowpp = ((struct Flow **)NULL);
  if(!(prev == ((struct Flow ***)NULL)))
    flowpp = *prev;

  for( ; !(where == ((struct Flow *)NULL)); where = where->next)
  {
    if(where->sip.s_addr == what->sip.s_addr)
    {
      if(where->dip.s_addr == what->dip.s_addr)
      {
        if(where->proto == what->proto)
          switch(what->flags + where->flags & 0x0003)
          {
            case 0:
            {
              if(what->sp == where->sp)
              {
                if(what->dp == where->dp)
                  goto done;

              }

              break;
            }
            case 2:
              if(where->id == what->id)
                goto done;

            default:
              ;
          }

      }

    }

    flowpp = &where->next;
  }

done:
  ;
  if(!(prev == ((struct Flow ***)NULL)))
    *prev = flowpp;

  return where;
}

// fprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf(struct _IO_FILE * restrict __stream, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  signed int return_value___fprintf_chk$2;
  return_value___fprintf_chk$2=__fprintf_chk(__stream, 2 - 1, __fmt, return_value___builtin_va_arg_pack$1);
  return return_value___fprintf_chk$2;
}

// fprintf$link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf$link1(struct _IO_FILE * restrict __stream$link1, const char * restrict __fmt$link1, ...)
{
  void *return_value___builtin_va_arg_pack$1$link1;
  return_value___builtin_va_arg_pack$1$link1=__builtin_va_arg_pack();
  signed int return_value___fprintf_chk$2$link1;
  return_value___fprintf_chk$2$link1=__fprintf_chk(__stream$link1, 2 - 1, __fmt$link1, return_value___builtin_va_arg_pack$1$link1);
  return return_value___fprintf_chk$2$link1;
}

// fprintf$link2
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf$link2(struct _IO_FILE * restrict __stream$link2, const char * restrict __fmt$link2, ...)
{
  void *return_value___builtin_va_arg_pack$1$link2;
  return_value___builtin_va_arg_pack$1$link2=__builtin_va_arg_pack();
  signed int return_value___fprintf_chk$2$link2;
  return_value___fprintf_chk$2$link2=__fprintf_chk(__stream$link2, 2 - 1, __fmt$link2, return_value___builtin_va_arg_pack$1$link2);
  return return_value___fprintf_chk$2$link2;
}

// fread
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 282
static inline unsigned long int fread(void * restrict __ptr, unsigned long int __size, unsigned long int __n, struct _IO_FILE * restrict __stream)
{
  unsigned long int return_value___fread_chk$1;
  unsigned long int return_value___fread_chk_warn$2;
  unsigned long int return_value___fread_alias$3;
  return_value___fread_alias$3=__fread_alias(__ptr, __size, __n, __stream);
  return return_value___fread_alias$3;
}

// gettime
// file fprobe.c line 387
void gettime(struct Time *now)
{
  struct timeval t;
  gettimeofday(&t, ((struct timezone *)NULL));
  now->sec = t.tv_sec;
  now->usec = t.tv_usec;
}

// getuptime
// file fprobe.c line 402
unsigned int getuptime(struct Time *t)
{
  signed long int return_value_cmpmtime$1;
  return_value_cmpmtime$1=cmpmtime(t, &start_time);
  return (unsigned int)return_value_cmpmtime$1;
}

// hash
// file ./hash.h line 49
unsigned short int hash(void *p, signed int size)
{
  unsigned short int hash$$1$$hash = (unsigned short int)0;
  signed int tmp_post$1;
  void *tmp_post$2;
  do
  {
    tmp_post$1 = size;
    size = size - 1;
    if(tmp_post$1 == 0)
      break;

    tmp_post$2 = p;
    p = p + 1l;
    hash$$1$$hash = (unsigned short int)((signed int)crc16_table[(signed long int)((signed int)shuffle_table[(signed long int)*((unsigned char *)tmp_post$2)] ^ (signed int)hash$$1$$hash >> 8)] ^ (signed int)hash$$1$$hash << 8);
  }
  while((_Bool)1);
  return hash$$1$$hash;
}

// hash_flow
// file fprobe.c line 408
unsigned short int hash_flow(struct Flow *flow)
{
  unsigned short int return_value_hash$1;
  unsigned short int return_value_hash$2;
  if(!((0x0001 & flow->flags) == 0))
  {
    return_value_hash$1=hash((void *)flow, (signed int)sizeof(struct Flow_F) /*12ul*/ );
    return return_value_hash$1;
  }

  else
  {
    return_value_hash$2=hash((void *)flow, (signed int)sizeof(struct Flow_TL) /*16ul*/ );
    return return_value_hash$2;
  }
}

// hash_init
// file ./hash.h line 50
void hash_init()
{
  signed int rnd;
  signed int i;
  signed int j;
  signed int m;
  struct _IO_FILE *rnddev;
  rnddev=fopen("/dev/random", "r");
  if(!(rnddev == ((struct _IO_FILE *)NULL)))
  {
    signed int return_value_fileno$1;
    return_value_fileno$1=fileno(rnddev);
    signed int return_value_fileno$2;
    return_value_fileno$2=fileno(rnddev);
    signed int return_value_fcntl$3;
    return_value_fcntl$3=fcntl(return_value_fileno$2, 3);
    fcntl(return_value_fileno$1, 4, return_value_fcntl$3 | 04000);
    fread((void *)&rnd, sizeof(signed int) /*4ul*/ , (unsigned long int)1, rnddev);
    fclose(rnddev);
  }

  signed long int return_value_time$4;
  return_value_time$4=time((signed long int *)(void *)0);
  signed int return_value_getpid$5;
  return_value_getpid$5=getpid();
  srand((unsigned int)(return_value_time$4 ^ (signed long int)return_value_getpid$5 ^ (signed long int)rnd));
  signed int return_value_rand$6;
  return_value_rand$6=rand();
  crc16_poly = (unsigned short int)(return_value_rand$6 | 1);
  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    crc16_table[(signed long int)i]=crc16((unsigned short int)0, (unsigned char)i);
    shuffle_table[(signed long int)i] = (unsigned char)i;
  }
  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    signed int return_value_rand$7;
    return_value_rand$7=rand();
    j = (signed int)((256.0 * (double)return_value_rand$7) / ((double)2147483647 + 1.0));
    m = (signed int)shuffle_table[(signed long int)i];
    shuffle_table[(signed long int)i] = shuffle_table[(signed long int)j];
    shuffle_table[(signed long int)j] = (unsigned char)m;
  }
}

// main
// file fprobe.c line 1180
signed int main(signed int argc, char **argv)
{
  char errbuf[256l];
  struct bpf_program bpf_filter;
  char *dhost;
  char *dport;
  char *lhost;
  char *type = ((char *)NULL);
  char *log_suffix = ((char *)NULL);
  signed int c;
  signed int i;
  signed int sock;
  signed int memory_limit = 0;
  signed int link_type;
  signed int link_type_idx;
  signed int snaplen;
  struct addrinfo hints;
  struct addrinfo *res;
  struct sockaddr_in saddr;
  union pthread_attr_t tattr;
  struct sigaction sigact;
  struct timeval timeout;
  link_type_idx = 0;
  sched_min=sched_get_priority_min(1);
  sched_max=sched_get_priority_max(1);
  memset((void *)&saddr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_flags = 0x0001;
  hints.ai_family = 2;
  hints.ai_socktype = 2;
  opterr = 0;
  do
  {
    c=my_getopt(argc, argv, parms);
    if(c == -1)
      break;

    switch(c)
    {
      case 63:
        usage();
      case 104:
        usage();
    }
  }
  while((_Bool)1);
  parms[(signed long int)15].count = parms[(signed long int)15].count - 1;
  promisc = (unsigned int)-parms[(signed long int)15].count;
  dev = parms[(signed long int)9].arg;
  if(!(dev == ((char *)NULL)))
  {
    if((signed int)*dev == 45)
      log_dest = (unsigned int)2;

  }

  if(!(parms[18l].count == 0))
    snaplen=atoi(parms[(signed long int)18].arg);

  else
    snaplen = 256;
  signed int return_value_atoi$1;
  if(!(parms[19l].count == 0))
  {
    return_value_atoi$1=atoi(parms[(signed long int)19].arg);
    scan_interval = (unsigned int)return_value_atoi$1;
  }

  if(!(parms[7l].count == 0))
    frag_lifetime=atoi(parms[(signed long int)7].arg);

  if(!(parms[4l].count == 0))
    inactive_lifetime=atoi(parms[(signed long int)4].arg);

  if(!(parms[5l].count == 0))
    active_lifetime=atoi(parms[(signed long int)5].arg);

  if(!(parms[14l].count == 0))
  {
    signed int return_value_atoi$2;
    return_value_atoi$2=atoi(parms[(signed long int)14].arg);
    switch(return_value_atoi$2)
    {
      case 1:
      {
        netflow = &NetFlow1;
        break;
      }
      case 5:
        break;
      case 7:
      {
        netflow = &NetFlow7;
        break;
      }
      default:
      {
        fprintf(stderr, "Illegal %s\n", (const void *)"NetFlow version");
        exit(1);
      }
    }
  }

  signed int return_value_atoi$3;
  if(!(parms[22l].count == 0))
  {
    return_value_atoi$3=atoi(parms[(signed long int)22].arg);
    verbosity = (unsigned int)return_value_atoi$3;
  }

  char *tmp_post$4;
  signed int return_value_atoi$6;
  if(!(parms[12l].count == 0))
  {
    char *return_value___builtin_strchr$5;
    return_value___builtin_strchr$5=__builtin_strchr(parms[(signed long int)12].arg, 58);
    log_suffix = return_value___builtin_strchr$5;
    if(!(log_suffix == ((char *)NULL)))
    {
      tmp_post$4 = log_suffix;
      log_suffix = log_suffix + 1l;
      *tmp_post$4 = (char)0;
      if(!(*log_suffix == 0))
      {
        sprintf(errbuf, "[%s]", log_suffix);
        strcat(ident, errbuf);
      }

    }

    if(!(*parms[12l].arg == 0))
    {
      return_value_atoi$6=atoi(parms[(signed long int)12].arg);
      log_dest = (unsigned int)return_value_atoi$6;
    }

    if(!(log_suffix == ((char *)NULL)))
    {
      log_suffix = log_suffix - 1l;
      *log_suffix = (char)58;
    }

  }

  unsigned long int return_value_strlen$9;
  return_value_strlen$9=strlen(ident);
  void *return_value_malloc$10;
  return_value_malloc$10=malloc(sizeof(char [9l]) /*9ul*/  + (unsigned long int)1 + return_value_strlen$9 + (unsigned long int)1 + (unsigned long int)3 + (unsigned long int)1);
  pidfilepath = (char *)return_value_malloc$10;
  if(pidfilepath == ((char *)NULL))
  {

  err_malloc:
    ;
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    char *return_value_strerror$8;
    return_value_strerror$8=strerror(*return_value___errno_location$7);
    fprintf(stderr, "malloc(): %s\n", return_value_strerror$8);
    exit(1);
  }

  sprintf(pidfilepath, "%s/%s.pid", (const void *)"/var/run", (const void *)ident);
  if(!(parms[16l].count == 0))
  {
    signed int return_value_atoi$11;
    return_value_atoi$11=atoi(parms[(signed long int)16].arg);
    pending_queue_length = (unsigned int)return_value_atoi$11;
    if(!(pending_queue_length >= 1u))
    {
      fprintf(stderr, "Illegal %s\n", (const void *)"pending queue length");
      exit(1);
    }

  }

  if(!(parms[17l].count == 0))
  {
    schedp.__sched_priority=atoi(parms[(signed long int)17].arg);
    if(!(schedp.__sched_priority == 0) && (!(schedp.__sched_priority >= sched_min) || !(sched_max >= schedp.__sched_priority)))
    {
      fprintf(stderr, "Illegal %s\n", (const void *)"realtime priority");
      exit(1);
    }

  }

  signed int return_value_atoi$12;
  if(!(parms[1l].count == 0))
  {
    return_value_atoi$12=atoi(parms[(signed long int)1].arg);
    sockbufsize = return_value_atoi$12 << 10;
  }

  if(!(parms[2l].count == 0))
  {
    signed int return_value_atoi$13;
    return_value_atoi$13=atoi(parms[(signed long int)2].arg);
    bulk_quantity = (unsigned int)return_value_atoi$13;
    if(!(bulk_quantity >= 1u))
    {
      fprintf(stderr, "Illegal %s\n", (const void *)"bulk size");
      exit(1);
    }

  }

  signed int return_value_atoi$14;
  if(!(parms[13l].count == 0))
  {
    return_value_atoi$14=atoi(parms[(signed long int)13].arg);
    memory_limit = return_value_atoi$14 << 10;
  }

  signed int return_value_sscanf$15;
  if(!(parms[23l].count == 0))
  {
    return_value_sscanf$15=sscanf(parms[(signed long int)23].arg, "%d:%d", &snmp_input_index, &snmp_output_index);
    if(return_value_sscanf$15 == 1)
      snmp_output_index = snmp_input_index;

  }

  if(!(parms[20l].count == 0))
    sscanf(parms[(signed long int)20].arg, "%d:%d", &emit_rate_bytes, &emit_rate_delay);

  if(!(parms[0l].count == 0))
  {
    signed int return_value_getaddrinfo$16;
    return_value_getaddrinfo$16=getaddrinfo(parms[(signed long int)0].arg, ((const char *)NULL), &hints, &res);
    if(!(return_value_getaddrinfo$16 == 0))
    {

    bad_lhost:
      ;
      fprintf(stderr, "Illegal %s\n", (const void *)"source address");
      exit(1);
    }

    else
    {
      saddr = *((struct sockaddr_in *)res->ai_addr);
      freeaddrinfo(res);
    }
  }

  if(!(parms[10l].count == 0))
    link_layer_size=atoi(parms[(signed long int)10].arg);

  link_layer = parms[(signed long int)11].count;
  char *tmp_if_expr$20;
  signed int *return_value___errno_location$18;
  char *return_value_strerror$19;
  if(!(parms[21l].count == 0))
  {
    pw=getpwnam(parms[(signed long int)21].arg);
    if(pw == ((struct passwd *)NULL))
    {
      signed int *return_value___errno_location$17;
      return_value___errno_location$17=__errno_location();
      if(!(*return_value___errno_location$17 == 0))
      {
        return_value___errno_location$18=__errno_location();
        return_value_strerror$19=strerror(*return_value___errno_location$18);
        tmp_if_expr$20 = return_value_strerror$19;
      }

      else
        tmp_if_expr$20 = "Unknown user";
      fprintf(stderr, "getpwnam(%s): %s\n", parms[(signed long int)21].arg, tmp_if_expr$20);
      exit(1);
    }

  }

  npeers = argc - optind;
  if(!(npeers >= 1))
    usage();

  void *return_value_malloc$21;
  return_value_malloc$21=malloc((unsigned long int)npeers * sizeof(struct peer) /*44ul*/ );
  peers = (struct peer *)return_value_malloc$21;
  if(peers == ((struct peer *)NULL))
    goto err_malloc;

  i = optind;
  npeers = 0;
  char *tmp_post$23;
  char *return_value___builtin_strchr$30;
  char *tmp_post$26;
  char *tmp_post$27;
  signed int return_value_bind$33;
  signed int return_value_getaddrinfo$34;
  for( ; !(i >= argc); npeers = npeers + 1)
  {
    dhost = argv[(signed long int)i];
    char *return_value___builtin_strchr$22;
    return_value___builtin_strchr$22=__builtin_strchr(dhost, 58);
    dport = return_value___builtin_strchr$22;
    if(!(dport == ((char *)NULL)))
    {
      tmp_post$23 = dport;
      dport = dport + 1l;
      *tmp_post$23 = (char)0;
      sock=socket(2, 2, 0);
      if(!(sock >= 0))
      {
        signed int *return_value___errno_location$24;
        return_value___errno_location$24=__errno_location();
        char *return_value_strerror$25;
        return_value_strerror$25=strerror(*return_value___errno_location$24);
        fprintf(stderr, "socket(): %s\n", return_value_strerror$25);
        exit(1);
      }

      (peers + (signed long int)npeers)->sock = sock;
      (peers + (signed long int)npeers)->type = 0;
      (peers + (signed long int)npeers)->laddr = saddr;
      (peers + (signed long int)npeers)->seq = (unsigned int)0;
      return_value___builtin_strchr$30=__builtin_strchr(dport, 47);
      lhost = return_value___builtin_strchr$30;
      if(!(lhost == ((char *)NULL)))
      {
        tmp_post$26 = lhost;
        lhost = lhost + 1l;
        *tmp_post$26 = (char)0;
        char *return_value___builtin_strchr$28;
        return_value___builtin_strchr$28=__builtin_strchr(lhost, 47);
        type = return_value___builtin_strchr$28;
        if(!(type == ((char *)NULL)))
        {
          tmp_post$27 = type;
          type = type + 1l;
          *tmp_post$27 = (char)0;
          switch((signed int)*type)
          {
            case 0:

            case 109:
              break;
            case 114:
            {
              (peers + (signed long int)npeers)->type = 1;
              npeers_rot = npeers_rot + 1;
              break;
            }
            default:
              goto bad_collector;
          }
        }

        if(!(*lhost == 0))
        {
          signed int return_value_getaddrinfo$29;
          return_value_getaddrinfo$29=getaddrinfo(lhost, ((const char *)NULL), &hints, &res);
          if(!(return_value_getaddrinfo$29 == 0))
            goto bad_lhost;

          (peers + (signed long int)npeers)->laddr = *((struct sockaddr_in *)res->ai_addr);
          freeaddrinfo(res);
        }

      }

      return_value_bind$33=bind(sock, (struct sockaddr *)&(peers + (signed long int)npeers)->laddr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(!(return_value_bind$33 == 0))
      {
        signed int *return_value___errno_location$31;
        return_value___errno_location$31=__errno_location();
        char *return_value_strerror$32;
        return_value_strerror$32=strerror(*return_value___errno_location$31);
        fprintf(stderr, "bind(): %s\n", return_value_strerror$32);
        exit(1);
      }

      return_value_getaddrinfo$34=getaddrinfo(dhost, dport, &hints, &res);
      if(return_value_getaddrinfo$34 == 0)
        goto __CPROVER_DUMP_L54;

    }


  bad_collector:
    ;
    fprintf(stderr, "Error in collector #%d parameters\n", npeers + 1);
    exit(1);

  __CPROVER_DUMP_L54:
    ;
    (peers + (signed long int)npeers)->addr = *((struct sockaddr_in *)res->ai_addr);
    freeaddrinfo(res);
    signed int return_value_connect$37;
    return_value_connect$37=connect(sock, (struct sockaddr *)&(peers + (signed long int)npeers)->addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_connect$37 == 0))
    {
      signed int *return_value___errno_location$35;
      return_value___errno_location$35=__errno_location();
      char *return_value_strerror$36;
      return_value_strerror$36=strerror(*return_value___errno_location$35);
      fprintf(stderr, "connect(): %s\n", return_value_strerror$36);
      exit(1);
    }

    if(!(type == ((char *)NULL)))
    {
      type = type - 1l;
      *type = (char)47;
    }

    if(!(lhost == ((char *)NULL)))
    {
      lhost = lhost - 1l;
      *lhost = (char)47;
    }

    dport = dport - 1l;
    *dport = (char)58;
    i = i + 1;
  }
  my_log_open(ident, verbosity, log_dest);
  signed int *return_value___errno_location$39;
  char *return_value_strerror$40;
  if((2u & log_dest) == 0u)
  {
    signed int return_value_fork$38;
    return_value_fork$38=fork();
    if(!(return_value_fork$38 == -1))
    {
      if(return_value_fork$38 == 0)
        goto __CPROVER_DUMP_L60;

    }

    else
    {
      return_value___errno_location$39=__errno_location();
      return_value_strerror$40=strerror(*return_value___errno_location$39);
      fprintf(stderr, "fork(): %s", return_value_strerror$40);
      exit(1);

    __CPROVER_DUMP_L60:
      ;
      setsid();
      freopen("/dev/null", "r", stdin);
      freopen("/dev/null", "w", stdout);
      freopen("/dev/null", "w", stderr);
      goto __CPROVER_DUMP_L62;
    }
    exit(0);
  }

  else
  {
    setvbuf(stdout, (char *)0, 2, (unsigned long int)0);
    setvbuf(stderr, (char *)0, 2, (unsigned long int)0);
  }

__CPROVER_DUMP_L62:
  ;
  pid=getpid();
  sprintf(errbuf, "[%ld]", (signed long int)pid);
  strcat(ident, errbuf);
  if(dev == ((char *)NULL))
  {
    dev=pcap_lookupdev(errbuf);
    if(dev == ((char *)NULL))
    {
      my_log((unsigned int)2, "pcap_lookupdev(): %s\n", (const void *)errbuf);
      exit(1);
    }

  }

  signed int return_value_pcap_fileno$43;
  signed int return_value_setsockopt$44;
  signed int *return_value___errno_location$41;
  char *return_value_strerror$42;
  if((signed int)*dev == 45)
  {
    pcap_handle=pcap_open_offline(dev, errbuf);
    if(pcap_handle == ((struct pcap *)NULL))
    {
      my_log((unsigned int)2, "pcap_open_offline(): %s", (const void *)errbuf);
      exit(1);
    }

  }

  else
  {
    pcap_handle=pcap_open_live(dev, snaplen, (signed int)promisc, 1000, errbuf);
    if(pcap_handle == ((struct pcap *)NULL))
    {
      my_log((unsigned int)2, "pcap_open_live(): %s", (const void *)errbuf);
      exit(1);
    }

    if(!(sockbufsize == 0))
    {
      return_value_pcap_fileno$43=pcap_fileno(pcap_handle);
      return_value_setsockopt$44=setsockopt(return_value_pcap_fileno$43, 1, 8, (const void *)&sockbufsize, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt$44 >= 0))
      {
        return_value___errno_location$41=__errno_location();
        return_value_strerror$42=strerror(*return_value___errno_location$41);
        my_log((unsigned int)4, "setsockopt(): %s", return_value_strerror$42);
      }

    }

  }
  link_type=pcap_datalink(pcap_handle);
  i = 0;
  _Bool tmp_if_expr$45;
  do
  {
    if(dlt[(signed long int)i].linktype == link_type)
      tmp_if_expr$45 = (_Bool)1;

    else
      tmp_if_expr$45 = dlt[(signed long int)i].linktype == -1 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$45)
    {
      off_nl = (signed int)dlt[(signed long int)i].offset_nl;
      link_type_idx = i;
      break;
    }

    i = i + 1;
  }
  while((_Bool)1);
  if(link_layer_size >= 0)
    off_nl = link_layer_size;

  if(off_nl == -1)
  {
    my_log((unsigned int)2, "Uknown data link type %d. Use -K option.", link_type);
    exit(1);
  }

  if(!(parms[6l].arg == ((char *)NULL)))
  {
    filter = parms[(signed long int)6].arg;
    signed int return_value_pcap_compile$47;
    return_value_pcap_compile$47=pcap_compile(pcap_handle, &bpf_filter, filter, 1, (unsigned int)0);
    if(return_value_pcap_compile$47 == -1)
    {
      char *return_value_pcap_geterr$46;
      return_value_pcap_geterr$46=pcap_geterr(pcap_handle);
      my_log((unsigned int)2, "pcap_compile(): %s. Filter: %s", return_value_pcap_geterr$46, filter);
      exit(1);
    }

    signed int return_value_pcap_setfilter$49;
    return_value_pcap_setfilter$49=pcap_setfilter(pcap_handle, &bpf_filter);
    if(return_value_pcap_setfilter$49 == -1)
    {
      char *return_value_pcap_geterr$48;
      return_value_pcap_geterr$48=pcap_geterr(pcap_handle);
      my_log((unsigned int)2, "pcap_setfilter(): %s", return_value_pcap_geterr$48);
      exit(1);
    }

  }

  else
    my_log((unsigned int)4, "Filter expression is empty! Are you sure?");
  hash_init();
  mem_init((unsigned int)sizeof(struct Flow) /*104ul*/ , bulk_quantity, (unsigned int)memory_limit);
  i = 0;
  for( ; !(i >= 65536); i = i + 1)
    pthread_mutex_init(&flows_mutex[(signed long int)i], ((const union anonymous$4 *)NULL));
  start_time_offset = (signed long int)(1 << 20);
  gettime(&start_time);
  void *return_value_mem_alloc$50;
  return_value_mem_alloc$50=mem_alloc();
  pending_head = (struct Flow *)return_value_mem_alloc$50;
  signed int tmp_post$51;
  void *return_value_mem_alloc$54;
  if(!(pending_head == ((struct Flow *)NULL)))
  {
    pending_tail = pending_head;
    i = (signed int)(pending_queue_length - (unsigned int)1);

  __CPROVER_DUMP_L84:
    ;
    tmp_post$51 = i;
    i = i - 1;
    if(tmp_post$51 == 0)
      goto __CPROVER_DUMP_L87;

    return_value_mem_alloc$54=mem_alloc();
    pending_tail->next = (struct Flow *)return_value_mem_alloc$54;
    if(!(pending_tail->next == ((struct Flow *)NULL)))
      goto __CPROVER_DUMP_L86;

  }


err_mem_alloc:
  ;
  signed int *return_value___errno_location$52;
  return_value___errno_location$52=__errno_location();
  char *return_value_strerror$53;
  return_value_strerror$53=strerror(*return_value___errno_location$52);
  my_log((unsigned int)2, "mem_alloc(): %s", return_value_strerror$53);
  exit(1);

__CPROVER_DUMP_L86:
  ;
  pending_tail = pending_tail->next;
  goto __CPROVER_DUMP_L84;

__CPROVER_DUMP_L87:
  ;
  pending_tail->next = pending_head;
  pending_tail = pending_head;
  sigemptyset(&sig_mask);
  sigact.__sigaction_handler.sa_handler = sighandler;
  sigact.sa_mask = sig_mask;
  sigact.sa_flags = 0;
  sigaddset(&sig_mask, 15);
  sigaction(15, &sigact, ((struct sigaction *)NULL));
  signed int return_value_pthread_sigmask$57;
  return_value_pthread_sigmask$57=pthread_sigmask(0, &sig_mask, ((struct anonymous$21 *)NULL));
  if(!(return_value_pthread_sigmask$57 == 0))
  {
    signed int *return_value___errno_location$55;
    return_value___errno_location$55=__errno_location();
    char *return_value_strerror$56;
    return_value_strerror$56=strerror(*return_value___errno_location$55);
    my_log((unsigned int)2, "pthread_sigmask(): %s", return_value_strerror$56);
    exit(1);
  }

  my_log((unsigned int)6, "Starting %s...", (const void *)"1.1");
  _Bool tmp_if_expr$62;
  signed int return_value_chroot$61;
  if(!(parms[3l].count == 0))
  {
    signed int return_value_chdir$60;
    return_value_chdir$60=chdir(parms[(signed long int)3].arg);
    if(!(return_value_chdir$60 == 0))
      tmp_if_expr$62 = (_Bool)1;

    else
    {
      return_value_chroot$61=chroot(".");
      tmp_if_expr$62 = return_value_chroot$61 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$62)
    {
      signed int *return_value___errno_location$58;
      return_value___errno_location$58=__errno_location();
      char *return_value_strerror$59;
      return_value_strerror$59=strerror(*return_value___errno_location$58);
      my_log((unsigned int)2, "could not chroot to %s: %s", parms[(signed long int)3].arg, return_value_strerror$59);
      exit(1);
    }

  }

  schedp.__sched_priority = (schedp.__sched_priority - 5) + 2;
  pthread_attr_init(&tattr);
  i = 0;
  _Bool tmp_if_expr$67;
  signed int return_value_pthread_attr_setschedparam$66;
  for( ; !(i >= 5); i = i + 1)
  {
    if(schedp.__sched_priority >= 1)
    {
      signed int return_value_pthread_attr_setschedpolicy$65;
      return_value_pthread_attr_setschedpolicy$65=pthread_attr_setschedpolicy(&tattr, 1);
      if(!(return_value_pthread_attr_setschedpolicy$65 == 0))
        tmp_if_expr$67 = (_Bool)1;

      else
      {
        return_value_pthread_attr_setschedparam$66=pthread_attr_setschedparam(&tattr, &schedp);
        tmp_if_expr$67 = return_value_pthread_attr_setschedparam$66 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$67)
      {
        signed int *return_value___errno_location$63;
        return_value___errno_location$63=__errno_location();
        char *return_value_strerror$64;
        return_value_strerror$64=strerror(*return_value___errno_location$63);
        my_log((unsigned int)2, "pthread_attr_setschedpolicy(): %s", return_value_strerror$64);
        exit(1);
      }

    }

    signed int return_value_pthread_create$70;
    static void *threads[4l] = { (void *)emit_thread, (void *)scan_thread, (void *)unpending_thread, (void *)pcap_thread };
    return_value_pthread_create$70=pthread_create(&thid, &tattr, (void * (*)(void *))threads[(signed long int)i], NULL);
    if(!(return_value_pthread_create$70 == 0))
    {
      signed int *return_value___errno_location$68;
      return_value___errno_location$68=__errno_location();
      char *return_value_strerror$69;
      return_value_strerror$69=strerror(*return_value___errno_location$68);
      my_log((unsigned int)2, "pthread_create(): %s", return_value_strerror$69);
      exit(1);
    }

    pthread_detach(thid);
    schedp.__sched_priority = schedp.__sched_priority + 1;
  }
  if(!(pw == ((struct passwd *)NULL)))
  {
    signed int return_value_setgroups$73;
    return_value_setgroups$73=setgroups((unsigned long int)0, (const unsigned int *)(void *)0);
    if(!(return_value_setgroups$73 >= 0))
    {
      signed int *return_value___errno_location$71;
      return_value___errno_location$71=__errno_location();
      char *return_value_strerror$72;
      return_value_strerror$72=strerror(*return_value___errno_location$71);
      my_log((unsigned int)2, "setgroups: %s", return_value_strerror$72);
      exit(1);
    }

    signed int return_value_setregid$76;
    return_value_setregid$76=setregid(pw->pw_gid, pw->pw_gid);
    if(!(return_value_setregid$76 == 0))
    {
      signed int *return_value___errno_location$74;
      return_value___errno_location$74=__errno_location();
      char *return_value_strerror$75;
      return_value_strerror$75=strerror(*return_value___errno_location$74);
      my_log((unsigned int)2, "setregid(%u): %s", pw->pw_gid, return_value_strerror$75);
      exit(1);
    }

    signed int return_value_setreuid$79;
    return_value_setreuid$79=setreuid(pw->pw_uid, pw->pw_uid);
    if(!(return_value_setreuid$79 == 0))
    {
      signed int *return_value___errno_location$77;
      return_value___errno_location$77=__errno_location();
      char *return_value_strerror$78;
      return_value_strerror$78=strerror(*return_value___errno_location$77);
      my_log((unsigned int)2, "setreuid(%u): %s", pw->pw_uid, return_value_strerror$78);
      exit(1);
    }

  }

  pidfile=fopen(pidfilepath, "w");
  signed int *return_value___errno_location$80;
  char *return_value_strerror$81;
  if(pidfile == ((struct _IO_FILE *)NULL))
  {
    return_value___errno_location$80=__errno_location();
    return_value_strerror$81=strerror(*return_value___errno_location$80);
    my_log((unsigned int)3, "Can't create pid file. fopen(): %s", return_value_strerror$81);
  }

  else
  {
    fprintf(pidfile, "%ld\n", (signed long int)pid);
    fclose(pidfile);
  }
  my_log((unsigned int)6, "pid: %d", pid);
  my_log((unsigned int)6, "interface: %s, datalink: %s (%d)", dev, dlt[(signed long int)link_type_idx].descr, link_type);
  my_log((unsigned int)6, "filter: \"%s\"", filter);
  char *return_value_inet_ntoa$82;
  return_value_inet_ntoa$82=inet_ntoa(saddr.sin_addr);
  char *tmp_if_expr$83;
  if(!(parms[3l].count == 0))
    tmp_if_expr$83 = parms[(signed long int)3].arg;

  else
    tmp_if_expr$83 = "";
  char *tmp_if_expr$84;
  if(!(parms[21l].count == 0))
    tmp_if_expr$84 = parms[(signed long int)21].arg;

  else
    tmp_if_expr$84 = "";
  my_log((unsigned int)6, "options: p=%d s=%u g=%u d=%u e=%u n=%u a=%s x=%u:%u b=%u m=%u q=%u B=%u r=%u t=%u:%u S=%d K=%d k=%d c=%s u=%s v=%u l=%u%s", promisc, scan_interval, frag_lifetime, inactive_lifetime, active_lifetime, netflow->Version, return_value_inet_ntoa$82, snmp_input_index, snmp_output_index, bulk_quantity, memory_limit >> 10, pending_queue_length, sockbufsize >> 10, schedp.__sched_priority - 1, emit_rate_bytes, emit_rate_delay, snaplen, off_nl, link_layer, tmp_if_expr$83, tmp_if_expr$84, verbosity, log_dest, log_suffix != ((char *)NULL) ? log_suffix : "");
  i = 0;
  unsigned short int tmp_statement_expression$87;
  for( ; !(i >= npeers); i = i + 1)
  {
    switch((peers + (signed long int)i)->type)
    {
      case 0:
      {
        c = 109;
        break;
      }
      case 1:
        c = 114;
    }
    char *return_value_inet_ntoa$85;
    return_value_inet_ntoa$85=inet_ntoa((peers + (signed long int)i)->laddr.sin_addr);
    snprintf(errbuf, sizeof(char [256l]) /*256ul*/ , "%s", return_value_inet_ntoa$85);
    char *return_value_inet_ntoa$86;
    return_value_inet_ntoa$86=inet_ntoa((peers + (signed long int)i)->addr.sin_addr);
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)(peers + (signed long int)i)->addr.sin_port;
    asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression$87 = __v;
    my_log((unsigned int)6, "collector #%d: %s:%u/%s/%c", i + 1, return_value_inet_ntoa$86, tmp_statement_expression$87, (const void *)errbuf, c);
  }
  unsigned short int tmp_statement_expression$88;
  unsigned short int main$$1$$27$$__v;
  unsigned short int main$$1$$27$$__x = (unsigned short int)snmp_input_index;
  asm("rorw $8, %w0" : "=r"(main$$1$$27$$__v) : "0"(main$$1$$27$$__x) : "cc");
  tmp_statement_expression$88 = main$$1$$27$$__v;
  snmp_input_index = (unsigned int)tmp_statement_expression$88;
  unsigned short int tmp_statement_expression$89;
  unsigned short int main$$1$$28$$__v;
  unsigned short int main$$1$$28$$__x = (unsigned short int)snmp_output_index;
  asm("rorw $8, %w0" : "=r"(main$$1$$28$$__v) : "0"(main$$1$$28$$__x) : "cc");
  tmp_statement_expression$89 = main$$1$$28$$__v;
  snmp_output_index = (unsigned int)tmp_statement_expression$89;
  pthread_sigmask(1, &sig_mask, ((struct anonymous$21 *)NULL));
  timeout.tv_usec = (signed long int)0;
  while((_Bool)1)
  {
    if(!(killed == 0))
    {
      if(total_elements + -free_elements == pending_queue_length)
      {
        if(emit_count == 0u)
        {
          if(pending_tail->flags == 0)
            goto __CPROVER_DUMP_L125;

        }

      }

    }

    if(sigs == 0)
    {
      timeout.tv_sec = (signed long int)scan_interval;
      select(0, ((struct anonymous$3 *)NULL), ((struct anonymous$3 *)NULL), ((struct anonymous$3 *)NULL), &timeout);
    }

    if(killed == 0 && !((2 & sigs) == 0))
    {
      sigs = sigs & ~2;
      my_log((unsigned int)6, "SIGTERM received. Emitting flows cache...");
      scan_interval = (unsigned int)1;
      frag_lifetime = -1;
      active_lifetime = -1;
      inactive_lifetime = -1;
      emit_timeout = 1;
      unpending_timeout = 1;
      killed = 1;
      pthread_cond_signal(&scan_cond);
      pthread_cond_signal(&unpending_cond);
    }

  }

__CPROVER_DUMP_L125:
  ;
  remove(pidfilepath);
  my_log((unsigned int)6, "Done.");
  return 0;
}

// mem_alloc
// file ./mem.h line 33
void * mem_alloc()
{
  unsigned int i;
  struct Mem *mptr;
  void **iptr;
  void *eptr;
  pthread_mutex_lock(&mem_mutex);
  void **tmp_post$3;
  if(free_elements == 0u)
  {
    if(!(limit_memory == 0u) && !(limit_memory >= malloc_size + total_memory))
    {
      mptr = ((struct Mem *)NULL);
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 12;
      goto done;
    }

    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)malloc_size, (unsigned long int)1);
    mptr = (struct Mem *)return_value_calloc$2;
    if(mptr == ((struct Mem *)NULL))
      goto done;

    iptr = (void **)((void *)mptr + (signed long int)sizeof(struct Mem) /*32ul*/ );
    eptr = (void *)iptr + (signed long int)mem_index_table_size;
    i = (unsigned int)0;
    for( ; !(i >= bulk_quantity$link1); i = i + 1u)
    {
      tmp_post$3 = iptr;
      iptr = iptr + 1l;
      *tmp_post$3 = eptr;
      eptr = eptr + (signed long int)element_size;
    }
    mptr->free = bulk_quantity$link1 - (unsigned int)1;
    free_elements = free_elements + mptr->free;
    total_elements = total_elements + bulk_quantity$link1;
    total_memory = total_memory + malloc_size;
    mptr->first = (void *)iptr;
    mptr->last = ((void *)iptr + (signed long int)element_table_size) - (signed long int)element_size;
    mptr->next = root;
    root = mptr;
    mptr = (struct Mem *)mptr->last;
    goto done;
  }

  mptr = root;
  for( ; mptr->free == 0u; mptr = mptr->next)
    ;
  mptr->free = mptr->free - 1u;
  free_elements = free_elements - 1u;
  iptr = (void **)((void *)mptr + (signed long int)sizeof(struct Mem) /*32ul*/ );
  mptr = (struct Mem *)iptr[(signed long int)mptr->free];

done:
  ;
  pthread_mutex_unlock(&mem_mutex);
  return (void *)mptr;
}

// mem_free
// file ./mem.h line 34
void mem_free(void *eptr)
{
  void **iptr;
  struct Mem *mptr;
  struct Mem **pptr;
  pthread_mutex_lock(&mem_mutex);
  mptr = root;
  pptr = &root;
  for( ; (_Bool)1; mptr = mptr->next)
  {
    if(eptr >= mptr->first)
    {
      if(mptr->last >= eptr)
        goto __CPROVER_DUMP_L3;

    }

    pptr = &mptr->next;
  }

__CPROVER_DUMP_L3:
  ;
  iptr = (void **)((void *)mptr + (signed long int)sizeof(struct Mem) /*32ul*/ );
  iptr[(signed long int)mptr->free] = eptr;
  mptr->free = mptr->free + 1u;
  free_elements = free_elements + 1u;
  if(mptr->free == bulk_quantity$link1)
  {
    *pptr = mptr->next;
    free((void *)mptr);
    total_elements = total_elements - bulk_quantity$link1;
    free_elements = free_elements - bulk_quantity$link1;
    total_memory = total_memory - malloc_size;
  }

  pthread_mutex_unlock(&mem_mutex);
}

// mem_init
// file ./mem.h line 35
signed int mem_init(unsigned int element, unsigned int bulk, unsigned int limit)
{
  bulk_quantity$link1 = (unsigned int)(void *)bulk;
  mem_index_table_size = (unsigned int)(sizeof(void *) /*8ul*/  * (unsigned long int)bulk_quantity$link1);
  element_size = element;
  element_table_size = element_size * bulk_quantity$link1;
  malloc_size = (unsigned int)(sizeof(struct Mem) /*32ul*/  + (unsigned long int)mem_index_table_size + (unsigned long int)element_table_size);
  limit_memory = limit;
  return 0;
}

// memset
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 78
static inline void * memset(void *__dest, signed int __ch, unsigned long int __len)
{
  void *return_value___builtin___memset_chk$1;
  return_value___builtin___memset_chk$1=__builtin___memset_chk(__dest, __ch, __len, 18446744073709551615ul);
  return return_value___builtin___memset_chk$1;
}

// my_getopt
// file ./my_getopt.h line 26
signed int my_getopt(signed int argc, char * const *argv, struct getopt_parms *parms)
{
  signed int c;
  signed int i;
  signed int p;
  static signed int flag = 0;
  signed int tmp_post$3 = flag;
  flag = flag + 1;
  signed int tmp_post$1;
  signed int tmp_post$2;
  static char optstring[4096l];
  if(tmp_post$3 == 0)
  {
    p = 0;
    i = 0;
    for( ; !((signed int)(parms + (signed long int)i)->name == 0); i = i + 1)
    {
      if(p >= 4096)
        break;

      tmp_post$1 = p;
      p = p + 1;
      optstring[(signed long int)tmp_post$1] = (parms + (signed long int)i)->name;
      if(!((0x1 & (parms + (signed long int)i)->flag) == 0))
      {
        tmp_post$2 = p;
        p = p + 1;
        optstring[(signed long int)tmp_post$2] = (char)58;
      }

      optstring[(signed long int)p] = (char)0;
    }
    flag = 1;
  }

  c=getopt(argc, argv, optstring);
  static signed int my_opterr = 1;
  if(!(c == 63))
  {
    if(c == -1)
      goto __CPROVER_DUMP_L7;

  }

  else
  {
    if(!(my_opterr == 0))
      fprintf$link1(stderr, "Wrong parameters\n");

    goto __CPROVER_DUMP_L19;

  __CPROVER_DUMP_L7:
    ;
    flag = 0;
    i = 0;
    for( ; !((signed int)(parms + (signed long int)i)->name == 0); i = i + 1)
      if(!((0x2 & (parms + (signed long int)i)->flag) == 0))
      {
        if((parms + (signed long int)i)->count == 0)
        {
          if(!(my_opterr == 0))
            fprintf$link1(stderr, "Missing required option\n");

          return 63;
        }

      }

    goto __CPROVER_DUMP_L19;
  }
  i = 0;
  for( ; !((signed int)(parms + (signed long int)i)->name == 0); i = i + 1)
    if((signed int)(parms + (signed long int)i)->name == c)
      break;

  if(!((0x1 & (parms + (signed long int)i)->flag) == 0))
  {
    if(optarg == ((char *)NULL))
    {
      if(!(my_opterr == 0))
        fprintf$link1(stderr, "Option `-%c': %s\n", c, (const void *)"require parameter");

      return 63;
    }

    else
      (parms + (signed long int)i)->arg = optarg;
  }

  (parms + (signed long int)i)->count = (parms + (signed long int)i)->count + 1;
  if((parms + (signed long int)i)->count >= 2)
  {
    if(!((0x4 & (parms + (signed long int)i)->flag) == 0))
      goto __CPROVER_DUMP_L19;

    if(!(my_opterr == 0))
      fprintf$link1(stderr, "Option `-%c': %s\n", c, (const void *)"repeat not allowed");

    return 63;
  }

  else
  {

  __CPROVER_DUMP_L19:
    ;
    return c;
  }
}

// my_log
// file ./my_log.h line 22
void my_log(unsigned int level, const char *format, ...)
{
  void **args;
  char msg[256l];
  char msg_prefix[64l];
  if(my_log_min_level >= level)
  {
    args = (void **)&format;
    vsnprintf(msg, sizeof(char [256l]) /*256ul*/ , format, args);
    snprintf$link1(msg_prefix, sizeof(char [64l]) /*64ul*/ , "[%s]: ", my_log_names[(signed long int)level]);
    if(!((1u & my_log_flags) == 0u))
      syslog((signed int)level, "%s%s", (const void *)msg_prefix, (const void *)msg);

    if(!((2u & my_log_flags) == 0u))
      fprintf$link2(stdout, "%s%s\n", (const void *)msg_prefix, (const void *)msg);

  }

}

// my_log_close
// file my_log.c line 35
void my_log_close(void)
{
  closelog();
}

// my_log_open
// file ./my_log.h line 20
void my_log_open(char *indent, unsigned int min_level, unsigned int flags)
{
  my_log_indent = indent;
  my_log_min_level = min_level;
  my_log_flags = flags;
  openlog(my_log_indent, 0, 3 << 3);
}

// pcap_callback
// file fprobe.c line 966
void pcap_callback(unsigned char *useless, struct pcap_pkthdr *pkthdr, const unsigned char *packet)
{
  struct ip *nl;
  void *tl;
  struct Flow *flow;
  signed int off_frag;
  signed int psize;
  _Bool tmp_if_expr$1;
  unsigned int tmp_if_expr$3;
  unsigned short int tmp_statement_expression$2;
  unsigned short int tmp_statement_expression$4;
  unsigned short int tmp_statement_expression$5;
  unsigned short int tmp_statement_expression$7;
  unsigned short int tmp_statement_expression$6;
  unsigned short int tmp_statement_expression$8;
  unsigned short int tmp_statement_expression$9;
  if(killed == 0)
  {
    nl = (struct ip *)((void *)packet + (signed long int)off_nl);
    psize = (signed int)(pkthdr->caplen - (unsigned int)off_nl);
    if(!(psize >= (signed int)sizeof(struct ip) /*20*/ ))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)nl->ip_v != 4 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1)
    {
      if(pending_head->flags == 0)
      {
        flow = pending_head;
        if(!(link_layer == 0))
          tmp_if_expr$3 = pkthdr->len;

        else
        {
          unsigned short int pcap_callback$$1$$3$$__v;
          unsigned short int pcap_callback$$1$$3$$__x = (unsigned short int)nl->ip_len;
          asm("rorw $8, %w0" : "=r"(pcap_callback$$1$$3$$__v) : "0"(pcap_callback$$1$$3$$__x) : "cc");
          tmp_statement_expression$2 = pcap_callback$$1$$3$$__v;
          tmp_if_expr$3 = (unsigned int)tmp_statement_expression$2;
        }
        flow->size = (unsigned long int)tmp_if_expr$3;
        flow->sip = nl->ip_src;
        flow->dip = nl->ip_dst;
        flow->tos = nl->ip_tos;
        flow->proto = nl->ip_p;
        flow->id = (unsigned short int)0;
        flow->tcp_flags = (unsigned char)0;
        flow->pkts = (unsigned long int)1;
        flow->sizeF = (unsigned long int)0;
        flow->sizeP = (unsigned long int)0;
        flow->ctime.sec = pkthdr->ts.tv_sec;
        flow->ctime.usec = pkthdr->ts.tv_usec;
        flow->mtime = flow->ctime;
        unsigned short int pcap_callback$$1$$4$$__v;
        unsigned short int pcap_callback$$1$$4$$__x = (unsigned short int)nl->ip_off;
        asm("rorw $8, %w0" : "=r"(pcap_callback$$1$$4$$__v) : "0"(pcap_callback$$1$$4$$__x) : "cc");
        tmp_statement_expression$4 = pcap_callback$$1$$4$$__v;
        off_frag = ((signed int)tmp_statement_expression$4 & 0x1fff) << 3;
        off_tl = (signed int)nl->ip_hl << 2;
        tl = (void *)nl + (signed long int)off_tl;
        unsigned short int pcap_callback$$1$$5$$__v;
        unsigned short int pcap_callback$$1$$5$$__x = (unsigned short int)nl->ip_len;
        asm("rorw $8, %w0" : "=r"(pcap_callback$$1$$5$$__v) : "0"(pcap_callback$$1$$5$$__x) : "cc");
        tmp_statement_expression$5 = pcap_callback$$1$$5$$__v;
        flow->sizeF = (unsigned long int)((signed int)tmp_statement_expression$5 - off_tl);
        psize = psize - off_tl;
        if(!((signed int)flow->sizeF >= 0))
          flow->sizeF = (unsigned long int)0;

        if(!((signed int)flow->sizeF >= psize))
          psize = (signed int)flow->sizeF;

        unsigned short int pcap_callback$$1$$6$$__v;
        unsigned short int pcap_callback$$1$$6$$__x = (unsigned short int)nl->ip_off;
        asm("rorw $8, %w0" : "=r"(pcap_callback$$1$$6$$__v) : "0"(pcap_callback$$1$$6$$__x) : "cc");
        tmp_statement_expression$7 = pcap_callback$$1$$6$$__v;
        if(!((16383 & (signed int)tmp_statement_expression$7) == 0))
        {
          flow->flags = flow->flags | 0x0001;
          flow->id = nl->ip_id;
          unsigned short int pcap_callback$$1$$7$$1$$__v;
          unsigned short int pcap_callback$$1$$7$$1$$__x = (unsigned short int)nl->ip_off;
          asm("rorw $8, %w0" : "=r"(pcap_callback$$1$$7$$1$$__v) : "0"(pcap_callback$$1$$7$$1$$__x) : "cc");
          tmp_statement_expression$6 = pcap_callback$$1$$7$$1$$__v;
          if((0x2000 & (signed int)tmp_statement_expression$6) == 0)
          {
            flow->flags = flow->flags | 0x0008;
            flow->sizeP = (unsigned long int)off_frag + flow->sizeF;
          }

        }

        if(off_frag == 0 && psize >= 8)
        {
          switch((signed int)flow->proto)
          {
            case 6:

            case 17:
            {
              flow->sp = ((struct udphdr *)tl)->$anon0.$anon0.uh_sport;
              flow->dp = ((struct udphdr *)tl)->$anon0.$anon0.uh_dport;
              break;
            }
            case 1:
            {
              unsigned short int __v;
              unsigned short int __x = (unsigned short int)((struct icmp *)tl)->icmp_type;
              asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
              tmp_statement_expression$8 = __v;
              flow->sp = tmp_statement_expression$8;
              unsigned short int pcap_callback$$1$$8$$1$$2$$__v;
              unsigned short int pcap_callback$$1$$8$$1$$2$$__x = (unsigned short int)((struct icmp *)tl)->icmp_code;
              asm("rorw $8, %w0" : "=r"(pcap_callback$$1$$8$$1$$2$$__v) : "0"(pcap_callback$$1$$8$$1$$2$$__x) : "cc");
              tmp_statement_expression$9 = pcap_callback$$1$$8$$1$$2$$__v;
              flow->dp = tmp_statement_expression$9;
              break;
            }
            default:
            {
              flow->sp = (unsigned short int)0;
              flow->dp = (unsigned short int)0;
              goto __CPROVER_DUMP_L28;
            }
          }

        tl_known:
          ;
          flow->flags = flow->flags | 0x0004;
        }


      __CPROVER_DUMP_L28:
        ;
        if((signed int)flow->proto == 6)
        {
          if(!(off_frag >= 16))
          {
            if(psize >= 16 + -off_frag)
              flow->tcp_flags = *((unsigned char *)((tl + (signed long int)13) - (signed long int)off_frag));

          }

        }

        pending_head->flags = pending_head->flags | 0x8000;
        pending_head = pending_head->next;
      }


    done:
      ;
      pthread_cond_signal(&unpending_cond);
      goto __CPROVER_DUMP_L31;
      useless = ((unsigned char *)NULL);
    }

  }


__CPROVER_DUMP_L31:
  ;
}

// pcap_thread
// file fprobe.c line 1165
void * pcap_thread()
{
  setuser();
  pcap_loop(pcap_handle, -1, pcap_callback, ((unsigned char *)NULL));
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  char *return_value_strerror$2;
  return_value_strerror$2=strerror(*return_value___errno_location$1);
  my_log((unsigned int)6, "pcap_loop() terminated: %s", return_value_strerror$2);
  kill(pid, 15);
  return NULL;
}

// put_into
// file fprobe.c line 467
signed int put_into(struct Flow *flow, signed int flag)
{
  signed int ret = 0;
  unsigned short int h;
  struct Flow *flown;
  struct Flow **flowpp;
  h=hash_flow(flow);
  pthread_mutex_lock(&flows_mutex[(signed long int)h]);
  flowpp = &flows[(signed long int)h];
  flown=find(flows[(signed long int)h], flow, &flowpp);
  if(flown == ((struct Flow *)NULL))
  {
    if(flag == 0)
    {
      void *return_value_mem_alloc$1;
      return_value_mem_alloc$1=mem_alloc();
      flown = (struct Flow *)return_value_mem_alloc$1;
      if(!(flown == ((struct Flow *)NULL)))
      {
        copy_flow(flow, flown);
        flow = flown;
      }

      else
        return -1;
    }

    flow->next = flows[(signed long int)h];
    flows[(signed long int)h] = flow;
  }

  else
  {
    signed long int return_value_cmpmtime$2;
    return_value_cmpmtime$2=cmpmtime(&flow->mtime, &flown->mtime);
    if(return_value_cmpmtime$2 >= 1l)
      flown->mtime = flow->mtime;

    signed long int return_value_cmpmtime$3;
    return_value_cmpmtime$3=cmpmtime(&flow->ctime, &flown->ctime);
    if(!(return_value_cmpmtime$3 >= 0l))
      flown->ctime = flow->ctime;

    flown->tcp_flags = flown->tcp_flags | flow->tcp_flags;
    flown->size = flown->size + flow->size;
    flown->pkts = flown->pkts + flow->pkts;
    if(!((0x0001 & flow->flags) == 0))
    {
      if(!((0x0004 & flow->flags) == 0))
      {
        flown->sp = flow->sp;
        flown->dp = flow->dp;
      }

      if(!((0x0008 & flow->flags) == 0))
        flown->sizeP = flow->sizeP;

      flown->flags = flown->flags | flow->flags;
      flown->sizeF = flown->sizeF + flow->sizeF;
      if(!((0x0008 & flown->flags) == 0))
      {
        if(flown->sizeF >= flown->sizeP)
        {
          *flowpp = flown->next;
          pthread_mutex_unlock(&flows_mutex[(signed long int)h]);
          flown->id = (unsigned short int)0;
          flown->flags = flown->flags & ~0x0001;
          ret=put_into(flown, 1);
        }

      }

    }

    if(flag == 1)
      mem_free((void *)flow);

  }
  pthread_mutex_unlock(&flows_mutex[(signed long int)h]);
  return ret;
}

// scan_thread
// file fprobe.c line 871
void * scan_thread()
{
  signed int i;
  struct Flow *flow;
  struct Flow **flowpp;
  struct Time now;
  struct timespec timeout;
  setuser();
  timeout.tv_nsec = (signed long int)0;
  pthread_mutex_lock(&scan_mutex);
  _Bool tmp_if_expr$1;
  do
  {
    gettime(&now);
    timeout.tv_sec = now.sec + (signed long int)scan_interval;
    pthread_cond_timedwait(&scan_cond, &scan_mutex, &timeout);
    gettime(&now);
    i = 0;
    for( ; !(i >= 65536); i = i + 1)
    {
      pthread_mutex_lock(&flows_mutex[(signed long int)i]);
      flow = flows[(signed long int)i];
      flowpp = &flows[(signed long int)i];
      while(!(flow == ((struct Flow *)NULL)))
      {
        if(!((0x0001 & flow->flags) == 0))
        {
          if(!((signed long int)frag_lifetime >= now.sec + -flow->mtime.sec))
          {
            *flowpp = flow->next;
            flow->id = (unsigned short int)0;
            flow->flags = flow->flags & ~0x0001;
            flow->next = scan_frag_dreg;
            scan_frag_dreg = flow;
            flow = *flowpp;
            continue;
          }

        }

        else
        {
          if(!((signed long int)inactive_lifetime >= now.sec + -flow->mtime.sec))
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = flow->mtime.sec - flow->ctime.sec > (signed long int)active_lifetime ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$1)
          {
            *flowpp = flow->next;
            pthread_mutex_lock(&emit_mutex);
            flow->next = flows_emit;
            flows_emit = flow;
            pthread_mutex_unlock(&emit_mutex);
            flow = *flowpp;
            continue;
          }

        }
        flowpp = &flow->next;
        flow = flow->next;
      }
      pthread_mutex_unlock(&flows_mutex[(signed long int)i]);
    }
    if(!(flows_emit == ((struct Flow *)NULL)))
      pthread_cond_signal(&emit_cond);

    while(!(scan_frag_dreg == ((struct Flow *)NULL)))
    {
      flow = scan_frag_dreg;
      scan_frag_dreg = flow->next;
      put_into(flow, 1);
    }
  }
  while((_Bool)1);
}

// setuser
// file fprobe.c line 718
void setuser()
{
  if(!(pw == ((struct passwd *)NULL)))
  {
    setgroups((unsigned long int)0, (const unsigned int *)(void *)0);
    setregid(pw->pw_gid, pw->pw_gid);
    setreuid(pw->pw_uid, pw->pw_uid);
  }

}

// sighandler
// file fprobe.c line 373
void sighandler(signed int sig)
{
  if(sig == 15)
    sigs = sigs | 2;

}

// snprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
static inline signed int snprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  signed int return_value___builtin___snprintf_chk$2;
  return_value___builtin___snprintf_chk$2=__builtin___snprintf_chk(__s, __n, 2 - 1, 18446744073709551615ul, __fmt, return_value___builtin_va_arg_pack$1);
  return return_value___builtin___snprintf_chk$2;
}

// snprintf$link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
static inline signed int snprintf$link1(char * restrict __s$link1, unsigned long int __n$link1, const char * restrict __fmt$link1, ...)
{
  void *return_value___builtin_va_arg_pack$1$link1;
  return_value___builtin_va_arg_pack$1$link1=__builtin_va_arg_pack();
  signed int return_value___builtin___snprintf_chk$2$link1;
  return_value___builtin___snprintf_chk$2$link1=__builtin___snprintf_chk(__s$link1, __n$link1, 2 - 1, 18446744073709551615ul, __fmt$link1, return_value___builtin_va_arg_pack$1$link1);
  return return_value___builtin___snprintf_chk$2$link1;
}

// sprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 31
static inline signed int sprintf(char * restrict __s, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  signed int return_value___builtin___sprintf_chk$2;
  return_value___builtin___sprintf_chk$2=__builtin___sprintf_chk(__s, 2 - 1, 18446744073709551615ul, __fmt, return_value___builtin_va_arg_pack$1);
  return return_value___builtin___sprintf_chk$2;
}

// strcat
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 146
static inline char * strcat(char * restrict __dest, const char * restrict __src)
{
  char *return_value___builtin___strcat_chk$1;
  return_value___builtin___strcat_chk$1=__builtin___strcat_chk(__dest, __src, 18446744073709551615ul);
  return return_value___builtin___strcat_chk$1;
}

// syslog
// file /usr/include/x86_64-linux-gnu/bits/syslog.h line 29
static inline void syslog(signed int __pri, const char *__fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  __syslog_chk(__pri, 2 - 1, __fmt, return_value___builtin_va_arg_pack$1);
}

// unpending_thread
// file fprobe.c line 824
void * unpending_thread()
{
  struct timeval now;
  struct timespec timeout;
  setuser();
  timeout.tv_nsec = (signed long int)0;
  pthread_mutex_lock(&unpending_mutex);

__CPROVER_DUMP_L1:
  ;
  while((_Bool)1)
  {
    if((0x8000 & pending_tail->flags) == 0)
    {
      gettimeofday(&now, ((struct timezone *)NULL));
      timeout.tv_sec = now.tv_sec + (signed long int)unpending_timeout;
      pthread_cond_timedwait(&unpending_cond, &unpending_mutex, &timeout);
      goto __CPROVER_DUMP_L1;
    }

    signed int return_value_put_into$1;
    return_value_put_into$1=put_into(pending_tail, 0);
    pending_tail->flags = 0;
    pending_tail = pending_tail->next;
  }
}

// usage
// file fprobe.c line 321
void usage()
{
  fprintf(stdout, "fprobe: a NetFlow probe. Version %s\nUsage: fprobe [options] remote:port[/[local][/type]] ...\n\n-h\t\tDisplay this help\n-p\t\tDon't put the interface into promiscuous mode\n-i <interface>\tNetwork interface name\n-f <expression>\tFilter expression (see tcpdump manual for details)\n-s <seconds>\tHow often scan for expired flows [5]\n-g <seconds>\tFragmented flow lifetime [30]\n-d <seconds>\tIdle flow lifetime (inactive timer) [60]\n-e <seconds>\tActive flow lifetime (active timer) [300]\n-n <version>\tNetFlow version for use (1, 5 or 7) [5]\n-a <address>\tUse <address> as source for NetFlow flow\n-x <id>[:<id>]\tWorkaround for SNMP interfaces indexes [0]\n-b <flows>\tMemory bulk size (1..%u) [%u]\n-m <kilobytes>\tMemory limit (0=no limit) [0]\n-q <flows>\tPending queue length [100]\n-B <kilobytes>\tKernel capture buffer size [0]\n-r <priority>\tReal-time priority (0=disabled, %d..%d) [0]\n-t <B:N>\tProduce <N> nanosecond delay after each <B> bytes sent [0:0]\n-S <bytes>\tSnaplen [256]\n-K <bytes>\tLink layer header size\n-k\t\tDon't exclude link layer header from packet size\n-c <directory>\tDirectory to chroot to\n-u <user>\tUser to run as\n-v <level>\tMaximum log level (0=EMERG, ..., 6=INFO, 7=DEBUG) [6]\n-l <[dst][:id]>\tLog destination and log/pidfile idetifier [1]\nremote:port\tAddress of the NetFlow collector\n", (const void *)"1.1", (unsigned int)(void *)-1, bulk_quantity, sched_min, sched_max);
  exit(0);
}

// vsnprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 74
static inline signed int vsnprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, void **__ap)
{
  signed int return_value___builtin___vsnprintf_chk$1;
  return_value___builtin___vsnprintf_chk$1=__builtin___vsnprintf_chk(__s, __n, 2 - 1, 18446744073709551615ul, __fmt, __ap);
  return return_value___builtin___vsnprintf_chk$1;
}

