// #anon_enum_PED_DEVICE_UNKNOWN=0_PED_DEVICE_SCSI=1_PED_DEVICE_IDE=2_PED_DEVICE_DAC960=3_PED_DEVICE_CPQARRAY=4_PED_DEVICE_FILE=5_PED_DEVICE_ATARAID=6_PED_DEVICE_I2O=7_PED_DEVICE_UBD=8_PED_DEVICE_DASD=9_PED_DEVICE_VIODASD=10_PED_DEVICE_SX8=11_PED_DEVICE_DM=12_PED_DEVICE_XVD=13_PED_DEVICE_SDMMC=14_PED_DEVICE_VIRTBLK=15_PED_DEVICE_AOE=16_PED_DEVICE_MD=17_PED_DEVICE_LOOP=18
// file /usr/include/parted/device.h line 33
enum anonymous_5 { PED_DEVICE_UNKNOWN=0, PED_DEVICE_SCSI=1, PED_DEVICE_IDE=2, PED_DEVICE_DAC960=3, PED_DEVICE_CPQARRAY=4, PED_DEVICE_FILE=5, PED_DEVICE_ATARAID=6, PED_DEVICE_I2O=7, PED_DEVICE_UBD=8, PED_DEVICE_DASD=9, PED_DEVICE_VIODASD=10, PED_DEVICE_SX8=11, PED_DEVICE_DM=12, PED_DEVICE_XVD=13, PED_DEVICE_SDMMC=14, PED_DEVICE_VIRTBLK=15, PED_DEVICE_AOE=16, PED_DEVICE_MD=17, PED_DEVICE_LOOP=18 };

// tag-#anon#ST[*{*{SYM#tag-nwipe_context_t_#}_SYM#tag-nwipe_context_t_#_}_*{SYM#tag-nwipe_context_t_#}_SYM#tag-nwipe_context_t_#__'c'||*{SYM#tag-#anon#ST[S32'nwipe_enumerated'||S32'nwipe_selected'||S64'maxeta'||U64'throughput'||U64'errors'||*{U64}_U64_'gui_thread'|]#}_SYM#tag-#anon#ST[S32'nwipe_enumerated'||S32'nwipe_selected'||S64'maxeta'||U64'throughput'||U64'errors'||*{U64}_U64_'gui_thread'|]#_'nwipe_misc_thread_data'|]
// file context.h line 135
struct anonymous_7;

// tag-#anon#ST[*{cS8}_cS8_'label'||*{S32(*{*{V}_V_}_*{V}_V__|*{SYM#tag-#anon#ST[U64'length'||*{U8}_U8_'s'|]#}_SYM#tag-#anon#ST[U64'length'||*{U8}_U8_'s'|]#_)->S32}_S32(*{*{V}_V_}_*{V}_V__|*{SYM#tag-#anon#ST[U64'length'||*{U8}_U8_'s'|]#}_SYM#tag-#anon#ST[U64'length'||*{U8}_U8_'s'|]#_)->S32_'init'||*{S32(*{*{V}_V_}_*{V}_V__|*{V}_V_|U64)->S32}_S32(*{*{V}_V_}_*{V}_V__|*{V}_V_|U64)->S32_'read'|]
// file prng.h line 39
struct anonymous_6;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_2;

// tag-#anon#ST[S32'autonuke'||S32'noblank'||S32'nowait'||S32'nogui'||*{S8}_S8_'banner'||*{V}_V_'method'||ARR4096{S8}_S8_'logfile'||*{SYM#tag-#anon#ST[*{cS8}_cS8_'label'||*{S32(*{*{V}_V_}_*{V}_V__|*{SYM#tag-#anon#ST[U64'length'||*{U8}_U8_'s'|]#}_SYM#tag-#anon#ST[U64'length'||*{U8}_U8_'s'|]#_)->S32}_S32(*{*{V}_V_}_*{V}_V__|*{SYM#tag-#anon#ST[U64'length'||*{U8}_U8_'s'|]#}_SYM#tag-#anon#ST[U64'length'||*{U8}_U8_'s'|]#_)->S32_'init'||*{S32(*{*{V}_V_}_*{V}_V__|*{V}_V_|U64)->S32}_S32(*{*{V}_V_}_*{V}_V__|*{V}_V_|U64)->S32_'read'|]#}_SYM#tag-#anon#ST[*{cS8}_cS8_'label'||*{S32(*{*{V}_V_}_*{V}_V__|*{SYM#tag-#anon#ST[U64'length'||*{U8}_U8_'s'|]#}_SYM#tag-#anon#ST[U64'length'||*{U8}_U8_'s'|]#_)->S32}_S32(*{*{V}_V_}_*{V}_V__|*{SYM#tag-#anon#ST[U64'length'||*{U8}_U8_'s'|]#}_SYM#tag-#anon#ST[U64'length'||*{U8}_U8_'s'|]#_)->S32_'init'||*{S32(*{*{V}_V_}_*{V}_V__|*{V}_V_|U64)->S32}_S32(*{*{V}_V_}_*{V}_V__|*{V}_V_|U64)->S32_'read'|]#_'prng'||S32'rounds'||S32'sync'||ENtag-nwipe_verify_t_#{U32}_U32_'verify'||U32'_pad0'|]
// file options.h line 47
struct anonymous_0;

// tag-#anon#ST[S32'length'||U32'_pad0'||*{S8}_S8_'s'|]
// file method.h line 40
struct anonymous_1;

// tag-#anon#ST[S32'nwipe_enumerated'||S32'nwipe_selected'||S64'maxeta'||U64'throughput'||U64'errors'||*{U64}_U64_'gui_thread'|]
// file context.h line 124
struct anonymous;

// tag-#anon#ST[U64'attr'||ARR5{S32}_S32_'chars'||U32'_pad0'|]
// file /usr/include/curses.h line 397
struct anonymous_4;

// tag-#anon#ST[U64'length'||*{U8}_U8_'s'|]
// file prng.h line 25
struct anonymous_3;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_8;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_PedCHSGeometry
// file /usr/include/parted/device.h line 57
struct _PedCHSGeometry;

// tag-_PedDevice
// file /usr/include/parted/device.h line 55
struct _PedDevice;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_win_st
// file /usr/include/curses.h line 365
struct _win_st;

// tag-hd_driveid
// file /usr/include/linux/hdreg.h line 385
struct hd_driveid;

// tag-ldat
// file /usr/include/curses.h line 412
struct ldat;

// tag-nwipe_context_t_
// file context.h line 73
struct nwipe_context_t_;

// tag-nwipe_device_t_
// file context.h line 28
enum nwipe_device_t_ { NWIPE_DEVICE_UNKNOWN=0, NWIPE_DEVICE_IDE=1, NWIPE_DEVICE_SCSI=2, NWIPE_DEVICE_COMPAQ=3, NWIPE_DEVICE_USB=4, NWIPE_DEVICE_IEEE1394=5 };

// tag-nwipe_log_t_
// file logging.h line 25
enum nwipe_log_t_ { NWIPE_LOG_NONE=0, NWIPE_LOG_DEBUG=1, NWIPE_LOG_INFO=2, NWIPE_LOG_NOTICE=3, NWIPE_LOG_WARNING=4, NWIPE_LOG_ERROR=5, NWIPE_LOG_FATAL=6, NWIPE_LOG_SANITY=7 };

// tag-nwipe_pass_t_
// file context.h line 38
enum nwipe_pass_t_ { NWIPE_PASS_NONE=0, NWIPE_PASS_WRITE=1, NWIPE_PASS_VERIFY=2, NWIPE_PASS_FINAL_BLANK=3, NWIPE_PASS_FINAL_OPS2=4 };

// tag-nwipe_select_t_
// file context.h line 47
enum nwipe_select_t_ { NWIPE_SELECT_NONE=0, NWIPE_SELECT_TRUE=1, NWIPE_SELECT_TRUE_PARENT=2, NWIPE_SELECT_FALSE=3, NWIPE_SELECT_FALSE_CHILD=4, NWIPE_SELECT_DISABLED=5 };

// tag-nwipe_speedring_t_
// file context.h line 61
struct nwipe_speedring_t_;

// tag-nwipe_verify_t_
// file method.h line 30
enum nwipe_verify_t_ { NWIPE_VERIFY_NONE=0, NWIPE_VERIFY_LAST=1, NWIPE_VERIFY_ALL=2 };

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-panel
// file /usr/include/panel.h line 44
struct panel;

// tag-pdat
// file /usr/include/curses.h line 452
struct pdat;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-randctx
// file isaac_rand.h line 23
struct randctx;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-twister_state_t_
// file mt19937ar-cok.h line 18
struct twister_state_t_;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// can_change_color
// file /usr/include/curses.h line 593
extern _Bool can_change_color(void);
// cbreak
// file /usr/include/curses.h line 594
extern signed int cbreak(void);
// check_device
// file device.c line 97
signed int check_device(struct nwipe_context_t_ ***c, struct _PedDevice *dev, signed int dcount);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// compute_stats
// file gui.h line 38
signed int compute_stats(void *ptr);
// curs_set
// file /usr/include/curses.h line 604
extern signed int curs_set(signed int);
// def_prog_mode
// file /usr/include/curses.h line 605
extern signed int def_prog_mode(void);
// del_panel
// file /usr/include/panel.h line 60
extern signed int del_panel(struct panel *);
// delwin
// file /usr/include/curses.h line 610
extern signed int delwin(struct _win_st *);
// display_help
// file options.c line 371
void display_help();
// doupdate
// file /usr/include/curses.h line 613
extern signed int doupdate(void);
// endwin
// file /usr/include/curses.h line 618
extern signed int endwin(void);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fdatasync
// file /usr/include/unistd.h line 1112
extern signed int fdatasync(signed int);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// flock
// file /usr/include/x86_64-linux-gnu/sys/file.h line 51
extern signed int flock(signed int, signed int);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fscanf
// file /usr/include/stdio.h line 425
extern signed int fscanf(struct _IO_FILE *, const char *, ...);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// gmtime
// file /usr/include/time.h line 239
extern struct tm * gmtime(const signed long int *);
// halfdelay
// file /usr/include/curses.h line 628
extern signed int halfdelay(signed int);
// has_colors
// file /usr/include/curses.h line 629
extern _Bool has_colors(void);
// hide_panel
// file /usr/include/panel.h line 58
extern signed int hide_panel(struct panel *);
// init_color
// file /usr/include/curses.h line 640
extern signed int init_color(signed short int, signed short int, signed short int, signed short int);
// init_genrand
// file mt19937ar-cok.c line 52
void init_genrand(struct twister_state_t_ *state, unsigned long int s);
// init_pair
// file /usr/include/curses.h line 641
extern signed int init_pair(signed short int, signed short int, signed short int);
// initscr
// file /usr/include/curses.h line 639
extern struct _win_st * initscr(void);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// isaac
// file isaac_rand.c line 28
void isaac(struct randctx *ctx);
// keypad
// file /usr/include/curses.h line 654
extern signed int keypad(struct _win_st *, _Bool);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mvwprintw
// file /usr/include/curses.h line 706
extern signed int mvwprintw(struct _win_st *, signed int, signed int, const char *, ...);
// new_panel
// file /usr/include/panel.h line 63
extern struct panel * new_panel(struct _win_st *);
// newwin
// file /usr/include/curses.h line 714
extern struct _win_st * newwin(signed int, signed int, signed int, signed int);
// next_state
// file mt19937ar-cok.c line 111
static void next_state(struct twister_state_t_ *state);
// nocbreak
// file /usr/include/curses.h line 716
extern signed int nocbreak(void);
// nodelay
// file /usr/include/curses.h line 717
extern signed int nodelay(struct _win_st *, _Bool);
// noecho
// file /usr/include/curses.h line 718
extern signed int noecho(void);
// nwipe_device_get
// file device.h line 29
signed int nwipe_device_get(struct nwipe_context_t_ ***c, char **devnamelist, signed int ndevnames);
// nwipe_device_scan
// file device.h line 28
signed int nwipe_device_scan(struct nwipe_context_t_ ***c);
// nwipe_dod522022m
// file method.h line 49
void * nwipe_dod522022m(void *ptr);
// nwipe_dodshort
// file method.h line 50
void * nwipe_dodshort(void *ptr);
// nwipe_gui_free
// file gui.h line 27
void nwipe_gui_free(void);
// nwipe_gui_init
// file gui.h line 28
void nwipe_gui_init(void);
// nwipe_gui_load
// file gui.c line 1550
void nwipe_gui_load(void);
// nwipe_gui_method
// file gui.c line 1346
void nwipe_gui_method(void);
// nwipe_gui_noblank
// file gui.c line 1226
void nwipe_gui_noblank(void);
// nwipe_gui_options
// file gui.h line 32
void nwipe_gui_options(void);
// nwipe_gui_prng
// file gui.c line 957
void nwipe_gui_prng(void);
// nwipe_gui_rounds
// file gui.c line 836
void nwipe_gui_rounds(void);
// nwipe_gui_select
// file gui.h line 29
void nwipe_gui_select(signed int count, struct nwipe_context_t_ **c);
// nwipe_gui_status
// file gui.h line 30
void * nwipe_gui_status(void *ptr);
// nwipe_gui_title
// file gui.c line 132
void nwipe_gui_title(struct _win_st *w, const char *s);
// nwipe_gui_verify
// file gui.c line 1093
void nwipe_gui_verify(void);
// nwipe_gutmann
// file method.h line 51
void * nwipe_gutmann(void *ptr);
// nwipe_isaac_init
// file prng.c line 79
signed int nwipe_isaac_init(void **state, struct anonymous_3 *seed);
// nwipe_isaac_read
// file prng.c line 128
signed int nwipe_isaac_read(void **state, void *buffer, unsigned long int count);
// nwipe_log
// file logging.h line 37
void nwipe_log(enum nwipe_log_t_ level, const char *format, ...);
// nwipe_method_label
// file method.h line 46
const char * nwipe_method_label(void *method);
// nwipe_ops2
// file method.h line 52
void * nwipe_ops2(void *ptr);
// nwipe_options_log
// file options.c line 306
void nwipe_options_log(void);
// nwipe_options_parse
// file options.h line 41
signed int nwipe_options_parse(signed int argc, char **argv);
// nwipe_perror
// file logging.h line 38
void nwipe_perror(signed int nwipe_errno, const char *f, const char *s);
// nwipe_random
// file method.h line 53
void * nwipe_random(void *ptr);
// nwipe_random_pass
// file pass.c line 214
signed int nwipe_random_pass(struct nwipe_context_t_ *c);
// nwipe_random_verify
// file pass.c line 35
signed int nwipe_random_verify(struct nwipe_context_t_ *c);
// nwipe_runmethod
// file method.c line 547
signed int nwipe_runmethod(struct nwipe_context_t_ *c, struct anonymous_1 *patterns);
// nwipe_static_pass
// file pass.c line 576
signed int nwipe_static_pass(struct nwipe_context_t_ *c, struct anonymous_1 *pattern);
// nwipe_static_verify
// file pass.c line 377
signed int nwipe_static_verify(struct nwipe_context_t_ *c, struct anonymous_1 *pattern);
// nwipe_twister_init
// file prng.c line 44
signed int nwipe_twister_init(void **state, struct anonymous_3 *seed);
// nwipe_twister_read
// file prng.c line 55
signed int nwipe_twister_read(void **state, void *buffer, unsigned long int count);
// nwipe_update_speedring
// file gui.c line 2088
void nwipe_update_speedring(struct nwipe_speedring_t_ *speedring, unsigned long long int speedring_bytes, signed long int speedring_now);
// nwipe_zero
// file method.h line 54
void * nwipe_zero(void *ptr);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// ped_device_close
// file /usr/include/parted/device.h line 138
extern signed int ped_device_close(struct _PedDevice *);
// ped_device_get
// file /usr/include/parted/device.h line 130
extern struct _PedDevice * ped_device_get(const char *);
// ped_device_get_next
// file /usr/include/parted/device.h line 131
extern struct _PedDevice * ped_device_get_next(const struct _PedDevice *);
// ped_device_open
// file /usr/include/parted/device.h line 137
extern signed int ped_device_open(struct _PedDevice *);
// ped_device_probe_all
// file /usr/include/parted/device.h line 127
extern void ped_device_probe_all();
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_8 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_8 *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_2 *, struct anonymous_2 *);
// pthread_testcancel
// file /usr/include/pthread.h line 520
extern void pthread_testcancel(void);
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// randinit
// file isaac_rand.c line 65
void randinit(struct randctx *ctx, signed int flag);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reset_prog_mode
// file /usr/include/curses.h line 738
extern signed int reset_prog_mode(void);
// setbuf
// file /usr/include/stdio.h line 332
extern void setbuf(struct _IO_FILE *, char *);
// show_panel
// file /usr/include/panel.h line 59
extern signed int show_panel(struct panel *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_2 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_2 *);
// signal_hand
// file nwipe.c line 484
void * signal_hand(void *ptr);
// sigwait
// file /usr/include/signal.h line 270
extern signed int sigwait(const struct anonymous_2 *, signed int *);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_color
// file /usr/include/curses.h line 771
extern signed int start_color(void);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// twister_genrand_int32
// file mt19937ar-cok.c line 125
unsigned long int twister_genrand_int32(struct twister_state_t_ *state);
// twister_init
// file mt19937ar-cok.c line 66
void twister_init(struct twister_state_t_ *state, unsigned long int *init_key, unsigned long int key_length);
// update_panels
// file /usr/include/panel.h line 57
extern void update_panels(void);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waddch
// file /usr/include/curses.h line 792
extern signed int waddch(struct _win_st *, const unsigned long int);
// wattr_on
// file /usr/include/curses.h line 801
extern signed int wattr_on(struct _win_st *, unsigned long int, void *);
// wbkgdset
// file /usr/include/curses.h line 805
extern void wbkgdset(struct _win_st *, unsigned long int);
// wborder
// file /usr/include/curses.h line 806
extern signed int wborder(struct _win_st *, unsigned long int, unsigned long int, unsigned long int, unsigned long int, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
// wclear
// file /usr/include/curses.h line 808
extern signed int wclear(struct _win_st *);
// werase
// file /usr/include/curses.h line 816
extern signed int werase(struct _win_st *);
// wgetch
// file /usr/include/curses.h line 817
extern signed int wgetch(struct _win_st *);
// wmove
// file /usr/include/curses.h line 831
extern signed int wmove(struct _win_st *, signed int, signed int);
// wprintw
// file /usr/include/curses.h line 833
extern signed int wprintw(struct _win_st *, const char *, ...);
// wrefresh
// file /usr/include/curses.h line 836
extern signed int wrefresh(struct _win_st *);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_7
{
  // c
  struct nwipe_context_t_ **c;
  // nwipe_misc_thread_data
  struct anonymous *nwipe_misc_thread_data;
};

struct anonymous_6
{
  // label
  const char *label;
  // init
  signed int (*init)(void **, struct anonymous_3 *);
  // read
  signed int (*read)(void **, void *, unsigned long int);
};

struct anonymous_2
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_0
{
  // autonuke
  signed int autonuke;
  // noblank
  signed int noblank;
  // nowait
  signed int nowait;
  // nogui
  signed int nogui;
  // banner
  char *banner;
  // method
  void *method;
  // logfile
  char logfile[4096l];
  // prng
  struct anonymous_6 *prng;
  // rounds
  signed int rounds;
  // sync
  signed int sync;
  // verify
  enum nwipe_verify_t_ verify;
};

struct anonymous_1
{
  // length
  signed int length;
  // s
  char *s;
};

struct anonymous
{
  // nwipe_enumerated
  signed int nwipe_enumerated;
  // nwipe_selected
  signed int nwipe_selected;
  // maxeta
  signed long int maxeta;
  // throughput
  unsigned long long int throughput;
  // errors
  unsigned long long int errors;
  // gui_thread
  unsigned long int *gui_thread;
};

struct anonymous_4
{
  // attr
  unsigned long int attr;
  // chars
  signed int chars[5l];
};

struct anonymous_3
{
  // length
  unsigned long int length;
  // s
  unsigned char *s;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_8
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _PedCHSGeometry
{
  // cylinders
  signed int cylinders;
  // heads
  signed int heads;
  // sectors
  signed int sectors;
};

struct _PedDevice
{
  // next
  struct _PedDevice *next;
  // model
  char *model;
  // path
  char *path;
  // type
  enum anonymous_5 type;
  // sector_size
  signed long long int sector_size;
  // phys_sector_size
  signed long long int phys_sector_size;
  // length
  signed long long int length;
  // open_count
  signed int open_count;
  // read_only
  signed int read_only;
  // external_mode
  signed int external_mode;
  // dirty
  signed int dirty;
  // boot_dirty
  signed int boot_dirty;
  // hw_geom
  struct _PedCHSGeometry hw_geom;
  // bios_geom
  struct _PedCHSGeometry bios_geom;
  // host
  signed short int host;
  // did
  signed short int did;
  // arch_specific
  void *arch_specific;
};

struct pdat
{
  // _pad_y
  signed short int _pad_y;
  // _pad_x
  signed short int _pad_x;
  // _pad_top
  signed short int _pad_top;
  // _pad_left
  signed short int _pad_left;
  // _pad_bottom
  signed short int _pad_bottom;
  // _pad_right
  signed short int _pad_right;
};

struct _win_st
{
  // _cury
  signed short int _cury;
  // _curx
  signed short int _curx;
  // _maxy
  signed short int _maxy;
  // _maxx
  signed short int _maxx;
  // _begy
  signed short int _begy;
  // _begx
  signed short int _begx;
  // _flags
  signed short int _flags;
  // _attrs
  unsigned long int _attrs;
  // _bkgd
  unsigned long int _bkgd;
  // _notimeout
  _Bool _notimeout;
  // _clear
  _Bool _clear;
  // _leaveok
  _Bool _leaveok;
  // _scroll
  _Bool _scroll;
  // _idlok
  _Bool _idlok;
  // _idcok
  _Bool _idcok;
  // _immed
  _Bool _immed;
  // _sync
  _Bool _sync;
  // _use_keypad
  _Bool _use_keypad;
  // _delay
  signed int _delay;
  // _line
  struct ldat *_line;
  // _regtop
  signed short int _regtop;
  // _regbottom
  signed short int _regbottom;
  // _parx
  signed int _parx;
  // _pary
  signed int _pary;
  // _parent
  struct _win_st *_parent;
  // _pad
  struct pdat _pad;
  // _yoffset
  signed short int _yoffset;
  // _bkgrnd
  struct anonymous_4 _bkgrnd;
};

struct hd_driveid
{
  // config
  unsigned short int config;
  // cyls
  unsigned short int cyls;
  // reserved2
  unsigned short int reserved2;
  // heads
  unsigned short int heads;
  // track_bytes
  unsigned short int track_bytes;
  // sector_bytes
  unsigned short int sector_bytes;
  // sectors
  unsigned short int sectors;
  // vendor0
  unsigned short int vendor0;
  // vendor1
  unsigned short int vendor1;
  // vendor2
  unsigned short int vendor2;
  // serial_no
  unsigned char serial_no[20l];
  // buf_type
  unsigned short int buf_type;
  // buf_size
  unsigned short int buf_size;
  // ecc_bytes
  unsigned short int ecc_bytes;
  // fw_rev
  unsigned char fw_rev[8l];
  // model
  unsigned char model[40l];
  // max_multsect
  unsigned char max_multsect;
  // vendor3
  unsigned char vendor3;
  // dword_io
  unsigned short int dword_io;
  // vendor4
  unsigned char vendor4;
  // capability
  unsigned char capability;
  // reserved50
  unsigned short int reserved50;
  // vendor5
  unsigned char vendor5;
  // tPIO
  unsigned char tPIO;
  // vendor6
  unsigned char vendor6;
  // tDMA
  unsigned char tDMA;
  // field_valid
  unsigned short int field_valid;
  // cur_cyls
  unsigned short int cur_cyls;
  // cur_heads
  unsigned short int cur_heads;
  // cur_sectors
  unsigned short int cur_sectors;
  // cur_capacity0
  unsigned short int cur_capacity0;
  // cur_capacity1
  unsigned short int cur_capacity1;
  // multsect
  unsigned char multsect;
  // multsect_valid
  unsigned char multsect_valid;
  // lba_capacity
  unsigned int lba_capacity;
  // dma_1word
  unsigned short int dma_1word;
  // dma_mword
  unsigned short int dma_mword;
  // eide_pio_modes
  unsigned short int eide_pio_modes;
  // eide_dma_min
  unsigned short int eide_dma_min;
  // eide_dma_time
  unsigned short int eide_dma_time;
  // eide_pio
  unsigned short int eide_pio;
  // eide_pio_iordy
  unsigned short int eide_pio_iordy;
  // words69_70
  unsigned short int words69_70[2l];
  // words71_74
  unsigned short int words71_74[4l];
  // queue_depth
  unsigned short int queue_depth;
  // words76_79
  unsigned short int words76_79[4l];
  // major_rev_num
  unsigned short int major_rev_num;
  // minor_rev_num
  unsigned short int minor_rev_num;
  // command_set_1
  unsigned short int command_set_1;
  // command_set_2
  unsigned short int command_set_2;
  // cfsse
  unsigned short int cfsse;
  // cfs_enable_1
  unsigned short int cfs_enable_1;
  // cfs_enable_2
  unsigned short int cfs_enable_2;
  // csf_default
  unsigned short int csf_default;
  // dma_ultra
  unsigned short int dma_ultra;
  // trseuc
  unsigned short int trseuc;
  // trsEuc
  unsigned short int trsEuc;
  // CurAPMvalues
  unsigned short int CurAPMvalues;
  // mprc
  unsigned short int mprc;
  // hw_config
  unsigned short int hw_config;
  // acoustic
  unsigned short int acoustic;
  // msrqs
  unsigned short int msrqs;
  // sxfert
  unsigned short int sxfert;
  // sal
  unsigned short int sal;
  // spg
  unsigned int spg;
  // lba_capacity_2
  unsigned long long int lba_capacity_2;
  // words104_125
  unsigned short int words104_125[22l];
  // last_lun
  unsigned short int last_lun;
  // word127
  unsigned short int word127;
  // dlf
  unsigned short int dlf;
  // csfo
  unsigned short int csfo;
  // words130_155
  unsigned short int words130_155[26l];
  // word156
  unsigned short int word156;
  // words157_159
  unsigned short int words157_159[3l];
  // cfa_power
  unsigned short int cfa_power;
  // words161_175
  unsigned short int words161_175[15l];
  // words176_205
  unsigned short int words176_205[30l];
  // words206_254
  unsigned short int words206_254[49l];
  // integrity_word
  unsigned short int integrity_word;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct nwipe_speedring_t_
{
  // bytes
  unsigned long long int bytes[30l];
  // bytestotal
  unsigned long long int bytestotal;
  // byteslast
  unsigned long long int byteslast;
  // times
  signed long int times[30l];
  // timestotal
  signed long int timestotal;
  // timeslast
  signed long int timeslast;
  // position
  unsigned long int position;
};

struct nwipe_context_t_
{
  // block_size
  signed int block_size;
  // device_bus
  signed int device_bus;
  // device_fd
  signed int device_fd;
  // device_host
  signed int device_host;
  // device_id
  struct hd_driveid device_id;
  // device_lun
  signed int device_lun;
  // device_major
  signed int device_major;
  // device_minor
  signed int device_minor;
  // device_part
  signed int device_part;
  // device_name
  char *device_name;
  // device_size
  signed long int device_size;
  // device_stat
  struct stat device_stat;
  // device_type
  enum nwipe_device_t_ device_type;
  // device_target
  signed int device_target;
  // eta
  unsigned long long int eta;
  // entropy_fd
  signed int entropy_fd;
  // label
  char *label;
  // pass_count
  signed int pass_count;
  // pass_done
  unsigned long long int pass_done;
  // pass_errors
  unsigned long long int pass_errors;
  // pass_size
  unsigned long long int pass_size;
  // pass_type
  enum nwipe_pass_t_ pass_type;
  // pass_working
  signed int pass_working;
  // prng
  struct anonymous_6 *prng;
  // prng_seed
  struct anonymous_3 prng_seed;
  // prng_state
  void *prng_state;
  // result
  signed int result;
  // round_count
  signed int round_count;
  // round_done
  unsigned long long int round_done;
  // round_errors
  unsigned long long int round_errors;
  // round_size
  unsigned long long int round_size;
  // round_percent
  double round_percent;
  // round_working
  signed int round_working;
  // sector_size
  signed int sector_size;
  // select
  enum nwipe_select_t_ select;
  // signal
  signed int signal;
  // speedring
  struct nwipe_speedring_t_ speedring;
  // sync_status
  signed short int sync_status;
  // thread
  unsigned long int thread;
  // throughput
  unsigned long long int throughput;
  // verify_errors
  unsigned long long int verify_errors;
  // identity
  struct hd_driveid identity;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct panel
{
  // win
  struct _win_st *win;
  // below
  struct panel *below;
  // above
  struct panel *above;
  // user
  const void *user;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct randctx
{
  // randcnt
  unsigned long int randcnt;
  // randrsl
  unsigned long int randrsl[256l];
  // randmem
  unsigned long int randmem[256l];
  // randa
  unsigned long int randa;
  // randb
  unsigned long int randb;
  // randc
  unsigned long int randc;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct twister_state_t_
{
  // array
  unsigned long int array[624l];
  // left
  signed int left;
  // initf
  signed int initf;
  // next
  unsigned long int *next;
};


// COLS
// file /usr/include/curses.h line 1399
extern signed int COLS;
// LINES
// file /usr/include/curses.h line 1401
extern signed int LINES;
// MAX_LOG_LINE_CHARS
// file logging.c line 29
const signed int MAX_LOG_LINE_CHARS = 512;
// acs_map
// file /usr/include/curses.h line 274
extern unsigned long int acs_map[];
// author_name
// file version.c line 9
const char *author_name = "Andy Beverley";
// copyright
// file version.c line 12
const char *copyright = "Copyright Darik Horn <dajhorn-dban@vanadac.com>\nModifications to original dwipe Copyright Andy Beverley <andy@andybev.com>\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.\n";
// email_address
// file version.c line 10
const char *email_address = "andy@andybev.com";
// footer_panel
// file gui.c line 112
struct panel *footer_panel;
// footer_window
// file gui.c line 106
struct _win_st *footer_window;
// header_panel
// file gui.c line 113
struct panel *header_panel;
// header_window
// file gui.c line 107
struct _win_st *header_window;
// log_current_element
// file logging.c line 33
signed int log_current_element = 0;
// log_elements_allocated
// file logging.c line 34
signed int log_elements_allocated = 0;
// log_lines
// file logging.c line 32
char **log_lines;
// main_panel
// file gui.c line 114
struct panel *main_panel;
// main_window
// file gui.c line 108
struct _win_st *main_window;
// mutex1
// file logging.c line 35
union anonymous_8 mutex1 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// nwipe_buttons1
// file gui.c line 126
const char *nwipe_buttons1 = "Ctrl-C=Quit S=Start M=Method P=PRNG V=Verify R=Rounds B=Blanking-pass Space=Select";
// nwipe_buttons2
// file gui.c line 127
const char *nwipe_buttons2 = " J=Up K=Down Space=Select";
// nwipe_buttons3
// file gui.c line 128
const char *nwipe_buttons3 = " B=Blank screen, ctrl-c=Quit";
// nwipe_dod522022m_label
// file method.c line 63
const char *nwipe_dod522022m_label = "DoD 5220.22-M";
// nwipe_dodshort_label
// file method.c line 64
const char *nwipe_dodshort_label = "DoD Short";
// nwipe_gutmann_label
// file method.c line 65
const char *nwipe_gutmann_label = "Gutmann Wipe";
// nwipe_isaac
// file prng.c line 35
struct anonymous_6 nwipe_isaac;
// nwipe_isaac
// file prng.c line 35
struct anonymous_6 nwipe_isaac = { .label="ISAAC (rand.c 20010626)", .init=nwipe_isaac_init, .read=nwipe_isaac_read };
// nwipe_ops2_label
// file method.c line 66
const char *nwipe_ops2_label = "RCMP TSSIT OPS-II";
// nwipe_options
// file options.c line 33
struct anonymous_0 nwipe_options;
// nwipe_random_label
// file method.c line 67
const char *nwipe_random_label = "PRNG Stream";
// nwipe_twister
// file prng.c line 28
struct anonymous_6 nwipe_twister;
// nwipe_twister
// file prng.c line 28
struct anonymous_6 nwipe_twister = { .label="Mersenne Twister (mt19937ar-cok)", .init=nwipe_twister_init,
    .read=nwipe_twister_read };
// nwipe_unknown_label
// file method.c line 70
const char *nwipe_unknown_label = "Unknown Method (FIXME)";
// nwipe_zero_label
// file method.c line 68
const char *nwipe_zero_label = "Quick Erase";
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// options_panel
// file gui.c line 115
struct panel *options_panel;
// options_title
// file gui.c line 120
const char *options_title = " Options ";
// options_window
// file gui.c line 109
struct _win_st *options_window;
// program_name
// file version.c line 8
char *program_name = "nwipe";
// stats_panel
// file gui.c line 116
struct panel *stats_panel;
// stats_title
// file gui.c line 123
const char *stats_title = " Statistics ";
// stats_window
// file gui.c line 110
struct _win_st *stats_window;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// stdscr
// file /usr/include/curses.h line 1395
extern struct _win_st *stdscr;
// version_string
// file version.c line 7
char *version_string = "0.17";
// years
// file version.c line 11
const char *years = "2012";

// check_device
// file device.c line 97
signed int check_device(struct nwipe_context_t_ ***c, struct _PedDevice *dev, signed int dcount)
{
  struct nwipe_context_t_ *next_device;
  signed int return_value_ped_device_open_1;
  return_value_ped_device_open_1=ped_device_open(dev);
  if(return_value_ped_device_open_1 == 0)
    return 0;

  else
  {
    ped_device_close(dev);
    void *return_value_realloc_2;
    return_value_realloc_2=realloc((void *)*c, (unsigned long int)(dcount + 1) * sizeof(struct nwipe_context_t_ *) /*8ul*/ );
    *c = (struct nwipe_context_t_ **)return_value_realloc_2;
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(sizeof(struct nwipe_context_t_) /*1928ul*/ );
    next_device = (struct nwipe_context_t_ *)return_value_malloc_3;
    if(next_device == ((struct nwipe_context_t_ *)NULL))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      nwipe_perror(*return_value___errno_location_4, "check_device", "malloc");
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to create the array of enumeration contexts.");
      return 0;
    }

    memset((void *)next_device, 0, sizeof(struct nwipe_context_t_) /*1928ul*/ );
    next_device->label = dev->model;
    next_device->device_name = dev->path;
    next_device->device_size = dev->length * dev->sector_size;
    ioctl(next_device->device_fd, (unsigned long int)0x030d, &next_device->identity);
    (*c)[(signed long int)dcount] = next_device;
    return 1;
  }
}

// compute_stats
// file gui.h line 38
signed int compute_stats(void *ptr)
{
  struct anonymous_7 *nwipe_thread_data_ptr = (struct anonymous_7 *)ptr;
  struct nwipe_context_t_ **c;
  struct anonymous *nwipe_misc_thread_data;
  c = nwipe_thread_data_ptr->c;
  nwipe_misc_thread_data = nwipe_thread_data_ptr->nwipe_misc_thread_data;
  signed int count = nwipe_misc_thread_data->nwipe_selected;
  signed int nwipe_active = 0;
  signed int i;
  signed long int nwipe_time_now;
  nwipe_time_now=time((signed long int *)(void *)0);
  i = 0;
  for( ; !(i >= count); i = i + 1)
  {
    if(c[(signed long int)i]->thread >= 1ul)
    {
      nwipe_active = nwipe_active + 1;
      nwipe_update_speedring(&c[(signed long int)i]->speedring, c[(signed long int)i]->round_done, nwipe_time_now);
      if(c[(signed long int)i]->speedring.timestotal >= 1l)
      {
        c[(signed long int)i]->throughput = c[(signed long int)i]->speedring.bytestotal / (unsigned long int)c[(signed long int)i]->speedring.timestotal;
        if(c[(signed long int)i]->throughput == 0ul)
          c[(signed long int)i]->throughput = (unsigned long long int)1;

        c[(signed long int)i]->eta = (c[(signed long int)i]->round_size - c[(signed long int)i]->round_done) / c[(signed long int)i]->throughput;
        if(!((unsigned long int)nwipe_misc_thread_data->maxeta >= c[(signed long int)i]->eta))
          nwipe_misc_thread_data->maxeta = (signed long int)c[(signed long int)i]->eta;

      }

      c[(signed long int)i]->round_percent = ((double)c[(signed long int)i]->round_done / (double)c[(signed long int)i]->round_size) * (double)100;
      nwipe_misc_thread_data->throughput = nwipe_misc_thread_data->throughput + c[(signed long int)i]->throughput;
    }

    nwipe_misc_thread_data->errors = nwipe_misc_thread_data->errors + c[(signed long int)i]->pass_errors;
    nwipe_misc_thread_data->errors = nwipe_misc_thread_data->errors + c[(signed long int)i]->verify_errors;
  }
  return nwipe_active;
}

// display_help
// file options.c line 371
void display_help()
{
  printf("Usage: %s [options] [device1] [device2] ...\n", program_name);
  printf("Options:\n");
  puts("  -V, --version           Prints the version number");
  puts("  -h, --help              Prints this help");
  puts("      --autonuke          If no devices have been specified on the command line, starts wiping all");
  puts("                          devices immediately. If devices have been specified, starts wiping only");
  puts("                          those specified devices immediately.");
  puts("      --sync              Open devices in sync mode");
  puts("      --verify=TYPE       Whether to perform verification of erasure (default: last)");
  puts("                          off   - Do not verify");
  puts("                          last  - Verify after the last pass");
  puts("                          all   - Verify every pass");
  puts("  -m, --method=METHOD     The wiping method (default: dodshort). See man page for more details.");
  puts("                          dod522022m / dod       - 7 pass DOD 5220.22-M method");
  puts("                          dodshort / dod3pass    - 3 pass DOD method");
  puts("                          gutmann                - Peter Gutmann's Algorithm");
  puts("                          ops2                   - RCMP TSSIT OPS-II");
  puts("                          random / prng / stream - PRNG Stream");
  puts("                          zero / quick           - Overwrite with zeros");
  puts("  -l, --logfile=FILE      Filename to log to. Default is STDOUT");
  puts("  -p, --prng=METHOD       PRNG option (mersenne|twister|isaac)");
  puts("  -r, --rounds=NUM        Number of times to wipe the device using the selected method (default: 1)");
  puts("      --noblank           Do not blank disk after wipe (default is to complete a final blank pass)");
  puts("      --nowait            Do not wait for a key before exiting (default is to wait)");
  puts("      --nogui             Do not show the GUI interface. Automatically invokes the nowait option");
  puts("                          Must be used with --autonuke option. Send SIGUSR1 to log current stats");
  puts("");
  exit(0);
}

// init_genrand
// file mt19937ar-cok.c line 52
void init_genrand(struct twister_state_t_ *state, unsigned long int s)
{
  signed int j;
  state->array[(signed long int)0] = s & 0xffffffffUL;
  j = 1;
  for( ; !(j >= 624); j = j + 1)
  {
    state->array[(signed long int)j] = 1812433253UL * (state->array[(signed long int)(j - 1)] ^ state->array[(signed long int)(j - 1)] >> 30) + (unsigned long int)j;
    state->array[(signed long int)j] = state->array[(signed long int)j] & 0xffffffffUL;
  }
  state->left = 1;
  state->initf = 1;
}

// isaac
// file isaac_rand.c line 28
void isaac(struct randctx *ctx)
{
  unsigned long int a;
  unsigned long int b;
  unsigned long int x;
  unsigned long int y;
  unsigned long int *m;
  unsigned long int *mm;
  unsigned long int *m2;
  unsigned long int *r;
  unsigned long int *mend;
  mm = ctx->randmem;
  r = ctx->randrsl;
  a = ctx->randa;
  ctx->randc = ctx->randc + 1ul;
  b = ctx->randb + ctx->randc;
  m = mm;
  m2 = m + (signed long int)((1 << 8) / 2);
  mend = m2;
  unsigned long int *tmp_post_1;
  unsigned long int *tmp_post_2;
  unsigned long int *tmp_post_3;
  unsigned long int *tmp_post_4;
  unsigned long int *tmp_post_5;
  unsigned long int *tmp_post_6;
  unsigned long int *tmp_post_7;
  unsigned long int *tmp_post_8;
  unsigned long int *tmp_post_9;
  unsigned long int *tmp_post_10;
  unsigned long int *tmp_post_11;
  unsigned long int *tmp_post_12;
  for( ; !(m >= mend); *tmp_post_12 = b)
  {
    x = *m;
    tmp_post_1 = m2;
    m2 = m2 + 1l;
    a = (a ^ a << 13) + *tmp_post_1;
    tmp_post_2 = m;
    m = m + 1l;
    y = *((unsigned long int *)((unsigned char *)mm + (signed long int)(x & (unsigned long int)((1 << 8) - 1 << 2)))) + a + b;
    *tmp_post_2 = y;
    tmp_post_3 = r;
    r = r + 1l;
    b = *((unsigned long int *)((unsigned char *)mm + (signed long int)(y >> 8 & (unsigned long int)((1 << 8) - 1 << 2)))) + x;
    *tmp_post_3 = b;
    x = *m;
    tmp_post_4 = m2;
    m2 = m2 + 1l;
    a = (a ^ a >> 6) + *tmp_post_4;
    tmp_post_5 = m;
    m = m + 1l;
    y = *((unsigned long int *)((unsigned char *)mm + (signed long int)(x & (unsigned long int)((1 << 8) - 1 << 2)))) + a + b;
    *tmp_post_5 = y;
    tmp_post_6 = r;
    r = r + 1l;
    b = *((unsigned long int *)((unsigned char *)mm + (signed long int)(y >> 8 & (unsigned long int)((1 << 8) - 1 << 2)))) + x;
    *tmp_post_6 = b;
    x = *m;
    tmp_post_7 = m2;
    m2 = m2 + 1l;
    a = (a ^ a << 2) + *tmp_post_7;
    tmp_post_8 = m;
    m = m + 1l;
    y = *((unsigned long int *)((unsigned char *)mm + (signed long int)(x & (unsigned long int)((1 << 8) - 1 << 2)))) + a + b;
    *tmp_post_8 = y;
    tmp_post_9 = r;
    r = r + 1l;
    b = *((unsigned long int *)((unsigned char *)mm + (signed long int)(y >> 8 & (unsigned long int)((1 << 8) - 1 << 2)))) + x;
    *tmp_post_9 = b;
    x = *m;
    tmp_post_10 = m2;
    m2 = m2 + 1l;
    a = (a ^ a >> 16) + *tmp_post_10;
    tmp_post_11 = m;
    m = m + 1l;
    y = *((unsigned long int *)((unsigned char *)mm + (signed long int)(x & (unsigned long int)((1 << 8) - 1 << 2)))) + a + b;
    *tmp_post_11 = y;
    tmp_post_12 = r;
    r = r + 1l;
    b = *((unsigned long int *)((unsigned char *)mm + (signed long int)(y >> 8 & (unsigned long int)((1 << 8) - 1 << 2)))) + x;
  }
  m2 = mm;
  unsigned long int *tmp_post_13;
  unsigned long int *tmp_post_14;
  unsigned long int *tmp_post_15;
  unsigned long int *tmp_post_16;
  unsigned long int *tmp_post_17;
  unsigned long int *tmp_post_18;
  unsigned long int *tmp_post_19;
  unsigned long int *tmp_post_20;
  unsigned long int *tmp_post_21;
  unsigned long int *tmp_post_22;
  unsigned long int *tmp_post_23;
  unsigned long int *tmp_post_24;
  for( ; !(m2 >= mend); *tmp_post_24 = b)
  {
    x = *m;
    tmp_post_13 = m2;
    m2 = m2 + 1l;
    a = (a ^ a << 13) + *tmp_post_13;
    tmp_post_14 = m;
    m = m + 1l;
    y = *((unsigned long int *)((unsigned char *)mm + (signed long int)(x & (unsigned long int)((1 << 8) - 1 << 2)))) + a + b;
    *tmp_post_14 = y;
    tmp_post_15 = r;
    r = r + 1l;
    b = *((unsigned long int *)((unsigned char *)mm + (signed long int)(y >> 8 & (unsigned long int)((1 << 8) - 1 << 2)))) + x;
    *tmp_post_15 = b;
    x = *m;
    tmp_post_16 = m2;
    m2 = m2 + 1l;
    a = (a ^ a >> 6) + *tmp_post_16;
    tmp_post_17 = m;
    m = m + 1l;
    y = *((unsigned long int *)((unsigned char *)mm + (signed long int)(x & (unsigned long int)((1 << 8) - 1 << 2)))) + a + b;
    *tmp_post_17 = y;
    tmp_post_18 = r;
    r = r + 1l;
    b = *((unsigned long int *)((unsigned char *)mm + (signed long int)(y >> 8 & (unsigned long int)((1 << 8) - 1 << 2)))) + x;
    *tmp_post_18 = b;
    x = *m;
    tmp_post_19 = m2;
    m2 = m2 + 1l;
    a = (a ^ a << 2) + *tmp_post_19;
    tmp_post_20 = m;
    m = m + 1l;
    y = *((unsigned long int *)((unsigned char *)mm + (signed long int)(x & (unsigned long int)((1 << 8) - 1 << 2)))) + a + b;
    *tmp_post_20 = y;
    tmp_post_21 = r;
    r = r + 1l;
    b = *((unsigned long int *)((unsigned char *)mm + (signed long int)(y >> 8 & (unsigned long int)((1 << 8) - 1 << 2)))) + x;
    *tmp_post_21 = b;
    x = *m;
    tmp_post_22 = m2;
    m2 = m2 + 1l;
    a = (a ^ a >> 16) + *tmp_post_22;
    tmp_post_23 = m;
    m = m + 1l;
    y = *((unsigned long int *)((unsigned char *)mm + (signed long int)(x & (unsigned long int)((1 << 8) - 1 << 2)))) + a + b;
    *tmp_post_23 = y;
    tmp_post_24 = r;
    r = r + 1l;
    b = *((unsigned long int *)((unsigned char *)mm + (signed long int)(y >> 8 & (unsigned long int)((1 << 8) - 1 << 2)))) + x;
  }
  ctx->randb = b;
  ctx->randa = a;
}

// main
// file nwipe.c line 45
signed int main(signed int argc, char **argv)
{
  signed int nwipe_optind;
  signed int nwipe_enumerated;
  signed int nwipe_error = 0;
  signed int nwipe_selected = 0;
  unsigned long int nwipe_gui_thread;
  unsigned long int nwipe_sigint_thread;
  signed int nwipe_entropy;
  signed int i;
  signed int j;
  signed int r;
  struct nwipe_context_t_ **c1 = ((struct nwipe_context_t_ **)NULL);
  struct nwipe_context_t_ **c2;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)nwipe_enumerated * sizeof(struct nwipe_context_t_ *) /*8ul*/ );
  c2 = (struct nwipe_context_t_ **)return_value_malloc_1;
  nwipe_optind=nwipe_options_parse(argc, argv);
  if(nwipe_optind == argc)
  {
    nwipe_enumerated=nwipe_device_scan(&c1);
    if(nwipe_enumerated == 0)
    {
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "Storage devices not found.");
      return -1;
    }

    else
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_INFO, "Automatically enumerated %i devices.", nwipe_enumerated);
  }

  else
  {
    argv = argv + (signed long int)nwipe_optind;
    argc = argc - nwipe_optind;
    nwipe_enumerated=nwipe_device_get(&c1, argv, argc);
    if(nwipe_enumerated == 0)
      exit(1);

  }
  nwipe_entropy=open("/dev/urandom", 00);
  if(!(nwipe_entropy >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    nwipe_perror(*return_value___errno_location_2, "main", "open");
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to open entropy source %s.", (const void *)"/dev/urandom");
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    return *return_value___errno_location_3;
  }

  nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Opened entropy source '%s'.", (const void *)"/dev/urandom");
  struct anonymous_2 sigset;
  sigemptyset(&sigset);
  sigaddset(&sigset, 1);
  sigaddset(&sigset, 15);
  sigaddset(&sigset, 3);
  sigaddset(&sigset, 2);
  sigaddset(&sigset, 10);
  pthread_sigmask(2, &sigset, (struct anonymous_2 *)(void *)0);
  struct anonymous nwipe_misc_thread_data;
  struct anonymous_7 nwipe_thread_data_ptr;
  nwipe_thread_data_ptr.c = c2;
  nwipe_misc_thread_data.nwipe_enumerated = nwipe_enumerated;
  if(nwipe_options.nogui == 0)
    nwipe_misc_thread_data.gui_thread = &nwipe_gui_thread;

  nwipe_thread_data_ptr.nwipe_misc_thread_data = &nwipe_misc_thread_data;
  union pthread_attr_t pthread_attr;
  pthread_attr_init(&pthread_attr);
  pthread_attr_setdetachstate(&pthread_attr, 1);
  pthread_create(&nwipe_sigint_thread, &pthread_attr, signal_hand, (void *)&nwipe_thread_data_ptr);
  i = 0;
  for( ; !(i >= nwipe_enumerated); i = i + 1)
  {
    c1[(signed long int)i]->entropy_fd = nwipe_entropy;
    if(!(nwipe_options.autonuke == 0))
      c1[(signed long int)i]->select = (enum nwipe_select_t_)NWIPE_SELECT_TRUE;

    else
      c1[(signed long int)i]->select = (enum nwipe_select_t_)NWIPE_SELECT_FALSE;
    c1[(signed long int)i]->prng = nwipe_options.prng;
    c1[(signed long int)i]->prng_seed.length = (unsigned long int)0;
    c1[(signed long int)i]->prng_seed.s = ((unsigned char *)NULL);
    c1[(signed long int)i]->prng_state = NULL;
  }
  signed int tmp_post_4;
  if(!(nwipe_error == 0))
    return -1;

  else
  {
    if(nwipe_options.nogui == 0)
      nwipe_gui_init();

    if(nwipe_options.autonuke == 1)
    {
      if(nwipe_options.nogui == 0)
        nwipe_gui_options();

    }

    else
      if(!(nwipe_options.nogui == 0))
      {
        printf("--nogui option must be used with autonuke option\n");
        exit(1);
      }

      else
        nwipe_gui_select(nwipe_enumerated, c1);
    i = 0;
    for( ; !(i >= nwipe_enumerated); i = i + 1)
      if((signed int)c1[(signed long int)i]->select == NWIPE_SELECT_TRUE)
        nwipe_selected = nwipe_selected + 1;

    nwipe_misc_thread_data.nwipe_selected = nwipe_selected;
    i = 0;
    j = 0;
    for( ; !(i >= nwipe_enumerated); i = i + 1)
      if((signed int)c1[(signed long int)i]->select == NWIPE_SELECT_TRUE)
      {
        tmp_post_4 = j;
        j = j + 1;
        c2[(signed long int)tmp_post_4] = c1[(signed long int)i];
      }

    i = 0;
    for( ; !(i >= nwipe_selected); i = i + 1)
    {
      unsigned long long int size64;
      c2[(signed long int)i]->device_fd=open(c2[(signed long int)i]->device_name, 02);
      if(!(c2[(signed long int)i]->device_fd >= 0))
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        nwipe_perror(*return_value___errno_location_5, "main", "open");
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "Unable to open device '%s'.", c2[(signed long int)i]->device_name);
        c2[(signed long int)i]->select = (enum nwipe_select_t_)NWIPE_SELECT_DISABLED;
        goto __CPROVER_DUMP_L44;
      }

      signed int return_value_fstat_7;
      return_value_fstat_7=fstat(c2[(signed long int)i]->device_fd, &c2[(signed long int)i]->device_stat);
      if(!(return_value_fstat_7 == 0))
      {
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        nwipe_perror(*return_value___errno_location_6, "main", "fstat");
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "Unable to stat file '%s'.", c2[(signed long int)i]->device_name);
        nwipe_error = nwipe_error + 1;
        goto __CPROVER_DUMP_L44;
      }

      if(!((61440u & c2[(signed long int)i]->device_stat.st_mode) == 24576u))
      {
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "'%s' is not a block device.", c2[(signed long int)i]->device_name);
        nwipe_error = nwipe_error + 1;
      }

      else
      {
        unsigned long int return_value_strlen_8;
        return_value_strlen_8=strlen((const char *)c2[(signed long int)i]->identity.serial_no);
        if(!(return_value_strlen_8 == 0ul))
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_INFO, "Device %s has serial number %s", c2[(signed long int)i]->device_name, (const void *)c2[(signed long int)i]->identity.serial_no);

        signed int return_value_ioctl_11;
        return_value_ioctl_11=ioctl(c2[(signed long int)i]->device_fd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(0x12 << 0 + 8) | (unsigned int)(104 << 0) | (unsigned int)(0 << 0 + 8 + 8)), &c2[(signed long int)i]->sector_size);
        if(return_value_ioctl_11 == 0)
        {
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_INFO, "Device '%s' has sector size %i.", c2[(signed long int)i]->device_name, c2[(signed long int)i]->sector_size);
          signed int return_value_ioctl_10;
          return_value_ioctl_10=ioctl(c2[(signed long int)i]->device_fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(0x12 << 0 + 8) | (unsigned int)(112 << 0)) | sizeof(unsigned long int) /*8ul*/  << 0 + 8 + 8, &c2[(signed long int)i]->block_size);
          if(return_value_ioctl_10 == 0)
          {
            if(!(c2[(signed long int)i]->block_size == c2[(signed long int)i]->sector_size))
            {
              nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "Changing '%s' block size from %i to %i.", c2[(signed long int)i]->device_name, c2[(signed long int)i]->block_size, c2[(signed long int)i]->sector_size);
              signed int return_value_ioctl_9;
              return_value_ioctl_9=ioctl(c2[(signed long int)i]->device_fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(0x12 << 0 + 8) | (unsigned int)(113 << 0)) | sizeof(unsigned long int) /*8ul*/  << 0 + 8 + 8, &c2[(signed long int)i]->sector_size);
              if(return_value_ioctl_9 == 0)
                c2[(signed long int)i]->block_size = c2[(signed long int)i]->sector_size;

              else
                nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "Device '%s' failed BLKBSZSET ioctl.", c2[(signed long int)i]->device_name);
            }

          }

          else
          {
            nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "Device '%s' failed BLKBSZGET ioctl.", c2[(signed long int)i]->device_name);
            c2[(signed long int)i]->block_size = 0;
          }
        }

        else
        {
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "Device '%s' failed BLKSSZGET ioctl.", c2[(signed long int)i]->device_name);
          c2[(signed long int)i]->sector_size = 0;
          c2[(signed long int)i]->block_size = 0;
        }
        c2[(signed long int)i]->device_size=lseek(c2[(signed long int)i]->device_fd, (signed long int)0, 2);
        signed int return_value_ioctl_12;
        return_value_ioctl_12=ioctl(c2[(signed long int)i]->device_fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(0x12 << 0 + 8) | (unsigned int)(114 << 0)) | sizeof(unsigned long int) /*8ul*/  << 0 + 8 + 8, &size64);
        if(!(return_value_ioctl_12 == 0))
        {
          fprintf(stderr, "Error: BLKGETSIZE64 failed  on '%s'.\n", c2[(signed long int)i]->device_name);
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "BLKGETSIZE64 failed  on '%s'.\n", c2[(signed long int)i]->device_name);
          nwipe_error = nwipe_error + 1;
        }

        c2[(signed long int)i]->device_size = (signed long int)size64;
        if(!((unsigned long int)c2[(signed long int)i]->device_size == size64))
        {
          fprintf(stderr, "Error: Last-odd-block detected on '%s'.\n", c2[(signed long int)i]->device_name);
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "Last-odd-block detected on '%s'.", c2[(signed long int)i]->device_name);
          nwipe_error = nwipe_error + 1;
        }

        if(c2[(signed long int)i]->device_size == -1l)
        {
          signed int *return_value___errno_location_13;
          return_value___errno_location_13=__errno_location();
          nwipe_perror(*return_value___errno_location_13, "main", "lseek");
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "Unable to determine the size of '%s'.", c2[(signed long int)i]->device_name);
          nwipe_error = nwipe_error + 1;
        }

        else
        {
          signed long int return_value_lseek_14;
          return_value_lseek_14=lseek(c2[(signed long int)i]->device_fd, (signed long int)0, 0);
          r = (signed int)return_value_lseek_14;
          if((signed long int)r == -1l)
          {
            signed int *return_value___errno_location_15;
            return_value___errno_location_15=__errno_location();
            nwipe_perror(*return_value___errno_location_15, "main", "lseek");
            nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "Unable to reset the '%s' file offset.", c2[(signed long int)i]->device_name);
            nwipe_error = nwipe_error + 1;
          }

        }
        if(c2[(signed long int)i]->device_size == 0l)
        {
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "Device '%s' is size %llu.", c2[(signed long int)i]->device_name, c2[(signed long int)i]->device_size);
          nwipe_error = nwipe_error + 1;
          goto __CPROVER_DUMP_L44;
        }

        else
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_INFO, "Device '%s' is size %llu.", c2[(signed long int)i]->device_name, c2[(signed long int)i]->device_size);
        signed int *return_value___errno_location_16;
        return_value___errno_location_16=__errno_location();
        *return_value___errno_location_16=pthread_create(&c2[(signed long int)i]->thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))nwipe_options.method, (void *)c2[(signed long int)i]);
        signed int *return_value___errno_location_19;
        return_value___errno_location_19=__errno_location();
        if(!(*return_value___errno_location_19 == 0))
        {
          signed int *return_value___errno_location_17;
          return_value___errno_location_17=__errno_location();
          nwipe_perror(*return_value___errno_location_17, "main", "pthread_create");
          if(nwipe_options.nogui == 0)
            nwipe_gui_free();

          signed int *return_value___errno_location_18;
          return_value___errno_location_18=__errno_location();
          return *return_value___errno_location_18;
        }

      }

    __CPROVER_DUMP_L44:
      ;
    }
    nodelay(stdscr, (_Bool)0);
    halfdelay(1 * 10);
    struct anonymous_7 nwipe_gui_data;
    if(nwipe_options.nogui == 0)
    {
      nwipe_gui_data.c = c2;
      nwipe_gui_data.nwipe_misc_thread_data = &nwipe_misc_thread_data;
      signed int *return_value___errno_location_20;
      return_value___errno_location_20=__errno_location();
      *return_value___errno_location_20=pthread_create(&nwipe_gui_thread, (const union pthread_attr_t *)(void *)0, nwipe_gui_status, (void *)&nwipe_gui_data);
    }

    i = 0;
    for( ; !(i >= nwipe_selected); i = i + 1)
      if(!(c2[(signed long int)i]->thread == 0ul))
      {
        pthread_join(c2[(signed long int)i]->thread, (void **)(void *)0);
        close(c2[(signed long int)i]->device_fd);
      }

    if(!(nwipe_gui_thread == 0ul))
    {
      pthread_join(nwipe_gui_thread, (void **)(void *)0);
      nocbreak();
      if(nwipe_options.nowait == 0)
        wgetch(stdscr);

      nwipe_gui_free();
    }

    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Nwipe exited.");
    i = 0;
    for( ; !(i >= nwipe_selected); i = i + 1)
      if(!(c2[(signed long int)i]->result >= 0))
        return -1;

    i = 0;
    for( ; !(i >= nwipe_selected); i = i + 1)
      if(c2[(signed long int)i]->result >= 1)
        return 1;

    i = 0;
    for( ; !(i >= log_current_element); i = i + 1)
      printf("%s\n", log_lines[(signed long int)i]);
    return 0;
  }
}

// next_state
// file mt19937ar-cok.c line 111
static void next_state(struct twister_state_t_ *state)
{
  unsigned long int *p = state->array;
  signed int j;
  if(state->initf == 0)
    init_genrand(state, 5489UL);

  state->left = 624;
  state->next = state->array;
  j = (624 - 397) + 1;
  do
  {
    j = j - 1;
    if(j == 0)
      break;

    *p = p[(signed long int)397] ^ (p[(signed long int)0] & 0x80000000UL | p[(signed long int)1] & 0x7fffffffUL) >> 1 ^ ((p[(signed long int)1] & 1UL) != 0ul ? 0x9908b0dfUL : 0UL);
    p = p + 1l;
  }
  while((_Bool)1);
  j = 397;
  do
  {
    j = j - 1;
    if(j == 0)
      break;

    *p = p[(signed long int)(397 - 624)] ^ (p[(signed long int)0] & 0x80000000UL | p[(signed long int)1] & 0x7fffffffUL) >> 1 ^ ((p[(signed long int)1] & 1UL) != 0ul ? 0x9908b0dfUL : 0UL);
    p = p + 1l;
  }
  while((_Bool)1);
  *p = p[(signed long int)(397 - 624)] ^ (p[(signed long int)0] & 0x80000000UL | state->array[(signed long int)0] & 0x7fffffffUL) >> 1 ^ ((state->array[(signed long int)0] & 1UL) != 0ul ? 0x9908b0dfUL : 0UL);
}

// nwipe_device_get
// file device.h line 29
signed int nwipe_device_get(struct nwipe_context_t_ ***c, char **devnamelist, signed int ndevnames)
{
  struct _PedDevice *dev = (struct _PedDevice *)(void *)0;
  signed int i;
  signed int dcount = 0;
  i = 0;
  for( ; !(i >= ndevnames); i = i + 1)
  {
    dev=ped_device_get(devnamelist[(signed long int)i]);
    if(dev == ((struct _PedDevice *)NULL))
      break;

    signed int return_value_check_device_1;
    return_value_check_device_1=check_device(c, dev, dcount);
    if(!(return_value_check_device_1 == 0))
      dcount = dcount + 1;

  }
  return dcount;
}

// nwipe_device_scan
// file device.h line 28
signed int nwipe_device_scan(struct nwipe_context_t_ ***c)
{
  struct _PedDevice *dev = (struct _PedDevice *)(void *)0;
  ped_device_probe_all();
  signed int dcount = 0;
  do
  {
    dev=ped_device_get_next(dev);
    if(dev == ((struct _PedDevice *)NULL))
      break;

    signed int return_value_check_device_1;
    return_value_check_device_1=check_device(c, dev, dcount);
    if(!(return_value_check_device_1 == 0))
      dcount = dcount + 1;

  }
  while((_Bool)1);
  return dcount;
}

// nwipe_dod522022m
// file method.h line 49
void * nwipe_dod522022m(void *ptr)
{
  struct nwipe_context_t_ *c = (struct nwipe_context_t_ *)ptr;
  signed int r;
  char dod[7l];
  struct anonymous_1 patterns[8l] = { { .length=1, .s=&dod[(signed long int)0] },
    { .length=1, .s=&dod[(signed long int)1] },
    { .length=-1, .s="" }, { .length=1, .s=&dod[(signed long int)3] },
    { .length=1, .s=&dod[(signed long int)4] },
    { .length=1, .s=&dod[(signed long int)5] },
    { .length=-1, .s="" }, { .length=0, .s=(char *)(void *)0 } };
  signed long int return_value_read_1;
  return_value_read_1=read(c->entropy_fd, (void *)&dod, sizeof(char [7l]) /*7ul*/ );
  r = (signed int)return_value_read_1;
  if(!((unsigned long int)r == sizeof(char [7l]) /*7ul*/ ))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    r = *return_value___errno_location_2;
    nwipe_perror(r, "nwipe_dod522022m", "read");
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to seed the %s method.", nwipe_dod522022m_label);
    if(!(r >= 0))
    {
      c->result = r;
      return (void *)0;
    }

    else
    {
      c->result = -1;
      return (void *)0;
    }
  }

  dod[(signed long int)1] = (char)~((signed int)dod[(signed long int)0]);
  dod[(signed long int)5] = (char)~((signed int)dod[(signed long int)4]);
  c->result=nwipe_runmethod(c, patterns);
  c->thread = (unsigned long int)0;
  return (void *)0;
}

// nwipe_dodshort
// file method.h line 50
void * nwipe_dodshort(void *ptr)
{
  struct nwipe_context_t_ *c = (struct nwipe_context_t_ *)ptr;
  signed int r;
  char dod[3l];
  struct anonymous_1 patterns[4l] = { { .length=1, .s=&dod[(signed long int)0] },
    { .length=1, .s=&dod[(signed long int)1] },
    { .length=-1, .s="" }, { .length=0, .s=(char *)(void *)0 } };
  signed long int return_value_read_1;
  return_value_read_1=read(c->entropy_fd, (void *)&dod, sizeof(char [3l]) /*3ul*/ );
  r = (signed int)return_value_read_1;
  if(!((unsigned long int)r == sizeof(char [3l]) /*3ul*/ ))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    r = *return_value___errno_location_2;
    nwipe_perror(r, "nwipe_dodshort", "read");
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to seed the %s method.", nwipe_dodshort_label);
    if(!(r >= 0))
    {
      c->result = r;
      return (void *)0;
    }

    else
    {
      c->result = -1;
      return (void *)0;
    }
  }

  dod[(signed long int)1] = (char)~((signed int)dod[(signed long int)0]);
  c->result=nwipe_runmethod(c, patterns);
  c->thread = (unsigned long int)0;
  return (void *)0;
}

// nwipe_gui_free
// file gui.h line 27
void nwipe_gui_free(void)
{
  del_panel(footer_panel);
  del_panel(header_panel);
  del_panel(main_panel);
  del_panel(options_panel);
  del_panel(stats_panel);
  delwin(footer_window);
  delwin(header_window);
  delwin(main_window);
  delwin(options_window);
  delwin(stats_window);
  endwin();
}

// nwipe_gui_init
// file gui.h line 28
void nwipe_gui_init(void)
{
  initscr();
  cbreak();
  noecho();
  keypad(stdscr, (_Bool)1);
  _Bool return_value_has_colors_2;
  return_value_has_colors_2=has_colors();
  if(!(return_value_has_colors_2 == (_Bool)0))
  {
    start_color();
    _Bool return_value_can_change_color_1;
    return_value_can_change_color_1=can_change_color();
    if(!(return_value_can_change_color_1 == (_Bool)0))
      init_color((signed short int)6, (signed short int)128, (signed short int)128, (signed short int)128);

    init_pair((signed short int)1, (signed short int)7, (signed short int)4);
    init_pair((signed short int)2, (signed short int)6, (signed short int)4);
    init_pair((signed short int)3, (signed short int)1, (signed short int)4);
    init_pair((signed short int)4, (signed short int)4, (signed short int)7);
    init_pair((signed short int)5, (signed short int)7, (signed short int)2);
    init_pair((signed short int)6, (signed short int)7, (signed short int)1);
    init_pair((signed short int)7, (signed short int)0, (signed short int)0);
    wbkgdset(stdscr, (unsigned long int)1 << 0 + 8 | (unsigned long int)32);
  }

  wclear(stdscr);
  header_window=newwin(1, COLS, 0, 0);
  header_panel=new_panel(header_window);
  _Bool return_value_has_colors_3;
  return_value_has_colors_3=has_colors();
  if(!(return_value_has_colors_3 == (_Bool)0))
    wbkgdset(header_window, (unsigned long int)4 << 0 + 8 | (unsigned long int)32);

  wclear(header_window);
  nwipe_gui_title(header_window, nwipe_options.banner);
  footer_window=newwin(1, COLS, LINES - 1, 0);
  footer_panel=new_panel(footer_window);
  _Bool return_value_has_colors_4;
  return_value_has_colors_4=has_colors();
  if(!(return_value_has_colors_4 == (_Bool)0))
    wbkgdset(footer_window, (unsigned long int)4 << 0 + 8 | (unsigned long int)32);

  wclear(footer_window);
  options_window=newwin(7, 44, 1, 0);
  options_panel=new_panel(options_window);
  _Bool return_value_has_colors_5;
  return_value_has_colors_5=has_colors();
  if(!(return_value_has_colors_5 == (_Bool)0))
  {
    wbkgdset(options_window, (unsigned long int)1 << 0 + 8 | (unsigned long int)32);
    wattr_on(options_window, (unsigned long int)((unsigned long int)1 << 0 + 8), (void *)0);
  }

  wclear(options_window);
  wborder(options_window, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
  stats_window=newwin(7, 36, 1, 44);
  stats_panel=new_panel(stats_window);
  _Bool return_value_has_colors_6;
  return_value_has_colors_6=has_colors();
  if(!(return_value_has_colors_6 == (_Bool)0))
  {
    wbkgdset(stats_window, (unsigned long int)1 << 0 + 8 | (unsigned long int)32);
    wattr_on(stats_window, (unsigned long int)((unsigned long int)1 << 0 + 8), (void *)0);
  }

  wclear(stats_window);
  wborder(stats_window, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
  nwipe_gui_title(stats_window, stats_title);
  mvwprintw(stats_window, 1, 1, "Runtime:       ");
  mvwprintw(stats_window, 2, 1, "Remaining:     ");
  mvwprintw(stats_window, 3, 1, "Load Averages: ");
  mvwprintw(stats_window, 4, 1, "Throughput:    ");
  mvwprintw(stats_window, 5, 1, "Errors:        ");
  main_window=newwin((LINES - 8) - 1, COLS, 8, 0);
  main_panel=new_panel(main_window);
  _Bool return_value_has_colors_7;
  return_value_has_colors_7=has_colors();
  if(!(return_value_has_colors_7 == (_Bool)0))
  {
    wbkgdset(main_window, (unsigned long int)1 << 0 + 8 | (unsigned long int)32);
    wattr_on(main_window, (unsigned long int)((unsigned long int)1 << 0 + 8), (void *)0);
  }

  werase(main_window);
  wborder(main_window, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
  wrefresh(stdscr);
  wrefresh(header_window);
  wrefresh(footer_window);
  wrefresh(options_window);
  wrefresh(stats_window);
  wrefresh(main_window);
  update_panels();
  doupdate();
  curs_set(0);
}

// nwipe_gui_load
// file gui.c line 1550
void nwipe_gui_load(void)
{
  struct _IO_FILE *nwipe_fp;
  float load_01;
  float load_05;
  float load_15;
  nwipe_fp=fopen("/proc/loadavg", "r");
  mvwprintw(stats_window, 3, 1, "Load Averages:");
  if(!(nwipe_fp == ((struct _IO_FILE *)NULL)))
  {
    signed int return_value_fscanf_2;
    return_value_fscanf_2=fscanf(nwipe_fp, "%f %f %f", &load_01, &load_05, &load_15);
    if(return_value_fscanf_2 == 3)
      mvwprintw(stats_window, 3, 16, "%04.2f %04.2f %04.2f", load_01, load_05, load_15);

    else
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      mvwprintw(stats_window, 3, 16, "(fscanf error %i)", *return_value___errno_location_1);
    }
    fclose(nwipe_fp);
  }

  else
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    mvwprintw(stats_window, 3, 16, "(fopen error %i)", *return_value___errno_location_3);
  }
}

// nwipe_gui_method
// file gui.c line 1346
void nwipe_gui_method(void)
{
  const signed int count = 6;
  const signed int tab1 = 2;
  const signed int tab2 = 30;
  signed int focus = 0;
  signed int yy;
  signed int keystroke;
  werase(footer_window);
  nwipe_gui_title(footer_window, nwipe_buttons2);
  wrefresh(footer_window);
  if((void * (*)(void *))nwipe_options.method == nwipe_zero)
    focus = 0;

  if((void * (*)(void *))nwipe_options.method == nwipe_ops2)
    focus = 1;

  if((void * (*)(void *))nwipe_options.method == nwipe_dodshort)
    focus = 2;

  if((void * (*)(void *))nwipe_options.method == nwipe_dod522022m)
    focus = 3;

  if((void * (*)(void *))nwipe_options.method == nwipe_gutmann)
    focus = 4;

  if((void * (*)(void *))nwipe_options.method == nwipe_random)
    focus = 5;

  signed int tmp_post_1;
  signed int tmp_post_3;
  signed int tmp_post_5;
  signed int tmp_post_7;
  signed int tmp_post_9;
  signed int tmp_post_11;
  signed int tmp_post_13;
  signed int tmp_post_15;
  signed int tmp_post_16;
  signed int tmp_post_17;
  signed int tmp_post_18;
  signed int tmp_post_19;
  signed int tmp_post_20;
  signed int tmp_post_21;
  signed int tmp_post_22;
  signed int tmp_post_23;
  signed int tmp_post_24;
  signed int tmp_post_25;
  signed int tmp_post_26;
  signed int tmp_post_27;
  signed int tmp_post_28;
  signed int tmp_post_29;
  signed int tmp_post_30;
  signed int tmp_post_31;
  signed int tmp_post_32;
  signed int tmp_post_33;
  signed int tmp_post_34;
  signed int tmp_post_35;
  signed int tmp_post_36;
  do
  {
    werase(main_window);
    yy = 2;
    tmp_post_1 = yy;
    yy = yy + 1;
    const char *return_value_nwipe_method_label_2;
    return_value_nwipe_method_label_2=nwipe_method_label((void *)nwipe_zero);
    mvwprintw(main_window, tmp_post_1, tab1, "  %s", return_value_nwipe_method_label_2);
    tmp_post_3 = yy;
    yy = yy + 1;
    const char *return_value_nwipe_method_label_4;
    return_value_nwipe_method_label_4=nwipe_method_label((void *)nwipe_ops2);
    mvwprintw(main_window, tmp_post_3, tab1, "  %s", return_value_nwipe_method_label_4);
    tmp_post_5 = yy;
    yy = yy + 1;
    const char *return_value_nwipe_method_label_6;
    return_value_nwipe_method_label_6=nwipe_method_label((void *)nwipe_dodshort);
    mvwprintw(main_window, tmp_post_5, tab1, "  %s", return_value_nwipe_method_label_6);
    tmp_post_7 = yy;
    yy = yy + 1;
    const char *return_value_nwipe_method_label_8;
    return_value_nwipe_method_label_8=nwipe_method_label((void *)nwipe_dod522022m);
    mvwprintw(main_window, tmp_post_7, tab1, "  %s", return_value_nwipe_method_label_8);
    tmp_post_9 = yy;
    yy = yy + 1;
    const char *return_value_nwipe_method_label_10;
    return_value_nwipe_method_label_10=nwipe_method_label((void *)nwipe_gutmann);
    mvwprintw(main_window, tmp_post_9, tab1, "  %s", return_value_nwipe_method_label_10);
    tmp_post_11 = yy;
    yy = yy + 1;
    const char *return_value_nwipe_method_label_12;
    return_value_nwipe_method_label_12=nwipe_method_label((void *)nwipe_random);
    mvwprintw(main_window, tmp_post_11, tab1, "  %s", return_value_nwipe_method_label_12);
    tmp_post_13 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_13, tab1, "                                             ");
    signed int return_value_wmove_14;
    return_value_wmove_14=wmove(main_window, 2 + focus, tab1);
    if(return_value_wmove_14 == -1)
      -1;

    else
      waddch(main_window, acs_map[(signed long int)(unsigned char)43]);
    switch(focus)
    {
      case 0:
      {
        mvwprintw(main_window, 2, tab2, "syslinux.cfg: nuke=\"nwipe --method zero\"");
        mvwprintw(main_window, 3, tab2, "Security Level: Low (1 pass)");
        tmp_post_15 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_15, tab1, "This method fills the device with zeros. Note that the rounds option does    ");
        tmp_post_16 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_16, tab1, "not apply to this method. This method always runs one round.                 ");
        tmp_post_17 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_17, tab1, "                                                                             ");
        tmp_post_18 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_18, tab1, "Use this method to blank disks before internal redeployment, or before       ");
        tmp_post_19 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_19, tab1, "reinstalling Microsoft Windows to remove the data areas that the format      ");
        tmp_post_20 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_20, tab1, "utility preserves.                                                    ");
        break;
      }
      case 1:
      {
        mvwprintw(main_window, 2, tab2, "syslinux.cfg: nuke=\"nwipe --method ops2\"");
        mvwprintw(main_window, 3, tab2, "Security Level: Medium (8 passes)");
        tmp_post_21 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_21, tab1, "The Royal Canadian Mounted Police Technical Security Standard for            ");
        tmp_post_22 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_22, tab1, "Information Technology, Appendix OPS-II: Media Sanitization.                 ");
        tmp_post_23 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_23, tab1, "                                                                             ");
        tmp_post_24 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_24, tab1, "This implementation, with regards to paragraph 2 section A of the standard,  ");
        tmp_post_25 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_25, tab1, "uses a pattern that is one random byte and that is changed each round.       ");
        break;
      }
      case 2:
      {
        mvwprintw(main_window, 2, tab2, "syslinux.cfg: nuke=\"nwipe --method dodshort\"");
        mvwprintw(main_window, 3, tab2, "Security Level: Medium (3 passes)");
        tmp_post_26 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_26, tab1, "The American Department of Defense 5220.22-M short wipe.                     ");
        tmp_post_27 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_27, tab1, "This method is composed of passes 1,2,7 from the standard wipe.              ");
        break;
      }
      case 3:
      {
        mvwprintw(main_window, 2, tab2, "syslinux.cfg: nuke=\"nwipe --method dod522022m\"");
        mvwprintw(main_window, 3, tab2, "Security Level: Medium (7 passes)");
        tmp_post_28 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_28, tab1, "The American Department of Defense 5220.22-M standard wipe.                  ");
        tmp_post_29 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_29, tab1, "This implementation uses the same algorithm as the Heidi Eraser product.     ");
        break;
      }
      case 4:
      {
        mvwprintw(main_window, 2, tab2, "syslinux.cfg: nuke=\"nwipe --method gutmann\"");
        mvwprintw(main_window, 3, tab2, "Security Level: High (35 passes)");
        tmp_post_30 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_30, tab1, "This is the method described by Peter Gutmann in the paper entitled          ");
        tmp_post_31 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_31, tab1, "\"Secure Deletion of Data from Magnetic and Solid-State Memory\".            ");
        break;
      }
      case 5:
      {
        mvwprintw(main_window, 2, tab2, "syslinux.cfg: nuke=\"nwipe --method random\"");
        mvwprintw(main_window, 3, tab2, "Security Level: Depends on Rounds");
        tmp_post_32 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_32, tab1, "This method fills the device with a stream from the PRNG. It is probably the ");
        tmp_post_33 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_33, tab1, "best method to use on modern hard disk drives because encoding schemes vary. ");
        tmp_post_34 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_34, tab1, "                                                                             ");
        tmp_post_35 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_35, tab1, "This method has a medium security level with 4 rounds, and a high security   ");
        tmp_post_36 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_36, tab1, "level with 8 rounds.                                                         ");
      }
    }
    wborder(main_window, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
    nwipe_gui_title(main_window, " Wipe Method ");
    wrefresh(main_window);
    keystroke=wgetch(stdscr);
    switch(keystroke)
    {
      case 0402:

      case 106:

      case 74:
      {
        if(!(focus >= count + -1))
          focus = focus + 1;

        goto __CPROVER_DUMP_L21;
      }
      case 0403:

      case 107:

      case 75:
      {
        if(focus >= 1)
          focus = focus - 1;

        goto __CPROVER_DUMP_L21;
      }
      case 0407:

      case 0401:
        goto __CPROVER_DUMP_L29;
      default:

        __CPROVER_DUMP_L21:
          ;
    }
  }
  while(!(keystroke == 10) && !(keystroke == 32) && !(keystroke == 0527) && !(keystroke == -1));
  switch(focus)
  {
    case 0:
    {
      nwipe_options.method = (void *)nwipe_zero;
      break;
    }
    case 1:
    {
      nwipe_options.method = (void *)nwipe_ops2;
      break;
    }
    case 2:
    {
      nwipe_options.method = (void *)nwipe_dodshort;
      break;
    }
    case 3:
    {
      nwipe_options.method = (void *)nwipe_dod522022m;
      break;
    }
    case 4:
    {
      nwipe_options.method = (void *)nwipe_gutmann;
      break;
    }
    case 5:
      nwipe_options.method = (void *)nwipe_random;
  }

__CPROVER_DUMP_L29:
  ;
}

// nwipe_gui_noblank
// file gui.c line 1226
void nwipe_gui_noblank(void)
{
  const signed int count = 2;
  const signed int tab1 = 2;
  const signed int tab2 = 40;
  signed int focus = nwipe_options.noblank;
  signed int yy;
  signed int keystroke;
  werase(footer_window);
  nwipe_gui_title(footer_window, nwipe_buttons2);
  wrefresh(footer_window);
  signed int tmp_post_1;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_5;
  signed int tmp_post_6;
  signed int tmp_post_7;
  signed int tmp_post_8;
  while(!(keystroke == -1))
  {
    werase(main_window);
    yy = 2;
    tmp_post_1 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_1, tab1, "  Perform a final blanking pass       ");
    tmp_post_2 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_2, tab1, "  Do not perform final blanking pass  ");
    tmp_post_3 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_3, tab1, "                                      ");
    signed int return_value_wmove_4;
    return_value_wmove_4=wmove(main_window, 2 + focus, tab1);
    if(return_value_wmove_4 == -1)
      -1;

    else
      waddch(main_window, acs_map[(signed long int)(unsigned char)43]);
    switch(focus)
    {
      case 0:
      {
        mvwprintw(main_window, 2, tab2, "syslinux.cfg:  nuke=\"nwipe\"");
        tmp_post_5 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_5, tab1, "Perform a final blanking pass after the wipe, leaving disk with only zeros. ");
        tmp_post_6 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_6, tab1, "                                                                            ");
        break;
      }
      case 1:
      {
        mvwprintw(main_window, 2, tab2, "syslinux.cfg:  nuke=\"nwipe -b\"");
        tmp_post_7 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_7, tab1, "Do not perform a final blanking pass. Leave data as per final wiping pass.  ");
        tmp_post_8 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_8, tab1, "Any verification options will be ignored. Not compatible with Quick Erase.  ");
      }
    }
    wborder(main_window, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
    nwipe_gui_title(main_window, " Final Blanking Pass ");
    wrefresh(main_window);
    keystroke=wgetch(stdscr);
    switch(keystroke)
    {
      case 0402:

      case 106:

      case 74:
      {
        if(!(focus >= count + -1))
          focus = focus + 1;

        goto __CPROVER_DUMP_L15;
      }
      case 0403:

      case 107:

      case 75:
      {
        if(focus >= 1)
          focus = focus - 1;

        goto __CPROVER_DUMP_L15;
      }
      case 0527:

      case 32:

      case 10:
      {
        if(focus >= 0 && !(focus >= count))
          nwipe_options.noblank = focus;

        if(!(nwipe_options.noblank == 0))
          nwipe_options.verify = (enum nwipe_verify_t_)NWIPE_VERIFY_NONE;

        goto __CPROVER_DUMP_L17;
      }
      case 0407:

      case 0401:
        goto __CPROVER_DUMP_L17;
      default:

        __CPROVER_DUMP_L15:
          ;
    }
  }

__CPROVER_DUMP_L17:
  ;
}

// nwipe_gui_options
// file gui.h line 32
void nwipe_gui_options(void)
{
  werase(options_window);
  mvwprintw(options_window, 1, 1, "Entropy: Linux Kernel (urandom)");
  mvwprintw(options_window, 2, 1, "PRNG:    %s", nwipe_options.prng->label);
  const char *return_value_nwipe_method_label_1;
  return_value_nwipe_method_label_1=nwipe_method_label(nwipe_options.method);
  mvwprintw(options_window, 3, 1, "Method:  %s", return_value_nwipe_method_label_1);
  mvwprintw(options_window, 4, 1, "Verify:  ");
  switch((signed int)nwipe_options.verify)
  {
    case NWIPE_VERIFY_NONE:
    {
      wprintw(options_window, "Off");
      break;
    }
    case NWIPE_VERIFY_LAST:
    {
      wprintw(options_window, "Last Pass");
      break;
    }
    case NWIPE_VERIFY_ALL:
    {
      wprintw(options_window, "All Passes");
      break;
    }
    default:
      wprintw(options_window, "Unknown %i", nwipe_options.verify);
  }
  mvwprintw(options_window, 5, 1, "Rounds:  ");
  if(!(nwipe_options.noblank == 0))
    wprintw(options_window, "%i (no final blanking pass)", nwipe_options.rounds);

  else
    wprintw(options_window, "%i (plus blanking pass)", nwipe_options.rounds);
  wborder(options_window, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
  nwipe_gui_title(options_window, options_title);
  wrefresh(options_window);
}

// nwipe_gui_prng
// file gui.c line 957
void nwipe_gui_prng(void)
{
  const signed int count = 2;
  const signed int tab1 = 2;
  const signed int tab2 = 30;
  signed int focus = 0;
  signed int yy;
  signed int keystroke;
  werase(footer_window);
  nwipe_gui_title(footer_window, nwipe_buttons2);
  wrefresh(footer_window);
  if(nwipe_options.prng == &nwipe_twister)
    focus = 0;

  if(nwipe_options.prng == &nwipe_isaac)
    focus = 1;

  signed int tmp_post_1;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  signed int tmp_post_5;
  signed int tmp_post_7;
  signed int tmp_post_8;
  signed int tmp_post_9;
  signed int tmp_post_10;
  signed int tmp_post_11;
  signed int tmp_post_12;
  signed int tmp_post_13;
  signed int tmp_post_14;
  signed int tmp_post_15;
  signed int tmp_post_16;
  while(!(keystroke == -1))
  {
    werase(main_window);
    yy = 2;
    tmp_post_1 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_1, tab1, "");
    tmp_post_2 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_2, tab1, "");
    tmp_post_3 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_3, tab1, "  %s", nwipe_twister.label);
    tmp_post_4 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_4, tab1, "  %s", nwipe_isaac.label);
    tmp_post_5 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_5, tab1, "");
    signed int return_value_wmove_6;
    return_value_wmove_6=wmove(main_window, 4 + focus, tab1);
    if(return_value_wmove_6 == -1)
      -1;

    else
      waddch(main_window, acs_map[(signed long int)(unsigned char)43]);
    switch(focus)
    {
      case 0:
      {
        mvwprintw(main_window, 2, tab2, "syslinux.cfg:  nuke=\"nwipe --prng twister\"");
        tmp_post_7 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_7, tab1, "The Mersenne Twister, by Makoto Matsumoto and Takuji Nishimura, is a        ");
        tmp_post_8 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_8, tab1, "generalized feedback shift register PRNG that is uniform and                ");
        tmp_post_9 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_9, tab1, "equidistributed in 623-dimensions with a proven period of 2^19937-1.        ");
        tmp_post_10 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_10, tab1, "                                                                            ");
        tmp_post_11 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_11, tab1, "This implementation passes the Marsaglia Diehard test suite.                ");
        tmp_post_12 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_12, tab1, "                                                                            ");
        break;
      }
      case 1:
      {
        mvwprintw(main_window, 2, tab2, "syslinux.cfg:  nuke=\"nwipe --prng isaac\"");
        tmp_post_13 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_13, tab1, "ISAAC, by Bob Jenkins, is a PRNG derived from RC4 with a minimum period of  ");
        tmp_post_14 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_14, tab1, "2^40 and an expected period of 2^8295.  It is difficult to recover the      ");
        tmp_post_15 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_15, tab1, "initial PRNG state by cryptanalysis of the ISAAC stream.                    ");
        tmp_post_16 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_16, tab1, "                                                                            ");
      }
    }
    wborder(main_window, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
    nwipe_gui_title(main_window, " Pseudo Random Number Generator ");
    wrefresh(main_window);
    keystroke=wgetch(stdscr);
    switch(keystroke)
    {
      case 0402:

      case 106:

      case 74:
      {
        if(!(focus >= count + -1))
          focus = focus + 1;

        goto __CPROVER_DUMP_L16;
      }
      case 0403:

      case 107:

      case 75:
      {
        if(focus >= 1)
          focus = focus - 1;

        goto __CPROVER_DUMP_L16;
      }
      case 0527:

      case 32:

      case 10:
      {
        if(focus == 0)
          nwipe_options.prng = &nwipe_twister;

        if(focus == 1)
          nwipe_options.prng = &nwipe_isaac;

        goto __CPROVER_DUMP_L18;
      }
      case 0407:

      case 0401:
        goto __CPROVER_DUMP_L18;
      default:

        __CPROVER_DUMP_L16:
          ;
    }
  }

__CPROVER_DUMP_L18:
  ;
}

// nwipe_gui_rounds
// file gui.c line 836
void nwipe_gui_rounds(void)
{
  signed int focus = nwipe_options.rounds;
  const signed int tab1 = 2;
  signed int yy;
  signed int keystroke;
  werase(footer_window);
  wrefresh(footer_window);
  signed int tmp_post_1;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  do
  {
    werase(main_window);
    wborder(main_window, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
    nwipe_gui_title(main_window, " Rounds ");
    yy = 4;
    tmp_post_1 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_1, tab1, "This is the number of times to run the wipe method on each device.");
    tmp_post_2 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_2, tab1, "");
    if(focus >= 1)
    {
      tmp_post_3 = yy;
      yy = yy + 1;
      mvwprintw(main_window, tmp_post_3, tab1, "syslinux.cfg:  nuke=\"nwipe --rounds %i\"", focus);
      mvwprintw(main_window, 2, tab1, "> %i", focus);
    }

    else
    {
      tmp_post_4 = yy;
      yy = yy + 1;
      mvwprintw(main_window, tmp_post_4, tab1, "The number of rounds must be a non-negative integer.");
      mvwprintw(main_window, 2, tab1, "> ");
    }
    curs_set(1);
    wrefresh(main_window);
    keystroke=wgetch(stdscr);
    switch(keystroke)
    {
      case 48:

      case 49:

      case 50:

      case 51:

      case 52:

      case 53:

      case 54:

      case 55:

      case 56:

      case 57:
      {
        if(!(focus >= 100000000))
        {
          focus = focus * 10;
          focus = focus + (keystroke - 48);
        }

        goto __CPROVER_DUMP_L7;
      }
      case 0407:

      case 0404:

      case 127:
        focus = focus / 10;
      default:
      {

      __CPROVER_DUMP_L7:
        ;
        curs_set(0);
      }
    }
  }
  while(!(keystroke == 10) && !(keystroke == -1));
  if(focus >= 1)
    nwipe_options.rounds = focus;

}

// nwipe_gui_select
// file gui.h line 29
void nwipe_gui_select(signed int count, struct nwipe_context_t_ **c)
{
  const char *select_title = " Disks and Partitions ";
  signed int wlines;
  signed int wcols;
  signed int slots;
  signed int offset = 0;
  signed int focus = 0;
  signed int i;
  signed int keystroke;
  signed int yy;
  signed int tmp_if_expr_1;
  if(!(main_window == ((struct _win_st *)NULL)))
    tmp_if_expr_1 = (signed int)main_window->_maxy + 1;

  else
    tmp_if_expr_1 = -1;
  wlines = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  if(!(main_window == ((struct _win_st *)NULL)))
    tmp_if_expr_2 = (signed int)main_window->_maxx + 1;

  else
    tmp_if_expr_2 = -1;
  wcols = tmp_if_expr_2;
  slots = wlines - 4;
  signed int tmp_post_3;
  _Bool tmp_if_expr_4;
  do
  {
    werase(main_window);
    werase(footer_window);
    nwipe_gui_title(footer_window, nwipe_buttons1);
    wrefresh(footer_window);
    nwipe_gui_options();
    yy = 2;
    i = 0;
    for( ; !(i >= slots) && !(i >= count); i = i + 1)
    {
      tmp_post_3 = yy;
      yy = yy + 1;
      mvwprintw(main_window, tmp_post_3, 1, " ");
      if(i + offset == focus)
      {
        if((signed int)c[(signed long int)focus]->select == NWIPE_SELECT_TRUE)
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = (signed int)c[(signed long int)focus]->select == NWIPE_SELECT_FALSE ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_4)
          waddch(main_window, acs_map[(signed long int)(unsigned char)43]);

        else
          waddch(main_window, acs_map[(signed long int)(unsigned char)96]);
      }

      else
        waddch(main_window, (const unsigned long int)32);
      switch((signed int)c[(signed long int)(i + offset)]->select)
      {
        case NWIPE_SELECT_TRUE:
        {
          wprintw(main_window, " [wipe] %i. %s - %s %s (%lld bytes)", i + offset + 1, c[(signed long int)(i + offset)]->device_name, c[(signed long int)(i + offset)]->label, (const void *)c[(signed long int)(i + offset)]->identity.serial_no, c[(signed long int)(i + offset)]->device_size);
          break;
        }
        case NWIPE_SELECT_FALSE:
        {
          wprintw(main_window, " [    ] %i. %s - %s %s (%lld bytes)", i + offset + 1, c[(signed long int)(i + offset)]->device_name, c[(signed long int)(i + offset)]->label, (const void *)c[(signed long int)(i + offset)]->identity.serial_no, c[(signed long int)(i + offset)]->device_size);
          break;
        }
        case NWIPE_SELECT_TRUE_PARENT:
        {
          wprintw(main_window, " [****] %i. %s - %s %s (%lld bytes)", i + offset + 1, c[(signed long int)(i + offset)]->device_name, c[(signed long int)(i + offset)]->label, (const void *)c[(signed long int)(i + offset)]->identity.serial_no, c[(signed long int)(i + offset)]->device_size);
          break;
        }
        case NWIPE_SELECT_FALSE_CHILD:
        {
          wprintw(main_window, " [----] %i. %s - %s %s (%lld bytes)", i + offset + 1, c[(signed long int)(i + offset)]->device_name, c[(signed long int)(i + offset)]->label, (const void *)c[(signed long int)(i + offset)]->identity.serial_no, c[(signed long int)(i + offset)]->device_size);
          break;
        }
        case NWIPE_SELECT_DISABLED:
          wprintw(main_window, " [????] %s", (const void *)"Unrecognized Device");
      }
    }
    if(offset >= 1)
    {
      mvwprintw(main_window, 1, wcols - 8, " More ");
      waddch(main_window, acs_map[(signed long int)(unsigned char)45]);
    }

    if(!(slots >= count + -offset))
    {
      mvwprintw(main_window, wlines - 2, wcols - 8, " More ");
      waddch(main_window, acs_map[(signed long int)(unsigned char)46]);
    }

    wborder(main_window, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
    nwipe_gui_title(main_window, select_title);
    wrefresh(main_window);
    keystroke=wgetch(stdscr);
    switch(keystroke)
    {
      case 0402:

      case 106:

      case 74:
      {
        focus = focus + 1;
        if(focus >= count)
        {
          focus = count - 1;
          break;
        }

        if(focus + -offset >= slots)
        {
          offset = offset + 1;
          break;
        }

        break;
      }
      case 0403:

      case 107:

      case 75:
      {
        focus = focus - 1;
        if(!(focus >= 0))
        {
          focus = 0;
          break;
        }

        if(!(focus >= offset))
        {
          offset = offset - 1;
          break;
        }

        break;
      }
      case 0527:

      case 10:

      case 32:
      {
        if((signed int)c[(signed long int)focus]->select == NWIPE_SELECT_TRUE)
        {
          c[(signed long int)focus]->select = (enum nwipe_select_t_)NWIPE_SELECT_FALSE;
          if(c[(signed long int)focus]->device_part == 0)
          {
            i = 0;
            for( ; !(i >= count); i = i + 1)
              if(c[(signed long int)i]->device_type == c[(signed long int)focus]->device_type)
              {
                if(c[(signed long int)i]->device_host == c[(signed long int)focus]->device_host)
                {
                  if(c[(signed long int)i]->device_bus == c[(signed long int)focus]->device_bus)
                  {
                    if(c[(signed long int)i]->device_target == c[(signed long int)focus]->device_target)
                    {
                      if(c[(signed long int)i]->device_lun == c[(signed long int)focus]->device_lun)
                      {
                        if(c[(signed long int)i]->device_part >= 1)
                          c[(signed long int)i]->select = (enum nwipe_select_t_)NWIPE_SELECT_FALSE;

                      }

                    }

                  }

                }

              }

          }

          else
          {
            signed int j = 0;
            i = 0;
            for( ; !(i >= count); i = i + 1)
              if(c[(signed long int)i]->device_type == c[(signed long int)focus]->device_type)
              {
                if(c[(signed long int)i]->device_host == c[(signed long int)focus]->device_host)
                {
                  if(c[(signed long int)i]->device_bus == c[(signed long int)focus]->device_bus)
                  {
                    if(c[(signed long int)i]->device_target == c[(signed long int)focus]->device_target)
                    {
                      if(c[(signed long int)i]->device_lun == c[(signed long int)focus]->device_lun)
                      {
                        if(c[(signed long int)i]->device_part >= 1)
                        {
                          if((signed int)c[(signed long int)i]->select == NWIPE_SELECT_TRUE)
                            j = j + 1;

                        }

                      }

                    }

                  }

                }

              }

            if(j == 0)
            {
              i = 0;
              for( ; !(i >= count); i = i + 1)
                if(c[(signed long int)i]->device_type == c[(signed long int)focus]->device_type)
                {
                  if(c[(signed long int)i]->device_host == c[(signed long int)focus]->device_host)
                  {
                    if(c[(signed long int)i]->device_bus == c[(signed long int)focus]->device_bus)
                    {
                      if(c[(signed long int)i]->device_target == c[(signed long int)focus]->device_target)
                      {
                        if(c[(signed long int)i]->device_lun == c[(signed long int)focus]->device_lun)
                        {
                          if(c[(signed long int)i]->device_part == 0)
                            c[(signed long int)i]->select = (enum nwipe_select_t_)NWIPE_SELECT_FALSE;

                        }

                      }

                    }

                  }

                }

            }

          }
          break;
        }

        if((signed int)c[(signed long int)focus]->select == NWIPE_SELECT_FALSE)
        {
          c[(signed long int)focus]->select = (enum nwipe_select_t_)NWIPE_SELECT_TRUE;
          if(c[(signed long int)focus]->device_part == 0)
          {
            i = 0;
            for( ; !(i >= count); i = i + 1)
              if(c[(signed long int)i]->device_type == c[(signed long int)focus]->device_type)
              {
                if(c[(signed long int)i]->device_host == c[(signed long int)focus]->device_host)
                {
                  if(c[(signed long int)i]->device_bus == c[(signed long int)focus]->device_bus)
                  {
                    if(c[(signed long int)i]->device_target == c[(signed long int)focus]->device_target)
                    {
                      if(c[(signed long int)i]->device_lun == c[(signed long int)focus]->device_lun)
                      {
                        if(c[(signed long int)i]->device_part >= 1)
                          c[(signed long int)i]->select = (enum nwipe_select_t_)NWIPE_SELECT_TRUE_PARENT;

                      }

                    }

                  }

                }

              }

          }

          else
          {
            i = 0;
            for( ; !(i >= count); i = i + 1)
              if(c[(signed long int)i]->device_type == c[(signed long int)focus]->device_type)
              {
                if(c[(signed long int)i]->device_host == c[(signed long int)focus]->device_host)
                {
                  if(c[(signed long int)i]->device_bus == c[(signed long int)focus]->device_bus)
                  {
                    if(c[(signed long int)i]->device_target == c[(signed long int)focus]->device_target)
                    {
                      if(c[(signed long int)i]->device_lun == c[(signed long int)focus]->device_lun)
                      {
                        if(c[(signed long int)i]->device_part == 0)
                          c[(signed long int)i]->select = (enum nwipe_select_t_)NWIPE_SELECT_FALSE_CHILD;

                      }

                    }

                  }

                }

              }

          }
          break;
        }

        break;
      }
      case 109:

      case 77:
      {
        nwipe_gui_method();
        break;
      }
      case 112:

      case 80:
      {
        nwipe_gui_prng();
        break;
      }
      case 114:

      case 82:
      {
        nwipe_gui_rounds();
        break;
      }
      case 118:

      case 86:
      {
        nwipe_gui_verify();
        break;
      }
      case 98:

      case 66:
        nwipe_gui_noblank();
      default:
        ;
    }
  }
  while(!(keystroke == 83) && !(keystroke == -1));
  werase(main_window);
  wrefresh(main_window);
  werase(footer_window);
  wrefresh(footer_window);
}

// nwipe_gui_status
// file gui.h line 30
void * nwipe_gui_status(void *ptr)
{
  struct anonymous_7 *nwipe_thread_data_ptr = (struct anonymous_7 *)ptr;
  struct nwipe_context_t_ **c;
  struct anonymous *nwipe_misc_thread_data;
  signed int count;
  c = nwipe_thread_data_ptr->c;
  nwipe_misc_thread_data = nwipe_thread_data_ptr->nwipe_misc_thread_data;
  count = nwipe_misc_thread_data->nwipe_selected;
  char *nwipe_tera = "%llu TB/s";
  char *nwipe_giga = "%llu GB/s";
  char *nwipe_mega = "%llu MB/s";
  char *nwipe_kilo = "%llu KB/s";
  char *nwipe_unit = "%llu B/s";
  char *nwipe_format;
  signed long int nwipe_time_now;
  signed int slots;
  signed int wlines;
  signed int wcols;
  signed int i;
  signed int yy;
  signed int keystroke;
  nwipe_misc_thread_data->throughput = (unsigned long long int)0;
  nwipe_misc_thread_data->maxeta = (signed long int)0;
  nwipe_misc_thread_data->errors = (unsigned long long int)0;
  signed int nwipe_hh;
  signed int nwipe_mm;
  signed int nwipe_ss;
  signed int nwipe_active = 1;
  static signed long int nwipe_time_start = (signed long int)0;
  if(nwipe_time_start == 0l)
  {
    signed long int return_value_time_1;
    return_value_time_1=time((signed long int *)(void *)0);
    nwipe_time_start = return_value_time_1 - (signed long int)1;
  }

  signed int tmp_if_expr_2;
  if(!(main_window == ((struct _win_st *)NULL)))
    tmp_if_expr_2 = (signed int)main_window->_maxy + 1;

  else
    tmp_if_expr_2 = -1;
  wlines = tmp_if_expr_2;
  signed int tmp_if_expr_3;
  if(!(main_window == ((struct _win_st *)NULL)))
    tmp_if_expr_3 = (signed int)main_window->_maxx + 1;

  else
    tmp_if_expr_3 = -1;
  wcols = tmp_if_expr_3;
  slots = wlines - 4;
  slots = slots / 3;
  nwipe_gui_title(footer_window, nwipe_buttons3);
  wrefresh(footer_window);
  signed int tmp_post_4;
  signed int tmp_post_5;
  signed int tmp_post_7;
  signed int tmp_post_8;
  signed int tmp_post_9;
  signed int tmp_post_10;
  while(!(nwipe_active == 0))
  {
    nwipe_time_now=time((signed long int *)(void *)0);
    werase(main_window);
    werase(stats_window);
    yy = 2;
    keystroke=wgetch(stdscr);
    static signed int offset;
    static signed int nwipe_gui_blank = 0;
    if(nwipe_gui_blank == 1 && keystroke >= 1)
    {
      nwipe_gui_blank = 0;
      wbkgdset(stdscr, (unsigned long int)1 << 0 + 8);
      wclear(stdscr);
      show_panel(header_panel);
      show_panel(footer_panel);
      show_panel(stats_panel);
      show_panel(options_panel);
      show_panel(main_panel);
      update_panels();
      doupdate();
    }

    else
      if(keystroke >= 1)
        switch(keystroke)
        {
          case 98:

          case 66:
          {
            nwipe_gui_blank = 1;
            hide_panel(header_panel);
            hide_panel(footer_panel);
            hide_panel(stats_panel);
            hide_panel(options_panel);
            hide_panel(main_panel);
            wbkgdset(stdscr, (unsigned long int)7 << 0 + 8);
            wclear(stdscr);
            break;
          }
          case 0402:

          case 106:

          case 74:
          {
            offset = offset + 1;
            if(!(count >= slots))
              offset = 0;

            else
              if(!(count >= offset + slots))
                offset = count - slots;

            break;
          }
          case 0403:

          case 107:

          case 75:
          {
            offset = offset - 1;
            if(!(offset >= 0))
              offset = 0;

          }
          default:
            ;
        }

    if(nwipe_gui_blank == 0)
    {
      nwipe_active=compute_stats(ptr);
      i = offset;
      while(!(i >= offset + slots) && !(i >= count))
      {
        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen((const char *)c[(signed long int)i]->identity.serial_no);
        if(!(return_value_strlen_6 == 0ul))
        {
          tmp_post_4 = yy;
          yy = yy + 1;
          mvwprintw(main_window, tmp_post_4, 2, "%s - %s (%s)", c[(signed long int)i]->device_name, c[(signed long int)i]->label, (const void *)c[(signed long int)i]->identity.serial_no);
        }

        else
        {
          tmp_post_5 = yy;
          yy = yy + 1;
          mvwprintw(main_window, tmp_post_5, 2, "%s - %s", c[(signed long int)i]->device_name, c[(signed long int)i]->label);
        }
        if(c[(signed long int)i]->thread >= 1ul)
        {
          tmp_post_7 = yy;
          yy = yy + 1;
          mvwprintw(main_window, tmp_post_7, 4, "[%05.2f%%, round %i of %i, pass %i of %i] ", c[(signed long int)i]->round_percent, c[(signed long int)i]->round_working, c[(signed long int)i]->round_count, c[(signed long int)i]->pass_working, c[(signed long int)i]->pass_count);
        }

        else
          if(c[(signed long int)i]->result == 0)
          {
            tmp_post_8 = yy;
            yy = yy + 1;
            mvwprintw(main_window, tmp_post_8, 4, "(success) ");
          }

          else
            if(!(c[(signed long int)i]->signal == 0))
            {
              tmp_post_9 = yy;
              yy = yy + 1;
              mvwprintw(main_window, tmp_post_9, 4, "(failure, signal %i) ", c[(signed long int)i]->signal);
            }

            else
            {
              tmp_post_10 = yy;
              yy = yy + 1;
              mvwprintw(main_window, tmp_post_10, 4, "(failure, code %i) ", c[(signed long int)i]->result);
            }
        if(!(c[(signed long int)i]->verify_errors == 0ull))
          wprintw(main_window, "[verify errors: %llu] ", c[(signed long int)i]->verify_errors);

        if(!(c[(signed long int)i]->pass_errors == 0ull))
          wprintw(main_window, "[pass errors: %llu] ", c[(signed long int)i]->pass_errors);

        switch((signed int)c[(signed long int)i]->pass_type)
        {
          case NWIPE_PASS_FINAL_BLANK:
          {
            wprintw(main_window, "[blanking] ");
            goto __CPROVER_DUMP_L27;
          }
          case NWIPE_PASS_FINAL_OPS2:
          {
            wprintw(main_window, "[OPS-II final] ");
            goto __CPROVER_DUMP_L27;
          }
          case NWIPE_PASS_WRITE:
          {
            wprintw(main_window, "[writing] ");
            goto __CPROVER_DUMP_L27;
          }
          case NWIPE_PASS_VERIFY:
            wprintw(main_window, "[verifying] ");
          case NWIPE_PASS_NONE:

          default:
          {

          __CPROVER_DUMP_L27:
            ;
            if(!(c[(signed long int)i]->sync_status == 0))
              wprintw(main_window, "[syncing] ");

            if(c[(signed long int)i]->throughput >= 1000000000000000ul)
              wprintw(main_window, "[%llu TB/s] ", c[(signed long int)i]->throughput / (unsigned long int)1000000000000L);

            else
              if(c[(signed long int)i]->throughput >= 1000000000000ul)
                wprintw(main_window, "[%llu GB/s] ", c[(signed long int)i]->throughput / (unsigned long int)1000000000L);

              else
                if(c[(signed long int)i]->throughput >= 1000000000ul)
                  wprintw(main_window, "[%llu MB/s] ", c[(signed long int)i]->throughput / (unsigned long int)1000000L);

                else
                  if(c[(signed long int)i]->throughput >= 1000000ul)
                    wprintw(main_window, "[%llu KB/s] ", c[(signed long int)i]->throughput / (unsigned long int)1000L);

                  else
                    wprintw(main_window, "[%llu B/s] ", c[(signed long int)i]->throughput / (unsigned long int)1L);
            yy = yy + 1;
            i = i + 1;
          }
        }
      }
      if(offset >= 1)
      {
        mvwprintw(main_window, 1, wcols - 8, " More ");
        waddch(main_window, acs_map[(signed long int)(unsigned char)45]);
      }

      if(!(slots >= count + -offset))
      {
        mvwprintw(main_window, wlines - 2, wcols - 8, " More ");
        waddch(main_window, acs_map[(signed long int)(unsigned char)46]);
      }

      wborder(main_window, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
      wrefresh(main_window);
      nwipe_gui_load();
      unsigned long long int nwipe_throughput = nwipe_misc_thread_data->throughput;
      if(nwipe_throughput >= 1000000000000000ul)
      {
        nwipe_throughput = nwipe_throughput / (unsigned long long int)1000000000000L;
        nwipe_format = nwipe_tera;
      }

      else
        if(nwipe_throughput >= 1000000000000ul)
        {
          nwipe_throughput = nwipe_throughput / (unsigned long long int)1000000000L;
          nwipe_format = nwipe_giga;
        }

        else
          if(nwipe_throughput >= 1000000000ul)
          {
            nwipe_throughput = nwipe_throughput / (unsigned long long int)1000000L;
            nwipe_format = nwipe_mega;
          }

          else
            if(nwipe_throughput >= 1000000ul)
            {
              nwipe_throughput = nwipe_throughput / (unsigned long long int)1000L;
              nwipe_format = nwipe_kilo;
            }

            else
            {
              nwipe_throughput = nwipe_throughput / (unsigned long long int)1L;
              nwipe_format = nwipe_unit;
            }
      mvwprintw(stats_window, 4, 1, "Throughput:");
      if(nwipe_throughput >= 1ul)
        mvwprintw(stats_window, 4, 16, nwipe_format, nwipe_throughput);

      nwipe_time_now = nwipe_time_now - nwipe_time_start;
      nwipe_hh = (signed int)(nwipe_time_now / (signed long int)3600);
      nwipe_time_now = nwipe_time_now % (signed long int)3600;
      nwipe_mm = (signed int)(nwipe_time_now / (signed long int)60);
      nwipe_time_now = nwipe_time_now % (signed long int)60;
      nwipe_ss = (signed int)nwipe_time_now;
      mvwprintw(stats_window, 1, 1, "Runtime:");
      mvwprintw(stats_window, 1, 16, "%02i:%02i:%02i", nwipe_hh, nwipe_mm, nwipe_ss);
      mvwprintw(stats_window, 2, 1, "Remaining:");
      signed long int nwipe_maxeta = nwipe_misc_thread_data->maxeta;
      if(nwipe_maxeta >= 1l)
      {
        nwipe_hh = (signed int)(nwipe_maxeta / (signed long int)3600);
        nwipe_maxeta = nwipe_maxeta % (signed long int)3600;
        nwipe_mm = (signed int)(nwipe_maxeta / (signed long int)60);
        nwipe_maxeta = nwipe_maxeta % (signed long int)60;
        nwipe_ss = (signed int)nwipe_maxeta;
        mvwprintw(stats_window, 2, 16, "%02i:%02i:%02i", nwipe_hh, nwipe_mm, nwipe_ss);
      }

      mvwprintw(stats_window, 5, 1, "Errors:");
      mvwprintw(stats_window, 5, 16, "%llu", nwipe_misc_thread_data->errors);
      wborder(stats_window, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
      unsigned long int return_value_strlen_11;
      return_value_strlen_11=strlen(stats_title);
      mvwprintw(stats_window, 0, (signed int)(((unsigned long int)36 - return_value_strlen_11) / (unsigned long int)2), "%s", stats_title);
      wrefresh(stats_window);
    }

    if((signed int)nwipe_options.logfile[0l] == 0)
    {
      def_prog_mode();
      endwin();
      fflush(stdout);
      setbuf(stdout, (char *)(void *)0);
      pthread_mutex_lock(&mutex1);
      i = 0;
      for( ; !(i >= log_current_element); i = i + 1)
        printf("%s\n", log_lines[(signed long int)i]);
      log_current_element = 0;
      pthread_mutex_unlock(&mutex1);
      reset_prog_mode();
      wrefresh(stdscr);
    }

    pthread_testcancel();
  }
  if((signed int)nwipe_options.logfile[0l] == 0)
    nwipe_gui_title(footer_window, "Wipe finished - press enter to exit. Logged to STDOUT");

  else
  {
    const signed long int nwipe_maxeta_array_size0 = (signed long int)COLS;
    char finish_message[nwipe_maxeta_array_size0];
    snprintf(finish_message, (unsigned long int)nwipe_maxeta_array_size0, "Wipe finished - press enter to exit. Logged to %s", (const void *)nwipe_options.logfile);
    nwipe_gui_title(footer_window, finish_message);
  }
  wrefresh(footer_window);
  nwipe_misc_thread_data->gui_thread = ((unsigned long int *)NULL);
  return (void *)0;
}

// nwipe_gui_title
// file gui.c line 132
void nwipe_gui_title(struct _win_st *w, const char *s)
{
  signed int wy;
  signed int wx;
  signed int tmp_if_expr_1;
  if(!(w == ((struct _win_st *)NULL)))
    tmp_if_expr_1 = (signed int)w->_maxy + 1;

  else
    tmp_if_expr_1 = -1;
  wy = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  if(!(w == ((struct _win_st *)NULL)))
    tmp_if_expr_2 = (signed int)w->_maxx + 1;

  else
    tmp_if_expr_2 = -1;
  wx = tmp_if_expr_2;
  signed int margin;
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(s);
  margin = (signed int)((unsigned long int)wx - return_value_strlen_3);
  if(!(margin >= 0))
    margin = 0;

  mvwprintw(w, 0, margin / 2, "%s", s);
}

// nwipe_gui_verify
// file gui.c line 1093
void nwipe_gui_verify(void)
{
  const signed int count = 3;
  const signed int tab1 = 2;
  const signed int tab2 = 30;
  signed int focus = (signed int)nwipe_options.verify;
  signed int yy;
  signed int keystroke;
  werase(footer_window);
  nwipe_gui_title(footer_window, nwipe_buttons2);
  wrefresh(footer_window);
  signed int tmp_post_1;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  signed int tmp_post_6;
  signed int tmp_post_7;
  signed int tmp_post_8;
  signed int tmp_post_9;
  signed int tmp_post_10;
  signed int tmp_post_11;
  signed int tmp_post_12;
  signed int tmp_post_13;
  signed int tmp_post_14;
  while(!(keystroke == -1))
  {
    werase(main_window);
    yy = 2;
    tmp_post_1 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_1, tab1, "  Verification Off  ");
    tmp_post_2 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_2, tab1, "  Verify Last Pass  ");
    tmp_post_3 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_3, tab1, "  Verify All Passes ");
    tmp_post_4 = yy;
    yy = yy + 1;
    mvwprintw(main_window, tmp_post_4, tab1, "                    ");
    signed int return_value_wmove_5;
    return_value_wmove_5=wmove(main_window, 2 + focus, tab1);
    if(return_value_wmove_5 == -1)
      -1;

    else
      waddch(main_window, acs_map[(signed long int)(unsigned char)43]);
    switch(focus)
    {
      case 0:
      {
        mvwprintw(main_window, 2, tab2, "syslinux.cfg:  nuke=\"nwipe --verify off\"");
        tmp_post_6 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_6, tab1, "Do not verify passes. The wipe will be a write-only operation.              ");
        tmp_post_7 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_7, tab1, "                                                                            ");
        break;
      }
      case 1:
      {
        mvwprintw(main_window, 2, tab2, "syslinux.cfg:  nuke=\"nwipe --verify last\"");
        tmp_post_8 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_8, tab1, "Check whether the device is actually empty after the last pass fills the    ");
        tmp_post_9 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_9, tab1, "device with zeros.                                                          ");
        break;
      }
      case 2:
      {
        mvwprintw(main_window, 2, tab2, "syslinux.cfg:  nuke=\"nwipe --verify all\"");
        tmp_post_10 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_10, tab1, "After every pass, read back the pattern and check whether it is correct.    ");
        tmp_post_11 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_11, tab1, "                                                                            ");
        tmp_post_12 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_12, tab1, "This program writes the entire length of the device before it reads back    ");
        tmp_post_13 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_13, tab1, "for verification, even for random pattern passes, to better ensure that     ");
        tmp_post_14 = yy;
        yy = yy + 1;
        mvwprintw(main_window, tmp_post_14, tab1, "hardware caches are actually flushed.                                       ");
      }
    }
    wborder(main_window, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
    nwipe_gui_title(main_window, " Verification Mode ");
    wrefresh(main_window);
    keystroke=wgetch(stdscr);
    switch(keystroke)
    {
      case 0402:

      case 106:

      case 74:
      {
        if(!(focus >= count + -1))
          focus = focus + 1;

        goto __CPROVER_DUMP_L16;
      }
      case 0403:

      case 107:

      case 75:
      {
        if(focus >= 1)
          focus = focus - 1;

        goto __CPROVER_DUMP_L16;
      }
      case 0527:

      case 32:

      case 10:
      {
        if(focus >= 0 && !(focus >= count))
          nwipe_options.verify = (enum nwipe_verify_t_)focus;

        if(!((signed int)nwipe_options.verify == NWIPE_VERIFY_NONE))
          nwipe_options.noblank = 0;

        goto __CPROVER_DUMP_L18;
      }
      case 0407:

      case 0401:
        goto __CPROVER_DUMP_L18;
      default:

        __CPROVER_DUMP_L16:
          ;
    }
  }

__CPROVER_DUMP_L18:
  ;
}

// nwipe_gutmann
// file method.h line 51
void * nwipe_gutmann(void *ptr)
{
  struct nwipe_context_t_ *c = (struct nwipe_context_t_ *)ptr;
  signed int r;
  signed int i = 35;
  signed int j;
  signed int n;
  struct anonymous_1 book[36l] = { { .length=-1, .s="" }, { .length=-1, .s="" }, { .length=-1, .s="" }, { .length=-1, .s="" }, { .length=3, .s="UUU" }, { .length=3, .s="" }, { .length=3, .s="I_" }, { .length=3, .s="I_" }, { .length=3, .s="_I" }, { .length=3, .s="\0\0\0" }, { .length=3, .s="\021\021\021" }, { .length=3, .s="\"\"\"" }, { .length=3, .s="333" }, { .length=3, .s="DDD" }, { .length=3, .s="UUU" }, { .length=3, .s="fff" }, { .length=3, .s="www" }, { .length=3, .s="" }, { .length=3, .s="" }, { .length=3, .s="" }, { .length=3, .s="" }, { .length=3, .s="" }, { .length=3, .s="" }, { .length=3, .s="" }, { .length=3, .s="" }, { .length=3, .s="I_" }, { .length=3, .s="I_" }, { .length=3, .s="_I" }, { .length=3, .s="m" }, { .length=3, .s="m" }, { .length=3, .s="m" }, { .length=-1, .s="" }, { .length=-1, .s="" }, { .length=-1, .s="" }, { .length=-1, .s="" }, { .length=0, .s=(char *)(void *)0 } };
  struct anonymous_1 patterns[36l];
  const signed long int patterns_array_size0 = (signed long int)i;
  unsigned short int s[patterns_array_size0];
  signed long int return_value_read_1;
  return_value_read_1=read(c->entropy_fd, (void *)&s, 2ul * (unsigned long int)patterns_array_size0);
  r = (signed int)return_value_read_1;
  if(!((unsigned long int)r == 2ul * (unsigned long int)patterns_array_size0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    r = *return_value___errno_location_2;
    nwipe_perror(r, "nwipe_gutmann", "read");
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to seed the %s method.", nwipe_gutmann_label);
    if(!(r >= 0))
    {
      c->result = r;
      return (void *)0;
    }

    else
    {
      c->result = -1;
      return (void *)0;
    }
  }

  signed int tmp_post_3;
  do
  {
    i = i - 1;
    if(!(i >= 0))
      break;

    n = (signed int)(((double)s[(signed long int)i] / (double)(0x0000FFFF + 1)) * (double)(i + 1));
    j = -1;
    do
    {
      tmp_post_3 = n;
      n = n - 1;
      if(!(tmp_post_3 >= 0))
        break;

      j = j + 1;
      for( ; book[(signed long int)j].length == 0; j = j + 1)
        ;
    }
    while((_Bool)1);
    patterns[(signed long int)i] = book[(signed long int)j];
    book[(signed long int)j].length = 0;
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_DEBUG, "nwipe_gutmann: Set patterns[%i] = book[%i].", i, j);
  }
  while((_Bool)1);
  patterns[(signed long int)35].length = 0;
  patterns[(signed long int)35].s = (char *)(void *)0;
  c->result=nwipe_runmethod(c, patterns);
  c->thread = (unsigned long int)0;
  return (void *)0;
}

// nwipe_isaac_init
// file prng.c line 79
signed int nwipe_isaac_init(void **state, struct anonymous_3 *seed)
{
  signed int count;
  struct randctx *isaac_state = (struct randctx *)*state;
  if(*state == NULL)
  {
    *state=malloc(sizeof(struct randctx) /*4128ul*/ );
    isaac_state = (struct randctx *)*state;
    if(isaac_state == ((struct randctx *)NULL))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      nwipe_perror(*return_value___errno_location_1, "nwipe_isaac_init", "malloc");
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to allocate memory for the isaac state.");
      return -1;
    }

  }

  if(seed->length >= 2049ul)
    count = (signed int)sizeof(unsigned long int [256l]) /*2048ul*/ ;

  else
  {
    memset((void *)isaac_state->randrsl, 0, sizeof(unsigned long int [256l]) /*2048ul*/ );
    count = (signed int)seed->length;
  }
  if(count == 0)
    randinit(isaac_state, 0);

  else
  {
    memcpy((void *)isaac_state->randrsl, (const void *)seed->s, (unsigned long int)count);
    randinit(isaac_state, 1);
  }
  return 0;
}

// nwipe_isaac_read
// file prng.c line 128
signed int nwipe_isaac_read(void **state, void *buffer, unsigned long int count)
{
  return 0;
}

// nwipe_log
// file logging.h line 37
void nwipe_log(enum nwipe_log_t_ level, const char *format, ...)
{
  signed long int t;
  struct tm *p;
  t=time((signed long int *)(void *)0);
  p=gmtime(&t);
  pthread_mutex_lock(&mutex1);
  if(log_current_element == log_elements_allocated)
  {
    log_elements_allocated = log_elements_allocated + 1;
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)log_lines, (unsigned long int)log_elements_allocated * sizeof(char *) /*8ul*/ );
    log_lines = (char **)return_value_realloc_1;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)MAX_LOG_LINE_CHARS * sizeof(char) /*1ul*/ );
    log_lines[(signed long int)log_current_element] = (char *)return_value_malloc_2;
  }

  signed int line_current_pos = 0;
  line_current_pos=snprintf(log_lines[(signed long int)log_current_element], (unsigned long int)MAX_LOG_LINE_CHARS, "[%i/%02i/%02i %02i:%02i:%02i] nwipe: ", 1900 + p->tm_year, 1 + p->tm_mon, p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec);
  signed int return_value_snprintf_3;
  signed int return_value_snprintf_4;
  signed int return_value_snprintf_5;
  signed int return_value_snprintf_6;
  signed int return_value_snprintf_7;
  signed int return_value_snprintf_8;
  signed int return_value_snprintf_9;
  switch((signed int)level)
  {
    case NWIPE_LOG_NONE:
      break;
    case NWIPE_LOG_DEBUG:
    {
      return_value_snprintf_3=snprintf(log_lines[(signed long int)log_current_element] + (signed long int)line_current_pos, (unsigned long int)MAX_LOG_LINE_CHARS, "debug: ");
      line_current_pos = line_current_pos + return_value_snprintf_3;
      break;
    }
    case NWIPE_LOG_INFO:
    {
      return_value_snprintf_4=snprintf(log_lines[(signed long int)log_current_element] + (signed long int)line_current_pos, (unsigned long int)MAX_LOG_LINE_CHARS, "info: ");
      line_current_pos = line_current_pos + return_value_snprintf_4;
      break;
    }
    case NWIPE_LOG_NOTICE:
    {
      return_value_snprintf_5=snprintf(log_lines[(signed long int)log_current_element] + (signed long int)line_current_pos, (unsigned long int)MAX_LOG_LINE_CHARS, "notice: ");
      line_current_pos = line_current_pos + return_value_snprintf_5;
      break;
    }
    case NWIPE_LOG_WARNING:
    {
      return_value_snprintf_6=snprintf(log_lines[(signed long int)log_current_element] + (signed long int)line_current_pos, (unsigned long int)MAX_LOG_LINE_CHARS, "warning: ");
      line_current_pos = line_current_pos + return_value_snprintf_6;
      break;
    }
    case NWIPE_LOG_ERROR:
    {
      return_value_snprintf_7=snprintf(log_lines[(signed long int)log_current_element] + (signed long int)line_current_pos, (unsigned long int)MAX_LOG_LINE_CHARS, "error: ");
      line_current_pos = line_current_pos + return_value_snprintf_7;
      break;
    }
    case NWIPE_LOG_FATAL:
    {
      return_value_snprintf_8=snprintf(log_lines[(signed long int)log_current_element] + (signed long int)line_current_pos, (unsigned long int)MAX_LOG_LINE_CHARS, "fatal: ");
      line_current_pos = line_current_pos + return_value_snprintf_8;
      break;
    }
    case NWIPE_LOG_SANITY:
    {
      return_value_snprintf_9=snprintf(log_lines[(signed long int)log_current_element] + (signed long int)line_current_pos, (unsigned long int)MAX_LOG_LINE_CHARS, "sanity: ");
      line_current_pos = line_current_pos + return_value_snprintf_9;
      break;
    }
    default:
    {
      signed int return_value_snprintf_10;
      return_value_snprintf_10=snprintf(log_lines[(signed long int)log_current_element] + (signed long int)line_current_pos, (unsigned long int)MAX_LOG_LINE_CHARS, "level %i: ", level);
      line_current_pos = line_current_pos + return_value_snprintf_10;
    }
  }
  void **ap = (void **)&format;
  signed int return_value_vsnprintf_11;
  return_value_vsnprintf_11=vsnprintf(log_lines[(signed long int)log_current_element] + (signed long int)line_current_pos, (unsigned long int)MAX_LOG_LINE_CHARS, format, ap);
  line_current_pos = line_current_pos + return_value_vsnprintf_11;
  ap = ((void **)NULL);
  signed int r;
  struct _IO_FILE *fp;
  signed int fd;
  if((signed int)nwipe_options.logfile[0l] == 0)
  {
    if(!(nwipe_options.nogui == 0))
      printf("%s\n", log_lines[(signed long int)log_current_element]);

    else
      log_current_element = log_current_element + 1;
  }

  else
  {
    fp=fopen(nwipe_options.logfile, "a");
    if(fp == ((struct _IO_FILE *)NULL))
    {
      fprintf(stderr, "nwipe_log: Unable to open '%s' for logging.\n", (const void *)nwipe_options.logfile);
      goto __CPROVER_DUMP_L19;
    }

    fd=fileno(fp);
    r=flock(fd, 2);
    if(!(r == 0))
    {
      perror("nwipe_log: flock:");
      fprintf(stderr, "nwipe_log: Unable to lock '%s' for logging.\n", (const void *)nwipe_options.logfile);
      goto __CPROVER_DUMP_L19;
    }

    fprintf(fp, "%s\n", log_lines[(signed long int)log_current_element]);
    r=flock(fd, 8);
    if(!(r == 0))
    {
      perror("nwipe_log: flock:");
      fprintf(stderr, "Error: Unable to unlock '%s' after logging.\n", (const void *)nwipe_options.logfile);
    }

    r=fclose(fp);
    if(!(r == 0))
    {
      perror("nwipe_log: fclose:");
      fprintf(stderr, "Error: Unable to close '%s' after logging.\n", (const void *)nwipe_options.logfile);
    }

  }
  pthread_mutex_unlock(&mutex1);

__CPROVER_DUMP_L19:
  ;
}

// nwipe_method_label
// file method.h line 46
const char * nwipe_method_label(void *method)
{
  if((void * (*)(void *))method == nwipe_dod522022m)
    return nwipe_dod522022m_label;

  else
    if((void * (*)(void *))method == nwipe_dodshort)
      return nwipe_dodshort_label;

    else
      if((void * (*)(void *))method == nwipe_gutmann)
        return nwipe_gutmann_label;

      else
        if((void * (*)(void *))method == nwipe_ops2)
          return nwipe_ops2_label;

        else
          if((void * (*)(void *))method == nwipe_random)
            return nwipe_random_label;

          else
            if((void * (*)(void *))method == nwipe_zero)
              return nwipe_zero_label;

            else
              return nwipe_unknown_label;
}

// nwipe_ops2
// file method.h line 52
void * nwipe_ops2(void *ptr)
{
  struct nwipe_context_t_ *c = (struct nwipe_context_t_ *)ptr;
  signed int i;
  signed int r;
  char *s;
  char *t;
  unsigned long int u;
  struct anonymous_1 *patterns;
  unsigned long int q;
  u = (unsigned long int)(1 * nwipe_options.rounds);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(char) /*1ul*/  * u);
  s = (char *)return_value_malloc_1;
  if(s == ((char *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    nwipe_perror(*return_value___errno_location_2, "nwipe_ops2", "malloc");
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to allocate the random character array.");
    c->result = -1;
    return (void *)0;
  }

  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(char) /*1ul*/  * u);
  t = (char *)return_value_malloc_3;
  if(s == ((char *)NULL))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    nwipe_perror(*return_value___errno_location_4, "nwipe_ops2", "malloc");
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to allocate the complement character array.");
    c->result = -1;
    return (void *)0;
  }

  q = (unsigned long int)8 * u + (unsigned long int)1;
  void *return_value_malloc_5;
  return_value_malloc_5=malloc(sizeof(struct anonymous_1) /*16ul*/  * q);
  patterns = (struct anonymous_1 *)return_value_malloc_5;
  if(patterns == ((struct anonymous_1 *)NULL))
  {
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    nwipe_perror(*return_value___errno_location_6, "nwipe_ops2", "malloc");
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to allocate the pattern array.");
    c->result = -1;
    return (void *)0;
  }

  signed long int return_value_read_7;
  return_value_read_7=read(c->entropy_fd, (void *)s, u);
  r = (signed int)return_value_read_7;
  if(!((unsigned long int)r == u))
  {
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    r = *return_value___errno_location_8;
    nwipe_perror(r, "nwipe_ops2", "read");
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to seed the %s method.", nwipe_ops2_label);
    if(!(r >= 0))
    {
      c->result = r;
      return (void *)0;
    }

    else
    {
      c->result = -1;
      return (void *)0;
    }
  }

  i = 0;
  for( ; !((unsigned long int)i >= u); i = i + 1)
    t[(signed long int)i] = (char)~((signed int)s[(signed long int)i]);
  i = 0;
  for( ; !((unsigned long int)i >= u); i = i + 8)
  {
    (patterns + (signed long int)(i * 4 + 0))->length = 1;
    (patterns + (signed long int)(i * 4 + 0))->s = &s[(signed long int)i];
    (patterns + (signed long int)(i * 4 + 2))->length = 1;
    (patterns + (signed long int)(i * 4 + 2))->s = &s[(signed long int)i];
    (patterns + (signed long int)(i * 4 + 4))->length = 1;
    (patterns + (signed long int)(i * 4 + 4))->s = &s[(signed long int)i];
    (patterns + (signed long int)(i * 4 + 6))->length = 1;
    (patterns + (signed long int)(i * 4 + 6))->s = &s[(signed long int)i];
    (patterns + (signed long int)(i * 4 + 1))->length = 1;
    (patterns + (signed long int)(i * 4 + 1))->s = &t[(signed long int)i];
    (patterns + (signed long int)(i * 4 + 3))->length = 1;
    (patterns + (signed long int)(i * 4 + 3))->s = &t[(signed long int)i];
    (patterns + (signed long int)(i * 4 + 5))->length = 1;
    (patterns + (signed long int)(i * 4 + 5))->s = &t[(signed long int)i];
    (patterns + (signed long int)(i * 4 + 7))->length = 1;
    (patterns + (signed long int)(i * 4 + 7))->s = &t[(signed long int)i];
  }
  (patterns + (signed long int)(q - (unsigned long int)1))->length = 0;
  (patterns + (signed long int)(q - (unsigned long int)1))->s = (char *)(void *)0;
  r=nwipe_runmethod(c, patterns);
  free((void *)s);
  free((void *)t);
  free((void *)patterns);
  c->result=nwipe_runmethod(c, patterns);
  c->thread = (unsigned long int)0;
  return (void *)0;
}

// nwipe_options_log
// file options.c line 306
void nwipe_options_log(void)
{
  nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Program options are set as follows...");
  if(!(nwipe_options.autonuke == 0))
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "  autonuke = %i (on)", nwipe_options.autonuke);

  else
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "  autonuke = %i (off)", nwipe_options.autonuke);
  if(!(nwipe_options.noblank == 0))
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "  do not perform a final blank pass");

  if(!(nwipe_options.nowait == 0))
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "  do not wait for a key before exiting");

  if(!(nwipe_options.nogui == 0))
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "  do not show GUI interface");

  nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "  banner   = %s", nwipe_options.banner);
  const char *return_value_nwipe_method_label_1;
  return_value_nwipe_method_label_1=nwipe_method_label(nwipe_options.method);
  nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "  method   = %s", return_value_nwipe_method_label_1);
  nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "  rounds   = %i", nwipe_options.rounds);
  nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "  sync     = %i", nwipe_options.sync);
  switch((signed int)nwipe_options.verify)
  {
    case NWIPE_VERIFY_NONE:
    {
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "  verify   = %i (off)", nwipe_options.verify);
      break;
    }
    case NWIPE_VERIFY_LAST:
    {
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "  verify   = %i (last pass)", nwipe_options.verify);
      break;
    }
    case NWIPE_VERIFY_ALL:
    {
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "  verify   = %i (all passes)", nwipe_options.verify);
      break;
    }
    default:
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "  verify   = %i", nwipe_options.verify);
  }
}

// nwipe_options_parse
// file options.h line 41
signed int nwipe_options_parse(signed int argc, char **argv)
{
  const signed int nwipe_banner_size = 81;
  signed int nwipe_opt;
  signed int i;
  char nwipe_options_short[12l] = { 'V', 'h', 'l', ':', 'h', 'm', ':', 'p', ':', 'r', ':', 0 };
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)nwipe_banner_size);
  nwipe_options.banner = (char *)return_value_malloc_1;
  strncpy(nwipe_options.banner, program_name, (unsigned long int)nwipe_banner_size);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(nwipe_options.banner);
  strncat(nwipe_options.banner, " ", ((unsigned long int)nwipe_banner_size - return_value_strlen_2) - (unsigned long int)1);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(nwipe_options.banner);
  strncat(nwipe_options.banner, version_string, ((unsigned long int)nwipe_banner_size - return_value_strlen_3) - (unsigned long int)1);
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(nwipe_options.banner);
  strncat(nwipe_options.banner, " (based on DBAN's dwipe - Darik's Wipe)", ((unsigned long int)nwipe_banner_size - return_value_strlen_4) - (unsigned long int)1);
  nwipe_options.autonuke = 0;
  nwipe_options.method = (void *)nwipe_dodshort;
  nwipe_options.prng = &nwipe_twister;
  nwipe_options.rounds = 1;
  nwipe_options.noblank = 0;
  nwipe_options.nowait = 0;
  nwipe_options.nogui = 0;
  nwipe_options.sync = 0;
  nwipe_options.verify = (enum nwipe_verify_t_)NWIPE_VERIFY_LAST;
  memset((void *)nwipe_options.logfile, 0, sizeof(char [4096l]) /*4096ul*/ );
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_19;
  _Bool tmp_if_expr_12;
  signed int return_value_strcmp_11;
  _Bool tmp_if_expr_15;
  signed int return_value_strcmp_14;
  _Bool tmp_if_expr_18;
  signed int return_value_strcmp_17;
  signed int return_value_strcmp_20;
  _Bool tmp_if_expr_22;
  signed int return_value_strcmp_21;
  signed int return_value_strcmp_23;
  _Bool tmp_if_expr_25;
  signed int return_value_strcmp_24;
  signed int return_value_strcmp_26;
  signed int return_value_strcmp_27;
  signed int return_value_strcmp_28;
  _Bool tmp_if_expr_30;
  signed int return_value_strcmp_29;
  _Bool tmp_if_expr_32;
  signed int return_value_strcmp_31;
  signed int return_value_strcmp_33;
  _Bool tmp_if_expr_35;
  signed int return_value_strcmp_34;
  unsigned long int return_value_strlen_36;
  signed int return_value_strcmp_37;
  _Bool tmp_if_expr_39;
  signed int return_value_strcmp_38;
  signed int return_value_strcmp_40;
  signed int return_value_sscanf_41;
  while((_Bool)1)
  {
    static struct option nwipe_options_long[13l] = { { .name="autonuke", .has_arg=0, .flag=((signed int *)NULL), .val=0 },
    { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 },
    { .name="method", .has_arg=1, .flag=((signed int *)NULL), .val=109 },
    { .name="logfile", .has_arg=1, .flag=((signed int *)NULL), .val=108 },
    { .name="prng", .has_arg=1, .flag=((signed int *)NULL), .val=112 },
    { .name="rounds", .has_arg=1, .flag=((signed int *)NULL), .val=114 },
    { .name="noblank", .has_arg=0, .flag=((signed int *)NULL), .val=0 },
    { .name="nowait", .has_arg=0, .flag=((signed int *)NULL), .val=0 },
    { .name="nogui", .has_arg=0, .flag=((signed int *)NULL), .val=0 },
    { .name="sync", .has_arg=0, .flag=((signed int *)NULL), .val=0 },
    { .name="verify", .has_arg=1, .flag=((signed int *)NULL), .val=0 },
    { .name="version", .has_arg=0, .flag=((signed int *)NULL), .val=86 },
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
    nwipe_opt=getopt_long(argc, argv, nwipe_options_short, nwipe_options_long, &i);
    if(!(nwipe_opt >= 0))
      break;

    switch(nwipe_opt)
    {
      case 0:
      {
        return_value_strcmp_5=strcmp(nwipe_options_long[(signed long int)i].name, "autonuke");
        if(return_value_strcmp_5 == 0)
        {
          nwipe_options.autonuke = 1;
          break;
        }

        return_value_strcmp_6=strcmp(nwipe_options_long[(signed long int)i].name, "noblank");
        if(return_value_strcmp_6 == 0)
        {
          nwipe_options.noblank = 1;
          break;
        }

        return_value_strcmp_7=strcmp(nwipe_options_long[(signed long int)i].name, "nowait");
        if(return_value_strcmp_7 == 0)
        {
          nwipe_options.nowait = 1;
          break;
        }

        return_value_strcmp_8=strcmp(nwipe_options_long[(signed long int)i].name, "nogui");
        if(return_value_strcmp_8 == 0)
        {
          nwipe_options.nogui = 1;
          nwipe_options.nowait = 1;
          break;
        }

        return_value_strcmp_9=strcmp(nwipe_options_long[(signed long int)i].name, "sync");
        if(return_value_strcmp_9 == 0)
        {
          nwipe_options.sync = 1;
          break;
        }

        return_value_strcmp_19=strcmp(nwipe_options_long[(signed long int)i].name, "verify");
        if(return_value_strcmp_19 == 0)
        {
          signed int return_value_strcmp_10;
          return_value_strcmp_10=strcmp(optarg, "0");
          if(return_value_strcmp_10 == 0)
            tmp_if_expr_12 = (_Bool)1;

          else
          {
            return_value_strcmp_11=strcmp(optarg, "off");
            tmp_if_expr_12 = return_value_strcmp_11 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_12)
          {
            nwipe_options.verify = (enum nwipe_verify_t_)NWIPE_VERIFY_NONE;
            break;
          }

          signed int return_value_strcmp_13;
          return_value_strcmp_13=strcmp(optarg, "1");
          if(return_value_strcmp_13 == 0)
            tmp_if_expr_15 = (_Bool)1;

          else
          {
            return_value_strcmp_14=strcmp(optarg, "last");
            tmp_if_expr_15 = return_value_strcmp_14 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_15)
          {
            nwipe_options.verify = (enum nwipe_verify_t_)NWIPE_VERIFY_LAST;
            break;
          }

          signed int return_value_strcmp_16;
          return_value_strcmp_16=strcmp(optarg, "2");
          if(return_value_strcmp_16 == 0)
            tmp_if_expr_18 = (_Bool)1;

          else
          {
            return_value_strcmp_17=strcmp(optarg, "all");
            tmp_if_expr_18 = return_value_strcmp_17 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_18)
          {
            nwipe_options.verify = (enum nwipe_verify_t_)NWIPE_VERIFY_ALL;
            break;
          }

          fprintf(stderr, "Error: Unknown verification level '%s'.\n", optarg);
          exit(22);
        }

      }
      case 109:
      {
        return_value_strcmp_20=strcmp(optarg, "dod522022m");
        if(return_value_strcmp_20 == 0)
          tmp_if_expr_22 = (_Bool)1;

        else
        {
          return_value_strcmp_21=strcmp(optarg, "dod");
          tmp_if_expr_22 = return_value_strcmp_21 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_22)
        {
          nwipe_options.method = (void *)nwipe_dod522022m;
          break;
        }

        return_value_strcmp_23=strcmp(optarg, "dodshort");
        if(return_value_strcmp_23 == 0)
          tmp_if_expr_25 = (_Bool)1;

        else
        {
          return_value_strcmp_24=strcmp(optarg, "dod3pass");
          tmp_if_expr_25 = return_value_strcmp_24 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_25)
        {
          nwipe_options.method = (void *)nwipe_dodshort;
          break;
        }

        return_value_strcmp_26=strcmp(optarg, "gutmann");
        if(return_value_strcmp_26 == 0)
        {
          nwipe_options.method = (void *)nwipe_gutmann;
          break;
        }

        return_value_strcmp_27=strcmp(optarg, "ops2");
        if(return_value_strcmp_27 == 0)
        {
          nwipe_options.method = (void *)nwipe_ops2;
          break;
        }

        return_value_strcmp_28=strcmp(optarg, "random");
        if(return_value_strcmp_28 == 0)
          tmp_if_expr_30 = (_Bool)1;

        else
        {
          return_value_strcmp_29=strcmp(optarg, "prng");
          tmp_if_expr_30 = return_value_strcmp_29 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_30)
          tmp_if_expr_32 = (_Bool)1;

        else
        {
          return_value_strcmp_31=strcmp(optarg, "stream");
          tmp_if_expr_32 = return_value_strcmp_31 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_32)
        {
          nwipe_options.method = (void *)nwipe_random;
          break;
        }

        return_value_strcmp_33=strcmp(optarg, "zero");
        if(return_value_strcmp_33 == 0)
          tmp_if_expr_35 = (_Bool)1;

        else
        {
          return_value_strcmp_34=strcmp(optarg, "quick");
          tmp_if_expr_35 = return_value_strcmp_34 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_35)
        {
          nwipe_options.method = (void *)nwipe_zero;
          break;
        }

        fprintf(stderr, "Error: Unknown wipe method '%s'.\n", optarg);
        exit(22);
      }
      case 108:
      {
        return_value_strlen_36=strlen(optarg);
        nwipe_options.logfile[(signed long int)return_value_strlen_36] = (char)0;
        strncpy(nwipe_options.logfile, optarg, sizeof(char [4096l]) /*4096ul*/ );
        break;
      }
      case 104:
      {
        display_help();
        break;
      }
      case 112:
      {
        return_value_strcmp_37=strcmp(optarg, "mersenne");
        if(return_value_strcmp_37 == 0)
          tmp_if_expr_39 = (_Bool)1;

        else
        {
          return_value_strcmp_38=strcmp(optarg, "twister");
          tmp_if_expr_39 = return_value_strcmp_38 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_39)
        {
          nwipe_options.prng = &nwipe_twister;
          break;
        }

        return_value_strcmp_40=strcmp(optarg, "isaac");
        if(return_value_strcmp_40 == 0)
        {
          nwipe_options.prng = &nwipe_isaac;
          break;
        }

        fprintf(stderr, "Error: Unknown prng '%s'.\n", optarg);
        exit(22);
      }
      case 114:
      {
        return_value_sscanf_41=sscanf(optarg, " %i", &nwipe_options.rounds);
        if(!(return_value_sscanf_41 == 1) || !(nwipe_options.rounds >= 1))
        {
          fprintf(stderr, "Error: The rounds argument must be a postive integer.\n");
          exit(22);
        }

        break;
      }
      case 86:
      {
        printf("%s version %s\n", program_name, version_string);
        exit(0);
      }
      default:
      {
        display_help();
        exit(22);
      }
    }
  }
  return optind;
}

// nwipe_perror
// file logging.h line 38
void nwipe_perror(signed int nwipe_errno, const char *f, const char *s)
{
  char *return_value_strerror_1;
  return_value_strerror_1=strerror(nwipe_errno);
  nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "%s: %s: %s", f, s, return_value_strerror_1);
}

// nwipe_random
// file method.h line 53
void * nwipe_random(void *ptr)
{
  struct nwipe_context_t_ *c = (struct nwipe_context_t_ *)ptr;
  struct anonymous_1 patterns[2l] = { { .length=-1, .s="" }, { .length=0, .s=(char *)(void *)0 } };
  c->result=nwipe_runmethod(c, patterns);
  c->thread = (unsigned long int)0;
  return (void *)0;
}

// nwipe_random_pass
// file pass.c line 214
signed int nwipe_random_pass(struct nwipe_context_t_ *c)
{
  signed int r;
  unsigned long int blocksize;
  signed long int offset;
  char *b;
  unsigned long long int z = (unsigned long long int)c->device_size;
  if(c->prng_seed.s == ((unsigned char *)NULL))
  {
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_SANITY, "__FUNCTION__: Null seed pointer.");
    return -1;
  }

  else
    if(!(c->prng_seed.length >= 1ul))
    {
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_SANITY, "__FUNCTION__: The entropy length member is %i.", c->prng_seed.length);
      return -1;
    }

    else
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc((unsigned long int)c->device_stat.st_blksize);
      b = (char *)return_value_malloc_1;
      if(b == ((char *)NULL))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        nwipe_perror(*return_value___errno_location_2, "nwipe_random_pass", "malloc");
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to allocate memory for the output buffer.");
        return -1;
      }

      c->prng->init(&c->prng_state, &c->prng_seed);
      offset=lseek(c->device_fd, (signed long int)0, 0);
      c->pass_done = (unsigned long long int)0;
      if(offset == -1l)
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        nwipe_perror(*return_value___errno_location_3, "nwipe_random_pass", "lseek");
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to reset the '%s' file offset.", c->device_name);
        return -1;
      }

      if(!(offset == 0l))
      {
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_SANITY, "__FUNCTION__: lseek() returned a bogus offset on '%s'.", c->device_name);
        return -1;
      }

      else
      {
        if(z >= 1ul)
        {
          if(z >= (unsigned long int)c->device_stat.st_blksize)
            blocksize = (unsigned long int)c->device_stat.st_blksize;

          else
          {
            blocksize = z;
            nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "%s: The size of '%s' is not a multiple of its block size %i.", (const void *)"nwipe_random_pass", c->device_name, c->device_stat.st_blksize);
          }
          c->prng->read(&c->prng_state, (void *)b, blocksize);
          signed long int return_value_write_4;
          return_value_write_4=write(c->device_fd, (const void *)b, blocksize);
          r = (signed int)return_value_write_4;
          if(!(r >= 0))
          {
            signed int *return_value___errno_location_5;
            return_value___errno_location_5=__errno_location();
            nwipe_perror(*return_value___errno_location_5, "nwipe_random_pass", "write");
            nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to read from '%s'.", c->device_name);
            return -1;
          }

          if(!((unsigned long int)r == blocksize))
          {
            signed int s = (signed int)(blocksize - (unsigned long int)r);
            c->pass_errors = c->pass_errors + (unsigned long long int)s;
            nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "Partial write on '%s', %i bytes short.", c->device_name, s);
            offset=lseek(c->device_fd, (signed long int)s, 1);
            if(offset == -1l)
            {
              signed int *return_value___errno_location_6;
              return_value___errno_location_6=__errno_location();
              nwipe_perror(*return_value___errno_location_6, "nwipe_random_pass", "lseek");
              nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "Unable to bump the '%s' file offset after a partial write.", c->device_name);
              return -1;
            }

          }

          z = z - (unsigned long long int)r;
          c->pass_done = c->pass_done + (unsigned long long int)r;
          c->round_done = c->round_done + (unsigned long long int)r;
          pthread_testcancel();
        }

        free((void *)b);
        c->sync_status = (signed short int)1;
        r=fdatasync(c->device_fd);
        c->sync_status = (signed short int)0;
        if(!(r == 0))
        {
          signed int *return_value___errno_location_7;
          return_value___errno_location_7=__errno_location();
          nwipe_perror(*return_value___errno_location_7, "nwipe_random_pass", "fdatasync");
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "Buffer flush failure on '%s'.", c->device_name);
        }

        return 0;
      }
    }
}

// nwipe_random_verify
// file pass.c line 35
signed int nwipe_random_verify(struct nwipe_context_t_ *c)
{
  signed int r;
  unsigned long int blocksize;
  signed long int offset;
  char *b;
  char *d;
  unsigned long long int z = (unsigned long long int)c->device_size;
  if(c->prng_seed.s == ((unsigned char *)NULL))
  {
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_SANITY, "Null seed pointer.");
    return -1;
  }

  else
    if(!(c->prng_seed.length >= 1ul))
    {
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_SANITY, "The entropy length member is %i.", c->prng_seed.length);
      return -1;
    }

    else
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc((unsigned long int)c->device_stat.st_blksize);
      b = (char *)return_value_malloc_1;
      if(b == ((char *)NULL))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        nwipe_perror(*return_value___errno_location_2, "nwipe_random_verify", "malloc");
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to allocate memory for the input buffer.");
        return -1;
      }

      void *return_value_malloc_3;
      return_value_malloc_3=malloc((unsigned long int)c->device_stat.st_blksize);
      d = (char *)return_value_malloc_3;
      if(d == ((char *)NULL))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        nwipe_perror(*return_value___errno_location_4, "nwipe_random_verify", "malloc");
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to allocate memory for the pattern buffer.");
        return -1;
      }

      offset=lseek(c->device_fd, (signed long int)0, 0);
      c->pass_done = (unsigned long long int)0;
      if(offset == -1l)
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        nwipe_perror(*return_value___errno_location_5, "nwipe_random_verify", "lseek");
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to reset the '%s' file offset.", c->device_name);
        return -1;
      }

      if(!(offset == 0l))
      {
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_SANITY, "lseek() returned a bogus offset on '%s'.", c->device_name);
        return -1;
      }

      else
      {
        c->sync_status = (signed short int)1;
        r=fdatasync(c->device_fd);
        c->sync_status = (signed short int)0;
        if(!(r == 0))
        {
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          nwipe_perror(*return_value___errno_location_6, "nwipe_random_verify", "fdatasync");
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "Buffer flush failure on '%s'.", c->device_name);
        }

        c->prng->init(&c->prng_state, &c->prng_seed);
        if(z >= 1ul)
        {
          if(z >= (unsigned long int)c->device_stat.st_blksize)
            blocksize = (unsigned long int)c->device_stat.st_blksize;

          else
          {
            blocksize = z;
            nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "%s: The size of '%s' is not a multiple of its block size %i.", (const void *)"nwipe_random_verify", c->device_name, c->device_stat.st_blksize);
          }
          c->prng->read(&c->prng_state, (void *)d, blocksize);
          signed long int return_value_read_7;
          return_value_read_7=read(c->device_fd, (void *)b, blocksize);
          r = (signed int)return_value_read_7;
          if(!(r >= 0))
          {
            signed int *return_value___errno_location_8;
            return_value___errno_location_8=__errno_location();
            nwipe_perror(*return_value___errno_location_8, "nwipe_random_verify", "read");
            nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "Unable to read from '%s'.", c->device_name);
            return -1;
          }

          if(!((unsigned long int)r == blocksize))
          {
            signed int s = (signed int)(blocksize - (unsigned long int)r);
            nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "%s: Partial read from '%s', %i bytes short.", (const void *)"nwipe_random_verify", c->device_name, s);
            c->verify_errors = c->verify_errors + (unsigned long long int)1;
            offset=lseek(c->device_fd, (signed long int)s, 1);
            if(offset == -1l)
            {
              signed int *return_value___errno_location_9;
              return_value___errno_location_9=__errno_location();
              nwipe_perror(*return_value___errno_location_9, "nwipe_random_verify", "lseek");
              nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "Unable to bump the '%s' file offset after a partial read.", c->device_name);
              return -1;
            }

          }

          signed int return_value_memcmp_10;
          return_value_memcmp_10=memcmp((const void *)b, (const void *)d, blocksize);
          if(!(return_value_memcmp_10 == 0))
            c->verify_errors = c->verify_errors + (unsigned long long int)1;

          z = z - (unsigned long long int)r;
          c->pass_done = c->pass_done + (unsigned long long int)r;
          c->round_done = c->round_done + (unsigned long long int)r;
          pthread_testcancel();
        }

        free((void *)b);
        free((void *)d);
        return 0;
      }
    }
}

// nwipe_runmethod
// file method.c line 547
signed int nwipe_runmethod(struct nwipe_context_t_ *c, struct anonymous_1 *patterns)
{
  signed int r;
  signed int i = 0;
  struct anonymous_1 pattern_zero = { .length=1, .s="\0" };
  c->prng_seed.length = (unsigned long int)512;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(c->prng_seed.length);
  c->prng_seed.s = (unsigned char *)return_value_malloc_1;
  if(c->prng_seed.s == ((unsigned char *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    nwipe_perror(*return_value___errno_location_2, "nwipe_runmethod", "malloc");
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to allocate memory for the prng seed buffer.");
    return -1;
  }

  for( ; !((patterns + (signed long int)i)->length == 0); i = i + 1)
    ;
  c->pass_count = i;
  c->pass_size = (unsigned long long int)((signed long int)c->pass_count * c->device_size);
  if((signed int)nwipe_options.verify == NWIPE_VERIFY_ALL)
    c->pass_size = c->pass_size * (unsigned long long int)2;

  c->round_count = nwipe_options.rounds;
  c->round_size = (unsigned long int)c->round_count * c->pass_size;
  if(nwipe_options.noblank == 0)
    c->round_size = c->round_size + (unsigned long long int)c->device_size;

  c->result = (signed int)c->round_size;
  if(nwipe_options.noblank == 0 && ((signed int)nwipe_options.verify == NWIPE_VERIFY_LAST || (signed int)nwipe_options.verify == NWIPE_VERIFY_ALL))
    c->round_size = c->round_size + (unsigned long long int)c->device_size;

  c->round_working = 0;
  const char *return_value_nwipe_method_label_3;
  return_value_nwipe_method_label_3=nwipe_method_label(nwipe_options.method);
  nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Invoking method '%s' on device '%s'.", return_value_nwipe_method_label_3, c->device_name);
  while(!(c->round_working >= c->round_count))
  {
    c->round_working = c->round_working + 1;
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Starting round %i of %i on device '%s'.", c->round_working, c->round_count, c->device_name);
    c->pass_working = 0;
    i = 0;
    for( ; !(i >= c->pass_count); i = i + 1)
    {
      c->pass_working = c->pass_working + 1;
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Starting pass %i of %i, round %i of %i, on device '%s'.", c->pass_working, c->pass_count, c->round_working, c->round_count, c->device_name);
      if((patterns + (signed long int)i)->length == 0)
      {
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_SANITY, "nwipe_runmethod: A non-terminating pattern element has zero length.");
        return -1;
      }

      if((patterns + (signed long int)i)->length >= 1)
      {
        c->pass_type = (enum nwipe_pass_t_)NWIPE_PASS_WRITE;
        r=nwipe_static_pass(c, &patterns[(signed long int)i]);
        c->pass_type = (enum nwipe_pass_t_)NWIPE_PASS_NONE;
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "%llu bytes written to device '%s'.", c->pass_done, c->device_name);
        if(!(r >= 0))
          return r;

        if((signed int)nwipe_options.verify == NWIPE_VERIFY_ALL)
        {
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Verifying pass %i of %i, round %i of %i, on device '%s'.", c->pass_working, c->pass_count, c->round_working, c->round_count, c->device_name);
          c->pass_type = (enum nwipe_pass_t_)NWIPE_PASS_VERIFY;
          r=nwipe_static_verify(c, &patterns[(signed long int)i]);
          c->pass_type = (enum nwipe_pass_t_)NWIPE_PASS_NONE;
          if(!(r >= 0))
            return r;

          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Verified pass %i of %i, round %i of %i, on device '%s'.", c->pass_working, c->pass_count, c->round_working, c->round_count, c->device_name);
        }

      }

      else
      {
        c->pass_type = (enum nwipe_pass_t_)NWIPE_PASS_WRITE;
        signed long int return_value_read_4;
        return_value_read_4=read(c->entropy_fd, (void *)c->prng_seed.s, c->prng_seed.length);
        r = (signed int)return_value_read_4;
        if(!(r >= 0))
        {
          c->pass_type = (enum nwipe_pass_t_)NWIPE_PASS_NONE;
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          nwipe_perror(*return_value___errno_location_5, "nwipe_runmethod", "read");
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to seed the PRNG.");
          return -1;
        }

        if(!((unsigned long int)r == c->prng_seed.length))
        {
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Insufficient entropy is available.");
          return -1;
        }

        r=nwipe_random_pass(c);
        c->pass_type = (enum nwipe_pass_t_)NWIPE_PASS_NONE;
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "%llu bytes written to device '%s'.", c->pass_done, c->device_name);
        if(!(r >= 0))
          return r;

        if((signed int)nwipe_options.verify == NWIPE_VERIFY_ALL)
        {
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Verifying pass %i of %i, round %i of %i, on device '%s'.", c->pass_working, c->pass_count, c->round_working, c->round_count, c->device_name);
          c->pass_type = (enum nwipe_pass_t_)NWIPE_PASS_VERIFY;
          r=nwipe_random_verify(c);
          c->pass_type = (enum nwipe_pass_t_)NWIPE_PASS_NONE;
          if(!(r >= 0))
            return r;

          const char *return_value_nwipe_method_label_6;
          return_value_nwipe_method_label_6=nwipe_method_label(nwipe_options.method);
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Verified pass %i of %i, round %i of %i, on device '%s'.", c->pass_working, c->pass_count, c->round_working, c->round_count, return_value_nwipe_method_label_6);
        }

      }
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Finished pass %i of %i, round %i of %i, on device '%s'.", c->pass_working, c->pass_count, c->round_working, c->round_count, c->device_name);
    }
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Finished round %i of %i on device '%s'.", c->round_working, c->round_count, c->device_name);
  }
  if((void * (*)(void *ptr))nwipe_options.method == nwipe_ops2)
  {
    c->pass_type = (enum nwipe_pass_t_)NWIPE_PASS_FINAL_OPS2;
    signed long int return_value_read_7;
    return_value_read_7=read(c->entropy_fd, (void *)c->prng_seed.s, c->prng_seed.length);
    r = (signed int)return_value_read_7;
    if(!(r >= 0))
    {
      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      nwipe_perror(*return_value___errno_location_8, "nwipe_runmethod", "read");
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to seed the PRNG.");
      return -1;
    }

    if(!((unsigned long int)r == c->prng_seed.length))
    {
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Insufficient entropy is available.");
      return -1;
    }

    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Writing final random pattern to '%s'.", c->device_name);
    r=nwipe_random_pass(c);
    if(!(r >= 0))
      return r;

    if((signed int)nwipe_options.verify == NWIPE_VERIFY_LAST || (signed int)nwipe_options.verify == NWIPE_VERIFY_ALL)
    {
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Verifying the final random pattern on '%s' is empty.", c->device_name);
      r=nwipe_random_verify(c);
      if(!(r >= 0))
        return r;

      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Verified the final random pattern on '%s' is empty.", c->device_name);
    }

    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Wrote final random pattern to '%s'.", c->device_name);
  }

  else
    if(nwipe_options.noblank == 0)
    {
      c->pass_type = (enum nwipe_pass_t_)NWIPE_PASS_FINAL_BLANK;
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Blanking device '%s'.", c->device_name);
      r=nwipe_static_pass(c, &pattern_zero);
      if(!(r >= 0))
        return r;

      if((signed int)nwipe_options.verify == NWIPE_VERIFY_LAST || (signed int)nwipe_options.verify == NWIPE_VERIFY_ALL)
      {
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Verifying that '%s' is empty.", c->device_name);
        r=nwipe_static_verify(c, &pattern_zero);
        if(!(r >= 0))
          return r;

        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Verified that '%s' is empty.", c->device_name);
      }

      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_NOTICE, "Blanked device '%s'.", c->device_name);
    }

  c->prng_seed.length = (unsigned long int)0;
  free((void *)c->prng_seed.s);
  c->pass_type = (enum nwipe_pass_t_)NWIPE_PASS_NONE;
  if(c->verify_errors >= 1ul)
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "%llu verification errors on device '%s'.", c->verify_errors, c->device_name);

  if(c->pass_errors >= 1ul)
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "%llu wipe errors on device '%s'.", c->pass_errors, c->device_name);

  _Bool tmp_if_expr_9;
  if(c->pass_errors >= 1ul)
    tmp_if_expr_9 = (_Bool)1;

  else
    tmp_if_expr_9 = c->round_errors > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_10;
  if(tmp_if_expr_9)
    tmp_if_expr_10 = (_Bool)1;

  else
    tmp_if_expr_10 = c->verify_errors > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_10)
    return 1;

  else
    return 0;
}

// nwipe_static_pass
// file pass.c line 576
signed int nwipe_static_pass(struct nwipe_context_t_ *c, struct anonymous_1 *pattern)
{
  signed int r;
  unsigned long int blocksize;
  signed long int offset;
  char *b;
  char *p;
  signed int w = 0;
  unsigned long long int z = (unsigned long long int)c->device_size;
  if(pattern == ((struct anonymous_1 *)NULL))
  {
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_SANITY, "__FUNCTION__: Null pattern pointer.");
    return -1;
  }

  else
    if(!(pattern->length >= 1))
    {
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_SANITY, "__FUNCTION__: The pattern length member is %i.", pattern->length);
      return -1;
    }

    else
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc((unsigned long int)(c->device_stat.st_blksize + (signed long int)(pattern->length * 2)));
      b = (char *)return_value_malloc_1;
      if(b == ((char *)NULL))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        nwipe_perror(*return_value___errno_location_2, "nwipe_static_pass", "malloc");
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to allocate memory for the pattern buffer.");
        return -1;
      }

      p = b;
      for( ; !(p >= b + c->device_stat.st_blksize + (signed long int)pattern->length); p = p + (signed long int)pattern->length)
        memcpy((void *)p, (const void *)pattern->s, (unsigned long int)pattern->length);
      offset=lseek(c->device_fd, (signed long int)0, 0);
      c->pass_done = (unsigned long long int)0;
      if(offset == -1l)
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        nwipe_perror(*return_value___errno_location_3, "nwipe_static_pass", "lseek");
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to reset the '%s' file offset.", c->device_name);
        return -1;
      }

      if(!(offset == 0l))
      {
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_SANITY, "__FUNCTION__: lseek() returned a bogus offset on '%s'.", c->device_name);
        return -1;
      }

      else
      {
        while(z >= 1ul)
        {
          if(z >= (unsigned long int)c->device_stat.st_blksize)
            blocksize = (unsigned long int)c->device_stat.st_blksize;

          else
          {
            blocksize = z;
            nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "%s: The size of '%s' is not a multiple of its block size %i.", (const void *)"nwipe_static_pass", c->device_name, c->device_stat.st_blksize);
          }
          signed long int return_value_write_4;
          return_value_write_4=write(c->device_fd, (const void *)&b[(signed long int)w], blocksize);
          r = (signed int)return_value_write_4;
          if(!(r >= 0))
          {
            signed int *return_value___errno_location_5;
            return_value___errno_location_5=__errno_location();
            nwipe_perror(*return_value___errno_location_5, "nwipe_static_pass", "write");
            nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to write to '%s'.", c->device_name);
            return -1;
          }

          if(!((unsigned long int)r == blocksize))
          {
            signed int s = (signed int)(blocksize - (unsigned long int)r);
            c->pass_errors = c->pass_errors + (unsigned long long int)s;
            nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "Partial write on '%s', %i bytes short.", c->device_name, s);
            offset=lseek(c->device_fd, (signed long int)s, 1);
            if(offset == -1l)
            {
              signed int *return_value___errno_location_6;
              return_value___errno_location_6=__errno_location();
              nwipe_perror(*return_value___errno_location_6, "nwipe_static_pass", "lseek");
              nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "Unable to bump the '%s' file offset after a partial write.", c->device_name);
              return -1;
            }

          }

          w = (signed int)((c->device_stat.st_blksize + (signed long int)w) % (signed long int)pattern->length);
          z = z - (unsigned long long int)r;
          c->pass_done = c->pass_done + (unsigned long long int)r;
          c->round_done = c->round_done + (unsigned long long int)r;
          pthread_testcancel();
        }
        c->sync_status = (signed short int)1;
        r=fdatasync(c->device_fd);
        c->sync_status = (signed short int)0;
        if(!(r == 0))
        {
          signed int *return_value___errno_location_7;
          return_value___errno_location_7=__errno_location();
          nwipe_perror(*return_value___errno_location_7, "nwipe_static_pass", "fdatasync");
          nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "Buffer flush failure on '%s'.", c->device_name);
        }

        free((void *)b);
        return 0;
      }
    }
}

// nwipe_static_verify
// file pass.c line 377
signed int nwipe_static_verify(struct nwipe_context_t_ *c, struct anonymous_1 *pattern)
{
  signed int r;
  unsigned long int blocksize;
  signed long int offset;
  char *b;
  char *d;
  char *q;
  signed int w = 0;
  unsigned long long int z = (unsigned long long int)c->device_size;
  if(pattern == ((struct anonymous_1 *)NULL))
  {
    nwipe_log((enum nwipe_log_t_)NWIPE_LOG_SANITY, "nwipe_static_verify: Null entropy pointer.");
    return -1;
  }

  else
    if(!(pattern->length >= 1))
    {
      nwipe_log((enum nwipe_log_t_)NWIPE_LOG_SANITY, "nwipe_static_verify: The pattern length member is %i.", pattern->length);
      return -1;
    }

    else
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc((unsigned long int)c->device_stat.st_blksize);
      b = (char *)return_value_malloc_1;
      if(b == ((char *)NULL))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        nwipe_perror(*return_value___errno_location_2, "nwipe_static_verify", "malloc");
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to allocate memory for the input buffer.");
        return -1;
      }

      void *return_value_malloc_3;
      return_value_malloc_3=malloc((unsigned long int)(c->device_stat.st_blksize + (signed long int)(pattern->length * 2)));
      d = (char *)return_value_malloc_3;
      if(d == ((char *)NULL))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        nwipe_perror(*return_value___errno_location_4, "nwipe_static_verify", "malloc");
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to allocate memory for the pattern buffer.");
        return -1;
      }

      q = d;
      for( ; !(q >= d + c->device_stat.st_blksize + (signed long int)pattern->length); q = q + (signed long int)pattern->length)
        memcpy((void *)q, (const void *)pattern->s, (unsigned long int)pattern->length);
      c->sync_status = (signed short int)1;
      r=fdatasync(c->device_fd);
      c->sync_status = (signed short int)0;
      if(!(r == 0))
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        nwipe_perror(*return_value___errno_location_5, "nwipe_static_verify", "fdatasync");
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "Buffer flush failure on '%s'.", c->device_name);
      }

      offset=lseek(c->device_fd, (signed long int)0, 0);
      c->pass_done = (unsigned long long int)0;
      if(offset == -1l)
      {
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        nwipe_perror(*return_value___errno_location_6, "nwipe_static_verify", "lseek");
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_FATAL, "Unable to reset the '%s' file offset.", c->device_name);
        return -1;
      }

      if(!(offset == 0l))
      {
        nwipe_log((enum nwipe_log_t_)NWIPE_LOG_SANITY, "nwipe_static_verify: lseek() returned a bogus offset on '%s'.", c->device_name);
        return -1;
      }

      else
      {
        while(z >= 1ul)
        {
          if(z >= (unsigned long int)c->device_stat.st_blksize)
            blocksize = (unsigned long int)c->device_stat.st_blksize;

          else
          {
            blocksize = z;
            nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "%s: The size of '%s' is not a multiple of its block size %i.", (const void *)"nwipe_static_verify", c->device_name, c->device_stat.st_blksize);
          }
          signed long int return_value_read_7;
          return_value_read_7=read(c->device_fd, (void *)b, blocksize);
          r = (signed int)return_value_read_7;
          if(!(r >= 0))
          {
            signed int *return_value___errno_location_8;
            return_value___errno_location_8=__errno_location();
            nwipe_perror(*return_value___errno_location_8, "nwipe_static_verify", "read");
            nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "Unable to read from '%s'.", c->device_name);
            return -1;
          }

          if((unsigned long int)r == blocksize)
          {
            signed int return_value_memcmp_9;
            return_value_memcmp_9=memcmp((const void *)b, (const void *)&d[(signed long int)w], (unsigned long int)r);
            if(!(return_value_memcmp_9 == 0))
              c->verify_errors = c->verify_errors + (unsigned long long int)1;

          }

          else
          {
            signed int s = (signed int)(blocksize - (unsigned long int)r);
            c->verify_errors = c->verify_errors + (unsigned long long int)1;
            nwipe_log((enum nwipe_log_t_)NWIPE_LOG_WARNING, "Partial read on '%s', %i bytes short.", c->device_name, s);
            offset=lseek(c->device_fd, (signed long int)s, 1);
            if(offset == -1l)
            {
              signed int *return_value___errno_location_10;
              return_value___errno_location_10=__errno_location();
              nwipe_perror(*return_value___errno_location_10, "nwipe_static_verify", "lseek");
              nwipe_log((enum nwipe_log_t_)NWIPE_LOG_ERROR, "Unable to bump the '%s' file offset after a partial read.", c->device_name);
              return -1;
            }

          }
          w = (signed int)((c->device_stat.st_blksize + (signed long int)w) % (signed long int)pattern->length);
          z = z - (unsigned long long int)r;
          c->pass_done = c->pass_done + (unsigned long long int)r;
          c->round_done = c->round_done + (unsigned long long int)r;
          pthread_testcancel();
        }
        free((void *)b);
        free((void *)d);
        return 0;
      }
    }
}

// nwipe_twister_init
// file prng.c line 44
signed int nwipe_twister_init(void **state, struct anonymous_3 *seed)
{
  if(*state == NULL)
    *state=malloc(sizeof(struct twister_state_t_) /*5008ul*/ );

  twister_init((struct twister_state_t_ *)*state, (unsigned long int *)seed->s, seed->length / sizeof(unsigned long int) /*8ul*/ );
  return 0;
}

// nwipe_twister_read
// file prng.c line 55
signed int nwipe_twister_read(void **state, void *buffer, unsigned long int count)
{
  unsigned long int ii;
  unsigned long int words = count / sizeof(unsigned long int) /*8ul*/ ;
  unsigned long int remain = count % sizeof(unsigned long int) /*8ul*/ ;
  ii = (unsigned long int)0;
  for( ; !(ii >= words); ii = ii + 1ul)
    ((unsigned long int *)buffer)[(signed long int)ii]=twister_genrand_int32((struct twister_state_t_ *)*state);
  ii = (unsigned long int)1;
  for( ; remain >= ii; ii = ii + 1ul)
  {
    unsigned long int return_value_twister_genrand_int32_1;
    return_value_twister_genrand_int32_1=twister_genrand_int32((struct twister_state_t_ *)*state);
    ((unsigned char *)buffer)[(signed long int)(count - ii)] = (unsigned char)return_value_twister_genrand_int32_1;
  }
  return 0;
}

// nwipe_update_speedring
// file gui.c line 2088
void nwipe_update_speedring(struct nwipe_speedring_t_ *speedring, unsigned long long int speedring_bytes, signed long int speedring_now)
{
  if(speedring->timeslast == 0l)
    speedring->timeslast = speedring_now;

  else
    if(speedring_now + -speedring->timeslast >= 10l)
    {
      speedring->bytestotal = speedring->bytestotal - speedring->bytes[(signed long int)speedring->position];
      speedring->timestotal = speedring->timestotal - speedring->times[(signed long int)speedring->position];
      speedring->bytes[(signed long int)speedring->position] = speedring_bytes - speedring->byteslast;
      speedring->times[(signed long int)speedring->position] = speedring_now - speedring->timeslast;
      speedring->bytestotal = speedring->bytestotal + speedring->bytes[(signed long int)speedring->position];
      speedring->timestotal = speedring->timestotal + speedring->times[(signed long int)speedring->position];
      speedring->byteslast = speedring_bytes;
      speedring->timeslast = speedring_now;
      speedring->position = speedring->position + 1ul;
      if(speedring->position >= 30ul)
        speedring->position = (unsigned long int)0;

    }

}

// nwipe_zero
// file method.h line 54
void * nwipe_zero(void *ptr)
{
  struct nwipe_context_t_ *c = (struct nwipe_context_t_ *)ptr;
  struct anonymous_1 patterns[1l] = { { .length=0, .s=(char *)(void *)0 } };
  c->result=nwipe_runmethod(c, patterns);
  c->thread = (unsigned long int)0;
  return (void *)0;
}

// randinit
// file isaac_rand.c line 65
void randinit(struct randctx *ctx, signed int flag)
{
  signed int i;
  unsigned long int a;
  unsigned long int b;
  unsigned long int c;
  unsigned long int d;
  unsigned long int e;
  unsigned long int f;
  unsigned long int g;
  unsigned long int h;
  unsigned long int *m;
  unsigned long int *r;
  ctx->randc = (unsigned long int)0;
  ctx->randb = ctx->randc;
  ctx->randa = ctx->randb;
  m = ctx->randmem;
  r = ctx->randrsl;
  h = (unsigned long int)0x9e3779b9;
  g = h;
  f = g;
  e = f;
  d = e;
  c = d;
  b = c;
  a = b;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    a = a ^ b << 11;
    d = d + a;
    b = b + c;
    b = b ^ c >> 2;
    e = e + b;
    c = c + d;
    c = c ^ d << 8;
    f = f + c;
    d = d + e;
    d = d ^ e >> 16;
    g = g + d;
    e = e + f;
    e = e ^ f << 10;
    h = h + e;
    f = f + g;
    f = f ^ g >> 4;
    a = a + f;
    g = g + h;
    g = g ^ h << 8;
    b = b + g;
    h = h + a;
    h = h ^ a >> 9;
    c = c + h;
    a = a + b;
  }
  if(!(flag == 0))
  {
    i = 0;
    for( ; !(i >= 256); i = i + 8)
    {
      a = a + r[(signed long int)i];
      b = b + r[(signed long int)(i + 1)];
      c = c + r[(signed long int)(i + 2)];
      d = d + r[(signed long int)(i + 3)];
      e = e + r[(signed long int)(i + 4)];
      f = f + r[(signed long int)(i + 5)];
      g = g + r[(signed long int)(i + 6)];
      h = h + r[(signed long int)(i + 7)];
      a = a ^ b << 11;
      d = d + a;
      b = b + c;
      b = b ^ c >> 2;
      e = e + b;
      c = c + d;
      c = c ^ d << 8;
      f = f + c;
      d = d + e;
      d = d ^ e >> 16;
      g = g + d;
      e = e + f;
      e = e ^ f << 10;
      h = h + e;
      f = f + g;
      f = f ^ g >> 4;
      a = a + f;
      g = g + h;
      g = g ^ h << 8;
      b = b + g;
      h = h + a;
      h = h ^ a >> 9;
      c = c + h;
      a = a + b;
      m[(signed long int)i] = a;
      m[(signed long int)(i + 1)] = b;
      m[(signed long int)(i + 2)] = c;
      m[(signed long int)(i + 3)] = d;
      m[(signed long int)(i + 4)] = e;
      m[(signed long int)(i + 5)] = f;
      m[(signed long int)(i + 6)] = g;
      m[(signed long int)(i + 7)] = h;
    }
    i = 0;
    for( ; !(i >= 256); i = i + 8)
    {
      a = a + m[(signed long int)i];
      b = b + m[(signed long int)(i + 1)];
      c = c + m[(signed long int)(i + 2)];
      d = d + m[(signed long int)(i + 3)];
      e = e + m[(signed long int)(i + 4)];
      f = f + m[(signed long int)(i + 5)];
      g = g + m[(signed long int)(i + 6)];
      h = h + m[(signed long int)(i + 7)];
      a = a ^ b << 11;
      d = d + a;
      b = b + c;
      b = b ^ c >> 2;
      e = e + b;
      c = c + d;
      c = c ^ d << 8;
      f = f + c;
      d = d + e;
      d = d ^ e >> 16;
      g = g + d;
      e = e + f;
      e = e ^ f << 10;
      h = h + e;
      f = f + g;
      f = f ^ g >> 4;
      a = a + f;
      g = g + h;
      g = g ^ h << 8;
      b = b + g;
      h = h + a;
      h = h ^ a >> 9;
      c = c + h;
      a = a + b;
      m[(signed long int)i] = a;
      m[(signed long int)(i + 1)] = b;
      m[(signed long int)(i + 2)] = c;
      m[(signed long int)(i + 3)] = d;
      m[(signed long int)(i + 4)] = e;
      m[(signed long int)(i + 5)] = f;
      m[(signed long int)(i + 6)] = g;
      m[(signed long int)(i + 7)] = h;
    }
  }

  else
  {
    i = 0;
    for( ; !(i >= 256); i = i + 8)
    {
      a = a ^ b << 11;
      d = d + a;
      b = b + c;
      b = b ^ c >> 2;
      e = e + b;
      c = c + d;
      c = c ^ d << 8;
      f = f + c;
      d = d + e;
      d = d ^ e >> 16;
      g = g + d;
      e = e + f;
      e = e ^ f << 10;
      h = h + e;
      f = f + g;
      f = f ^ g >> 4;
      a = a + f;
      g = g + h;
      g = g ^ h << 8;
      b = b + g;
      h = h + a;
      h = h ^ a >> 9;
      c = c + h;
      a = a + b;
      m[(signed long int)i] = a;
      m[(signed long int)(i + 1)] = b;
      m[(signed long int)(i + 2)] = c;
      m[(signed long int)(i + 3)] = d;
      m[(signed long int)(i + 4)] = e;
      m[(signed long int)(i + 5)] = f;
      m[(signed long int)(i + 6)] = g;
      m[(signed long int)(i + 7)] = h;
    }
  }
  isaac(ctx);
  ctx->randcnt = (unsigned long int)(1 << 8);
}

// signal_hand
// file nwipe.c line 484
void * signal_hand(void *ptr)
{
  signed int sig;
  struct anonymous_2 sigset;
  sigemptyset(&sigset);
  sigaddset(&sigset, 1);
  sigaddset(&sigset, 15);
  sigaddset(&sigset, 3);
  sigaddset(&sigset, 2);
  sigaddset(&sigset, 10);
  signed int i;
  struct anonymous_7 *nwipe_thread_data_ptr;
  struct nwipe_context_t_ **c;
  struct anonymous *nwipe_misc_thread_data;
  nwipe_thread_data_ptr = (struct anonymous_7 *)ptr;
  c = nwipe_thread_data_ptr->c;
  nwipe_misc_thread_data = nwipe_thread_data_ptr->nwipe_misc_thread_data;
  while((_Bool)1)
  {
    sigwait(&sigset, &sig);
    switch(sig)
    {
      case 10:
      {
        compute_stats(ptr);
        i = 0;
        for( ; !(i >= nwipe_misc_thread_data->nwipe_selected); i = i + 1)
          if(!(c[(signed long int)i]->thread == 0ul))
          {
            char *status;
            switch((signed int)c[(signed long int)i]->pass_type)
            {
              case NWIPE_PASS_FINAL_BLANK:
              {
                status = "[blanking]";
                goto __CPROVER_DUMP_L8;
              }
              case NWIPE_PASS_FINAL_OPS2:
              {
                status = "[OPS-II final]";
                goto __CPROVER_DUMP_L8;
              }
              case NWIPE_PASS_WRITE:
              {
                status = "[writing]";
                goto __CPROVER_DUMP_L8;
              }
              case NWIPE_PASS_VERIFY:
                status = "[verifying]";
              case NWIPE_PASS_NONE:

              default:
              {

              __CPROVER_DUMP_L8:
                ;
                if(!(c[(signed long int)i]->sync_status == 0))
                  status = "[syncing]";

                nwipe_log((enum nwipe_log_t_)NWIPE_LOG_INFO, "%s: %05.2f%%, round %i of %i, pass %i of %i %s", c[(signed long int)i]->device_name, c[(signed long int)i]->round_percent, c[(signed long int)i]->round_working, c[(signed long int)i]->round_count, c[(signed long int)i]->pass_working, c[(signed long int)i]->pass_count, status);
              }
            }
          }

          else
            if(c[(signed long int)i]->result == 0)
              nwipe_log((enum nwipe_log_t_)NWIPE_LOG_INFO, "%s: Success", c[(signed long int)i]->device_name);

            else
              if(!(c[(signed long int)i]->signal == 0))
                nwipe_log((enum nwipe_log_t_)NWIPE_LOG_INFO, "%s: Failure: signal %i", c[(signed long int)i]->device_name, c[(signed long int)i]->signal);

              else
                nwipe_log((enum nwipe_log_t_)NWIPE_LOG_INFO, "%s: Failure: code %i", c[(signed long int)i]->device_name, c[(signed long int)i]->result);
        break;
      }
      case 1:

      case 2:

      case 3:

      case 15:
      {
        i = 0;
        for( ; !(i >= nwipe_misc_thread_data->nwipe_selected); i = i + 1)
          if(!(c[(signed long int)i]->thread == 0ul))
            pthread_cancel(c[(signed long int)i]->thread);

        if(nwipe_options.nogui == 0)
        {
          if(!(nwipe_misc_thread_data->gui_thread == ((unsigned long int *)NULL)))
          {
            pthread_cancel(*nwipe_misc_thread_data->gui_thread);
            *nwipe_misc_thread_data->gui_thread = (unsigned long int)0;
          }

        }

        if(nwipe_options.nogui == 0)
          nwipe_gui_free();

        i = 0;
        for( ; !(i >= log_current_element); i = i + 1)
          printf("%s\n", log_lines[(signed long int)i]);
        printf("Program interrupted (caught signal %d)\n", sig);
        exit(0);
      }
      default:
        ;
    }
  }
  return (void *)0;
}

// twister_genrand_int32
// file mt19937ar-cok.c line 125
unsigned long int twister_genrand_int32(struct twister_state_t_ *state)
{
  unsigned long int y;
  state->left = state->left - 1;
  if(state->left == 0)
    next_state(state);

  unsigned long int *tmp_post_1 = state->next;
  state->next = state->next + 1l;
  y = *tmp_post_1;
  y = y ^ y >> 11;
  y = y ^ y << 7 & 0x9d2c5680UL;
  y = y ^ y << 15 & 0xefc60000UL;
  y = y ^ y >> 18;
  return y;
}

// twister_init
// file mt19937ar-cok.c line 66
void twister_init(struct twister_state_t_ *state, unsigned long int *init_key, unsigned long int key_length)
{
  signed int i = 1;
  signed int j = 0;
  signed int k = (signed int)((unsigned long int)624 > key_length ? (unsigned long int)624 : key_length);
  init_genrand(state, 19650218UL);
  for( ; !(k == 0); k = k - 1)
  {
    state->array[(signed long int)i] = (state->array[(signed long int)i] ^ (state->array[(signed long int)(i - 1)] ^ state->array[(signed long int)(i - 1)] >> 30) * 1664525UL) + init_key[(signed long int)j] + (unsigned long int)j;
    state->array[(signed long int)i] = state->array[(signed long int)i] & 0xffffffffUL;
    i = i + 1;
    j = j + 1;
    if(i >= 624)
    {
      state->array[(signed long int)0] = state->array[(signed long int)(624 - 1)];
      i = 1;
    }

    if((unsigned long int)j >= key_length)
      j = 0;

  }
  k = 624 - 1;
  for( ; !(k == 0); k = k - 1)
  {
    state->array[(signed long int)i] = (state->array[(signed long int)i] ^ (state->array[(signed long int)(i - 1)] ^ state->array[(signed long int)(i - 1)] >> 30) * 1566083941UL) - (unsigned long int)i;
    state->array[(signed long int)i] = state->array[(signed long int)i] & 0xffffffffUL;
    i = i + 1;
    if(i >= 624)
    {
      state->array[(signed long int)0] = state->array[(signed long int)(624 - 1)];
      i = 1;
    }

  }
  state->array[(signed long int)0] = 0x80000000UL;
  state->left = 1;
  state->initf = 1;
}

