// tag-#anon#ST[*{V(SYM#tag-sigval#)->V}_V(SYM#tag-sigval#)->V_'_function'||*{SYM#tag-pthread_attr_t#}_SYM#tag-pthread_attr_t#_'_attribute'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 327
struct anonymous_19;

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_14;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_12;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_0;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_17;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_8;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_11;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_10;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_16;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_9;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_13;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous;

// tag-#anon#UN[ARR12{S32}_S32_'_pad'||S32'_tid'||SYM#tag-#anon#ST[*{V(SYM#tag-sigval#)->V}_V(SYM#tag-sigval#)->V_'_function'||*{SYM#tag-pthread_attr_t#}_SYM#tag-pthread_attr_t#_'_attribute'|]#'_sigev_thread'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 319
union anonymous_1;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_15;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_5;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_4;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_3;

// tag-#anon#UN[SYM#tag-io_iocb_common#'c'||SYM#tag-io_iocb_vector#'v'||SYM#tag-io_iocb_poll#'poll'||SYM#tag-io_iocb_sockaddr#'saddr'|]
// file /usr/include/libaio.h line 126
union anonymous_7;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_6;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_2;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-aicb
// file sanlock_internal.h line 454
struct aicb;

// tag-aiocb
// file /usr/include/aio.h line 35
struct aiocb;

// tag-blkid_struct_probe
// file /usr/include/blkid/blkid.h line 55
struct blkid_struct_probe;

// tag-blkid_struct_topology
// file /usr/include/blkid/blkid.h line 62
struct blkid_struct_topology;

// tag-client
// file sanlock_internal.h line 485
struct client;

// tag-cmd_args
// file cmd.h line 12
struct cmd_args;

// tag-command_line
// file sanlock_internal.h line 523
struct command_line;

// tag-entry
// file log.c line 40
struct entry;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-host_status
// file sanlock_internal.h line 128
struct host_status;

// tag-io_context
// file /usr/include/libaio.h line 37
struct io_context;

// tag-io_event
// file /usr/include/libaio.h line 134
struct io_event;

// tag-io_iocb_common
// file /usr/include/libaio.h line 103
struct io_iocb_common;

// tag-io_iocb_poll
// file /usr/include/libaio.h line 94
struct io_iocb_poll;

// tag-io_iocb_sockaddr
// file /usr/include/libaio.h line 98
struct io_iocb_sockaddr;

// tag-io_iocb_vector
// file /usr/include/libaio.h line 112
struct io_iocb_vector;

// tag-iocb
// file /usr/include/libaio.h line 118
struct iocb;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-leader_record
// file leader.h line 47
struct leader_record;

// tag-lease_status
// file sanlock_internal.h line 114
struct lease_status;

// tag-list_head
// file list.h line 31
struct list_head;

// tag-mode_block
// file mode_block.h line 17
struct mode_block;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-paxos_dblock
// file paxos_lease.c line 38
struct paxos_dblock;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-random_data
// file /usr/include/stdlib.h line 343
struct random_data;

// tag-request_record
// file leader.h line 79
struct request_record;

// tag-resource
// file sanlock_internal.h line 86
struct resource;

// tag-sanlk_disk
// file sanlock.h line 47
struct sanlk_disk;

// tag-sanlk_lockspace
// file sanlock.h line 82
struct sanlk_lockspace;

// tag-sanlk_options
// file sanlock.h line 74
struct sanlk_options;

// tag-sanlk_resource
// file sanlock.h line 58
struct sanlk_resource;

// tag-sanlk_state
// file sanlock_sock.h line 60
struct sanlk_state;

// tag-sched_param
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 72
struct sched_param;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigevent
// file /usr/include/time.h line 168
struct sigevent;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sm_header
// file sanlock_sock.h line 41
struct sm_header;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-space
// file sanlock_internal.h line 139
struct space;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-sync_disk
// file sanlock_internal.h line 57
struct sync_disk;

// tag-task
// file sanlock_internal.h line 460
struct task;

// tag-thread_pool
// file main.c line 59
struct thread_pool;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-token
// file sanlock_internal.h line 73
struct token;

// tag-ucred
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 311
struct ucred;

// tag-utsname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 48
struct utsname;

// tag-wdmd_header
// file wdmd_sock.h line 24
struct wdmd_header;

#ifndef NULL
#define NULL ((void*)0)
#endif

// INIT_LIST_HEAD
// file list.h line 40
static inline void INIT_LIST_HEAD(struct list_head *list);
// INIT_LIST_HEAD_link1
// file list.h line 40
static inline void INIT_LIST_HEAD_link1(struct list_head *list_link1);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __list_add
// file list.h line 52
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next);
// __list_add_link1
// file list.h line 52
static inline void __list_add_link1(struct list_head *new_link1, struct list_head *prev_link1, struct list_head *next_link1);
// __list_add_link2
// file list.h line 52
static inline void __list_add_link2(struct list_head *new_link2, struct list_head *prev_link2, struct list_head *next_link2);
// __list_del
// file list.h line 96
static inline void __list_del(struct list_head *prev, struct list_head *next);
// __list_del_link1
// file list.h line 96
static inline void __list_del_link1(struct list_head *prev_link1, struct list_head *next_link1);
// __list_del_link2
// file list.h line 96
static inline void __list_del_link2(struct list_head *prev_link2, struct list_head *next_link2);
// _client_free
// file main.c line 119
static void _client_free(signed int ci);
// _leader_read_num
// file paxos_lease.c line 715
static signed int _leader_read_num(struct task *task, struct token *token, struct leader_record *leader_ret, const char *caller);
// _leader_read_num_link1
// file paxos_lease.c line 715
static signed int _leader_read_num_link1(struct task *task_link1, struct token *token_link1, struct leader_record *leader_ret_link1, const char *caller_link1);
// _leader_read_one
// file paxos_lease.c line 691
static signed int _leader_read_one(struct task *task, struct token *token, struct leader_record *leader_ret, const char *caller);
// _leader_read_one_link1
// file paxos_lease.c line 691
static signed int _leader_read_one_link1(struct task *task_link1, struct token *token_link1, struct leader_record *leader_ret_link1, const char *caller_link1);
// _lease_read_num
// file paxos_lease.c line 900
static signed int _lease_read_num(struct task *task, struct token *token, struct leader_record *leader_ret, struct paxos_dblock *our_dblock, unsigned long int *max_mbal, signed int *max_q, const char *caller);
// _lease_read_num_link1
// file paxos_lease.c line 900
static signed int _lease_read_num_link1(struct task *task_link1, struct token *token_link1, struct leader_record *leader_ret_link1, struct paxos_dblock *our_dblock_link1, unsigned long int *max_mbal_link1, signed int *max_q_link1, const char *caller_link1);
// _lease_read_one
// file paxos_lease.c line 837
static signed int _lease_read_one(struct task *task, struct token *token, struct sync_disk *disk, struct leader_record *leader_ret, struct paxos_dblock *our_dblock, unsigned long int *max_mbal, signed int *max_q, const char *caller);
// _lease_read_one_link1
// file paxos_lease.c line 837
static signed int _lease_read_one_link1(struct task *task_link1, struct token *token_link1, struct sync_disk *disk_link1, struct leader_record *leader_ret_link1, struct paxos_dblock *our_dblock_link1, unsigned long int *max_mbal_link1, signed int *max_q_link1, const char *caller_link1);
// _lockspace_info
// file lockspace.c line 95
signed int _lockspace_info(char *space_name, struct space *sp_out);
// _log_save_dump
// file log.c line 61
static void _log_save_dump(signed int level, signed int len);
// _log_save_ent
// file log.c line 86
static void _log_save_ent(signed int level, signed int len);
// _release_token
// file resource.c line 340
static signed int _release_token(struct task *task, struct token *token, signed int opened, signed int nodisk);
// _search_space
// file lockspace.c line 39
static struct space * _search_space(char *name, struct sync_disk *disk, unsigned long int host_id, struct list_head *head1, struct list_head *head2, struct list_head *head3);
// _write_sectors
// file diskio.c line 599
static signed int _write_sectors(struct sync_disk *disk, unsigned long int sector_nr, unsigned int sector_count, const char *data, signed int data_len, signed int iobuf_len, struct task *task, const char *blktype);
// _write_sectors_link1
// file diskio.c line 599
static signed int _write_sectors_link1(struct sync_disk *disk_link1, unsigned long int sector_nr_link1, unsigned int sector_count_link1, const char *data_link1, signed int data_len_link1, signed int iobuf_len_link1, struct task *task_link1, const char *blktype_link1);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// acquire_disk
// file resource.c line 293
static signed int acquire_disk(struct task *task, struct token *token, unsigned long int acquire_lver, signed int new_num_hosts, struct leader_record *leader);
// acquire_token
// file resource.c line 557
signed int acquire_token(struct task *task, struct token *token);
// add_lockspace_start
// file lockspace.c line 577
signed int add_lockspace_start(struct sanlk_lockspace *ls, struct space **sp_out);
// add_lockspace_wait
// file lockspace.c line 679
signed int add_lockspace_wait(struct space *sp);
// aio_cancel
// file /usr/include/aio.h line 162
extern signed int aio_cancel(signed int, struct aiocb *);
// aio_read
// file /usr/include/aio.h line 145
extern signed int aio_read(struct aiocb *);
// aio_suspend
// file /usr/include/aio.h line 169
extern signed int aio_suspend(struct aiocb * const *, signed int, struct timespec *);
// aio_write
// file /usr/include/aio.h line 147
extern signed int aio_write(struct aiocb *);
// all_pids_dead
// file main.c line 512
static signed int all_pids_dead(struct space *sp);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atoll
// file /usr/include/stdlib.h line 157
extern signed long long int atoll(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// blkid_free_probe
// file /usr/include/blkid/blkid.h line 222
extern void blkid_free_probe(struct blkid_struct_probe *);
// blkid_new_probe_from_filename
// file /usr/include/blkid/blkid.h line 220
extern struct blkid_struct_probe * blkid_new_probe_from_filename(const char *);
// blkid_probe_get_sectorsize
// file /usr/include/blkid/blkid.h line 240
extern unsigned int blkid_probe_get_sectorsize(struct blkid_struct_probe *);
// blkid_probe_get_topology
// file /usr/include/blkid/blkid.h line 294
extern struct blkid_struct_topology * blkid_probe_get_topology(struct blkid_struct_probe *);
// blkid_topology_get_logical_sector_size
// file /usr/include/blkid/blkid.h line 302
extern unsigned long int blkid_topology_get_logical_sector_size(struct blkid_struct_topology *);
// blkid_topology_get_physical_sector_size
// file /usr/include/blkid/blkid.h line 304
extern unsigned long int blkid_topology_get_physical_sector_size(struct blkid_struct_topology *);
// call_cmd_daemon
// file cmd.h line 25
void call_cmd_daemon(signed int ci, struct sm_header *h_recv, signed int client_maxi);
// call_cmd_thread
// file cmd.h line 22
void call_cmd_thread(struct task *task, struct cmd_args *ca);
// check_mode_block
// file resource.h line 16
void check_mode_block(struct token *token, signed int q, char *dblock);
// check_new_tokens_space
// file cmd.c line 87
static signed int check_new_tokens_space(struct client *cl, struct token **new_tokens, signed int new_tokens_count);
// check_other_leases
// file lockspace.c line 248
void check_other_leases(struct task *task, struct space *sp, char *buf);
// check_our_lease
// file lockspace.c line 309
signed int check_our_lease(struct task *task, struct space *sp, signed int *check_all, char *check_buf);
// chmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 283
extern signed int chmod(const char *, unsigned int);
// chown
// file /usr/include/unistd.h line 473
extern signed int chown(const char *, unsigned int, unsigned int);
// clear_dead_shared
// file resource.c line 247
static signed int clear_dead_shared(struct task *task, struct token *token, signed int num_hosts, signed int *live_count);
// client_add
// file main.c line 264
static signed int client_add(signed int fd, void (*workfn)(signed int), void (*deadfn)(signed int));

//


//

// client_alloc
// file main.c line 92
static signed int client_alloc(void);
// client_free
// file main.c line 174
void client_free(signed int ci);
// client_pid_dead
// file main.c line 334
void client_pid_dead(signed int ci);
// client_recv_all
// file main.c line 296
void client_recv_all(signed int ci, struct sm_header *h_recv, signed int pos);
// client_resume
// file main.c line 226
void client_resume(signed int ci);
// client_suspend
// file main.c line 186
static signed int client_suspend(signed int ci);
// client_using_space
// file main.c line 415
static signed int client_using_space(struct client *cl, struct space *sp);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_disks
// file diskio.h line 12
void close_disks(struct sync_disk *disks, signed int num_disks);
// close_logging
// file log.c line 278
void close_logging(void);
// close_task_aio
// file task.h line 14
void close_task_aio(struct task *task);
// close_token_manager
// file resource.h line 28
void close_token_manager(void);
// close_watchdog
// file watchdog.h line 18
void close_watchdog(void);
// close_watchdog_file
// file watchdog.h line 15
void close_watchdog_file(struct space *sp);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// cmd_acquire
// file cmd.c line 121
static void cmd_acquire(struct task *task, struct cmd_args *ca);
// cmd_add_lockspace
// file cmd.c line 845
static void cmd_add_lockspace(struct cmd_args *ca);
// cmd_align
// file cmd.c line 1014
static void cmd_align(struct task *task, struct cmd_args *ca);
// cmd_examine
// file cmd.c line 796
static void cmd_examine(struct task *task, struct cmd_args *ca);
// cmd_host_status
// file cmd.c line 1547
static void cmd_host_status(signed int fd, struct sm_header *h_recv);
// cmd_init_lockspace
// file cmd.c line 1057
static void cmd_init_lockspace(struct task *task, struct cmd_args *ca);
// cmd_init_resource
// file cmd.c line 1104
static void cmd_init_resource(struct task *task, struct cmd_args *ca);
// cmd_inq_lockspace
// file cmd.c line 891
static void cmd_inq_lockspace(struct cmd_args *ca);
// cmd_inquire
// file cmd.c line 569
static void cmd_inquire(struct task *task, struct cmd_args *ca);
// cmd_lockspace
// file client.c line 119
static signed int cmd_lockspace(signed int cmd, struct sanlk_lockspace *ls, unsigned int flags);
// cmd_log_dump
// file cmd.c line 1607
static void cmd_log_dump(signed int fd, struct sm_header *h_recv);
// cmd_release
// file cmd.c line 466
static void cmd_release(struct task *task, struct cmd_args *ca);
// cmd_rem_lockspace
// file cmd.c line 965
static void cmd_rem_lockspace(struct cmd_args *ca);
// cmd_request
// file cmd.c line 699
static void cmd_request(struct task *task, struct cmd_args *ca);
// cmd_restrict
// file cmd.c line 1619
static void cmd_restrict(signed int ci, signed int fd, struct sm_header *h_recv);
// cmd_status
// file cmd.c line 1500
static void cmd_status(signed int fd, struct sm_header *h_recv, signed int client_maxi);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// connect_socket
// file client.c line 40
static signed int connect_socket(signed int *sock_fd);
// copy_disks
// file resource.c line 502
static void copy_disks(void *dst, void *src, signed int num_disks);
// copy_log_dump
// file log.c line 189
void copy_log_dump(char *buf, signed int *len);
// copy_path_in
// file client.c line 249
static void copy_path_in(char *dst, char *src);
// copy_path_out
// file client.c line 236
static void copy_path_out(char *dst, char *src);
// corrupt_result
// file lockspace.c line 358
static signed int corrupt_result(signed int result);
// crc32c
// file crc32c.c line 96
unsigned int crc32c(unsigned int crc, unsigned char *data, unsigned long int length);
// create_bitmap
// file lockspace.c line 221
static void create_bitmap(struct task *task, struct space *sp, char *bitmap);
// create_watchdog_file
// file watchdog.h line 13
signed int create_watchdog_file(struct space *sp, unsigned long int timestamp);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// dblock_checksum
// file paxos_lease.c line 183
static unsigned int dblock_checksum(struct paxos_dblock *pd);
// dblock_checksum_link1
// file paxos_lease.c line 183
static unsigned int dblock_checksum_link1(struct paxos_dblock *pd_link1);
// delta_lease_acquire
// file delta_lease.c line 191
signed int delta_lease_acquire(struct task *task, struct space *sp, struct sync_disk *disk, char *space_name, char *our_host_name, unsigned long int host_id, struct leader_record *leader_ret);
// delta_lease_init
// file delta_lease.c line 547
signed int delta_lease_init(struct task *task, struct sync_disk *disk, char *space_name, signed int max_hosts);
// delta_lease_leader_read
// file delta_lease.c line 150
signed int delta_lease_leader_read(struct task *task, struct sync_disk *disk, char *space_name, unsigned long int host_id, struct leader_record *leader_ret, const char *caller);
// delta_lease_release
// file delta_lease.c line 513
signed int delta_lease_release(struct task *task, struct space *sp, struct sync_disk *disk, char *space_name, struct leader_record *leader_last, struct leader_record *leader_ret);
// delta_lease_renew
// file delta_lease.c line 329
signed int delta_lease_renew(struct task *task, struct space *sp, struct sync_disk *disk, char *space_name, char *bitmap, signed int prev_result, signed int *read_result, struct leader_record *leader_last, struct leader_record *leader_ret);
// direct_acquire
// file direct.c line 161
signed int direct_acquire(struct task *task, struct sanlk_resource *res, signed int num_hosts, unsigned long int local_host_id, unsigned long int local_host_generation, struct leader_record *leader_ret);
// direct_acquire_id
// file direct.c line 282
signed int direct_acquire_id(struct task *task, struct sanlk_lockspace *ls, char *our_host_name);
// direct_align
// file direct.h line 41
signed int direct_align(struct sync_disk *disk);
// direct_dump
// file direct.c line 429
signed int direct_dump(struct task *task, char *dump_path, signed int force_mode);
// direct_init
// file direct.c line 387
signed int direct_init(struct task *task, struct sanlk_lockspace *ls, struct sanlk_resource *res, signed int max_hosts, signed int num_hosts);
// direct_live_id
// file direct.c line 318
signed int direct_live_id(struct task *task, struct sanlk_lockspace *ls, unsigned long int *timestamp, unsigned long int *owner_id, unsigned long int *owner_generation, signed int *live);
// direct_read_id
// file direct.c line 298
signed int direct_read_id(struct task *task, struct sanlk_lockspace *ls, unsigned long int *timestamp, unsigned long int *owner_id, unsigned long int *owner_generation);
// direct_read_leader
// file direct.c line 411
signed int direct_read_leader(struct task *task, struct sanlk_lockspace *ls, struct sanlk_resource *res, struct leader_record *leader_ret);
// direct_release
// file direct.c line 174
signed int direct_release(struct task *task, struct sanlk_resource *res, struct leader_record *leader_ret);
// direct_release_id
// file direct.c line 288
signed int direct_release_id(struct task *task, struct sanlk_lockspace *ls);
// direct_renew_id
// file direct.c line 293
signed int direct_renew_id(struct task *task, struct sanlk_lockspace *ls);
// do_client
// file main.c line 1703
static signed int do_client(void);
// do_daemon
// file main.c line 1189
static signed int do_daemon(void);
// do_delta_action
// file direct.c line 184
static signed int do_delta_action(signed int action, struct task *task, struct sanlk_lockspace *ls, signed int max_hosts, char *our_host_name, struct leader_record *leader_ret);
// do_delta_action_link1
// file direct.c line 184
static signed int do_delta_action_link1(signed int action_link1, struct task *task_link1, struct sanlk_lockspace *ls_link1, signed int max_hosts_link1, char *our_host_name_link1, struct leader_record *leader_ret_link1);
// do_direct
// file main.c line 1871
static signed int do_direct(void);
// do_linux_aio
// file diskio.c line 368
static signed int do_linux_aio(signed int fd, unsigned long int offset, char *buf, signed int len, struct task *task, signed int cmd);
// do_linux_aio_link1
// file diskio.c line 368
static signed int do_linux_aio_link1(signed int fd_link1, unsigned long int offset_link1, char *buf_link1, signed int len_link1, struct task *task_link1, signed int cmd_link1);
// do_paxos_action
// file direct.c line 81
static signed int do_paxos_action(signed int action, struct task *task, struct sanlk_resource *res, signed int max_hosts, signed int num_hosts, unsigned long int local_host_id, unsigned long int local_host_generation, struct leader_record *leader_ret);
// do_paxos_action_link1
// file direct.c line 81
static signed int do_paxos_action_link1(signed int action_link1, struct task *task_link1, struct sanlk_resource *res_link1, signed int max_hosts_link1, signed int num_hosts_link1, unsigned long int local_host_id_link1, unsigned long int local_host_generation_link1, struct leader_record *leader_ret_link1);
// do_read
// file diskio.c line 292
static signed int do_read(signed int fd, unsigned long int offset, char *buf, signed int len, struct task *task);
// do_read_link1
// file diskio.c line 292
static signed int do_read_link1(signed int fd_link1, unsigned long int offset_link1, char *buf_link1, signed int len_link1, struct task *task_link1);
// do_read_aio_linux
// file diskio.c line 485
static signed int do_read_aio_linux(signed int fd, unsigned long int offset, char *buf, signed int len, struct task *task);
// do_read_aio_linux_link1
// file diskio.c line 485
static signed int do_read_aio_linux_link1(signed int fd_link1, unsigned long int offset_link1, char *buf_link1, signed int len_link1, struct task *task_link1);
// do_read_aio_posix
// file diskio.c line 539
static signed int do_read_aio_posix(signed int fd, unsigned long int offset, char *buf, signed int len, struct task *task);
// do_read_aio_posix_link1
// file diskio.c line 539
static signed int do_read_aio_posix_link1(signed int fd_link1, unsigned long int offset_link1, char *buf_link1, signed int len_link1, struct task *task_link1);
// do_req_kill_pid
// file resource.c line 802
static void do_req_kill_pid(struct token *tt, signed int pid);
// do_write
// file diskio.c line 259
static signed int do_write(signed int fd, unsigned long int offset, const char *buf, signed int len, struct task *task);
// do_write_link1
// file diskio.c line 259
static signed int do_write_link1(signed int fd_link1, unsigned long int offset_link1, const char *buf_link1, signed int len_link1, struct task *task_link1);
// do_write_aio_linux
// file diskio.c line 480
static signed int do_write_aio_linux(signed int fd, unsigned long int offset, char *buf, signed int len, struct task *task);
// do_write_aio_linux_link1
// file diskio.c line 480
static signed int do_write_aio_linux_link1(signed int fd_link1, unsigned long int offset_link1, char *buf_link1, signed int len_link1, struct task *task_link1);
// do_write_aio_posix
// file diskio.c line 490
static signed int do_write_aio_posix(signed int fd, unsigned long int offset, char *buf, signed int len, struct task *task);
// do_write_aio_posix_link1
// file diskio.c line 490
static signed int do_write_aio_posix_link1(signed int fd_link1, unsigned long int offset_link1, char *buf_link1, signed int len_link1, struct task *task_link1);
// examine_token
// file resource.c line 772
static signed int examine_token(struct task *task, struct token *token, struct request_record *req_out);
// execv
// file /usr/include/unistd.h line 563
extern signed int execv(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// find_callback_slot
// file diskio.c line 318
static struct aicb * find_callback_slot(struct task *task);
// find_callback_slot_link1
// file diskio.c line 318
static struct aicb * find_callback_slot_link1(struct task *task_link1);
// find_lockspace
// file lockspace.c line 90
struct space * find_lockspace(char *name);
// find_resource
// file resource.c line 463
static struct resource * find_resource(struct token *token, struct list_head *head);
// find_resource_flag
// file resource.c line 865
static struct resource * find_resource_flag(struct list_head *head, unsigned int flag);
// find_type
// file client_cmd.c line 195
static signed int find_type(signed int type, signed int *sort_index);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_lockspaces
// file lockspace.c line 860
void free_lockspaces(signed int wait);
// free_sp
// file lockspace.c line 570
static void free_sp(struct space *sp);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// get_peer_pid
// file cmd.c line 1629
static signed int get_peer_pid(signed int fd, signed int *pid);
// get_rand
// file main.c line 1143
signed int get_rand(signed int a, signed int b);
// getgrnam
// file /usr/include/grp.h line 110
extern struct group * getgrnam(const char *);
// getpagesize
// file /usr/include/unistd.h line 978
extern signed int getpagesize(void);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// group_to_gid
// file main.c line 1282
static signed int group_to_gid(char *arg);
// host_info
// file lockspace.c line 198
signed int host_info(char *space_name, unsigned long int host_id, struct host_status *hs_out);
// host_live
// file resource.c line 77
static signed int host_live(struct task *task, char *lockspace_name, unsigned long int host_id, unsigned long int gen);
// host_status_set_bit
// file lockspace.c line 172
signed int host_status_set_bit(char *space_name, unsigned long int host_id);
// initstate_r
// file /usr/include/stdlib.h line 360
extern signed int initstate_r(unsigned int, char *, unsigned long int, struct random_data *);
// inq_lockspace
// file lockspace.c line 720
signed int inq_lockspace(struct sanlk_lockspace *ls);
// io_cancel
// file /usr/include/libaio.h line 158
extern signed int io_cancel(struct io_context *, struct iocb *, struct io_event *);
// io_destroy
// file /usr/include/libaio.h line 156
extern signed int io_destroy(struct io_context *);
// io_getevents
// file /usr/include/libaio.h line 159
extern signed int io_getevents(struct io_context *, signed long int, signed long int, struct io_event *, struct timespec *);
// io_setup
// file /usr/include/libaio.h line 155
extern signed int io_setup(signed int, struct io_context **);
// io_submit
// file /usr/include/libaio.h line 157
extern signed int io_submit(struct io_context *, signed long int, struct iocb **);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// kill_pids
// file main.c line 438
static void kill_pids(struct space *sp);
// leader_checksum
// file paxos_lease.h line 16
unsigned int leader_checksum(struct leader_record *lr);
// leaders_match
// file paxos_lease.c line 684
static signed int leaders_match(struct leader_record *a, struct leader_record *b);
// leaders_match_link1
// file paxos_lease.c line 684
static signed int leaders_match_link1(struct leader_record *a_link1, struct leader_record *b_link1);
// list_add
// file list.h line 70
static inline void list_add(struct list_head *new, struct list_head *head);
// list_add_link1
// file list.h line 70
static inline void list_add_link1(struct list_head *new_link1, struct list_head *head_link1);
// list_add_link2
// file list.h line 70
static inline void list_add_link2(struct list_head *new_link2, struct list_head *head_link2);
// list_add_tail
// file list.h line 84
static inline void list_add_tail(struct list_head *new, struct list_head *head);
// list_del
// file list.h line 108
static inline void list_del(struct list_head *entry);
// list_del_link1
// file list.h line 108
static inline void list_del_link1(struct list_head *entry_link1);
// list_del_link2
// file list.h line 108
static inline void list_del_link2(struct list_head *entry_link2);
// list_empty
// file list.h line 186
static inline signed int list_empty(struct list_head *head);
// list_empty_link1
// file list.h line 186
static inline signed int list_empty_link1(struct list_head *head_link1);
// list_empty_link2
// file list.h line 186
static inline signed int list_empty_link2(struct list_head *head_link2);
// list_move
// file list.h line 153
static inline void list_move(struct list_head *list, struct list_head *head);
// list_move_link1
// file list.h line 153
static inline void list_move_link1(struct list_head *list_link1, struct list_head *head_link1);
// list_move_link2
// file list.h line 153
static inline void list_move_link2(struct list_head *list_link2, struct list_head *head_link2);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// lockfile
// file lockfile.c line 32
signed int lockfile(const char *dir, const char *name);
// lockspace_disk
// file lockspace.c line 119
signed int lockspace_disk(char *space_name, struct sync_disk *disk);
// lockspace_info
// file lockspace.c line 108
signed int lockspace_info(char *space_name, struct space *sp_out);
// lockspace_is_used
// file resource.c line 478
signed int lockspace_is_used(struct sanlk_lockspace *ls);
// lockspace_thread
// file lockspace.c line 374
static void * lockspace_thread(void *arg_in);
// log_leader_error
// file delta_lease.c line 44
static void log_leader_error(signed int result, char *space_name, unsigned long int host_id, struct sync_disk *disk, struct leader_record *lr, const char *caller);
// log_leader_error_link1
// file paxos_lease.c line 568
static void log_leader_error_link1(signed int result_link1, struct token *token, struct sync_disk *disk_link1, struct leader_record *lr_link1, const char *caller_link1);
// log_leader_error_link1_link1
// file paxos_lease.c line 568
static void log_leader_error_link1_link1(signed int result_link1_link1, struct token *token_link1, struct sync_disk *disk_link1_link1, struct leader_record *lr_link1_link1, const char *caller_link1_link1);
// log_leader_error_link2
// file delta_lease.c line 44
static void log_leader_error_link2(signed int result_link2, char *space_name_link1, unsigned long int host_id_link1, struct sync_disk *disk_link2, struct leader_record *lr_link2, const char *caller_link2);
// log_level
// file log.h line 12
void log_level(unsigned int space_id, unsigned int token_id, char *name_in, signed int level, const char *fmt, ...);
// log_thread_fn
// file log.c line 210
static void * log_thread_fn(void *arg);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// main_loop
// file main.c line 560
static signed int main_loop(void);

//


//

// majority_disks
// file diskio.c line 82
signed int majority_disks(signed int num_disks, signed int num);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mlockall
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 111
extern signed int mlockall(signed int);
// monotime
// file monotime.h line 12
unsigned long int monotime(void);
// new_resource
// file resource.c line 523
static struct resource * new_resource(struct token *token);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// open_disk
// file diskio.h line 13
signed int open_disk(struct sync_disk *disk);
// open_disks
// file diskio.h line 14
signed int open_disks(struct sync_disk *disks, signed int num_disks);
// open_disks_fd
// file diskio.c line 109
signed int open_disks_fd(struct sync_disk *disks, signed int num_disks);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// parse_arg_lockspace
// file main.c line 1296
static signed int parse_arg_lockspace(char *arg);
// parse_arg_resource
// file main.c line 1309
static signed int parse_arg_resource(char *arg);
// paxos_lease_acquire
// file paxos_lease.h line 23
signed int paxos_lease_acquire(struct task *task, struct token *token, unsigned int flags, struct leader_record *leader_ret, unsigned long int acquire_lver, signed int new_num_hosts);
// paxos_lease_init
// file paxos_lease.h line 35
signed int paxos_lease_init(struct task *task, struct token *token, signed int num_hosts, signed int max_hosts);
// paxos_lease_leader_read
// file paxos_lease.h line 18
signed int paxos_lease_leader_read(struct task *task, struct token *token, struct leader_record *leader_ret, const char *caller);
// paxos_lease_read
// file paxos_lease.c line 1006
static signed int paxos_lease_read(struct task *task, struct token *token, struct leader_record *leader_ret, unsigned long int *max_mbal, const char *caller);
// paxos_lease_read_link1
// file paxos_lease.c line 1006
static signed int paxos_lease_read_link1(struct task *task_link1, struct token *token_link1, struct leader_record *leader_ret_link1, unsigned long int *max_mbal_link1, const char *caller_link1);
// paxos_lease_release
// file paxos_lease.h line 30
signed int paxos_lease_release(struct task *task, struct token *token, struct leader_record *leader_last, struct leader_record *leader_ret);
// paxos_lease_request_read
// file paxos_lease.c line 60
signed int paxos_lease_request_read(struct task *task, struct token *token, struct request_record *rr);
// paxos_lease_request_write
// file paxos_lease.c line 75
signed int paxos_lease_request_write(struct task *task, struct token *token, struct request_record *rr);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// posix_memalign
// file /usr/include/stdlib.h line 503
extern signed int posix_memalign(void **, unsigned long int, unsigned long int);
// print_debug
// file client_cmd.c line 41
static void print_debug(char *str, signed int len);
// print_p
// file client_cmd.c line 169
static void print_p(signed int p, signed int debug);
// print_r
// file client_cmd.c line 215
static void print_r(signed int p, char *s, signed int debug);
// print_r_by_p
// file client_cmd.c line 245
static void print_r_by_p(signed int debug);
// print_r_by_s
// file client_cmd.c line 271
static void print_r_by_s(signed int debug);
// print_st
// file client_cmd.c line 123
static void print_st(struct sanlk_state *st, char *str, char *bin, signed int debug);
// print_state_client
// file cmd.c line 1273
static signed int print_state_client(struct client *cl, signed int ci, char *str);
// print_state_daemon
// file cmd.c line 1250
static signed int print_state_daemon(char *str);
// print_state_host
// file cmd.c line 1355
static signed int print_state_host(struct host_status *hs, char *str);
// print_state_lockspace
// file cmd.c line 1304
static signed int print_state_lockspace(struct space *sp, char *str, const char *list_name);
// print_state_resource
// file cmd.c line 1337
static signed int print_state_resource(struct resource *r, char *str, const char *list_name, unsigned int token_id);
// print_type
// file client_cmd.c line 146
static void print_type(signed int type, signed int debug);
// print_usage
// file main.c line 1348
static void print_usage(void);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_cmd_thread_registered
// file main.c line 838
static void process_cmd_thread_registered(signed int ci_in, struct sm_header *h_recv);
// process_cmd_thread_unregistered
// file main.c line 808
static void process_cmd_thread_unregistered(signed int ci_in, struct sm_header *h_recv);
// process_connection
// file main.c line 967
static void process_connection(signed int ci);

//

// process_listener
// file main.c line 1046
static void process_listener(signed int ci);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_4 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_4 *, const union anonymous_5 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_4 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_4 *, union anonymous_3 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_3 *, const union anonymous_5 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_3 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_3 *);
// pthread_tryjoin_np
// file /usr/include/pthread.h line 257
extern signed int pthread_tryjoin_np(unsigned long int, void **);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// random_r
// file /usr/include/stdlib.h line 354
extern signed int random_r(struct random_data *, signed int *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_command_line
// file main.c line 1424
static signed int read_command_line(signed int argc, char **argv);
// read_iobuf
// file diskio.h line 26
signed int read_iobuf(signed int fd, unsigned long int offset, char *iobuf, signed int iobuf_len, struct task *task);
// read_iobuf_reap
// file diskio.h line 29
signed int read_iobuf_reap(signed int fd, unsigned long int offset, char *iobuf, signed int iobuf_len, struct task *task);
// read_leader
// file paxos_lease.c line 169
static signed int read_leader(struct task *task, struct sync_disk *disk, struct leader_record *lr);
// read_leader_link1
// file paxos_lease.c line 169
static signed int read_leader_link1(struct task *task_link1, struct sync_disk *disk_link1, struct leader_record *lr_link1);
// read_mode_block
// file resource.c line 199
static signed int read_mode_block(struct task *task, struct token *token, unsigned long int host_id, unsigned long int *max_gen);
// read_sectors
// file diskio.h line 45
signed int read_sectors(struct sync_disk *disk, unsigned long int sector_nr, unsigned int sector_count, char *data, signed int data_len, struct task *task, const char *blktype);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// recv_bin
// file client_cmd.c line 297
static void recv_bin(signed int fd, struct sanlk_state *st, char *bin);
// recv_result
// file client.c line 103
static signed int recv_result(signed int fd);
// release_cl_tokens
// file cmd.c line 59
static void release_cl_tokens(struct task *task, struct client *cl);
// release_disk
// file resource.c line 323
static signed int release_disk(struct task *task, struct token *token, struct leader_record *leader);
// release_new_tokens
// file cmd.c line 73
static void release_new_tokens(struct task *task, struct token **new_tokens, signed int alloc_count, signed int acquire_count);
// release_token
// file resource.c line 430
signed int release_token(struct task *task, struct token *token);
// release_token_async
// file resource.h line 20
void release_token_async(struct token *token);
// release_token_nodisk
// file resource.c line 420
static signed int release_token_nodisk(struct task *task, struct token *token);
// release_token_opened
// file resource.c line 425
static signed int release_token_opened(struct task *task, struct token *token);
// rem_lockspace_start
// file lockspace.c line 748
signed int rem_lockspace_start(struct sanlk_lockspace *ls, unsigned int *space_id);
// rem_lockspace_wait
// file lockspace.c line 806
signed int rem_lockspace_wait(struct sanlk_lockspace *ls, unsigned int space_id);
// request_token
// file resource.c line 695
signed int request_token(struct task *task, struct token *token, unsigned int force_mode, unsigned long int *owner_id);
// resource_thread
// file resource.c line 934
static void * resource_thread(void *arg);
// resource_thread_examine
// file resource.c line 900
static void resource_thread_examine(struct task *task, struct token *tt, signed int pid, unsigned long int lver);
// resource_thread_release
// file resource.c line 876
static void resource_thread_release(struct task *task, struct resource *r, struct token *tt);
// roundup_power_of_two
// file paxos_lease.c line 48
static unsigned int roundup_power_of_two(unsigned int val);
// roundup_power_of_two_link1
// file paxos_lease.c line 48
static unsigned int roundup_power_of_two_link1(unsigned int val_link1);
// run_ballot
// file paxos_lease.c line 253
static signed int run_ballot(struct task *task, struct token *token, signed int num_hosts, unsigned long int next_lver, unsigned long int our_mbal, struct paxos_dblock *dblock_out);
// run_ballot_link1
// file paxos_lease.c line 253
static signed int run_ballot_link1(struct task *task_link1, struct token *token_link1, signed int num_hosts_link1, unsigned long int next_lver_link1, unsigned long int our_mbal_link1, struct paxos_dblock *dblock_out_link1);
// sanlock_acquire
// file sanlock_resource.h line 38
signed int sanlock_acquire(signed int sock, signed int pid, unsigned int flags, signed int res_count, struct sanlk_resource **res_args, struct sanlk_options *opt_in);
// sanlock_add_lockspace
// file sanlock_admin.h line 29
signed int sanlock_add_lockspace(struct sanlk_lockspace *ls, unsigned int flags);
// sanlock_align
// file sanlock_admin.h line 57
signed int sanlock_align(struct sanlk_disk *disk);
// sanlock_args_to_state
// file sanlock_resource.h line 79
signed int sanlock_args_to_state(signed int res_count, struct sanlk_resource **res_args, char **res_state);
// sanlock_direct_align
// file direct_lib.c line 144
signed int sanlock_direct_align(struct sanlk_disk *disk_in);
// sanlock_direct_init
// file direct_lib.c line 128
signed int sanlock_direct_init(struct sanlk_lockspace *ls, struct sanlk_resource *res, signed int max_hosts, signed int num_hosts, signed int use_aio);
// sanlock_direct_live_id
// file direct_lib.c line 108
signed int sanlock_direct_live_id(struct sanlk_lockspace *ls, unsigned long int *timestamp, unsigned long int *owner_id, unsigned long int *owner_generation, signed int *live, signed int use_aio, signed int io_timeout_sec);
// sanlock_direct_read_id
// file direct_lib.c line 89
signed int sanlock_direct_read_id(struct sanlk_lockspace *ls, unsigned long int *timestamp, unsigned long int *owner_id, unsigned long int *owner_generation, signed int use_aio, signed int io_timeout_sec);
// sanlock_examine
// file sanlock_resource.h line 51
signed int sanlock_examine(unsigned int flags, struct sanlk_lockspace *ls, struct sanlk_resource *res);
// sanlock_host_status
// file client_cmd.h line 13
signed int sanlock_host_status(signed int debug, char *lockspace_name);
// sanlock_init
// file sanlock_admin.h line 66
signed int sanlock_init(struct sanlk_lockspace *ls, struct sanlk_resource *res, signed int max_hosts, signed int num_hosts);
// sanlock_inq_lockspace
// file sanlock_admin.h line 37
signed int sanlock_inq_lockspace(struct sanlk_lockspace *ls, unsigned int flags);
// sanlock_inquire
// file sanlock_resource.h line 45
signed int sanlock_inquire(signed int sock, signed int pid, unsigned int flags, signed int *res_count, char **res_state);
// sanlock_log_dump
// file client_cmd.h line 14
signed int sanlock_log_dump(signed int max_size);
// sanlock_register
// file sanlock_resource.h line 34
signed int sanlock_register(void);
// sanlock_release
// file sanlock_resource.h line 42
signed int sanlock_release(signed int sock, signed int pid, unsigned int flags, signed int res_count, struct sanlk_resource **res_args);
// sanlock_rem_lockspace
// file sanlock_admin.h line 50
signed int sanlock_rem_lockspace(struct sanlk_lockspace *ls, unsigned int flags);
// sanlock_request
// file sanlock_resource.h line 48
signed int sanlock_request(unsigned int flags, unsigned int force_mode, struct sanlk_resource *res);
// sanlock_res_to_str
// file sanlock_resource.h line 64
signed int sanlock_res_to_str(struct sanlk_resource *res, char **str_ret);
// sanlock_restrict
// file client.c line 277
signed int sanlock_restrict(signed int sock, unsigned int flags);
// sanlock_shutdown
// file client_cmd.h line 15
signed int sanlock_shutdown(unsigned int force);
// sanlock_socket_address
// file sanlock_sock.h line 70
signed int sanlock_socket_address(struct sockaddr_un *addr);
// sanlock_state_to_args
// file sanlock_resource.h line 89
signed int sanlock_state_to_args(char *res_state, signed int *res_count, struct sanlk_resource ***res_args);
// sanlock_status
// file client_cmd.h line 12
signed int sanlock_status(signed int debug, char sort_arg);
// sanlock_str_to_lockspace
// file sanlock_resource.h line 98
signed int sanlock_str_to_lockspace(char *str, struct sanlk_lockspace *ls);
// sanlock_str_to_res
// file sanlock_resource.h line 71
signed int sanlock_str_to_res(char *str, struct sanlk_resource **res_ret);
// sched_get_priority_max
// file /usr/include/sched.h line 68
extern signed int sched_get_priority_max(signed int);
// sched_setscheduler
// file /usr/include/sched.h line 58
extern signed int sched_setscheduler(signed int, signed int, struct sched_param *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// send_command
// file client.c line 86
signed int send_command(signed int cmd, unsigned int data);
// send_header
// file client.c line 63
static signed int send_header(signed int sock, signed int cmd, unsigned int cmd_flags, signed int datalen, unsigned int data, unsigned int data2);
// send_header_link1
// file client.c line 66
static signed int send_header_link1(signed int con, signed int cmd_link1);
// send_header_link2
// file client.c line 66
static signed int send_header_link2(signed int con_link1, signed int cmd_link2);
// send_result
// file main.c line 322
void send_result(signed int fd, struct sm_header *h_recv, signed int result);
// send_state_client
// file cmd.c line 1396
static void send_state_client(signed int fd, struct client *cl, signed int ci);
// send_state_daemon
// file cmd.c line 1376
static void send_state_daemon(signed int fd);
// send_state_host
// file cmd.c line 1479
static void send_state_host(signed int fd, struct host_status *hs, signed int host_id);
// send_state_lockspace
// file cmd.c line 1417
static void send_state_lockspace(signed int fd, struct space *sp, const char *list_name);
// send_state_resource
// file resource.c line 36
void send_state_resource(signed int fd, struct resource *r, const char *list_name, signed int pid, unsigned int token_id);
// send_state_resources
// file resource.c line 51
void send_state_resources(signed int fd);
// set_disk_properties
// file diskio.c line 34
static signed int set_disk_properties(struct sync_disk *disk);
// set_disk_properties_link1
// file diskio.c line 34
static signed int set_disk_properties_link1(struct sync_disk *disk_link1);
// set_id_bit
// file lockspace.c line 145
void set_id_bit(signed int host_id, char *bitmap, char *c);
// set_mode_block
// file resource.c line 146
static signed int set_mode_block(struct task *task, struct token *token, unsigned long int host_id, unsigned long int gen, unsigned int flags);
// set_resource_examine
// file resource.h line 25
signed int set_resource_examine(char *space_name, char *res_name);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setup_host_name
// file main.c line 1157
static void setup_host_name(void);
// setup_listener
// file main.c line 1060
static signed int setup_listener(void);
// setup_logging
// file log.c line 248
signed int setup_logging(void);
// setup_priority
// file main.c line 1112
static void setup_priority(void);
// setup_task_aio
// file task.h line 13
void setup_task_aio(struct task *task, signed int use_aio, signed int cb_size);
// setup_task_lib
// file direct_lib.c line 78
static void setup_task_lib(struct task *task, signed int use_aio, signed int io_timeout_sec);
// setup_task_timeouts
// file task.h line 12
void setup_task_timeouts(struct task *task, signed int io_timeout_arg);
// setup_token_manager
// file resource.h line 27
signed int setup_token_manager(void);
// setup_watchdog
// file watchdog.h line 17
signed int setup_watchdog(void);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigterm_handler
// file main.c line 1107
static void sigterm_handler(signed int sig);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// status_client
// file client_cmd.c line 67
static void status_client(struct sanlk_state *st, char *str, signed int debug);
// status_daemon
// file client_cmd.c line 59
static void status_daemon(struct sanlk_state *st, char *str, signed int debug);
// status_host
// file client_cmd.c line 114
static void status_host(struct sanlk_state *st, char *str, signed int debug);
// status_lockspace
// file client_cmd.c line 76
static void status_lockspace(struct sanlk_state *st, char *str, char *bin, signed int debug);
// status_resource
// file client_cmd.c line 90
static void status_resource(struct sanlk_state *st, char *str, char *bin, signed int debug);
// stop_lockspace_thread
// file lockspace.c line 837
static signed int stop_lockspace_thread(struct space *sp, signed int wait);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// strtoull
// file /usr/include/stdlib.h line 214
extern unsigned long long int strtoull(const char *, char ** restrict , signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// test_id_bit
// file direct.c line 427
signed int test_id_bit(signed int host_id, char *bitmap);
// thread_pool_add_work
// file main.c line 739
static signed int thread_pool_add_work(struct cmd_args *ca);
// thread_pool_create
// file main.c line 779
static signed int thread_pool_create(signed int min_workers, signed int max_workers);
// thread_pool_free
// file main.c line 768
static void thread_pool_free(void);
// thread_pool_worker
// file main.c line 696
static void * thread_pool_worker(void *data);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// time_diff
// file main.c line 550
static unsigned int time_diff(struct timeval *begin, struct timeval *end);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// uname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 81
extern signed int uname(struct utsname *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unlink_lockfile
// file lockfile.c line 92
void unlink_lockfile(signed int fd, const char *dir, const char *name);
// unlink_watchdog_file
// file watchdog.h line 14
void unlink_watchdog_file(struct space *sp);
// update_watchdog_file
// file watchdog.h line 12
void update_watchdog_file(struct space *sp, unsigned long int timestamp);
// user_to_uid
// file main.c line 1268
static signed int user_to_uid(char *arg);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// uuid_generate
// file /usr/include/uuid/uuid.h line 79
extern void uuid_generate(unsigned char *);
// uuid_unparse_lower
// file /usr/include/uuid/uuid.h line 92
extern void uuid_unparse_lower(unsigned char *, char *);
// verify_dblock
// file paxos_lease.c line 188
static signed int verify_dblock(struct token *token, struct paxos_dblock *pd);
// verify_dblock_link1
// file paxos_lease.c line 188
static signed int verify_dblock_link1(struct token *token_link1, struct paxos_dblock *pd_link1);
// verify_leader
// file delta_lease.c line 78
static signed int verify_leader(struct sync_disk *disk, char *space_name, unsigned long int host_id, struct leader_record *lr, const char *caller);
// verify_leader_link1
// file paxos_lease.c line 607
static signed int verify_leader_link1(struct token *token, struct sync_disk *disk_link1, struct leader_record *lr_link1, const char *caller_link1);
// verify_leader_link1_link1
// file paxos_lease.c line 607
static signed int verify_leader_link1_link1(struct token *token_link1, struct sync_disk *disk_link1_link1, struct leader_record *lr_link1_link1, const char *caller_link1_link1);
// verify_leader_link2
// file delta_lease.c line 78
static signed int verify_leader_link2(struct sync_disk *disk_link2, char *space_name_link1, unsigned long int host_id_link1, struct leader_record *lr_link2, const char *caller_link2);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// wdmd_connect
// file ../wdmd/wdmd.h line 15
signed int wdmd_connect(void);
// wdmd_refcount_clear
// file ../wdmd/wdmd.h line 18
signed int wdmd_refcount_clear(signed int con);
// wdmd_refcount_set
// file ../wdmd/wdmd.h line 17
signed int wdmd_refcount_set(signed int con);
// wdmd_register
// file ../wdmd/wdmd.h line 16
signed int wdmd_register(signed int con, char *name);
// wdmd_socket_address
// file wdmd_sock.h line 37
signed int wdmd_socket_address(struct sockaddr_un *addr);
// wdmd_status
// file ../wdmd/wdmd.h line 20
signed int wdmd_status(signed int con, signed int *test_interval, signed int *fire_timeout, unsigned long int *last_keepalive);
// wdmd_test_live
// file ../wdmd/wdmd.h line 19
signed int wdmd_test_live(signed int con, unsigned long int renewal_time, unsigned long int expire_time);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_dblock
// file paxos_lease.c line 88
static signed int write_dblock(struct task *task, struct sync_disk *disk, unsigned long int host_id, struct paxos_dblock *pd);
// write_dblock_link1
// file paxos_lease.c line 88
static signed int write_dblock_link1(struct task *task_link1, struct sync_disk *disk_link1, unsigned long int host_id_link1, struct paxos_dblock *pd_link1);
// write_dropped
// file log.c line 182
static void write_dropped(signed int level, signed int num);
// write_entry
// file log.c line 172
static void write_entry(signed int level, char *str);
// write_iobuf
// file diskio.h line 23
signed int write_iobuf(signed int fd, unsigned long int offset, char *iobuf, signed int iobuf_len, struct task *task);
// write_leader
// file paxos_lease.c line 103
static signed int write_leader(struct task *task, struct sync_disk *disk, struct leader_record *lr);
// write_leader_link1
// file paxos_lease.c line 103
static signed int write_leader_link1(struct task *task_link1, struct sync_disk *disk_link1, struct leader_record *lr_link1);
// write_new_leader
// file paxos_lease.c line 1040
static signed int write_new_leader(struct task *task, struct token *token, struct leader_record *nl, const char *caller);
// write_new_leader_link1
// file paxos_lease.c line 1040
static signed int write_new_leader_link1(struct task *task_link1, struct token *token_link1, struct leader_record *nl_link1, const char *caller_link1);
// write_sector
// file diskio.h line 37
signed int write_sector(struct sync_disk *disk, unsigned long int sector_nr, const char *data, signed int data_len, struct task *task, const char *blktype);
// write_sectors
// file diskio.c line 661
signed int write_sectors(struct sync_disk *disk, unsigned long int sector_nr, unsigned int sector_count, const char *data, signed int data_len, struct task *task, const char *blktype);

struct anonymous_19
{
  // _function
  void (*_function)(union sigval);
  // _attribute
  union pthread_attr_t *_attribute;
};

struct anonymous_14
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_12
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_0
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_17
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_8
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_11
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_10
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_9
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_13
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_15
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_8 _kill;
  // _timer
  struct anonymous_9 _timer;
  // _rt
  struct anonymous_10 _rt;
  // _sigchld
  struct anonymous_11 _sigchld;
  // _sigfault
  struct anonymous_12 _sigfault;
  // _sigpoll
  struct anonymous_13 _sigpoll;
  // _sigsys
  struct anonymous_14 _sigsys;
};

struct anonymous_16
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_15 _sifields;
};

union anonymous
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_16 *, void *);
};

union anonymous_1
{
  // _pad
  signed int _pad[12l];
  // _tid
  signed int _tid;
  // _sigev_thread
  struct anonymous_19 _sigev_thread;
};

union anonymous_5
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_4
{
  // __data
  struct anonymous_17 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_3
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct io_iocb_common
{
  // buf
  void *buf;
  // nbytes
  unsigned long int nbytes;
  // offset
  signed long long int offset;
  // __pad3
  signed long long int __pad3;
  // flags
  unsigned int flags;
  // resfd
  unsigned int resfd;
};

struct io_iocb_vector
{
  // vec
  struct iovec *vec;
  // nr
  signed int nr;
  // offset
  signed long long int offset;
};

struct io_iocb_poll
{
  // events
  signed int events;
  // __pad1
  signed int __pad1;
};

struct io_iocb_sockaddr
{
  // addr
  struct sockaddr *addr;
  // len
  signed int len;
};

union anonymous_7
{
  // c
  struct io_iocb_common c;
  // v
  struct io_iocb_vector v;
  // poll
  struct io_iocb_poll poll;
  // saddr
  struct io_iocb_sockaddr saddr;
};

union anonymous_6
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_2
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct iocb
{
  // data
  void *data;
  // key
  unsigned int key;
  // __pad2
  unsigned int __pad2;
  // aio_lio_opcode
  signed short int aio_lio_opcode;
  // aio_reqprio
  signed short int aio_reqprio;
  // aio_fildes
  signed int aio_fildes;
  // u
  union anonymous_7 u;
};

struct aicb
{
  // used
  signed int used;
  // buf
  char *buf;
  // iocb
  struct iocb iocb;
};

struct sigevent
{
  // sigev_value
  union sigval sigev_value;
  // sigev_signo
  signed int sigev_signo;
  // sigev_notify
  signed int sigev_notify;
  // _sigev_un
  union anonymous_1 _sigev_un;
};

struct aiocb
{
  // aio_fildes
  signed int aio_fildes;
  // aio_lio_opcode
  signed int aio_lio_opcode;
  // aio_reqprio
  signed int aio_reqprio;
  // aio_buf
  volatile void *aio_buf;
  // aio_nbytes
  unsigned long int aio_nbytes;
  // aio_sigevent
  struct sigevent aio_sigevent;
  // __next_prio
  struct aiocb *__next_prio;
  // __abs_prio
  signed int __abs_prio;
  // __policy
  signed int __policy;
  // __error_code
  signed int __error_code;
  // __return_value
  signed long int __return_value;
  // aio_offset
  signed long int aio_offset;
  // __pad
  char __pad[0l];
  // __glibc_reserved
  char __glibc_reserved[32l];
};

struct list_head
{
  // next
  struct list_head *next;
  // prev
  struct list_head *prev;
};

struct sanlk_disk
{
  // path
  char path[1024l];
  // offset
  unsigned long int offset;
  // pad1
  unsigned int pad1;
  // pad2
  unsigned int pad2;
};

struct sanlk_resource
{
  // lockspace_name
  char lockspace_name[48l];
  // name
  char name[48l];
  // lver
  unsigned long int lver;
  // data64
  unsigned long int data64;
  // data32
  unsigned int data32;
  // unused
  unsigned int unused;
  // flags
  unsigned int flags;
  // num_disks
  unsigned int num_disks;
  // disks
  struct sanlk_disk disks[0l];
};

struct token
{
  // acquire_lver
  unsigned long int acquire_lver;
  // acquire_data64
  unsigned long int acquire_data64;
  // acquire_data32
  unsigned int acquire_data32;
  // acquire_flags
  unsigned int acquire_flags;
  // host_id
  unsigned long int host_id;
  // host_generation
  unsigned long int host_generation;
  // list
  struct list_head list;
  // resource
  struct resource *resource;
  // pid
  signed int pid;
  // flags
  unsigned int flags;
  // token_id
  unsigned int token_id;
  // shared_count
  signed int shared_count;
  // shared_bitmap
  char shared_bitmap[256l];
  // disks
  struct sync_disk *disks;
  // r
  struct sanlk_resource r;
};

struct client
{
  // used
  signed int used;
  // fd
  signed int fd;
  // pid
  signed int pid;
  // cmd_active
  signed int cmd_active;
  // cmd_last
  signed int cmd_last;
  // pid_dead
  signed int pid_dead;
  // suspend
  signed int suspend;
  // need_free
  signed int need_free;
  // kill_count
  signed int kill_count;
  // restricted
  unsigned int restricted;
  // kill_last
  unsigned long int kill_last;
  // owner_name
  char owner_name[49l];
  // mutex
  union anonymous_3 mutex;
  // workfn
  void *workfn;
  // deadfn
  void *deadfn;
  // tokens
  struct token *tokens[8l];
};

struct sm_header
{
  // magic
  unsigned int magic;
  // version
  unsigned int version;
  // cmd
  unsigned int cmd;
  // cmd_flags
  unsigned int cmd_flags;
  // length
  unsigned int length;
  // seq
  unsigned int seq;
  // data
  unsigned int data;
  // data2
  unsigned int data2;
};

struct cmd_args
{
  // list
  struct list_head list;
  // ci_in
  signed int ci_in;
  // ci_target
  signed int ci_target;
  // cl_fd
  signed int cl_fd;
  // cl_pid
  signed int cl_pid;
  // header
  struct sm_header header;
};

struct sanlk_lockspace
{
  // name
  char name[48l];
  // host_id
  unsigned long int host_id;
  // flags
  unsigned int flags;
  // host_id_disk
  struct sanlk_disk host_id_disk;
};

struct command_line
{
  // type
  signed int type;
  // action
  signed int action;
  // debug
  signed int debug;
  // debug_renew
  signed int debug_renew;
  // quiet_fail
  signed int quiet_fail;
  // use_watchdog
  signed int use_watchdog;
  // high_priority
  signed int high_priority;
  // max_worker_threads
  signed int max_worker_threads;
  // aio_arg
  signed int aio_arg;
  // io_timeout_arg
  signed int io_timeout_arg;
  // uid
  signed int uid;
  // gid
  signed int gid;
  // pid
  signed int pid;
  // sort_arg
  char sort_arg;
  // local_host_id
  unsigned long int local_host_id;
  // local_host_generation
  unsigned long int local_host_generation;
  // num_hosts
  signed int num_hosts;
  // max_hosts
  signed int max_hosts;
  // res_count
  signed int res_count;
  // sh_retries
  signed int sh_retries;
  // force_mode
  unsigned int force_mode;
  // our_host_name
  char our_host_name[49l];
  // dump_path
  char *dump_path;
  // lockspace
  struct sanlk_lockspace lockspace;
  // res_args
  struct sanlk_resource *res_args[8l];
};

struct entry
{
  // level
  signed int level;
  // str
  char str[512l];
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct host_status
{
  // first_check
  unsigned long int first_check;
  // last_check
  unsigned long int last_check;
  // last_live
  unsigned long int last_live;
  // last_req
  unsigned long int last_req;
  // owner_id
  unsigned long int owner_id;
  // owner_generation
  unsigned long int owner_generation;
  // timestamp
  unsigned long int timestamp;
  // set_bit_time
  unsigned long int set_bit_time;
};

struct io_event
{
  // data
  void *data;
  // obj
  struct iocb *obj;
  // res
  unsigned long int res;
  // res2
  unsigned long int res2;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct leader_record
{
  // magic
  unsigned int magic;
  // version
  unsigned int version;
  // flags
  unsigned int flags;
  // sector_size
  unsigned int sector_size;
  // num_hosts
  unsigned long int num_hosts;
  // max_hosts
  unsigned long int max_hosts;
  // owner_id
  unsigned long int owner_id;
  // owner_generation
  unsigned long int owner_generation;
  // lver
  unsigned long int lver;
  // space_name
  char space_name[48l];
  // resource_name
  char resource_name[48l];
  // timestamp
  unsigned long int timestamp;
  // unused1
  unsigned long int unused1;
  // checksum
  unsigned int checksum;
  // unused2
  unsigned int unused2;
  // write_id
  unsigned long int write_id;
  // write_generation
  unsigned long int write_generation;
  // write_timestamp
  unsigned long int write_timestamp;
};

struct lease_status
{
  // corrupt_result
  signed int corrupt_result;
  // acquire_last_result
  signed int acquire_last_result;
  // renewal_last_result
  signed int renewal_last_result;
  // acquire_last_attempt
  unsigned long int acquire_last_attempt;
  // acquire_last_success
  unsigned long int acquire_last_success;
  // renewal_last_attempt
  unsigned long int renewal_last_attempt;
  // renewal_last_success
  unsigned long int renewal_last_success;
  // renewal_read_count
  unsigned int renewal_read_count;
  // renewal_read_check
  unsigned int renewal_read_check;
  // renewal_read_buf
  char *renewal_read_buf;
};

struct mode_block
{
  // flags
  unsigned int flags;
  // generation
  unsigned long int generation;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct paxos_dblock
{
  // mbal
  unsigned long int mbal;
  // bal
  unsigned long int bal;
  // inp
  unsigned long int inp;
  // inp2
  unsigned long int inp2;
  // inp3
  unsigned long int inp3;
  // lver
  unsigned long int lver;
  // checksum
  unsigned int checksum;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct random_data
{
  // fptr
  signed int *fptr;
  // rptr
  signed int *rptr;
  // state
  signed int *state;
  // rand_type
  signed int rand_type;
  // rand_deg
  signed int rand_deg;
  // rand_sep
  signed int rand_sep;
  // end_ptr
  signed int *end_ptr;
};

struct request_record
{
  // magic
  unsigned int magic;
  // version
  unsigned int version;
  // lver
  unsigned long int lver;
  // force_mode
  unsigned int force_mode;
};

struct resource
{
  // list
  struct list_head list;
  // tokens
  struct list_head tokens;
  // host_id
  unsigned long int host_id;
  // host_generation
  unsigned long int host_generation;
  // pid
  signed int pid;
  // flags
  unsigned int flags;
  // release_token_id
  unsigned int release_token_id;
  // leader
  struct leader_record leader;
  // r
  struct sanlk_resource r;
};

struct sanlk_options
{
  // owner_name
  char owner_name[48l];
  // flags
  unsigned int flags;
  // len
  unsigned int len;
  // str
  char str[0l];
};

struct sanlk_state
{
  // type
  unsigned int type;
  // flags
  unsigned int flags;
  // data32
  unsigned int data32;
  // data64
  unsigned long int data64;
  // name
  char name[48l];
  // str_len
  unsigned int str_len;
  // str
  char str[0l];
};

struct sched_param
{
  // __sched_priority
  signed int __sched_priority;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous __sigaction_handler;
  // sa_mask
  struct anonymous_0 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct sync_disk
{
  // path
  char path[1024l];
  // offset
  unsigned long int offset;
  // sector_size
  unsigned int sector_size;
  // fd
  signed int fd;
};

struct space
{
  // list
  struct list_head list;
  // space_name
  char space_name[48l];
  // space_id
  unsigned int space_id;
  // host_id
  unsigned long int host_id;
  // host_generation
  unsigned long int host_generation;
  // host_id_disk
  struct sync_disk host_id_disk;
  // align_size
  signed int align_size;
  // space_dead
  signed int space_dead;
  // killing_pids
  signed int killing_pids;
  // external_remove
  signed int external_remove;
  // thread_stop
  signed int thread_stop;
  // wd_fd
  signed int wd_fd;
  // thread
  unsigned long int thread;
  // mutex
  union anonymous_3 mutex;
  // lease_status
  struct lease_status lease_status;
  // host_status
  struct host_status host_status[2000l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct task
{
  // name
  char name[49l];
  // io_timeout_seconds
  signed int io_timeout_seconds;
  // id_renewal_seconds
  signed int id_renewal_seconds;
  // id_renewal_fail_seconds
  signed int id_renewal_fail_seconds;
  // id_renewal_warn_seconds
  signed int id_renewal_warn_seconds;
  // host_dead_seconds
  signed int host_dead_seconds;
  // request_finish_seconds
  signed int request_finish_seconds;
  // kill_count_term
  signed int kill_count_term;
  // kill_count_max
  signed int kill_count_max;
  // io_count
  unsigned int io_count;
  // to_count
  unsigned int to_count;
  // use_aio
  signed int use_aio;
  // cb_size
  signed int cb_size;
  // iobuf
  char *iobuf;
  // aio_ctx
  struct io_context *aio_ctx;
  // read_iobuf_timeout_aicb
  struct aicb *read_iobuf_timeout_aicb;
  // callbacks
  struct aicb *callbacks;
};

struct thread_pool
{
  // num_workers
  signed int num_workers;
  // max_workers
  signed int max_workers;
  // free_workers
  signed int free_workers;
  // quit
  signed int quit;
  // work_data
  struct list_head work_data;
  // mutex
  union anonymous_3 mutex;
  // cond
  union anonymous_4 cond;
  // quit_wait
  union anonymous_4 quit_wait;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct ucred
{
  // pid
  signed int pid;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
};

struct utsname
{
  // sysname
  char sysname[65l];
  // nodename
  char nodename[65l];
  // release
  char release[65l];
  // version
  char version[65l];
  // machine
  char machine[65l];
  // domainname
  char domainname[65l];
};

struct wdmd_header
{
  // magic
  unsigned int magic;
  // cmd
  unsigned int cmd;
  // len
  unsigned int len;
  // flags
  unsigned int flags;
  // test_interval
  unsigned int test_interval;
  // fire_timeout
  unsigned int fire_timeout;
  // last_keepalive
  unsigned long int last_keepalive;
  // renewal_time
  unsigned long int renewal_time;
  // expire_time
  unsigned long int expire_time;
  // name
  char name[128l];
};


// client
// file sanlock_internal.h line 509
struct client *client;
// client_maxi
// file main.c line 76
static signed int client_maxi;
// client_size
// file main.c line 77
static signed int client_size = 0;
// cmd_argc
// file main.c line 80
static signed int cmd_argc;
// cmd_argv
// file main.c line 81
static char **cmd_argv;
// com
// file sanlock_internal.h line 551
struct command_line com;
// command
// file main.c line 79
static char command[4096l];
// crc32c_table
// file crc32c.c line 22
static const unsigned int crc32c_table[256l] = { (const unsigned int)0x00000000L, (const unsigned int)0xF26B8303L, (const unsigned int)0xE13B70F7L, (const unsigned int)0x1350F3F4L, (const unsigned int)0xC79A971FL, (const unsigned int)0x35F1141CL, (const unsigned int)0x26A1E7E8L, (const unsigned int)0xD4CA64EBL, (const unsigned int)0x8AD958CFL, (const unsigned int)0x78B2DBCCL, (const unsigned int)0x6BE22838L, (const unsigned int)0x9989AB3BL, (const unsigned int)0x4D43CFD0L, (const unsigned int)0xBF284CD3L, (const unsigned int)0xAC78BF27L, (const unsigned int)0x5E133C24L, (const unsigned int)0x105EC76FL, (const unsigned int)0xE235446CL, (const unsigned int)0xF165B798L, (const unsigned int)0x030E349BL, (const unsigned int)0xD7C45070L, (const unsigned int)0x25AFD373L, (const unsigned int)0x36FF2087L, (const unsigned int)0xC494A384L, (const unsigned int)0x9A879FA0L, (const unsigned int)0x68EC1CA3L, (const unsigned int)0x7BBCEF57L, (const unsigned int)0x89D76C54L, (const unsigned int)0x5D1D08BFL, (const unsigned int)0xAF768BBCL, (const unsigned int)0xBC267848L, (const unsigned int)0x4E4DFB4BL, (const unsigned int)0x20BD8EDEL, (const unsigned int)0xD2D60DDDL, (const unsigned int)0xC186FE29L, (const unsigned int)0x33ED7D2AL, (const unsigned int)0xE72719C1L, (const unsigned int)0x154C9AC2L, (const unsigned int)0x061C6936L, (const unsigned int)0xF477EA35L, (const unsigned int)0xAA64D611L, (const unsigned int)0x580F5512L, (const unsigned int)0x4B5FA6E6L, (const unsigned int)0xB93425E5L, (const unsigned int)0x6DFE410EL, (const unsigned int)0x9F95C20DL, (const unsigned int)0x8CC531F9L, (const unsigned int)0x7EAEB2FAL, (const unsigned int)0x30E349B1L, (const unsigned int)0xC288CAB2L, (const unsigned int)0xD1D83946L, (const unsigned int)0x23B3BA45L, (const unsigned int)0xF779DEAEL, (const unsigned int)0x05125DADL, (const unsigned int)0x1642AE59L, (const unsigned int)0xE4292D5AL, (const unsigned int)0xBA3A117EL, (const unsigned int)0x4851927DL, (const unsigned int)0x5B016189L, (const unsigned int)0xA96AE28AL, (const unsigned int)0x7DA08661L, (const unsigned int)0x8FCB0562L, (const unsigned int)0x9C9BF696L, (const unsigned int)0x6EF07595L, (const unsigned int)0x417B1DBCL, (const unsigned int)0xB3109EBFL, (const unsigned int)0xA0406D4BL, (const unsigned int)0x522BEE48L, (const unsigned int)0x86E18AA3L, (const unsigned int)0x748A09A0L, (const unsigned int)0x67DAFA54L, (const unsigned int)0x95B17957L, (const unsigned int)0xCBA24573L, (const unsigned int)0x39C9C670L, (const unsigned int)0x2A993584L, (const unsigned int)0xD8F2B687L, (const unsigned int)0x0C38D26CL, (const unsigned int)0xFE53516FL, (const unsigned int)0xED03A29BL, (const unsigned int)0x1F682198L, (const unsigned int)0x5125DAD3L, (const unsigned int)0xA34E59D0L, (const unsigned int)0xB01EAA24L, (const unsigned int)0x42752927L, (const unsigned int)0x96BF4DCCL, (const unsigned int)0x64D4CECFL, (const unsigned int)0x77843D3BL, (const unsigned int)0x85EFBE38L, (const unsigned int)0xDBFC821CL, (const unsigned int)0x2997011FL, (const unsigned int)0x3AC7F2EBL, (const unsigned int)0xC8AC71E8L, (const unsigned int)0x1C661503L, (const unsigned int)0xEE0D9600L, (const unsigned int)0xFD5D65F4L, (const unsigned int)0x0F36E6F7L, (const unsigned int)0x61C69362L, (const unsigned int)0x93AD1061L, (const unsigned int)0x80FDE395L, (const unsigned int)0x72966096L, (const unsigned int)0xA65C047DL, (const unsigned int)0x5437877EL, (const unsigned int)0x4767748AL, (const unsigned int)0xB50CF789L, (const unsigned int)0xEB1FCBADL, (const unsigned int)0x197448AEL, (const unsigned int)0x0A24BB5AL, (const unsigned int)0xF84F3859L, (const unsigned int)0x2C855CB2L, (const unsigned int)0xDEEEDFB1L, (const unsigned int)0xCDBE2C45L, (const unsigned int)0x3FD5AF46L, (const unsigned int)0x7198540DL, (const unsigned int)0x83F3D70EL, (const unsigned int)0x90A324FAL, (const unsigned int)0x62C8A7F9L, (const unsigned int)0xB602C312L, (const unsigned int)0x44694011L, (const unsigned int)0x5739B3E5L, (const unsigned int)0xA55230E6L, (const unsigned int)0xFB410CC2L, (const unsigned int)0x092A8FC1L, (const unsigned int)0x1A7A7C35L, (const unsigned int)0xE811FF36L, (const unsigned int)0x3CDB9BDDL, (const unsigned int)0xCEB018DEL, (const unsigned int)0xDDE0EB2AL, (const unsigned int)0x2F8B6829L, (const unsigned int)0x82F63B78L, (const unsigned int)0x709DB87BL, (const unsigned int)0x63CD4B8FL, (const unsigned int)0x91A6C88CL, (const unsigned int)0x456CAC67L, (const unsigned int)0xB7072F64L, (const unsigned int)0xA457DC90L, (const unsigned int)0x563C5F93L, (const unsigned int)0x082F63B7L, (const unsigned int)0xFA44E0B4L, (const unsigned int)0xE9141340L, (const unsigned int)0x1B7F9043L, (const unsigned int)0xCFB5F4A8L, (const unsigned int)0x3DDE77ABL, (const unsigned int)0x2E8E845FL, (const unsigned int)0xDCE5075CL, (const unsigned int)0x92A8FC17L, (const unsigned int)0x60C37F14L, (const unsigned int)0x73938CE0L, (const unsigned int)0x81F80FE3L, (const unsigned int)0x55326B08L, (const unsigned int)0xA759E80BL, (const unsigned int)0xB4091BFFL, (const unsigned int)0x466298FCL, (const unsigned int)0x1871A4D8L, (const unsigned int)0xEA1A27DBL, (const unsigned int)0xF94AD42FL, (const unsigned int)0x0B21572CL, (const unsigned int)0xDFEB33C7L, (const unsigned int)0x2D80B0C4L, (const unsigned int)0x3ED04330L, (const unsigned int)0xCCBBC033L, (const unsigned int)0xA24BB5A6L, (const unsigned int)0x502036A5L, (const unsigned int)0x4370C551L, (const unsigned int)0xB11B4652L, (const unsigned int)0x65D122B9L, (const unsigned int)0x97BAA1BAL, (const unsigned int)0x84EA524EL, (const unsigned int)0x7681D14DL, (const unsigned int)0x2892ED69L, (const unsigned int)0xDAF96E6AL, (const unsigned int)0xC9A99D9EL, (const unsigned int)0x3BC21E9DL, (const unsigned int)0xEF087A76L, (const unsigned int)0x1D63F975L, (const unsigned int)0x0E330A81L, (const unsigned int)0xFC588982L, (const unsigned int)0xB21572C9L, (const unsigned int)0x407EF1CAL, (const unsigned int)0x532E023EL, (const unsigned int)0xA145813DL, (const unsigned int)0x758FE5D6L, (const unsigned int)0x87E466D5L, (const unsigned int)0x94B49521L, (const unsigned int)0x66DF1622L, (const unsigned int)0x38CC2A06L, (const unsigned int)0xCAA7A905L, (const unsigned int)0xD9F75AF1L, (const unsigned int)0x2B9CD9F2L, (const unsigned int)0xFF56BD19L, (const unsigned int)0x0D3D3E1AL, (const unsigned int)0x1E6DCDEEL, (const unsigned int)0xEC064EEDL, (const unsigned int)0xC38D26C4L, (const unsigned int)0x31E6A5C7L, (const unsigned int)0x22B65633L, (const unsigned int)0xD0DDD530L, (const unsigned int)0x0417B1DBL, (const unsigned int)0xF67C32D8L, (const unsigned int)0xE52CC12CL, (const unsigned int)0x1747422FL, (const unsigned int)0x49547E0BL, (const unsigned int)0xBB3FFD08L, (const unsigned int)0xA86F0EFCL, (const unsigned int)0x5A048DFFL, (const unsigned int)0x8ECEE914L, (const unsigned int)0x7CA56A17L, (const unsigned int)0x6FF599E3L, (const unsigned int)0x9D9E1AE0L, (const unsigned int)0xD3D3E1ABL, (const unsigned int)0x21B862A8L, (const unsigned int)0x32E8915CL, (const unsigned int)0xC083125FL, (const unsigned int)0x144976B4L, (const unsigned int)0xE622F5B7L, (const unsigned int)0xF5720643L, (const unsigned int)0x07198540L, (const unsigned int)0x590AB964L, (const unsigned int)0xAB613A67L, (const unsigned int)0xB831C993L, (const unsigned int)0x4A5A4A90L, (const unsigned int)0x9E902E7BL, (const unsigned int)0x6CFBAD78L, (const unsigned int)0x7FAB5E8CL, (const unsigned int)0x8DC0DD8FL, (const unsigned int)0xE330A81AL, (const unsigned int)0x115B2B19L, (const unsigned int)0x020BD8EDL, (const unsigned int)0xF0605BEEL, (const unsigned int)0x24AA3F05L, (const unsigned int)0xD6C1BC06L, (const unsigned int)0xC5914FF2L, (const unsigned int)0x37FACCF1L, (const unsigned int)0x69E9F0D5L, (const unsigned int)0x9B8273D6L, (const unsigned int)0x88D28022L, (const unsigned int)0x7AB90321L, (const unsigned int)0xAE7367CAL, (const unsigned int)0x5C18E4C9L, (const unsigned int)0x4F48173DL, (const unsigned int)0xBD23943EL, (const unsigned int)0xF36E6F75L, (const unsigned int)0x0105EC76L, (const unsigned int)0x12551F82L, (const unsigned int)0xE03E9C81L, (const unsigned int)0x34F4F86AL, (const unsigned int)0xC69F7B69L, (const unsigned int)0xD5CF889DL, (const unsigned int)0x27A40B9EL, (const unsigned int)0x79B737BAL, (const unsigned int)0x8BDCB4B9L, (const unsigned int)0x988C474DL, (const unsigned int)0x6AE7C44EL, (const unsigned int)0xBE2DA0A5L, (const unsigned int)0x4C4623A6L, (const unsigned int)0x5F16D052L, (const unsigned int)0xAD7D5351L };
// crc32c_table_link1
// file crc32c.c line 22
static const unsigned int crc32c_table_link1[256l] = { (const unsigned int)0x00000000L, (const unsigned int)0xF26B8303L, (const unsigned int)0xE13B70F7L, (const unsigned int)0x1350F3F4L, (const unsigned int)0xC79A971FL, (const unsigned int)0x35F1141CL, (const unsigned int)0x26A1E7E8L, (const unsigned int)0xD4CA64EBL, (const unsigned int)0x8AD958CFL, (const unsigned int)0x78B2DBCCL, (const unsigned int)0x6BE22838L, (const unsigned int)0x9989AB3BL, (const unsigned int)0x4D43CFD0L, (const unsigned int)0xBF284CD3L, (const unsigned int)0xAC78BF27L, (const unsigned int)0x5E133C24L, (const unsigned int)0x105EC76FL, (const unsigned int)0xE235446CL, (const unsigned int)0xF165B798L, (const unsigned int)0x030E349BL, (const unsigned int)0xD7C45070L, (const unsigned int)0x25AFD373L, (const unsigned int)0x36FF2087L, (const unsigned int)0xC494A384L, (const unsigned int)0x9A879FA0L, (const unsigned int)0x68EC1CA3L, (const unsigned int)0x7BBCEF57L, (const unsigned int)0x89D76C54L, (const unsigned int)0x5D1D08BFL, (const unsigned int)0xAF768BBCL, (const unsigned int)0xBC267848L, (const unsigned int)0x4E4DFB4BL, (const unsigned int)0x20BD8EDEL, (const unsigned int)0xD2D60DDDL, (const unsigned int)0xC186FE29L, (const unsigned int)0x33ED7D2AL, (const unsigned int)0xE72719C1L, (const unsigned int)0x154C9AC2L, (const unsigned int)0x061C6936L, (const unsigned int)0xF477EA35L, (const unsigned int)0xAA64D611L, (const unsigned int)0x580F5512L, (const unsigned int)0x4B5FA6E6L, (const unsigned int)0xB93425E5L, (const unsigned int)0x6DFE410EL, (const unsigned int)0x9F95C20DL, (const unsigned int)0x8CC531F9L, (const unsigned int)0x7EAEB2FAL, (const unsigned int)0x30E349B1L, (const unsigned int)0xC288CAB2L, (const unsigned int)0xD1D83946L, (const unsigned int)0x23B3BA45L, (const unsigned int)0xF779DEAEL, (const unsigned int)0x05125DADL, (const unsigned int)0x1642AE59L, (const unsigned int)0xE4292D5AL, (const unsigned int)0xBA3A117EL, (const unsigned int)0x4851927DL, (const unsigned int)0x5B016189L, (const unsigned int)0xA96AE28AL, (const unsigned int)0x7DA08661L, (const unsigned int)0x8FCB0562L, (const unsigned int)0x9C9BF696L, (const unsigned int)0x6EF07595L, (const unsigned int)0x417B1DBCL, (const unsigned int)0xB3109EBFL, (const unsigned int)0xA0406D4BL, (const unsigned int)0x522BEE48L, (const unsigned int)0x86E18AA3L, (const unsigned int)0x748A09A0L, (const unsigned int)0x67DAFA54L, (const unsigned int)0x95B17957L, (const unsigned int)0xCBA24573L, (const unsigned int)0x39C9C670L, (const unsigned int)0x2A993584L, (const unsigned int)0xD8F2B687L, (const unsigned int)0x0C38D26CL, (const unsigned int)0xFE53516FL, (const unsigned int)0xED03A29BL, (const unsigned int)0x1F682198L, (const unsigned int)0x5125DAD3L, (const unsigned int)0xA34E59D0L, (const unsigned int)0xB01EAA24L, (const unsigned int)0x42752927L, (const unsigned int)0x96BF4DCCL, (const unsigned int)0x64D4CECFL, (const unsigned int)0x77843D3BL, (const unsigned int)0x85EFBE38L, (const unsigned int)0xDBFC821CL, (const unsigned int)0x2997011FL, (const unsigned int)0x3AC7F2EBL, (const unsigned int)0xC8AC71E8L, (const unsigned int)0x1C661503L, (const unsigned int)0xEE0D9600L, (const unsigned int)0xFD5D65F4L, (const unsigned int)0x0F36E6F7L, (const unsigned int)0x61C69362L, (const unsigned int)0x93AD1061L, (const unsigned int)0x80FDE395L, (const unsigned int)0x72966096L, (const unsigned int)0xA65C047DL, (const unsigned int)0x5437877EL, (const unsigned int)0x4767748AL, (const unsigned int)0xB50CF789L, (const unsigned int)0xEB1FCBADL, (const unsigned int)0x197448AEL, (const unsigned int)0x0A24BB5AL, (const unsigned int)0xF84F3859L, (const unsigned int)0x2C855CB2L, (const unsigned int)0xDEEEDFB1L, (const unsigned int)0xCDBE2C45L, (const unsigned int)0x3FD5AF46L, (const unsigned int)0x7198540DL, (const unsigned int)0x83F3D70EL, (const unsigned int)0x90A324FAL, (const unsigned int)0x62C8A7F9L, (const unsigned int)0xB602C312L, (const unsigned int)0x44694011L, (const unsigned int)0x5739B3E5L, (const unsigned int)0xA55230E6L, (const unsigned int)0xFB410CC2L, (const unsigned int)0x092A8FC1L, (const unsigned int)0x1A7A7C35L, (const unsigned int)0xE811FF36L, (const unsigned int)0x3CDB9BDDL, (const unsigned int)0xCEB018DEL, (const unsigned int)0xDDE0EB2AL, (const unsigned int)0x2F8B6829L, (const unsigned int)0x82F63B78L, (const unsigned int)0x709DB87BL, (const unsigned int)0x63CD4B8FL, (const unsigned int)0x91A6C88CL, (const unsigned int)0x456CAC67L, (const unsigned int)0xB7072F64L, (const unsigned int)0xA457DC90L, (const unsigned int)0x563C5F93L, (const unsigned int)0x082F63B7L, (const unsigned int)0xFA44E0B4L, (const unsigned int)0xE9141340L, (const unsigned int)0x1B7F9043L, (const unsigned int)0xCFB5F4A8L, (const unsigned int)0x3DDE77ABL, (const unsigned int)0x2E8E845FL, (const unsigned int)0xDCE5075CL, (const unsigned int)0x92A8FC17L, (const unsigned int)0x60C37F14L, (const unsigned int)0x73938CE0L, (const unsigned int)0x81F80FE3L, (const unsigned int)0x55326B08L, (const unsigned int)0xA759E80BL, (const unsigned int)0xB4091BFFL, (const unsigned int)0x466298FCL, (const unsigned int)0x1871A4D8L, (const unsigned int)0xEA1A27DBL, (const unsigned int)0xF94AD42FL, (const unsigned int)0x0B21572CL, (const unsigned int)0xDFEB33C7L, (const unsigned int)0x2D80B0C4L, (const unsigned int)0x3ED04330L, (const unsigned int)0xCCBBC033L, (const unsigned int)0xA24BB5A6L, (const unsigned int)0x502036A5L, (const unsigned int)0x4370C551L, (const unsigned int)0xB11B4652L, (const unsigned int)0x65D122B9L, (const unsigned int)0x97BAA1BAL, (const unsigned int)0x84EA524EL, (const unsigned int)0x7681D14DL, (const unsigned int)0x2892ED69L, (const unsigned int)0xDAF96E6AL, (const unsigned int)0xC9A99D9EL, (const unsigned int)0x3BC21E9DL, (const unsigned int)0xEF087A76L, (const unsigned int)0x1D63F975L, (const unsigned int)0x0E330A81L, (const unsigned int)0xFC588982L, (const unsigned int)0xB21572C9L, (const unsigned int)0x407EF1CAL, (const unsigned int)0x532E023EL, (const unsigned int)0xA145813DL, (const unsigned int)0x758FE5D6L, (const unsigned int)0x87E466D5L, (const unsigned int)0x94B49521L, (const unsigned int)0x66DF1622L, (const unsigned int)0x38CC2A06L, (const unsigned int)0xCAA7A905L, (const unsigned int)0xD9F75AF1L, (const unsigned int)0x2B9CD9F2L, (const unsigned int)0xFF56BD19L, (const unsigned int)0x0D3D3E1AL, (const unsigned int)0x1E6DCDEEL, (const unsigned int)0xEC064EEDL, (const unsigned int)0xC38D26C4L, (const unsigned int)0x31E6A5C7L, (const unsigned int)0x22B65633L, (const unsigned int)0xD0DDD530L, (const unsigned int)0x0417B1DBL, (const unsigned int)0xF67C32D8L, (const unsigned int)0xE52CC12CL, (const unsigned int)0x1747422FL, (const unsigned int)0x49547E0BL, (const unsigned int)0xBB3FFD08L, (const unsigned int)0xA86F0EFCL, (const unsigned int)0x5A048DFFL, (const unsigned int)0x8ECEE914L, (const unsigned int)0x7CA56A17L, (const unsigned int)0x6FF599E3L, (const unsigned int)0x9D9E1AE0L, (const unsigned int)0xD3D3E1ABL, (const unsigned int)0x21B862A8L, (const unsigned int)0x32E8915CL, (const unsigned int)0xC083125FL, (const unsigned int)0x144976B4L, (const unsigned int)0xE622F5B7L, (const unsigned int)0xF5720643L, (const unsigned int)0x07198540L, (const unsigned int)0x590AB964L, (const unsigned int)0xAB613A67L, (const unsigned int)0xB831C993L, (const unsigned int)0x4A5A4A90L, (const unsigned int)0x9E902E7BL, (const unsigned int)0x6CFBAD78L, (const unsigned int)0x7FAB5E8CL, (const unsigned int)0x8DC0DD8FL, (const unsigned int)0xE330A81AL, (const unsigned int)0x115B2B19L, (const unsigned int)0x020BD8EDL, (const unsigned int)0xF0605BEEL, (const unsigned int)0x24AA3F05L, (const unsigned int)0xD6C1BC06L, (const unsigned int)0xC5914FF2L, (const unsigned int)0x37FACCF1L, (const unsigned int)0x69E9F0D5L, (const unsigned int)0x9B8273D6L, (const unsigned int)0x88D28022L, (const unsigned int)0x7AB90321L, (const unsigned int)0xAE7367CAL, (const unsigned int)0x5C18E4C9L, (const unsigned int)0x4F48173DL, (const unsigned int)0xBD23943EL, (const unsigned int)0xF36E6F75L, (const unsigned int)0x0105EC76L, (const unsigned int)0x12551F82L, (const unsigned int)0xE03E9C81L, (const unsigned int)0x34F4F86AL, (const unsigned int)0xC69F7B69L, (const unsigned int)0xD5CF889DL, (const unsigned int)0x27A40B9EL, (const unsigned int)0x79B737BAL, (const unsigned int)0x8BDCB4B9L, (const unsigned int)0x988C474DL, (const unsigned int)0x6AE7C44EL, (const unsigned int)0xBE2DA0A5L, (const unsigned int)0x4C4623A6L, (const unsigned int)0x5F16D052L, (const unsigned int)0xAD7D5351L };
// daemon_wdmd_con
// file watchdog.c line 42
static signed int daemon_wdmd_con;
// external_shutdown
// file sanlock_internal.h line 585
signed int external_shutdown;
// log_cond
// file log.c line 34
static union anonymous_4 log_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// log_dropped
// file log.c line 50
static unsigned int log_dropped;
// log_dump
// file log.c line 36
static char log_dump[1048576l];
// log_ents
// file log.c line 46
static struct entry *log_ents;
// log_head_ent
// file log.c line 48
static unsigned int log_head_ent;
// log_logfile_priority
// file main.c line 71
signed int log_logfile_priority = 4;
// log_mutex
// file log.c line 33
static union anonymous_3 log_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// log_num_ents
// file log.c line 47
static unsigned int log_num_ents = (unsigned int)4096;
// log_pending_ents
// file log.c line 51
static unsigned int log_pending_ents;
// log_point
// file log.c line 37
static unsigned int log_point;
// log_stderr_priority
// file main.c line 73
signed int log_stderr_priority = -1;
// log_str
// file log.c line 29
static char log_str[512l];
// log_syslog_priority
// file main.c line 72
signed int log_syslog_priority = 3;
// log_tail_ent
// file log.c line 49
static unsigned int log_tail_ent;
// log_thread_done
// file log.c line 52
static unsigned int log_thread_done;
// log_wrap
// file log.c line 38
static unsigned int log_wrap;
// logfile_fp
// file log.c line 55
static struct _IO_FILE *logfile_fp;
// logfile_path
// file log.c line 54
static char logfile_path[4096l];
// main_task
// file sanlock_internal.h line 483
struct task main_task;
// our_host_name_global
// file sanlock_internal.h line 586
char our_host_name_global[49l];
// pollfd
// file main.c line 78
static struct pollfd *pollfd;
// pool
// file main.c line 82
static struct thread_pool pool;
// rand_data
// file main.c line 83
static struct random_data rand_data;
// rand_mutex
// file main.c line 85
static union anonymous_3 rand_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// rand_state
// file main.c line 84
static char rand_state[32l];
// resource_cond
// file resource.c line 48
static union anonymous_4 resource_cond;
// resource_mutex
// file resource.c line 47
static union anonymous_3 resource_mutex;
// resource_pt
// file resource.c line 41
static unsigned long int resource_pt;
// resource_thread_stop
// file resource.c line 42
static signed int resource_thread_stop;
// resource_thread_work
// file resource.c line 43
static signed int resource_thread_work;
// resources_add
// file resource.c line 45
static struct list_head resources_add;
// resources_held
// file resource.c line 44
static struct list_head resources_held;
// resources_rem
// file resource.c line 46
static struct list_head resources_rem;
// send_log_dump
// file cmd.c line 1605
static char send_log_dump[1048576l];
// sort_bufs
// file client_cmd.c line 142
static char *sort_bufs[1024l];
// sort_count
// file client_cmd.c line 143
static signed int sort_count;
// sort_done
// file client_cmd.c line 144
static signed int sort_done;
// space_id_counter
// file lockspace.c line 37
static unsigned int space_id_counter = (unsigned int)1;
// spaces
// file sanlock_internal.h line 588
struct list_head spaces;
// spaces_add
// file sanlock_internal.h line 590
struct list_head spaces_add;
// spaces_mutex
// file sanlock_internal.h line 591
union anonymous_3 spaces_mutex;
// spaces_rem
// file sanlock_internal.h line 589
struct list_head spaces_rem;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// thread_handle
// file log.c line 31
static unsigned long int thread_handle;
// token_id_counter
// file cmd.c line 57
static unsigned int token_id_counter = (unsigned int)1;

// INIT_LIST_HEAD
// file list.h line 40
static inline void INIT_LIST_HEAD(struct list_head *list)
{
  list->next = list;
  list->prev = list;
}

// INIT_LIST_HEAD_link1
// file list.h line 40
static inline void INIT_LIST_HEAD_link1(struct list_head *list_link1)
{
  list_link1->next = list_link1;
  list_link1->prev = list_link1;
}

// __list_add
// file list.h line 52
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next)
{
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
}

// __list_add_link1
// file list.h line 52
static inline void __list_add_link1(struct list_head *new_link1, struct list_head *prev_link1, struct list_head *next_link1)
{
  next_link1->prev = new_link1;
  new_link1->next = next_link1;
  new_link1->prev = prev_link1;
  prev_link1->next = new_link1;
}

// __list_add_link2
// file list.h line 52
static inline void __list_add_link2(struct list_head *new_link2, struct list_head *prev_link2, struct list_head *next_link2)
{
  next_link2->prev = new_link2;
  new_link2->next = next_link2;
  new_link2->prev = prev_link2;
  prev_link2->next = new_link2;
}

// __list_del
// file list.h line 96
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
  next->prev = prev;
  prev->next = next;
}

// __list_del_link1
// file list.h line 96
static inline void __list_del_link1(struct list_head *prev_link1, struct list_head *next_link1)
{
  next_link1->prev = prev_link1;
  prev_link1->next = next_link1;
}

// __list_del_link2
// file list.h line 96
static inline void __list_del_link2(struct list_head *prev_link2, struct list_head *next_link2)
{
  next_link2->prev = prev_link2;
  prev_link2->next = next_link2;
}

// _client_free
// file main.c line 119
static void _client_free(signed int ci)
{
  struct client *cl = &client[(signed long int)ci];
  if(cl->used == 0)
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "client_free ci %d not used", ci);

  else
    if(!(cl->pid == -1))
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "client_free ci %d live pid %d", ci, cl->pid);

    else
      if(cl->fd == -1)
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "client_free ci %d is free", ci);

      else
        if(!(cl->suspend == 0))
        {
          log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "client_free ci %d is suspended", ci);
          cl->need_free = 1;
        }

        else
        {
          if(!(cl->fd == -1))
            close(cl->fd);

          cl->used = 0;
          cl->fd = -1;
          cl->pid = -1;
          cl->cmd_active = 0;
          cl->pid_dead = 0;
          cl->suspend = 0;
          cl->need_free = 0;
          cl->kill_count = 0;
          cl->kill_last = (unsigned long int)0;
          cl->restricted = (unsigned int)0;
          memset((void *)cl->owner_name, 0, sizeof(char [49l]) /*49ul*/ );
          cl->workfn = (void *)0;
          cl->deadfn = (void *)0;
          memset((void *)cl->tokens, 0, sizeof(struct token *) /*8ul*/  * (unsigned long int)8);
          (pollfd + (signed long int)ci)->fd = -1;
          (pollfd + (signed long int)ci)->events = (signed short int)0;
        }

out:
  ;
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
}

// _leader_read_num
// file paxos_lease.c line 715
static signed int _leader_read_num(struct task *task, struct token *token, struct leader_record *leader_ret, const char *caller)
{
  struct leader_record leader;
  struct leader_record *leaders;
  signed int *leader_reps;
  signed int leaders_len;
  signed int leader_reps_len;
  signed int num_reads;
  signed int num_disks = (signed int)token->r.num_disks;
  signed int rv = 0;
  signed int d;
  signed int i;
  signed int found;
  signed int error;
  leaders_len = (signed int)((unsigned long int)num_disks * sizeof(struct leader_record) /*200ul*/ );
  leader_reps_len = (signed int)((unsigned long int)num_disks * sizeof(signed int) /*4ul*/ );
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)leaders_len);
  leaders = (struct leader_record *)return_value_malloc_1;
  if(leaders == ((struct leader_record *)NULL))
    return -12;

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)leader_reps_len);
    leader_reps = (signed int *)return_value_malloc_2;
    if(leader_reps == ((signed int *)NULL))
    {
      free((void *)leaders);
      return -12;
    }

    else
    {
      memset((void *)&leader, 0, sizeof(struct leader_record) /*200ul*/ );
      memset((void *)leaders, 0, (unsigned long int)leaders_len);
      memset((void *)leader_reps, 0, (unsigned long int)leader_reps_len);
      num_reads = 0;
      d = 0;
      for( ; !(d >= num_disks); d = d + 1)
      {
        rv=read_leader(task, &token->disks[(signed long int)d], &leaders[(signed long int)d]);
        if(rv >= 0)
        {
          rv=verify_leader_link1(token, &token->disks[(signed long int)d], &leaders[(signed long int)d], caller);
          if(rv >= 0)
          {
            num_reads = num_reads + 1;
            leader_reps[(signed long int)d] = 1;
            i = 0;
            for( ; !(i >= d); i = i + 1)
            {
              signed int return_value_leaders_match_3;
              return_value_leaders_match_3=leaders_match(&leaders[(signed long int)d], &leaders[(signed long int)i]);
              if(!(return_value_leaders_match_3 == 0))
              {
                leader_reps[(signed long int)i] = leader_reps[(signed long int)i] + 1;
                break;
              }

            }
          }

        }

      }
      signed int return_value_majority_disks_4;
      return_value_majority_disks_4=majority_disks(num_disks, num_reads);
      if(return_value_majority_disks_4 == 0)
      {
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "%s leader read error %d", caller, rv);
        error = -220;
      }

      else
      {
        found = 0;
        d = 0;
        for( ; !(d >= num_disks); d = d + 1)
        {
          signed int return_value_majority_disks_5;
          return_value_majority_disks_5=majority_disks(num_disks, leader_reps[(signed long int)d]);
          if(!(return_value_majority_disks_5 == 0))
          {
            memcpy((void *)&leader, (const void *)&leaders[(signed long int)d], sizeof(struct leader_record) /*200ul*/ );
            found = 1;
            break;
          }

        }
        if(found == 0)
        {
          log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "%s leader inconsistent", caller);
          error = -222;
        }

        else
          error = 1;
      }

    out:
      ;
      memcpy((void *)leader_ret, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );
      free((void *)leaders);
      free((void *)leader_reps);
      return error;
    }
  }
}

// _leader_read_num_link1
// file paxos_lease.c line 715
static signed int _leader_read_num_link1(struct task *task_link1, struct token *token_link1, struct leader_record *leader_ret_link1, const char *caller_link1)
{
  struct leader_record leader_link1;
  struct leader_record *leaders_link1;
  signed int *leader_reps_link1;
  signed int leaders_len_link1;
  signed int leader_reps_len_link1;
  signed int num_reads_link1;
  signed int num_disks_link1 = (signed int)token_link1->r.num_disks;
  signed int rv_link1 = 0;
  signed int d_link1;
  signed int i_link1;
  signed int found_link1;
  signed int error_link1;
  leaders_len_link1 = (signed int)((unsigned long int)num_disks_link1 * sizeof(struct leader_record) /*200ul*/ );
  leader_reps_len_link1 = (signed int)((unsigned long int)num_disks_link1 * sizeof(signed int) /*4ul*/ );
  void *return_value_malloc_1_link1;
  return_value_malloc_1_link1=malloc((unsigned long int)leaders_len_link1);
  leaders_link1 = (struct leader_record *)return_value_malloc_1_link1;
  if(leaders_link1 == ((struct leader_record *)NULL))
    return -12;

  else
  {
    void *return_value_malloc_2_link1;
    return_value_malloc_2_link1=malloc((unsigned long int)leader_reps_len_link1);
    leader_reps_link1 = (signed int *)return_value_malloc_2_link1;
    if(leader_reps_link1 == ((signed int *)NULL))
    {
      free((void *)leaders_link1);
      return -12;
    }

    else
    {
      memset((void *)&leader_link1, 0, sizeof(struct leader_record) /*200ul*/ );
      memset((void *)leaders_link1, 0, (unsigned long int)leaders_len_link1);
      memset((void *)leader_reps_link1, 0, (unsigned long int)leader_reps_len_link1);
      num_reads_link1 = 0;
      d_link1 = 0;
      for( ; !(d_link1 >= num_disks_link1); d_link1 = d_link1 + 1)
      {
        rv_link1=read_leader_link1(task_link1, &token_link1->disks[(signed long int)d_link1], &leaders_link1[(signed long int)d_link1]);
        if(rv_link1 >= 0)
        {
          rv_link1=verify_leader_link1_link1(token_link1, &token_link1->disks[(signed long int)d_link1], &leaders_link1[(signed long int)d_link1], caller_link1);
          if(rv_link1 >= 0)
          {
            num_reads_link1 = num_reads_link1 + 1;
            leader_reps_link1[(signed long int)d_link1] = 1;
            i_link1 = 0;
            for( ; !(i_link1 >= d_link1); i_link1 = i_link1 + 1)
            {
              signed int return_value_leaders_match_3_link1;
              return_value_leaders_match_3_link1=leaders_match_link1(&leaders_link1[(signed long int)d_link1], &leaders_link1[(signed long int)i_link1]);
              if(!(return_value_leaders_match_3_link1 == 0))
              {
                leader_reps_link1[(signed long int)i_link1] = leader_reps_link1[(signed long int)i_link1] + 1;
                break;
              }

            }
          }

        }

      }
      signed int return_value_majority_disks_4_link1;
      return_value_majority_disks_4_link1=majority_disks(num_disks_link1, num_reads_link1);
      if(return_value_majority_disks_4_link1 == 0)
      {
        log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "%s leader read error %d", caller_link1, rv_link1);
        error_link1 = -220;
      }

      else
      {
        found_link1 = 0;
        d_link1 = 0;
        for( ; !(d_link1 >= num_disks_link1); d_link1 = d_link1 + 1)
        {
          signed int return_value_majority_disks_5_link1;
          return_value_majority_disks_5_link1=majority_disks(num_disks_link1, leader_reps_link1[(signed long int)d_link1]);
          if(!(return_value_majority_disks_5_link1 == 0))
          {
            memcpy((void *)&leader_link1, (const void *)&leaders_link1[(signed long int)d_link1], sizeof(struct leader_record) /*200ul*/ );
            found_link1 = 1;
            break;
          }

        }
        if(found_link1 == 0)
        {
          log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "%s leader inconsistent", caller_link1);
          error_link1 = -222;
        }

        else
          error_link1 = 1;
      }

    out:
      ;
      memcpy((void *)leader_ret_link1, (const void *)&leader_link1, sizeof(struct leader_record) /*200ul*/ );
      free((void *)leaders_link1);
      free((void *)leader_reps_link1);
      return error_link1;
    }
  }
}

// _leader_read_one
// file paxos_lease.c line 691
static signed int _leader_read_one(struct task *task, struct token *token, struct leader_record *leader_ret, const char *caller)
{
  struct leader_record leader;
  signed int rv;
  memset((void *)&leader, 0, sizeof(struct leader_record) /*200ul*/ );
  rv=read_leader(task, &token->disks[(signed long int)0], &leader);
  if(!(rv >= 0))
    return rv;

  else
  {
    rv=verify_leader_link1(token, &token->disks[(signed long int)0], &leader, caller);
    memcpy((void *)leader_ret, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );
    return rv;
  }
}

// _leader_read_one_link1
// file paxos_lease.c line 691
static signed int _leader_read_one_link1(struct task *task_link1, struct token *token_link1, struct leader_record *leader_ret_link1, const char *caller_link1)
{
  struct leader_record leader_link1;
  signed int rv_link1;
  memset((void *)&leader_link1, 0, sizeof(struct leader_record) /*200ul*/ );
  rv_link1=read_leader_link1(task_link1, &token_link1->disks[(signed long int)0], &leader_link1);
  if(!(rv_link1 >= 0))
    return rv_link1;

  else
  {
    rv_link1=verify_leader_link1_link1(token_link1, &token_link1->disks[(signed long int)0], &leader_link1, caller_link1);
    memcpy((void *)leader_ret_link1, (const void *)&leader_link1, sizeof(struct leader_record) /*200ul*/ );
    return rv_link1;
  }
}

// _lease_read_num
// file paxos_lease.c line 900
static signed int _lease_read_num(struct task *task, struct token *token, struct leader_record *leader_ret, struct paxos_dblock *our_dblock, unsigned long int *max_mbal, signed int *max_q, const char *caller)
{
  struct paxos_dblock dblock_one;
  struct leader_record leader_one;
  struct leader_record *leaders;
  unsigned long int tmp_mbal = (unsigned long int)0;
  unsigned long int mbal_one;
  signed int *leader_reps;
  signed int num_disks = (signed int)token->r.num_disks;
  signed int leaders_len;
  signed int leader_reps_len;
  signed int i;
  signed int d;
  signed int rv;
  signed int found;
  signed int num_reads;
  signed int q_one;
  signed int tmp_q = -1;
  leaders_len = (signed int)((unsigned long int)num_disks * sizeof(struct leader_record) /*200ul*/ );
  leader_reps_len = (signed int)((unsigned long int)num_disks * sizeof(signed int) /*4ul*/ );
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)leaders_len);
  leaders = (struct leader_record *)return_value_malloc_1;
  if(leaders == ((struct leader_record *)NULL))
    return -12;

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)leader_reps_len);
    leader_reps = (signed int *)return_value_malloc_2;
    if(leader_reps == ((signed int *)NULL))
    {
      free((void *)leaders);
      return -12;
    }

    else
    {
      memset((void *)leaders, 0, (unsigned long int)leaders_len);
      memset((void *)leader_reps, 0, (unsigned long int)leader_reps_len);
      num_reads = 0;
      d = 0;
      for( ; !(d >= num_disks); d = d + 1)
      {
        rv=_lease_read_one(task, token, &token->disks[(signed long int)d], &leader_one, &dblock_one, &mbal_one, &q_one, caller);
        if(rv >= 0)
        {
          num_reads = num_reads + 1;
          if(tmp_mbal == 0ul || !(tmp_mbal >= mbal_one))
          {
            tmp_mbal = mbal_one;
            tmp_q = q_one;
            memcpy((void *)our_dblock, (const void *)&dblock_one, sizeof(struct paxos_dblock) /*56ul*/ );
          }

          memcpy((void *)&leaders[(signed long int)d], (const void *)&leader_one, sizeof(struct leader_record) /*200ul*/ );
          leader_reps[(signed long int)d] = 1;
          i = 0;
          for( ; !(i >= d); i = i + 1)
          {
            signed int return_value_leaders_match_3;
            return_value_leaders_match_3=leaders_match(&leaders[(signed long int)d], &leaders[(signed long int)i]);
            if(!(return_value_leaders_match_3 == 0))
            {
              leader_reps[(signed long int)i] = leader_reps[(signed long int)i] + 1;
              break;
            }

          }
        }

      }
      *max_mbal = tmp_mbal;
      *max_q = tmp_q;
      if(num_reads == 0)
      {
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "%s lease_read_num cannot read disks %d", caller, rv);
        rv = -210;
      }

      else
      {
        found = 0;
        d = 0;
        for( ; !(d >= num_disks); d = d + 1)
        {
          signed int return_value_majority_disks_4;
          return_value_majority_disks_4=majority_disks(num_disks, leader_reps[(signed long int)d]);
          if(!(return_value_majority_disks_4 == 0))
          {
            memcpy((void *)leader_ret, (const void *)&leaders[(signed long int)d], sizeof(struct leader_record) /*200ul*/ );
            found = 1;
            break;
          }

        }
        if(found == 0)
        {
          log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "%s lease_read_num leader inconsistent", caller);
          rv = -222;
        }

      }

    out:
      ;
      free((void *)leaders);
      free((void *)leader_reps);
      return rv;
    }
  }
}

// _lease_read_num_link1
// file paxos_lease.c line 900
static signed int _lease_read_num_link1(struct task *task_link1, struct token *token_link1, struct leader_record *leader_ret_link1, struct paxos_dblock *our_dblock_link1, unsigned long int *max_mbal_link1, signed int *max_q_link1, const char *caller_link1)
{
  struct paxos_dblock dblock_one_link1;
  struct leader_record leader_one_link1;
  struct leader_record *leaders_link1;
  unsigned long int tmp_mbal_link1 = (unsigned long int)0;
  unsigned long int mbal_one_link1;
  signed int *leader_reps_link1;
  signed int num_disks_link1 = (signed int)token_link1->r.num_disks;
  signed int leaders_len_link1;
  signed int leader_reps_len_link1;
  signed int i_link1;
  signed int d_link1;
  signed int rv_link1;
  signed int found_link1;
  signed int num_reads_link1;
  signed int q_one_link1;
  signed int tmp_q_link1 = -1;
  leaders_len_link1 = (signed int)((unsigned long int)num_disks_link1 * sizeof(struct leader_record) /*200ul*/ );
  leader_reps_len_link1 = (signed int)((unsigned long int)num_disks_link1 * sizeof(signed int) /*4ul*/ );
  void *return_value_malloc_1_link1;
  return_value_malloc_1_link1=malloc((unsigned long int)leaders_len_link1);
  leaders_link1 = (struct leader_record *)return_value_malloc_1_link1;
  if(leaders_link1 == ((struct leader_record *)NULL))
    return -12;

  else
  {
    void *return_value_malloc_2_link1;
    return_value_malloc_2_link1=malloc((unsigned long int)leader_reps_len_link1);
    leader_reps_link1 = (signed int *)return_value_malloc_2_link1;
    if(leader_reps_link1 == ((signed int *)NULL))
    {
      free((void *)leaders_link1);
      return -12;
    }

    else
    {
      memset((void *)leaders_link1, 0, (unsigned long int)leaders_len_link1);
      memset((void *)leader_reps_link1, 0, (unsigned long int)leader_reps_len_link1);
      num_reads_link1 = 0;
      d_link1 = 0;
      for( ; !(d_link1 >= num_disks_link1); d_link1 = d_link1 + 1)
      {
        rv_link1=_lease_read_one_link1(task_link1, token_link1, &token_link1->disks[(signed long int)d_link1], &leader_one_link1, &dblock_one_link1, &mbal_one_link1, &q_one_link1, caller_link1);
        if(rv_link1 >= 0)
        {
          num_reads_link1 = num_reads_link1 + 1;
          if(tmp_mbal_link1 == 0ul || !(tmp_mbal_link1 >= mbal_one_link1))
          {
            tmp_mbal_link1 = mbal_one_link1;
            tmp_q_link1 = q_one_link1;
            memcpy((void *)our_dblock_link1, (const void *)&dblock_one_link1, sizeof(struct paxos_dblock) /*56ul*/ );
          }

          memcpy((void *)&leaders_link1[(signed long int)d_link1], (const void *)&leader_one_link1, sizeof(struct leader_record) /*200ul*/ );
          leader_reps_link1[(signed long int)d_link1] = 1;
          i_link1 = 0;
          for( ; !(i_link1 >= d_link1); i_link1 = i_link1 + 1)
          {
            signed int return_value_leaders_match_3_link1;
            return_value_leaders_match_3_link1=leaders_match_link1(&leaders_link1[(signed long int)d_link1], &leaders_link1[(signed long int)i_link1]);
            if(!(return_value_leaders_match_3_link1 == 0))
            {
              leader_reps_link1[(signed long int)i_link1] = leader_reps_link1[(signed long int)i_link1] + 1;
              break;
            }

          }
        }

      }
      *max_mbal_link1 = tmp_mbal_link1;
      *max_q_link1 = tmp_q_link1;
      if(num_reads_link1 == 0)
      {
        log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "%s lease_read_num cannot read disks %d", caller_link1, rv_link1);
        rv_link1 = -210;
      }

      else
      {
        found_link1 = 0;
        d_link1 = 0;
        for( ; !(d_link1 >= num_disks_link1); d_link1 = d_link1 + 1)
        {
          signed int return_value_majority_disks_4_link1;
          return_value_majority_disks_4_link1=majority_disks(num_disks_link1, leader_reps_link1[(signed long int)d_link1]);
          if(!(return_value_majority_disks_4_link1 == 0))
          {
            memcpy((void *)leader_ret_link1, (const void *)&leaders_link1[(signed long int)d_link1], sizeof(struct leader_record) /*200ul*/ );
            found_link1 = 1;
            break;
          }

        }
        if(found_link1 == 0)
        {
          log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "%s lease_read_num leader inconsistent", caller_link1);
          rv_link1 = -222;
        }

      }

    out:
      ;
      free((void *)leaders_link1);
      free((void *)leader_reps_link1);
      return rv_link1;
    }
  }
}

// _lease_read_one
// file paxos_lease.c line 837
static signed int _lease_read_one(struct task *task, struct token *token, struct sync_disk *disk, struct leader_record *leader_ret, struct paxos_dblock *our_dblock, unsigned long int *max_mbal, signed int *max_q, const char *caller)
{
  char *iobuf;
  char **p_iobuf;
  unsigned int host_id = (unsigned int)token->host_id;
  unsigned int sector_size = disk->sector_size;
  struct paxos_dblock *bk;
  unsigned long int tmp_mbal = (unsigned long int)0;
  signed int q;
  signed int tmp_q = -1;
  signed int rv;
  signed int iobuf_len;
  iobuf_len=direct_align(disk);
  _Bool tmp_if_expr_2;
  if(!(iobuf_len >= 0))
    return iobuf_len;

  else
  {
    p_iobuf = &iobuf;
    signed int return_value_getpagesize_1;
    return_value_getpagesize_1=getpagesize();
    rv=posix_memalign((void **)(void *)p_iobuf, (unsigned long int)return_value_getpagesize_1, (unsigned long int)iobuf_len);
    if(!(rv == 0))
      return rv;

    else
    {
      memset((void *)iobuf, 0, (unsigned long int)iobuf_len);
      rv=read_iobuf(disk->fd, disk->offset, iobuf, iobuf_len, task);
      if(rv >= 0)
      {
        memcpy((void *)leader_ret, (const void *)iobuf, sizeof(struct leader_record) /*200ul*/ );
        memcpy((void *)our_dblock, (const void *)(iobuf + (signed long int)((host_id + (unsigned int)1) * sector_size)), sizeof(struct paxos_dblock) /*56ul*/ );
        rv=verify_leader_link1(token, disk, leader_ret, caller);
        if(rv >= 0)
        {
          q = 0;
          for( ; !((unsigned long int)q >= leader_ret->num_hosts); q = q + 1)
          {
            bk = (struct paxos_dblock *)(iobuf + (signed long int)((unsigned int)(2 + q) * sector_size));
            rv=verify_dblock(token, bk);
            if(!(rv >= 0))
              goto out;

            if(tmp_mbal == 0ul)
              tmp_if_expr_2 = (_Bool)1;

            else
              tmp_if_expr_2 = bk->mbal > tmp_mbal ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_2)
            {
              tmp_mbal = bk->mbal;
              tmp_q = q;
            }

          }
          *max_mbal = tmp_mbal;
          *max_q = tmp_q;
        }

      }


    out:
      ;
      if(!(rv == -202))
        free((void *)iobuf);

      return rv;
    }
  }
}

// _lease_read_one_link1
// file paxos_lease.c line 837
static signed int _lease_read_one_link1(struct task *task_link1, struct token *token_link1, struct sync_disk *disk_link1, struct leader_record *leader_ret_link1, struct paxos_dblock *our_dblock_link1, unsigned long int *max_mbal_link1, signed int *max_q_link1, const char *caller_link1)
{
  char *iobuf_link1;
  char **p_iobuf_link1;
  unsigned int host_id_link1 = (unsigned int)token_link1->host_id;
  unsigned int sector_size_link1 = disk_link1->sector_size;
  struct paxos_dblock *bk_link1;
  unsigned long int tmp_mbal_link1 = (unsigned long int)0;
  signed int q_link1;
  signed int tmp_q_link1 = -1;
  signed int rv_link1;
  signed int iobuf_len_link1;
  iobuf_len_link1=direct_align(disk_link1);
  _Bool tmp_if_expr_2_link1;
  if(!(iobuf_len_link1 >= 0))
    return iobuf_len_link1;

  else
  {
    p_iobuf_link1 = &iobuf_link1;
    signed int return_value_getpagesize_1_link1;
    return_value_getpagesize_1_link1=getpagesize();
    rv_link1=posix_memalign((void **)(void *)p_iobuf_link1, (unsigned long int)return_value_getpagesize_1_link1, (unsigned long int)iobuf_len_link1);
    if(!(rv_link1 == 0))
      return rv_link1;

    else
    {
      memset((void *)iobuf_link1, 0, (unsigned long int)iobuf_len_link1);
      rv_link1=read_iobuf(disk_link1->fd, disk_link1->offset, iobuf_link1, iobuf_len_link1, task_link1);
      if(rv_link1 >= 0)
      {
        memcpy((void *)leader_ret_link1, (const void *)iobuf_link1, sizeof(struct leader_record) /*200ul*/ );
        memcpy((void *)our_dblock_link1, (const void *)(iobuf_link1 + (signed long int)((host_id_link1 + (unsigned int)1) * sector_size_link1)), sizeof(struct paxos_dblock) /*56ul*/ );
        rv_link1=verify_leader_link1_link1(token_link1, disk_link1, leader_ret_link1, caller_link1);
        if(rv_link1 >= 0)
        {
          q_link1 = 0;
          for( ; !((unsigned long int)q_link1 >= leader_ret_link1->num_hosts); q_link1 = q_link1 + 1)
          {
            bk_link1 = (struct paxos_dblock *)(iobuf_link1 + (signed long int)((unsigned int)(2 + q_link1) * sector_size_link1));
            rv_link1=verify_dblock_link1(token_link1, bk_link1);
            if(!(rv_link1 >= 0))
              goto out;

            if(tmp_mbal_link1 == 0ul)
              tmp_if_expr_2_link1 = (_Bool)1;

            else
              tmp_if_expr_2_link1 = bk_link1->mbal > tmp_mbal_link1 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_2_link1)
            {
              tmp_mbal_link1 = bk_link1->mbal;
              tmp_q_link1 = q_link1;
            }

          }
          *max_mbal_link1 = tmp_mbal_link1;
          *max_q_link1 = tmp_q_link1;
        }

      }


    out:
      ;
      if(!(rv_link1 == -202))
        free((void *)iobuf_link1);

      return rv_link1;
    }
  }
}

// _lockspace_info
// file lockspace.c line 95
signed int _lockspace_info(char *space_name, struct space *sp_out)
{
  struct space *sp;
  struct space *tmp_statement_expression_1;
  const struct list_head *__mptr = (&spaces)->next;
  tmp_statement_expression_1 = (struct space *)((char *)__mptr - (signed long int)0ul);
  sp = tmp_statement_expression_1;
  struct space *tmp_statement_expression_2;
  for( ; !(&sp->list == &spaces); sp = tmp_statement_expression_2)
  {
    signed int return_value_strncmp_3;
    return_value_strncmp_3=strncmp(sp->space_name, space_name, (unsigned long int)48);
    if(return_value_strncmp_3 == 0)
    {
      memcpy((void *)sp_out, (const void *)sp, sizeof(struct space) /*129264ul*/ );
      return 0;
    }

    const struct list_head *_lockspace_info__1__1__2____mptr = sp->list.next;
    tmp_statement_expression_2 = (struct space *)((char *)_lockspace_info__1__1__2____mptr - (signed long int)0ul);
  }
  return -1;
}

// _log_save_dump
// file log.c line 61
static void _log_save_dump(signed int level, signed int len)
{
  signed int i;
  unsigned int tmp_post_1;
  if(!((unsigned int)len >= 1048576u + -log_point))
  {
    memcpy((void *)(log_dump + (signed long int)log_point), (const void *)log_str, (unsigned long int)len);
    log_point = log_point + (unsigned int)len;
    if(log_point == 1048576u)
    {
      log_point = (unsigned int)0;
      log_wrap = (unsigned int)1;
    }

  }

  else
  {
    i = 0;
    for( ; !(i >= len); i = i + 1)
    {
      tmp_post_1 = log_point;
      log_point = log_point + 1u;
      log_dump[(signed long int)tmp_post_1] = log_str[(signed long int)i];
      if(log_point == 1048576u)
      {
        log_point = (unsigned int)0;
        log_wrap = (unsigned int)1;
      }

    }
  }
}

// _log_save_ent
// file log.c line 86
static void _log_save_ent(signed int level, signed int len)
{
  struct entry *e;
  unsigned int tmp_post_1;
  if(!(log_ents == ((struct entry *)NULL)))
  {
    if(log_pending_ents == log_num_ents)
      log_dropped = log_dropped + 1u;

    else
    {
      tmp_post_1 = log_head_ent;
      log_head_ent = log_head_ent + 1u;
      e = &log_ents[(signed long int)tmp_post_1];
      log_head_ent = log_head_ent % log_num_ents;
      log_pending_ents = log_pending_ents + 1u;
      e->level = level;
      memcpy((void *)e->str, (const void *)log_str, (unsigned long int)len);
    }
  }

}

// _release_token
// file resource.c line 340
static signed int _release_token(struct task *task, struct token *token, signed int opened, signed int nodisk)
{
  struct resource *r = token->resource;
  unsigned long int lver;
  signed int last_token = 0;
  signed int rv;
  pthread_mutex_lock(&resource_mutex);
  list_del_link2(&token->list);
  signed int return_value_list_empty_1;
  return_value_list_empty_1=list_empty_link1(&r->tokens);
  if(!(return_value_list_empty_1 == 0))
  {
    list_move_link2(&r->list, &resources_rem);
    last_token = 1;
  }

  lver = r->leader.lver;
  pthread_mutex_unlock(&resource_mutex);
  if(!((1u & r->flags) == 0u))
  {
    if(!(last_token == 0))
      goto __CPROVER_DUMP_L2;

    log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "release_token more shared");
    close_disks(token->disks, (signed int)token->r.num_disks);
    return 1;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(last_token == 0)
    {
      log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "release_token exclusive not last");
      close_disks(token->disks, (signed int)token->r.num_disks);
      return -201;
    }

    else
    {
      if(lver == 0ul)
      {
        close_disks(token->disks, (signed int)token->r.num_disks);
        rv = 1;
      }

      else
        if(!(nodisk == 0))
          rv = 1;

        else
          if(opened == 0)
          {
            rv=open_disks_fd(token->disks, (signed int)token->r.num_disks);
            if(rv >= 0)
              goto __CPROVER_DUMP_L6;

            rv = 1;
          }

          else
          {

          __CPROVER_DUMP_L6:
            ;
            if(!((1u & r->flags) == 0u))
              rv=set_mode_block(task, token, token->host_id, (unsigned long int)0, (unsigned int)0);

            else
              rv=release_disk(task, token, &r->leader);
            close_disks(token->disks, (signed int)token->r.num_disks);
          }

    out:
      ;
      if(!(rv >= 0))
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "release_token rv %d flags %x lver %llu o %d n %d", rv, r->flags, (unsigned long long int)lver, opened, nodisk);

      else
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "release_token flags %x", r->flags);
      pthread_mutex_lock(&resource_mutex);
      list_del_link2(&r->list);
      pthread_mutex_unlock(&resource_mutex);
      free((void *)r);
      return rv;
    }
  }
}

// _search_space
// file lockspace.c line 39
static struct space * _search_space(char *name, struct sync_disk *disk, unsigned long int host_id, struct list_head *head1, struct list_head *head2, struct list_head *head3)
{
  struct space *sp;
  struct space *tmp_statement_expression_1;
  signed int return_value_strncmp_3;
  signed int return_value_strncmp_4;
  struct space *tmp_statement_expression_2;
  if(!(head1 == ((struct list_head *)NULL)))
  {
    const struct list_head *_search_space__1__1__1__1____mptr = head1->next;
    tmp_statement_expression_1 = (struct space *)((char *)_search_space__1__1__1__1____mptr - (signed long int)0ul);
    sp = tmp_statement_expression_1;
    for( ; !(&sp->list == head1); sp = tmp_statement_expression_2)
    {
      if(!(name == ((char *)NULL)))
      {
        return_value_strncmp_3=strncmp(sp->space_name, name, (unsigned long int)48);
        if(!(return_value_strncmp_3 == 0))
          goto __CPROVER_DUMP_L6;

      }

      if(!(disk == ((struct sync_disk *)NULL)))
      {
        return_value_strncmp_4=strncmp(sp->host_id_disk.path, disk->path, (unsigned long int)1024);
        if(return_value_strncmp_4 == 0)
          goto __CPROVER_DUMP_L3;

      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        if(!(disk == ((struct sync_disk *)NULL)))
        {
          if(sp->host_id_disk.offset == disk->offset)
            goto __CPROVER_DUMP_L4;

        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          if(!(host_id == 0ul))
          {
            if(sp->host_id == host_id)
              goto __CPROVER_DUMP_L5;

          }

          else
          {

          __CPROVER_DUMP_L5:
            ;
            return sp;
          }
        }
      }

    __CPROVER_DUMP_L6:
      ;
      const struct list_head *_search_space__1__1__1__2____mptr = sp->list.next;
      tmp_statement_expression_2 = (struct space *)((char *)_search_space__1__1__1__2____mptr - (signed long int)0ul);
    }
  }

  struct space *tmp_statement_expression_5;
  signed int return_value_strncmp_7;
  signed int return_value_strncmp_8;
  struct space *tmp_statement_expression_6;
  if(!(head2 == ((struct list_head *)NULL)))
  {
    const struct list_head *_search_space__1__2__1__1____mptr = head2->next;
    tmp_statement_expression_5 = (struct space *)((char *)_search_space__1__2__1__1____mptr - (signed long int)0ul);
    sp = tmp_statement_expression_5;
    for( ; !(&sp->list == head2); sp = tmp_statement_expression_6)
    {
      if(!(name == ((char *)NULL)))
      {
        return_value_strncmp_7=strncmp(sp->space_name, name, (unsigned long int)48);
        if(!(return_value_strncmp_7 == 0))
          goto __CPROVER_DUMP_L13;

      }

      if(!(disk == ((struct sync_disk *)NULL)))
      {
        return_value_strncmp_8=strncmp(sp->host_id_disk.path, disk->path, (unsigned long int)1024);
        if(return_value_strncmp_8 == 0)
          goto __CPROVER_DUMP_L10;

      }

      else
      {

      __CPROVER_DUMP_L10:
        ;
        if(!(disk == ((struct sync_disk *)NULL)))
        {
          if(sp->host_id_disk.offset == disk->offset)
            goto __CPROVER_DUMP_L11;

        }

        else
        {

        __CPROVER_DUMP_L11:
          ;
          if(!(host_id == 0ul))
          {
            if(sp->host_id == host_id)
              goto __CPROVER_DUMP_L12;

          }

          else
          {

          __CPROVER_DUMP_L12:
            ;
            return sp;
          }
        }
      }

    __CPROVER_DUMP_L13:
      ;
      const struct list_head *_search_space__1__2__1__2____mptr = sp->list.next;
      tmp_statement_expression_6 = (struct space *)((char *)_search_space__1__2__1__2____mptr - (signed long int)0ul);
    }
  }

  struct space *tmp_statement_expression_9;
  signed int return_value_strncmp_11;
  signed int return_value_strncmp_12;
  struct space *tmp_statement_expression_10;
  if(!(head3 == ((struct list_head *)NULL)))
  {
    const struct list_head *_search_space__1__3__1__1____mptr = head3->next;
    tmp_statement_expression_9 = (struct space *)((char *)_search_space__1__3__1__1____mptr - (signed long int)0ul);
    sp = tmp_statement_expression_9;
    for( ; !(&sp->list == head3); sp = tmp_statement_expression_10)
    {
      if(!(name == ((char *)NULL)))
      {
        return_value_strncmp_11=strncmp(sp->space_name, name, (unsigned long int)48);
        if(!(return_value_strncmp_11 == 0))
          goto __CPROVER_DUMP_L20;

      }

      if(!(disk == ((struct sync_disk *)NULL)))
      {
        return_value_strncmp_12=strncmp(sp->host_id_disk.path, disk->path, (unsigned long int)1024);
        if(return_value_strncmp_12 == 0)
          goto __CPROVER_DUMP_L17;

      }

      else
      {

      __CPROVER_DUMP_L17:
        ;
        if(!(disk == ((struct sync_disk *)NULL)))
        {
          if(sp->host_id_disk.offset == disk->offset)
            goto __CPROVER_DUMP_L18;

        }

        else
        {

        __CPROVER_DUMP_L18:
          ;
          if(!(host_id == 0ul))
          {
            if(sp->host_id == host_id)
              goto __CPROVER_DUMP_L19;

          }

          else
          {

          __CPROVER_DUMP_L19:
            ;
            return sp;
          }
        }
      }

    __CPROVER_DUMP_L20:
      ;
      const struct list_head *__mptr = sp->list.next;
      tmp_statement_expression_10 = (struct space *)((char *)__mptr - (signed long int)0ul);
    }
  }

  return (struct space *)(void *)0;
}

// _write_sectors
// file diskio.c line 599
static signed int _write_sectors(struct sync_disk *disk, unsigned long int sector_nr, unsigned int sector_count, const char *data, signed int data_len, signed int iobuf_len, struct task *task, const char *blktype)
{
  char *iobuf;
  char **p_iobuf;
  unsigned long int offset;
  signed int rv;
  if(disk->sector_size == 0u)
    return -22;

  else
  {
    offset = disk->offset + sector_nr * (unsigned long int)disk->sector_size;
    p_iobuf = &iobuf;
    signed int return_value_getpagesize_1;
    return_value_getpagesize_1=getpagesize();
    rv=posix_memalign((void **)(void *)p_iobuf, (unsigned long int)return_value_getpagesize_1, (unsigned long int)iobuf_len);
    if(!(rv == 0))
    {
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "write_sectors %s posix_memalign rv %d %s", blktype, rv, (const void *)disk->path);
      rv = -12;
    }

    else
    {
      memset((void *)iobuf, 0, (unsigned long int)iobuf_len);
      memcpy((void *)iobuf, (const void *)data, (unsigned long int)data_len);
      rv=write_iobuf(disk->fd, offset, iobuf, iobuf_len, task);
      if(!(rv >= 0))
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "write_sectors %s offset %llu rv %d %s", blktype, (unsigned long long int)offset, rv, (const void *)disk->path);

      if(!(rv == -202))
        free((void *)iobuf);

    }

  out:
    ;
    return rv;
  }
}

// _write_sectors_link1
// file diskio.c line 599
static signed int _write_sectors_link1(struct sync_disk *disk_link1, unsigned long int sector_nr_link1, unsigned int sector_count_link1, const char *data_link1, signed int data_len_link1, signed int iobuf_len_link1, struct task *task_link1, const char *blktype_link1)
{
  char *iobuf_link1;
  char **p_iobuf_link1;
  unsigned long int offset_link1;
  signed int rv_link1;
  if(disk_link1->sector_size == 0u)
    return -22;

  else
  {
    offset_link1 = disk_link1->offset + sector_nr_link1 * (unsigned long int)disk_link1->sector_size;
    p_iobuf_link1 = &iobuf_link1;
    signed int return_value_getpagesize_1_link1;
    return_value_getpagesize_1_link1=getpagesize();
    rv_link1=posix_memalign((void **)(void *)p_iobuf_link1, (unsigned long int)return_value_getpagesize_1_link1, (unsigned long int)iobuf_len_link1);
    if(!(rv_link1 == 0))
    {
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "write_sectors %s posix_memalign rv %d %s", blktype_link1, rv_link1, (const void *)disk_link1->path);
      rv_link1 = -12;
    }

    else
    {
      memset((void *)iobuf_link1, 0, (unsigned long int)iobuf_len_link1);
      memcpy((void *)iobuf_link1, (const void *)data_link1, (unsigned long int)data_len_link1);
      rv_link1=write_iobuf(disk_link1->fd, offset_link1, iobuf_link1, iobuf_len_link1, task_link1);
      if(!(rv_link1 >= 0))
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "write_sectors %s offset %llu rv %d %s", blktype_link1, (unsigned long long int)offset_link1, rv_link1, (const void *)disk_link1->path);

      if(!(rv_link1 == -202))
        free((void *)iobuf_link1);

    }

  out:
    ;
    return rv_link1;
  }
}

// acquire_disk
// file resource.c line 293
static signed int acquire_disk(struct task *task, struct token *token, unsigned long int acquire_lver, signed int new_num_hosts, struct leader_record *leader)
{
  struct leader_record leader_tmp;
  signed int rv;
  unsigned int flags = (unsigned int)0;
  if(!(com.quiet_fail == 0))
    flags = flags | (unsigned int)0x00000002;

  if(!((4u & token->acquire_flags) == 0u))
    flags = flags | (unsigned int)0x00000004;

  memset((void *)&leader_tmp, 0, sizeof(struct leader_record) /*200ul*/ );
  rv=paxos_lease_acquire(task, token, flags, &leader_tmp, acquire_lver, new_num_hosts);
  log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "acquire_disk rv %d lver %llu at %llu", rv, (unsigned long long int)leader_tmp.lver, (unsigned long long int)leader_tmp.timestamp);
  memcpy((void *)leader, (const void *)&leader_tmp, sizeof(struct leader_record) /*200ul*/ );
  return rv;
}

// acquire_token
// file resource.c line 557
signed int acquire_token(struct task *task, struct token *token)
{
  struct leader_record leader;
  struct resource *r;
  unsigned long int acquire_lver = (unsigned long int)0;
  unsigned int new_num_hosts = (unsigned int)0;
  signed int sh_retries = 0;
  signed int live_count = 0;
  signed int rv;
  if(!((1u & token->acquire_flags) == 0u))
    acquire_lver = token->acquire_lver;

  if(!((2u & token->acquire_flags) == 0u))
    new_num_hosts = token->acquire_data32;

  pthread_mutex_lock(&resource_mutex);
  r=find_resource(token, &resources_rem);
  signed int tmp_post_1;
  signed int us;
  if(!(r == ((struct resource *)NULL)))
  {
    if(com.quiet_fail == 0)
      log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "acquire_token resource being removed");

    pthread_mutex_unlock(&resource_mutex);
    return -11;
  }

  else
  {
    r=find_resource(token, &resources_add);
    if(!(r == ((struct resource *)NULL)))
    {
      if(com.quiet_fail == 0)
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "acquire_token resource being added");

      pthread_mutex_unlock(&resource_mutex);
      return -16;
    }

    else
    {
      r=find_resource(token, &resources_held);
      if(!(r == ((struct resource *)NULL)))
      {
        if((4u & token->acquire_flags) == 0u)
          goto __CPROVER_DUMP_L7;

        if((1u & r->flags) == 0u)
          goto __CPROVER_DUMP_L7;

        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "acquire_token add shared");
        copy_disks((void *)&token->r.disks, (void *)&r->r.disks, (signed int)token->r.num_disks);
        token->resource = r;
        list_add_link2(&token->list, &r->tokens);
        pthread_mutex_unlock(&resource_mutex);
        return 1;
      }

      else
      {

      __CPROVER_DUMP_L7:
        ;
        if(!(r == ((struct resource *)NULL)))
        {
          if(com.quiet_fail == 0)
            log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "acquire_token resource exists");

          pthread_mutex_unlock(&resource_mutex);
          return -17;
        }

        else
        {
          r=new_resource(token);
          if(r == ((struct resource *)NULL))
          {
            pthread_mutex_unlock(&resource_mutex);
            return -12;
          }

          else
          {
            list_add_link2(&token->list, &r->tokens);
            list_add_link2(&r->list, &resources_add);
            token->resource = r;
            pthread_mutex_unlock(&resource_mutex);
            rv=open_disks(token->disks, (signed int)token->r.num_disks);
            if(!(rv >= 0))
            {
              log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "acquire_token open error %d", rv);
              release_token_nodisk(task, token);
              return rv;
            }

            else
            {
              copy_disks((void *)&r->r.disks, (void *)&token->r.disks, (signed int)token->r.num_disks);
              do
              {

              retry:
                ;
                memset((void *)&leader, 0, sizeof(struct leader_record) /*200ul*/ );
                rv=acquire_disk(task, token, acquire_lver, (signed int)new_num_hosts, &leader);
                if(rv >= 0)
                  goto __CPROVER_DUMP_L15;

                if((4u & token->acquire_flags) == 0u)
                  goto __CPROVER_DUMP_L14;

                if((1u & leader.flags) == 0u)
                  goto __CPROVER_DUMP_L14;

                tmp_post_1 = sh_retries;
                sh_retries = sh_retries + 1;
                if(tmp_post_1 >= com.sh_retries)
                  break;

                us=get_rand(0, 1000000);
                log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "acquire_token sh_retry %d %d", rv, us);
                usleep((unsigned int)us);
              }
              while((_Bool)1);
              rv = -246;

            __CPROVER_DUMP_L14:
              ;
              release_token_opened(task, token);
              return rv;

            __CPROVER_DUMP_L15:
              ;
              memcpy((void *)&r->leader, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );
              if(!((4u & token->acquire_flags) == 0u))
              {
                rv=set_mode_block(task, token, token->host_id, token->host_generation, (unsigned int)0x00000001);
                if(!(rv >= 0))
                {
                  release_token_opened(task, token);
                  return rv;
                }

                release_disk(task, token, &leader);
              }

              else
                if(!(token->shared_count == 0))
                {
                  rv=clear_dead_shared(task, token, (signed int)leader.num_hosts, &live_count);
                  if(!(rv >= 0))
                  {
                    release_token_opened(task, token);
                    return rv;
                  }

                  if(!(live_count == 0))
                  {
                    release_token_opened(task, token);
                    return -11;
                  }

                }


            out:
              ;
              close_disks(token->disks, (signed int)token->r.num_disks);
              pthread_mutex_lock(&resource_mutex);
              list_move_link2(&r->list, &resources_held);
              pthread_mutex_unlock(&resource_mutex);
              return 1;
            }
          }
        }
      }
    }
  }
}

// add_lockspace_start
// file lockspace.c line 577
signed int add_lockspace_start(struct sanlk_lockspace *ls, struct space **sp_out)
{
  struct space *sp;
  struct space *sp2;
  signed int rv;
  _Bool tmp_if_expr_3;
  if(ls->name[0l] == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = !(ls->host_id != 0ul) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = !(ls->host_id_disk.path[(signed long int)0] != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_4)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(ls->name);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(ls->host_id_disk.path);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "add_lockspace bad args id %llu name %zu path %zu", (unsigned long long int)ls->host_id, return_value_strlen_1, return_value_strlen_2);
    return -22;
  }

  void *return_value_malloc_5;
  return_value_malloc_5=malloc(sizeof(struct space) /*129264ul*/ );
  sp = (struct space *)return_value_malloc_5;
  unsigned int tmp_post_6;
  if(sp == ((struct space *)NULL))
    return -12;

  else
  {
    memset((void *)sp, 0, sizeof(struct space) /*129264ul*/ );
    memcpy((void *)sp->space_name, (const void *)ls->name, (unsigned long int)48);
    memcpy((void *)&sp->host_id_disk, (const void *)&ls->host_id_disk, sizeof(struct sanlk_disk) /*1040ul*/ );
    sp->host_id_disk.sector_size = (unsigned int)0;
    sp->host_id_disk.fd = -1;
    sp->host_id = ls->host_id;
    pthread_mutex_init(&sp->mutex, (const union anonymous_5 *)(void *)0);
    pthread_mutex_lock(&spaces_mutex);
    sp2=_search_space(sp->space_name, &sp->host_id_disk, sp->host_id, &spaces, (struct list_head *)(void *)0, (struct list_head *)(void *)0);
    if(!(sp2 == ((struct space *)NULL)))
    {
      pthread_mutex_unlock(&spaces_mutex);
      rv = -17;
    }

    else
    {
      sp2=_search_space(sp->space_name, &sp->host_id_disk, sp->host_id, &spaces_add, (struct list_head *)(void *)0, (struct list_head *)(void *)0);
      if(!(sp2 == ((struct space *)NULL)))
      {
        pthread_mutex_unlock(&spaces_mutex);
        rv = -115;
      }

      else
      {
        sp2=_search_space(sp->space_name, &sp->host_id_disk, sp->host_id, &spaces_rem, (struct list_head *)(void *)0, (struct list_head *)(void *)0);
        if(!(sp2 == ((struct space *)NULL)))
        {
          pthread_mutex_unlock(&spaces_mutex);
          rv = -11;
        }

        else
        {
          sp2=_search_space(sp->space_name, (struct sync_disk *)(void *)0, (unsigned long int)0, &spaces, &spaces_add, &spaces_rem);
          if(!(sp2 == ((struct space *)NULL)))
          {
            pthread_mutex_unlock(&spaces_mutex);
            rv = -22;
          }

          else
          {
            sp2=_search_space((char *)(void *)0, &sp->host_id_disk, (unsigned long int)0, &spaces, &spaces_add, &spaces_rem);
            if(!(sp2 == ((struct space *)NULL)))
            {
              pthread_mutex_unlock(&spaces_mutex);
              rv = -22;
            }

            else
            {
              tmp_post_6 = space_id_counter;
              space_id_counter = space_id_counter + 1u;
              sp->space_id = tmp_post_6;
              list_add(&sp->list, &spaces_add);
              pthread_mutex_unlock(&spaces_mutex);
              log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 4, "lockspace %.48s:%llu:%.256s:%llu", (const void *)sp->space_name, (unsigned long long int)sp->host_id, (const void *)sp->host_id_disk.path, (unsigned long long int)sp->host_id_disk.offset);
              rv=pthread_create(&sp->thread, (const union pthread_attr_t *)(void *)0, lockspace_thread, (void *)sp);
              if(!(rv >= 0))
                log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "add_lockspace create thread failed");

              else
              {
                *sp_out = sp;
                return 0;
              }

            fail_del:
              ;
              pthread_mutex_lock(&spaces_mutex);
              list_del(&sp->list);
              pthread_mutex_unlock(&spaces_mutex);
            }
          }
        }
      }
    }

  fail_free:
    ;
    free_sp(sp);
    return rv;
  }
}

// add_lockspace_wait
// file lockspace.c line 679
signed int add_lockspace_wait(struct space *sp)
{
  signed int rv;
  signed int result;
  while((_Bool)1)
  {
    pthread_mutex_lock(&sp->mutex);
    result = sp->lease_status.acquire_last_result;
    pthread_mutex_unlock(&sp->mutex);
    if(!(result == 0))
      break;

    sleep((unsigned int)1);
  }
  if(!(result == 1))
  {
    pthread_join(sp->thread, (void **)(void *)0);
    rv = result;
  }

  else
  {
    pthread_mutex_lock(&spaces_mutex);
    if(!(sp->external_remove == 0) || !(external_shutdown == 0))
    {
      rv = -1;
      pthread_mutex_unlock(&spaces_mutex);
    }

    else
    {
      list_move(&sp->list, &spaces);
      pthread_mutex_unlock(&spaces_mutex);
      return 0;
    }
  }

fail_del:
  ;
  pthread_mutex_lock(&spaces_mutex);
  list_del(&sp->list);
  pthread_mutex_unlock(&spaces_mutex);
  free_sp(sp);
  return rv;
}

// all_pids_dead
// file main.c line 512
static signed int all_pids_dead(struct space *sp)
{
  struct client *cl;
  signed int stuck = 0;
  signed int check = 0;
  signed int ci = 0;
  signed int return_value_client_using_space_1;
  for( ; client_maxi >= ci; ci = ci + 1)
  {
    cl = &client[(signed long int)ci];
    pthread_mutex_lock(&cl->mutex);
    if(!(cl->used == 0))
    {
      if(cl->pid >= 1)
      {
        return_value_client_using_space_1=client_using_space(cl, sp);
        if(!(return_value_client_using_space_1 == 0))
        {
          if(cl->kill_count >= main_task.kill_count_max)
            stuck = stuck + 1;

          else
            check = check + 1;
        }

      }

    }


  unlock:
    ;
    pthread_mutex_unlock(&cl->mutex);
  }
  if(check == 0 && !(stuck == 0))
  {
    if(!(sp->killing_pids >= 2))
    {
      log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "killing pids stuck %d", stuck);
      sp->killing_pids = 2;
    }

  }

  if(!(check == 0) || !(stuck == 0))
    return 0;

  else
  {
    log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "used by no pids");
    return 1;
  }
}

// call_cmd_daemon
// file cmd.h line 25
void call_cmd_daemon(signed int ci, struct sm_header *h_recv, signed int client_maxi)
{
  signed int rv;
  signed int pid;
  signed int auto_close = 1;
  signed int fd = (client + (signed long int)ci)->fd;
  _Bool tmp_if_expr_3;
  signed int return_value_list_empty_2;
  _Bool tmp_if_expr_5;
  signed int return_value_list_empty_4;
  switch(h_recv->cmd)
  {
    case (unsigned int)1:
    {
      rv=get_peer_pid(fd, &pid);
      if(!(rv >= 0))
      {
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_register ci %d fd %d get pid failed", ci, fd);
        break;
      }

      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_register ci %d fd %d pid %d", ci, fd, pid);
      snprintf((client + (signed long int)ci)->owner_name, (unsigned long int)48, "%d", pid);
      (client + (signed long int)ci)->pid = pid;
      (client + (signed long int)ci)->deadfn = (void *)client_pid_dead;
      auto_close = 0;
      break;
    }
    case (unsigned int)10:
    {
      cmd_restrict(ci, fd, h_recv);
      auto_close = 0;
      break;
    }
    case (unsigned int)4:
    {
      strcpy((client + (signed long int)ci)->owner_name, "shutdown");
      if(!(h_recv->data == 0u))
        external_shutdown = 2;

      else
      {
        pthread_mutex_lock(&spaces_mutex);
        signed int return_value_list_empty_1;
        return_value_list_empty_1=list_empty_link2(&spaces);
        if(!(return_value_list_empty_1 == 0))
        {
          return_value_list_empty_2=list_empty_link2(&spaces_rem);
          tmp_if_expr_3 = return_value_list_empty_2 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
        {
          return_value_list_empty_4=list_empty_link2(&spaces_add);
          tmp_if_expr_5 = return_value_list_empty_4 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_5 = (_Bool)0;
        if(tmp_if_expr_5)
          external_shutdown = 1;

        else
          log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "ignore shutdown, lockspace exists");
        pthread_mutex_unlock(&spaces_mutex);
      }
      break;
    }
    case (unsigned int)5:
    {
      strcpy((client + (signed long int)ci)->owner_name, "status");
      cmd_status(fd, h_recv, client_maxi);
      break;
    }
    case (unsigned int)17:
    {
      strcpy((client + (signed long int)ci)->owner_name, "host_status");
      cmd_host_status(fd, h_recv);
      break;
    }
    case (unsigned int)6:
    {
      strcpy((client + (signed long int)ci)->owner_name, "log_dump");
      cmd_log_dump(fd, h_recv);
    }
  }
  if(!(auto_close == 0))
    close(fd);

}

// call_cmd_thread
// file cmd.h line 22
void call_cmd_thread(struct task *task, struct cmd_args *ca)
{
  switch(ca->header.cmd)
  {
    case (unsigned int)7:
    {
      cmd_acquire(task, ca);
      break;
    }
    case (unsigned int)8:
    {
      cmd_release(task, ca);
      break;
    }
    case (unsigned int)9:
    {
      cmd_inquire(task, ca);
      break;
    }
    case (unsigned int)11:
    {
      cmd_request(task, ca);
      break;
    }
    case (unsigned int)2:
    {
      strcpy((client + (signed long int)ca->ci_in)->owner_name, "add_lockspace");
      cmd_add_lockspace(ca);
      break;
    }
    case (unsigned int)18:
    {
      strcpy((client + (signed long int)ca->ci_in)->owner_name, "inq_lockspace");
      cmd_inq_lockspace(ca);
      break;
    }
    case (unsigned int)3:
    {
      strcpy((client + (signed long int)ca->ci_in)->owner_name, "rem_lockspace");
      cmd_rem_lockspace(ca);
      break;
    }
    case (unsigned int)12:
    {
      cmd_align(task, ca);
      break;
    }
    case (unsigned int)13:
    {
      cmd_init_lockspace(task, ca);
      break;
    }
    case (unsigned int)14:
    {
      cmd_init_resource(task, ca);
      break;
    }
    case (unsigned int)15:

    case (unsigned int)16:
      cmd_examine(task, ca);
    default:
      ;
  }
}

// check_mode_block
// file resource.h line 16
void check_mode_block(struct token *token, signed int q, char *dblock)
{
  struct mode_block *mb = (struct mode_block *)(dblock + (signed long int)128);
  if(!((1u & mb->flags) == 0u))
  {
    set_id_bit(q + 1, token->shared_bitmap, (char *)(void *)0);
    token->shared_count = token->shared_count + 1;
  }

}

// check_new_tokens_space
// file cmd.c line 87
static signed int check_new_tokens_space(struct client *cl, struct token **new_tokens, signed int new_tokens_count)
{
  struct space space;
  struct token *token;
  signed int i;
  signed int rv;
  signed int empty_slots = 0;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    if(cl->tokens[(signed long int)i] == ((struct token *)NULL))
      empty_slots = empty_slots + 1;

  if(!(empty_slots >= new_tokens_count))
    return -2;

  else
  {
    i = 0;
    for( ; !(i >= new_tokens_count); i = i + 1)
    {
      token = new_tokens[(signed long int)i];
      rv=_lockspace_info(token->r.lockspace_name, &space);
      if(space.killing_pids == 0 && rv == 0)
      {
        if(space.host_id == token->host_id)
          goto __CPROVER_DUMP_L7;

      }

      return -28;

    __CPROVER_DUMP_L7:
      ;
    }
    return 0;
  }
}

// check_other_leases
// file lockspace.c line 248
void check_other_leases(struct task *task, struct space *sp, char *buf)
{
  struct leader_record *leader;
  struct sync_disk *disk;
  struct host_status *hs;
  char *bitmap;
  unsigned long int now;
  signed int i;
  signed int new;
  disk = &sp->host_id_disk;
  now=monotime();
  new = 0;
  i = 0;
  for( ; !(i >= 2000); i = i + 1)
  {
    hs = &sp->host_status[(signed long int)i];
    hs->last_check = now;
    if(hs->first_check == 0ul)
      hs->first_check = now;

    leader = (struct leader_record *)(buf + (signed long int)((unsigned int)i * disk->sector_size));
    if(hs->owner_id == leader->owner_id)
    {
      if(hs->owner_generation == leader->owner_generation)
      {
        if(hs->timestamp == leader->timestamp)
          goto __CPROVER_DUMP_L5;

      }

    }

    hs->owner_id = leader->owner_id;
    hs->owner_generation = leader->owner_generation;
    hs->timestamp = leader->timestamp;
    hs->last_live = now;
    if(!((unsigned long int)(1 + i) == sp->host_id))
    {
      bitmap = (char *)leader + (signed long int)256;
      signed int return_value_test_id_bit_1;
      return_value_test_id_bit_1=test_id_bit((signed int)sp->host_id, bitmap);
      if(!(return_value_test_id_bit_1 == 0))
      {
        if(now + -hs->last_req >= (unsigned long int)task->request_finish_seconds)
        {
          log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "request from host_id %d", i + 1);
          hs->last_req = now;
          new = 1;
        }

      }

    }


  __CPROVER_DUMP_L5:
    ;
  }
  if(!(new == 0))
    set_resource_examine(sp->space_name, (char *)(void *)0);

}

// check_our_lease
// file lockspace.c line 309
signed int check_our_lease(struct task *task, struct space *sp, signed int *check_all, char *check_buf)
{
  unsigned long int last_success;
  signed int check_our_lease__1__corrupt_result;
  signed int gap;
  pthread_mutex_lock(&sp->mutex);
  last_success = sp->lease_status.renewal_last_success;
  check_our_lease__1__corrupt_result = sp->lease_status.corrupt_result;
  if(!(sp->lease_status.renewal_read_check >= sp->lease_status.renewal_read_count))
  {
    sp->lease_status.renewal_read_check = sp->lease_status.renewal_read_count;
    *check_all = 1;
    if(!(check_buf == ((char *)NULL)))
      memcpy((void *)check_buf, (const void *)sp->lease_status.renewal_read_buf, (unsigned long int)sp->align_size);

  }

  pthread_mutex_unlock(&sp->mutex);
  if(!(check_our_lease__1__corrupt_result == 0))
  {
    log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "check_our_lease corrupt %d", check_our_lease__1__corrupt_result);
    return -1;
  }

  else
  {
    unsigned long int return_value_monotime_1;
    return_value_monotime_1=monotime();
    gap = (signed int)(return_value_monotime_1 - last_success);
    if(gap >= task->id_renewal_fail_seconds)
    {
      log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "check_our_lease failed %d", gap);
      return -1;
    }

    else
    {
      if(gap >= task->id_renewal_warn_seconds)
        log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "check_our_lease warning %d last_success %llu", gap, (unsigned long long int)last_success);

      if(com.debug_renew >= 2)
        log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "check_our_lease good %d %llu", gap, (unsigned long long int)last_success);

      return 0;
    }
  }
}

// clear_dead_shared
// file resource.c line 247
static signed int clear_dead_shared(struct task *task, struct token *token, signed int num_hosts, signed int *live_count)
{
  unsigned long int host_id;
  unsigned long int max_gen = (unsigned long int)0;
  signed int i;
  signed int rv;
  signed int live = 0;
  i = 0;
  for( ; !(i >= num_hosts); i = i + 1)
  {
    host_id = (unsigned long int)(i + 1);
    if(!(host_id == token->host_id))
    {
      signed int return_value_test_id_bit_1;
      return_value_test_id_bit_1=test_id_bit((signed int)host_id, token->shared_bitmap);
      if(!(return_value_test_id_bit_1 == 0))
      {
        rv=read_mode_block(task, token, host_id, &max_gen);
        if(!(rv >= 0))
        {
          log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "clear_dead_shared read_mode_block %llu %d", (unsigned long long int)host_id, rv);
          return rv;
        }

        signed int return_value_host_live_2;
        return_value_host_live_2=host_live(task, token->r.lockspace_name, host_id, max_gen);
        if(!(return_value_host_live_2 == 0))
        {
          log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "clear_dead_shared host_id %llu gen %llu alive", (unsigned long long int)host_id, (unsigned long long int)max_gen);
          live = live + 1;
        }

        else
        {
          rv=set_mode_block(task, token, host_id, (unsigned long int)0, (unsigned int)0);
          if(!(rv >= 0))
          {
            log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "clear_dead_shared host_id %llu set_mode_block %d", (unsigned long long int)host_id, rv);
            return rv;
          }

          log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "clear_dead_shared host_id %llu gen %llu dead and cleared", (unsigned long long int)host_id, (unsigned long long int)max_gen);
        }
      }

    }

  }
  *live_count = live;
  return rv;
}

// client_add
// file main.c line 264
static signed int client_add(signed int fd, void (*workfn)(signed int), void (*deadfn)(signed int))
{
  struct client *cl;
  signed int i = 0;
  for( ; !(i >= client_size); i = i + 1)
  {
    cl = &client[(signed long int)i];
    pthread_mutex_lock(&cl->mutex);
    if(cl->used == 0)
    {
      cl->used = 1;
      cl->fd = fd;
      cl->workfn = (void *)workfn;
      cl->deadfn = (void *)(deadfn != ((void (*)(signed int))NULL) ? deadfn : client_free);
      (pollfd + (signed long int)i)->fd = fd;
      (pollfd + (signed long int)i)->events = (signed short int)0x001;
      if(!(client_maxi >= i))
        client_maxi = i;

      pthread_mutex_unlock(&cl->mutex);
      return i;
    }

    pthread_mutex_unlock(&cl->mutex);
  }
  return -1;
}

// client_alloc
// file main.c line 92
static signed int client_alloc(void)
{
  signed int i;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)1024 * sizeof(struct client) /*224ul*/ );
  client = (struct client *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)1024 * sizeof(struct pollfd) /*8ul*/ );
  pollfd = (struct pollfd *)return_value_malloc_2;
  if(client == ((struct client *)NULL) || pollfd == ((struct pollfd *)NULL))
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "can't alloc for client or pollfd array");
    return -12;
  }

  else
  {
    i = 0;
    for( ; !(i >= 1024); i = i + 1)
    {
      memset((void *)&client[(signed long int)i], 0, sizeof(struct client) /*224ul*/ );
      memset((void *)&pollfd[(signed long int)i], 0, sizeof(struct pollfd) /*8ul*/ );
      pthread_mutex_init(&(client + (signed long int)i)->mutex, (const union anonymous_5 *)(void *)0);
      (client + (signed long int)i)->fd = -1;
      (client + (signed long int)i)->pid = -1;
      (pollfd + (signed long int)i)->fd = -1;
      (pollfd + (signed long int)i)->events = (signed short int)0;
    }
    client_size = 1024;
    return 0;
  }
}

// client_free
// file main.c line 174
void client_free(signed int ci)
{
  struct client *cl = &client[(signed long int)ci];
  pthread_mutex_lock(&cl->mutex);
  _client_free(ci);
  pthread_mutex_unlock(&cl->mutex);
}

// client_pid_dead
// file main.c line 334
void client_pid_dead(signed int ci)
{
  struct client *cl = &client[(signed long int)ci];
  signed int cmd_active;
  signed int i;
  signed int pid;
  pthread_mutex_lock(&cl->mutex);
  _Bool tmp_if_expr_1;
  if(cl->used == 0)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = cl->fd == -1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = cl->pid == -1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    pthread_mutex_unlock(&cl->mutex);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "client_pid_dead %d,%d,%d u %d a %d s %d bad state", ci, cl->fd, cl->pid, cl->used, cl->cmd_active, cl->suspend);
  }

  else
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "client_pid_dead %d,%d,%d cmd_active %d suspend %d", ci, cl->fd, cl->pid, cl->cmd_active, cl->suspend);
    cmd_active = cl->cmd_active;
    pid = cl->pid;
    cl->pid = -1;
    cl->pid_dead = 1;
    (pollfd + (signed long int)ci)->fd = -1;
    (pollfd + (signed long int)ci)->events = (signed short int)0;
    pthread_mutex_unlock(&cl->mutex);
    kill(pid, 9);
    if(!(cmd_active == 0))
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "client_pid_dead %d,%d,%d defer to cmd %d", ci, cl->fd, pid, cmd_active);

    else
    {
      pthread_mutex_lock(&cl->mutex);
      i = 0;
      for( ; !(i >= 8); i = i + 1)
        if(!(cl->tokens[(signed long int)i] == ((struct token *)NULL)))
        {
          release_token_async(cl->tokens[(signed long int)i]);
          free((void *)cl->tokens[(signed long int)i]);
        }

      _client_free(ci);
      pthread_mutex_unlock(&cl->mutex);
    }
  }
}

// client_recv_all
// file main.c line 296
void client_recv_all(signed int ci, struct sm_header *h_recv, signed int pos)
{
  char trash[64l];
  signed int rem = (signed int)(((unsigned long int)h_recv->length - sizeof(struct sm_header) /*32ul*/ ) - (unsigned long int)pos);
  signed int rv;
  signed int error = 0;
  signed int total = 0;
  signed int *return_value___errno_location_2;
  if(!(rem == 0))
  {
    while((_Bool)1)
    {
      signed long int return_value_recv_1;
      return_value_recv_1=recv((client + (signed long int)ci)->fd, (void *)trash, sizeof(char [64l]) /*64ul*/ , 64);
      rv = (signed int)return_value_recv_1;
      if(rv == -1)
      {
        return_value___errno_location_2=__errno_location();
        error = *return_value___errno_location_2;
      }

      if(!(rv >= 1))
        break;

      total = total + rv;
      if(total >= rem)
        break;

    }
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "recv_all %d,%d,%d pos %d rv %d error %d rem %d total %d", ci, (client + (signed long int)ci)->fd, (client + (signed long int)ci)->pid, pos, rv, error, rem, total);
  }

}

// client_resume
// file main.c line 226
void client_resume(signed int ci)
{
  struct client *cl = &client[(signed long int)ci];
  pthread_mutex_lock(&cl->mutex);
  if(cl->used == 0)
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "client_resume ci %d not used", ci);

  else
    if(cl->fd == -1)
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "client_resume ci %d is free", ci);

    else
      if(cl->suspend == 0)
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "client_resume ci %d not suspended", ci);

      else
      {
        cl->suspend = 0;
        if(!(cl->need_free == 0))
        {
          log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "client_resume ci %d need_free", ci);
          _client_free(ci);
        }

        else
        {
          (pollfd + (signed long int)ci)->fd = cl->fd;
          (pollfd + (signed long int)ci)->events = (signed short int)0x001;
        }
      }

out:
  ;
  pthread_mutex_unlock(&cl->mutex);
}

// client_suspend
// file main.c line 186
static signed int client_suspend(signed int ci)
{
  struct client *cl = &client[(signed long int)ci];
  signed int rv = 0;
  pthread_mutex_lock(&cl->mutex);
  if(cl->used == 0)
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "client_suspend ci %d not used", ci);
    rv = -1;
  }

  else
    if(cl->fd == -1)
    {
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "client_suspend ci %d is free", ci);
      rv = -1;
    }

    else
      if(!(cl->suspend == 0))
      {
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "client_suspend ci %d is suspended", ci);
        rv = -1;
      }

      else
      {
        cl->suspend = 1;
        (pollfd + (signed long int)ci)->fd = -1;
        (pollfd + (signed long int)ci)->events = (signed short int)0;
      }

out:
  ;
  pthread_mutex_unlock(&cl->mutex);
  return rv;
}

// client_using_space
// file main.c line 415
static signed int client_using_space(struct client *cl, struct space *sp)
{
  struct token *token;
  signed int i;
  signed int rv = 0;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
  {
    token = cl->tokens[(signed long int)i];
    if(!(token == ((struct token *)NULL)))
    {
      signed int return_value_strncmp_1;
      return_value_strncmp_1=strncmp(token->r.lockspace_name, sp->space_name, (unsigned long int)48);
      if(return_value_strncmp_1 == 0)
      {
        if(cl->kill_count == 0)
          log_level(sp->space_id, token->token_id, (char *)(void *)0, 7, "client_using_space pid %d", cl->pid);

        if(!(sp->space_dead == 0))
          token->flags = token->flags | (unsigned int)0x00000002;

        rv = 1;
      }

    }

  }
  return rv;
}

// close_disks
// file diskio.h line 12
void close_disks(struct sync_disk *disks, signed int num_disks)
{
  signed int d = 0;
  for( ; !(d >= num_disks); d = d + 1)
    if(!((disks + (signed long int)d)->fd == -1))
    {
      close((disks + (signed long int)d)->fd);
      (disks + (signed long int)d)->fd = -1;
    }

}

// close_logging
// file log.c line 278
void close_logging(void)
{
  pthread_mutex_lock(&log_mutex);
  log_thread_done = (unsigned int)1;
  pthread_cond_signal(&log_cond);
  pthread_mutex_unlock(&log_mutex);
  pthread_join(thread_handle, (void **)(void *)0);
  pthread_mutex_lock(&log_mutex);
  closelog();
  if(!(logfile_fp == ((struct _IO_FILE *)NULL)))
  {
    fclose(logfile_fp);
    logfile_fp = (struct _IO_FILE *)(void *)0;
  }

  pthread_mutex_unlock(&log_mutex);
}

// close_task_aio
// file task.h line 14
void close_task_aio(struct task *task)
{
  struct timespec ts;
  struct io_event event;
  unsigned long int last_warn;
  signed int rv;
  signed int i;
  signed int used;
  signed int warn;
  signed long int return_value_time_1;
  struct aicb *tmp_statement_expression_4;
  if(!(task->use_aio == 0))
  {
    memset((void *)&ts, 0, sizeof(struct timespec) /*16ul*/ );
    ts.tv_sec = (signed long int)task->io_timeout_seconds;
    return_value_time_1=time((signed long int *)(void *)0);
    last_warn = (unsigned long int)return_value_time_1;
    while((_Bool)1)
    {
      warn = 0;
      signed long int return_value_time_3;
      return_value_time_3=time((signed long int *)(void *)0);
      if((unsigned long int)return_value_time_3 + -last_warn >= (unsigned long int)task->io_timeout_seconds)
      {
        signed long int return_value_time_2;
        return_value_time_2=time((signed long int *)(void *)0);
        last_warn = (unsigned long int)return_value_time_2;
        warn = 1;
      }

      used = 0;
      i = 0;
      for( ; !(i >= task->cb_size); i = i + 1)
        if(!((task->callbacks + (signed long int)i)->used == 0))
        {
          used = used + 1;
          if(!(warn == 0))
            log_level((unsigned int)0, (unsigned int)0, task->name, 3, "close_task_aio %d %p busy", i, &task->callbacks[(signed long int)i]);

        }

      if(used == 0)
        break;

      memset((void *)&event, 0, sizeof(struct io_event) /*32ul*/ );
      rv=io_getevents(task->aio_ctx, (signed long int)1, (signed long int)1, &event, &ts);
      if(!(rv == -4))
      {
        if(!(rv >= 0))
          break;

        if(rv == 1)
        {
          struct iocb *ev_iocb = event.obj;
          struct aicb *ev_aicb;
          const struct iocb *__mptr = ev_iocb;
          tmp_statement_expression_4 = (struct aicb *)((char *)__mptr - (signed long int)16ul);
          ev_aicb = tmp_statement_expression_4;
          if(ev_aicb->buf == task->iobuf)
            task->iobuf = (char *)(void *)0;

          log_level((unsigned int)0, (unsigned int)0, task->name, 3, "aio collect %p:%p:%p result %ld:%ld close free", ev_aicb, ev_iocb, ev_aicb->buf, event.res, event.res2);
          ev_aicb->used = 0;
          free((void *)ev_aicb->buf);
          ev_aicb->buf = (char *)(void *)0;
        }

      }

    }
    io_destroy(task->aio_ctx);
    if(!(task->iobuf == ((char *)NULL)))
      free((void *)task->iobuf);

  }


skip_aio:
  ;
  if(!(task->callbacks == ((struct aicb *)NULL)))
    free((void *)task->callbacks);

  task->callbacks = (struct aicb *)(void *)0;
}

// close_token_manager
// file resource.h line 28
void close_token_manager(void)
{
  pthread_mutex_lock(&resource_mutex);
  resource_thread_stop = 1;
  pthread_cond_signal(&resource_cond);
  pthread_mutex_unlock(&resource_mutex);
  pthread_join(resource_pt, (void **)(void *)0);
}

// close_watchdog
// file watchdog.h line 18
void close_watchdog(void)
{
  if(!(com.use_watchdog == 0))
  {
    wdmd_refcount_clear(daemon_wdmd_con);
    close(daemon_wdmd_con);
  }

}

// close_watchdog_file
// file watchdog.h line 15
void close_watchdog_file(struct space *sp)
{
  if(!(com.use_watchdog == 0))
    close(sp->wd_fd);

}

// cmd_acquire
// file cmd.c line 121
static void cmd_acquire(struct task *task, struct cmd_args *ca)
{
  struct client *cl;
  struct token *token = (struct token *)(void *)0;
  struct token *new_tokens[8l];
  struct sanlk_resource res;
  struct sanlk_options opt;
  struct space space;
  char *opt_str;
  signed int token_len;
  signed int disks_len;
  signed int fd;
  signed int rv;
  signed int i;
  signed int j;
  signed int empty_slots;
  signed int lvl;
  signed int alloc_count = 0;
  signed int acquire_count = 0;
  signed int pos = 0;
  signed int pid_dead = 0;
  signed int new_tokens_count;
  signed int recv_done = 0;
  signed int result = 0;
  signed int cl_ci = ca->ci_target;
  signed int cl_fd = ca->cl_fd;
  signed int cl_pid = ca->cl_pid;
  cl = &client[(signed long int)cl_ci];
  fd = (client + (signed long int)ca->ci_in)->fd;
  new_tokens_count = (signed int)ca->header.data;
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_acquire %d,%d,%d ci_in %d fd %d count %d", cl_ci, cl_fd, cl_pid, ca->ci_in, fd, new_tokens_count);
  unsigned int tmp_post_6;
  signed long int return_value_recv_7;
  if(new_tokens_count >= 9)
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_acquire %d,%d,%d new %d max %d", cl_ci, cl_fd, cl_pid, new_tokens_count, 8);
    result = -7;
  }

  else
  {
    pthread_mutex_lock(&cl->mutex);
    if(!(cl->pid_dead == 0))
    {
      result = -116;
      pthread_mutex_unlock(&cl->mutex);
    }

    else
    {
      empty_slots = 0;
      i = 0;
      for( ; !(i >= 8); i = i + 1)
        if(cl->tokens[(signed long int)i] == ((struct token *)NULL))
          empty_slots = empty_slots + 1;

      pthread_mutex_unlock(&cl->mutex);
      if(!(empty_slots >= new_tokens_count))
      {
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_acquire %d,%d,%d new %d slots %d", cl_ci, cl_fd, cl_pid, new_tokens_count, empty_slots);
        result = -2;
      }

      else
      {
        i = 0;
        for( ; !(i >= new_tokens_count); i = i + 1)
        {
          signed long int return_value_recv_1;
          return_value_recv_1=recv(fd, (void *)&res, sizeof(struct sanlk_resource) /*128ul*/ , 256);
          rv = (signed int)return_value_recv_1;
          if(rv >= 1)
            pos = pos + rv;

          if(!((unsigned long int)rv == sizeof(struct sanlk_resource) /*128ul*/ ))
          {
            signed int *return_value___errno_location_2;
            return_value___errno_location_2=__errno_location();
            log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_acquire %d,%d,%d recv res %d %d", cl_ci, cl_fd, cl_pid, rv, *return_value___errno_location_2);
            result = -107;
            goto done;
          }

          if(res.num_disks == 0u || res.num_disks >= 5u)
          {
            result = -34;
            goto done;
          }

          disks_len = (signed int)((unsigned long int)res.num_disks * sizeof(struct sync_disk) /*1040ul*/ );
          token_len = (signed int)(sizeof(struct token) /*472ul*/  + (unsigned long int)disks_len);
          void *return_value_malloc_3;
          return_value_malloc_3=malloc((unsigned long int)token_len);
          token = (struct token *)return_value_malloc_3;
          if(token == ((struct token *)NULL))
          {
            result = -12;
            goto done;
          }

          memset((void *)token, 0, (unsigned long int)token_len);
          token->disks = (struct sync_disk *)&token->r.disks[(signed long int)0];
          token->r.num_disks = res.num_disks;
          memcpy((void *)token->r.lockspace_name, (const void *)res.lockspace_name, (unsigned long int)48);
          memcpy((void *)token->r.name, (const void *)res.name, (unsigned long int)48);
          if(!((4u & res.flags) == 0u))
            token->r.flags = token->r.flags | (unsigned int)0x4;

          token->acquire_lver = res.lver;
          token->acquire_data64 = res.data64;
          token->acquire_data32 = res.data32;
          token->acquire_flags = res.flags;
          signed long int return_value_recv_4;
          return_value_recv_4=recv(fd, (void *)token->disks, (unsigned long int)disks_len, 256);
          rv = (signed int)return_value_recv_4;
          if(rv >= 1)
            pos = pos + rv;

          if(!(rv == disks_len))
          {
            signed int *return_value___errno_location_5;
            return_value___errno_location_5=__errno_location();
            log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_acquire %d,%d,%d recv disks %d %d", cl_ci, cl_fd, cl_pid, rv, *return_value___errno_location_5);
            free((void *)token);
            result = -107;
            goto done;
          }

          j = 0;
          for( ; !((unsigned int)j >= token->r.num_disks); j = j + 1)
          {
            (token->disks + (signed long int)j)->sector_size = (unsigned int)0;
            (token->disks + (signed long int)j)->fd = -1;
          }
          tmp_post_6 = token_id_counter;
          token_id_counter = token_id_counter + 1u;
          token->token_id = tmp_post_6;
          new_tokens[(signed long int)i] = token;
          alloc_count = alloc_count + 1;
        }
        return_value_recv_7=recv(fd, (void *)&opt, sizeof(struct sanlk_options) /*56ul*/ , 256);
        rv = (signed int)return_value_recv_7;
        if(rv >= 1)
          pos = pos + rv;

        if(!((unsigned long int)rv == sizeof(struct sanlk_options) /*56ul*/ ))
        {
          signed int *return_value___errno_location_8;
          return_value___errno_location_8=__errno_location();
          log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_acquire %d,%d,%d recv opt %d %d", cl_ci, cl_fd, cl_pid, rv, *return_value___errno_location_8);
          result = -107;
          goto done;
        }

        strncpy(cl->owner_name, opt.owner_name, (unsigned long int)48);
        if(!(opt.len == 0u))
        {
          void *return_value_malloc_9;
          return_value_malloc_9=malloc((unsigned long int)opt.len);
          opt_str = (char *)return_value_malloc_9;
          if(opt_str == ((char *)NULL))
          {
            result = -12;
            goto done;
          }

          signed long int return_value_recv_10;
          return_value_recv_10=recv(fd, (void *)opt_str, (unsigned long int)opt.len, 256);
          rv = (signed int)return_value_recv_10;
          if(rv >= 1)
            pos = pos + rv;

          if(!((unsigned int)rv == opt.len))
          {
            signed int *return_value___errno_location_11;
            return_value___errno_location_11=__errno_location();
            log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_acquire %d,%d,%d recv str %d %d", cl_ci, cl_fd, cl_pid, rv, *return_value___errno_location_11);
            free((void *)opt_str);
            result = -107;
            goto done;
          }

        }

        recv_done = 1;
        i = 0;
        for( ; !(i >= new_tokens_count); i = i + 1)
        {
          token = new_tokens[(signed long int)i];
          rv=lockspace_info(token->r.lockspace_name, &space);
          if(!(space.killing_pids == 0) || !(rv >= 0))
          {
            log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "cmd_acquire %d,%d,%d invalid lockspace found %d failed %d name %.48s", cl_ci, cl_fd, cl_pid, rv, space.killing_pids, (const void *)token->r.lockspace_name);
            result = -28;
            goto done;
          }

          token->host_id = space.host_id;
          token->host_generation = space.host_generation;
          token->pid = cl_pid;
          if(!((2u & cl->restricted) == 0u))
            token->flags = token->flags | (unsigned int)0x00000001;

          log_level(space.space_id, token->token_id, (char *)(void *)0, 4, "resource %.48s:%.48s:%.256s:%llu%s for %d,%d,%d", (const void *)token->r.lockspace_name, (const void *)token->r.name, (const void *)token->r.disks[(signed long int)0].path, (unsigned long long int)token->r.disks[(signed long int)0].offset, (token->acquire_flags & (unsigned int)0x4) != 0u ? ":SH" : "", cl_ci, cl_fd, cl_pid);
        }
        i = 0;
        for( ; !(i >= new_tokens_count); i = i + 1)
        {
          token = new_tokens[(signed long int)i];
          rv=acquire_token(task, token);
          if(!(rv >= 0))
          {
            if(!(rv == -17) && !(rv == -16) && !(rv == -11))
            {
              if(rv == -243)
                goto __CPROVER_DUMP_L30;

            }

            else
            {
              lvl = 7;
              goto __CPROVER_DUMP_L32;

            __CPROVER_DUMP_L30:
              ;
              lvl = com.quiet_fail != 0 ? 7 : 3;
              goto __CPROVER_DUMP_L32;
            }
            lvl = 3;

          __CPROVER_DUMP_L32:
            ;
            log_level((unsigned int)0, token->token_id, (char *)(void *)0, lvl, "cmd_acquire %d,%d,%d acquire_token %d", cl_ci, cl_fd, cl_pid, rv);
            result = rv;
            break;
          }

          acquire_count = acquire_count + 1;
        }
      }
    }
  }

done:
  ;
  pthread_mutex_lock(&spaces_mutex);
  pthread_mutex_lock(&cl->mutex);
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_acquire %d,%d,%d result %d pid_dead %d", cl_ci, cl_fd, cl_pid, result, cl->pid_dead);
  pid_dead = cl->pid_dead;
  cl->cmd_active = 0;
  if(pid_dead == 0 && result == 0)
  {
    signed int return_value_check_new_tokens_space_12;
    return_value_check_new_tokens_space_12=check_new_tokens_space(cl, new_tokens, new_tokens_count);
    if(!(return_value_check_new_tokens_space_12 == 0))
    {
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_acquire %d,%d,%d invalid lockspace", cl_ci, cl_fd, cl_pid);
      result = -28;
    }

  }

  if(pid_dead == 0 && result == 0)
  {
    i = 0;
    for( ; !(i >= new_tokens_count); i = i + 1)
    {
      j = 0;
      for( ; !(j >= 8); j = j + 1)
        if(cl->tokens[(signed long int)j] == ((struct token *)NULL))
        {
          cl->tokens[(signed long int)j] = new_tokens[(signed long int)i];
          break;
        }

    }
  }

  pthread_mutex_unlock(&cl->mutex);
  pthread_mutex_unlock(&spaces_mutex);
  if(!(pid_dead == 0) || !(result == 0))
  {
    if(result == 0 && !(pid_dead == 0))
    {
      release_new_tokens(task, new_tokens, alloc_count, acquire_count);
      release_cl_tokens(task, cl);
      client_free(cl_ci);
      result = -25;
    }

    else
      if(pid_dead == 0 && !(result == 0))
        release_new_tokens(task, new_tokens, alloc_count, acquire_count);

      else
        if(!(pid_dead == 0) && !(result == 0))
        {
          release_new_tokens(task, new_tokens, alloc_count, acquire_count);
          release_cl_tokens(task, cl);
          client_free(cl_ci);
        }

  }


reply:
  ;
  if(recv_done == 0)
    client_recv_all(ca->ci_in, &ca->header, pos);

  send_result(fd, &ca->header, result);
  client_resume(ca->ci_in);
}

// cmd_add_lockspace
// file cmd.c line 845
static void cmd_add_lockspace(struct cmd_args *ca)
{
  struct sanlk_lockspace lockspace;
  struct space *sp;
  signed int async = (signed int)(ca->header.cmd_flags & (unsigned int)0x00000001);
  signed int fd;
  signed int rv;
  signed int result;
  fd = (client + (signed long int)ca->ci_in)->fd;
  signed long int return_value_recv_1;
  return_value_recv_1=recv(fd, (void *)&lockspace, sizeof(struct sanlk_lockspace) /*1104ul*/ , 256);
  rv = (signed int)return_value_recv_1;
  if(!((unsigned long int)rv == sizeof(struct sanlk_lockspace) /*1104ul*/ ))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_add_lockspace %d,%d recv %d %d", ca->ci_in, fd, rv, *return_value___errno_location_2);
    result = -107;
    goto reply;
  }

  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_add_lockspace %d,%d %.48s:%llu:%s:%llu flags %x", ca->ci_in, fd, (const void *)lockspace.name, (unsigned long long int)lockspace.host_id, (const void *)lockspace.host_id_disk.path, (unsigned long long int)lockspace.host_id_disk.offset, ca->header.cmd_flags);
  rv=add_lockspace_start(&lockspace, &sp);
  if(!(rv >= 0))
    result = rv;

  else
  {
    if(!(async == 0))
    {
      result = rv;
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_add_lockspace %d,%d async done %d", ca->ci_in, fd, result);
      send_result(fd, &ca->header, result);
      client_resume(ca->ci_in);
      add_lockspace_wait(sp);
      goto __CPROVER_DUMP_L5;
    }

    result=add_lockspace_wait(sp);
  }

reply:
  ;
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_add_lockspace %d,%d done %d", ca->ci_in, fd, result);
  send_result(fd, &ca->header, result);
  client_resume(ca->ci_in);

__CPROVER_DUMP_L5:
  ;
}

// cmd_align
// file cmd.c line 1014
static void cmd_align(struct task *task, struct cmd_args *ca)
{
  struct sanlk_disk disk;
  struct sync_disk sd;
  signed int fd;
  signed int rv;
  signed int result;
  fd = (client + (signed long int)ca->ci_in)->fd;
  signed long int return_value_recv_1;
  return_value_recv_1=recv(fd, (void *)&disk, sizeof(struct sanlk_disk) /*1040ul*/ , 256);
  rv = (signed int)return_value_recv_1;
  if(!((unsigned long int)rv == sizeof(struct sanlk_disk) /*1040ul*/ ))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_align %d,%d recv %d %d", ca->ci_in, fd, rv, *return_value___errno_location_2);
    result = -107;
    goto reply;
  }

  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_align %d,%d", ca->ci_in, fd);
  if(disk.path[0l] == 0)
    result = -19;

  else
  {
    memset((void *)&sd, 0, sizeof(struct sync_disk) /*1040ul*/ );
    memcpy((void *)&sd, (const void *)&disk, sizeof(struct sanlk_disk) /*1040ul*/ );
    sd.fd = -1;
    rv=open_disk(&sd);
    if(!(rv >= 0))
      result = -19;

    else
    {
      result=direct_align(&sd);
      close_disks(&sd, 1);
    }
  }

reply:
  ;
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_align %d,%d done %d", ca->ci_in, fd, result);
  send_result(fd, &ca->header, result);
  client_resume(ca->ci_in);
}

// cmd_examine
// file cmd.c line 796
static void cmd_examine(struct task *task, struct cmd_args *ca)
{
  /* tag-#anon#lUN[lSYM#tag-sanlk_resource#'r'||lSYM#tag-sanlk_lockspace#'s'|] */
union anonymous_18
{
  // r
  struct sanlk_resource r;
  // s
  struct sanlk_lockspace s;
};

/* */
  ;
  union anonymous_18 buf;
  struct sanlk_resource *res = (struct sanlk_resource *)(void *)0;
  struct sanlk_lockspace *ls = (struct sanlk_lockspace *)(void *)0;
  char *space_name = (char *)(void *)0;
  char *res_name = (char *)(void *)0;
  signed int fd;
  signed int rv;
  signed int result;
  signed int count = 0;
  signed int datalen;
  fd = (client + (signed long int)ca->ci_in)->fd;
  if(ca->header.cmd == 16u)
  {
    datalen = (signed int)sizeof(struct sanlk_resource) /*128ul*/ ;
    res = &buf.r;
  }

  else
  {
    datalen = (signed int)sizeof(struct sanlk_lockspace) /*1104ul*/ ;
    ls = &buf.s;
  }
  signed long int return_value_recv_1;
  return_value_recv_1=recv(fd, (void *)&buf, (unsigned long int)datalen, 256);
  rv = (signed int)return_value_recv_1;
  if(!(rv == datalen))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_examine %d,%d recv %d %d", ca->ci_in, fd, rv, *return_value___errno_location_2);
    result = -107;
    goto reply;
  }

  if(!(res == ((struct sanlk_resource *)NULL)))
  {
    space_name = res->lockspace_name;
    res_name = res->name;
  }

  else
    space_name = ls->name;
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_examine %d,%d %.48s %.48s", ca->ci_in, fd, space_name, res_name != ((char *)NULL) ? res_name : "");
  count=set_resource_examine(space_name, res_name);
  result = 0;

reply:
  ;
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_examine %d,%d done %d", ca->ci_in, fd, count);
  send_result(fd, &ca->header, result);
  client_resume(ca->ci_in);
}

// cmd_host_status
// file cmd.c line 1547
static void cmd_host_status(signed int fd, struct sm_header *h_recv)
{
  struct sm_header h;
  struct sanlk_lockspace lockspace;
  struct space *sp;
  struct host_status *hs;
  struct host_status *status = (struct host_status *)(void *)0;
  signed int status_len;
  signed int i;
  signed int rv;
  memset((void *)&h, 0, sizeof(struct sm_header) /*32ul*/ );
  memcpy((void *)&h, (const void *)h_recv, sizeof(struct sm_header) /*32ul*/ );
  h.length = (unsigned int)sizeof(struct sm_header) /*32ul*/ ;
  h.data = (unsigned int)0;
  status_len = (signed int)(sizeof(struct host_status) /*64ul*/  * (unsigned long int)2000);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)status_len);
  status = (struct host_status *)return_value_malloc_1;
  signed long int return_value_recv_2;
  if(status == ((struct host_status *)NULL))
    h.data = (unsigned int)-12;

  else
  {
    return_value_recv_2=recv(fd, (void *)&lockspace, sizeof(struct sanlk_lockspace) /*1104ul*/ , 256);
    rv = (signed int)return_value_recv_2;
    if(!((unsigned long int)rv == sizeof(struct sanlk_lockspace) /*1104ul*/ ))
      h.data = (unsigned int)-107;

    else
    {
      pthread_mutex_lock(&spaces_mutex);
      sp=find_lockspace(lockspace.name);
      if(!(sp == ((struct space *)NULL)))
        memcpy((void *)status, (const void *)&sp->host_status, (unsigned long int)status_len);

      pthread_mutex_unlock(&spaces_mutex);
      if(sp == ((struct space *)NULL))
        h.data = (unsigned int)-28;

      else
      {
        send(fd, (const void *)&h, sizeof(struct sm_header) /*32ul*/ , 16384);
        i = 0;
        for( ; !(i >= 2000); i = i + 1)
        {
          hs = &status[(signed long int)i];
          if(hs->last_live == 0ul)
          {
            if(hs->owner_id == 0ul)
              goto __CPROVER_DUMP_L7;

          }

          send_state_host(fd, hs, i + 1);

        __CPROVER_DUMP_L7:
          ;
        }
        if(!(status == ((struct host_status *)NULL)))
          free((void *)status);

        goto __CPROVER_DUMP_L12;
      }
    }
  }

fail:
  ;
  send(fd, (const void *)&h, sizeof(struct sm_header) /*32ul*/ , 16384);
  if(!(status == ((struct host_status *)NULL)))
    free((void *)status);


__CPROVER_DUMP_L12:
  ;
}

// cmd_init_lockspace
// file cmd.c line 1057
static void cmd_init_lockspace(struct task *task, struct cmd_args *ca)
{
  struct sanlk_lockspace lockspace;
  struct sync_disk sd;
  signed int fd;
  signed int rv;
  signed int result;
  fd = (client + (signed long int)ca->ci_in)->fd;
  signed long int return_value_recv_1;
  return_value_recv_1=recv(fd, (void *)&lockspace, sizeof(struct sanlk_lockspace) /*1104ul*/ , 256);
  rv = (signed int)return_value_recv_1;
  if(!((unsigned long int)rv == sizeof(struct sanlk_lockspace) /*1104ul*/ ))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_init_lockspace %d,%d recv %d %d", ca->ci_in, fd, rv, *return_value___errno_location_2);
    result = -107;
    goto reply;
  }

  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_init_lockspace %d,%d %.48s:%llu:%s:%llu", ca->ci_in, fd, (const void *)lockspace.name, (unsigned long long int)lockspace.host_id, (const void *)lockspace.host_id_disk.path, (unsigned long long int)lockspace.host_id_disk.offset);
  if(lockspace.host_id_disk.path[0l] == 0)
    result = -19;

  else
  {
    memset((void *)&sd, 0, sizeof(struct sync_disk) /*1040ul*/ );
    memcpy((void *)&sd, (const void *)&lockspace.host_id_disk, sizeof(struct sanlk_disk) /*1040ul*/ );
    sd.fd = -1;
    rv=open_disk(&sd);
    if(!(rv >= 0))
      result = -19;

    else
    {
      result=delta_lease_init(task, &sd, lockspace.name, (signed int)ca->header.data);
      close_disks(&sd, 1);
    }
  }

reply:
  ;
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_init_lockspace %d,%d done %d", ca->ci_in, fd, result);
  send_result(fd, &ca->header, result);
  client_resume(ca->ci_in);
}

// cmd_init_resource
// file cmd.c line 1104
static void cmd_init_resource(struct task *task, struct cmd_args *ca)
{
  struct token *token = (struct token *)(void *)0;
  struct sanlk_resource res;
  signed int token_len;
  signed int disks_len;
  signed int j;
  signed int fd;
  signed int rv;
  signed int result;
  fd = (client + (signed long int)ca->ci_in)->fd;
  signed long int return_value_recv_1;
  return_value_recv_1=recv(fd, (void *)&res, sizeof(struct sanlk_resource) /*128ul*/ , 256);
  rv = (signed int)return_value_recv_1;
  if(!((unsigned long int)rv == sizeof(struct sanlk_resource) /*128ul*/ ))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_init_resource %d,%d recv %d %d", ca->ci_in, fd, rv, *return_value___errno_location_2);
    result = -107;
    goto reply;
  }

  void *return_value_malloc_3;
  signed long int return_value_recv_4;
  if(res.num_disks == 0u || res.num_disks >= 5u)
    result = -34;

  else
  {
    disks_len = (signed int)((unsigned long int)res.num_disks * sizeof(struct sync_disk) /*1040ul*/ );
    token_len = (signed int)(sizeof(struct token) /*472ul*/  + (unsigned long int)disks_len);
    return_value_malloc_3=malloc((unsigned long int)token_len);
    token = (struct token *)return_value_malloc_3;
    if(token == ((struct token *)NULL))
      result = -12;

    else
    {
      memset((void *)token, 0, (unsigned long int)token_len);
      token->disks = (struct sync_disk *)&token->r.disks[(signed long int)0];
      token->r.num_disks = res.num_disks;
      memcpy((void *)token->r.lockspace_name, (const void *)res.lockspace_name, (unsigned long int)48);
      memcpy((void *)token->r.name, (const void *)res.name, (unsigned long int)48);
      return_value_recv_4=recv(fd, (void *)token->disks, (unsigned long int)disks_len, 256);
      rv = (signed int)return_value_recv_4;
      if(!(rv == disks_len))
        result = -107;

      else
      {
        j = 0;
        for( ; !((unsigned int)j >= token->r.num_disks); j = j + 1)
        {
          (token->disks + (signed long int)j)->sector_size = (unsigned int)0;
          (token->disks + (signed long int)j)->fd = -1;
        }
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_init_resource %d,%d %.48s:%.48s:%.256s:%llu", ca->ci_in, fd, (const void *)token->r.lockspace_name, (const void *)token->r.name, (const void *)(token->disks + (signed long int)0)->path, (unsigned long long int)token->r.disks[(signed long int)0].offset);
        rv=open_disks(token->disks, (signed int)token->r.num_disks);
        if(!(rv >= 0))
          result = rv;

        else
        {
          result=paxos_lease_init(task, token, (signed int)ca->header.data, (signed int)ca->header.data2);
          close_disks(token->disks, (signed int)token->r.num_disks);
        }
      }
    }
  }

reply:
  ;
  if(!(token == ((struct token *)NULL)))
    free((void *)token);

  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_init_resource %d,%d done %d", ca->ci_in, fd, result);
  send_result(fd, &ca->header, result);
  client_resume(ca->ci_in);
}

// cmd_inq_lockspace
// file cmd.c line 891
static void cmd_inq_lockspace(struct cmd_args *ca)
{
  struct sanlk_lockspace lockspace;
  signed int fd;
  signed int rv;
  signed int result;
  fd = (client + (signed long int)ca->ci_in)->fd;
  signed long int return_value_recv_1;
  return_value_recv_1=recv(fd, (void *)&lockspace, sizeof(struct sanlk_lockspace) /*1104ul*/ , 256);
  rv = (signed int)return_value_recv_1;
  if(!((unsigned long int)rv == sizeof(struct sanlk_lockspace) /*1104ul*/ ))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_inq_lockspace %d,%d recv %d %d", ca->ci_in, fd, rv, *return_value___errno_location_2);
    result = -107;
    goto reply;
  }

  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_inq_lockspace %d,%d %.48s:%llu:%s:%llu", ca->ci_in, fd, (const void *)lockspace.name, (unsigned long long int)lockspace.host_id, (const void *)lockspace.host_id_disk.path, (unsigned long long int)lockspace.host_id_disk.offset);
  result=inq_lockspace(&lockspace);

reply:
  ;
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_inq_lockspace %d,%d done %d", ca->ci_in, fd, result);
  send_result(fd, &ca->header, result);
  client_resume(ca->ci_in);
}

// cmd_inquire
// file cmd.c line 569
static void cmd_inquire(struct task *task, struct cmd_args *ca)
{
  struct sm_header h;
  struct token *token;
  struct client *cl;
  char *state = (char *)(void *)0;
  char *str;
  signed int state_maxlen = 0;
  signed int state_strlen = 0;
  signed int res_count = 0;
  signed int cat_count = 0;
  signed int fd;
  signed int i;
  signed int rv;
  signed int pid_dead;
  signed int result = 0;
  signed int cl_ci = ca->ci_target;
  signed int cl_fd = ca->cl_fd;
  signed int cl_pid = ca->cl_pid;
  cl = &client[(signed long int)cl_ci];
  fd = (client + (signed long int)ca->ci_in)->fd;
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_inquire %d,%d,%d ci_in %d fd %d", cl_ci, cl_fd, cl_pid, ca->ci_in, fd);
  pthread_mutex_lock(&cl->mutex);
  void *return_value_malloc_1;
  unsigned long int return_value_strlen_5;
  if(!(cl->pid_dead == 0))
    result = -116;

  else
  {
    i = 0;
    for( ; !(i >= 8); i = i + 1)
      if(!(cl->tokens[(signed long int)i] == ((struct token *)NULL)))
        res_count = res_count + 1;

    if(res_count == 0)
      result = 0;

    else
    {
      state_maxlen = res_count * (4400 + 1);
      return_value_malloc_1=malloc((unsigned long int)state_maxlen);
      state = (char *)return_value_malloc_1;
      if(state == ((char *)NULL))
        result = -12;

      else
      {
        memset((void *)state, 0, (unsigned long int)state_maxlen);
        i = 0;
        for( ; !(i >= 8); i = i + 1)
        {
          token = cl->tokens[(signed long int)i];
          if(!(token == ((struct token *)NULL)))
          {
            if(cat_count >= res_count)
            {
              log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_inquire %d,%d,%d count changed %d %d", cl_ci, cl_fd, cl_pid, res_count, cat_count);
              result = -2;
              goto done;
            }

            str = (char *)(void *)0;
            rv=sanlock_res_to_str(&token->r, &str);
            if(str == ((char *)NULL) || !(rv >= 0))
            {
              log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "cmd_inquire %d,%d,%d res_to_str %d", cl_ci, cl_fd, cl_pid, rv);
              result = -79;
              goto done;
            }

            unsigned long int return_value_strlen_3;
            return_value_strlen_3=strlen(str);
            if(return_value_strlen_3 >= 4400ul)
            {
              unsigned long int return_value_strlen_2;
              return_value_strlen_2=strlen(str);
              log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "cmd_inquire %d,%d,%d strlen %zu", cl_ci, cl_fd, cl_pid, return_value_strlen_2);
              free((void *)str);
              result = -80;
              goto done;
            }

            char *return_value_strstr_4;
            return_value_strstr_4=strstr(str, " ");
            if(!(return_value_strstr_4 == ((char *)NULL)))
            {
              log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "cmd_inquire %d,%d,%d str space", cl_ci, cl_fd, cl_pid);
              free((void *)str);
              result = -81;
              goto done;
            }

            if(!(cat_count == 0))
              strcat(state, " ");

            strcat(state, str);
            cat_count = cat_count + 1;
            free((void *)str);
          }

        }
        state[(signed long int)(state_maxlen - 1)] = (char)0;
        return_value_strlen_5=strlen(state);
        state_strlen = (signed int)return_value_strlen_5;
        result = 0;
      }
    }
  }

done:
  ;
  pid_dead = cl->pid_dead;
  cl->cmd_active = 0;
  pthread_mutex_unlock(&cl->mutex);
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_inquire %d,%d,%d result %d pid_dead %d res_count %d cat_count %d strlen %d", cl_ci, cl_fd, cl_pid, result, pid_dead, res_count, cat_count, state_strlen);
  if(!(pid_dead == 0))
  {
    release_cl_tokens(task, cl);
    client_free(cl_ci);
  }

  memcpy((void *)&h, (const void *)&ca->header, sizeof(struct sm_header) /*32ul*/ );
  h.data = (unsigned int)result;
  h.data2 = (unsigned int)res_count;
  if(!(state == ((char *)NULL)))
  {
    h.length = (unsigned int)(sizeof(struct sm_header) /*32ul*/  + (unsigned long int)state_strlen + (unsigned long int)1);
    send(fd, (const void *)&h, sizeof(struct sm_header) /*32ul*/ , 16384);
    send(fd, (const void *)state, (unsigned long int)(state_strlen + 1), 16384);
    free((void *)state);
  }

  else
  {
    h.length = (unsigned int)sizeof(struct sm_header) /*32ul*/ ;
    send(fd, (const void *)&h, sizeof(struct sm_header) /*32ul*/ , 16384);
  }
  client_resume(ca->ci_in);
}

// cmd_lockspace
// file client.c line 119
static signed int cmd_lockspace(signed int cmd, struct sanlk_lockspace *ls, unsigned int flags)
{
  signed int rv;
  signed int fd;
  rv=connect_socket(&fd);
  signed long int return_value_send_1;
  if(!(rv >= 0))
    return rv;

  else
  {
    rv=send_header(fd, cmd, flags, (signed int)sizeof(struct sanlk_lockspace) /*1104ul*/ , (unsigned int)0, (unsigned int)0);
    if(rv >= 0)
    {
      return_value_send_1=send(fd, (void *)ls, sizeof(struct sanlk_lockspace) /*1104ul*/ , 0);
      rv = (signed int)return_value_send_1;
      if(!(rv >= 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        rv = -(*return_value___errno_location_2);
        goto out;
      }

      rv=recv_result(fd);
    }


  out:
    ;
    close(fd);
    return rv;
  }
}

// cmd_log_dump
// file cmd.c line 1607
static void cmd_log_dump(signed int fd, struct sm_header *h_recv)
{
  signed int len;
  copy_log_dump(send_log_dump, &len);
  h_recv->data = (unsigned int)len;
  send(fd, (const void *)h_recv, sizeof(struct sm_header) /*32ul*/ , 16384);
  send(fd, (const void *)send_log_dump, (unsigned long int)len, 16384);
}

// cmd_release
// file cmd.c line 466
static void cmd_release(struct task *task, struct cmd_args *ca)
{
  struct client *cl;
  struct token *token;
  struct token *rem_tokens[8l];
  struct sanlk_resource res;
  signed int fd;
  signed int rv;
  signed int i;
  signed int j;
  signed int found;
  signed int pid_dead;
  signed int rem_tokens_count = 0;
  signed int result = 0;
  signed int cl_ci = ca->ci_target;
  signed int cl_fd = ca->cl_fd;
  signed int cl_pid = ca->cl_pid;
  cl = &client[(signed long int)cl_ci];
  fd = (client + (signed long int)ca->ci_in)->fd;
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_release %d,%d,%d ci_in %d fd %d count %d flags %x", cl_ci, cl_fd, cl_pid, ca->ci_in, fd, ca->header.data, ca->header.cmd_flags);
  signed int tmp_post_1;
  signed int tmp_post_6;
  if(!((1u & ca->header.cmd_flags) == 0u))
  {
    pthread_mutex_lock(&cl->mutex);
    j = 0;
    for( ; !(j >= 8); j = j + 1)
    {
      token = cl->tokens[(signed long int)j];
      if(!(token == ((struct token *)NULL)))
      {
        tmp_post_1 = rem_tokens_count;
        rem_tokens_count = rem_tokens_count + 1;
        rem_tokens[(signed long int)tmp_post_1] = token;
        cl->tokens[(signed long int)j] = (struct token *)(void *)0;
      }

    }
    pthread_mutex_unlock(&cl->mutex);
  }

  else
  {
    i = 0;
    for( ; !((unsigned int)i >= ca->header.data); i = i + 1)
    {
      signed long int return_value_recv_2;
      return_value_recv_2=recv(fd, (void *)&res, sizeof(struct sanlk_resource) /*128ul*/ , 256);
      rv = (signed int)return_value_recv_2;
      if(!((unsigned long int)rv == sizeof(struct sanlk_resource) /*128ul*/ ))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_release %d,%d,%d recv res %d %d", cl_ci, cl_fd, cl_pid, rv, *return_value___errno_location_3);
        result = -107;
        break;
      }

      found = 0;
      pthread_mutex_lock(&cl->mutex);
      j = 0;
      for( ; !(j >= 8); j = j + 1)
      {
        token = cl->tokens[(signed long int)j];
        if(!(token == ((struct token *)NULL)))
        {
          signed int return_value_memcmp_4;
          return_value_memcmp_4=memcmp((const void *)token->r.lockspace_name, (const void *)res.lockspace_name, (unsigned long int)48);
          if(return_value_memcmp_4 == 0)
          {
            signed int return_value_memcmp_5;
            return_value_memcmp_5=memcmp((const void *)token->r.name, (const void *)res.name, (unsigned long int)48);
            if(return_value_memcmp_5 == 0)
            {
              tmp_post_6 = rem_tokens_count;
              rem_tokens_count = rem_tokens_count + 1;
              rem_tokens[(signed long int)tmp_post_6] = token;
              cl->tokens[(signed long int)j] = (struct token *)(void *)0;
              found = 1;
              break;
            }

          }

        }

      }
      pthread_mutex_unlock(&cl->mutex);
      if(found == 0)
      {
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_release %d,%d,%d no resource %.48s", cl_ci, cl_fd, cl_pid, (const void *)res.name);
        result = -1;
      }

    }
  }

do_remove:
  ;
  i = 0;
  for( ; !(i >= rem_tokens_count); i = i + 1)
  {
    token = rem_tokens[(signed long int)i];
    rv=release_token(task, token);
    if(!(rv >= 0))
      result = rv;

    free((void *)token);
  }
  pthread_mutex_lock(&cl->mutex);
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_release %d,%d,%d result %d pid_dead %d count %d", cl_ci, cl_fd, cl_pid, result, cl->pid_dead, rem_tokens_count);
  pid_dead = cl->pid_dead;
  cl->cmd_active = 0;
  pthread_mutex_unlock(&cl->mutex);
  if(!(pid_dead == 0))
  {
    release_cl_tokens(task, cl);
    client_free(cl_ci);
  }

  send_result(fd, &ca->header, result);
  client_resume(ca->ci_in);
}

// cmd_rem_lockspace
// file cmd.c line 965
static void cmd_rem_lockspace(struct cmd_args *ca)
{
  struct sanlk_lockspace lockspace;
  signed int async = (signed int)(ca->header.cmd_flags & (unsigned int)0x00000001);
  signed int fd;
  signed int rv;
  signed int result;
  unsigned int space_id;
  fd = (client + (signed long int)ca->ci_in)->fd;
  signed long int return_value_recv_1;
  return_value_recv_1=recv(fd, (void *)&lockspace, sizeof(struct sanlk_lockspace) /*1104ul*/ , 256);
  rv = (signed int)return_value_recv_1;
  if(!((unsigned long int)rv == sizeof(struct sanlk_lockspace) /*1104ul*/ ))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_rem_lockspace %d,%d recv %d %d", ca->ci_in, fd, rv, *return_value___errno_location_2);
    result = -107;
    goto reply;
  }

  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_rem_lockspace %d,%d %.48s flags %x", ca->ci_in, fd, (const void *)lockspace.name, ca->header.cmd_flags);
  if(!((2u & ca->header.cmd_flags) == 0u))
  {
    signed int return_value_lockspace_is_used_3;
    return_value_lockspace_is_used_3=lockspace_is_used(&lockspace);
    if(!(return_value_lockspace_is_used_3 == 0))
    {
      result = -16;
      goto reply;
    }

  }

  rv=rem_lockspace_start(&lockspace, &space_id);
  if(!(rv >= 0))
    result = rv;

  else
  {
    if(!(async == 0))
    {
      result = rv;
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_rem_lockspace %d,%d async done %d", ca->ci_in, fd, result);
      send_result(fd, &ca->header, result);
      client_resume(ca->ci_in);
      rem_lockspace_wait(&lockspace, space_id);
      goto __CPROVER_DUMP_L7;
    }

    result=rem_lockspace_wait(&lockspace, space_id);
  }

reply:
  ;
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_rem_lockspace %d,%d done %d", ca->ci_in, fd, result);
  send_result(fd, &ca->header, result);
  client_resume(ca->ci_in);

__CPROVER_DUMP_L7:
  ;
}

// cmd_request
// file cmd.c line 699
static void cmd_request(struct task *task, struct cmd_args *ca)
{
  struct token *token;
  struct sanlk_resource res;
  unsigned long int owner_id;
  unsigned int force_mode;
  signed int token_len;
  signed int disks_len;
  signed int j;
  signed int fd;
  signed int rv;
  signed int error;
  signed int result;
  fd = (client + (signed long int)ca->ci_in)->fd;
  force_mode = ca->header.data;
  signed long int return_value_recv_1;
  return_value_recv_1=recv(fd, (void *)&res, sizeof(struct sanlk_resource) /*128ul*/ , 256);
  rv = (signed int)return_value_recv_1;
  if(!((unsigned long int)rv == sizeof(struct sanlk_resource) /*128ul*/ ))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd_request %d,%d recv %d %d", ca->ci_in, fd, rv, *return_value___errno_location_2);
    result = -107;
    goto reply;
  }

  void *return_value_malloc_3;
  signed long int return_value_recv_4;
  if(res.num_disks == 0u || res.num_disks >= 5u)
    result = -34;

  else
  {
    disks_len = (signed int)((unsigned long int)res.num_disks * sizeof(struct sync_disk) /*1040ul*/ );
    token_len = (signed int)(sizeof(struct token) /*472ul*/  + (unsigned long int)disks_len);
    return_value_malloc_3=malloc((unsigned long int)token_len);
    token = (struct token *)return_value_malloc_3;
    if(token == ((struct token *)NULL))
      result = -12;

    else
    {
      memset((void *)token, 0, (unsigned long int)token_len);
      token->disks = (struct sync_disk *)&token->r.disks[(signed long int)0];
      token->r.num_disks = res.num_disks;
      memcpy((void *)token->r.lockspace_name, (const void *)res.lockspace_name, (unsigned long int)48);
      memcpy((void *)token->r.name, (const void *)res.name, (unsigned long int)48);
      token->acquire_lver = res.lver;
      token->acquire_data64 = res.data64;
      token->acquire_data32 = res.data32;
      token->acquire_flags = res.flags;
      return_value_recv_4=recv(fd, (void *)token->disks, (unsigned long int)disks_len, 256);
      rv = (signed int)return_value_recv_4;
      if(!(rv == disks_len))
        result = -107;

      else
      {
        j = 0;
        for( ; !((unsigned int)j >= token->r.num_disks); j = j + 1)
        {
          (token->disks + (signed long int)j)->sector_size = (unsigned int)0;
          (token->disks + (signed long int)j)->fd = -1;
        }
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_request %d,%d force_mode %u %.48s:%.48s:%.256s:%llu", ca->ci_in, fd, force_mode, (const void *)token->r.lockspace_name, (const void *)token->r.name, (const void *)(token->disks + (signed long int)0)->path, (unsigned long long int)token->r.disks[(signed long int)0].offset);
        error=request_token(task, token, force_mode, &owner_id);
        if(!(error >= 0))
          result = error;

        else
        {
          result = 0;
          if(token->acquire_lver == 0ul)
          {
            if(force_mode == 0u)
              goto reply_free;

          }

          if(!(owner_id == 0ul))
            host_status_set_bit(token->r.lockspace_name, owner_id);

        }
      }

    reply_free:
      ;
      free((void *)token);
    }
  }

reply:
  ;
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_request %d,%d done %d", ca->ci_in, fd, result);
  send_result(fd, &ca->header, result);
  client_resume(ca->ci_in);
}

// cmd_restrict
// file cmd.c line 1619
static void cmd_restrict(signed int ci, signed int fd, struct sm_header *h_recv)
{
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "cmd_restrict ci %d fd %d pid %d flags %x", ci, fd, (client + (signed long int)ci)->pid, h_recv->cmd_flags);
  (client + (signed long int)ci)->restricted = h_recv->cmd_flags;
  send_result(fd, h_recv, 0);
}

// cmd_status
// file cmd.c line 1500
static void cmd_status(signed int fd, struct sm_header *h_recv, signed int client_maxi)
{
  struct sm_header h;
  struct client *cl;
  struct space *sp;
  signed int ci;
  memset((void *)&h, 0, sizeof(struct sm_header) /*32ul*/ );
  memcpy((void *)&h, (const void *)h_recv, sizeof(struct sm_header) /*32ul*/ );
  h.length = (unsigned int)sizeof(struct sm_header) /*32ul*/ ;
  h.data = (unsigned int)0;
  send(fd, (const void *)&h, sizeof(struct sm_header) /*32ul*/ , 16384);
  send_state_daemon(fd);
  struct space *tmp_statement_expression_1;
  struct space *tmp_statement_expression_2;
  struct space *tmp_statement_expression_3;
  struct space *tmp_statement_expression_4;
  struct space *tmp_statement_expression_5;
  struct space *tmp_statement_expression_6;
  if(!(h_recv->data == 1u))
  {
    ci = 0;
    for( ; client_maxi >= ci; ci = ci + 1)
    {
      cl = &client[(signed long int)ci];
      if(!(cl->used == 0))
        send_state_client(fd, cl, ci);

    }
    if(!(h_recv->data == 2u))
    {
      pthread_mutex_lock(&spaces_mutex);
      const struct list_head *__mptr = (&spaces)->next;
      tmp_statement_expression_1 = (struct space *)((char *)__mptr - (signed long int)0ul);
      sp = tmp_statement_expression_1;
      for( ; !(&sp->list == &spaces); sp = tmp_statement_expression_2)
      {
        send_state_lockspace(fd, sp, "spaces");
        const struct list_head *cmd_status__1__2__2____mptr = sp->list.next;
        tmp_statement_expression_2 = (struct space *)((char *)cmd_status__1__2__2____mptr - (signed long int)0ul);
      }
      const struct list_head *cmd_status__1__3__1____mptr = (&spaces_rem)->next;
      tmp_statement_expression_3 = (struct space *)((char *)cmd_status__1__3__1____mptr - (signed long int)0ul);
      sp = tmp_statement_expression_3;
      for( ; !(&sp->list == &spaces_rem); sp = tmp_statement_expression_4)
      {
        send_state_lockspace(fd, sp, "spaces_rem");
        const struct list_head *cmd_status__1__3__2____mptr = sp->list.next;
        tmp_statement_expression_4 = (struct space *)((char *)cmd_status__1__3__2____mptr - (signed long int)0ul);
      }
      const struct list_head *cmd_status__1__4__1____mptr = (&spaces_rem)->next;
      tmp_statement_expression_5 = (struct space *)((char *)cmd_status__1__4__1____mptr - (signed long int)0ul);
      sp = tmp_statement_expression_5;
      for( ; !(&sp->list == &spaces_rem); sp = tmp_statement_expression_6)
      {
        send_state_lockspace(fd, sp, "spaces_add");
        const struct list_head *cmd_status__1__4__2____mptr = sp->list.next;
        tmp_statement_expression_6 = (struct space *)((char *)cmd_status__1__4__2____mptr - (signed long int)0ul);
      }
      pthread_mutex_unlock(&spaces_mutex);
      if(!(h_recv->data == 3u))
        send_state_resources(fd);

    }

  }

}

// connect_socket
// file client.c line 40
static signed int connect_socket(signed int *sock_fd)
{
  signed int rv;
  signed int s;
  struct sockaddr_un addr;
  s=socket(1, 1, 0);
  signed int *return_value___errno_location_1;
  if(!(s >= 0))
  {
    return_value___errno_location_1=__errno_location();
    return -(*return_value___errno_location_1);
  }

  else
  {
    rv=sanlock_socket_address(&addr);
    if(!(rv >= 0))
      return rv;

    else
    {
      rv=connect(s, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
      if(!(rv >= 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        rv = -(*return_value___errno_location_2);
        close(s);
        return rv;
      }

      *sock_fd = s;
      return 0;
    }
  }
}

// copy_disks
// file resource.c line 502
static void copy_disks(void *dst, void *src, signed int num_disks)
{
  struct sync_disk *d;
  struct sync_disk *s;
  signed int i;
  d = (struct sync_disk *)dst;
  s = (struct sync_disk *)src;
  i = 0;
  for( ; !(i >= num_disks); i = i + 1)
  {
    memcpy((void *)d->path, (const void *)s->path, (unsigned long int)1024);
    d->offset = s->offset;
    d->sector_size = s->sector_size;
    d->fd = -1;
    d = d + 1l;
    s = s + 1l;
  }
}

// copy_log_dump
// file log.c line 189
void copy_log_dump(char *buf, signed int *len)
{
  signed int tail_len;
  pthread_mutex_lock(&log_mutex);
  if(log_point == 0u && log_wrap == 0u)
    *len = 0;

  else
    if(!(log_wrap == 0u))
    {
      tail_len = (signed int)((unsigned int)(1024 * 1024) - log_point);
      memcpy((void *)buf, (const void *)(log_dump + (signed long int)log_point), (unsigned long int)tail_len);
      if(!(log_point == 0u))
        memcpy((void *)(buf + (signed long int)tail_len), (const void *)log_dump, (unsigned long int)log_point);

      *len = 1024 * 1024;
    }

    else
    {
      memcpy((void *)buf, (const void *)log_dump, (unsigned long int)(log_point - (unsigned int)1));
      *len = (signed int)(log_point - (unsigned int)1);
    }
  pthread_mutex_unlock(&log_mutex);
}

// copy_path_in
// file client.c line 249
static void copy_path_in(char *dst, char *src)
{
  signed int i;
  signed int j = 0;
  i = 0;
  unsigned long int return_value_strlen_1;
  signed int tmp_post_2;
  do
  {
    return_value_strlen_1=strlen(src);
    if((unsigned long int)i >= return_value_strlen_1)
      break;

    if(!((signed int)src[(signed long int)i] == 92))
    {
      tmp_post_2 = j;
      j = j + 1;
      dst[(signed long int)tmp_post_2] = src[(signed long int)i];
    }

    i = i + 1;
  }
  while((_Bool)1);
}

// copy_path_out
// file client.c line 236
static void copy_path_out(char *dst, char *src)
{
  signed int i;
  signed int j = 0;
  i = 0;
  unsigned long int return_value_strlen_1;
  signed int tmp_post_2;
  signed int tmp_post_3;
  do
  {
    return_value_strlen_1=strlen(src);
    if((unsigned long int)i >= return_value_strlen_1)
      break;

    if((signed int)src[(signed long int)i] == 58)
    {
      tmp_post_2 = j;
      j = j + 1;
      dst[(signed long int)tmp_post_2] = (char)92;
    }

    tmp_post_3 = j;
    j = j + 1;
    dst[(signed long int)tmp_post_3] = src[(signed long int)i];
    i = i + 1;
  }
  while((_Bool)1);
}

// corrupt_result
// file lockspace.c line 358
static signed int corrupt_result(signed int result)
{
  if(result == -261 || result == -260 || result == -229 || result == -226 || result == -225 || result == -224 || result == -223)
    return result;

  return 0;
}

// crc32c
// file crc32c.c line 96
unsigned int crc32c(unsigned int crc, unsigned char *data, unsigned long int length)
{
  unsigned long int tmp_post_1;
  unsigned char *tmp_post_2;
  do
  {
    tmp_post_1 = length;
    length = length - 1ul;
    if(tmp_post_1 == 0ul)
      break;

    tmp_post_2 = data;
    data = data + 1l;
    crc = crc32c_table[(signed long int)(crc ^ (unsigned int)*tmp_post_2) & 0xFFL] ^ crc >> 8;
  }
  while((_Bool)1);
  return crc;
}

// create_bitmap
// file lockspace.c line 221
static void create_bitmap(struct task *task, struct space *sp, char *bitmap)
{
  unsigned long int now;
  signed int i;
  char c;
  now=monotime();
  pthread_mutex_lock(&sp->mutex);
  i = 0;
  for( ; !(i >= 2000); i = i + 1)
    if(!((unsigned long int)(1 + i) == sp->host_id))
    {
      if(!(sp->host_status[(signed long int)i].set_bit_time == 0ul))
      {
        if(!((unsigned long int)task->request_finish_seconds >= now + -sp->host_status[(signed long int)i].set_bit_time))
        {
          log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "bitmap clear host_id %d", i + 1);
          sp->host_status[(signed long int)i].set_bit_time = (unsigned long int)0;
        }

        else
        {
          set_id_bit(i + 1, bitmap, &c);
          log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "bitmap set host_id %d byte %x", i + 1, c);
        }
      }

    }

  pthread_mutex_unlock(&sp->mutex);
}

// create_watchdog_file
// file watchdog.h line 13
signed int create_watchdog_file(struct space *sp, unsigned long int timestamp)
{
  char name[128l];
  signed int con;
  signed int rv;
  if(com.use_watchdog == 0)
    return 0;

  else
  {
    con=wdmd_connect();
    if(!(con >= 0))
      log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "wdmd connect failed %d", con);

    else
    {
      memset((void *)name, 0, sizeof(char [128l]) /*128ul*/ );
      snprintf(name, (unsigned long int)(128 - 1), "sanlock_%s_hostid%llu", (const void *)sp->space_name, (unsigned long long int)sp->host_id);
      rv=wdmd_register(con, name);
      if(!(rv >= 0))
        log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "wdmd register failed %d", rv);

      else
      {
        rv=wdmd_test_live(con, timestamp, timestamp + (unsigned long int)main_task.id_renewal_fail_seconds);
        if(!(rv >= 0))
          log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "wdmd_test_live failed %d", rv);

        else
        {
          sp->wd_fd = con;
          return 0;
        }
      }

    fail_close:
      ;
      close(con);
    }

  fail:
    ;
    return -1;
  }
}

// dblock_checksum
// file paxos_lease.c line 183
static unsigned int dblock_checksum(struct paxos_dblock *pd)
{
  unsigned int return_value_crc32c_1;
  return_value_crc32c_1=crc32c((unsigned int)~1, (unsigned char *)pd, (unsigned long int)48);
  return return_value_crc32c_1;
}

// dblock_checksum_link1
// file paxos_lease.c line 183
static unsigned int dblock_checksum_link1(struct paxos_dblock *pd_link1)
{
  unsigned int return_value_crc32c_1_link1;
  return_value_crc32c_1_link1=crc32c((unsigned int)~1, (unsigned char *)pd_link1, (unsigned long int)48);
  return return_value_crc32c_1_link1;
}

// delta_lease_acquire
// file delta_lease.c line 191
signed int delta_lease_acquire(struct task *task, struct space *sp, struct sync_disk *disk, char *space_name, char *our_host_name, unsigned long int host_id, struct leader_record *leader_ret)
{
  struct leader_record leader;
  struct leader_record leader1;
  unsigned long int new_ts;
  signed int i;
  signed int error;
  signed int rv;
  signed int delay;
  signed int delta_large_delay;
  log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "delta_acquire %llu begin", (unsigned long long int)host_id);
  error=delta_lease_leader_read(task, disk, space_name, host_id, &leader, "delta_acquire_begin");
  signed int return_value_strncmp_1;
  if(!(error >= 0))
    return error;

  else
  {
    if(!(leader.timestamp == 0ul))
    {
      return_value_strncmp_1=strncmp(leader.resource_name, our_host_name, (unsigned long int)48);
      if(return_value_strncmp_1 == 0)
        log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "delta_acquire %llu fast reacquire", (unsigned long long int)host_id);

      else
      {
        delay = task->host_dead_seconds;
        delta_large_delay = task->id_renewal_seconds + 6 * task->io_timeout_seconds;
        if(!(delay >= delta_large_delay))
          delay = delta_large_delay;

        {
          memcpy((void *)&leader1, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );
          log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "delta_acquire %llu delta_large_delay %d delay %d", (unsigned long long int)host_id, delta_large_delay, delay);
          i = 0;
          for( ; !(i >= delay); i = i + 1)
          {
            if(!(sp->external_remove == 0) || !(external_shutdown == 0))
              return -201;

            sleep((unsigned int)1);
          }
          error=delta_lease_leader_read(task, disk, space_name, host_id, &leader, "delta_acquire_wait");
          if(!(error >= 0))
            return error;

          signed int return_value_memcmp_2;
          return_value_memcmp_2=memcmp((const void *)&leader1, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );
          if(!(return_value_memcmp_2 == 0))
          {
            if(!(leader.timestamp == 0ul))
            {
              log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "delta_acquire %llu busy %llu %llu %llu %.48s", (unsigned long long int)host_id, (unsigned long long int)leader.owner_id, (unsigned long long int)leader.owner_generation, (unsigned long long int)leader.timestamp, (const void *)leader.resource_name);
              return -262;
            }

          }

        }
      }
    }


  write_new:
    ;
    new_ts=monotime();
    leader.timestamp = new_ts;
    leader.owner_id = host_id;
    leader.owner_generation = leader.owner_generation + 1ul;
    snprintf(leader.resource_name, (unsigned long int)48, "%s", our_host_name);
    leader.checksum=leader_checksum(&leader);
    log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "delta_acquire %llu write %llu %llu %llu %.48s", (unsigned long long int)host_id, (unsigned long long int)leader.owner_id, (unsigned long long int)leader.owner_generation, (unsigned long long int)leader.timestamp, (const void *)leader.resource_name);
    rv=write_sector(disk, host_id - (unsigned long int)1, (char *)&leader, (signed int)sizeof(struct leader_record) /*200ul*/ , task, "delta_leader");
    if(!(rv >= 0))
      return rv;

    else
    {
      memcpy((void *)&leader1, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );
      delay = 2 * task->io_timeout_seconds;
      log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "delta_acquire %llu delta_short_delay %d", (unsigned long long int)host_id, delay);
      i = 0;
      for( ; !(i >= delay); i = i + 1)
      {
        if(!(sp->external_remove == 0) || !(external_shutdown == 0))
          return -201;

        sleep((unsigned int)1);
      }
      error=delta_lease_leader_read(task, disk, space_name, host_id, &leader, "delta_acquire_check");
      if(!(error >= 0))
        return error;

      else
      {
        signed int return_value_memcmp_3;
        return_value_memcmp_3=memcmp((const void *)&leader1, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );
        if(!(return_value_memcmp_3 == 0))
        {
          log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "delta_acquire %llu busy %llu %llu %llu %.48s", (unsigned long long int)host_id, (unsigned long long int)leader.owner_id, (unsigned long long int)leader.owner_generation, (unsigned long long int)leader.timestamp, (const void *)leader.resource_name);
          return -262;
        }

        else
        {
          memcpy((void *)leader_ret, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );
          return 1;
        }
      }
    }
  }
}

// delta_lease_init
// file delta_lease.c line 547
signed int delta_lease_init(struct task *task, struct sync_disk *disk, char *space_name, signed int max_hosts)
{
  struct leader_record *leader;
  char *iobuf;
  char **p_iobuf;
  signed int iobuf_len;
  signed int align_size;
  signed int i;
  signed int rv;
  if(max_hosts == 0)
    max_hosts = 2000;

  align_size=direct_align(disk);
  if(!(align_size >= 0))
    return align_size;

  else
    if(!((unsigned int)align_size >= disk->sector_size * (unsigned int)max_hosts))
      return -7;

    else
    {
      iobuf_len = align_size;
      p_iobuf = &iobuf;
      signed int return_value_getpagesize_1;
      return_value_getpagesize_1=getpagesize();
      rv=posix_memalign((void **)(void *)p_iobuf, (unsigned long int)return_value_getpagesize_1, (unsigned long int)iobuf_len);
      if(!(rv == 0))
        return rv;

      else
      {
        memset((void *)iobuf, 0, (unsigned long int)iobuf_len);
        i = 0;
        for( ; !(i >= max_hosts); i = i + 1)
        {
          leader = (struct leader_record *)(iobuf + (signed long int)((unsigned int)i * disk->sector_size));
          leader->magic = (unsigned int)0x12212010;
          leader->version = (unsigned int)(0x00030000 | 0x00000002);
          leader->sector_size = disk->sector_size;
          leader->max_hosts = (unsigned long int)1;
          leader->timestamp = (unsigned long int)0;
          strncpy(leader->space_name, space_name, (unsigned long int)48);
          leader->checksum=leader_checksum(leader);
        }
        rv=write_iobuf(disk->fd, disk->offset, iobuf, iobuf_len, task);
        if(!(rv == -202))
          free((void *)iobuf);

        if(!(rv >= 0))
          return rv;

        else
          return 0;
      }
    }
}

// delta_lease_leader_read
// file delta_lease.c line 150
signed int delta_lease_leader_read(struct task *task, struct sync_disk *disk, char *space_name, unsigned long int host_id, struct leader_record *leader_ret, const char *caller)
{
  struct leader_record leader;
  signed int rv;
  signed int error;
  memset((void *)&leader, 0, sizeof(struct leader_record) /*200ul*/ );
  memset((void *)leader_ret, 0, sizeof(struct leader_record) /*200ul*/ );
  rv=read_sectors(disk, host_id - (unsigned long int)1, (unsigned int)1, (char *)&leader, (signed int)sizeof(struct leader_record) /*200ul*/ , task, "delta_leader");
  if(!(rv >= 0))
    return rv;

  else
  {
    error=verify_leader(disk, space_name, host_id, &leader, caller);
    memcpy((void *)leader_ret, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );
    return error;
  }
}

// delta_lease_release
// file delta_lease.c line 513
signed int delta_lease_release(struct task *task, struct space *sp, struct sync_disk *disk, char *space_name, struct leader_record *leader_last, struct leader_record *leader_ret)
{
  struct leader_record leader;
  unsigned long int host_id;
  signed int rv;
  if(leader_last == ((struct leader_record *)NULL))
    return -22;

  else
  {
    host_id = leader_last->owner_id;
    log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "delta_release %llu begin", (unsigned long long int)host_id);
    memcpy((void *)&leader, (const void *)leader_last, sizeof(struct leader_record) /*200ul*/ );
    leader.timestamp = (unsigned long int)0;
    leader.checksum=leader_checksum(&leader);
    rv=write_sector(disk, host_id - (unsigned long int)1, (char *)&leader, (signed int)sizeof(struct leader_record) /*200ul*/ , task, "delta_leader");
    if(!(rv >= 0))
      return rv;

    else
    {
      memcpy((void *)leader_ret, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );
      return 1;
    }
  }
}

// delta_lease_renew
// file delta_lease.c line 329
signed int delta_lease_renew(struct task *task, struct space *sp, struct sync_disk *disk, char *space_name, char *bitmap, signed int prev_result, signed int *read_result, struct leader_record *leader_last, struct leader_record *leader_ret)
{
  struct leader_record leader;
  char **p_iobuf;
  char **p_wbuf;
  char *wbuf;
  unsigned long int host_id;
  unsigned long int id_offset;
  unsigned long int new_ts;
  signed int rv;
  signed int iobuf_len;
  signed int sector_size;
  signed int io_timeout_save;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  signed int return_value_memcmp_3;
  signed int return_value_memcmp_5;
  if(leader_last == ((struct leader_record *)NULL))
    return -22;

  else
  {
    *read_result = -201;
    host_id = leader_last->owner_id;
    iobuf_len = sp->align_size;
    sector_size = (signed int)disk->sector_size;
    id_offset = (host_id - (unsigned long int)1) * (unsigned long int)sector_size;
    if(!((unsigned long int)iobuf_len >= id_offset))
      return -22;

    else
    {
      if(prev_result == -202)
      {
        if(task->read_iobuf_timeout_aicb == ((struct aicb *)NULL))
          log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "delta_renew reap no aicb");

        else
          if(task->iobuf == ((char *)NULL))
            log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "delta_renew reap no iobuf");

          else
          {
            rv=read_iobuf_reap(disk->fd, disk->offset, task->iobuf, iobuf_len, task);
            log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "delta_renew reap %d", rv);
            if(rv == 0)
            {
              task->read_iobuf_timeout_aicb = (struct aicb *)(void *)0;
              goto read_done;
            }

          }

      skip_reap:
        ;
        task->read_iobuf_timeout_aicb = (struct aicb *)(void *)0;
        task->iobuf = (char *)(void *)0;
      }

      if(!(task->read_iobuf_timeout_aicb == ((struct aicb *)NULL)))
      {
        log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "delta_renew timeout_aicb is unexpectedly %p iobuf %p", task->read_iobuf_timeout_aicb, task->iobuf);
        task->read_iobuf_timeout_aicb = (struct aicb *)(void *)0;
        task->iobuf = (char *)(void *)0;
      }

      if(task->iobuf == ((char *)NULL))
      {
        p_iobuf = &task->iobuf;
        signed int return_value_getpagesize_1;
        return_value_getpagesize_1=getpagesize();
        rv=posix_memalign((void **)(void *)p_iobuf, (unsigned long int)return_value_getpagesize_1, (unsigned long int)iobuf_len);
        if(!(rv == 0))
        {
          log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "dela_renew memalign rv %d", rv);
          rv = -12;
        }

      }

      rv=read_iobuf(disk->fd, disk->offset, task->iobuf, iobuf_len, task);
      if(!(rv == 0))
      {
        log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "delta_renew read rv %d offset %llu %s", rv, (unsigned long long int)disk->offset, (const void *)disk->path);
        return rv;
      }

      else
      {

      read_done:
        ;
        *read_result = 1;
        memcpy((void *)&leader, (const void *)(task->iobuf + (signed long int)id_offset), sizeof(struct leader_record) /*200ul*/ );
        rv=verify_leader(disk, space_name, host_id, &leader, "delta_renew");
        if(!(rv >= 0))
          return rv;

        else
        {
          if(!(leader.owner_id == leader_last->owner_id))
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = leader.owner_generation != leader_last->owner_generation ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_2)
            tmp_if_expr_4 = (_Bool)1;

          else
          {
            return_value_memcmp_3=memcmp((const void *)leader.resource_name, (const void *)leader_last->resource_name, (unsigned long int)48);
            tmp_if_expr_4 = return_value_memcmp_3 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_4)
          {
            log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "delta_renew not owner");
            log_leader_error(0, space_name, host_id, disk, leader_last, "delta_renew_last");
            log_leader_error(0, space_name, host_id, disk, &leader, "delta_renew_read");
            return -260;
          }

          else
            if(prev_result == 1)
            {
              return_value_memcmp_5=memcmp((const void *)&leader, (const void *)leader_last, sizeof(struct leader_record) /*200ul*/ );
              if(return_value_memcmp_5 == 0)
                goto __CPROVER_DUMP_L17;

              log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "delta_renew reread mismatch");
              log_leader_error(0, space_name, host_id, disk, leader_last, "delta_renew_last");
              log_leader_error(0, space_name, host_id, disk, &leader, "delta_renew_read");
              return -261;
            }

            else
            {

            __CPROVER_DUMP_L17:
              ;
              new_ts=monotime();
              if(leader.timestamp >= new_ts)
                log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "delta_renew timestamp too small");

              leader.timestamp = new_ts;
              leader.checksum=leader_checksum(&leader);
              p_wbuf = &wbuf;
              signed int return_value_getpagesize_6;
              return_value_getpagesize_6=getpagesize();
              rv=posix_memalign((void **)(void *)p_wbuf, (unsigned long int)return_value_getpagesize_6, (unsigned long int)sector_size);
              if(!(rv == 0))
              {
                log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "dela_renew write memalign rv %d", rv);
                return -12;
              }

              else
              {
                memset((void *)wbuf, 0, (unsigned long int)sector_size);
                memcpy((void *)wbuf, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );
                memcpy((void *)(wbuf + (signed long int)256), (const void *)bitmap, (unsigned long int)256);
                io_timeout_save = task->io_timeout_seconds;
                task->io_timeout_seconds = task->host_dead_seconds;
                rv=write_iobuf(disk->fd, disk->offset + id_offset, wbuf, sector_size, task);
                if(!(rv == -202))
                  free((void *)wbuf);

                task->io_timeout_seconds = io_timeout_save;
                if(!(rv >= 0))
                  return rv;

                else
                {
                  memcpy((void *)leader_ret, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );
                  return 1;
                }
              }
            }
        }
      }
    }
  }
}

// direct_acquire
// file direct.c line 161
signed int direct_acquire(struct task *task, struct sanlk_resource *res, signed int num_hosts, unsigned long int local_host_id, unsigned long int local_host_generation, struct leader_record *leader_ret)
{
  signed int return_value_do_paxos_action_1;
  return_value_do_paxos_action_1=do_paxos_action(9, task, res, -1, num_hosts, local_host_id, local_host_generation, leader_ret);
  return return_value_do_paxos_action_1;
}

// direct_acquire_id
// file direct.c line 282
signed int direct_acquire_id(struct task *task, struct sanlk_lockspace *ls, char *our_host_name)
{
  signed int return_value_do_delta_action_1;
  return_value_do_delta_action_1=do_delta_action(13, task, ls, -1, our_host_name, (struct leader_record *)(void *)0);
  return return_value_do_delta_action_1;
}

// direct_align
// file direct.h line 41
signed int direct_align(struct sync_disk *disk)
{
  if(disk->sector_size == 512u)
    return 1024 * 1024;

  else
    if(disk->sector_size == 4096u)
      return 8 * 1024 * 1024;

    else
      return -22;
}

// direct_dump
// file direct.c line 429
signed int direct_dump(struct task *task, char *dump_path, signed int force_mode)
{
  char *data;
  char *bitmap;
  char *colon;
  char *off_str;
  struct leader_record *lr;
  struct request_record *rr;
  struct sync_disk sd;
  char sname[49l];
  char rname[49l];
  unsigned long int sector_nr;
  signed int sector_count;
  signed int datalen;
  signed int align_size;
  signed int i;
  signed int rv;
  signed int b;
  memset((void *)&sd, 0, sizeof(struct sync_disk) /*1040ul*/ );
  colon=strstr(dump_path, ":");
  if(!(colon == ((char *)NULL)))
  {
    off_str = colon + (signed long int)1;
    *colon = (char)0;
    signed long long int return_value_atoll_1;
    return_value_atoll_1=atoll(off_str);
    sd.offset = (unsigned long int)return_value_atoll_1;
  }

  strncpy(sd.path, dump_path, (unsigned long int)1024);
  sd.fd = -1;
  rv=open_disk(&sd);
  void *return_value_malloc_2;
  if(!(rv >= 0))
    return -19;

  else
  {
    rv=direct_align(&sd);
    if(rv >= 0)
    {
      align_size = rv;
      datalen = align_size;
      sector_count = (signed int)((unsigned int)align_size / sd.sector_size);
      return_value_malloc_2=malloc((unsigned long int)datalen);
      data = (char *)return_value_malloc_2;
      if(data == ((char *)NULL))
        rv = -12;

      else
      {
        printf("%8s %36s %48s %10s %4s %4s %s", (const void *)"offset", (const void *)"lockspace", (const void *)"resource", (const void *)"timestamp", (const void *)"own", (const void *)"gen", (const void *)"lver");
        if(!(force_mode == 0))
          printf("/req/mode");

        printf("\n");
        sector_nr = (unsigned long int)0;
        for( ; (_Bool)1; sector_nr = sector_nr + (unsigned long int)sector_count)
        {
          memset((void *)sname, 0, sizeof(char [49l]) /*49ul*/ );
          memset((void *)rname, 0, sizeof(char [49l]) /*49ul*/ );
          memset((void *)data, 0, (unsigned long int)sd.sector_size);
          rv=read_sectors(&sd, sector_nr, (unsigned int)sector_count, data, datalen, task, "dump");
          lr = (struct leader_record *)data;
          if(lr->magic == 304160784u)
          {
            i = 0;
            for( ; !(i >= sector_count); i = i + 1)
            {
              lr = (struct leader_record *)(data + (signed long int)((unsigned int)i * sd.sector_size));
              if(!(lr->magic == 0u))
              {
                if(lr->owner_id == 0ul)
                {
                  if(lr->owner_generation == 0ul)
                    goto __CPROVER_DUMP_L11;

                }

                strncpy(sname, lr->space_name, (unsigned long int)48);
                strncpy(rname, lr->resource_name, (unsigned long int)48);
                printf("%08llu %36s %48s %010llu %04llu %04llu", (unsigned long long int)((sector_nr + (unsigned long int)i) * (unsigned long int)sd.sector_size), (const void *)sname, (const void *)rname, (unsigned long long int)lr->timestamp, (unsigned long long int)lr->owner_id, (unsigned long long int)lr->owner_generation);
                if(!(force_mode == 0))
                {
                  bitmap = (char *)lr + (signed long int)256;
                  b = 0;
                  for( ; !(b >= 2000); b = b + 1)
                  {
                    signed int return_value_test_id_bit_3;
                    return_value_test_id_bit_3=test_id_bit(b + 1, bitmap);
                    if(!(return_value_test_id_bit_3 == 0))
                      printf(" %d", b + 1);

                  }
                }

                printf("\n");
              }


            __CPROVER_DUMP_L11:
              ;
            }
          }

          else
            if(lr->magic == 102047760u)
            {
              strncpy(sname, lr->space_name, (unsigned long int)48);
              strncpy(rname, lr->resource_name, (unsigned long int)48);
              printf("%08llu %36s %48s %010llu %04llu %04llu %llu", (unsigned long long int)(sector_nr * (unsigned long int)sd.sector_size), (const void *)sname, (const void *)rname, (unsigned long long int)lr->timestamp, (unsigned long long int)lr->owner_id, (unsigned long long int)lr->owner_generation, (unsigned long long int)lr->lver);
              if(!(force_mode == 0))
              {
                rr = (struct request_record *)(data + (signed long int)sd.sector_size);
                printf("/%llu/%u", (unsigned long long int)rr->lver, rr->force_mode);
              }

              printf("\n");
              i = 0;
              for( ; !((unsigned long int)i >= lr->num_hosts); i = i + 1)
              {
                char *pd = data + (signed long int)((unsigned int)(2 + i) * sd.sector_size);
                struct mode_block *mb = (struct mode_block *)(pd + (signed long int)128);
                if(!((1u & mb->flags) == 0u))
                {
                  printf("                                                                                                          ");
                  printf("%04u %04llu SH\n", i + 1, (unsigned long long int)mb->generation);
                }

              }
            }

            else
              break;
        }
        rv = 0;
        free((void *)data);
      }
    }


  out_close:
    ;
    close_disks(&sd, 1);
    return rv;
  }
}

// direct_init
// file direct.c line 387
signed int direct_init(struct task *task, struct sanlk_lockspace *ls, struct sanlk_resource *res, signed int max_hosts, signed int num_hosts)
{
  signed int rv = -1;
  _Bool tmp_if_expr_1;
  if(!(ls == ((struct sanlk_lockspace *)NULL)))
    tmp_if_expr_1 = ls->host_id_disk.path[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    rv=do_delta_action(18, task, ls, max_hosts, (char *)(void *)0, (struct leader_record *)(void *)0);

  else
    if(!(res == ((struct sanlk_resource *)NULL)))
    {
      if(res->num_disks == 0u)
        return -19;

      if(res->disks[0l].path[0l] == 0)
        return -19;

      rv=do_paxos_action(18, task, res, max_hosts, num_hosts, (unsigned long int)0, (unsigned long int)0, (struct leader_record *)(void *)0);
    }

  return rv;
}

// direct_live_id
// file direct.c line 318
signed int direct_live_id(struct task *task, struct sanlk_lockspace *ls, unsigned long int *timestamp, unsigned long int *owner_id, unsigned long int *owner_generation, signed int *live)
{
  struct leader_record leader_begin;
  struct leader_record leader;
  signed long int start;
  signed int rv;
  rv=do_delta_action(16, task, ls, -1, (char *)(void *)0, &leader_begin);
  if(!(rv >= 0))
    return rv;

  else
  {
    unsigned long int return_value_monotime_1;
    return_value_monotime_1=monotime();
    start = (signed long int)return_value_monotime_1;
    while((_Bool)1)
    {
      sleep((unsigned int)1);
      rv=do_delta_action(16, task, ls, -1, (char *)(void *)0, &leader);
      if(!(rv >= 0))
        return rv;

      if(!(leader.timestamp == leader_begin.timestamp))
      {
        *live = 1;
        break;
      }

      if(!(leader.owner_id == leader_begin.owner_id))
      {
        *live = 2;
        break;
      }

      if(!(leader.owner_generation == leader_begin.owner_generation))
      {
        *live = 3;
        break;
      }

      unsigned long int return_value_monotime_2;
      return_value_monotime_2=monotime();
      if(!((unsigned long int)task->host_dead_seconds >= return_value_monotime_2 + -((unsigned long int)start)))
      {
        *live = 0;
        break;
      }

    }
    *timestamp = leader.timestamp;
    *owner_id = leader.owner_id;
    *owner_generation = leader.owner_generation;
    return 0;
  }
}

// direct_read_id
// file direct.c line 298
signed int direct_read_id(struct task *task, struct sanlk_lockspace *ls, unsigned long int *timestamp, unsigned long int *owner_id, unsigned long int *owner_generation)
{
  struct leader_record leader;
  signed int rv;
  memset((void *)&leader, 0, sizeof(struct leader_record) /*200ul*/ );
  rv=do_delta_action(16, task, ls, -1, (char *)(void *)0, &leader);
  *timestamp = leader.timestamp;
  *owner_id = leader.owner_id;
  *owner_generation = leader.owner_generation;
  return rv;
}

// direct_read_leader
// file direct.c line 411
signed int direct_read_leader(struct task *task, struct sanlk_lockspace *ls, struct sanlk_resource *res, struct leader_record *leader_ret)
{
  signed int rv = -1;
  _Bool tmp_if_expr_1;
  if(!(ls == ((struct sanlk_lockspace *)NULL)))
    tmp_if_expr_1 = ls->host_id_disk.path[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    rv=do_delta_action(20, task, ls, -1, (char *)(void *)0, leader_ret);

  else
    if(!(res == ((struct sanlk_resource *)NULL)))
      rv=do_paxos_action(20, task, res, -1, -1, (unsigned long int)0, (unsigned long int)0, leader_ret);

  return rv;
}

// direct_release
// file direct.c line 174
signed int direct_release(struct task *task, struct sanlk_resource *res, struct leader_record *leader_ret)
{
  signed int return_value_do_paxos_action_1;
  return_value_do_paxos_action_1=do_paxos_action(10, task, res, -1, -1, (unsigned long int)0, (unsigned long int)0, leader_ret);
  return return_value_do_paxos_action_1;
}

// direct_release_id
// file direct.c line 288
signed int direct_release_id(struct task *task, struct sanlk_lockspace *ls)
{
  signed int return_value_do_delta_action_1;
  return_value_do_delta_action_1=do_delta_action(14, task, ls, -1, (char *)(void *)0, (struct leader_record *)(void *)0);
  return return_value_do_delta_action_1;
}

// direct_renew_id
// file direct.c line 293
signed int direct_renew_id(struct task *task, struct sanlk_lockspace *ls)
{
  signed int return_value_do_delta_action_1;
  return_value_do_delta_action_1=do_delta_action(15, task, ls, -1, (char *)(void *)0, (struct leader_record *)(void *)0);
  return return_value_do_delta_action_1;
}

// do_client
// file main.c line 1703
static signed int do_client(void)
{
  struct sanlk_resource **res_args = (struct sanlk_resource **)(void *)0;
  struct sanlk_resource *res;
  char *res_state = (char *)(void *)0;
  signed int i;
  signed int fd;
  signed int rv = 0;
  if(com.action == 8 || com.action == 9)
  {
    if(!(com.num_hosts == 0))
    {
      i = 0;
      for( ; !(i >= com.res_count); i = i + 1)
      {
        res = com.res_args[(signed long int)i];
        res->flags = res->flags | (unsigned int)0x2;
        res->data32 = (unsigned int)com.num_hosts;
      }
    }

  }

  switch(com.action)
  {
    case 1:
    {
      rv=sanlock_status(com.debug, com.sort_arg);
      break;
    }
    case 2:
    {
      rv=sanlock_host_status(com.debug, com.lockspace.name);
      break;
    }
    case 3:
    {
      rv=sanlock_log_dump(1024 * 1024);
      break;
    }
    case 4:
    {
      do
        fprintf(stderr, "shutdown\n");
      while((_Bool)0);
      rv=sanlock_shutdown(com.force_mode);
      do
        fprintf(stderr, "shutdown done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 8:
    {
      do
        fprintf(stderr, "register\n");
      while((_Bool)0);
      fd=sanlock_register();
      do
        fprintf(stderr, "register done %d\n", fd);
      while((_Bool)0);
      if(!(fd >= 0))
        break;

      do
        fprintf(stderr, "acquire fd %d\n", fd);
      while((_Bool)0);
      rv=sanlock_acquire(fd, -1, (unsigned int)0, com.res_count, com.res_args, (struct sanlk_options *)(void *)0);
      do
        fprintf(stderr, "acquire done %d\n", rv);
      while((_Bool)0);
      if(!(rv >= 0))
        break;

      if(command[0l] == 0)
        while((_Bool)1)
          sleep((unsigned int)10);

      execv(command, cmd_argv);
      perror("execv failed");
      break;
    }
    case 5:
    {
      do
        fprintf(stderr, "add_lockspace\n");
      while((_Bool)0);
      rv=sanlock_add_lockspace(&com.lockspace, (unsigned int)0);
      do
        fprintf(stderr, "add_lockspace done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 6:
    {
      do
        fprintf(stderr, "inq_lockspace\n");
      while((_Bool)0);
      rv=sanlock_inq_lockspace(&com.lockspace, (unsigned int)0);
      do
        fprintf(stderr, "inq_lockspace done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 7:
    {
      do
        fprintf(stderr, "rem_lockspace\n");
      while((_Bool)0);
      rv=sanlock_rem_lockspace(&com.lockspace, (unsigned int)0);
      do
        fprintf(stderr, "rem_lockspace done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 9:
    {
      do
        fprintf(stderr, "acquire pid %d\n", com.pid);
      while((_Bool)0);
      rv=sanlock_acquire(-1, com.pid, (unsigned int)0, com.res_count, com.res_args, (struct sanlk_options *)(void *)0);
      do
        fprintf(stderr, "acquire done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 10:
    {
      do
        fprintf(stderr, "release pid %d\n", com.pid);
      while((_Bool)0);
      rv=sanlock_release(-1, com.pid, (unsigned int)0, com.res_count, com.res_args);
      do
        fprintf(stderr, "release done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 11:
    {
      do
        fprintf(stderr, "inquire pid %d\n", com.pid);
      while((_Bool)0);
      rv=sanlock_inquire(-1, com.pid, (unsigned int)0, &com.res_count, &res_state);
      do
        fprintf(stderr, "inquire done %d res_count %d\n", rv, com.res_count);
      while((_Bool)0);
      if(!(rv >= 0))
        break;

      do
        fprintf(stderr, "\"%s\"\n", res_state);
      while((_Bool)0);
      if(com.debug == 0)
        break;

      com.res_count = 0;
      rv=sanlock_state_to_args(res_state, &com.res_count, &res_args);
      do
        fprintf(stderr, "\nstate_to_args done %d res_count %d\n", rv, com.res_count);
      while((_Bool)0);
      if(!(rv >= 0))
        break;

      free((void *)res_state);
      res_state = (char *)(void *)0;
      i = 0;
      for( ; !(i >= com.res_count); i = i + 1)
      {
        res = res_args[(signed long int)i];
        do
          fprintf(stderr, "\"%s:%s:%s:%llu:%llu\"\n", (const void *)res->lockspace_name, (const void *)res->name, (const void *)res->disks[(signed long int)0].path, (unsigned long long int)res->disks[(signed long int)0].offset, (unsigned long long int)res->lver);
        while((_Bool)0);
      }
      rv=sanlock_args_to_state(com.res_count, res_args, &res_state);
      do
        fprintf(stderr, "\nargs_to_state done %d\n", rv);
      while((_Bool)0);
      if(!(rv >= 0))
        break;

      do
        fprintf(stderr, "\"%s\"\n", res_state);
      while((_Bool)0);
      break;
    }
    case 12:
    {
      do
        fprintf(stderr, "request\n");
      while((_Bool)0);
      rv=sanlock_request((unsigned int)0, com.force_mode, com.res_args[(signed long int)0]);
      do
        fprintf(stderr, "request done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 23:
    {
      do
        fprintf(stderr, "examine\n");
      while((_Bool)0);
      if(!(com.lockspace.host_id_disk.path[0l] == 0))
        rv=sanlock_examine((unsigned int)0, &com.lockspace, (struct sanlk_resource *)(void *)0);

      else
        rv=sanlock_examine((unsigned int)0, (struct sanlk_lockspace *)(void *)0, com.res_args[(signed long int)0]);
      do
        fprintf(stderr, "examine done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 22:
    {
      do
        fprintf(stderr, "align\n");
      while((_Bool)0);
      rv=sanlock_align(&com.lockspace.host_id_disk);
      do
        fprintf(stderr, "align done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 21:
    {
      do
        fprintf(stderr, "init\n");
      while((_Bool)0);
      if(!(com.lockspace.host_id_disk.path[0l] == 0))
        rv=sanlock_init(&com.lockspace, (struct sanlk_resource *)(void *)0, com.max_hosts, com.num_hosts);

      else
        rv=sanlock_init((struct sanlk_lockspace *)(void *)0, com.res_args[(signed long int)0], com.max_hosts, com.num_hosts);
      do
        fprintf(stderr, "init done %d\n", rv);
      while((_Bool)0);
      break;
    }
    default:
    {
      do
        fprintf(stderr, "action not implemented\n");
      while((_Bool)0);
      rv = -1;
    }
  }

out:
  ;
  return rv;
}

// do_daemon
// file main.c line 1189
static signed int do_daemon(void)
{
  struct sigaction act;
  signed int fd;
  signed int rv;
  if(com.debug == 0)
  {
    signed int return_value_daemon_1;
    return_value_daemon_1=daemon(0, 0);
    if(!(return_value_daemon_1 >= 0))
    {
      do
        fprintf(stderr, "cannot fork daemon\n\n");
      while((_Bool)0);
      exit(1);
    }

  }

  sprintf(main_task.name, "%s", (const void *)"main");
  setup_task_timeouts(&main_task, com.io_timeout_arg);
  setup_task_aio(&main_task, com.aio_arg, 0);
  rv=client_alloc();
  if(!(rv >= 0))
    return rv;

  else
  {
    memset((void *)&act, 0, sizeof(struct sigaction) /*152ul*/ );
    act.__sigaction_handler.sa_handler = sigterm_handler;
    rv=sigaction(15, &act, (struct sigaction *)(void *)0);
    if(!(rv >= 0))
      return rv;

    else
    {
      fd=lockfile("/var/run/sanlock", "sanlock.pid");
      if(!(fd >= 0))
        return fd;

      else
      {
        setup_logging();
        setup_host_name();
        signed long int return_value_time_2;
        return_value_time_2=time((signed long int *)(void *)0);
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "sanlock daemon started %s aio %d %d renew %d %d host %s time %llu", (const void *)"2.2", main_task.use_aio, main_task.io_timeout_seconds, main_task.id_renewal_seconds, main_task.id_renewal_fail_seconds, (const void *)our_host_name_global, (unsigned long long int)return_value_time_2);
        setup_priority();
        rv=thread_pool_create(2, com.max_worker_threads);
        if(rv >= 0)
        {
          rv=setup_watchdog();
          if(rv >= 0)
          {
            rv=setup_listener();
            if(rv >= 0)
            {
              setup_token_manager();
              if(rv >= 0)
              {
                main_loop();
                close_token_manager();
                close_watchdog();
              }

            }

          }


        out_threads:
          ;
          thread_pool_free();
        }


      out_logging:
        ;
        close_logging();
        unlink_lockfile(fd, "/var/run/sanlock", "sanlock.pid");
        return rv;
      }
    }
  }
}

// do_delta_action
// file direct.c line 184
static signed int do_delta_action(signed int action, struct task *task, struct sanlk_lockspace *ls, signed int max_hosts, char *our_host_name, struct leader_record *leader_ret)
{
  struct leader_record leader;
  struct sync_disk sd;
  struct space space;
  char bitmap[256l];
  signed int read_result;
  signed int rv;
  memset((void *)bitmap, 0, sizeof(char [256l]) /*256ul*/ );
  memset((void *)&space, 0, sizeof(struct space) /*129264ul*/ );
  if(ls->host_id_disk.path[0l] == 0)
    return -19;

  else
  {
    memset((void *)&sd, 0, sizeof(struct sync_disk) /*1040ul*/ );
    memcpy((void *)&sd, (const void *)&ls->host_id_disk, sizeof(struct sanlk_disk) /*1040ul*/ );
    sd.fd = -1;
    rv=open_disk(&sd);
    if(!(rv >= 0))
      return -19;

    else
      switch(action)
      {
        case 18:
        {
          rv=delta_lease_init(task, &sd, ls->name, max_hosts);
          goto __CPROVER_DUMP_L10;
        }
        case 13:
        {
          rv=delta_lease_acquire(task, &space, &sd, ls->name, our_host_name, ls->host_id, &leader);
          goto __CPROVER_DUMP_L10;
        }
        case 15:
        {
          rv=delta_lease_leader_read(task, &sd, ls->name, ls->host_id, &leader, "direct_renew");
          if(!(rv >= 0))
            return rv;

          rv=delta_lease_renew(task, &space, &sd, ls->name, bitmap, -1, &read_result, &leader, &leader);
          goto __CPROVER_DUMP_L10;
        }
        case 14:
        {
          rv=delta_lease_leader_read(task, &sd, ls->name, ls->host_id, &leader, "direct_release");
          if(!(rv >= 0))
            return rv;

          rv=delta_lease_release(task, &space, &sd, ls->name, &leader, &leader);
          goto __CPROVER_DUMP_L10;
        }
        case 16:

        case 20:
          rv=delta_lease_leader_read(task, &sd, ls->name, ls->host_id, &leader, "direct_read");
        default:
        {

        __CPROVER_DUMP_L10:
          ;
          close_disks(&sd, 1);
          if(rv == 1)
            rv = 0;

          if(!(leader_ret == ((struct leader_record *)NULL)))
            memcpy((void *)leader_ret, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );

          return rv;
        }
      }
  }
}

// do_delta_action_link1
// file direct.c line 184
static signed int do_delta_action_link1(signed int action_link1, struct task *task_link1, struct sanlk_lockspace *ls_link1, signed int max_hosts_link1, char *our_host_name_link1, struct leader_record *leader_ret_link1)
{
  struct leader_record leader_link1;
  struct sync_disk sd_link1;
  struct space space_link1;
  char bitmap_link1[256l];
  signed int read_result_link1;
  signed int rv_link1;
  memset((void *)bitmap_link1, 0, sizeof(char [256l]) /*256ul*/ );
  memset((void *)&space_link1, 0, sizeof(struct space) /*129264ul*/ );
  if(ls_link1->host_id_disk.path[0l] == 0)
    return -19;

  else
  {
    memset((void *)&sd_link1, 0, sizeof(struct sync_disk) /*1040ul*/ );
    memcpy((void *)&sd_link1, (const void *)&ls_link1->host_id_disk, sizeof(struct sanlk_disk) /*1040ul*/ );
    sd_link1.fd = -1;
    rv_link1=open_disk(&sd_link1);
    if(!(rv_link1 >= 0))
      return -19;

    else
      switch(action_link1)
      {
        case 18:
        {
          rv_link1=delta_lease_init(task_link1, &sd_link1, ls_link1->name, max_hosts_link1);
          goto __CPROVER_DUMP_L10;
        }
        case 13:
        {
          rv_link1=delta_lease_acquire(task_link1, &space_link1, &sd_link1, ls_link1->name, our_host_name_link1, ls_link1->host_id, &leader_link1);
          goto __CPROVER_DUMP_L10;
        }
        case 15:
        {
          rv_link1=delta_lease_leader_read(task_link1, &sd_link1, ls_link1->name, ls_link1->host_id, &leader_link1, "direct_renew");
          if(!(rv_link1 >= 0))
            return rv_link1;

          rv_link1=delta_lease_renew(task_link1, &space_link1, &sd_link1, ls_link1->name, bitmap_link1, -1, &read_result_link1, &leader_link1, &leader_link1);
          goto __CPROVER_DUMP_L10;
        }
        case 14:
        {
          rv_link1=delta_lease_leader_read(task_link1, &sd_link1, ls_link1->name, ls_link1->host_id, &leader_link1, "direct_release");
          if(!(rv_link1 >= 0))
            return rv_link1;

          rv_link1=delta_lease_release(task_link1, &space_link1, &sd_link1, ls_link1->name, &leader_link1, &leader_link1);
          goto __CPROVER_DUMP_L10;
        }
        case 16:

        case 20:
          rv_link1=delta_lease_leader_read(task_link1, &sd_link1, ls_link1->name, ls_link1->host_id, &leader_link1, "direct_read");
        default:
        {

        __CPROVER_DUMP_L10:
          ;
          close_disks(&sd_link1, 1);
          if(rv_link1 == 1)
            rv_link1 = 0;

          if(!(leader_ret_link1 == ((struct leader_record *)NULL)))
            memcpy((void *)leader_ret_link1, (const void *)&leader_link1, sizeof(struct leader_record) /*200ul*/ );

          return rv_link1;
        }
      }
  }
}

// do_direct
// file main.c line 1871
static signed int do_direct(void)
{
  struct leader_record leader;
  unsigned long int timestamp;
  unsigned long int owner_id;
  unsigned long int owner_generation;
  signed int live;
  signed int rv;
  setup_task_timeouts(&main_task, com.io_timeout_arg);
  setup_task_aio(&main_task, com.aio_arg, 1);
  sprintf(main_task.name, "%s", (const void *)"main_direct");
  switch(com.action)
  {
    case 18:
    {
      rv=direct_init(&main_task, &com.lockspace, com.res_args[(signed long int)0], com.max_hosts, com.num_hosts);
      do
        fprintf(stderr, "init done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 19:
    {
      rv=direct_dump(&main_task, com.dump_path, (signed int)com.force_mode);
      break;
    }
    case 20:
    {
      rv=direct_read_leader(&main_task, &com.lockspace, com.res_args[(signed long int)0], &leader);
      do
        fprintf(stderr, "read_leader done %d\n", rv);
      while((_Bool)0);
      do
        fprintf(stderr, "magic 0x%0x\n", leader.magic);
      while((_Bool)0);
      do
        fprintf(stderr, "version 0x%x\n", leader.version);
      while((_Bool)0);
      do
        fprintf(stderr, "flags 0x%x\n", leader.flags);
      while((_Bool)0);
      do
        fprintf(stderr, "sector_size %u\n", leader.sector_size);
      while((_Bool)0);
      do
        fprintf(stderr, "num_hosts %llu\n", (unsigned long long int)leader.num_hosts);
      while((_Bool)0);
      do
        fprintf(stderr, "max_hosts %llu\n", (unsigned long long int)leader.max_hosts);
      while((_Bool)0);
      do
        fprintf(stderr, "owner_id %llu\n", (unsigned long long int)leader.owner_id);
      while((_Bool)0);
      do
        fprintf(stderr, "owner_generation %llu\n", (unsigned long long int)leader.owner_generation);
      while((_Bool)0);
      do
        fprintf(stderr, "lver %llu\n", (unsigned long long int)leader.lver);
      while((_Bool)0);
      do
        fprintf(stderr, "space_name %.48s\n", (const void *)leader.space_name);
      while((_Bool)0);
      do
        fprintf(stderr, "resource_name %.48s\n", (const void *)leader.resource_name);
      while((_Bool)0);
      do
        fprintf(stderr, "timestamp %llu\n", (unsigned long long int)leader.timestamp);
      while((_Bool)0);
      do
        fprintf(stderr, "checksum 0x%0x\n", leader.checksum);
      while((_Bool)0);
      do
        fprintf(stderr, "write_id %llu\n", (unsigned long long int)leader.write_id);
      while((_Bool)0);
      do
        fprintf(stderr, "write_generation %llu\n", (unsigned long long int)leader.write_generation);
      while((_Bool)0);
      do
        fprintf(stderr, "write_timestamp %llu\n", (unsigned long long int)leader.write_timestamp);
      while((_Bool)0);
      break;
    }
    case 9:
    {
      rv=direct_acquire(&main_task, com.res_args[(signed long int)0], com.num_hosts, com.local_host_id, com.local_host_generation, &leader);
      do
        fprintf(stderr, "acquire done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 10:
    {
      rv=direct_release(&main_task, com.res_args[(signed long int)0], &leader);
      do
        fprintf(stderr, "release done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 13:
    {
      setup_host_name();
      rv=direct_acquire_id(&main_task, &com.lockspace, our_host_name_global);
      do
        fprintf(stderr, "acquire_id done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 14:
    {
      rv=direct_release_id(&main_task, &com.lockspace);
      do
        fprintf(stderr, "release_id done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 15:
    {
      rv=direct_renew_id(&main_task, &com.lockspace);
      do
        fprintf(stderr, "rewew_id done %d\n", rv);
      while((_Bool)0);
      break;
    }
    case 16:
    {
      rv=direct_read_id(&main_task, &com.lockspace, &timestamp, &owner_id, &owner_generation);
      do
        fprintf(stderr, "read_id done %d timestamp %llu owner_id %llu owner_generation %llu\n", rv, (unsigned long long int)timestamp, (unsigned long long int)owner_id, (unsigned long long int)owner_generation);
      while((_Bool)0);
      break;
    }
    case 17:
    {
      rv=direct_live_id(&main_task, &com.lockspace, &timestamp, &owner_id, &owner_generation, &live);
      do
        fprintf(stderr, "live_id done %d live %d timestamp %llu owner_id %llu owner_generation %llu\n", rv, live, (unsigned long long int)timestamp, (unsigned long long int)owner_id, (unsigned long long int)owner_generation);
      while((_Bool)0);
      break;
    }
    default:
    {
      do
        fprintf(stderr, "direct action %d not known\n", com.action);
      while((_Bool)0);
      rv = -1;
    }
  }
  close_task_aio(&main_task);
  return rv;
}

// do_linux_aio
// file diskio.c line 368
static signed int do_linux_aio(signed int fd, unsigned long int offset, char *buf, signed int len, struct task *task, signed int cmd)
{
  struct timespec ts;
  struct aicb *aicb;
  struct iocb *iocb;
  struct io_event event;
  signed int rv;
  aicb=find_callback_slot(task);
  struct iocb *ev_iocb;
  struct aicb *ev_aicb;
  struct aicb *tmp_statement_expression_1;
  if(aicb == ((struct aicb *)NULL))
    return -2;

  else
  {
    iocb = &aicb->iocb;
    memset((void *)iocb, 0, sizeof(struct iocb) /*64ul*/ );
    iocb->aio_fildes = fd;
    iocb->aio_lio_opcode = (signed short int)cmd;
    iocb->u.c.buf = (void *)buf;
    iocb->u.c.nbytes = (unsigned long int)len;
    iocb->u.c.offset = (signed long long int)offset;
    rv=io_submit(task->aio_ctx, (signed long int)1, &iocb);
    if(!(rv >= 0))
      log_level((unsigned int)0, (unsigned int)0, task->name, 3, "aio submit %p:%p:%p rv %d fd %d cmd %d", aicb, iocb, buf, rv, fd, cmd);

    else
    {
      task->io_count = task->io_count + 1u;
      aicb->used = 1;
      aicb->buf = buf;
      memset((void *)&ts, 0, sizeof(struct timespec) /*16ul*/ );
      ts.tv_sec = (signed long int)task->io_timeout_seconds;
      do
      {

      retry:
        ;
        memset((void *)&event, 0, sizeof(struct io_event) /*32ul*/ );
        rv=io_getevents(task->aio_ctx, (signed long int)1, (signed long int)1, &event, &ts);
        if(rv == -4)
          goto retry;

        if(!(rv >= 0))
        {
          log_level((unsigned int)0, (unsigned int)0, task->name, 3, "aio getevent %p:%p:%p rv %d", aicb, iocb, buf, rv);
          goto out;
        }

        if(!(rv == 1))
          goto __CPROVER_DUMP_L8;

        ev_iocb = event.obj;
        const struct iocb *__mptr = ev_iocb;
        tmp_statement_expression_1 = (struct aicb *)((char *)__mptr - (signed long int)16ul);
        ev_aicb = tmp_statement_expression_1;
        ev_aicb->used = 0;
        if(ev_iocb == iocb)
          break;

        log_level((unsigned int)0, (unsigned int)0, task->name, 3, "aio collect %p:%p:%p result %ld:%ld other free", ev_aicb, ev_iocb, ev_aicb->buf, event.res, event.res2);
        free((void *)ev_aicb->buf);
        ev_aicb->buf = (char *)(void *)0;
      }
      while((_Bool)1);
      if(!((signed int)event.res >= 0))
      {
        log_level((unsigned int)0, (unsigned int)0, task->name, 3, "aio collect %p:%p:%p result %ld:%ld match res", ev_aicb, ev_iocb, ev_aicb->buf, event.res, event.res2);
        rv = (signed int)event.res;
      }

      else
        if(!(event.res == (unsigned long int)len))
        {
          log_level((unsigned int)0, (unsigned int)0, task->name, 3, "aio collect %p:%p:%p result %ld:%ld match len %d", ev_aicb, ev_iocb, ev_aicb->buf, event.res, event.res2, len);
          rv = -90;
        }

        else
        {
          rv = 0;
          goto out;

        __CPROVER_DUMP_L8:
          ;
          task->to_count = task->to_count + 1u;
          log_level((unsigned int)0, (unsigned int)0, task->name, 3, "aio timeout %p:%p:%p sec %d to_count %d", aicb, iocb, buf, task->io_timeout_seconds, task->to_count);
          rv=io_cancel(task->aio_ctx, iocb, &event);
          if(rv == 0)
          {
            aicb->used = 0;
            rv = -125;
          }

          else
          {
            rv = -202;
            if(cmd == 0)
              task->read_iobuf_timeout_aicb = aicb;

          }
        }
    }

  out:
    ;
    return rv;
  }
}

// do_linux_aio_link1
// file diskio.c line 368
static signed int do_linux_aio_link1(signed int fd_link1, unsigned long int offset_link1, char *buf_link1, signed int len_link1, struct task *task_link1, signed int cmd_link1)
{
  struct timespec ts_link1;
  struct aicb *aicb_link1;
  struct iocb *iocb_link1;
  struct io_event event_link1;
  signed int rv_link1;
  aicb_link1=find_callback_slot_link1(task_link1);
  struct iocb *ev_iocb_link1;
  struct aicb *ev_aicb_link1;
  struct aicb *tmp_statement_expression_1_link1;
  if(aicb_link1 == ((struct aicb *)NULL))
    return -2;

  else
  {
    iocb_link1 = &aicb_link1->iocb;
    memset((void *)iocb_link1, 0, sizeof(struct iocb) /*64ul*/ );
    iocb_link1->aio_fildes = fd_link1;
    iocb_link1->aio_lio_opcode = (signed short int)cmd_link1;
    iocb_link1->u.c.buf = (void *)buf_link1;
    iocb_link1->u.c.nbytes = (unsigned long int)len_link1;
    iocb_link1->u.c.offset = (signed long long int)offset_link1;
    rv_link1=io_submit(task_link1->aio_ctx, (signed long int)1, &iocb_link1);
    if(!(rv_link1 >= 0))
      log_level((unsigned int)0, (unsigned int)0, task_link1->name, 3, "aio submit %p:%p:%p rv %d fd %d cmd %d", aicb_link1, iocb_link1, buf_link1, rv_link1, fd_link1, cmd_link1);

    else
    {
      task_link1->io_count = task_link1->io_count + 1u;
      aicb_link1->used = 1;
      aicb_link1->buf = buf_link1;
      memset((void *)&ts_link1, 0, sizeof(struct timespec) /*16ul*/ );
      ts_link1.tv_sec = (signed long int)task_link1->io_timeout_seconds;
      do
      {

      retry:
        ;
        memset((void *)&event_link1, 0, sizeof(struct io_event) /*32ul*/ );
        rv_link1=io_getevents(task_link1->aio_ctx, (signed long int)1, (signed long int)1, &event_link1, &ts_link1);
        if(rv_link1 == -4)
          goto retry;

        if(!(rv_link1 >= 0))
        {
          log_level((unsigned int)0, (unsigned int)0, task_link1->name, 3, "aio getevent %p:%p:%p rv %d", aicb_link1, iocb_link1, buf_link1, rv_link1);
          goto out;
        }

        if(!(rv_link1 == 1))
          goto __CPROVER_DUMP_L8;

        ev_iocb_link1 = event_link1.obj;
        const struct iocb *__mptr_link1 = ev_iocb_link1;
        tmp_statement_expression_1_link1 = (struct aicb *)((char *)__mptr_link1 - (signed long int)16ul);
        ev_aicb_link1 = tmp_statement_expression_1_link1;
        ev_aicb_link1->used = 0;
        if(ev_iocb_link1 == iocb_link1)
          break;

        log_level((unsigned int)0, (unsigned int)0, task_link1->name, 3, "aio collect %p:%p:%p result %ld:%ld other free", ev_aicb_link1, ev_iocb_link1, ev_aicb_link1->buf, event_link1.res, event_link1.res2);
        free((void *)ev_aicb_link1->buf);
        ev_aicb_link1->buf = (char *)(void *)0;
      }
      while((_Bool)1);
      if(!((signed int)event_link1.res >= 0))
      {
        log_level((unsigned int)0, (unsigned int)0, task_link1->name, 3, "aio collect %p:%p:%p result %ld:%ld match res", ev_aicb_link1, ev_iocb_link1, ev_aicb_link1->buf, event_link1.res, event_link1.res2);
        rv_link1 = (signed int)event_link1.res;
      }

      else
        if(!(event_link1.res == (unsigned long int)len_link1))
        {
          log_level((unsigned int)0, (unsigned int)0, task_link1->name, 3, "aio collect %p:%p:%p result %ld:%ld match len %d", ev_aicb_link1, ev_iocb_link1, ev_aicb_link1->buf, event_link1.res, event_link1.res2, len_link1);
          rv_link1 = -90;
        }

        else
        {
          rv_link1 = 0;
          goto out;

        __CPROVER_DUMP_L8:
          ;
          task_link1->to_count = task_link1->to_count + 1u;
          log_level((unsigned int)0, (unsigned int)0, task_link1->name, 3, "aio timeout %p:%p:%p sec %d to_count %d", aicb_link1, iocb_link1, buf_link1, task_link1->io_timeout_seconds, task_link1->to_count);
          rv_link1=io_cancel(task_link1->aio_ctx, iocb_link1, &event_link1);
          if(rv_link1 == 0)
          {
            aicb_link1->used = 0;
            rv_link1 = -125;
          }

          else
          {
            rv_link1 = -202;
            if(cmd_link1 == 0)
              task_link1->read_iobuf_timeout_aicb = aicb_link1;

          }
        }
    }

  out:
    ;
    return rv_link1;
  }
}

// do_paxos_action
// file direct.c line 81
static signed int do_paxos_action(signed int action, struct task *task, struct sanlk_resource *res, signed int max_hosts, signed int num_hosts, unsigned long int local_host_id, unsigned long int local_host_generation, struct leader_record *leader_ret)
{
  struct token *token;
  struct leader_record leader;
  signed int disks_len;
  signed int token_len;
  signed int j;
  signed int rv = 0;
  disks_len = (signed int)((unsigned long int)res->num_disks * sizeof(struct sync_disk) /*1040ul*/ );
  token_len = (signed int)(sizeof(struct token) /*472ul*/  + (unsigned long int)disks_len);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)token_len);
  token = (struct token *)return_value_malloc_1;
  if(token == ((struct token *)NULL))
    return -12;

  else
  {
    memset((void *)token, 0, (unsigned long int)token_len);
    token->disks = (struct sync_disk *)&token->r.disks[(signed long int)0];
    token->r.num_disks = res->num_disks;
    memcpy((void *)token->r.lockspace_name, (const void *)res->lockspace_name, (unsigned long int)48);
    memcpy((void *)token->r.name, (const void *)res->name, (unsigned long int)48);
    memcpy((void *)token->disks, (const void *)&res->disks, (unsigned long int)disks_len);
    j = 0;
    for( ; !((unsigned int)j >= token->r.num_disks); j = j + 1)
    {
      (token->disks + (signed long int)j)->sector_size = (unsigned int)0;
      (token->disks + (signed long int)j)->fd = -1;
    }
    rv=open_disks(token->disks, (signed int)token->r.num_disks);
    if(!(rv >= 0))
    {
      free((void *)token);
      return rv;
    }

    else
    {
      switch(action)
      {
        case 18:
        {
          rv=paxos_lease_init(task, token, num_hosts, max_hosts);
          break;
        }
        case 9:
        {
          token->host_id = local_host_id;
          token->host_generation = local_host_generation;
          rv=paxos_lease_acquire(task, token, (unsigned int)0, leader_ret, (unsigned long int)0, num_hosts);
          break;
        }
        case 10:
        {
          rv=paxos_lease_leader_read(task, token, &leader, "direct_release");
          if(!(rv >= 0))
            break;

          rv=paxos_lease_release(task, token, &leader, leader_ret);
          break;
        }
        case 20:
          rv=paxos_lease_leader_read(task, token, &leader, "direct_read_leader");
      }
      close_disks(token->disks, (signed int)token->r.num_disks);
      free((void *)token);
      if(rv == 1)
        rv = 0;

      if(!(leader_ret == ((struct leader_record *)NULL)))
        memcpy((void *)leader_ret, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );

      return rv;
    }
  }
}

// do_paxos_action_link1
// file direct.c line 81
static signed int do_paxos_action_link1(signed int action_link1, struct task *task_link1, struct sanlk_resource *res_link1, signed int max_hosts_link1, signed int num_hosts_link1, unsigned long int local_host_id_link1, unsigned long int local_host_generation_link1, struct leader_record *leader_ret_link1)
{
  struct token *token_link1;
  struct leader_record leader_link1;
  signed int disks_len_link1;
  signed int token_len_link1;
  signed int j_link1;
  signed int rv_link1 = 0;
  disks_len_link1 = (signed int)((unsigned long int)res_link1->num_disks * sizeof(struct sync_disk) /*1040ul*/ );
  token_len_link1 = (signed int)(sizeof(struct token) /*472ul*/  + (unsigned long int)disks_len_link1);
  void *return_value_malloc_1_link1;
  return_value_malloc_1_link1=malloc((unsigned long int)token_len_link1);
  token_link1 = (struct token *)return_value_malloc_1_link1;
  if(token_link1 == ((struct token *)NULL))
    return -12;

  else
  {
    memset((void *)token_link1, 0, (unsigned long int)token_len_link1);
    token_link1->disks = (struct sync_disk *)&token_link1->r.disks[(signed long int)0];
    token_link1->r.num_disks = res_link1->num_disks;
    memcpy((void *)token_link1->r.lockspace_name, (const void *)res_link1->lockspace_name, (unsigned long int)48);
    memcpy((void *)token_link1->r.name, (const void *)res_link1->name, (unsigned long int)48);
    memcpy((void *)token_link1->disks, (const void *)&res_link1->disks, (unsigned long int)disks_len_link1);
    j_link1 = 0;
    for( ; !((unsigned int)j_link1 >= token_link1->r.num_disks); j_link1 = j_link1 + 1)
    {
      (token_link1->disks + (signed long int)j_link1)->sector_size = (unsigned int)0;
      (token_link1->disks + (signed long int)j_link1)->fd = -1;
    }
    rv_link1=open_disks(token_link1->disks, (signed int)token_link1->r.num_disks);
    if(!(rv_link1 >= 0))
    {
      free((void *)token_link1);
      return rv_link1;
    }

    else
    {
      switch(action_link1)
      {
        case 18:
        {
          rv_link1=paxos_lease_init(task_link1, token_link1, num_hosts_link1, max_hosts_link1);
          break;
        }
        case 9:
        {
          token_link1->host_id = local_host_id_link1;
          token_link1->host_generation = local_host_generation_link1;
          rv_link1=paxos_lease_acquire(task_link1, token_link1, (unsigned int)0, leader_ret_link1, (unsigned long int)0, num_hosts_link1);
          break;
        }
        case 10:
        {
          rv_link1=paxos_lease_leader_read(task_link1, token_link1, &leader_link1, "direct_release");
          if(!(rv_link1 >= 0))
            break;

          rv_link1=paxos_lease_release(task_link1, token_link1, &leader_link1, leader_ret_link1);
          break;
        }
        case 20:
          rv_link1=paxos_lease_leader_read(task_link1, token_link1, &leader_link1, "direct_read_leader");
      }
      close_disks(token_link1->disks, (signed int)token_link1->r.num_disks);
      free((void *)token_link1);
      if(rv_link1 == 1)
        rv_link1 = 0;

      if(!(leader_ret_link1 == ((struct leader_record *)NULL)))
        memcpy((void *)leader_ret_link1, (const void *)&leader_link1, sizeof(struct leader_record) /*200ul*/ );

      return rv_link1;
    }
  }
}

// do_read
// file diskio.c line 292
static signed int do_read(signed int fd, unsigned long int offset, char *buf, signed int len, struct task *task)
{
  signed long int ret;
  signed int rv;
  signed int pos = 0;
  if(!(task == ((struct task *)NULL)))
    task->io_count = task->io_count + 1u;

  ret=lseek(fd, (signed long int)offset, 0);
  signed int *return_value___errno_location_2;
  if(!((unsigned long int)ret == offset))
    return -1;

  else
  {
    while(!(pos >= len))
    {
      signed long int return_value_read_1;
      return_value_read_1=read(fd, (void *)(buf + (signed long int)pos), (unsigned long int)(len - pos));
      rv = (signed int)return_value_read_1;
      if(rv == 0)
        return -1;

      if(rv == -1)
      {
        return_value___errno_location_2=__errno_location();
        if(!(*return_value___errno_location_2 == 4))
          goto __CPROVER_DUMP_L4;

      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        if(!(rv >= 0))
          return -1;

        pos = pos + rv;
      }
    }
    return 0;
  }
}

// do_read_link1
// file diskio.c line 292
static signed int do_read_link1(signed int fd_link1, unsigned long int offset_link1, char *buf_link1, signed int len_link1, struct task *task_link1)
{
  signed long int ret_link1;
  signed int rv_link1;
  signed int pos_link1 = 0;
  if(!(task_link1 == ((struct task *)NULL)))
    task_link1->io_count = task_link1->io_count + 1u;

  ret_link1=lseek(fd_link1, (signed long int)offset_link1, 0);
  signed int *return_value___errno_location_2_link1;
  if(!((unsigned long int)ret_link1 == offset_link1))
    return -1;

  else
  {
    while(!(pos_link1 >= len_link1))
    {
      signed long int return_value_read_1_link1;
      return_value_read_1_link1=read(fd_link1, (void *)(buf_link1 + (signed long int)pos_link1), (unsigned long int)(len_link1 - pos_link1));
      rv_link1 = (signed int)return_value_read_1_link1;
      if(rv_link1 == 0)
        return -1;

      if(rv_link1 == -1)
      {
        return_value___errno_location_2_link1=__errno_location();
        if(!(*return_value___errno_location_2_link1 == 4))
          goto __CPROVER_DUMP_L4;

      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        if(!(rv_link1 >= 0))
          return -1;

        pos_link1 = pos_link1 + rv_link1;
      }
    }
    return 0;
  }
}

// do_read_aio_linux
// file diskio.c line 485
static signed int do_read_aio_linux(signed int fd, unsigned long int offset, char *buf, signed int len, struct task *task)
{
  signed int return_value_do_linux_aio_1;
  return_value_do_linux_aio_1=do_linux_aio(fd, offset, buf, len, task, 0);
  return return_value_do_linux_aio_1;
}

// do_read_aio_linux_link1
// file diskio.c line 485
static signed int do_read_aio_linux_link1(signed int fd_link1, unsigned long int offset_link1, char *buf_link1, signed int len_link1, struct task *task_link1)
{
  signed int return_value_do_linux_aio_1_link1;
  return_value_do_linux_aio_1_link1=do_linux_aio_link1(fd_link1, offset_link1, buf_link1, len_link1, task_link1, 0);
  return return_value_do_linux_aio_1_link1;
}

// do_read_aio_posix
// file diskio.c line 539
static signed int do_read_aio_posix(signed int fd, unsigned long int offset, char *buf, signed int len, struct task *task)
{
  struct timespec ts;
  struct aiocb cb;
  struct aiocb *p_cb;
  signed int rv;
  memset((void *)&ts, 0, sizeof(struct timespec) /*16ul*/ );
  ts.tv_sec = (signed long int)task->io_timeout_seconds;
  memset((void *)&cb, 0, sizeof(struct aiocb) /*168ul*/ );
  p_cb = &cb;
  cb.aio_fildes = fd;
  cb.aio_buf = (volatile void *)buf;
  cb.aio_nbytes = (unsigned long int)len;
  cb.aio_offset = (signed long int)offset;
  rv=aio_read(&cb);
  if(!(rv >= 0))
    return -1;

  else
  {
    rv=aio_suspend(&p_cb, 1, &ts);
    if(rv == 0)
      return 0;

    else
    {
      rv=aio_cancel(fd, &cb);
      if(!(rv >= 0))
        return -1;

      else
        if(rv == 2)
          return 0;

        else
          if(rv == 0)
            return -5;

          else
            if(rv == 1)
              return -5;

            else
              return -1;
    }
  }
}

// do_read_aio_posix_link1
// file diskio.c line 539
static signed int do_read_aio_posix_link1(signed int fd_link1, unsigned long int offset_link1, char *buf_link1, signed int len_link1, struct task *task_link1)
{
  struct timespec ts_link1;
  struct aiocb cb_link1;
  struct aiocb *p_cb_link1;
  signed int rv_link1;
  memset((void *)&ts_link1, 0, sizeof(struct timespec) /*16ul*/ );
  ts_link1.tv_sec = (signed long int)task_link1->io_timeout_seconds;
  memset((void *)&cb_link1, 0, sizeof(struct aiocb) /*168ul*/ );
  p_cb_link1 = &cb_link1;
  cb_link1.aio_fildes = fd_link1;
  cb_link1.aio_buf = (volatile void *)buf_link1;
  cb_link1.aio_nbytes = (unsigned long int)len_link1;
  cb_link1.aio_offset = (signed long int)offset_link1;
  rv_link1=aio_read(&cb_link1);
  if(!(rv_link1 >= 0))
    return -1;

  else
  {
    rv_link1=aio_suspend(&p_cb_link1, 1, &ts_link1);
    if(rv_link1 == 0)
      return 0;

    else
    {
      rv_link1=aio_cancel(fd_link1, &cb_link1);
      if(!(rv_link1 >= 0))
        return -1;

      else
        if(rv_link1 == 2)
          return 0;

        else
          if(rv_link1 == 0)
            return -5;

          else
            if(rv_link1 == 1)
              return -5;

            else
              return -1;
    }
  }
}

// do_req_kill_pid
// file resource.c line 802
static void do_req_kill_pid(struct token *tt, signed int pid)
{
  struct resource *r;
  unsigned int flags;
  signed int found = 0;
  pthread_mutex_lock(&resource_mutex);
  r=find_resource(tt, &resources_held);
  if(!(r == ((struct resource *)NULL)))
  {
    if(r->pid == pid)
    {
      found = 1;
      flags = r->flags;
    }

  }

  pthread_mutex_unlock(&resource_mutex);
  if(found == 0)
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "req pid %d %.48s:%.48s not found", pid, (const void *)tt->r.lockspace_name, (const void *)tt->r.name);

  else
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "do_req_kill_pid %d flags %x %.48s:%.48s", pid, flags, (const void *)tt->r.lockspace_name, (const void *)tt->r.name);
    kill(pid, 15);
    if((8u & flags) == 0u)
    {
      sleep((unsigned int)1);
      kill(pid, 9);
    }

  }
}

// do_write
// file diskio.c line 259
static signed int do_write(signed int fd, unsigned long int offset, const char *buf, signed int len, struct task *task)
{
  signed long int ret;
  signed int rv;
  signed int pos = 0;
  if(!(task == ((struct task *)NULL)))
    task->io_count = task->io_count + 1u;

  ret=lseek(fd, (signed long int)offset, 0);
  signed long int return_value_write_1;
  signed int *return_value___errno_location_2;
  if(!((unsigned long int)ret == offset))
    return -1;

  else
  {
    do
    {

    retry:
      ;
      return_value_write_1=write(fd, (const void *)(buf + (signed long int)pos), (unsigned long int)len);
      rv = (signed int)return_value_write_1;
      if(rv == -1)
      {
        return_value___errno_location_2=__errno_location();
        if(*return_value___errno_location_2 == 4)
          goto retry;

      }

      if(!(rv >= 0))
        return -1;

      if(rv == len)
        break;

      len = len - rv;
      pos = pos + rv;
    }
    while((_Bool)1);
    return 0;
  }
}

// do_write_link1
// file diskio.c line 259
static signed int do_write_link1(signed int fd_link1, unsigned long int offset_link1, const char *buf_link1, signed int len_link1, struct task *task_link1)
{
  signed long int ret_link1;
  signed int rv_link1;
  signed int pos_link1 = 0;
  if(!(task_link1 == ((struct task *)NULL)))
    task_link1->io_count = task_link1->io_count + 1u;

  ret_link1=lseek(fd_link1, (signed long int)offset_link1, 0);
  signed long int return_value_write_1_link1;
  signed int *return_value___errno_location_2_link1;
  if(!((unsigned long int)ret_link1 == offset_link1))
    return -1;

  else
  {
    do
    {

    retry:
      ;
      return_value_write_1_link1=write(fd_link1, (const void *)(buf_link1 + (signed long int)pos_link1), (unsigned long int)len_link1);
      rv_link1 = (signed int)return_value_write_1_link1;
      if(rv_link1 == -1)
      {
        return_value___errno_location_2_link1=__errno_location();
        if(*return_value___errno_location_2_link1 == 4)
          goto retry;

      }

      if(!(rv_link1 >= 0))
        return -1;

      if(rv_link1 == len_link1)
        break;

      len_link1 = len_link1 - rv_link1;
      pos_link1 = pos_link1 + rv_link1;
    }
    while((_Bool)1);
    return 0;
  }
}

// do_write_aio_linux
// file diskio.c line 480
static signed int do_write_aio_linux(signed int fd, unsigned long int offset, char *buf, signed int len, struct task *task)
{
  signed int return_value_do_linux_aio_1;
  return_value_do_linux_aio_1=do_linux_aio(fd, offset, buf, len, task, 1);
  return return_value_do_linux_aio_1;
}

// do_write_aio_linux_link1
// file diskio.c line 480
static signed int do_write_aio_linux_link1(signed int fd_link1, unsigned long int offset_link1, char *buf_link1, signed int len_link1, struct task *task_link1)
{
  signed int return_value_do_linux_aio_1_link1;
  return_value_do_linux_aio_1_link1=do_linux_aio_link1(fd_link1, offset_link1, buf_link1, len_link1, task_link1, 1);
  return return_value_do_linux_aio_1_link1;
}

// do_write_aio_posix
// file diskio.c line 490
static signed int do_write_aio_posix(signed int fd, unsigned long int offset, char *buf, signed int len, struct task *task)
{
  struct timespec ts;
  struct aiocb cb;
  struct aiocb *p_cb;
  signed int rv;
  memset((void *)&ts, 0, sizeof(struct timespec) /*16ul*/ );
  ts.tv_sec = (signed long int)task->io_timeout_seconds;
  memset((void *)&cb, 0, sizeof(struct aiocb) /*168ul*/ );
  p_cb = &cb;
  cb.aio_fildes = fd;
  cb.aio_buf = (volatile void *)buf;
  cb.aio_nbytes = (unsigned long int)len;
  cb.aio_offset = (signed long int)offset;
  rv=aio_write(&cb);
  if(!(rv >= 0))
    return -1;

  else
  {
    rv=aio_suspend(&p_cb, 1, &ts);
    if(rv == 0)
      return 0;

    else
    {
      rv=aio_cancel(fd, &cb);
      if(!(rv >= 0))
        return -1;

      else
        if(rv == 2)
          return 0;

        else
          if(rv == 0)
            return -5;

          else
            if(rv == 1)
              return -5;

            else
              return -1;
    }
  }
}

// do_write_aio_posix_link1
// file diskio.c line 490
static signed int do_write_aio_posix_link1(signed int fd_link1, unsigned long int offset_link1, char *buf_link1, signed int len_link1, struct task *task_link1)
{
  struct timespec ts_link1;
  struct aiocb cb_link1;
  struct aiocb *p_cb_link1;
  signed int rv_link1;
  memset((void *)&ts_link1, 0, sizeof(struct timespec) /*16ul*/ );
  ts_link1.tv_sec = (signed long int)task_link1->io_timeout_seconds;
  memset((void *)&cb_link1, 0, sizeof(struct aiocb) /*168ul*/ );
  p_cb_link1 = &cb_link1;
  cb_link1.aio_fildes = fd_link1;
  cb_link1.aio_buf = (volatile void *)buf_link1;
  cb_link1.aio_nbytes = (unsigned long int)len_link1;
  cb_link1.aio_offset = (signed long int)offset_link1;
  rv_link1=aio_write(&cb_link1);
  if(!(rv_link1 >= 0))
    return -1;

  else
  {
    rv_link1=aio_suspend(&p_cb_link1, 1, &ts_link1);
    if(rv_link1 == 0)
      return 0;

    else
    {
      rv_link1=aio_cancel(fd_link1, &cb_link1);
      if(!(rv_link1 >= 0))
        return -1;

      else
        if(rv_link1 == 2)
          return 0;

        else
          if(rv_link1 == 0)
            return -5;

          else
            if(rv_link1 == 1)
              return -5;

            else
              return -1;
    }
  }
}

// examine_token
// file resource.c line 772
static signed int examine_token(struct task *task, struct token *token, struct request_record *req_out)
{
  struct request_record req;
  signed int rv;
  memset((void *)&req, 0, sizeof(struct request_record) /*24ul*/ );
  rv=paxos_lease_request_read(task, token, &req);
  if(rv >= 0)
  {
    if(!(req.magic == 136912913u))
      rv = -270;

    else
      if(!((0xFFFF0000 & req.version) == 65536u))
        rv = -271;

      else
        memcpy((void *)req_out, (const void *)&req, sizeof(struct request_record) /*24ul*/ );
  }


out:
  ;
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "examine_token rv %d lver %llu mode %u", rv, (unsigned long long int)req.lver, req.force_mode);
  return rv;
}

// find_callback_slot
// file diskio.c line 318
static struct aicb * find_callback_slot(struct task *task)
{
  struct timespec ts;
  struct io_event event;
  signed int cleared = 0;
  signed int rv;
  signed int i;
  signed int tmp_post_1;
  struct iocb *ev_iocb;
  struct aicb *ev_aicb;
  struct aicb *tmp_statement_expression_2;
  do
  {

  find:
    ;
    i = 0;
    for( ; !(i >= task->cb_size); i = i + 1)
      if((task->callbacks + (signed long int)i)->used == 0)
        return &task->callbacks[(signed long int)i];

    tmp_post_1 = cleared;
    cleared = cleared + 1;
    if(!(tmp_post_1 == 0))
      return (struct aicb *)(void *)0;

    memset((void *)&ts, 0, sizeof(struct timespec) /*16ul*/ );
    ts.tv_sec = (signed long int)task->io_timeout_seconds;
    do
    {

    retry:
      ;
      memset((void *)&event, 0, sizeof(struct io_event) /*32ul*/ );
      rv=io_getevents(task->aio_ctx, (signed long int)1, (signed long int)1, &event, &ts);
    }
    while(rv == -4);
    if(!(rv >= 0))
      return (struct aicb *)(void *)0;

    if(!(rv == 1))
      break;

    ev_iocb = event.obj;
    const struct iocb *__mptr = ev_iocb;
    tmp_statement_expression_2 = (struct aicb *)((char *)__mptr - (signed long int)16ul);
    ev_aicb = tmp_statement_expression_2;
    log_level((unsigned int)0, (unsigned int)0, task->name, 3, "aio collect %p:%p:%p result %ld:%ld old free", ev_aicb, ev_iocb, ev_aicb->buf, event.res, event.res2);
    ev_aicb->used = 0;
    free((void *)ev_aicb->buf);
    ev_aicb->buf = (char *)(void *)0;
  }
  while((_Bool)1);
  return (struct aicb *)(void *)0;
}

// find_callback_slot_link1
// file diskio.c line 318
static struct aicb * find_callback_slot_link1(struct task *task_link1)
{
  struct timespec ts_link1;
  struct io_event event_link1;
  signed int cleared_link1 = 0;
  signed int rv_link1;
  signed int i_link1;
  signed int tmp_post_1_link1;
  struct iocb *ev_iocb_link1;
  struct aicb *ev_aicb_link1;
  struct aicb *tmp_statement_expression_2_link1;
  do
  {

  find:
    ;
    i_link1 = 0;
    for( ; !(i_link1 >= task_link1->cb_size); i_link1 = i_link1 + 1)
      if((task_link1->callbacks + (signed long int)i_link1)->used == 0)
        return &task_link1->callbacks[(signed long int)i_link1];

    tmp_post_1_link1 = cleared_link1;
    cleared_link1 = cleared_link1 + 1;
    if(!(tmp_post_1_link1 == 0))
      return (struct aicb *)(void *)0;

    memset((void *)&ts_link1, 0, sizeof(struct timespec) /*16ul*/ );
    ts_link1.tv_sec = (signed long int)task_link1->io_timeout_seconds;
    do
    {

    retry:
      ;
      memset((void *)&event_link1, 0, sizeof(struct io_event) /*32ul*/ );
      rv_link1=io_getevents(task_link1->aio_ctx, (signed long int)1, (signed long int)1, &event_link1, &ts_link1);
    }
    while(rv_link1 == -4);
    if(!(rv_link1 >= 0))
      return (struct aicb *)(void *)0;

    if(!(rv_link1 == 1))
      break;

    ev_iocb_link1 = event_link1.obj;
    const struct iocb *__mptr_link1 = ev_iocb_link1;
    tmp_statement_expression_2_link1 = (struct aicb *)((char *)__mptr_link1 - (signed long int)16ul);
    ev_aicb_link1 = tmp_statement_expression_2_link1;
    log_level((unsigned int)0, (unsigned int)0, task_link1->name, 3, "aio collect %p:%p:%p result %ld:%ld old free", ev_aicb_link1, ev_iocb_link1, ev_aicb_link1->buf, event_link1.res, event_link1.res2);
    ev_aicb_link1->used = 0;
    free((void *)ev_aicb_link1->buf);
    ev_aicb_link1->buf = (char *)(void *)0;
  }
  while((_Bool)1);
  return (struct aicb *)(void *)0;
}

// find_lockspace
// file lockspace.c line 90
struct space * find_lockspace(char *name)
{
  struct space *return_value__search_space_1;
  return_value__search_space_1=_search_space(name, (struct sync_disk *)(void *)0, (unsigned long int)0, &spaces, &spaces_rem, &spaces_add);
  return return_value__search_space_1;
}

// find_resource
// file resource.c line 463
static struct resource * find_resource(struct token *token, struct list_head *head)
{
  struct resource *r;
  struct resource *tmp_statement_expression_1;
  const struct list_head *__mptr = head->next;
  tmp_statement_expression_1 = (struct resource *)((char *)__mptr - (signed long int)0ul);
  r = tmp_statement_expression_1;
  struct resource *tmp_statement_expression_2;
  for( ; !(&r->list == head); r = tmp_statement_expression_2)
  {
    signed int return_value_strncmp_3;
    return_value_strncmp_3=strncmp(r->r.lockspace_name, token->r.lockspace_name, (unsigned long int)48);
    if(return_value_strncmp_3 == 0)
    {
      signed int return_value_strncmp_4;
      return_value_strncmp_4=strncmp(r->r.name, token->r.name, (unsigned long int)48);
      if(return_value_strncmp_4 == 0)
        return r;

    }

    const struct list_head *find_resource__1__1__2____mptr = r->list.next;
    tmp_statement_expression_2 = (struct resource *)((char *)find_resource__1__1__2____mptr - (signed long int)0ul);
  }
  return (struct resource *)(void *)0;
}

// find_resource_flag
// file resource.c line 865
static struct resource * find_resource_flag(struct list_head *head, unsigned int flag)
{
  struct resource *r;
  struct resource *tmp_statement_expression_1;
  const struct list_head *find_resource_flag__1__1__1____mptr = head->next;
  tmp_statement_expression_1 = (struct resource *)((char *)find_resource_flag__1__1__1____mptr - (signed long int)0ul);
  r = tmp_statement_expression_1;
  struct resource *tmp_statement_expression_2;
  for( ; !(&r->list == head); r = tmp_statement_expression_2)
  {
    if(!((r->flags & flag) == 0u))
      return r;

    const struct list_head *__mptr = r->list.next;
    tmp_statement_expression_2 = (struct resource *)((char *)__mptr - (signed long int)0ul);
  }
  return (struct resource *)(void *)0;
}

// find_type
// file client_cmd.c line 195
static signed int find_type(signed int type, signed int *sort_index)
{
  struct sanlk_state *st;
  char *buf;
  signed int i = 0;
  for( ; !(i >= sort_count); i = i + 1)
  {
    buf = sort_bufs[(signed long int)i];
    if(!(buf == ((char *)NULL)))
    {
      st = (struct sanlk_state *)buf;
      if(st->type == (unsigned int)type)
      {
        *sort_index = i;
        return 0;
      }

    }

  }
  return -1;
}

// free_lockspaces
// file lockspace.c line 860
void free_lockspaces(signed int wait)
{
  struct space *sp;
  struct space *safe;
  signed int rv;
  pthread_mutex_lock(&spaces_mutex);
  struct space *tmp_statement_expression_1;
  const struct list_head *__mptr = (&spaces_rem)->next;
  tmp_statement_expression_1 = (struct space *)((char *)__mptr - (signed long int)0ul);
  sp = tmp_statement_expression_1;
  struct space *tmp_statement_expression_2;
  const struct list_head *free_lockspaces__1__1__2____mptr = sp->list.next;
  tmp_statement_expression_2 = (struct space *)((char *)free_lockspaces__1__1__2____mptr - (signed long int)0ul);
  safe = tmp_statement_expression_2;
  struct space *tmp_statement_expression_3;
  for( ; !(&sp->list == &spaces_rem); safe = tmp_statement_expression_3)
  {
    rv=stop_lockspace_thread(sp, wait);
    if(rv == 0)
    {
      log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "free lockspace");
      list_del(&sp->list);
      free_sp(sp);
    }

    sp = safe;
    const struct list_head *free_lockspaces__1__1__3____mptr = safe->list.next;
    tmp_statement_expression_3 = (struct space *)((char *)free_lockspaces__1__1__3____mptr - (signed long int)0ul);
  }
  pthread_mutex_unlock(&spaces_mutex);
}

// free_sp
// file lockspace.c line 570
static void free_sp(struct space *sp)
{
  if(!(sp->lease_status.renewal_read_buf == ((char *)NULL)))
    free((void *)sp->lease_status.renewal_read_buf);

  free((void *)sp);
}

// get_peer_pid
// file cmd.c line 1629
static signed int get_peer_pid(signed int fd, signed int *pid)
{
  struct ucred cred;
  unsigned int len = (unsigned int)sizeof(struct ucred) /*12ul*/ ;
  signed int return_value_getsockopt_1;
  return_value_getsockopt_1=getsockopt(fd, 1, 17, (void *)&cred, &len);
  if(!(return_value_getsockopt_1 == 0))
    return -1;

  else
  {
    *pid = cred.pid;
    return 0;
  }
}

// get_rand
// file main.c line 1143
signed int get_rand(signed int a, signed int b)
{
  signed int val;
  signed int rv;
  pthread_mutex_lock(&rand_mutex);
  rv=random_r(&rand_data, &val);
  pthread_mutex_unlock(&rand_mutex);
  if(!(rv >= 0))
    return rv;

  else
    return a + (signed int)((double)((float)((b - a) + 1) * (float)val) / ((double)2147483647 + 1.0));
}

// group_to_gid
// file main.c line 1282
static signed int group_to_gid(char *arg)
{
  struct group *gr;
  gr=getgrnam(arg);
  if(gr == ((struct group *)NULL))
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "group '%s' not found, using uid: %i", arg, 0);
    return 0;
  }

  else
    return (signed int)gr->gr_gid;
}

// host_info
// file lockspace.c line 198
signed int host_info(char *space_name, unsigned long int host_id, struct host_status *hs_out)
{
  struct space *sp;
  signed int found = 0;
  struct space *tmp_statement_expression_1;
  struct space *tmp_statement_expression_2;
  if(host_id == 0ul || host_id >= 2001ul)
    return -22;

  else
  {
    pthread_mutex_lock(&spaces_mutex);
    const struct list_head *__mptr = (&spaces)->next;
    tmp_statement_expression_1 = (struct space *)((char *)__mptr - (signed long int)0ul);
    sp = tmp_statement_expression_1;
    for( ; !(&sp->list == &spaces); sp = tmp_statement_expression_2)
    {
      signed int return_value_strncmp_3;
      return_value_strncmp_3=strncmp(sp->space_name, space_name, (unsigned long int)48);
      if(return_value_strncmp_3 == 0)
      {
        memcpy((void *)hs_out, (const void *)&sp->host_status[(signed long int)(host_id - (unsigned long int)1)], sizeof(struct host_status) /*64ul*/ );
        found = 1;
        break;
      }

      const struct list_head *host_info__1__1__2____mptr = sp->list.next;
      tmp_statement_expression_2 = (struct space *)((char *)host_info__1__1__2____mptr - (signed long int)0ul);
    }
    pthread_mutex_unlock(&spaces_mutex);
    if(found == 0)
      return -28;

    else
      return 0;
  }
}

// host_live
// file resource.c line 77
static signed int host_live(struct task *task, char *lockspace_name, unsigned long int host_id, unsigned long int gen)
{
  struct host_status hs;
  unsigned long int now;
  signed int rv;
  rv=host_info(lockspace_name, host_id, &hs);
  if(!(rv == 0))
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "host_live %llu %llu yes host_info %d", (unsigned long long int)host_id, (unsigned long long int)gen, rv);
    return 1;
  }

  else
    if(hs.last_check == 0ul)
    {
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "host_live %llu %llu yes unchecked", (unsigned long long int)host_id, (unsigned long long int)gen);
      return 1;
    }

    else
      if(hs.timestamp == 0ul)
      {
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "host_live %llu %llu no lease free", (unsigned long long int)host_id, (unsigned long long int)gen);
        return 0;
      }

      else
        if(!(gen >= hs.owner_generation))
        {
          log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "host_live %llu %llu no old gen %llu", (unsigned long long int)host_id, (unsigned long long int)gen, (unsigned long long int)hs.owner_generation);
          return 0;
        }

        else
        {
          now=monotime();
          if(hs.last_live == 0ul)
          {
            if((unsigned long int)task->host_dead_seconds >= now + -hs.first_check)
              goto __CPROVER_DUMP_L5;

            log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "host_live %llu %llu no first_check %llu", (unsigned long long int)host_id, (unsigned long long int)gen, (unsigned long long int)hs.first_check);
            return 0;
          }

          else
          {

          __CPROVER_DUMP_L5:
            ;
            if(!(hs.last_live == 0ul))
            {
              if((unsigned long int)task->host_dead_seconds >= now + -hs.last_live)
                goto __CPROVER_DUMP_L6;

              log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "host_live %llu %llu no last_live %llu", (unsigned long long int)host_id, (unsigned long long int)gen, (unsigned long long int)hs.last_live);
              return 0;
            }

            else
            {

            __CPROVER_DUMP_L6:
              ;
              log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "host_live %llu %llu yes recent first_check %llu last_live %llu", (unsigned long long int)host_id, (unsigned long long int)gen, (unsigned long long int)hs.first_check, (unsigned long long int)hs.last_live);
              return 1;
            }
          }
        }
}

// host_status_set_bit
// file lockspace.c line 172
signed int host_status_set_bit(char *space_name, unsigned long int host_id)
{
  struct space *sp;
  signed int found = 0;
  struct space *tmp_statement_expression_1;
  struct space *tmp_statement_expression_2;
  if(host_id == 0ul || host_id >= 2001ul)
    return -22;

  else
  {
    pthread_mutex_lock(&spaces_mutex);
    const struct list_head *__mptr = (&spaces)->next;
    tmp_statement_expression_1 = (struct space *)((char *)__mptr - (signed long int)0ul);
    sp = tmp_statement_expression_1;
    for( ; !(&sp->list == &spaces); sp = tmp_statement_expression_2)
    {
      signed int return_value_strncmp_3;
      return_value_strncmp_3=strncmp(sp->space_name, space_name, (unsigned long int)48);
      if(return_value_strncmp_3 == 0)
      {
        found = 1;
        break;
      }

      const struct list_head *host_status_set_bit__1__1__2____mptr = sp->list.next;
      tmp_statement_expression_2 = (struct space *)((char *)host_status_set_bit__1__1__2____mptr - (signed long int)0ul);
    }
    pthread_mutex_unlock(&spaces_mutex);
    if(found == 0)
      return -28;

    else
    {
      pthread_mutex_lock(&sp->mutex);
      sp->host_status[(signed long int)(host_id - (unsigned long int)1)].set_bit_time=monotime();
      pthread_mutex_unlock(&sp->mutex);
      return 0;
    }
  }
}

// inq_lockspace
// file lockspace.c line 720
signed int inq_lockspace(struct sanlk_lockspace *ls)
{
  signed int rv;
  struct space *sp;
  pthread_mutex_lock(&spaces_mutex);
  sp=_search_space(ls->name, (struct sync_disk *)&ls->host_id_disk, ls->host_id, &spaces, (struct list_head *)(void *)0, (struct list_head *)(void *)0);
  if(!(sp == ((struct space *)NULL)))
  {
    rv = 0;
    goto out;
  }

  else
    rv = -2;
  sp=_search_space(ls->name, (struct sync_disk *)&ls->host_id_disk, ls->host_id, &spaces_add, &spaces_rem, (struct list_head *)(void *)0);
  if(!(sp == ((struct space *)NULL)))
    rv = -115;


out:
  ;
  pthread_mutex_unlock(&spaces_mutex);
  return rv;
}

// kill_pids
// file main.c line 438
static void kill_pids(struct space *sp)
{
  struct client *cl;
  unsigned long int now;
  signed int ci;
  signed int fd;
  signed int pid;
  signed int sig;
  signed int do_kill;
  signed int return_value_client_using_space_1;
  if(!(sp->killing_pids >= 2))
  {
    now=monotime();
    ci = 0;
    for( ; client_maxi >= ci; ci = ci + 1)
    {
      do_kill = 0;
      cl = &client[(signed long int)ci];
      pthread_mutex_lock(&cl->mutex);
      if(!(cl->used == 0))
      {
        if(cl->pid >= 1)
        {
          if(!(cl->kill_count >= main_task.kill_count_max))
          {
            if(!(cl->kill_count == 0))
            {
              if(!(now + -cl->kill_last >= 1ul))
                goto unlock;

            }

            return_value_client_using_space_1=client_using_space(cl, sp);
            if(!(return_value_client_using_space_1 == 0))
            {
              cl->kill_last = now;
              cl->kill_count = cl->kill_count + 1;
              fd = cl->fd;
              pid = cl->pid;
              if(!((2u & cl->restricted) == 0u))
                sig = 15;

              else
                if(!((4u & cl->restricted) == 0u))
                  sig = 9;

                else
                  if(main_task.kill_count_term >= cl->kill_count)
                    sig = 15;

                  else
                    sig = 9;
              do_kill = 1;
            }

          }

        }

      }


    unlock:
      ;
      pthread_mutex_unlock(&cl->mutex);
      if(!(do_kill == 0))
      {
        if(cl->kill_count == main_task.kill_count_max)
          log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "kill %d,%d,%d sig %d count %d final attempt", ci, fd, pid, sig, cl->kill_count);

        else
          log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "kill %d,%d,%d sig %d count %d", ci, fd, pid, sig, cl->kill_count);
        kill(pid, sig);
      }

    }
  }

}

// leader_checksum
// file paxos_lease.h line 16
unsigned int leader_checksum(struct leader_record *lr)
{
  unsigned int return_value_crc32c_1;
  return_value_crc32c_1=crc32c((unsigned int)~1, (unsigned char *)lr, (unsigned long int)168);
  return return_value_crc32c_1;
}

// leaders_match
// file paxos_lease.c line 684
static signed int leaders_match(struct leader_record *a, struct leader_record *b)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)a, (const void *)b, (unsigned long int)152);
  if(return_value_memcmp_1 == 0)
    return 1;

  else
    return 0;
}

// leaders_match_link1
// file paxos_lease.c line 684
static signed int leaders_match_link1(struct leader_record *a_link1, struct leader_record *b_link1)
{
  signed int return_value_memcmp_1_link1;
  return_value_memcmp_1_link1=memcmp((const void *)a_link1, (const void *)b_link1, (unsigned long int)152);
  if(return_value_memcmp_1_link1 == 0)
    return 1;

  else
    return 0;
}

// list_add
// file list.h line 70
static inline void list_add(struct list_head *new, struct list_head *head)
{
  __list_add(new, head, head->next);
}

// list_add_link1
// file list.h line 70
static inline void list_add_link1(struct list_head *new_link1, struct list_head *head_link1)
{
  __list_add_link1(new_link1, head_link1, head_link1->next);
}

// list_add_link2
// file list.h line 70
static inline void list_add_link2(struct list_head *new_link2, struct list_head *head_link2)
{
  __list_add_link2(new_link2, head_link2, head_link2->next);
}

// list_add_tail
// file list.h line 84
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
  __list_add_link1(new, head->prev, head);
}

// list_del
// file list.h line 108
static inline void list_del(struct list_head *entry)
{
  __list_del(entry->prev, entry->next);
  entry->next = (struct list_head *)(void *)0x00100100;
  entry->prev = (struct list_head *)(void *)0x00200200;
}

// list_del_link1
// file list.h line 108
static inline void list_del_link1(struct list_head *entry_link1)
{
  __list_del_link1(entry_link1->prev, entry_link1->next);
  entry_link1->next = (struct list_head *)(void *)0x00100100;
  entry_link1->prev = (struct list_head *)(void *)0x00200200;
}

// list_del_link2
// file list.h line 108
static inline void list_del_link2(struct list_head *entry_link2)
{
  __list_del_link2(entry_link2->prev, entry_link2->next);
  entry_link2->next = (struct list_head *)(void *)0x00100100;
  entry_link2->prev = (struct list_head *)(void *)0x00200200;
}

// list_empty
// file list.h line 186
static inline signed int list_empty(struct list_head *head)
{
  return (signed int)(head->next == head);
}

// list_empty_link1
// file list.h line 186
static inline signed int list_empty_link1(struct list_head *head_link1)
{
  return (signed int)(head_link1->next == head_link1);
}

// list_empty_link2
// file list.h line 186
static inline signed int list_empty_link2(struct list_head *head_link2)
{
  return (signed int)(head_link2->next == head_link2);
}

// list_move
// file list.h line 153
static inline void list_move(struct list_head *list, struct list_head *head)
{
  __list_del(list->prev, list->next);
  list_add(list, head);
}

// list_move_link1
// file list.h line 153
static inline void list_move_link1(struct list_head *list_link1, struct list_head *head_link1)
{
  __list_del_link1(list_link1->prev, list_link1->next);
  list_add_link1(list_link1, head_link1);
}

// list_move_link2
// file list.h line 153
static inline void list_move_link2(struct list_head *list_link2, struct list_head *head_link2)
{
  __list_del_link2(list_link2->prev, list_link2->next);
  list_add_link2(list_link2, head_link2);
}

// lockfile
// file lockfile.c line 32
signed int lockfile(const char *dir, const char *name)
{
  char path[4096l];
  char buf[16l];
  struct flock lock;
  unsigned int old_umask;
  signed int fd;
  signed int rv;
  old_umask=umask((unsigned int)0022);
  rv=mkdir("/var/run/sanlock", (unsigned int)0777);
  signed int *return_value___errno_location_1;
  if(!(rv >= 0))
  {
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 17)
      goto __CPROVER_DUMP_L1;

    umask(old_umask);
    return rv;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    umask(old_umask);
    snprintf(path, (unsigned long int)4096, "%s/%s", dir, name);
    fd=open(path, 0100 | 01 | 02000000, 0644);
    if(!(fd >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "lockfile open error %s: %s", (const void *)path, return_value_strerror_3);
      return -1;
    }

    lock.l_type = (signed short int)1;
    lock.l_start = (signed long int)0;
    lock.l_whence = (signed short int)0;
    lock.l_len = (signed long int)0;
    rv=fcntl(fd, 6, &lock);
    if(!(rv >= 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "lockfile setlk error %s: %s", (const void *)path, return_value_strerror_5);
      goto fail;
    }

    rv=ftruncate(fd, (signed long int)0);
    if(!(rv >= 0))
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      char *return_value_strerror_7;
      return_value_strerror_7=strerror(*return_value___errno_location_6);
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "lockfile truncate error %s: %s", (const void *)path, return_value_strerror_7);
      goto fail;
    }

    memset((void *)buf, 0, sizeof(char [16l]) /*16ul*/ );
    signed int return_value_getpid_8;
    return_value_getpid_8=getpid();
    snprintf(buf, sizeof(char [16l]) /*16ul*/ , "%d\n", return_value_getpid_8);
    unsigned long int return_value_strlen_9;
    return_value_strlen_9=strlen(buf);
    signed long int return_value_write_10;
    return_value_write_10=write(fd, (const void *)buf, return_value_strlen_9);
    rv = (signed int)return_value_write_10;
    if(!(rv >= 1))
    {
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      char *return_value_strerror_12;
      return_value_strerror_12=strerror(*return_value___errno_location_11);
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "lockfile write error %s: %s", (const void *)path, return_value_strerror_12);
      goto fail;
    }

    return fd;

  fail:
    ;
    close(fd);
    return -1;
  }
}

// lockspace_disk
// file lockspace.c line 119
signed int lockspace_disk(char *space_name, struct sync_disk *disk)
{
  struct space space;
  signed int rv;
  pthread_mutex_lock(&spaces_mutex);
  rv=_lockspace_info(space_name, &space);
  if(rv == 0)
  {
    memcpy((void *)disk, (const void *)&space.host_id_disk, sizeof(struct sync_disk) /*1040ul*/ );
    disk->fd = -1;
  }

  pthread_mutex_unlock(&spaces_mutex);
  return rv;
}

// lockspace_info
// file lockspace.c line 108
signed int lockspace_info(char *space_name, struct space *sp_out)
{
  signed int rv;
  pthread_mutex_lock(&spaces_mutex);
  rv=_lockspace_info(space_name, sp_out);
  pthread_mutex_unlock(&spaces_mutex);
  return rv;
}

// lockspace_is_used
// file resource.c line 478
signed int lockspace_is_used(struct sanlk_lockspace *ls)
{
  struct resource *r;
  pthread_mutex_lock(&resource_mutex);
  struct resource *tmp_statement_expression_1;
  const struct list_head *__mptr = (&resources_held)->next;
  tmp_statement_expression_1 = (struct resource *)((char *)__mptr - (signed long int)0ul);
  r = tmp_statement_expression_1;
  struct resource *tmp_statement_expression_2;
  for( ; !(&r->list == &resources_held); r = tmp_statement_expression_2)
  {
    signed int return_value_strncmp_3;
    return_value_strncmp_3=strncmp(r->r.lockspace_name, ls->name, (unsigned long int)48);
    if(return_value_strncmp_3 == 0)
      goto yes;

    const struct list_head *lockspace_is_used__1__1__2____mptr = r->list.next;
    tmp_statement_expression_2 = (struct resource *)((char *)lockspace_is_used__1__1__2____mptr - (signed long int)0ul);
  }
  struct resource *tmp_statement_expression_4;
  const struct list_head *lockspace_is_used__1__2__1____mptr = (&resources_add)->next;
  tmp_statement_expression_4 = (struct resource *)((char *)lockspace_is_used__1__2__1____mptr - (signed long int)0ul);
  r = tmp_statement_expression_4;
  struct resource *tmp_statement_expression_5;
  for( ; !(&r->list == &resources_add); r = tmp_statement_expression_5)
  {
    signed int return_value_strncmp_6;
    return_value_strncmp_6=strncmp(r->r.lockspace_name, ls->name, (unsigned long int)48);
    if(return_value_strncmp_6 == 0)
      goto yes;

    const struct list_head *lockspace_is_used__1__2__2____mptr = r->list.next;
    tmp_statement_expression_5 = (struct resource *)((char *)lockspace_is_used__1__2__2____mptr - (signed long int)0ul);
  }
  struct resource *tmp_statement_expression_7;
  const struct list_head *lockspace_is_used__1__3__1____mptr = (&resources_rem)->next;
  tmp_statement_expression_7 = (struct resource *)((char *)lockspace_is_used__1__3__1____mptr - (signed long int)0ul);
  r = tmp_statement_expression_7;
  struct resource *tmp_statement_expression_8;
  for( ; !(&r->list == &resources_rem); r = tmp_statement_expression_8)
  {
    signed int return_value_strncmp_9;
    return_value_strncmp_9=strncmp(r->r.lockspace_name, ls->name, (unsigned long int)48);
    if(return_value_strncmp_9 == 0)
      goto yes;

    const struct list_head *lockspace_is_used__1__3__2____mptr = r->list.next;
    tmp_statement_expression_8 = (struct resource *)((char *)lockspace_is_used__1__3__2____mptr - (signed long int)0ul);
  }
  pthread_mutex_unlock(&resource_mutex);
  return 0;

yes:
  ;
  pthread_mutex_unlock(&resource_mutex);
  return 1;
}

// lockspace_thread
// file lockspace.c line 374
static void * lockspace_thread(void *arg_in)
{
  char bitmap[256l];
  struct task task;
  struct space *sp;
  struct leader_record leader;
  unsigned long int delta_begin;
  unsigned long int last_success;
  signed int rv;
  signed int delta_length;
  signed int renewal_interval;
  signed int acquire_result;
  signed int delta_result;
  signed int read_result;
  signed int opened = 0;
  signed int stop = 0;
  sp = (struct space *)arg_in;
  memset((void *)&task, 0, sizeof(struct task) /*136ul*/ );
  setup_task_timeouts(&task, main_task.io_timeout_seconds);
  setup_task_aio(&task, main_task.use_aio, 4);
  memcpy((void *)task.name, (const void *)sp->space_name, (unsigned long int)48);
  delta_begin=monotime();
  rv=open_disk(&sp->host_id_disk);
  void *return_value_malloc_1;
  unsigned long int return_value_monotime_2;
  if(!(rv >= 0))
  {
    log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "open_disk %s error %d", (const void *)sp->host_id_disk.path, rv);
    acquire_result = -19;
    delta_result = -1;
  }

  else
  {
    opened = 1;
    sp->align_size=direct_align(&sp->host_id_disk);
    if(!(sp->align_size >= 0))
    {
      log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "direct_align error");
      acquire_result = sp->align_size;
      delta_result = -1;
    }

    else
    {
      return_value_malloc_1=malloc((unsigned long int)sp->align_size);
      sp->lease_status.renewal_read_buf = (char *)return_value_malloc_1;
      if(sp->lease_status.renewal_read_buf == ((char *)NULL))
      {
        acquire_result = -12;
        delta_result = -1;
      }

      else
      {
        delta_begin=monotime();
        delta_result=delta_lease_acquire(&task, sp, &sp->host_id_disk, sp->space_name, our_host_name_global, sp->host_id, &leader);
        return_value_monotime_2=monotime();
        delta_length = (signed int)(return_value_monotime_2 - delta_begin);
        if(delta_result == 1)
          last_success = leader.timestamp;

        acquire_result = delta_result;
        if(delta_result == 1)
        {
          rv=create_watchdog_file(sp, last_success);
          if(!(rv >= 0))
          {
            log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "create_watchdog failed %d", rv);
            acquire_result = -201;
          }

        }

      }
    }
  }

set_status:
  ;
  pthread_mutex_lock(&sp->mutex);
  sp->lease_status.acquire_last_result = acquire_result;
  sp->lease_status.acquire_last_attempt = delta_begin;
  if(delta_result == 1)
    sp->lease_status.acquire_last_success = last_success;

  sp->lease_status.renewal_last_result = acquire_result;
  sp->lease_status.renewal_last_attempt = delta_begin;
  if(delta_result == 1)
    sp->lease_status.renewal_last_success = last_success;

  pthread_mutex_unlock(&sp->mutex);
  if(acquire_result >= 0)
  {
    sp->host_generation = leader.owner_generation;
    while((_Bool)1)
    {
      pthread_mutex_lock(&sp->mutex);
      stop = sp->thread_stop;
      pthread_mutex_unlock(&sp->mutex);
      if(!(stop == 0))
        break;

      unsigned long int return_value_monotime_3;
      return_value_monotime_3=monotime();
      if(!(return_value_monotime_3 + -last_success >= (unsigned long int)task.id_renewal_seconds))
      {
        sleep((unsigned int)1);
        continue;
      }

      else
        usleep((unsigned int)500000);
      memset((void *)bitmap, 0, sizeof(char [256l]) /*256ul*/ );
      create_bitmap(&task, sp, bitmap);
      delta_begin=monotime();
      delta_result=delta_lease_renew(&task, sp, &sp->host_id_disk, sp->space_name, bitmap, delta_result, &read_result, &leader, &leader);
      unsigned long int return_value_monotime_4;
      return_value_monotime_4=monotime();
      delta_length = (signed int)(return_value_monotime_4 - delta_begin);
      if(delta_result == 1)
      {
        renewal_interval = (signed int)(leader.timestamp - last_success);
        last_success = leader.timestamp;
      }

      pthread_mutex_lock(&sp->mutex);
      sp->lease_status.renewal_last_result = delta_result;
      sp->lease_status.renewal_last_attempt = delta_begin;
      if(delta_result == 1)
        sp->lease_status.renewal_last_success = last_success;

      if(!(delta_result == 1))
      {
        if(sp->lease_status.corrupt_result == 0)
          sp->lease_status.corrupt_result=corrupt_result(delta_result);

      }

      if(read_result == 1 && !(task.iobuf == ((char *)NULL)))
      {
        memcpy((void *)sp->lease_status.renewal_read_buf, (const void *)task.iobuf, (unsigned long int)sp->align_size);
        sp->lease_status.renewal_read_count = sp->lease_status.renewal_read_count + 1u;
      }

      if(delta_result == 1)
      {
        if(sp->thread_stop == 0)
          update_watchdog_file(sp, last_success);

      }

      pthread_mutex_unlock(&sp->mutex);
      if(!(delta_result == 1))
        log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "renewal error %d delta_length %d last_success %llu", delta_result, delta_length, (unsigned long long int)last_success);

      else
        if(!(task.id_renewal_seconds >= delta_length))
          log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "renewed %llu delta_length %d too long", (unsigned long long int)last_success, delta_length);

        else
          if(!(com.debug_renew == 0))
            log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "renewed %llu delta_length %d interval %d", (unsigned long long int)last_success, delta_length, renewal_interval);

    }
    close_watchdog_file(sp);
  }


out:
  ;
  if(delta_result == 1)
    delta_lease_release(&task, sp, &sp->host_id_disk, sp->space_name, &leader, &leader);

  if(!(opened == 0))
    close(sp->host_id_disk.fd);

  close_task_aio(&task);
  return (void *)0;
}

// log_leader_error
// file delta_lease.c line 44
static void log_leader_error(signed int result, char *space_name, unsigned long int host_id, struct sync_disk *disk, struct leader_record *lr, const char *caller)
{
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "leader1 %s error %d lockspace %.48s host_id %llu", caller != ((const char *)NULL) ? caller : "unknown", result, space_name, (unsigned long long int)host_id);
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "leader2 path %s offset %llu", (const void *)disk->path, (unsigned long long int)disk->offset);
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "leader3 m %x v %x ss %u nh %llu mh %llu oi %llu og %llu lv %llu", lr->magic, lr->version, lr->sector_size, (unsigned long long int)lr->num_hosts, (unsigned long long int)lr->max_hosts, (unsigned long long int)lr->owner_id, (unsigned long long int)lr->owner_generation, (unsigned long long int)lr->lver);
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "leader4 sn %.48s rn %.48s ts %llu cs %x", (const void *)lr->space_name, (const void *)lr->resource_name, (unsigned long long int)lr->timestamp, lr->checksum);
}

// log_leader_error_link1
// file paxos_lease.c line 568
static void log_leader_error_link1(signed int result_link1, struct token *token, struct sync_disk *disk_link1, struct leader_record *lr_link1, const char *caller_link1)
{
  log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "leader1 %s error %d sn %.48s rn %.48s", caller_link1 != ((const char *)NULL) ? caller_link1 : "unknown", result_link1, (const void *)token->r.lockspace_name, (const void *)token->r.name);
  log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "leader2 path %s offset %llu fd %d", (const void *)disk_link1->path, (unsigned long long int)disk_link1->offset, disk_link1->fd);
  log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "leader3 m %x v %x ss %u nh %llu mh %llu oi %llu og %llu lv %llu", lr_link1->magic, lr_link1->version, lr_link1->sector_size, (unsigned long long int)lr_link1->num_hosts, (unsigned long long int)lr_link1->max_hosts, (unsigned long long int)lr_link1->owner_id, (unsigned long long int)lr_link1->owner_generation, (unsigned long long int)lr_link1->lver);
  log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "leader4 sn %.48s rn %.48s ts %llu cs %x", (const void *)lr_link1->space_name, (const void *)lr_link1->resource_name, (unsigned long long int)lr_link1->timestamp, lr_link1->checksum);
  log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "leader5 wi %llu wg %llu wt %llu", (unsigned long long int)lr_link1->write_id, (unsigned long long int)lr_link1->write_generation, (unsigned long long int)lr_link1->write_timestamp);
}

// log_leader_error_link1_link1
// file paxos_lease.c line 568
static void log_leader_error_link1_link1(signed int result_link1_link1, struct token *token_link1, struct sync_disk *disk_link1_link1, struct leader_record *lr_link1_link1, const char *caller_link1_link1)
{
  log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "leader1 %s error %d sn %.48s rn %.48s", caller_link1_link1 != ((const char *)NULL) ? caller_link1_link1 : "unknown", result_link1_link1, (const void *)token_link1->r.lockspace_name, (const void *)token_link1->r.name);
  log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "leader2 path %s offset %llu fd %d", (const void *)disk_link1_link1->path, (unsigned long long int)disk_link1_link1->offset, disk_link1_link1->fd);
  log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "leader3 m %x v %x ss %u nh %llu mh %llu oi %llu og %llu lv %llu", lr_link1_link1->magic, lr_link1_link1->version, lr_link1_link1->sector_size, (unsigned long long int)lr_link1_link1->num_hosts, (unsigned long long int)lr_link1_link1->max_hosts, (unsigned long long int)lr_link1_link1->owner_id, (unsigned long long int)lr_link1_link1->owner_generation, (unsigned long long int)lr_link1_link1->lver);
  log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "leader4 sn %.48s rn %.48s ts %llu cs %x", (const void *)lr_link1_link1->space_name, (const void *)lr_link1_link1->resource_name, (unsigned long long int)lr_link1_link1->timestamp, lr_link1_link1->checksum);
  log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "leader5 wi %llu wg %llu wt %llu", (unsigned long long int)lr_link1_link1->write_id, (unsigned long long int)lr_link1_link1->write_generation, (unsigned long long int)lr_link1_link1->write_timestamp);
}

// log_leader_error_link2
// file delta_lease.c line 44
static void log_leader_error_link2(signed int result_link2, char *space_name_link1, unsigned long int host_id_link1, struct sync_disk *disk_link2, struct leader_record *lr_link2, const char *caller_link2)
{
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "leader1 %s error %d lockspace %.48s host_id %llu", caller_link2 != ((const char *)NULL) ? caller_link2 : "unknown", result_link2, space_name_link1, (unsigned long long int)host_id_link1);
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "leader2 path %s offset %llu", (const void *)disk_link2->path, (unsigned long long int)disk_link2->offset);
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "leader3 m %x v %x ss %u nh %llu mh %llu oi %llu og %llu lv %llu", lr_link2->magic, lr_link2->version, lr_link2->sector_size, (unsigned long long int)lr_link2->num_hosts, (unsigned long long int)lr_link2->max_hosts, (unsigned long long int)lr_link2->owner_id, (unsigned long long int)lr_link2->owner_generation, (unsigned long long int)lr_link2->lver);
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "leader4 sn %.48s rn %.48s ts %llu cs %x", (const void *)lr_link2->space_name, (const void *)lr_link2->resource_name, (unsigned long long int)lr_link2->timestamp, lr_link2->checksum);
}

// log_level
// file log.h line 12
void log_level(unsigned int space_id, unsigned int token_id, char *name_in, signed int level, const char *fmt, ...)
{
  void **ap;
  char name[49l];
  signed int ret;
  signed int pos = 0;
  signed int len = 512 - 2;
  memset((void *)name, 0, sizeof(char [49l]) /*49ul*/ );
  if(token_id == 0u && !(space_id == 0u))
    snprintf(name, (unsigned long int)48, "s%u ", space_id);

  else
    if(space_id == 0u && !(token_id == 0u))
      snprintf(name, (unsigned long int)48, "r%u ", token_id);

    else
      if(!(space_id == 0u) && !(token_id == 0u))
        snprintf(name, (unsigned long int)48, "s%u:r%u ", space_id, token_id);

      else
        if(!(name_in == ((char *)NULL)))
          snprintf(name, (unsigned long int)48, "%.8s ", name_in);

  pthread_mutex_lock(&log_mutex);
  unsigned long int return_value_monotime_1;
  return_value_monotime_1=monotime();
  ret=snprintf(log_str + (signed long int)pos, (unsigned long int)(len - pos), "%llu %s", (unsigned long long int)return_value_monotime_1, (const void *)name);
  pos = pos + ret;
  ap = (void **)&fmt;
  ret=vsnprintf(log_str + (signed long int)pos, (unsigned long int)(len - pos), fmt, ap);
  ap = ((void **)NULL);
  if(ret >= len + -pos)
    pos = len - 1;

  else
    pos = pos + ret;
  signed int tmp_post_2 = pos;
  pos = pos + 1;
  log_str[(signed long int)tmp_post_2] = (char)10;
  signed int tmp_post_3 = pos;
  pos = pos + 1;
  log_str[(signed long int)tmp_post_3] = (char)0;
  _log_save_dump(level, pos - 1);
  if(log_logfile_priority >= level || log_syslog_priority >= level)
    _log_save_ent(level, pos);

  if(log_stderr_priority >= level)
    fprintf(stderr, "%s", (const void *)log_str);

  pthread_cond_signal(&log_cond);
  pthread_mutex_unlock(&log_mutex);
}

// log_thread_fn
// file log.c line 210
static void * log_thread_fn(void *arg)
{
  char str[512l];
  struct entry *e;
  signed int level;
  signed int prev_dropped = 0;
  unsigned int tmp_post_1;
  while((_Bool)1)
  {
    pthread_mutex_lock(&log_mutex);
    while(log_head_ent == log_tail_ent)
    {
      if(!(log_thread_done == 0u))
      {
        pthread_mutex_unlock(&log_mutex);
        goto out;
      }

      pthread_cond_wait(&log_cond, &log_mutex);
    }
    tmp_post_1 = log_tail_ent;
    log_tail_ent = log_tail_ent + 1u;
    e = &log_ents[(signed long int)tmp_post_1];
    log_tail_ent = log_tail_ent % log_num_ents;
    log_pending_ents = log_pending_ents - 1u;
    memcpy((void *)str, (const void *)e->str, (unsigned long int)512);
    level = e->level;
    prev_dropped = (signed int)log_dropped;
    log_dropped = (unsigned int)0;
    pthread_mutex_unlock(&log_mutex);
    if(!(prev_dropped == 0))
    {
      write_dropped(level, prev_dropped);
      prev_dropped = 0;
    }

    write_entry(level, str);
  }

out:
  ;
  pthread_exit((void *)0);
}

// main
// file main.c line 1991
signed int main(signed int argc, char **argv)
{
  signed int rv;
  pthread_mutex_init(&spaces_mutex, (const union anonymous_5 *)(void *)0);
  INIT_LIST_HEAD(&spaces);
  INIT_LIST_HEAD(&spaces_rem);
  INIT_LIST_HEAD(&spaces_add);
  memset((void *)&com, 0, sizeof(struct command_line) /*1320ul*/ );
  com.use_watchdog = 1;
  com.high_priority = 1;
  com.max_worker_threads = 8;
  com.io_timeout_arg = 10;
  com.aio_arg = 1;
  com.uid = 0;
  com.gid = 0;
  com.pid = -1;
  com.sh_retries = 8;
  memset((void *)&main_task, 0, sizeof(struct task) /*136ul*/ );
  rv=read_command_line(argc, argv);
  if(rv >= 0)
    switch(com.type)
    {
      case 1:
      {
        rv=do_daemon();
        break;
      }
      case 2:
      {
        rv=do_client();
        break;
      }
      case 3:
        rv=do_direct();
    }


out:
  ;
  return rv;
}

// main_loop
// file main.c line 560
static signed int main_loop(void)
{
  void (*workfn)(signed int);
  void (*deadfn)(signed int);
  struct space *sp;
  struct space *safe;
  struct timeval now;
  struct timeval last_check;
  signed int poll_timeout;
  signed int check_interval;
  unsigned int ms;
  signed int i;
  signed int rv;
  signed int empty;
  signed int check_all;
  char *check_buf = (char *)(void *)0;
  signed int check_buf_len = 0;
  gettimeofday(&last_check, (struct timezone *)(void *)0);
  poll_timeout = 1000;
  check_interval = 1000;
  signed int *return_value___errno_location_1;
  struct space *tmp_statement_expression_2;
  struct space *tmp_statement_expression_3;
  signed int return_value_all_pids_dead_5;
  _Bool tmp_if_expr_7;
  struct space *tmp_statement_expression_4;
  while((_Bool)1)
  {
    rv=poll(pollfd, (unsigned long int)(client_maxi + 1), poll_timeout);
    if(rv == -1)
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        continue;

    }

    i = 0;
    for( ; client_maxi >= i; i = i + 1)
      if((client + (signed long int)i)->fd >= 0)
      {
        if(!((0x001 & (signed int)(pollfd + (signed long int)i)->revents) == 0))
        {
          workfn = (void (*)(signed int))(client + (signed long int)i)->workfn;
          if(!(workfn == ((void (*)(signed int))NULL)))
            workfn(i);

        }

        if(!((56 & (signed int)(pollfd + (signed long int)i)->revents) == 0))
        {
          deadfn = (void (*)(signed int))(client + (signed long int)i)->deadfn;
          if(!(deadfn == ((void (*)(signed int))NULL)))
            deadfn(i);

        }

      }

    gettimeofday(&now, (struct timezone *)(void *)0);
    ms=time_diff(&last_check, &now);
    if(!(ms >= (unsigned int)check_interval))
      poll_timeout = (signed int)((unsigned int)check_interval - ms);

    else
    {
      last_check = now;
      check_interval = 1000;
      pthread_mutex_lock(&spaces_mutex);
      const struct list_head *__mptr = (&spaces)->next;
      tmp_statement_expression_2 = (struct space *)((char *)__mptr - (signed long int)0ul);
      sp = tmp_statement_expression_2;
      const struct list_head *main_loop__1__1__4__2____mptr = sp->list.next;
      tmp_statement_expression_3 = (struct space *)((char *)main_loop__1__1__4__2____mptr - (signed long int)0ul);
      safe = tmp_statement_expression_3;
      for( ; !(&sp->list == &spaces); safe = tmp_statement_expression_4)
      {
        if(!(sp->killing_pids == 0))
        {
          return_value_all_pids_dead_5=all_pids_dead(sp);
          if(return_value_all_pids_dead_5 == 0)
            goto __CPROVER_DUMP_L9;

          log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "set thread_stop");
          pthread_mutex_lock(&sp->mutex);
          sp->thread_stop = 1;
          unlink_watchdog_file(sp);
          pthread_mutex_unlock(&sp->mutex);
          list_move_link1(&sp->list, &spaces_rem);
        }

        else
        {

        __CPROVER_DUMP_L9:
          ;
          if(!(sp->killing_pids == 0))
          {
            kill_pids(sp);
            check_interval = 200;
          }

          else
          {
            if(!(check_buf_len >= sp->align_size))
            {
              if(!(check_buf == ((char *)NULL)))
                free((void *)check_buf);

              check_buf_len = sp->align_size;
              void *return_value_malloc_6;
              return_value_malloc_6=malloc((unsigned long int)check_buf_len);
              check_buf = (char *)return_value_malloc_6;
            }

            if(!(check_buf == ((char *)NULL)))
              memset((void *)check_buf, 0, (unsigned long int)check_buf_len);

            check_all = 0;
            rv=check_our_lease(&main_task, sp, &check_all, check_buf);
            if(!(rv == 0))
              tmp_if_expr_7 = (_Bool)1;

            else
              tmp_if_expr_7 = sp->external_remove != 0 ? (_Bool)1 : (_Bool)0;
            if(external_shutdown >= 2 || tmp_if_expr_7)
            {
              log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "set killing_pids check %d remove %d", rv, sp->external_remove);
              sp->space_dead = 1;
              sp->killing_pids = 1;
              kill_pids(sp);
              check_interval = 200;
            }

            else
              if(!(check_all == 0))
                check_other_leases(&main_task, sp, check_buf);

          }
        }
        sp = safe;
        const struct list_head *main_loop__1__1__4__3____mptr = safe->list.next;
        tmp_statement_expression_4 = (struct space *)((char *)main_loop__1__1__4__3____mptr - (signed long int)0ul);
      }
      empty=list_empty(&spaces);
      pthread_mutex_unlock(&spaces_mutex);
      if(!(external_shutdown == 0) && !(empty == 0))
        break;

      if(external_shutdown == 1)
      {
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "ignore shutdown, lockspace exists");
        external_shutdown = 0;
      }

      free_lockspaces(0);
      gettimeofday(&now, (struct timezone *)(void *)0);
      ms=time_diff(&last_check, &now);
      if(!(ms >= (unsigned int)check_interval))
        poll_timeout = (signed int)((unsigned int)check_interval - ms);

      else
        poll_timeout = 1;
    }
  }
  free_lockspaces(1);
  return 0;
}

// majority_disks
// file diskio.c line 82
signed int majority_disks(signed int num_disks, signed int num)
{
  if(num == 0 && num_disks == 1)
    return 0;

  else
    if(!(num_disks % 2 == 0))
      return (signed int)(num >= num_disks / 2 + 1);

    else
      if(!(num_disks / 2 >= num))
        return 1;

      else
        if(!(num >= num_disks / 2))
          return 0;

        else
          return 0;
}

// monotime
// file monotime.h line 12
unsigned long int monotime(void)
{
  struct timespec ts;
  clock_gettime(1, &ts);
  return (unsigned long int)ts.tv_sec;
}

// new_resource
// file resource.c line 523
static struct resource * new_resource(struct token *token)
{
  struct resource *r;
  signed int disks_len;
  signed int r_len;
  disks_len = (signed int)((unsigned long int)token->r.num_disks * sizeof(struct sync_disk) /*1040ul*/ );
  r_len = (signed int)(sizeof(struct resource) /*392ul*/  + (unsigned long int)disks_len);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)r_len);
  r = (struct resource *)return_value_malloc_1;
  if(r == ((struct resource *)NULL))
    return (struct resource *)(void *)0;

  else
  {
    memset((void *)r, 0, (unsigned long int)r_len);
    memcpy((void *)&r->r, (const void *)&token->r, sizeof(struct sanlk_resource) /*128ul*/ );
    INIT_LIST_HEAD_link1(&r->tokens);
    r->host_id = token->host_id;
    r->host_generation = token->host_generation;
    if(!((4u & token->acquire_flags) == 0u))
      r->flags = r->flags | (unsigned int)0x00000001;

    else
    {
      r->pid = token->pid;
      if(!((1u & token->flags) == 0u))
        r->flags = r->flags | (unsigned int)0x00000008;

    }
    return r;
  }
}

// open_disk
// file diskio.h line 13
signed int open_disk(struct sync_disk *disk)
{
  struct stat st;
  signed int align_size;
  signed int fd;
  signed int rv;
  fd=open(disk->path, 02 | 040000 | 04010000, 0);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    rv = -(*return_value___errno_location_1);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "open error %d %s", rv, (const void *)disk->path);
    goto fail;
  }

  signed int return_value_fstat_3;
  return_value_fstat_3=fstat(fd, &st);
  if(!(return_value_fstat_3 >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    rv = -(*return_value___errno_location_2);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "fstat error %d %s", rv, (const void *)disk->path);
    close(fd);
    goto fail;
  }

  if((61440u & st.st_mode) == 32768u)
    disk->sector_size = (unsigned int)512;

  else
  {
    rv=set_disk_properties(disk);
    if(!(rv >= 0))
    {
      close(fd);
      goto fail;
    }

  }
  align_size=direct_align(disk);
  if(!(align_size >= 0))
  {
    rv = align_size;
    close(fd);
  }

  else
    if(!(disk->offset % (unsigned long int)align_size == 0ul))
    {
      rv = -57;
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "invalid offset %llu align size %u %s", (unsigned long long int)disk->offset, align_size, (const void *)disk->path);
      close(fd);
    }

    else
    {
      disk->fd = fd;
      return 0;
    }

fail:
  ;
  if(rv >= 0)
    rv = -1;

  return rv;
}

// open_disks
// file diskio.h line 14
signed int open_disks(struct sync_disk *disks, signed int num_disks)
{
  struct sync_disk *disk;
  signed int num_opens = 0;
  signed int d;
  signed int err;
  signed int rv = -1;
  unsigned int ss = (unsigned int)0;
  d = 0;
  for( ; !(d >= num_disks); d = d + 1)
  {
    disk = &disks[(signed long int)d];
    if(!(disk->fd == -1))
    {
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "open fd %d exists %s", disk->fd, (const void *)disk->path);
      rv = -39;
      goto fail;
    }

    err=open_disk(disk);
    if(!(err >= 0))
      rv = err;

    else
    {
      if(ss == 0u)
        ss = disk->sector_size;

      else
        if(!(ss == disk->sector_size))
        {
          log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "inconsistent sector sizes %u %u %s", ss, disk->sector_size, (const void *)disk->path);
          goto fail;
        }

      num_opens = num_opens + 1;
    }
  }
  signed int return_value_majority_disks_1;
  return_value_majority_disks_1=majority_disks(num_disks, num_opens);
  if(!(return_value_majority_disks_1 == 0))
    return 0;

  else
  {

  fail:
    ;
    close_disks(disks, num_disks);
    return rv;
  }
}

// open_disks_fd
// file diskio.c line 109
signed int open_disks_fd(struct sync_disk *disks, signed int num_disks)
{
  struct sync_disk *disk;
  signed int num_opens = 0;
  signed int d;
  signed int fd;
  signed int rv = -1;
  d = 0;
  for( ; !(d >= num_disks); d = d + 1)
  {
    disk = &disks[(signed long int)d];
    if(!(disk->fd == -1))
    {
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "open fd %d exists %s", disk->fd, (const void *)disk->path);
      rv = -1;
      goto fail;
    }

    fd=open(disk->path, 02 | 040000 | 04010000, 0);
    if(!(fd >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      rv = -(*return_value___errno_location_1);
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "open error %d %s", fd, (const void *)disk->path);
      goto __CPROVER_DUMP_L4;
    }

    disk->fd = fd;
    num_opens = num_opens + 1;

  __CPROVER_DUMP_L4:
    ;
  }
  signed int return_value_majority_disks_2;
  return_value_majority_disks_2=majority_disks(num_disks, num_opens);
  if(!(return_value_majority_disks_2 == 0))
    return 0;

  else
  {

  fail:
    ;
    close_disks(disks, num_disks);
    return rv;
  }
}

// parse_arg_lockspace
// file main.c line 1296
static signed int parse_arg_lockspace(char *arg)
{
  sanlock_str_to_lockspace(arg, &com.lockspace);
  log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "lockspace %s host_id %llu path %s offset %llu", (const void *)com.lockspace.name, (unsigned long long int)com.lockspace.host_id, (const void *)com.lockspace.host_id_disk.path, (unsigned long long int)com.lockspace.host_id_disk.offset);
  return 0;
}

// parse_arg_resource
// file main.c line 1309
static signed int parse_arg_resource(char *arg)
{
  struct sanlk_resource *res;
  signed int rv;
  signed int i;
  if(com.res_count >= 8)
  {
    do
      fprintf(stderr, "resource args over max %d\n", 8);
    while((_Bool)0);
    return -1;
  }

  else
  {
    rv=sanlock_str_to_res(arg, &res);
    if(!(rv >= 0))
    {
      do
        fprintf(stderr, "resource arg parse error %d\n\n", rv);
      while((_Bool)0);
      return rv;
    }

    else
    {
      com.res_args[(signed long int)com.res_count] = res;
      com.res_count = com.res_count + 1;
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "resource %s %s num_disks %d flags %x lver %llu", (const void *)res->lockspace_name, (const void *)res->name, res->num_disks, res->flags, (unsigned long long int)res->lver);
      i = 0;
      for( ; !((unsigned int)i >= res->num_disks); i = i + 1)
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "resource disk %s %llu", (const void *)res->disks[(signed long int)i].path, (unsigned long long int)res->disks[(signed long int)i].offset);
      return 0;
    }
  }
}

// paxos_lease_acquire
// file paxos_lease.h line 23
signed int paxos_lease_acquire(struct task *task, struct token *token, unsigned int flags, struct leader_record *leader_ret, unsigned long int acquire_lver, signed int new_num_hosts)
{
  struct sync_disk host_id_disk;
  struct leader_record host_id_leader;
  struct leader_record cur_leader;
  struct leader_record tmp_leader;
  struct leader_record new_leader;
  struct paxos_dblock dblock;
  struct host_status hs;
  unsigned long int wait_start;
  unsigned long int now;
  unsigned long int last_timestamp;
  unsigned long int next_lver;
  unsigned long int max_mbal;
  unsigned long int num_mbal;
  unsigned long int our_mbal;
  signed int copy_cur_leader = 0;
  signed int disk_open = 0;
  signed int error;
  signed int rv;
  signed int us;
  log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "paxos_acquire begin %x %llu %d", flags, (unsigned long long int)acquire_lver, new_num_hosts);
  _Bool tmp_if_expr_2;
  signed int return_value_memcmp_3;
  do
  {

  restart:
    ;
    error=paxos_lease_read(task, token, &cur_leader, &max_mbal, "paxos_acquire");
    if(!(error >= 0))
      goto out;

    if(!((1u & flags) == 0u))
      copy_cur_leader = 1;

    else
    {
      if(!(cur_leader.lver == acquire_lver) && !(acquire_lver == 0ul))
      {
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "paxos_acquire acquire_lver %llu cur_leader %llu", (unsigned long long int)acquire_lver, (unsigned long long int)cur_leader.lver);
        error = -240;
        goto out;
      }

      if(cur_leader.timestamp == 0ul)
      {
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "paxos_acquire leader %llu free", (unsigned long long int)cur_leader.lver);
        copy_cur_leader = 1;
      }

      else
        if(cur_leader.owner_id == token->host_id)
        {
          if(!(cur_leader.owner_generation == token->host_generation))
            goto __CPROVER_DUMP_L5;

          log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "paxos_acquire already owner id %llu gen %llu", (unsigned long long int)token->host_id, (unsigned long long int)token->host_generation);
          copy_cur_leader = 1;
        }

        else
        {

        __CPROVER_DUMP_L5:
          ;
          if(disk_open == 0)
          {
            memset((void *)&host_id_disk, 0, sizeof(struct sync_disk) /*1040ul*/ );
            rv=lockspace_disk(cur_leader.space_name, &host_id_disk);
            if(!(rv >= 0))
            {
              log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "paxos_acquire no lockspace info %.48s", (const void *)cur_leader.space_name);
              error = -241;
              goto out;
            }

            host_id_disk.fd = -1;
            rv=open_disks_fd(&host_id_disk, 1);
            if(!(rv >= 0))
            {
              log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "paxos_acquire open host_id_disk error %d", rv);
              error = -242;
              goto out;
            }

            disk_open = 1;
          }

          rv=host_info(cur_leader.space_name, cur_leader.owner_id, &hs);
          if(hs.owner_generation == cur_leader.owner_generation && hs.owner_id == cur_leader.owner_id && rv == 0 && !(hs.last_check == 0ul) && !(hs.last_live == 0ul))
          {
            wait_start = hs.last_live;
            last_timestamp = hs.timestamp;
          }

          else
          {
            wait_start=monotime();
            last_timestamp = (unsigned long int)0;
          }
          log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "paxos_acquire owner %llu %llu %llu host_status %llu %llu %llu wait_start %llu", (unsigned long long int)cur_leader.owner_id, (unsigned long long int)cur_leader.owner_generation, (unsigned long long int)cur_leader.timestamp, (unsigned long long int)hs.owner_id, (unsigned long long int)hs.owner_generation, (unsigned long long int)hs.timestamp, (unsigned long long int)wait_start);
          while((_Bool)1)
          {
            error=delta_lease_leader_read(task, &host_id_disk, cur_leader.space_name, cur_leader.owner_id, &host_id_leader, "paxos_acquire");
            if(!(error >= 0))
            {
              log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "paxos_acquire owner %llu %llu %llu delta read %d fd %d path %s off %llu ss %u", (unsigned long long int)cur_leader.owner_id, (unsigned long long int)cur_leader.owner_generation, (unsigned long long int)cur_leader.timestamp, error, host_id_disk.fd, (const void *)host_id_disk.path, (unsigned long long int)host_id_disk.offset, host_id_disk.sector_size);
              goto out;
            }

            if(host_id_leader.timestamp == 0ul)
            {
              log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "paxos_acquire owner %llu delta free", (unsigned long long int)cur_leader.owner_id);
              break;
            }

            if(!(host_id_leader.owner_id == cur_leader.owner_id) || !(cur_leader.owner_generation >= host_id_leader.owner_generation))
            {
              log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "paxos_acquire owner %llu %llu %llu delta %llu %llu %llu mismatch", (unsigned long long int)cur_leader.owner_id, (unsigned long long int)cur_leader.owner_generation, (unsigned long long int)cur_leader.timestamp, (unsigned long long int)host_id_leader.owner_id, (unsigned long long int)host_id_leader.owner_generation, (unsigned long long int)host_id_leader.timestamp);
              break;
            }

            if(last_timestamp == 0ul)
              last_timestamp = host_id_leader.timestamp;

            else
            {
              if(!(host_id_leader.timestamp == last_timestamp))
              {
                if(!((2u & flags) == 0u))
                  log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "paxos_acquire owner %llu delta %llu %llu %llu alive", (unsigned long long int)cur_leader.owner_id, (unsigned long long int)host_id_leader.owner_id, (unsigned long long int)host_id_leader.owner_generation, (unsigned long long int)host_id_leader.timestamp);

                else
                  log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "paxos_acquire owner %llu delta %llu %llu %llu alive", (unsigned long long int)cur_leader.owner_id, (unsigned long long int)host_id_leader.owner_id, (unsigned long long int)host_id_leader.owner_generation, (unsigned long long int)host_id_leader.timestamp);
                memcpy((void *)leader_ret, (const void *)&cur_leader, sizeof(struct leader_record) /*200ul*/ );
                error = -243;
                goto out;
              }

              now=monotime();
              if(!((unsigned long int)task->host_dead_seconds >= now + -wait_start))
              {
                log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "paxos_acquire owner %llu %llu %llu delta %llu %llu %llu dead %llu-%llu>%d", (unsigned long long int)cur_leader.owner_id, (unsigned long long int)cur_leader.owner_generation, (unsigned long long int)cur_leader.timestamp, (unsigned long long int)host_id_leader.owner_id, (unsigned long long int)host_id_leader.owner_generation, (unsigned long long int)host_id_leader.timestamp, (unsigned long long int)now, (unsigned long long int)wait_start, task->host_dead_seconds);
                break;
              }

            }

          skip_live_check:
            ;
            sleep((unsigned int)1);
            if(!(external_shutdown == 0))
            {
              error = -1;
              goto out;
            }

            error=paxos_lease_leader_read(task, token, &tmp_leader, "paxos_acquire");
            if(!(error >= 0))
              goto out;

            signed int return_value_memcmp_1;
            return_value_memcmp_1=memcmp((const void *)&cur_leader, (const void *)&tmp_leader, sizeof(struct leader_record) /*200ul*/ );
            if(!(return_value_memcmp_1 == 0))
            {
              log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "paxos_acquire restart leader changed");
              goto restart;
            }

          }
        }
    }

  run:
    ;
    next_lver = cur_leader.lver + (unsigned long int)1;
    if(max_mbal == 0ul)
      our_mbal = token->host_id;

    else
    {
      num_mbal = max_mbal - max_mbal % cur_leader.max_hosts;
      our_mbal = num_mbal + cur_leader.max_hosts + token->host_id;
    }

  retry_ballot:
    ;
    if(!(copy_cur_leader == 0))
    {
      copy_cur_leader = 0;
      memcpy((void *)&tmp_leader, (const void *)&cur_leader, sizeof(struct leader_record) /*200ul*/ );
    }

    else
    {
      error=paxos_lease_leader_read(task, token, &tmp_leader, "paxos_acquire");
      if(!(error >= 0))
        goto out;

    }
    if(tmp_leader.lver == next_lver)
    {
      if(tmp_leader.owner_id == token->host_id)
        tmp_if_expr_2 = tmp_leader.owner_generation == token->host_generation ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
      {
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "paxos_acquire %llu owner is our inp %llu %llu %llu commited by %llu", (unsigned long long int)next_lver, (unsigned long long int)tmp_leader.owner_id, (unsigned long long int)tmp_leader.owner_generation, (unsigned long long int)tmp_leader.timestamp, (unsigned long long int)tmp_leader.write_id);
        memcpy((void *)leader_ret, (const void *)&tmp_leader, sizeof(struct leader_record) /*200ul*/ );
        error = 1;
      }

      else
      {
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "paxos_acquire %llu owner is %llu %llu %llu", (unsigned long long int)next_lver, (unsigned long long int)tmp_leader.owner_id, (unsigned long long int)tmp_leader.owner_generation, (unsigned long long int)tmp_leader.timestamp);
        memcpy((void *)leader_ret, (const void *)&tmp_leader, sizeof(struct leader_record) /*200ul*/ );
        error = -244;
      }
      goto out;
    }

    if(!(next_lver >= tmp_leader.lver))
    {
      log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "paxos_acquire stale next_lver %llu now %llu owner %llu %llu %llu", (unsigned long long int)next_lver, (unsigned long long int)tmp_leader.lver, (unsigned long long int)tmp_leader.owner_id, (unsigned long long int)tmp_leader.owner_generation, (unsigned long long int)tmp_leader.timestamp);
      goto restart;
    }

    return_value_memcmp_3=memcmp((const void *)&cur_leader, (const void *)&tmp_leader, sizeof(struct leader_record) /*200ul*/ );
    if(return_value_memcmp_3 == 0)
      break;

    log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "paxos_acquire restart leader changed2");
  }
  while((_Bool)1);
  error=run_ballot(task, token, (signed int)cur_leader.num_hosts, next_lver, our_mbal, &dblock);
  if(error == -213)
  {
    us=get_rand(0, 1000000);
    if(!(us >= 0))
      us = (signed int)(token->host_id * (unsigned long int)100);

    log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "paxos_acquire %llu retry delay %d us", (unsigned long long int)next_lver, us);
    usleep((unsigned int)us);
    our_mbal = our_mbal + cur_leader.max_hosts;
    goto retry_ballot;
  }

  if(!(error >= 0))
    log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "paxos_acquire %llu ballot error %d", (unsigned long long int)next_lver, error);

  else
  {
    memcpy((void *)&new_leader, (const void *)&cur_leader, sizeof(struct leader_record) /*200ul*/ );
    new_leader.lver = dblock.lver;
    new_leader.owner_id = dblock.inp;
    new_leader.owner_generation = dblock.inp2;
    new_leader.timestamp = dblock.inp3;
    new_leader.write_id = token->host_id;
    new_leader.write_generation = token->host_generation;
    new_leader.write_timestamp=monotime();
    if(!(new_num_hosts == 0))
      new_leader.num_hosts = (unsigned long int)new_num_hosts;

    if(new_leader.owner_id == token->host_id)
    {
      if(!((4u & flags) == 0u))
        new_leader.flags = new_leader.flags | (unsigned int)0x00000001;

      else
        new_leader.flags = new_leader.flags & (unsigned int)~0x00000001;
    }

    new_leader.checksum=leader_checksum(&new_leader);
    error=write_new_leader(task, token, &new_leader, "paxos_acquire");
    if(error >= 0)
    {
      if(!(new_leader.owner_id == token->host_id))
      {
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "ballot %llu commit other owner %llu %llu %llu", (unsigned long long int)new_leader.lver, (unsigned long long int)new_leader.owner_id, (unsigned long long int)new_leader.owner_generation, (unsigned long long int)new_leader.timestamp);
        memcpy((void *)leader_ret, (const void *)&new_leader, sizeof(struct leader_record) /*200ul*/ );
        error = -245;
      }

      else
      {
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "ballot %llu commit self owner %llu %llu %llu", (unsigned long long int)next_lver, (unsigned long long int)new_leader.owner_id, (unsigned long long int)new_leader.owner_generation, (unsigned long long int)new_leader.timestamp);
        memcpy((void *)leader_ret, (const void *)&new_leader, sizeof(struct leader_record) /*200ul*/ );
        error = 1;
      }
    }

  }

out:
  ;
  if(!(disk_open == 0))
    close_disks(&host_id_disk, 1);

  return error;
}

// paxos_lease_init
// file paxos_lease.h line 35
signed int paxos_lease_init(struct task *task, struct token *token, signed int num_hosts, signed int max_hosts)
{
  char *iobuf;
  char **p_iobuf;
  struct leader_record *leader;
  struct request_record *rr;
  signed int iobuf_len;
  signed int sector_size;
  signed int align_size;
  signed int aio_timeout = 0;
  signed int rv;
  signed int d;
  if(num_hosts == 0)
    num_hosts = 2000;

  if(max_hosts == 0)
    max_hosts = 2000;

  sector_size = (signed int)(token->disks + (signed long int)0)->sector_size;
  align_size=direct_align(&token->disks[(signed long int)0]);
  if(!(align_size >= 0))
    return align_size;

  else
    if(!(align_size >= (2 + max_hosts) * sector_size))
      return -7;

    else
    {
      iobuf_len = align_size;
      p_iobuf = &iobuf;
      signed int return_value_getpagesize_1;
      return_value_getpagesize_1=getpagesize();
      rv=posix_memalign((void **)(void *)p_iobuf, (unsigned long int)return_value_getpagesize_1, (unsigned long int)iobuf_len);
      if(!(rv == 0))
        return rv;

      else
      {
        memset((void *)iobuf, 0, (unsigned long int)iobuf_len);
        leader = (struct leader_record *)iobuf;
        leader->magic = (unsigned int)0x06152010;
        leader->version = (unsigned int)(0x00060000 | 0x00000001);
        leader->sector_size = (unsigned int)sector_size;
        leader->num_hosts = (unsigned long int)num_hosts;
        leader->max_hosts = (unsigned long int)max_hosts;
        leader->timestamp = (unsigned long int)0;
        strncpy(leader->space_name, token->r.lockspace_name, (unsigned long int)48);
        strncpy(leader->resource_name, token->r.name, (unsigned long int)48);
        leader->checksum=leader_checksum(leader);
        rr = (struct request_record *)(iobuf + (signed long int)sector_size);
        rr->magic = (unsigned int)0x08292011;
        rr->version = (unsigned int)(0x00010000 | 0x00000001);
        d = 0;
        for( ; !((unsigned int)d >= token->r.num_disks); d = d + 1)
        {
          rv=write_iobuf((token->disks + (signed long int)d)->fd, (token->disks + (signed long int)d)->offset, iobuf, iobuf_len, task);
          if(rv == -202)
            aio_timeout = 1;

          if(!(rv >= 0))
            return rv;

        }
        if(aio_timeout == 0)
          free((void *)iobuf);

        return 0;
      }
    }
}

// paxos_lease_leader_read
// file paxos_lease.h line 18
signed int paxos_lease_leader_read(struct task *task, struct token *token, struct leader_record *leader_ret, const char *caller)
{
  signed int rv;
  if(token->r.num_disks >= 2u)
    rv=_leader_read_num(task, token, leader_ret, caller);

  else
    rv=_leader_read_one(task, token, leader_ret, caller);
  if(rv == 1)
    log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "%s leader %llu owner %llu %llu %llu", caller, (unsigned long long int)leader_ret->lver, (unsigned long long int)leader_ret->owner_id, (unsigned long long int)leader_ret->owner_generation, (unsigned long long int)leader_ret->timestamp);

  return rv;
}

// paxos_lease_read
// file paxos_lease.c line 1006
static signed int paxos_lease_read(struct task *task, struct token *token, struct leader_record *leader_ret, unsigned long int *max_mbal, const char *caller)
{
  struct paxos_dblock our_dblock;
  signed int rv;
  signed int q = -1;
  if(token->r.num_disks >= 2u)
    rv=_lease_read_num(task, token, leader_ret, &our_dblock, max_mbal, &q, caller);

  else
    rv=_lease_read_one(task, token, &token->disks[(signed long int)0], leader_ret, &our_dblock, max_mbal, &q, caller);
  if(rv == 1)
    log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "%s leader %llu owner %llu %llu %llu max mbal[%d] %llu our_dblock %llu %llu %llu %llu %llu %llu", caller, (unsigned long long int)leader_ret->lver, (unsigned long long int)leader_ret->owner_id, (unsigned long long int)leader_ret->owner_generation, (unsigned long long int)leader_ret->timestamp, q, (unsigned long long int)*max_mbal, (unsigned long long int)our_dblock.mbal, (unsigned long long int)our_dblock.bal, (unsigned long long int)our_dblock.inp, (unsigned long long int)our_dblock.inp2, (unsigned long long int)our_dblock.inp3, (unsigned long long int)our_dblock.lver);

  return rv;
}

// paxos_lease_read_link1
// file paxos_lease.c line 1006
static signed int paxos_lease_read_link1(struct task *task_link1, struct token *token_link1, struct leader_record *leader_ret_link1, unsigned long int *max_mbal_link1, const char *caller_link1)
{
  struct paxos_dblock our_dblock_link1;
  signed int rv_link1;
  signed int q_link1 = -1;
  if(token_link1->r.num_disks >= 2u)
    rv_link1=_lease_read_num_link1(task_link1, token_link1, leader_ret_link1, &our_dblock_link1, max_mbal_link1, &q_link1, caller_link1);

  else
    rv_link1=_lease_read_one_link1(task_link1, token_link1, &token_link1->disks[(signed long int)0], leader_ret_link1, &our_dblock_link1, max_mbal_link1, &q_link1, caller_link1);
  if(rv_link1 == 1)
    log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 7, "%s leader %llu owner %llu %llu %llu max mbal[%d] %llu our_dblock %llu %llu %llu %llu %llu %llu", caller_link1, (unsigned long long int)leader_ret_link1->lver, (unsigned long long int)leader_ret_link1->owner_id, (unsigned long long int)leader_ret_link1->owner_generation, (unsigned long long int)leader_ret_link1->timestamp, q_link1, (unsigned long long int)*max_mbal_link1, (unsigned long long int)our_dblock_link1.mbal, (unsigned long long int)our_dblock_link1.bal, (unsigned long long int)our_dblock_link1.inp, (unsigned long long int)our_dblock_link1.inp2, (unsigned long long int)our_dblock_link1.inp3, (unsigned long long int)our_dblock_link1.lver);

  return rv_link1;
}

// paxos_lease_release
// file paxos_lease.h line 30
signed int paxos_lease_release(struct task *task, struct token *token, struct leader_record *leader_last, struct leader_record *leader_ret)
{
  struct leader_record leader;
  signed int error;
  error=paxos_lease_leader_read(task, token, &leader, "paxos_release");
  _Bool tmp_if_expr_1;
  signed int return_value_memcmp_2;
  if(!(error >= 0))
    log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "paxos_release leader_read error %d", error);

  else
  {
    if(!(leader.lver == leader_last->lver))
    {
      log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "paxos_release %llu other lver %llu", (unsigned long long int)leader_last->lver, (unsigned long long int)leader.lver);
      return -250;
    }

    if(!(leader.owner_id == token->host_id))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = leader.owner_generation != token->host_generation ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "paxos_release %llu other owner %llu %llu %llu", (unsigned long long int)leader_last->lver, (unsigned long long int)leader.owner_id, (unsigned long long int)leader.owner_generation, (unsigned long long int)leader.timestamp);
      return -251;
    }

    return_value_memcmp_2=memcmp((const void *)&leader, (const void *)leader_last, sizeof(struct leader_record) /*200ul*/ );
    if(!(return_value_memcmp_2 == 0))
      log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "paxos_release %llu leader different write %llu %llu %llu vs %llu %llu %llu", (unsigned long long int)leader_last->lver, (unsigned long long int)leader_last->write_id, (unsigned long long int)leader_last->write_generation, (unsigned long long int)leader_last->write_timestamp, (unsigned long long int)leader.write_id, (unsigned long long int)leader.write_generation, (unsigned long long int)leader.write_timestamp);

    leader.timestamp = (unsigned long int)0;
    leader.write_id = token->host_id;
    leader.write_generation = token->host_generation;
    leader.write_timestamp=monotime();
    leader.flags = leader.flags & (unsigned int)~0x00000001;
    leader.checksum=leader_checksum(&leader);
    error=write_new_leader(task, token, &leader, "paxos_release");
    if(error >= 0)
      memcpy((void *)leader_ret, (const void *)&leader, sizeof(struct leader_record) /*200ul*/ );

  }

out:
  ;
  return error;
}

// paxos_lease_request_read
// file paxos_lease.c line 60
signed int paxos_lease_request_read(struct task *task, struct token *token, struct request_record *rr)
{
  signed int rv;
  rv=read_sectors(&token->disks[(signed long int)0], (unsigned long int)1, (unsigned int)1, (char *)rr, (signed int)sizeof(struct request_record) /*24ul*/ , task, "request");
  if(!(rv >= 0))
    return rv;

  else
    return 1;
}

// paxos_lease_request_write
// file paxos_lease.c line 75
signed int paxos_lease_request_write(struct task *task, struct token *token, struct request_record *rr)
{
  signed int rv;
  rv=write_sector(&token->disks[(signed long int)0], (unsigned long int)1, (char *)rr, (signed int)sizeof(struct request_record) /*24ul*/ , task, "request");
  if(!(rv >= 0))
    return rv;

  else
    return 1;
}

// print_debug
// file client_cmd.c line 41
static void print_debug(char *str, signed int len)
{
  char *p;
  signed int i;
  p = &str[(signed long int)0];
  i = 0;
  for( ; !(i >= len + -1); i = i + 1)
    if((signed int)str[(signed long int)i] == 32)
    {
      str[(signed long int)i] = (char)0;
      printf("    %s\n", p);
      p = &str[(signed long int)(i + 1)];
    }

  if(!(p == ((char *)NULL)))
    printf("    %s\n", p);

}

// print_p
// file client_cmd.c line 169
static void print_p(signed int p, signed int debug)
{
  struct sanlk_state *st;
  char *buf;
  char *str;
  char *bin;
  signed int i = 0;
  for( ; !(i >= sort_count); i = i + 1)
  {
    buf = sort_bufs[(signed long int)i];
    if(!(buf == ((char *)NULL)))
    {
      st = (struct sanlk_state *)buf;
      str = buf + (signed long int)sizeof(struct sanlk_state) /*80ul*/ ;
      bin = buf + (signed long int)sizeof(struct sanlk_state) /*80ul*/  + (signed long int)4096;
      if(st->type == 2u)
      {
        if(st->data32 == (unsigned int)p)
        {
          print_st(st, str, bin, debug);
          free((void *)buf);
          sort_bufs[(signed long int)i] = (char *)(void *)0;
          sort_done = sort_done + 1;
        }

      }

    }

  }
}

// print_r
// file client_cmd.c line 215
static void print_r(signed int p, char *s, signed int debug)
{
  struct sanlk_resource *res;
  struct sanlk_state *st;
  char *buf;
  char *str;
  char *bin;
  signed int i = 0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  signed int return_value_strncmp_2;
  for( ; !(i >= sort_count); i = i + 1)
  {
    buf = sort_bufs[(signed long int)i];
    if(!(buf == ((char *)NULL)))
    {
      st = (struct sanlk_state *)buf;
      str = buf + (signed long int)sizeof(struct sanlk_state) /*80ul*/ ;
      bin = buf + (signed long int)sizeof(struct sanlk_state) /*80ul*/  + (signed long int)4096;
      if(st->type == 4u)
      {
        res = (struct sanlk_resource *)bin;
        if(!(p == 0))
          tmp_if_expr_1 = st->data32 == (unsigned int)p ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(tmp_if_expr_1)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          if(!(s == ((char *)NULL)))
          {
            return_value_strncmp_2=strncmp(s, res->lockspace_name, (unsigned long int)48);
            tmp_if_expr_3 = !(return_value_strncmp_2 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_3 = (_Bool)0;
          tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          print_st(st, str, bin, debug);
          free((void *)buf);
          sort_bufs[(signed long int)i] = (char *)(void *)0;
          sort_done = sort_done + 1;
        }

      }

    }

  }
}

// print_r_by_p
// file client_cmd.c line 245
static void print_r_by_p(signed int debug)
{
  struct sanlk_state *st;
  char *buf;
  char *str;
  char *bin;
  signed int rv;
  signed int i;
  for( ; (_Bool)1; sort_done = sort_done + 1)
  {
    rv=find_type(2, &i);
    if(!(rv >= 0))
      goto __CPROVER_DUMP_L4;

    buf = sort_bufs[(signed long int)i];
    st = (struct sanlk_state *)buf;
    str = buf + (signed long int)sizeof(struct sanlk_state) /*80ul*/ ;
    bin = buf + (signed long int)sizeof(struct sanlk_state) /*80ul*/  + (signed long int)4096;
    print_st(st, str, bin, debug);
    print_r((signed int)st->data32, (char *)(void *)0, debug);
    free((void *)buf);
    sort_bufs[(signed long int)i] = (char *)(void *)0;
  }

__CPROVER_DUMP_L4:
  ;
}

// print_r_by_s
// file client_cmd.c line 271
static void print_r_by_s(signed int debug)
{
  struct sanlk_state *st;
  char *buf;
  char *str;
  char *bin;
  signed int rv;
  signed int i;
  for( ; (_Bool)1; sort_done = sort_done + 1)
  {
    rv=find_type(3, &i);
    if(!(rv >= 0))
      goto __CPROVER_DUMP_L4;

    buf = sort_bufs[(signed long int)i];
    st = (struct sanlk_state *)buf;
    str = buf + (signed long int)sizeof(struct sanlk_state) /*80ul*/ ;
    bin = buf + (signed long int)sizeof(struct sanlk_state) /*80ul*/  + (signed long int)4096;
    print_st(st, str, bin, debug);
    print_r(0, st->name, debug);
    free((void *)buf);
    sort_bufs[(signed long int)i] = (char *)(void *)0;
  }

__CPROVER_DUMP_L4:
  ;
}

// print_st
// file client_cmd.c line 123
static void print_st(struct sanlk_state *st, char *str, char *bin, signed int debug)
{
  switch(st->type)
  {
    case (unsigned int)1:
    {
      status_daemon(st, str, debug);
      break;
    }
    case (unsigned int)2:
    {
      status_client(st, str, debug);
      break;
    }
    case (unsigned int)3:
    {
      status_lockspace(st, str, bin, debug);
      break;
    }
    case (unsigned int)4:
      status_resource(st, str, bin, debug);
  }
}

// print_state_client
// file cmd.c line 1273
static signed int print_state_client(struct client *cl, signed int ci, char *str)
{
  memset((void *)str, 0, (unsigned long int)4096);
  snprintf(str, (unsigned long int)(4096 - 1), "ci=%d fd=%d pid=%d restricted=%x cmd_active=%d cmd_last=%d pid_dead=%d kill_count=%d kill_last=%llu suspend=%d need_free=%d", ci, cl->fd, cl->pid, cl->restricted, cl->cmd_active, cl->cmd_last, cl->pid_dead, cl->kill_count, (unsigned long long int)cl->kill_last, cl->suspend, cl->need_free);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  return (signed int)(return_value_strlen_1 + (unsigned long int)1);
}

// print_state_daemon
// file cmd.c line 1250
static signed int print_state_daemon(char *str)
{
  memset((void *)str, 0, (unsigned long int)4096);
  unsigned long int return_value_monotime_1;
  return_value_monotime_1=monotime();
  snprintf(str, (unsigned long int)(4096 - 1), "our_host_name=%s use_aio=%d io_timeout=%d id_renewal=%d id_renewal_fail=%d id_renewal_warn=%d monotime=%llu", (const void *)our_host_name_global, main_task.use_aio, main_task.io_timeout_seconds, main_task.id_renewal_seconds, main_task.id_renewal_fail_seconds, main_task.id_renewal_warn_seconds, (unsigned long long int)return_value_monotime_1);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(str);
  return (signed int)(return_value_strlen_2 + (unsigned long int)1);
}

// print_state_host
// file cmd.c line 1355
static signed int print_state_host(struct host_status *hs, char *str)
{
  memset((void *)str, 0, (unsigned long int)4096);
  snprintf(str, (unsigned long int)(4096 - 1), "last_check=%llu last_live=%llu last_req=%llu owner_id=%llu owner_generation=%llu timestamp=%llu", (unsigned long long int)hs->last_check, (unsigned long long int)hs->last_live, (unsigned long long int)hs->last_req, (unsigned long long int)hs->owner_id, (unsigned long long int)hs->owner_generation, (unsigned long long int)hs->timestamp);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  return (signed int)(return_value_strlen_1 + (unsigned long int)1);
}

// print_state_lockspace
// file cmd.c line 1304
static signed int print_state_lockspace(struct space *sp, char *str, const char *list_name)
{
  memset((void *)str, 0, (unsigned long int)4096);
  snprintf(str, (unsigned long int)(4096 - 1), "list=%s space_id=%u host_generation=%llu space_dead=%d killing_pids=%d corrupt_result=%d acquire_last_result=%d renewal_last_result=%d acquire_last_attempt=%llu acquire_last_success=%llu renewal_last_attempt=%llu renewal_last_success=%llu", list_name, sp->space_id, (unsigned long long int)sp->host_generation, sp->space_dead, sp->killing_pids, sp->lease_status.corrupt_result, sp->lease_status.acquire_last_result, sp->lease_status.renewal_last_result, (unsigned long long int)sp->lease_status.acquire_last_attempt, (unsigned long long int)sp->lease_status.acquire_last_success, (unsigned long long int)sp->lease_status.renewal_last_attempt, (unsigned long long int)sp->lease_status.renewal_last_success);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  return (signed int)(return_value_strlen_1 + (unsigned long int)1);
}

// print_state_resource
// file cmd.c line 1337
static signed int print_state_resource(struct resource *r, char *str, const char *list_name, unsigned int token_id)
{
  memset((void *)str, 0, (unsigned long int)4096);
  snprintf(str, (unsigned long int)(4096 - 1), "list=%s flags=%x lver=%llu token_id=%u", list_name, r->flags, (unsigned long long int)r->leader.lver, token_id);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  return (signed int)(return_value_strlen_1 + (unsigned long int)1);
}

// print_type
// file client_cmd.c line 146
static void print_type(signed int type, signed int debug)
{
  struct sanlk_state *st;
  char *buf;
  char *str;
  char *bin;
  signed int i = 0;
  _Bool tmp_if_expr_1;
  for( ; !(i >= sort_count); i = i + 1)
  {
    buf = sort_bufs[(signed long int)i];
    if(!(buf == ((char *)NULL)))
    {
      st = (struct sanlk_state *)buf;
      str = buf + (signed long int)sizeof(struct sanlk_state) /*80ul*/ ;
      bin = buf + (signed long int)sizeof(struct sanlk_state) /*80ul*/  + (signed long int)4096;
      if(type == 0)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = st->type == (unsigned int)type ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        print_st(st, str, bin, debug);
        free((void *)buf);
        sort_bufs[(signed long int)i] = (char *)(void *)0;
        sort_done = sort_done + 1;
      }

    }

  }
}

// print_usage
// file main.c line 1348
static void print_usage(void)
{
  printf("Usage:\n");
  printf("sanlock <command> <action> ...\n\n");
  printf("commands:\n");
  printf("  daemon        start daemon\n");
  printf("  client        send request to daemon (default type if none given)\n");
  printf("  direct        access storage directly (no coordination with daemon)\n");
  printf("  help          print this usage (defaults in parens)\n");
  printf("  version       print version\n");
  printf("\n");
  printf("sanlock daemon [options]\n");
  printf("  -D            no fork and print all logging to stderr\n");
  printf("  -Q 0|1        quiet error messages for common lock contention (0)\n");
  printf("  -R 0|1        renewal debugging, log debug info about renewals (0)\n");
  printf("  -L <pri>      write logging at priority level and up to logfile (3 LOG_ERR))\n");
  printf("                (use -1 for none)\n");
  printf("  -S <pri>      write logging at priority level and up to syslog (3 LOG_ERR)\n");
  printf("                (use -1 for none)\n");
  printf("  -U <uid>      user id\n");
  printf("  -G <gid>      group id\n");
  printf("  -t <num>      max worker threads (%d)\n", 8);
  printf("  -w 0|1        use watchdog through wdmd (%d)\n", 1);
  printf("  -h 0|1        use high priority features (%d)\n", 1);
  printf("                (realtime scheduling, mlockall)\n");
  printf("  -a 0|1        use async io (%d)\n", 1);
  printf("  -o 0|1        io timeout in seconds (%d)\n", 10);
  printf("\n");
  printf("sanlock client <action> [options]\n");
  printf("sanlock client status [-D] [-o p|s]\n");
  printf("sanlock client host_status -s LOCKSPACE [-D]\n");
  printf("sanlock client log_dump\n");
  printf("sanlock client shutdown [-f 0|1]\n");
  printf("sanlock client init -s LOCKSPACE | -r RESOURCE\n");
  printf("sanlock client align -s LOCKSPACE\n");
  printf("sanlock client add_lockspace -s LOCKSPACE\n");
  printf("sanlock client inq_lockspace -s LOCKSPACE\n");
  printf("sanlock client rem_lockspace -s LOCKSPACE\n");
  printf("sanlock client command -r RESOURCE -c <path> <args>\n");
  printf("sanlock client acquire -r RESOURCE -p <pid>\n");
  printf("sanlock client release -r RESOURCE -p <pid>\n");
  printf("sanlock client inquire -p <pid>\n");
  printf("sanlock client request -r RESOURCE -f <force_mode>\n");
  printf("sanlock client examine -r RESOURCE | -s LOCKSPACE\n");
  printf("\n");
  printf("sanlock direct <action> [-a 0|1] [-o 0|1]\n");
  printf("sanlock direct init -s LOCKSPACE | -r RESOURCE\n");
  printf("sanlock direct read_leader -s LOCKSPACE | -r RESOURCE\n");
  printf("sanlock direct read_id -s LOCKSPACE\n");
  printf("sanlock direct live_id -s LOCKSPACE\n");
  printf("sanlock direct dump <path>[:<offset>]\n");
  printf("\n");
  printf("LOCKSPACE = <lockspace_name>:<host_id>:<path>:<offset>\n");
  printf("  <lockspace_name>\tname of lockspace\n");
  printf("  <host_id>\t\tlocal host identifier in lockspace\n");
  printf("  <path>\t\tdisk to storage reserved for leases\n");
  printf("  <offset>\t\toffset on path (bytes)\n");
  printf("\n");
  printf("RESOURCE = <lockspace_name>:<resource_name>:<path>:<offset>[:<lver>]\n");
  printf("  <lockspace_name>\tname of lockspace\n");
  printf("  <resource_name>\tname of resource\n");
  printf("  <path>\t\tdisk to storage reserved for leases\n");
  printf("  <offset>\t\toffset on path (bytes)\n");
  printf("  <lver>                optional leader version or SH for shared lease\n");
  printf("\n");
  printf("Limits:\n");
  printf("offset alignment with 512 byte sectors: %d (1MB)\n", 1024 * 1024);
  printf("offset alignment with 4096 byte sectors: %d (8MB)\n", 1024 * 1024 * 8);
  printf("maximum name length for lockspaces and resources: %d\n", 48);
  printf("maximum path length: %d\n", 1024);
  printf("maximum host_id: %d\n", 2000);
  printf("maximum client process connections: 1000\n");
  printf("\n");
}

// process_cmd_thread_registered
// file main.c line 838
static void process_cmd_thread_registered(signed int ci_in, struct sm_header *h_recv)
{
  struct cmd_args *ca;
  struct client *cl;
  signed int result = 0;
  signed int rv;
  signed int i;
  signed int ci_target;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct cmd_args) /*64ul*/ );
  ca = (struct cmd_args *)return_value_malloc_1;
  if(ca == ((struct cmd_args *)NULL))
    result = -12;

  else
  {
    if(!(h_recv->data2 == 4294967295u))
    {
      ci_target = -1;
      i = 0;
      for( ; !(i >= client_size); i = i + 1)
      {
        cl = &client[(signed long int)i];
        pthread_mutex_lock(&cl->mutex);
        if(!((unsigned int)cl->pid == h_recv->data2))
          pthread_mutex_unlock(&cl->mutex);

        else
        {
          ci_target = i;
          break;
        }
      }
      if(!(ci_target >= 0))
      {
        result = -3;
        goto fail;
      }

    }

    else
    {
      ci_target = ci_in;
      cl = &client[(signed long int)ci_target];
      pthread_mutex_lock(&cl->mutex);
    }
    if(cl->used == 0)
    {
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd %d %d,%d,%d not used", h_recv->cmd, ci_target, cl->fd, cl->pid);
      result = -16;
    }

    else
      if(!(cl->pid >= 1))
      {
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd %d %d,%d,%d no pid", h_recv->cmd, ci_target, cl->fd, cl->pid);
        result = -16;
      }

      else
        if(!(cl->pid_dead == 0))
        {
          log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd %d %d,%d,%d pid_dead", h_recv->cmd, ci_target, cl->fd, cl->pid);
          result = -16;
        }

        else
          if(!(cl->need_free == 0))
          {
            log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd %d %d,%d,%d need_free", h_recv->cmd, ci_target, cl->fd, cl->pid);
            result = -16;
          }

          else
            if(!(cl->kill_count == 0))
            {
              log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd %d %d,%d,%d kill_count %d", h_recv->cmd, ci_target, cl->fd, cl->pid, cl->kill_count);
              result = -16;
            }

            else
              if(!(cl->cmd_active == 0))
              {
                if(!(com.quiet_fail == 0))
                {
                  if(cl->cmd_active == 7)
                  {
                    result = -16;
                    goto out;
                  }

                }

                log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cmd %d %d,%d,%d cmd_active %d", h_recv->cmd, ci_target, cl->fd, cl->pid, cl->cmd_active);
                result = -16;
              }

              else
                cl->cmd_active = (signed int)h_recv->cmd;

  out:
    ;
    pthread_mutex_unlock(&cl->mutex);
    if(result >= 0)
    {
      ca->ci_in = ci_in;
      ca->ci_target = ci_target;
      ca->cl_pid = cl->pid;
      ca->cl_fd = cl->fd;
      memcpy((void *)&ca->header, (const void *)h_recv, sizeof(struct sm_header) /*32ul*/ );
      rv=thread_pool_add_work(ca);
      if(!(rv >= 0))
      {
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "create cmd thread failed");
        pthread_mutex_lock(&cl->mutex);
        cl->cmd_active = 0;
        pthread_mutex_unlock(&cl->mutex);
        result = rv;
      }

      else
        goto __CPROVER_DUMP_L20;
    }

  }

fail:
  ;
  client_recv_all(ci_in, h_recv, 0);
  send_result((client + (signed long int)ci_in)->fd, h_recv, result);
  client_resume(ci_in);
  if(!(ca == ((struct cmd_args *)NULL)))
    free((void *)ca);


__CPROVER_DUMP_L20:
  ;
}

// process_cmd_thread_unregistered
// file main.c line 808
static void process_cmd_thread_unregistered(signed int ci_in, struct sm_header *h_recv)
{
  struct cmd_args *ca;
  signed int rv;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct cmd_args) /*64ul*/ );
  ca = (struct cmd_args *)return_value_malloc_1;
  if(ca == ((struct cmd_args *)NULL))
    rv = -12;

  else
  {
    ca->ci_in = ci_in;
    memcpy((void *)&ca->header, (const void *)h_recv, sizeof(struct sm_header) /*32ul*/ );
    snprintf((client + (signed long int)ci_in)->owner_name, (unsigned long int)48, "cmd%d", h_recv->cmd);
    rv=thread_pool_add_work(ca);
    if(rv >= 0)
      goto __CPROVER_DUMP_L4;


  fail_free:
    ;
    free((void *)ca);
  }

fail:
  ;
  send_result((client + (signed long int)ci_in)->fd, h_recv, rv);
  close((client + (signed long int)ci_in)->fd);

__CPROVER_DUMP_L4:
  ;
}

// process_connection
// file main.c line 967
static void process_connection(signed int ci)
{
  struct sm_header h;
  void (*deadfn)(signed int);
  signed int rv;
  memset((void *)&h, 0, sizeof(struct sm_header) /*32ul*/ );
  signed long int return_value_recv_1;
  return_value_recv_1=recv((client + (signed long int)ci)->fd, (void *)&h, sizeof(struct sm_header) /*32ul*/ , 256);
  rv = (signed int)return_value_recv_1;
  if(!(rv == 0))
  {
    if(!(rv >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "ci %d fd %d pid %d recv errno %d", ci, (client + (signed long int)ci)->fd, (client + (signed long int)ci)->pid, *return_value___errno_location_2);
      goto dead;
    }

    if(!((unsigned long int)rv == sizeof(struct sm_header) /*32ul*/ ))
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "ci %d fd %d pid %d recv size %d", ci, (client + (signed long int)ci)->fd, (client + (signed long int)ci)->pid, rv);

    else
      if(!(h.magic == 69738512u))
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "ci %d recv %d magic %x vs %x", ci, rv, h.magic, 0x04282010);

      else
        if(!((1u & (client + (signed long int)ci)->restricted) == 0u))
          log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "ci %d fd %d pid %d cmd %d restrict all", ci, (client + (signed long int)ci)->fd, (client + (signed long int)ci)->pid, h.cmd);

        else
        {
          (client + (signed long int)ci)->cmd_last = (signed int)h.cmd;
          switch(h.cmd)
          {
            case (unsigned int)1:

            case (unsigned int)10:

            case (unsigned int)4:

            case (unsigned int)5:

            case (unsigned int)17:

            case (unsigned int)6:
            {
              call_cmd_daemon(ci, &h, client_maxi);
              break;
            }
            case (unsigned int)2:

            case (unsigned int)18:

            case (unsigned int)3:

            case (unsigned int)11:

            case (unsigned int)16:

            case (unsigned int)15:

            case (unsigned int)12:

            case (unsigned int)13:

            case (unsigned int)14:
            {
              rv=client_suspend(ci);
              if(!(rv >= 0))
                goto __CPROVER_DUMP_L15;

              process_cmd_thread_unregistered(ci, &h);
              break;
            }
            case (unsigned int)7:

            case (unsigned int)8:

            case (unsigned int)9:
            {
              rv=client_suspend(ci);
              if(!(rv >= 0))
                goto __CPROVER_DUMP_L15;

              process_cmd_thread_registered(ci, &h);
              break;
            }
            default:
              log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "ci %d cmd %d unknown", ci, h.cmd);
          }
          goto __CPROVER_DUMP_L15;
        }

  dead:
    ;
    deadfn = (void (*)(signed int))(client + (signed long int)ci)->deadfn;
    if(!(deadfn == ((void (*)(signed int))NULL)))
      deadfn(ci);

  }


__CPROVER_DUMP_L15:
  ;
}

// process_listener
// file main.c line 1046
static void process_listener(signed int ci)
{
  signed int fd;
  signed int on = 1;
  fd=accept((client + (signed long int)ci)->fd, (void *)0, (unsigned int *)(void *)0);
  if(fd >= 0)
  {
    setsockopt(fd, 1, 16, (const void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
    client_add(fd, process_connection, (void (*)(signed int))(void *)0);
  }

}

// read_command_line
// file main.c line 1424
static signed int read_command_line(signed int argc, char **argv)
{
  char optchar;
  char *optionarg;
  char *p;
  char *arg1 = argv[(signed long int)1];
  char *act;
  signed int i;
  signed int j;
  signed int len;
  signed int begin_command = 0;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  if(!(argc >= 2))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strcmp_1=strcmp(arg1, "help");
    tmp_if_expr_2 = !(return_value_strcmp_1 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  if(tmp_if_expr_2)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_strcmp_3=strcmp(arg1, "--help");
    tmp_if_expr_4 = !(return_value_strcmp_3 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_5;
  if(tmp_if_expr_4)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_strcmp_5=strcmp(arg1, "-h");
    tmp_if_expr_6 = !(return_value_strcmp_5 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_6)
  {
    print_usage();
    exit(0);
  }

  signed int return_value_strcmp_7;
  return_value_strcmp_7=strcmp(arg1, "version");
  _Bool tmp_if_expr_9;
  signed int return_value_strcmp_8;
  if(return_value_strcmp_7 == 0)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value_strcmp_8=strcmp(arg1, "--version");
    tmp_if_expr_9 = !(return_value_strcmp_8 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_11;
  signed int return_value_strcmp_10;
  if(tmp_if_expr_9)
    tmp_if_expr_11 = (_Bool)1;

  else
  {
    return_value_strcmp_10=strcmp(arg1, "-V");
    tmp_if_expr_11 = !(return_value_strcmp_10 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_11)
  {
    printf("%s %s (built %s %s)\n", argv[(signed long int)0], (const void *)"2.2", (const void *)"Jan 26 2016", (const void *)"11:06:07");
    exit(0);
  }

  signed int return_value_strcmp_14;
  return_value_strcmp_14=strcmp(arg1, "daemon");
  signed int return_value_strcmp_13;
  signed int return_value_strcmp_12;
  if(return_value_strcmp_14 == 0)
  {
    com.type = 1;
    i = 2;
  }

  else
  {
    return_value_strcmp_13=strcmp(arg1, "direct");
    if(return_value_strcmp_13 == 0)
    {
      com.type = 3;
      if(!(argc >= 3))
      {
        print_usage();
        exit(1);
      }

      act = argv[(signed long int)2];
      i = 3;
    }

    else
    {
      return_value_strcmp_12=strcmp(arg1, "client");
      if(return_value_strcmp_12 == 0)
      {
        com.type = 2;
        if(!(argc >= 3))
        {
          print_usage();
          exit(1);
        }

        act = argv[(signed long int)2];
        i = 3;
      }

      else
      {
        com.type = 2;
        act = argv[(signed long int)1];
        i = 2;
      }
    }
  }
  signed int return_value_strcmp_29;
  signed int return_value_strcmp_28;
  signed int return_value_strcmp_27;
  signed int return_value_strcmp_26;
  signed int return_value_strcmp_25;
  signed int return_value_strcmp_24;
  signed int return_value_strcmp_23;
  signed int return_value_strcmp_22;
  signed int return_value_strcmp_21;
  signed int return_value_strcmp_20;
  signed int return_value_strcmp_19;
  signed int return_value_strcmp_18;
  signed int return_value_strcmp_17;
  signed int return_value_strcmp_16;
  signed int return_value_strcmp_15;
  signed int return_value_strcmp_39;
  signed int return_value_strcmp_38;
  signed int return_value_strcmp_37;
  signed int return_value_strcmp_36;
  signed int return_value_strcmp_35;
  signed int return_value_strcmp_34;
  signed int return_value_strcmp_33;
  signed int return_value_strcmp_32;
  signed int return_value_strcmp_31;
  signed int return_value_strcmp_30;
  switch(com.type)
  {
    case 1:
      break;
    case 2:
    {
      return_value_strcmp_29=strcmp(act, "status");
      if(return_value_strcmp_29 == 0)
        com.action = 1;

      else
      {
        return_value_strcmp_28=strcmp(act, "host_status");
        if(return_value_strcmp_28 == 0)
          com.action = 2;

        else
        {
          return_value_strcmp_27=strcmp(act, "log_dump");
          if(return_value_strcmp_27 == 0)
            com.action = 3;

          else
          {
            return_value_strcmp_26=strcmp(act, "shutdown");
            if(return_value_strcmp_26 == 0)
              com.action = 4;

            else
            {
              return_value_strcmp_25=strcmp(act, "add_lockspace");
              if(return_value_strcmp_25 == 0)
                com.action = 5;

              else
              {
                return_value_strcmp_24=strcmp(act, "inq_lockspace");
                if(return_value_strcmp_24 == 0)
                  com.action = 6;

                else
                {
                  return_value_strcmp_23=strcmp(act, "rem_lockspace");
                  if(return_value_strcmp_23 == 0)
                    com.action = 7;

                  else
                  {
                    return_value_strcmp_22=strcmp(act, "command");
                    if(return_value_strcmp_22 == 0)
                      com.action = 8;

                    else
                    {
                      return_value_strcmp_21=strcmp(act, "acquire");
                      if(return_value_strcmp_21 == 0)
                        com.action = 9;

                      else
                      {
                        return_value_strcmp_20=strcmp(act, "release");
                        if(return_value_strcmp_20 == 0)
                          com.action = 10;

                        else
                        {
                          return_value_strcmp_19=strcmp(act, "inquire");
                          if(return_value_strcmp_19 == 0)
                            com.action = 11;

                          else
                          {
                            return_value_strcmp_18=strcmp(act, "request");
                            if(return_value_strcmp_18 == 0)
                              com.action = 12;

                            else
                            {
                              return_value_strcmp_17=strcmp(act, "examine");
                              if(return_value_strcmp_17 == 0)
                                com.action = 23;

                              else
                              {
                                return_value_strcmp_16=strcmp(act, "align");
                                if(return_value_strcmp_16 == 0)
                                  com.action = 22;

                                else
                                {
                                  return_value_strcmp_15=strcmp(act, "init");
                                  if(return_value_strcmp_15 == 0)
                                    com.action = 21;

                                  else
                                  {
                                    do
                                      fprintf(stderr, "client action \"%s\" is unknown\n", act);
                                    while((_Bool)0);
                                    exit(1);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      break;
    }
    case 3:
    {
      return_value_strcmp_39=strcmp(act, "init");
      if(return_value_strcmp_39 == 0)
        com.action = 18;

      else
      {
        return_value_strcmp_38=strcmp(act, "dump");
        if(return_value_strcmp_38 == 0)
          com.action = 19;

        else
        {
          return_value_strcmp_37=strcmp(act, "read_leader");
          if(return_value_strcmp_37 == 0)
            com.action = 20;

          else
          {
            return_value_strcmp_36=strcmp(act, "acquire");
            if(return_value_strcmp_36 == 0)
              com.action = 9;

            else
            {
              return_value_strcmp_35=strcmp(act, "release");
              if(return_value_strcmp_35 == 0)
                com.action = 10;

              else
              {
                return_value_strcmp_34=strcmp(act, "acquire_id");
                if(return_value_strcmp_34 == 0)
                  com.action = 13;

                else
                {
                  return_value_strcmp_33=strcmp(act, "release_id");
                  if(return_value_strcmp_33 == 0)
                    com.action = 14;

                  else
                  {
                    return_value_strcmp_32=strcmp(act, "renew_id");
                    if(return_value_strcmp_32 == 0)
                      com.action = 15;

                    else
                    {
                      return_value_strcmp_31=strcmp(act, "read_id");
                      if(return_value_strcmp_31 == 0)
                        com.action = 16;

                      else
                      {
                        return_value_strcmp_30=strcmp(act, "live_id");
                        if(return_value_strcmp_30 == 0)
                          com.action = 17;

                        else
                        {
                          do
                            fprintf(stderr, "direct action \"%s\" is unknown\n", act);
                          while((_Bool)0);
                          exit(1);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  signed int tmp_post_40;
  if(com.action == 19)
  {
    if(!(argc >= 4))
      exit(1);

    tmp_post_40 = i;
    i = i + 1;
    optionarg = argv[(signed long int)tmp_post_40];
    com.dump_path=strdup(optionarg);
  }

  _Bool tmp_if_expr_42;
  unsigned long int return_value_strlen_41;
  signed long long int return_value_atoll_43;
  signed long long int return_value_atoll_44;
  unsigned long int return_value_strtoul_45;
  while(!(i >= argc))
  {
    p = argv[(signed long int)i];
    if(!((signed int)*p == 45))
      tmp_if_expr_42 = (_Bool)1;

    else
    {
      return_value_strlen_41=strlen(p);
      tmp_if_expr_42 = return_value_strlen_41 != (unsigned long int)2 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_42)
    {
      do
        fprintf(stderr, "unknown option %s\n", p);
      while((_Bool)0);
      do
        fprintf(stderr, "space required before option value\n");
      while((_Bool)0);
      exit(1);
    }

    optchar = p[(signed long int)1];
    i = i + 1;
    if((signed int)optchar == 68)
    {
      com.debug = 1;
      log_stderr_priority = 7;
    }

    else
    {
      if(i >= argc)
      {
        do
          fprintf(stderr, "option '%c' requires arg\n", optchar);
        while((_Bool)0);
        exit(1);
      }

      optionarg = argv[(signed long int)i];
      switch((signed int)optchar)
      {
        case 81:
        {
          com.quiet_fail=atoi(optionarg);
          break;
        }
        case 82:
        {
          com.debug_renew=atoi(optionarg);
          break;
        }
        case 76:
        {
          log_logfile_priority=atoi(optionarg);
          break;
        }
        case 83:
        {
          log_syslog_priority=atoi(optionarg);
          break;
        }
        case 97:
        {
          com.aio_arg=atoi(optionarg);
          if(!(com.aio_arg == 0) && !(com.aio_arg == 1))
            com.aio_arg = 1;

          break;
        }
        case 116:
        {
          com.max_worker_threads=atoi(optionarg);
          if(!(com.max_worker_threads >= 2))
            com.max_worker_threads = 2;

          break;
        }
        case 119:
        {
          com.use_watchdog=atoi(optionarg);
          break;
        }
        case 104:
        {
          com.high_priority=atoi(optionarg);
          break;
        }
        case 111:
        {
          if(com.action == 1)
            com.sort_arg = *optionarg;

          else
          {
            com.io_timeout_arg=atoi(optionarg);
            if(com.io_timeout_arg == 0)
              com.io_timeout_arg = 10;

          }
          break;
        }
        case 110:
        {
          com.num_hosts=atoi(optionarg);
          break;
        }
        case 109:
        {
          com.max_hosts=atoi(optionarg);
          break;
        }
        case 112:
        {
          com.pid=atoi(optionarg);
          break;
        }
        case 101:
        {
          strncpy(com.our_host_name, optionarg, (unsigned long int)48);
          break;
        }
        case 105:
        {
          return_value_atoll_43=atoll(optionarg);
          com.local_host_id = (unsigned long int)return_value_atoll_43;
          break;
        }
        case 103:
        {
          return_value_atoll_44=atoll(optionarg);
          com.local_host_generation = (unsigned long int)return_value_atoll_44;
          break;
        }
        case 102:
        {
          return_value_strtoul_45=strtoul(optionarg, (char ** restrict )(void *)0, 0);
          com.force_mode = (unsigned int)return_value_strtoul_45;
          break;
        }
        case 115:
        {
          parse_arg_lockspace(optionarg);
          break;
        }
        case 114:
        {
          parse_arg_resource(optionarg);
          break;
        }
        case 85:
        {
          com.uid=user_to_uid(optionarg);
          break;
        }
        case 71:
        {
          com.gid=group_to_gid(optionarg);
          break;
        }
        case 99:
        {
          begin_command = 1;
          break;
        }
        default:
        {
          do
            fprintf(stderr, "unknown option: %c\n", optchar);
          while((_Bool)0);
          exit(1);
        }
      }
      if(!(begin_command == 0))
        break;

      i = i + 1;
    }
  }
  signed int tmp_post_47;
  if(!(begin_command == 0))
  {
    cmd_argc = argc - i;
    if(!(cmd_argc >= 1))
    {
      do
        fprintf(stderr, "command option (-c) requires an arg\n");
      while((_Bool)0);
      return -22;
    }

    len = (signed int)((unsigned long int)(cmd_argc + 1) * sizeof(char *) /*8ul*/ );
    void *return_value_malloc_46;
    return_value_malloc_46=malloc((unsigned long int)len);
    cmd_argv = (char **)return_value_malloc_46;
    if(cmd_argv == ((char **)NULL))
      return -12;

    memset((void *)cmd_argv, 0, (unsigned long int)len);
    j = 0;
    for( ; !(j >= cmd_argc); j = j + 1)
    {
      tmp_post_47 = i;
      i = i + 1;
      cmd_argv[(signed long int)j]=strdup(argv[(signed long int)tmp_post_47]);
      if(cmd_argv[(signed long int)j] == ((char *)NULL))
        return -12;

    }
    strncpy(command, cmd_argv[(signed long int)0], (unsigned long int)(4096 - 1));
  }

  return 0;
}

// read_iobuf
// file diskio.h line 26
signed int read_iobuf(signed int fd, unsigned long int offset, char *iobuf, signed int iobuf_len, struct task *task)
{
  _Bool tmp_if_expr_5;
  if(!(task == ((struct task *)NULL)))
    tmp_if_expr_5 = task->use_aio == 1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_5 = (_Bool)0;
  signed int return_value_do_read_aio_linux_1;
  _Bool tmp_if_expr_4;
  signed int return_value_do_read_aio_posix_2;
  signed int return_value_do_read_3;
  if(tmp_if_expr_5)
  {
    return_value_do_read_aio_linux_1=do_read_aio_linux(fd, offset, iobuf, iobuf_len, task);
    return return_value_do_read_aio_linux_1;
  }

  else
  {
    if(!(task == ((struct task *)NULL)))
      tmp_if_expr_4 = task->use_aio == 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      return_value_do_read_aio_posix_2=do_read_aio_posix(fd, offset, iobuf, iobuf_len, task);
      return return_value_do_read_aio_posix_2;
    }

    else
    {
      return_value_do_read_3=do_read(fd, offset, iobuf, iobuf_len, task);
      return return_value_do_read_3;
    }
  }
}

// read_iobuf_reap
// file diskio.h line 29
signed int read_iobuf_reap(signed int fd, unsigned long int offset, char *iobuf, signed int iobuf_len, struct task *task)
{
  struct timespec ts;
  struct aicb *aicb;
  struct iocb *iocb;
  struct io_event event;
  signed int rv;
  aicb = task->read_iobuf_timeout_aicb;
  iocb = &aicb->iocb;
  struct iocb *ev_iocb;
  struct aicb *ev_aicb;
  struct aicb *tmp_statement_expression_1;
  if(aicb->used == 0)
    return -22;

  else
    if(!(iocb->aio_fildes == fd))
      return -22;

    else
      if(!((char *)iocb->u.c.buf == iobuf))
        return -22;

      else
        if(!(iocb->u.c.nbytes == (unsigned long int)iobuf_len))
          return -22;

        else
          if(!((unsigned long int)iocb->u.c.offset == offset))
            return -22;

          else
            if(!((signed int)iocb->aio_lio_opcode == 0))
              return -22;

            else
            {
              memset((void *)&ts, 0, sizeof(struct timespec) /*16ul*/ );
              ts.tv_nsec = (signed long int)500000000;
              do
              {

              retry:
                ;
                memset((void *)&event, 0, sizeof(struct io_event) /*32ul*/ );
                rv=io_getevents(task->aio_ctx, (signed long int)1, (signed long int)1, &event, &ts);
                if(rv == -4)
                  goto retry;

                if(!(rv >= 0))
                {
                  log_level((unsigned int)0, (unsigned int)0, task->name, 3, "aio getevent %p:%p:%p rv %d r", aicb, iocb, iobuf, rv);
                  goto out;
                }

                if(!(rv == 1))
                  goto __CPROVER_DUMP_L12;

                ev_iocb = event.obj;
                const struct iocb *__mptr = ev_iocb;
                tmp_statement_expression_1 = (struct aicb *)((char *)__mptr - (signed long int)16ul);
                ev_aicb = tmp_statement_expression_1;
                ev_aicb->used = 0;
                if(ev_iocb == iocb)
                  break;

                log_level((unsigned int)0, (unsigned int)0, task->name, 3, "aio collect %p:%p:%p result %ld:%ld other free r", ev_aicb, ev_iocb, ev_aicb->buf, event.res, event.res2);
                free((void *)ev_aicb->buf);
                ev_aicb->buf = (char *)(void *)0;
              }
              while((_Bool)1);
              if(!((signed int)event.res >= 0))
              {
                log_level((unsigned int)0, (unsigned int)0, task->name, 3, "aio collect %p:%p:%p result %ld:%ld match res r", ev_aicb, ev_iocb, ev_aicb->buf, event.res, event.res2);
                rv = (signed int)event.res;
              }

              else
                if(!(event.res == (unsigned long int)iobuf_len))
                {
                  log_level((unsigned int)0, (unsigned int)0, task->name, 3, "aio collect %p:%p:%p result %ld:%ld match len %d r", ev_aicb, ev_iocb, ev_aicb->buf, event.res, event.res2, iobuf_len);
                  rv = -90;
                }

                else
                {
                  log_level((unsigned int)0, (unsigned int)0, task->name, 3, "aio collect %p:%p:%p result %ld:%ld match reap", ev_aicb, ev_iocb, ev_aicb->buf, event.res, event.res2);
                  rv = 0;
                  goto out;

                __CPROVER_DUMP_L12:
                  ;
                  rv = -202;
                }

            out:
              ;
              return rv;
            }
}

// read_leader
// file paxos_lease.c line 169
static signed int read_leader(struct task *task, struct sync_disk *disk, struct leader_record *lr)
{
  signed int rv;
  rv=read_sectors(disk, (unsigned long int)0, (unsigned int)1, (char *)lr, (signed int)sizeof(struct leader_record) /*200ul*/ , task, "leader");
  return rv;
}

// read_leader_link1
// file paxos_lease.c line 169
static signed int read_leader_link1(struct task *task_link1, struct sync_disk *disk_link1, struct leader_record *lr_link1)
{
  signed int rv_link1;
  rv_link1=read_sectors(disk_link1, (unsigned long int)0, (unsigned int)1, (char *)lr_link1, (signed int)sizeof(struct leader_record) /*200ul*/ , task_link1, "leader");
  return rv_link1;
}

// read_mode_block
// file resource.c line 199
static signed int read_mode_block(struct task *task, struct token *token, unsigned long int host_id, unsigned long int *max_gen)
{
  struct sync_disk *disk;
  struct mode_block *mb;
  char *iobuf;
  char **p_iobuf;
  unsigned long int offset;
  unsigned long int max = (unsigned long int)0;
  signed int num_disks = (signed int)token->r.num_disks;
  signed int iobuf_len;
  signed int rv;
  signed int d;
  disk = &token->disks[(signed long int)0];
  iobuf_len = (signed int)disk->sector_size;
  _Bool tmp_if_expr_2;
  if(iobuf_len == 0)
    return -22;

  else
  {
    p_iobuf = &iobuf;
    signed int return_value_getpagesize_1;
    return_value_getpagesize_1=getpagesize();
    rv=posix_memalign((void **)(void *)p_iobuf, (unsigned long int)return_value_getpagesize_1, (unsigned long int)iobuf_len);
    if(!(rv == 0))
      return -12;

    else
    {
      d = 0;
      for( ; !(d >= num_disks); d = d + 1)
      {
        disk = &token->disks[(signed long int)d];
        offset = disk->offset + (((unsigned long int)2 + host_id) - (unsigned long int)1) * (unsigned long int)disk->sector_size;
        rv=read_iobuf(disk->fd, offset, iobuf, iobuf_len, task);
        if(!(rv >= 0))
          break;

        mb = (struct mode_block *)(iobuf + (signed long int)128);
        if(!((1u & mb->flags) == 0u))
        {
          if(max == 0ul)
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = mb->generation > max ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_2)
            max = mb->generation;

        }

      }
      if(!(rv == -202))
        free((void *)iobuf);

      *max_gen = max;
      return rv;
    }
  }
}

// read_sectors
// file diskio.h line 45
signed int read_sectors(struct sync_disk *disk, unsigned long int sector_nr, unsigned int sector_count, char *data, signed int data_len, struct task *task, const char *blktype)
{
  char *iobuf;
  char **p_iobuf;
  unsigned long int offset;
  signed int iobuf_len;
  signed int rv;
  if(disk->sector_size == 0u)
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "read_sectors %s zero sector_size", blktype);
    return -22;
  }

  else
  {
    iobuf_len = (signed int)(sector_count * disk->sector_size);
    offset = disk->offset + sector_nr * (unsigned long int)disk->sector_size;
    p_iobuf = &iobuf;
    signed int return_value_getpagesize_1;
    return_value_getpagesize_1=getpagesize();
    rv=posix_memalign((void **)(void *)p_iobuf, (unsigned long int)return_value_getpagesize_1, (unsigned long int)iobuf_len);
    if(!(rv == 0))
    {
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "read_sectors %s posix_memalign rv %d %s", blktype, rv, (const void *)disk->path);
      rv = -12;
    }

    else
    {
      memset((void *)iobuf, 0, (unsigned long int)iobuf_len);
      rv=read_iobuf(disk->fd, offset, iobuf, iobuf_len, task);
      if(rv == 0)
        memcpy((void *)data, (const void *)iobuf, (unsigned long int)data_len);

      else
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "read_sectors %s offset %llu rv %d %s", blktype, (unsigned long long int)offset, rv, (const void *)disk->path);
      if(!(rv == -202))
        free((void *)iobuf);

    }

  out:
    ;
    return rv;
  }
}

// recv_bin
// file client_cmd.c line 297
static void recv_bin(signed int fd, struct sanlk_state *st, char *bin)
{
  struct sanlk_resource *res;
  if(st->type == 3u)
    recv(fd, (void *)bin, sizeof(struct sanlk_lockspace) /*1104ul*/ , 256);

  else
    if(st->type == 4u)
    {
      recv(fd, (void *)bin, sizeof(struct sanlk_resource) /*128ul*/ , 256);
      res = (struct sanlk_resource *)bin;
      recv(fd, (void *)(bin + (signed long int)sizeof(struct sanlk_resource) /*128ul*/ ), (unsigned long int)res->num_disks * sizeof(struct sanlk_disk) /*1040ul*/ , 256);
    }

}

// recv_result
// file client.c line 103
static signed int recv_result(signed int fd)
{
  struct sm_header h;
  signed int rv;
  memset((void *)&h, 0, sizeof(struct sm_header) /*32ul*/ );
  signed long int return_value_recv_1;
  return_value_recv_1=recv(fd, (void *)&h, sizeof(struct sm_header) /*32ul*/ , 256);
  rv = (signed int)return_value_recv_1;
  signed int *return_value___errno_location_2;
  if(!(rv >= 0))
  {
    return_value___errno_location_2=__errno_location();
    return -(*return_value___errno_location_2);
  }

  else
    if(!((unsigned long int)rv == sizeof(struct sm_header) /*32ul*/ ))
      return -1;

    else
      return (signed int)h.data;
}

// release_cl_tokens
// file cmd.c line 59
static void release_cl_tokens(struct task *task, struct client *cl)
{
  struct token *token;
  signed int j = 0;
  for( ; !(j >= 8); j = j + 1)
  {
    token = cl->tokens[(signed long int)j];
    if(!(token == ((struct token *)NULL)))
    {
      release_token(task, token);
      free((void *)token);
    }

  }
}

// release_disk
// file resource.c line 323
static signed int release_disk(struct task *task, struct token *token, struct leader_record *leader)
{
  struct leader_record leader_tmp;
  signed int rv;
  rv=paxos_lease_release(task, token, leader, &leader_tmp);
  log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "release_disk rv %d", rv);
  if(!(rv >= 0))
    return rv;

  else
  {
    memcpy((void *)leader, (const void *)&leader_tmp, sizeof(struct leader_record) /*200ul*/ );
    return rv;
  }
}

// release_new_tokens
// file cmd.c line 73
static void release_new_tokens(struct task *task, struct token **new_tokens, signed int alloc_count, signed int acquire_count)
{
  signed int i = 0;
  for( ; !(i >= acquire_count); i = i + 1)
    release_token(task, new_tokens[(signed long int)i]);
  i = 0;
  for( ; !(i >= alloc_count); i = i + 1)
    free((void *)new_tokens[(signed long int)i]);
}

// release_token
// file resource.c line 430
signed int release_token(struct task *task, struct token *token)
{
  signed int return_value__release_token_1;
  return_value__release_token_1=_release_token(task, token, 0, 0);
  return return_value__release_token_1;
}

// release_token_async
// file resource.h line 20
void release_token_async(struct token *token)
{
  struct resource *r = token->resource;
  pthread_mutex_lock(&resource_mutex);
  list_del_link2(&token->list);
  signed int return_value_list_empty_2;
  return_value_list_empty_2=list_empty_link1(&r->tokens);
  _Bool tmp_if_expr_1;
  if(!(return_value_list_empty_2 == 0))
  {
    if(!((2u & token->flags) == 0u))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = !(r->leader.lver != 0ul) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      list_del_link2(&r->list);
      free((void *)r);
    }

    else
    {
      r->flags = r->flags | (unsigned int)0x00000004;
      r->release_token_id = token->token_id;
      resource_thread_work = 1;
      list_move_link2(&r->list, &resources_rem);
      pthread_cond_signal(&resource_cond);
    }
  }

  pthread_mutex_unlock(&resource_mutex);
}

// release_token_nodisk
// file resource.c line 420
static signed int release_token_nodisk(struct task *task, struct token *token)
{
  signed int return_value__release_token_1;
  return_value__release_token_1=_release_token(task, token, 0, 1);
  return return_value__release_token_1;
}

// release_token_opened
// file resource.c line 425
static signed int release_token_opened(struct task *task, struct token *token)
{
  signed int return_value__release_token_1;
  return_value__release_token_1=_release_token(task, token, 1, 0);
  return return_value__release_token_1;
}

// rem_lockspace_start
// file lockspace.c line 748
signed int rem_lockspace_start(struct sanlk_lockspace *ls, unsigned int *space_id)
{
  struct space *sp;
  unsigned int id;
  signed int rv;
  pthread_mutex_lock(&spaces_mutex);
  sp=_search_space(ls->name, (struct sync_disk *)&ls->host_id_disk, ls->host_id, &spaces_rem, (struct list_head *)(void *)0, (struct list_head *)(void *)0);
  if(!(sp == ((struct space *)NULL)))
  {
    pthread_mutex_unlock(&spaces_mutex);
    rv = -115;
  }

  else
  {
    sp=_search_space(ls->name, (struct sync_disk *)&ls->host_id_disk, ls->host_id, &spaces_add, (struct list_head *)(void *)0, (struct list_head *)(void *)0);
    if(!(sp == ((struct space *)NULL)))
    {
      sp->external_remove = 1;
      pthread_mutex_unlock(&spaces_mutex);
      rv = 0;
    }

    else
    {
      sp=_search_space(ls->name, (struct sync_disk *)&ls->host_id_disk, ls->host_id, &spaces, (struct list_head *)(void *)0, (struct list_head *)(void *)0);
      if(sp == ((struct space *)NULL))
      {
        pthread_mutex_unlock(&spaces_mutex);
        rv = -2;
      }

      else
      {
        sp->external_remove = 1;
        id = sp->space_id;
        pthread_mutex_unlock(&spaces_mutex);
        *space_id = id;
        rv = 0;
      }
    }
  }

out:
  ;
  return rv;
}

// rem_lockspace_wait
// file lockspace.c line 806
signed int rem_lockspace_wait(struct sanlk_lockspace *ls, unsigned int space_id)
{
  struct space *sp;
  signed int done;
  _Bool tmp_if_expr_1;
  while((_Bool)1)
  {
    pthread_mutex_lock(&spaces_mutex);
    sp=_search_space(ls->name, (struct sync_disk *)&ls->host_id_disk, ls->host_id, &spaces, &spaces_rem, (struct list_head *)(void *)0);
    if(!(sp == ((struct space *)NULL)))
      tmp_if_expr_1 = sp->space_id == space_id ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      done = 0;

    else
      done = 1;
    pthread_mutex_unlock(&spaces_mutex);
    if(!(done == 0))
      break;

    sleep((unsigned int)1);
  }
  return 0;
}

// request_token
// file resource.c line 695
signed int request_token(struct task *task, struct token *token, unsigned int force_mode, unsigned long int *owner_id)
{
  struct leader_record leader;
  struct request_record req;
  signed int rv;
  memset((void *)&req, 0, sizeof(struct request_record) /*24ul*/ );
  rv=open_disks(token->disks, (signed int)token->r.num_disks);
  if(!(rv >= 0))
  {
    log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "request_token open error %d", rv);
    return rv;
  }

  else
  {
    if(token->acquire_lver == 0ul)
    {
      if(force_mode == 0u)
        goto req_read;

    }

    rv=paxos_lease_leader_read(task, token, &leader, "request");
    if(rv >= 0)
    {
      if(leader.timestamp == 0ul)
      {
        *owner_id = (unsigned long int)0;
        rv = 1;
      }

      else
      {
        *owner_id = leader.owner_id;
        if(leader.lver >= token->acquire_lver)
          rv = -272;

        else
        {

        req_read:
          ;
          rv=paxos_lease_request_read(task, token, &req);
          if(rv >= 0)
          {
            if(!(req.magic == 136912913u))
              rv = -270;

            else
              if(!((0xFFFF0000 & req.version) == 65536u))
                rv = -271;

              else
              {
                if(token->acquire_lver == 0ul)
                {
                  if(force_mode == 0u)
                    goto req_write;

                }

                if(!(token->acquire_lver >= req.lver))
                  rv = -273;

                else
                {

                req_write:
                  ;
                  req.version = (unsigned int)(0x00010000 | 0x00000001);
                  req.lver = token->acquire_lver;
                  req.force_mode = force_mode;
                  rv=paxos_lease_request_write(task, token, &req);
                }
              }
          }

        }
      }
    }


  out:
    ;
    close_disks(token->disks, (signed int)token->r.num_disks);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "request_token rv %d owner %llu lver %llu mode %u", rv, (unsigned long long int)*owner_id, (unsigned long long int)req.lver, req.force_mode);
    return rv;
  }
}

// resource_thread
// file resource.c line 934
static void * resource_thread(void *arg)
{
  struct task task;
  struct resource *r;
  struct token *tt = (struct token *)(void *)0;
  unsigned long int lver;
  signed int pid;
  signed int tt_len;
  memset((void *)&task, 0, sizeof(struct task) /*136ul*/ );
  setup_task_timeouts(&task, main_task.io_timeout_seconds);
  setup_task_aio(&task, main_task.use_aio, 2);
  sprintf(task.name, "%s", (const void *)"resource");
  tt_len = (signed int)(sizeof(struct token) /*472ul*/  + (unsigned long int)4 * sizeof(struct sync_disk) /*1040ul*/ );
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)tt_len);
  tt = (struct token *)return_value_malloc_1;
  if(tt == ((struct token *)NULL))
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "resource_thread tt malloc error");

  else
    while((_Bool)1)
    {
      pthread_mutex_lock(&resource_mutex);
      while(resource_thread_work == 0)
      {
        if(!(resource_thread_stop == 0))
        {
          pthread_mutex_unlock(&resource_mutex);
          goto out;
        }

        pthread_cond_wait(&resource_cond, &resource_mutex);
      }
      memset((void *)tt, 0, (unsigned long int)tt_len);
      tt->disks = (struct sync_disk *)&tt->r.disks[(signed long int)0];
      r=find_resource_flag(&resources_rem, (unsigned int)0x00000004);
      if(!(r == ((struct resource *)NULL)))
      {
        memcpy((void *)&tt->r, (const void *)&r->r, sizeof(struct sanlk_resource) /*128ul*/ );
        copy_disks((void *)&tt->r.disks, (void *)&r->r.disks, (signed int)r->r.num_disks);
        tt->host_id = r->host_id;
        tt->host_generation = r->host_generation;
        tt->token_id = r->release_token_id;
        r->flags = r->flags & (unsigned int)~0x00000004;
        pthread_mutex_unlock(&resource_mutex);
        resource_thread_release(&task, r, tt);
      }

      else
      {
        r=find_resource_flag(&resources_held, (unsigned int)0x00000002);
        if(!(r == ((struct resource *)NULL)))
        {
          memcpy((void *)&tt->r, (const void *)&r->r, sizeof(struct sanlk_resource) /*128ul*/ );
          copy_disks((void *)&tt->r.disks, (void *)&r->r.disks, (signed int)r->r.num_disks);
          tt->host_id = r->host_id;
          tt->host_generation = r->host_generation;
          pid = r->pid;
          lver = r->leader.lver;
          r->flags = r->flags & (unsigned int)~0x00000002;
          pthread_mutex_unlock(&resource_mutex);
          resource_thread_examine(&task, tt, pid, lver);
        }

        else
        {
          resource_thread_work = 0;
          pthread_mutex_unlock(&resource_mutex);
        }
      }
    }

out:
  ;
  if(!(tt == ((struct token *)NULL)))
    free((void *)tt);

  close_task_aio(&task);
  return (void *)0;
}

// resource_thread_examine
// file resource.c line 900
static void resource_thread_examine(struct task *task, struct token *tt, signed int pid, unsigned long int lver)
{
  struct request_record req;
  signed int rv;
  rv=open_disks_fd(tt->disks, (signed int)tt->r.num_disks);
  if(!(rv >= 0))
    log_level((unsigned int)0, tt->token_id, (char *)(void *)0, 3, "resource_thread_examine open error %d", rv);

  else
  {
    rv=examine_token(task, tt, &req);
    close_disks(tt->disks, (signed int)tt->r.num_disks);
    if(rv == 1)
    {
      if(!(req.force_mode == 0u) && !(req.lver == 0ul))
      {
        if(lver >= req.lver)
          log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "examine req lver %llu our lver %llu", (unsigned long long int)req.lver, (unsigned long long int)lver);

        else
          if(req.force_mode == 1u)
            do_req_kill_pid(tt, pid);

          else
            log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "req force_mode %u unknown", req.force_mode);
      }

    }

  }
}

// resource_thread_release
// file resource.c line 876
static void resource_thread_release(struct task *task, struct resource *r, struct token *tt)
{
  signed int rv;
  rv=open_disks_fd(tt->disks, (signed int)tt->r.num_disks);
  if(!(rv >= 0))
    log_level((unsigned int)0, tt->token_id, (char *)(void *)0, 3, "resource_thread_release open error %d", rv);

  else
  {
    if(!((1u & r->flags) == 0u))
      set_mode_block(task, tt, tt->host_id, (unsigned long int)0, (unsigned int)0);

    else
      release_disk(task, tt, &r->leader);
    close_disks(tt->disks, (signed int)tt->r.num_disks);
  }

out:
  ;
  pthread_mutex_lock(&resource_mutex);
  list_del_link2(&r->list);
  pthread_mutex_unlock(&resource_mutex);
  free((void *)r);
}

// roundup_power_of_two
// file paxos_lease.c line 48
static unsigned int roundup_power_of_two(unsigned int val)
{
  val = val - 1u;
  val = val | val >> 1;
  val = val | val >> 2;
  val = val | val >> 4;
  val = val | val >> 8;
  val = val | val >> 16;
  val = val + 1u;
  return val;
}

// roundup_power_of_two_link1
// file paxos_lease.c line 48
static unsigned int roundup_power_of_two_link1(unsigned int val_link1)
{
  val_link1 = val_link1 - 1u;
  val_link1 = val_link1 | val_link1 >> 1;
  val_link1 = val_link1 | val_link1 >> 2;
  val_link1 = val_link1 | val_link1 >> 4;
  val_link1 = val_link1 | val_link1 >> 8;
  val_link1 = val_link1 | val_link1 >> 16;
  val_link1 = val_link1 + 1u;
  return val_link1;
}

// run_ballot
// file paxos_lease.c line 253
static signed int run_ballot(struct task *task, struct token *token, signed int num_hosts, unsigned long int next_lver, unsigned long int our_mbal, struct paxos_dblock *dblock_out)
{
  struct paxos_dblock dblock;
  struct paxos_dblock bk_max;
  struct paxos_dblock *bk;
  struct sync_disk *disk;
  char *iobuf[4l];
  char **p_iobuf[4l];
  signed int num_disks = (signed int)token->r.num_disks;
  signed int num_writes;
  signed int num_reads;
  signed int sector_size = (signed int)(token->disks + (signed long int)0)->sector_size;
  signed int sector_count;
  signed int iobuf_len;
  signed int d;
  signed int q;
  signed int rv;
  signed int q_max = -1;
  signed int error;
  unsigned int return_value_roundup_power_of_two_1;
  return_value_roundup_power_of_two_1=roundup_power_of_two((unsigned int)(num_hosts + 2));
  sector_count = (signed int)return_value_roundup_power_of_two_1;
  iobuf_len = sector_count * sector_size;
  signed int return_value_majority_disks_4;
  signed int return_value_majority_disks_5;
  signed int return_value_majority_disks_6;
  if(iobuf_len == 0)
    return -22;

  else
  {
    d = 0;
    for( ; !(d >= num_disks); d = d + 1)
    {
      p_iobuf[(signed long int)d] = &iobuf[(signed long int)d];
      signed int return_value_getpagesize_2;
      return_value_getpagesize_2=getpagesize();
      rv=posix_memalign((void **)(void *)p_iobuf[(signed long int)d], (unsigned long int)return_value_getpagesize_2, (unsigned long int)iobuf_len);
      if(!(rv == 0))
        return rv;

    }
    log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "ballot %llu phase1 mbal %llu", (unsigned long long int)next_lver, (unsigned long long int)our_mbal);
    memset((void *)&dblock, 0, sizeof(struct paxos_dblock) /*56ul*/ );
    dblock.mbal = our_mbal;
    dblock.lver = next_lver;
    dblock.checksum=dblock_checksum(&dblock);
    memset((void *)&bk_max, 0, sizeof(struct paxos_dblock) /*56ul*/ );
    num_writes = 0;
    d = 0;
    for( ; !(d >= num_disks); d = d + 1)
    {
      rv=write_dblock(task, &token->disks[(signed long int)d], token->host_id, &dblock);
      if(rv >= 0)
        num_writes = num_writes + 1;

    }
    signed int return_value_majority_disks_3;
    return_value_majority_disks_3=majority_disks(num_disks, num_writes);
    if(return_value_majority_disks_3 == 0)
    {
      log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "ballot %llu dblock write error %d", (unsigned long long int)next_lver, rv);
      error = -211;
    }

    else
    {
      num_reads = 0;
      d = 0;
      for( ; !(d >= num_disks); d = d + 1)
      {
        disk = &token->disks[(signed long int)d];
        if(!(iobuf[(signed long int)d] == ((char *)NULL)))
        {
          memset((void *)iobuf[(signed long int)d], 0, (unsigned long int)iobuf_len);
          rv=read_iobuf(disk->fd, disk->offset, iobuf[(signed long int)d], iobuf_len, task);
          if(rv == -202)
            iobuf[(signed long int)d] = (char *)(void *)0;

          if(rv >= 0)
          {
            num_reads = num_reads + 1;
            q = 0;
            for( ; !(q >= num_hosts); q = q + 1)
            {
              bk = (struct paxos_dblock *)(iobuf[(signed long int)d] + (signed long int)((2 + q) * sector_size));
              rv=verify_dblock(token, bk);
              if(rv >= 0)
              {
                check_mode_block(token, q, (char *)bk);
                if(bk->lver >= dblock.lver)
                {
                  if(!(dblock.lver >= bk->lver))
                  {
                    log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "ballot %llu larger1 lver[%d] %llu", (unsigned long long int)next_lver, q, (unsigned long long int)bk->lver);
                    error = -212;
                    goto out;
                  }

                  if(!(dblock.mbal >= bk->mbal))
                  {
                    log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "ballot %llu abort1 mbal %llu mbal[%d] %llu", (unsigned long long int)next_lver, (unsigned long long int)our_mbal, q, (unsigned long long int)bk->mbal);
                    error = -213;
                    goto out;
                  }

                  if(!(bk->inp == 0ul))
                  {
                    if(bk->bal == 0ul)
                      log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "ballot %llu zero bal inp[%d] %llu", (unsigned long long int)next_lver, q, (unsigned long long int)bk->inp);

                    else
                      if(!(bk_max.bal >= bk->bal))
                      {
                        bk_max = *bk;
                        q_max = q;
                      }

                  }

                }

              }

            }
          }

        }

      }
      return_value_majority_disks_4=majority_disks(num_disks, num_reads);
      if(return_value_majority_disks_4 == 0)
      {
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "ballot %llu dblock read error %d", (unsigned long long int)next_lver, rv);
        error = -210;
      }

      else
      {
        if(!(bk_max.inp == 0ul))
        {
          dblock.inp = bk_max.inp;
          dblock.inp2 = bk_max.inp2;
          dblock.inp3 = bk_max.inp3;
        }

        else
        {
          dblock.inp = token->host_id;
          dblock.inp2 = token->host_generation;
          dblock.inp3=monotime();
        }
        dblock.bal = dblock.mbal;
        dblock.checksum=dblock_checksum(&dblock);
        if(!(bk_max.inp == 0ul))
          log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "ballot %llu choose bk_max[%d] lver %llu mbal %llu bal %llu inp %llu %llu %llu", (unsigned long long int)next_lver, q_max, (unsigned long long int)bk_max.lver, (unsigned long long int)bk_max.mbal, (unsigned long long int)bk_max.bal, (unsigned long long int)bk_max.inp, (unsigned long long int)bk_max.inp2, (unsigned long long int)bk_max.inp3);

        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "ballot %llu phase2 bal %llu inp %llu %llu %llu q_max %d", (unsigned long long int)dblock.lver, (unsigned long long int)dblock.bal, (unsigned long long int)dblock.inp, (unsigned long long int)dblock.inp2, (unsigned long long int)dblock.inp3, q_max);
        num_writes = 0;
        d = 0;
        for( ; !(d >= num_disks); d = d + 1)
        {
          rv=write_dblock(task, &token->disks[(signed long int)d], token->host_id, &dblock);
          if(rv >= 0)
            num_writes = num_writes + 1;

        }
        return_value_majority_disks_5=majority_disks(num_disks, num_writes);
        if(return_value_majority_disks_5 == 0)
        {
          log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "ballot %llu our dblock write2 error %d", (unsigned long long int)next_lver, rv);
          error = -211;
        }

        else
        {
          num_reads = 0;
          d = 0;
          for( ; !(d >= num_disks); d = d + 1)
          {
            disk = &token->disks[(signed long int)d];
            if(!(iobuf[(signed long int)d] == ((char *)NULL)))
            {
              memset((void *)iobuf[(signed long int)d], 0, (unsigned long int)iobuf_len);
              rv=read_iobuf(disk->fd, disk->offset, iobuf[(signed long int)d], iobuf_len, task);
              if(rv == -202)
                iobuf[(signed long int)d] = (char *)(void *)0;

              if(rv >= 0)
              {
                num_reads = num_reads + 1;
                q = 0;
                for( ; !(q >= num_hosts); q = q + 1)
                {
                  bk = (struct paxos_dblock *)(iobuf[(signed long int)d] + (signed long int)((2 + q) * sector_size));
                  rv=verify_dblock(token, bk);
                  if(rv >= 0)
                  {
                    if(bk->lver >= dblock.lver)
                    {
                      if(!(dblock.lver >= bk->lver))
                      {
                        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "ballot %llu larger2 lver[%d] %llu dblock %llu", (unsigned long long int)next_lver, q, (unsigned long long int)bk->lver, (unsigned long long int)dblock.lver);
                        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "ballot %llu larger2 mbal[%d] %llu dblock %llu", (unsigned long long int)next_lver, q, (unsigned long long int)bk->mbal, (unsigned long long int)dblock.mbal);
                        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "ballot %llu larger2 inp[%d] %llu %llu %llu dblock %llu %llu %llu", (unsigned long long int)next_lver, q, (unsigned long long int)bk->inp, (unsigned long long int)bk->inp2, (unsigned long long int)bk->inp3, (unsigned long long int)dblock.inp, (unsigned long long int)dblock.inp2, (unsigned long long int)dblock.inp3);
                        error = -212;
                        goto out;
                      }

                      if(!(dblock.mbal >= bk->mbal))
                      {
                        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "ballot %llu abort2 mbal %llu mbal[%d] %llu", (unsigned long long int)next_lver, (unsigned long long int)our_mbal, q, (unsigned long long int)bk->mbal);
                        error = -213;
                        goto out;
                      }

                    }

                  }

                }
              }

            }

          }
          return_value_majority_disks_6=majority_disks(num_disks, num_reads);
          if(return_value_majority_disks_6 == 0)
          {
            log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "ballot %llu dblock read2 error %d", (unsigned long long int)next_lver, rv);
            error = -210;
          }

          else
          {
            memcpy((void *)dblock_out, (const void *)&dblock, sizeof(struct paxos_dblock) /*56ul*/ );
            error = 1;
          }
        }
      }
    }

  out:
    ;
    d = 0;
    for( ; !(d >= num_disks); d = d + 1)
      if(!(iobuf[(signed long int)d] == ((char *)NULL)))
        free((void *)iobuf[(signed long int)d]);

    return error;
  }
}

// run_ballot_link1
// file paxos_lease.c line 253
static signed int run_ballot_link1(struct task *task_link1, struct token *token_link1, signed int num_hosts_link1, unsigned long int next_lver_link1, unsigned long int our_mbal_link1, struct paxos_dblock *dblock_out_link1)
{
  struct paxos_dblock dblock_link1;
  struct paxos_dblock bk_max_link1;
  struct paxos_dblock *bk_link1;
  struct sync_disk *disk_link1;
  char *iobuf_link1[4l];
  char **p_iobuf_link1[4l];
  signed int num_disks_link1 = (signed int)token_link1->r.num_disks;
  signed int num_writes_link1;
  signed int num_reads_link1;
  signed int sector_size_link1 = (signed int)(token_link1->disks + (signed long int)0)->sector_size;
  signed int sector_count_link1;
  signed int iobuf_len_link1;
  signed int d_link1;
  signed int q_link1;
  signed int rv_link1;
  signed int q_max_link1 = -1;
  signed int error_link1;
  unsigned int return_value_roundup_power_of_two_1_link1;
  return_value_roundup_power_of_two_1_link1=roundup_power_of_two_link1((unsigned int)(num_hosts_link1 + 2));
  sector_count_link1 = (signed int)return_value_roundup_power_of_two_1_link1;
  iobuf_len_link1 = sector_count_link1 * sector_size_link1;
  signed int return_value_majority_disks_4_link1;
  signed int return_value_majority_disks_5_link1;
  signed int return_value_majority_disks_6_link1;
  if(iobuf_len_link1 == 0)
    return -22;

  else
  {
    d_link1 = 0;
    for( ; !(d_link1 >= num_disks_link1); d_link1 = d_link1 + 1)
    {
      p_iobuf_link1[(signed long int)d_link1] = &iobuf_link1[(signed long int)d_link1];
      signed int return_value_getpagesize_2_link1;
      return_value_getpagesize_2_link1=getpagesize();
      rv_link1=posix_memalign((void **)(void *)p_iobuf_link1[(signed long int)d_link1], (unsigned long int)return_value_getpagesize_2_link1, (unsigned long int)iobuf_len_link1);
      if(!(rv_link1 == 0))
        return rv_link1;

    }
    log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 7, "ballot %llu phase1 mbal %llu", (unsigned long long int)next_lver_link1, (unsigned long long int)our_mbal_link1);
    memset((void *)&dblock_link1, 0, sizeof(struct paxos_dblock) /*56ul*/ );
    dblock_link1.mbal = our_mbal_link1;
    dblock_link1.lver = next_lver_link1;
    dblock_link1.checksum=dblock_checksum_link1(&dblock_link1);
    memset((void *)&bk_max_link1, 0, sizeof(struct paxos_dblock) /*56ul*/ );
    num_writes_link1 = 0;
    d_link1 = 0;
    for( ; !(d_link1 >= num_disks_link1); d_link1 = d_link1 + 1)
    {
      rv_link1=write_dblock_link1(task_link1, &token_link1->disks[(signed long int)d_link1], token_link1->host_id, &dblock_link1);
      if(rv_link1 >= 0)
        num_writes_link1 = num_writes_link1 + 1;

    }
    signed int return_value_majority_disks_3_link1;
    return_value_majority_disks_3_link1=majority_disks(num_disks_link1, num_writes_link1);
    if(return_value_majority_disks_3_link1 == 0)
    {
      log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "ballot %llu dblock write error %d", (unsigned long long int)next_lver_link1, rv_link1);
      error_link1 = -211;
    }

    else
    {
      num_reads_link1 = 0;
      d_link1 = 0;
      for( ; !(d_link1 >= num_disks_link1); d_link1 = d_link1 + 1)
      {
        disk_link1 = &token_link1->disks[(signed long int)d_link1];
        if(!(iobuf_link1[(signed long int)d_link1] == ((char *)NULL)))
        {
          memset((void *)iobuf_link1[(signed long int)d_link1], 0, (unsigned long int)iobuf_len_link1);
          rv_link1=read_iobuf(disk_link1->fd, disk_link1->offset, iobuf_link1[(signed long int)d_link1], iobuf_len_link1, task_link1);
          if(rv_link1 == -202)
            iobuf_link1[(signed long int)d_link1] = (char *)(void *)0;

          if(rv_link1 >= 0)
          {
            num_reads_link1 = num_reads_link1 + 1;
            q_link1 = 0;
            for( ; !(q_link1 >= num_hosts_link1); q_link1 = q_link1 + 1)
            {
              bk_link1 = (struct paxos_dblock *)(iobuf_link1[(signed long int)d_link1] + (signed long int)((2 + q_link1) * sector_size_link1));
              rv_link1=verify_dblock_link1(token_link1, bk_link1);
              if(rv_link1 >= 0)
              {
                check_mode_block(token_link1, q_link1, (char *)bk_link1);
                if(bk_link1->lver >= dblock_link1.lver)
                {
                  if(!(dblock_link1.lver >= bk_link1->lver))
                  {
                    log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "ballot %llu larger1 lver[%d] %llu", (unsigned long long int)next_lver_link1, q_link1, (unsigned long long int)bk_link1->lver);
                    error_link1 = -212;
                    goto out;
                  }

                  if(!(dblock_link1.mbal >= bk_link1->mbal))
                  {
                    log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "ballot %llu abort1 mbal %llu mbal[%d] %llu", (unsigned long long int)next_lver_link1, (unsigned long long int)our_mbal_link1, q_link1, (unsigned long long int)bk_link1->mbal);
                    error_link1 = -213;
                    goto out;
                  }

                  if(!(bk_link1->inp == 0ul))
                  {
                    if(bk_link1->bal == 0ul)
                      log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "ballot %llu zero bal inp[%d] %llu", (unsigned long long int)next_lver_link1, q_link1, (unsigned long long int)bk_link1->inp);

                    else
                      if(!(bk_max_link1.bal >= bk_link1->bal))
                      {
                        bk_max_link1 = *bk_link1;
                        q_max_link1 = q_link1;
                      }

                  }

                }

              }

            }
          }

        }

      }
      return_value_majority_disks_4_link1=majority_disks(num_disks_link1, num_reads_link1);
      if(return_value_majority_disks_4_link1 == 0)
      {
        log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "ballot %llu dblock read error %d", (unsigned long long int)next_lver_link1, rv_link1);
        error_link1 = -210;
      }

      else
      {
        if(!(bk_max_link1.inp == 0ul))
        {
          dblock_link1.inp = bk_max_link1.inp;
          dblock_link1.inp2 = bk_max_link1.inp2;
          dblock_link1.inp3 = bk_max_link1.inp3;
        }

        else
        {
          dblock_link1.inp = token_link1->host_id;
          dblock_link1.inp2 = token_link1->host_generation;
          dblock_link1.inp3=monotime();
        }
        dblock_link1.bal = dblock_link1.mbal;
        dblock_link1.checksum=dblock_checksum_link1(&dblock_link1);
        if(!(bk_max_link1.inp == 0ul))
          log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "ballot %llu choose bk_max[%d] lver %llu mbal %llu bal %llu inp %llu %llu %llu", (unsigned long long int)next_lver_link1, q_max_link1, (unsigned long long int)bk_max_link1.lver, (unsigned long long int)bk_max_link1.mbal, (unsigned long long int)bk_max_link1.bal, (unsigned long long int)bk_max_link1.inp, (unsigned long long int)bk_max_link1.inp2, (unsigned long long int)bk_max_link1.inp3);

        log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 7, "ballot %llu phase2 bal %llu inp %llu %llu %llu q_max %d", (unsigned long long int)dblock_link1.lver, (unsigned long long int)dblock_link1.bal, (unsigned long long int)dblock_link1.inp, (unsigned long long int)dblock_link1.inp2, (unsigned long long int)dblock_link1.inp3, q_max_link1);
        num_writes_link1 = 0;
        d_link1 = 0;
        for( ; !(d_link1 >= num_disks_link1); d_link1 = d_link1 + 1)
        {
          rv_link1=write_dblock_link1(task_link1, &token_link1->disks[(signed long int)d_link1], token_link1->host_id, &dblock_link1);
          if(rv_link1 >= 0)
            num_writes_link1 = num_writes_link1 + 1;

        }
        return_value_majority_disks_5_link1=majority_disks(num_disks_link1, num_writes_link1);
        if(return_value_majority_disks_5_link1 == 0)
        {
          log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "ballot %llu our dblock write2 error %d", (unsigned long long int)next_lver_link1, rv_link1);
          error_link1 = -211;
        }

        else
        {
          num_reads_link1 = 0;
          d_link1 = 0;
          for( ; !(d_link1 >= num_disks_link1); d_link1 = d_link1 + 1)
          {
            disk_link1 = &token_link1->disks[(signed long int)d_link1];
            if(!(iobuf_link1[(signed long int)d_link1] == ((char *)NULL)))
            {
              memset((void *)iobuf_link1[(signed long int)d_link1], 0, (unsigned long int)iobuf_len_link1);
              rv_link1=read_iobuf(disk_link1->fd, disk_link1->offset, iobuf_link1[(signed long int)d_link1], iobuf_len_link1, task_link1);
              if(rv_link1 == -202)
                iobuf_link1[(signed long int)d_link1] = (char *)(void *)0;

              if(rv_link1 >= 0)
              {
                num_reads_link1 = num_reads_link1 + 1;
                q_link1 = 0;
                for( ; !(q_link1 >= num_hosts_link1); q_link1 = q_link1 + 1)
                {
                  bk_link1 = (struct paxos_dblock *)(iobuf_link1[(signed long int)d_link1] + (signed long int)((2 + q_link1) * sector_size_link1));
                  rv_link1=verify_dblock_link1(token_link1, bk_link1);
                  if(rv_link1 >= 0)
                  {
                    if(bk_link1->lver >= dblock_link1.lver)
                    {
                      if(!(dblock_link1.lver >= bk_link1->lver))
                      {
                        log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "ballot %llu larger2 lver[%d] %llu dblock %llu", (unsigned long long int)next_lver_link1, q_link1, (unsigned long long int)bk_link1->lver, (unsigned long long int)dblock_link1.lver);
                        log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "ballot %llu larger2 mbal[%d] %llu dblock %llu", (unsigned long long int)next_lver_link1, q_link1, (unsigned long long int)bk_link1->mbal, (unsigned long long int)dblock_link1.mbal);
                        log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "ballot %llu larger2 inp[%d] %llu %llu %llu dblock %llu %llu %llu", (unsigned long long int)next_lver_link1, q_link1, (unsigned long long int)bk_link1->inp, (unsigned long long int)bk_link1->inp2, (unsigned long long int)bk_link1->inp3, (unsigned long long int)dblock_link1.inp, (unsigned long long int)dblock_link1.inp2, (unsigned long long int)dblock_link1.inp3);
                        error_link1 = -212;
                        goto out;
                      }

                      if(!(dblock_link1.mbal >= bk_link1->mbal))
                      {
                        log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "ballot %llu abort2 mbal %llu mbal[%d] %llu", (unsigned long long int)next_lver_link1, (unsigned long long int)our_mbal_link1, q_link1, (unsigned long long int)bk_link1->mbal);
                        error_link1 = -213;
                        goto out;
                      }

                    }

                  }

                }
              }

            }

          }
          return_value_majority_disks_6_link1=majority_disks(num_disks_link1, num_reads_link1);
          if(return_value_majority_disks_6_link1 == 0)
          {
            log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "ballot %llu dblock read2 error %d", (unsigned long long int)next_lver_link1, rv_link1);
            error_link1 = -210;
          }

          else
          {
            memcpy((void *)dblock_out_link1, (const void *)&dblock_link1, sizeof(struct paxos_dblock) /*56ul*/ );
            error_link1 = 1;
          }
        }
      }
    }

  out:
    ;
    d_link1 = 0;
    for( ; !(d_link1 >= num_disks_link1); d_link1 = d_link1 + 1)
      if(!(iobuf_link1[(signed long int)d_link1] == ((char *)NULL)))
        free((void *)iobuf_link1[(signed long int)d_link1]);

    return error_link1;
  }
}

// sanlock_acquire
// file sanlock_resource.h line 38
signed int sanlock_acquire(signed int sock, signed int pid, unsigned int flags, signed int res_count, struct sanlk_resource **res_args, struct sanlk_options *opt_in)
{
  struct sanlk_resource *res;
  struct sanlk_options opt;
  signed int rv;
  signed int i;
  signed int fd;
  signed int data2;
  signed int datalen = 0;
  if(res_count >= 9)
    return -22;

  else
  {
    i = 0;
    for( ; !(i >= res_count); i = i + 1)
    {
      res = res_args[(signed long int)i];
      datalen = datalen + (signed int)sizeof(struct sanlk_resource) /*128ul*/ ;
      if(res->num_disks >= 5u)
        return -22;

      datalen = datalen + (signed int)((unsigned long int)res->num_disks * sizeof(struct sanlk_disk) /*1040ul*/ );
    }
    datalen = datalen + (signed int)sizeof(struct sanlk_options) /*56ul*/ ;
    if(!(opt_in == ((struct sanlk_options *)NULL)))
    {
      memcpy((void *)&opt, (const void *)opt_in, sizeof(struct sanlk_options) /*56ul*/ );
      datalen = datalen + (signed int)opt_in->len;
    }

    else
      memset((void *)&opt, 0, sizeof(struct sanlk_options) /*56ul*/ );
    if(sock == -1)
    {
      data2 = pid;
      rv=connect_socket(&fd);
      if(!(rv >= 0))
        return rv;

    }

    else
    {
      data2 = -1;
      fd = sock;
    }
    rv=send_header(fd, 7, flags, datalen, (unsigned int)res_count, (unsigned int)data2);
    if(!(rv >= 0))
      return rv;

    else
    {
      i = 0;
      for( ; !(i >= res_count); i = i + 1)
      {
        res = res_args[(signed long int)i];
        signed long int return_value_send_1;
        return_value_send_1=send(fd, (const void *)res, sizeof(struct sanlk_resource) /*128ul*/ , 0);
        rv = (signed int)return_value_send_1;
        if(!(rv >= 0))
        {
          rv = -1;
          goto out;
        }

        signed long int return_value_send_2;
        return_value_send_2=send(fd, (const void *)res->disks, sizeof(struct sanlk_disk) /*1040ul*/  * (unsigned long int)res->num_disks, 0);
        rv = (signed int)return_value_send_2;
        if(!(rv >= 0))
        {
          rv = -1;
          goto out;
        }

      }
      signed long int return_value_send_3;
      return_value_send_3=send(fd, (const void *)&opt, sizeof(struct sanlk_options) /*56ul*/ , 0);
      rv = (signed int)return_value_send_3;
      if(!(rv >= 0))
        rv = -1;

      else
      {
        if(!(opt.len == 0u))
        {
          signed long int return_value_send_4;
          return_value_send_4=send(fd, (const void *)opt_in->str, (unsigned long int)opt.len, 0);
          rv = (signed int)return_value_send_4;
          if(!(rv >= 0))
          {
            rv = -1;
            goto out;
          }

        }

        rv=recv_result(fd);
      }

    out:
      ;
      if(sock == -1)
        close(fd);

      return rv;
    }
  }
}

// sanlock_add_lockspace
// file sanlock_admin.h line 29
signed int sanlock_add_lockspace(struct sanlk_lockspace *ls, unsigned int flags)
{
  signed int return_value_cmd_lockspace_1;
  return_value_cmd_lockspace_1=cmd_lockspace(2, ls, flags);
  return return_value_cmd_lockspace_1;
}

// sanlock_align
// file sanlock_admin.h line 57
signed int sanlock_align(struct sanlk_disk *disk)
{
  signed int rv;
  signed int fd;
  rv=connect_socket(&fd);
  signed long int return_value_send_1;
  if(!(rv >= 0))
    return rv;

  else
  {
    rv=send_header(fd, 12, (unsigned int)0, (signed int)sizeof(struct sanlk_disk) /*1040ul*/ , (unsigned int)0, (unsigned int)0);
    if(rv >= 0)
    {
      return_value_send_1=send(fd, (void *)disk, sizeof(struct sanlk_disk) /*1040ul*/ , 0);
      rv = (signed int)return_value_send_1;
      if(!(rv >= 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        rv = -(*return_value___errno_location_2);
        goto out;
      }

      rv=recv_result(fd);
    }


  out:
    ;
    close(fd);
    return rv;
  }
}

// sanlock_args_to_state
// file sanlock_resource.h line 79
signed int sanlock_args_to_state(signed int res_count, struct sanlk_resource **res_args, char **res_state)
{
  char *str;
  char *state;
  signed int i;
  signed int rv;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(res_count * (4400 + 1)));
  state = (char *)return_value_malloc_1;
  if(state == ((char *)NULL))
    return -12;

  else
  {
    memset((void *)state, 0, (unsigned long int)(res_count * (4400 + 1)));
    i = 0;
    for( ; !(i >= res_count); i = i + 1)
    {
      str = (char *)(void *)0;
      rv=sanlock_res_to_str(res_args[(signed long int)i], &str);
      if(str == ((char *)NULL) || !(rv >= 0))
      {
        free((void *)state);
        return rv;
      }

      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(str);
      if(return_value_strlen_2 >= 4400ul)
      {
        free((void *)str);
        free((void *)state);
        return -22;
      }

      char *return_value_strstr_3;
      return_value_strstr_3=strstr(str, " ");
      if(!(return_value_strstr_3 == ((char *)NULL)))
      {
        free((void *)str);
        free((void *)state);
        return -22;
      }

      if(!(i == 0))
        strcat(state, " ");

      strcat(state, str);
      free((void *)str);
    }
    *res_state = state;
    return 0;
  }
}

// sanlock_direct_align
// file direct_lib.c line 144
signed int sanlock_direct_align(struct sanlk_disk *disk_in)
{
  struct sync_disk disk;
  signed int align_size;
  signed int rv;
  memset((void *)&disk, 0, sizeof(struct sync_disk) /*1040ul*/ );
  memcpy((void *)disk.path, (const void *)disk_in->path, (unsigned long int)1024);
  rv=open_disk(&disk);
  if(!(rv >= 0))
    return rv;

  else
  {
    align_size=direct_align(&disk);
    close(disk.fd);
    return align_size;
  }
}

// sanlock_direct_init
// file direct_lib.c line 128
signed int sanlock_direct_init(struct sanlk_lockspace *ls, struct sanlk_resource *res, signed int max_hosts, signed int num_hosts, signed int use_aio)
{
  struct task task;
  signed int rv;
  setup_task_lib(&task, use_aio, 10);
  rv=direct_init(&task, ls, res, max_hosts, num_hosts);
  close_task_aio(&task);
  return rv;
}

// sanlock_direct_live_id
// file direct_lib.c line 108
signed int sanlock_direct_live_id(struct sanlk_lockspace *ls, unsigned long int *timestamp, unsigned long int *owner_id, unsigned long int *owner_generation, signed int *live, signed int use_aio, signed int io_timeout_sec)
{
  struct task task;
  signed int rv;
  setup_task_lib(&task, use_aio, io_timeout_sec);
  rv=direct_live_id(&task, ls, timestamp, owner_id, owner_generation, live);
  close_task_aio(&task);
  return rv;
}

// sanlock_direct_read_id
// file direct_lib.c line 89
signed int sanlock_direct_read_id(struct sanlk_lockspace *ls, unsigned long int *timestamp, unsigned long int *owner_id, unsigned long int *owner_generation, signed int use_aio, signed int io_timeout_sec)
{
  struct task task;
  signed int rv;
  setup_task_lib(&task, use_aio, io_timeout_sec);
  rv=direct_read_id(&task, ls, timestamp, owner_id, owner_generation);
  close_task_aio(&task);
  return rv;
}

// sanlock_examine
// file sanlock_resource.h line 51
signed int sanlock_examine(unsigned int flags, struct sanlk_lockspace *ls, struct sanlk_resource *res)
{
  char *data;
  signed int rv;
  signed int fd;
  signed int cmd;
  signed int datalen;
  _Bool tmp_if_expr_1;
  signed long int return_value_send_2;
  if(ls == ((struct sanlk_lockspace *)NULL) && res == ((struct sanlk_resource *)NULL))
    return -22;

  else
  {
    rv=connect_socket(&fd);
    if(!(rv >= 0))
      return rv;

    else
    {
      if(!(ls == ((struct sanlk_lockspace *)NULL)))
        tmp_if_expr_1 = ls->host_id_disk.path[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
      {
        cmd = 15;
        datalen = (signed int)sizeof(struct sanlk_lockspace) /*1104ul*/ ;
        data = (char *)ls;
      }

      else
      {
        cmd = 16;
        datalen = (signed int)sizeof(struct sanlk_resource) /*128ul*/ ;
        data = (char *)res;
      }
      rv=send_header(fd, cmd, flags, datalen, (unsigned int)0, (unsigned int)0);
      if(rv >= 0)
      {
        return_value_send_2=send(fd, (const void *)data, (unsigned long int)datalen, 0);
        rv = (signed int)return_value_send_2;
        if(!(rv >= 0))
        {
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          rv = -(*return_value___errno_location_3);
          goto out;
        }

        rv=recv_result(fd);
      }


    out:
      ;
      close(fd);
      return rv;
    }
  }
}

// sanlock_host_status
// file client_cmd.h line 13
signed int sanlock_host_status(signed int debug, char *lockspace_name)
{
  struct sm_header h;
  struct sanlk_state st;
  struct sanlk_lockspace lockspace;
  char str[4096l];
  signed int fd;
  signed int rv;
  _Bool tmp_if_expr_1;
  if(lockspace_name == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(lockspace_name[(signed long int)0] != 0) ? (_Bool)1 : (_Bool)0;
  signed long int return_value_recv_3;
  if(tmp_if_expr_1)
    return -1;

  else
  {
    fd=send_command(17, (unsigned int)0);
    if(!(fd >= 0))
      return fd;

    else
    {
      memset((void *)&lockspace, 0, sizeof(struct sanlk_lockspace) /*1104ul*/ );
      snprintf(lockspace.name, (unsigned long int)48, "%s", lockspace_name);
      signed long int return_value_send_2;
      return_value_send_2=send(fd, (const void *)&lockspace, sizeof(struct sanlk_lockspace) /*1104ul*/ , 0);
      rv = (signed int)return_value_send_2;
      if(rv >= 0)
      {
        return_value_recv_3=recv(fd, (void *)&h, sizeof(struct sm_header) /*32ul*/ , 256);
        rv = (signed int)return_value_recv_3;
        if(!(rv >= 0))
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          rv = -(*return_value___errno_location_4);
          goto out;
        }

        if(!((unsigned long int)rv == sizeof(struct sm_header) /*32ul*/ ))
          rv = -1;

        else
        {
          while((_Bool)1)
          {
            signed long int return_value_recv_5;
            return_value_recv_5=recv(fd, (void *)&st, sizeof(struct sanlk_state) /*80ul*/ , 256);
            rv = (signed int)return_value_recv_5;
            if(rv == 0)
              break;

            if(!((unsigned long int)rv == sizeof(struct sanlk_state) /*80ul*/ ))
              break;

            if(!(st.str_len == 0u))
            {
              signed long int return_value_recv_6;
              return_value_recv_6=recv(fd, (void *)str, (unsigned long int)st.str_len, 256);
              rv = (signed int)return_value_recv_6;
              if(!((unsigned int)rv == st.str_len))
                break;

            }

            if(st.type == 5u)
              status_host(&st, str, debug);

          }
          rv = (signed int)h.data;
        }
      }


    out:
      ;
      close(fd);
      return rv;
    }
  }
}

// sanlock_init
// file sanlock_admin.h line 66
signed int sanlock_init(struct sanlk_lockspace *ls, struct sanlk_resource *res, signed int max_hosts, signed int num_hosts)
{
  signed int rv;
  signed int fd;
  signed int cmd;
  signed int datalen;
  _Bool tmp_if_expr_1;
  if(ls == ((struct sanlk_lockspace *)NULL) && res == ((struct sanlk_resource *)NULL))
    return -22;

  else
  {
    rv=connect_socket(&fd);
    if(!(rv >= 0))
      return rv;

    else
    {
      if(!(ls == ((struct sanlk_lockspace *)NULL)))
        tmp_if_expr_1 = ls->host_id_disk.path[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
      {
        cmd = 13;
        datalen = (signed int)sizeof(struct sanlk_lockspace) /*1104ul*/ ;
      }

      else
      {
        cmd = 14;
        datalen = (signed int)(sizeof(struct sanlk_resource) /*128ul*/  + sizeof(struct sanlk_disk) /*1040ul*/  * (unsigned long int)res->num_disks);
      }
      rv=send_header(fd, cmd, (unsigned int)0, datalen, (unsigned int)max_hosts, (unsigned int)num_hosts);
      if(rv >= 0)
      {
        if(!(ls == ((struct sanlk_lockspace *)NULL)))
        {
          signed long int return_value_send_2;
          return_value_send_2=send(fd, (const void *)ls, sizeof(struct sanlk_lockspace) /*1104ul*/ , 0);
          rv = (signed int)return_value_send_2;
          if(!(rv >= 0))
          {
            signed int *return_value___errno_location_3;
            return_value___errno_location_3=__errno_location();
            rv = -(*return_value___errno_location_3);
            goto out;
          }

        }

        else
        {
          signed long int return_value_send_4;
          return_value_send_4=send(fd, (const void *)res, sizeof(struct sanlk_resource) /*128ul*/ , 0);
          rv = (signed int)return_value_send_4;
          if(!(rv >= 0))
          {
            signed int *return_value___errno_location_5;
            return_value___errno_location_5=__errno_location();
            rv = -(*return_value___errno_location_5);
            goto out;
          }

          signed long int return_value_send_6;
          return_value_send_6=send(fd, (const void *)res->disks, sizeof(struct sanlk_disk) /*1040ul*/  * (unsigned long int)res->num_disks, 0);
          rv = (signed int)return_value_send_6;
          if(!(rv >= 0))
          {
            signed int *return_value___errno_location_7;
            return_value___errno_location_7=__errno_location();
            rv = -(*return_value___errno_location_7);
            goto out;
          }

        }
        rv=recv_result(fd);
      }


    out:
      ;
      close(fd);
      return rv;
    }
  }
}

// sanlock_inq_lockspace
// file sanlock_admin.h line 37
signed int sanlock_inq_lockspace(struct sanlk_lockspace *ls, unsigned int flags)
{
  signed int return_value_cmd_lockspace_1;
  return_value_cmd_lockspace_1=cmd_lockspace(18, ls, flags);
  return return_value_cmd_lockspace_1;
}

// sanlock_inquire
// file sanlock_resource.h line 45
signed int sanlock_inquire(signed int sock, signed int pid, unsigned int flags, signed int *res_count, char **res_state)
{
  struct sm_header h;
  char *reply_data = (char *)(void *)0;
  signed int rv;
  signed int fd;
  signed int data2;
  signed int len;
  *res_count = 0;
  if(!(res_state == ((char **)NULL)))
    *res_state = (char *)(void *)0;

  if(sock == -1)
  {
    data2 = pid;
    rv=connect_socket(&fd);
    if(!(rv >= 0))
      return rv;

  }

  else
  {
    data2 = -1;
    fd = sock;
  }
  rv=send_header(fd, 9, flags, 0, (unsigned int)0, (unsigned int)data2);
  void *return_value_malloc_2;
  signed long int return_value_recv_3;
  if(!(rv >= 0))
    return rv;

  else
  {
    memset((void *)&h, 0, sizeof(struct sm_header) /*32ul*/ );
    signed long int return_value_recv_1;
    return_value_recv_1=recv(fd, (void *)&h, sizeof(struct sm_header) /*32ul*/ , 256);
    rv = (signed int)return_value_recv_1;
    if(!((unsigned long int)rv == sizeof(struct sm_header) /*32ul*/ ))
      rv = -1;

    else
    {
      len = (signed int)((unsigned long int)h.length - sizeof(struct sm_header) /*32ul*/ );
      if(len == 0)
        rv = (signed int)h.data;

      else
      {
        return_value_malloc_2=malloc((unsigned long int)len);
        reply_data = (char *)return_value_malloc_2;
        if(reply_data == ((char *)NULL))
          rv = -12;

        else
        {
          return_value_recv_3=recv(fd, (void *)reply_data, (unsigned long int)len, 256);
          rv = (signed int)return_value_recv_3;
          if(!(rv == len))
          {
            free((void *)reply_data);
            rv = -1;
          }

          else
          {
            if(!(res_state == ((char **)NULL)))
              *res_state = reply_data;

            else
              free((void *)reply_data);
            *res_count = (signed int)h.data2;
            rv = (signed int)h.data;
          }
        }
      }
    }

  out:
    ;
    if(sock == -1)
      close(fd);

    return rv;
  }
}

// sanlock_log_dump
// file client_cmd.h line 14
signed int sanlock_log_dump(signed int max_size)
{
  struct sm_header h;
  char *buf;
  signed int fd;
  signed int rv;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)max_size);
  buf = (char *)return_value_malloc_1;
  signed long int return_value_recv_4;
  if(buf == ((char *)NULL))
    return -12;

  else
  {
    memset((void *)buf, 0, (unsigned long int)max_size);
    fd=send_command(6, (unsigned int)0);
    if(!(fd >= 0))
    {
      free((void *)buf);
      return fd;
    }

    else
    {
      memset((void *)&h, 0, sizeof(struct sm_header) /*32ul*/ );
      signed long int return_value_recv_2;
      return_value_recv_2=recv(fd, (void *)&h, sizeof(struct sm_header) /*32ul*/ , 256);
      rv = (signed int)return_value_recv_2;
      if(!(rv >= 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        rv = -(*return_value___errno_location_3);
        goto out;
      }

      if(!((unsigned long int)rv == sizeof(struct sm_header) /*32ul*/ ))
        rv = -1;

      else
        if(h.data >= 1u && (unsigned int)max_size >= h.data)
        {
          return_value_recv_4=recv(fd, (void *)buf, (unsigned long int)h.data, 256);
          rv = (signed int)return_value_recv_4;
          if(!(rv >= 0))
          {
            signed int *return_value___errno_location_5;
            return_value___errno_location_5=__errno_location();
            rv = -(*return_value___errno_location_5);
            goto out;
          }

          if(rv == 0)
            rv = -1;

          else
          {
            printf("%s", buf);
            printf("\n");
            if(!((unsigned int)rv == h.data))
              printf("partial dump %d of %d\n", rv, h.data);

          }
        }


    out:
      ;
      close(fd);
      free((void *)buf);
      return rv;
    }
  }
}

// sanlock_register
// file sanlock_resource.h line 34
signed int sanlock_register(void)
{
  signed int sock;
  signed int rv;
  rv=connect_socket(&sock);
  if(!(rv >= 0))
    return rv;

  else
  {
    rv=send_header(sock, 1, (unsigned int)0, 0, (unsigned int)0, (unsigned int)0);
    if(!(rv >= 0))
    {
      close(sock);
      return rv;
    }

    else
      return sock;
  }
}

// sanlock_release
// file sanlock_resource.h line 42
signed int sanlock_release(signed int sock, signed int pid, unsigned int flags, signed int res_count, struct sanlk_resource **res_args)
{
  signed int fd;
  signed int rv;
  signed int i;
  signed int data2;
  signed int datalen;
  if(sock == -1)
  {
    data2 = pid;
    rv=connect_socket(&fd);
    if(!(rv >= 0))
      return rv;

  }

  else
  {
    data2 = -1;
    fd = sock;
  }
  datalen = (signed int)((unsigned long int)res_count * sizeof(struct sanlk_resource) /*128ul*/ );
  rv=send_header(fd, 8, flags, datalen, (unsigned int)res_count, (unsigned int)data2);
  if(rv >= 0)
  {
    i = 0;
    for( ; !(i >= res_count); i = i + 1)
    {
      signed long int return_value_send_1;
      return_value_send_1=send(fd, (const void *)res_args[(signed long int)i], sizeof(struct sanlk_resource) /*128ul*/ , 0);
      rv = (signed int)return_value_send_1;
      if(!(rv >= 0))
      {
        rv = -1;
        goto out;
      }

    }
    rv=recv_result(fd);
  }


out:
  ;
  if(sock == -1)
    close(fd);

  return rv;
}

// sanlock_rem_lockspace
// file sanlock_admin.h line 50
signed int sanlock_rem_lockspace(struct sanlk_lockspace *ls, unsigned int flags)
{
  signed int return_value_cmd_lockspace_1;
  return_value_cmd_lockspace_1=cmd_lockspace(3, ls, flags);
  return return_value_cmd_lockspace_1;
}

// sanlock_request
// file sanlock_resource.h line 48
signed int sanlock_request(unsigned int flags, unsigned int force_mode, struct sanlk_resource *res)
{
  signed int fd;
  signed int rv;
  signed int datalen = (signed int)(sizeof(struct sanlk_resource) /*128ul*/  + sizeof(struct sanlk_disk) /*1040ul*/  * (unsigned long int)res->num_disks);
  rv=connect_socket(&fd);
  signed long int return_value_send_1;
  signed long int return_value_send_3;
  if(!(rv >= 0))
    return rv;

  else
  {
    rv=send_header(fd, 11, flags, datalen, force_mode, (unsigned int)0);
    if(rv >= 0)
    {
      return_value_send_1=send(fd, (const void *)res, sizeof(struct sanlk_resource) /*128ul*/ , 0);
      rv = (signed int)return_value_send_1;
      if(!(rv >= 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        rv = -(*return_value___errno_location_2);
        goto out;
      }

      return_value_send_3=send(fd, (const void *)res->disks, sizeof(struct sanlk_disk) /*1040ul*/  * (unsigned long int)res->num_disks, 0);
      rv = (signed int)return_value_send_3;
      if(!(rv >= 0))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        rv = -(*return_value___errno_location_4);
        goto out;
      }

      rv=recv_result(fd);
    }


  out:
    ;
    close(fd);
    return rv;
  }
}

// sanlock_res_to_str
// file sanlock_resource.h line 64
signed int sanlock_res_to_str(struct sanlk_resource *res, char **str_ret)
{
  char path[1025l];
  char *str;
  signed int ret;
  signed int len;
  signed int pos;
  signed int d;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(4400 + 1));
  str = (char *)return_value_malloc_1;
  if(str == ((char *)NULL))
    return -12;

  else
  {
    memset((void *)str, 0, (unsigned long int)(4400 + 1));
    len = 4400;
    pos = 0;
    ret=snprintf(str + (signed long int)pos, (unsigned long int)(len - pos), "%s:%s", (const void *)res->lockspace_name, (const void *)res->name);
    if(!(ret >= len + -pos))
    {
      pos = pos + ret;
      d = 0;
      for( ; !((unsigned int)d >= res->num_disks); d = d + 1)
      {
        memset((void *)path, 0, sizeof(char [1025l]) /*1025ul*/ );
        copy_path_out(path, res->disks[(signed long int)d].path);
        ret=snprintf(str + (signed long int)pos, (unsigned long int)(len - pos), ":%s:%llu", (const void *)path, (unsigned long long int)res->disks[(signed long int)d].offset);
        if(ret >= len + -pos)
          goto fail;

        pos = pos + ret;
      }
      if(!((4u & res->flags) == 0u))
        ret=snprintf(str + (signed long int)pos, (unsigned long int)(len - pos), ":SH");

      else
        ret=snprintf(str + (signed long int)pos, (unsigned long int)(len - pos), ":%llu", (unsigned long long int)res->lver);
      if(!(len + -pos >= ret))
        goto fail;

      pos = pos + ret;
      if(!(len >= pos))
        goto fail;

      *str_ret = str;
      return 0;
    }

    else
    {

    fail:
      ;
      free((void *)str);
      return -22;
    }
  }
}

// sanlock_restrict
// file client.c line 277
signed int sanlock_restrict(signed int sock, unsigned int flags)
{
  signed int rv;
  rv=send_header(sock, 10, flags, 0, (unsigned int)0, (unsigned int)-1);
  if(!(rv >= 0))
    return rv;

  else
  {
    rv=recv_result(sock);
    return rv;
  }
}

// sanlock_shutdown
// file client_cmd.h line 15
signed int sanlock_shutdown(unsigned int force)
{
  signed int fd;
  fd=send_command(4, force);
  if(!(fd >= 0))
    return fd;

  else
  {
    close(fd);
    return 0;
  }
}

// sanlock_socket_address
// file sanlock_sock.h line 70
signed int sanlock_socket_address(struct sockaddr_un *addr)
{
  memset((void *)addr, 0, sizeof(struct sockaddr_un) /*110ul*/ );
  addr->sun_family = (unsigned short int)1;
  snprintf(addr->sun_path, sizeof(char [108l]) /*108ul*/  - (unsigned long int)1, "%s/%s", (const void *)"/var/run/sanlock", (const void *)"sanlock.sock");
  return 0;
}

// sanlock_state_to_args
// file sanlock_resource.h line 89
signed int sanlock_state_to_args(char *res_state, signed int *res_count, struct sanlk_resource ***res_args)
{
  struct sanlk_resource **args;
  struct sanlk_resource *res;
  char str[4401l];
  signed int count = 1;
  signed int arg_count = 0;
  signed int i;
  signed int j;
  signed int len;
  signed int rv;
  i = 0;
  unsigned long int return_value_strlen_1;
  do
  {
    return_value_strlen_1=strlen(res_state);
    if((unsigned long int)i >= return_value_strlen_1)
      break;

    if((signed int)res_state[(signed long int)i] == 32)
      count = count + 1;

    i = i + 1;
  }
  while((_Bool)1);
  *res_count = count;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)count * sizeof(struct sanlk_resource *) /*8ul*/ );
  args = (struct sanlk_resource **)return_value_malloc_2;
  signed int tmp_post_4;
  signed int tmp_post_5;
  if(args == ((struct sanlk_resource **)NULL))
    return -12;

  else
  {
    memset((void *)args, 0, (unsigned long int)count * sizeof(struct sanlk_resource *) /*8ul*/ );
    j = 0;
    memset((void *)str, 0, sizeof(char [4401l]) /*4401ul*/ );
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(res_state);
    len = (signed int)return_value_strlen_3;
    i = 0;
    for( ; !(i >= 1 + len); i = i + 1)
      if(!(i >= len))
      {
        if((signed int)res_state[(signed long int)i] == 32)
          goto __CPROVER_DUMP_L6;

        tmp_post_4 = j;
        j = j + 1;
        str[(signed long int)tmp_post_4] = res_state[(signed long int)i];
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        rv=sanlock_str_to_res(str, &res);
        if(res == ((struct sanlk_resource *)NULL) || !(rv >= 0))
          goto fail_free;

        if(arg_count == count)
          goto fail_free;

        tmp_post_5 = arg_count;
        arg_count = arg_count + 1;
        args[(signed long int)tmp_post_5] = res;
        j = 0;
        memset((void *)str, 0, sizeof(char [4401l]) /*4401ul*/ );
      }
    *res_count = arg_count;
    *res_args = args;
    return 0;

  fail_free:
    ;
    i = 0;
    for( ; !(i >= count); i = i + 1)
      if(!(args[(signed long int)i] == ((struct sanlk_resource *)NULL)))
        free((void *)args[(signed long int)i]);

    free((void *)args);
    return rv;
  }
}

// sanlock_status
// file client_cmd.h line 12
signed int sanlock_status(signed int debug, char sort_arg)
{
  struct sm_header h;
  struct sanlk_state state;
  char maxstr[4096l];
  char maxbin[4096l];
  struct sanlk_state *st;
  char *buf;
  char *str;
  char *bin;
  signed int fd;
  signed int rv;
  signed int len;
  signed int sort_p = 0;
  signed int sort_s = 0;
  if((signed int)sort_arg == 112)
    sort_p = 1;

  else
    if((signed int)sort_arg == 115)
      sort_s = 1;

  fd=send_command(5, (unsigned int)0);
  signed int tmp_post_6;
  if(!(fd >= 0))
    return fd;

  else
  {
    signed long int return_value_recv_1;
    return_value_recv_1=recv(fd, (void *)&h, sizeof(struct sm_header) /*32ul*/ , 256);
    rv = (signed int)return_value_recv_1;
    if(!(rv >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      rv = -(*return_value___errno_location_2);
      goto out;
    }

    if(!((unsigned long int)rv == sizeof(struct sm_header) /*32ul*/ ))
      rv = -1;

    else
    {
      st = &state;
      str = maxstr;
      bin = maxbin;
      while((_Bool)1)
      {
        if(!(sort_p == 0) || !(sort_s == 0))
        {
          len = (signed int)(sizeof(struct sanlk_state) /*80ul*/  + (unsigned long int)(4096 * 4));
          void *return_value_malloc_3;
          return_value_malloc_3=malloc((unsigned long int)len);
          buf = (char *)return_value_malloc_3;
          if(buf == ((char *)NULL))
            return -12;

          memset((void *)buf, 0, (unsigned long int)len);
          st = (struct sanlk_state *)buf;
          str = buf + (signed long int)sizeof(struct sanlk_state) /*80ul*/ ;
          bin = buf + (signed long int)sizeof(struct sanlk_state) /*80ul*/  + (signed long int)4096;
        }

        else
        {
          memset((void *)&state, 0, sizeof(struct sanlk_state) /*80ul*/ );
          memset((void *)maxstr, 0, sizeof(char [4096l]) /*4096ul*/ );
          memset((void *)maxbin, 0, sizeof(char [4096l]) /*4096ul*/ );
        }
        signed long int return_value_recv_4;
        return_value_recv_4=recv(fd, (void *)st, sizeof(struct sanlk_state) /*80ul*/ , 256);
        rv = (signed int)return_value_recv_4;
        if(rv == 0)
          break;

        if(!((unsigned long int)rv == sizeof(struct sanlk_state) /*80ul*/ ))
          break;

        if(!(st->str_len == 0u))
        {
          signed long int return_value_recv_5;
          return_value_recv_5=recv(fd, (void *)str, (unsigned long int)st->str_len, 256);
          rv = (signed int)return_value_recv_5;
          if(!((unsigned int)rv == st->str_len))
            break;

        }

        recv_bin(fd, st, bin);
        if(!(sort_p == 0) || !(sort_s == 0))
        {
          if(sort_count == 1024)
          {
            printf("cannot sort over %d\n", 1024);
            goto out;
          }

          tmp_post_6 = sort_count;
          sort_count = sort_count + 1;
          sort_bufs[(signed long int)tmp_post_6] = buf;
        }

        else
          print_st(st, str, bin, debug);
      }
      if(!(sort_p == 0))
      {
        print_type(1, debug);
        print_p(-1, debug);
        print_type(3, debug);
        print_r_by_p(debug);
        if(!(sort_done >= sort_count))
        {
          printf("-\n");
          print_type(0, debug);
        }

      }

      else
        if(!(sort_s == 0))
        {
          print_type(1, debug);
          print_p(-1, debug);
          print_type(2, debug);
          print_r_by_s(debug);
          if(!(sort_done >= sort_count))
          {
            printf("-\n");
            print_type(0, debug);
          }

        }

      rv = 0;
    }

  out:
    ;
    close(fd);
    return rv;
  }
}

// sanlock_str_to_lockspace
// file sanlock_resource.h line 98
signed int sanlock_str_to_lockspace(char *str, struct sanlk_lockspace *ls)
{
  char *host_id = (char *)(void *)0;
  char *path = (char *)(void *)0;
  char *offset = (char *)(void *)0;
  signed int i;
  unsigned long int return_value_strlen_1;
  signed long long int return_value_atoll_2;
  signed long long int return_value_atoll_3;
  if(str == ((char *)NULL))
    return -22;

  else
  {
    i = 0;
    do
    {
      return_value_strlen_1=strlen(str);
      if((unsigned long int)i >= return_value_strlen_1)
        break;

      if((signed int)str[(signed long int)i] == 92)
        i = i + 1;

      else
        if((signed int)str[(signed long int)i] == 58)
        {
          if(host_id == ((char *)NULL))
            host_id = &str[(signed long int)i];

          else
            if(path == ((char *)NULL))
              path = &str[(signed long int)i];

            else
              if(offset == ((char *)NULL))
                offset = &str[(signed long int)i];

        }

      i = i + 1;
    }
    while((_Bool)1);
    if(!(host_id == ((char *)NULL)))
    {
      *host_id = (char)0;
      host_id = host_id + 1l;
    }

    if(!(path == ((char *)NULL)))
    {
      *path = (char)0;
      path = path + 1l;
    }

    if(!(offset == ((char *)NULL)))
    {
      *offset = (char)0;
      offset = offset + 1l;
    }

    strncpy(ls->name, str, (unsigned long int)48);
    if(!(host_id == ((char *)NULL)))
    {
      return_value_atoll_2=atoll(host_id);
      ls->host_id = (unsigned long int)return_value_atoll_2;
    }

    if(!(path == ((char *)NULL)))
      copy_path_in(ls->host_id_disk.path, path);

    if(!(offset == ((char *)NULL)))
    {
      return_value_atoll_3=atoll(offset);
      ls->host_id_disk.offset = (unsigned long int)return_value_atoll_3;
    }

    return 0;
  }
}

// sanlock_str_to_res
// file sanlock_resource.h line 71
signed int sanlock_str_to_res(char *str, struct sanlk_resource **res_ret)
{
  struct sanlk_resource *res;
  char sub[1025l];
  signed int i;
  signed int j;
  signed int d;
  signed int rv;
  signed int len;
  signed int sub_count;
  signed int colons;
  signed int num_disks;
  signed int have_lver;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  unsigned long int return_value_strlen_2;
  signed int tmp_post_5;
  signed int tmp_post_6;
  unsigned long int return_value_strlen_7;
  unsigned long int return_value_strlen_8;
  _Bool tmp_if_expr_10;
  unsigned long int return_value_strlen_9;
  if(!(return_value_strlen_1 >= 3ul))
    return -6;

  else
  {
    colons = 0;
    i = 0;
    do
    {
      return_value_strlen_2=strlen(str);
      if((unsigned long int)i >= return_value_strlen_2)
        break;

      if((signed int)str[(signed long int)i] == 92)
        i = i + 1;

      else
        if((signed int)str[(signed long int)i] == 58)
          colons = colons + 1;

      i = i + 1;
    }
    while((_Bool)1);
    if(colons == 0 || colons == 2)
      return -1;

    else
    {
      num_disks = (colons - 1) / 2;
      have_lver = (colons - 1) % 2;
      if(num_disks >= 5)
        return -2;

      else
      {
        len = (signed int)(sizeof(struct sanlk_resource) /*128ul*/  + (unsigned long int)num_disks * sizeof(struct sanlk_disk) /*1040ul*/ );
        void *return_value_malloc_3;
        return_value_malloc_3=malloc((unsigned long int)len);
        res = (struct sanlk_resource *)return_value_malloc_3;
        if(res == ((struct sanlk_resource *)NULL))
          return -12;

        else
        {
          memset((void *)res, 0, (unsigned long int)len);
          res->num_disks = (unsigned int)num_disks;
          d = 0;
          sub_count = 0;
          j = 0;
          memset((void *)sub, 0, sizeof(char [1025l]) /*1025ul*/ );
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(str);
          len = (signed int)return_value_strlen_4;
          i = 0;
          for( ; !(i >= 1 + len); i = i + 1)
            if((signed int)str[(signed long int)i] == 92)
            {
              if(i == len + -1)
                goto fail;

              i = i + 1;
              tmp_post_5 = j;
              j = j + 1;
              sub[(signed long int)tmp_post_5] = str[(signed long int)i];
            }

            else
              if(!(i >= len))
              {
                if((signed int)str[(signed long int)i] == 58)
                  goto __CPROVER_DUMP_L11;

                if(j >= 1024)
                  goto fail;

                tmp_post_6 = j;
                j = j + 1;
                sub[(signed long int)tmp_post_6] = str[(signed long int)i];
              }

              else
              {

              __CPROVER_DUMP_L11:
                ;
                if(!(sub_count >= 2))
                {
                  return_value_strlen_7=strlen(sub);
                  if(return_value_strlen_7 >= 49ul)
                    goto fail;

                }

                if(sub_count >= 2)
                {
                  return_value_strlen_8=strlen(sub);
                  if(return_value_strlen_8 >= 1024ul)
                    tmp_if_expr_10 = (_Bool)1;

                  else
                  {
                    return_value_strlen_9=strlen(sub);
                    tmp_if_expr_10 = return_value_strlen_9 < (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_10)
                    goto fail;

                }

                if(sub_count == 0)
                  strncpy(res->lockspace_name, sub, (unsigned long int)48);

                else
                  if(sub_count == 1)
                    strncpy(res->name, sub, (unsigned long int)48);

                  else
                    if(sub_count % 2 == 0)
                    {
                      if(d == num_disks && !(have_lver == 0))
                      {
                        signed int return_value_strncmp_11;
                        return_value_strncmp_11=strncmp(sub, "SH", (unsigned long int)2);
                        if(return_value_strncmp_11 == 0)
                          res->flags = res->flags | (unsigned int)0x4;

                        else
                        {
                          res->flags = res->flags | (unsigned int)0x1;
                          res->lver=strtoull(sub, (char ** restrict )(void *)0, 0);
                        }
                      }

                      else
                        strncpy(res->disks[(signed long int)d].path, sub, (unsigned long int)(1024 - 1));
                    }

                    else
                    {
                      rv=sscanf(sub, "%llu", (unsigned long long int *)&res->disks[(signed long int)d].offset);
                      if(!(rv == 1))
                        goto fail;

                      d = d + 1;
                    }
                sub_count = sub_count + 1;
                j = 0;
                memset((void *)sub, 0, sizeof(char [1025l]) /*1025ul*/ );
              }
          *res_ret = res;
          return 0;

        fail:
          ;
          free((void *)res);
          return -1;
        }
      }
    }
  }
}

// send_command
// file client.c line 86
signed int send_command(signed int cmd, unsigned int data)
{
  signed int rv;
  signed int sock;
  rv=connect_socket(&sock);
  if(!(rv >= 0))
    return rv;

  else
  {
    rv=send_header(sock, cmd, (unsigned int)0, 0, data, (unsigned int)0);
    if(!(rv >= 0))
    {
      close(sock);
      return rv;
    }

    else
      return sock;
  }
}

// send_header
// file client.c line 63
static signed int send_header(signed int sock, signed int cmd, unsigned int cmd_flags, signed int datalen, unsigned int data, unsigned int data2)
{
  struct sm_header header;
  signed int rv;
  memset((void *)&header, 0, sizeof(struct sm_header) /*32ul*/ );
  header.magic = (unsigned int)0x04282010;
  header.cmd = (unsigned int)cmd;
  header.cmd_flags = cmd_flags;
  header.length = (unsigned int)(sizeof(struct sm_header) /*32ul*/  + (unsigned long int)datalen);
  header.data = data;
  header.data2 = data2;
  signed long int return_value_send_1;
  return_value_send_1=send(sock, (void *)&header, sizeof(struct sm_header) /*32ul*/ , 0);
  rv = (signed int)return_value_send_1;
  signed int *return_value___errno_location_2;
  if(!(rv >= 0))
  {
    return_value___errno_location_2=__errno_location();
    return -(*return_value___errno_location_2);
  }

  else
    return 0;
}

// send_header_link1
// file client.c line 66
static signed int send_header_link1(signed int con, signed int cmd_link1)
{
  struct wdmd_header h;
  signed int rv_link1;
  memset((void *)&h, 0, sizeof(struct wdmd_header) /*176ul*/ );
  h.cmd = (unsigned int)cmd_link1;
  signed long int return_value_send_1_link1;
  return_value_send_1_link1=send(con, (void *)&h, sizeof(struct wdmd_header) /*176ul*/ , 0);
  rv_link1 = (signed int)return_value_send_1_link1;
  signed int *return_value___errno_location_2_link1;
  if(!(rv_link1 >= 0))
  {
    return_value___errno_location_2_link1=__errno_location();
    return -(*return_value___errno_location_2_link1);
  }

  else
    return 0;
}

// send_header_link2
// file client.c line 66
static signed int send_header_link2(signed int con_link1, signed int cmd_link2)
{
  struct wdmd_header h_link1;
  signed int rv_link2;
  memset((void *)&h_link1, 0, sizeof(struct wdmd_header) /*176ul*/ );
  h_link1.cmd = (unsigned int)cmd_link2;
  signed long int return_value_send_1_link2;
  return_value_send_1_link2=send(con_link1, (void *)&h_link1, sizeof(struct wdmd_header) /*176ul*/ , 0);
  rv_link2 = (signed int)return_value_send_1_link2;
  signed int *return_value___errno_location_2_link2;
  if(!(rv_link2 >= 0))
  {
    return_value___errno_location_2_link2=__errno_location();
    return -(*return_value___errno_location_2_link2);
  }

  else
    return 0;
}

// send_result
// file main.c line 322
void send_result(signed int fd, struct sm_header *h_recv, signed int result)
{
  struct sm_header h;
  memcpy((void *)&h, (const void *)h_recv, sizeof(struct sm_header) /*32ul*/ );
  h.length = (unsigned int)sizeof(struct sm_header) /*32ul*/ ;
  h.data = (unsigned int)result;
  h.data2 = (unsigned int)0;
  send(fd, (const void *)&h, sizeof(struct sm_header) /*32ul*/ , 16384);
}

// send_state_client
// file cmd.c line 1396
static void send_state_client(signed int fd, struct client *cl, signed int ci)
{
  struct sanlk_state st;
  char str[4096l];
  signed int str_len;
  memset((void *)&st, 0, sizeof(struct sanlk_state) /*80ul*/ );
  st.type = (unsigned int)2;
  st.data32 = (unsigned int)cl->pid;
  strncpy(st.name, cl->owner_name, (unsigned long int)48);
  str_len=print_state_client(cl, ci, str);
  st.str_len = (unsigned int)str_len;
  send(fd, (const void *)&st, sizeof(struct sanlk_state) /*80ul*/ , 16384);
  if(!(str_len == 0))
    send(fd, (const void *)str, (unsigned long int)str_len, 16384);

}

// send_state_daemon
// file cmd.c line 1376
static void send_state_daemon(signed int fd)
{
  struct sanlk_state st;
  char str[4096l];
  signed int str_len;
  memset((void *)&st, 0, sizeof(struct sanlk_state) /*80ul*/ );
  strncpy(st.name, our_host_name_global, (unsigned long int)48);
  st.type = (unsigned int)1;
  str_len=print_state_daemon(str);
  st.str_len = (unsigned int)str_len;
  send(fd, (const void *)&st, sizeof(struct sanlk_state) /*80ul*/ , 16384);
  if(!(str_len == 0))
    send(fd, (const void *)str, (unsigned long int)str_len, 16384);

}

// send_state_host
// file cmd.c line 1479
static void send_state_host(signed int fd, struct host_status *hs, signed int host_id)
{
  struct sanlk_state st;
  char str[4096l];
  signed int str_len;
  memset((void *)&st, 0, sizeof(struct sanlk_state) /*80ul*/ );
  st.type = (unsigned int)5;
  st.data32 = (unsigned int)host_id;
  st.data64 = hs->timestamp;
  str_len=print_state_host(hs, str);
  st.str_len = (unsigned int)str_len;
  send(fd, (const void *)&st, sizeof(struct sanlk_state) /*80ul*/ , 16384);
  if(!(str_len == 0))
    send(fd, (const void *)str, (unsigned long int)str_len, 16384);

}

// send_state_lockspace
// file cmd.c line 1417
static void send_state_lockspace(signed int fd, struct space *sp, const char *list_name)
{
  struct sanlk_state st;
  struct sanlk_lockspace lockspace;
  char str[4096l];
  signed int str_len;
  memset((void *)&st, 0, sizeof(struct sanlk_state) /*80ul*/ );
  st.type = (unsigned int)3;
  st.data64 = sp->host_id;
  strncpy(st.name, sp->space_name, (unsigned long int)48);
  str_len=print_state_lockspace(sp, str, list_name);
  st.str_len = (unsigned int)str_len;
  send(fd, (const void *)&st, sizeof(struct sanlk_state) /*80ul*/ , 16384);
  if(!(str_len == 0))
    send(fd, (const void *)str, (unsigned long int)str_len, 16384);

  memset((void *)&lockspace, 0, sizeof(struct sanlk_lockspace) /*1104ul*/ );
  strncpy(lockspace.name, sp->space_name, (unsigned long int)48);
  lockspace.host_id = sp->host_id;
  memcpy((void *)&lockspace.host_id_disk, (const void *)&sp->host_id_disk, sizeof(struct sanlk_disk) /*1040ul*/ );
  send(fd, (const void *)&lockspace, sizeof(struct sanlk_lockspace) /*1104ul*/ , 16384);
}

// send_state_resource
// file resource.c line 36
void send_state_resource(signed int fd, struct resource *r, const char *list_name, signed int pid, unsigned int token_id)
{
  struct sanlk_state st;
  char str[4096l];
  signed int str_len;
  signed int i;
  memset((void *)&st, 0, sizeof(struct sanlk_state) /*80ul*/ );
  st.type = (unsigned int)4;
  st.data32 = (unsigned int)pid;
  st.data64 = r->leader.lver;
  strncpy(st.name, r->r.name, (unsigned long int)48);
  str_len=print_state_resource(r, str, list_name, token_id);
  st.str_len = (unsigned int)str_len;
  send(fd, (const void *)&st, sizeof(struct sanlk_state) /*80ul*/ , 16384);
  if(!(str_len == 0))
    send(fd, (const void *)str, (unsigned long int)str_len, 16384);

  send(fd, (const void *)&r->r, sizeof(struct sanlk_resource) /*128ul*/ , 16384);
  i = 0;
  for( ; !((unsigned int)i >= r->r.num_disks); i = i + 1)
    send(fd, (const void *)&r->r.disks[(signed long int)i], sizeof(struct sanlk_disk) /*1040ul*/ , 16384);
}

// send_state_resources
// file resource.c line 51
void send_state_resources(signed int fd)
{
  struct resource *r;
  struct token *token;
  pthread_mutex_lock(&resource_mutex);
  struct resource *tmp_statement_expression_1;
  const struct list_head *send_state_resources__1__1__1____mptr = (&resources_held)->next;
  tmp_statement_expression_1 = (struct resource *)((char *)send_state_resources__1__1__1____mptr - (signed long int)0ul);
  r = tmp_statement_expression_1;
  struct token *tmp_statement_expression_3;
  struct token *tmp_statement_expression_4;
  struct resource *tmp_statement_expression_2;
  for( ; !(&r->list == &resources_held); r = tmp_statement_expression_2)
  {
    const struct list_head *send_state_resources__1__1__3__1__1____mptr = (&r->tokens)->next;
    tmp_statement_expression_3 = (struct token *)((char *)send_state_resources__1__1__3__1__1____mptr - (signed long int)40ul);
    token = tmp_statement_expression_3;
    for( ; !(&token->list == &r->tokens); token = tmp_statement_expression_4)
    {
      send_state_resource(fd, r, "held", token->pid, token->token_id);
      const struct list_head *send_state_resources__1__1__3__1__2____mptr = token->list.next;
      tmp_statement_expression_4 = (struct token *)((char *)send_state_resources__1__1__3__1__2____mptr - (signed long int)40ul);
    }
    const struct list_head *send_state_resources__1__1__2____mptr = r->list.next;
    tmp_statement_expression_2 = (struct resource *)((char *)send_state_resources__1__1__2____mptr - (signed long int)0ul);
  }
  struct resource *tmp_statement_expression_5;
  const struct list_head *send_state_resources__1__2__1____mptr = (&resources_add)->next;
  tmp_statement_expression_5 = (struct resource *)((char *)send_state_resources__1__2__1____mptr - (signed long int)0ul);
  r = tmp_statement_expression_5;
  struct token *tmp_statement_expression_7;
  struct token *tmp_statement_expression_8;
  struct resource *tmp_statement_expression_6;
  for( ; !(&r->list == &resources_add); r = tmp_statement_expression_6)
  {
    const struct list_head *send_state_resources__1__2__3__1__1____mptr = (&r->tokens)->next;
    tmp_statement_expression_7 = (struct token *)((char *)send_state_resources__1__2__3__1__1____mptr - (signed long int)40ul);
    token = tmp_statement_expression_7;
    for( ; !(&token->list == &r->tokens); token = tmp_statement_expression_8)
    {
      send_state_resource(fd, r, "add", token->pid, token->token_id);
      const struct list_head *send_state_resources__1__2__3__1__2____mptr = token->list.next;
      tmp_statement_expression_8 = (struct token *)((char *)send_state_resources__1__2__3__1__2____mptr - (signed long int)40ul);
    }
    const struct list_head *send_state_resources__1__2__2____mptr = r->list.next;
    tmp_statement_expression_6 = (struct resource *)((char *)send_state_resources__1__2__2____mptr - (signed long int)0ul);
  }
  struct resource *tmp_statement_expression_9;
  const struct list_head *send_state_resources__1__3__1____mptr = (&resources_rem)->next;
  tmp_statement_expression_9 = (struct resource *)((char *)send_state_resources__1__3__1____mptr - (signed long int)0ul);
  r = tmp_statement_expression_9;
  struct resource *tmp_statement_expression_10;
  for( ; !(&r->list == &resources_rem); r = tmp_statement_expression_10)
  {
    send_state_resource(fd, r, "rem", r->pid, r->release_token_id);
    const struct list_head *__mptr = r->list.next;
    tmp_statement_expression_10 = (struct resource *)((char *)__mptr - (signed long int)0ul);
  }
  pthread_mutex_unlock(&resource_mutex);
}

// set_disk_properties
// file diskio.c line 34
static signed int set_disk_properties(struct sync_disk *disk)
{
  struct blkid_struct_probe *probe;
  struct blkid_struct_topology *topo;
  unsigned int sector_size;
  unsigned int ss_logical;
  unsigned int ss_physical;
  probe=blkid_new_probe_from_filename(disk->path);
  if(probe == ((struct blkid_struct_probe *)NULL))
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cannot get blkid probe %s", (const void *)disk->path);
    return -1;
  }

  else
  {
    topo=blkid_probe_get_topology(probe);
    if(topo == ((struct blkid_struct_topology *)NULL))
    {
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cannot get blkid topology %s", (const void *)disk->path);
      blkid_free_probe(probe);
      return -1;
    }

    else
    {
      sector_size=blkid_probe_get_sectorsize(probe);
      unsigned long int return_value_blkid_topology_get_logical_sector_size_1;
      return_value_blkid_topology_get_logical_sector_size_1=blkid_topology_get_logical_sector_size(topo);
      ss_logical = (unsigned int)return_value_blkid_topology_get_logical_sector_size_1;
      unsigned long int return_value_blkid_topology_get_physical_sector_size_2;
      return_value_blkid_topology_get_physical_sector_size_2=blkid_topology_get_physical_sector_size(topo);
      ss_physical = (unsigned int)return_value_blkid_topology_get_physical_sector_size_2;
      blkid_free_probe(probe);
      if(!(sector_size % 512u == 0u) || !(sector_size == ss_logical))
      {
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "invalid disk sector size %u logical %u physical %u %s", sector_size, ss_logical, ss_physical, (const void *)disk->path);
        return -1;
      }

      else
      {
        disk->sector_size = sector_size;
        return 0;
      }
    }
  }
}

// set_disk_properties_link1
// file diskio.c line 34
static signed int set_disk_properties_link1(struct sync_disk *disk_link1)
{
  struct blkid_struct_probe *probe_link1;
  struct blkid_struct_topology *topo_link1;
  unsigned int sector_size_link1;
  unsigned int ss_logical_link1;
  unsigned int ss_physical_link1;
  probe_link1=blkid_new_probe_from_filename(disk_link1->path);
  if(probe_link1 == ((struct blkid_struct_probe *)NULL))
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cannot get blkid probe %s", (const void *)disk_link1->path);
    return -1;
  }

  else
  {
    topo_link1=blkid_probe_get_topology(probe_link1);
    if(topo_link1 == ((struct blkid_struct_topology *)NULL))
    {
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "cannot get blkid topology %s", (const void *)disk_link1->path);
      blkid_free_probe(probe_link1);
      return -1;
    }

    else
    {
      sector_size_link1=blkid_probe_get_sectorsize(probe_link1);
      unsigned long int return_value_blkid_topology_get_logical_sector_size_1_link1;
      return_value_blkid_topology_get_logical_sector_size_1_link1=blkid_topology_get_logical_sector_size(topo_link1);
      ss_logical_link1 = (unsigned int)return_value_blkid_topology_get_logical_sector_size_1_link1;
      unsigned long int return_value_blkid_topology_get_physical_sector_size_2_link1;
      return_value_blkid_topology_get_physical_sector_size_2_link1=blkid_topology_get_physical_sector_size(topo_link1);
      ss_physical_link1 = (unsigned int)return_value_blkid_topology_get_physical_sector_size_2_link1;
      blkid_free_probe(probe_link1);
      if(!(sector_size_link1 % 512u == 0u) || !(sector_size_link1 == ss_logical_link1))
      {
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "invalid disk sector size %u logical %u physical %u %s", sector_size_link1, ss_logical_link1, ss_physical_link1, (const void *)disk_link1->path);
        return -1;
      }

      else
      {
        disk_link1->sector_size = sector_size_link1;
        return 0;
      }
    }
  }
}

// set_id_bit
// file lockspace.c line 145
void set_id_bit(signed int host_id, char *bitmap, char *c)
{
  char *byte = bitmap + (signed long int)((host_id - 1) / 8);
  unsigned int bit = (unsigned int)((host_id - 1) % 8);
  char mask = (char)(1 << bit);
  *byte = *byte | mask;
  if(!(c == ((char *)NULL)))
    *c = *byte;

}

// set_mode_block
// file resource.c line 146
static signed int set_mode_block(struct task *task, struct token *token, unsigned long int host_id, unsigned long int gen, unsigned int flags)
{
  struct sync_disk *disk;
  struct mode_block *mb;
  char *iobuf;
  char **p_iobuf;
  unsigned long int offset;
  signed int num_disks = (signed int)token->r.num_disks;
  signed int iobuf_len;
  signed int rv;
  signed int d;
  disk = &token->disks[(signed long int)0];
  iobuf_len = (signed int)disk->sector_size;
  if(iobuf_len == 0)
    return -22;

  else
  {
    p_iobuf = &iobuf;
    signed int return_value_getpagesize_1;
    return_value_getpagesize_1=getpagesize();
    rv=posix_memalign((void **)(void *)p_iobuf, (unsigned long int)return_value_getpagesize_1, (unsigned long int)iobuf_len);
    if(!(rv == 0))
      return -12;

    else
    {
      d = 0;
      for( ; !(d >= num_disks); d = d + 1)
      {
        disk = &token->disks[(signed long int)d];
        offset = disk->offset + (((unsigned long int)2 + host_id) - (unsigned long int)1) * (unsigned long int)disk->sector_size;
        rv=read_iobuf(disk->fd, offset, iobuf, iobuf_len, task);
        if(!(rv >= 0))
          break;

        mb = (struct mode_block *)(iobuf + (signed long int)128);
        mb->flags = flags;
        mb->generation = gen;
        rv=write_iobuf(disk->fd, offset, iobuf, iobuf_len, task);
        if(!(rv >= 0))
          break;

      }
      if(!(rv >= 0))
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "set_mode_block host_id %llu flags %x gen %llu d %d rv %d", (unsigned long long int)host_id, flags, (unsigned long long int)gen, d, rv);

      else
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 7, "set_mode_block host_id %llu flags %x gen %llu", (unsigned long long int)host_id, flags, (unsigned long long int)gen);
      if(!(rv == -202))
        free((void *)iobuf);

      return rv;
    }
  }
}

// set_resource_examine
// file resource.h line 25
signed int set_resource_examine(char *space_name, char *res_name)
{
  struct resource *r;
  signed int count = 0;
  pthread_mutex_lock(&resource_mutex);
  struct resource *tmp_statement_expression_1;
  const struct list_head *__mptr = (&resources_held)->next;
  tmp_statement_expression_1 = (struct resource *)((char *)__mptr - (signed long int)0ul);
  r = tmp_statement_expression_1;
  signed int return_value_strncmp_4;
  struct resource *tmp_statement_expression_2;
  for( ; !(&r->list == &resources_held); r = tmp_statement_expression_2)
  {
    signed int return_value_strncmp_3;
    return_value_strncmp_3=strncmp(r->r.lockspace_name, space_name, (unsigned long int)48);
    if(return_value_strncmp_3 == 0)
    {
      if(!(res_name == ((char *)NULL)))
      {
        return_value_strncmp_4=strncmp(r->r.name, res_name, (unsigned long int)48);
        if(return_value_strncmp_4 == 0)
          goto __CPROVER_DUMP_L2;

      }

      else
      {

      __CPROVER_DUMP_L2:
        ;
        r->flags = r->flags | (unsigned int)0x00000002;
        resource_thread_work = 1;
        count = count + 1;
      }
    }

    const struct list_head *set_resource_examine__1__1__2____mptr = r->list.next;
    tmp_statement_expression_2 = (struct resource *)((char *)set_resource_examine__1__1__2____mptr - (signed long int)0ul);
  }
  if(!(count == 0))
    pthread_cond_signal(&resource_cond);

  pthread_mutex_unlock(&resource_mutex);
  return count;
}

// setup_host_name
// file main.c line 1157
static void setup_host_name(void)
{
  struct utsname name;
  char uuid[37l];
  unsigned char uu[16l];
  memset((void *)rand_state, 0, sizeof(char [32l]) /*32ul*/ );
  memset((void *)&rand_data, 0, sizeof(struct random_data) /*48ul*/ );
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  initstate_r((unsigned int)return_value_time_1, rand_state, sizeof(char [32l]) /*32ul*/ , &rand_data);
  if(!(com.our_host_name[0l] == 0))
    memcpy((void *)our_host_name_global, (const void *)com.our_host_name, (unsigned long int)48);

  else
  {
    memset((void *)&our_host_name_global, 0, sizeof(char [49l]) /*49ul*/ );
    memset((void *)&name, 0, sizeof(struct utsname) /*390ul*/ );
    memset((void *)&uuid, 0, sizeof(char [37l]) /*37ul*/ );
    uname(&name);
    uuid_generate(uu);
    uuid_unparse_lower(uu, uuid);
    snprintf(our_host_name_global, (unsigned long int)48, "%s.%s", (const void *)uuid, (const void *)name.nodename);
  }
}

// setup_listener
// file main.c line 1060
static signed int setup_listener(void)
{
  struct sockaddr_un addr;
  signed int rv;
  signed int fd;
  signed int ci;
  rv=sanlock_socket_address(&addr);
  signed int return_value_fcntl_3;
  if(!(rv >= 0))
    return rv;

  else
  {
    fd=socket(1, 1, 0);
    if(!(fd >= 0))
      return fd;

    else
    {
      unlink(addr.sun_path);
      rv=bind(fd, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
      if(rv >= 0)
      {
        rv=chmod(addr.sun_path, (unsigned int)(0400 | 0200 | 0400 >> 3 | 0200 >> 3));
        if(!(rv >= 0))
          goto exit_fail;

        rv=chown(addr.sun_path, (unsigned int)com.uid, (unsigned int)com.gid);
        if(!(rv >= 0))
        {
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          char *return_value_strerror_2;
          return_value_strerror_2=strerror(*return_value___errno_location_1);
          log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "could not set socket %s permissions: %s", (const void *)addr.sun_path, return_value_strerror_2);
          goto exit_fail;
        }

        rv=listen(fd, 5);
        if(!(rv >= 0))
          goto exit_fail;

        return_value_fcntl_3=fcntl(fd, 3, 0);
        fcntl(fd, 4, return_value_fcntl_3 | 04000);
        ci=client_add(fd, process_listener, (void (*)(signed int))(void *)0);
        if(!(ci >= 0))
          goto exit_fail;

        strcpy((client + (signed long int)ci)->owner_name, "listener");
        return 0;
      }

      else
      {

      exit_fail:
        ;
        close(fd);
        return -1;
      }
    }
  }
}

// setup_logging
// file log.c line 248
signed int setup_logging(void)
{
  signed int fd;
  signed int rv;
  snprintf(logfile_path, (unsigned long int)4096, "%s/%s", (const void *)"/var/log", (const void *)"sanlock.log");
  logfile_fp=fopen(logfile_path, "a+");
  if(!(logfile_fp == ((struct _IO_FILE *)NULL)))
  {
    fd=fileno(logfile_fp);
    signed int return_value_fcntl_1;
    return_value_fcntl_1=fcntl(fd, 1, 0);
    fcntl(fd, 2, return_value_fcntl_1 | 1);
  }

  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)log_num_ents * sizeof(struct entry) /*516ul*/ );
  log_ents = (struct entry *)return_value_malloc_2;
  if(log_ents == ((struct entry *)NULL))
  {
    fclose(logfile_fp);
    logfile_fp = (struct _IO_FILE *)(void *)0;
    return -1;
  }

  else
  {
    memset((void *)log_ents, 0, (unsigned long int)log_num_ents * sizeof(struct entry) /*516ul*/ );
    openlog("sanlock", 0x02 | 0x01, 3 << 3);
    rv=pthread_create(&thread_handle, (const union pthread_attr_t *)(void *)0, log_thread_fn, (void *)0);
    if(!(rv == 0))
      return -1;

    else
      return 0;
  }
}

// setup_priority
// file main.c line 1112
static void setup_priority(void)
{
  struct sched_param sched_param;
  signed int rv;
  if(!(com.high_priority == 0))
  {
    rv=mlockall(1 | 2);
    if(!(rv >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "mlockall failed: %s", return_value_strerror_2);
    }

    rv=sched_get_priority_max(2);
    if(!(rv >= 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "could not get max scheduler priority err %d", *return_value___errno_location_3);
      goto __CPROVER_DUMP_L5;
    }

    sched_param.__sched_priority = rv;
    rv=sched_setscheduler(0, 2 | 0x40000000, &sched_param);
    if(!(rv >= 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "set scheduler RR|RESET_ON_FORK priority %d failed: %s", sched_param.__sched_priority, return_value_strerror_5);
    }

  }


__CPROVER_DUMP_L5:
  ;
}

// setup_task_aio
// file task.h line 13
void setup_task_aio(struct task *task, signed int use_aio, signed int cb_size)
{
  signed int rv;
  task->use_aio = use_aio;
  memset((void *)&task->aio_ctx, 0, sizeof(struct io_context *) /*8ul*/ );
  void *return_value_malloc_1;
  if(!(use_aio == 0))
  {
    if(!(cb_size == 0))
    {
      rv=io_setup(cb_size, &task->aio_ctx);
      if(rv >= 0)
      {
        task->cb_size = cb_size;
        return_value_malloc_1=malloc((unsigned long int)cb_size * sizeof(struct aicb) /*80ul*/ );
        task->callbacks = (struct aicb *)return_value_malloc_1;
        if(task->callbacks == ((struct aicb *)NULL))
          rv = -12;

        else
        {
          memset((void *)task->callbacks, 0, (unsigned long int)cb_size * sizeof(struct aicb) /*80ul*/ );
          goto __CPROVER_DUMP_L6;
        }

      fail_setup:
        ;
        io_destroy(task->aio_ctx);
      }


    fail:
      ;
      task->use_aio = 0;
    }

  }


__CPROVER_DUMP_L6:
  ;
}

// setup_task_lib
// file direct_lib.c line 78
static void setup_task_lib(struct task *task, signed int use_aio, signed int io_timeout_sec)
{
  memset((void *)task, 0, sizeof(struct task) /*136ul*/ );
  if(io_timeout_sec == 0)
    io_timeout_sec = 10;

  setup_task_timeouts(task, io_timeout_sec);
  setup_task_aio(task, use_aio, 1);
  sprintf(task->name, "%s", (const void *)"lib");
}

// setup_task_timeouts
// file task.h line 12
void setup_task_timeouts(struct task *task, signed int io_timeout_arg)
{
  signed int io_timeout_seconds = io_timeout_arg;
  signed int id_renewal_seconds = 2 * io_timeout_seconds;
  signed int id_renewal_fail_seconds = 8 * io_timeout_seconds;
  signed int id_renewal_warn_seconds = 6 * io_timeout_seconds;
  signed int host_dead_seconds = id_renewal_fail_seconds + 60;
  signed int delta_large_delay = id_renewal_seconds + 6 * io_timeout_seconds;
  signed int delta_short_delay = 2 * io_timeout_seconds;
  signed int max = host_dead_seconds;
  if(!(max >= delta_large_delay))
    max = delta_large_delay;

  signed int delta_acquire_held_max = max + delta_short_delay + 4 * io_timeout_seconds;
  signed int delta_acquire_held_min = max;
  signed int delta_acquire_free_max = delta_short_delay + 3 * io_timeout_seconds;
  signed int delta_acquire_free_min = delta_short_delay;
  signed int delta_renew_max = 2 * io_timeout_seconds;
  signed int delta_renew_min = 0;
  signed int paxos_acquire_held_max = host_dead_seconds + 7 * io_timeout_seconds;
  signed int paxos_acquire_held_min = host_dead_seconds;
  signed int paxos_acquire_free_max = 6 * io_timeout_seconds;
  signed int paxos_acquire_free_min = 0;
  signed int request_finish_seconds = 3 * id_renewal_seconds;
  task->io_timeout_seconds = io_timeout_seconds;
  task->id_renewal_seconds = id_renewal_seconds;
  task->id_renewal_fail_seconds = id_renewal_fail_seconds;
  task->id_renewal_warn_seconds = id_renewal_warn_seconds;
  task->host_dead_seconds = host_dead_seconds;
  task->request_finish_seconds = request_finish_seconds;
  task->kill_count_term = 10;
  task->kill_count_max = 60;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(task->name, "main");
  if(return_value_strcmp_1 == 0)
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "io_timeout_seconds %d", io_timeout_seconds);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "id_renewal_seconds %d", id_renewal_seconds);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "id_renewal_fail_seconds %d", id_renewal_fail_seconds);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "id_renewal_warn_seconds %d", id_renewal_warn_seconds);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "host_dead_seconds %d", host_dead_seconds);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "delta_large_delay %d", delta_large_delay);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "delta_short_delay %d", delta_short_delay);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "delta_acquire_held_max %d", delta_acquire_held_max);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "delta_acquire_held_min %d", delta_acquire_held_min);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "delta_acquire_free_max %d", delta_acquire_free_max);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "delta_acquire_free_min %d", delta_acquire_free_min);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "delta_renew_max %d", delta_renew_max);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "delta_renew_min %d", delta_renew_min);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "paxos_acquire_held_max %d", paxos_acquire_held_max);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "paxos_acquire_held_min %d", paxos_acquire_held_min);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "paxos_acquire_free_max %d", paxos_acquire_free_max);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "paxos_acquire_free_min %d", paxos_acquire_free_min);
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "request_finish_seconds %d", request_finish_seconds);
  }

}

// setup_token_manager
// file resource.h line 27
signed int setup_token_manager(void)
{
  signed int rv;
  pthread_mutex_init(&resource_mutex, (const union anonymous_5 *)(void *)0);
  pthread_cond_init(&resource_cond, (const union anonymous_5 *)(void *)0);
  INIT_LIST_HEAD_link1(&resources_add);
  INIT_LIST_HEAD_link1(&resources_rem);
  INIT_LIST_HEAD_link1(&resources_held);
  rv=pthread_create(&resource_pt, (const union pthread_attr_t *)(void *)0, resource_thread, (void *)0);
  if(!(rv == 0))
    return -1;

  else
    return 0;
}

// setup_watchdog
// file watchdog.h line 17
signed int setup_watchdog(void)
{
  char name[128l];
  signed int test_interval;
  signed int fire_timeout;
  unsigned long int last_keepalive;
  signed int con;
  signed int rv;
  if(com.use_watchdog == 0)
    return 0;

  else
  {
    memset((void *)name, 0, sizeof(char [128l]) /*128ul*/ );
    snprintf(name, (unsigned long int)(128 - 1), "%s", (const void *)"sanlock_daemon");
    con=wdmd_connect();
    if(!(con >= 0))
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "wdmd connect failed for watchdog handling");

    else
    {
      rv=wdmd_register(con, name);
      if(!(rv >= 0))
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "wdmd register failed");

      else
      {
        rv=wdmd_refcount_set(con);
        if(!(rv >= 0))
          log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "wdmd refcount failed");

        else
        {
          rv=wdmd_status(con, &test_interval, &fire_timeout, &last_keepalive);
          if(!(rv >= 0))
            log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "wdmd status failed");

          else
          {
            log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 7, "wdmd test_interval %d fire_timeout %d last_keepalive %llu", test_interval, fire_timeout, (unsigned long long int)last_keepalive);
            if(!(fire_timeout == 60))
              log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "invalid watchdog fire_timeout %d vs %d", fire_timeout, 60);

            else
            {
              daemon_wdmd_con = con;
              return 0;
            }
          }

        fail_clear:
          ;
          wdmd_refcount_clear(con);
        }
      }

    fail_close:
      ;
      close(con);
    }

  fail:
    ;
    return -1;
  }
}

// sigterm_handler
// file main.c line 1107
static void sigterm_handler(signed int sig)
{
  external_shutdown = 1;
}

// status_client
// file client_cmd.c line 67
static void status_client(struct sanlk_state *st, char *str, signed int debug)
{
  printf("p %d ", st->data32);
  printf("%.48s\n", (const void *)st->name);
  if(!(st->str_len == 0u))
  {
    if(!(debug == 0))
      print_debug(str, (signed int)st->str_len);

  }

}

// status_daemon
// file client_cmd.c line 59
static void status_daemon(struct sanlk_state *st, char *str, signed int debug)
{
  printf("daemon %.48s\n", (const void *)st->name);
  if(!(st->str_len == 0u))
  {
    if(!(debug == 0))
      print_debug(str, (signed int)st->str_len);

  }

}

// status_host
// file client_cmd.c line 114
static void status_host(struct sanlk_state *st, char *str, signed int debug)
{
  printf("%u timestamp %llu\n", st->data32, (unsigned long long int)st->data64);
  if(!(st->str_len == 0u))
  {
    if(!(debug == 0))
      print_debug(str, (signed int)st->str_len);

  }

}

// status_lockspace
// file client_cmd.c line 76
static void status_lockspace(struct sanlk_state *st, char *str, char *bin, signed int debug)
{
  struct sanlk_lockspace *ls = (struct sanlk_lockspace *)bin;
  printf("s %.48s:%llu:%s:%llu\n", (const void *)ls->name, (unsigned long long int)ls->host_id, (const void *)ls->host_id_disk.path, (unsigned long long int)ls->host_id_disk.offset);
  if(!(st->str_len == 0u))
  {
    if(!(debug == 0))
      print_debug(str, (signed int)st->str_len);

  }

}

// status_resource
// file client_cmd.c line 90
static void status_resource(struct sanlk_state *st, char *str, char *bin, signed int debug)
{
  struct sanlk_resource *res = (struct sanlk_resource *)bin;
  struct sanlk_disk *disk;
  signed int i;
  printf("r %.48s:%.48s", (const void *)res->lockspace_name, (const void *)res->name);
  i = 0;
  for( ; !((unsigned int)i >= res->num_disks); i = i + 1)
  {
    disk = (struct sanlk_disk *)(bin + (signed long int)sizeof(struct sanlk_resource) /*128ul*/  + (signed long int)((unsigned long int)i * sizeof(struct sanlk_disk) /*1040ul*/ ));
    printf(":%s:%llu", (const void *)disk->path, (unsigned long long int)disk->offset);
  }
  if(!((4u & res->flags) == 0u))
    printf(":SH p %u\n", st->data32);

  else
    printf(":%llu p %u\n", (unsigned long long int)st->data64, st->data32);
  if(!(st->str_len == 0u))
  {
    if(!(debug == 0))
      print_debug(str, (signed int)st->str_len);

  }

}

// stop_lockspace_thread
// file lockspace.c line 837
static signed int stop_lockspace_thread(struct space *sp, signed int wait)
{
  signed int stop;
  signed int rv;
  pthread_mutex_lock(&sp->mutex);
  stop = sp->thread_stop;
  sp->thread_stop = 1;
  pthread_mutex_unlock(&sp->mutex);
  if(stop == 0)
  {
    log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "stop_lockspace_thread zero thread_stop");
    return -22;
  }

  else
  {
    if(!(wait == 0))
      rv=pthread_join(sp->thread, (void **)(void *)0);

    else
      rv=pthread_tryjoin_np(sp->thread, (void **)(void *)0);
    return rv;
  }
}

// test_id_bit
// file direct.c line 427
signed int test_id_bit(signed int host_id, char *bitmap)
{
  char *byte = bitmap + (signed long int)((host_id - 1) / 8);
  unsigned int bit = (unsigned int)((host_id - 1) % 8);
  char mask = (char)(1 << bit);
  return (signed int)*byte & (signed int)mask;
}

// thread_pool_add_work
// file main.c line 739
static signed int thread_pool_add_work(struct cmd_args *ca)
{
  unsigned long int th;
  signed int rv;
  pthread_mutex_lock(&pool.mutex);
  if(!(pool.quit == 0))
  {
    pthread_mutex_unlock(&pool.mutex);
    return -1;
  }

  else
  {
    list_add_tail(&ca->list, &pool.work_data);
    if(pool.free_workers == 0 && !(pool.num_workers >= pool.max_workers))
    {
      rv=pthread_create(&th, (const union pthread_attr_t *)(void *)0, thread_pool_worker, (void *)(signed long int)pool.num_workers);
      if(!(rv >= 0))
      {
        list_del_link1(&ca->list);
        pthread_mutex_unlock(&pool.mutex);
        return rv;
      }

      pool.num_workers = pool.num_workers + 1;
    }

    pthread_cond_signal(&pool.cond);
    pthread_mutex_unlock(&pool.mutex);
    return 0;
  }
}

// thread_pool_create
// file main.c line 779
static signed int thread_pool_create(signed int min_workers, signed int max_workers)
{
  unsigned long int th;
  signed int i;
  signed int rv;
  memset((void *)&pool, 0, sizeof(struct thread_pool) /*168ul*/ );
  INIT_LIST_HEAD(&pool.work_data);
  pthread_mutex_init(&pool.mutex, (const union anonymous_5 *)(void *)0);
  pthread_cond_init(&pool.cond, (const union anonymous_5 *)(void *)0);
  pthread_cond_init(&pool.quit_wait, (const union anonymous_5 *)(void *)0);
  pool.max_workers = max_workers;
  i = 0;
  for( ; !(i >= min_workers); i = i + 1)
  {
    rv=pthread_create(&th, (const union pthread_attr_t *)(void *)0, thread_pool_worker, (void *)(signed long int)i);
    if(!(rv >= 0))
      break;

    pool.num_workers = pool.num_workers + 1;
  }
  if(!(rv >= 0))
    thread_pool_free();

  return rv;
}

// thread_pool_free
// file main.c line 768
static void thread_pool_free(void)
{
  pthread_mutex_lock(&pool.mutex);
  pool.quit = 1;
  if(pool.num_workers >= 1)
  {
    pthread_cond_broadcast(&pool.cond);
    pthread_cond_wait(&pool.quit_wait, &pool.mutex);
  }

  pthread_mutex_unlock(&pool.mutex);
}

// thread_pool_worker
// file main.c line 696
static void * thread_pool_worker(void *data)
{
  struct task task;
  struct cmd_args *ca;
  memset((void *)&task, 0, sizeof(struct task) /*136ul*/ );
  setup_task_timeouts(&task, main_task.io_timeout_seconds);
  setup_task_aio(&task, main_task.use_aio, 2);
  snprintf(task.name, (unsigned long int)48, "worker%ld", (signed long int)data);
  pthread_mutex_lock(&pool.mutex);
  signed int return_value_list_empty_1;
  signed int return_value_list_empty_2;
  struct cmd_args *tmp_statement_expression_3;
  while((_Bool)1)
  {
    for( ; pool.quit == 0; pool.free_workers = pool.free_workers - 1)
    {
      return_value_list_empty_1=list_empty(&pool.work_data);
      if(return_value_list_empty_1 == 0)
        break;

      pool.free_workers = pool.free_workers + 1;
      pthread_cond_wait(&pool.cond, &pool.mutex);
    }
    do
    {
      return_value_list_empty_2=list_empty(&pool.work_data);
      if(!(return_value_list_empty_2 == 0))
        break;

      const struct list_head *__mptr = (&pool.work_data)->next;
      tmp_statement_expression_3 = (struct cmd_args *)((char *)__mptr - (signed long int)0ul);
      ca = tmp_statement_expression_3;
      list_del_link1(&ca->list);
      pthread_mutex_unlock(&pool.mutex);
      call_cmd_thread(&task, ca);
      free((void *)ca);
      pthread_mutex_lock(&pool.mutex);
    }
    while((_Bool)1);
    if(!(pool.quit == 0))
      break;

  }
  pool.num_workers = pool.num_workers - 1;
  if(pool.num_workers == 0)
    pthread_cond_signal(&pool.quit_wait);

  pthread_mutex_unlock(&pool.mutex);
  close_task_aio(&task);
  return (void *)0;
}

// time_diff
// file main.c line 550
static unsigned int time_diff(struct timeval *begin, struct timeval *end)
{
  struct timeval result;
  do
  {
    (&result)->tv_sec = end->tv_sec - begin->tv_sec;
    (&result)->tv_usec = end->tv_usec - begin->tv_usec;
    if(!(result.tv_usec >= 0l))
    {
      (&result)->tv_sec = (&result)->tv_sec - 1l;
      (&result)->tv_usec = (&result)->tv_usec + (signed long int)1000000;
    }

  }
  while((_Bool)0);
  return (unsigned int)(result.tv_sec * (signed long int)1000 + result.tv_usec / (signed long int)1000);
}

// unlink_lockfile
// file lockfile.c line 92
void unlink_lockfile(signed int fd, const char *dir, const char *name)
{
  char path[4096l];
  snprintf(path, (unsigned long int)4096, "%s/%s", dir, name);
  unlink(path);
  close(fd);
}

// unlink_watchdog_file
// file watchdog.h line 14
void unlink_watchdog_file(struct space *sp)
{
  signed int rv;
  if(!(com.use_watchdog == 0))
  {
    log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 7, "wdmd_test_live 0 0 to disable");
    rv=wdmd_test_live(sp->wd_fd, (unsigned long int)0, (unsigned long int)0);
    if(!(rv >= 0))
      log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "wdmd_test_live failed %d", rv);

  }

}

// update_watchdog_file
// file watchdog.h line 12
void update_watchdog_file(struct space *sp, unsigned long int timestamp)
{
  signed int rv;
  if(!(com.use_watchdog == 0))
  {
    rv=wdmd_test_live(sp->wd_fd, timestamp, timestamp + (unsigned long int)main_task.id_renewal_fail_seconds);
    if(!(rv >= 0))
      log_level(sp->space_id, (unsigned int)0, (char *)(void *)0, 3, "wdmd_test_live failed %d", rv);

  }

}

// user_to_uid
// file main.c line 1268
static signed int user_to_uid(char *arg)
{
  struct passwd *pw;
  pw=getpwnam(arg);
  if(pw == ((struct passwd *)NULL))
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "user '%s' not found, using uid: %i", arg, 0);
    return 0;
  }

  else
    return (signed int)pw->pw_uid;
}

// verify_dblock
// file paxos_lease.c line 188
static signed int verify_dblock(struct token *token, struct paxos_dblock *pd)
{
  unsigned int sum;
  if(pd->checksum == 0u)
  {
    if(!(pd->mbal == 0ul))
      goto __CPROVER_DUMP_L1;

    if(!(pd->bal == 0ul))
      goto __CPROVER_DUMP_L1;

    if(!(pd->inp == 0ul))
      goto __CPROVER_DUMP_L1;

    if(!(pd->lver == 0ul))
      goto __CPROVER_DUMP_L1;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    sum=dblock_checksum(pd);
    if(!(pd->checksum == sum))
    {
      log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "verify_dblock wrong checksum %x %x", pd->checksum, sum);
      return -214;
    }

    else
      return 1;
  }
}

// verify_dblock_link1
// file paxos_lease.c line 188
static signed int verify_dblock_link1(struct token *token_link1, struct paxos_dblock *pd_link1)
{
  unsigned int sum_link1;
  if(pd_link1->checksum == 0u)
  {
    if(!(pd_link1->mbal == 0ul))
      goto __CPROVER_DUMP_L1;

    if(!(pd_link1->bal == 0ul))
      goto __CPROVER_DUMP_L1;

    if(!(pd_link1->inp == 0ul))
      goto __CPROVER_DUMP_L1;

    if(!(pd_link1->lver == 0ul))
      goto __CPROVER_DUMP_L1;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    sum_link1=dblock_checksum_link1(pd_link1);
    if(!(pd_link1->checksum == sum_link1))
    {
      log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "verify_dblock wrong checksum %x %x", pd_link1->checksum, sum_link1);
      return -214;
    }

    else
      return 1;
  }
}

// verify_leader
// file delta_lease.c line 78
static signed int verify_leader(struct sync_disk *disk, char *space_name, unsigned long int host_id, struct leader_record *lr, const char *caller)
{
  unsigned int sum;
  signed int result;
  signed int return_value_strncmp_1;
  if(!(lr->magic == 304160784u))
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "verify_leader %llu wrong magic %x %s", (unsigned long long int)host_id, lr->magic, (const void *)disk->path);
    result = -223;
  }

  else
    if(!((0xFFFF0000 & lr->version) == 196608u))
    {
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "verify_leader %llu wrong version %x %s", (unsigned long long int)host_id, lr->version, (const void *)disk->path);
      result = -224;
    }

    else
      if(!(lr->sector_size == disk->sector_size))
      {
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "verify_leader %llu wrong sector size %d %d %s", (unsigned long long int)host_id, lr->sector_size, disk->sector_size, (const void *)disk->path);
        result = -225;
      }

      else
      {
        return_value_strncmp_1=strncmp(lr->space_name, space_name, (unsigned long int)48);
        if(!(return_value_strncmp_1 == 0))
        {
          log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "verify_leader %llu wrong space name %.48s %.48s %s", (unsigned long long int)host_id, (const void *)lr->space_name, space_name, (const void *)disk->path);
          result = -226;
        }

        else
        {
          sum=leader_checksum(lr);
          if(!(lr->checksum == sum))
          {
            log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "verify_leader %llu wrong checksum %x %x %s", (unsigned long long int)host_id, lr->checksum, sum, (const void *)disk->path);
            result = -229;
          }

          else
            return 1;
        }
      }

fail:
  ;
  log_leader_error(result, space_name, host_id, disk, lr, caller);
  return result;
}

// verify_leader_link1
// file paxos_lease.c line 607
static signed int verify_leader_link1(struct token *token, struct sync_disk *disk_link1, struct leader_record *lr_link1, const char *caller_link1)
{
  struct leader_record leader_rr;
  unsigned int sum_link1;
  signed int result_link1;
  signed int rv;
  signed int return_value_strncmp_1;
  signed int return_value_strncmp_2;
  if(!(lr_link1->magic == 102047760u))
  {
    log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "verify_leader wrong magic %x %s", lr_link1->magic, (const void *)disk_link1->path);
    result_link1 = -223;
  }

  else
    if(!((0xFFFF0000 & lr_link1->version) == 393216u))
    {
      log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "verify_leader wrong version %x %s", lr_link1->version, (const void *)disk_link1->path);
      result_link1 = -224;
    }

    else
      if(!(lr_link1->sector_size == disk_link1->sector_size))
      {
        log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "verify_leader wrong sector size %d %d %s", lr_link1->sector_size, disk_link1->sector_size, (const void *)disk_link1->path);
        result_link1 = -225;
      }

      else
      {
        return_value_strncmp_1=strncmp(lr_link1->space_name, token->r.lockspace_name, (unsigned long int)48);
        if(!(return_value_strncmp_1 == 0))
        {
          log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "verify_leader wrong space name %.48s %.48s %s", (const void *)lr_link1->space_name, (const void *)token->r.lockspace_name, (const void *)disk_link1->path);
          result_link1 = -226;
        }

        else
        {
          return_value_strncmp_2=strncmp(lr_link1->resource_name, token->r.name, (unsigned long int)48);
          if(!(return_value_strncmp_2 == 0))
          {
            log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "verify_leader wrong resource name %.48s %.48s %s", (const void *)lr_link1->resource_name, (const void *)token->r.name, (const void *)disk_link1->path);
            result_link1 = -227;
          }

          else
            if(!(lr_link1->num_hosts >= token->host_id))
            {
              log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "verify_leader num_hosts too small %llu %llu %s", (unsigned long long int)lr_link1->num_hosts, (unsigned long long int)token->host_id, (const void *)disk_link1->path);
              result_link1 = -228;
            }

            else
            {
              sum_link1=leader_checksum(lr_link1);
              if(!(lr_link1->checksum == sum_link1))
              {
                log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "verify_leader wrong checksum %x %x %s", lr_link1->checksum, sum_link1, (const void *)disk_link1->path);
                result_link1 = -229;
              }

              else
                return 1;
            }
        }
      }

fail:
  ;
  log_leader_error_link1(result_link1, token, disk_link1, lr_link1, caller_link1);
  memset((void *)&leader_rr, 0, sizeof(struct leader_record) /*200ul*/ );
  rv=read_sectors(disk_link1, (unsigned long int)0, (unsigned int)1, (char *)&leader_rr, (signed int)sizeof(struct leader_record) /*200ul*/ , (struct task *)(void *)0, "paxos_verify");
  log_leader_error_link1(rv, token, disk_link1, &leader_rr, "paxos_verify");
  return result_link1;
}

// verify_leader_link1_link1
// file paxos_lease.c line 607
static signed int verify_leader_link1_link1(struct token *token_link1, struct sync_disk *disk_link1_link1, struct leader_record *lr_link1_link1, const char *caller_link1_link1)
{
  struct leader_record leader_rr_link1;
  unsigned int sum_link1_link1;
  signed int result_link1_link1;
  signed int rv_link1;
  signed int return_value_strncmp_1_link1;
  signed int return_value_strncmp_2_link1;
  if(!(lr_link1_link1->magic == 102047760u))
  {
    log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "verify_leader wrong magic %x %s", lr_link1_link1->magic, (const void *)disk_link1_link1->path);
    result_link1_link1 = -223;
  }

  else
    if(!((0xFFFF0000 & lr_link1_link1->version) == 393216u))
    {
      log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "verify_leader wrong version %x %s", lr_link1_link1->version, (const void *)disk_link1_link1->path);
      result_link1_link1 = -224;
    }

    else
      if(!(lr_link1_link1->sector_size == disk_link1_link1->sector_size))
      {
        log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "verify_leader wrong sector size %d %d %s", lr_link1_link1->sector_size, disk_link1_link1->sector_size, (const void *)disk_link1_link1->path);
        result_link1_link1 = -225;
      }

      else
      {
        return_value_strncmp_1_link1=strncmp(lr_link1_link1->space_name, token_link1->r.lockspace_name, (unsigned long int)48);
        if(!(return_value_strncmp_1_link1 == 0))
        {
          log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "verify_leader wrong space name %.48s %.48s %s", (const void *)lr_link1_link1->space_name, (const void *)token_link1->r.lockspace_name, (const void *)disk_link1_link1->path);
          result_link1_link1 = -226;
        }

        else
        {
          return_value_strncmp_2_link1=strncmp(lr_link1_link1->resource_name, token_link1->r.name, (unsigned long int)48);
          if(!(return_value_strncmp_2_link1 == 0))
          {
            log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "verify_leader wrong resource name %.48s %.48s %s", (const void *)lr_link1_link1->resource_name, (const void *)token_link1->r.name, (const void *)disk_link1_link1->path);
            result_link1_link1 = -227;
          }

          else
            if(!(lr_link1_link1->num_hosts >= token_link1->host_id))
            {
              log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "verify_leader num_hosts too small %llu %llu %s", (unsigned long long int)lr_link1_link1->num_hosts, (unsigned long long int)token_link1->host_id, (const void *)disk_link1_link1->path);
              result_link1_link1 = -228;
            }

            else
            {
              sum_link1_link1=leader_checksum(lr_link1_link1);
              if(!(lr_link1_link1->checksum == sum_link1_link1))
              {
                log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "verify_leader wrong checksum %x %x %s", lr_link1_link1->checksum, sum_link1_link1, (const void *)disk_link1_link1->path);
                result_link1_link1 = -229;
              }

              else
                return 1;
            }
        }
      }

fail:
  ;
  log_leader_error_link1_link1(result_link1_link1, token_link1, disk_link1_link1, lr_link1_link1, caller_link1_link1);
  memset((void *)&leader_rr_link1, 0, sizeof(struct leader_record) /*200ul*/ );
  rv_link1=read_sectors(disk_link1_link1, (unsigned long int)0, (unsigned int)1, (char *)&leader_rr_link1, (signed int)sizeof(struct leader_record) /*200ul*/ , (struct task *)(void *)0, "paxos_verify");
  log_leader_error_link1_link1(rv_link1, token_link1, disk_link1_link1, &leader_rr_link1, "paxos_verify");
  return result_link1_link1;
}

// verify_leader_link2
// file delta_lease.c line 78
static signed int verify_leader_link2(struct sync_disk *disk_link2, char *space_name_link1, unsigned long int host_id_link1, struct leader_record *lr_link2, const char *caller_link2)
{
  unsigned int sum_link2;
  signed int result_link2;
  signed int return_value_strncmp_1_link1;
  if(!(lr_link2->magic == 304160784u))
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "verify_leader %llu wrong magic %x %s", (unsigned long long int)host_id_link1, lr_link2->magic, (const void *)disk_link2->path);
    result_link2 = -223;
  }

  else
    if(!((0xFFFF0000 & lr_link2->version) == 196608u))
    {
      log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "verify_leader %llu wrong version %x %s", (unsigned long long int)host_id_link1, lr_link2->version, (const void *)disk_link2->path);
      result_link2 = -224;
    }

    else
      if(!(lr_link2->sector_size == disk_link2->sector_size))
      {
        log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "verify_leader %llu wrong sector size %d %d %s", (unsigned long long int)host_id_link1, lr_link2->sector_size, disk_link2->sector_size, (const void *)disk_link2->path);
        result_link2 = -225;
      }

      else
      {
        return_value_strncmp_1_link1=strncmp(lr_link2->space_name, space_name_link1, (unsigned long int)48);
        if(!(return_value_strncmp_1_link1 == 0))
        {
          log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "verify_leader %llu wrong space name %.48s %.48s %s", (unsigned long long int)host_id_link1, (const void *)lr_link2->space_name, space_name_link1, (const void *)disk_link2->path);
          result_link2 = -226;
        }

        else
        {
          sum_link2=leader_checksum(lr_link2);
          if(!(lr_link2->checksum == sum_link2))
          {
            log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "verify_leader %llu wrong checksum %x %x %s", (unsigned long long int)host_id_link1, lr_link2->checksum, sum_link2, (const void *)disk_link2->path);
            result_link2 = -229;
          }

          else
            return 1;
        }
      }

fail:
  ;
  log_leader_error_link2(result_link2, space_name_link1, host_id_link1, disk_link2, lr_link2, caller_link2);
  return result_link2;
}

// wdmd_connect
// file ../wdmd/wdmd.h line 15
signed int wdmd_connect(void)
{
  signed int rv;
  signed int s;
  struct sockaddr_un addr;
  s=socket(1, 1, 0);
  signed int *return_value___errno_location_1;
  if(!(s >= 0))
  {
    return_value___errno_location_1=__errno_location();
    return -(*return_value___errno_location_1);
  }

  else
  {
    rv=wdmd_socket_address(&addr);
    if(!(rv >= 0))
      return rv;

    else
    {
      rv=connect(s, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
      if(!(rv >= 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        rv = -(*return_value___errno_location_2);
        close(s);
        return rv;
      }

      return s;
    }
  }
}

// wdmd_refcount_clear
// file ../wdmd/wdmd.h line 18
signed int wdmd_refcount_clear(signed int con)
{
  signed int return_value_send_header_1;
  return_value_send_header_1=send_header_link1(con, 3);
  return return_value_send_header_1;
}

// wdmd_refcount_set
// file ../wdmd/wdmd.h line 17
signed int wdmd_refcount_set(signed int con)
{
  signed int return_value_send_header_1;
  return_value_send_header_1=send_header_link1(con, 2);
  return return_value_send_header_1;
}

// wdmd_register
// file ../wdmd/wdmd.h line 16
signed int wdmd_register(signed int con, char *name)
{
  struct wdmd_header h;
  signed int rv;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  signed int *return_value___errno_location_3;
  if(return_value_strlen_1 >= 129ul)
    return -36;

  else
  {
    memset((void *)&h, 0, sizeof(struct wdmd_header) /*176ul*/ );
    h.cmd = (unsigned int)1;
    strncpy(h.name, name, (unsigned long int)128);
    signed long int return_value_send_2;
    return_value_send_2=send(con, (void *)&h, sizeof(struct wdmd_header) /*176ul*/ , 0);
    rv = (signed int)return_value_send_2;
    if(!(rv >= 0))
    {
      return_value___errno_location_3=__errno_location();
      return -(*return_value___errno_location_3);
    }

    else
      return 0;
  }
}

// wdmd_socket_address
// file wdmd_sock.h line 37
signed int wdmd_socket_address(struct sockaddr_un *addr)
{
  memset((void *)addr, 0, sizeof(struct sockaddr_un) /*110ul*/ );
  addr->sun_family = (unsigned short int)1;
  snprintf(addr->sun_path, sizeof(char [108l]) /*108ul*/  - (unsigned long int)1, "%s/%s", (const void *)"/var/run/wdmd", (const void *)"wdmd.sock");
  return 0;
}

// wdmd_status
// file ../wdmd/wdmd.h line 20
signed int wdmd_status(signed int con, signed int *test_interval, signed int *fire_timeout, unsigned long int *last_keepalive)
{
  struct wdmd_header h;
  signed int rv;
  rv=send_header_link1(con, 5);
  signed int *return_value___errno_location_2;
  if(!(rv >= 0))
    return rv;

  else
  {
    signed long int return_value_recv_1;
    return_value_recv_1=recv(con, (void *)&h, sizeof(struct wdmd_header) /*176ul*/ , 256);
    rv = (signed int)return_value_recv_1;
    if(!(rv >= 0))
    {
      return_value___errno_location_2=__errno_location();
      return -(*return_value___errno_location_2);
    }

    else
    {
      *test_interval = (signed int)h.test_interval;
      *fire_timeout = (signed int)h.fire_timeout;
      *last_keepalive = h.last_keepalive;
      return 0;
    }
  }
}

// wdmd_test_live
// file ../wdmd/wdmd.h line 19
signed int wdmd_test_live(signed int con, unsigned long int renewal_time, unsigned long int expire_time)
{
  struct wdmd_header h;
  signed int rv;
  memset((void *)&h, 0, sizeof(struct wdmd_header) /*176ul*/ );
  h.cmd = (unsigned int)4;
  h.renewal_time = renewal_time;
  h.expire_time = expire_time;
  signed long int return_value_send_1;
  return_value_send_1=send(con, (void *)&h, sizeof(struct wdmd_header) /*176ul*/ , 0);
  rv = (signed int)return_value_send_1;
  signed int *return_value___errno_location_2;
  if(!(rv >= 0))
  {
    return_value___errno_location_2=__errno_location();
    return -(*return_value___errno_location_2);
  }

  else
    return 0;
}

// write_dblock
// file paxos_lease.c line 88
static signed int write_dblock(struct task *task, struct sync_disk *disk, unsigned long int host_id, struct paxos_dblock *pd)
{
  signed int rv;
  rv=write_sector(disk, ((unsigned long int)2 + host_id) - (unsigned long int)1, (char *)pd, (signed int)sizeof(struct paxos_dblock) /*56ul*/ , task, "dblock");
  return rv;
}

// write_dblock_link1
// file paxos_lease.c line 88
static signed int write_dblock_link1(struct task *task_link1, struct sync_disk *disk_link1, unsigned long int host_id_link1, struct paxos_dblock *pd_link1)
{
  signed int rv_link1;
  rv_link1=write_sector(disk_link1, ((unsigned long int)2 + host_id_link1) - (unsigned long int)1, (char *)pd_link1, (signed int)sizeof(struct paxos_dblock) /*56ul*/ , task_link1, "dblock");
  return rv_link1;
}

// write_dropped
// file log.c line 182
static void write_dropped(signed int level, signed int num)
{
  char str[512l];
  sprintf(str, "dropped %d entries", num);
  write_entry(level, str);
}

// write_entry
// file log.c line 172
static void write_entry(signed int level, char *str)
{
  if(log_logfile_priority >= level && !(logfile_fp == ((struct _IO_FILE *)NULL)))
  {
    fprintf(logfile_fp, "%s", str);
    fflush(logfile_fp);
  }

  if(log_syslog_priority >= level)
    syslog(level, "%s", str);

}

// write_iobuf
// file diskio.h line 23
signed int write_iobuf(signed int fd, unsigned long int offset, char *iobuf, signed int iobuf_len, struct task *task)
{
  _Bool tmp_if_expr_5;
  if(!(task == ((struct task *)NULL)))
    tmp_if_expr_5 = task->use_aio == 1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_5 = (_Bool)0;
  signed int return_value_do_write_aio_linux_1;
  _Bool tmp_if_expr_4;
  signed int return_value_do_write_aio_posix_2;
  signed int return_value_do_write_3;
  if(tmp_if_expr_5)
  {
    return_value_do_write_aio_linux_1=do_write_aio_linux(fd, offset, iobuf, iobuf_len, task);
    return return_value_do_write_aio_linux_1;
  }

  else
  {
    if(!(task == ((struct task *)NULL)))
      tmp_if_expr_4 = task->use_aio == 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      return_value_do_write_aio_posix_2=do_write_aio_posix(fd, offset, iobuf, iobuf_len, task);
      return return_value_do_write_aio_posix_2;
    }

    else
    {
      return_value_do_write_3=do_write(fd, offset, iobuf, iobuf_len, task);
      return return_value_do_write_3;
    }
  }
}

// write_leader
// file paxos_lease.c line 103
static signed int write_leader(struct task *task, struct sync_disk *disk, struct leader_record *lr)
{
  signed int rv;
  rv=write_sector(disk, (unsigned long int)0, (char *)lr, (signed int)sizeof(struct leader_record) /*200ul*/ , task, "leader");
  return rv;
}

// write_leader_link1
// file paxos_lease.c line 103
static signed int write_leader_link1(struct task *task_link1, struct sync_disk *disk_link1, struct leader_record *lr_link1)
{
  signed int rv_link1;
  rv_link1=write_sector(disk_link1, (unsigned long int)0, (char *)lr_link1, (signed int)sizeof(struct leader_record) /*200ul*/ , task_link1, "leader");
  return rv_link1;
}

// write_new_leader
// file paxos_lease.c line 1040
static signed int write_new_leader(struct task *task, struct token *token, struct leader_record *nl, const char *caller)
{
  signed int num_disks = (signed int)token->r.num_disks;
  signed int num_writes = 0;
  signed int error = 1;
  signed int rv = 0;
  signed int d = 0;
  for( ; !(d >= num_disks); d = d + 1)
  {
    rv=write_leader(task, &token->disks[(signed long int)d], nl);
    if(rv >= 0)
      num_writes = num_writes + 1;

  }
  signed int return_value_majority_disks_1;
  return_value_majority_disks_1=majority_disks(num_disks, num_writes);
  if(return_value_majority_disks_1 == 0)
  {
    log_level((unsigned int)0, token->token_id, (char *)(void *)0, 3, "%s write_new_leader error %d owner %llu %llu %llu", caller, rv, (unsigned long long int)nl->owner_id, (unsigned long long int)nl->owner_generation, (unsigned long long int)nl->timestamp);
    error = -221;
  }

  return error;
}

// write_new_leader_link1
// file paxos_lease.c line 1040
static signed int write_new_leader_link1(struct task *task_link1, struct token *token_link1, struct leader_record *nl_link1, const char *caller_link1)
{
  signed int num_disks_link1 = (signed int)token_link1->r.num_disks;
  signed int num_writes_link1 = 0;
  signed int error_link1 = 1;
  signed int rv_link1 = 0;
  signed int d_link1 = 0;
  for( ; !(d_link1 >= num_disks_link1); d_link1 = d_link1 + 1)
  {
    rv_link1=write_leader_link1(task_link1, &token_link1->disks[(signed long int)d_link1], nl_link1);
    if(rv_link1 >= 0)
      num_writes_link1 = num_writes_link1 + 1;

  }
  signed int return_value_majority_disks_1_link1;
  return_value_majority_disks_1_link1=majority_disks(num_disks_link1, num_writes_link1);
  if(return_value_majority_disks_1_link1 == 0)
  {
    log_level((unsigned int)0, token_link1->token_id, (char *)(void *)0, 3, "%s write_new_leader error %d owner %llu %llu %llu", caller_link1, rv_link1, (unsigned long long int)nl_link1->owner_id, (unsigned long long int)nl_link1->owner_generation, (unsigned long long int)nl_link1->timestamp);
    error_link1 = -221;
  }

  return error_link1;
}

// write_sector
// file diskio.h line 37
signed int write_sector(struct sync_disk *disk, unsigned long int sector_nr, const char *data, signed int data_len, struct task *task, const char *blktype)
{
  signed int iobuf_len = (signed int)disk->sector_size;
  if(!(iobuf_len >= data_len))
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "write_sector %s data_len %d max %d %s", blktype, data_len, iobuf_len, (const void *)disk->path);
    return -1;
  }

  else
  {
    signed int return_value__write_sectors_1;
    return_value__write_sectors_1=_write_sectors(disk, sector_nr, (unsigned int)1, data, data_len, iobuf_len, task, blktype);
    return return_value__write_sectors_1;
  }
}

// write_sectors
// file diskio.c line 661
signed int write_sectors(struct sync_disk *disk, unsigned long int sector_nr, unsigned int sector_count, const char *data, signed int data_len, struct task *task, const char *blktype)
{
  signed int iobuf_len = data_len;
  if(!((unsigned int)data_len == disk->sector_size * sector_count))
  {
    log_level((unsigned int)0, (unsigned int)0, (char *)(void *)0, 3, "write_sectors %s data_len %d sector_count %d %s", blktype, data_len, sector_count, (const void *)disk->path);
    return -1;
  }

  else
  {
    signed int return_value__write_sectors_1;
    return_value__write_sectors_1=_write_sectors(disk, sector_nr, sector_count, data, data_len, iobuf_len, task, blktype);
    return return_value__write_sectors_1;
  }
}

