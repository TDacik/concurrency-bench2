// #anon_enum_CURLE_OK=0_CURLE_UNSUPPORTED_PROTOCOL=1_CURLE_FAILED_INIT=2_CURLE_URL_MALFORMAT=3_CURLE_NOT_BUILT_IN=4_CURLE_COULDNT_RESOLVE_PROXY=5_CURLE_COULDNT_RESOLVE_HOST=6_CURLE_COULDNT_CONNECT=7_CURLE_FTP_WEIRD_SERVER_REPLY=8_CURLE_REMOTE_ACCESS_DENIED=9_CURLE_FTP_ACCEPT_FAILED=10_CURLE_FTP_WEIRD_PASS_REPLY=11_CURLE_FTP_ACCEPT_TIMEOUT=12_CURLE_FTP_WEIRD_PASV_REPLY=13_CURLE_FTP_WEIRD_227_FORMAT=14_CURLE_FTP_CANT_GET_HOST=15_CURLE_HTTP2=16_CURLE_FTP_COULDNT_SET_TYPE=17_CURLE_PARTIAL_FILE=18_CURLE_FTP_COULDNT_RETR_FILE=19_CURLE_OBSOLETE20=20_CURLE_QUOTE_ERROR=21_CURLE_HTTP_RETURNED_ERROR=22_CURLE_WRITE_ERROR=23_CURLE_OBSOLETE24=24_CURLE_UPLOAD_FAILED=25_CURLE_READ_ERROR=26_CURLE_OUT_OF_MEMORY=27_CURLE_OPERATION_TIMEDOUT=28_CURLE_OBSOLETE29=29_CURLE_FTP_PORT_FAILED=30_CURLE_FTP_COULDNT_USE_REST=31_CURLE_OBSOLETE32=32_CURLE_RANGE_ERROR=33_CURLE_HTTP_POST_ERROR=34_CURLE_SSL_CONNECT_ERROR=35_CURLE_BAD_DOWNLOAD_RESUME=36_CURLE_FILE_COULDNT_READ_FILE=37_CURLE_LDAP_CANNOT_BIND=38_CURLE_LDAP_SEARCH_FAILED=39_CURLE_OBSOLETE40=40_CURLE_FUNCTION_NOT_FOUND=41_CURLE_ABORTED_BY_CALLBACK=42_CURLE_BAD_FUNCTION_ARGUMENT=43_CURLE_OBSOLETE44=44_CURLE_INTERFACE_FAILED=45_CURLE_OBSOLETE46=46_CURLE_TOO_MANY_REDIRECTS=47_CURLE_UNKNOWN_OPTION=48_CURLE_TELNET_OPTION_SYNTAX=49_CURLE_OBSOLETE50=50_CURLE_PEER_FAILED_VERIFICATION=51_CURLE_GOT_NOTHING=52_CURLE_SSL_ENGINE_NOTFOUND=53_CURLE_SSL_ENGINE_SETFAILED=54_CURLE_SEND_ERROR=55_CURLE_RECV_ERROR=56_CURLE_OBSOLETE57=57_CURLE_SSL_CERTPROBLEM=58_CURLE_SSL_CIPHER=59_CURLE_SSL_CACERT=60_CURLE_BAD_CONTENT_ENCODING=61_CURLE_LDAP_INVALID_URL=62_CURLE_FILESIZE_EXCEEDED=63_CURLE_USE_SSL_FAILED=64_CURLE_SEND_FAIL_REWIND=65_CURLE_SSL_ENGINE_INITFAILED=66_CURLE_LOGIN_DENIED=67_CURLE_TFTP_NOTFOUND=68_CURLE_TFTP_PERM=69_CURLE_REMOTE_DISK_FULL=70_CURLE_TFTP_ILLEGAL=71_CURLE_TFTP_UNKNOWNID=72_CURLE_REMOTE_FILE_EXISTS=73_CURLE_TFTP_NOSUCHUSER=74_CURLE_CONV_FAILED=75_CURLE_CONV_REQD=76_CURLE_SSL_CACERT_BADFILE=77_CURLE_REMOTE_FILE_NOT_FOUND=78_CURLE_SSH=79_CURLE_SSL_SHUTDOWN_FAILED=80_CURLE_AGAIN=81_CURLE_SSL_CRL_BADFILE=82_CURLE_SSL_ISSUER_ERROR=83_CURLE_FTP_PRET_FAILED=84_CURLE_RTSP_CSEQ_ERROR=85_CURLE_RTSP_SESSION_ERROR=86_CURLE_FTP_BAD_FILE_LIST=87_CURLE_CHUNK_FAILED=88_CURLE_NO_CONNECTION_AVAILABLE=89_CURLE_SSL_PINNEDPUBKEYNOTMATCH=90_CURLE_SSL_INVALIDCERTSTATUS=91_CURL_LAST=92
// file /usr/include/curl/curl.h line 414
enum anonymous_19 { CURLE_OK=0, CURLE_UNSUPPORTED_PROTOCOL=1, CURLE_FAILED_INIT=2, CURLE_URL_MALFORMAT=3, CURLE_NOT_BUILT_IN=4, CURLE_COULDNT_RESOLVE_PROXY=5, CURLE_COULDNT_RESOLVE_HOST=6, CURLE_COULDNT_CONNECT=7, CURLE_FTP_WEIRD_SERVER_REPLY=8, CURLE_REMOTE_ACCESS_DENIED=9, CURLE_FTP_ACCEPT_FAILED=10, CURLE_FTP_WEIRD_PASS_REPLY=11, CURLE_FTP_ACCEPT_TIMEOUT=12, CURLE_FTP_WEIRD_PASV_REPLY=13, CURLE_FTP_WEIRD_227_FORMAT=14, CURLE_FTP_CANT_GET_HOST=15, CURLE_HTTP2=16, CURLE_FTP_COULDNT_SET_TYPE=17, CURLE_PARTIAL_FILE=18, CURLE_FTP_COULDNT_RETR_FILE=19, CURLE_OBSOLETE20=20, CURLE_QUOTE_ERROR=21, CURLE_HTTP_RETURNED_ERROR=22, CURLE_WRITE_ERROR=23, CURLE_OBSOLETE24=24, CURLE_UPLOAD_FAILED=25, CURLE_READ_ERROR=26, CURLE_OUT_OF_MEMORY=27, CURLE_OPERATION_TIMEDOUT=28, CURLE_OBSOLETE29=29, CURLE_FTP_PORT_FAILED=30, CURLE_FTP_COULDNT_USE_REST=31, CURLE_OBSOLETE32=32, CURLE_RANGE_ERROR=33, CURLE_HTTP_POST_ERROR=34, CURLE_SSL_CONNECT_ERROR=35, CURLE_BAD_DOWNLOAD_RESUME=36, CURLE_FILE_COULDNT_READ_FILE=37, CURLE_LDAP_CANNOT_BIND=38, CURLE_LDAP_SEARCH_FAILED=39, CURLE_OBSOLETE40=40, CURLE_FUNCTION_NOT_FOUND=41, CURLE_ABORTED_BY_CALLBACK=42, CURLE_BAD_FUNCTION_ARGUMENT=43, CURLE_OBSOLETE44=44, CURLE_INTERFACE_FAILED=45, CURLE_OBSOLETE46=46, CURLE_TOO_MANY_REDIRECTS=47, CURLE_UNKNOWN_OPTION=48, CURLE_TELNET_OPTION_SYNTAX=49, CURLE_OBSOLETE50=50, CURLE_PEER_FAILED_VERIFICATION=51, CURLE_GOT_NOTHING=52, CURLE_SSL_ENGINE_NOTFOUND=53, CURLE_SSL_ENGINE_SETFAILED=54, CURLE_SEND_ERROR=55, CURLE_RECV_ERROR=56, CURLE_OBSOLETE57=57, CURLE_SSL_CERTPROBLEM=58, CURLE_SSL_CIPHER=59, CURLE_SSL_CACERT=60, CURLE_BAD_CONTENT_ENCODING=61, CURLE_LDAP_INVALID_URL=62, CURLE_FILESIZE_EXCEEDED=63, CURLE_USE_SSL_FAILED=64, CURLE_SEND_FAIL_REWIND=65, CURLE_SSL_ENGINE_INITFAILED=66, CURLE_LOGIN_DENIED=67, CURLE_TFTP_NOTFOUND=68, CURLE_TFTP_PERM=69, CURLE_REMOTE_DISK_FULL=70, CURLE_TFTP_ILLEGAL=71, CURLE_TFTP_UNKNOWNID=72, CURLE_REMOTE_FILE_EXISTS=73, CURLE_TFTP_NOSUCHUSER=74, CURLE_CONV_FAILED=75, CURLE_CONV_REQD=76, CURLE_SSL_CACERT_BADFILE=77, CURLE_REMOTE_FILE_NOT_FOUND=78, CURLE_SSH=79, CURLE_SSL_SHUTDOWN_FAILED=80, CURLE_AGAIN=81, CURLE_SSL_CRL_BADFILE=82, CURLE_SSL_ISSUER_ERROR=83, CURLE_FTP_PRET_FAILED=84, CURLE_RTSP_CSEQ_ERROR=85, CURLE_RTSP_SESSION_ERROR=86, CURLE_FTP_BAD_FILE_LIST=87, CURLE_CHUNK_FAILED=88, CURLE_NO_CONNECTION_AVAILABLE=89, CURLE_SSL_PINNEDPUBKEYNOTMATCH=90, CURLE_SSL_INVALIDCERTSTATUS=91, CURL_LAST=92 };

// #anon_enum_CURLINFO_NONE=0_CURLINFO_EFFECTIVE_URL=1048577_CURLINFO_RESPONSE_CODE=2097154_CURLINFO_TOTAL_TIME=3145731_CURLINFO_NAMELOOKUP_TIME=3145732_CURLINFO_CONNECT_TIME=3145733_CURLINFO_PRETRANSFER_TIME=3145734_CURLINFO_SIZE_UPLOAD=3145735_CURLINFO_SIZE_DOWNLOAD=3145736_CURLINFO_SPEED_DOWNLOAD=3145737_CURLINFO_SPEED_UPLOAD=3145738_CURLINFO_HEADER_SIZE=2097163_CURLINFO_REQUEST_SIZE=2097164_CURLINFO_SSL_VERIFYRESULT=2097165_CURLINFO_FILETIME=2097166_CURLINFO_CONTENT_LENGTH_DOWNLOAD=3145743_CURLINFO_CONTENT_LENGTH_UPLOAD=3145744_CURLINFO_STARTTRANSFER_TIME=3145745_CURLINFO_CONTENT_TYPE=1048594_CURLINFO_REDIRECT_TIME=3145747_CURLINFO_REDIRECT_COUNT=2097172_CURLINFO_PRIVATE=1048597_CURLINFO_HTTP_CONNECTCODE=2097174_CURLINFO_HTTPAUTH_AVAIL=2097175_CURLINFO_PROXYAUTH_AVAIL=2097176_CURLINFO_OS_ERRNO=2097177_CURLINFO_NUM_CONNECTS=2097178_CURLINFO_SSL_ENGINES=4194331_CURLINFO_COOKIELIST=4194332_CURLINFO_LASTSOCKET=2097181_CURLINFO_FTP_ENTRY_PATH=1048606_CURLINFO_REDIRECT_URL=1048607_CURLINFO_PRIMARY_IP=1048608_CURLINFO_APPCONNECT_TIME=3145761_CURLINFO_CERTINFO=4194338_CURLINFO_CONDITION_UNMET=2097187_CURLINFO_RTSP_SESSION_ID=1048612_CURLINFO_RTSP_CLIENT_CSEQ=2097189_CURLINFO_RTSP_SERVER_CSEQ=2097190_CURLINFO_RTSP_CSEQ_RECV=2097191_CURLINFO_PRIMARY_PORT=2097192_CURLINFO_LOCAL_IP=1048617_CURLINFO_LOCAL_PORT=2097194_CURLINFO_TLS_SESSION=4194347_CURLINFO_ACTIVESOCKET=5242924_CURLINFO_LASTONE=44
// file /usr/include/curl/curl.h line 2126
enum anonymous_17 { CURLINFO_NONE=0, CURLINFO_EFFECTIVE_URL=1048577, CURLINFO_RESPONSE_CODE=2097154, CURLINFO_TOTAL_TIME=3145731, CURLINFO_NAMELOOKUP_TIME=3145732, CURLINFO_CONNECT_TIME=3145733, CURLINFO_PRETRANSFER_TIME=3145734, CURLINFO_SIZE_UPLOAD=3145735, CURLINFO_SIZE_DOWNLOAD=3145736, CURLINFO_SPEED_DOWNLOAD=3145737, CURLINFO_SPEED_UPLOAD=3145738, CURLINFO_HEADER_SIZE=2097163, CURLINFO_REQUEST_SIZE=2097164, CURLINFO_SSL_VERIFYRESULT=2097165, CURLINFO_FILETIME=2097166, CURLINFO_CONTENT_LENGTH_DOWNLOAD=3145743, CURLINFO_CONTENT_LENGTH_UPLOAD=3145744, CURLINFO_STARTTRANSFER_TIME=3145745, CURLINFO_CONTENT_TYPE=1048594, CURLINFO_REDIRECT_TIME=3145747, CURLINFO_REDIRECT_COUNT=2097172, CURLINFO_PRIVATE=1048597, CURLINFO_HTTP_CONNECTCODE=2097174, CURLINFO_HTTPAUTH_AVAIL=2097175, CURLINFO_PROXYAUTH_AVAIL=2097176, CURLINFO_OS_ERRNO=2097177, CURLINFO_NUM_CONNECTS=2097178, CURLINFO_SSL_ENGINES=4194331, CURLINFO_COOKIELIST=4194332, CURLINFO_LASTSOCKET=2097181, CURLINFO_FTP_ENTRY_PATH=1048606, CURLINFO_REDIRECT_URL=1048607, CURLINFO_PRIMARY_IP=1048608, CURLINFO_APPCONNECT_TIME=3145761, CURLINFO_CERTINFO=4194338, CURLINFO_CONDITION_UNMET=2097187, CURLINFO_RTSP_SESSION_ID=1048612, CURLINFO_RTSP_CLIENT_CSEQ=2097189, CURLINFO_RTSP_SERVER_CSEQ=2097190, CURLINFO_RTSP_CSEQ_RECV=2097191, CURLINFO_PRIMARY_PORT=2097192, CURLINFO_LOCAL_IP=1048617, CURLINFO_LOCAL_PORT=2097194, CURLINFO_TLS_SESSION=4194347, CURLINFO_ACTIVESOCKET=5242924, CURLINFO_LASTONE=44 };

// #anon_enum_CURLOPT_WRITEDATA=10001_CURLOPT_URL=10002_CURLOPT_PORT=3_CURLOPT_PROXY=10004_CURLOPT_USERPWD=10005_CURLOPT_PROXYUSERPWD=10006_CURLOPT_RANGE=10007_CURLOPT_READDATA=10009_CURLOPT_ERRORBUFFER=10010_CURLOPT_WRITEFUNCTION=20011_CURLOPT_READFUNCTION=20012_CURLOPT_TIMEOUT=13_CURLOPT_INFILESIZE=14_CURLOPT_POSTFIELDS=10015_CURLOPT_REFERER=10016_CURLOPT_FTPPORT=10017_CURLOPT_USERAGENT=10018_CURLOPT_LOW_SPEED_LIMIT=19_CURLOPT_LOW_SPEED_TIME=20_CURLOPT_RESUME_FROM=21_CURLOPT_COOKIE=10022_CURLOPT_HTTPHEADER=10023_CURLOPT_HTTPPOST=10024_CURLOPT_SSLCERT=10025_CURLOPT_KEYPASSWD=10026_CURLOPT_CRLF=27_CURLOPT_QUOTE=10028_CURLOPT_HEADERDATA=10029_CURLOPT_COOKIEFILE=10031_CURLOPT_SSLVERSION=32_CURLOPT_TIMECONDITION=33_CURLOPT_TIMEVALUE=34_CURLOPT_CUSTOMREQUEST=10036_CURLOPT_STDERR=10037_CURLOPT_POSTQUOTE=10039_CURLOPT_OBSOLETE40=10040_CURLOPT_VERBOSE=41_CURLOPT_HEADER=42_CURLOPT_NOPROGRESS=43_CURLOPT_NOBODY=44_CURLOPT_FAILONERROR=45_CURLOPT_UPLOAD=46_CURLOPT_POST=47_CURLOPT_DIRLISTONLY=48_CURLOPT_APPEND=50_CURLOPT_NETRC=51_CURLOPT_FOLLOWLOCATION=52_CURLOPT_TRANSFERTEXT=53_CURLOPT_PUT=54_CURLOPT_PROGRESSFUNCTION=20056_CURLOPT_PROGRESSDATA=10057_CURLOPT_AUTOREFERER=58_CURLOPT_PROXYPORT=59_CURLOPT_POSTFIELDSIZE=60_CURLOPT_HTTPPROXYTUNNEL=61_CURLOPT_INTERFACE=10062_CURLOPT_KRBLEVEL=10063_CURLOPT_SSL_VERIFYPEER=64_CURLOPT_CAINFO=10065_CURLOPT_MAXREDIRS=68_CURLOPT_FILETIME=69_CURLOPT_TELNETOPTIONS=10070_CURLOPT_MAXCONNECTS=71_CURLOPT_OBSOLETE72=72_CURLOPT_FRESH_CONNECT=74_CURLOPT_FORBID_REUSE=75_CURLOPT_RANDOM_FILE=10076_CURLOPT_EGDSOCKET=10077_CURLOPT_CONNECTTIMEOUT=78_CURLOPT_HEADERFUNCTION=20079_CURLOPT_HTTPGET=80_CURLOPT_SSL_VERIFYHOST=81_CURLOPT_COOKIEJAR=10082_CURLOPT_SSL_CIPHER_LIST=10083_CURLOPT_HTTP_VERSION=84_CURLOPT_FTP_USE_EPSV=85_CURLOPT_SSLCERTTYPE=10086_CURLOPT_SSLKEY=10087_CURLOPT_SSLKEYTYPE=10088_CURLOPT_SSLENGINE=10089_CURLOPT_SSLENGINE_DEFAULT=90_CURLOPT_DNS_USE_GLOBAL_CACHE=91_CURLOPT_DNS_CACHE_TIMEOUT=92_CURLOPT_PREQUOTE=10093_CURLOPT_DEBUGFUNCTION=20094_CURLOPT_DEBUGDATA=10095_CURLOPT_COOKIESESSION=96_CURLOPT_CAPATH=10097_CURLOPT_BUFFERSIZE=98_CURLOPT_NOSIGNAL=99_CURLOPT_SHARE=10100_CURLOPT_PROXYTYPE=101_CURLOPT_ACCEPT_ENCODING=10102_CURLOPT_PRIVATE=10103_CURLOPT_HTTP200ALIASES=10104_CURLOPT_UNRESTRICTED_AUTH=105_CURLOPT_FTP_USE_EPRT=106_CURLOPT_HTTPAUTH=107_CURLOPT_SSL_CTX_FUNCTION=20108_CURLOPT_SSL_CTX_DATA=10109_CURLOPT_FTP_CREATE_MISSING_DIRS=110_CURLOPT_PROXYAUTH=111_CURLOPT_FTP_RESPONSE_TIMEOUT=112_CURLOPT_IPRESOLVE=113_CURLOPT_MAXFILESIZE=114_CURLOPT_INFILESIZE_LARGE=30115_CURLOPT_RESUME_FROM_LARGE=30116_CURLOPT_MAXFILESIZE_LARGE=30117_CURLOPT_NETRC_FILE=10118_CURLOPT_USE_SSL=119_CURLOPT_POSTFIELDSIZE_LARGE=30120_CURLOPT_TCP_NODELAY=121_CURLOPT_FTPSSLAUTH=129_CURLOPT_IOCTLFUNCTION=20130_CURLOPT_IOCTLDATA=10131_CURLOPT_FTP_ACCOUNT=10134_CURLOPT_COOKIELIST=10135_CURLOPT_IGNORE_CONTENT_LENGTH=136_CURLOPT_FTP_SKIP_PASV_IP=137_CURLOPT_FTP_FILEMETHOD=138_CURLOPT_LOCALPORT=139_CURLOPT_LOCALPORTRANGE=140_CURLOPT_CONNECT_ONLY=141_CURLOPT_CONV_FROM_NETWORK_FUNCTION=20142_CURLOPT_CONV_TO_NETWORK_FUNCTION=20143_CURLOPT_CONV_FROM_UTF8_FUNCTION=20144_CURLOPT_MAX_SEND_SPEED_LARGE=30145_CURLOPT_MAX_RECV_SPEED_LARGE=30146_CURLOPT_FTP_ALTERNATIVE_TO_USER=10147_CURLOPT_SOCKOPTFUNCTION=20148_CURLOPT_SOCKOPTDATA=10149_CURLOPT_SSL_SESSIONID_CACHE=150_CURLOPT_SSH_AUTH_TYPES=151_CURLOPT_SSH_PUBLIC_KEYFILE=10152_CURLOPT_SSH_PRIVATE_KEYFILE=10153_CURLOPT_FTP_SSL_CCC=154_CURLOPT_TIMEOUT_MS=155_CURLOPT_CONNECTTIMEOUT_MS=156_CURLOPT_HTTP_TRANSFER_DECODING=157_CURLOPT_HTTP_CONTENT_DECODING=158_CURLOPT_NEW_FILE_PERMS=159_CURLOPT_NEW_DIRECTORY_PERMS=160_CURLOPT_POSTREDIR=161_CURLOPT_SSH_HOST_PUBLIC_KEY_MD5=10162_CURLOPT_OPENSOCKETFUNCTION=20163_CURLOPT_OPENSOCKETDATA=10164_CURLOPT_COPYPOSTFIELDS=10165_CURLOPT_PROXY_TRANSFER_MODE=166_CURLOPT_SEEKFUNCTION=20167_CURLOPT_SEEKDATA=10168_CURLOPT_CRLFILE=10169_CURLOPT_ISSUERCERT=10170_CURLOPT_ADDRESS_SCOPE=171_CURLOPT_CERTINFO=172_CURLOPT_USERNAME=10173_CURLOPT_PASSWORD=10174_CURLOPT_PROXYUSERNAME=10175_CURLOPT_PROXYPASSWORD=10176_CURLOPT_NOPROXY=10177_CURLOPT_TFTP_BLKSIZE=178_CURLOPT_SOCKS5_GSSAPI_SERVICE=10179_CURLOPT_SOCKS5_GSSAPI_NEC=180_CURLOPT_PROTOCOLS=181_CURLOPT_REDIR_PROTOCOLS=182_CURLOPT_SSH_KNOWNHOSTS=10183_CURLOPT_SSH_KEYFUNCTION=20184_CURLOPT_SSH_KEYDATA=10185_CURLOPT_MAIL_FROM=10186_CURLOPT_MAIL_RCPT=10187_CURLOPT_FTP_USE_PRET=188_CURLOPT_RTSP_REQUEST=189_CURLOPT_RTSP_SESSION_ID=10190_CURLOPT_RTSP_STREAM_URI=10191_CURLOPT_RTSP_TRANSPORT=10192_CURLOPT_RTSP_CLIENT_CSEQ=193_CURLOPT_RTSP_SERVER_CSEQ=194_CURLOPT_INTERLEAVEDATA=10195_CURLOPT_INTERLEAVEFUNCTION=20196_CURLOPT_WILDCARDMATCH=197_CURLOPT_CHUNK_BGN_FUNCTION=20198_CURLOPT_CHUNK_END_FUNCTION=20199_CURLOPT_FNMATCH_FUNCTION=20200_CURLOPT_CHUNK_DATA=10201_CURLOPT_FNMATCH_DATA=10202_CURLOPT_RESOLVE=10203_CURLOPT_TLSAUTH_USERNAME=10204_CURLOPT_TLSAUTH_PASSWORD=10205_CURLOPT_TLSAUTH_TYPE=10206_CURLOPT_TRANSFER_ENCODING=207_CURLOPT_CLOSESOCKETFUNCTION=20208_CURLOPT_CLOSESOCKETDATA=10209_CURLOPT_GSSAPI_DELEGATION=210_CURLOPT_DNS_SERVERS=10211_CURLOPT_ACCEPTTIMEOUT_MS=212_CURLOPT_TCP_KEEPALIVE=213_CURLOPT_TCP_KEEPIDLE=214_CURLOPT_TCP_KEEPINTVL=215_CURLOPT_SSL_OPTIONS=216_CURLOPT_MAIL_AUTH=10217_CURLOPT_SASL_IR=218_CURLOPT_XFERINFOFUNCTION=20219_CURLOPT_XOAUTH2_BEARER=10220_CURLOPT_DNS_INTERFACE=10221_CURLOPT_DNS_LOCAL_IP4=10222_CURLOPT_DNS_LOCAL_IP6=10223_CURLOPT_LOGIN_OPTIONS=10224_CURLOPT_SSL_ENABLE_NPN=225_CURLOPT_SSL_ENABLE_ALPN=226_CURLOPT_EXPECT_100_TIMEOUT_MS=227_CURLOPT_PROXYHEADER=10228_CURLOPT_HEADEROPT=229_CURLOPT_PINNEDPUBLICKEY=10230_CURLOPT_UNIX_SOCKET_PATH=10231_CURLOPT_SSL_VERIFYSTATUS=232_CURLOPT_SSL_FALSESTART=233_CURLOPT_PATH_AS_IS=234_CURLOPT_PROXY_SERVICE_NAME=10235_CURLOPT_SERVICE_NAME=10236_CURLOPT_PIPEWAIT=237_CURLOPT_DEFAULT_PROTOCOL=10238_CURLOPT_STREAM_WEIGHT=239_CURLOPT_STREAM_DEPENDS=10240_CURLOPT_STREAM_DEPENDS_E=10241_CURLOPT_LASTENTRY=10242
// file /usr/include/curl/curl.h line 864
enum anonymous_20 { CURLOPT_WRITEDATA=10001, CURLOPT_URL=10002, CURLOPT_PORT=3, CURLOPT_PROXY=10004, CURLOPT_USERPWD=10005, CURLOPT_PROXYUSERPWD=10006, CURLOPT_RANGE=10007, CURLOPT_READDATA=10009, CURLOPT_ERRORBUFFER=10010, CURLOPT_WRITEFUNCTION=20011, CURLOPT_READFUNCTION=20012, CURLOPT_TIMEOUT=13, CURLOPT_INFILESIZE=14, CURLOPT_POSTFIELDS=10015, CURLOPT_REFERER=10016, CURLOPT_FTPPORT=10017, CURLOPT_USERAGENT=10018, CURLOPT_LOW_SPEED_LIMIT=19, CURLOPT_LOW_SPEED_TIME=20, CURLOPT_RESUME_FROM=21, CURLOPT_COOKIE=10022, CURLOPT_HTTPHEADER=10023, CURLOPT_HTTPPOST=10024, CURLOPT_SSLCERT=10025, CURLOPT_KEYPASSWD=10026, CURLOPT_CRLF=27, CURLOPT_QUOTE=10028, CURLOPT_HEADERDATA=10029, CURLOPT_COOKIEFILE=10031, CURLOPT_SSLVERSION=32, CURLOPT_TIMECONDITION=33, CURLOPT_TIMEVALUE=34, CURLOPT_CUSTOMREQUEST=10036, CURLOPT_STDERR=10037, CURLOPT_POSTQUOTE=10039, CURLOPT_OBSOLETE40=10040, CURLOPT_VERBOSE=41, CURLOPT_HEADER=42, CURLOPT_NOPROGRESS=43, CURLOPT_NOBODY=44, CURLOPT_FAILONERROR=45, CURLOPT_UPLOAD=46, CURLOPT_POST=47, CURLOPT_DIRLISTONLY=48, CURLOPT_APPEND=50, CURLOPT_NETRC=51, CURLOPT_FOLLOWLOCATION=52, CURLOPT_TRANSFERTEXT=53, CURLOPT_PUT=54, CURLOPT_PROGRESSFUNCTION=20056, CURLOPT_PROGRESSDATA=10057, CURLOPT_AUTOREFERER=58, CURLOPT_PROXYPORT=59, CURLOPT_POSTFIELDSIZE=60, CURLOPT_HTTPPROXYTUNNEL=61, CURLOPT_INTERFACE=10062, CURLOPT_KRBLEVEL=10063, CURLOPT_SSL_VERIFYPEER=64, CURLOPT_CAINFO=10065, CURLOPT_MAXREDIRS=68, CURLOPT_FILETIME=69, CURLOPT_TELNETOPTIONS=10070, CURLOPT_MAXCONNECTS=71, CURLOPT_OBSOLETE72=72, CURLOPT_FRESH_CONNECT=74, CURLOPT_FORBID_REUSE=75, CURLOPT_RANDOM_FILE=10076, CURLOPT_EGDSOCKET=10077, CURLOPT_CONNECTTIMEOUT=78, CURLOPT_HEADERFUNCTION=20079, CURLOPT_HTTPGET=80, CURLOPT_SSL_VERIFYHOST=81, CURLOPT_COOKIEJAR=10082, CURLOPT_SSL_CIPHER_LIST=10083, CURLOPT_HTTP_VERSION=84, CURLOPT_FTP_USE_EPSV=85, CURLOPT_SSLCERTTYPE=10086, CURLOPT_SSLKEY=10087, CURLOPT_SSLKEYTYPE=10088, CURLOPT_SSLENGINE=10089, CURLOPT_SSLENGINE_DEFAULT=90, CURLOPT_DNS_USE_GLOBAL_CACHE=91, CURLOPT_DNS_CACHE_TIMEOUT=92, CURLOPT_PREQUOTE=10093, CURLOPT_DEBUGFUNCTION=20094, CURLOPT_DEBUGDATA=10095, CURLOPT_COOKIESESSION=96, CURLOPT_CAPATH=10097, CURLOPT_BUFFERSIZE=98, CURLOPT_NOSIGNAL=99, CURLOPT_SHARE=10100, CURLOPT_PROXYTYPE=101, CURLOPT_ACCEPT_ENCODING=10102, CURLOPT_PRIVATE=10103, CURLOPT_HTTP200ALIASES=10104, CURLOPT_UNRESTRICTED_AUTH=105, CURLOPT_FTP_USE_EPRT=106, CURLOPT_HTTPAUTH=107, CURLOPT_SSL_CTX_FUNCTION=20108, CURLOPT_SSL_CTX_DATA=10109, CURLOPT_FTP_CREATE_MISSING_DIRS=110, CURLOPT_PROXYAUTH=111, CURLOPT_FTP_RESPONSE_TIMEOUT=112, CURLOPT_IPRESOLVE=113, CURLOPT_MAXFILESIZE=114, CURLOPT_INFILESIZE_LARGE=30115, CURLOPT_RESUME_FROM_LARGE=30116, CURLOPT_MAXFILESIZE_LARGE=30117, CURLOPT_NETRC_FILE=10118, CURLOPT_USE_SSL=119, CURLOPT_POSTFIELDSIZE_LARGE=30120, CURLOPT_TCP_NODELAY=121, CURLOPT_FTPSSLAUTH=129, CURLOPT_IOCTLFUNCTION=20130, CURLOPT_IOCTLDATA=10131, CURLOPT_FTP_ACCOUNT=10134, CURLOPT_COOKIELIST=10135, CURLOPT_IGNORE_CONTENT_LENGTH=136, CURLOPT_FTP_SKIP_PASV_IP=137, CURLOPT_FTP_FILEMETHOD=138, CURLOPT_LOCALPORT=139, CURLOPT_LOCALPORTRANGE=140, CURLOPT_CONNECT_ONLY=141, CURLOPT_CONV_FROM_NETWORK_FUNCTION=20142, CURLOPT_CONV_TO_NETWORK_FUNCTION=20143, CURLOPT_CONV_FROM_UTF8_FUNCTION=20144, CURLOPT_MAX_SEND_SPEED_LARGE=30145, CURLOPT_MAX_RECV_SPEED_LARGE=30146, CURLOPT_FTP_ALTERNATIVE_TO_USER=10147, CURLOPT_SOCKOPTFUNCTION=20148, CURLOPT_SOCKOPTDATA=10149, CURLOPT_SSL_SESSIONID_CACHE=150, CURLOPT_SSH_AUTH_TYPES=151, CURLOPT_SSH_PUBLIC_KEYFILE=10152, CURLOPT_SSH_PRIVATE_KEYFILE=10153, CURLOPT_FTP_SSL_CCC=154, CURLOPT_TIMEOUT_MS=155, CURLOPT_CONNECTTIMEOUT_MS=156, CURLOPT_HTTP_TRANSFER_DECODING=157, CURLOPT_HTTP_CONTENT_DECODING=158, CURLOPT_NEW_FILE_PERMS=159, CURLOPT_NEW_DIRECTORY_PERMS=160, CURLOPT_POSTREDIR=161, CURLOPT_SSH_HOST_PUBLIC_KEY_MD5=10162, CURLOPT_OPENSOCKETFUNCTION=20163, CURLOPT_OPENSOCKETDATA=10164, CURLOPT_COPYPOSTFIELDS=10165, CURLOPT_PROXY_TRANSFER_MODE=166, CURLOPT_SEEKFUNCTION=20167, CURLOPT_SEEKDATA=10168, CURLOPT_CRLFILE=10169, CURLOPT_ISSUERCERT=10170, CURLOPT_ADDRESS_SCOPE=171, CURLOPT_CERTINFO=172, CURLOPT_USERNAME=10173, CURLOPT_PASSWORD=10174, CURLOPT_PROXYUSERNAME=10175, CURLOPT_PROXYPASSWORD=10176, CURLOPT_NOPROXY=10177, CURLOPT_TFTP_BLKSIZE=178, CURLOPT_SOCKS5_GSSAPI_SERVICE=10179, CURLOPT_SOCKS5_GSSAPI_NEC=180, CURLOPT_PROTOCOLS=181, CURLOPT_REDIR_PROTOCOLS=182, CURLOPT_SSH_KNOWNHOSTS=10183, CURLOPT_SSH_KEYFUNCTION=20184, CURLOPT_SSH_KEYDATA=10185, CURLOPT_MAIL_FROM=10186, CURLOPT_MAIL_RCPT=10187, CURLOPT_FTP_USE_PRET=188, CURLOPT_RTSP_REQUEST=189, CURLOPT_RTSP_SESSION_ID=10190, CURLOPT_RTSP_STREAM_URI=10191, CURLOPT_RTSP_TRANSPORT=10192, CURLOPT_RTSP_CLIENT_CSEQ=193, CURLOPT_RTSP_SERVER_CSEQ=194, CURLOPT_INTERLEAVEDATA=10195, CURLOPT_INTERLEAVEFUNCTION=20196, CURLOPT_WILDCARDMATCH=197, CURLOPT_CHUNK_BGN_FUNCTION=20198, CURLOPT_CHUNK_END_FUNCTION=20199, CURLOPT_FNMATCH_FUNCTION=20200, CURLOPT_CHUNK_DATA=10201, CURLOPT_FNMATCH_DATA=10202, CURLOPT_RESOLVE=10203, CURLOPT_TLSAUTH_USERNAME=10204, CURLOPT_TLSAUTH_PASSWORD=10205, CURLOPT_TLSAUTH_TYPE=10206, CURLOPT_TRANSFER_ENCODING=207, CURLOPT_CLOSESOCKETFUNCTION=20208, CURLOPT_CLOSESOCKETDATA=10209, CURLOPT_GSSAPI_DELEGATION=210, CURLOPT_DNS_SERVERS=10211, CURLOPT_ACCEPTTIMEOUT_MS=212, CURLOPT_TCP_KEEPALIVE=213, CURLOPT_TCP_KEEPIDLE=214, CURLOPT_TCP_KEEPINTVL=215, CURLOPT_SSL_OPTIONS=216, CURLOPT_MAIL_AUTH=10217, CURLOPT_SASL_IR=218, CURLOPT_XFERINFOFUNCTION=20219, CURLOPT_XOAUTH2_BEARER=10220, CURLOPT_DNS_INTERFACE=10221, CURLOPT_DNS_LOCAL_IP4=10222, CURLOPT_DNS_LOCAL_IP6=10223, CURLOPT_LOGIN_OPTIONS=10224, CURLOPT_SSL_ENABLE_NPN=225, CURLOPT_SSL_ENABLE_ALPN=226, CURLOPT_EXPECT_100_TIMEOUT_MS=227, CURLOPT_PROXYHEADER=10228, CURLOPT_HEADEROPT=229, CURLOPT_PINNEDPUBLICKEY=10230, CURLOPT_UNIX_SOCKET_PATH=10231, CURLOPT_SSL_VERIFYSTATUS=232, CURLOPT_SSL_FALSESTART=233, CURLOPT_PATH_AS_IS=234, CURLOPT_PROXY_SERVICE_NAME=10235, CURLOPT_SERVICE_NAME=10236, CURLOPT_PIPEWAIT=237, CURLOPT_DEFAULT_PROTOCOL=10238, CURLOPT_STREAM_WEIGHT=239, CURLOPT_STREAM_DEPENDS=10240, CURLOPT_STREAM_DEPENDS_E=10241, CURLOPT_LASTENTRY=10242 };

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_32;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_30;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_16;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_9;

// tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous_4;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_26;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_29;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_28;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_25;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_27;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_31;

// tag-#anon#ST[U32'__pad'||U32'nr_nodes'||ARR2{U32}_U32_'__reserved'||U64'store_size'||U64'store_free'|]
// file ../include/sheepdog_proto.h line 200
struct anonymous;

// tag-#anon#ST[U32'__pad'||U32'rsvd'||U32'vdi_id'||U32'attr_id'||U8'copies'||ARR3{U8}_U8_'reserved'|]
// file ../include/sheepdog_proto.h line 190
struct anonymous_2;

// tag-#anon#ST[U32'__pad'||U8'copies'||ARR3{U8}_U8_'reserved'||U64'offset'|]
// file ../include/sheepdog_proto.h line 184
struct anonymous_1;

// tag-#anon#ST[U32'__pad1'||U32'__pad2'||ARR20{U8}_U8_'digest'|]
// file ../include/sheepdog_proto.h line 207
struct anonymous_0;

// tag-#anon#ST[U32'old_vid'||U32'new_vid'||U8'copies'||U8'set_bitmap'||U8'copy_policy'||U8'_pad0'|]
// file ../include/sheepdog_proto.h line 162
struct anonymous_15;

// tag-#anon#ST[U64'oid'||U64'cow_oid'||U8'copies'||U8'copy_policy'||U8'ec_index'||U8'reserved'||U32'tgt_epoch'||U32'offset'||U32'__pad'|]
// file ../include/sheepdog_proto.h line 132
struct anonymous_12;

// tag-#anon#ST[U64'oid'||U64'ctime'||U8'copies'||U8'copy_policy'||U16'flags'||U32'tag'|]
// file ../include/sheepdog_proto.h line 154
struct anonymous_14;

// tag-#anon#ST[U64'val'|]
// file ../include/util.h line 204
struct anonymous_6;

// tag-#anon#ST[U64'vdi_size'||U32'base_vdi_id'||U8'copies'||U8'copy_policy'||U8'store_policy'||U8'reserved'||U32'snapid'||U32'_pad0'|]
// file ../include/sheepdog_proto.h line 143
struct anonymous_13;

// tag-#anon#UN[*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'ifu_broadaddr'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'ifu_dstaddr'|]
// file /usr/include/ifaddrs.h line 38
union anonymous_22;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_24;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_23;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_33;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_8;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_10;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]#'__data'||ARR56{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous_5;

// tag-#anon#UN[SYM#tag-#anon#ST[U64'oid'||U64'cow_oid'||U8'copies'||U8'copy_policy'||U8'ec_index'||U8'reserved'||U32'tgt_epoch'||U32'offset'||U32'__pad'|]#'obj'||SYM#tag-#anon#ST[U64'vdi_size'||U32'base_vdi_id'||U8'copies'||U8'copy_policy'||U8'store_policy'||U8'reserved'||U32'snapid'||U32'_pad0'|]#'vdi'||SYM#tag-#anon#ST[U64'oid'||U64'ctime'||U8'copies'||U8'copy_policy'||U16'flags'||U32'tag'|]#'cluster'||SYM#tag-#anon#ST[U32'old_vid'||U32'new_vid'||U8'copies'||U8'set_bitmap'||U8'copy_policy'||U8'_pad0'|]#'vdi_state'||ARR8{U32}_U32_'__pad'|]
// file ../include/sheepdog_proto.h line 131
union anonymous_11;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_7;

// tag-#anon#UN[U32'result'||SYM#tag-#anon#ST[U32'__pad'||U8'copies'||ARR3{U8}_U8_'reserved'||U64'offset'|]#'obj'||SYM#tag-#anon#ST[U32'__pad'||U32'rsvd'||U32'vdi_id'||U32'attr_id'||U8'copies'||ARR3{U8}_U8_'reserved'|]#'vdi'||SYM#tag-#anon#ST[U32'__pad'||U32'nr_nodes'||ARR2{U32}_U32_'__reserved'||U64'store_size'||U64'store_free'|]#'node'||SYM#tag-#anon#ST[U32'__pad1'||U32'__pad2'||ARR20{U8}_U8_'digest'|]#'hash'||ARR8{U32}_U32_'__pad'|]
// file ../include/sheepdog_proto.h line 182
union anonymous_3;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_21;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_18;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__uatomic_dummy
// file /usr/include/urcu/uatomic.h line 37
struct __uatomic_dummy;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-btree_node_type
// file ../include/sheepdog_proto.h line 255
enum btree_node_type { BTREE_HEAD=1, BTREE_EXT=2, BTREE_IDX=3 };

// tag-buffer_s
// file http.c line 102
struct buffer_s;

// tag-connection
// file ../include/net.h line 28
struct connection;

// tag-curl_slist
// file /usr/include/curl/curl.h line 136
struct curl_slist;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-epoll_data
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 79
union epoll_data;

// tag-epoll_event
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 87
struct epoll_event;

// tag-event_info
// file ../include/event.h line 7
struct event_info;

// tag-fec
// file ../include/fec.h line 68
struct fec;

// tag-find_path
// file sd_inode.c line 98
struct find_path;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-fuse_args
// file /usr/include/fuse/fuse_opt.h line 108
struct fuse_args;

// tag-fuse_buf
// file /usr/include/fuse/fuse_common.h line 345
struct fuse_buf;

// tag-fuse_buf_flags
// file /usr/include/fuse/fuse_common.h line 269
enum fuse_buf_flags { FUSE_BUF_IS_FD=2, FUSE_BUF_FD_SEEK=4, FUSE_BUF_FD_RETRY=8 };

// tag-fuse_bufvec
// file /usr/include/fuse/fuse_common.h line 386
struct fuse_bufvec;

// tag-fuse_conn_info
// file /usr/include/fuse/fuse_common.h line 140
struct fuse_conn_info;

// tag-fuse_dirhandle
// file /usr/include/fuse/fuse.h line 62
struct fuse_dirhandle;

// tag-fuse_file_info
// file /usr/include/fuse/fuse_common.h line 45
struct fuse_file_info;

// tag-fuse_operations
// file /usr/include/fuse/fuse.h line 88
struct fuse_operations;

// tag-fuse_pollhandle
// file /usr/include/fuse/fuse_common.h line 194
struct fuse_pollhandle;

// tag-ifaddrs
// file /usr/include/ifaddrs.h line 29
struct ifaddrs;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-itimerspec
// file /usr/include/time.h line 161
struct itimerspec;

// tag-linger
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 379
struct linger;

// tag-list_head
// file ../include/list.h line 15
struct list_head;

// tag-list_node
// file ../include/list.h line 10
struct list_node;

// tag-log_dst_type
// file ../include/logger.h line 33
enum log_dst_type { LOG_DST_DEFAULT=0, LOG_DST_STDOUT=1, LOG_DST_SYSLOG=2 };

// tag-log_format
// file logger.c line 100
struct log_format;

// tag-logarea
// file logger.c line 75
struct logarea;

// tag-logger_user_info
// file ../include/logger.h line 27
struct logger_user_info;

// tag-logmsg
// file logger.c line 86
struct logmsg;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-node_id
// file ../include/internal_proto.h line 138
struct node_id;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-option_parser
// file ../include/option.h line 25
struct option_parser;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rb_node
// file ../include/rbtree.h line 7
struct rb_node;

// tag-rb_root
// file ../include/rbtree.h line 15
struct rb_root;

// tag-sd_cond
// file ../include/util.h line 344
struct sd_cond;

// tag-sd_extent
// file ../include/sheepdog_proto.h line 237
struct sd_extent;

// tag-sd_extent_header
// file ../include/sheepdog_proto.h line 249
struct sd_extent_header;

// tag-sd_extent_idx
// file ../include/sheepdog_proto.h line 242
struct sd_extent_idx;

// tag-sd_inode
// file ../include/sheepdog_proto.h line 217
struct sd_inode;

// tag-sd_mutex
// file ../include/util.h line 269
struct sd_mutex;

// tag-sd_node
// file ../include/internal_proto.h line 148
struct sd_node;

// tag-sd_option
// file ../include/option.h line 17
struct sd_option;

// tag-sd_req
// file ../include/sheepdog_proto.h line 124
struct sd_req;

// tag-sd_rsp
// file ../include/sheepdog_proto.h line 175
struct sd_rsp;

// tag-sd_rw_lock
// file ../include/util.h line 401
struct sd_rw_lock;

// tag-sembuf
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 41
struct sembuf;

// tag-semid_ds
// file /usr/include/x86_64-linux-gnu/bits/sem.h line 38
struct semid_ds;

// tag-seminfo
// file /usr/include/x86_64-linux-gnu/bits/sem.h line 72
struct seminfo;

// tag-semun
// file logger.c line 68
union semun;

// tag-sha1_ctx
// file ../include/sha1.h line 20
struct sha1_ctx;

// tag-sheepfs_file_operation
// file core.c line 55
struct sheepfs_file_operation;

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-sockfd
// file ../include/sockfd_cache.h line 7
struct sockfd;

// tag-sockfd_cache
// file sockfd_cache.c line 38
struct sockfd_cache;

// tag-sockfd_cache_entry
// file sockfd_cache.c line 69
struct sockfd_cache_entry;

// tag-sockfd_cache_fd
// file sockfd_cache.c line 64
struct sockfd_cache_fd;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-statvfs
// file /usr/include/x86_64-linux-gnu/bits/statvfs.h line 29
struct statvfs;

// tag-strbuf
// file ../include/strbuf.h line 12
struct strbuf;

// tag-timer
// file ../include/event.h line 19
struct timer;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-utimbuf
// file /usr/include/utime.h line 37
struct utimbuf;

// tag-vdi_inode
// file volume.c line 44
struct vdi_inode;

// tag-work
// file ../include/work.h line 9
struct work;

// tag-work_queue
// file ../include/work.h line 19
struct work_queue;

// tag-wq_info
// file work.c line 43
struct wq_info;

// tag-wq_thread_control
// file ../include/work.h line 24
enum wq_thread_control { WQ_ORDERED=0, WQ_DYNAMIC=1, WQ_UNLIMITED=2 };

#ifndef NULL
#define NULL ((void*)0)
#endif

// INIT_LIST_HEAD
// file ../include/list.h line 27
static inline void INIT_LIST_HEAD(struct list_head *list);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __list_add
// file ../include/list.h line 72
static inline void __list_add(struct list_node *new, struct list_node *prev, struct list_node *next);
// __list_del
// file ../include/list.h line 92
static inline void __list_del(struct list_node *prev, struct list_node *next);
// __list_splice
// file ../include/list.h line 122
static inline void __list_splice(struct list_head *list, struct list_node *prev, struct list_node *next);
// __rb_erase_color
// file rbtree.c line 124
static void __rb_erase_color(struct rb_node *node, struct rb_node *parent, struct rb_root *root);
// __rb_rotate_left
// file rbtree.c line 25
static void __rb_rotate_left(struct rb_node *node, struct rb_root *root);
// __rb_rotate_right
// file rbtree.c line 47
static void __rb_rotate_right(struct rb_node *node, struct rb_root *root);
// __sd_dump_variable
// file logger.c line 791
signed int __sd_dump_variable(const char *var);
// __uatomic_add_return
// file /usr/include/urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return(void *addr, unsigned long int val, signed int len);
// __uatomic_add_return_link1
// file /usr/include/urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return_link1(void *addr_link1, unsigned long int val_link1, signed int len_link1);
// __uatomic_cmpxchg
// file /usr/include/urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg(void *addr, unsigned long int old, unsigned long int _new, signed int len);
// __uatomic_cmpxchg_link1
// file /usr/include/urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg_link1(void *addr_link1, unsigned long int old_link1, unsigned long int _new_link1, signed int len_link1);
// __uatomic_dec
// file /usr/include/urcu/uatomic.h line 467
static inline void __uatomic_dec(void *addr, signed int len);
// __uatomic_inc
// file /usr/include/urcu/uatomic.h line 414
static inline void __uatomic_inc(void *addr, signed int len);
// _addmul1
// file fec.c line 216
static void _addmul1(unsigned char *dst, const unsigned char *src, unsigned char c, unsigned long int sz);
// _curl_easy_getinfo_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 201
static void _curl_easy_getinfo_err_curl_slist(void);
// _curl_easy_getinfo_err_double
// file /usr/include/curl/typecheck-gcc.h line 199
static void _curl_easy_getinfo_err_double(void);
// _curl_easy_getinfo_err_long
// file /usr/include/curl/typecheck-gcc.h line 197
static void _curl_easy_getinfo_err_long(void);
// _curl_easy_getinfo_err_string
// file /usr/include/curl/typecheck-gcc.h line 195
static void _curl_easy_getinfo_err_string(void);
// _curl_easy_setopt_err_CURLSH
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH(void);
// _curl_easy_setopt_err_FILE
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE(void);
// _curl_easy_setopt_err_cb_data
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data(void);
// _curl_easy_setopt_err_conv_cb
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb(void);
// _curl_easy_setopt_err_curl_httpost
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost(void);
// _curl_easy_setopt_err_curl_off_t
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t(void);
// _curl_easy_setopt_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist(void);
// _curl_easy_setopt_err_debug_cb
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb(void);
// _curl_easy_setopt_err_error_buffer
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer(void);
// _curl_easy_setopt_err_ioctl_cb
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb(void);
// _curl_easy_setopt_err_long
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long(void);
// _curl_easy_setopt_err_opensocket_cb
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb(void);
// _curl_easy_setopt_err_postfields
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields(void);
// _curl_easy_setopt_err_progress_cb
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb(void);
// _curl_easy_setopt_err_read_cb
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb(void);
// _curl_easy_setopt_err_seek_cb
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb(void);
// _curl_easy_setopt_err_sockopt_cb
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb(void);
// _curl_easy_setopt_err_ssl_ctx_cb
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb(void);
// _curl_easy_setopt_err_string
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string(void);
// _curl_easy_setopt_err_write_callback
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback(void);
// _init_mul_table
// file fec.c line 127
static void _init_mul_table(void);
// _invert_mat
// file fec.c line 278
static void _invert_mat(unsigned char *src, unsigned int d);
// _invert_vdm
// file fec.c line 386
static void _invert_vdm(unsigned char *src, unsigned int d);
// _matmul
// file fec.c line 255
static void _matmul(unsigned char *a, unsigned char *b, unsigned char *c, unsigned int dp, unsigned int d, unsigned int m);
// _pread
// file util.c line 168
static signed long int _pread(signed int fd, void *buf, unsigned long int len, signed long int offset);
// _pwrite
// file util.c line 179
static signed long int _pwrite(signed int fd, const void *buf, unsigned long int len, signed long int offset);
// _read
// file util.c line 106
static signed long int _read(signed int fd, void *buf, unsigned long int len);
// _write
// file util.c line 117
static signed long int _write(signed int fd, const void *buf, unsigned long int len);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// add_timer
// file event.c line 39
void add_timer(struct timer *t, unsigned int mseconds);
// addr_to_str
// file net.c line 365
const char * addr_to_str(const unsigned char *addr, unsigned short int port);
// atomic_create_and_write
// file util.c line 567
signed int atomic_create_and_write(const char *path, const char *buf, unsigned long int len, _Bool force_create);
// backtrace
// file /usr/include/execinfo.h line 27
extern signed int backtrace(void **, signed int);
// backtrace_symbols
// file /usr/include/execinfo.h line 32
extern char ** backtrace_symbols(void * const *, signed int);
// bg_printf
// file core.c line 104
static void bg_printf(const char *func, signed int line, const char *fmt, ...);
// binary_search
// file sd_inode.c line 222
static void * binary_search(void *first, void *last, void *key, unsigned long int obj_size, signed int (*cmp)(void *, void *));
// binary_search::cmp_object
//
signed int cmp_object(void *, void *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// block_sighup
// file logger.c line 130
static void block_sighup(void);
// build_decode_matrix_into_space
// file fec.c line 538
static void build_decode_matrix_into_space(struct fec * const code, const signed int * const idx, const unsigned int d, unsigned char * const matrix);
// build_long_options
// file option.c line 35
struct option * build_long_options(struct sd_option *sd_opts);
// build_short_options
// file option.c line 19
char * build_short_options(struct sd_option *sd_opts);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// check_gdb
// file logger.c line 753
static _Bool check_gdb(void);
// check_idx
// file sockfd_cache.c line 277
static inline void check_idx(signed int idx);
// chomp
// file ../include/util.h line 106
char * chomp(char *str);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// cluster_info_get_size
// file sheepfs.h line 72
unsigned long int cluster_info_get_size(const char *path);
// cluster_info_read
// file sheepfs.h line 71
signed int cluster_info_read(const char *path, char *buf, unsigned long int size, signed long int ignore);
// config_ocache_get_size
// file sheepfs.h line 99
unsigned long int config_ocache_get_size(const char *path);
// config_ocache_read
// file sheepfs.h line 97
signed int config_ocache_read(const char *path, char *buf, unsigned long int size, signed long int ignore);
// config_ocache_write
// file sheepfs.h line 98
signed int config_ocache_write(const char *path, const char *buf, unsigned long int size, signed long int ignore);
// config_pcache_get_size
// file sheepfs.h line 95
unsigned long int config_pcache_get_size(const char *path);
// config_pcache_read
// file sheepfs.h line 93
signed int config_pcache_read(const char *path, char *buf, unsigned long int size, signed long int ignore);
// config_pcache_write
// file sheepfs.h line 94
signed int config_pcache_write(const char *path, const char *buf, unsigned long int size, signed long int ignore);
// config_sheep_info_get_size
// file sheepfs.h line 103
unsigned long int config_sheep_info_get_size(const char *path);
// config_sheep_info_read
// file sheepfs.h line 101
signed int config_sheep_info_read(const char *path, char *buf, unsigned long int size, signed long int ignore);
// config_sheep_info_write
// file sheepfs.h line 102
signed int config_sheep_info_write(const char *path, const char *buf, unsigned long int size, signed long int ignore);
// conn_rx_off
// file net.c line 50
signed int conn_rx_off(struct connection *conn);
// conn_rx_on
// file net.c line 57
signed int conn_rx_on(struct connection *conn);
// conn_tx_off
// file net.c line 36
signed int conn_tx_off(struct connection *conn);
// conn_tx_on
// file net.c line 43
signed int conn_tx_on(struct connection *conn);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// connect_to
// file ../include/net.h line 46
signed int connect_to(const char *name, signed int port);
// connect_to_addr
// file ../include/net.h line 71
static inline signed int connect_to_addr(const unsigned char *addr, signed int port);
// container_rmdir
// file sheepfs.h line 122
signed int container_rmdir(const char *path);
// count_data_objs
// file ../include/sheepdog_proto.h line 411
static inline unsigned long int count_data_objs(struct sd_inode *inode);
// crash_handler
// file logger.c line 534
static void crash_handler(signed int signo);
// creat
// file /usr/include/fcntl.h line 195
extern signed int creat(const char *, unsigned int);
// create_cluster_layout
// file sheepfs.h line 73
signed int create_cluster_layout(void);
// create_config_layout
// file sheepfs.h line 91
signed int create_config_layout(void);
// create_http_layout
// file sheepfs.h line 107
signed int create_http_layout(void);
// create_listen_ports
// file net.c line 64
signed int create_listen_ports(const char *bindaddr, signed int port, signed int (*callback)(signed int, void *), void *data);

//

// create_node_layout
// file sheepfs.h line 88
signed int create_node_layout(void);
// create_ordered_work_queue
// file work.c line 440
struct work_queue * create_ordered_work_queue(const char *name);
// create_sheepfs_layout
// file core.c line 314
static signed int create_sheepfs_layout(void);
// create_unix_domain_socket
// file net.c line 536
signed int create_unix_domain_socket(const char *unix_path, signed int (*callback)(signed int, void *), void *data);

//

// create_vdi_layout
// file sheepfs.h line 76
signed int create_vdi_layout(void);
// create_volume_layout
// file sheepfs.h line 60
signed int create_volume_layout(void);
// create_work_queue
// file work.c line 404
struct work_queue * create_work_queue(const char *name, enum wq_thread_control tc);
// create_worker_threads
// file work.c line 249
static signed int create_worker_threads(struct wq_info *wi, unsigned long int nr_threads);
// curl_easy_cleanup
// file /usr/include/curl/easy.h line 31
void curl_easy_cleanup(void *);
// curl_easy_getinfo
// file /usr/include/curl/easy.h line 46
enum anonymous_19 curl_easy_getinfo(void *, enum anonymous_17, ...);
// curl_easy_init
// file /usr/include/curl/easy.h line 28
void * curl_easy_init(void);
// curl_easy_perform
// file /usr/include/curl/easy.h line 30
enum anonymous_19 curl_easy_perform(void *);
// curl_easy_setopt
// file /usr/include/curl/easy.h line 29
enum anonymous_19 curl_easy_setopt(void *, enum anonymous_20, ...);
// curl_easy_strerror
// file /usr/include/curl/curl.h line 2356
const char * curl_easy_strerror(enum anonymous_19);
// curl_get_object_size
// file http.c line 71
static unsigned long int curl_get_object_size(const char *url);
// curl_object_exists
// file http.c line 175
static _Bool curl_object_exists(const char *url);
// curl_read_object
// file http.c line 120
static unsigned long int curl_read_object(const char *url, char *buf, unsigned long int size, signed long int offset);
// curl_slist_append
// file /usr/include/curl/curl.h line 2062
struct curl_slist * curl_slist_append(struct curl_slist *, const char *);
// curl_slist_free_all
// file /usr/include/curl/curl.h line 2072
void curl_slist_free_all(struct curl_slist *);
// data_is_missing
// file fec.c line 618
static inline _Bool data_is_missing(const unsigned char **dp, signed int d);
// data_oid_to_idx
// file ../include/sheepdog_proto.h line 430
static inline unsigned long int data_oid_to_idx(unsigned long int oid);
// data_to_str
// file util.c line 417
const char * data_to_str(void *data, unsigned long int data_length);
// decode_prepare
// file fec.c line 591
static inline void decode_prepare(struct fec *ctx, const unsigned char **dp, const unsigned char **out, signed int *outidx);
// destroy_all_slots
// file sockfd_cache.c line 141
static inline void destroy_all_slots(struct sockfd_cache_entry *entry);
// destroy_socket_pool
// file volume.c line 366
static void destroy_socket_pool(signed int *array, signed int len);
// dirname
// file /usr/include/libgen.h line 26
extern char * dirname(char *);
// do_event_loop
// file event.c line 190
static void do_event_loop(signed int timeout, _Bool sort_with_prio);
// do_grow_fds
// file sockfd_cache.c line 247
static void do_grow_fds(struct work *work);
// do_nothing
// file util.c line 28
static void do_nothing(unsigned long int size);
// do_read
// file net.c line 213
signed int do_read(signed int sockfd, void *buf, signed int len, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count);
// do_read::need_retry_object
//
_Bool need_retry_object(unsigned int);
// do_write
// file net.c line 261
static signed int do_write(signed int sockfd, struct msghdr *msg, signed int len, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count);
// do_write::need_retry_object
//
_Bool need_retry_object(unsigned int);
// do_writev2
// file net.c line 587
signed int do_writev2(signed int fd, void *hdr, unsigned long int hdr_len, void *body, unsigned long int body_len);
// dolog
// file logger.c line 395
static void dolog(signed int prio, const char *func, signed int line, const char *fmt, void **ap);
// dump_btree
// file sd_inode.c line 209
static void dump_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode);
// dump_btree::reader_object
//
signed int reader_object(unsigned long int, void **, unsigned int, unsigned long int);
// dump_stack_frames
// file logger.c line 800
static signed int dump_stack_frames(void);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// early_log_init
// file logger.c line 634
void early_log_init(const char *format_name, struct logger_user_info *user_info);
// ec_decode
// file fec.c line 635
void ec_decode(struct fec *ctx, const unsigned char **input, const signed int *inidx, unsigned char *output, signed int idx);
// ec_decode_buffer
// file fec.c line 690
void ec_decode_buffer(struct fec *ctx, unsigned char **input, const signed int *in_idx, char *buf, signed int idx);
// ec_encode
// file ../include/fec.h line 169
static inline void ec_encode(struct fec *ctx, const unsigned char **ds, unsigned char **ps);
// epoll_create
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 100
extern signed int epoll_create(signed int);
// epoll_ctl
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 113
extern signed int epoll_ctl(signed int, signed int, signed int, struct epoll_event *);
// epoll_event_cmp
// file event.c line 179
static signed int epoll_event_cmp(struct epoll_event *_a, struct epoll_event *_b);
// epoll_wait
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 127
extern signed int epoll_wait(signed int, struct epoll_event *, signed int, signed int);
// event_cmp
// file event.c line 74
static signed int event_cmp(struct event_info *e1, struct event_info *e2);
// event_force_refresh
// file event.c line 174
void event_force_refresh(void);
// event_loop
// file event.c line 218
void event_loop(signed int timeout);
// event_loop_prio
// file event.c line 223
void event_loop_prio(signed int timeout);
// eventfd
// file /usr/include/x86_64-linux-gnu/sys/eventfd.h line 34
extern signed int eventfd(unsigned int, signed int);
// eventfd_read
// file /usr/include/x86_64-linux-gnu/sys/eventfd.h line 37
extern signed int eventfd_read(signed int, unsigned long int *);
// eventfd_write
// file /usr/include/x86_64-linux-gnu/sys/eventfd.h line 40
extern signed int eventfd_write(signed int, unsigned long int);
// eventfd_xread
// file util.c line 279
signed int eventfd_xread(signed int efd);
// eventfd_xwrite
// file util.c line 296
void eventfd_xwrite(signed int efd, signed int value);
// exec_req
// file ../include/net.h line 49
signed int exec_req(signed int sockfd, struct sd_req *hdr, void *data, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count);
// exec_req::need_retry_object
//
_Bool need_retry_object(unsigned int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// ext_in_range
// file sd_inode.c line 252
static _Bool ext_in_range(struct sd_extent_header *header, struct sd_extent *ext);
// extent_comp
// file sd_inode.c line 108
static signed int extent_comp(void *a, void *b);
// fallocate
// file /usr/include/x86_64-linux-gnu/bits/fcntl-linux.h line 407
extern signed int fallocate(signed int, signed int, signed long int, signed long int);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fec_decode
// file fec.c line 555
void fec_decode(struct fec *code, const unsigned char * const * const inpkts, unsigned char * const * const outpkts, const signed int * const idx, unsigned long int sz);
// fec_encode
// file fec.c line 508
void fec_encode(struct fec *code, const unsigned char * const * const src, unsigned char * const * const fecs, const signed int * const block_nums, unsigned long int num_block_nums, unsigned long int sz);
// fec_free
// file fec.c line 452
void fec_free(struct fec *p);
// fec_new
// file fec.c line 460
struct fec * fec_new(unsigned short int d, unsigned short int dp);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fg_printf
// file core.c line 93
static void fg_printf(const char *func, signed int line, const char *fmt, ...);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// format_thread_name
// file logger.c line 156
static const char * format_thread_name(char *str, unsigned long int size, const char *name, signed int idx);
// forward_iov
// file net.c line 248
static void forward_iov(struct msghdr *msg, signed int len);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_cache_entry
// file sockfd_cache.c line 149
static void free_cache_entry(struct sockfd_cache_entry *entry);
// free_logarea
// file logger.c line 350
static void free_logarea(void);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// freeifaddrs
// file /usr/include/ifaddrs.h line 69
extern void freeifaddrs(struct ifaddrs *);

//

// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// fuse_main_real
// file /usr/include/fuse/fuse.h line 766
signed int fuse_main_real(signed int, char **, struct fuse_operations *, unsigned long int, void *);
// fuse_opt_add_arg
// file /usr/include/fuse/fuse_opt.h line 230
signed int fuse_opt_add_arg(struct fuse_args *, const char *);
// gdb_cmd
// file logger.c line 760
static signed int gdb_cmd(const char *cmd);
// generate_gf
// file fec.c line 143
static void generate_gf(void);
// generate_url
// file http.c line 209
static signed int generate_url(const char *buff, signed int size, char *url, signed int url_len);
// get_buffer_sha1
// file sha1.c line 337
void get_buffer_sha1(unsigned char *buf, unsigned int len, unsigned char *sha1);
// get_current_dir_name
// file /usr/include/unistd.h line 517
extern char * get_current_dir_name(void);
// get_free_slot
// file sockfd_cache.c line 94
static inline signed int get_free_slot(struct sockfd_cache_entry *entry);
// get_local_addr
// file net.c line 493
signed int get_local_addr(unsigned char *bytes);
// get_loglevel
// file logger.c line 861
signed int get_loglevel(void);
// get_msec_time
// file work.c line 194
static unsigned long int get_msec_time(void);
// get_socket_fd
// file volume.c line 112
static inline signed int get_socket_fd(struct vdi_inode *vdi, signed int *idx);
// get_thread_name
// file logger.c line 745
void get_thread_name(char *name);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getifaddrs
// file /usr/include/ifaddrs.h line 66
extern signed int getifaddrs(struct ifaddrs **);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getppid
// file /usr/include/unistd.h line 631
extern signed int getppid(void);
// gettid
// file ../include/util.h line 114
signed int gettid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getxattr
// file /usr/include/x86_64-linux-gnu/sys/xattr.h line 59
extern signed long int getxattr(const char *, const char *, void *, unsigned long int);
// grow_fds_done
// file sockfd_cache.c line 270
static void grow_fds_done(struct work *work);
// http_address_get_size
// file sheepfs.h line 115
unsigned long int http_address_get_size(const char *path);
// http_address_read
// file sheepfs.h line 112
signed int http_address_read(const char *path, char *buf, unsigned long int size, signed long int ignore);
// http_address_write
// file sheepfs.h line 113
signed int http_address_write(const char *path, const char *buf, unsigned long int size, signed long int ignore);
// http_object_write
// file sheepfs.h line 116
signed int http_object_write(const char *path, const char *buf, unsigned long int size, signed long int ignore);
// idx_in_range
// file sd_inode.c line 261
static _Bool idx_in_range(struct sd_extent_header *header, struct sd_extent_idx *idx);
// index_comp
// file sd_inode.c line 122
static signed int index_comp(void *a, void *b);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// inetaddr_is_valid
// file net.c line 574
_Bool inetaddr_is_valid(char *addr);
// init_event
// file event.c line 79
signed int init_event(signed int nr);
// init_fec
// file fec.c line 438
void init_fec(void);
// init_logmsg
// file logger.c line 381
static void init_logmsg(struct logmsg *msg, struct timeval *tv, signed int prio, const char *func, signed int line);
// init_vdi_info
// file volume.c line 417
static signed int init_vdi_info(const char *entry, unsigned int *vid, unsigned long int *size);
// init_work_queue
// file work.c line 364
signed int init_work_queue(unsigned long int (*get_nr_nodes)(void));
// init_work_queue::get_nr_nodes_object
//
unsigned long int get_nr_nodes_object(void);
// insert_ext_entry_nosearch
// file sd_inode.c line 290
static void insert_ext_entry_nosearch(struct sd_extent_header *header, struct sd_extent *ext, unsigned int idx, unsigned int vdi_id);
// insert_idx_entry
// file sd_inode.c line 314
static void insert_idx_entry(struct sd_extent_header *header, unsigned int idx, unsigned long int oid);
// insert_idx_entry_nosearch
// file sd_inode.c line 302
static void insert_idx_entry_nosearch(struct sd_extent_header *header, struct sd_extent_idx *idx_ext, unsigned int idx, unsigned long int oid);
// insert_new_node
// file sd_inode.c line 499
static signed int insert_new_node(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, struct find_path *path, unsigned int idx, unsigned int vdi_id);
// insert_new_node::reader_object
//
signed int reader_object(unsigned long int, void **, unsigned int, unsigned long int);
// insert_new_node::writer_object
//
signed int writer_object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// install_crash_handler
// file ../include/util.h line 112
signed int install_crash_handler(void (*handler)(signed int));

//

// install_sighandler
// file ../include/util.h line 111
signed int install_sighandler(signed int signum, void (*handler)(signed int), _Bool once);

//

// is_data_obj
// file ../include/sheepdog_proto.h line 405
static inline _Bool is_data_obj(unsigned long int oid);
// is_data_obj_writeable
// file volume.c line 81
static inline _Bool is_data_obj_writeable(struct sd_inode *inode, unsigned int idx);
// is_numeric
// file util.c line 399
_Bool is_numeric(const char *s);
// is_sheep_dead
// file logger.c line 529
static _Bool is_sheep_dead(signed int signo);
// is_stdout_console
// file ../include/util.h line 493
static inline _Bool is_stdout_console(void);
// is_vdi_attr_obj
// file ../include/sheepdog_proto.h line 395
static inline _Bool is_vdi_attr_obj(unsigned long int oid);
// is_vdi_btree_obj
// file ../include/sheepdog_proto.h line 400
static inline _Bool is_vdi_btree_obj(unsigned long int oid);
// is_vdi_obj
// file ../include/sheepdog_proto.h line 385
static inline _Bool is_vdi_obj(unsigned long int oid);
// is_vmstate_obj
// file ../include/sheepdog_proto.h line 390
static inline _Bool is_vmstate_obj(unsigned long int oid);
// is_xattr_enabled
// file ../include/util.h line 116
_Bool is_xattr_enabled(const char *path);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// list_add
// file ../include/list.h line 82
static inline void list_add(struct list_node *new, struct list_head *head);
// list_add_tail
// file ../include/list.h line 87
static inline void list_add_tail(struct list_node *new, struct list_head *head);
// list_del
// file ../include/list.h line 103
static inline void list_del(struct list_node *entry);
// list_empty
// file ../include/list.h line 42
static inline _Bool list_empty(struct list_head *head);
// list_empty_link1
// file ../include/list.h line 42
static inline _Bool list_empty_link1(struct list_head *head_link1);
// list_sort
// file util.c line 700
void list_sort(void *priv, struct list_head *head, signed int (*cmp)(void *, struct list_node *, struct list_node *));
// list_sort::cmp_object
//
signed int cmp_object(void *, struct list_node *, struct list_node *);
// list_splice_init
// file ../include/list.h line 136
static inline void list_splice_init(struct list_head *list, struct list_head *head);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// log_close
// file logger.c line 712
void log_close(void);
// log_flush
// file logger.c line 494
static void log_flush(void);
// log_init
// file logger.c line 656
signed int log_init(const char *program_name, enum log_dst_type type, signed int level, char *outfile);
// log_syslog
// file logger.c line 360
static void log_syslog(struct logmsg *msg);
// log_write
// file ../include/logger.h line 45
void log_write(signed int prio, const char *func, signed int line, const char *fmt, ...);
// logarea_init
// file logger.c line 289
static signed int logarea_init(signed int size);
// logger
// file logger.c line 560
static void logger(char *log_dir, char *outfile);
// lookup_event
// file event.c line 92
static struct event_info * lookup_event(signed int fd);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// make_path
// file util.c line 554
void make_path(char *path, unsigned long int size, unsigned long int nr_segs, const char **segs);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// mempcpy
// file /usr/include/string.h line 390
extern void * mempcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// merge
// file util.c line 616
static struct list_node * merge(void *priv, signed int (*cmp)(void *, struct list_node *, struct list_node *), struct list_node *a, struct list_node *b);
// merge::cmp_object
//
signed int cmp_object(void *, struct list_node *, struct list_node *);
// merge_and_restore_back_links
// file util.c line 646
static void merge_and_restore_back_links(void *priv, signed int (*cmp)(void *, struct list_node *, struct list_node *), struct list_head *head, struct list_node *a, struct list_node *b);
// merge_and_restore_back_links::cmp_object
//
signed int cmp_object(void *, struct list_node *, struct list_node *);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// modify_event
// file event.c line 148
signed int modify_event(signed int fd, unsigned int new_events);
// modnn
// file fec.c line 89
static unsigned char modnn(signed int x);
// my_exe_path
// file ../include/util.h line 117
const char * my_exe_path(void);
// node_id_cmp
// file ../include/sheep.h line 186
static inline signed int node_id_cmp(struct node_id *node1, struct node_id *node2);
// node_info_get_size
// file sheepfs.h line 87
unsigned long int node_info_get_size(const char *path);
// node_info_read
// file sheepfs.h line 86
signed int node_info_read(const char *path, char *buf, unsigned long int size, signed long int ignore);
// node_list_get_size
// file sheepfs.h line 85
unsigned long int node_list_get_size(const char *path);
// node_list_read
// file sheepfs.h line 84
signed int node_list_read(const char *path, char *buf, unsigned long int size, signed long int ignore);
// object_create_entry
// file http.c line 276
static signed int object_create_entry(const char *entry, const char *url);
// object_get_size
// file sheepfs.h line 120
unsigned long int object_get_size(const char *path);
// object_read
// file sheepfs.h line 119
signed int object_read(const char *path, char *buf, unsigned long int size, signed long int offset);
// object_unlink
// file sheepfs.h line 121
signed int object_unlink(const char *path);
// oid_to_vid
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid(unsigned long int oid);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// option_get_help
// file option.c line 53
const char * option_get_help(struct sd_option *sd_opts, signed int ch);
// option_parse
// file option.c line 104
signed int option_parse(char *arg, const char *delim, struct option_parser *parsers);
// option_parse_size
// file option.c line 64
signed int option_parse_size(const char *value, unsigned long int *ret);
// pclose
// file /usr/include/stdio.h line 878
extern signed int pclose(struct _IO_FILE *);
// popen
// file /usr/include/stdio.h line 872
extern struct _IO_FILE * popen(const char *, const char *);
// pread
// file /usr/include/unistd.h line 376
extern signed long int pread(signed int, void *, unsigned long int, signed long int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pstrcpy
// file ../include/util.h line 105
void pstrcpy(char *buf, signed int buf_size, const char *str);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_10 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_10 *, const union anonymous_8 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_10 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_10 *, union anonymous_7 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_7 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_7 *, const union anonymous_8 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_7 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_7 *);
// pthread_rwlock_rdlock
// file /usr/include/pthread.h line 899
extern signed int pthread_rwlock_rdlock(union anonymous_5 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 929
extern signed int pthread_rwlock_unlock(union anonymous_5 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 914
extern signed int pthread_rwlock_wrlock(union anonymous_5 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// purge_directory
// file util.c line 346
signed int purge_directory(const char *dir_path);
// put_socket_fd
// file volume.c line 128
static inline void put_socket_fd(struct vdi_inode *vdi, signed int idx);
// pwrite
// file /usr/include/unistd.h line 384
extern signed long int pwrite(signed int, const void *, unsigned long int, signed long int);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// queue_work
// file work.c line 270
void queue_work(struct work_queue *q, struct work *work);
// raise
// file /usr/include/signal.h line 139
extern signed int raise(signed int);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// rb_erase
// file ../include/rbtree.h line 57
void rb_erase(struct rb_node *node, struct rb_root *root);
// rb_first
// file ../include/rbtree.h line 62
struct rb_node * rb_first(struct rb_root *root);
// rb_insert_color
// file ../include/rbtree.h line 56
void rb_insert_color(struct rb_node *node, struct rb_root *root);
// rb_last
// file rbtree.c line 267
struct rb_node * rb_last(struct rb_root *root);
// rb_link_node
// file ../include/rbtree.h line 69
static inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link);
// rb_link_node_link1
// file ../include/rbtree.h line 69
static inline void rb_link_node_link1(struct rb_node *node_link1, struct rb_node *parent_link1, struct rb_node **rb_link_link1);
// rb_link_node_link2
// file ../include/rbtree.h line 69
static inline void rb_link_node_link2(struct rb_node *node_link2, struct rb_node *parent_link2, struct rb_node **rb_link_link2);
// rb_next
// file ../include/rbtree.h line 60
struct rb_node * rb_next(struct rb_node *node);
// rb_prev
// file rbtree.c line 311
struct rb_node * rb_prev(struct rb_node *node);
// rb_replace_node
// file rbtree.c line 339
void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root);
// rb_set_color
// file ../include/rbtree.h line 31
static inline void rb_set_color(struct rb_node *rb, signed int color);
// rb_set_parent
// file ../include/rbtree.h line 27
static inline void rb_set_parent(struct rb_node *rb, struct rb_node *p);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readdir
// file /usr/include/dirent.h line 165
extern struct dirent * readdir(struct __dirstream *);
// readlink
// file /usr/include/unistd.h line 809
extern signed long int readlink(const char *, char *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// register_event
// file ../include/event.h line 30
static inline signed int register_event(signed int fd, void (*h)(signed int, signed int, void *), void *data);
// register_event_link1
// file ../include/event.h line 30
static inline signed int register_event_link1(signed int fd_link1, void (*h_link1)(signed int, signed int, void *), void *data_link1);
// register_event::h_link1_object
//
void h_link1_object(signed int, signed int, void *);
// register_event::h_object
//
void h_object(signed int, signed int, void *);
// register_event_prio
// file event.c line 99
signed int register_event_prio(signed int fd, void (*h)(signed int, signed int, void *), void *data, signed int prio);
// register_event_prio::h_object
//
void h_object(signed int, signed int, void *);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// reraise_crash_signal
// file ../include/util.h line 113
void reraise_crash_signal(signed int signo, signed int status);
// reset_socket_pool
// file volume.c line 398
signed int reset_socket_pool(void);
// revalidate_node
// file sockfd_cache.c line 293
static inline signed int revalidate_node(struct node_id *nid);
// rmdir
// file /usr/include/unistd.h line 835
extern signed int rmdir(const char *);
// rmdir_r
// file ../include/util.h line 107
signed int rmdir_r(const char *dir_path);
// rotate_log
// file logger.c line 453
static void rotate_log(void);
// sd_backtrace
// file logger.c line 806
void sd_backtrace(void);
// sd_cond_init
// file ../include/util.h line 348
static inline void sd_cond_init(struct sd_cond *cond);
// sd_cond_signal
// file ../include/util.h line 373
static inline signed int sd_cond_signal(struct sd_cond *cond);
// sd_cond_wait
// file ../include/util.h line 378
static inline signed int sd_cond_wait(struct sd_cond *cond, struct sd_mutex *mutex);
// sd_destroy_cond
// file ../include/util.h line 361
static inline void sd_destroy_cond(struct sd_cond *cond);
// sd_destroy_mutex
// file ../include/util.h line 299
static inline void sd_destroy_mutex(struct sd_mutex *mutex);
// sd_init_mutex
// file ../include/util.h line 273
static inline void sd_init_mutex(struct sd_mutex *mutex);
// sd_inode_copy_vdis
// file sd_inode.c line 700
extern void sd_inode_copy_vdis(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), unsigned int *data_vdi_id, unsigned char store_policy, unsigned char nr_copies, unsigned char copy_policy, struct sd_inode *newi);
// sd_inode_copy_vdis::reader_object
//
signed int reader_object(unsigned long int, void **, unsigned int, unsigned long int);
// sd_inode_copy_vdis::writer_object
//
signed int writer_object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// sd_inode_get_meta_size
// file sd_inode.c line 626
extern unsigned int sd_inode_get_meta_size(struct sd_inode *inode, unsigned long int size);
// sd_inode_get_vid
// file ../include/sheepdog_proto.h line 278
extern unsigned int sd_inode_get_vid(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx);
// sd_inode_get_vid::reader_object
//
signed int reader_object(unsigned long int, void **, unsigned int, unsigned long int);
// sd_inode_init
// file sd_inode.c line 243
extern void sd_inode_init(void *data, signed int depth);
// sd_inode_set_vid
// file ../include/sheepdog_proto.h line 280
extern void sd_inode_set_vid(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx, unsigned int vdi_id);
// sd_inode_set_vid::reader_object
//
signed int reader_object(unsigned long int, void **, unsigned int, unsigned long int);
// sd_inode_set_vid::writer_object
//
signed int writer_object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// sd_inode_write
// file sd_inode.c line 650
extern signed int sd_inode_write(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, signed int flags, _Bool create, _Bool direct);
// sd_inode_write::writer_object
//
signed int writer_object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// sd_inode_write_vid
// file ../include/sheepdog_proto.h line 285
extern signed int sd_inode_write_vid(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, unsigned int idx, unsigned int vid, unsigned int value, signed int flags, _Bool create, _Bool direct);
// sd_inode_write_vid::writer_object
//
signed int writer_object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// sd_mutex_lock
// file ../include/util.h line 311
static inline void sd_mutex_lock(struct sd_mutex *mutex);
// sd_mutex_unlock
// file ../include/util.h line 328
static inline void sd_mutex_unlock(struct sd_mutex *mutex);
// sd_read_lock
// file ../include/util.h line 429
static inline void sd_read_lock(struct sd_rw_lock *lock);
// sd_read_lock_link1
// file ../include/util.h line 429
static inline void sd_read_lock_link1(struct sd_rw_lock *lock_link1);
// sd_rw_unlock
// file ../include/util.h line 457
static inline void sd_rw_unlock(struct sd_rw_lock *lock);
// sd_rw_unlock_link1
// file ../include/util.h line 457
static inline void sd_rw_unlock_link1(struct sd_rw_lock *lock_link1);
// sd_strerror
// file ../include/sheep.h line 119
static inline const char * sd_strerror(signed int err);
// sd_write_lock
// file ../include/util.h line 445
static inline void sd_write_lock(struct sd_rw_lock *lock);
// sd_write_lock_link1
// file ../include/util.h line 445
static inline void sd_write_lock_link1(struct sd_rw_lock *lock_link1);
// search_ext_entry
// file sd_inode.c line 271
static struct sd_extent * search_ext_entry(struct sd_extent_header *header, unsigned int idx);
// search_idx_entry
// file sd_inode.c line 281
static struct sd_extent_idx * search_idx_entry(struct sd_extent_header *header, unsigned int idx);
// search_whole_btree
// file sd_inode.c line 392
static signed int search_whole_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx, struct find_path *path);
// search_whole_btree::reader_object
//
signed int reader_object(unsigned long int, void **, unsigned int, unsigned long int);
// semctl
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 52
extern signed int semctl(signed int, signed int, signed int, ...);
// semget
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 55
extern signed int semget(signed int, signed int, signed int);
// semop
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 58
extern signed int semop(signed int, struct sembuf *, unsigned long int);
// send_req
// file net.c line 294
signed int send_req(signed int sockfd, struct sd_req *hdr, void *data, unsigned int wlen, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count);
// send_req::need_retry_object
//
_Bool need_retry_object(unsigned int);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// set_keepalive
// file net.c line 467
signed int set_keepalive(signed int fd);
// set_loglevel
// file logger.c line 855
void set_loglevel(signed int new_loglevel);
// set_nodelay
// file ../include/net.h line 59
signed int set_nodelay(signed int fd);
// set_rcv_timeout
// file net.c line 438
signed int set_rcv_timeout(signed int fd);
// set_snd_timeout
// file net.c line 427
signed int set_snd_timeout(signed int fd);
// set_thread_name
// file logger.c line 738
void set_thread_name(const char *name, _Bool show_idx);
// set_try_to_free_routine
// file util.c line 34
void (*set_try_to_free_routine(void (*routine)(unsigned long int)))(unsigned long int);
// set_try_to_free_routine::1::old_object
//
void old_object(unsigned long int);
// set_try_to_free_routine::routine_object
//
void routine_object(unsigned long int);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setup_socket_pool
// file volume.c line 373
static signed int setup_socket_pool(signed int *array, signed int len);
// setxattr
// file /usr/include/x86_64-linux-gnu/sys/xattr.h line 41
extern signed int setxattr(const char *, const char *, const void *, unsigned long int, signed int);
// sha1_final_object
//
void sha1_final_object(void *, unsigned char *);
// sha1_init_object
//
void sha1_init_object(void *);
// sha1_to_hex
// file sha1.c line 322
const char * sha1_to_hex(const unsigned char *sha1);
// sha1_update_object
//
void sha1_update_object(void *, const unsigned char *, unsigned int);
// shadow_dir_create
// file sheepfs.h line 48
signed int shadow_dir_create(const char *path);
// shadow_dir_delete
// file shadow_file.c line 95
signed int shadow_dir_delete(const char *path);
// shadow_file_create
// file sheepfs.h line 50
signed int shadow_file_create(const char *path);
// shadow_file_delete
// file sheepfs.h line 55
signed int shadow_file_delete(const char *path);
// shadow_file_exsit
// file shadow_file.c line 147
_Bool shadow_file_exsit(const char *path);
// shadow_file_getxattr
// file sheepfs.h line 53
signed int shadow_file_getxattr(const char *path, const char *name, void *value, unsigned long int size);
// shadow_file_read
// file sheepfs.h line 47
signed int shadow_file_read(const char *path, char *buf, unsigned long int size, signed long int offset);
// shadow_file_setxattr
// file sheepfs.h line 51
signed int shadow_file_setxattr(const char *path, const char *name, const void *value, unsigned long int size);
// shadow_file_stat
// file shadow_file.c line 161
_Bool shadow_file_stat(const char *path, struct stat *st);
// shadow_file_write
// file sheepfs.h line 46
unsigned long int shadow_file_write(const char *path, const char *buf, unsigned long int size);
// sheepfs_bnode_reader
// file volume.c line 274
static signed int sheepfs_bnode_reader(unsigned long int oid, void **mem, unsigned int len, unsigned long int offset);
// sheepfs_bnode_writer
// file volume.c line 263
static signed int sheepfs_bnode_writer(unsigned long int oid, void *mem, unsigned int len, unsigned long int offset, unsigned int flags, signed int copies, signed int copy_policy, _Bool create, _Bool direct);
// sheepfs_fsync
// file core.c line 254
static signed int sheepfs_fsync(const char *path, signed int datasync, struct fuse_file_info *fi);
// sheepfs_get_op
// file core.c line 125
static unsigned int sheepfs_get_op(const char *path);
// sheepfs_get_size
// file core.c line 135
static unsigned long int sheepfs_get_size(const char *path);
// sheepfs_getattr
// file core.c line 145
static signed int sheepfs_getattr(const char *path, struct stat *st);
// sheepfs_main_loop
// file core.c line 289
static signed int sheepfs_main_loop(char *mountpoint);
// sheepfs_open
// file core.c line 266
static signed int sheepfs_open(const char *path, struct fuse_file_info *fi);
// sheepfs_read
// file core.c line 214
static signed int sheepfs_read(const char *path, char *buf, unsigned long int size, signed long int offset, struct fuse_file_info *fi);
// sheepfs_readdir
// file core.c line 185
static signed int sheepfs_readdir(const char *path, void *buf, signed int (*filler)(void *, const char *, struct stat *, signed long int), signed long int offset, struct fuse_file_info *fi);
// sheepfs_readdir::filler_object
//
signed int filler_object(void *, const char *, struct stat *, signed long int);
// sheepfs_rmdir
// file core.c line 174
static signed int sheepfs_rmdir(const char *path);
// sheepfs_run_cmd
// file core.c line 431
struct strbuf * sheepfs_run_cmd(const char *command);
// sheepfs_set_op
// file core.c line 116
signed int sheepfs_set_op(const char *path, unsigned int opcode);
// sheepfs_truncate
// file core.c line 238
static signed int sheepfs_truncate(const char *path, signed long int size);
// sheepfs_unlink
// file core.c line 163
static signed int sheepfs_unlink(const char *path);
// sheepfs_write
// file core.c line 226
static signed int sheepfs_write(const char *path, const char *buf, unsigned long int size, signed long int offset, struct fuse_file_info *fi);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_16 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_16 *);
// sighup_handler
// file logger.c line 555
static void sighup_handler(signed int signo);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous_16 *, struct anonymous_16 *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// slots_all_free
// file sockfd_cache.c line 132
static inline _Bool slots_all_free(struct sockfd_cache_entry *entry);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sockaddr_in_to_str
// file net.c line 394
char * sockaddr_in_to_str(struct sockaddr_in *sockaddr);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sockfd_cache_add
// file sockfd_cache.c line 220
void sockfd_cache_add(struct node_id *nid);
// sockfd_cache_add_group
// file sockfd_cache.c line 208
void sockfd_cache_add_group(struct rb_root *nroot);
// sockfd_cache_add_nolock
// file sockfd_cache.c line 190
static void sockfd_cache_add_nolock(struct node_id *nid);
// sockfd_cache_close
// file sockfd_cache.c line 381
static void sockfd_cache_close(struct node_id *nid, signed int idx);
// sockfd_cache_cmp
// file sockfd_cache.c line 75
static signed int sockfd_cache_cmp(struct sockfd_cache_entry *a, struct sockfd_cache_entry *b);
// sockfd_cache_del
// file sockfd_cache.c line 485
void sockfd_cache_del(struct node_id *nid, struct sockfd *sfd);
// sockfd_cache_del_node
// file sockfd_cache.c line 467
void sockfd_cache_del_node(struct node_id *nid);
// sockfd_cache_destroy
// file sockfd_cache.c line 162
static _Bool sockfd_cache_destroy(struct node_id *nid);
// sockfd_cache_get
// file sockfd_cache.c line 425
struct sockfd * sockfd_cache_get(struct node_id *nid);
// sockfd_cache_get_long
// file sockfd_cache.c line 313
static struct sockfd * sockfd_cache_get_long(struct node_id *nid);
// sockfd_cache_grab
// file sockfd_cache.c line 112
static struct sockfd_cache_entry * sockfd_cache_grab(struct node_id *nid, signed int *ret_idx);
// sockfd_cache_insert
// file sockfd_cache.c line 82
static struct sockfd_cache_entry * sockfd_cache_insert(struct sockfd_cache_entry *new);
// sockfd_cache_put
// file sockfd_cache.c line 453
void sockfd_cache_put(struct node_id *nid, struct sockfd *sfd);
// sockfd_cache_put_long
// file sockfd_cache.c line 365
static void sockfd_cache_put_long(struct node_id *nid, signed int idx);
// sockfd_cache_search
// file sockfd_cache.c line 87
static struct sockfd_cache_entry * sockfd_cache_search(struct node_id *nid);
// sockfd_init
// file sockfd_cache.c line 404
signed int sockfd_init(void);
// split_ext_node
// file sd_inode.c line 471
static void split_ext_node(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, struct find_path *path);
// split_ext_node::writer_object
//
signed int writer_object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// split_path
// file ../include/util.h line 119
signed int split_path(const char *path, unsigned long int nr_segs, char **segs);
// split_to_nodes
// file sd_inode.c line 335
static void split_to_nodes(struct sd_extent_header *src, struct sd_extent_header *left, struct sd_extent_header *right, signed int num);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// str_to_addr
// file net.c line 413
unsigned char * str_to_addr(const char *ipstr, unsigned char *addr);
// strbuf_add
// file strbuf.c line 101
void strbuf_add(struct strbuf *sb, const void *data, unsigned long int len);
// strbuf_addf
// file ../include/strbuf.h line 91
void strbuf_addf(struct strbuf *sb, const char *fmt, ...);
// strbuf_attach
// file strbuf.c line 43
void strbuf_attach(struct strbuf *sb, void *buf, unsigned long int len, unsigned long int alloc);
// strbuf_avail
// file ../include/strbuf.h line 49
static inline unsigned long int strbuf_avail(struct strbuf *sb);
// strbuf_copyout
// file strbuf.c line 193
signed int strbuf_copyout(struct strbuf *sb, void *buf, unsigned long int len);
// strbuf_detach
// file strbuf.c line 36
char * strbuf_detach(struct strbuf *sb);
// strbuf_fread
// file ../include/strbuf.h line 93
unsigned long int strbuf_fread(struct strbuf *sb, unsigned long int size, struct _IO_FILE *f);
// strbuf_getline
// file strbuf.c line 184
signed int strbuf_getline(struct strbuf *sb, struct _IO_FILE *fp, signed int term);
// strbuf_getwholeline
// file strbuf.c line 163
static signed int strbuf_getwholeline(struct strbuf *sb, struct _IO_FILE *fp, signed int term);
// strbuf_grow
// file strbuf.c line 53
void strbuf_grow(struct strbuf *sb, unsigned long int extra);
// strbuf_init
// file ../include/strbuf.h line 42
void strbuf_init(struct strbuf *sb, unsigned long int hint);
// strbuf_insert
// file strbuf.c line 67
void strbuf_insert(struct strbuf *sb, unsigned long int pos, const void *data, unsigned long int len);
// strbuf_read
// file strbuf.c line 140
signed long int strbuf_read(struct strbuf *sb, signed int fd, unsigned long int hint);
// strbuf_release
// file ../include/strbuf.h line 43
void strbuf_release(struct strbuf *sb);
// strbuf_remove
// file strbuf.c line 96
void strbuf_remove(struct strbuf *sb, unsigned long int pos, unsigned long int len);
// strbuf_reset
// file strbuf.c line 29
void strbuf_reset(struct strbuf *sb);
// strbuf_rtrim
// file strbuf.c line 60
void strbuf_rtrim(struct strbuf *sb);
// strbuf_setlen
// file ../include/strbuf.h line 53
static inline void strbuf_setlen(struct strbuf *sb, unsigned long int len);
// strbuf_splice
// file strbuf.c line 77
void strbuf_splice(struct strbuf *sb, unsigned long int pos, unsigned long int len, const void *data, unsigned long int dlen);
// strbuf_stripout
// file strbuf.c line 201
signed int strbuf_stripout(struct strbuf *sb, void *buf, unsigned long int len);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strchrnul
// file /usr/include/string.h line 276
extern char * strchrnul(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strsignal
// file /usr/include/string.h line 563
extern char * strsignal(signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtok_r
// file /usr/include/string.h line 358
extern char * strtok_r(char *, const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// syscall
// file /usr/include/unistd.h line 1058
extern signed long int syscall(signed long int, ...);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timer_handler
// file event.c line 25
static void timer_handler(signed int fd, signed int events, void *data);
// timerfd_create
// file /usr/include/x86_64-linux-gnu/sys/timerfd.h line 38
extern signed int timerfd_create(signed int, signed int);
// timerfd_settime
// file /usr/include/x86_64-linux-gnu/sys/timerfd.h line 43
extern signed int timerfd_settime(signed int, signed int, struct itimerspec *, struct itimerspec *);
// tkill
// file util.c line 482
signed int tkill(signed int tid, signed int sig);
// trace_clear_tid_map
// file work.c line 190
static inline void trace_clear_tid_map(signed int tid);
// trace_set_tid_map
// file work.c line 189
static inline void trace_set_tid_map(signed int tid);
// transfer_to_idx_root
// file sd_inode.c line 355
static void transfer_to_idx_root(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode);
// transfer_to_idx_root::writer_object
//
signed int writer_object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// traverse_btree
// file sd_inode.c line 139
extern void traverse_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, void (*fn)(void *, enum btree_node_type, void *), void *arg);

//

// traverse_btree::reader_object
//
signed int reader_object(unsigned long int, void **, unsigned int, unsigned long int);
// try_to_free_routine_object
//
void try_to_free_routine_object(unsigned long int);
// uatomic_is_true
// file ../include/util.h line 206
static inline _Bool uatomic_is_true(struct anonymous_6 *val);
// uatomic_set_false
// file ../include/util.h line 217
static inline void uatomic_set_false(struct anonymous_6 *val);
// uatomic_set_false_link1
// file ../include/util.h line 217
static inline void uatomic_set_false_link1(struct anonymous_6 *val_link1);
// uatomic_set_true
// file ../include/util.h line 212
static inline _Bool uatomic_set_true(struct anonymous_6 *val);
// uatomic_set_true_link1
// file ../include/util.h line 212
static inline _Bool uatomic_set_true_link1(struct anonymous_6 *val_link1);
// unblock_sighup
// file logger.c line 143
static void unblock_sighup(void);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unregister_event
// file event.c line 125
void unregister_event(signed int fd);
// usage
// file core.c line 331
static void usage(signed int inval);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// valloc
// file /usr/include/stdlib.h line 498
extern void * valloc(unsigned long int);
// vdi_inode_cmp
// file volume.c line 87
static signed int vdi_inode_cmp(struct vdi_inode *a, struct vdi_inode *b);
// vdi_inode_tree_insert
// file volume.c line 92
static struct vdi_inode * vdi_inode_tree_insert(struct vdi_inode *new);
// vdi_inode_tree_search
// file volume.c line 97
static struct vdi_inode * vdi_inode_tree_search(unsigned int vid);
// vdi_list_get_size
// file sheepfs.h line 78
unsigned long int vdi_list_get_size(const char *path);
// vdi_list_read
// file sheepfs.h line 77
signed int vdi_list_read(const char *path, char *buf, unsigned long int size, signed long int ignore);
// vdi_mount_write
// file sheepfs.h line 80
signed int vdi_mount_write(const char *path, const char *buf, unsigned long int size, signed long int ignore);
// vdi_unmount_write
// file sheepfs.h line 81
signed int vdi_unmount_write(const char *path, const char *buf, unsigned long int size, signed long int ignore);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vid_to_btree_oid
// file ../include/sheepdog_proto.h line 455
static inline unsigned long int vid_to_btree_oid(unsigned int vid, unsigned int btreeid);
// vid_to_data_oid
// file ../include/sheepdog_proto.h line 440
static inline unsigned long int vid_to_data_oid(unsigned int vid, unsigned long int idx);
// vid_to_vdi_oid
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid(unsigned int vid);
// vid_to_vdi_oid_link1
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid_link1(unsigned int vid_link1);
// volume_create_entry
// file sheepfs.h line 64
signed int volume_create_entry(const char *entry);
// volume_do_rw
// file volume.c line 210
static signed long int volume_do_rw(const char *path, char *buf, unsigned long int size, signed long int offset, signed int rw);
// volume_do_sync
// file volume.c line 314
static signed int volume_do_sync(unsigned int vid);
// volume_get_size
// file sheepfs.h line 63
unsigned long int volume_get_size(const char *path);
// volume_open
// file sheepfs.h line 67
signed int volume_open(const char *path, struct fuse_file_info *fi);
// volume_read
// file sheepfs.h line 61
signed int volume_read(const char *path, char *buf, unsigned long int size, signed long int offset);
// volume_remove_entry
// file sheepfs.h line 65
signed int volume_remove_entry(const char *entry);
// volume_rw_object
// file volume.c line 133
static signed int volume_rw_object(char *buf, unsigned long int oid, unsigned long int size, signed long int off, signed int rw);
// volume_sync
// file sheepfs.h line 66
signed int volume_sync(const char *path);
// volume_sync_and_delete
// file volume.c line 505
static signed int volume_sync_and_delete(unsigned int vid);
// volume_write
// file sheepfs.h line 62
signed int volume_write(const char *path, const char *buf, unsigned long int size, signed long int offset);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vsyslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 200
extern void vsyslog(signed int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// work_queue_empty
// file work.c line 445
_Bool work_queue_empty(struct work_queue *q);
// worker_routine
// file work.c line 313
static void * worker_routine(void *arg);
// worker_thread_request_done
// file work.c line 287
static void worker_thread_request_done(signed int fd, signed int events, void *data);
// wq_get_nr_nodes_object
//
unsigned long int wq_get_nr_nodes_object(void);
// wq_get_roof
// file work.c line 202
static inline unsigned long int wq_get_roof(struct wq_info *wi);
// wq_need_grow
// file work.c line 222
static _Bool wq_need_grow(struct wq_info *wi);
// wq_need_shrink
// file work.c line 238
static _Bool wq_need_shrink(struct wq_info *wi);
// wq_trace_init
// file work.c line 188
static inline signed int wq_trace_init(void);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_cb
// file http.c line 108
static unsigned long int write_cb(void *contents, unsigned long int size, unsigned long int nmemb, void *userp);
// writev
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 50
extern signed long int writev(signed int, struct iovec *, signed int);
// xcalloc
// file ../include/util.h line 94
void * xcalloc(unsigned long int nmemb, unsigned long int size);
// xfallocate
// file util.c line 252
signed int xfallocate(signed int fd, signed int mode, signed long int offset, signed long int len);
// xftruncate
// file util.c line 263
signed int xftruncate(signed int fd, signed long int length);
// xmalloc
// file ../include/util.h line 91
void * xmalloc(unsigned long int size);
// xmkdir
// file ../include/util.h line 100
signed int xmkdir(const char *pathname, unsigned int mode);
// xpread
// file ../include/util.h line 98
signed long int xpread(signed int fd, void *buf, unsigned long int count, signed long int offset);
// xpwrite
// file util.c line 210
signed long int xpwrite(signed int fd, const void *buf, unsigned long int count, signed long int offset);
// xread
// file util.c line 128
signed long int xread(signed int fd, void *buf, unsigned long int count);
// xrealloc
// file util.c line 64
void * xrealloc(void *ptr, unsigned long int size);
// xvalloc
// file util.c line 97
void * xvalloc(unsigned long int size);
// xwrite
// file ../include/util.h line 97
signed long int xwrite(signed int fd, const void *buf, unsigned long int count);
// xzalloc
// file ../include/util.h line 92
void * xzalloc(unsigned long int size);

struct anonymous_32
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_30
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_16
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_9
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_4
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

struct anonymous_26
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_29
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_28
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_27
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_31
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_33
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_26 _kill;
  // _timer
  struct anonymous_27 _timer;
  // _rt
  struct anonymous_28 _rt;
  // _sigchld
  struct anonymous_29 _sigchld;
  // _sigfault
  struct anonymous_30 _sigfault;
  // _sigpoll
  struct anonymous_31 _sigpoll;
  // _sigsys
  struct anonymous_32 _sigsys;
};

struct anonymous_25
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_33 _sifields;
};

struct anonymous
{
  // __pad
  unsigned int __pad;
  // nr_nodes
  unsigned int nr_nodes;
  // __reserved
  unsigned int __reserved[2l];
  // store_size
  unsigned long int store_size;
  // store_free
  unsigned long int store_free;
};

struct anonymous_2
{
  // __pad
  unsigned int __pad;
  // rsvd
  unsigned int rsvd;
  // vdi_id
  unsigned int vdi_id;
  // attr_id
  unsigned int attr_id;
  // copies
  unsigned char copies;
  // reserved
  unsigned char reserved[3l];
};

struct anonymous_1
{
  // __pad
  unsigned int __pad;
  // copies
  unsigned char copies;
  // reserved
  unsigned char reserved[3l];
  // offset
  unsigned long int offset;
};

struct anonymous_0
{
  // __pad1
  unsigned int __pad1;
  // __pad2
  unsigned int __pad2;
  // digest
  unsigned char digest[20l];
};

struct anonymous_15
{
  // old_vid
  unsigned int old_vid;
  // new_vid
  unsigned int new_vid;
  // copies
  unsigned char copies;
  // set_bitmap
  unsigned char set_bitmap;
  // copy_policy
  unsigned char copy_policy;
};

struct anonymous_12
{
  // oid
  unsigned long int oid;
  // cow_oid
  unsigned long int cow_oid;
  // copies
  unsigned char copies;
  // copy_policy
  unsigned char copy_policy;
  // ec_index
  unsigned char ec_index;
  // reserved
  unsigned char reserved;
  // tgt_epoch
  unsigned int tgt_epoch;
  // offset
  unsigned int offset;
  // __pad
  unsigned int __pad;
};

struct anonymous_14
{
  // oid
  unsigned long int oid;
  // ctime
  unsigned long int ctime;
  // copies
  unsigned char copies;
  // copy_policy
  unsigned char copy_policy;
  // flags
  unsigned short int flags;
  // tag
  unsigned int tag;
};

struct anonymous_6
{
  // val
  unsigned long int val;
};

struct anonymous_13
{
  // vdi_size
  unsigned long int vdi_size;
  // base_vdi_id
  unsigned int base_vdi_id;
  // copies
  unsigned char copies;
  // copy_policy
  unsigned char copy_policy;
  // store_policy
  unsigned char store_policy;
  // reserved
  unsigned char reserved;
  // snapid
  unsigned int snapid;
};

union anonymous_22
{
  // ifu_broadaddr
  struct sockaddr *ifu_broadaddr;
  // ifu_dstaddr
  struct sockaddr *ifu_dstaddr;
};

union anonymous_24
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_25 *, void *);
};

union anonymous_23
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_8
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_10
{
  // __data
  struct anonymous_9 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous_5
{
  // __data
  struct anonymous_4 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

union anonymous_11
{
  // obj
  struct anonymous_12 obj;
  // vdi
  struct anonymous_13 vdi;
  // cluster
  struct anonymous_14 cluster;
  // vdi_state
  struct anonymous_15 vdi_state;
  // __pad
  unsigned int __pad[8l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_7
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous_3
{
  // result
  unsigned int result;
  // obj
  struct anonymous_1 obj;
  // vdi
  struct anonymous_2 vdi;
  // node
  struct anonymous node;
  // hash
  struct anonymous_0 hash;
  // __pad
  unsigned int __pad[8l];
};

union anonymous_21
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_18
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __uatomic_dummy
{
  // v
  unsigned long int v[10l];
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct buffer_s
{
  // mem
  char *mem;
  // current_size
  unsigned long int current_size;
  // total_size
  unsigned long int total_size;
};

struct connection
{
  // fd
  signed int fd;
  // events
  unsigned int events;
  // port
  unsigned short int port;
  // ipstr
  char ipstr[46l];
  // dead
  _Bool dead;
};

struct curl_slist
{
  // data
  char *data;
  // next
  struct curl_slist *next;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

union epoll_data
{
  // ptr
  void *ptr;
  // fd
  signed int fd;
  // u32
  unsigned int u32;
  // u64
  unsigned long int u64;
};

struct epoll_event
{
  // events
  unsigned int events;
  // data
  union epoll_data data;
} __attribute__ ((__packed__));

struct rb_node
{
  // rb_parent_color
  unsigned long int rb_parent_color;
  // rb_right
  struct rb_node *rb_right;
  // rb_left
  struct rb_node *rb_left;
};

struct event_info
{
  // handler
  void (*handler)(signed int, signed int, void *);
  // fd
  signed int fd;
  // data
  void *data;
  // rb
  struct rb_node rb;
  // prio
  signed int prio;
};

struct fec
{
  // magic
  unsigned long int magic;
  // d
  unsigned short int d;
  // dp
  unsigned short int dp;
  // enc_matrix
  unsigned char *enc_matrix;
};

struct find_path
{
  // p_idx
  struct sd_extent_idx *p_idx;
  // p_ext
  struct sd_extent *p_ext;
  // p_ext_header
  struct sd_extent_header *p_ext_header;
  // depth
  signed int depth;
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct fuse_args
{
  // argc
  signed int argc;
  // argv
  char **argv;
  // allocated
  signed int allocated;
};

struct fuse_buf
{
  // size
  unsigned long int size;
  // flags
  enum fuse_buf_flags flags;
  // mem
  void *mem;
  // fd
  signed int fd;
  // pos
  signed long int pos;
};

struct fuse_bufvec
{
  // count
  unsigned long int count;
  // idx
  unsigned long int idx;
  // off
  unsigned long int off;
  // buf
  struct fuse_buf buf[1l];
};

struct fuse_conn_info
{
  // proto_major
  unsigned int proto_major;
  // proto_minor
  unsigned int proto_minor;
  // async_read
  unsigned int async_read;
  // max_write
  unsigned int max_write;
  // max_readahead
  unsigned int max_readahead;
  // capable
  unsigned int capable;
  // want
  unsigned int want;
  // max_background
  unsigned int max_background;
  // congestion_threshold
  unsigned int congestion_threshold;
  // reserved
  unsigned int reserved[23l];
};

struct fuse_file_info
{
  // flags
  signed int flags;
  // fh_old
  unsigned long int fh_old;
  // writepage
  signed int writepage;
  // direct_io
  unsigned int direct_io : 1;
  // keep_cache
  unsigned int keep_cache : 1;
  // flush
  unsigned int flush : 1;
  // nonseekable
  unsigned int nonseekable : 1;
  // flock_release
  unsigned int flock_release : 1;
  // padding
  unsigned int padding : 27;
  // fh
  unsigned long int fh;
  // lock_owner
  unsigned long int lock_owner;
};

struct fuse_operations
{
  // getattr
  signed int (*getattr)(const char *, struct stat *);
  // readlink
  signed int (*readlink)(const char *, char *, unsigned long int);
  // getdir
  signed int (*getdir)(const char *, struct fuse_dirhandle *, signed int (*)(struct fuse_dirhandle *, const char *, signed int, unsigned long int));
  // mknod
  signed int (*mknod)(const char *, unsigned int, unsigned long int);
  // mkdir
  signed int (*mkdir)(const char *, unsigned int);
  // unlink
  signed int (*unlink)(const char *);
  // rmdir
  signed int (*rmdir)(const char *);
  // symlink
  signed int (*symlink)(const char *, const char *);
  // rename
  signed int (*rename)(const char *, const char *);
  // link
  signed int (*link)(const char *, const char *);
  // chmod
  signed int (*chmod)(const char *, unsigned int);
  // chown
  signed int (*chown)(const char *, unsigned int, unsigned int);
  // truncate
  signed int (*truncate)(const char *, signed long int);
  // utime
  signed int (*utime)(const char *, struct utimbuf *);
  // open
  signed int (*open)(const char *, struct fuse_file_info *);
  // read
  signed int (*read)(const char *, char *, unsigned long int, signed long int, struct fuse_file_info *);
  // write
  signed int (*write)(const char *, const char *, unsigned long int, signed long int, struct fuse_file_info *);
  // statfs
  signed int (*statfs)(const char *, struct statvfs *);
  // flush
  signed int (*flush)(const char *, struct fuse_file_info *);
  // release
  signed int (*release)(const char *, struct fuse_file_info *);
  // fsync
  signed int (*fsync)(const char *, signed int, struct fuse_file_info *);
  // setxattr
  signed int (*setxattr)(const char *, const char *, const char *, unsigned long int, signed int);
  // getxattr
  signed int (*getxattr)(const char *, const char *, char *, unsigned long int);
  // listxattr
  signed int (*listxattr)(const char *, char *, unsigned long int);
  // removexattr
  signed int (*removexattr)(const char *, const char *);
  // opendir
  signed int (*opendir)(const char *, struct fuse_file_info *);
  // readdir
  signed int (*readdir)(const char *, void *, signed int (*)(void *, const char *, struct stat *, signed long int), signed long int, struct fuse_file_info *);
  // releasedir
  signed int (*releasedir)(const char *, struct fuse_file_info *);
  // fsyncdir
  signed int (*fsyncdir)(const char *, signed int, struct fuse_file_info *);
  // init
  void * (*init)(struct fuse_conn_info *);
  // destroy
  void (*destroy)(void *);
  // access
  signed int (*access)(const char *, signed int);
  // create
  signed int (*create)(const char *, unsigned int, struct fuse_file_info *);
  // ftruncate
  signed int (*ftruncate)(const char *, signed long int, struct fuse_file_info *);
  // fgetattr
  signed int (*fgetattr)(const char *, struct stat *, struct fuse_file_info *);
  // lock
  signed int (*lock)(const char *, struct fuse_file_info *, signed int, struct flock *);
  // utimens
  signed int (*utimens)(const char *, struct timespec *);
  // bmap
  signed int (*bmap)(const char *, unsigned long int, unsigned long int *);
  // flag_nullpath_ok
  unsigned int flag_nullpath_ok : 1;
  // flag_nopath
  unsigned int flag_nopath : 1;
  // flag_utime_omit_ok
  unsigned int flag_utime_omit_ok : 1;
  // flag_reserved
  unsigned int flag_reserved : 29;
  // ioctl
  signed int (*ioctl)(const char *, signed int, void *, struct fuse_file_info *, unsigned int, void *);
  // poll
  signed int (*poll)(const char *, struct fuse_file_info *, struct fuse_pollhandle *, unsigned int *);
  // write_buf
  signed int (*write_buf)(const char *, struct fuse_bufvec *, signed long int, struct fuse_file_info *);
  // read_buf
  signed int (*read_buf)(const char *, struct fuse_bufvec **, unsigned long int, signed long int, struct fuse_file_info *);
  // flock
  signed int (*flock)(const char *, struct fuse_file_info *, signed int);
  // fallocate
  signed int (*fallocate)(const char *, signed int, signed long int, signed long int, struct fuse_file_info *);
};

struct ifaddrs
{
  // ifa_next
  struct ifaddrs *ifa_next;
  // ifa_name
  char *ifa_name;
  // ifa_flags
  unsigned int ifa_flags;
  // ifa_addr
  struct sockaddr *ifa_addr;
  // ifa_netmask
  struct sockaddr *ifa_netmask;
  // ifa_ifu
  union anonymous_22 ifa_ifu;
  // ifa_data
  void *ifa_data;
};

struct in6_addr
{
  // __in6_u
  union anonymous_23 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct itimerspec
{
  // it_interval
  struct timespec it_interval;
  // it_value
  struct timespec it_value;
};

struct linger
{
  // l_onoff
  signed int l_onoff;
  // l_linger
  signed int l_linger;
};

struct list_node
{
  // next
  struct list_node *next;
  // prev
  struct list_node *prev;
};

struct list_head
{
  // n
  struct list_node n;
};

struct log_format
{
  // name
  const char *name;
  // formatter
  signed int (*formatter)(char *, unsigned long int, struct logmsg *, _Bool);
  // list
  struct list_node list;
};

union semun
{
  // val
  signed int val;
  // buf
  struct semid_ds *buf;
  // array
  unsigned short int *array;
  // __buf
  struct seminfo *__buf;
};

struct logarea
{
  // active
  _Bool active;
  // tail
  char *tail;
  // start
  char *start;
  // end
  char *end;
  // semid
  signed int semid;
  // semarg
  union semun semarg;
  // fd
  signed int fd;
};

struct logger_user_info
{
  // port
  signed int port;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct logmsg
{
  // tv
  struct timeval tv;
  // prio
  signed int prio;
  // func
  char func[32l];
  // line
  signed int line;
  // worker_name
  char worker_name[20l];
  // worker_idx
  signed int worker_idx;
  // str_len
  unsigned long int str_len;
  // str
  char str[0l];
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct node_id
{
  // addr
  unsigned char addr[16l];
  // port
  unsigned short int port;
  // io_addr
  unsigned char io_addr[16l];
  // io_port
  unsigned short int io_port;
  // pad
  unsigned char pad[4l];
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct option_parser
{
  // option
  const char *option;
  // parser
  signed int (*parser)(const char *);
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rb_root
{
  // rb_node
  struct rb_node *rb_node;
};

struct sd_cond
{
  // cond
  union anonymous_10 cond;
};

struct sd_extent
{
  // idx
  unsigned int idx;
  // vdi_id
  unsigned int vdi_id;
};

struct sd_extent_header
{
  // magic
  unsigned short int magic;
  // depth
  unsigned short int depth;
  // entries
  unsigned int entries;
};

struct sd_extent_idx
{
  // idx
  unsigned int idx;
  // oid
  unsigned long int oid;
};

struct sd_inode
{
  // name
  char name[256l];
  // tag
  char tag[256l];
  // create_time
  unsigned long int create_time;
  // snap_ctime
  unsigned long int snap_ctime;
  // vm_clock_nsec
  unsigned long int vm_clock_nsec;
  // vdi_size
  unsigned long int vdi_size;
  // vm_state_size
  unsigned long int vm_state_size;
  // copy_policy
  unsigned char copy_policy;
  // store_policy
  unsigned char store_policy;
  // nr_copies
  unsigned char nr_copies;
  // block_size_shift
  unsigned char block_size_shift;
  // snap_id
  unsigned int snap_id;
  // vdi_id
  unsigned int vdi_id;
  // parent_vdi_id
  unsigned int parent_vdi_id;
  // child_vdi_id
  unsigned int child_vdi_id[1024l];
  // data_vdi_id
  unsigned int data_vdi_id[1048576l];
  // btree_counter
  unsigned int btree_counter;
};

struct sd_mutex
{
  // mutex
  union anonymous_7 mutex;
};

struct sd_node
{
  // rb
  struct rb_node rb;
  // nid
  struct node_id nid;
  // nr_vnodes
  unsigned short int nr_vnodes;
  // zone
  unsigned int zone;
  // space
  unsigned long int space;
};

struct sd_option
{
  // ch
  signed int ch;
  // name
  const char *name;
  // has_arg
  _Bool has_arg;
  // desc
  const char *desc;
  // help
  const char *help;
};

struct sd_req
{
  // proto_ver
  unsigned char proto_ver;
  // opcode
  unsigned char opcode;
  // flags
  unsigned short int flags;
  // epoch
  unsigned int epoch;
  // id
  unsigned int id;
  // data_length
  unsigned int data_length;
  // _anon0
  union anonymous_11 _anon0;
};

struct sd_rsp
{
  // proto_ver
  unsigned char proto_ver;
  // opcode
  unsigned char opcode;
  // flags
  unsigned short int flags;
  // epoch
  unsigned int epoch;
  // id
  unsigned int id;
  // data_length
  unsigned int data_length;
  // _anon0
  union anonymous_3 _anon0;
};

struct sd_rw_lock
{
  // rwlock
  union anonymous_5 rwlock;
};

struct sembuf
{
  // sem_num
  unsigned short int sem_num;
  // sem_op
  signed short int sem_op;
  // sem_flg
  signed short int sem_flg;
};

struct semid_ds
{
  // sem_perm
  struct ipc_perm sem_perm;
  // sem_otime
  signed long int sem_otime;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // sem_ctime
  signed long int sem_ctime;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
  // sem_nsems
  unsigned long int sem_nsems;
  // __glibc_reserved3
  unsigned long int __glibc_reserved3;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
};

struct seminfo
{
  // semmap
  signed int semmap;
  // semmni
  signed int semmni;
  // semmns
  signed int semmns;
  // semmnu
  signed int semmnu;
  // semmsl
  signed int semmsl;
  // semopm
  signed int semopm;
  // semume
  signed int semume;
  // semusz
  signed int semusz;
  // semvmx
  signed int semvmx;
  // semaem
  signed int semaem;
};

struct sha1_ctx
{
  // count
  unsigned long int count;
  // state
  unsigned int state[5l];
  // buffer
  unsigned char buffer[64l];
};

struct sheepfs_file_operation
{
  // read
  signed int (*read)(const char *, char *, unsigned long int, signed long int);
  // write
  signed int (*write)(const char *, const char *, unsigned long int, signed long int);
  // get_size
  unsigned long int (*get_size)(const char *);
  // sync
  signed int (*sync)(const char *);
  // open
  signed int (*open)(const char *, struct fuse_file_info *);
  // unlink
  signed int (*unlink)(const char *);
  // rmdir
  signed int (*rmdir)(const char *);
};

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_24 __sigaction_handler;
  // sa_mask
  struct anonymous_16 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct sockfd
{
  // fd
  signed int fd;
  // idx
  signed int idx;
};

struct sockfd_cache
{
  // root
  struct rb_root root;
  // lock
  struct sd_rw_lock lock;
  // count
  signed int count;
};

struct sockfd_cache_entry
{
  // rb
  struct rb_node rb;
  // nid
  struct node_id nid;
  // fds
  struct sockfd_cache_fd *fds;
};

struct sockfd_cache_fd
{
  // fd
  signed int fd;
  // in_use
  struct anonymous_6 in_use;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct statvfs
{
  // f_bsize
  unsigned long int f_bsize;
  // f_frsize
  unsigned long int f_frsize;
  // f_blocks
  unsigned long int f_blocks;
  // f_bfree
  unsigned long int f_bfree;
  // f_bavail
  unsigned long int f_bavail;
  // f_files
  unsigned long int f_files;
  // f_ffree
  unsigned long int f_ffree;
  // f_favail
  unsigned long int f_favail;
  // f_fsid
  unsigned long int f_fsid;
  // f_flag
  unsigned long int f_flag;
  // f_namemax
  unsigned long int f_namemax;
  // __f_spare
  signed int __f_spare[6l];
};

struct strbuf
{
  // alloc
  unsigned long int alloc;
  // len
  unsigned long int len;
  // eof
  signed int eof;
  // buf
  char *buf;
};

struct timer
{
  // callback
  void (*callback)(void *);
  // data
  void *data;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct utimbuf
{
  // actime
  signed long int actime;
  // modtime
  signed long int modtime;
};

struct vdi_inode
{
  // rb
  struct rb_node rb;
  // vid
  unsigned int vid;
  // inode
  struct sd_inode *inode;
  // socket_pool
  signed int socket_pool[31l];
  // socket_in_use
  struct anonymous_6 socket_in_use[31l];
  // socket_poll_adder
  unsigned int socket_poll_adder;
};

struct work
{
  // w_list
  struct list_node w_list;
  // fn
  void (*fn)(struct work *);
  // done
  void (*done)(struct work *);
};

struct work_queue
{
  // wq_state
  signed int wq_state;
  // pending_list
  struct list_head pending_list;
};

struct wq_info
{
  // name
  const char *name;
  // finished_list
  struct list_head finished_list;
  // list
  struct list_node list;
  // finished_lock
  struct sd_mutex finished_lock;
  // startup_lock
  struct sd_mutex startup_lock;
  // pending_cond
  struct sd_cond pending_cond;
  // pending_lock
  struct sd_mutex pending_lock;
  // q
  struct work_queue q;
  // nr_threads
  unsigned long int nr_threads;
  // nr_queued_work
  unsigned long int nr_queued_work;
  // tm_end_of_protection
  unsigned long int tm_end_of_protection;
  // tc
  enum wq_thread_control tc;
};


// Pp
// file fec.c line 69
static const char * const Pp = "101110001";
// colorize
// file logger.c line 40
static _Bool colorize;
// dst_type
// file logger.c line 123
static enum log_dst_type dst_type = (enum log_dst_type)1;
// efd
// file event.c line 22
static signed int efd;
// efd_link1
// file work.c line 68
static signed int efd_link1;
// event_loop_refresh
// file event.c line 172
static _Bool event_loop_refresh;
// events
// file event.c line 71
static struct epoll_event *events;
// events_tree
// file event.c line 23
static struct rb_root events_tree = { .rb_node=(struct rb_node *)(void *)0 };
// fds_count
// file sockfd_cache.c line 62
static signed int fds_count = 8;
// fds_high_watermark
// file sockfd_cache.c line 243
static signed int fds_high_watermark = (8 * 3) / 4;
// fds_in_grow
// file sockfd_cache.c line 242
static struct anonymous_6 fds_in_grow;
// format
// file logger.c line 107
static struct log_format *format;
// fs_printf
// file core.c line 114
void (*fs_printf)(const char *, signed int, const char *, ...);
// fs_printf
// file core.c line 114
void (*fs_printf)(const char *, signed int, const char *, ...) = bg_printf;
// gf_exp
// file fec.c line 80
static unsigned char gf_exp[510l];
// gf_log
// file fec.c line 81
static signed int gf_log[256l];
// gf_mul_table
// file fec.c line 108
static unsigned char gf_mul_table[256l][256l];
// grow_wq
// file sockfd_cache.c line 245
static struct work_queue *grow_wq;
// inverse
// file fec.c line 82
static unsigned char inverse[256l];
// la
// file logger.c line 112
static struct logarea *la;
// log_buff
// file logger.c line 119
static char *log_buff;
// log_fd
// file logger.c line 109
static signed int log_fd = -1;
// log_formats
// file logger.c line 106
static struct list_head log_formats;
// log_formats
// file logger.c line 106
static struct list_head log_formats = { .n={ .next=&log_formats.n, .prev=&log_formats.n } };
// log_name
// file logger.c line 113
static const char *log_name;
// log_nowname
// file logger.c line 114
static char *log_nowname;
// logger_pid
// file logger.c line 117
signed int logger_pid = -1;
// logger_user_info
// file logger.c line 63
static struct logger_user_info *logger_user_info;
// long_options
// file core.c line 42
static struct option long_options[8l] = { { .name="address", .has_arg=1, .flag=(signed int *)(void *)0, .val=97 },
    { .name="debug", .has_arg=0, .flag=(signed int *)(void *)0, .val=100 },
    { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name="foreground", .has_arg=0, .flag=(signed int *)(void *)0, .val=102 },
    { .name="pagecache", .has_arg=0, .flag=(signed int *)(void *)0, .val=107 },
    { .name="objectcache", .has_arg=0, .flag=(signed int *)(void *)0, .val=111 },
    { .name="port", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
// max_logsize
// file logger.c line 121
static signed long int max_logsize = (signed long int)(500 * 1024 * 1024);
// nr_events
// file event.c line 72
static signed int nr_events;
// nr_nodes
// file work.c line 70
static unsigned long int nr_nodes = (unsigned long int)1;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// sd_def_dmode
// file util.c line 25
unsigned int sd_def_dmode = (unsigned int)(0400 | 0200 | 0100 | 0400 >> 3 | 0200 >> 3 | 0100 >> 3);
// sd_def_fmode
// file util.c line 26
unsigned int sd_def_fmode = (unsigned int)(0400 | 0200 | 0400 >> 3 | 0200 >> 3);
// sd_log_level
// file logger.c line 115
signed int sd_log_level = 6;
// sdhost
// file core.c line 39
char sdhost[32l] = { '1', '2', '7', '.', '0', '.', '0', '.', '1', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// sdport
// file core.c line 40
signed int sdport = 7000;
// semkey
// file logger.c line 118
static signed int semkey;
// sha1_final
// file ../include/sha1.h line 32
void (*sha1_final)(void *, unsigned char *);
// sha1_init
// file ../include/sha1.h line 30
void (*sha1_init)(void *);
// sha1_update
// file ../include/sha1.h line 31
void (*sha1_update)(void *, const unsigned char *, unsigned int);
// sheep_pid
// file logger.c line 116
static signed int sheep_pid;
// sheepfs_debug
// file core.c line 35
static signed int sheepfs_debug;
// sheepfs_fg
// file core.c line 36
static signed int sheepfs_fg;
// sheepfs_file_ops
// file core.c line 63
static struct sheepfs_file_operation sheepfs_file_ops[15l];
// sheepfs_file_ops
// file core.c line 63
static struct sheepfs_file_operation sheepfs_file_ops[15l] = { { .read=(signed int (*)(const char *, char *, unsigned long int, signed long int))(void *)0, .write=(signed int (*)(const char *, const char *, unsigned long int, signed long int))(void *)0,
    .get_size=(unsigned long int (*)(const char *))(void *)0,
    .sync=((signed int (*)(const char *))NULL),
    .open=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .unlink=((signed int (*)(const char *))NULL),
    .rmdir=((signed int (*)(const char *))NULL) },
    { .read=cluster_info_read, .write=(signed int (*)(const char *, const char *, unsigned long int, signed long int))(void *)0, .get_size=cluster_info_get_size,
    .sync=((signed int (*)(const char *))NULL), .open=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .unlink=((signed int (*)(const char *))NULL),
    .rmdir=((signed int (*)(const char *))NULL) },
    { .read=vdi_list_read, .write=(signed int (*)(const char *, const char *, unsigned long int, signed long int))(void *)0, .get_size=vdi_list_get_size,
    .sync=((signed int (*)(const char *))NULL), .open=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .unlink=((signed int (*)(const char *))NULL),
    .rmdir=((signed int (*)(const char *))NULL) },
    { .read=(signed int (*)(const char *, char *, unsigned long int, signed long int))(void *)0, .write=vdi_mount_write,
    .get_size=((unsigned long int (*)(const char *))NULL), .sync=((signed int (*)(const char *))NULL),
    .open=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .unlink=((signed int (*)(const char *))NULL),
    .rmdir=((signed int (*)(const char *))NULL) },
    { .read=(signed int (*)(const char *, char *, unsigned long int, signed long int))(void *)0, .write=vdi_unmount_write,
    .get_size=((unsigned long int (*)(const char *))NULL), .sync=((signed int (*)(const char *))NULL),
    .open=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .unlink=((signed int (*)(const char *))NULL),
    .rmdir=((signed int (*)(const char *))NULL) },
    { .read=node_info_read, .write=(signed int (*)(const char *, const char *, unsigned long int, signed long int))(void *)0, .get_size=node_info_get_size,
    .sync=((signed int (*)(const char *))NULL), .open=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .unlink=((signed int (*)(const char *))NULL),
    .rmdir=((signed int (*)(const char *))NULL) },
    { .read=node_list_read, .write=(signed int (*)(const char *, const char *, unsigned long int, signed long int))(void *)0, .get_size=node_list_get_size,
    .sync=((signed int (*)(const char *))NULL), .open=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .unlink=((signed int (*)(const char *))NULL),
    .rmdir=((signed int (*)(const char *))NULL) },
    { .read=config_pcache_read, .write=config_pcache_write, .get_size=config_pcache_get_size,
    .sync=((signed int (*)(const char *))NULL), .open=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .unlink=((signed int (*)(const char *))NULL),
    .rmdir=((signed int (*)(const char *))NULL) },
    { .read=config_ocache_read, .write=config_ocache_write, .get_size=config_ocache_get_size,
    .sync=((signed int (*)(const char *))NULL), .open=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .unlink=((signed int (*)(const char *))NULL),
    .rmdir=((signed int (*)(const char *))NULL) },
    { .read=config_sheep_info_read, .write=config_sheep_info_write, .get_size=config_sheep_info_get_size,
    .sync=((signed int (*)(const char *))NULL),
    .open=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .unlink=((signed int (*)(const char *))NULL),
    .rmdir=((signed int (*)(const char *))NULL) },
    { .read=volume_read, .write=volume_write, .get_size=volume_get_size,
    .sync=volume_sync, .open=volume_open,
    .unlink=((signed int (*)(const char *))NULL), .rmdir=((signed int (*)(const char *))NULL) },
    { .read=http_address_read, .write=http_address_write, .get_size=http_address_get_size,
    .sync=((signed int (*)(const char *))NULL), .open=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .unlink=((signed int (*)(const char *))NULL),
    .rmdir=((signed int (*)(const char *))NULL) },
    { .read=(signed int (*)(const char *, char *, unsigned long int, signed long int))(void *)0, .write=http_object_write,
    .get_size=((unsigned long int (*)(const char *))NULL), .sync=((signed int (*)(const char *))NULL),
    .open=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .unlink=((signed int (*)(const char *))NULL),
    .rmdir=((signed int (*)(const char *))NULL) },
    { .read=object_read, .write=(signed int (*)(const char *, const char *, unsigned long int, signed long int))(void *)0, .get_size=object_get_size,
    .sync=(signed int (*)(const char *))(void *)0, .open=(signed int (*)(const char *, struct fuse_file_info *))(void *)0,
    .unlink=object_unlink,
    .rmdir=((signed int (*)(const char *))NULL) },
    { .read=(signed int (*)(const char *, char *, unsigned long int, signed long int))(void *)0, .write=(signed int (*)(const char *, const char *, unsigned long int, signed long int))(void *)0,
    .get_size=(unsigned long int (*)(const char *))(void *)0,
    .sync=(signed int (*)(const char *))(void *)0,
    .open=(signed int (*)(const char *, struct fuse_file_info *))(void *)0,
    .unlink=(signed int (*)(const char *))(void *)0,
    .rmdir=container_rmdir } };
// sheepfs_object_cache
// file core.c line 38
signed int sheepfs_object_cache;
// sheepfs_ops
// file core.c line 277
static struct fuse_operations sheepfs_ops;
// sheepfs_ops
// file core.c line 277
static struct fuse_operations sheepfs_ops = { .getattr=sheepfs_getattr, .readlink=((signed int (*)(const char *, char *, unsigned long int))NULL), .getdir=((signed int (*)(const char *, struct fuse_dirhandle *, signed int (*)(struct fuse_dirhandle *, const char *, signed int, unsigned long int)))NULL),
    .mknod=((signed int (*)(const char *, unsigned int, unsigned long int))NULL),
    .mkdir=((signed int (*)(const char *, unsigned int))NULL),
    .unlink=sheepfs_unlink,
    .rmdir=sheepfs_rmdir, .symlink=((signed int (*)(const char *, const char *))NULL),
    .rename=((signed int (*)(const char *, const char *))NULL),
    .link=((signed int (*)(const char *, const char *))NULL),
    .chmod=((signed int (*)(const char *, unsigned int))NULL),
    .chown=((signed int (*)(const char *, unsigned int, unsigned int))NULL),
    .truncate=sheepfs_truncate,
    .utime=((signed int (*)(const char *, struct utimbuf *))NULL), .open=sheepfs_open,
    .read=sheepfs_read, .write=sheepfs_write,
    .statfs=((signed int (*)(const char *, struct statvfs *))NULL), .flush=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .release=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .fsync=sheepfs_fsync,
    .setxattr=((signed int (*)(const char *, const char *, const char *, unsigned long int, signed int))NULL), .getxattr=((signed int (*)(const char *, const char *, char *, unsigned long int))NULL),
    .listxattr=((signed int (*)(const char *, char *, unsigned long int))NULL),
    .removexattr=((signed int (*)(const char *, const char *))NULL),
    .opendir=((signed int (*)(const char *, struct fuse_file_info *))NULL),
    .readdir=sheepfs_readdir,
    .releasedir=((signed int (*)(const char *, struct fuse_file_info *))NULL), .fsyncdir=((signed int (*)(const char *, signed int, struct fuse_file_info *))NULL),
    .init=((void * (*)(struct fuse_conn_info *))NULL),
    .destroy=((void (*)(void *))NULL),
    .access=((signed int (*)(const char *, signed int))NULL), .create=((signed int (*)(const char *, unsigned int, struct fuse_file_info *))NULL),
    .ftruncate=((signed int (*)(const char *, signed long int, struct fuse_file_info *))NULL),
    .fgetattr=((signed int (*)(const char *, struct stat *, struct fuse_file_info *))NULL),
    .lock=((signed int (*)(const char *, struct fuse_file_info *, signed int, struct flock *))NULL),
    .utimens=((signed int (*)(const char *, struct timespec *))NULL),
    .bmap=((signed int (*)(const char *, unsigned long int, unsigned long int *))NULL),
    .flag_nullpath_ok=0u,
    .flag_nopath=0u, .flag_utime_omit_ok=0u,
    .flag_reserved=0u, .ioctl=((signed int (*)(const char *, signed int, void *, struct fuse_file_info *, unsigned int, void *))NULL),
    .poll=((signed int (*)(const char *, struct fuse_file_info *, struct fuse_pollhandle *, unsigned int *))NULL),
    .write_buf=((signed int (*)(const char *, struct fuse_bufvec *, signed long int, struct fuse_file_info *))NULL),
    .read_buf=((signed int (*)(const char *, struct fuse_bufvec **, unsigned long int, signed long int, struct fuse_file_info *))NULL),
    .flock=((signed int (*)(const char *, struct fuse_file_info *, signed int))NULL),
    .fallocate=((signed int (*)(const char *, signed int, signed long int, signed long int, struct fuse_file_info *))NULL) };
// sheepfs_page_cache
// file core.c line 37
signed int sheepfs_page_cache;
// sheepfs_shadow
// file core.c line 33
char sheepfs_shadow[4096l];
// short_options
// file core.c line 53
static const char *short_options = "a:dfhknp:";
// sockfd_cache
// file sockfd_cache.c line 44
static struct sockfd_cache sockfd_cache = { .root={ .rb_node=(struct rb_node *)(void *)0 }, .lock={ .rwlock={ .__data={ .__lock=0, .__nr_readers=(unsigned int)0, .__readers_wakeup=(unsigned int)0,
    .__writer_wakeup=(unsigned int)0, .__nr_readers_queued=(unsigned int)0,
    .__nr_writers_queued=(unsigned int)0,
    .__writer=0,
    .__shared=0, .__rwelision=(signed char)0, .__pad1={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    .__pad2=(unsigned long int)0,
    .__flags=(unsigned int)0 } } },
    .count=0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// try_to_free_routine
// file util.c line 32
static void (*try_to_free_routine)(unsigned long int);
// try_to_free_routine
// file util.c line 32
static void (*try_to_free_routine)(unsigned long int) = do_nothing;
// vdi_inode_tree
// file volume.c line 64
static struct rb_root vdi_inode_tree = { .rb_node=(struct rb_node *)(void *)0 };
// vdi_inode_tree_lock
// file volume.c line 65
static struct sd_rw_lock vdi_inode_tree_lock = { .rwlock={ .__data={ .__lock=0, .__nr_readers=(unsigned int)0, .__readers_wakeup=(unsigned int)0,
    .__writer_wakeup=(unsigned int)0, .__nr_readers_queued=(unsigned int)0,
    .__nr_writers_queued=(unsigned int)0,
    .__writer=0,
    .__shared=0, .__rwelision=(signed char)0, .__pad1={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    .__pad2=(unsigned long int)0,
    .__flags=(unsigned int)0 } } };
// worker_idx
// file logger.c line 111
static signed int worker_idx;
// worker_name
// file logger.c line 110
static const char *worker_name;
// wq_get_nr_nodes
// file work.c line 71
static unsigned long int (*wq_get_nr_nodes)(void);
// wq_info_list
// file work.c line 69
static struct list_head wq_info_list;
// wq_info_list
// file work.c line 69
static struct list_head wq_info_list = { .n={ .next=&wq_info_list.n, .prev=&wq_info_list.n } };

// INIT_LIST_HEAD
// file ../include/list.h line 27
static inline void INIT_LIST_HEAD(struct list_head *list)
{
  list->n.next = &list->n;
  list->n.prev = &list->n;
}

// __list_add
// file ../include/list.h line 72
static inline void __list_add(struct list_node *new, struct list_node *prev, struct list_node *next)
{
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
}

// __list_del
// file ../include/list.h line 92
static inline void __list_del(struct list_node *prev, struct list_node *next)
{
  next->prev = prev;
  prev->next = next;
}

// __list_splice
// file ../include/list.h line 122
static inline void __list_splice(struct list_head *list, struct list_node *prev, struct list_node *next)
{
  struct list_node *first = list->n.next;
  struct list_node *last = list->n.prev;
  first->prev = prev;
  prev->next = first;
  last->next = next;
  next->prev = last;
}

// __rb_erase_color
// file rbtree.c line 124
static void __rb_erase_color(struct rb_node *node, struct rb_node *parent, struct rb_root *root)
{
  struct rb_node *other;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_5;
  while((_Bool)1)
  {
    if(!(node == ((struct rb_node *)NULL)))
    {
      if((1ul & node->rb_parent_color) == 0ul)
        goto __CPROVER_DUMP_L42;

    }

    if(node == root->rb_node)
      break;

    if(parent->rb_left == node)
    {
      other = parent->rb_right;
      if((1ul & other->rb_parent_color) == 0ul)
      {
        do
          other->rb_parent_color = other->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          parent->rb_parent_color = parent->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        __rb_rotate_left(parent, root);
        other = parent->rb_right;
      }

      if(other->rb_left == ((struct rb_node *)NULL))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (other->rb_left->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        if(other->rb_right == ((struct rb_node *)NULL))
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (other->rb_right->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
        tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
      {
        do
          other->rb_parent_color = other->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        node = parent;
        parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
      }

      else
      {
        if(other->rb_right == ((struct rb_node *)NULL))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = (other->rb_right->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          do
            other->rb_left->rb_parent_color = other->rb_left->rb_parent_color | (unsigned long int)1;
          while((_Bool)0);
          do
            other->rb_parent_color = other->rb_parent_color & (unsigned long int)~1;
          while((_Bool)0);
          __rb_rotate_right(other, root);
          other = parent->rb_right;
        }

        rb_set_color(other, (signed int)(parent->rb_parent_color & (unsigned long int)1));
        do
          parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          other->rb_right->rb_parent_color = other->rb_right->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        __rb_rotate_left(parent, root);
        node = root->rb_node;
        break;
      }
    }

    else
    {
      other = parent->rb_left;
      if((1ul & other->rb_parent_color) == 0ul)
      {
        do
          other->rb_parent_color = other->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          parent->rb_parent_color = parent->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        __rb_rotate_right(parent, root);
        other = parent->rb_left;
      }

      if(other->rb_left == ((struct rb_node *)NULL))
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = (other->rb_left->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_6)
      {
        if(other->rb_right == ((struct rb_node *)NULL))
          tmp_if_expr_7 = (_Bool)1;

        else
          tmp_if_expr_7 = (other->rb_right->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
        tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_8 = (_Bool)0;
      if(tmp_if_expr_8)
      {
        do
          other->rb_parent_color = other->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        node = parent;
        parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
      }

      else
      {
        if(other->rb_left == ((struct rb_node *)NULL))
          tmp_if_expr_5 = (_Bool)1;

        else
          tmp_if_expr_5 = (other->rb_left->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_5)
        {
          do
            other->rb_right->rb_parent_color = other->rb_right->rb_parent_color | (unsigned long int)1;
          while((_Bool)0);
          do
            other->rb_parent_color = other->rb_parent_color & (unsigned long int)~1;
          while((_Bool)0);
          __rb_rotate_left(other, root);
          other = parent->rb_left;
        }

        rb_set_color(other, (signed int)(parent->rb_parent_color & (unsigned long int)1));
        do
          parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          other->rb_left->rb_parent_color = other->rb_left->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        __rb_rotate_right(parent, root);
        node = root->rb_node;
        break;
      }
    }
  }

__CPROVER_DUMP_L42:
  ;
  if(!(node == ((struct rb_node *)NULL)))
    do
      node->rb_parent_color = node->rb_parent_color | (unsigned long int)1;
    while((_Bool)0);

}

// __rb_rotate_left
// file rbtree.c line 25
static void __rb_rotate_left(struct rb_node *node, struct rb_root *root)
{
  struct rb_node *right = node->rb_right;
  struct rb_node *parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
  node->rb_right = right->rb_left;
  if(!(node->rb_right == ((struct rb_node *)NULL)))
    rb_set_parent(right->rb_left, node);

  right->rb_left = node;
  rb_set_parent(right, parent);
  if(!(parent == ((struct rb_node *)NULL)))
  {
    if(node == parent->rb_left)
      parent->rb_left = right;

    else
      parent->rb_right = right;
  }

  else
    root->rb_node = right;
  rb_set_parent(node, right);
}

// __rb_rotate_right
// file rbtree.c line 47
static void __rb_rotate_right(struct rb_node *node, struct rb_root *root)
{
  struct rb_node *left = node->rb_left;
  struct rb_node *parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
  node->rb_left = left->rb_right;
  if(!(node->rb_left == ((struct rb_node *)NULL)))
    rb_set_parent(left->rb_right, node);

  left->rb_right = node;
  rb_set_parent(left, parent);
  if(!(parent == ((struct rb_node *)NULL)))
  {
    if(node == parent->rb_right)
      parent->rb_right = left;

    else
      parent->rb_left = left;
  }

  else
    root->rb_node = left;
  rb_set_parent(node, left);
}

// __sd_dump_variable
// file logger.c line 791
signed int __sd_dump_variable(const char *var)
{
  char cmd[256l];
  snprintf(cmd, sizeof(char [256l]) /*256ul*/ , "p %s", var);
  signed int return_value_gdb_cmd_1;
  return_value_gdb_cmd_1=gdb_cmd(cmd);
  return return_value_gdb_cmd_1;
}

// __uatomic_add_return
// file /usr/include/urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return(void *addr, unsigned long int val, signed int len)
{
  unsigned char __uatomic_add_return__1__1__1__result;
  unsigned short int __uatomic_add_return__1__1__2__result;
  unsigned int result;
  unsigned long int __uatomic_add_return__1__1__4__result;
  switch(len)
  {
    case 1:
    {
      __uatomic_add_return__1__1__1__result = (unsigned char)val;
      asm("lock; xaddb %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+q"(__uatomic_add_return__1__1__1__result) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return__1__1__1__result + (signed int)(unsigned char)val);
    }
    case 2:
    {
      __uatomic_add_return__1__1__2__result = (unsigned short int)val;
      asm("lock; xaddw %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+r"(__uatomic_add_return__1__1__2__result) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return__1__1__2__result + (signed int)(unsigned short int)val);
    }
    case 4:
    {
      result = (unsigned int)val;
      asm("lock; xaddl %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+r"(result) :  : "memory");
      return (unsigned long int)(result + (unsigned int)val);
    }
    case 8:
    {
      __uatomic_add_return__1__1__4__result = val;
      asm("lock; xaddq %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+r"(__uatomic_add_return__1__1__4__result) :  : "memory");
      return __uatomic_add_return__1__1__4__result + (unsigned long int)val;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_add_return_link1
// file /usr/include/urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return_link1(void *addr_link1, unsigned long int val_link1, signed int len_link1)
{
  unsigned char __uatomic_add_return__1__1__1__result_link1;
  unsigned short int result_link1;
  unsigned int __uatomic_add_return__1__1__3__result_link1;
  unsigned long int __uatomic_add_return__1__1__4__result_link1;
  switch(len_link1)
  {
    case 1:
    {
      __uatomic_add_return__1__1__1__result_link1 = (unsigned char)val_link1;
      asm("lock; xaddb %1, %0" : "+m"(*((struct __uatomic_dummy *)addr_link1)), "+q"(__uatomic_add_return__1__1__1__result_link1) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return__1__1__1__result_link1 + (signed int)(unsigned char)val_link1);
    }
    case 2:
    {
      result_link1 = (unsigned short int)val_link1;
      asm("lock; xaddw %1, %0" : "+m"(*((struct __uatomic_dummy *)addr_link1)), "+r"(result_link1) :  : "memory");
      return (unsigned long int)((signed int)result_link1 + (signed int)(unsigned short int)val_link1);
    }
    case 4:
    {
      __uatomic_add_return__1__1__3__result_link1 = (unsigned int)val_link1;
      asm("lock; xaddl %1, %0" : "+m"(*((struct __uatomic_dummy *)addr_link1)), "+r"(__uatomic_add_return__1__1__3__result_link1) :  : "memory");
      return (unsigned long int)(__uatomic_add_return__1__1__3__result_link1 + (unsigned int)val_link1);
    }
    case 8:
    {
      __uatomic_add_return__1__1__4__result_link1 = val_link1;
      asm("lock; xaddq %1, %0" : "+m"(*((struct __uatomic_dummy *)addr_link1)), "+r"(__uatomic_add_return__1__1__4__result_link1) :  : "memory");
      return __uatomic_add_return__1__1__4__result_link1 + (unsigned long int)val_link1;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg
// file /usr/include/urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg(void *addr, unsigned long int old, unsigned long int _new, signed int len)
{
  unsigned char __uatomic_cmpxchg__1__1__1__result;
  unsigned short int __uatomic_cmpxchg__1__1__2__result;
  unsigned int __uatomic_cmpxchg__1__1__3__result;
  unsigned long int result;
  switch(len)
  {
    case 1:
    {
      __uatomic_cmpxchg__1__1__1__result = (unsigned char)old;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg__1__1__1__result), "+m"(*((struct __uatomic_dummy *)addr)) : "q"((unsigned char)_new) : "memory");
      return (unsigned long int)__uatomic_cmpxchg__1__1__1__result;
    }
    case 2:
    {
      __uatomic_cmpxchg__1__1__2__result = (unsigned short int)old;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg__1__1__2__result), "+m"(*((struct __uatomic_dummy *)addr)) : "r"((unsigned short int)_new) : "memory");
      return (unsigned long int)__uatomic_cmpxchg__1__1__2__result;
    }
    case 4:
    {
      __uatomic_cmpxchg__1__1__3__result = (unsigned int)old;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg__1__1__3__result), "+m"(*((struct __uatomic_dummy *)addr)) : "r"((unsigned int)_new) : "memory");
      return (unsigned long int)__uatomic_cmpxchg__1__1__3__result;
    }
    case 8:
    {
      result = old;
      asm("lock; cmpxchgq %2, %1" : "+a"(result), "+m"(*((struct __uatomic_dummy *)addr)) : "r"((unsigned long int)_new) : "memory");
      return result;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg_link1
// file /usr/include/urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg_link1(void *addr_link1, unsigned long int old_link1, unsigned long int _new_link1, signed int len_link1)
{
  unsigned char __uatomic_cmpxchg__1__1__1__result_link1;
  unsigned short int result_link1;
  unsigned int __uatomic_cmpxchg__1__1__3__result_link1;
  unsigned long int __uatomic_cmpxchg__1__1__4__result_link1;
  switch(len_link1)
  {
    case 1:
    {
      __uatomic_cmpxchg__1__1__1__result_link1 = (unsigned char)old_link1;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg__1__1__1__result_link1), "+m"(*((struct __uatomic_dummy *)addr_link1)) : "q"((unsigned char)_new_link1) : "memory");
      return (unsigned long int)__uatomic_cmpxchg__1__1__1__result_link1;
    }
    case 2:
    {
      result_link1 = (unsigned short int)old_link1;
      asm("lock; cmpxchgw %2, %1" : "+a"(result_link1), "+m"(*((struct __uatomic_dummy *)addr_link1)) : "r"((unsigned short int)_new_link1) : "memory");
      return (unsigned long int)result_link1;
    }
    case 4:
    {
      __uatomic_cmpxchg__1__1__3__result_link1 = (unsigned int)old_link1;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg__1__1__3__result_link1), "+m"(*((struct __uatomic_dummy *)addr_link1)) : "r"((unsigned int)_new_link1) : "memory");
      return (unsigned long int)__uatomic_cmpxchg__1__1__3__result_link1;
    }
    case 8:
    {
      __uatomic_cmpxchg__1__1__4__result_link1 = old_link1;
      asm("lock; cmpxchgq %2, %1" : "+a"(__uatomic_cmpxchg__1__1__4__result_link1), "+m"(*((struct __uatomic_dummy *)addr_link1)) : "r"((unsigned long int)_new_link1) : "memory");
      return __uatomic_cmpxchg__1__1__4__result_link1;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_dec
// file /usr/include/urcu/uatomic.h line 467
static inline void __uatomic_dec(void *addr, signed int len)
{
  switch(len)
  {
    case 1:
    {
      asm("lock; decb %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; decw %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; decl %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; decq %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_inc
// file /usr/include/urcu/uatomic.h line 414
static inline void __uatomic_inc(void *addr, signed int len)
{
  switch(len)
  {
    case 1:
    {
      asm("lock; incb %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; incw %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; incl %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; incq %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// _addmul1
// file fec.c line 216
static void _addmul1(unsigned char *dst, const unsigned char *src, unsigned char c, unsigned long int sz)
{
  unsigned char *__gf_mulc_;
  const unsigned char *lim = &dst[(signed long int)((sz - (unsigned long int)16) + (unsigned long int)1)];
  __gf_mulc_ = gf_mul_table[(signed long int)c];
  for( ; !(dst >= lim); src = src + (signed long int)16)
  {
    dst[(signed long int)0] = dst[(signed long int)0] ^ __gf_mulc_[(signed long int)src[(signed long int)0]];
    dst[(signed long int)1] = dst[(signed long int)1] ^ __gf_mulc_[(signed long int)src[(signed long int)1]];
    dst[(signed long int)2] = dst[(signed long int)2] ^ __gf_mulc_[(signed long int)src[(signed long int)2]];
    dst[(signed long int)3] = dst[(signed long int)3] ^ __gf_mulc_[(signed long int)src[(signed long int)3]];
    dst[(signed long int)4] = dst[(signed long int)4] ^ __gf_mulc_[(signed long int)src[(signed long int)4]];
    dst[(signed long int)5] = dst[(signed long int)5] ^ __gf_mulc_[(signed long int)src[(signed long int)5]];
    dst[(signed long int)6] = dst[(signed long int)6] ^ __gf_mulc_[(signed long int)src[(signed long int)6]];
    dst[(signed long int)7] = dst[(signed long int)7] ^ __gf_mulc_[(signed long int)src[(signed long int)7]];
    dst[(signed long int)8] = dst[(signed long int)8] ^ __gf_mulc_[(signed long int)src[(signed long int)8]];
    dst[(signed long int)9] = dst[(signed long int)9] ^ __gf_mulc_[(signed long int)src[(signed long int)9]];
    dst[(signed long int)10] = dst[(signed long int)10] ^ __gf_mulc_[(signed long int)src[(signed long int)10]];
    dst[(signed long int)11] = dst[(signed long int)11] ^ __gf_mulc_[(signed long int)src[(signed long int)11]];
    dst[(signed long int)12] = dst[(signed long int)12] ^ __gf_mulc_[(signed long int)src[(signed long int)12]];
    dst[(signed long int)13] = dst[(signed long int)13] ^ __gf_mulc_[(signed long int)src[(signed long int)13]];
    dst[(signed long int)14] = dst[(signed long int)14] ^ __gf_mulc_[(signed long int)src[(signed long int)14]];
    dst[(signed long int)15] = dst[(signed long int)15] ^ __gf_mulc_[(signed long int)src[(signed long int)15]];
    dst = dst + (signed long int)16;
  }
  lim = lim + (signed long int)(16 - 1);
  for( ; !(dst >= lim); src = src + 1l)
  {
    *dst = *dst ^ __gf_mulc_[(signed long int)*src];
    dst = dst + 1l;
  }
}

// _curl_easy_getinfo_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 201
static void _curl_easy_getinfo_err_curl_slist(void)
{
  asm("");
}

// _curl_easy_getinfo_err_double
// file /usr/include/curl/typecheck-gcc.h line 199
static void _curl_easy_getinfo_err_double(void)
{
  asm("");
}

// _curl_easy_getinfo_err_long
// file /usr/include/curl/typecheck-gcc.h line 197
static void _curl_easy_getinfo_err_long(void)
{
  asm("");
}

// _curl_easy_getinfo_err_string
// file /usr/include/curl/typecheck-gcc.h line 195
static void _curl_easy_getinfo_err_string(void)
{
  asm("");
}

// _curl_easy_setopt_err_CURLSH
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH(void)
{
  asm("");
}

// _curl_easy_setopt_err_FILE
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE(void)
{
  asm("");
}

// _curl_easy_setopt_err_cb_data
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data(void)
{
  asm("");
}

// _curl_easy_setopt_err_conv_cb
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_httpost
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_off_t
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist(void)
{
  asm("");
}

// _curl_easy_setopt_err_debug_cb
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_error_buffer
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer(void)
{
  asm("");
}

// _curl_easy_setopt_err_ioctl_cb
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_long
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long(void)
{
  asm("");
}

// _curl_easy_setopt_err_opensocket_cb
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_postfields
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields(void)
{
  asm("");
}

// _curl_easy_setopt_err_progress_cb
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_read_cb
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_seek_cb
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_sockopt_cb
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_ssl_ctx_cb
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_string
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string(void)
{
  asm("");
}

// _curl_easy_setopt_err_write_callback
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback(void)
{
  asm("");
}

// _init_mul_table
// file fec.c line 127
static void _init_mul_table(void)
{
  signed int i;
  signed int j;
  i = 0;
  unsigned char return_value_modnn_1;
  for( ; !(i >= 256); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 256); j = j + 1)
    {
      return_value_modnn_1=modnn(gf_log[(signed long int)i] + gf_log[(signed long int)j]);
      gf_mul_table[(signed long int)i][(signed long int)j] = gf_exp[(signed long int)return_value_modnn_1];
    }
  }
  j = 0;
  for( ; !(j >= 256); j = j + 1)
  {
    gf_mul_table[(signed long int)j][(signed long int)0] = (unsigned char)0;
    gf_mul_table[(signed long int)0][(signed long int)j] = gf_mul_table[(signed long int)j][(signed long int)0];
  }
}

// _invert_mat
// file fec.c line 278
static void _invert_mat(unsigned char *src, unsigned int d)
{
  unsigned char c;
  unsigned char *p;
  unsigned int irow = (unsigned int)0;
  unsigned int icol = (unsigned int)0;
  unsigned int row;
  unsigned int col;
  unsigned int i;
  unsigned int ix;
  unsigned int *indxc;
  void *return_value_xmalloc_1;
  return_value_xmalloc_1=xmalloc((unsigned long int)d * sizeof(unsigned int) /*4ul*/ );
  indxc = (unsigned int *)return_value_xmalloc_1;
  unsigned int *indxr;
  void *return_value_xmalloc_2;
  return_value_xmalloc_2=xmalloc((unsigned long int)d * sizeof(unsigned int) /*4ul*/ );
  indxr = (unsigned int *)return_value_xmalloc_2;
  unsigned int *ipiv;
  void *return_value_xmalloc_3;
  return_value_xmalloc_3=xmalloc((unsigned long int)d * sizeof(unsigned int) /*4ul*/ );
  ipiv = (unsigned int *)return_value_xmalloc_3;
  unsigned char *id_row;
  void *return_value_xmalloc_4;
  return_value_xmalloc_4=xmalloc((unsigned long int)((unsigned int)1 * d));
  id_row = (unsigned char *)return_value_xmalloc_4;
  memset((void *)id_row, 0, (unsigned long int)d * sizeof(unsigned char) /*1ul*/ );
  i = (unsigned int)0;
  for( ; !(i >= d); i = i + 1u)
    ipiv[(signed long int)i] = (unsigned int)0;
  col = (unsigned int)0;
  for( ; !(col >= d); col = col + 1u)
  {
    unsigned char *pivot_row;
    if(!(ipiv[(signed long int)col] == 1u))
    {
      if((signed int)src[(signed long int)(col * d + col)] == 0)
        goto __CPROVER_DUMP_L4;

      irow = col;
      icol = col;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      row = (unsigned int)0;
      for( ; !(row >= d); row = row + 1u)
        if(!(ipiv[(signed long int)row] == 1u))
        {
          ix = (unsigned int)0;
          for( ; !(ix >= d); ix = ix + 1u)
            if(ipiv[(signed long int)ix] == 0u)
            {
              if(!((signed int)src[(signed long int)(row * d + ix)] == 0))
              {
                irow = row;
                icol = ix;
                goto found_piv;
              }

            }

        }

    }

  found_piv:
    ;
    ipiv[(signed long int)icol] = ipiv[(signed long int)icol] + 1u;
    if(!(irow == icol))
    {
      ix = (unsigned int)0;
      for( ; !(ix >= d); ix = ix + 1u)
      {
        unsigned char tmp = src[(signed long int)(irow * d + ix)];
        src[(signed long int)(irow * d + ix)] = src[(signed long int)(icol * d + ix)];
        src[(signed long int)(icol * d + ix)] = tmp;
      }
    }

    indxr[(signed long int)col] = irow;
    indxc[(signed long int)col] = icol;
    pivot_row = &src[(signed long int)(icol * d)];
    c = pivot_row[(signed long int)icol];
    if(!((signed int)c == 1))
    {
      c = inverse[(signed long int)c];
      pivot_row[(signed long int)icol] = (unsigned char)1;
      ix = (unsigned int)0;
      for( ; !(ix >= d); ix = ix + 1u)
        pivot_row[(signed long int)ix] = gf_mul_table[(signed long int)c][(signed long int)pivot_row[(signed long int)ix]];
    }

    id_row[(signed long int)icol] = (unsigned char)1;
    signed int return_value_memcmp_5;
    return_value_memcmp_5=memcmp((const void *)pivot_row, (const void *)id_row, (unsigned long int)d * sizeof(unsigned char) /*1ul*/ );
    if(!(return_value_memcmp_5 == 0))
    {
      p = src;
      ix = (unsigned int)0;
      for( ; !(ix >= d); p = p + (signed long int)d)
      {
        if(!(ix == icol))
        {
          c = p[(signed long int)icol];
          p[(signed long int)icol] = (unsigned char)0;
          if(!((signed int)c == 0))
            _addmul1(p, pivot_row, c, (unsigned long int)d);

        }

        ix = ix + 1u;
      }
    }

    id_row[(signed long int)icol] = (unsigned char)0;
  }
  col = d;
  for( ; col >= 1u; col = col - 1u)
    if(!(indxr[(signed long int)(col + 4294967295u)] == indxc[(signed long int)(col + 4294967295u)]))
    {
      row = (unsigned int)0;
      for( ; !(row >= d); row = row + 1u)
      {
        unsigned char _invert_mat__1__3__1__1__tmp = src[(signed long int)(row * d + indxr[(signed long int)(col - (unsigned int)1)])];
        src[(signed long int)(row * d + indxr[(signed long int)(col - (unsigned int)1)])] = src[(signed long int)(row * d + indxc[(signed long int)(col - (unsigned int)1)])];
        src[(signed long int)(row * d + indxc[(signed long int)(col - (unsigned int)1)])] = _invert_mat__1__3__1__1__tmp;
      }
    }

  free((void *)indxc);
  free((void *)indxr);
  free((void *)ipiv);
  free((void *)id_row);
}

// _invert_vdm
// file fec.c line 386
static void _invert_vdm(unsigned char *src, unsigned int d)
{
  unsigned int i;
  unsigned int j;
  unsigned int row;
  unsigned int col;
  unsigned char *b;
  unsigned char *c;
  unsigned char *p;
  unsigned char t;
  unsigned char xx;
  if(!(d == 1u))
  {
    void *return_value_xmalloc_1;
    return_value_xmalloc_1=xmalloc((unsigned long int)((unsigned int)1 * d));
    c = (unsigned char *)return_value_xmalloc_1;
    void *return_value_xmalloc_2;
    return_value_xmalloc_2=xmalloc((unsigned long int)((unsigned int)1 * d));
    b = (unsigned char *)return_value_xmalloc_2;
    void *return_value_xmalloc_3;
    return_value_xmalloc_3=xmalloc((unsigned long int)((unsigned int)1 * d));
    p = (unsigned char *)return_value_xmalloc_3;
    j = (unsigned int)1;
    i = (unsigned int)0;
    for( ; !(i >= d); j = j + d)
    {
      c[(signed long int)i] = (unsigned char)0;
      p[(signed long int)i] = src[(signed long int)j];
      i = i + 1u;
    }
    c[(signed long int)(d - (unsigned int)1)] = p[(signed long int)0];
    i = (unsigned int)1;
    for( ; !(i >= d); i = i + 1u)
    {
      unsigned char p_i = p[(signed long int)i];
      j = (d - (unsigned int)1) - (i - (unsigned int)1);
      for( ; !(j >= d + 4294967295u); j = j + 1u)
        c[(signed long int)j] = c[(signed long int)j] ^ gf_mul_table[(signed long int)p_i][(signed long int)c[(signed long int)(j + (unsigned int)1)]];
      c[(signed long int)(d - (unsigned int)1)] = c[(signed long int)(d - (unsigned int)1)] ^ p_i;
    }
    row = (unsigned int)0;
    for( ; !(row >= d); row = row + 1u)
    {
      xx = p[(signed long int)row];
      t = (unsigned char)1;
      b[(signed long int)(d - (unsigned int)1)] = (unsigned char)1;
      i = d - (unsigned int)1;
      for( ; i >= 1u; i = i - 1u)
      {
        b[(signed long int)(i - (unsigned int)1)] = (unsigned char)((signed int)c[(signed long int)i] ^ (signed int)gf_mul_table[(signed long int)xx][(signed long int)b[(signed long int)i]]);
        t = (unsigned char)((signed int)gf_mul_table[(signed long int)xx][(signed long int)t] ^ (signed int)b[(signed long int)(i - (unsigned int)1)]);
      }
      col = (unsigned int)0;
      for( ; !(col >= d); col = col + 1u)
        src[(signed long int)(col * d + row)] = gf_mul_table[(signed long int)inverse[(signed long int)t]][(signed long int)b[(signed long int)col]];
    }
    free((void *)c);
    free((void *)b);
    free((void *)p);
    goto __CPROVER_DUMP_L14;
  }


__CPROVER_DUMP_L14:
  ;
}

// _matmul
// file fec.c line 255
static void _matmul(unsigned char *a, unsigned char *b, unsigned char *c, unsigned int dp, unsigned int d, unsigned int m)
{
  unsigned int row;
  unsigned int col;
  unsigned int i;
  row = (unsigned int)0;
  for( ; !(row >= dp); row = row + 1u)
  {
    col = (unsigned int)0;
    for( ; !(col >= m); col = col + 1u)
    {
      unsigned char *pa = &a[(signed long int)(row * d)];
      unsigned char *pb = &b[(signed long int)col];
      unsigned char acc = (unsigned char)0;
      i = (unsigned int)0;
      for( ; !(i >= d); pb = pb + (signed long int)m)
      {
        acc = acc ^ gf_mul_table[(signed long int)*pa][(signed long int)*pb];
        i = i + 1u;
        pa = pa + 1l;
      }
      c[(signed long int)(row * m + col)] = acc;
    }
  }
}

// _pread
// file util.c line 168
static signed long int _pread(signed int fd, void *buf, unsigned long int len, signed long int offset)
{
  signed long int nr;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  while((_Bool)1)
  {
    nr=pread(fd, buf, len, offset);
    if(!(nr >= 0l))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 11)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        continue;

    }

    return nr;
  }
}

// _pwrite
// file util.c line 179
static signed long int _pwrite(signed int fd, const void *buf, unsigned long int len, signed long int offset)
{
  signed long int nr;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  while((_Bool)1)
  {
    nr=pwrite(fd, buf, len, offset);
    if(!(nr >= 0l))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 11)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        continue;

    }

    return nr;
  }
}

// _read
// file util.c line 106
static signed long int _read(signed int fd, void *buf, unsigned long int len)
{
  signed long int nr;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  while((_Bool)1)
  {
    nr=read(fd, buf, len);
    if(!(nr >= 0l))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 11)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        continue;

    }

    return nr;
  }
}

// _write
// file util.c line 117
static signed long int _write(signed int fd, const void *buf, unsigned long int len)
{
  signed long int nr;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  while((_Bool)1)
  {
    nr=write(fd, buf, len);
    if(!(nr >= 0l))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 11)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        continue;

    }

    return nr;
  }
}

// add_timer
// file event.c line 39
void add_timer(struct timer *t, unsigned int mseconds)
{
  struct itimerspec it;
  signed int tfd;
  tfd=timerfd_create(1, 2048);
  if(!(tfd >= 0))
    log_write(3, "add_timer", 46, "timerfd_create: %m");

  else
  {
    memset((void *)&it, 0, sizeof(struct itimerspec) /*32ul*/ );
    it.it_value.tv_sec = (signed long int)(mseconds / (unsigned int)1000);
    it.it_value.tv_nsec = (signed long int)((mseconds % (unsigned int)1000) * (unsigned int)1000000);
    signed int return_value_timerfd_settime_1;
    return_value_timerfd_settime_1=timerfd_settime(tfd, 0, &it, (struct itimerspec *)(void *)0);
    if(!(return_value_timerfd_settime_1 >= 0))
      log_write(3, "add_timer", 55, "timerfd_settime: %m");

    else
    {
      signed int return_value_register_event_2;
      return_value_register_event_2=register_event(tfd, timer_handler, (void *)t);
      if(!(return_value_register_event_2 >= 0))
        log_write(3, "add_timer", 60, "failed to register timer fd");

    }
  }
}

// addr_to_str
// file net.c line 365
const char * addr_to_str(const unsigned char *addr, unsigned short int port)
{
  signed int af = 10;
  signed int addr_start_idx = 0;
  const char *ret;
  signed int tmp_post_1;
  if(!(addr[12l] == 0))
  {
    signed int oct_no = 0;
    while(addr[(signed long int)oct_no] == 0)
    {
      tmp_post_1 = oct_no;
      oct_no = oct_no + 1;
      if(tmp_post_1 >= 12)
        break;

    }
    if(oct_no == 12)
    {
      af = 2;
      addr_start_idx = 12;
    }

  }

  static char str[72l];
  ret=inet_ntop(af, (const void *)(addr + (signed long int)addr_start_idx), str, (unsigned int)sizeof(char [72l]) /*72ul*/ );
  if(ret == ((const char *)NULL))
  {
    log_write(0, "addr_to_str", 384, "PANIC: failed to convert addr to string, %m");
    abort();
  }

  if(!(port == 0))
  {
    signed int len;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(str);
    len = (signed int)return_value_strlen_2;
    snprintf(str + (signed long int)len, sizeof(char [72l]) /*72ul*/  - (unsigned long int)len, ":%d", port);
  }

  return str;
}

// atomic_create_and_write
// file util.c line 567
signed int atomic_create_and_write(const char *path, const char *buf, unsigned long int len, _Bool force_create)
{
  signed int fd;
  signed int ret;
  char tmp_path[4096l];
  snprintf(tmp_path, (unsigned long int)4096, "%s.tmp", path);
  signed int *return_value___errno_location_1;
  do
  {

  again:
    ;
    fd=open(tmp_path, 01 | 0100 | 04010000 | 0200, sd_def_fmode);
    if(fd >= 0)
      goto __CPROVER_DUMP_L7;

    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 17))
      goto __CPROVER_DUMP_L5;

    if(force_create == (_Bool)0)
      break;

    if(sd_log_level == 7)
      log_write(7, "atomic_create_and_write", 580, "clean up a temporary file %s", (const void *)tmp_path);

    unlink(tmp_path);
  }
  while((_Bool)1);
  if(sd_log_level == 7)
    log_write(7, "atomic_create_and_write", 585, "someone else is dealing with %s", (const void *)tmp_path);

  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L5:
  ;
  log_write(3, "atomic_create_and_write", 587, "failed to open temporal file %s, %m", (const void *)tmp_path);

__CPROVER_DUMP_L6:
  ;
  ret = -1;
  goto end;

__CPROVER_DUMP_L7:
  ;
  signed long int return_value_xwrite_2;
  return_value_xwrite_2=xwrite(fd, (const void *)buf, len);
  ret = (signed int)return_value_xwrite_2;
  if(!((unsigned long int)ret == len))
  {
    log_write(3, "atomic_create_and_write", 594, "failed to write %s, %m", path);
    ret = -1;
  }

  else
  {
    ret=rename(tmp_path, path);
    if(!(ret >= 0))
    {
      log_write(3, "atomic_create_and_write", 601, "failed to rename %s, %m", path);
      ret = -1;
    }

  }

close_fd:
  ;
  close(fd);

end:
  ;
  return ret;
}

// bg_printf
// file core.c line 104
static void bg_printf(const char *func, signed int line, const char *fmt, ...)
{
  void **ap;
  syslog(3, "%s(%d)", func, line);
  ap = (void **)&fmt;
  vsyslog(3, fmt, ap);
  ap = ((void **)NULL);
}

// binary_search
// file sd_inode.c line 222
static void * binary_search(void *first, void *last, void *key, unsigned long int obj_size, signed int (*cmp)(void *, void *))
{
  const char *l;
  const char *r;
  const char *m;
  signed int ret;
  l = (const char *)first;
  r = (const char *)last - (signed long int)obj_size;
  if(r >= l)
  {
    m = l + (signed long int)((((unsigned long int)(r - l) / obj_size) / (unsigned long int)2) * obj_size);
    ret=cmp((void *)key, (void *)m);
    if(!(ret >= 0))
      r = m - (signed long int)obj_size;

    else
      if(ret >= 1)
        l = m + (signed long int)obj_size;

      else
        return (void *)m;
  }

  return (void *)l;
}

// block_sighup
// file logger.c line 130
static void block_sighup(void)
{
  signed int ret;
  struct anonymous_16 new;
  struct anonymous_16 old;
  sigemptyset(&new);
  sigemptyset(&old);
  sigaddset(&new, 1);
  ret=sigprocmask(0, &new, &old);
  if(!(ret >= 0))
    syslog(3, "blocking SIGHUP failed\n");

}

// build_decode_matrix_into_space
// file fec.c line 538
static void build_decode_matrix_into_space(struct fec * const code, const signed int * const idx, const unsigned int d, unsigned char * const matrix)
{
  unsigned char i;
  unsigned char *p;
  i = (unsigned char)0;
  p = matrix;
  for( ; !((unsigned int)i >= d); p = p + (signed long int)d)
  {
    if(!((unsigned int)idx[(signed long int)i] >= d))
    {
      memset((void *)p, 0, (unsigned long int)d);
      p[(signed long int)i] = (unsigned char)1;
    }

    else
      memcpy((void *)p, (const void *)&code->enc_matrix[(signed long int)(idx[(signed long int)i] * (signed int)code->d)], (unsigned long int)d);
    i = i + 1;
  }
  _invert_mat(matrix, d);
}

// build_long_options
// file option.c line 35
struct option * build_long_options(struct sd_option *sd_opts)
{
  struct sd_option *opt;
  static struct option lopts[256l];
  static struct option *p;
  p = lopts;
  opt = sd_opts;
  for( ; !(opt->name == ((const char *)NULL)); opt = opt + 1l)
  {
    p->name = opt->name;
    p->has_arg = (signed int)opt->has_arg;
    p->flag = (signed int *)(void *)0;
    p->val = opt->ch;
    p = p + 1l;
  }
  memset((void *)p, 0, sizeof(struct option) /*32ul*/ );
  return lopts;
}

// build_short_options
// file option.c line 19
char * build_short_options(struct sd_option *sd_opts)
{
  struct sd_option *opt;
  static char sopts[256l];
  static char *p;
  p = sopts;
  opt = sd_opts;
  char *tmp_post_1;
  char *tmp_post_2;
  for( ; !(opt->name == ((const char *)NULL)); opt = opt + 1l)
  {
    tmp_post_1 = p;
    p = p + 1l;
    *tmp_post_1 = (char)opt->ch;
    if(!(opt->has_arg == (_Bool)0))
    {
      tmp_post_2 = p;
      p = p + 1l;
      *tmp_post_2 = (char)58;
    }

  }
  *p = (char)0;
  return sopts;
}

// check_gdb
// file logger.c line 753
static _Bool check_gdb(void)
{
  signed int return_value_system_1;
  return_value_system_1=system("which gdb > /dev/null");
  return return_value_system_1 == 0;
}

// check_idx
// file sockfd_cache.c line 277
static inline void check_idx(signed int idx)
{
  struct work *w;
  if(!(fds_high_watermark >= idx))
  {
    _Bool return_value_uatomic_set_true_1;
    return_value_uatomic_set_true_1=uatomic_set_true_link1(&fds_in_grow);
    if(!(return_value_uatomic_set_true_1 == (_Bool)0))
    {
      void *return_value_xmalloc_2;
      return_value_xmalloc_2=xmalloc(sizeof(struct work) /*32ul*/ );
      w = (struct work *)return_value_xmalloc_2;
      w->fn = do_grow_fds;
      w->done = grow_fds_done;
      queue_work(grow_wq, w);
    }

  }

}

// chomp
// file ../include/util.h line 106
char * chomp(char *str)
{
  char *p;
  p=strchr(str, 10);
  if(!(p == ((char *)NULL)))
    *p = (char)0;

  return str;
}

// cluster_info_get_size
// file sheepfs.h line 72
unsigned long int cluster_info_get_size(const char *path)
{
  struct strbuf *buf;
  unsigned long int len;
  char cmd[512l];
  snprintf(cmd, sizeof(char [512l]) /*512ul*/ , "dog cluster info -a %s -p %d", (const void *)sdhost, sdport);
  buf=sheepfs_run_cmd(cmd);
  if(buf == ((struct strbuf *)NULL))
    return (unsigned long int)0;

  else
  {
    len=shadow_file_write(path, buf->buf, buf->len);
    strbuf_release(buf);
    free((void *)buf);
    return len;
  }
}

// cluster_info_read
// file sheepfs.h line 71
signed int cluster_info_read(const char *path, char *buf, unsigned long int size, signed long int ignore)
{
  signed int return_value_shadow_file_read_1;
  return_value_shadow_file_read_1=shadow_file_read(path, buf, size, (signed long int)0);
  return return_value_shadow_file_read_1;
}

// config_ocache_get_size
// file sheepfs.h line 99
unsigned long int config_ocache_get_size(const char *path)
{
  return sizeof(signed int) /*4ul*/  + (unsigned long int)1;
}

// config_ocache_read
// file sheepfs.h line 97
signed int config_ocache_read(const char *path, char *buf, unsigned long int size, signed long int ignore)
{
  snprintf(buf, size, "%d\n", sheepfs_object_cache);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buf);
  return (signed int)return_value_strlen_1;
}

// config_ocache_write
// file sheepfs.h line 98
signed int config_ocache_write(const char *path, const char *buf, unsigned long int size, signed long int ignore)
{
  signed int value;
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(buf, "%d\n", &value);
  if(!(return_value_sscanf_1 == 1))
    return -22;

  else
  {
    sheepfs_object_cache = (signed int)!(!(value != 0));
    return (signed int)size;
  }
}

// config_pcache_get_size
// file sheepfs.h line 95
unsigned long int config_pcache_get_size(const char *path)
{
  return sizeof(signed int) /*4ul*/  + (unsigned long int)1;
}

// config_pcache_read
// file sheepfs.h line 93
signed int config_pcache_read(const char *path, char *buf, unsigned long int size, signed long int ignore)
{
  snprintf(buf, size, "%d\n", sheepfs_page_cache);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buf);
  return (signed int)return_value_strlen_1;
}

// config_pcache_write
// file sheepfs.h line 94
signed int config_pcache_write(const char *path, const char *buf, unsigned long int size, signed long int ignore)
{
  signed int value;
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(buf, "%d", &value);
  if(!(return_value_sscanf_1 == 1))
    return -22;

  else
  {
    sheepfs_page_cache = (signed int)!(!(value != 0));
    return (signed int)size;
  }
}

// config_sheep_info_get_size
// file sheepfs.h line 103
unsigned long int config_sheep_info_get_size(const char *path)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(sdhost);
  return return_value_strlen_1 + (unsigned long int)1 + sizeof(signed int) /*4ul*/  + (unsigned long int)1;
}

// config_sheep_info_read
// file sheepfs.h line 101
signed int config_sheep_info_read(const char *path, char *buf, unsigned long int size, signed long int ignore)
{
  snprintf(buf, size, "%s:%d\n", (const void *)sdhost, sdport);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buf);
  return (signed int)return_value_strlen_1;
}

// config_sheep_info_write
// file sheepfs.h line 102
signed int config_sheep_info_write(const char *path, const char *buf, unsigned long int size, signed long int ignore)
{
  char *ip;
  char *pt;
  unsigned int port;
  ip=strtok((char *)buf, ":");
  if(ip == ((char *)NULL))
    return -22;

  else
  {
    pt=strtok((char *)(void *)0, ":");
    if(pt == ((char *)NULL))
      return -22;

    else
    {
      signed int return_value_sscanf_1;
      return_value_sscanf_1=sscanf(pt, "%u", &port);
      if(!(return_value_sscanf_1 == 1))
        return -22;

      else
      {
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(ip);
        memcpy((void *)sdhost, (const void *)ip, return_value_strlen_2);
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(ip);
        sdhost[(signed long int)return_value_strlen_3] = (char)0;
        sdport = (signed int)port;
        signed int return_value_reset_socket_pool_4;
        return_value_reset_socket_pool_4=reset_socket_pool();
        if(!(return_value_reset_socket_pool_4 >= 0))
          return -22;

        else
          return (signed int)size;
      }
    }
  }
}

// conn_rx_off
// file net.c line 50
signed int conn_rx_off(struct connection *conn)
{
  conn->events = conn->events & (unsigned int)~1;
  signed int return_value_modify_event_1;
  return_value_modify_event_1=modify_event(conn->fd, conn->events);
  return return_value_modify_event_1;
}

// conn_rx_on
// file net.c line 57
signed int conn_rx_on(struct connection *conn)
{
  conn->events = conn->events | (unsigned int)1;
  signed int return_value_modify_event_1;
  return_value_modify_event_1=modify_event(conn->fd, conn->events);
  return return_value_modify_event_1;
}

// conn_tx_off
// file net.c line 36
signed int conn_tx_off(struct connection *conn)
{
  conn->events = conn->events & (unsigned int)~4;
  signed int return_value_modify_event_1;
  return_value_modify_event_1=modify_event(conn->fd, conn->events);
  return return_value_modify_event_1;
}

// conn_tx_on
// file net.c line 43
signed int conn_tx_on(struct connection *conn)
{
  conn->events = conn->events | (unsigned int)4;
  signed int return_value_modify_event_1;
  return_value_modify_event_1=modify_event(conn->fd, conn->events);
  return return_value_modify_event_1;
}

// connect_to
// file ../include/net.h line 46
signed int connect_to(const char *name, signed int port)
{
  char buf[64l];
  char hbuf[1025l];
  char sbuf[32l];
  signed int fd;
  signed int ret;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *res0;
  struct linger linger_opt = { .l_onoff=1, .l_linger=0 };
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  snprintf(buf, sizeof(char [64l]) /*64ul*/ , "%d", port);
  hints.ai_socktype = 1;
  ret=getaddrinfo(name, buf, &hints, &res0);
  signed int *return_value___errno_location_1;
  if(!(ret == 0))
  {
    log_write(3, "connect_to", 152, "failed to get address info: %m");
    return -1;
  }

  else
  {
    res = res0;
    for( ; !(res == ((struct addrinfo *)NULL)); res = res->ai_next)
    {
      ret=getnameinfo(res->ai_addr, res->ai_addrlen, hbuf, (unsigned int)sizeof(char [1025l]) /*1025ul*/ , sbuf, (unsigned int)sizeof(char [32l]) /*32ul*/ , 1 | 2);
      if(ret == 0)
      {
        fd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
        if(fd >= 0)
        {
          ret=setsockopt(fd, 1, 13, (const void *)&linger_opt, (unsigned int)sizeof(struct linger) /*8ul*/ );
          if(!(ret == 0))
          {
            log_write(3, "connect_to", 170, "failed to set SO_LINGER: %m");
            close(fd);
          }

          else
          {
            ret=set_snd_timeout(fd);
            if(!(ret == 0))
            {
              log_write(3, "connect_to", 177, "failed to set send timeout: %m");
              close(fd);
              break;
            }

            ret=set_rcv_timeout(fd);
            if(!(ret == 0))
            {
              log_write(3, "connect_to", 184, "failed to set recv timeout: %m");
              close(fd);
              break;
            }

            do
            {

            reconnect:
              ;
              ret=connect(fd, res->ai_addr, res->ai_addrlen);
              if(ret == 0)
                goto __CPROVER_DUMP_L6;

              return_value___errno_location_1=__errno_location();
            }
            while(*return_value___errno_location_1 == 4);
            log_write(3, "connect_to", 193, "failed to connect to %s:%d: %m", name, port);
            close(fd);
            goto __CPROVER_DUMP_L8;

          __CPROVER_DUMP_L6:
            ;
            ret=set_nodelay(fd);
            if(!(ret == 0))
            {
              log_write(3, "connect_to", 200, "%m");
              close(fd);
              break;
            }

            else
              goto success;
          }
        }

      }


    __CPROVER_DUMP_L8:
      ;
    }
    fd = -1;

  success:
    ;
    freeaddrinfo(res0);
    if(sd_log_level == 7)
      log_write(7, "connect_to", 209, "%d, %s:%d", fd, name, port);

    return fd;
  }
}

// connect_to_addr
// file ../include/net.h line 71
static inline signed int connect_to_addr(const unsigned char *addr, signed int port)
{
  const char *return_value_addr_to_str_1;
  return_value_addr_to_str_1=addr_to_str(addr, (unsigned short int)0);
  signed int return_value_connect_to_2;
  return_value_connect_to_2=connect_to(return_value_addr_to_str_1, port);
  return return_value_connect_to_2;
}

// container_rmdir
// file sheepfs.h line 122
signed int container_rmdir(const char *path)
{
  signed int return_value_shadow_dir_delete_1;
  return_value_shadow_dir_delete_1=shadow_dir_delete(path);
  return return_value_shadow_dir_delete_1;
}

// count_data_objs
// file ../include/sheepdog_proto.h line 411
static inline unsigned long int count_data_objs(struct sd_inode *inode)
{
  return ((inode->vdi_size + (1UL << 22)) - (unsigned long int)1) / (1UL << 22);
}

// crash_handler
// file logger.c line 534
static void crash_handler(signed int signo)
{
  _Bool return_value_is_sheep_dead_3;
  return_value_is_sheep_dead_3=is_sheep_dead(signo);
  if(!(return_value_is_sheep_dead_3 == (_Bool)0))
    log_write(3, "crash_handler", 537, "sheep pid %d exited unexpectedly.", sheep_pid);

  else
  {
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    char *return_value_strsignal_2;
    return_value_strsignal_2=strsignal(signo);
    log_write(3, "crash_handler", 540, "logger pid %d exits unexpectedly (%s).", return_value_getpid_1, return_value_strsignal_2);
    sd_backtrace();
  }
  log_flush();
  closelog();
  free_logarea();
  _Bool return_value_is_sheep_dead_4;
  return_value_is_sheep_dead_4=is_sheep_dead(signo);
  if(!(return_value_is_sheep_dead_4 == (_Bool)0))
    exit(1);

  reraise_crash_signal(signo, 1);
}

// create_cluster_layout
// file sheepfs.h line 73
signed int create_cluster_layout(void)
{
  signed int return_value_shadow_dir_create_1;
  return_value_shadow_dir_create_1=shadow_dir_create("/cluster");
  if(!(return_value_shadow_dir_create_1 >= 0))
    return -1;

  else
  {
    signed int return_value_shadow_file_create_2;
    return_value_shadow_file_create_2=shadow_file_create("/cluster/info");
    if(!(return_value_shadow_file_create_2 >= 0))
      return -1;

    else
    {
      signed int return_value_sheepfs_set_op_3;
      return_value_sheepfs_set_op_3=sheepfs_set_op("/cluster/info", (unsigned int)1);
      if(!(return_value_sheepfs_set_op_3 >= 0))
        return -1;

      else
        return 0;
    }
  }
}

// create_config_layout
// file sheepfs.h line 91
signed int create_config_layout(void)
{
  signed int return_value_shadow_dir_create_1;
  return_value_shadow_dir_create_1=shadow_dir_create("/config");
  if(!(return_value_shadow_dir_create_1 >= 0))
    return -1;

  else
  {
    signed int return_value_shadow_file_create_2;
    return_value_shadow_file_create_2=shadow_file_create("/config/page_cache");
    if(!(return_value_shadow_file_create_2 >= 0))
      return -1;

    else
    {
      signed int return_value_sheepfs_set_op_3;
      return_value_sheepfs_set_op_3=sheepfs_set_op("/config/page_cache", (unsigned int)7);
      if(!(return_value_sheepfs_set_op_3 >= 0))
        return -1;

      else
      {
        signed int return_value_shadow_file_create_4;
        return_value_shadow_file_create_4=shadow_file_create("/config/object_cache");
        if(!(return_value_shadow_file_create_4 >= 0))
          return -1;

        else
        {
          signed int return_value_sheepfs_set_op_5;
          return_value_sheepfs_set_op_5=sheepfs_set_op("/config/object_cache", (unsigned int)8);
          if(!(return_value_sheepfs_set_op_5 >= 0))
            return -1;

          else
          {
            signed int return_value_shadow_file_create_6;
            return_value_shadow_file_create_6=shadow_file_create("/config/sheep_info");
            if(!(return_value_shadow_file_create_6 >= 0))
              return -1;

            else
            {
              signed int return_value_sheepfs_set_op_7;
              return_value_sheepfs_set_op_7=sheepfs_set_op("/config/sheep_info", (unsigned int)9);
              if(!(return_value_sheepfs_set_op_7 >= 0))
                return -1;

              else
                return 0;
            }
          }
        }
      }
    }
  }
}

// create_http_layout
// file sheepfs.h line 107
signed int create_http_layout(void)
{
  signed int return_value_shadow_dir_create_1;
  return_value_shadow_dir_create_1=shadow_dir_create("/http");
  if(!(return_value_shadow_dir_create_1 >= 0))
    return -1;

  else
  {
    signed int return_value_shadow_file_create_2;
    return_value_shadow_file_create_2=shadow_file_create("/http/address");
    if(!(return_value_shadow_file_create_2 >= 0))
      return -1;

    else
    {
      signed int return_value_sheepfs_set_op_3;
      return_value_sheepfs_set_op_3=sheepfs_set_op("/http/address", (unsigned int)11);
      if(!(return_value_sheepfs_set_op_3 >= 0))
        return -1;

      else
      {
        signed int return_value_shadow_file_create_4;
        return_value_shadow_file_create_4=shadow_file_create("/http/object");
        if(!(return_value_shadow_file_create_4 >= 0))
          return -1;

        else
        {
          signed int return_value_sheepfs_set_op_5;
          return_value_sheepfs_set_op_5=sheepfs_set_op("/http/object", (unsigned int)12);
          if(!(return_value_sheepfs_set_op_5 >= 0))
            return -1;

          else
            return 0;
        }
      }
    }
  }
}

// create_listen_ports
// file net.c line 64
signed int create_listen_ports(const char *bindaddr, signed int port, signed int (*callback)(signed int, void *), void *data)
{
  char servname[64l];
  signed int fd;
  signed int ret;
  signed int opt;
  signed int success = 0;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *res0;
  memset((void *)servname, 0, sizeof(char [64l]) /*64ul*/ );
  snprintf(servname, sizeof(char [64l]) /*64ul*/ , "%d", port);
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_socktype = 1;
  hints.ai_flags = 0x0001;
  ret=getaddrinfo(bindaddr, servname, &hints, &res0);
  if(!(ret == 0))
  {
    log_write(3, "create_listen_ports", 81, "failed to get address info: %m");
    return 1;
  }

  else
  {
    res = res0;
    for( ; !(res == ((struct addrinfo *)NULL)); res = res->ai_next)
    {
      fd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
      if(fd >= 0)
      {
        opt = 1;
        ret=setsockopt(fd, 1, 2, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
        if(!(ret == 0))
          log_write(3, "create_listen_ports", 94, "failed to set SO_REUSEADDR: %m");

        opt = 1;
        if(res->ai_family == 10)
        {
          ret=setsockopt(fd, 41, 26, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
          if(ret == 0)
            goto __CPROVER_DUMP_L4;

          close(fd);
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          ret=bind(fd, res->ai_addr, res->ai_addrlen);
          if(!(ret == 0))
          {
            log_write(3, "create_listen_ports", 108, "failed to bind server socket: %m");
            close(fd);
          }

          else
          {
            ret=listen(fd, 128);
            if(!(ret == 0))
            {
              log_write(3, "create_listen_ports", 115, "failed to listen on server socket: %m");
              close(fd);
            }

            else
            {
              ret=callback(fd, data);
              if(!(ret == 0))
                close(fd);

              else
                success = success + 1;
            }
          }
        }
      }

    }
    freeaddrinfo(res0);
    if(success == 0)
      log_write(3, "create_listen_ports", 132, "failed to create a listening port");

    return (signed int)!(success != 0);
  }
}

// create_node_layout
// file sheepfs.h line 88
signed int create_node_layout(void)
{
  signed int return_value_shadow_dir_create_1;
  return_value_shadow_dir_create_1=shadow_dir_create("/node");
  if(!(return_value_shadow_dir_create_1 >= 0))
    return -1;

  else
  {
    signed int return_value_shadow_file_create_2;
    return_value_shadow_file_create_2=shadow_file_create("/node/info");
    if(!(return_value_shadow_file_create_2 >= 0))
      return -1;

    else
    {
      signed int return_value_sheepfs_set_op_3;
      return_value_sheepfs_set_op_3=sheepfs_set_op("/node/info", (unsigned int)5);
      if(!(return_value_sheepfs_set_op_3 >= 0))
        return -1;

      else
      {
        signed int return_value_shadow_file_create_4;
        return_value_shadow_file_create_4=shadow_file_create("/node/list");
        if(!(return_value_shadow_file_create_4 >= 0))
          return -1;

        else
        {
          signed int return_value_sheepfs_set_op_5;
          return_value_sheepfs_set_op_5=sheepfs_set_op("/node/list", (unsigned int)6);
          if(!(return_value_sheepfs_set_op_5 >= 0))
            return -1;

          else
            return 0;
        }
      }
    }
  }
}

// create_ordered_work_queue
// file work.c line 440
struct work_queue * create_ordered_work_queue(const char *name)
{
  struct work_queue *return_value_create_work_queue_1;
  return_value_create_work_queue_1=create_work_queue(name, (enum wq_thread_control)WQ_ORDERED);
  return return_value_create_work_queue_1;
}

// create_sheepfs_layout
// file core.c line 314
static signed int create_sheepfs_layout(void)
{
  signed int return_value_create_cluster_layout_1;
  return_value_create_cluster_layout_1=create_cluster_layout();
  if(!(return_value_create_cluster_layout_1 >= 0))
    return -1;

  else
  {
    signed int return_value_create_vdi_layout_2;
    return_value_create_vdi_layout_2=create_vdi_layout();
    if(!(return_value_create_vdi_layout_2 >= 0))
      return -1;

    else
    {
      signed int return_value_create_volume_layout_3;
      return_value_create_volume_layout_3=create_volume_layout();
      if(!(return_value_create_volume_layout_3 >= 0))
        return -1;

      else
      {
        signed int return_value_create_node_layout_4;
        return_value_create_node_layout_4=create_node_layout();
        if(!(return_value_create_node_layout_4 >= 0))
          return -1;

        else
        {
          signed int return_value_create_config_layout_5;
          return_value_create_config_layout_5=create_config_layout();
          if(!(return_value_create_config_layout_5 >= 0))
            return -1;

          else
          {
            signed int return_value_create_http_layout_6;
            return_value_create_http_layout_6=create_http_layout();
            if(!(return_value_create_http_layout_6 >= 0))
              return -1;

            else
              return 0;
          }
        }
      }
    }
  }
}

// create_unix_domain_socket
// file net.c line 536
signed int create_unix_domain_socket(const char *unix_path, signed int (*callback)(signed int, void *), void *data)
{
  signed int fd;
  signed int ret;
  struct sockaddr_un addr;
  addr.sun_family = (unsigned short int)1;
  pstrcpy(addr.sun_path, (signed int)sizeof(char [108l]) /*108ul*/ , unix_path);
  fd=socket((signed int)addr.sun_family, 1, 0);
  if(!(fd >= 0))
  {
    log_write(3, "create_unix_domain_socket", 547, "failed to create socket, %m");
    return -1;
  }

  else
  {
    ret=bind(fd, &addr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
    if(!(ret == 0))
      log_write(3, "create_unix_domain_socket", 553, "failed to bind socket: %m");

    else
    {
      ret=listen(fd, 128);
      if(!(ret == 0))
        log_write(3, "create_unix_domain_socket", 559, "failed to listen on socket: %m");

      else
      {
        ret=callback(fd, data);
        if(ret == 0)
          return 0;

      }
    }

  err:
    ;
    close(fd);
    return -1;
  }
}

// create_vdi_layout
// file sheepfs.h line 76
signed int create_vdi_layout(void)
{
  signed int return_value_shadow_dir_create_1;
  return_value_shadow_dir_create_1=shadow_dir_create("/vdi");
  if(!(return_value_shadow_dir_create_1 >= 0))
    return -1;

  else
  {
    signed int return_value_shadow_file_create_2;
    return_value_shadow_file_create_2=shadow_file_create("/vdi/list");
    if(!(return_value_shadow_file_create_2 >= 0))
      return -1;

    else
    {
      signed int return_value_sheepfs_set_op_3;
      return_value_sheepfs_set_op_3=sheepfs_set_op("/vdi/list", (unsigned int)2);
      if(!(return_value_sheepfs_set_op_3 >= 0))
        return -1;

      else
      {
        signed int return_value_shadow_file_create_4;
        return_value_shadow_file_create_4=shadow_file_create("/vdi/mount");
        if(!(return_value_shadow_file_create_4 >= 0))
          return -1;

        else
        {
          signed int return_value_sheepfs_set_op_5;
          return_value_sheepfs_set_op_5=sheepfs_set_op("/vdi/mount", (unsigned int)3);
          if(!(return_value_sheepfs_set_op_5 >= 0))
            return -1;

          else
          {
            signed int return_value_shadow_file_create_6;
            return_value_shadow_file_create_6=shadow_file_create("/vdi/unmount");
            if(!(return_value_shadow_file_create_6 >= 0))
              return -1;

            else
            {
              signed int return_value_sheepfs_set_op_7;
              return_value_sheepfs_set_op_7=sheepfs_set_op("/vdi/unmount", (unsigned int)4);
              if(!(return_value_sheepfs_set_op_7 >= 0))
                return -1;

              else
                return 0;
            }
          }
        }
      }
    }
  }
}

// create_volume_layout
// file sheepfs.h line 60
signed int create_volume_layout(void)
{
  signed int return_value_shadow_dir_create_1;
  return_value_shadow_dir_create_1=shadow_dir_create("/volume");
  if(!(return_value_shadow_dir_create_1 >= 0))
    return -1;

  else
    return 0;
}

// create_work_queue
// file work.c line 404
struct work_queue * create_work_queue(const char *name, enum wq_thread_control tc)
{
  signed int ret;
  struct wq_info *wi;
  void *return_value_xzalloc_1;
  return_value_xzalloc_1=xzalloc(sizeof(struct wq_info) /*264ul*/ );
  wi = (struct wq_info *)return_value_xzalloc_1;
  wi->name = name;
  wi->tc = tc;
  INIT_LIST_HEAD(&wi->q.pending_list);
  INIT_LIST_HEAD(&wi->finished_list);
  sd_cond_init(&wi->pending_cond);
  sd_init_mutex(&wi->finished_lock);
  sd_init_mutex(&wi->pending_lock);
  sd_init_mutex(&wi->startup_lock);
  ret=create_worker_threads(wi, (unsigned long int)1);
  if(ret >= 0)
  {
    list_add(&wi->list, &wq_info_list);
    return &wi->q;
  }

  else
  {

  destroy_threads:
    ;
    sd_mutex_unlock(&wi->startup_lock);
    sd_destroy_cond(&wi->pending_cond);
    sd_destroy_mutex(&wi->pending_lock);
    sd_destroy_mutex(&wi->finished_lock);
    free((void *)wi);
    return (struct work_queue *)(void *)0;
  }
}

// create_worker_threads
// file work.c line 249
static signed int create_worker_threads(struct wq_info *wi, unsigned long int nr_threads)
{
  unsigned long int thread;
  signed int ret;
  sd_mutex_lock(&wi->startup_lock);
  while(!(wi->nr_threads >= nr_threads))
  {
    ret=pthread_create(&thread, (const union pthread_attr_t *)(void *)0, worker_routine, (void *)wi);
    if(!(ret == 0))
    {
      log_write(3, "create_worker_threads", 258, "failed to create worker thread: %m");
      sd_mutex_unlock(&wi->startup_lock);
      return -1;
    }

    wi->nr_threads = wi->nr_threads + 1ul;
    if(sd_log_level == 7)
      log_write(7, "create_worker_threads", 263, "create thread %s %zu", wi->name, wi->nr_threads);

  }
  sd_mutex_unlock(&wi->startup_lock);
  return 0;
}

// curl_get_object_size
// file http.c line 71
static unsigned long int curl_get_object_size(const char *url)
{
  void *curl;
  enum anonymous_19 res;
  double content_length = (double)0;
  curl=curl_easy_init();
  enum anonymous_19 tmp_statement_expression_1;
  if(curl == NULL)
    fs_printf("curl_get_object_size", 79, "Failed to init curl");

  else
  {
    signed int curl_get_object_size__1__2___curl_opt = CURLOPT_FAILONERROR;
    curl_easy_setopt(curl, (enum anonymous_20)curl_get_object_size__1__2___curl_opt, 1);
    signed int curl_get_object_size__1__3___curl_opt = CURLOPT_NOBODY;
    curl_easy_setopt(curl, (enum anonymous_20)curl_get_object_size__1__3___curl_opt, 1);
    signed int curl_get_object_size__1__4___curl_opt = CURLOPT_CUSTOMREQUEST;
    curl_easy_setopt(curl, (enum anonymous_20)curl_get_object_size__1__4___curl_opt, (const void *)"HEAD");
    signed int _curl_opt = CURLOPT_URL;
    curl_easy_setopt(curl, (enum anonymous_20)_curl_opt, url);
    res=curl_easy_perform(curl);
    if((signed int)res == CURLE_OK)
    {
      signed int _curl_info = CURLINFO_CONTENT_LENGTH_DOWNLOAD;
      tmp_statement_expression_1=curl_easy_getinfo(curl, (enum anonymous_17)_curl_info, &content_length);
      res = tmp_statement_expression_1;
      if(!((signed int)res == CURLE_OK))
      {
        const char *return_value_curl_easy_strerror_2;
        return_value_curl_easy_strerror_2=curl_easy_strerror(res);
        fs_printf("curl_get_object_size", 93, "Failed to get size of object %s", return_value_curl_easy_strerror_2);
        content_length = (double)0;
      }

    }

  }

out:
  ;
  curl_easy_cleanup(curl);
  return (unsigned long int)content_length;
}

// curl_object_exists
// file http.c line 175
static _Bool curl_object_exists(const char *url)
{
  void *curl;
  enum anonymous_19 res;
  _Bool ret = (_Bool)0;
  curl=curl_easy_init();
  if(curl == NULL)
    fs_printf("curl_object_exists", 183, "Failed to init curl");

  else
  {
    signed int _curl_opt = CURLOPT_FAILONERROR;
    curl_easy_setopt(curl, (enum anonymous_20)_curl_opt, 1);
    signed int curl_object_exists__1__3___curl_opt = CURLOPT_NOBODY;
    curl_easy_setopt(curl, (enum anonymous_20)curl_object_exists__1__3___curl_opt, 1);
    signed int curl_object_exists__1__4___curl_opt = CURLOPT_CUSTOMREQUEST;
    curl_easy_setopt(curl, (enum anonymous_20)curl_object_exists__1__4___curl_opt, (const void *)"HEAD");
    signed int curl_object_exists__1__5___curl_opt = CURLOPT_URL;
    curl_easy_setopt(curl, (enum anonymous_20)curl_object_exists__1__5___curl_opt, url);
    res=curl_easy_perform(curl);
    if((signed int)res == CURLE_OK)
      ret = (_Bool)1;

    else
    {
      const char *return_value_curl_easy_strerror_1;
      return_value_curl_easy_strerror_1=curl_easy_strerror(res);
      fs_printf("curl_object_exists", 196, "Failed to call libcurl res: %s, url: %s", return_value_curl_easy_strerror_1, url);
    }
  }

out:
  ;
  curl_easy_cleanup(curl);
  return ret;
}

// curl_read_object
// file http.c line 120
static unsigned long int curl_read_object(const char *url, char *buf, unsigned long int size, signed long int offset)
{
  void *curl;
  enum anonymous_19 res;
  char header[4096l];
  double content_length;
  struct buffer_s buffer = { .mem=((char *)NULL), .current_size=0ul, .total_size=0ul };
  struct curl_slist *headers = (struct curl_slist *)(void *)0;
  curl=curl_easy_init();
  enum anonymous_19 tmp_statement_expression_1;
  if(curl == NULL)
    fs_printf("curl_read_object", 132, "Failed to init curl");

  else
  {
    snprintf(header, sizeof(char [4096l]) /*4096ul*/ , "Range: bytes=%lu-%lu", offset, ((unsigned long int)offset + size) - (unsigned long int)1);
    headers=curl_slist_append(headers, header);
    signed int _curl_opt = CURLOPT_FAILONERROR;
    curl_easy_setopt(curl, (enum anonymous_20)_curl_opt, 1);
    signed int curl_read_object__1__3___curl_opt = CURLOPT_URL;
    curl_easy_setopt(curl, (enum anonymous_20)curl_read_object__1__3___curl_opt, url);
    signed int curl_read_object__1__4___curl_opt = CURLOPT_HTTPHEADER;
    curl_easy_setopt(curl, (enum anonymous_20)curl_read_object__1__4___curl_opt, headers);
    signed int curl_read_object__1__5___curl_opt = CURLOPT_CUSTOMREQUEST;
    curl_easy_setopt(curl, (enum anonymous_20)curl_read_object__1__5___curl_opt, (const void *)"GET");
    signed int curl_read_object__1__6___curl_opt = CURLOPT_WRITEFUNCTION;
    curl_easy_setopt(curl, (enum anonymous_20)curl_read_object__1__6___curl_opt, write_cb);
    buffer.mem = buf;
    buffer.total_size = size;
    signed int curl_read_object__1__7___curl_opt = CURLOPT_WRITEDATA;
    curl_easy_setopt(curl, (enum anonymous_20)curl_read_object__1__7___curl_opt, &buffer);
    res=curl_easy_perform(curl);
    if((signed int)res == CURLE_OK)
    {
      signed int _curl_info = CURLINFO_CONTENT_LENGTH_DOWNLOAD;
      tmp_statement_expression_1=curl_easy_getinfo(curl, (enum anonymous_17)_curl_info, &content_length);
      res = tmp_statement_expression_1;
      if(!((signed int)res == CURLE_OK))
      {
        const char *return_value_curl_easy_strerror_2;
        return_value_curl_easy_strerror_2=curl_easy_strerror(res);
        fs_printf("curl_read_object", 153, "Failed to getinfo res: %s", return_value_curl_easy_strerror_2);
        size = (unsigned long int)0;
      }

      if(!(size >= (unsigned long int)content_length))
      {
        fs_printf("curl_read_object", 160, "Failed to get correct CONTENT_LENGTH, content_length: %lu, get_size: %lu", (unsigned long int)content_length, size);
        size = (unsigned long int)0;
      }

      else
        if(sd_log_level == 7)
          log_write(7, "curl_read_object", 163, "Read out %lu data from %s", size, url);

    }

    else
    {
      const char *return_value_curl_easy_strerror_3;
      return_value_curl_easy_strerror_3=curl_easy_strerror(res);
      fs_printf("curl_read_object", 166, "Failed to call libcurl res: %s, url: %s", return_value_curl_easy_strerror_3, url);
      size = (unsigned long int)0;
    }
  }

out:
  ;
  curl_slist_free_all(headers);
  curl_easy_cleanup(curl);
  return size;
}

// data_is_missing
// file fec.c line 618
static inline _Bool data_is_missing(const unsigned char **dp, signed int d)
{
  signed int i = 0;
  for( ; !(i >= d); i = i + 1)
    if(dp[(signed long int)i] == ((const unsigned char *)NULL))
      return (_Bool)1;

  return (_Bool)0;
}

// data_oid_to_idx
// file ../include/sheepdog_proto.h line 430
static inline unsigned long int data_oid_to_idx(unsigned long int oid)
{
  return oid & (1ULL << 32) - (unsigned long int)1;
}

// data_to_str
// file util.c line 417
const char * data_to_str(void *data, unsigned long int data_length)
{
  data_length = data_length < (unsigned long int)256 ? data_length : (unsigned long int)256;
  if(data == NULL)
    return "(null)";

  else
  {
    void *return_value_memchr_1;
    return_value_memchr_1=memchr(data, 0, data_length);
    if(!(return_value_memchr_1 == NULL))
      return (const char *)data;

    else
      return "(not string)";
  }
}

// decode_prepare
// file fec.c line 591
static inline void decode_prepare(struct fec *ctx, const unsigned char **dp, const unsigned char **out, signed int *outidx)
{
  signed int i;
  signed int p = 0;
  i = (signed int)ctx->d;
  for( ; !(i >= (signed int)ctx->dp); i = i + 1)
    if(!(dp[(signed long int)i] == ((const unsigned char *)NULL)))
    {
      p = i;
      break;
    }

  i = 0;
  for( ; !(i >= (signed int)ctx->d); i = i + 1)
    if(!(dp[(signed long int)i] == ((const unsigned char *)NULL)))
    {
      out[(signed long int)i] = dp[(signed long int)i];
      outidx[(signed long int)i] = i;
    }

    else
    {
      out[(signed long int)i] = dp[(signed long int)p];
      outidx[(signed long int)i] = p;
      do
      {
        p = p + 1;
        if(p >= (signed int)ctx->dp)
          break;

        if(!(dp[(signed long int)p] == ((const unsigned char *)NULL)))
          break;

      }
      while((_Bool)1);
    }
}

// destroy_all_slots
// file sockfd_cache.c line 141
static inline void destroy_all_slots(struct sockfd_cache_entry *entry)
{
  signed int i = 0;
  for( ; !(i >= fds_count); i = i + 1)
    if(!((entry->fds + (signed long int)i)->fd == -1))
      close((entry->fds + (signed long int)i)->fd);

}

// destroy_socket_pool
// file volume.c line 366
static void destroy_socket_pool(signed int *array, signed int len)
{
  signed int i = 0;
  for( ; !(i >= len); i = i + 1)
    close(array[(signed long int)i]);
}

// do_event_loop
// file event.c line 190
static void do_event_loop(signed int timeout, _Bool sort_with_prio)
{
  signed int i;
  signed int nr;

refresh:
  ;
  event_loop_refresh = (_Bool)0;
  nr=epoll_wait(efd, events, nr_events, timeout);
  if(!(sort_with_prio == (_Bool)0))
  {
    if(nr >= 2)
      qsort((void *)events, (unsigned long int)nr, sizeof(struct epoll_event) /*12ul*/ , (signed int (*)(const void *, const void *))epoll_event_cmp);

  }

  if(!(nr >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 4)
      goto __CPROVER_DUMP_L7;

    log_write(3, "do_event_loop", 203, "epoll_wait failed: %m");
    exit(1);
  }

  else
    if(!(nr == 0))
    {
      i = 0;
      if(!(i >= nr))
      {
        struct event_info *ei = (struct event_info *)(events + (signed long int)i)->data.ptr;
        ei->handler(ei->fd, (signed int)(events + (signed long int)i)->events, ei->data);
        i = i + 1;
      }

    }


__CPROVER_DUMP_L7:
  ;
}

// do_grow_fds
// file sockfd_cache.c line 247
static void do_grow_fds(struct work *work)
{
  struct sockfd_cache_entry *entry;
  signed int old_fds_count;
  signed int new_fds_count;
  signed int new_size;
  signed int i;
  if(sd_log_level == 7)
    log_write(7, "do_grow_fds", 252, "%d", fds_count);

  sd_write_lock_link1(&sockfd_cache.lock);
  old_fds_count = fds_count;
  new_fds_count = fds_count * 2;
  new_size = (signed int)(sizeof(struct sockfd_cache_fd) /*16ul*/  * (unsigned long int)fds_count * (unsigned long int)2);
  struct rb_node *__p257;
  __p257=rb_first(&sockfd_cache.root);
  struct rb_node *__n257;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  struct sockfd_cache_entry *tmp_statement_expression_2;
  do
  {
    if(!(__p257 == ((struct rb_node *)NULL)))
    {
      __n257=rb_next(__p257);
      tmp_if_expr_1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
    {
      const struct rb_node *__mptr = __p257;
      tmp_statement_expression_2 = (struct sockfd_cache_entry *)((char *)__mptr - (signed long int)0ul);
      entry = tmp_statement_expression_2;
      tmp_if_expr_3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
      break;

    void *return_value_xrealloc_4;
    return_value_xrealloc_4=xrealloc((void *)entry->fds, (unsigned long int)new_size);
    entry->fds = (struct sockfd_cache_fd *)return_value_xrealloc_4;
    i = old_fds_count;
    for( ; !(i >= new_fds_count); i = i + 1)
    {
      (entry->fds + (signed long int)i)->fd = -1;
      uatomic_set_false_link1(&(entry->fds + (signed long int)i)->in_use);
    }
    __p257 = __n257;
  }
  while((_Bool)1);
  fds_count = fds_count * 2;
  fds_high_watermark = (fds_count * 3) / 4;
  sd_rw_unlock_link1(&sockfd_cache.lock);
}

// do_nothing
// file util.c line 28
static void do_nothing(unsigned long int size)
{
  ;
}

// do_read
// file net.c line 213
signed int do_read(signed int sockfd, void *buf, signed int len, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count)
{
  signed int ret;
  signed int repeat = (signed int)max_count;
  signed long int return_value_read_1;
  _Bool tmp_if_expr_3;
  _Bool return_value;
  do
  {

  reread:
    ;
    return_value_read_1=read(sockfd, buf, (unsigned long int)len);
    ret = (signed int)return_value_read_1;
    if(ret == 0)
    {
      if(sd_log_level == 7)
        log_write(7, "do_read", 220, "connection is closed (%d bytes left)", len);

      return 1;
    }

    if(!(ret >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(*return_value___errno_location_2 == 4)
        goto reread;

      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      if(*return_value___errno_location_4 == 11)
      {
        if(!(repeat == 0))
        {
          if(need_retry == ((_Bool (*)(unsigned int))NULL))
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value=need_retry(epoch);
            tmp_if_expr_3 = return_value != (_Bool)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_3)
          {
            repeat = repeat - 1;
            goto reread;
          }

        }

      }

      log_write(3, "do_read", 236, "failed to read from socket: %d, %m", ret);
      return 1;
    }

    len = len - ret;
    buf = (void *)((char *)buf + (signed long int)ret);
  }
  while(!(len == 0));
  return 0;
}

// do_write
// file net.c line 261
static signed int do_write(signed int sockfd, struct msghdr *msg, signed int len, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count)
{
  signed int ret;
  signed int repeat = (signed int)max_count;
  signed long int return_value_sendmsg_1;
  _Bool tmp_if_expr_3;
  _Bool return_value;
  do
  {

  rewrite:
    ;
    return_value_sendmsg_1=sendmsg(sockfd, msg, 0);
    ret = (signed int)return_value_sendmsg_1;
    if(!(ret >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(*return_value___errno_location_2 == 4)
        goto rewrite;

      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      if(*return_value___errno_location_4 == 11)
      {
        if(!(repeat == 0))
        {
          if(need_retry == ((_Bool (*)(unsigned int))NULL))
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value=need_retry(epoch);
            tmp_if_expr_3 = return_value != (_Bool)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_3)
          {
            repeat = repeat - 1;
            goto rewrite;
          }

        }

      }

      log_write(3, "do_write", 281, "failed to write to socket: %m");
      return 1;
    }

    len = len - ret;
    if(len == 0)
      break;

    forward_iov(msg, ret);
  }
  while((_Bool)1);
  return 0;
}

// do_writev2
// file net.c line 587
signed int do_writev2(signed int fd, void *hdr, unsigned long int hdr_len, void *body, unsigned long int body_len)
{
  struct iovec iov[2l];
  iov[(signed long int)0].iov_base = hdr;
  iov[(signed long int)0].iov_len = hdr_len;
  iov[(signed long int)1].iov_base = body;
  iov[(signed long int)1].iov_len = body_len;
  signed long int return_value_writev_1;
  return_value_writev_1=writev(fd, iov, 2);
  return (signed int)return_value_writev_1;
}

// dolog
// file logger.c line 395
static void dolog(signed int prio, const char *func, signed int line, const char *fmt, void **ap)
{
  char buf[(signed long int)(sizeof(struct logmsg) * 12 + 56) /*1112l*/ ];
  char *str = buf + (signed long int)sizeof(struct logmsg) /*88ul*/ ;
  struct logmsg *msg = (struct logmsg *)buf;
  signed int len = 0;
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  len=vsnprintf(str, (unsigned long int)1024, fmt, ap);
  signed int tmp_statement_expression_1;
  signed int tmp_post_4;
  if(!(len >= 0))
    syslog(3, "vsnprintf failed");

  else
  {
    signed int _x = len;
    signed int _y = 1024 - 1;
    (void)(&_x == &_y);
    tmp_statement_expression_1 = _x < _y ? _x : _y;
    msg->str_len = (unsigned long int)tmp_statement_expression_1;
    if(!(la == ((struct logarea *)NULL)))
    {
      struct sembuf ops;
      ops.sem_num = (unsigned short int)0;
      ops.sem_flg = (signed short int)0x1000;
      ops.sem_op = (signed short int)-1;
      signed int return_value_semop_2;
      return_value_semop_2=semop(la->semid, &ops, (unsigned long int)1);
      if(!(return_value_semop_2 >= 0))
      {
        syslog(3, "semop up failed: %m");
        goto __CPROVER_DUMP_L8;
      }

      if(!((unsigned long int)(la->end - la->tail) >= 89ul + (unsigned long int)len))
        syslog(3, "enqueue: log area overrun, dropping message\n");

      else
      {
        msg = (struct logmsg *)la->tail;
        init_logmsg(msg, &tv, prio, func, line);
        memcpy((void *)msg->str, (const void *)str, (unsigned long int)(len + 1));
        msg->str_len = (unsigned long int)len;
        la->tail = la->tail + (signed long int)(sizeof(struct logmsg) /*88ul*/  + (unsigned long int)len + (unsigned long int)1);
      }
      ops.sem_op = (signed short int)1;
      signed int return_value_semop_3;
      return_value_semop_3=semop(la->semid, &ops, (unsigned long int)1);
      if(!(return_value_semop_3 >= 0))
      {
        syslog(3, "semop down failed: %m");
        goto __CPROVER_DUMP_L8;
      }

    }

    else
    {
      char str_final[1024l];
      init_logmsg(msg, &tv, prio, func, line);
      len=format->formatter(str_final, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, msg, (_Bool)1);
      tmp_post_4 = len;
      len = len + 1;
      str_final[(signed long int)tmp_post_4] = (char)10;
      signed int return_value_fileno_5;
      return_value_fileno_5=fileno(stderr);
      xwrite(return_value_fileno_5, (const void *)str_final, (unsigned long int)len);
      fflush(stderr);
    }
  }

__CPROVER_DUMP_L8:
  ;
}

// dump_btree
// file sd_inode.c line 209
static void dump_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode)
{
  ;
}

// dump_stack_frames
// file logger.c line 800
static signed int dump_stack_frames(void)
{
  signed int return_value_gdb_cmd_1;
  return_value_gdb_cmd_1=gdb_cmd("thread apply all where full");
  return return_value_gdb_cmd_1;
}

// early_log_init
// file logger.c line 634
void early_log_init(const char *format_name, struct logger_user_info *user_info)
{
  struct log_format *f;
  logger_user_info = user_info;
  struct log_format *__n640;
  struct log_format *tmp_statement_expression_1;
  const struct list_node *early_log_init__1__1__1____mptr = (&log_formats)->n.next;
  tmp_statement_expression_1 = (struct log_format *)((char *)early_log_init__1__1__1____mptr - (signed long int)16ul);
  f = tmp_statement_expression_1;
  struct log_format *tmp_statement_expression_2;
  const struct list_node *early_log_init__1__1__2____mptr = f->list.next;
  tmp_statement_expression_2 = (struct log_format *)((char *)early_log_init__1__1__2____mptr - (signed long int)16ul);
  __n640 = tmp_statement_expression_2;
  struct log_format *tmp_statement_expression_3;
  for( ; !(&f->list == &(&log_formats)->n); __n640 = tmp_statement_expression_3)
  {
    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(f->name, format_name);
    if(return_value_strcmp_4 == 0)
    {
      format = f;
      goto __CPROVER_DUMP_L6;
    }

    f = __n640;
    const struct list_node *early_log_init__1__1__3____mptr = __n640->list.next;
    tmp_statement_expression_3 = (struct log_format *)((char *)early_log_init__1__1__3____mptr - (signed long int)16ul);
  }
  log_write(3, "early_log_init", 647, "invalid log format: %s", format_name);
  log_write(3, "early_log_init", 648, "valid options are:");
  struct log_format *__n649;
  struct log_format *tmp_statement_expression_5;
  const struct list_node *__mptr = (&log_formats)->n.next;
  tmp_statement_expression_5 = (struct log_format *)((char *)__mptr - (signed long int)16ul);
  f = tmp_statement_expression_5;
  struct log_format *tmp_statement_expression_6;
  const struct list_node *early_log_init__1__2__2____mptr = f->list.next;
  tmp_statement_expression_6 = (struct log_format *)((char *)early_log_init__1__2__2____mptr - (signed long int)16ul);
  __n649 = tmp_statement_expression_6;
  struct log_format *tmp_statement_expression_7;
  for( ; !(&f->list == &(&log_formats)->n); __n649 = tmp_statement_expression_7)
  {
    log_write(3, "early_log_init", 650, "\t%s", f->name);
    f = __n649;
    const struct list_node *early_log_init__1__2__3____mptr = __n649->list.next;
    tmp_statement_expression_7 = (struct log_format *)((char *)early_log_init__1__2__3____mptr - (signed long int)16ul);
  }
  exit(1);

__CPROVER_DUMP_L6:
  ;
}

// ec_decode
// file fec.c line 635
void ec_decode(struct fec *ctx, const unsigned char **input, const signed int *inidx, unsigned char *output, signed int idx)
{
  signed int edp = (signed int)ctx->dp;
  signed int ep = (signed int)ctx->dp - (signed int)ctx->d;
  signed int ed = (signed int)ctx->d;
  const signed long int ed_array_size0 = (signed long int)edp;
  const unsigned char *dp[ed_array_size0];
  const signed long int dp_array_size0 = (signed long int)ed;
  const unsigned char *oin[dp_array_size0];
  const signed long int oin_array_size0 = (signed long int)ed;
  signed int oidx[oin_array_size0];
  signed int i;
  signed int strip_size = 1024 / ed;
  const signed long int strip_size_array_size0 = (signed long int)strip_size;
  const signed long int m0_array_size0 = (signed long int)strip_size;
  const signed long int m1_array_size0 = (signed long int)strip_size;
  const signed long int m2_array_size0 = (signed long int)strip_size;
  const signed long int m3_array_size0 = (signed long int)strip_size;
  const signed long int m4_array_size0 = (signed long int)strip_size;
  const signed long int m5_array_size0 = (signed long int)strip_size;
  const signed long int m6_array_size0 = (signed long int)strip_size;
  const signed long int m7_array_size0 = (signed long int)strip_size;
  const signed long int m8_array_size0 = (signed long int)strip_size;
  const signed long int m9_array_size0 = (signed long int)strip_size;
  const signed long int m10_array_size0 = (signed long int)strip_size;
  const signed long int m11_array_size0 = (signed long int)strip_size;
  const signed long int m12_array_size0 = (signed long int)strip_size;
  const signed long int m13_array_size0 = (signed long int)strip_size;
  const signed long int m14_array_size0 = (signed long int)strip_size;
  const signed long int m15_array_size0 = (signed long int)strip_size;
  const signed long int p0_array_size0 = (signed long int)strip_size;
  const signed long int p1_array_size0 = (signed long int)strip_size;
  const signed long int p2_array_size0 = (signed long int)strip_size;
  const signed long int p3_array_size0 = (signed long int)strip_size;
  const signed long int p4_array_size0 = (signed long int)strip_size;
  const signed long int p5_array_size0 = (signed long int)strip_size;
  const signed long int p6_array_size0 = (signed long int)strip_size;
  const signed long int p7_array_size0 = (signed long int)strip_size;
  const signed long int p8_array_size0 = (signed long int)strip_size;
  const signed long int p9_array_size0 = (signed long int)strip_size;
  const signed long int p10_array_size0 = (signed long int)strip_size;
  const signed long int p11_array_size0 = (signed long int)strip_size;
  const signed long int p12_array_size0 = (signed long int)strip_size;
  const signed long int p13_array_size0 = (signed long int)strip_size;
  unsigned char m0[strip_size_array_size0];
  unsigned char m1[m0_array_size0];
  unsigned char m2[m1_array_size0];
  unsigned char m3[m2_array_size0];
  unsigned char m4[m3_array_size0];
  unsigned char m5[m4_array_size0];
  unsigned char m6[m5_array_size0];
  unsigned char m7[m6_array_size0];
  unsigned char m8[m7_array_size0];
  unsigned char m9[m8_array_size0];
  unsigned char m10[m9_array_size0];
  unsigned char m11[m10_array_size0];
  unsigned char m12[m11_array_size0];
  unsigned char m13[m12_array_size0];
  unsigned char m14[m13_array_size0];
  unsigned char m15[m14_array_size0];
  unsigned char p0[m15_array_size0];
  unsigned char p1[p0_array_size0];
  unsigned char p2[p1_array_size0];
  unsigned char p3[p2_array_size0];
  unsigned char p4[p3_array_size0];
  unsigned char p5[p4_array_size0];
  unsigned char p6[p5_array_size0];
  unsigned char p7[p6_array_size0];
  unsigned char p8[p7_array_size0];
  unsigned char p9[p8_array_size0];
  unsigned char p10[p9_array_size0];
  unsigned char p11[p10_array_size0];
  unsigned char p12[p11_array_size0];
  unsigned char p13[p12_array_size0];
  unsigned char p14[p13_array_size0];
  unsigned char *missing[16l] = { m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15 };
  unsigned char *p[15l] = { p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14 };
  i = 0;
  for( ; !(i >= edp); i = i + 1)
    dp[(signed long int)i] = (const unsigned char *)(void *)0;
  i = 0;
  for( ; !(i >= ed); i = i + 1)
    oin[(signed long int)i] = (const unsigned char *)(void *)0;
  i = 0;
  for( ; !(i >= ed); i = i + 1)
    oidx[(signed long int)i] = 0;
  i = 0;
  for( ; !(i >= ed); i = i + 1)
    dp[(signed long int)inidx[(signed long int)i]] = input[(signed long int)i];
  decode_prepare(ctx, dp, oin, oidx);
  _Bool return_value_data_is_missing_2;
  return_value_data_is_missing_2=data_is_missing(dp, ed);
  signed int tmp_post_1;
  if(!(return_value_data_is_missing_2 == (_Bool)0))
  {
    signed int m = 0;
    fec_decode(ctx, oin, missing, oidx, (unsigned long int)strip_size);
    i = 0;
    for( ; !(i >= ed); i = i + 1)
      if(dp[(signed long int)i] == ((const unsigned char *)NULL))
      {
        tmp_post_1 = m;
        m = m + 1;
        dp[(signed long int)i] = missing[(signed long int)tmp_post_1];
      }

  }

  if(idx >= ed)
  {
    ec_encode(ctx, dp, p);
    i = 0;
    for( ; !(i >= ep); i = i + 1)
      dp[(signed long int)(ed + i)] = p[(signed long int)i];
  }


out:
  ;
  memcpy((void *)output, (const void *)dp[(signed long int)idx], (unsigned long int)strip_size);
}

// ec_decode_buffer
// file fec.c line 690
void ec_decode_buffer(struct fec *ctx, unsigned char **input, const signed int *in_idx, char *buf, signed int idx)
{
  signed int i;
  signed int j;
  signed int d = (signed int)ctx->d;
  unsigned long int strip_size = (unsigned long int)(1024 / d);
  i = 0;
  for( ; !((unsigned long int)i >= 4096ul); i = i + 1)
  {
    const signed long int strip_size_array_size0 = (signed long int)d;
    const unsigned char *in[strip_size_array_size0];
    const signed long int in_array_size0 = (signed long int)strip_size;
    unsigned char out[in_array_size0];
    j = 0;
    for( ; !(j >= d); j = j + 1)
      in[(signed long int)j] = input[(signed long int)j] + (signed long int)(strip_size * (unsigned long int)i);
    ec_decode(ctx, in, in_idx, out, idx);
    memcpy((void *)(buf + (signed long int)(strip_size * (unsigned long int)i)), (const void *)out, strip_size);
  }
}

// ec_encode
// file ../include/fec.h line 169
static inline void ec_encode(struct fec *ctx, const unsigned char **ds, unsigned char **ps)
{
  signed int p = (signed int)ctx->dp - (signed int)ctx->d;
  const signed long int p_array_size0 = (signed long int)p;
  signed int pidx[p_array_size0];
  signed int i = 0;
  for( ; !(i >= p); i = i + 1)
    pidx[(signed long int)i] = (signed int)ctx->d + i;
  fec_encode(ctx, ds, ps, pidx, (unsigned long int)p, (unsigned long int)(1024 / (signed int)ctx->d));
}

// epoll_event_cmp
// file event.c line 179
static signed int epoll_event_cmp(struct epoll_event *_a, struct epoll_event *_b)
{
  struct event_info *a;
  struct event_info *b;
  a = (struct event_info *)_a->data.ptr;
  b = (struct event_info *)_b->data.ptr;
  signed int tmp_statement_expression_1;
  signed int _x = b->prio;
  signed int _y = a->prio;
  (void)(&_x == &_y);
  tmp_statement_expression_1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return tmp_statement_expression_1;
}

// event_cmp
// file event.c line 74
static signed int event_cmp(struct event_info *e1, struct event_info *e2)
{
  signed int tmp_statement_expression_1;
  signed int _x = e1->fd;
  signed int _y = e2->fd;
  (void)(&_x == &_y);
  tmp_statement_expression_1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return tmp_statement_expression_1;
}

// event_force_refresh
// file event.c line 174
void event_force_refresh(void)
{
  event_loop_refresh = (_Bool)1;
}

// event_loop
// file event.c line 218
void event_loop(signed int timeout)
{
  do_event_loop(timeout, (_Bool)0);
}

// event_loop_prio
// file event.c line 223
void event_loop_prio(signed int timeout)
{
  do_event_loop(timeout, (_Bool)1);
}

// eventfd_xread
// file util.c line 279
signed int eventfd_xread(signed int efd)
{
  signed int ret;
  unsigned long int value = (unsigned long int)0;
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  do
  {
    ret=eventfd_read(efd, &value);
    if(!(ret >= 0))
    {
      return_value___errno_location_1=__errno_location();
      tmp_if_expr_2 = *return_value___errno_location_1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  signed int *return_value___errno_location_3;
  if(ret == 0)
    ret = (signed int)value;

  else
  {
    return_value___errno_location_3=__errno_location();
    if(!(*return_value___errno_location_3 == 11))
    {
      log_write(0, "eventfd_xread", 291, "PANIC: eventfd_read() failed, %m");
      abort();
    }

  }
  return ret;
}

// eventfd_xwrite
// file util.c line 296
void eventfd_xwrite(signed int efd, signed int value)
{
  signed int ret;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  do
  {
    ret=eventfd_write(efd, (unsigned long int)value);
    if(!(ret >= 0))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 11 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
  }
  while(tmp_if_expr_4);
  if(!(ret >= 0))
  {
    log_write(0, "eventfd_xwrite", 305, "PANIC: eventfd_write() failed, %m");
    abort();
  }

}

// exec_req
// file ../include/net.h line 49
signed int exec_req(signed int sockfd, struct sd_req *hdr, void *data, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count)
{
  signed int ret;
  struct sd_rsp *rsp = (struct sd_rsp *)hdr;
  unsigned int wlen;
  unsigned int rlen;
  if(!((0x01 & (signed int)hdr->flags) == 0))
  {
    wlen = hdr->data_length;
    rlen = (unsigned int)0;
  }

  else
  {
    wlen = (unsigned int)0;
    rlen = hdr->data_length;
  }
  signed int return_value_send_req_1;
  return_value_send_req_1=send_req(sockfd, hdr, data, wlen, need_retry, epoch, max_count);
  if(!(return_value_send_req_1 == 0))
    return 1;

  else
  {
    ret=do_read(sockfd, (void *)rsp, (signed int)sizeof(struct sd_rsp) /*48ul*/ , need_retry, epoch, max_count);
    if(!(ret == 0))
    {
      log_write(3, "exec_req", 347, "failed to read a response");
      return 1;
    }

    else
    {
      if(!(rsp->data_length >= rlen))
        rlen = rsp->data_length;

      if(!(rlen == 0u))
      {
        ret=do_read(sockfd, data, (signed int)rlen, need_retry, epoch, max_count);
        if(ret == 0)
          goto __CPROVER_DUMP_L6;

        log_write(3, "exec_req", 357, "failed to read the response data");
        return 1;
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        return 0;
      }
    }
  }
}

// ext_in_range
// file sd_inode.c line 252
static _Bool ext_in_range(struct sd_extent_header *header, struct sd_extent *ext)
{
  struct sd_extent *last = (struct sd_extent *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries;
  if(last - ext >= 1l)
    return (_Bool)1;

  else
    return (_Bool)0;
}

// extent_comp
// file sd_inode.c line 108
static signed int extent_comp(void *a, void *b)
{
  struct sd_extent *ea = (struct sd_extent *)a;
  struct sd_extent *eb = (struct sd_extent *)b;
  if(!(eb->idx >= ea->idx))
    return 1;

  else
    if(!(ea->idx >= eb->idx))
      return -1;

    else
      return 0;
}

// fec_decode
// file fec.c line 555
void fec_decode(struct fec *code, const unsigned char * const * const inpkts, unsigned char * const * const outpkts, const signed int * const idx, unsigned long int sz)
{
  const signed long int fec_decode_array_size0 = (signed long int)((signed int)code->d * (signed int)code->d);
  unsigned char m_dec[fec_decode_array_size0];
  unsigned char outix = (unsigned char)0;
  unsigned char row = (unsigned char)0;
  unsigned char col = (unsigned char)0;
  build_decode_matrix_into_space(code, idx, (const unsigned int)code->d, m_dec);
  row = (unsigned char)0;
  for( ; !((signed int)row >= (signed int)code->d); row = row + 1)
    if(idx[(signed long int)row] >= (signed int)code->d)
    {
      memset((void *)outpkts[(signed long int)outix], 0, sz);
      col = (unsigned char)0;
      for( ; !((signed int)col >= (signed int)code->d); col = col + 1)
        if(!((signed int)m_dec[(signed long int)((signed int)code->d * (signed int)row + (signed int)col)] == 0))
          _addmul1(outpkts[(signed long int)outix], inpkts[(signed long int)col], m_dec[(signed long int)((signed int)row * (signed int)code->d + (signed int)col)], sz);

      outix = outix + 1;
    }

}

// fec_encode
// file fec.c line 508
void fec_encode(struct fec *code, const unsigned char * const * const src, unsigned char * const * const fecs, const signed int * const block_nums, unsigned long int num_block_nums, unsigned long int sz)
{
  unsigned char i;
  unsigned char j;
  unsigned long int d;
  unsigned int fecnum;
  const unsigned char *p;
  d = (unsigned long int)0;
  for( ; !(d >= sz); d = d + (unsigned long int)8192)
  {
    unsigned long int stride = sz - d < (unsigned long int)8192 ? sz - d : (unsigned long int)8192;
    i = (unsigned char)0;
    for( ; !((unsigned long int)i >= num_block_nums); i = i + 1)
    {
      fecnum = (unsigned int)block_nums[(signed long int)i];
      memset((void *)(fecs[(signed long int)i] + (signed long int)d), 0, stride);
      p = &code->enc_matrix[(signed long int)(fecnum * (unsigned int)code->d)];
      j = (unsigned char)0;
      for( ; !((signed int)j >= (signed int)code->d); j = j + 1)
        if(!((signed int)p[(signed long int)j] == 0))
          _addmul1(fecs[(signed long int)i] + (signed long int)d, src[(signed long int)j] + (signed long int)d, p[(signed long int)j], stride);

    }
  }
}

// fec_free
// file fec.c line 452
void fec_free(struct fec *p)
{
  free((void *)p->enc_matrix);
  free((void *)p);
}

// fec_new
// file fec.c line 460
struct fec * fec_new(unsigned short int d, unsigned short int dp)
{
  unsigned int row;
  unsigned int col;
  unsigned char *p;
  unsigned char *tmp_m;
  struct fec *retval;
  void *return_value_xmalloc_1;
  return_value_xmalloc_1=xmalloc(sizeof(struct fec) /*24ul*/ );
  retval = (struct fec *)return_value_xmalloc_1;
  retval->d = d;
  retval->dp = dp;
  void *return_value_xmalloc_2;
  return_value_xmalloc_2=xmalloc((unsigned long int)((signed int)dp * (signed int)d));
  retval->enc_matrix = (unsigned char *)return_value_xmalloc_2;
  retval->magic = (unsigned long int)(0xFECC0DEC ^ (unsigned int)d ^ (unsigned int)dp) ^ (unsigned long int)retval->enc_matrix;
  void *return_value_xmalloc_3;
  return_value_xmalloc_3=xmalloc((unsigned long int)((signed int)dp * (signed int)d));
  tmp_m = (unsigned char *)return_value_xmalloc_3;
  tmp_m[(signed long int)0] = (unsigned char)1;
  col = (unsigned int)1;
  for( ; !(col >= (unsigned int)d); col = col + 1u)
    tmp_m[(signed long int)col] = (unsigned char)0;
  p = tmp_m + (signed long int)d;
  row = (unsigned int)0;
  unsigned char return_value_modnn_4;
  for( ; !(row >= 4294967295u + (unsigned int)(signed int)dp); p = p + (signed long int)d)
  {
    col = (unsigned int)0;
    for( ; !(col >= (unsigned int)d); col = col + 1u)
    {
      return_value_modnn_4=modnn((signed int)(row * col));
      p[(signed long int)col] = gf_exp[(signed long int)return_value_modnn_4];
    }
    row = row + 1u;
  }
  _invert_vdm(tmp_m, (unsigned int)d);
  _matmul(tmp_m + (signed long int)((signed int)d * (signed int)d), tmp_m, retval->enc_matrix + (signed long int)((signed int)d * (signed int)d), (unsigned int)((signed int)dp - (signed int)d), (unsigned int)d, (unsigned int)d);
  memset((void *)retval->enc_matrix, 0, (unsigned long int)((signed int)d * (signed int)d) * sizeof(unsigned char) /*1ul*/ );
  p = retval->enc_matrix;
  col = (unsigned int)0;
  for( ; !(col >= (unsigned int)d); p = p + (signed long int)((signed int)d + 1))
  {
    *p = (unsigned char)1;
    col = col + 1u;
  }
  free((void *)tmp_m);
  return retval;
}

// fg_printf
// file core.c line 93
static void fg_printf(const char *func, signed int line, const char *fmt, ...)
{
  void **ap;
  fprintf(stderr, "%s(%d): ", func, line);
  ap = (void **)&fmt;
  vfprintf(stderr, fmt, ap);
  ap = ((void **)NULL);
}

// format_thread_name
// file logger.c line 156
static const char * format_thread_name(char *str, unsigned long int size, const char *name, signed int idx)
{
  _Bool tmp_if_expr_2;
  if(!(name == ((const char *)NULL)))
    tmp_if_expr_2 = name[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_1;
  if(!(idx == 0) && tmp_if_expr_2)
    snprintf(str, size, "%s %d", name, idx);

  else
  {
    if(!(name == ((const char *)NULL)))
      tmp_if_expr_1 = name[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      snprintf(str, size, "%s", name);

    else
      snprintf(str, size, "main");
  }
  return str;
}

// forward_iov
// file net.c line 248
static void forward_iov(struct msghdr *msg, signed int len)
{
  for( ; (unsigned long int)len >= msg->msg_iov->iov_len; msg->msg_iovlen = msg->msg_iovlen - 1ul)
  {
    len = len - (signed int)msg->msg_iov->iov_len;
    msg->msg_iov = msg->msg_iov + 1l;
  }
  msg->msg_iov->iov_base = (void *)((char *)msg->msg_iov->iov_base + (signed long int)len);
  msg->msg_iov->iov_len = msg->msg_iov->iov_len - (unsigned long int)len;
}

// free_cache_entry
// file sockfd_cache.c line 149
static void free_cache_entry(struct sockfd_cache_entry *entry)
{
  free((void *)entry->fds);
  free((void *)entry);
}

// free_logarea
// file logger.c line 350
static void free_logarea(void)
{
  if(log_fd >= 0)
    close(log_fd);

  semctl(la->semid, 0, 0, la->semarg);
  shmdt((const void *)la->start);
  shmdt((const void *)la);
}

// gdb_cmd
// file logger.c line 760
static signed int gdb_cmd(const char *cmd)
{
  signed long int time_str_array_size0;
  time_str_array_size0=sysconf(0);
  char time_str[256l];
  char cmd_str[time_str_array_size0];
  signed long int ti;
  struct tm tm;
  _Bool return_value_check_gdb_1;
  return_value_check_gdb_1=check_gdb();
  if(return_value_check_gdb_1 == (_Bool)0)
  {
    if(sd_log_level == 7)
      log_write(7, "gdb_cmd", 767, "cannot find gdb");

    return -1;
  }

  else
  {
    time(&ti);
    localtime_r(&ti, &tm);
    strftime(time_str, sizeof(char [256l]) /*256ul*/ , "%b %2d %H:%M:%S ", &tm);
    const char *return_value_my_exe_path_2;
    return_value_my_exe_path_2=my_exe_path();
    signed int return_value_getpid_3;
    return_value_getpid_3=getpid();
    const char *return_value_my_exe_path_4;
    return_value_my_exe_path_4=my_exe_path();
    snprintf(cmd_str, (unsigned long int)time_str_array_size0, "gdb -nw %s %d -batch >/dev/null 2>&1 -ex 'set logging on' -ex 'echo \\n' -ex 'echo ==\\n' -ex 'echo == %s\\n' -ex 'echo == program: %s\\n' -ex 'echo == command: %s\\n' -ex 'echo ==\\n' -ex '%s' -ex 'set logging off'", return_value_my_exe_path_2, return_value_getpid_3, (const void *)time_str, return_value_my_exe_path_4, cmd, cmd);
    signed int return_value_system_5;
    return_value_system_5=system(cmd_str);
    return return_value_system_5;
  }
}

// generate_gf
// file fec.c line 143
static void generate_gf(void)
{
  signed int i;
  unsigned char mask = (unsigned char)1;
  gf_exp[(signed long int)8] = (unsigned char)0;
  i = 0;
  for( ; !(i >= 8); mask = mask << 1)
  {
    gf_exp[(signed long int)i] = mask;
    gf_log[(signed long int)gf_exp[(signed long int)i]] = i;
    if((signed int)Pp[(signed long int)i] == 49)
      gf_exp[(signed long int)8] = gf_exp[(signed long int)8] ^ mask;

    i = i + 1;
  }
  gf_log[(signed long int)gf_exp[(signed long int)8]] = 8;
  mask = (unsigned char)(1 << 7);
  i = 9;
  for( ; !(i >= 255); i = i + 1)
  {
    if((signed int)gf_exp[(signed long int)(i + -1)] >= (signed int)mask)
      gf_exp[(signed long int)i] = (unsigned char)((signed int)gf_exp[(signed long int)8] ^ ((signed int)gf_exp[(signed long int)(i - 1)] ^ (signed int)mask) << 1);

    else
      gf_exp[(signed long int)i] = (unsigned char)((signed int)gf_exp[(signed long int)(i - 1)] << 1);
    gf_log[(signed long int)gf_exp[(signed long int)i]] = i;
  }
  gf_log[(signed long int)0] = 255;
  i = 0;
  for( ; !(i >= 255); i = i + 1)
    gf_exp[(signed long int)(i + 255)] = gf_exp[(signed long int)i];
  inverse[(signed long int)0] = (unsigned char)0;
  inverse[(signed long int)1] = (unsigned char)1;
  i = 2;
  for( ; !(i >= 256); i = i + 1)
    inverse[(signed long int)i] = gf_exp[(signed long int)(255 - gf_log[(signed long int)i])];
}

// generate_url
// file http.c line 209
static signed int generate_url(const char *buff, signed int size, char *url, signed int url_len)
{
  char address[4096l];
  char *ch;
  signed int len;
  signed int ret = 0;
  len=shadow_file_read("/http/address", address, sizeof(char [4096l]) /*4096ul*/ , (signed long int)0);
  if(!(len >= 1))
  {
    fs_printf("generate_url", 216, "Can't get address of http");
    ret = -22;
  }

  else
  {
    ch=strchr(address, 10);
    if(!(ch == ((char *)NULL)))
      *ch = (char)0;

    snprintf(url, (unsigned long int)url_len, "http://%s/v1%.*s", (const void *)address, size, buff);
  }

out:
  ;
  return ret;
}

// get_buffer_sha1
// file sha1.c line 337
void get_buffer_sha1(unsigned char *buf, unsigned int len, unsigned char *sha1)
{
  struct sha1_ctx c;
  sha1_init((void *)&c);
  sha1_update((void *)&c, buf, len);
  sha1_final((void *)&c, sha1);
}

// get_free_slot
// file sockfd_cache.c line 94
static inline signed int get_free_slot(struct sockfd_cache_entry *entry)
{
  signed int idx = -1;
  signed int i = 0;
  for( ; !(i >= fds_count); i = i + 1)
  {
    _Bool return_value_uatomic_set_true_1;
    return_value_uatomic_set_true_1=uatomic_set_true_link1(&(entry->fds + (signed long int)i)->in_use);
    if(!(return_value_uatomic_set_true_1 == (_Bool)0))
    {
      idx = i;
      break;
    }

  }
  return idx;
}

// get_local_addr
// file net.c line 493
signed int get_local_addr(unsigned char *bytes)
{
  struct ifaddrs *ifaddr;
  struct ifaddrs *ifa;
  signed int ret = 0;
  signed int return_value_getifaddrs_1;
  return_value_getifaddrs_1=getifaddrs(&ifaddr);
  if(return_value_getifaddrs_1 == -1)
  {
    log_write(3, "get_local_addr", 499, "getifaddrs failed: %m");
    return -1;
  }

  else
  {
    ifa = ifaddr;
    for( ; !(ifa == ((struct ifaddrs *)NULL)); ifa = ifa->ifa_next)
    {
      struct sockaddr_in *sin;
      struct sockaddr_in6 *sin6;
      if((8u & ifa->ifa_flags) == 0u)
      {
        if(!(ifa->ifa_addr == ((struct sockaddr *)NULL)))
          switch((signed int)ifa->ifa_addr->sa_family)
          {
            case 2:
            {
              sin = (struct sockaddr_in *)ifa->ifa_addr;
              memset((void *)bytes, 0, (unsigned long int)12);
              memcpy((void *)(bytes + (signed long int)12), (const void *)&sin->sin_addr, (unsigned long int)4);
              memcpy((void *)(bytes + (signed long int)12), (const void *)&sin->sin_addr, (unsigned long int)4);
              log_write(5, "get_local_addr", 519, "found IPv4 address");
              goto out;
            }
            case 10:
            {
              sin6 = (struct sockaddr_in6 *)ifa->ifa_addr;
              memcpy((void *)bytes, (const void *)&sin6->sin6_addr, (unsigned long int)16);
              log_write(5, "get_local_addr", 524, "found IPv6 address");
              goto out;
            }
            default:
              ;
          }

      }

    }
    log_write(3, "get_local_addr", 529, "no valid interface found");
    ret = -1;

  out:
    ;
    freeifaddrs(ifaddr);
    return ret;
  }
}

// get_loglevel
// file logger.c line 861
signed int get_loglevel(void)
{
  return sd_log_level;
}

// get_msec_time
// file work.c line 194
static unsigned long int get_msec_time(void)
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  return (unsigned long int)(tv.tv_sec * (signed long int)1000 + tv.tv_usec / (signed long int)1000);
}

// get_socket_fd
// file volume.c line 112
static inline signed int get_socket_fd(struct vdi_inode *vdi, signed int *idx)
{
  signed int sock_idx;
  signed int fd;
  unsigned long int return_value___uatomic_add_return_1;
  _Bool return_value_uatomic_set_true_2;
  do
  {

  retry:
    ;
    return_value___uatomic_add_return_1=__uatomic_add_return((void *)&vdi->socket_poll_adder, (unsigned long int)1, (signed int)sizeof(unsigned int) /*4ul*/ );
    sock_idx = (signed int)((unsigned int)return_value___uatomic_add_return_1 % (unsigned int)31);
    return_value_uatomic_set_true_2=uatomic_set_true(&vdi->socket_in_use[(signed long int)sock_idx]);
  }
  while(return_value_uatomic_set_true_2 != (_Bool)0);
  fd = vdi->socket_pool[(signed long int)sock_idx];
  *idx = sock_idx;
  return fd;
}

// get_thread_name
// file logger.c line 745
void get_thread_name(char *name)
{
  format_thread_name(name, (unsigned long int)20, worker_name, worker_idx);
}

// gettid
// file ../include/util.h line 114
signed int gettid(void)
{
  signed long int return_value_syscall_1;
  return_value_syscall_1=syscall((signed long int)186);
  return (signed int)return_value_syscall_1;
}

// grow_fds_done
// file sockfd_cache.c line 270
static void grow_fds_done(struct work *work)
{
  if(sd_log_level == 7)
    log_write(7, "grow_fds_done", 272, "fd count has been grown into %d", fds_count);

  uatomic_set_false_link1(&fds_in_grow);
  free((void *)work);
}

// http_address_get_size
// file sheepfs.h line 115
unsigned long int http_address_get_size(const char *path)
{
  struct stat st;
  _Bool return_value_shadow_file_stat_1;
  return_value_shadow_file_stat_1=shadow_file_stat(path, &st);
  if(!(return_value_shadow_file_stat_1 == (_Bool)0))
    return (unsigned long int)st.st_size;

  else
    return (unsigned long int)0;
}

// http_address_read
// file sheepfs.h line 112
signed int http_address_read(const char *path, char *buf, unsigned long int size, signed long int ignore)
{
  signed int return_value_shadow_file_read_1;
  return_value_shadow_file_read_1=shadow_file_read(path, buf, size, (signed long int)0);
  return return_value_shadow_file_read_1;
}

// http_address_write
// file sheepfs.h line 113
signed int http_address_write(const char *path, const char *buf, unsigned long int size, signed long int ignore)
{
  unsigned long int return_value_shadow_file_write_1;
  return_value_shadow_file_write_1=shadow_file_write(path, buf, size);
  return (signed int)return_value_shadow_file_write_1;
}

// http_object_write
// file sheepfs.h line 116
signed int http_object_write(const char *path, const char *buf, unsigned long int size, signed long int ignore)
{
  char entry[4096l];
  char url[4096l];
  signed int ret = -22;
  ret=generate_url(buf, (signed int)(size - (unsigned long int)1), url, 4096);
  _Bool return_value_curl_object_exists_1;
  if(ret == 0)
  {
    return_value_curl_object_exists_1=curl_object_exists(url);
    if(!(return_value_curl_object_exists_1 == (_Bool)0))
    {
      snprintf(entry, size, "%s", buf);
      ret=object_create_entry(entry, url);
      if(ret >= 0)
        ret = (signed int)size;

    }

  }


out:
  ;
  return ret;
}

// idx_in_range
// file sd_inode.c line 261
static _Bool idx_in_range(struct sd_extent_header *header, struct sd_extent_idx *idx)
{
  struct sd_extent_idx *last = (struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries;
  if(last - idx >= 1l)
    return (_Bool)1;

  else
    return (_Bool)0;
}

// index_comp
// file sd_inode.c line 122
static signed int index_comp(void *a, void *b)
{
  struct sd_extent_idx *ia = (struct sd_extent_idx *)a;
  struct sd_extent_idx *ib = (struct sd_extent_idx *)b;
  if(!(ib->idx >= ia->idx))
    return 1;

  else
    if(!(ia->idx >= ib->idx))
      return -1;

    else
      return 0;
}

// inetaddr_is_valid
// file net.c line 574
_Bool inetaddr_is_valid(char *addr)
{
  unsigned char buf[46l];
  signed int af;
  char *return_value_strstr_1;
  return_value_strstr_1=strstr(addr, ":");
  af = return_value_strstr_1 != ((char *)NULL) ? 10 : 2;
  signed int return_value_inet_pton_2;
  return_value_inet_pton_2=inet_pton(af, addr, (void *)buf);
  if(return_value_inet_pton_2 == 0)
  {
    log_write(3, "inetaddr_is_valid", 581, "Bad address '%s'", addr);
    return (_Bool)0;
  }

  else
    return (_Bool)1;
}

// init_event
// file event.c line 79
signed int init_event(signed int nr)
{
  nr_events = nr;
  void *return_value_xcalloc_1;
  return_value_xcalloc_1=xcalloc((unsigned long int)nr_events, sizeof(struct epoll_event) /*12ul*/ );
  events = (struct epoll_event *)return_value_xcalloc_1;
  efd=epoll_create(nr);
  if(!(efd >= 0))
  {
    log_write(3, "init_event", 86, "failed to create epoll fd");
    return -1;
  }

  else
    return 0;
}

// init_fec
// file fec.c line 438
void init_fec(void)
{
  generate_gf();
  _init_mul_table();
}

// init_logmsg
// file logger.c line 381
static void init_logmsg(struct logmsg *msg, struct timeval *tv, signed int prio, const char *func, signed int line)
{
  msg->tv = *tv;
  msg->prio = prio;
  pstrcpy(msg->func, 32, func);
  msg->line = line;
  if(!(worker_name == ((const char *)NULL)))
    pstrcpy(msg->worker_name, 20, worker_name);

  else
    msg->worker_name[(signed long int)0] = (char)0;
  msg->worker_idx = worker_idx;
}

// init_vdi_info
// file volume.c line 417
static signed int init_vdi_info(const char *entry, unsigned int *vid, unsigned long int *size)
{
  struct strbuf *buf;
  void *inode_buf = (void *)0;
  struct vdi_inode *inode = (struct vdi_inode *)(void *)0;
  struct vdi_inode *dummy;
  char command[512l];
  snprintf(command, sizeof(char [512l]) /*512ul*/ , "dog vdi list -r %s -a %s -p %d", entry, (const void *)sdhost, sdport);
  buf=sheepfs_run_cmd(command);
  void *return_value_xzalloc_2;
  signed int return_value_setup_socket_pool_3;
  unsigned long int return_value_vid_to_vdi_oid_4;
  signed int return_value_volume_rw_object_5;
  if(buf == ((struct strbuf *)NULL))
    return -1;

  else
  {
    signed int return_value_sscanf_1;
    return_value_sscanf_1=sscanf(buf->buf, "%*s %*s %*d %zu %*s %*s %*s %x", size, vid);
    if(!(return_value_sscanf_1 >= 2))
      fs_printf("init_vdi_info", 431, "failed to sscanf %s\n", entry);

    else
    {
      inode_buf=malloc(sizeof(struct sd_inode) /*4198976ul*/ );
      if(inode_buf == NULL)
        fs_printf("init_vdi_info", 437, "%m\n");

      else
      {
        return_value_xzalloc_2=xzalloc(sizeof(struct vdi_inode) /*424ul*/ );
        inode = (struct vdi_inode *)return_value_xzalloc_2;
        inode->vid = *vid;
        return_value_setup_socket_pool_3=setup_socket_pool(inode->socket_pool, 31);
        if(!(return_value_setup_socket_pool_3 >= 0))
          fs_printf("init_vdi_info", 444, "failed to setup socket pool\n");

        else
        {
          sd_write_lock(&vdi_inode_tree_lock);
          dummy=vdi_inode_tree_insert(inode);
          sd_rw_unlock(&vdi_inode_tree_lock);
          if(dummy == ((struct vdi_inode *)NULL))
          {
            return_value_vid_to_vdi_oid_4=vid_to_vdi_oid(*vid);
            return_value_volume_rw_object_5=volume_rw_object((char *)inode_buf, return_value_vid_to_vdi_oid_4, sizeof(struct sd_inode) /*4198976ul*/ , (signed long int)0, 0);
            if(!(return_value_volume_rw_object_5 >= 0))
            {
              rb_erase(&inode->rb, &vdi_inode_tree);
              fs_printf("init_vdi_info", 456, "failed to read inode for %x\n", *vid);
            }

            else
            {
              inode->inode = (struct sd_inode *)inode_buf;
              strbuf_release(buf);
              free((void *)buf);
              return 0;
            }
          }

        }
      }
    }

  err:
    ;
    free(inode_buf);
    free((void *)inode);
    strbuf_release(buf);
    free((void *)buf);
    return -1;
  }
}

// init_work_queue
// file work.c line 364
signed int init_work_queue(unsigned long int (*get_nr_nodes)(void))
{
  signed int ret;
  wq_get_nr_nodes = get_nr_nodes;
  if(!(wq_get_nr_nodes == ((unsigned long int (*)(void))NULL)))
    nr_nodes=wq_get_nr_nodes();

  efd_link1=eventfd((unsigned int)0, 2048);
  if(!(efd_link1 >= 0))
  {
    log_write(3, "init_work_queue", 375, "failed to create event fd: %m");
    return -1;
  }

  else
  {
    ret=wq_trace_init();
    if(!(ret >= 0))
      return ret;

    else
    {
      ret=register_event_link1(efd_link1, worker_thread_request_done, (void *)0);
      if(!(ret == 0))
      {
        log_write(3, "init_work_queue", 385, "failed to register event fd %m");
        close(efd_link1);
        return -1;
      }

      else
        return 0;
    }
  }
}

// insert_ext_entry_nosearch
// file sd_inode.c line 290
static void insert_ext_entry_nosearch(struct sd_extent_header *header, struct sd_extent *ext, unsigned int idx, unsigned int vdi_id)
{
  struct sd_extent *last = (struct sd_extent *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries;
  memmove((void *)(ext + (signed long int)1), (const void *)ext, (unsigned long int)(last - ext) * sizeof(struct sd_extent) /*8ul*/ );
  ext->idx = idx;
  ext->vdi_id = vdi_id;
  header->entries = header->entries + 1u;
}

// insert_idx_entry
// file sd_inode.c line 314
static void insert_idx_entry(struct sd_extent_header *header, unsigned int idx, unsigned long int oid)
{
  struct sd_extent_idx *found;
  if(!((unsigned long int)header->entries >= 262143ul))
  {
    if(header->entries == 0u)
    {
      ((struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ))->idx = idx;
      ((struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ))->oid = oid;
      header->entries = header->entries + 1u;
    }

    else
    {
      found=search_idx_entry(header, idx);
      insert_idx_entry_nosearch(header, found, idx, oid);
    }
  }


out:
  ;
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// insert_idx_entry_nosearch
// file sd_inode.c line 302
static void insert_idx_entry_nosearch(struct sd_extent_header *header, struct sd_extent_idx *idx_ext, unsigned int idx, unsigned long int oid)
{
  struct sd_extent_idx *last = (struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries;
  memmove((void *)(idx_ext + (signed long int)1), (const void *)idx_ext, (unsigned long int)(last - idx_ext) * sizeof(struct sd_extent_idx) /*16ul*/ );
  idx_ext->idx = idx;
  idx_ext->oid = oid;
  header->entries = header->entries + 1u;
}

// insert_new_node
// file sd_inode.c line 499
static signed int insert_new_node(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, struct find_path *path, unsigned int idx, unsigned int vdi_id)
{
  struct sd_extent_header *header = (struct sd_extent_header *)inode->data_vdi_id;
  struct sd_extent_header *leaf_node = (struct sd_extent_header *)(void *)0;
  unsigned long int oid;
  signed int ret = 0x00;
  unsigned int tmp_post_2;
  if(path->depth == 1)
  {
    if((unsigned long int)header->entries >= 524287ul)
    {
      transfer_to_idx_root(writer, inode);
      ret = 0x1D;
      goto out;
    }

    insert_ext_entry_nosearch(header, path->p_ext, idx, vdi_id);
  }

  else
    if(path->depth == 2)
    {
      _Bool return_value_idx_in_range_3;
      return_value_idx_in_range_3=idx_in_range(header, path->p_idx);
      if(!(return_value_idx_in_range_3 == (_Bool)0))
      {
        if(path->p_ext_header == ((struct sd_extent_header *)NULL))
        {
          ret = 0x1B;
          goto out;
        }

        if((unsigned long int)path->p_ext_header->entries >= 524287ul)
        {
          split_ext_node(writer, inode, path);
          ret = 0x1D;
          goto out;
        }

        insert_ext_entry_nosearch(path->p_ext_header, path->p_ext, idx, vdi_id);
        writer(path->p_idx->oid, (void *)path->p_ext_header, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)0, (_Bool)0);
      }

      else
        if(!(path->p_ext_header == ((struct sd_extent_header *)NULL)))
        {
          insert_ext_entry_nosearch(path->p_ext_header, path->p_ext, idx, vdi_id);
          path->p_idx = path->p_idx - 1l;
          path->p_idx->idx = (((struct sd_extent *)((char *)path->p_ext_header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)path->p_ext_header)->entries) - (signed long int)1)->idx;
          writer(path->p_idx->oid, (void *)path->p_ext_header, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)0, (_Bool)0);
        }

        else
        {
          if((unsigned long int)header->entries >= 262143ul)
          {
            log_write(0, "insert_new_node", 545, "PANIC: %s() B-tree is full!", (const void *)"insert_new_node");
            abort();
          }

          void *return_value_xvalloc_1;
          return_value_xvalloc_1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
          leaf_node = (struct sd_extent_header *)return_value_xvalloc_1;
          sd_inode_init((void *)leaf_node, 2);
          tmp_post_2 = inode->btree_counter;
          inode->btree_counter = inode->btree_counter + 1u;
          oid=vid_to_btree_oid(inode->vdi_id, tmp_post_2);
          insert_ext_entry_nosearch(leaf_node, (struct sd_extent *)((char *)leaf_node + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ), idx, vdi_id);
          writer(oid, (void *)leaf_node, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)1, (_Bool)0);
          insert_idx_entry_nosearch(header, path->p_idx, idx, oid);
        }
    }


out:
  ;
  if(!(leaf_node == ((struct sd_extent_header *)NULL)))
    free((void *)leaf_node);

  return ret;
}

// install_crash_handler
// file ../include/util.h line 112
signed int install_crash_handler(void (*handler)(signed int))
{
  signed int return_value_install_sighandler_1;
  return_value_install_sighandler_1=install_sighandler(11, handler, (_Bool)1);
  _Bool tmp_if_expr_3;
  signed int return_value_install_sighandler_2;
  if(!(return_value_install_sighandler_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_install_sighandler_2=install_sighandler(6, handler, (_Bool)1);
    tmp_if_expr_3 = return_value_install_sighandler_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  signed int return_value_install_sighandler_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_install_sighandler_4=install_sighandler(7, handler, (_Bool)1);
    tmp_if_expr_5 = return_value_install_sighandler_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int return_value_install_sighandler_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_install_sighandler_6=install_sighandler(4, handler, (_Bool)1);
    tmp_if_expr_7 = return_value_install_sighandler_6 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_9;
  signed int return_value_install_sighandler_8;
  if(tmp_if_expr_7)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value_install_sighandler_8=install_sighandler(8, handler, (_Bool)1);
    tmp_if_expr_9 = return_value_install_sighandler_8 != 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr_9;
}

// install_sighandler
// file ../include/util.h line 111
signed int install_sighandler(signed int signum, void (*handler)(signed int), _Bool once)
{
  struct sigaction sa = { .__sigaction_handler={ .sa_handler=((void (*)(signed int))NULL) }, .sa_mask={ .__val={ 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul } },
    .sa_flags=0,
    .sa_restorer=((void (*)(void))NULL) };
  sa.__sigaction_handler.sa_handler = handler;
  if(!(once == (_Bool)0))
    sa.sa_flags = (signed int)(0x80000000 | (unsigned int)0x40000000);

  sigemptyset(&sa.sa_mask);
  signed int return_value_sigaction_1;
  return_value_sigaction_1=sigaction(signum, &sa, (struct sigaction *)(void *)0);
  return return_value_sigaction_1;
}

// is_data_obj
// file ../include/sheepdog_proto.h line 405
static inline _Bool is_data_obj(unsigned long int oid)
{
  _Bool return_value_is_vdi_obj_1;
  return_value_is_vdi_obj_1=is_vdi_obj(oid);
  _Bool tmp_if_expr_3;
  _Bool return_value_is_vmstate_obj_2;
  if(return_value_is_vdi_obj_1 == (_Bool)0)
  {
    return_value_is_vmstate_obj_2=is_vmstate_obj(oid);
    tmp_if_expr_3 = !(return_value_is_vmstate_obj_2 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  _Bool tmp_if_expr_5;
  _Bool return_value_is_vdi_attr_obj_4;
  if(tmp_if_expr_3)
  {
    return_value_is_vdi_attr_obj_4=is_vdi_attr_obj(oid);
    tmp_if_expr_5 = !(return_value_is_vdi_attr_obj_4 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_5 = (_Bool)0;
  _Bool tmp_if_expr_7;
  _Bool return_value_is_vdi_btree_obj_6;
  if(tmp_if_expr_5)
  {
    return_value_is_vdi_btree_obj_6=is_vdi_btree_obj(oid);
    tmp_if_expr_7 = !(return_value_is_vdi_btree_obj_6 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_7 = (_Bool)0;
  return tmp_if_expr_7;
}

// is_data_obj_writeable
// file volume.c line 81
static inline _Bool is_data_obj_writeable(struct sd_inode *inode, unsigned int idx)
{
  unsigned int return_value_sd_inode_get_vid_1;
  return_value_sd_inode_get_vid_1=sd_inode_get_vid(sheepfs_bnode_reader, inode, idx);
  return inode->vdi_id == return_value_sd_inode_get_vid_1;
}

// is_numeric
// file util.c line 399
_Bool is_numeric(const char *s)
{
  const char *p = s;
  const char *tmp_post_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  if(!(*p == 0))
  {
    char c;
    do
    {
      tmp_post_1 = p;
      p = p + 1l;
      c = *tmp_post_1;
      if(c == 0)
        break;

      return_value___ctype_b_loc_2=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)c]) == 0)
        return (_Bool)0;

    }
    while((_Bool)1);
    return (_Bool)1;
  }

  return (_Bool)0;
}

// is_sheep_dead
// file logger.c line 529
static _Bool is_sheep_dead(signed int signo)
{
  return signo == 1;
}

// is_stdout_console
// file ../include/util.h line 493
static inline _Bool is_stdout_console(void)
{
  signed int return_value_isatty_1;
  return_value_isatty_1=isatty(1);
  return (_Bool)return_value_isatty_1;
}

// is_vdi_attr_obj
// file ../include/sheepdog_proto.h line 395
static inline _Bool is_vdi_attr_obj(unsigned long int oid)
{
  return !(!((oid & 1UL << 61) != 0ul));
}

// is_vdi_btree_obj
// file ../include/sheepdog_proto.h line 400
static inline _Bool is_vdi_btree_obj(unsigned long int oid)
{
  return !(!((oid & 1UL << 60) != 0ul));
}

// is_vdi_obj
// file ../include/sheepdog_proto.h line 385
static inline _Bool is_vdi_obj(unsigned long int oid)
{
  return !(!((oid & 1UL << 63) != 0ul));
}

// is_vmstate_obj
// file ../include/sheepdog_proto.h line 390
static inline _Bool is_vmstate_obj(unsigned long int oid)
{
  return !(!((oid & 1UL << 62) != 0ul));
}

// is_xattr_enabled
// file ../include/util.h line 116
_Bool is_xattr_enabled(const char *path)
{
  signed int ret;
  signed int dummy;
  signed long int return_value_getxattr_1;
  return_value_getxattr_1=getxattr(path, "user.dummy", (void *)&dummy, sizeof(signed int) /*4ul*/ );
  ret = (signed int)return_value_getxattr_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  if(ret == -1)
  {
    return_value___errno_location_2=__errno_location();
    tmp_if_expr_3 = *return_value___errno_location_2 == 95 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  return !tmp_if_expr_3;
}

// list_add
// file ../include/list.h line 82
static inline void list_add(struct list_node *new, struct list_head *head)
{
  __list_add(new, &head->n, head->n.next);
}

// list_add_tail
// file ../include/list.h line 87
static inline void list_add_tail(struct list_node *new, struct list_head *head)
{
  __list_add(new, head->n.prev, &head->n);
}

// list_del
// file ../include/list.h line 103
static inline void list_del(struct list_node *entry)
{
  __list_del(entry->prev, entry->next);
  entry->prev = (struct list_node *)(void *)0;
  entry->next = entry->prev;
}

// list_empty
// file ../include/list.h line 42
static inline _Bool list_empty(struct list_head *head)
{
  return head->n.next == &head->n;
}

// list_empty_link1
// file ../include/list.h line 42
static inline _Bool list_empty_link1(struct list_head *head_link1)
{
  return head_link1->n.next == &head_link1->n;
}

// list_sort
// file util.c line 700
void list_sort(void *priv, struct list_head *head, signed int (*cmp)(void *, struct list_node *, struct list_node *))
{
  struct list_node *part[21l];
  signed int lev;
  signed int max_lev = 0;
  struct list_node *list;
  _Bool return_value_list_empty_1;
  return_value_list_empty_1=list_empty(head);
  if(return_value_list_empty_1 == (_Bool)0)
  {
    memset((void *)part, 0, sizeof(struct list_node *[21l]) /*168ul*/ );
    head->n.prev->next = (struct list_node *)(void *)0;
    list = head->n.next;
    while(!(list == ((struct list_node *)NULL)))
    {
      struct list_node *cur = list;
      list = list->next;
      cur->next = (struct list_node *)(void *)0;
      lev = 0;
      for( ; !(part[(signed long int)lev] == ((struct list_node *)NULL)); lev = lev + 1)
      {
        cur=merge(priv, cmp, part[(signed long int)lev], cur);
        part[(signed long int)lev] = (struct list_node *)(void *)0;
      }
      if(!(max_lev >= lev))
      {
        if((unsigned long int)lev >= 20ul)
          lev = lev - 1;

        max_lev = lev;
      }

      part[(signed long int)lev] = cur;
    }
    lev = 0;
    for( ; !(lev >= max_lev); lev = lev + 1)
      if(!(part[(signed long int)lev] == ((struct list_node *)NULL)))
        list=merge(priv, cmp, part[(signed long int)lev], list);

    merge_and_restore_back_links(priv, cmp, head, part[(signed long int)max_lev], list);
  }

}

// list_splice_init
// file ../include/list.h line 136
static inline void list_splice_init(struct list_head *list, struct list_head *head)
{
  _Bool return_value_list_empty_1;
  return_value_list_empty_1=list_empty_link1(list);
  if(return_value_list_empty_1 == (_Bool)0)
  {
    __list_splice(list, &head->n, head->n.next);
    INIT_LIST_HEAD(list);
  }

}

// log_close
// file logger.c line 712
void log_close(void)
{
  signed int pid;
  if(!(la == ((struct logarea *)NULL)))
    while((_Bool)1)
    {
      la->active = (_Bool)0;
      pid=waitpid(logger_pid, (signed int *)(void *)0, 1);
      if(pid == 0)
      {
        usleep((unsigned int)100000);
        continue;
      }

      else
        if(pid >= 1)
        {
          syslog(4, "logger pid %d stopped\n", logger_pid);
          closelog();
          free_logarea();
          break;
        }

        else
        {
          syslog(3, "waitpid() failure\n");
          exit(1);
        }
    }

}

// log_flush
// file logger.c line 494
static void log_flush(void)
{
  struct sembuf ops;
  unsigned long int size;
  unsigned long int done = (unsigned long int)0;
  struct logmsg *msg;
  if(!(la->tail == la->start))
  {
    ops.sem_num = (unsigned short int)0;
    ops.sem_flg = (signed short int)0x1000;
    ops.sem_op = (signed short int)-1;
    signed int return_value_semop_1;
    return_value_semop_1=semop(la->semid, &ops, (unsigned long int)1);
    if(!(return_value_semop_1 >= 0))
    {
      syslog(3, "semop up failed: %m");
      exit(1);
    }

    size = (unsigned long int)(la->tail - la->start);
    memcpy((void *)log_buff, (const void *)la->start, size);
    memset((void *)la->start, 0, size);
    la->tail = la->start;
    ops.sem_op = (signed short int)1;
    signed int return_value_semop_2;
    return_value_semop_2=semop(la->semid, &ops, (unsigned long int)1);
    if(!(return_value_semop_2 >= 0))
    {
      syslog(3, "semop down failed: %m");
      exit(1);
    }

    for( ; !(done >= size); done = done + sizeof(struct logmsg) /*88ul*/  + msg->str_len + (unsigned long int)1)
    {
      msg = (struct logmsg *)(log_buff + (signed long int)done);
      log_syslog(msg);
    }
  }

}

// log_init
// file logger.c line 656
signed int log_init(const char *program_name, enum log_dst_type type, signed int level, char *outfile)
{
  char log_dir[4096l];
  char tmp[4096l];
  signed int size = level == 7 ? 32 * 1024 * 1024 : 1 * 1024 * 1024;
  dst_type = type;
  sd_log_level = level;
  log_name = program_name;
  log_nowname = outfile;
  pstrcpy(tmp, (signed int)sizeof(char [4096l]) /*4096ul*/ , outfile);
  char *return_value_dirname_1;
  return_value_dirname_1=dirname(tmp);
  pstrcpy(log_dir, (signed int)sizeof(char [4096l]) /*4096ul*/ , return_value_dirname_1);
  signed long int return_value_random_2;
  return_value_random_2=random();
  semkey = (signed int)return_value_random_2;
  _Bool return_value_is_stdout_console_3;
  signed int return_value_logarea_init_4;
  switch((signed int)type)
  {
    case LOG_DST_STDOUT:
    {
      return_value_is_stdout_console_3=is_stdout_console();
      if(!(return_value_is_stdout_console_3 == (_Bool)0))
        colorize = (_Bool)1;

      break;
    }
    case LOG_DST_SYSLOG:
      openlog(program_name, 0x01, 3 << 3);
    case LOG_DST_DEFAULT:
    {
      return_value_logarea_init_4=logarea_init(size);
      if(!(return_value_logarea_init_4 == 0))
      {
        syslog(3, "failed to initialize the logger\n");
        return 1;
      }

      sheep_pid=getpid();
      logger_pid=fork();
      if(!(logger_pid >= 0))
      {
        syslog(3, "failed to fork the logger process: %m\n");
        return 1;
      }

      if(!(logger_pid == 0))
        syslog(4, "logger pid %d starting\n", logger_pid);

      else
        logger(log_dir, outfile);
      break;
    }
    default:
    {
      log_write(3, "log_init", 705, "unknown type of log destination type: %d", type);
      return -1;
    }
  }
  return 0;
}

// log_syslog
// file logger.c line 360
static void log_syslog(struct logmsg *msg)
{
  char str[1024l];
  signed int len;
  len=format->formatter(str, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, msg, log_fd >= 0);
  signed int tmp_post_1;
  signed int tmp_post_2;
  if((signed int)dst_type == LOG_DST_DEFAULT)
  {
    tmp_post_1 = len;
    len = len + 1;
    str[(signed long int)tmp_post_1] = (char)10;
  }

  else
  {
    tmp_post_2 = len;
    len = len + 1;
    str[(signed long int)tmp_post_2] = (char)0;
  }
  block_sighup();
  if(log_fd >= 0)
    xwrite(log_fd, (const void *)str, (unsigned long int)len);

  else
    syslog(msg->prio, "%s", (const void *)str);
  unblock_sighup();
}

// log_write
// file ../include/logger.h line 45
void log_write(signed int prio, const char *func, signed int line, const char *fmt, ...)
{
  void **ap;
  if(sd_log_level >= prio)
  {
    ap = (void **)&fmt;
    dolog(prio, func, line, fmt, ap);
    ap = ((void **)NULL);
  }

}

// logarea_init
// file logger.c line 289
static signed int logarea_init(signed int size)
{
  signed int shmid;
  shmid=shmget((signed int)0, sizeof(struct logarea) /*56ul*/ , 0644 | 01000 | 02000);
  if(shmid == -1)
  {
    syslog(3, "shmget logarea failed: %m");
    return 1;
  }

  else
  {
    void *return_value_shmat_1;
    return_value_shmat_1=shmat(shmid, (void *)0, 0);
    la = (struct logarea *)return_value_shmat_1;
    if(la == ((struct logarea *)NULL))
    {
      syslog(3, "shmat logarea failed: %m");
      return 1;
    }

    else
    {
      shmctl(shmid, 0, (struct shmid_ds *)(void *)0);
      if(!(size >= 1024))
        size = 1 * 1024 * 1024;

      shmid=shmget((signed int)0, (unsigned long int)size, 0644 | 01000 | 02000);
      if(shmid == -1)
      {
        syslog(3, "shmget msg failed: %m");
        shmdt((const void *)la);
        return 1;
      }

      else
      {
        void *return_value_shmat_2;
        return_value_shmat_2=shmat(shmid, (void *)0, 0);
        la->start = (char *)return_value_shmat_2;
        if(la->start == ((char *)NULL))
        {
          syslog(3, "shmat msg failed: %m");
          shmdt((const void *)la);
          return 1;
        }

        else
        {
          memset((void *)la->start, 0, (unsigned long int)size);
          shmctl(shmid, 0, (struct shmid_ds *)(void *)0);
          la->end = la->start + (signed long int)size;
          la->tail = la->start;
          la->semid=semget(semkey, 1, 0666 | 01000);
          if(!(la->semid >= 0))
          {
            syslog(3, "semget failed: %m");
            shmdt((const void *)la->start);
            shmdt((const void *)la);
            return 1;
          }

          else
          {
            la->semarg.val = 1;
            signed int return_value_semctl_3;
            return_value_semctl_3=semctl(la->semid, 0, 16, la->semarg);
            if(!(return_value_semctl_3 >= 0))
            {
              syslog(3, "semctl failed: %m");
              shmdt((const void *)la->start);
              shmdt((const void *)la);
              return 1;
            }

            else
              return 0;
          }
        }
      }
    }
  }
}

// logger
// file logger.c line 560
static void logger(char *log_dir, char *outfile)
{
  signed int fd;
  void *return_value_xzalloc_1;
  return_value_xzalloc_1=xzalloc((unsigned long int)(la->end - la->start));
  log_buff = (char *)return_value_xzalloc_1;
  if((signed int)dst_type == LOG_DST_DEFAULT)
  {
    log_fd=open(outfile, 0100 | 02 | 02000, 0644);
    if(!(log_fd >= 0))
    {
      syslog(3, "failed to open %s\n", outfile);
      exit(1);
    }

  }

  la->active = (_Bool)1;
  fd=open("/dev/null", 02);
  if(!(fd >= 0))
  {
    syslog(3, "failed to open /dev/null: %m\n");
    exit(1);
  }

  dup2(fd, 0);
  dup2(fd, 1);
  dup2(fd, 2);
  setsid();
  signed int return_value_chdir_2;
  return_value_chdir_2=chdir(log_dir);
  if(!(return_value_chdir_2 >= 0))
  {
    syslog(3, "failed to chdir to %s: %m\n", log_dir);
    exit(1);
  }

  install_crash_handler(crash_handler);
  install_sighandler(1, sighup_handler, (_Bool)0);
  signed int return_value_kill_3;
  return_value_kill_3=kill(sheep_pid, 0);
  if(!(return_value_kill_3 >= 0))
    kill(logger_pid, 1);

  while(!(la->active == (_Bool)0))
  {
    log_flush();
    block_sighup();
    if((signed int)dst_type == LOG_DST_DEFAULT && !(max_logsize == 0l))
    {
      signed long int offset;
      offset=lseek(log_fd, (signed long int)0, 2);
      if(!(offset >= 0l))
        syslog(3, "sheep log error\n");

      else
      {
        unsigned long int log_size = (unsigned long int)offset;
        if(log_size >= (unsigned long int)max_logsize)
          rotate_log();

      }
    }

    unblock_sighup();
    signed int return_value_getppid_4;
    return_value_getppid_4=getppid();
    if(return_value_getppid_4 == 1)
      break;

    sleep((unsigned int)1);
  }
  log_flush();
  free((void *)log_buff);
  free_logarea();
  exit(0);
}

// lookup_event
// file event.c line 92
static struct event_info * lookup_event(signed int fd)
{
  struct event_info key = { .handler=((void (*)(signed int, signed int, void *))NULL), .fd=fd,
    .data=NULL, .rb={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) }, .prio=0 };
  struct event_info *tmp_statement_expression_1;
  struct rb_node *__n = (&events_tree)->rb_node;
  struct event_info *__ret = (struct event_info *)(void *)0;
  struct event_info *__data;
  struct event_info *tmp_statement_expression_2;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression_2 = (struct event_info *)((char *)__mptr - (signed long int)24ul);
    __data = tmp_statement_expression_2;
    signed int __cmp;
    __cmp=event_cmp(&key, __data);
    if(!(__cmp >= 0))
      __n = __n->rb_left;

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  tmp_statement_expression_1 = __ret;
  return tmp_statement_expression_1;
}

// main
// file core.c line 350
signed int main(signed int argc, char **argv)
{
  struct strbuf path = { .alloc=(unsigned long int)0, .len=(unsigned long int)0, .eof=0,
    .buf=(char *)(void *)0 };
  struct strbuf *t;
  signed int ch;
  signed int longindex;
  char *dir = (char *)(void *)0;
  char *cwd;
  unsigned long int return_value_strlen_1;
  signed long int return_value_strtol_2;
  do
  {
    ch=getopt_long(argc, argv, short_options, long_options, &longindex);
    if(!(ch >= 0))
      break;

    switch(ch)
    {
      case 97:
      {
        return_value_strlen_1=strlen(optarg);
        memcpy((void *)sdhost, (const void *)optarg, return_value_strlen_1);
        break;
      }
      case 100:
      {
        sheepfs_debug = 1;
        break;
      }
      case 104:
      {
        usage(0);
        break;
      }
      case 102:
      {
        sheepfs_fg = 1;
        fs_printf = fg_printf;
        break;
      }
      case 107:
      {
        sheepfs_page_cache = 1;
        break;
      }
      case 111:
      {
        sheepfs_object_cache = 1;
        break;
      }
      case 112:
      {
        return_value_strtol_2=strtol(optarg, (char ** restrict )(void *)0, 10);
        sdport = (signed int)return_value_strtol_2;
        if(sdport >= 65536 || !(sdport >= 1))
        {
          fprintf(stderr, "Invalid port number '%s'\n", optarg);
          exit(1);
        }

        break;
      }
      default:
        usage(1);
    }
  }
  while((_Bool)1);
  t=sheepfs_run_cmd("dog");
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(t->buf);
  if(return_value_strlen_3 == 0ul)
  {
    fprintf(stderr, "command dog not found\n");
    exit(1);
  }

  strbuf_release(t);
  if(!(optind == argc))
    dir = argv[(signed long int)optind];

  else
    usage(1);
  cwd=get_current_dir_name();
  if(cwd == ((char *)NULL))
  {
    fprintf(stderr, "%m\n");
    exit(1);
  }

  _Bool return_value_is_xattr_enabled_4;
  return_value_is_xattr_enabled_4=is_xattr_enabled(cwd);
  if(return_value_is_xattr_enabled_4 == (_Bool)0)
  {
    fprintf(stderr, "%s doesn't support xattr\n", cwd);
    exit(1);
  }

  strbuf_addf(&path, "%s/%s", cwd, (const void *)".sheepfs");
  free((void *)cwd);
  memcpy((void *)sheepfs_shadow, (const void *)path.buf, path.len);
  signed int return_value_xmkdir_5;
  return_value_xmkdir_5=xmkdir(sheepfs_shadow, (unsigned int)0755);
  if(!(return_value_xmkdir_5 >= 0))
  {
    fprintf(stderr, "%m\n");
    exit(1);
  }

  strbuf_release(&path);
  signed int return_value_create_sheepfs_layout_6;
  return_value_create_sheepfs_layout_6=create_sheepfs_layout();
  if(!(return_value_create_sheepfs_layout_6 >= 0))
    fprintf(stderr, "failed to create sheepfs layout\n");

  if(sheepfs_fg == 0)
    openlog("sheepfs", 0x02 | 0x01, 3 << 3);

  signed int return_value_sheepfs_main_loop_7;
  return_value_sheepfs_main_loop_7=sheepfs_main_loop(dir);
  return return_value_sheepfs_main_loop_7;
}

// make_path
// file util.c line 554
void make_path(char *path, unsigned long int size, unsigned long int nr_segs, const char **segs)
{
  signed int i = 0;
  for( ; !((unsigned long int)i >= nr_segs); i = i + 1)
  {
    signed int len;
    len=snprintf(path, size, "/%s", segs[(signed long int)i]);
    path = path + (signed long int)len;
    size = size - (unsigned long int)len;
  }
}

// merge
// file util.c line 616
static struct list_node * merge(void *priv, signed int (*cmp)(void *, struct list_node *, struct list_node *), struct list_node *a, struct list_node *b)
{
  struct list_node head;
  struct list_node *tail = &head;
  if(!(a == ((struct list_node *)NULL)) && !(b == ((struct list_node *)NULL)))
  {
    signed int return_value;
    return_value=cmp(priv, a, b);
    if(!(return_value >= 1))
    {
      tail->next = a;
      a = a->next;
    }

    else
    {
      tail->next = b;
      b = b->next;
    }
    tail = tail->next;
  }

  tail->next = (_Bool)a ? a : b;
  return head.next;
}

// merge_and_restore_back_links
// file util.c line 646
static void merge_and_restore_back_links(void *priv, signed int (*cmp)(void *, struct list_node *, struct list_node *), struct list_head *head, struct list_node *a, struct list_node *b)
{
  struct list_node *tail = &head->n;
  if(!(a == ((struct list_node *)NULL)) && !(b == ((struct list_node *)NULL)))
  {
    signed int return_value;
    return_value=cmp(priv, a, b);
    if(!(return_value >= 1))
    {
      tail->next = a;
      a->prev = tail;
      a = a->next;
    }

    else
    {
      tail->next = b;
      b->prev = tail;
      b = b->next;
    }
    tail = tail->next;
  }

  tail->next = (_Bool)a ? a : b;
  cmp(priv, tail->next, tail->next);
  tail->next->prev = tail;
  tail = tail->next;
  tail->next = &head->n;
  head->n.prev = tail;
}

// modify_event
// file event.c line 148
signed int modify_event(signed int fd, unsigned int new_events)
{
  signed int ret;
  struct epoll_event ev;
  struct event_info *ei;
  ei=lookup_event(fd);
  if(ei == ((struct event_info *)NULL))
  {
    log_write(3, "modify_event", 156, "event info for fd %d not found", fd);
    return 1;
  }

  else
  {
    memset((void *)&ev, 0, sizeof(struct epoll_event) /*12ul*/ );
    ev.events = new_events;
    ev.data.ptr = (void *)ei;
    ret=epoll_ctl(efd, 3, fd, &ev);
    if(!(ret == 0))
    {
      log_write(3, "modify_event", 166, "failed to modify epoll event for fd %d: %m", fd);
      return 1;
    }

    else
      return 0;
  }
}

// modnn
// file fec.c line 89
static unsigned char modnn(signed int x)
{
  for( ; x >= 255; x = (x >> 8) + (x & 255))
    x = x - 255;
  return (unsigned char)x;
}

// my_exe_path
// file ../include/util.h line 117
const char * my_exe_path(void)
{
  signed int ret;
  static char path[4096l];
  if((signed int)path[0l] == 0)
  {
    signed long int return_value_readlink_1;
    return_value_readlink_1=readlink("/proc/self/exe", path, sizeof(char [4096l]) /*4096ul*/ );
    ret = (signed int)return_value_readlink_1;
    if(!(ret >= -1))
    {
      log_write(0, "my_exe_path", 504, "PANIC: %m");
      abort();
    }

  }

  return path;
}

// node_id_cmp
// file ../include/sheep.h line 186
static inline signed int node_id_cmp(struct node_id *node1, struct node_id *node2)
{
  signed int cmp;
  cmp=memcmp((const void *)node1->addr, (const void *)node2->addr, sizeof(unsigned char [16l]) /*16ul*/ );
  signed int tmp_statement_expression_1;
  if(!(cmp == 0))
    return cmp;

  else
  {
    unsigned short int _x = node1->port;
    unsigned short int _y = node2->port;
    (void)(&_x == &_y);
    tmp_statement_expression_1 = (signed int)_x < (signed int)_y ? -1 : ((signed int)_x > (signed int)_y ? 1 : 0);
    return tmp_statement_expression_1;
  }
}

// node_info_get_size
// file sheepfs.h line 87
unsigned long int node_info_get_size(const char *path)
{
  struct strbuf *buf;
  unsigned long int len;
  char cmd[512l];
  snprintf(cmd, sizeof(char [512l]) /*512ul*/ , "dog node info -a %s -p %d", (const void *)sdhost, sdport);
  buf=sheepfs_run_cmd(cmd);
  if(buf == ((struct strbuf *)NULL))
    return (unsigned long int)0;

  else
  {
    len=shadow_file_write(path, buf->buf, buf->len);
    strbuf_release(buf);
    free((void *)buf);
    return len;
  }
}

// node_info_read
// file sheepfs.h line 86
signed int node_info_read(const char *path, char *buf, unsigned long int size, signed long int ignore)
{
  signed int return_value_shadow_file_read_1;
  return_value_shadow_file_read_1=shadow_file_read(path, buf, size, (signed long int)0);
  return return_value_shadow_file_read_1;
}

// node_list_get_size
// file sheepfs.h line 85
unsigned long int node_list_get_size(const char *path)
{
  struct strbuf *buf;
  unsigned long int len;
  char cmd[512l];
  snprintf(cmd, sizeof(char [512l]) /*512ul*/ , "dog node list -a %s -p %d", (const void *)sdhost, sdport);
  buf=sheepfs_run_cmd(cmd);
  if(buf == ((struct strbuf *)NULL))
    return (unsigned long int)0;

  else
  {
    len=shadow_file_write(path, buf->buf, buf->len);
    strbuf_release(buf);
    return len;
  }
}

// node_list_read
// file sheepfs.h line 84
signed int node_list_read(const char *path, char *buf, unsigned long int size, signed long int ignore)
{
  signed int return_value_shadow_file_read_1;
  return_value_shadow_file_read_1=shadow_file_read(path, buf, size, (signed long int)0);
  return return_value_shadow_file_read_1;
}

// object_create_entry
// file http.c line 276
static signed int object_create_entry(const char *entry, const char *url)
{
  struct strbuf buf = { .alloc=(unsigned long int)0, .len=(unsigned long int)0, .eof=0,
    .buf=(char *)(void *)0 };
  char *args[3l];
  char path[4096l];
  signed int nr;
  signed int ret = -22;
  unsigned long int size;
  nr=split_path(entry, sizeof(char *[3l]) /*24ul*/  / sizeof(char *) /*8ul*/ , args);
  if(!((unsigned long int)nr == 3ul))
    fs_printf("object_create_entry", 285, "Invalid argument %d, %s", nr, entry);

  else
  {
    strbuf_addf(&buf, "%s", (const void *)"/http");
    signed int i = 0;
    for( ; !(i >= nr); i = i + 1)
    {
      strbuf_addf(&buf, "/%s", args[(signed long int)i]);
      snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%.*s", (signed int)buf.len, buf.buf);
      if(i == nr + -1)
      {
        signed int return_value_shadow_file_create_1;
        return_value_shadow_file_create_1=shadow_file_create(path);
        if(!(return_value_shadow_file_create_1 >= 0))
          fs_printf("object_create_entry", 295, "Create file %s fail", (const void *)path);

        size=curl_get_object_size(url);
        if(!(size >= 1ul))
        {
          fs_printf("object_create_entry", 300, "Failed to get size of object");
          shadow_file_delete(path);
        }

        signed int return_value_shadow_file_setxattr_2;
        return_value_shadow_file_setxattr_2=shadow_file_setxattr(path, "user.object.size", (const void *)&size, sizeof(unsigned long int) /*8ul*/ );
        if(!(return_value_shadow_file_setxattr_2 >= 0))
        {
          fs_printf("object_create_entry", 307, "Failed to setxattr for %s", (const void *)"user.object.size");
          shadow_file_delete(path);
        }

        signed int return_value_sheepfs_set_op_3;
        return_value_sheepfs_set_op_3=sheepfs_set_op(path, (unsigned int)13);
        if(!(return_value_sheepfs_set_op_3 >= 0))
        {
          fs_printf("object_create_entry", 312, "Set_op %s fail", (const void *)path);
          shadow_file_delete(path);
        }

      }

      else
      {
        signed int return_value_shadow_dir_create_4;
        return_value_shadow_dir_create_4=shadow_dir_create(path);
        if(!(return_value_shadow_dir_create_4 >= 0))
          fs_printf("object_create_entry", 318, "Create dir %s fail", (const void *)path);

        signed int return_value_sheepfs_set_op_5;
        return_value_sheepfs_set_op_5=sheepfs_set_op(path, (unsigned int)14);
        if(!(return_value_sheepfs_set_op_5 >= 0))
        {
          fs_printf("object_create_entry", 322, "Set_op %s fail", (const void *)path);
          shadow_dir_delete(path);
        }

      }
    }
    ret = 0;
  }

out:
  ;
  strbuf_release(&buf);
  return ret;
}

// object_get_size
// file sheepfs.h line 120
unsigned long int object_get_size(const char *path)
{
  unsigned long int object_size;
  signed int return_value_shadow_file_getxattr_1;
  return_value_shadow_file_getxattr_1=shadow_file_getxattr(path, "user.object.size", (void *)&object_size, sizeof(unsigned long int) /*8ul*/ );
  if(!(return_value_shadow_file_getxattr_1 >= 0))
    return (unsigned long int)0;

  else
    return object_size;
}

// object_read
// file sheepfs.h line 119
signed int object_read(const char *path, char *buf, unsigned long int size, signed long int offset)
{
  char url[4096l];
  char *pos;
  signed int ret;
  pos=strstr(path, "/http");
  unsigned long int return_value_strlen_1;
  unsigned long int return_value_strlen_2;
  unsigned long int return_value_strlen_3;
  unsigned long int return_value_curl_read_object_4;
  if(pos == ((char *)NULL))
  {
    fs_printf("object_read", 239, "Invalid Path %s", path);
    ret = -22;
  }

  else
  {
    return_value_strlen_1=strlen("/http");
    pos = pos + (signed long int)return_value_strlen_1;
    return_value_strlen_2=strlen(path);
    return_value_strlen_3=strlen("/http");
    ret=generate_url(pos, (signed int)(return_value_strlen_2 - return_value_strlen_3), url, 4096);
    if(ret == 0)
    {
      return_value_curl_read_object_4=curl_read_object(url, buf, size, offset);
      ret = (signed int)return_value_curl_read_object_4;
    }

  }

out:
  ;
  return ret;
}

// object_unlink
// file sheepfs.h line 121
signed int object_unlink(const char *path)
{
  signed int return_value_shadow_file_delete_1;
  return_value_shadow_file_delete_1=shadow_file_delete(path);
  return return_value_shadow_file_delete_1;
}

// oid_to_vid
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid(unsigned long int oid)
{
  return (unsigned int)((oid & (unsigned long int)0x00FFFFFF00000000) >> 32);
}

// option_get_help
// file option.c line 53
const char * option_get_help(struct sd_option *sd_opts, signed int ch)
{
  struct sd_option *opt = sd_opts;
  for( ; !(opt->name == ((const char *)NULL)); opt = opt + 1l)
    if(opt->ch == ch)
      return opt->help;

  return (const char *)(void *)0;
}

// option_parse
// file option.c line 104
signed int option_parse(char *arg, const char *delim, struct option_parser *parsers)
{
  char *savep;
  char *opt;
  struct option_parser *iter = (struct option_parser *)(void *)0;
  opt=strtok_r(arg, delim, &savep);
  do
  {
    iter = parsers;
    for( ; !(iter->option == ((const char *)NULL)); iter = iter + 1l)
    {
      signed int len;
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(iter->option);
      len = (signed int)return_value_strlen_1;
      signed int return_value_strncmp_2;
      return_value_strncmp_2=strncmp(iter->option, opt, (unsigned long int)len);
      if(return_value_strncmp_2 == 0)
      {
        signed int return_value;
        return_value=iter->parser(opt + (signed long int)len);
        if(!(return_value >= 0))
          return -1;

        break;
      }

    }
    if(iter->option == ((const char *)NULL))
    {
      log_write(3, "option_parse", 121, "invalid option %s", opt);
      return -1;
    }

    opt=strtok_r((char *)(void *)0, delim, &savep);
  }
  while(!(opt == ((char *)NULL)));
  return 0;
}

// option_parse_size
// file option.c line 64
signed int option_parse_size(const char *value, unsigned long int *ret)
{
  char *postfix;
  double sizef;
  sizef=strtod(value, &postfix);
  if(!((signed int)*postfix == 0))
  {
    if(!((signed int)postfix[1l] == 0))
      goto err;

  }

  switch((signed int)*postfix)
  {
    case 80:

    case 112:
      sizef = sizef * (double)1024;
    case 84:

    case 116:
      sizef = sizef * (double)1024;
    case 71:

    case 103:
      sizef = sizef * (double)1024;
    case 77:

    case 109:
      sizef = sizef * (double)1024;
    case 75:

    case 107:
      sizef = sizef * (double)1024;
    case 98:

    case 0:
    {
      *ret = (unsigned long int)sizef;
      break;
    }
    default:
    {

    err:
      ;
      log_write(3, "option_parse_size", 95, "Invalid size '%s'", value);
      log_write(3, "option_parse_size", 97, "You may use k, M, G, T or P suffixes for kilobytes, megabytes, gigabytes, terabytes and petabytes.");
      return -1;
    }
  }
  return 0;
}

// pstrcpy
// file ../include/util.h line 105
void pstrcpy(char *buf, signed int buf_size, const char *str)
{
  signed int c;
  char *q = buf;
  const char *tmp_post_1;
  char *tmp_post_2;
  if(buf_size >= 1)
  {
    for( ; (_Bool)1; *tmp_post_2 = (char)c)
    {
      tmp_post_1 = str;
      str = str + 1l;
      c = (signed int)*tmp_post_1;
      if(c == 0 || q >= buf + (signed long int)buf_size + -1l)
        break;

      tmp_post_2 = q;
      q = q + 1l;
    }
    *q = (char)0;
  }

}

// purge_directory
// file util.c line 346
signed int purge_directory(const char *dir_path)
{
  signed int ret = 0;
  struct stat s;
  struct __dirstream *dir;
  struct dirent *d;
  char path[4096l];
  dir=opendir(dir_path);
  if(dir == ((struct __dirstream *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 2))
      log_write(3, "purge_directory", 357, "failed to open %s: %m", dir_path);

    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    return -(*return_value___errno_location_2);
  }

  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  do
  {
    d=readdir(dir);
    if(d == ((struct dirent *)NULL))
      break;

    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(d->d_name, ".");
    if(return_value_strcmp_3 == 0)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_strcmp_4=strcmp(d->d_name, "..");
      tmp_if_expr_5 = !(return_value_strcmp_4 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_5)
    {
      snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", dir_path, (const void *)d->d_name);
      ret=stat(path, &s);
      if(!(ret == 0))
      {
        log_write(3, "purge_directory", 368, "failed to stat %s: %m", (const void *)path);
        break;
      }

      if((61440u & s.st_mode) == 16384u)
        ret=rmdir_r(path);

      else
        ret=unlink(path);
      if(!(ret == 0))
      {
        log_write(3, "purge_directory", 378, "failed to remove %s %s: %m", (s.st_mode & (unsigned int)0170000) == (unsigned int)0040000 ? "directory" : "file", (const void *)path);
        break;
      }

    }

  }
  while((_Bool)1);

out:
  ;
  closedir(dir);
  return ret;
}

// put_socket_fd
// file volume.c line 128
static inline void put_socket_fd(struct vdi_inode *vdi, signed int idx)
{
  uatomic_set_false(&vdi->socket_in_use[(signed long int)idx]);
}

// queue_work
// file work.c line 270
void queue_work(struct work_queue *q, struct work *work)
{
  struct wq_info *wi;
  struct wq_info *tmp_statement_expression_1;
  const struct work_queue *__mptr = q;
  tmp_statement_expression_1 = (struct wq_info *)((char *)__mptr - (signed long int)208ul);
  wi = tmp_statement_expression_1;
  __uatomic_inc((void *)&wi->nr_queued_work, (signed int)sizeof(unsigned long int) /*8ul*/ );
  sd_mutex_lock(&wi->pending_lock);
  _Bool return_value_wq_need_grow_2;
  return_value_wq_need_grow_2=wq_need_grow(wi);
  if(!(return_value_wq_need_grow_2 == (_Bool)0))
    create_worker_threads(wi, wi->nr_threads * (unsigned long int)2);

  list_add_tail(&work->w_list, &wi->q.pending_list);
  sd_mutex_unlock(&wi->pending_lock);
  sd_cond_signal(&wi->pending_cond);
}

// rb_erase
// file ../include/rbtree.h line 57
void rb_erase(struct rb_node *node, struct rb_root *root)
{
  struct rb_node *child;
  struct rb_node *parent;
  signed int color;
  if(node->rb_left == ((struct rb_node *)NULL))
    child = node->rb_right;

  else
    if(node->rb_right == ((struct rb_node *)NULL))
      child = node->rb_left;

    else
    {
      struct rb_node *old = node;
      struct rb_node *left;
      node = node->rb_right;
      do
      {
        left = node->rb_left;
        if(left == ((struct rb_node *)NULL))
          break;

        node = left;
      }
      while((_Bool)1);
      if(!((18446744073709551612ul & old->rb_parent_color) == 0ul))
      {
        if(((struct rb_node *)(18446744073709551612ul & old->rb_parent_color))->rb_left == old)
          ((struct rb_node *)(old->rb_parent_color & (unsigned long int)~3))->rb_left = node;

        else
          ((struct rb_node *)(old->rb_parent_color & (unsigned long int)~3))->rb_right = node;
      }

      else
        root->rb_node = node;
      child = node->rb_right;
      parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
      color = (signed int)(node->rb_parent_color & (unsigned long int)1);
      if(parent == old)
        parent = node;

      else
      {
        if(!(child == ((struct rb_node *)NULL)))
          rb_set_parent(child, parent);

        parent->rb_left = child;
        node->rb_right = old->rb_right;
        rb_set_parent(old->rb_right, node);
      }
      node->rb_parent_color = old->rb_parent_color;
      node->rb_left = old->rb_left;
      rb_set_parent(old->rb_left, node);
      goto color;
    }
  parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
  color = (signed int)(node->rb_parent_color & (unsigned long int)1);
  if(!(child == ((struct rb_node *)NULL)))
    rb_set_parent(child, parent);

  if(!(parent == ((struct rb_node *)NULL)))
  {
    if(parent->rb_left == node)
      parent->rb_left = child;

    else
      parent->rb_right = child;
  }

  else
    root->rb_node = child;

color:
  ;
  if(color == 1)
    __rb_erase_color(child, parent, root);

}

// rb_first
// file ../include/rbtree.h line 62
struct rb_node * rb_first(struct rb_root *root)
{
  struct rb_node *n = root->rb_node;
  if(n == ((struct rb_node *)NULL))
    return (struct rb_node *)(void *)0;

  else
  {
    for( ; !(n->rb_left == ((struct rb_node *)NULL)); n = n->rb_left)
      ;
    return n;
  }
}

// rb_insert_color
// file ../include/rbtree.h line 56
void rb_insert_color(struct rb_node *node, struct rb_root *root)
{
  struct rb_node *parent;
  struct rb_node *gparent;
  do
  {
    parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
    if(parent == ((struct rb_node *)NULL))
      break;

    if(!((1ul & parent->rb_parent_color) == 0ul))
      break;

    gparent = (struct rb_node *)(parent->rb_parent_color & (unsigned long int)~3);
    if(parent == gparent->rb_left)
    {
      struct rb_node *rb_insert_color__1__1__1__uncle = gparent->rb_right;
      if(!(rb_insert_color__1__1__1__uncle == ((struct rb_node *)NULL)))
      {
        if((1ul & rb_insert_color__1__1__1__uncle->rb_parent_color) == 0ul)
        {
          do
            rb_insert_color__1__1__1__uncle->rb_parent_color = rb_insert_color__1__1__1__uncle->rb_parent_color | (unsigned long int)1;
          while((_Bool)0);
          do
            parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
          while((_Bool)0);
          do
            gparent->rb_parent_color = gparent->rb_parent_color & (unsigned long int)~1;
          while((_Bool)0);
          node = gparent;
          continue;
        }

      }

      if(parent->rb_right == node)
      {
        struct rb_node *rb_insert_color__1__1__1__2__tmp;
        __rb_rotate_left(parent, root);
        rb_insert_color__1__1__1__2__tmp = parent;
        parent = node;
        node = rb_insert_color__1__1__1__2__tmp;
      }

      do
        parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
      while((_Bool)0);
      do
        gparent->rb_parent_color = gparent->rb_parent_color & (unsigned long int)~1;
      while((_Bool)0);
      __rb_rotate_right(gparent, root);
    }

    else
    {
      struct rb_node *uncle = gparent->rb_left;
      if(!(uncle == ((struct rb_node *)NULL)))
      {
        if(!((1ul & uncle->rb_parent_color) == 0ul))
          goto __CPROVER_DUMP_L12;

        do
          uncle->rb_parent_color = uncle->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          gparent->rb_parent_color = gparent->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        node = gparent;
      }

      else
      {

      __CPROVER_DUMP_L12:
        ;
        if(parent->rb_left == node)
        {
          struct rb_node *tmp;
          __rb_rotate_right(parent, root);
          tmp = parent;
          parent = node;
          node = tmp;
        }

        do
          parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          gparent->rb_parent_color = gparent->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        __rb_rotate_left(gparent, root);
      }
    }
  }
  while((_Bool)1);
  do
    root->rb_node->rb_parent_color = root->rb_node->rb_parent_color | (unsigned long int)1;
  while((_Bool)0);
}

// rb_last
// file rbtree.c line 267
struct rb_node * rb_last(struct rb_root *root)
{
  struct rb_node *n = root->rb_node;
  if(n == ((struct rb_node *)NULL))
    return (struct rb_node *)(void *)0;

  else
  {
    for( ; !(n->rb_right == ((struct rb_node *)NULL)); n = n->rb_right)
      ;
    return n;
  }
}

// rb_link_node
// file ../include/rbtree.h line 69
static inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link)
{
  node->rb_parent_color = (unsigned long int)parent;
  node->rb_right = (struct rb_node *)(void *)0;
  node->rb_left = node->rb_right;
  *rb_link = node;
}

// rb_link_node_link1
// file ../include/rbtree.h line 69
static inline void rb_link_node_link1(struct rb_node *node_link1, struct rb_node *parent_link1, struct rb_node **rb_link_link1)
{
  node_link1->rb_parent_color = (unsigned long int)parent_link1;
  node_link1->rb_right = (struct rb_node *)(void *)0;
  node_link1->rb_left = node_link1->rb_right;
  *rb_link_link1 = node_link1;
}

// rb_link_node_link2
// file ../include/rbtree.h line 69
static inline void rb_link_node_link2(struct rb_node *node_link2, struct rb_node *parent_link2, struct rb_node **rb_link_link2)
{
  node_link2->rb_parent_color = (unsigned long int)parent_link2;
  node_link2->rb_right = (struct rb_node *)(void *)0;
  node_link2->rb_left = node_link2->rb_right;
  *rb_link_link2 = node_link2;
}

// rb_next
// file ../include/rbtree.h line 60
struct rb_node * rb_next(struct rb_node *node)
{
  struct rb_node *parent;
  if((struct rb_node *)(18446744073709551612ul & node->rb_parent_color) == node)
    return (struct rb_node *)(void *)0;

  else
    if(!(node->rb_right == ((struct rb_node *)NULL)))
    {
      node = node->rb_right;
      for( ; !(node->rb_left == ((struct rb_node *)NULL)); node = node->rb_left)
        ;
      return (struct rb_node *)node;
    }

    else
    {
      do
      {
        parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
        if(parent == ((struct rb_node *)NULL))
          break;

        if(!(node == parent->rb_right))
          break;

        node = parent;
      }
      while((_Bool)1);
      return parent;
    }
}

// rb_prev
// file rbtree.c line 311
struct rb_node * rb_prev(struct rb_node *node)
{
  struct rb_node *parent;
  if((struct rb_node *)(18446744073709551612ul & node->rb_parent_color) == node)
    return (struct rb_node *)(void *)0;

  else
    if(!(node->rb_left == ((struct rb_node *)NULL)))
    {
      node = node->rb_left;
      for( ; !(node->rb_right == ((struct rb_node *)NULL)); node = node->rb_right)
        ;
      return (struct rb_node *)node;
    }

    else
    {
      do
      {
        parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
        if(parent == ((struct rb_node *)NULL))
          break;

        if(!(node == parent->rb_left))
          break;

        node = parent;
      }
      while((_Bool)1);
      return parent;
    }
}

// rb_replace_node
// file rbtree.c line 339
void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root)
{
  struct rb_node *parent = (struct rb_node *)(victim->rb_parent_color & (unsigned long int)~3);
  if(!(parent == ((struct rb_node *)NULL)))
  {
    if(victim == parent->rb_left)
      parent->rb_left = new;

    else
      parent->rb_right = new;
  }

  else
    root->rb_node = new;
  if(!(victim->rb_left == ((struct rb_node *)NULL)))
    rb_set_parent(victim->rb_left, new);

  if(!(victim->rb_right == ((struct rb_node *)NULL)))
    rb_set_parent(victim->rb_right, new);

  *new = *victim;
}

// rb_set_color
// file ../include/rbtree.h line 31
static inline void rb_set_color(struct rb_node *rb, signed int color)
{
  rb->rb_parent_color = rb->rb_parent_color & (unsigned long int)~1 | (unsigned long int)color;
}

// rb_set_parent
// file ../include/rbtree.h line 27
static inline void rb_set_parent(struct rb_node *rb, struct rb_node *p)
{
  rb->rb_parent_color = rb->rb_parent_color & (unsigned long int)3 | (unsigned long int)p;
}

// register_event
// file ../include/event.h line 30
static inline signed int register_event(signed int fd, void (*h)(signed int, signed int, void *), void *data)
{
  signed int return_value_register_event_prio_1;
  return_value_register_event_prio_1=register_event_prio(fd, h, data, 0);
  return return_value_register_event_prio_1;
}

// register_event_link1
// file ../include/event.h line 30
static inline signed int register_event_link1(signed int fd_link1, void (*h_link1)(signed int, signed int, void *), void *data_link1)
{
  signed int return_value_register_event_prio_1_link1;
  return_value_register_event_prio_1_link1=register_event_prio(fd_link1, h_link1, data_link1, 0);
  return return_value_register_event_prio_1_link1;
}

// register_event_prio
// file event.c line 99
signed int register_event_prio(signed int fd, void (*h)(signed int, signed int, void *), void *data, signed int prio)
{
  signed int ret;
  struct epoll_event ev;
  struct event_info *ei;
  void *return_value_xzalloc_1;
  return_value_xzalloc_1=xzalloc(sizeof(struct event_info) /*56ul*/ );
  ei = (struct event_info *)return_value_xzalloc_1;
  ei->fd = fd;
  ei->handler = h;
  ei->data = data;
  ei->prio = prio;
  memset((void *)&ev, 0, sizeof(struct epoll_event) /*12ul*/ );
  ev.events = (unsigned int)1;
  ev.data.ptr = (void *)ei;
  ret=epoll_ctl(efd, 1, fd, &ev);
  struct event_info *tmp_statement_expression_2;
  if(!(ret == 0))
  {
    log_write(3, "register_event_prio", 117, "failed to add epoll event for fd %d: %m", fd);
    free((void *)ei);
  }

  else
  {
    struct rb_node **__n = &(&events_tree)->rb_node;
    struct rb_node *__parent = (struct rb_node *)(void *)0;
    struct event_info *__old = (struct event_info *)(void *)0;
    struct event_info *__data;
    while(!(*__n == ((struct rb_node *)NULL)))
    {
      const struct rb_node *__mptr = *__n;
      tmp_statement_expression_2 = (struct event_info *)((char *)__mptr - (signed long int)24ul);
      __data = tmp_statement_expression_2;
      signed int __cmp;
      __cmp=event_cmp(ei, __data);
      __parent = *__n;
      if(!(__cmp >= 0))
        __n = &(*__n)->rb_left;

      else
        if(__cmp >= 1)
          __n = &(*__n)->rb_right;

        else
        {
          __old = __data;
          break;
        }
    }
    if(__old == ((struct event_info *)NULL))
    {
      rb_link_node_link1(&ei->rb, __parent, __n);
      rb_insert_color(&ei->rb, &events_tree);
    }

    __old;
  }
  return ret;
}

// reraise_crash_signal
// file ../include/util.h line 113
void reraise_crash_signal(signed int signo, signed int status)
{
  signed int ret;
  ret=raise(signo);
  char *return_value_strsignal_1;
  char *return_value_strsignal_2;
  if(!(ret == 0))
  {
    return_value_strsignal_1=strsignal(signo);
    log_write(0, "reraise_crash_signal", 468, "failed to re-raise signal %d (%s).", signo, return_value_strsignal_1);
  }

  else
  {
    return_value_strsignal_2=strsignal(signo);
    log_write(0, "reraise_crash_signal", 472, "default handler for the re-raised signal %d (%s) didn't work expectedly", signo, return_value_strsignal_2);
  }
  exit(status);
}

// reset_socket_pool
// file volume.c line 398
signed int reset_socket_pool(void)
{
  struct vdi_inode *vdi;
  signed int ret = 0;
  sd_read_lock(&vdi_inode_tree_lock);
  struct rb_node *__p404;
  __p404=rb_first(&vdi_inode_tree);
  struct rb_node *__n404;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  struct vdi_inode *tmp_statement_expression_2;
  do
  {
    if(!(__p404 == ((struct rb_node *)NULL)))
    {
      __n404=rb_next(__p404);
      tmp_if_expr_1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
    {
      const struct rb_node *__mptr = __p404;
      tmp_statement_expression_2 = (struct vdi_inode *)((char *)__mptr - (signed long int)0ul);
      vdi = tmp_statement_expression_2;
      tmp_if_expr_3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
      break;

    destroy_socket_pool(vdi->socket_pool, 31);
    signed int return_value_setup_socket_pool_4;
    return_value_setup_socket_pool_4=setup_socket_pool(vdi->socket_pool, 31);
    if(!(return_value_setup_socket_pool_4 >= 0))
    {
      ret = -1;
      goto out;
    }

    __p404 = __n404;
  }
  while((_Bool)1);

out:
  ;
  sd_rw_unlock(&vdi_inode_tree_lock);
  return ret;
}

// revalidate_node
// file sockfd_cache.c line 293
static inline signed int revalidate_node(struct node_id *nid)
{
  _Bool use_io = (_Bool)(nid->io_port != 0 ? 1 : 0);
  signed int fd;
  if(!(use_io == (_Bool)0))
  {
    fd=connect_to_addr(nid->io_addr, (signed int)nid->io_port);
    if(fd >= 0)
      goto alive;

  }

  fd=connect_to_addr(nid->addr, (signed int)nid->port);
  if(!(fd >= 0))
    return 0;

  else
  {

  alive:
    ;
    close(fd);
    sockfd_cache_add(nid);
    return 1;
  }
}

// rmdir_r
// file ../include/util.h line 107
signed int rmdir_r(const char *dir_path)
{
  signed int ret;
  ret=purge_directory(dir_path);
  if(ret == 0)
    ret=rmdir(dir_path);

  return ret;
}

// rotate_log
// file logger.c line 453
static void rotate_log(void)
{
  signed int new_fd;
  signed int return_value_access_1;
  return_value_access_1=access(log_nowname, 4);
  if(return_value_access_1 == 0)
  {
    char old_logfile[256l];
    signed long int t;
    struct tm tm;
    time(&t);
    localtime_r((const signed long int *)&t, &tm);
    snprintf(old_logfile, sizeof(char [256l]) /*256ul*/ , "%s.%04d-%02d-%02d-%02d-%02d", log_nowname, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min);
    rename(log_nowname, old_logfile);
  }

  new_fd=open(log_nowname, 02 | 0100 | 02000, 0644);
  if(!(new_fd >= 0))
  {
    syslog(3, "failed to create new log file\n");
    exit(1);
  }

  signed int return_value_dup2_2;
  return_value_dup2_2=dup2(new_fd, log_fd);
  if(!(return_value_dup2_2 >= 0))
  {
    syslog(3, "failed to dup2 the log fd\n");
    exit(1);
  }

  close(new_fd);
}

// sd_backtrace
// file logger.c line 806
void sd_backtrace(void)
{
  void *addrs[1024l];
  signed int i;
  signed int n;
  n=backtrace(addrs, (signed int)(sizeof(void *[1024l]) /*8192ul*/  / sizeof(void *) /*8ul*/ ));
  i = 1;
  char *return_value_fgets_2;
  _Bool tmp_if_expr_4;
  char *return_value_chomp_3;
  for( ; !(i >= n); i = i + 1)
  {
    void *addr = addrs[(signed long int)i];
    signed long int addr_array_size0;
    addr_array_size0=sysconf(0);
    char cmd[addr_array_size0];
    char info[256l];
    char **str;
    struct _IO_FILE *f;
    addr = (void *)((char *)addr - (signed long int)1);
    const char *return_value_my_exe_path_1;
    return_value_my_exe_path_1=my_exe_path();
    snprintf(cmd, (unsigned long int)addr_array_size0, "addr2line -s -e %s -f -i %p | perl -e '@a=<>; chomp @a; print \"_a[1]: _a[0]\"'", return_value_my_exe_path_1, addr);
    f=popen(cmd, "r");
    if(!(f == ((struct _IO_FILE *)NULL)))
    {
      return_value_fgets_2=fgets(info, (signed int)sizeof(char [256l]) /*256ul*/ , f);
      if(!(return_value_fgets_2 == ((char *)NULL)))
      {
        if(!((signed int)info[0l] == 63))
          tmp_if_expr_4 = (signed int)info[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
        {
          return_value_chomp_3=chomp(info);
          log_write(0, "sd_backtrace", 833, "%s", return_value_chomp_3);
        }

        else
          goto fallback_close;
        pclose(f);
        goto __CPROVER_DUMP_L8;
      }


    fallback_close:
      ;
      pclose(f);
    }


  fallback:
    ;
    str=backtrace_symbols(&addr, 1);
    log_write(0, "sd_backtrace", 847, "%s", *str);
    free((void *)str);

  __CPROVER_DUMP_L8:
    ;
  }
  dump_stack_frames();
}

// sd_cond_init
// file ../include/util.h line 348
static inline void sd_cond_init(struct sd_cond *cond)
{
  signed int ret;
  do
    ret=pthread_cond_init(&cond->cond, (const union anonymous_8 *)(void *)0);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_cond_init", 357, "PANIC: failed to initialize a lock, %s", return_value_strerror_1);
    abort();
  }

}

// sd_cond_signal
// file ../include/util.h line 373
static inline signed int sd_cond_signal(struct sd_cond *cond)
{
  signed int return_value_pthread_cond_signal_1;
  return_value_pthread_cond_signal_1=pthread_cond_signal(&cond->cond);
  return return_value_pthread_cond_signal_1;
}

// sd_cond_wait
// file ../include/util.h line 378
static inline signed int sd_cond_wait(struct sd_cond *cond, struct sd_mutex *mutex)
{
  signed int return_value_pthread_cond_wait_1;
  return_value_pthread_cond_wait_1=pthread_cond_wait(&cond->cond, &mutex->mutex);
  return return_value_pthread_cond_wait_1;
}

// sd_destroy_cond
// file ../include/util.h line 361
static inline void sd_destroy_cond(struct sd_cond *cond)
{
  signed int ret;
  do
    ret=pthread_cond_destroy(&cond->cond);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_destroy_cond", 370, "PANIC: failed to destroy a lock, %s", return_value_strerror_1);
    abort();
  }

}

// sd_destroy_mutex
// file ../include/util.h line 299
static inline void sd_destroy_mutex(struct sd_mutex *mutex)
{
  signed int ret;
  do
    ret=pthread_mutex_destroy(&mutex->mutex);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_destroy_mutex", 308, "PANIC: failed to destroy a lock, %s", return_value_strerror_1);
    abort();
  }

}

// sd_init_mutex
// file ../include/util.h line 273
static inline void sd_init_mutex(struct sd_mutex *mutex)
{
  signed int ret;
  do
    ret=pthread_mutex_init(&mutex->mutex, (const union anonymous_8 *)(void *)0);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_init_mutex", 282, "PANIC: failed to initialize a lock, %s", return_value_strerror_1);
    abort();
  }

}

// sd_inode_copy_vdis
// file sd_inode.c line 700
extern void sd_inode_copy_vdis(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), unsigned int *data_vdi_id, unsigned char store_policy, unsigned char nr_copies, unsigned char copy_policy, struct sd_inode *newi)
{
  struct sd_extent_header *header = (struct sd_extent_header *)data_vdi_id;
  struct sd_extent_header *leaf_node;
  struct sd_extent_idx *last_idx;
  struct sd_extent_idx *old_iter_idx;
  struct sd_extent_idx *new_iter_idx;
  unsigned long int oid;
  void *tmp;
  memcpy((void *)newi->data_vdi_id, (const void *)data_vdi_id, sizeof(unsigned int [1048576l]) /*4194304ul*/ );
  unsigned int tmp_post_2;
  if((signed int)store_policy == 1)
  {
    if((signed int)header->depth >= 2)
    {
      last_idx = (struct sd_extent_idx *)((char *)data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)data_vdi_id)->entries;
      old_iter_idx = (struct sd_extent_idx *)((char *)data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
      new_iter_idx = (struct sd_extent_idx *)((char *)newi->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
      void *return_value_xvalloc_1;
      return_value_xvalloc_1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
      leaf_node = (struct sd_extent_header *)return_value_xvalloc_1;
      tmp = (void *)leaf_node;
      if(!(old_iter_idx == last_idx))
      {
        reader(old_iter_idx->oid, &tmp, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0);
        tmp_post_2 = newi->btree_counter;
        newi->btree_counter = newi->btree_counter + 1u;
        oid=vid_to_btree_oid(newi->vdi_id, tmp_post_2);
        writer(oid, (void *)leaf_node, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)nr_copies, (signed int)copy_policy, (_Bool)1, (_Bool)0);
        new_iter_idx->oid = oid;
        old_iter_idx = old_iter_idx + 1l;
        new_iter_idx = new_iter_idx + 1l;
      }

      free((void *)leaf_node);
    }

  }

}

// sd_inode_get_meta_size
// file sd_inode.c line 626
extern unsigned int sd_inode_get_meta_size(struct sd_inode *inode, unsigned long int size)
{
  struct sd_extent_header *header;
  unsigned int len;
  if((signed int)inode->store_policy == 0)
  {
    unsigned long int return_value_count_data_objs_1;
    return_value_count_data_objs_1=count_data_objs(inode);
    len = (unsigned int)(return_value_count_data_objs_1 * sizeof(unsigned int) /*4ul*/ );
    if(!(size + 18446744073709546952ul + 18446744073709551612ul >= (unsigned long int)len))
      len = (unsigned int)((size - 4664ul) - sizeof(unsigned int) /*4ul*/ );

  }

  else
  {
    header = (struct sd_extent_header *)inode->data_vdi_id;
    len = (unsigned int)sizeof(struct sd_extent_header) /*8ul*/ ;
    if((signed int)header->depth == 1)
      len = len + (unsigned int)(sizeof(struct sd_extent) /*8ul*/  * (unsigned long int)header->entries);

    else
      if((signed int)header->depth == 2)
        len = len + (unsigned int)(sizeof(struct sd_extent_idx) /*16ul*/  * (unsigned long int)header->entries);

      else
      {
        log_write(0, "sd_inode_get_meta_size", 644, "PANIC: Depth of B-tree is out of range(depth: %u)", header->depth);
        abort();
      }
  }
  return len;
}

// sd_inode_get_vid
// file ../include/sheepdog_proto.h line 278
extern unsigned int sd_inode_get_vid(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx)
{
  struct find_path path;
  signed int ret;
  if((signed int)inode->store_policy == 0)
    return inode->data_vdi_id[(signed long int)idx];

  else
  {
    if(inode->data_vdi_id[0l] == 0u)
      return (unsigned int)0;

    memset((void *)&path, 0, sizeof(struct find_path) /*32ul*/ );
    ret=search_whole_btree(reader, inode, idx, &path);
    if(ret == 0x1C)
      return path.p_ext->vdi_id;

    if(!(path.p_ext_header == ((struct sd_extent_header *)NULL)))
      free((void *)path.p_ext_header);

  }
  return (unsigned int)0;
}

// sd_inode_init
// file sd_inode.c line 243
extern void sd_inode_init(void *data, signed int depth)
{
  struct sd_extent_header *header = (struct sd_extent_header *)data;
  header->magic = (unsigned short int)0x6274;
  header->depth = (unsigned short int)depth;
  header->entries = (unsigned int)0;
}

// sd_inode_set_vid
// file ../include/sheepdog_proto.h line 280
extern void sd_inode_set_vid(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx, unsigned int vdi_id)
{
  struct sd_extent_header *header;
  struct find_path path;
  unsigned long int offset;
  signed int ret;
  path.p_ext_header = (struct sd_extent_header *)(void *)0;
  if((signed int)inode->store_policy == 0)
    inode->data_vdi_id[(signed long int)idx] = vdi_id;

  else
  {
    if(inode->data_vdi_id[0l] == 0u)
      sd_inode_init((void *)inode->data_vdi_id, 1);

    header = (struct sd_extent_header *)inode->data_vdi_id;
    if(!((signed int)header->magic == 0x6274))
    {
      log_write(0, "sd_inode_set_vid", 583, "PANIC: %s() B-tree in inode is corrupt!", (const void *)"sd_inode_set_vid");
      abort();
    }

    while((_Bool)1)
    {
      memset((void *)&path, 0, sizeof(struct find_path) /*32ul*/ );
      ret=search_whole_btree(reader, inode, idx, &path);
      if(ret == 0x1C)
      {
        path.p_ext->vdi_id = vdi_id;
        if(path.p_ext_header == ((struct sd_extent_header *)NULL))
          break;

        offset = (unsigned long int)((unsigned char *)path.p_ext - (unsigned char *)path.p_ext_header) + 4ul;
        writer(path.p_idx->oid, (void *)&vdi_id, (unsigned int)sizeof(unsigned int) /*4ul*/ , offset, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)0, (_Bool)0);
        break;
      }

      else
      {
        ret=insert_new_node(writer, reader, inode, &path, idx, vdi_id);
        if(ret == 0x1D)
        {
          if(!(path.p_ext_header == ((struct sd_extent_header *)NULL)))
            free((void *)path.p_ext_header);

          continue;
        }

        else
          break;
      }
    }
  }

out:
  ;
  if(!(path.p_ext_header == ((struct sd_extent_header *)NULL)))
    free((void *)path.p_ext_header);

  if(!((signed int)inode->store_policy == 0))
    dump_btree(reader, inode);

}

// sd_inode_write
// file sd_inode.c line 650
extern signed int sd_inode_write(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, signed int flags, _Bool create, _Bool direct)
{
  unsigned int len;
  signed int ret;
  unsigned long int return_value_vid_to_vdi_oid_1;
  if((signed int)inode->store_policy == 0)
  {
    return_value_vid_to_vdi_oid_1=vid_to_vdi_oid_link1(inode->vdi_id);
    ret=writer(return_value_vid_to_vdi_oid_1, (void *)inode, (unsigned int)4664ul, (unsigned long int)0, (unsigned int)flags, (signed int)inode->nr_copies, (signed int)inode->copy_policy, create, direct);
  }

  else
  {
    unsigned int return_value_sd_inode_get_meta_size_2;
    return_value_sd_inode_get_meta_size_2=sd_inode_get_meta_size(inode, (unsigned long int)0);
    len = (unsigned int)(4664ul + (unsigned long int)return_value_sd_inode_get_meta_size_2);
    unsigned long int return_value_vid_to_vdi_oid_3;
    return_value_vid_to_vdi_oid_3=vid_to_vdi_oid_link1(inode->vdi_id);
    ret=writer(return_value_vid_to_vdi_oid_3, (void *)inode, len, (unsigned long int)0, (unsigned int)flags, (signed int)inode->nr_copies, (signed int)inode->copy_policy, create, (_Bool)0);
    if(ret == 0x00)
    {
      unsigned long int return_value_vid_to_vdi_oid_4;
      return_value_vid_to_vdi_oid_4=vid_to_vdi_oid_link1(inode->vdi_id);
      ret=writer(return_value_vid_to_vdi_oid_4, (void *)inode, (unsigned int)sizeof(unsigned int) /*4ul*/ , 4198968ul, (unsigned int)flags, (signed int)inode->nr_copies, (signed int)inode->copy_policy, create, (_Bool)0);
    }

  }

out:
  ;
  return ret;
}

// sd_inode_write_vid
// file ../include/sheepdog_proto.h line 285
extern signed int sd_inode_write_vid(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, unsigned int idx, unsigned int vid, unsigned int value, signed int flags, _Bool create, _Bool direct)
{
  signed int ret = 0x00;
  unsigned long int return_value_vid_to_vdi_oid_1;
  if((signed int)inode->store_policy == 0)
  {
    return_value_vid_to_vdi_oid_1=vid_to_vdi_oid_link1(vid);
    ret=writer(return_value_vid_to_vdi_oid_1, (void *)&value, (unsigned int)sizeof(unsigned int) /*4ul*/ , 4664ul + sizeof(unsigned int) /*4ul*/  * (unsigned long int)idx, (unsigned int)flags, (signed int)inode->nr_copies, (signed int)inode->copy_policy, create, direct);
  }

  else
    ret=sd_inode_write(writer, inode, flags, create, direct);
  return ret;
}

// sd_mutex_lock
// file ../include/util.h line 311
static inline void sd_mutex_lock(struct sd_mutex *mutex)
{
  signed int ret;
  do
    ret=pthread_mutex_lock(&mutex->mutex);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_mutex_lock", 320, "PANIC: failed to lock for reading, %s", return_value_strerror_1);
    abort();
  }

}

// sd_mutex_unlock
// file ../include/util.h line 328
static inline void sd_mutex_unlock(struct sd_mutex *mutex)
{
  signed int ret;
  do
    ret=pthread_mutex_unlock(&mutex->mutex);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_mutex_unlock", 337, "PANIC: failed to unlock, %s", return_value_strerror_1);
    abort();
  }

}

// sd_read_lock
// file ../include/util.h line 429
static inline void sd_read_lock(struct sd_rw_lock *lock)
{
  signed int ret;
  do
    ret=pthread_rwlock_rdlock(&lock->rwlock);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_read_lock", 438, "PANIC: failed to lock for reading, %s", return_value_strerror_1);
    abort();
  }

}

// sd_read_lock_link1
// file ../include/util.h line 429
static inline void sd_read_lock_link1(struct sd_rw_lock *lock_link1)
{
  signed int ret_link1;
  do
    ret_link1=pthread_rwlock_rdlock(&lock_link1->rwlock);
  while(ret_link1 == 11);
  if(!(ret_link1 == 0))
  {
    char *return_value_strerror_1_link1;
    return_value_strerror_1_link1=strerror(ret_link1);
    log_write(0, "sd_read_lock", 438, "PANIC: failed to lock for reading, %s", return_value_strerror_1_link1);
    abort();
  }

}

// sd_rw_unlock
// file ../include/util.h line 457
static inline void sd_rw_unlock(struct sd_rw_lock *lock)
{
  signed int ret;
  do
    ret=pthread_rwlock_unlock(&lock->rwlock);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_rw_unlock", 466, "PANIC: failed to unlock, %s", return_value_strerror_1);
    abort();
  }

}

// sd_rw_unlock_link1
// file ../include/util.h line 457
static inline void sd_rw_unlock_link1(struct sd_rw_lock *lock_link1)
{
  signed int ret_link1;
  do
    ret_link1=pthread_rwlock_unlock(&lock_link1->rwlock);
  while(ret_link1 == 11);
  if(!(ret_link1 == 0))
  {
    char *return_value_strerror_1_link1;
    return_value_strerror_1_link1=strerror(ret_link1);
    log_write(0, "sd_rw_unlock", 466, "PANIC: failed to unlock, %s", return_value_strerror_1_link1);
    abort();
  }

}

// sd_strerror
// file ../include/sheep.h line 119
static inline const char * sd_strerror(signed int err)
{
  _Bool tmp_if_expr_1;
  static const char *descs[256l] = { "Success", "Unknown error", "No object found", "I/O error", "VDI exists already", "Invalid parameters", "System error", "VDI is already locked", "No VDI found", "No base VDI found", "Failed to read from requested VDI", "Failed to write to requested VDI", "Failed to read from base VDI", "Failed to write to base VDI", "Failed to find requested tag", "System is still booting", "VDI is not locked", "System is shutting down", "Out of memory on server", "Maximum number of VDIs reached", "Protocol version mismatch", "Server has no space for new objects", "Waiting for cluster to be formatted", "Waiting for other nodes to join cluster",
    "Node has failed to join cluster", "IO has halted as there are not enough living nodes",
    "Object is read-only", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Request has an old epoch", "Request has a new epoch", "Cluster has not been formatted", "Creation times differ", "Invalid epoch", "Network error between sheep", "No cache object found", "The buffer is too small", "Cluster is running/halted and cannot be force recovered",
    "Targeted backend store is not found", "Operation is not supported", "Targeted node is in recovery", "Node is killed", "Object ID exists already", "Ask to try again", "Object may be stale", "Cluster driver error", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
  if(!(err >= 0) || (unsigned long int)err >= 256ul)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = descs[(signed long int)err] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    static char msg[32l];
    snprintf(msg, sizeof(char [32l]) /*32ul*/ , "Invalid error code %x", err);
    return msg;
  }

  else
    return descs[(signed long int)err];
}

// sd_write_lock
// file ../include/util.h line 445
static inline void sd_write_lock(struct sd_rw_lock *lock)
{
  signed int ret;
  do
    ret=pthread_rwlock_wrlock(&lock->rwlock);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_write_lock", 454, "PANIC: failed to lock for writing, %s", return_value_strerror_1);
    abort();
  }

}

// sd_write_lock_link1
// file ../include/util.h line 445
static inline void sd_write_lock_link1(struct sd_rw_lock *lock_link1)
{
  signed int ret_link1;
  do
    ret_link1=pthread_rwlock_wrlock(&lock_link1->rwlock);
  while(ret_link1 == 11);
  if(!(ret_link1 == 0))
  {
    char *return_value_strerror_1_link1;
    return_value_strerror_1_link1=strerror(ret_link1);
    log_write(0, "sd_write_lock", 454, "PANIC: failed to lock for writing, %s", return_value_strerror_1_link1);
    abort();
  }

}

// search_ext_entry
// file sd_inode.c line 271
static struct sd_extent * search_ext_entry(struct sd_extent_header *header, unsigned int idx)
{
  struct sd_extent tmp;
  tmp.idx = idx;
  void *return_value_binary_search_1;
  return_value_binary_search_1=binary_search((void *)(struct sd_extent *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ), (void *)((struct sd_extent *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries), (void *)&tmp, sizeof(struct sd_extent) /*8ul*/ , extent_comp);
  return (struct sd_extent *)return_value_binary_search_1;
}

// search_idx_entry
// file sd_inode.c line 281
static struct sd_extent_idx * search_idx_entry(struct sd_extent_header *header, unsigned int idx)
{
  struct sd_extent_idx tmp;
  tmp.idx = idx;
  void *return_value_binary_search_1;
  return_value_binary_search_1=binary_search((void *)(struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ), (void *)((struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries), (void *)&tmp, sizeof(struct sd_extent_idx) /*16ul*/ , index_comp);
  return (struct sd_extent_idx *)return_value_binary_search_1;
}

// search_whole_btree
// file sd_inode.c line 392
static signed int search_whole_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx, struct find_path *path)
{
  struct sd_extent_header *header;
  struct sd_extent_header *leaf_node;
  void *tmp;
  unsigned long int oid;
  signed int ret = 0x1B;
  header = (struct sd_extent_header *)inode->data_vdi_id;
  _Bool tmp_if_expr_5;
  if((signed int)header->depth == 2)
  {
    path->depth = 2;
    path->p_idx=search_idx_entry(header, idx);
    void *return_value_xvalloc_1;
    return_value_xvalloc_1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
    leaf_node = (struct sd_extent_header *)return_value_xvalloc_1;
    tmp = (void *)leaf_node;
    _Bool return_value_idx_in_range_3;
    return_value_idx_in_range_3=idx_in_range(header, path->p_idx);
    if(!(return_value_idx_in_range_3 == (_Bool)0))
    {
      oid = path->p_idx->oid;
      ret=reader(oid, &tmp, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0);
      path->p_ext=search_ext_entry(leaf_node, idx);
      path->p_ext_header = leaf_node;
      _Bool return_value_ext_in_range_2;
      return_value_ext_in_range_2=ext_in_range(leaf_node, path->p_ext);
      if(!(return_value_ext_in_range_2 == (_Bool)0))
      {
        if(path->p_ext->idx == idx)
          ret = 0x1C;

      }

    }

    else
    {
      oid = (path->p_idx - (signed long int)1)->oid;
      ret=reader(oid, &tmp, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0);
      if(!((unsigned long int)leaf_node->entries >= 524287ul))
      {
        path->p_ext=search_ext_entry(leaf_node, idx);
        path->p_ext_header = leaf_node;
      }

    }
  }

  else
    if((signed int)header->depth == 1)
    {
      path->depth = 1;
      path->p_ext=search_ext_entry(header, idx);
      _Bool return_value_ext_in_range_4;
      return_value_ext_in_range_4=ext_in_range(header, path->p_ext);
      if(!(return_value_ext_in_range_4 == (_Bool)0))
        tmp_if_expr_5 = path->p_ext->idx == idx ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        ret = 0x1C;

      else
        ret = 0x1B;
    }


out:
  ;
  return ret;
}

// send_req
// file net.c line 294
signed int send_req(signed int sockfd, struct sd_req *hdr, void *data, unsigned int wlen, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count)
{
  signed int ret;
  struct msghdr msg;
  struct iovec iov[2l];
  memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
  msg.msg_iov = iov;
  msg.msg_iovlen = (unsigned long int)1;
  iov[(signed long int)0].iov_base = (void *)hdr;
  iov[(signed long int)0].iov_len = sizeof(struct sd_req) /*48ul*/ ;
  if(!(wlen == 0u))
  {
    msg.msg_iovlen = msg.msg_iovlen + 1ul;
    iov[(signed long int)1].iov_base = data;
    iov[(signed long int)1].iov_len = (unsigned long int)wlen;
  }

  ret=do_write(sockfd, &msg, (signed int)(sizeof(struct sd_req) /*48ul*/  + (unsigned long int)wlen), need_retry, epoch, max_count);
  if(!(ret == 0))
  {
    log_write(3, "send_req", 319, "failed to send request %x, %d: %m", hdr->opcode, wlen);
    ret = -1;
  }

  return ret;
}

// set_keepalive
// file net.c line 467
signed int set_keepalive(signed int fd)
{
  signed int val = 1;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 1, 9, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_setsockopt_1 >= 0))
  {
    if(sd_log_level == 7)
      log_write(7, "set_keepalive", 472, "%m");

    return -1;
  }

  else
  {
    val = 5;
    signed int return_value_setsockopt_2;
    return_value_setsockopt_2=setsockopt(fd, 6, 4, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_2 >= 0))
    {
      if(sd_log_level == 7)
        log_write(7, "set_keepalive", 477, "%m");

      return -1;
    }

    else
    {
      val = 1;
      signed int return_value_setsockopt_3;
      return_value_setsockopt_3=setsockopt(fd, 6, 5, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_3 >= 0))
      {
        if(sd_log_level == 7)
          log_write(7, "set_keepalive", 482, "%m");

        return -1;
      }

      else
      {
        val = 3;
        signed int return_value_setsockopt_4;
        return_value_setsockopt_4=setsockopt(fd, 6, 6, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_setsockopt_4 >= 0))
        {
          if(sd_log_level == 7)
            log_write(7, "set_keepalive", 487, "%m");

          return -1;
        }

        else
          return 0;
      }
    }
  }
}

// set_loglevel
// file logger.c line 855
void set_loglevel(signed int new_loglevel)
{
  sd_log_level = new_loglevel;
}

// set_nodelay
// file ../include/net.h line 59
signed int set_nodelay(signed int fd)
{
  signed int ret;
  signed int opt = 1;
  ret=setsockopt(fd, 6, 1, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
  return ret;
}

// set_rcv_timeout
// file net.c line 438
signed int set_rcv_timeout(signed int fd)
{
  struct timeval timeout;
  timeout.tv_sec = (signed long int)30;
  timeout.tv_usec = (signed long int)0;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 1, 20, (const void *)(char *)&timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
  return return_value_setsockopt_1;
}

// set_snd_timeout
// file net.c line 427
signed int set_snd_timeout(signed int fd)
{
  struct timeval timeout;
  timeout.tv_sec = (signed long int)5;
  timeout.tv_usec = (signed long int)0;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 1, 21, (const void *)(char *)&timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
  return return_value_setsockopt_1;
}

// set_thread_name
// file logger.c line 738
void set_thread_name(const char *name, _Bool show_idx)
{
  worker_name = name;
  if(!(show_idx == (_Bool)0))
    worker_idx=gettid();

}

// set_try_to_free_routine
// file util.c line 34
void (*set_try_to_free_routine(void (*routine)(unsigned long int)))(unsigned long int)
{
  void (*old)(unsigned long int) = try_to_free_routine;
  if(routine == ((void (*)(unsigned long int))NULL))
    routine = do_nothing;

  try_to_free_routine = routine;
  return old;
}

// setup_socket_pool
// file volume.c line 373
static signed int setup_socket_pool(signed int *array, signed int len)
{
  signed int fd;
  signed int i;
  signed int ret;
  i = 0;
  for( ; !(i >= len); i = i + 1)
  {
    fd=connect_to(sdhost, sdport);
    if(!(fd >= 0))
    {
      fs_printf("setup_socket_pool", 380, "connect_to %m\n");
      i = i - 1;
      destroy_socket_pool(array, i);
      return -1;
    }

    ret=set_nodelay(fd);
    if(!(ret == 0))
    {
      fs_printf("setup_socket_pool", 387, "%m\n");
      destroy_socket_pool(array, i);
      return -1;
    }

    array[(signed long int)i] = fd;
  }
  return 0;
}

// sha1_to_hex
// file sha1.c line 322
const char * sha1_to_hex(const unsigned char *sha1)
{
  static char buffer[50l];
  char *buf = buffer;
  signed int i = 0;
  const unsigned char *tmp_post_1;
  char *tmp_post_2;
  char *tmp_post_3;
  for( ; !(i >= 20); i = i + 1)
  {
    unsigned int val;
    tmp_post_1 = sha1;
    sha1 = sha1 + 1l;
    val = (unsigned int)*tmp_post_1;
    tmp_post_2 = buf;
    buf = buf + 1l;
    static const char hex[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 0 };
    *tmp_post_2 = hex[(signed long int)(val >> 4)];
    tmp_post_3 = buf;
    buf = buf + 1l;
    *tmp_post_3 = hex[(signed long int)(val & (unsigned int)0xf)];
  }
  return buffer;
}

// shadow_dir_create
// file sheepfs.h line 48
signed int shadow_dir_create(const char *path)
{
  char p[4096l];
  snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s%s", (const void *)sheepfs_shadow, path);
  signed int return_value_xmkdir_1;
  return_value_xmkdir_1=xmkdir(p, (unsigned int)0755);
  if(!(return_value_xmkdir_1 >= 0))
  {
    fs_printf("shadow_dir_create", 89, "%m\n");
    return -1;
  }

  else
    return 0;
}

// shadow_dir_delete
// file shadow_file.c line 95
signed int shadow_dir_delete(const char *path)
{
  char p[4096l];
  snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s%s", (const void *)sheepfs_shadow, path);
  signed int return_value_rmdir_1;
  return_value_rmdir_1=rmdir(p);
  if(!(return_value_rmdir_1 >= 0))
  {
    fs_printf("shadow_dir_delete", 101, "%m\n");
    return -1;
  }

  else
    return 0;
}

// shadow_file_create
// file sheepfs.h line 50
signed int shadow_file_create(const char *path)
{
  char p[4096l];
  signed int fd;
  snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s%s", (const void *)sheepfs_shadow, path);
  fd=creat(p, (unsigned int)0644);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 17))
    {
      fs_printf("shadow_file_create", 75, "%m\n");
      return -1;
    }

  }

  close(fd);
  return 0;
}

// shadow_file_delete
// file sheepfs.h line 55
signed int shadow_file_delete(const char *path)
{
  char p[4096l];
  snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s%s", (const void *)sheepfs_shadow, path);
  signed int return_value_unlink_2;
  return_value_unlink_2=unlink(p);
  if(!(return_value_unlink_2 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 2))
    {
      fs_printf("shadow_file_delete", 140, "%m\n");
      return -1;
    }

  }

  return 0;
}

// shadow_file_exsit
// file shadow_file.c line 147
_Bool shadow_file_exsit(const char *path)
{
  char p[4096l];
  snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s%s", (const void *)sheepfs_shadow, path);
  signed int return_value_access_2;
  return_value_access_2=access(p, 4 | 2);
  if(!(return_value_access_2 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 2))
      fs_printf("shadow_file_exsit", 154, "%m\n");

    return (_Bool)0;
  }

  return (_Bool)1;
}

// shadow_file_getxattr
// file sheepfs.h line 53
signed int shadow_file_getxattr(const char *path, const char *name, void *value, unsigned long int size)
{
  char p[4096l];
  snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s%s", (const void *)sheepfs_shadow, path);
  signed long int return_value_getxattr_1;
  return_value_getxattr_1=getxattr(p, name, value, size);
  if(!(return_value_getxattr_1 >= 0l))
  {
    fs_printf("shadow_file_getxattr", 127, "%m\n");
    return -1;
  }

  else
    return 0;
}

// shadow_file_read
// file sheepfs.h line 47
signed int shadow_file_read(const char *path, char *buf, unsigned long int size, signed long int offset)
{
  char p[4096l];
  signed int fd;
  signed int len;
  snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s%s", (const void *)sheepfs_shadow, path);
  fd=open(p, 00);
  if(!(fd >= 0))
  {
    fs_printf("shadow_file_read", 38, "%m\n");
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    return -(*return_value___errno_location_1);
  }

  signed long int return_value_xpread_2;
  return_value_xpread_2=xpread(fd, (void *)buf, size, offset);
  len = (signed int)return_value_xpread_2;
  close(fd);
  return len;
}

// shadow_file_setxattr
// file sheepfs.h line 51
signed int shadow_file_setxattr(const char *path, const char *name, const void *value, unsigned long int size)
{
  char p[4096l];
  snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s%s", (const void *)sheepfs_shadow, path);
  signed int return_value_setxattr_1;
  return_value_setxattr_1=setxattr(p, name, value, size, 0);
  if(!(return_value_setxattr_1 >= 0))
  {
    fs_printf("shadow_file_setxattr", 114, "%m\n");
    return -1;
  }

  else
    return 0;
}

// shadow_file_stat
// file shadow_file.c line 161
_Bool shadow_file_stat(const char *path, struct stat *st)
{
  char p[4096l];
  snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s%s", (const void *)sheepfs_shadow, path);
  signed int return_value_stat_2;
  return_value_stat_2=stat(p, st);
  if(!(return_value_stat_2 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 2))
      fs_printf("shadow_file_stat", 168, "%m\n");

    return (_Bool)0;
  }

  return (_Bool)1;
}

// shadow_file_write
// file sheepfs.h line 46
unsigned long int shadow_file_write(const char *path, const char *buf, unsigned long int size)
{
  char p[4096l];
  signed int fd;
  unsigned long int len = (unsigned long int)0;
  snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s%s", (const void *)sheepfs_shadow, path);
  fd=open(p, 01 | 01000);
  if(!(fd >= 0))
  {
    fs_printf("shadow_file_write", 55, "%m\n");
    return (unsigned long int)0;
  }

  else
  {
    signed long int return_value_xwrite_1;
    return_value_xwrite_1=xwrite(fd, (const void *)buf, size);
    len = (unsigned long int)return_value_xwrite_1;
    if(!(len == size))
    {
      fs_printf("shadow_file_write", 60, "failed to write\n");
      len = (unsigned long int)0;
    }

    close(fd);
    return len;
  }
}

// sheepfs_bnode_reader
// file volume.c line 274
static signed int sheepfs_bnode_reader(unsigned long int oid, void **mem, unsigned int len, unsigned long int offset)
{
  signed int ret;
  ret=volume_rw_object((char *)*mem, oid, (unsigned long int)len, (signed long int)offset, 0);
  if((unsigned int)ret == len)
    return 0x00;

  else
    return ret;
}

// sheepfs_bnode_writer
// file volume.c line 263
static signed int sheepfs_bnode_writer(unsigned long int oid, void *mem, unsigned int len, unsigned long int offset, unsigned int flags, signed int copies, signed int copy_policy, _Bool create, _Bool direct)
{
  signed int ret;
  ret=volume_rw_object((char *)mem, oid, (unsigned long int)len, (signed long int)offset, 1);
  if((unsigned int)ret == len)
    return 0x00;

  else
    return ret;
}

// sheepfs_fsync
// file core.c line 254
static signed int sheepfs_fsync(const char *path, signed int datasync, struct fuse_file_info *fi)
{
  signed int ret = 0;
  unsigned int op;
  op=sheepfs_get_op(path);
  if(!(sheepfs_file_ops[(signed long int)op].sync == ((signed int (*)(const char *))NULL)))
    ret=sheepfs_file_ops[(signed long int)op].sync(path);

  return ret;
}

// sheepfs_get_op
// file core.c line 125
static unsigned int sheepfs_get_op(const char *path)
{
  unsigned int opcode = (unsigned int)0;
  shadow_file_getxattr(path, "user.sheepfs.opcode", (void *)&opcode, sizeof(unsigned int) /*4ul*/ );
  return opcode;
}

// sheepfs_get_size
// file core.c line 135
static unsigned long int sheepfs_get_size(const char *path)
{
  unsigned int op;
  op=sheepfs_get_op(path);
  unsigned long int return_value;
  if(!(sheepfs_file_ops[(signed long int)op].get_size == ((unsigned long int (*)(const char *))NULL)))
  {
    return_value=sheepfs_file_ops[(signed long int)op].get_size(path);
    return return_value;
  }

  else
    return (unsigned long int)0;
}

// sheepfs_getattr
// file core.c line 145
static signed int sheepfs_getattr(const char *path, struct stat *st)
{
  struct strbuf p = { .alloc=(unsigned long int)0, .len=(unsigned long int)0, .eof=0,
    .buf=(char *)(void *)0 };
  signed int ret;
  strbuf_addf(&p, "%s%s", (const void *)sheepfs_shadow, path);
  ret=stat(p.buf, st);
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    ret = -(*return_value___errno_location_1);
    goto out;
  }

  unsigned long int return_value_sheepfs_get_size_2;
  if((61440u & st->st_mode) == 32768u)
  {
    return_value_sheepfs_get_size_2=sheepfs_get_size(path);
    st->st_size = (signed long int)return_value_sheepfs_get_size_2;
  }


out:
  ;
  strbuf_release(&p);
  return ret;
}

// sheepfs_main_loop
// file core.c line 289
static signed int sheepfs_main_loop(char *mountpoint)
{
  struct fuse_args args = { .argc=0, .argv=(char **)(void *)0, .allocated=0 };
  signed int ret = -1;
  fuse_opt_add_arg(&args, "sheepfs");
  fuse_opt_add_arg(&args, "-oallow_root");
  fuse_opt_add_arg(&args, "-obig_writes");
  fuse_opt_add_arg(&args, "-okernel_cache");
  fuse_opt_add_arg(&args, "-ofsname=sheepfs");
  fuse_opt_add_arg(&args, mountpoint);
  if(!(sheepfs_debug == 0))
    fuse_opt_add_arg(&args, "-odebug");

  if(!(sheepfs_fg == 0))
    fuse_opt_add_arg(&args, "-f");

  fs_printf("sheepfs_main_loop", 307, "sheepfs daemon started\n");
  ret=fuse_main_real(args.argc, args.argv, &sheepfs_ops, sizeof(struct fuse_operations) /*360ul*/ , (void *)0);
  rmdir_r(sheepfs_shadow);
  fs_printf("sheepfs_main_loop", 310, "sheepfs daemon exited %d\n", ret);
  return ret;
}

// sheepfs_open
// file core.c line 266
static signed int sheepfs_open(const char *path, struct fuse_file_info *fi)
{
  signed int ret = 0;
  unsigned int op;
  op=sheepfs_get_op(path);
  if(!(sheepfs_file_ops[(signed long int)op].open == ((signed int (*)(const char *, struct fuse_file_info *))NULL)))
    ret=sheepfs_file_ops[(signed long int)op].open(path, fi);

  return ret;
}

// sheepfs_read
// file core.c line 214
static signed int sheepfs_read(const char *path, char *buf, unsigned long int size, signed long int offset, struct fuse_file_info *fi)
{
  signed int ret = 0;
  unsigned int op;
  op=sheepfs_get_op(path);
  if(!(sheepfs_file_ops[(signed long int)op].read == ((signed int (*)(const char *, char *, unsigned long int, signed long int))NULL)))
    ret=sheepfs_file_ops[(signed long int)op].read(path, buf, size, offset);

  return ret;
}

// sheepfs_readdir
// file core.c line 185
static signed int sheepfs_readdir(const char *path, void *buf, signed int (*filler)(void *, const char *, struct stat *, signed long int), signed long int offset, struct fuse_file_info *fi)
{
  struct __dirstream *dir;
  struct dirent *dentry;
  struct strbuf p = { .alloc=(unsigned long int)0, .len=(unsigned long int)0, .eof=0,
    .buf=(char *)(void *)0 };
  signed int ret = 0;
  strbuf_addf(&p, "%s%s", (const void *)sheepfs_shadow, path);
  dir=opendir(p.buf);
  if(dir == ((struct __dirstream *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    ret = -(*return_value___errno_location_1);
    fs_printf("sheepfs_readdir", 197, "%m\n");
  }

  dentry=readdir(dir);
  if(!(dentry == ((struct dirent *)NULL)))
  {
    signed int return_value;
    return_value=filler(buf, dentry->d_name, (struct stat *)(void *)0, (signed long int)0);
    if(!(return_value == 0))
    {
      fs_printf("sheepfs_readdir", 203, "out of memory\n");
      ret = -12;
    }

  }


out:
  ;
  strbuf_release(&p);
  return ret;
}

// sheepfs_rmdir
// file core.c line 174
static signed int sheepfs_rmdir(const char *path)
{
  signed int ret = 0;
  unsigned int op;
  op=sheepfs_get_op(path);
  if(!(sheepfs_file_ops[(signed long int)op].rmdir == ((signed int (*)(const char *))NULL)))
    ret=sheepfs_file_ops[(signed long int)op].rmdir(path);

  return ret;
}

// sheepfs_run_cmd
// file core.c line 431
struct strbuf * sheepfs_run_cmd(const char *command)
{
  struct strbuf *buf;
  void *return_value_xmalloc_1;
  return_value_xmalloc_1=xmalloc(sizeof(struct strbuf) /*32ul*/ );
  buf = (struct strbuf *)return_value_xmalloc_1;
  struct _IO_FILE *f;
  f=popen(command, "r");
  signed int return_value_fileno_2;
  signed int return_value_fcntl_3;
  signed int return_value_feof_4;
  if(f == ((struct _IO_FILE *)NULL))
    fs_printf("sheepfs_run_cmd", 437, "popen failed\n");

  else
  {
    return_value_fileno_2=fileno(f);
    return_value_fcntl_3=fcntl(return_value_fileno_2, 2, 1);
    if(!(return_value_fcntl_3 >= 0))
      fs_printf("sheepfs_run_cmd", 442, "fcntl failed\n");

    else
    {
      strbuf_init(buf, (unsigned long int)4096);
      do
      {
        return_value_feof_4=feof(f);
        if(!(return_value_feof_4 == 0))
          break;

        strbuf_fread(buf, (unsigned long int)4096, f);
      }
      while((_Bool)1);
      pclose(f);
      return buf;
    }
  }

err:
  ;
  strbuf_release(buf);
  if(!(f == ((struct _IO_FILE *)NULL)))
    pclose(f);

  free((void *)buf);
  return (struct strbuf *)(void *)0;
}

// sheepfs_set_op
// file core.c line 116
signed int sheepfs_set_op(const char *path, unsigned int opcode)
{
  signed int return_value_shadow_file_setxattr_1;
  return_value_shadow_file_setxattr_1=shadow_file_setxattr(path, "user.sheepfs.opcode", (const void *)&opcode, sizeof(unsigned int) /*4ul*/ );
  if(!(return_value_shadow_file_setxattr_1 >= 0))
  {
    shadow_file_delete(path);
    return -1;
  }

  else
    return 0;
}

// sheepfs_truncate
// file core.c line 238
static signed int sheepfs_truncate(const char *path, signed long int size)
{
  struct strbuf p = { .alloc=(unsigned long int)0, .len=(unsigned long int)0, .eof=0,
    .buf=(char *)(void *)0 };
  signed int ret = 0;
  signed int fd;
  strbuf_addf(&p, "%s%s", (const void *)sheepfs_shadow, path);
  fd=open(p.buf, 02);
  if(!(fd >= 0))
    ret = -2;

  else
    close(fd);
  strbuf_release(&p);
  return ret;
}

// sheepfs_unlink
// file core.c line 163
static signed int sheepfs_unlink(const char *path)
{
  signed int ret = 0;
  unsigned int op;
  op=sheepfs_get_op(path);
  if(!(sheepfs_file_ops[(signed long int)op].unlink == ((signed int (*)(const char *))NULL)))
    ret=sheepfs_file_ops[(signed long int)op].unlink(path);

  return ret;
}

// sheepfs_write
// file core.c line 226
static signed int sheepfs_write(const char *path, const char *buf, unsigned long int size, signed long int offset, struct fuse_file_info *fi)
{
  signed int ret = 0;
  unsigned int op;
  op=sheepfs_get_op(path);
  if(!(sheepfs_file_ops[(signed long int)op].write == ((signed int (*)(const char *, const char *, unsigned long int, signed long int))NULL)))
    ret=sheepfs_file_ops[(signed long int)op].write(path, buf, size, offset);

  return ret;
}

// sighup_handler
// file logger.c line 555
static void sighup_handler(signed int signo)
{
  rotate_log();
}

// slots_all_free
// file sockfd_cache.c line 132
static inline _Bool slots_all_free(struct sockfd_cache_entry *entry)
{
  signed int i = 0;
  _Bool return_value_uatomic_is_true_1;
  for( ; !(i >= fds_count); i = i + 1)
  {
    return_value_uatomic_is_true_1=uatomic_is_true(&(entry->fds + (signed long int)i)->in_use);
    if(!(return_value_uatomic_is_true_1 == (_Bool)0))
      return (_Bool)0;

  }
  return (_Bool)1;
}

// sockaddr_in_to_str
// file net.c line 394
char * sockaddr_in_to_str(struct sockaddr_in *sockaddr)
{
  signed int i;
  signed int si;
  unsigned char *addr;
  si = 0;
  static char str[32l];
  memset((void *)str, 0, (unsigned long int)32);
  addr = (unsigned char *)&sockaddr->sin_addr.s_addr;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    signed int return_value_snprintf_1;
    return_value_snprintf_1=snprintf(str + (signed long int)si, (unsigned long int)(32 - si), i != 3 ? "%d." : "%d", addr[(signed long int)i]);
    si = si + return_value_snprintf_1;
  }
  snprintf(str + (signed long int)si, (unsigned long int)(32 - si), ":%u", sockaddr->sin_port);
  return str;
}

// sockfd_cache_add
// file sockfd_cache.c line 220
void sockfd_cache_add(struct node_id *nid)
{
  struct sockfd_cache_entry *new;
  signed int n;
  signed int i;
  sd_write_lock_link1(&sockfd_cache.lock);
  void *return_value_xmalloc_1;
  return_value_xmalloc_1=xmalloc(sizeof(struct sockfd_cache_entry) /*72ul*/ );
  new = (struct sockfd_cache_entry *)return_value_xmalloc_1;
  void *return_value_xzalloc_2;
  return_value_xzalloc_2=xzalloc(sizeof(struct sockfd_cache_fd) /*16ul*/  * (unsigned long int)fds_count);
  new->fds = (struct sockfd_cache_fd *)return_value_xzalloc_2;
  i = 0;
  for( ; !(i >= fds_count); i = i + 1)
    (new->fds + (signed long int)i)->fd = -1;
  memcpy((void *)&new->nid, (const void *)nid, sizeof(struct node_id) /*40ul*/ );
  struct sockfd_cache_entry *return_value_sockfd_cache_insert_3;
  return_value_sockfd_cache_insert_3=sockfd_cache_insert(new);
  const char *return_value_addr_to_str_5;
  if(!(return_value_sockfd_cache_insert_3 == ((struct sockfd_cache_entry *)NULL)))
  {
    free_cache_entry(new);
    sd_rw_unlock_link1(&sockfd_cache.lock);
  }

  else
  {
    sd_rw_unlock_link1(&sockfd_cache.lock);
    unsigned long int return_value___uatomic_add_return_4;
    return_value___uatomic_add_return_4=__uatomic_add_return_link1((void *)&sockfd_cache.count, (unsigned long int)1, (signed int)sizeof(signed int) /*4ul*/ );
    n = (signed int)return_value___uatomic_add_return_4;
    if(sd_log_level == 7)
    {
      return_value_addr_to_str_5=addr_to_str(nid->addr, nid->port);
      log_write(7, "sockfd_cache_add", 239, "%s, count %d", return_value_addr_to_str_5, n);
    }

  }
}

// sockfd_cache_add_group
// file sockfd_cache.c line 208
void sockfd_cache_add_group(struct rb_root *nroot)
{
  struct sd_node *n;
  sd_write_lock_link1(&sockfd_cache.lock);
  struct rb_node *__p213;
  __p213=rb_first(nroot);
  struct rb_node *__n213;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  struct sd_node *tmp_statement_expression_2;
  do
  {
    if(!(__p213 == ((struct rb_node *)NULL)))
    {
      __n213=rb_next(__p213);
      tmp_if_expr_1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
    {
      const struct rb_node *__mptr = __p213;
      tmp_statement_expression_2 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      n = tmp_statement_expression_2;
      tmp_if_expr_3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
      break;

    sockfd_cache_add_nolock(&n->nid);
    __p213 = __n213;
  }
  while((_Bool)1);
  sd_rw_unlock_link1(&sockfd_cache.lock);
}

// sockfd_cache_add_nolock
// file sockfd_cache.c line 190
static void sockfd_cache_add_nolock(struct node_id *nid)
{
  struct sockfd_cache_entry *new;
  void *return_value_xmalloc_1;
  return_value_xmalloc_1=xmalloc(sizeof(struct sockfd_cache_entry) /*72ul*/ );
  new = (struct sockfd_cache_entry *)return_value_xmalloc_1;
  signed int i;
  void *return_value_xzalloc_2;
  return_value_xzalloc_2=xzalloc(sizeof(struct sockfd_cache_fd) /*16ul*/  * (unsigned long int)fds_count);
  new->fds = (struct sockfd_cache_fd *)return_value_xzalloc_2;
  i = 0;
  for( ; !(i >= fds_count); i = i + 1)
    (new->fds + (signed long int)i)->fd = -1;
  memcpy((void *)&new->nid, (const void *)nid, sizeof(struct node_id) /*40ul*/ );
  struct sockfd_cache_entry *return_value_sockfd_cache_insert_3;
  return_value_sockfd_cache_insert_3=sockfd_cache_insert(new);
  if(!(return_value_sockfd_cache_insert_3 == ((struct sockfd_cache_entry *)NULL)))
    free_cache_entry(new);

  else
    sockfd_cache.count = sockfd_cache.count + 1;
}

// sockfd_cache_close
// file sockfd_cache.c line 381
static void sockfd_cache_close(struct node_id *nid, signed int idx)
{
  _Bool use_io = (_Bool)(nid->io_port != 0 ? 1 : 0);
  const unsigned char *addr;
  unsigned char *tmp_if_expr_1;
  if(!(use_io == (_Bool)0))
    tmp_if_expr_1 = nid->io_addr;

  else
    tmp_if_expr_1 = nid->addr;
  addr = tmp_if_expr_1;
  signed int port;
  signed int tmp_if_expr_2;
  if(!(use_io == (_Bool)0))
    tmp_if_expr_2 = (signed int)nid->io_port;

  else
    tmp_if_expr_2 = (signed int)nid->port;
  port = tmp_if_expr_2;
  struct sockfd_cache_entry *entry;
  const char *return_value_addr_to_str_3;
  if(sd_log_level == 7)
  {
    return_value_addr_to_str_3=addr_to_str(addr, (unsigned short int)port);
    log_write(7, "sockfd_cache_close", 388, "%s idx %d", return_value_addr_to_str_3, idx);
  }

  sd_write_lock_link1(&sockfd_cache.lock);
  entry=sockfd_cache_search(nid);
  if(!(entry == ((struct sockfd_cache_entry *)NULL)))
  {
    close((entry->fds + (signed long int)idx)->fd);
    (entry->fds + (signed long int)idx)->fd = -1;
    uatomic_set_false_link1(&(entry->fds + (signed long int)idx)->in_use);
  }

  sd_rw_unlock_link1(&sockfd_cache.lock);
}

// sockfd_cache_cmp
// file sockfd_cache.c line 75
static signed int sockfd_cache_cmp(struct sockfd_cache_entry *a, struct sockfd_cache_entry *b)
{
  signed int return_value_node_id_cmp_1;
  return_value_node_id_cmp_1=node_id_cmp(&a->nid, &b->nid);
  return return_value_node_id_cmp_1;
}

// sockfd_cache_del
// file sockfd_cache.c line 485
void sockfd_cache_del(struct node_id *nid, struct sockfd *sfd)
{
  if(sfd->idx == -1)
  {
    if(sd_log_level == 7)
      log_write(7, "sockfd_cache_del", 488, "%d", sfd->fd);

    close(sfd->fd);
    free((void *)sfd);
  }

  else
  {
    sockfd_cache_close(nid, sfd->idx);
    sockfd_cache_del_node(nid);
    free((void *)sfd);
  }
}

// sockfd_cache_del_node
// file sockfd_cache.c line 467
void sockfd_cache_del_node(struct node_id *nid)
{
  signed int n;
  _Bool return_value_sockfd_cache_destroy_1;
  return_value_sockfd_cache_destroy_1=sockfd_cache_destroy(nid);
  const char *return_value_addr_to_str_3;
  if(!(return_value_sockfd_cache_destroy_1 == (_Bool)0))
  {
    unsigned long int return_value___uatomic_add_return_2;
    return_value___uatomic_add_return_2=__uatomic_add_return_link1((void *)&sockfd_cache.count, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed int) /*4ul*/ );
    n = (signed int)return_value___uatomic_add_return_2;
    if(sd_log_level == 7)
    {
      return_value_addr_to_str_3=addr_to_str(nid->addr, nid->port);
      log_write(7, "sockfd_cache_del_node", 475, "%s, count %d", return_value_addr_to_str_3, n);
    }

  }

}

// sockfd_cache_destroy
// file sockfd_cache.c line 162
static _Bool sockfd_cache_destroy(struct node_id *nid)
{
  struct sockfd_cache_entry *entry;
  sd_write_lock_link1(&sockfd_cache.lock);
  entry=sockfd_cache_search(nid);
  _Bool return_value_slots_all_free_1;
  if(entry == ((struct sockfd_cache_entry *)NULL))
  {
    if(sd_log_level == 7)
      log_write(7, "sockfd_cache_destroy", 169, "It is already destroyed");

  }

  else
  {
    return_value_slots_all_free_1=slots_all_free(entry);
    if(return_value_slots_all_free_1 == (_Bool)0)
    {
      if(sd_log_level == 7)
        log_write(7, "sockfd_cache_destroy", 174, "Some victim still holds it");

    }

    else
    {
      rb_erase(&entry->rb, &sockfd_cache.root);
      sd_rw_unlock_link1(&sockfd_cache.lock);
      destroy_all_slots(entry);
      free_cache_entry(entry);
      return (_Bool)1;
    }
  }

false_out:
  ;
  sd_rw_unlock_link1(&sockfd_cache.lock);
  return (_Bool)0;
}

// sockfd_cache_get
// file sockfd_cache.c line 425
struct sockfd * sockfd_cache_get(struct node_id *nid)
{
  struct sockfd *sfd;
  signed int fd;
  sfd=sockfd_cache_get_long(nid);
  if(!(sfd == ((struct sockfd *)NULL)))
    return sfd;

  else
  {
    fd=connect_to_addr(nid->addr, (signed int)nid->port);
    if(!(fd >= 0))
      return (struct sockfd *)(void *)0;

    else
    {
      void *return_value_xmalloc_1;
      return_value_xmalloc_1=xmalloc(sizeof(struct sockfd) /*8ul*/ );
      sfd = (struct sockfd *)return_value_xmalloc_1;
      sfd->idx = -1;
      sfd->fd = fd;
      if(sd_log_level == 7)
        log_write(7, "sockfd_cache_get", 442, "%d", fd);

      return sfd;
    }
  }
}

// sockfd_cache_get_long
// file sockfd_cache.c line 313
static struct sockfd * sockfd_cache_get_long(struct node_id *nid)
{
  struct sockfd_cache_entry *entry;
  struct sockfd *sfd;
  _Bool use_io = (_Bool)(nid->io_port != 0 ? 1 : 0);
  const unsigned char *addr;
  unsigned char *tmp_if_expr_1;
  if(!(use_io == (_Bool)0))
    tmp_if_expr_1 = nid->io_addr;

  else
    tmp_if_expr_1 = nid->addr;
  addr = tmp_if_expr_1;
  signed int fd;
  signed int idx = -1;
  signed int port;
  signed int tmp_if_expr_2;
  if(!(use_io == (_Bool)0))
    tmp_if_expr_2 = (signed int)nid->io_port;

  else
    tmp_if_expr_2 = (signed int)nid->port;
  port = tmp_if_expr_2;
  signed int return_value_revalidate_node_3;
  do
  {

  grab:
    ;
    entry=sockfd_cache_grab(nid, &idx);
    if(!(entry == ((struct sockfd_cache_entry *)NULL)))
      break;

    return_value_revalidate_node_3=revalidate_node(nid);
    if(return_value_revalidate_node_3 == 0)
      return (struct sockfd *)(void *)0;

  }
  while((_Bool)1);
  check_idx(idx);
  const char *return_value_addr_to_str_4;
  const char *return_value_addr_to_str_5;
  if(!((entry->fds + (signed long int)idx)->fd == -1))
  {
    if(sd_log_level == 7)
    {
      return_value_addr_to_str_4=addr_to_str(addr, (unsigned short int)port);
      log_write(7, "sockfd_cache_get_long", 338, "%s, idx %d", return_value_addr_to_str_4, idx);
    }

  }

  else
  {
    if(sd_log_level == 7)
    {
      return_value_addr_to_str_5=addr_to_str(addr, (unsigned short int)port);
      log_write(7, "sockfd_cache_get_long", 344, "create cache connection %s idx %d", return_value_addr_to_str_5, idx);
    }

    fd=connect_to_addr(addr, port);
    if(!(fd >= 0))
    {
      if(!(use_io == (_Bool)0))
      {
        log_write(3, "sockfd_cache_get_long", 348, "fallback to non-io connection");
        fd=connect_to_addr(nid->addr, (signed int)nid->port);
        if(fd >= 0)
          goto new;

      }

      uatomic_set_false_link1(&(entry->fds + (signed long int)idx)->in_use);
      return (struct sockfd *)(void *)0;
    }


  new:
    ;
    (entry->fds + (signed long int)idx)->fd = fd;
  }

out:
  ;
  void *return_value_xmalloc_6;
  return_value_xmalloc_6=xmalloc(sizeof(struct sockfd) /*8ul*/ );
  sfd = (struct sockfd *)return_value_xmalloc_6;
  sfd->fd = (entry->fds + (signed long int)idx)->fd;
  sfd->idx = idx;
  return sfd;
}

// sockfd_cache_grab
// file sockfd_cache.c line 112
static struct sockfd_cache_entry * sockfd_cache_grab(struct node_id *nid, signed int *ret_idx)
{
  struct sockfd_cache_entry *entry;
  sd_read_lock_link1(&sockfd_cache.lock);
  entry=sockfd_cache_search(nid);
  const char *return_value_addr_to_str_1;
  if(entry == ((struct sockfd_cache_entry *)NULL))
  {
    if(sd_log_level == 7)
    {
      return_value_addr_to_str_1=addr_to_str(nid->addr, nid->port);
      log_write(7, "sockfd_cache_grab", 120, "failed node %s", return_value_addr_to_str_1);
    }

  }

  else
  {
    *ret_idx=get_free_slot(entry);
    if(*ret_idx == -1)
      entry = (struct sockfd_cache_entry *)(void *)0;

  }

out:
  ;
  sd_rw_unlock_link1(&sockfd_cache.lock);
  return entry;
}

// sockfd_cache_insert
// file sockfd_cache.c line 82
static struct sockfd_cache_entry * sockfd_cache_insert(struct sockfd_cache_entry *new)
{
  struct sockfd_cache_entry *tmp_statement_expression_1;
  struct rb_node **__n = &(&sockfd_cache.root)->rb_node;
  struct rb_node *__parent = (struct rb_node *)(void *)0;
  struct sockfd_cache_entry *__old = (struct sockfd_cache_entry *)(void *)0;
  struct sockfd_cache_entry *__data;
  struct sockfd_cache_entry *tmp_statement_expression_2;
  while(!(*__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = *__n;
    tmp_statement_expression_2 = (struct sockfd_cache_entry *)((char *)__mptr - (signed long int)0ul);
    __data = tmp_statement_expression_2;
    signed int __cmp;
    __cmp=sockfd_cache_cmp(new, __data);
    __parent = *__n;
    if(!(__cmp >= 0))
      __n = &(*__n)->rb_left;

    else
      if(__cmp >= 1)
        __n = &(*__n)->rb_right;

      else
      {
        __old = __data;
        break;
      }
  }
  if(__old == ((struct sockfd_cache_entry *)NULL))
  {
    rb_link_node_link2(&new->rb, __parent, __n);
    rb_insert_color(&new->rb, &sockfd_cache.root);
  }

  tmp_statement_expression_1 = __old;
  return tmp_statement_expression_1;
}

// sockfd_cache_put
// file sockfd_cache.c line 453
void sockfd_cache_put(struct node_id *nid, struct sockfd *sfd)
{
  if(sfd->idx == -1)
  {
    if(sd_log_level == 7)
      log_write(7, "sockfd_cache_put", 456, "%d", sfd->fd);

    close(sfd->fd);
    free((void *)sfd);
  }

  else
  {
    sockfd_cache_put_long(nid, sfd->idx);
    free((void *)sfd);
  }
}

// sockfd_cache_put_long
// file sockfd_cache.c line 365
static void sockfd_cache_put_long(struct node_id *nid, signed int idx)
{
  _Bool use_io = (_Bool)(nid->io_port != 0 ? 1 : 0);
  const unsigned char *addr;
  unsigned char *tmp_if_expr_1;
  if(!(use_io == (_Bool)0))
    tmp_if_expr_1 = nid->io_addr;

  else
    tmp_if_expr_1 = nid->addr;
  addr = tmp_if_expr_1;
  signed int port;
  signed int tmp_if_expr_2;
  if(!(use_io == (_Bool)0))
    tmp_if_expr_2 = (signed int)nid->io_port;

  else
    tmp_if_expr_2 = (signed int)nid->port;
  port = tmp_if_expr_2;
  struct sockfd_cache_entry *entry;
  const char *return_value_addr_to_str_3;
  if(sd_log_level == 7)
  {
    return_value_addr_to_str_3=addr_to_str(addr, (unsigned short int)port);
    log_write(7, "sockfd_cache_put_long", 372, "%s idx %d", return_value_addr_to_str_3, idx);
  }

  sd_read_lock_link1(&sockfd_cache.lock);
  entry=sockfd_cache_search(nid);
  if(!(entry == ((struct sockfd_cache_entry *)NULL)))
    uatomic_set_false_link1(&(entry->fds + (signed long int)idx)->in_use);

  sd_rw_unlock_link1(&sockfd_cache.lock);
}

// sockfd_cache_search
// file sockfd_cache.c line 87
static struct sockfd_cache_entry * sockfd_cache_search(struct node_id *nid)
{
  struct sockfd_cache_entry key = { .rb={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) }, .nid=*nid,
    .fds=((struct sockfd_cache_fd *)NULL) };
  struct sockfd_cache_entry *tmp_statement_expression_1;
  struct rb_node *__n = (&sockfd_cache.root)->rb_node;
  struct sockfd_cache_entry *__ret = (struct sockfd_cache_entry *)(void *)0;
  struct sockfd_cache_entry *__data;
  struct sockfd_cache_entry *tmp_statement_expression_2;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression_2 = (struct sockfd_cache_entry *)((char *)__mptr - (signed long int)0ul);
    __data = tmp_statement_expression_2;
    signed int __cmp;
    __cmp=sockfd_cache_cmp(&key, __data);
    if(!(__cmp >= 0))
      __n = __n->rb_left;

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  tmp_statement_expression_1 = __ret;
  return tmp_statement_expression_1;
}

// sockfd_init
// file sockfd_cache.c line 404
signed int sockfd_init(void)
{
  grow_wq=create_ordered_work_queue("sockfd_grow");
  if(grow_wq == ((struct work_queue *)NULL))
  {
    log_write(3, "sockfd_init", 409, "error at creating workqueue for sockfd growth");
    return -1;
  }

  else
    return 0;
}

// split_ext_node
// file sd_inode.c line 471
static void split_ext_node(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, struct find_path *path)
{
  struct sd_extent_header *old = path->p_ext_header;
  struct sd_extent_header *new_ext;
  unsigned int num = old->entries / (unsigned int)2;
  unsigned long int new_oid;
  void *return_value_xvalloc_1;
  return_value_xvalloc_1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
  new_ext = (struct sd_extent_header *)return_value_xvalloc_1;
  split_to_nodes(old, new_ext, old, (signed int)num);
  unsigned int tmp_post_2 = inode->btree_counter;
  inode->btree_counter = inode->btree_counter + 1u;
  new_oid=vid_to_btree_oid(inode->vdi_id, tmp_post_2);
  writer(new_oid, (void *)new_ext, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)1, (_Bool)0);
  writer(path->p_idx->oid, (void *)old, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)0, (_Bool)0);
  insert_idx_entry((struct sd_extent_header *)inode->data_vdi_id, ((struct sd_extent *)((char *)new_ext + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)new_ext)->entries)->idx, new_oid);
  free((void *)new_ext);
}

// split_path
// file ../include/util.h line 119
signed int split_path(const char *path, unsigned long int nr_segs, char **segs)
{
  signed int i = 0;
  for( ; !((unsigned long int)i >= nr_segs); i = i + 1)
  {
    for( ; (signed int)*path == 47; path = path + 1l)
      ;
    if((signed int)*path == 0)
      return i;

    if((unsigned long int)i == nr_segs + 18446744073709551615ul)
    {
      segs[(signed long int)i]=strdup(path);
      if(segs[(signed long int)i] == ((char *)NULL))
      {
        log_write(0, "split_path", 537, "PANIC: OOM");
        abort();
      }

    }

    else
    {
      char *p;
      p=strchrnul(path, 47);
      signed int len = (signed int)(p - path);
      void *return_value_xmalloc_1;
      return_value_xmalloc_1=xmalloc((unsigned long int)(len + 1));
      segs[(signed long int)i] = (char *)return_value_xmalloc_1;
      memcpy((void *)segs[(signed long int)i], (const void *)path, (unsigned long int)len);
      segs[(signed long int)i][(signed long int)len] = (char)0;
      path = p;
    }
  }
  return (signed int)nr_segs;
}

// split_to_nodes
// file sd_inode.c line 335
static void split_to_nodes(struct sd_extent_header *src, struct sd_extent_header *left, struct sd_extent_header *right, signed int num)
{
  memcpy((void *)left, (const void *)src, sizeof(struct sd_extent_header) /*8ul*/  + (unsigned long int)num * sizeof(struct sd_extent) /*8ul*/ );
  left->entries = (unsigned int)num;
  mempcpy((void *)right, (const void *)src, sizeof(struct sd_extent_header) /*8ul*/ );
  mempcpy((void *)(struct sd_extent *)((char *)right + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ), (const void *)((char *)src + (signed long int)sizeof(struct sd_extent_header) /*8ul*/  + (signed long int)((unsigned long int)num * sizeof(struct sd_extent) /*8ul*/ )), (unsigned long int)(src->entries - (unsigned int)num) * sizeof(struct sd_extent) /*8ul*/ );
  right->entries = src->entries - (unsigned int)num;
}

// str_to_addr
// file net.c line 413
unsigned char * str_to_addr(const char *ipstr, unsigned char *addr)
{
  signed int addr_start_idx = 0;
  signed int af;
  char *return_value_strstr_1;
  return_value_strstr_1=strstr(ipstr, ":");
  af = return_value_strstr_1 != ((char *)NULL) ? 10 : 2;
  if(af == 2)
  {
    addr_start_idx = 12;
    memset((void *)addr, 0, (unsigned long int)addr_start_idx);
  }

  signed int return_value_inet_pton_2;
  return_value_inet_pton_2=inet_pton(af, ipstr, (void *)(addr + (signed long int)addr_start_idx));
  if(return_value_inet_pton_2 == 0)
    return (unsigned char *)(void *)0;

  else
    return addr;
}

// strbuf_add
// file strbuf.c line 101
void strbuf_add(struct strbuf *sb, const void *data, unsigned long int len)
{
  strbuf_grow(sb, len);
  memcpy((void *)(sb->buf + (signed long int)sb->len), data, len);
  strbuf_setlen(sb, sb->len + len);
}

// strbuf_addf
// file ../include/strbuf.h line 91
void strbuf_addf(struct strbuf *sb, const char *fmt, ...)
{
  signed int len;
  void **ap = (void **)&fmt;
  len=vsnprintf(sb->buf + (signed long int)sb->len, sb->alloc - sb->len, fmt, ap);
  ap = ((void **)NULL);
  if(!(len >= 0))
    len = 0;

  unsigned long int return_value_strbuf_avail_2;
  return_value_strbuf_avail_2=strbuf_avail(sb);
  if(!(return_value_strbuf_avail_2 >= (unsigned long int)len))
  {
    strbuf_grow(sb, (unsigned long int)len);
    ap = (void **)&fmt;
    len=vsnprintf(sb->buf + (signed long int)sb->len, sb->alloc - sb->len, fmt, ap);
    ap = ((void **)NULL);
    unsigned long int return_value_strbuf_avail_1;
    return_value_strbuf_avail_1=strbuf_avail(sb);
    if(!(return_value_strbuf_avail_1 >= (unsigned long int)len))
    {
      log_write(0, "strbuf_addf", 124, "PANIC: this should not happen, your snprintf is broken");
      abort();
    }

  }

  strbuf_setlen(sb, sb->len + (unsigned long int)len);
}

// strbuf_attach
// file strbuf.c line 43
void strbuf_attach(struct strbuf *sb, void *buf, unsigned long int len, unsigned long int alloc)
{
  strbuf_release(sb);
  sb->buf = (char *)buf;
  sb->len = len;
  sb->alloc = alloc;
  strbuf_grow(sb, (unsigned long int)0);
  sb->buf[(signed long int)sb->len] = (char)0;
}

// strbuf_avail
// file ../include/strbuf.h line 49
static inline unsigned long int strbuf_avail(struct strbuf *sb)
{
  unsigned long int tmp_if_expr_1;
  if(!(sb->alloc == 0ul))
    tmp_if_expr_1 = (sb->alloc - sb->len) - (unsigned long int)1;

  else
    tmp_if_expr_1 = (unsigned long int)0;
  return tmp_if_expr_1;
}

// strbuf_copyout
// file strbuf.c line 193
signed int strbuf_copyout(struct strbuf *sb, void *buf, unsigned long int len)
{
  unsigned long int tmp_statement_expression_1;
  unsigned long int _x = len;
  unsigned long int _y = sb->len + (unsigned long int)1;
  (void)(&_x == &_y);
  tmp_statement_expression_1 = _x < _y ? _x : _y;
  len = tmp_statement_expression_1;
  memcpy(buf, (const void *)sb->buf, len);
  return (signed int)len;
}

// strbuf_detach
// file strbuf.c line 36
char * strbuf_detach(struct strbuf *sb)
{
  char *res = sb->buf;
  strbuf_init(sb, (unsigned long int)0);
  return res;
}

// strbuf_fread
// file ../include/strbuf.h line 93
unsigned long int strbuf_fread(struct strbuf *sb, unsigned long int size, struct _IO_FILE *f)
{
  unsigned long int res;
  strbuf_grow(sb, size);
  res=fread((void *)(sb->buf + (signed long int)sb->len), (unsigned long int)1, size, f);
  if(res >= 1ul)
    strbuf_setlen(sb, sb->len + res);

  return res;
}

// strbuf_getline
// file strbuf.c line 184
signed int strbuf_getline(struct strbuf *sb, struct _IO_FILE *fp, signed int term)
{
  signed int return_value_strbuf_getwholeline_1;
  return_value_strbuf_getwholeline_1=strbuf_getwholeline(sb, fp, term);
  if(!(return_value_strbuf_getwholeline_1 == 0))
    return -1;

  else
  {
    if((signed int)sb->buf[-1l + (signed long int)sb->len] == term)
      strbuf_setlen(sb, sb->len - (unsigned long int)1);

    return 0;
  }
}

// strbuf_getwholeline
// file strbuf.c line 163
static signed int strbuf_getwholeline(struct strbuf *sb, struct _IO_FILE *fp, signed int term)
{
  signed int ch;
  signed int return_value_feof_1;
  return_value_feof_1=feof(fp);
  unsigned long int tmp_post_2;
  if(!(return_value_feof_1 == 0))
    return -1;

  else
  {
    strbuf_reset(sb);
    do
    {
      ch=fgetc(fp);
      if(ch == -1)
        break;

      strbuf_grow(sb, (unsigned long int)1);
      tmp_post_2 = sb->len;
      sb->len = sb->len + 1ul;
      sb->buf[(signed long int)tmp_post_2] = (char)ch;
      if(ch == term)
        break;

    }
    while((_Bool)1);
    if(ch == -1)
    {
      if(!(sb->len == 0ul))
        goto __CPROVER_DUMP_L4;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      sb->buf[(signed long int)sb->len] = (char)0;
      return 0;
    }
  }
}

// strbuf_grow
// file strbuf.c line 53
void strbuf_grow(struct strbuf *sb, unsigned long int extra)
{
  if(sb->len >= 1ul + sb->len + extra)
  {
    log_write(0, "strbuf_grow", 56, "PANIC: you want to use way too much memory");
    abort();
  }

  do
    if(!(sb->alloc >= 1ul + sb->len + extra))
    {
      if(!(((16ul + sb->alloc) * 3ul) / 2ul >= 1ul + sb->len + extra))
        sb->alloc = sb->len + extra + (unsigned long int)1;

      else
        sb->alloc = ((sb->alloc + (unsigned long int)16) * (unsigned long int)3) / (unsigned long int)2;
      void *return_value_xrealloc_1;
      return_value_xrealloc_1=xrealloc((void *)sb->buf, sb->alloc * sizeof(char) /*1ul*/ );
      sb->buf = (char *)return_value_xrealloc_1;
    }

  while((_Bool)0);
}

// strbuf_init
// file ../include/strbuf.h line 42
void strbuf_init(struct strbuf *sb, unsigned long int hint)
{
  memset((void *)sb, 0, sizeof(struct strbuf) /*32ul*/ );
  if(!(hint == 0ul))
    strbuf_grow(sb, hint);

}

// strbuf_insert
// file strbuf.c line 67
void strbuf_insert(struct strbuf *sb, unsigned long int pos, const void *data, unsigned long int len)
{
  strbuf_grow(sb, len);
  if(!(sb->len >= pos))
  {
    log_write(0, "strbuf_insert", 71, "PANIC: `pos' is too far after the end of the buffer");
    abort();
  }

  memmove((void *)(sb->buf + (signed long int)pos + (signed long int)len), (const void *)(sb->buf + (signed long int)pos), sb->len - pos);
  memcpy((void *)(sb->buf + (signed long int)pos), data, len);
  strbuf_setlen(sb, sb->len + len);
}

// strbuf_read
// file strbuf.c line 140
signed long int strbuf_read(struct strbuf *sb, signed int fd, unsigned long int hint)
{
  unsigned long int oldlen = sb->len;
  strbuf_grow(sb, hint != 0ul ? hint : (unsigned long int)8192);
  do
  {
    signed long int cnt;
    cnt=xread(fd, (void *)(sb->buf + (signed long int)sb->len), (sb->alloc - sb->len) - (unsigned long int)1);
    if(!(cnt >= 0l))
    {
      strbuf_setlen(sb, oldlen);
      return (signed long int)-1;
    }

    if(cnt == 0l)
      break;

    sb->len = sb->len + (unsigned long int)cnt;
    strbuf_grow(sb, (unsigned long int)8192);
  }
  while((_Bool)1);
  sb->buf[(signed long int)sb->len] = (char)0;
  return (signed long int)(sb->len - oldlen);
}

// strbuf_release
// file ../include/strbuf.h line 43
void strbuf_release(struct strbuf *sb)
{
  free((void *)sb->buf);
  memset((void *)sb, 0, sizeof(struct strbuf) /*32ul*/ );
}

// strbuf_remove
// file strbuf.c line 96
void strbuf_remove(struct strbuf *sb, unsigned long int pos, unsigned long int len)
{
  strbuf_splice(sb, pos, len, (void *)0, (unsigned long int)0);
}

// strbuf_reset
// file strbuf.c line 29
void strbuf_reset(struct strbuf *sb)
{
  if(!(sb->len == 0ul))
    strbuf_setlen(sb, (unsigned long int)0);

  sb->eof = 0;
}

// strbuf_rtrim
// file strbuf.c line 60
void strbuf_rtrim(struct strbuf *sb)
{
  const unsigned short int **return_value___ctype_b_loc_1;
  for( ; sb->len >= 1ul; sb->len = sb->len - 1ul)
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)sb->buf[-1l + (signed long int)sb->len]]) == 0)
      break;

  }
  sb->buf[(signed long int)sb->len] = (char)0;
}

// strbuf_setlen
// file ../include/strbuf.h line 53
static inline void strbuf_setlen(struct strbuf *sb, unsigned long int len)
{
  sb->len = len;
  sb->buf[(signed long int)len] = (char)0;
}

// strbuf_splice
// file strbuf.c line 77
void strbuf_splice(struct strbuf *sb, unsigned long int pos, unsigned long int len, const void *data, unsigned long int dlen)
{
  if(!(len + pos >= pos))
  {
    log_write(0, "strbuf_splice", 81, "PANIC: you want to use way too much memory");
    abort();
  }

  if(!(sb->len >= pos))
  {
    log_write(0, "strbuf_splice", 83, "PANIC: `pos' is too far after the end of the buffer");
    abort();
  }

  if(!(sb->len >= len + pos))
  {
    log_write(0, "strbuf_splice", 85, "PANIC: `pos + len' is too far after the end of the buffer");
    abort();
  }

  if(dlen >= len)
    strbuf_grow(sb, dlen - len);

  memmove((void *)(sb->buf + (signed long int)pos + (signed long int)dlen), (const void *)(sb->buf + (signed long int)pos + (signed long int)len), (sb->len - pos) - len);
  memcpy((void *)(sb->buf + (signed long int)pos), data, dlen);
  strbuf_setlen(sb, (sb->len + dlen) - len);
}

// strbuf_stripout
// file strbuf.c line 201
signed int strbuf_stripout(struct strbuf *sb, void *buf, unsigned long int len)
{
  unsigned long int tmp_statement_expression_1;
  unsigned long int _x = len;
  unsigned long int _y = sb->len;
  (void)(&_x == &_y);
  tmp_statement_expression_1 = _x < _y ? _x : _y;
  len = tmp_statement_expression_1;
  if(!(len == 0ul))
  {
    memcpy(buf, (const void *)sb->buf, len);
    strbuf_remove(sb, (unsigned long int)0, len);
  }


out:
  ;
  return (signed int)len;
}

// timer_handler
// file event.c line 25
static void timer_handler(signed int fd, signed int events, void *data)
{
  struct timer *t = (struct timer *)data;
  unsigned long int val;
  signed long int return_value_read_1;
  return_value_read_1=read(fd, (void *)&val, sizeof(unsigned long int) /*8ul*/ );
  if(return_value_read_1 >= 0l)
  {
    t->callback(t->data);
    unregister_event(fd);
    close(fd);
  }

}

// tkill
// file util.c line 482
signed int tkill(signed int tid, signed int sig)
{
  signed int return_value_getpid_1;
  return_value_getpid_1=getpid();
  signed long int return_value_syscall_2;
  return_value_syscall_2=syscall((signed long int)234, return_value_getpid_1, tid, sig);
  return (signed int)return_value_syscall_2;
}

// trace_clear_tid_map
// file work.c line 190
static inline void trace_clear_tid_map(signed int tid)
{
  ;
}

// trace_set_tid_map
// file work.c line 189
static inline void trace_set_tid_map(signed int tid)
{
  ;
}

// transfer_to_idx_root
// file sd_inode.c line 355
static void transfer_to_idx_root(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode)
{
  struct sd_extent_header *left;
  struct sd_extent_header *right;
  struct sd_extent_header *root = (struct sd_extent_header *)inode->data_vdi_id;
  unsigned long int left_oid;
  unsigned long int right_oid;
  unsigned int num = root->entries / (unsigned int)2;
  void *return_value_xvalloc_1;
  return_value_xvalloc_1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
  left = (struct sd_extent_header *)return_value_xvalloc_1;
  void *return_value_xvalloc_2;
  return_value_xvalloc_2=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
  right = (struct sd_extent_header *)return_value_xvalloc_2;
  split_to_nodes(root, left, right, (signed int)num);
  unsigned int tmp_post_3 = inode->btree_counter;
  inode->btree_counter = inode->btree_counter + 1u;
  left_oid=vid_to_btree_oid(inode->vdi_id, tmp_post_3);
  unsigned int tmp_post_4 = inode->btree_counter;
  inode->btree_counter = inode->btree_counter + 1u;
  right_oid=vid_to_btree_oid(inode->vdi_id, tmp_post_4);
  writer(left_oid, (void *)left, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)1, (_Bool)0);
  writer(right_oid, (void *)right, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)1, (_Bool)0);
  root->entries = (unsigned int)0;
  root->depth = (unsigned short int)2;
  insert_idx_entry(root, (((struct sd_extent *)((char *)left + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)left)->entries) - (signed long int)1)->idx, left_oid);
  insert_idx_entry(root, (((struct sd_extent *)((char *)right + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)right)->entries) - (signed long int)1)->idx, right_oid);
  free((void *)left);
  free((void *)right);
}

// traverse_btree
// file sd_inode.c line 139
extern void traverse_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, void (*fn)(void *, enum btree_node_type, void *), void *arg)
{
  struct sd_extent_header *header = (struct sd_extent_header *)inode->data_vdi_id;
  struct sd_extent_header *leaf_node = (struct sd_extent_header *)(void *)0;
  struct sd_extent *last;
  struct sd_extent *iter;
  struct sd_extent_idx *last_idx;
  struct sd_extent_idx *iter_idx;
  void *tmp;
  fn((void *)header, (enum btree_node_type)BTREE_HEAD, arg);
  if((signed int)header->depth == 1)
  {
    last = (struct sd_extent *)((char *)inode->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)inode->data_vdi_id)->entries;
    iter = (struct sd_extent *)((char *)inode->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
    if(!(iter == last))
    {
      fn((void *)iter, (enum btree_node_type)BTREE_EXT, arg);
      iter = iter + 1l;
    }

  }

  else
    if((signed int)header->depth == 2)
    {
      last_idx = (struct sd_extent_idx *)((char *)inode->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)inode->data_vdi_id)->entries;
      iter_idx = (struct sd_extent_idx *)((char *)inode->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
      void *return_value_xvalloc_1;
      return_value_xvalloc_1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
      leaf_node = (struct sd_extent_header *)return_value_xvalloc_1;
      tmp = (void *)leaf_node;
      if(!(iter_idx == last_idx))
      {
        reader(iter_idx->oid, &tmp, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0);
        fn((void *)iter_idx, (enum btree_node_type)BTREE_IDX, arg);
        fn((void *)leaf_node, (enum btree_node_type)BTREE_HEAD, arg);
        last = (struct sd_extent *)((char *)leaf_node + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)leaf_node)->entries;
        iter = (struct sd_extent *)((char *)leaf_node + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
        if(!(iter == last))
        {
          fn((void *)iter, (enum btree_node_type)BTREE_EXT, arg);
          iter = iter + 1l;
        }

        iter_idx = iter_idx + 1l;
      }

      free((void *)leaf_node);
    }

    else
    {
      log_write(0, "traverse_btree", 180, "PANIC: This B-tree not support depth %u", header->depth);
      abort();
    }
}

// uatomic_is_true
// file ../include/util.h line 206
static inline _Bool uatomic_is_true(struct anonymous_6 *val)
{
  volatile unsigned long int tmp_statement_expression_1;
  asm("" :  :  : "memory");
  tmp_statement_expression_1 = *((volatile unsigned long int *)&(*(&val->val)));
  return tmp_statement_expression_1 == (unsigned long int)1;
}

// uatomic_set_false
// file ../include/util.h line 217
static inline void uatomic_set_false(struct anonymous_6 *val)
{
  unsigned long int _v;
  volatile unsigned long int tmp_statement_expression_1;
  *((volatile unsigned long int *)&(*(&val->val))) = (volatile unsigned long int)0;
  tmp_statement_expression_1 = *((volatile unsigned long int *)&(*(&val->val)));
  _v = tmp_statement_expression_1;
  asm("" :  :  : "memory");
  _v = _v;
}

// uatomic_set_false_link1
// file ../include/util.h line 217
static inline void uatomic_set_false_link1(struct anonymous_6 *val_link1)
{
  unsigned long int _v_link1;
  volatile unsigned long int tmp_statement_expression_1_link1;
  *((volatile unsigned long int *)&(*(&val_link1->val))) = (volatile unsigned long int)0;
  tmp_statement_expression_1_link1 = *((volatile unsigned long int *)&(*(&val_link1->val)));
  _v_link1 = tmp_statement_expression_1_link1;
  asm("" :  :  : "memory");
  _v_link1 = _v_link1;
}

// uatomic_set_true
// file ../include/util.h line 212
static inline _Bool uatomic_set_true(struct anonymous_6 *val)
{
  unsigned long int return_value___uatomic_cmpxchg_1;
  return_value___uatomic_cmpxchg_1=__uatomic_cmpxchg((void *)&val->val, (unsigned long int)0, (unsigned long int)1, (signed int)sizeof(unsigned long int) /*8ul*/ );
  return (unsigned long int)return_value___uatomic_cmpxchg_1 == (unsigned long int)0;
}

// uatomic_set_true_link1
// file ../include/util.h line 212
static inline _Bool uatomic_set_true_link1(struct anonymous_6 *val_link1)
{
  unsigned long int return_value___uatomic_cmpxchg_1_link1;
  return_value___uatomic_cmpxchg_1_link1=__uatomic_cmpxchg_link1((void *)&val_link1->val, (unsigned long int)0, (unsigned long int)1, (signed int)sizeof(unsigned long int) /*8ul*/ );
  return (unsigned long int)return_value___uatomic_cmpxchg_1_link1 == (unsigned long int)0;
}

// unblock_sighup
// file logger.c line 143
static void unblock_sighup(void)
{
  signed int ret;
  struct anonymous_16 new;
  struct anonymous_16 old;
  sigemptyset(&new);
  sigemptyset(&old);
  sigaddset(&new, 1);
  ret=sigprocmask(1, &new, &old);
  if(!(ret >= 0))
    syslog(3, "unblock SIGHUP failed\n");

}

// unregister_event
// file event.c line 125
void unregister_event(signed int fd)
{
  signed int ret;
  struct event_info *ei;
  ei=lookup_event(fd);
  if(!(ei == ((struct event_info *)NULL)))
  {
    ret=epoll_ctl(efd, 2, fd, (struct epoll_event *)(void *)0);
    if(!(ret == 0))
      log_write(3, "unregister_event", 136, "failed to delete epoll event for fd %d: %m", fd);

    rb_erase(&ei->rb, &events_tree);
    free((void *)ei);
    event_force_refresh();
  }

}

// usage
// file core.c line 331
static void usage(signed int inval)
{
  if(!(inval == 0))
    fprintf(stderr, "Try 'sheepfs --help' for help.\n");

  else
    printf("Usage: sheepfs [OPTION]... MOUNTPOINT\nOptions:\n  -a, --address           specify the sheep address (default: 127.0.0.1)\n  -d, --debug             enable debug output (implies -f)\n  -f, --foreground        sheepfs run in the foreground\n  -k, --pagecache         use local kernel's page cache to access volume\n  -o, --objectcache       enable object cache of the connected sheep daemon\n  -p, --port              specify the sheep port (default: 7000)\n  -h, --help              display this help and exit\n");
  exit(inval);
}

// vdi_inode_cmp
// file volume.c line 87
static signed int vdi_inode_cmp(struct vdi_inode *a, struct vdi_inode *b)
{
  signed int tmp_statement_expression_1;
  unsigned int _x = a->vid;
  unsigned int _y = b->vid;
  (void)(&_x == &_y);
  tmp_statement_expression_1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return tmp_statement_expression_1;
}

// vdi_inode_tree_insert
// file volume.c line 92
static struct vdi_inode * vdi_inode_tree_insert(struct vdi_inode *new)
{
  struct vdi_inode *tmp_statement_expression_1;
  struct rb_node **__n = &(&vdi_inode_tree)->rb_node;
  struct rb_node *__parent = (struct rb_node *)(void *)0;
  struct vdi_inode *__old = (struct vdi_inode *)(void *)0;
  struct vdi_inode *__data;
  struct vdi_inode *tmp_statement_expression_2;
  while(!(*__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = *__n;
    tmp_statement_expression_2 = (struct vdi_inode *)((char *)__mptr - (signed long int)0ul);
    __data = tmp_statement_expression_2;
    signed int __cmp;
    __cmp=vdi_inode_cmp(new, __data);
    __parent = *__n;
    if(!(__cmp >= 0))
      __n = &(*__n)->rb_left;

    else
      if(__cmp >= 1)
        __n = &(*__n)->rb_right;

      else
      {
        __old = __data;
        break;
      }
  }
  if(__old == ((struct vdi_inode *)NULL))
  {
    rb_link_node(&new->rb, __parent, __n);
    rb_insert_color(&new->rb, &vdi_inode_tree);
  }

  tmp_statement_expression_1 = __old;
  return tmp_statement_expression_1;
}

// vdi_inode_tree_search
// file volume.c line 97
static struct vdi_inode * vdi_inode_tree_search(unsigned int vid)
{
  struct vdi_inode key = { .rb={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) }, .vid=vid,
    .inode=((struct sd_inode *)NULL), .socket_pool={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .socket_in_use={ { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul }, { .val=0ul } },
    .socket_poll_adder=0u };
  struct vdi_inode *tmp_statement_expression_1;
  struct rb_node *__n = (&vdi_inode_tree)->rb_node;
  struct vdi_inode *__ret = (struct vdi_inode *)(void *)0;
  struct vdi_inode *__data;
  struct vdi_inode *tmp_statement_expression_2;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression_2 = (struct vdi_inode *)((char *)__mptr - (signed long int)0ul);
    __data = tmp_statement_expression_2;
    signed int __cmp;
    __cmp=vdi_inode_cmp(&key, __data);
    if(!(__cmp >= 0))
      __n = __n->rb_left;

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  tmp_statement_expression_1 = __ret;
  return tmp_statement_expression_1;
}

// vdi_list_get_size
// file sheepfs.h line 78
unsigned long int vdi_list_get_size(const char *path)
{
  struct strbuf *buf;
  unsigned long int len;
  char cmd[512l];
  snprintf(cmd, sizeof(char [512l]) /*512ul*/ , "dog vdi list -a %s -p %d", (const void *)sdhost, sdport);
  buf=sheepfs_run_cmd(cmd);
  if(buf == ((struct strbuf *)NULL))
    return (unsigned long int)0;

  else
  {
    len=shadow_file_write(path, buf->buf, buf->len);
    strbuf_release(buf);
    free((void *)buf);
    return len;
  }
}

// vdi_list_read
// file sheepfs.h line 77
signed int vdi_list_read(const char *path, char *buf, unsigned long int size, signed long int ignore)
{
  signed int return_value_shadow_file_read_1;
  return_value_shadow_file_read_1=shadow_file_read(path, buf, size, (signed long int)0);
  return return_value_shadow_file_read_1;
}

// vdi_mount_write
// file sheepfs.h line 80
signed int vdi_mount_write(const char *path, const char *buf, unsigned long int size, signed long int ignore)
{
  signed int return_value_volume_create_entry_1;
  return_value_volume_create_entry_1=volume_create_entry(buf);
  if(!(return_value_volume_create_entry_1 >= 0))
    return -22;

  else
    return (signed int)size;
}

// vdi_unmount_write
// file sheepfs.h line 81
signed int vdi_unmount_write(const char *path, const char *buf, unsigned long int size, signed long int ignore)
{
  signed int return_value_volume_remove_entry_1;
  return_value_volume_remove_entry_1=volume_remove_entry(buf);
  if(!(return_value_volume_remove_entry_1 >= 0))
    return -22;

  else
    return (signed int)size;
}

// vid_to_btree_oid
// file ../include/sheepdog_proto.h line 455
static inline unsigned long int vid_to_btree_oid(unsigned int vid, unsigned int btreeid)
{
  return (unsigned long int)vid << 32 | 1UL << 60 | (unsigned long int)btreeid;
}

// vid_to_data_oid
// file ../include/sheepdog_proto.h line 440
static inline unsigned long int vid_to_data_oid(unsigned int vid, unsigned long int idx)
{
  return (unsigned long int)vid << 32 | idx;
}

// vid_to_vdi_oid
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid(unsigned int vid)
{
  return 1UL << 63 | (unsigned long int)vid << 32;
}

// vid_to_vdi_oid_link1
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid_link1(unsigned int vid_link1)
{
  return 1UL << 63 | (unsigned long int)vid_link1 << 32;
}

// volume_create_entry
// file sheepfs.h line 64
signed int volume_create_entry(const char *entry)
{
  char path[4096l];
  char *ch;
  unsigned int vid;
  unsigned long int size;
  ch=strchr(entry, 10);
  if(!(ch == ((char *)NULL)))
    *ch = (char)0;

  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", (const void *)"/volume", entry);
  _Bool return_value_shadow_file_exsit_1;
  return_value_shadow_file_exsit_1=shadow_file_exsit(path);
  if(!(return_value_shadow_file_exsit_1 == (_Bool)0))
    return 0;

  else
  {
    signed int return_value_init_vdi_info_2;
    return_value_init_vdi_info_2=init_vdi_info(entry, &vid, &size);
    if(!(return_value_init_vdi_info_2 >= 0))
      return -1;

    else
    {
      signed int return_value_shadow_file_create_3;
      return_value_shadow_file_create_3=shadow_file_create(path);
      if(!(return_value_shadow_file_create_3 >= 0))
        return -1;

      else
      {
        signed int return_value_shadow_file_setxattr_4;
        return_value_shadow_file_setxattr_4=shadow_file_setxattr(path, "user.volume.vid", (const void *)&vid, sizeof(unsigned int) /*4ul*/ );
        if(!(return_value_shadow_file_setxattr_4 >= 0))
        {
          shadow_file_delete(path);
          return -1;
        }

        else
        {
          signed int return_value_shadow_file_setxattr_5;
          return_value_shadow_file_setxattr_5=shadow_file_setxattr(path, "user.volume.size", (const void *)&size, sizeof(unsigned long int) /*8ul*/ );
          if(!(return_value_shadow_file_setxattr_5 >= 0))
          {
            shadow_file_delete(path);
            return -1;
          }

          else
          {
            signed int return_value_sheepfs_set_op_6;
            return_value_sheepfs_set_op_6=sheepfs_set_op(path, (unsigned int)10);
            if(!(return_value_sheepfs_set_op_6 >= 0))
              return -1;

            else
              return 0;
          }
        }
      }
    }
  }
}

// volume_do_rw
// file volume.c line 210
static signed long int volume_do_rw(const char *path, char *buf, unsigned long int size, signed long int offset, signed int rw)
{
  unsigned int vid;
  unsigned long int oid;
  unsigned long int idx;
  signed long int start;
  unsigned long int len;
  unsigned long int ret;
  unsigned long int vdi_size;
  unsigned long int sz;
  signed int return_value_shadow_file_getxattr_1;
  return_value_shadow_file_getxattr_1=shadow_file_getxattr(path, "user.volume.vid", (void *)&vid, sizeof(unsigned int) /*4ul*/ );
  if(!(return_value_shadow_file_getxattr_1 >= 0))
    return (signed long int)-1;

  else
  {
    signed int return_value_shadow_file_getxattr_2;
    return_value_shadow_file_getxattr_2=shadow_file_getxattr(path, "user.volume.size", (void *)&vdi_size, sizeof(unsigned long int) /*8ul*/ );
    if(!(return_value_shadow_file_getxattr_2 >= 0))
      return (signed long int)-1;

    else
      if((unsigned long int)offset >= vdi_size)
        return (signed long int)0;

      else
      {
        if(!(vdi_size >= size + (unsigned long int)offset))
          size = vdi_size - (unsigned long int)offset;

        sz = size;
        idx = (unsigned long int)offset / (1UL << 22);
        oid=vid_to_data_oid(vid, idx);
        start = (signed long int)((unsigned long int)offset % (1UL << 22));
        len = (1UL << 22) - (unsigned long int)start;
        if(!(size >= len))
          len = size;

        do
        {
          signed int return_value_volume_rw_object_3;
          return_value_volume_rw_object_3=volume_rw_object(buf, oid, len, start, rw);
          ret = (unsigned long int)return_value_volume_rw_object_3;
          if(!(ret == len))
            return (signed long int)-1;

          oid = oid + 1ul;
          size = size - len;
          start = (signed long int)(((unsigned long int)start + len) % (1UL << 22));
          buf = buf + (signed long int)len;
          len = size > 1UL << 22 ? 1UL << 22 : size;
        }
        while(size >= 1ul);
        return (signed long int)(sz - size);
      }
  }
}

// volume_do_sync
// file volume.c line 314
static signed int volume_do_sync(unsigned int vid)
{
  struct sd_req hdr = { .proto_ver=(unsigned char)0, .opcode=0, .flags=0,
    .epoch=0u, .id=0u, .data_length=0u, ._anon0={ .obj={ .oid=0ul, .cow_oid=0ul, .copies=0, .copy_policy=0, .ec_index=0,
    .reserved=0, .tgt_epoch=0u, .offset=0u,
    .__pad=0u } } };
  struct sd_rsp *rsp = (struct sd_rsp *)&hdr;
  signed int ret;
  signed int fd;
  signed int idx;
  struct vdi_inode *vdi;
  sd_read_lock(&vdi_inode_tree_lock);
  vdi=vdi_inode_tree_search(vid);
  sd_rw_unlock(&vdi_inode_tree_lock);
  hdr.opcode = (unsigned char)0x16;
  hdr._anon0.obj.oid=vid_to_vdi_oid(vid);
  fd=get_socket_fd(vdi, &idx);
  ret=exec_req(fd, &hdr, (void *)0, (_Bool (*)(unsigned int))(void *)0, (unsigned int)0, (unsigned int)(30 / 5));
  put_socket_fd(vdi, idx);
  _Bool tmp_if_expr_1;
  if(rsp->_anon0.result == 5u)
    sheepfs_object_cache = 0;

  else
  {
    if(!(ret == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = rsp->_anon0.result != (unsigned int)0x00 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      fs_printf("volume_do_sync", 339, "failed to flush vdi %x\n", vid);
      return -1;
    }

  }

out:
  ;
  return 0;
}

// volume_get_size
// file sheepfs.h line 63
unsigned long int volume_get_size(const char *path)
{
  unsigned long int size = (unsigned long int)0;
  shadow_file_getxattr(path, "user.volume.size", (void *)&size, sizeof(unsigned long int) /*8ul*/ );
  return size;
}

// volume_open
// file sheepfs.h line 67
signed int volume_open(const char *path, struct fuse_file_info *fi)
{
  if(sheepfs_page_cache == 0)
    fi->direct_io = (unsigned int)1;

  return 0;
}

// volume_read
// file sheepfs.h line 61
signed int volume_read(const char *path, char *buf, unsigned long int size, signed long int offset)
{
  signed long int done;
  done=volume_do_rw(path, buf, size, offset, 0);
  if(!(done >= 0l))
    return -5;

  else
    return (signed int)done;
}

// volume_remove_entry
// file sheepfs.h line 65
signed int volume_remove_entry(const char *entry)
{
  char path[4096l];
  char *ch;
  unsigned int vid;
  struct vdi_inode *vdi;
  ch=strchr(entry, 10);
  if(!(ch == ((char *)NULL)))
    *ch = (char)0;

  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", (const void *)"/volume", entry);
  _Bool return_value_shadow_file_exsit_1;
  return_value_shadow_file_exsit_1=shadow_file_exsit(path);
  signed int return_value_volume_sync_and_delete_3;
  if(return_value_shadow_file_exsit_1 == (_Bool)0)
    return -1;

  else
  {
    signed int return_value_shadow_file_getxattr_2;
    return_value_shadow_file_getxattr_2=shadow_file_getxattr(path, "user.volume.vid", (void *)&vid, sizeof(unsigned int) /*4ul*/ );
    if(!(return_value_shadow_file_getxattr_2 >= 0))
      return -1;

    else
      if(!(sheepfs_object_cache == 0))
      {
        return_value_volume_sync_and_delete_3=volume_sync_and_delete(vid);
        if(return_value_volume_sync_and_delete_3 >= 0)
          goto __CPROVER_DUMP_L4;

        return -1;
      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        sd_read_lock(&vdi_inode_tree_lock);
        vdi=vdi_inode_tree_search(vid);
        sd_rw_unlock(&vdi_inode_tree_lock);
        destroy_socket_pool(vdi->socket_pool, 31);
        sd_write_lock(&vdi_inode_tree_lock);
        rb_erase(&vdi->rb, &vdi_inode_tree);
        sd_rw_unlock(&vdi_inode_tree_lock);
        free((void *)vdi->inode);
        free((void *)vdi);
        shadow_file_delete(path);
        return 0;
      }
  }
}

// volume_rw_object
// file volume.c line 133
static signed int volume_rw_object(char *buf, unsigned long int oid, unsigned long int size, signed long int off, signed int rw)
{
  struct sd_req hdr = { .proto_ver=(unsigned char)0, .opcode=0, .flags=0,
    .epoch=0u, .id=0u, .data_length=0u, ._anon0={ .obj={ .oid=0ul, .cow_oid=0ul, .copies=0, .copy_policy=0, .ec_index=0,
    .reserved=0, .tgt_epoch=0u, .offset=0u,
    .__pad=0u } } };
  struct sd_rsp *rsp = (struct sd_rsp *)&hdr;
  signed int ret;
  signed int fd;
  signed int sock_idx;
  _Bool create = (_Bool)0;
  unsigned int vid;
  vid=oid_to_vid(oid);
  unsigned int vdi_id;
  struct vdi_inode *vdi;
  unsigned long int idx = (unsigned long int)0;
  unsigned long int cow_oid = (unsigned long int)0;
  sd_read_lock(&vdi_inode_tree_lock);
  vdi=vdi_inode_tree_search(vid);
  sd_rw_unlock(&vdi_inode_tree_lock);
  _Bool return_value_is_data_obj_2;
  return_value_is_data_obj_2=is_data_obj(oid);
  _Bool return_value_is_data_obj_writeable_1;
  if(!(return_value_is_data_obj_2 == (_Bool)0))
  {
    idx=data_oid_to_idx(oid);
    vdi_id=sd_inode_get_vid(sheepfs_bnode_reader, vdi->inode, (unsigned int)idx);
    if(vdi_id == 0u)
    {
      if(rw == 0)
      {
        memset((void *)buf, 0, size);
        goto done;
      }

      create = (_Bool)1;
    }

    else
      if(rw == 0)
        oid=vid_to_data_oid(vdi_id, idx);

      else
      {
        return_value_is_data_obj_writeable_1=is_data_obj_writeable(vdi->inode, (unsigned int)idx);
        if(return_value_is_data_obj_writeable_1 == (_Bool)0)
        {
          cow_oid=vid_to_data_oid(vdi_id, idx);
          hdr.flags = hdr.flags | (unsigned short int)0x02;
          create = (_Bool)1;
        }

      }
  }

  _Bool tmp_if_expr_4;
  _Bool return_value_is_vdi_btree_obj_3;
  if(rw == 0)
    hdr.opcode = (unsigned char)0x02;

  else
  {
    if(!(create == (_Bool)0))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_is_vdi_btree_obj_3=is_vdi_btree_obj(oid);
      tmp_if_expr_4 = return_value_is_vdi_btree_obj_3 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
    }
    hdr.opcode = (unsigned char)(tmp_if_expr_4 ? 0x01 : 0x03);
    hdr.flags = hdr.flags | (unsigned short int)0x01;
  }
  hdr._anon0.obj.oid = oid;
  hdr._anon0.obj.offset = (unsigned int)off;
  hdr._anon0.obj.cow_oid = cow_oid;
  hdr.data_length = (unsigned int)size;
  if(!(sheepfs_object_cache == 0))
    hdr.flags = hdr.flags | (unsigned short int)0x04;

  fd=get_socket_fd(vdi, &sock_idx);
  ret=exec_req(fd, &hdr, (void *)buf, (_Bool (*)(unsigned int))(void *)0, (unsigned int)0, (unsigned int)(30 / 5));
  put_socket_fd(vdi, sock_idx);
  _Bool tmp_if_expr_6;
  if(!(ret == 0))
    tmp_if_expr_6 = (_Bool)1;

  else
    tmp_if_expr_6 = rsp->_anon0.result != (unsigned int)0x00 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_6)
  {
    const char *return_value_sd_strerror_5;
    return_value_sd_strerror_5=sd_strerror((signed int)rsp->_anon0.result);
    fs_printf("volume_rw_object", 194, "failed to %s object %lx ret %d, res %s\n", rw == 0 ? "read" : "write", oid, ret, return_value_sd_strerror_5);
    return -1;
  }

  else
  {
    if(!(create == (_Bool)0))
    {
      sd_inode_set_vid(sheepfs_bnode_writer, sheepfs_bnode_reader, vdi->inode, (unsigned int)idx, vid);
      signed int return_value_sd_inode_write_vid_7;
      return_value_sd_inode_write_vid_7=sd_inode_write_vid(sheepfs_bnode_writer, vdi->inode, (unsigned int)idx, vid, vid, 0, (_Bool)0, (_Bool)0);
      if(!(return_value_sd_inode_write_vid_7 >= 0))
        return -1;

    }


  done:
    ;
    return (signed int)size;
  }
}

// volume_sync
// file sheepfs.h line 66
signed int volume_sync(const char *path)
{
  unsigned int vid;
  signed int return_value_shadow_file_getxattr_1;
  return_value_shadow_file_getxattr_1=shadow_file_getxattr(path, "user.volume.vid", (void *)&vid, sizeof(unsigned int) /*4ul*/ );
  signed int return_value_volume_do_sync_2;
  if(!(return_value_shadow_file_getxattr_1 >= 0))
    return -5;

  else
    if(!(sheepfs_object_cache == 0))
    {
      return_value_volume_do_sync_2=volume_do_sync(vid);
      if(return_value_volume_do_sync_2 >= 0)
        goto __CPROVER_DUMP_L2;

      return -5;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      return 0;
    }
}

// volume_sync_and_delete
// file volume.c line 505
static signed int volume_sync_and_delete(unsigned int vid)
{
  struct sd_req hdr = { .proto_ver=(unsigned char)0, .opcode=0, .flags=0,
    .epoch=0u, .id=0u, .data_length=0u, ._anon0={ .obj={ .oid=0ul, .cow_oid=0ul, .copies=0, .copy_policy=0, .ec_index=0,
    .reserved=0, .tgt_epoch=0u, .offset=0u,
    .__pad=0u } } };
  struct sd_rsp *rsp = (struct sd_rsp *)&hdr;
  signed int ret;
  signed int fd;
  signed int idx;
  struct vdi_inode *vdi;
  sd_read_lock(&vdi_inode_tree_lock);
  vdi=vdi_inode_tree_search(vid);
  sd_rw_unlock(&vdi_inode_tree_lock);
  hdr.opcode = (unsigned char)0x98;
  hdr._anon0.obj.oid=vid_to_vdi_oid(vid);
  fd=get_socket_fd(vdi, &idx);
  ret=exec_req(fd, &hdr, (void *)0, (_Bool (*)(unsigned int))(void *)0, (unsigned int)0, (unsigned int)(30 / 5));
  put_socket_fd(vdi, idx);
  _Bool tmp_if_expr_1;
  if(!(ret == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = rsp->_anon0.result != (unsigned int)0x00 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    fs_printf("volume_sync_and_delete", 524, "failed to flush vdi %x\n", vid);
    return -1;
  }

  else
    return 0;
}

// volume_write
// file sheepfs.h line 62
signed int volume_write(const char *path, const char *buf, unsigned long int size, signed long int offset)
{
  signed long int done;
  done=volume_do_rw(path, (char *)buf, size, offset, 1);
  if(!(done >= 0l))
    return -5;

  else
    return (signed int)done;
}

// work_queue_empty
// file work.c line 445
_Bool work_queue_empty(struct work_queue *q)
{
  struct wq_info *wi;
  struct wq_info *tmp_statement_expression_1;
  const struct work_queue *__mptr = q;
  tmp_statement_expression_1 = (struct wq_info *)((char *)__mptr - (signed long int)208ul);
  wi = tmp_statement_expression_1;
  volatile unsigned long int tmp_statement_expression_2;
  asm("" :  :  : "memory");
  tmp_statement_expression_2 = *((volatile unsigned long int *)&(*(&wi->nr_queued_work)));
  return tmp_statement_expression_2 == (unsigned long int)0;
}

// worker_routine
// file work.c line 313
static void * worker_routine(void *arg)
{
  struct wq_info *wi = (struct wq_info *)arg;
  struct work *work;
  signed int tid;
  tid=gettid();
  set_thread_name(wi->name, (signed int)wi->tc != WQ_ORDERED);
  sd_mutex_lock(&wi->startup_lock);
  sd_mutex_unlock(&wi->startup_lock);
  trace_set_tid_map(tid);
  _Bool return_value_list_empty_3;
  struct work *tmp_statement_expression_4;
  while((_Bool)1)
  {
    sd_mutex_lock(&wi->pending_lock);
    _Bool return_value_wq_need_shrink_2;
    return_value_wq_need_shrink_2=wq_need_shrink(wi);
    if(!(return_value_wq_need_shrink_2 == (_Bool)0))
    {
      wi->nr_threads = wi->nr_threads - 1ul;
      trace_clear_tid_map(tid);
      sd_mutex_unlock(&wi->pending_lock);
      unsigned long int return_value_pthread_self_1;
      return_value_pthread_self_1=pthread_self();
      pthread_detach(return_value_pthread_self_1);
      if(sd_log_level == 7)
        log_write(7, "worker_routine", 336, "destroy thread %s %d, %zu", wi->name, tid, wi->nr_threads);

      break;
    }

    do
    {

    retest:
      ;
      return_value_list_empty_3=list_empty_link1(&wi->q.pending_list);
      if(return_value_list_empty_3 == (_Bool)0)
        break;

      sd_cond_wait(&wi->pending_cond, &wi->pending_lock);
    }
    while((_Bool)1);
    const struct list_node *__mptr = (&wi->q.pending_list)->n.next;
    tmp_statement_expression_4 = (struct work *)((char *)__mptr - (signed long int)0ul);
    work = tmp_statement_expression_4;
    list_del(&work->w_list);
    sd_mutex_unlock(&wi->pending_lock);
    if(!(work->fn == ((void (*)(struct work *))NULL)))
      work->fn(work);

    sd_mutex_lock(&wi->finished_lock);
    list_add_tail(&work->w_list, &wi->finished_list);
    sd_mutex_unlock(&wi->finished_lock);
    eventfd_xwrite(efd_link1, 1);
  }
  pthread_exit((void *)0);
}

// worker_thread_request_done
// file work.c line 287
static void worker_thread_request_done(signed int fd, signed int events, void *data)
{
  struct wq_info *wi;
  struct work *work;
  struct list_head list = { .n={ .next=&list.n, .prev=&list.n } };
  if(!(wq_get_nr_nodes == ((unsigned long int (*)(void))NULL)))
    nr_nodes=wq_get_nr_nodes();

  eventfd_xread(fd);
  struct wq_info *__n298;
  struct wq_info *tmp_statement_expression_1;
  const struct list_node *__mptr = (&wq_info_list)->n.next;
  tmp_statement_expression_1 = (struct wq_info *)((char *)__mptr - (signed long int)24ul);
  wi = tmp_statement_expression_1;
  struct wq_info *tmp_statement_expression_2;
  const struct list_node *worker_thread_request_done__1__1__2____mptr = wi->list.next;
  tmp_statement_expression_2 = (struct wq_info *)((char *)worker_thread_request_done__1__1__2____mptr - (signed long int)24ul);
  __n298 = tmp_statement_expression_2;
  struct work *tmp_statement_expression_5;
  struct wq_info *tmp_statement_expression_3;
  for( ; !(&wi->list == &(&wq_info_list)->n); __n298 = tmp_statement_expression_3)
  {
    sd_mutex_lock(&wi->finished_lock);
    list_splice_init(&wi->finished_list, &list);
    sd_mutex_unlock(&wi->finished_lock);
    _Bool return_value_list_empty_4;
    return_value_list_empty_4=list_empty_link1(&list);
    if(return_value_list_empty_4 == (_Bool)0)
    {
      const struct list_node *worker_thread_request_done__1__1__4__1__1____mptr = (&list)->n.next;
      tmp_statement_expression_5 = (struct work *)((char *)worker_thread_request_done__1__1__4__1__1____mptr - (signed long int)0ul);
      work = tmp_statement_expression_5;
      list_del(&work->w_list);
      work->done(work);
      __uatomic_dec((void *)&wi->nr_queued_work, (signed int)sizeof(unsigned long int) /*8ul*/ );
    }

    wi = __n298;
    const struct list_node *worker_thread_request_done__1__1__3____mptr = __n298->list.next;
    tmp_statement_expression_3 = (struct wq_info *)((char *)worker_thread_request_done__1__1__3____mptr - (signed long int)24ul);
  }
}

// wq_get_roof
// file work.c line 202
static inline unsigned long int wq_get_roof(struct wq_info *wi)
{
  unsigned long int nr = (unsigned long int)1;
  switch((signed int)wi->tc)
  {
    case WQ_ORDERED:
      break;
    case WQ_DYNAMIC:
    {
      nr = nr_nodes * (unsigned long int)2;
      break;
    }
    case WQ_UNLIMITED:
    {
      nr = 18446744073709551615UL;
      break;
    }
    default:
    {
      log_write(0, "wq_get_roof", 217, "PANIC: Invalid threads control %d", wi->tc);
      abort();
    }
  }
  return nr;
}

// wq_need_grow
// file work.c line 222
static _Bool wq_need_grow(struct wq_info *wi)
{
  volatile unsigned long int tmp_statement_expression_3;
  asm("" :  :  : "memory");
  tmp_statement_expression_3 = *((volatile unsigned long int *)&(*(&wi->nr_queued_work)));
  unsigned long int return_value_wq_get_roof_2;
  if(!(wi->nr_threads >= tmp_statement_expression_3))
  {
    return_value_wq_get_roof_2=wq_get_roof(wi);
    if(return_value_wq_get_roof_2 >= 2ul * wi->nr_threads)
    {
      unsigned long int return_value_get_msec_time_1;
      return_value_get_msec_time_1=get_msec_time();
      wi->tm_end_of_protection = return_value_get_msec_time_1 + (unsigned long int)1000;
      return (_Bool)1;
    }

  }

  return (_Bool)0;
}

// wq_need_shrink
// file work.c line 238
static _Bool wq_need_shrink(struct wq_info *wi)
{
  volatile unsigned long int tmp_statement_expression_2;
  asm("" :  :  : "memory");
  tmp_statement_expression_2 = *((volatile unsigned long int *)&(*(&wi->nr_queued_work)));
  unsigned long int return_value_get_msec_time_1;
  if(!(tmp_statement_expression_2 >= wi->nr_threads / 2ul))
  {
    return_value_get_msec_time_1=get_msec_time();
    return wi->tm_end_of_protection <= return_value_get_msec_time_1;
  }

  else
  {
    unsigned long int return_value_get_msec_time_3;
    return_value_get_msec_time_3=get_msec_time();
    wi->tm_end_of_protection = return_value_get_msec_time_3 + (unsigned long int)1000;
    return (_Bool)0;
  }
}

// wq_trace_init
// file work.c line 188
static inline signed int wq_trace_init(void)
{
  return 0;
}

// write_cb
// file http.c line 108
static unsigned long int write_cb(void *contents, unsigned long int size, unsigned long int nmemb, void *userp)
{
  unsigned long int real_size = size * nmemb;
  struct buffer_s *buff = (struct buffer_s *)userp;
  if(!(buff->total_size >= buff->current_size + real_size))
    real_size = buff->total_size - buff->current_size;

  memcpy((void *)(buff->mem + (signed long int)buff->current_size), contents, real_size);
  buff->current_size = buff->current_size + real_size;
  return real_size;
}

// xcalloc
// file ../include/util.h line 94
void * xcalloc(unsigned long int nmemb, unsigned long int size)
{
  void *ret;
  ret=calloc(nmemb, size);
  if(ret == NULL && (nmemb == 0ul || size == 0ul))
    ret=calloc((unsigned long int)1, (unsigned long int)1);

  if(ret == NULL)
  {
    try_to_free_routine(nmemb * size);
    ret=calloc(nmemb, size);
    if(ret == NULL && (nmemb == 0ul || size == 0ul))
      ret=calloc((unsigned long int)1, (unsigned long int)1);

    if(ret == NULL)
    {
      log_write(0, "xcalloc", 91, "PANIC: Out of memory");
      abort();
    }

  }

  return ret;
}

// xfallocate
// file util.c line 252
signed int xfallocate(signed int fd, signed int mode, signed long int offset, signed long int len)
{
  signed int ret;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  do
  {
    ret=fallocate(fd, mode, offset, len);
    if(!(ret >= 0))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 11)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
  }
  while(tmp_if_expr_4);
  return ret;
}

// xftruncate
// file util.c line 263
signed int xftruncate(signed int fd, signed long int length)
{
  signed int ret;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  do
  {
    ret=ftruncate(fd, length);
    if(!(ret >= 0))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 11)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
  }
  while(tmp_if_expr_4);
  return ret;
}

// xmalloc
// file ../include/util.h line 91
void * xmalloc(unsigned long int size)
{
  void *ret;
  ret=malloc(size);
  if(ret == NULL && size == 0ul)
    ret=malloc((unsigned long int)1);

  if(ret == NULL)
  {
    try_to_free_routine(size);
    ret=malloc(size);
    if(ret == NULL && size == 0ul)
      ret=malloc((unsigned long int)1);

    if(ret == NULL)
    {
      log_write(0, "xmalloc", 54, "PANIC: Out of memory");
      abort();
    }

  }

  return ret;
}

// xmkdir
// file ../include/util.h line 100
signed int xmkdir(const char *pathname, unsigned int mode)
{
  signed int return_value_mkdir_4;
  return_value_mkdir_4=mkdir(pathname, mode);
  if(!(return_value_mkdir_4 >= 0))
  {
    struct stat st;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 17))
      return -1;

    signed int return_value_stat_2;
    return_value_stat_2=stat(pathname, &st);
    if(!(return_value_stat_2 >= 0))
      return -1;

    if(!((61440u & st.st_mode) == 16384u))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 17;
      return -1;
    }

  }

  return 0;
}

// xpread
// file ../include/util.h line 98
signed long int xpread(signed int fd, void *buf, unsigned long int count, signed long int offset)
{
  char *p = (char *)buf;
  signed long int total = (signed long int)0;
  while(count >= 1ul)
  {
    signed long int loaded;
    loaded=_pread(fd, (void *)p, count, offset);
    if(!(loaded >= 0l))
      return (signed long int)-1;

    if(loaded == 0l)
      return total;

    count = count - (unsigned long int)loaded;
    p = p + loaded;
    total = total + loaded;
    offset = offset + loaded;
  }
  return total;
}

// xpwrite
// file util.c line 210
signed long int xpwrite(signed int fd, const void *buf, unsigned long int count, signed long int offset)
{
  const char *p = (const char *)buf;
  signed long int total = (signed long int)0;
  while(count >= 1ul)
  {
    signed long int written;
    written=_pwrite(fd, (const void *)p, count, offset);
    if(!(written >= 0l))
      return (signed long int)-1;

    if(written == 0l)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 28;
      return (signed long int)-1;
    }

    count = count - (unsigned long int)written;
    p = p + written;
    total = total + written;
    offset = offset + written;
  }
  return total;
}

// xread
// file util.c line 128
signed long int xread(signed int fd, void *buf, unsigned long int count)
{
  char *p = (char *)buf;
  signed long int total = (signed long int)0;
  while(count >= 1ul)
  {
    signed long int loaded;
    loaded=_read(fd, (void *)p, count);
    if(!(loaded >= 0l))
      return (signed long int)-1;

    if(loaded == 0l)
      return total;

    count = count - (unsigned long int)loaded;
    p = p + loaded;
    total = total + loaded;
  }
  return total;
}

// xrealloc
// file util.c line 64
void * xrealloc(void *ptr, unsigned long int size)
{
  void *ret;
  ret=realloc(ptr, size);
  if(ret == NULL && size == 0ul)
    ret=realloc(ptr, (unsigned long int)1);

  if(ret == NULL)
  {
    try_to_free_routine(size);
    ret=realloc(ptr, size);
    if(ret == NULL && size == 0ul)
      ret=realloc(ptr, (unsigned long int)1);

    if(ret == NULL)
    {
      log_write(0, "xrealloc", 75, "PANIC: Out of memory");
      abort();
    }

  }

  return ret;
}

// xvalloc
// file util.c line 97
void * xvalloc(unsigned long int size)
{
  void *ret;
  ret=valloc(size);
  if(ret == NULL)
  {
    log_write(0, "xvalloc", 101, "PANIC: Out of memory");
    abort();
  }

  memset(ret, 0, size);
  return ret;
}

// xwrite
// file ../include/util.h line 97
signed long int xwrite(signed int fd, const void *buf, unsigned long int count)
{
  const char *p = (const char *)buf;
  signed long int total = (signed long int)0;
  while(count >= 1ul)
  {
    signed long int written;
    written=_write(fd, (const void *)p, count);
    if(!(written >= 0l))
      return (signed long int)-1;

    if(written == 0l)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 28;
      return (signed long int)-1;
    }

    count = count - (unsigned long int)written;
    p = p + written;
    total = total + written;
  }
  return total;
}

// xzalloc
// file ../include/util.h line 92
void * xzalloc(unsigned long int size)
{
  void *return_value_xcalloc_1;
  return_value_xcalloc_1=xcalloc((unsigned long int)1, size);
  return return_value_xcalloc_1;
}

