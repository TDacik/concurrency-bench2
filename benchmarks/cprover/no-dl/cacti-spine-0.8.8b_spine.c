// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$20;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$17;

// tag-#anon#ST[*{cS8}$cS8$'opt'||*{cS8}$cS8$'val'|]
// file util.c line 49
struct anonymous$0;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$8;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$12;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#}$SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#$'__cancel_jmp_buf'||ARR4{*{V}$V$}$*{V}$V$$'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous$2;

// tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous$1;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$13;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$16;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$15;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$19;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$14;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$18;

// tag-#anon#ST[SYM#tag-ip#'idi_ip'|]
// file /usr/include/netinet/ip_icmp.h line 185
struct anonymous$6;

// tag-#anon#ST[U32'its_otime'||U32'its_rtime'||U32'its_ttime'|]
// file /usr/include/netinet/ip_icmp.h line 179
struct anonymous$5;

// tag-#anon#UN[*{S64}$S64$'integer'||*{U8}$U8$'string'||*{U64}$U64$'objid'||*{U8}$U8$'bitstring'||*{SYM#tag-counter64#}$SYM#tag-counter64#$'counter64'||*{F32}$F32$'floatVal'||*{F64}$F64$'doubleVal'|]
// file /usr/include/net-snmp/types.h line 114
union anonymous$3;

// tag-#anon#UN[*{S8}$S8$'client_ip'||*{S8}$S8$'bind_address'|]
// file /usr/include/mysql/mysql.h line 208
union anonymous;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$11;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$21;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$10;

// tag-#anon#UN[SYM#tag-#anon#ST[U32'its_otime'||U32'its_rtime'||U32'its_ttime'|]#'id_ts'||SYM#tag-#anon#ST[SYM#tag-ip#'idi_ip'|]#'id_ip'||SYM#tag-icmp_ra_addr#'id_radv'||U32'id_mask'||ARR1{U8}$U8$'id_data'|]
// file /usr/include/netinet/ip_icmp.h line 177
union anonymous$7;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$9;

// tag-#anon#UN[U8'ih_pptr'||SYM#tag-in_addr#'ih_gwaddr'||SYM#tag-ih_idseq#'ih_idseq'||U32'ih_void'||SYM#tag-ih_pmtu#'ih_pmtu'||SYM#tag-ih_rtradv#'ih_rtradv'|]
// file /usr/include/netinet/ip_icmp.h line 142
union anonymous$4;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-charset_info_st
// file /usr/include/mysql/mysql.h line 269
struct charset_info_st;

// tag-config_struct
// file spine.h line 291
struct config_struct;

// tag-counter64
// file /usr/include/net-snmp/types.h line 119
struct counter64;

// tag-embedded_query_result
// file /usr/include/mysql/mysql.h line 148
struct embedded_query_result;

// tag-enum_field_types
// file /usr/include/mysql/mysql_com.h line 369
enum enum_field_types { MYSQL_TYPE_DECIMAL=0, MYSQL_TYPE_TINY=1, MYSQL_TYPE_SHORT=2, MYSQL_TYPE_LONG=3, MYSQL_TYPE_FLOAT=4, MYSQL_TYPE_DOUBLE=5, MYSQL_TYPE_NULL=6, MYSQL_TYPE_TIMESTAMP=7, MYSQL_TYPE_LONGLONG=8, MYSQL_TYPE_INT24=9, MYSQL_TYPE_DATE=10, MYSQL_TYPE_TIME=11, MYSQL_TYPE_DATETIME=12, MYSQL_TYPE_YEAR=13, MYSQL_TYPE_NEWDATE=14, MYSQL_TYPE_VARCHAR=15, MYSQL_TYPE_BIT=16, MYSQL_TYPE_TIMESTAMP2=17, MYSQL_TYPE_DATETIME2=18, MYSQL_TYPE_TIME2=19, MYSQL_TYPE_NEWDECIMAL=246, MYSQL_TYPE_ENUM=247, MYSQL_TYPE_SET=248, MYSQL_TYPE_TINY_BLOB=249, MYSQL_TYPE_MEDIUM_BLOB=250, MYSQL_TYPE_LONG_BLOB=251, MYSQL_TYPE_BLOB=252, MYSQL_TYPE_VAR_STRING=253, MYSQL_TYPE_STRING=254, MYSQL_TYPE_GEOMETRY=255 };

// tag-enum_list
// file /usr/include/net-snmp/library/parse.h line 53
struct enum_list;

// tag-host_reindex_struct
// file spine.h line 474
struct host_reindex_struct;

// tag-host_struct
// file spine.h line 432
struct host_struct;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-icmp
// file /usr/include/netinet/ip_icmp.h line 137
struct icmp;

// tag-icmp_ra_addr
// file /usr/include/netinet/ip_icmp.h line 131
struct icmp_ra_addr;

// tag-ih_idseq
// file /usr/include/netinet/ip_icmp.h line 146
struct ih_idseq;

// tag-ih_pmtu
// file /usr/include/netinet/ip_icmp.h line 154
struct ih_pmtu;

// tag-ih_rtradv
// file /usr/include/netinet/ip_icmp.h line 160
struct ih_rtradv;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-ip
// file /usr/include/netinet/ip.h line 107
struct ip;

// tag-keyword
// file keywords.c line 49
struct keyword;

// tag-mysql_option
// file /usr/include/mysql/mysql.h line 159
enum mysql_option { MYSQL_OPT_CONNECT_TIMEOUT=0, MYSQL_OPT_COMPRESS=1, MYSQL_OPT_NAMED_PIPE=2, MYSQL_INIT_COMMAND=3, MYSQL_READ_DEFAULT_FILE=4, MYSQL_READ_DEFAULT_GROUP=5, MYSQL_SET_CHARSET_DIR=6, MYSQL_SET_CHARSET_NAME=7, MYSQL_OPT_LOCAL_INFILE=8, MYSQL_OPT_PROTOCOL=9, MYSQL_SHARED_MEMORY_BASE_NAME=10, MYSQL_OPT_READ_TIMEOUT=11, MYSQL_OPT_WRITE_TIMEOUT=12, MYSQL_OPT_USE_RESULT=13, MYSQL_OPT_USE_REMOTE_CONNECTION=14, MYSQL_OPT_USE_EMBEDDED_CONNECTION=15, MYSQL_OPT_GUESS_CONNECTION=16, MYSQL_SET_CLIENT_IP=17, MYSQL_SECURE_AUTH=18, MYSQL_REPORT_DATA_TRUNCATION=19, MYSQL_OPT_RECONNECT=20, MYSQL_OPT_SSL_VERIFY_SERVER_CERT=21, MYSQL_PLUGIN_DIR=22, MYSQL_DEFAULT_AUTH=23, MYSQL_OPT_BIND=24, MYSQL_OPT_SSL_KEY=25, MYSQL_OPT_SSL_CERT=26, MYSQL_OPT_SSL_CA=27, MYSQL_OPT_SSL_CAPATH=28, MYSQL_OPT_SSL_CIPHER=29, MYSQL_OPT_SSL_CRL=30, MYSQL_OPT_SSL_CRLPATH=31, MYSQL_OPT_CONNECT_ATTR_RESET=32, MYSQL_OPT_CONNECT_ATTR_ADD=33, MYSQL_OPT_CONNECT_ATTR_DELETE=34, MYSQL_SERVER_PUBLIC_KEY=35, MYSQL_ENABLE_CLEARTEXT_PLUGIN=36, MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS=37 };

// tag-mysql_status
// file /usr/include/mysql/mysql.h line 236
enum mysql_status { MYSQL_STATUS_READY=0, MYSQL_STATUS_GET_RESULT=1, MYSQL_STATUS_USE_RESULT=2, MYSQL_STATUS_STATEMENT_GET_RESULT=3 };

// tag-netsnmp_container_s
// file /usr/include/net-snmp/types.h line 284
struct netsnmp_container_s;

// tag-netsnmp_iterator_s
// file /usr/include/net-snmp/library/container.h line 42
struct netsnmp_iterator_s;

// tag-netsnmp_void_array_s
// file /usr/include/net-snmp/library/types.h line 17
struct netsnmp_void_array_s;

// tag-php_processes
// file spine.h line 419
struct php_processes;

// tag-pid
// file nft_popen.c line 68
struct pid;

// tag-ping_results
// file spine.h line 487
struct ping_results;

// tag-poller_thread
// file spine.h line 405
struct poller_thread;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-snmp_oids
// file spine.h line 394
struct snmp_oids;

// tag-snmp_pdu
// file /usr/include/net-snmp/types.h line 168
struct snmp_pdu;

// tag-snmp_session
// file /usr/include/net-snmp/types.h line 273
struct snmp_session;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-st_dynamic_array
// file /usr/include/mysql/mysql.h line 192
struct st_dynamic_array;

// tag-st_list
// file /usr/include/mysql/my_list.h line 23
struct st_list;

// tag-st_mem_root
// file /usr/include/mysql/my_alloc.h line 38
struct st_mem_root;

// tag-st_mysql
// file /usr/include/mysql/mysql.h line 263
struct st_mysql;

// tag-st_mysql_data
// file /usr/include/mysql/mysql.h line 149
struct st_mysql_data;

// tag-st_mysql_field
// file /usr/include/mysql/mysql.h line 94
struct st_mysql_field;

// tag-st_mysql_methods
// file /usr/include/mysql/mysql.h line 260
struct st_mysql_methods;

// tag-st_mysql_options
// file /usr/include/mysql/mysql.h line 187
struct st_mysql_options;

// tag-st_mysql_options_extention
// file /usr/include/mysql/mysql.h line 185
struct st_mysql_options_extention;

// tag-st_mysql_res
// file /usr/include/mysql/mysql.h line 308
struct st_mysql_res;

// tag-st_mysql_rows
// file /usr/include/mysql/mysql.h line 138
struct st_mysql_rows;

// tag-st_net
// file /usr/include/mysql/mysql_com.h line 316
struct st_net;

// tag-st_used_mem
// file /usr/include/mysql/my_alloc.h line 30
struct st_used_mem;

// tag-st_vio
// file /usr/include/mysql/mysql_com.h line 305
struct st_vio;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-target_struct
// file spine.h line 359
struct target_struct;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-variable_list
// file /usr/include/net-snmp/types.h line 138
struct variable_list;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous$2 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous$2 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous$2 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// add_slashes
// file util.c line 918
extern char * add_slashes(char *string);
// all_digits
// file util.h line 53
extern signed int all_digits(const char *string);
// append_hostrange
// file sql.c line 289
extern signed int append_hostrange(char *obuf, const char *colname);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// char_count
// file util.c line 1117
extern signed int char_count(const char *str, signed int chr);
// checkAsRoot
// file util.h line 84
extern void checkAsRoot();
// child
// file poller.h line 34
extern void * child(void *arg);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_cleanup
// file nft_popen.c line 349
static void close_cleanup(void *arg);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// config_defaults
// file util.h line 37
extern void config_defaults(void);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// db_connect
// file sql.c line 173
extern void db_connect(const char *database, struct st_mysql *mysql);
// db_disconnect
// file sql.c line 269
extern void db_disconnect(struct st_mysql *mysql);
// db_escape
// file sql.c line 312
extern void db_escape(struct st_mysql *mysql, char *output, const char *input);
// db_insert
// file sql.c line 48
extern signed int db_insert(struct st_mysql *mysql, const char *query);
// db_query
// file sql.c line 109
extern struct st_mysql_res * db_query(struct st_mysql *mysql, const char *query);
// die
// file util.h line 43
extern void die(const char *format, ...);
// display_help
// file spine.c line 842
static void display_help(void);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// exec_poll
// file poller.c line 1350
extern char * exec_poll(struct host_struct *current_host, char *command);
// execv
// file /usr/include/unistd.h line 563
extern signed int execv(const char *, char * const *);
// execve
// file /usr/include/unistd.h line 551
extern signed int execve(const char *, char * const *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// file_exists
// file util.c line 733
extern signed int file_exists(const char *filename);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// find_keyword_by_value
// file keywords.c line 156
static const char * find_keyword_by_value(struct keyword *tbl, signed int value, const char *dflt);
// find_keyword_by_word
// file keywords.c line 122
static signed int find_keyword_by_word(struct keyword *tbl, const char *word, signed int dflt);
// floor
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 184
extern double floor(double);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// generate_Ku
// file /usr/include/net-snmp/library/keytools.h line 28
extern signed int generate_Ku(const unsigned long int *, unsigned int, const unsigned char *, unsigned long int, unsigned char *, unsigned long int *);
// get_attr
// file locks.c line 115
extern signed int * get_attr(signed int locko);
// get_checksum
// file ping.c line 951
extern unsigned short int get_checksum(void *buf, signed int len);
// get_host_poll_time
// file util.h line 77
extern char * get_host_poll_time(void);
// get_lock
// file locks.c line 89
extern union anonymous$9 * get_lock(signed int lock);
// get_time_as_double
// file util.h line 74
extern double get_time_as_double(void);
// getarg
// file spine.c line 904
static char * getarg(char *opt, char ***pargv);
// getboolsetting
// file util.c line 118
static signed int getboolsetting(struct st_mysql *psql, const char *setting, signed int dflt);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getglobalvariable
// file util.c line 157
static const char * getglobalvariable(struct st_mysql *psql, const char *setting);
// gethostbyname_r
// file /usr/include/netdb.h line 179
extern signed int gethostbyname_r(const char *, struct hostent *, char *, unsigned long int, struct hostent ** restrict , signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getsetting
// file util.c line 79
static const char * getsetting(struct st_mysql *psql, const char *setting);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// hasCaps
// file util.c line 1218
extern signed int hasCaps();
// hex2dec
// file util.c line 1132
unsigned long long int hex2dec(char *str);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// init_ghbn_lock
// file locks.c line 54
static void init_ghbn_lock(void);
// init_mutexes
// file locks.h line 34
extern void init_mutexes(void);
// init_php_lock
// file locks.c line 57
static void init_php_lock(void);
// init_php_proc_0_lock
// file locks.c line 58
static void init_php_proc_0_lock(void);
// init_php_proc_1_lock
// file locks.c line 59
static void init_php_proc_1_lock(void);
// init_php_proc_2_lock
// file locks.c line 60
static void init_php_proc_2_lock(void);
// init_php_proc_3_lock
// file locks.c line 61
static void init_php_proc_3_lock(void);
// init_php_proc_4_lock
// file locks.c line 62
static void init_php_proc_4_lock(void);
// init_php_proc_5_lock
// file locks.c line 63
static void init_php_proc_5_lock(void);
// init_php_proc_6_lock
// file locks.c line 64
static void init_php_proc_6_lock(void);
// init_php_proc_7_lock
// file locks.c line 65
static void init_php_proc_7_lock(void);
// init_php_proc_8_lock
// file locks.c line 66
static void init_php_proc_8_lock(void);
// init_php_proc_9_lock
// file locks.c line 67
static void init_php_proc_9_lock(void);
// init_pipe_lock
// file locks.c line 55
static void init_pipe_lock(void);
// init_seteuid_lock
// file locks.c line 53
static void init_seteuid_lock(void);
// init_snmp
// file /usr/include/net-snmp/library/snmp_api.h line 366
extern void init_snmp(const char *);
// init_snmp_lock
// file locks.c line 51
static void init_snmp_lock(void);
// init_sockaddr
// file ping.c line 779
extern signed int init_sockaddr(struct sockaddr_in *name, const char *hostname, unsigned short int port);
// init_syslog_lock
// file locks.c line 56
static void init_syslog_lock(void);
// init_thread_lock
// file locks.c line 52
static void init_thread_lock(void);
// install_spine_signal_handler
// file error.h line 34
extern void install_spine_signal_handler(void);
// install_spine_signal_handler::1::ohandler$object
//
void ohandler$object(signed int);
// is_hexadecimal
// file util.c line 858
extern signed int is_hexadecimal(const char *str, const signed short int ignore_space);
// is_ipaddress
// file util.c line 774
extern signed int is_ipaddress(const char *string);
// is_multipart_output
// file poller.c line 1277
extern signed int is_multipart_output(char *result);
// is_numeric
// file util.c line 797
extern signed int is_numeric(const char *string);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// ltrim
// file util.c line 1077
extern char * ltrim(char *str);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mysql_close
// file /usr/include/mysql/mysql.h line 718
void mysql_close(struct st_mysql *);
// mysql_errno
// file /usr/include/mysql/mysql.h line 392
unsigned int mysql_errno(struct st_mysql *);
// mysql_error
// file /usr/include/mysql/mysql.h line 393
const char * mysql_error(struct st_mysql *);
// mysql_fetch_row
// file /usr/include/mysql/mysql.h line 477
char ** mysql_fetch_row(struct st_mysql_res *);
// mysql_free_result
// file /usr/include/mysql/mysql.h line 470
void mysql_free_result(struct st_mysql_res *);
// mysql_init
// file /usr/include/mysql/mysql.h line 401
struct st_mysql * mysql_init(struct st_mysql *);
// mysql_num_rows
// file /usr/include/mysql/mysql.h line 380
unsigned long long int mysql_num_rows(struct st_mysql_res *);
// mysql_options
// file /usr/include/mysql/mysql.h line 466
signed int mysql_options(struct st_mysql *, enum mysql_option, const void *);
// mysql_query
// file /usr/include/mysql/mysql.h line 416
signed int mysql_query(struct st_mysql *, const char *);
// mysql_real_connect
// file /usr/include/mysql/mysql.h line 408
struct st_mysql * mysql_real_connect(struct st_mysql *, const char *, const char *, const char *, const char *, unsigned int, const char *, unsigned long int);
// mysql_real_escape_string
// file /usr/include/mysql/mysql.h line 486
unsigned long int mysql_real_escape_string(struct st_mysql *, char *, const char *, unsigned long int);
// mysql_store_result
// file /usr/include/mysql/mysql.h line 421
struct st_mysql_res * mysql_store_result(struct st_mysql *);
// mysql_thread_end
// file /usr/include/mysql/mysql.h line 373
void mysql_thread_end(void);
// mysql_thread_safe
// file /usr/include/mysql/mysql.h line 491
unsigned int mysql_thread_safe(void);
// netsnmp_ds_set_boolean
// file /usr/include/net-snmp/library/default_store.h line 179
extern signed int netsnmp_ds_set_boolean(signed int, signed int, signed int);
// nft_pchild
// file nft_popen.h line 57
extern signed int nft_pchild(signed int fd);
// nft_pclose
// file nft_popen.h line 70
extern signed int nft_pclose(signed int fd);
// nft_pclose::1::3::__cancel_routine$object
//
void __cancel_routine$object(void *);
// nft_popen
// file nft_popen.h line 45
extern signed int nft_popen(const char *command, const char *type);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// parse_action
// file keywords.c line 188
extern signed int parse_action(const char *word, signed int dflt);
// parse_log_level
// file keywords.c line 172
extern signed int parse_log_level(const char *word, signed int dflt);
// parse_logdest
// file keywords.h line 38
extern signed int parse_logdest(const char *word, signed int dflt);
// php_close
// file php.h line 37
extern void php_close(signed int php_process);
// php_cmd
// file php.h line 34
extern char * php_cmd(const char *php_command, signed int php_process);
// php_get_process
// file php.h line 38
extern signed int php_get_process(void);
// php_init
// file php.h line 36
extern signed int php_init(signed int php_process);
// php_readpipe
// file php.c line 151
extern char * php_readpipe(signed int php_process);
// ping_host
// file ping.h line 137
extern signed int ping_host(struct host_struct *host, struct ping_results *ping);
// ping_icmp
// file ping.c line 235
extern signed int ping_icmp(struct host_struct *host, struct ping_results *ping);
// ping_snmp
// file ping.c line 156
extern signed int ping_snmp(struct host_struct *host, struct ping_results *ping);
// ping_tcp
// file ping.c line 670
extern signed int ping_tcp(struct host_struct *host, struct ping_results *ping);
// ping_udp
// file ping.c line 512
extern signed int ping_udp(struct host_struct *host, struct ping_results *ping);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// poll_host
// file poller.c line 109
extern void poll_host(signed int host_id, signed int host_thread, signed int last_host_thread, signed int host_data_ids, char *host_time);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// printable_action
// file keywords.c line 184
extern const char * printable_action(signed int token);
// printable_log_level
// file keywords.c line 168
extern const char * printable_log_level(signed int token);
// printable_logdest
// file keywords.h line 37
extern const char * printable_logdest(signed int token);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$9 *, const union anonymous$10 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$9 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous$9 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$9 *);
// pthread_once
// file /usr/include/pthread.h line 496
extern signed int pthread_once(signed int *, void (*)(void));
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_config_options
// file util.h line 35
extern void read_config_options(void);
// read_spine_config
// file util.h line 36
extern signed int read_spine_config(char *file);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, struct sockaddr *, unsigned int *);
// remove_tcp_udp_from_hostname
// file ping.c line 925
extern char * remove_tcp_udp_from_hostname(char *hostname);
// reverse
// file util.c line 1096
extern char * reverse(char *str);
// rint
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 279
extern double rint(double);
// rtrim
// file util.c line 1054
extern char * rtrim(char *str);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$8 *, struct anonymous$8 *, struct anonymous$8 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, struct sockaddr *, unsigned int);
// set_option
// file util.h line 48
extern void set_option(const char *option, const char *value);
// seteuid
// file /usr/include/unistd.h line 710
extern signed int seteuid(unsigned int);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snmp_add_null_var
// file /usr/include/net-snmp/varbind_api.h line 29
extern struct variable_list * snmp_add_null_var(struct snmp_pdu *, const unsigned long int *, unsigned long int);
// snmp_api_errstring
// file /usr/include/net-snmp/output_api.h line 25
extern const char * snmp_api_errstring(signed int);
// snmp_count
// file snmp.c line 485
extern signed int snmp_count(struct host_struct *current_host, char *snmp_oid);
// snmp_duplicate_objid
// file /usr/include/net-snmp/library/snmp_api.h line 401
extern unsigned long int * snmp_duplicate_objid(const unsigned long int *, unsigned long int);
// snmp_fix_pdu
// file /usr/include/net-snmp/pdu_api.h line 19
extern struct snmp_pdu * snmp_fix_pdu(struct snmp_pdu *, signed int);
// snmp_free_pdu
// file /usr/include/net-snmp/pdu_api.h line 21
extern void snmp_free_pdu(struct snmp_pdu *);
// snmp_get
// file snmp.c line 313
extern char * snmp_get(struct host_struct *current_host, char *snmp_oid);
// snmp_get_multi
// file snmp.c line 618
extern void snmp_get_multi(struct host_struct *current_host, struct snmp_oids *snmp_oids, signed int num_oids);
// snmp_getnext
// file snmp.c line 397
extern char * snmp_getnext(struct host_struct *current_host, char *snmp_oid);
// snmp_host_cleanup
// file snmp.c line 297
extern void snmp_host_cleanup(void *snmp_session);
// snmp_host_init
// file snmp.c line 122
extern void * snmp_host_init(signed int host_id, char *hostname, signed int snmp_version, char *snmp_community, char *snmp_username, char *snmp_password, char *snmp_auth_protocol, char *snmp_priv_passphrase, char *snmp_priv_protocol, char *snmp_context, signed int snmp_port, signed int snmp_timeout);
// snmp_oid_compare
// file /usr/include/net-snmp/library/snmp_api.h line 340
extern signed int snmp_oid_compare(const unsigned long int *, unsigned long int, const unsigned long int *, unsigned long int);
// snmp_parse_oid
// file /usr/include/net-snmp/mib_api.h line 59
extern unsigned long int * snmp_parse_oid(const char *, unsigned long int *, unsigned long int *);
// snmp_pdu_create
// file /usr/include/net-snmp/pdu_api.h line 15
extern struct snmp_pdu * snmp_pdu_create(signed int);
// snmp_sess_close
// file /usr/include/net-snmp/session_api.h line 253
extern signed int snmp_sess_close(void *);
// snmp_sess_init
// file /usr/include/net-snmp/session_api.h line 16
extern void snmp_sess_init(struct snmp_session *);
// snmp_sess_open
// file /usr/include/net-snmp/session_api.h line 213
extern void * snmp_sess_open(struct snmp_session *);
// snmp_sess_synch_response
// file /usr/include/net-snmp/session_api.h line 256
extern signed int snmp_sess_synch_response(void *, struct snmp_pdu *, struct snmp_pdu **);
// snmp_shutdown
// file /usr/include/net-snmp/library/snmp_api.h line 396
extern void snmp_shutdown(const char *);
// snmp_snprint_value
// file snmp.c line 592
extern void snmp_snprint_value(char *obuf, unsigned long int buf_len, const unsigned long int *objid, unsigned long int objidlen, struct variable_list *variable);
// snmp_spine_close
// file snmp.c line 108
void snmp_spine_close(void);
// snmp_spine_init
// file snmp.h line 34
extern void snmp_spine_init(void);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// spine_log
// file util.h line 40
extern signed int spine_log(const char *format, ...);
// spine_signal_handler
// file error.c line 46
static void spine_signal_handler(signed int spine_signal);
// sprint_realloc_by_type
// file /usr/include/net-snmp/library/mib.h line 203
extern signed int sprint_realloc_by_type(unsigned char **, unsigned long int *, unsigned long int *, signed int, const struct variable_list *, struct enum_list *, const char *, const char *);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strip_alpha
// file util.c line 894
extern char * strip_alpha(char *string);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncopy
// file util.c line 972
extern char * strncopy(char *dst, const char *src, unsigned long int obuf);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoll
// file /usr/include/stdlib.h line 209
extern signed long long int strtoll(const char *, char ** restrict , signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// thread_mutex_lock
// file locks.h line 35
extern void thread_mutex_lock(signed int mutex);
// thread_mutex_trylock
// file locks.h line 37
extern signed int thread_mutex_trylock(signed int mutex);
// thread_mutex_unlock
// file locks.h line 36
extern void thread_mutex_unlock(signed int mutex);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// trim
// file util.c line 1044
extern char * trim(char *str);
// uninstall_spine_signal_handler
// file error.h line 35
extern void uninstall_spine_signal_handler(void);
// uninstall_spine_signal_handler::1::ohandler$object
//
void ohandler$object(signed int);
// update_host_status
// file ping.h line 143
extern void update_host_status(signed int status, struct host_struct *host, struct ping_results *ping, signed int availability_method);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// validate_result
// file poller.c line 1322
extern signed int validate_result(char *result);
// vfork
// file /usr/include/unistd.h line 764
extern signed int vfork(void);
// vsprintf
// file /usr/include/stdio.h line 379
extern signed int vsprintf(char *, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$20
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$17
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$0
{
  // opt
  const char *opt;
  // val
  const char *val;
};

struct anonymous$8
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$12
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$1
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous$2
{
  // __cancel_jmp_buf
  struct anonymous$1 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous$13
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$16
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$15
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$14
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$18
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$21
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$13 _kill;
  // _timer
  struct anonymous$14 _timer;
  // _rt
  struct anonymous$15 _rt;
  // _sigchld
  struct anonymous$16 _sigchld;
  // _sigfault
  struct anonymous$17 _sigfault;
  // _sigpoll
  struct anonymous$18 _sigpoll;
  // _sigsys
  struct anonymous$20 _sigsys;
};

struct anonymous$19
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$21 _sifields;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct ip
{
  // ip_hl
  unsigned int ip_hl : 4;
  // ip_v
  unsigned int ip_v : 4;
  // ip_tos
  unsigned char ip_tos;
  // ip_len
  unsigned short int ip_len;
  // ip_id
  unsigned short int ip_id;
  // ip_off
  unsigned short int ip_off;
  // ip_ttl
  unsigned char ip_ttl;
  // ip_p
  unsigned char ip_p;
  // ip_sum
  unsigned short int ip_sum;
  // ip_src
  struct in_addr ip_src;
  // ip_dst
  struct in_addr ip_dst;
};

struct anonymous$6
{
  // idi_ip
  struct ip idi_ip;
};

struct anonymous$5
{
  // its_otime
  unsigned int its_otime;
  // its_rtime
  unsigned int its_rtime;
  // its_ttime
  unsigned int its_ttime;
};

union anonymous$3
{
  // integer
  signed long int *integer;
  // string
  unsigned char *string;
  // objid
  unsigned long int *objid;
  // bitstring
  unsigned char *bitstring;
  // counter64
  struct counter64 *counter64;
  // floatVal
  float *floatVal;
  // doubleVal
  double *doubleVal;
};

union anonymous
{
  // client_ip
  char *client_ip;
  // bind_address
  char *bind_address;
};

union anonymous$11
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$19 *, void *);
};

union anonymous$10
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct icmp_ra_addr
{
  // ira_addr
  unsigned int ira_addr;
  // ira_preference
  unsigned int ira_preference;
};

union anonymous$7
{
  // id_ts
  struct anonymous$5 id_ts;
  // id_ip
  struct anonymous$6 id_ip;
  // id_radv
  struct icmp_ra_addr id_radv;
  // id_mask
  unsigned int id_mask;
  // id_data
  unsigned char id_data[1l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$9
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ih_idseq
{
  // icd_id
  unsigned short int icd_id;
  // icd_seq
  unsigned short int icd_seq;
};

struct ih_pmtu
{
  // ipm_void
  unsigned short int ipm_void;
  // ipm_nextmtu
  unsigned short int ipm_nextmtu;
};

struct ih_rtradv
{
  // irt_num_addrs
  unsigned char irt_num_addrs;
  // irt_wpa
  unsigned char irt_wpa;
  // irt_lifetime
  unsigned short int irt_lifetime;
};

union anonymous$4
{
  // ih_pptr
  unsigned char ih_pptr;
  // ih_gwaddr
  struct in_addr ih_gwaddr;
  // ih_idseq
  struct ih_idseq ih_idseq;
  // ih_void
  unsigned int ih_void;
  // ih_pmtu
  struct ih_pmtu ih_pmtu;
  // ih_rtradv
  struct ih_rtradv ih_rtradv;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct config_struct
{
  // stdout_notty
  signed int stdout_notty;
  // stderr_notty
  signed int stderr_notty;
  // poller_id
  signed int poller_id;
  // poller_id_exists
  signed int poller_id_exists;
  // device_threads_exists
  signed int device_threads_exists;
  // poller_interval
  signed int poller_interval;
  // parent_fork
  signed int parent_fork;
  // num_parent_processes
  signed int num_parent_processes;
  // script_timeout
  signed int script_timeout;
  // threads
  signed int threads;
  // logfile_processed
  signed int logfile_processed;
  // boost_redirect
  signed int boost_redirect;
  // cygwinshloc
  signed int cygwinshloc;
  // snmponly
  signed int snmponly;
  // SQL_readonly
  signed int SQL_readonly;
  // start_host_id
  signed int start_host_id;
  // end_host_id
  signed int end_host_id;
  // host_id_list
  char host_id_list[65535l];
  // dbhost
  char dbhost[256l];
  // dbdb
  char dbdb[256l];
  // dbuser
  char dbuser[256l];
  // dbpass
  char dbpass[256l];
  // dbport
  unsigned int dbport;
  // pre087g
  unsigned int pre087g;
  // dbversion
  signed int dbversion;
  // path_logfile
  char path_logfile[256l];
  // path_php
  char path_php[256l];
  // path_php_server
  char path_php_server[256l];
  // log_level
  signed int log_level;
  // log_destination
  signed int log_destination;
  // log_perror
  signed int log_perror;
  // log_pwarn
  signed int log_pwarn;
  // log_pstats
  signed int log_pstats;
  // icmp_avail
  signed int icmp_avail;
  // availability_method
  signed int availability_method;
  // ping_method
  signed int ping_method;
  // ping_retries
  signed int ping_retries;
  // ping_timeout
  signed int ping_timeout;
  // ping_failure_count
  signed int ping_failure_count;
  // ping_recovery_count
  signed int ping_recovery_count;
  // snmp_max_get_size
  signed int snmp_max_get_size;
  // snmp_retries
  signed int snmp_retries;
  // snmp_clientaddr
  char snmp_clientaddr[256l];
  // php_required
  signed int php_required;
  // php_initialized
  signed int php_initialized;
  // php_servers
  signed int php_servers;
  // php_current_server
  signed int php_current_server;
  // exit_code
  signed int exit_code;
};

struct counter64
{
  // high
  unsigned long int high;
  // low
  unsigned long int low;
};

struct enum_list
{
  // next
  struct enum_list *next;
  // value
  signed int value;
  // label
  char *label;
};

struct host_reindex_struct
{
  // op
  char op[4l];
  // assert_value
  char assert_value[100l];
  // arg1
  char arg1[512l];
  // data_query_id
  signed int data_query_id;
  // action
  signed int action;
};

struct host_struct
{
  // id
  signed int id;
  // hostname
  char hostname[250l];
  // snmp_community
  char snmp_community[100l];
  // snmp_version
  signed int snmp_version;
  // snmp_username
  char snmp_username[50l];
  // snmp_password
  char snmp_password[50l];
  // snmp_auth_protocol
  char snmp_auth_protocol[5l];
  // snmp_priv_passphrase
  char snmp_priv_passphrase[200l];
  // snmp_priv_protocol
  char snmp_priv_protocol[7l];
  // snmp_context
  char snmp_context[65l];
  // snmp_port
  signed int snmp_port;
  // snmp_timeout
  signed int snmp_timeout;
  // snmp_retries
  signed int snmp_retries;
  // max_oids
  signed int max_oids;
  // availability_method
  signed int availability_method;
  // ping_method
  signed int ping_method;
  // ping_port
  signed int ping_port;
  // ping_timeout
  signed int ping_timeout;
  // ping_retries
  signed int ping_retries;
  // status
  signed int status;
  // status_event_count
  signed int status_event_count;
  // status_fail_date
  char status_fail_date[40l];
  // status_rec_date
  char status_rec_date[40l];
  // status_last_error
  char status_last_error[256l];
  // min_time
  double min_time;
  // max_time
  double max_time;
  // cur_time
  double cur_time;
  // avg_time
  double avg_time;
  // total_polls
  signed int total_polls;
  // failed_polls
  signed int failed_polls;
  // availability
  double availability;
  // ignore_host
  signed int ignore_host;
  // snmp_session
  void *snmp_session;
  // snmp_status
  signed int snmp_status;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct icmp
{
  // icmp_type
  unsigned char icmp_type;
  // icmp_code
  unsigned char icmp_code;
  // icmp_cksum
  unsigned short int icmp_cksum;
  // icmp_hun
  union anonymous$4 icmp_hun;
  // icmp_dun
  union anonymous$7 icmp_dun;
};

struct keyword
{
  // word
  const char *word;
  // value
  signed int value;
};

struct netsnmp_container_s
{
  // container_data
  void *container_data;
  // get_size
  unsigned long int (*get_size)(struct netsnmp_container_s *);
  // init
  signed int (*init)(struct netsnmp_container_s *);
  // cfree
  signed int (*cfree)(struct netsnmp_container_s *);
  // insert
  signed int (*insert)(struct netsnmp_container_s *, const void *);
  // remove
  signed int (*remove)(struct netsnmp_container_s *, const void *);
  // release
  signed int (*release)(struct netsnmp_container_s *, const void *);
  // free_item
  void (*free_item)(void *, void *);
  // find
  void * (*find)(struct netsnmp_container_s *, const void *);
  // find_next
  void * (*find_next)(struct netsnmp_container_s *, const void *);
  // get_subset
  struct netsnmp_void_array_s * (*get_subset)(struct netsnmp_container_s *, void *);
  // get_iterator
  struct netsnmp_iterator_s * (*get_iterator)(struct netsnmp_container_s *);
  // for_each
  void (*for_each)(struct netsnmp_container_s *, void (*)(void *, void *), void *);
  // clear
  void (*clear)(struct netsnmp_container_s *, void (*)(void *, void *), void *);
  // insert_filter
  signed int (*insert_filter)(struct netsnmp_container_s *, const void *);
  // duplicate
  struct netsnmp_container_s * (*duplicate)(struct netsnmp_container_s *, void *, unsigned int);
  // compare
  signed int (*compare)(const void *, const void *);
  // ncompare
  signed int (*ncompare)(const void *, const void *);
  // options
  signed int (*options)(struct netsnmp_container_s *, signed int, unsigned int);
  // container_name
  char *container_name;
  // sync
  unsigned long int sync;
  // flags
  unsigned int flags;
  // next
  struct netsnmp_container_s *next;
  // prev
  struct netsnmp_container_s *prev;
};

struct netsnmp_iterator_s
{
  // container
  struct netsnmp_container_s *container;
  // sync
  unsigned long int sync;
  // reset
  signed int (*reset)(struct netsnmp_iterator_s *);
  // release
  signed int (*release)(struct netsnmp_iterator_s *);
  // first
  void * (*first)(struct netsnmp_iterator_s *);
  // curr
  void * (*curr)(struct netsnmp_iterator_s *);
  // last
  void * (*last)(struct netsnmp_iterator_s *);
  // next
  void * (*next)(struct netsnmp_iterator_s *);
  // remove
  signed int (*remove)(struct netsnmp_iterator_s *);
};

struct netsnmp_void_array_s
{
  // size
  unsigned long int size;
  // array
  void **array;
};

struct php_processes
{
  // php_state
  signed int php_state;
  // php_pid
  signed int php_pid;
  // php_write_fd
  signed int php_write_fd;
  // php_read_fd
  signed int php_read_fd;
};

struct pid
{
  // next
  struct pid *next;
  // fd
  signed int fd;
  // pid
  signed int pid;
};

struct ping_results
{
  // hostname
  char hostname[256l];
  // ping_status
  char ping_status[50l];
  // ping_response
  char ping_response[256l];
  // snmp_status
  char snmp_status[50l];
  // snmp_response
  char snmp_response[256l];
};

struct poller_thread
{
  // host_id
  signed int host_id;
  // host_thread
  signed int host_thread;
  // last_host_thread
  signed int last_host_thread;
  // host_data_ids
  signed int host_data_ids;
  // host_time
  char *host_time;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$11 __sigaction_handler;
  // sa_mask
  struct anonymous$12 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct snmp_oids
{
  // array_position
  signed int array_position;
  // oid
  char oid[512l];
  // result
  char result[1024l];
};

struct snmp_pdu
{
  // version
  signed long int version;
  // command
  signed int command;
  // reqid
  signed long int reqid;
  // msgid
  signed long int msgid;
  // transid
  signed long int transid;
  // sessid
  signed long int sessid;
  // errstat
  signed long int errstat;
  // errindex
  signed long int errindex;
  // time
  unsigned long int time;
  // flags
  unsigned long int flags;
  // securityModel
  signed int securityModel;
  // securityLevel
  signed int securityLevel;
  // msgParseModel
  signed int msgParseModel;
  // transport_data
  void *transport_data;
  // transport_data_length
  signed int transport_data_length;
  // tDomain
  const unsigned long int *tDomain;
  // tDomainLen
  unsigned long int tDomainLen;
  // variables
  struct variable_list *variables;
  // community
  unsigned char *community;
  // community_len
  unsigned long int community_len;
  // enterprise
  unsigned long int *enterprise;
  // enterprise_length
  unsigned long int enterprise_length;
  // trap_type
  signed long int trap_type;
  // specific_type
  signed long int specific_type;
  // agent_addr
  unsigned char agent_addr[4l];
  // contextEngineID
  unsigned char *contextEngineID;
  // contextEngineIDLen
  unsigned long int contextEngineIDLen;
  // contextName
  char *contextName;
  // contextNameLen
  unsigned long int contextNameLen;
  // securityEngineID
  unsigned char *securityEngineID;
  // securityEngineIDLen
  unsigned long int securityEngineIDLen;
  // securityName
  char *securityName;
  // securityNameLen
  unsigned long int securityNameLen;
  // priority
  signed int priority;
  // range_subid
  signed int range_subid;
  // securityStateRef
  void *securityStateRef;
};

struct snmp_session
{
  // version
  signed long int version;
  // retries
  signed int retries;
  // timeout
  signed long int timeout;
  // flags
  unsigned long int flags;
  // subsession
  struct snmp_session *subsession;
  // next
  struct snmp_session *next;
  // peername
  char *peername;
  // remote_port
  unsigned short int remote_port;
  // localname
  char *localname;
  // local_port
  unsigned short int local_port;
  // authenticator
  unsigned char * (*authenticator)(unsigned char *, unsigned long int *, unsigned char *, unsigned long int);
  // callback
  signed int (*callback)(signed int, struct snmp_session *, signed int, struct snmp_pdu *, void *);
  // callback_magic
  void *callback_magic;
  // s_errno
  signed int s_errno;
  // s_snmp_errno
  signed int s_snmp_errno;
  // sessid
  signed long int sessid;
  // community
  unsigned char *community;
  // community_len
  unsigned long int community_len;
  // rcvMsgMaxSize
  unsigned long int rcvMsgMaxSize;
  // sndMsgMaxSize
  unsigned long int sndMsgMaxSize;
  // isAuthoritative
  unsigned char isAuthoritative;
  // contextEngineID
  unsigned char *contextEngineID;
  // contextEngineIDLen
  unsigned long int contextEngineIDLen;
  // engineBoots
  unsigned int engineBoots;
  // engineTime
  unsigned int engineTime;
  // contextName
  char *contextName;
  // contextNameLen
  unsigned long int contextNameLen;
  // securityEngineID
  unsigned char *securityEngineID;
  // securityEngineIDLen
  unsigned long int securityEngineIDLen;
  // securityName
  char *securityName;
  // securityNameLen
  unsigned long int securityNameLen;
  // securityAuthProto
  unsigned long int *securityAuthProto;
  // securityAuthProtoLen
  unsigned long int securityAuthProtoLen;
  // securityAuthKey
  unsigned char securityAuthKey[32l];
  // securityAuthKeyLen
  unsigned long int securityAuthKeyLen;
  // securityAuthLocalKey
  unsigned char *securityAuthLocalKey;
  // securityAuthLocalKeyLen
  unsigned long int securityAuthLocalKeyLen;
  // securityPrivProto
  unsigned long int *securityPrivProto;
  // securityPrivProtoLen
  unsigned long int securityPrivProtoLen;
  // securityPrivKey
  unsigned char securityPrivKey[32l];
  // securityPrivKeyLen
  unsigned long int securityPrivKeyLen;
  // securityPrivLocalKey
  unsigned char *securityPrivLocalKey;
  // securityPrivLocalKeyLen
  unsigned long int securityPrivLocalKeyLen;
  // securityModel
  signed int securityModel;
  // securityLevel
  signed int securityLevel;
  // paramName
  char *paramName;
  // securityInfo
  void *securityInfo;
  // transport_configuration
  struct netsnmp_container_s *transport_configuration;
  // myvoid
  void *myvoid;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct st_list
{
  // prev
  struct st_list *prev;
  // next
  struct st_list *next;
  // data
  void *data;
};

struct st_mem_root
{
  // free
  struct st_used_mem *free;
  // used
  struct st_used_mem *used;
  // pre_alloc
  struct st_used_mem *pre_alloc;
  // min_malloc
  unsigned long int min_malloc;
  // block_size
  unsigned long int block_size;
  // block_num
  unsigned int block_num;
  // first_block_usage
  unsigned int first_block_usage;
  // error_handler
  void (*error_handler)(void);
};

struct st_net
{
  // vio
  struct st_vio *vio;
  // buff
  unsigned char *buff;
  // buff_end
  unsigned char *buff_end;
  // write_pos
  unsigned char *write_pos;
  // read_pos
  unsigned char *read_pos;
  // fd
  signed int fd;
  // remain_in_buf
  unsigned long int remain_in_buf;
  // length
  unsigned long int length;
  // buf_length
  unsigned long int buf_length;
  // where_b
  unsigned long int where_b;
  // max_packet
  unsigned long int max_packet;
  // max_packet_size
  unsigned long int max_packet_size;
  // pkt_nr
  unsigned int pkt_nr;
  // compress_pkt_nr
  unsigned int compress_pkt_nr;
  // write_timeout
  unsigned int write_timeout;
  // read_timeout
  unsigned int read_timeout;
  // retry_count
  unsigned int retry_count;
  // fcntl
  signed int fcntl;
  // return_status
  unsigned int *return_status;
  // reading_or_writing
  unsigned char reading_or_writing;
  // save_char
  char save_char;
  // unused1
  char unused1;
  // unused2
  char unused2;
  // compress
  char compress;
  // unused3
  char unused3;
  // unused
  unsigned char *unused;
  // last_errno
  unsigned int last_errno;
  // error
  unsigned char error;
  // unused4
  char unused4;
  // unused5
  char unused5;
  // last_error
  char last_error[512l];
  // sqlstate
  char sqlstate[6l];
  // extension
  void *extension;
};

struct st_mysql_options
{
  // connect_timeout
  unsigned int connect_timeout;
  // read_timeout
  unsigned int read_timeout;
  // write_timeout
  unsigned int write_timeout;
  // port
  unsigned int port;
  // protocol
  unsigned int protocol;
  // client_flag
  unsigned long int client_flag;
  // host
  char *host;
  // user
  char *user;
  // password
  char *password;
  // unix_socket
  char *unix_socket;
  // db
  char *db;
  // init_commands
  struct st_dynamic_array *init_commands;
  // my_cnf_file
  char *my_cnf_file;
  // my_cnf_group
  char *my_cnf_group;
  // charset_dir
  char *charset_dir;
  // charset_name
  char *charset_name;
  // ssl_key
  char *ssl_key;
  // ssl_cert
  char *ssl_cert;
  // ssl_ca
  char *ssl_ca;
  // ssl_capath
  char *ssl_capath;
  // ssl_cipher
  char *ssl_cipher;
  // shared_memory_base_name
  char *shared_memory_base_name;
  // max_allowed_packet
  unsigned long int max_allowed_packet;
  // use_ssl
  char use_ssl;
  // compress
  char compress;
  // named_pipe
  char named_pipe;
  // unused1
  char unused1;
  // unused2
  char unused2;
  // unused3
  char unused3;
  // unused4
  char unused4;
  // methods_to_use
  enum mysql_option methods_to_use;
  // ci
  union anonymous ci;
  // secure_auth
  char secure_auth;
  // report_data_truncation
  char report_data_truncation;
  // local_infile_init
  signed int (*local_infile_init)(void **, const char *, void *);
  // local_infile_read
  signed int (*local_infile_read)(void *, char *, unsigned int);
  // local_infile_end
  void (*local_infile_end)(void *);
  // local_infile_error
  signed int (*local_infile_error)(void *, char *, unsigned int);
  // local_infile_userdata
  void *local_infile_userdata;
  // extension
  struct st_mysql_options_extention *extension;
};

struct st_mysql
{
  // net
  struct st_net net;
  // connector_fd
  unsigned char *connector_fd;
  // host
  char *host;
  // user
  char *user;
  // passwd
  char *passwd;
  // unix_socket
  char *unix_socket;
  // server_version
  char *server_version;
  // host_info
  char *host_info;
  // info
  char *info;
  // db
  char *db;
  // charset
  struct charset_info_st *charset;
  // fields
  struct st_mysql_field *fields;
  // field_alloc
  struct st_mem_root field_alloc;
  // affected_rows
  unsigned long long int affected_rows;
  // insert_id
  unsigned long long int insert_id;
  // extra_info
  unsigned long long int extra_info;
  // thread_id
  unsigned long int thread_id;
  // packet_length
  unsigned long int packet_length;
  // port
  unsigned int port;
  // client_flag
  unsigned long int client_flag;
  // server_capabilities
  unsigned long int server_capabilities;
  // protocol_version
  unsigned int protocol_version;
  // field_count
  unsigned int field_count;
  // server_status
  unsigned int server_status;
  // server_language
  unsigned int server_language;
  // warning_count
  unsigned int warning_count;
  // options
  struct st_mysql_options options;
  // status
  enum mysql_status status;
  // free_me
  char free_me;
  // reconnect
  char reconnect;
  // scramble
  char scramble[21l];
  // unused1
  char unused1;
  // unused2
  void *unused2;
  // unused3
  void *unused3;
  // unused4
  void *unused4;
  // unused5
  void *unused5;
  // stmts
  struct st_list *stmts;
  // methods
  struct st_mysql_methods *methods;
  // thd
  void *thd;
  // unbuffered_fetch_owner
  char *unbuffered_fetch_owner;
  // info_buffer
  char *info_buffer;
  // extension
  void *extension;
};

struct st_mysql_data
{
  // data
  struct st_mysql_rows *data;
  // embedded_info
  struct embedded_query_result *embedded_info;
  // alloc
  struct st_mem_root alloc;
  // rows
  unsigned long long int rows;
  // fields
  unsigned int fields;
  // extension
  void *extension;
};

struct st_mysql_field
{
  // name
  char *name;
  // org_name
  char *org_name;
  // table
  char *table;
  // org_table
  char *org_table;
  // db
  char *db;
  // catalog
  char *catalog;
  // def
  char *def;
  // length
  unsigned long int length;
  // max_length
  unsigned long int max_length;
  // name_length
  unsigned int name_length;
  // org_name_length
  unsigned int org_name_length;
  // table_length
  unsigned int table_length;
  // org_table_length
  unsigned int org_table_length;
  // db_length
  unsigned int db_length;
  // catalog_length
  unsigned int catalog_length;
  // def_length
  unsigned int def_length;
  // flags
  unsigned int flags;
  // decimals
  unsigned int decimals;
  // charsetnr
  unsigned int charsetnr;
  // type
  enum enum_field_types type;
  // extension
  void *extension;
};

struct st_mysql_res
{
  // row_count
  unsigned long long int row_count;
  // fields
  struct st_mysql_field *fields;
  // data
  struct st_mysql_data *data;
  // data_cursor
  struct st_mysql_rows *data_cursor;
  // lengths
  unsigned long int *lengths;
  // handle
  struct st_mysql *handle;
  // methods
  struct st_mysql_methods *methods;
  // row
  char **row;
  // current_row
  char **current_row;
  // field_alloc
  struct st_mem_root field_alloc;
  // field_count
  unsigned int field_count;
  // current_field
  unsigned int current_field;
  // eof
  char eof;
  // unbuffered_fetch_cancelled
  char unbuffered_fetch_cancelled;
  // extension
  void *extension;
};

struct st_mysql_rows
{
  // next
  struct st_mysql_rows *next;
  // data
  char **data;
  // length
  unsigned long int length;
};

struct st_used_mem
{
  // next
  struct st_used_mem *next;
  // left
  unsigned int left;
  // size
  unsigned int size;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct target_struct
{
  // target_id
  signed int target_id;
  // result
  char result[1024l];
  // local_data_id
  signed int local_data_id;
  // action
  signed int action;
  // command
  char command[256l];
  // hostname
  char hostname[250l];
  // snmp_community
  char snmp_community[100l];
  // snmp_version
  signed int snmp_version;
  // snmp_username
  char snmp_username[50l];
  // snmp_password
  char snmp_password[50l];
  // snmp_auth_protocol
  char snmp_auth_protocol[5l];
  // snmp_priv_passphrase
  char snmp_priv_passphrase[200l];
  // snmp_priv_protocol
  char snmp_priv_protocol[7l];
  // snmp_context
  char snmp_context[65l];
  // snmp_port
  signed int snmp_port;
  // snmp_timeout
  signed int snmp_timeout;
  // availability_method
  signed int availability_method;
  // ping_method
  signed int ping_method;
  // ping_port
  signed int ping_port;
  // ping_timeout
  signed int ping_timeout;
  // ping_retries
  signed int ping_retries;
  // rrd_name
  char rrd_name[30l];
  // rrd_path
  char rrd_path[255l];
  // rrd_num
  signed int rrd_num;
  // arg1
  char arg1[512l];
  // arg2
  char arg2[255l];
  // arg3
  char arg3[255l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct variable_list
{
  // next_variable
  struct variable_list *next_variable;
  // name
  unsigned long int *name;
  // name_length
  unsigned long int name_length;
  // type
  unsigned char type;
  // val
  union anonymous$3 val;
  // val_len
  unsigned long int val_len;
  // name_loc
  unsigned long int name_loc[128l];
  // buf
  unsigned char buf[40l];
  // data
  void *data;
  // dataFreeHook
  void (*dataFreeHook)(void *);
  // index
  signed int index;
};


// ListMutex
// file nft_popen.c line 76
static union anonymous$9 ListMutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// PidList
// file nft_popen.c line 73
static struct pid *PidList;
// actions
// file keywords.c line 91
static struct keyword actions[7l] = { { .word="SNMP", .value=0 }, { .word="SCRIPT", .value=1 }, { .word="PHPSCRIPT", .value=2 }, { .word="SNMP_CT", .value=10 }, { .word="SCRIPT_CT", .value=11 }, { .word="PHPSCRIPT_CT", .value=12 }, { .word=((const char *)NULL), .value=0 } };
// active_scripts
// file spine.c line 96
signed int active_scripts = 0;
// active_threads
// file spine.c line 95
signed int active_threads = 0;
// config_paths
// file spine.c line 101
char config_paths[4l][1024l];
// entries
// file spine.c line 93
signed int entries = 0;
// environ
// file nft_popen.c line 109 function nft_popen
extern char **environ;
// ghbn_lock
// file locks.c line 54
static union anonymous$9 ghbn_lock;
// ghbn_lock_o
// file locks.c line 54
static signed int ghbn_lock_o = 0;
// log_level
// file keywords.c line 60
static struct keyword log_level[6l] = { { .word="NONE", .value=1 }, { .word="LOW", .value=2 }, { .word="MEDIUM", .value=3 }, { .word="HIGH", .value=4 }, { .word="DEBUG", .value=5 }, { .word=((const char *)NULL), .value=0 } };
// logdest
// file keywords.c line 76
static struct keyword logdest[5l] = { { .word="FILE", .value=1 }, { .word="SYSLOG", .value=3 }, { .word="BOTH", .value=2 }, { .word="STDOUT", .value=4 }, { .word=((const char *)NULL), .value=0 } };
// nopts
// file util.c line 37
static signed int nopts = 0;
// num_hosts
// file spine.c line 94
signed int num_hosts = 0;
// opttable
// file util.c line 52
static struct anonymous$0 opttable[256l];
// php_lock
// file locks.c line 57
static union anonymous$9 php_lock;
// php_lock_o
// file locks.c line 57
static signed int php_lock_o = 0;
// php_proc_0_lock
// file locks.c line 58
static union anonymous$9 php_proc_0_lock;
// php_proc_0_lock_o
// file locks.c line 58
static signed int php_proc_0_lock_o = 0;
// php_proc_1_lock
// file locks.c line 59
static union anonymous$9 php_proc_1_lock;
// php_proc_1_lock_o
// file locks.c line 59
static signed int php_proc_1_lock_o = 0;
// php_proc_2_lock
// file locks.c line 60
static union anonymous$9 php_proc_2_lock;
// php_proc_2_lock_o
// file locks.c line 60
static signed int php_proc_2_lock_o = 0;
// php_proc_3_lock
// file locks.c line 61
static union anonymous$9 php_proc_3_lock;
// php_proc_3_lock_o
// file locks.c line 61
static signed int php_proc_3_lock_o = 0;
// php_proc_4_lock
// file locks.c line 62
static union anonymous$9 php_proc_4_lock;
// php_proc_4_lock_o
// file locks.c line 62
static signed int php_proc_4_lock_o = 0;
// php_proc_5_lock
// file locks.c line 63
static union anonymous$9 php_proc_5_lock;
// php_proc_5_lock_o
// file locks.c line 63
static signed int php_proc_5_lock_o = 0;
// php_proc_6_lock
// file locks.c line 64
static union anonymous$9 php_proc_6_lock;
// php_proc_6_lock_o
// file locks.c line 64
static signed int php_proc_6_lock_o = 0;
// php_proc_7_lock
// file locks.c line 65
static union anonymous$9 php_proc_7_lock;
// php_proc_7_lock_o
// file locks.c line 65
static signed int php_proc_7_lock_o = 0;
// php_proc_8_lock
// file locks.c line 66
static union anonymous$9 php_proc_8_lock;
// php_proc_8_lock_o
// file locks.c line 66
static signed int php_proc_8_lock_o = 0;
// php_proc_9_lock
// file locks.c line 67
static union anonymous$9 php_proc_9_lock;
// php_proc_9_lock_o
// file locks.c line 67
static signed int php_proc_9_lock_o = 0;
// php_processes
// file spine.c line 100
struct php_processes *php_processes = ((struct php_processes *)NULL);
// pipe_lock
// file locks.c line 55
static union anonymous$9 pipe_lock;
// pipe_lock_o
// file locks.c line 55
static signed int pipe_lock_o = 0;
// set
// file spine.c line 99
struct config_struct set;
// seteuid_lock
// file locks.c line 53
static union anonymous$9 seteuid_lock;
// seteuid_lock_o
// file locks.c line 53
static signed int seteuid_lock_o = 0;
// snmp_lock
// file locks.c line 51
static union anonymous$9 snmp_lock;
// snmp_lock_o
// file locks.c line 51
static signed int snmp_lock_o = 0;
// spine_fatal_signals
// file error.c line 76
static signed int spine_fatal_signals[6l] = { 2, 11, 7, 8, 3, 0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// syslog_lock
// file locks.c line 56
static union anonymous$9 syslog_lock;
// syslog_lock_o
// file locks.c line 56
static signed int syslog_lock_o = 0;
// thread_lock
// file locks.c line 52
static union anonymous$9 thread_lock;
// thread_lock_o
// file locks.c line 52
static signed int thread_lock_o = 0;
// thread_ready
// file spine.c line 97
signed int thread_ready = 0;
// usmAESPrivProtocol
// file /usr/include/net-snmp/library/transform_oids.h line 24
extern unsigned long int usmAESPrivProtocol[10l];
// usmDESPrivProtocol
// file /usr/include/net-snmp/library/transform_oids.h line 20
extern unsigned long int usmDESPrivProtocol[10l];
// usmHMACMD5AuthProtocol
// file /usr/include/net-snmp/library/transform_oids.h line 15
extern unsigned long int usmHMACMD5AuthProtocol[10l];
// usmHMACSHA1AuthProtocol
// file /usr/include/net-snmp/library/transform_oids.h line 17
extern unsigned long int usmHMACSHA1AuthProtocol[10l];
// usmNoPrivProtocol
// file /usr/include/net-snmp/library/transform_oids.h line 18
extern unsigned long int usmNoPrivProtocol[10l];

// add_slashes
// file util.c line 918
extern char * add_slashes(char *string)
{
  signed int length;
  signed int position;
  signed int new_position;
  char *return_str;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)1024);
  return_str = (char *)return_value_malloc$1;
  if(return_str == ((char *)NULL))
    die("ERROR: Fatal malloc error: util.c add_slashes!");

  return_str[(signed long int)0] = (char)0;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(string);
  length = (signed int)return_value_strlen$2;
  position = 0;
  new_position = 0;
  if(length == 0)
    return return_str;

  else
  {
    for( ; !(position >= length); position = position + 1)
    {
      if((signed int)string[(signed long int)position] == 92)
      {
        return_str[(signed long int)new_position] = (char)92;
        new_position = new_position + 1;
        return_str[(signed long int)new_position] = (char)92;
      }

      else
        return_str[(signed long int)new_position] = string[(signed long int)position];
      new_position = new_position + 1;
    }
    return_str[(signed long int)new_position] = (char)0;
    return return_str;
  }
}

// all_digits
// file util.h line 53
extern signed int all_digits(const char *string)
{
  const unsigned short int **return_value___ctype_b_loc$1;
  if((signed int)*string == 0)
    return 0;

  else
  {
    do
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*string]) == 0)
        break;

      string = string + 1l;
    }
    while((_Bool)1);
    return (signed int)((signed int)*string == 0);
  }
}

// append_hostrange
// file sql.c line 289
extern signed int append_hostrange(char *obuf, const char *colname)
{
  if(set.end_host_id >= 0 && set.start_host_id >= 0)
  {
    signed int return_value_sprintf$1;
    return_value_sprintf$1=sprintf(obuf, " AND %s BETWEEN %d AND %d", colname, set.start_host_id, set.end_host_id);
    return return_value_sprintf$1;
  }

  else
    return 0;
}

// char_count
// file util.c line 1117
extern signed int char_count(const char *str, signed int chr)
{
  const unsigned char *my_str = (const unsigned char *)str;
  const unsigned char my_chr = (const unsigned char)chr;
  signed int count = 0;
  const unsigned char *tmp_post$1;
  if(my_chr == 0)
    return 1;

  else
  {
    while(!(*my_str == 0))
    {
      tmp_post$1 = my_str;
      my_str = my_str + 1l;
      if(*tmp_post$1 == my_chr)
        count = count + 1;

    }
    return count;
  }
}

// checkAsRoot
// file util.h line 84
extern void checkAsRoot()
{
  signed int return_value_hasCaps$6;
  return_value_hasCaps$6=hasCaps();
  signed int return_value_spine_log$1;
  signed int return_value_spine_log$2;
  signed int return_value_spine_log$5;
  if(!(return_value_hasCaps$6 == 1))
  {
    seteuid((unsigned int)0);
    unsigned int return_value_geteuid$4;
    return_value_geteuid$4=geteuid();
    if(!(return_value_geteuid$4 == 0u))
    {
      if(set.log_level >= 5)
      {
        return_value_spine_log$1=spine_log("WARNING: Spine NOT running asroot.  This is required if using ICMP.  Please run \"chmod +s;chown root:root spine\" to resolve.");
        if(!(return_value_spine_log$1 == 0))
          (_Bool)1;

        else
          (_Bool)0;
      }

      else
        (_Bool)0;
      set.icmp_avail = 0;
    }

    else
    {
      if(set.log_level >= 5)
      {
        return_value_spine_log$2=spine_log("DEBUG: Spine is running asroot.");
        if(!(return_value_spine_log$2 == 0))
          (_Bool)1;

        else
          (_Bool)0;
      }

      else
        (_Bool)0;
      set.icmp_avail = 1;
      unsigned int return_value_getuid$3;
      return_value_getuid$3=getuid();
      seteuid(return_value_getuid$3);
    }
  }

  else
  {
    if(set.log_level >= 5)
    {
      return_value_spine_log$5=spine_log("DEBUG: Spine has cap_net_raw capability.");
      if(!(return_value_spine_log$5 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
    set.icmp_avail = 1;
  }
}

// child
// file poller.h line 34
extern void * child(void *arg)
{
  signed int host_id;
  signed int host_thread;
  signed int last_host_thread;
  signed int host_data_ids;
  char host_time[256l];
  struct poller_thread poller_details = *((struct poller_thread *)arg);
  host_id = poller_details.host_id;
  host_thread = poller_details.host_thread;
  last_host_thread = poller_details.last_host_thread;
  host_data_ids = poller_details.host_data_ids;
  snprintf(host_time, (unsigned long int)256, "%s", poller_details.host_time);
  free(arg);
  thread_ready = 1;
  signed int return_value_spine_log$1;
  if(set.log_level >= 5)
  {
    return_value_spine_log$1=spine_log("DEBUG: In Poller, About to Start Polling of Host");
    if(!(return_value_spine_log$1 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  poll_host(host_id, host_thread, last_host_thread, host_data_ids, host_time);
  while((_Bool)1)
  {
    signed int return_value_thread_mutex_trylock$2;
    return_value_thread_mutex_trylock$2=thread_mutex_trylock(1);
    if(return_value_thread_mutex_trylock$2 == 0)
    {
      active_threads = active_threads - 1;
      thread_mutex_unlock(1);
      break;
    }

    usleep((unsigned int)100);
  }
  signed int return_value_spine_log$3;
  if(set.log_level >= 5)
  {
    return_value_spine_log$3=spine_log("DEBUG: The Value of Active Threads is %i", active_threads);
    if(!(return_value_spine_log$3 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  pthread_exit(NULL);
  exit(0);
}

// close_cleanup
// file nft_popen.c line 349
static void close_cleanup(void *arg)
{
  struct pid *cur = (struct pid *)arg;
  struct pid *prev;
  if(cur->fd >= 0)
    close(cur->fd);

  pthread_mutex_lock(&ListMutex);
  if(PidList == cur)
    PidList = cur->next;

  else
  {
    prev = PidList;
    for( ; !(prev == ((struct pid *)NULL)); prev = prev->next)
      if(prev->next == cur)
      {
        prev->next = cur->next;
        break;
      }

    /* assertion prev != ((void *)0) */
    assert(prev != (struct pid *)(void *)0);
  }
  pthread_mutex_unlock(&ListMutex);
  free((void *)cur);
}

// config_defaults
// file util.h line 37
extern void config_defaults(void)
{
  set.threads = 5;
  set.dbport = (unsigned int)3306;
  set.pre087g = (unsigned int)0;
  strncopy(set.dbhost, "localhost", sizeof(char [256l]) /*256ul*/ );
  strncopy(set.dbdb, "cacti", sizeof(char [256l]) /*256ul*/ );
  strncopy(set.dbuser, "cactiuser", sizeof(char [256l]) /*256ul*/ );
  strncopy(set.dbpass, "cactiuser", sizeof(char [256l]) /*256ul*/ );
  strncopy(config_paths[(signed long int)0], "", sizeof(char [1024l]) /*1024ul*/ );
  strncopy(config_paths[(signed long int)1], "/etc/", sizeof(char [1024l]) /*1024ul*/ );
  strncopy(config_paths[(signed long int)2], "/etc/cacti/", sizeof(char [1024l]) /*1024ul*/ );
  strncopy(config_paths[(signed long int)3], "../etc/", sizeof(char [1024l]) /*1024ul*/ );
  set.log_destination = 1;
}

// db_connect
// file sql.c line 173
extern void db_connect(const char *database, struct st_mysql *mysql)
{
  signed int tries;
  signed int timeout;
  signed int rtimeout;
  signed int wtimeout;
  signed int options_error;
  signed int success;
  char *hostname;
  char *db_connect$$1$$socket = (char *)(void *)0;
  struct stat socket_stat;
  hostname=strdup(set.dbhost);
  if(hostname == ((char *)NULL))
    die("FATAL: malloc(): strdup() failed");

  signed int return_value_stat$2;
  return_value_stat$2=stat(hostname, &socket_stat);
  char *tmp_post$1;
  if(return_value_stat$2 == 0)
  {
    if(!((49152u & socket_stat.st_mode) == 0u))
    {
      db_connect$$1$$socket=strdup(set.dbhost);
      hostname = (char *)(void *)0;
    }

  }

  else
  {
    db_connect$$1$$socket=strstr(hostname, ":");
    if(!(db_connect$$1$$socket == ((char *)NULL)))
    {
      tmp_post$1 = db_connect$$1$$socket;
      db_connect$$1$$socket = db_connect$$1$$socket + 1l;
      *tmp_post$1 = (char)0x0;
    }

  }
  tries = 5;
  success = 0;
  timeout = 5;
  rtimeout = 10;
  wtimeout = 20;
  mysql_init(mysql);
  if(mysql == ((struct st_mysql *)NULL))
    die("FATAL: MySQL unable to allocate memory and therefore can not connect");

  options_error=mysql_options(mysql, (enum mysql_option)MYSQL_OPT_READ_TIMEOUT, (const void *)(char *)&rtimeout);
  if(!(options_error >= 0))
    die("FATAL: MySQL options unable to set read timeout value");

  options_error=mysql_options(mysql, (enum mysql_option)MYSQL_OPT_WRITE_TIMEOUT, (const void *)(char *)&wtimeout);
  if(!(options_error >= 0))
    die("FATAL: MySQL options unable to set read timeout value");

  options_error=mysql_options(mysql, (enum mysql_option)MYSQL_OPT_CONNECT_TIMEOUT, (const void *)(char *)&timeout);
  if(!(options_error >= 0))
    die("FATAL: MySQL options unable to set timeout value");

  _Bool tmp_if_expr$7;
  unsigned int return_value_mysql_errno$6;
  _Bool tmp_if_expr$9;
  unsigned int return_value_mysql_errno$8;
  while(tries >= 1)
  {
    tries = tries - 1;
    struct st_mysql *return_value_mysql_real_connect$10;
    return_value_mysql_real_connect$10=mysql_real_connect(mysql, hostname, set.dbuser, set.dbpass, database, set.dbport, db_connect$$1$$socket, (unsigned long int)0);
    if(return_value_mysql_real_connect$10 == ((struct st_mysql *)NULL))
    {
      unsigned int return_value_mysql_errno$5;
      return_value_mysql_errno$5=mysql_errno(mysql);
      if(!(return_value_mysql_errno$5 == 1049u))
      {
        return_value_mysql_errno$6=mysql_errno(mysql);
        tmp_if_expr$7 = return_value_mysql_errno$6 != (unsigned int)2005 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$7 = (_Bool)0;
      if(tmp_if_expr$7)
      {
        return_value_mysql_errno$8=mysql_errno(mysql);
        tmp_if_expr$9 = return_value_mysql_errno$8 != (unsigned int)1045 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
      {
        unsigned int return_value_mysql_errno$3;
        return_value_mysql_errno$3=mysql_errno(mysql);
        const char *return_value_mysql_error$4;
        return_value_mysql_error$4=mysql_error(mysql);
        printf("MYSQL: Connection Failed: Error:'%u', Message:'%s'\n", return_value_mysql_errno$3, return_value_mysql_error$4);
        success = 0;
        usleep((unsigned int)2000);
      }

      else
      {
        tries = 0;
        success = 0;
      }
    }

    else
    {
      tries = 0;
      success = 1;
    }
  }
  free((void *)hostname);
  if(success == 0)
  {
    unsigned int return_value_mysql_errno$11;
    return_value_mysql_errno$11=mysql_errno(mysql);
    const char *return_value_mysql_error$12;
    return_value_mysql_error$12=mysql_error(mysql);
    die("FATAL: Connection Failed, Error:'%i', Message:'%s'", return_value_mysql_errno$11, return_value_mysql_error$12);
  }

}

// db_disconnect
// file sql.c line 269
extern void db_disconnect(struct st_mysql *mysql)
{
  mysql_close(mysql);
}

// db_escape
// file sql.c line 312
extern void db_escape(struct st_mysql *mysql, char *output, const char *input)
{
  if(!(input == ((const char *)NULL)))
  {
    output[(signed long int)0] = (char)0;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(input);
    mysql_real_escape_string(mysql, output, input, return_value_strlen$1);
  }

}

// db_insert
// file sql.c line 48
extern signed int db_insert(struct st_mysql *mysql, const char *query)
{
  signed int error;
  signed int error_count = 0;
  char query_frag[1024l];
  snprintf(query_frag, (unsigned long int)1024, "%s", query);
  signed int return_value_spine_log$1;
  if(set.log_level >= 6)
  {
    return_value_spine_log$1=spine_log("DEVDBG: SQL:'%s'", (const void *)query_frag);
    if(!(return_value_spine_log$1 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  while((_Bool)1)
    if(set.SQL_readonly == 0)
    {
      signed int return_value_mysql_query$5;
      return_value_mysql_query$5=mysql_query(mysql, query);
      if(!(return_value_mysql_query$5 == 0))
      {
        unsigned int return_value_mysql_errno$2;
        return_value_mysql_errno$2=mysql_errno(mysql);
        error = (signed int)return_value_mysql_errno$2;
        if(error == 1205 || error == 1213)
        {
          usleep((unsigned int)50000);
          error_count = error_count + 1;
          if(error_count >= 31)
          {
            spine_log("ERROR: Too many Lock/Deadlock errors occurred!, SQL Fragment:'%s'", (const void *)query_frag);
            return 0;
          }

          continue;
        }

        else
          if(error == 2006)
          {
            const char *return_value_mysql_error$3;
            return_value_mysql_error$3=mysql_error(mysql);
            spine_log("WARNING: SQL Failed! Error:'%i', Message:'%s', Attempting to Reconnect", error, return_value_mysql_error$3);
            db_disconnect(mysql);
            usleep((unsigned int)50000);
            db_connect(set.dbdb, mysql);
            error_count = error_count + 1;
            if(error_count >= 31)
              die("FATAL: Too many Reconnect Attempts!\n");

            continue;
          }

          else
          {
            const char *return_value_mysql_error$4;
            return_value_mysql_error$4=mysql_error(mysql);
            spine_log("ERROR: SQL Failed! Error:'%i', Message:'%s', SQL Fragment:'%s'", error, return_value_mysql_error$4, (const void *)query_frag);
            return 0;
          }
      }

      else
        return 1;
    }

    else
      return 1;
}

// db_query
// file sql.c line 109
extern struct st_mysql_res * db_query(struct st_mysql *mysql, const char *query)
{
  struct st_mysql_res *mysql_res = ((struct st_mysql_res *)NULL);
  signed int error = 0;
  signed int error_count = 0;
  char query_frag[1024l];
  snprintf(query_frag, (unsigned long int)1024, "%s", query);
  signed int return_value_spine_log$1;
  if(set.log_level >= 6)
  {
    return_value_spine_log$1=spine_log("DEVDBG: SQL:'%s'", (const void *)query_frag);
    if(!(return_value_spine_log$1 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  while((_Bool)1)
  {
    signed int return_value_mysql_query$5;
    return_value_mysql_query$5=mysql_query(mysql, query);
    if(!(return_value_mysql_query$5 == 0))
    {
      unsigned int return_value_mysql_errno$2;
      return_value_mysql_errno$2=mysql_errno(mysql);
      error = (signed int)return_value_mysql_errno$2;
      if(error == 1205 || error == 1213)
      {
        usleep((unsigned int)50000);
        error_count = error_count + 1;
        if(error_count >= 31)
          die("FATAL: Too many Lock/Deadlock errors occurred!, SQL Fragment:'%s'\n", (const void *)query_frag);

        continue;
      }

      else
        if(error == 2006)
        {
          const char *return_value_mysql_error$3;
          return_value_mysql_error$3=mysql_error(mysql);
          spine_log("WARNING: SQL Failed! Error:'%i', Message:'%s', Attempting to Reconnect", error, return_value_mysql_error$3);
          db_disconnect(mysql);
          usleep((unsigned int)50000);
          db_connect(set.dbdb, mysql);
          error_count = error_count + 1;
          if(error_count >= 31)
            die("FATAL: Too many Reconnect Attempts!\n");

          continue;
        }

        else
        {
          const char *return_value_mysql_error$4;
          return_value_mysql_error$4=mysql_error(mysql);
          die("FATAL: MySQL Error:'%i', Message:'%s'", error, return_value_mysql_error$4);
        }
    }

    else
    {
      mysql_res=mysql_store_result(mysql);
      break;
    }
  }
  return mysql_res;
}

// die
// file util.h line 43
extern void die(const char *format, ...)
{
  void **args;
  char logmessage[1024l];
  char flogmessage[1024l];
  args = (void **)&format;
  vsprintf(logmessage, format, args);
  args = ((void **)NULL);
  if(!(set.logfile_processed == 0))
  {
    if(set.parent_fork == 1)
      snprintf(flogmessage, (unsigned long int)1024, "%s (Spine parent)", (const void *)logmessage);

    else
      snprintf(flogmessage, (unsigned long int)1024, "%s (Spine thread)", (const void *)logmessage);
  }

  else
    snprintf(flogmessage, (unsigned long int)1024, "%s (Spine init)", (const void *)logmessage);
  spine_log("%s", (const void *)flogmessage);
  if(set.parent_fork == 1)
  {
    if(!(set.php_initialized == 0))
      php_close(999);

  }

  exit(set.exit_code);
}

// display_help
// file spine.c line 842
static void display_help(void)
{
  printf("SPINE %s  Copyright 2002-2013 by The Cacti Group\n\n", (const void *)"0.8.8b");
  static const char * const helptext[31l] = { "Usage: spine [options] [[firstid lastid] || [-H/--hostlist='hostid1,hostid2,...,hostidn']]",
    "", "Options:", "  -h/--help          Show this brief help listing",
    "  -f/--first=X       Start polling with host id X",
    "  -l/--last=X        End polling with host id X",
    "  -H/--hostlist=X    Poll the list of host ids, separated by comma's",
    "  -p/--poller=X      Set the poller id to X",
    "  -C/--conf=F        Read spine configuration from file F",
    "  -O/--option=S:V    Override DB settings 'set' with value 'V'",
    "  -R/--readonly      Spine will not write output to the DB",
    "  -S/--stdout        Logging is performed to standard output",
    "  -V/--verbosity=V   Set logging verbosity to <V>",
    "  --snmponly         Only do SNMP polling: no scripts",
    "", "Either both of --first/--last must be provided, a valid hostlist must be provided.",
    "In their absence, all hosts are processed.",
    "", "Without the --conf parameter, spine searches for its spine.conf",
    "file in the usual places.", "", "Verbosity is one of NONE/LOW/MEDIUM/HIGH/DEBUG or 1..5",
    "", "Runtime options are read from the 'settings' table in the Cacti",
    "database, but they can be overridden with the --option=S:V",
    "parameter.", "", "Spine is distributed under the Terms of the GNU Lessor",
    "General Public License Version 2.1. (http://www.gnu.org/licenses/lgpl.txt)",
    "For more information, see http://www.cacti.net",
    ((const char *)NULL) };
  static const char * const *p;
  p = helptext;
  for( ; !(*p == ((const char *)NULL)); p = p + 1l)
    puts(*p);
}

// exec_poll
// file poller.c line 1350
extern char * exec_poll(struct host_struct *current_host, char *command)
{
  signed int cmd_fd;
  signed int pid;
  signed int close_fd = 1;
  signed int bytes_read;
  struct anonymous$8 fds;
  double begin_time = (double)0;
  double end_time = (double)0;
  double script_timeout;
  struct timeval timeout;
  char *proc_command;
  char *result_string;
  proc_command = command;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)1024);
  result_string = (char *)return_value_malloc$1;
  if(result_string == ((char *)NULL))
    die("ERROR: Fatal malloc error: poller.c exec_poll!");

  memset((void *)result_string, 0, (unsigned long int)1024);
  script_timeout = (double)set.script_timeout;
  timeout.tv_sec = (signed long int)set.script_timeout;
  timeout.tv_usec = (signed long int)0;
  begin_time=get_time_as_double();
  while((_Bool)1)
  {
    thread_mutex_lock(4);
    if(active_scripts >= 21)
    {
      thread_mutex_unlock(4);
      usleep((unsigned int)50000);
    }

    else
    {
      active_scripts = active_scripts + 1;
      thread_mutex_unlock(4);
      break;
    }
  }
  cmd_fd=nft_popen((char *)proc_command, "r");
  signed int return_value_spine_log$2;
  if(set.log_level >= 5)
  {
    return_value_spine_log$2=spine_log("Host[%i] DEBUG: The NIFTY POPEN returned the following File Descriptor %i", current_host->id, cmd_fd);
    if(!(return_value_spine_log$2 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  signed int return_value_select$3;
  signed int *return_value___errno_location$4;
  double return_value_floor$5;
  double return_value_rint$6;
  double return_value_rint$7;
  if(cmd_fd >= 1)
  {
    do
    {

    retry:
      ;
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$8) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->__fds_bits[(signed long int)0]) : "memory");
      (&fds)->__fds_bits[(signed long int)(cmd_fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)(cmd_fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << cmd_fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      return_value_select$3=select(1024, &fds, (struct anonymous$8 *)(void *)0, (struct anonymous$8 *)(void *)0, &timeout);
      if(!(return_value_select$3 == -1))
      {
        if(return_value_select$3 == 0)
          goto __CPROVER_DUMP_L18;

        goto __CPROVER_DUMP_L19;
      }

      return_value___errno_location$4=__errno_location();
      if(!(*return_value___errno_location$4 == 9))
      {
        if(*return_value___errno_location$4 == 4)
          goto __CPROVER_DUMP_L13;

        if(*return_value___errno_location$4 == 22)
          goto __CPROVER_DUMP_L16;

        goto __CPROVER_DUMP_L17;
      }

      spine_log("Host[%i] ERROR: One or more of the file descriptor sets specified a file descriptor that is not a valid open file descriptor.", current_host->id);
      result_string[(signed long int)0] = (char)85;
      result_string[(signed long int)1] = (char)0;
      close_fd = 0;
      goto __CPROVER_DUMP_L18;

    __CPROVER_DUMP_L13:
      ;
      usleep((unsigned int)2000);
      end_time=get_time_as_double();
      return_value_floor$5=floor(script_timeout - (end_time - begin_time));
      return_value_rint$6=rint(return_value_floor$5);
      timeout.tv_sec = (signed long int)return_value_rint$6;
      return_value_rint$7=rint(((script_timeout - (end_time - begin_time)) - (double)timeout.tv_sec) * (double)1000000);
      timeout.tv_usec = (signed long int)return_value_rint$7;
      if(!(end_time + -begin_time < (double)set.script_timeout))
        break;

    }
    while((_Bool)1);
    spine_log("WARNING: A script timed out while processing EINTR's.");
    result_string[(signed long int)0] = (char)85;
    result_string[(signed long int)1] = (char)0;
    close_fd = 0;
    goto __CPROVER_DUMP_L18;

  __CPROVER_DUMP_L16:
    ;
    spine_log("Host[%i] ERROR: Possible invalid timeout specified in select() statement.", current_host->id);
    result_string[(signed long int)0] = (char)85;
    result_string[(signed long int)1] = (char)0;
    close_fd = 0;
    goto __CPROVER_DUMP_L18;

  __CPROVER_DUMP_L17:
    ;
    spine_log("Host[%i] ERROR: The script/command select() failed", current_host->id);
    result_string[(signed long int)0] = (char)85;
    result_string[(signed long int)1] = (char)0;
    close_fd = 0;
    goto __CPROVER_DUMP_L18;

  __CPROVER_DUMP_L18:
    ;
    spine_log("Host[%i] ERROR: The NIFTY POPEN timed out", current_host->id);
    pid=nft_pchild(cmd_fd);
    kill(pid, 9);
    result_string[(signed long int)0] = (char)85;
    result_string[(signed long int)1] = (char)0;
    goto __CPROVER_DUMP_L22;

  __CPROVER_DUMP_L19:
    ;
    signed long int return_value_read$8;
    return_value_read$8=read(cmd_fd, (void *)result_string, (unsigned long int)(1024 - 1));
    bytes_read = (signed int)return_value_read$8;
    if(bytes_read >= 1)
      result_string[(signed long int)bytes_read] = (char)0;

    else
    {
      spine_log("Host[%i] ERROR: Empty result [%s]: '%s'", current_host->id, (const void *)current_host->hostname, command);
      result_string[(signed long int)0] = (char)85;
      result_string[(signed long int)1] = (char)0;
    }

  __CPROVER_DUMP_L22:
    ;
    nft_pclose(cmd_fd);
  }

  else
  {
    spine_log("Host[%i] ERROR: Problem executing POPEN [%s]: '%s'", current_host->id, (const void *)current_host->hostname, command);
    result_string[(signed long int)0] = (char)85;
    result_string[(signed long int)1] = (char)0;
  }
  thread_mutex_lock(4);
  active_scripts = active_scripts - 1;
  thread_mutex_unlock(4);
  return result_string;
}

// file_exists
// file util.c line 733
extern signed int file_exists(const char *filename)
{
  struct stat file_stat;
  signed int return_value_stat$1;
  return_value_stat$1=stat(filename, &file_stat);
  if(!(return_value_stat$1 == 0))
    return 0;

  else
    return 1;
}

// find_keyword_by_value
// file keywords.c line 156
static const char * find_keyword_by_value(struct keyword *tbl, signed int value, const char *dflt)
{
  /* assertion tbl != 0 */
  assert(tbl != ((struct keyword *)NULL));
  for( ; !(tbl->word == ((const char *)NULL)); tbl = tbl + 1l)
    if(tbl->value == value)
      return tbl->word;

  return dflt;
}

// find_keyword_by_word
// file keywords.c line 122
static signed int find_keyword_by_word(struct keyword *tbl, const char *word, signed int dflt)
{
  /* assertion tbl != 0 */
  assert(tbl != ((struct keyword *)NULL));
  /* assertion word != 0 */
  assert(word != ((const char *)NULL));
  signed int return_value_all_digits$2;
  return_value_all_digits$2=all_digits(word);
  if(!(return_value_all_digits$2 == 0))
  {
    signed int return_value_atoi$1;
    return_value_atoi$1=atoi(word);
    return return_value_atoi$1;
  }

  for( ; !(tbl->word == ((const char *)NULL)); tbl = tbl + 1l)
  {
    signed int return_value_strcasecmp$3;
    return_value_strcasecmp$3=strcasecmp(word, tbl->word);
    if(return_value_strcasecmp$3 == 0)
      return tbl->value;

  }
  return dflt;
}

// get_attr
// file locks.c line 115
extern signed int * get_attr(signed int locko)
{
  signed int *ret_val = (signed int *)(void *)0;
  switch(locko)
  {
    case 0:
    {
      ret_val = &snmp_lock_o;
      break;
    }
    case 1:
    {
      ret_val = &thread_lock_o;
      break;
    }
    case 2:
    {
      ret_val = &seteuid_lock_o;
      break;
    }
    case 3:
    {
      ret_val = &ghbn_lock_o;
      break;
    }
    case 4:
    {
      ret_val = &pipe_lock_o;
      break;
    }
    case 5:
    {
      ret_val = &syslog_lock_o;
      break;
    }
    case 6:
    {
      ret_val = &php_lock_o;
      break;
    }
    case 7:
    {
      ret_val = &php_proc_0_lock_o;
      break;
    }
    case 8:
    {
      ret_val = &php_proc_1_lock_o;
      break;
    }
    case 9:
    {
      ret_val = &php_proc_2_lock_o;
      break;
    }
    case 10:
    {
      ret_val = &php_proc_3_lock_o;
      break;
    }
    case 11:
    {
      ret_val = &php_proc_4_lock_o;
      break;
    }
    case 12:
    {
      ret_val = &php_proc_5_lock_o;
      break;
    }
    case 13:
    {
      ret_val = &php_proc_6_lock_o;
      break;
    }
    case 14:
    {
      ret_val = &php_proc_7_lock_o;
      break;
    }
    case 15:
    {
      ret_val = &php_proc_8_lock_o;
      break;
    }
    case 16:
      ret_val = &php_proc_9_lock_o;
  }
  return ret_val;
}

// get_checksum
// file ping.c line 951
extern unsigned short int get_checksum(void *buf, signed int len)
{
  signed int nleft = len;
  signed int sum = 0;
  unsigned short int answer;
  unsigned short int *w = (unsigned short int *)buf;
  unsigned short int odd_byte = (unsigned short int)0;
  unsigned short int *tmp_post$1;
  for( ; nleft >= 2; nleft = nleft - 2)
  {
    tmp_post$1 = w;
    w = w + 1l;
    sum = sum + (signed int)*tmp_post$1;
  }
  if(nleft == 1)
  {
    *((unsigned char *)&odd_byte) = *((unsigned char *)w);
    sum = sum + (signed int)odd_byte;
  }

  sum = (sum >> 16) + (sum & 0xffff);
  sum = sum + (sum >> 16);
  answer = (unsigned short int)~sum;
  return answer;
}

// get_host_poll_time
// file util.h line 77
extern char * get_host_poll_time(void)
{
  signed long int nowbin;
  struct tm now_time;
  struct tm *now_ptr;
  char *host_time;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)20);
  host_time = (char *)return_value_malloc$1;
  if(host_time == ((char *)NULL))
    die("ERROR: Fatal malloc error: util.c host_time");

  host_time[(signed long int)0] = (char)0;
  signed long int return_value_time$2;
  return_value_time$2=time(&nowbin);
  if(return_value_time$2 == -1l)
    die("ERROR: Could not get time of day from time() util.c get_host_poll_time()");

  localtime_r(&nowbin, &now_time);
  now_ptr = &now_time;
  unsigned long int return_value_strftime$3;
  return_value_strftime$3=strftime(host_time, (unsigned long int)20, "%Y-%m-%d %H:%M:%S", now_ptr);
  if(return_value_strftime$3 == 0ul)
    die("ERROR: Could not get string from strftime() util.c get_host_poll_time()");

  return host_time;
}

// get_lock
// file locks.c line 89
extern union anonymous$9 * get_lock(signed int lock)
{
  union anonymous$9 *ret_val = (union anonymous$9 *)(void *)0;
  switch(lock)
  {
    case 0:
    {
      ret_val = &snmp_lock;
      break;
    }
    case 1:
    {
      ret_val = &thread_lock;
      break;
    }
    case 2:
    {
      ret_val = &seteuid_lock;
      break;
    }
    case 3:
    {
      ret_val = &ghbn_lock;
      break;
    }
    case 4:
    {
      ret_val = &pipe_lock;
      break;
    }
    case 5:
    {
      ret_val = &syslog_lock;
      break;
    }
    case 6:
    {
      ret_val = &php_lock;
      break;
    }
    case 7:
    {
      ret_val = &php_proc_0_lock;
      break;
    }
    case 8:
    {
      ret_val = &php_proc_1_lock;
      break;
    }
    case 9:
    {
      ret_val = &php_proc_2_lock;
      break;
    }
    case 10:
    {
      ret_val = &php_proc_3_lock;
      break;
    }
    case 11:
    {
      ret_val = &php_proc_4_lock;
      break;
    }
    case 12:
    {
      ret_val = &php_proc_5_lock;
      break;
    }
    case 13:
    {
      ret_val = &php_proc_6_lock;
      break;
    }
    case 14:
    {
      ret_val = &php_proc_7_lock;
      break;
    }
    case 15:
    {
      ret_val = &php_proc_8_lock;
      break;
    }
    case 16:
      ret_val = &php_proc_9_lock;
  }
  return ret_val;
}

// get_time_as_double
// file util.h line 74
extern double get_time_as_double(void)
{
  struct timeval now;
  gettimeofday(&now, (struct timezone *)(void *)0);
  return (double)now.tv_sec + (double)now.tv_usec / (double)1000000;
}

// getarg
// file spine.c line 904
static char * getarg(char *opt, char ***pargv)
{
  const char * const optname = *(*pargv);
  if(!(opt == ((char *)NULL)))
    return opt;

  else
  {
    *pargv = *pargv + 1l;
    opt = *(*pargv);
    if(!(opt == ((char *)NULL)))
      return opt;

    else
      die("ERROR: option %s requires a parameter", optname);
  }
}

// getboolsetting
// file util.c line 118
static signed int getboolsetting(struct st_mysql *psql, const char *setting, signed int dflt)
{
  const char *rc;
  /* assertion psql != 0 */
  assert(psql != ((struct st_mysql *)NULL));
  /* assertion setting != 0 */
  assert(setting != ((const char *)NULL));
  rc=getsetting(psql, setting);
  _Bool tmp_if_expr$3;
  signed int return_value_strcasecmp$2;
  _Bool tmp_if_expr$5;
  signed int return_value_strcasecmp$4;
  _Bool tmp_if_expr$7;
  signed int return_value_strcasecmp$6;
  _Bool tmp_if_expr$10;
  signed int return_value_strcasecmp$9;
  _Bool tmp_if_expr$12;
  signed int return_value_strcasecmp$11;
  _Bool tmp_if_expr$14;
  signed int return_value_strcasecmp$13;
  if(rc == ((const char *)NULL))
    return dflt;

  else
  {
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(rc, "on");
    if(return_value_strcasecmp$1 == 0)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_strcasecmp$2=strcasecmp(rc, "yes");
      tmp_if_expr$3 = return_value_strcasecmp$2 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_strcasecmp$4=strcasecmp(rc, "true");
      tmp_if_expr$5 = return_value_strcasecmp$4 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      return_value_strcasecmp$6=strcasecmp(rc, "1");
      tmp_if_expr$7 = return_value_strcasecmp$6 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
      return 1;

    else
    {
      signed int return_value_strcasecmp$8;
      return_value_strcasecmp$8=strcasecmp(rc, "off");
      if(return_value_strcasecmp$8 == 0)
        tmp_if_expr$10 = (_Bool)1;

      else
      {
        return_value_strcasecmp$9=strcasecmp(rc, "no");
        tmp_if_expr$10 = return_value_strcasecmp$9 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$10)
        tmp_if_expr$12 = (_Bool)1;

      else
      {
        return_value_strcasecmp$11=strcasecmp(rc, "false");
        tmp_if_expr$12 = return_value_strcasecmp$11 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$12)
        tmp_if_expr$14 = (_Bool)1;

      else
      {
        return_value_strcasecmp$13=strcasecmp(rc, "0");
        tmp_if_expr$14 = return_value_strcasecmp$13 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$14)
        return 0;

      else
        return dflt;
    }
  }
}

// getglobalvariable
// file util.c line 157
static const char * getglobalvariable(struct st_mysql *psql, const char *setting)
{
  char qstring[256l];
  struct st_mysql_res *result;
  char **mysql_row;
  signed int i;
  /* assertion psql != 0 */
  assert(psql != ((struct st_mysql *)NULL));
  /* assertion setting != 0 */
  assert(setting != ((const char *)NULL));
  i = 0;
  for( ; !(i >= nopts); i = i + 1)
  {
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(setting, opttable[(signed long int)i].opt);
    if(return_value_strcasecmp$1 == 0)
      return opttable[(signed long int)i].val;

  }
  sprintf(qstring, "SHOW GLOBAL VARIABLES LIKE '%s'", setting);
  result=db_query(psql, qstring);
  unsigned long long int return_value_mysql_num_rows$2;
  return_value_mysql_num_rows$2=mysql_num_rows(result);
  _Bool tmp_if_expr$3;
  if(return_value_mysql_num_rows$2 >= 1ul)
  {
    mysql_row=mysql_fetch_row(result);
    tmp_if_expr$3 = mysql_row != ((char **)NULL) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
    return mysql_row[(signed long int)1];

  else
    return ((const char *)NULL);
}

// getsetting
// file util.c line 79
static const char * getsetting(struct st_mysql *psql, const char *setting)
{
  char qstring[256l];
  struct st_mysql_res *result;
  char **mysql_row;
  signed int i;
  /* assertion psql != 0 */
  assert(psql != ((struct st_mysql *)NULL));
  /* assertion setting != 0 */
  assert(setting != ((const char *)NULL));
  i = 0;
  for( ; !(i >= nopts); i = i + 1)
  {
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(setting, opttable[(signed long int)i].opt);
    if(return_value_strcasecmp$1 == 0)
      return opttable[(signed long int)i].val;

  }
  sprintf(qstring, "SELECT value FROM settings WHERE name = '%s'", setting);
  result=db_query(psql, qstring);
  unsigned long long int return_value_mysql_num_rows$2;
  return_value_mysql_num_rows$2=mysql_num_rows(result);
  _Bool tmp_if_expr$3;
  if(return_value_mysql_num_rows$2 >= 1ul)
  {
    mysql_row=mysql_fetch_row(result);
    tmp_if_expr$3 = mysql_row != ((char **)NULL) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
    return mysql_row[(signed long int)0];

  else
    return ((const char *)NULL);
}

// hasCaps
// file util.c line 1218
extern signed int hasCaps()
{
  return 0;
}

// hex2dec
// file util.c line 1132
unsigned long long int hex2dec(char *str)
{
  signed int i = 0;
  unsigned long long int number = (unsigned long long int)0;
  double return_value_pow$1;
  double return_value_pow$2;
  double return_value_pow$3;
  double return_value_pow$4;
  double return_value_pow$5;
  double return_value_pow$6;
  double return_value_pow$7;
  double return_value_pow$8;
  double return_value_pow$9;
  double return_value_pow$10;
  double return_value_pow$11;
  double return_value_pow$12;
  double return_value_pow$13;
  double return_value_pow$14;
  double return_value_pow$15;
  if(str == ((char *)NULL))
    return (unsigned long long int)0;

  else
  {
    reverse(str);
    for( ; !(*str == 0); str = str + 1l)
      switch((signed int)*str)
      {
        case 48:
        {
          i = i + 1;
          break;
        }
        case 49:
        {
          return_value_pow$1=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$1 * (double)1);
          i = i + 1;
          break;
        }
        case 50:
        {
          return_value_pow$2=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$2 * (double)2);
          i = i + 1;
          break;
        }
        case 51:
        {
          return_value_pow$3=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$3 * (double)3);
          i = i + 1;
          break;
        }
        case 52:
        {
          return_value_pow$4=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$4 * (double)4);
          i = i + 1;
          break;
        }
        case 53:
        {
          return_value_pow$5=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$5 * (double)5);
          i = i + 1;
          break;
        }
        case 54:
        {
          return_value_pow$6=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$6 * (double)6);
          i = i + 1;
          break;
        }
        case 55:
        {
          return_value_pow$7=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$7 * (double)7);
          i = i + 1;
          break;
        }
        case 56:
        {
          return_value_pow$8=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$8 * (double)8);
          i = i + 1;
          break;
        }
        case 57:
        {
          return_value_pow$9=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$9 * (double)9);
          i = i + 1;
          break;
        }
        case 97:

        case 65:
        {
          return_value_pow$10=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$10 * (double)10);
          i = i + 1;
          break;
        }
        case 98:

        case 66:
        {
          return_value_pow$11=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$11 * (double)11);
          i = i + 1;
          break;
        }
        case 99:

        case 67:
        {
          return_value_pow$12=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$12 * (double)12);
          i = i + 1;
          break;
        }
        case 100:

        case 68:
        {
          return_value_pow$13=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$13 * (double)13);
          i = i + 1;
          break;
        }
        case 101:

        case 69:
        {
          return_value_pow$14=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$14 * (double)14);
          i = i + 1;
          break;
        }
        case 102:

        case 70:
        {
          return_value_pow$15=pow((double)16, (double)i);
          number = number + (unsigned long long int)(return_value_pow$15 * (double)15);
          i = i + 1;
          break;
        }
        case 34:

        case 32:

        case 9:
          break;
        default:
          return (unsigned long long int)0;
      }
    return number;
  }
}

// init_ghbn_lock
// file locks.c line 54
static void init_ghbn_lock(void)
{
  pthread_mutex_init(&ghbn_lock, (union anonymous$10 *)0);
}

// init_mutexes
// file locks.h line 34
extern void init_mutexes(void)
{
  signed int *return_value_get_attr$1;
  return_value_get_attr$1=get_attr(0);
  pthread_once((signed int *)return_value_get_attr$1, init_snmp_lock);
  signed int *return_value_get_attr$2;
  return_value_get_attr$2=get_attr(1);
  pthread_once((signed int *)return_value_get_attr$2, init_thread_lock);
  signed int *return_value_get_attr$3;
  return_value_get_attr$3=get_attr(2);
  pthread_once((signed int *)return_value_get_attr$3, init_seteuid_lock);
  signed int *return_value_get_attr$4;
  return_value_get_attr$4=get_attr(3);
  pthread_once((signed int *)return_value_get_attr$4, init_ghbn_lock);
  signed int *return_value_get_attr$5;
  return_value_get_attr$5=get_attr(4);
  pthread_once((signed int *)return_value_get_attr$5, init_pipe_lock);
  signed int *return_value_get_attr$6;
  return_value_get_attr$6=get_attr(5);
  pthread_once((signed int *)return_value_get_attr$6, init_syslog_lock);
  signed int *return_value_get_attr$7;
  return_value_get_attr$7=get_attr(6);
  pthread_once((signed int *)return_value_get_attr$7, init_php_lock);
  signed int *return_value_get_attr$8;
  return_value_get_attr$8=get_attr(7);
  pthread_once((signed int *)return_value_get_attr$8, init_php_proc_0_lock);
  signed int *return_value_get_attr$9;
  return_value_get_attr$9=get_attr(8);
  pthread_once((signed int *)return_value_get_attr$9, init_php_proc_1_lock);
  signed int *return_value_get_attr$10;
  return_value_get_attr$10=get_attr(9);
  pthread_once((signed int *)return_value_get_attr$10, init_php_proc_2_lock);
  signed int *return_value_get_attr$11;
  return_value_get_attr$11=get_attr(10);
  pthread_once((signed int *)return_value_get_attr$11, init_php_proc_3_lock);
  signed int *return_value_get_attr$12;
  return_value_get_attr$12=get_attr(11);
  pthread_once((signed int *)return_value_get_attr$12, init_php_proc_4_lock);
  signed int *return_value_get_attr$13;
  return_value_get_attr$13=get_attr(12);
  pthread_once((signed int *)return_value_get_attr$13, init_php_proc_5_lock);
  signed int *return_value_get_attr$14;
  return_value_get_attr$14=get_attr(13);
  pthread_once((signed int *)return_value_get_attr$14, init_php_proc_6_lock);
  signed int *return_value_get_attr$15;
  return_value_get_attr$15=get_attr(14);
  pthread_once((signed int *)return_value_get_attr$15, init_php_proc_7_lock);
  signed int *return_value_get_attr$16;
  return_value_get_attr$16=get_attr(15);
  pthread_once((signed int *)return_value_get_attr$16, init_php_proc_8_lock);
  signed int *return_value_get_attr$17;
  return_value_get_attr$17=get_attr(16);
  pthread_once((signed int *)return_value_get_attr$17, init_php_proc_9_lock);
}

// init_php_lock
// file locks.c line 57
static void init_php_lock(void)
{
  pthread_mutex_init(&php_lock, (union anonymous$10 *)0);
}

// init_php_proc_0_lock
// file locks.c line 58
static void init_php_proc_0_lock(void)
{
  pthread_mutex_init(&php_proc_0_lock, (union anonymous$10 *)0);
}

// init_php_proc_1_lock
// file locks.c line 59
static void init_php_proc_1_lock(void)
{
  pthread_mutex_init(&php_proc_1_lock, (union anonymous$10 *)0);
}

// init_php_proc_2_lock
// file locks.c line 60
static void init_php_proc_2_lock(void)
{
  pthread_mutex_init(&php_proc_2_lock, (union anonymous$10 *)0);
}

// init_php_proc_3_lock
// file locks.c line 61
static void init_php_proc_3_lock(void)
{
  pthread_mutex_init(&php_proc_3_lock, (union anonymous$10 *)0);
}

// init_php_proc_4_lock
// file locks.c line 62
static void init_php_proc_4_lock(void)
{
  pthread_mutex_init(&php_proc_4_lock, (union anonymous$10 *)0);
}

// init_php_proc_5_lock
// file locks.c line 63
static void init_php_proc_5_lock(void)
{
  pthread_mutex_init(&php_proc_5_lock, (union anonymous$10 *)0);
}

// init_php_proc_6_lock
// file locks.c line 64
static void init_php_proc_6_lock(void)
{
  pthread_mutex_init(&php_proc_6_lock, (union anonymous$10 *)0);
}

// init_php_proc_7_lock
// file locks.c line 65
static void init_php_proc_7_lock(void)
{
  pthread_mutex_init(&php_proc_7_lock, (union anonymous$10 *)0);
}

// init_php_proc_8_lock
// file locks.c line 66
static void init_php_proc_8_lock(void)
{
  pthread_mutex_init(&php_proc_8_lock, (union anonymous$10 *)0);
}

// init_php_proc_9_lock
// file locks.c line 67
static void init_php_proc_9_lock(void)
{
  pthread_mutex_init(&php_proc_9_lock, (union anonymous$10 *)0);
}

// init_pipe_lock
// file locks.c line 55
static void init_pipe_lock(void)
{
  pthread_mutex_init(&pipe_lock, (union anonymous$10 *)0);
}

// init_seteuid_lock
// file locks.c line 53
static void init_seteuid_lock(void)
{
  pthread_mutex_init(&seteuid_lock, (union anonymous$10 *)0);
}

// init_snmp_lock
// file locks.c line 51
static void init_snmp_lock(void)
{
  pthread_mutex_init(&snmp_lock, (union anonymous$10 *)0);
}

// init_sockaddr
// file ping.c line 779
extern signed int init_sockaddr(struct sockaddr_in *name, const char *hostname, unsigned short int port)
{
  struct hostent *hostinfo;
  signed int retry_count;
  name->sin_family = (unsigned short int)2;
  name->sin_port=htons(port);
  retry_count = 0;
  struct hostent result_buf;
  unsigned long int len = (unsigned long int)1024;
  char *buf;
  signed int herr;
  signed int rv;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(len * sizeof(char) /*1ul*/ );
  buf = (char *)return_value_malloc$1;
  memset((void *)buf, 0, sizeof(char *) /*8ul*/ );
  while((_Bool)1)
  {
    rv=gethostbyname_r(hostname, &result_buf, buf, len, &hostinfo, &herr);
    if(hostinfo == ((struct hostent *)NULL))
    {
      if(rv == 34)
      {
        len = len * (unsigned long int)2;
        void *return_value_realloc$2;
        return_value_realloc$2=realloc((void *)buf, len * sizeof(char) /*1ul*/ );
        buf = (char *)return_value_realloc$2;
        continue;
      }

      else
        if(herr == 2 && !(retry_count >= 3))
        {
          retry_count = retry_count + 1;
          usleep((unsigned int)50000);
          continue;
        }

        else
        {
          free((void *)buf);
          return 0;
        }
    }

    else
      break;
  }
  name->sin_addr = *((struct in_addr *)hostinfo->h_addr_list[(signed long int)0]);
  free((void *)buf);
  if(hostinfo == ((struct hostent *)NULL))
  {
    spine_log("WARNING: Unknown host %s", hostname);
    return 0;
  }

  else
    return 1;
}

// init_syslog_lock
// file locks.c line 56
static void init_syslog_lock(void)
{
  pthread_mutex_init(&syslog_lock, (union anonymous$10 *)0);
}

// init_thread_lock
// file locks.c line 52
static void init_thread_lock(void)
{
  pthread_mutex_init(&thread_lock, (union anonymous$10 *)0);
}

// install_spine_signal_handler
// file error.h line 34
extern void install_spine_signal_handler(void)
{
  signed int i;
  struct sigaction action;
  void (*ohandler)(signed int);
  i = 0;
  for( ; !(spine_fatal_signals[(signed long int)i] == 0); i = i + 1)
  {
    sigaction(spine_fatal_signals[(signed long int)i], (struct sigaction *)(void *)0, &action);
    if(action.__sigaction_handler.sa_handler == ((void (*)(signed int))NULL))
    {
      action.__sigaction_handler.sa_handler = spine_signal_handler;
      sigaction(spine_fatal_signals[(signed long int)i], &action, (struct sigaction *)(void *)0);
    }

  }
  i = 0;
  for( ; !(spine_fatal_signals[(signed long int)i] == 0); i = i + 1)
  {
    ohandler=signal(spine_fatal_signals[(signed long int)i], spine_signal_handler);
    if(!(ohandler == ((void (*)(signed int))NULL)))
      signal(spine_fatal_signals[(signed long int)i], ohandler);

  }
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
}

// is_hexadecimal
// file util.c line 858
extern signed int is_hexadecimal(const char *str, const signed short int ignore_space)
{
  signed int i = 0;
  if(str == ((const char *)NULL))
    return 0;

  else
  {
    for( ; !(*str == 0); i = i + 1)
    {
      switch((signed int)*str)
      {
        case 48:

        case 49:

        case 50:

        case 51:

        case 52:

        case 53:

        case 54:

        case 55:

        case 56:

        case 57:

        case 97:

        case 65:

        case 98:

        case 66:

        case 99:

        case 67:

        case 100:

        case 68:

        case 101:

        case 69:

        case 102:

        case 70:

        case 34:
          break;
        case 32:

        case 9:
          if(!(ignore_space == 0))
            break;

        default:
          return 0;
      }
      str = str + 1l;
    }
    if(!(i >= 3))
      return 0;

    else
      return 1;
  }
}

// is_ipaddress
// file util.c line 774
extern signed int is_ipaddress(const char *string)
{
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  while(!(*string == 0))
  {
    const unsigned short int **return_value___ctype_b_loc$1;
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if(!((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*string]) == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)*string == 46 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)*string == 58 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      string = string + 1l;

    else
      return 0;
  }
  return 1;
}

// is_multipart_output
// file poller.c line 1277
extern signed int is_multipart_output(char *result)
{
  signed int space_cnt = 0;
  signed int delim_cnt = 0;
  signed int i;
  _Bool tmp_if_expr$6;
  char *return_value_strstr$5;
  _Bool tmp_if_expr$2;
  if(!(result == ((char *)NULL)))
  {
    char *return_value_strstr$4;
    return_value_strstr$4=strstr(result, ":");
    if(!(return_value_strstr$4 == ((char *)NULL)))
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      return_value_strstr$5=strstr(result, "!");
      tmp_if_expr$6 = return_value_strstr$5 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
    {
      char *return_value_strstr$3;
      return_value_strstr$3=strstr(result, " ");
      if(return_value_strstr$3 == ((char *)NULL))
        return 1;

      else
      {
        signed int len;
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(result);
        len = (const signed int)return_value_strlen$1;
        i = 0;
        for( ; !(i >= len); i = i + 1)
        {
          if((signed int)result[(signed long int)i] == 58)
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = (signed int)result[(signed long int)i] == 33 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$2)
            delim_cnt = delim_cnt + 1;

          else
            if((signed int)result[(signed long int)i] == 32)
              space_cnt = space_cnt + 1;

        }
        if(1 + space_cnt == delim_cnt)
          return 1;

        else
          return 0;
      }
    }

  }

  return 0;
}

// is_numeric
// file util.c line 797
extern signed int is_numeric(const char *string)
{
  signed long int local_lval;
  double local_dval;
  char *end_ptr_long;
  char *end_ptr_double;
  signed int conv_base = 10;
  signed int length;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(string);
  length = (signed int)return_value_strlen$1;
  if(length == 0)
    return 0;

  else
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 0;
    local_lval=strtol(string, &end_ptr_long, conv_base);
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    if(!(*return_value___errno_location$3 == 34))
    {
      if(end_ptr_long == string + (signed long int)length)
        return 1;

      else
        if(end_ptr_long == string)
        {
          if(!((signed int)*end_ptr_long == 0))
          {
            if(!((signed int)*end_ptr_long == 46))
            {
              if(!((signed int)*end_ptr_long == 45))
              {
                if(!((signed int)*end_ptr_long == 43))
                  return 0;

              }

            }

          }

        }

    }

    else
      end_ptr_long = (char *)(void *)0;
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    *return_value___errno_location$4 = 0;
    local_dval=strtod(string, &end_ptr_double);
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    if(!(*return_value___errno_location$5 == 34))
    {
      if(end_ptr_double == string + (signed long int)length)
        return 1;

    }

    else
      end_ptr_double = (char *)(void *)0;
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    if(*return_value___errno_location$7 == 0)
    {
      signed int return_value_strcasecmp$6;
      return_value_strcasecmp$6=strcasecmp(string, " ");
      if(return_value_strcasecmp$6 == 0)
        return 0;

      else
        return 1;
    }

    else
      return 0;
  }
}

// ltrim
// file util.c line 1077
extern char * ltrim(char *str)
{
  char *ltrim$$1$$trim = " \"'\\\t\n\r";
  if(str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    while(!(*str == 0))
    {
      char *return_value_strchr$1;
      return_value_strchr$1=strchr(ltrim$$1$$trim, (signed int)*str);
      if(return_value_strchr$1 == ((char *)NULL))
        return str;

      str = str + 1l;
    }
    return str;
  }
}

// main
// file spine.c line 178
signed int main(signed int argc, char **argv)
{
  struct timeval now;
  char *conf_file = (char *)(void *)0;
  double begin_time;
  double end_time;
  double current_time;
  signed int num_rows = 0;
  signed int device_counter = 0;
  signed int poller_counter = 0;
  signed int last_active_threads = 0;
  signed int valid_conf_file = 0;
  signed long int EXTERNAL_THREAD_SLEEP = (signed long int)50;
  signed long int internal_thread_sleep;
  char querybuf[65535l];
  char *qp = querybuf;
  char *host_time = (char *)(void *)0;
  signed int itemsPT = 0;
  signed int device_threads;
  unsigned long int *threads = (unsigned long int *)(void *)0;
  struct poller_thread *poller_details = (struct poller_thread *)(void *)0;
  union pthread_attr_t attr;
  signed int *ids = (signed int *)(void *)0;
  struct st_mysql mysql;
  struct st_mysql_res *result = (struct st_mysql_res *)(void *)0;
  struct st_mysql_res *tresult = (struct st_mysql_res *)(void *)0;
  char **mysql_row;
  signed int canexit = 0;
  signed int host_id = 0;
  signed int i;
  signed int mutex_status = 0;
  signed int thread_status = 0;
  signed int change_host = 1;
  signed int current_thread;
  (void)argc;
  install_spine_signal_handler();
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)10, sizeof(struct php_processes) /*16ul*/ );
  php_processes = (struct php_processes *)return_value_calloc$1;
  i = 0;
  for( ; !(i >= 10); i = i + 1)
    (php_processes + (signed long int)i)->php_state = 1;
  set.icmp_avail = 1;
  signed int return_value_fileno$2;
  return_value_fileno$2=fileno(stdout);
  signed int return_value_isatty$3;
  return_value_isatty$3=isatty(return_value_fileno$2);
  if(return_value_isatty$3 == 0)
    set.stdout_notty = 1;

  else
    set.stdout_notty = 0;
  signed int return_value_fileno$4;
  return_value_fileno$4=fileno(stderr);
  signed int return_value_isatty$5;
  return_value_isatty$5=isatty(return_value_fileno$4);
  if(return_value_isatty$5 == 0)
    set.stderr_notty = 1;

  else
    set.stderr_notty = 0;
  begin_time=get_time_as_double();
  set.log_level = 2;
  set.exit_code = 0;
  config_defaults();
  set.poller_id = 0;
  set.start_host_id = -1;
  set.end_host_id = -1;
  set.host_id_list[(signed long int)0] = (char)0;
  set.php_initialized = 0;
  set.logfile_processed = 0;
  set.parent_fork = 1;
  argv = argv + 1l;
  char *tmp_post$6;
  _Bool tmp_if_expr$58;
  signed int return_value_strcmp$57;
  signed int return_value_strcmp$53;
  _Bool tmp_if_expr$55;
  signed int return_value_strcasecmp$54;
  signed int return_value_strcmp$50;
  _Bool tmp_if_expr$52;
  signed int return_value_strcasecmp$51;
  signed int return_value_strcmp$47;
  _Bool tmp_if_expr$49;
  signed int return_value_strcasecmp$48;
  signed int return_value_strcmp$40;
  _Bool tmp_if_expr$42;
  signed int return_value_strcmp$41;
  _Bool tmp_if_expr$44;
  signed int return_value_strcmp$43;
  _Bool tmp_if_expr$46;
  signed int return_value_strcmp$45;
  signed int return_value_strcmp$37;
  _Bool tmp_if_expr$39;
  signed int return_value_strcasecmp$38;
  char *tmp_post$9;
  signed int return_value_strcmp$32;
  _Bool tmp_if_expr$34;
  signed int return_value_strcmp$33;
  _Bool tmp_if_expr$36;
  signed int return_value_strcmp$35;
  signed int return_value_strcmp$29;
  _Bool tmp_if_expr$31;
  signed int return_value_strcmp$30;
  signed int return_value_strcmp$26;
  _Bool tmp_if_expr$28;
  signed int return_value_strcmp$27;
  signed int return_value_strcmp$23;
  _Bool tmp_if_expr$25;
  signed int return_value_strcmp$24;
  signed int return_value_strcmp$20;
  _Bool tmp_if_expr$22;
  signed int return_value_strcmp$21;
  signed int return_value_strcmp$17;
  _Bool tmp_if_expr$19;
  signed int return_value_strcmp$18;
  _Bool tmp_if_expr$16;
  signed int return_value_all_digits$15;
  _Bool tmp_if_expr$14;
  signed int return_value_all_digits$13;
  for( ; !(*argv == ((char *)NULL)); argv = argv + 1l)
  {
    char *arg = *argv;
    char *opt;
    opt=strchr(arg, 61);
    if(!(opt == ((char *)NULL)))
    {
      tmp_post$6 = opt;
      opt = opt + 1l;
      *tmp_post$6 = (char)0;
    }

    signed int return_value_strcmp$56;
    return_value_strcmp$56=strcmp(arg, "-f");
    if(return_value_strcmp$56 == 0)
      tmp_if_expr$58 = (_Bool)1;

    else
    {
      return_value_strcmp$57=strcmp(arg, "--first");
      tmp_if_expr$58 = return_value_strcmp$57 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$58)
    {
      if(set.start_host_id >= 0)
        die("ERROR: %s can only be used once", arg);

      opt=getarg(opt, &argv);
      set.start_host_id=atoi(opt);
      if(!(set.start_host_id >= 0))
        die("ERROR: '%s=%s' is invalid first-host ID", arg, opt);

    }

    else
    {
      return_value_strcmp$53=strcmp(arg, "-l");
      if(return_value_strcmp$53 == 0)
        tmp_if_expr$55 = (_Bool)1;

      else
      {
        return_value_strcasecmp$54=strcasecmp(arg, "--last");
        tmp_if_expr$55 = return_value_strcasecmp$54 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$55)
      {
        if(set.end_host_id >= 0)
          die("ERROR: %s can only be used once", arg);

        opt=getarg(opt, &argv);
        set.end_host_id=atoi(opt);
        if(!(set.end_host_id >= 0))
          die("ERROR: '%s=%s' is invalid last-host ID", arg, opt);

      }

      else
      {
        return_value_strcmp$50=strcmp(arg, "-p");
        if(return_value_strcmp$50 == 0)
          tmp_if_expr$52 = (_Bool)1;

        else
        {
          return_value_strcasecmp$51=strcasecmp(arg, "--poller");
          tmp_if_expr$52 = return_value_strcasecmp$51 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$52)
        {
          char *return_value_getarg$7;
          return_value_getarg$7=getarg(opt, &argv);
          set.poller_id=atoi(return_value_getarg$7);
        }

        else
        {
          return_value_strcmp$47=strcmp(arg, "-H");
          if(return_value_strcmp$47 == 0)
            tmp_if_expr$49 = (_Bool)1;

          else
          {
            return_value_strcasecmp$48=strcasecmp(arg, "--hostlist");
            tmp_if_expr$49 = return_value_strcasecmp$48 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$49)
          {
            char *return_value_getarg$8;
            return_value_getarg$8=getarg(opt, &argv);
            snprintf(set.host_id_list, (unsigned long int)65535, "%s", return_value_getarg$8);
          }

          else
          {
            return_value_strcmp$40=strcmp(arg, "-h");
            if(return_value_strcmp$40 == 0)
              tmp_if_expr$42 = (_Bool)1;

            else
            {
              return_value_strcmp$41=strcmp(arg, "-v");
              tmp_if_expr$42 = return_value_strcmp$41 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$42)
              tmp_if_expr$44 = (_Bool)1;

            else
            {
              return_value_strcmp$43=strcmp(arg, "--help");
              tmp_if_expr$44 = return_value_strcmp$43 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$44)
              tmp_if_expr$46 = (_Bool)1;

            else
            {
              return_value_strcmp$45=strcmp(arg, "--version");
              tmp_if_expr$46 = return_value_strcmp$45 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$46)
            {
              display_help();
              exit(0);
            }

            else
            {
              return_value_strcmp$37=strcmp(arg, "-O");
              if(return_value_strcmp$37 == 0)
                tmp_if_expr$39 = (_Bool)1;

              else
              {
                return_value_strcasecmp$38=strcasecmp(arg, "--option");
                tmp_if_expr$39 = return_value_strcasecmp$38 == 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$39)
              {
                char *setting;
                setting=getarg(opt, &argv);
                char *value;
                value=strchr(setting, 58);
                if(!(*value == 0))
                {
                  tmp_post$9 = value;
                  value = value + 1l;
                  *tmp_post$9 = (char)0;
                }

                else
                  die("ERROR: -O requires setting:value");
                set_option(setting, value);
              }

              else
              {
                return_value_strcmp$32=strcmp(arg, "-R");
                if(return_value_strcmp$32 == 0)
                  tmp_if_expr$34 = (_Bool)1;

                else
                {
                  return_value_strcmp$33=strcmp(arg, "--readonly");
                  tmp_if_expr$34 = return_value_strcmp$33 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$34)
                  tmp_if_expr$36 = (_Bool)1;

                else
                {
                  return_value_strcmp$35=strcmp(arg, "--read-only");
                  tmp_if_expr$36 = return_value_strcmp$35 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$36)
                  set.SQL_readonly = 1;

                else
                {
                  return_value_strcmp$29=strcmp(arg, "-C");
                  if(return_value_strcmp$29 == 0)
                    tmp_if_expr$31 = (_Bool)1;

                  else
                  {
                    return_value_strcmp$30=strcmp(arg, "--conf");
                    tmp_if_expr$31 = return_value_strcmp$30 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$31)
                  {
                    char *return_value_getarg$10;
                    return_value_getarg$10=getarg(opt, &argv);
                    conf_file=strdup(return_value_getarg$10);
                  }

                  else
                  {
                    return_value_strcmp$26=strcmp(arg, "-S");
                    if(return_value_strcmp$26 == 0)
                      tmp_if_expr$28 = (_Bool)1;

                    else
                    {
                      return_value_strcmp$27=strcmp(arg, "--stdout");
                      tmp_if_expr$28 = return_value_strcmp$27 == 0 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr$28)
                      set_option("log_destination", "STDOUT");

                    else
                    {
                      return_value_strcmp$23=strcmp(arg, "-L");
                      if(return_value_strcmp$23 == 0)
                        tmp_if_expr$25 = (_Bool)1;

                      else
                      {
                        return_value_strcmp$24=strcmp(arg, "--log");
                        tmp_if_expr$25 = return_value_strcmp$24 == 0 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr$25)
                      {
                        char *return_value_getarg$11;
                        return_value_getarg$11=getarg(opt, &argv);
                        set_option("log_destination", return_value_getarg$11);
                      }

                      else
                      {
                        return_value_strcmp$20=strcmp(arg, "-V");
                        if(return_value_strcmp$20 == 0)
                          tmp_if_expr$22 = (_Bool)1;

                        else
                        {
                          return_value_strcmp$21=strcmp(arg, "--verbosity");
                          tmp_if_expr$22 = return_value_strcmp$21 == 0 ? (_Bool)1 : (_Bool)0;
                        }
                        if(tmp_if_expr$22)
                        {
                          char *return_value_getarg$12;
                          return_value_getarg$12=getarg(opt, &argv);
                          set_option("log_verbosity", return_value_getarg$12);
                        }

                        else
                        {
                          return_value_strcmp$17=strcmp(arg, "--snmponly");
                          if(return_value_strcmp$17 == 0)
                            tmp_if_expr$19 = (_Bool)1;

                          else
                          {
                            return_value_strcmp$18=strcmp(arg, "--snmp-only");
                            tmp_if_expr$19 = return_value_strcmp$18 == 0 ? (_Bool)1 : (_Bool)0;
                          }
                          if(tmp_if_expr$19)
                            set.snmponly = 1;

                          else
                          {
                            if(!(set.start_host_id >= 0))
                            {
                              return_value_all_digits$15=all_digits(arg);
                              tmp_if_expr$16 = return_value_all_digits$15 != 0 ? (_Bool)1 : (_Bool)0;
                            }

                            else
                              tmp_if_expr$16 = (_Bool)0;
                            if(tmp_if_expr$16)
                              set.start_host_id=atoi(arg);

                            else
                            {
                              if(!(set.end_host_id >= 0))
                              {
                                return_value_all_digits$13=all_digits(arg);
                                tmp_if_expr$14 = return_value_all_digits$13 != 0 ? (_Bool)1 : (_Bool)0;
                              }

                              else
                                tmp_if_expr$14 = (_Bool)0;
                              if(tmp_if_expr$14)
                                set.end_host_id=atoi(arg);

                              else
                                die("ERROR: %s is an unknown command-line parameter", arg);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  unsigned long int return_value_strlen$59;
  if(!(set.start_host_id >= 0 == set.end_host_id >= 0))
  {
    return_value_strlen$59=strlen(set.host_id_list);
    if(return_value_strlen$59 == 0ul)
      die("ERROR: must provide both -f/-l, a hostlist (-H/--hostlist), or neither");

  }

  if(!(set.end_host_id >= set.start_host_id))
    die("ERROR: Invalid row spec; first host_id must be less than the second");

  if(!(conf_file == ((char *)NULL)))
  {
    signed int return_value_read_spine_config$60;
    return_value_read_spine_config$60=read_spine_config(conf_file);
    if(!(return_value_read_spine_config$60 >= 0))
      die("ERROR: Could not read config file: %s", conf_file);

    else
      valid_conf_file = 1;
  }

  else
  {
    void *return_value_calloc$61;
    return_value_calloc$61=calloc((unsigned long int)4, (unsigned long int)1024);
    conf_file = (char *)return_value_calloc$61;
    if(conf_file == ((char *)NULL))
      die("ERROR: Fatal malloc error: spine.c conf_file!");

    i = 0;
    for( ; !(i >= 4); i = i + 1)
    {
      snprintf(conf_file, (unsigned long int)1024, "%s%s", (const void *)config_paths[(signed long int)i], (const void *)"spine.conf");
      signed int return_value_read_spine_config$62;
      return_value_read_spine_config$62=read_spine_config(conf_file);
      if(return_value_read_spine_config$62 >= 0)
      {
        valid_conf_file = 1;
        break;
      }

      if(i == 4)
        snprintf(conf_file, (unsigned long int)1024, "%s%s", (const void *)config_paths[(signed long int)0], (const void *)"spine.conf");

    }
  }
  if(!(valid_conf_file == 0))
    read_config_options();

  else
    die("FATAL: Unable to read configuration file!");
  if(set.poller_interval == 0)
    set.poller_interval = 300;

  internal_thread_sleep = (EXTERNAL_THREAD_SLEEP * (signed long int)set.num_parent_processes) / (signed long int)50;
  db_connect(set.dbdb, &mysql);
  signed int return_value_spine_log$63;
  if(set.log_level == 5)
  {
    if(set.log_level >= 5)
    {
      return_value_spine_log$63=spine_log("Version %s starting", (const void *)"0.8.8b");
      if(!(return_value_spine_log$63 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
  }

  else
    if(set.stdout_notty == 0)
      printf("SPINE: Version %s starting\n", (const void *)"0.8.8b");

  unsigned int return_value_mysql_thread_safe$64;
  return_value_mysql_thread_safe$64=mysql_thread_safe();
  if(!(return_value_mysql_thread_safe$64 == 0u))
  {
    if(set.log_level == 5)
      spine_log("DEBUG: MySQL is Thread Safe!");

  }

  else
    spine_log("WARNING: MySQL is NOT Thread Safe!");
  checkAsRoot();
  signed int return_value_spine_log$65;
  if(set.log_level >= 5)
  {
    return_value_spine_log$65=spine_log("SPINE: Initializing Net-SNMP API");
    if(!(return_value_spine_log$65 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  snmp_spine_init();
  signed int return_value_spine_log$66;
  if(set.log_level >= 5)
  {
    return_value_spine_log$66=spine_log("SPINE: Initializing PHP Script Server(s)");
    if(!(return_value_spine_log$66 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  set.parent_fork = 1;
  if(!(set.php_required == 0))
  {
    php_init(999);
    set.php_initialized = 1;
    set.php_current_server = 0;
  }

  result=db_query(&mysql, "SHOW COLUMNS FROM host LIKE 'poller_id'");
  unsigned long long int return_value_mysql_num_rows$67;
  return_value_mysql_num_rows$67=mysql_num_rows(result);
  if(!(return_value_mysql_num_rows$67 == 0ull))
    set.poller_id_exists = 1;

  else
  {
    set.poller_id_exists = 0;
    if(set.poller_id >= 1)
      spine_log("WARNING: PollerID > 0, but 'host' table does NOT contain the poller_id column!!");

  }
  result=db_query(&mysql, "SHOW COLUMNS FROM host LIKE 'device_threads'");
  unsigned long long int return_value_mysql_num_rows$68;
  return_value_mysql_num_rows$68=mysql_num_rows(result);
  if(!(return_value_mysql_num_rows$68 == 0ull))
    set.device_threads_exists = 1;

  else
    set.device_threads_exists = 0;
  signed int return_value_spine_log$69;
  signed int return_value_spine_log$70;
  if(!(set.device_threads_exists == 0))
  {
    if(set.log_level >= 3)
    {
      return_value_spine_log$69=spine_log("NOTE: Spine will support multithread device polling.");
      if(!(return_value_spine_log$69 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
  }

  else
    if(set.log_level >= 3)
    {
      return_value_spine_log$70=spine_log("NOTE: Spine did not detect multithreaded device polling.");
      if(!(return_value_spine_log$70 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
  if(!(set.device_threads_exists == 0))
  {
    signed int return_value_sprintf$71;
    return_value_sprintf$71=sprintf(qp, "SELECT id, device_threads FROM host");
    qp = qp + (signed long int)return_value_sprintf$71;
  }

  else
  {
    signed int return_value_sprintf$72;
    return_value_sprintf$72=sprintf(qp, "SELECT id, '1' as device_threads FROM host");
    qp = qp + (signed long int)return_value_sprintf$72;
  }
  signed int return_value_sprintf$73;
  return_value_sprintf$73=sprintf(qp, " WHERE disabled=''");
  qp = qp + (signed long int)return_value_sprintf$73;
  unsigned long int return_value_strlen$76;
  return_value_strlen$76=strlen(set.host_id_list);
  if(return_value_strlen$76 == 0ul)
  {
    signed int return_value_append_hostrange$74;
    return_value_append_hostrange$74=append_hostrange(qp, "id");
    qp = qp + (signed long int)return_value_append_hostrange$74;
  }

  else
  {
    signed int return_value_sprintf$75;
    return_value_sprintf$75=sprintf(qp, " AND id IN(%s)", (const void *)set.host_id_list);
    qp = qp + (signed long int)return_value_sprintf$75;
  }
  if(!(set.poller_id_exists == 0))
  {
    signed int return_value_sprintf$77;
    return_value_sprintf$77=sprintf(qp, " AND host.poller_id=%i", set.poller_id);
    qp = qp + (signed long int)return_value_sprintf$77;
  }

  signed int return_value_sprintf$78;
  return_value_sprintf$78=sprintf(qp, " ORDER BY id");
  qp = qp + (signed long int)return_value_sprintf$78;
  result=db_query(&mysql, querybuf);
  if(set.poller_id == 0)
  {
    unsigned long long int return_value_mysql_num_rows$79;
    return_value_mysql_num_rows$79=mysql_num_rows(result);
    num_rows = (signed int)(return_value_mysql_num_rows$79 + (unsigned long int)1);
  }

  else
  {
    unsigned long long int return_value_mysql_num_rows$80;
    return_value_mysql_num_rows$80=mysql_num_rows(result);
    num_rows = (signed int)return_value_mysql_num_rows$80;
  }
  void *return_value_malloc$81;
  return_value_malloc$81=malloc((unsigned long int)num_rows * sizeof(unsigned long int) /*8ul*/ );
  threads = (unsigned long int *)return_value_malloc$81;
  if(threads == ((unsigned long int *)NULL))
    die("ERROR: Fatal malloc error: spine.c threads!");

  void *return_value_malloc$82;
  return_value_malloc$82=malloc((unsigned long int)num_rows * sizeof(signed int) /*4ul*/ );
  ids = (signed int *)return_value_malloc$82;
  if(ids == ((signed int *)NULL))
    die("ERROR: Fatal malloc error: spine.c host id's!");

  signed int return_value_spine_log$83;
  signed int return_value_spine_log$85;
  if(set.pre087g == 0u)
  {
    if(set.log_level >= 3)
    {
      return_value_spine_log$83=spine_log("NOTE: Spine is behaving in a 0.8.7g+ manner");
      if(!(return_value_spine_log$83 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
    signed int return_value_getpid$84;
    return_value_getpid$84=getpid();
    snprintf(querybuf, (unsigned long int)65535, "INSERT INTO poller_time (poller_id, pid, start_time, end_time) VALUES (%i, %i, NOW(), '0000-00-00 00:00:00')", set.poller_id, return_value_getpid$84);
    db_insert(&mysql, querybuf);
  }

  else
    if(set.log_level >= 3)
    {
      return_value_spine_log$85=spine_log("NOTE: Spine is behaving in a PRE 0.8.7g manner");
      if(!(return_value_spine_log$85 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, 1);
  init_mutexes();
  signed int return_value_spine_log$86;
  if(set.log_level >= 5)
  {
    return_value_spine_log$86=spine_log("DEBUG: Initial Value of Active Threads is %i", active_threads);
    if(!(return_value_spine_log$86 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  set.parent_fork = 0;
  device_threads = 1;
  current_thread = 0;
  if(set.poller_id == 0)
  {
    host_id = 0;
    change_host = 0;
  }

  else
    change_host = 1;
  void *return_value_malloc$87;
  signed int return_value_spine_log$88;
  signed int return_value_spine_log$89;
  while(canexit == 0 && !(device_counter >= num_rows))
  {
    while(canexit == 0 && !(active_threads >= set.threads) && !(device_counter >= num_rows))
    {
      mutex_status=thread_mutex_trylock(1);
      switch(mutex_status)
      {
        case 0:
        {
          last_active_threads = active_threads;
          if(!(change_host == 0))
          {
            mysql_row=mysql_fetch_row(result);
            host_id=atoi(mysql_row[(signed long int)0]);
            device_threads=atoi(mysql_row[(signed long int)1]);
            current_thread = 1;
          }

          else
            current_thread = current_thread + 1;
          if(current_thread >= device_threads)
            change_host = 1;

          else
            change_host = 0;
          if(device_threads >= 2)
          {
            if(current_thread == 1)
            {
              snprintf(querybuf, (unsigned long int)65535, "SELECT CEIL(COUNT(*)/%i) FROM poller_item WHERE host_id=%i", device_threads, host_id);
              tresult=db_query(&mysql, querybuf);
              mysql_row=mysql_fetch_row(tresult);
              itemsPT=atoi(mysql_row[(signed long int)0]);
              if(!(host_time == ((char *)NULL)))
                free((void *)host_time);

              host_time=get_host_poll_time();
            }

          }

          else
          {
            itemsPT = 0;
            if(!(host_time == ((char *)NULL)))
              free((void *)host_time);

            host_time=get_host_poll_time();
          }
          return_value_malloc$87=malloc(sizeof(struct poller_thread) /*24ul*/ );
          poller_details = (struct poller_thread *)return_value_malloc$87;
          if(poller_details == ((struct poller_thread *)NULL))
            die("ERROR: Fatal malloc error: spine.c poller_details!");

          poller_details->host_id = host_id;
          poller_details->host_thread = current_thread;
          poller_details->last_host_thread = device_threads;
          poller_details->host_data_ids = itemsPT;
          poller_details->host_time = host_time;
          thread_ready = 0;
          thread_status=pthread_create(&threads[(signed long int)device_counter], &attr, child, (void *)poller_details);
          switch(thread_status)
          {
            case 0:
            {
              if(set.log_level >= 5)
              {
                return_value_spine_log$88=spine_log("DEBUG: Valid Thread to be Created");
                if(!(return_value_spine_log$88 == 0))
                  (_Bool)1;

                else
                  (_Bool)0;
              }

              else
                (_Bool)0;
              if(!(change_host == 0))
                device_counter = device_counter + 1;

              active_threads = active_threads + 1;
              while(thread_ready == 0)
                usleep((unsigned int)internal_thread_sleep);
              if(set.log_level >= 5)
              {
                return_value_spine_log$89=spine_log("DEBUG: The Value of Active Threads is %i", active_threads);
                if(!(return_value_spine_log$89 == 0))
                  (_Bool)1;

                else
                  (_Bool)0;
              }

              else
                (_Bool)0;
              break;
            }
            case 11:
            {
              spine_log("ERROR: The System Lacked the Resources to Create a Thread");
              break;
            }
            case 14:
            {
              spine_log("ERROR: The Thread or Attribute were Invalid");
              break;
            }
            case 22:
            {
              spine_log("ERROR: The Thread Attribute is Not Initialized");
              break;
            }
            default:
              spine_log("ERROR: Unknown Thread Creation Error");
          }
          thread_mutex_unlock(1);
          if(poller_counter >= 20)
          {
            current_time=get_time_as_double();
            if(current_time + -begin_time + .2 > (double)set.poller_interval)
            {
              spine_log("ERROR: Spine Timed Out While Processing Hosts Internal");
              canexit = 1;
              break;
            }

            poller_counter = 0;
          }

          else
            poller_counter = poller_counter + 1;
          break;
        }
        case 35:
        {
          spine_log("ERROR: Deadlock Occured");
          break;
        }
        case 16:
          break;
        case 22:
        {
          spine_log("ERROR: Attempt to Unlock an Uninitialized Mutex");
          break;
        }
        case 14:
        {
          spine_log("ERROR: Attempt to Unlock an Invalid Mutex");
          break;
        }
        default:
          spine_log("ERROR: Unknown Mutex Lock Error Code Returned");
      }
      if(poller_counter >= 20)
      {
        current_time=get_time_as_double();
        if(current_time + -begin_time + .2 > (double)set.poller_interval)
        {
          spine_log("ERROR: Spine Timed Out While Processing Hosts Internal");
          canexit = 1;
          break;
        }

        poller_counter = 0;
      }

      else
        poller_counter = poller_counter + 1;
    }
    usleep((unsigned int)internal_thread_sleep);
  }
  while(canexit == 0)
  {
    signed int return_value_thread_mutex_trylock$90;
    return_value_thread_mutex_trylock$90=thread_mutex_trylock(1);
    if(return_value_thread_mutex_trylock$90 == 0)
    {
      last_active_threads = active_threads;
      if(active_threads == 0)
        canexit = 1;

      thread_mutex_unlock(1);
    }

    usleep((unsigned int)EXTERNAL_THREAD_SLEEP);
    if(poller_counter >= 20)
    {
      current_time=get_time_as_double();
      if(current_time + -begin_time + .2 > (double)set.poller_interval)
      {
        spine_log("ERROR: Spine Timed Out While Processing Hosts Internal");
        canexit = 1;
        break;
      }

      poller_counter = 0;
    }

    else
      poller_counter = poller_counter + 1;
  }
  set.parent_fork = 1;
  gettimeofday(&now, (struct timezone *)(void *)0);
  db_insert(&mysql, "replace into settings (name,value) values ('date',NOW())");
  if(!(set.pre087g == 0u))
  {
    signed int return_value_getpid$91;
    return_value_getpid$91=getpid();
    snprintf(querybuf, (unsigned long int)65535, "INSERT INTO poller_time (poller_id, pid, start_time, end_time) VALUES (%i, %i, NOW(), NOW())", set.poller_id, return_value_getpid$91);
  }

  else
  {
    signed int return_value_getpid$92;
    return_value_getpid$92=getpid();
    snprintf(querybuf, (unsigned long int)65535, "UPDATE poller_time SET end_time=NOW() WHERE poller_id=%i AND pid=%i", set.poller_id, return_value_getpid$92);
  }
  db_insert(&mysql, querybuf);
  pthread_attr_destroy(&attr);
  signed int return_value_spine_log$93;
  if(set.log_level >= 5)
  {
    return_value_spine_log$93=spine_log("DEBUG: Thread Cleanup Complete");
    if(!(return_value_spine_log$93 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  if(!(set.php_required == 0))
    php_close(999);

  signed int return_value_spine_log$94;
  if(set.log_level >= 5)
  {
    return_value_spine_log$94=spine_log("DEBUG: PHP Script Server Pipes Closed");
    if(!(return_value_spine_log$94 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  free((void *)threads);
  free((void *)ids);
  free((void *)conf_file);
  signed int return_value_spine_log$95;
  if(set.log_level >= 5)
  {
    return_value_spine_log$95=spine_log("DEBUG: Allocated Variable Memory Freed");
    if(!(return_value_spine_log$95 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  mysql_free_result(result);
  mysql_close(&mysql);
  signed int return_value_spine_log$96;
  if(set.log_level >= 5)
  {
    return_value_spine_log$96=spine_log("DEBUG: MYSQL Free & Close Completed");
    if(!(return_value_spine_log$96 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  snmp_spine_close();
  signed int return_value_spine_log$97;
  if(set.log_level >= 5)
  {
    return_value_spine_log$97=spine_log("DEBUG: Net-SNMP Close Completed");
    if(!(return_value_spine_log$97 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  end_time = (double)now.tv_sec + (double)now.tv_usec / (double)1000000;
  if(set.log_level >= 3)
    spine_log("Time: %.4f s, Threads: %i, Hosts: %i", end_time - begin_time, set.threads, num_rows);

  else
    if(set.stdout_notty == 0)
      fprintf(stdout, "SPINE: Time: %.4f s, Threads: %i, Hosts: %i\n", end_time - begin_time, set.threads, num_rows);

  uninstall_spine_signal_handler();
  exit(0);
}

// nft_pchild
// file nft_popen.h line 57
extern signed int nft_pchild(signed int fd)
{
  struct pid *cur;
  signed int pid = 0;
  pthread_mutex_lock(&ListMutex);
  cur = PidList;
  for( ; !(cur == ((struct pid *)NULL)); cur = cur->next)
    if(cur->fd == fd)
    {
      pid = cur->pid;
      break;
    }

  pthread_mutex_unlock(&ListMutex);
  if(cur == ((struct pid *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 9;
    return -1;
  }

  return pid;
}

// nft_pclose
// file nft_popen.h line 70
extern signed int nft_pclose(signed int fd)
{
  struct pid *cur;
  signed int pstat;
  signed int pid;
  pthread_mutex_lock(&ListMutex);
  cur = PidList;
  for( ; !(cur == ((struct pid *)NULL)); cur = cur->next)
    if(cur->fd == fd)
      break;

  pthread_mutex_unlock(&ListMutex);
  if(cur == ((struct pid *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 9;
    return -1;
  }

  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  do
  {
    struct anonymous$2 __cancel_buf;
    void (*__cancel_routine)(void *) = close_cleanup;
    void *__cancel_arg = (void *)cur;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      close(fd);
      cur->fd = -1;
      do
      {
        pid=waitpid(cur->pid, &pstat, 0);
        if(pid == -1)
        {
          return_value___errno_location$2=__errno_location();
          tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$3 = (_Bool)0;
      }
      while(tmp_if_expr$3);

    __CPROVER_DUMP_L9:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  return pid == -1 ? -1 : pstat;
}

// nft_popen
// file nft_popen.h line 45
extern signed int nft_popen(const char *command, const char *type)
{
  struct pid *cur;
  struct pid *p;
  signed int pdes[2l];
  signed int fd;
  signed int pid;
  signed int twoway;
  char *argv[4l];
  signed int cancel_state;
  signed int retry_count = 0;
  char *return_value_strchr$4;
  return_value_strchr$4=strchr(type, 43);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(!(return_value_strchr$4 == ((char *)NULL)))
  {
    twoway = 1;
    type = "r+";
  }

  else
  {
    twoway = 0;
    if(!((signed int)*type == 114))
      tmp_if_expr$2 = (signed int)*type != 119 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = type[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 22;
      return -1;
    }

  }
  signed int return_value_pipe$5;
  return_value_pipe$5=pipe(pdes);
  signed int *return_value___errno_location$7;
  if(!(return_value_pipe$5 >= 0))
    return -1;

  else
  {
    pthread_setcancelstate(1, &cancel_state);
    void *return_value_malloc$6;
    return_value_malloc$6=malloc(sizeof(struct pid) /*16ul*/ );
    cur = (struct pid *)return_value_malloc$6;
    if(cur == ((struct pid *)NULL))
    {
      close(pdes[(signed long int)0]);
      close(pdes[(signed long int)1]);
      pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
      return -1;
    }

    else
    {
      argv[(signed long int)0] = "sh";
      argv[(signed long int)1] = "-c";
      argv[(signed long int)2] = (char *)command;
      argv[(signed long int)3] = (char *)(void *)0;
      pthread_mutex_lock(&ListMutex);
      do
      {

      retry:
        ;
        pid=vfork();
        if(!(pid == -1))
        {
          if(pid == 0)
            goto __CPROVER_DUMP_L16;

          goto __CPROVER_DUMP_L25;
        }

        return_value___errno_location$7=__errno_location();
        if(!(*return_value___errno_location$7 == 11))
        {
          if(*return_value___errno_location$7 == 12)
            goto __CPROVER_DUMP_L13;

          goto __CPROVER_DUMP_L15;
        }

        if(!(retry_count >= 3))
        {
          retry_count = retry_count + 1;
          usleep((unsigned int)50000);
          goto retry;
        }

        else
          spine_log("ERROR: SCRIPT: Cound not fork. Out of Resources nft_popen.c");

      __CPROVER_DUMP_L13:
        ;
        if(retry_count >= 3)
          break;

        retry_count = retry_count + 1;
        usleep((unsigned int)50000);
      }
      while((_Bool)1);
      spine_log("ERROR: SCRIPT Cound not fork. Out of Memory nft_popen.c");

    __CPROVER_DUMP_L15:
      ;
      spine_log("ERROR: SCRIPT Cound not fork. Unknown Reason nft_popen.c");
      close(pdes[(signed long int)0]);
      close(pdes[(signed long int)1]);
      pthread_mutex_unlock(&ListMutex);
      pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
      return -1;

    __CPROVER_DUMP_L16:
      ;
      if((signed int)*type == 114)
      {
        close(pdes[(signed long int)0]);
        if(!(pdes[1l] == 1))
        {
          dup2(pdes[(signed long int)1], 1);
          close(pdes[(signed long int)1]);
          if(!(twoway == 0))
            dup2(1, 0);

        }

        else
          if(!(twoway == 0))
          {
            if(!(pdes[1l] == 0))
              dup2(pdes[(signed long int)1], 0);

          }

      }

      else
      {
        if(!(pdes[0l] == 0))
        {
          dup2(pdes[(signed long int)0], 0);
          close(pdes[(signed long int)0]);
        }

        close(pdes[(signed long int)1]);
      }
      p = PidList;
      for( ; !(p == ((struct pid *)NULL)); p = p->next)
        close(p->fd);
      execve("/bin/sh", argv, environ);
      _exit(127);

    __CPROVER_DUMP_L25:
      ;
      if((signed int)*type == 114)
      {
        fd = pdes[(signed long int)0];
        close(pdes[(signed long int)1]);
      }

      else
      {
        fd = pdes[(signed long int)1];
        close(pdes[(signed long int)0]);
      }
      cur->fd = fd;
      cur->pid = pid;
      cur->next = PidList;
      PidList = cur;
      pthread_mutex_unlock(&ListMutex);
      pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
      return fd;
    }
  }
}

// parse_action
// file keywords.c line 188
extern signed int parse_action(const char *word, signed int dflt)
{
  signed int return_value_find_keyword_by_word$1;
  return_value_find_keyword_by_word$1=find_keyword_by_word(actions, word, dflt);
  return return_value_find_keyword_by_word$1;
}

// parse_log_level
// file keywords.c line 172
extern signed int parse_log_level(const char *word, signed int dflt)
{
  signed int return_value_find_keyword_by_word$1;
  return_value_find_keyword_by_word$1=find_keyword_by_word(log_level, word, dflt);
  return return_value_find_keyword_by_word$1;
}

// parse_logdest
// file keywords.h line 38
extern signed int parse_logdest(const char *word, signed int dflt)
{
  signed int return_value_find_keyword_by_word$1;
  return_value_find_keyword_by_word$1=find_keyword_by_word(logdest, word, dflt);
  return return_value_find_keyword_by_word$1;
}

// php_close
// file php.h line 37
extern void php_close(signed int php_process)
{
  signed int i;
  signed int num_processes;
  signed long int bytes;
  if(php_process == 999)
    num_processes = set.php_servers;

  else
    num_processes = 1;
  i = 0;
  signed int return_value_spine_log$1;
  for( ; !(i >= num_processes); i = i + 1)
  {
    struct php_processes *phpp;
    if(set.log_level >= 5)
    {
      return_value_spine_log$1=spine_log("DEBUG: SS[%i] Script Server Shutdown Started", i);
      if(!(return_value_spine_log$1 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
    if(php_process == 999)
      phpp = &php_processes[(signed long int)i];

    else
      phpp = &php_processes[(signed long int)php_process];
    if(phpp->php_write_fd >= 0)
    {
      unsigned long int return_value_strlen$2;
      static const char quit[7l] = { 'q', 'u', 'i', 't', '\r', '\n', 0 };
      return_value_strlen$2=strlen(quit);
      bytes=write(phpp->php_write_fd, (const void *)quit, return_value_strlen$2);
      close(phpp->php_write_fd);
      phpp->php_write_fd = -1;
      usleep((unsigned int)50000);
    }

    if(phpp->php_pid >= 2)
      kill(phpp->php_pid, 15);

    close(phpp->php_read_fd);
    phpp->php_read_fd = -1;
  }
}

// php_cmd
// file php.h line 34
extern char * php_cmd(const char *php_command, signed int php_process)
{
  char *result_string;
  char command[1024l];
  signed long int bytes;
  signed int retries = 0;
  /* assertion php_command != 0 */
  assert(php_command != ((const char *)NULL));
  snprintf(command, (unsigned long int)1024, "%s\r\n", php_command);
  switch(php_process)
  {
    case 0:
    {
      thread_mutex_lock(7);
      break;
    }
    case 1:
    {
      thread_mutex_lock(8);
      break;
    }
    case 2:
    {
      thread_mutex_lock(9);
      break;
    }
    case 3:
    {
      thread_mutex_lock(10);
      break;
    }
    case 4:
    {
      thread_mutex_lock(11);
      break;
    }
    case 5:
    {
      thread_mutex_lock(12);
      break;
    }
    case 6:
    {
      thread_mutex_lock(13);
      break;
    }
    case 7:
    {
      thread_mutex_lock(14);
      break;
    }
    case 8:
    {
      thread_mutex_lock(15);
      break;
    }
    case 9:
      thread_mutex_lock(16);
  }
  unsigned long int return_value_strlen$1;
  do
  {

  retry:
    ;
    return_value_strlen$1=strlen(command);
    bytes=write((php_processes + (signed long int)php_process)->php_write_fd, (const void *)command, return_value_strlen$1);
    if(bytes >= 1l)
      goto __CPROVER_DUMP_L12;

    result_string=strdup("U");
    spine_log("ERROR: SS[%i] PHP Script Server communications lost.  Restarting PHP Script Server", php_process);
    php_close(php_process);
    php_init(php_process);
    retries = retries + 1;
  }
  while(!(retries >= 3));
  goto __CPROVER_DUMP_L14;

__CPROVER_DUMP_L12:
  ;
  result_string=php_readpipe(php_process);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(result_string);
  if(return_value_strlen$2 == 0ul)
  {
    result_string[(signed long int)0] = (char)85;
    result_string[(signed long int)1] = (char)0;
  }


__CPROVER_DUMP_L14:
  ;
  switch(php_process)
  {
    case 0:
    {
      thread_mutex_unlock(7);
      break;
    }
    case 1:
    {
      thread_mutex_unlock(8);
      break;
    }
    case 2:
    {
      thread_mutex_unlock(9);
      break;
    }
    case 3:
    {
      thread_mutex_unlock(10);
      break;
    }
    case 4:
    {
      thread_mutex_unlock(11);
      break;
    }
    case 5:
    {
      thread_mutex_unlock(12);
      break;
    }
    case 6:
    {
      thread_mutex_unlock(13);
      break;
    }
    case 7:
    {
      thread_mutex_unlock(14);
      break;
    }
    case 8:
    {
      thread_mutex_unlock(15);
      break;
    }
    case 9:
      thread_mutex_unlock(16);
  }
  return result_string;
}

// php_get_process
// file php.h line 38
extern signed int php_get_process(void)
{
  signed int i;
  thread_mutex_lock(6);
  if(set.php_current_server >= set.php_servers)
    set.php_current_server = 0;

  i = set.php_current_server;
  set.php_current_server = set.php_current_server + 1;
  thread_mutex_unlock(6);
  return i;
}

// php_init
// file php.h line 36
extern signed int php_init(signed int php_process)
{
  signed int cacti2php_pdes[2l];
  signed int php2cacti_pdes[2l];
  signed int pid;
  char poller_id[16l];
  char *argv[6l];
  signed int cancel_state;
  char *result_string = ((char *)NULL);
  signed int num_processes;
  signed int i;
  signed int retry_count = 0;
  if(php_process == 999)
    num_processes = set.php_servers;

  else
    num_processes = 1;
  i = 0;
  signed int return_value_spine_log$1;
  signed int return_value_spine_log$4;
  signed int *return_value___errno_location$5;
  signed int return_value_spine_log$6;
  signed int return_value_spine_log$7;
  signed int return_value_spine_log$8;
  for( ; !(i >= num_processes); i = i + 1)
  {
    if(set.log_level >= 5)
    {
      return_value_spine_log$1=spine_log("DEBUG: SS[%i] PHP Script Server Routine Starting", i);
      if(!(return_value_spine_log$1 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
    signed int return_value_pipe$2;
    return_value_pipe$2=pipe(cacti2php_pdes);
    if(!(return_value_pipe$2 >= 0))
    {
      spine_log("ERROR: SS[%i] Could not allocate php server pipes", i);
      return 0;
    }

    signed int return_value_pipe$3;
    return_value_pipe$3=pipe(php2cacti_pdes);
    if(!(return_value_pipe$3 >= 0))
    {
      spine_log("ERROR: SS[%i] Could not allocate php server pipes", i);
      return 0;
    }

    pthread_setcancelstate(1, &cancel_state);
    argv[(signed long int)0] = set.path_php;
    argv[(signed long int)1] = "-q";
    argv[(signed long int)2] = set.path_php_server;
    argv[(signed long int)3] = "spine";
    snprintf(poller_id, (unsigned long int)16, "%d", set.poller_id);
    argv[(signed long int)4] = poller_id;
    argv[(signed long int)5] = (char *)(void *)0;
    if(set.log_level >= 5)
    {
      return_value_spine_log$4=spine_log("DEBUG: SS[%i] PHP Script Server About to FORK Child Process", i);
      if(!(return_value_spine_log$4 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
    do
    {

    retry:
      ;
      pid=vfork();
      if(!(pid == -1))
      {
        if(pid == 0)
          goto __CPROVER_DUMP_L20;

        goto __CPROVER_DUMP_L21;
      }

      return_value___errno_location$5=__errno_location();
      if(!(*return_value___errno_location$5 == 11))
      {
        if(*return_value___errno_location$5 == 12)
          goto __CPROVER_DUMP_L17;

        goto __CPROVER_DUMP_L19;
      }

      if(!(retry_count >= 3))
      {
        retry_count = retry_count + 1;
        usleep((unsigned int)50000);
        goto retry;
      }

      else
        spine_log("ERROR: SS[%i] Could not fork PHP Script Server Out of Resources", i);

    __CPROVER_DUMP_L17:
      ;
      if(retry_count >= 3)
        break;

      retry_count = retry_count + 1;
      usleep((unsigned int)50000);
    }
    while((_Bool)1);
    spine_log("ERROR: SS[%i] Could not fork PHP Script Server Out of Memory", i);

  __CPROVER_DUMP_L19:
    ;
    spine_log("ERROR: SS[%i] Could not fork PHP Script Server Unknown Reason", i);
    close(php2cacti_pdes[(signed long int)0]);
    close(php2cacti_pdes[(signed long int)1]);
    close(cacti2php_pdes[(signed long int)0]);
    close(cacti2php_pdes[(signed long int)1]);
    spine_log("ERROR: SS[%i] Could not fork PHP Script Server", i);
    pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
    return 0;

  __CPROVER_DUMP_L20:
    ;
    dup2(cacti2php_pdes[(signed long int)0], 0);
    dup2(php2cacti_pdes[(signed long int)1], 1);
    close(php2cacti_pdes[(signed long int)0]);
    close(php2cacti_pdes[(signed long int)1]);
    close(cacti2php_pdes[(signed long int)0]);
    close(cacti2php_pdes[(signed long int)1]);
    execv(argv[(signed long int)0], argv);
    _exit(127);

  __CPROVER_DUMP_L21:
    ;
    if(set.log_level >= 5)
    {
      return_value_spine_log$6=spine_log("DEBUG: SS[%i] PHP Script Server Child FORK Success", i);
      if(!(return_value_spine_log$6 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
    close(cacti2php_pdes[(signed long int)0]);
    close(php2cacti_pdes[(signed long int)1]);
    if(php_process == 999)
    {
      (php_processes + (signed long int)i)->php_pid = pid;
      (php_processes + (signed long int)i)->php_write_fd = cacti2php_pdes[(signed long int)1];
      (php_processes + (signed long int)i)->php_read_fd = php2cacti_pdes[(signed long int)0];
    }

    else
    {
      (php_processes + (signed long int)php_process)->php_pid = pid;
      (php_processes + (signed long int)php_process)->php_write_fd = cacti2php_pdes[(signed long int)1];
      (php_processes + (signed long int)php_process)->php_read_fd = php2cacti_pdes[(signed long int)0];
    }
    pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
    if(php_process == 999)
      result_string=php_readpipe(i);

    else
      result_string=php_readpipe(php_process);
    char *return_value_strstr$9;
    return_value_strstr$9=strstr(result_string, "Started");
    if(!(return_value_strstr$9 == ((char *)NULL)))
    {
      if(php_process == 999)
      {
        if(set.log_level >= 5)
        {
          return_value_spine_log$7=spine_log("DEBUG: SS[%i] Confirmed PHP Script Server running using readfd[%i], writefd[%i]", i, php2cacti_pdes[(signed long int)0], cacti2php_pdes[(signed long int)1]);
          if(!(return_value_spine_log$7 == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
        (php_processes + (signed long int)i)->php_state = 0;
      }

      else
      {
        if(set.log_level >= 5)
        {
          return_value_spine_log$8=spine_log("DEBUG: SS[%i] Confirmed PHP Script Server running using readfd[%i], writefd[%i]", php_process, php2cacti_pdes[(signed long int)0], cacti2php_pdes[(signed long int)1]);
          if(!(return_value_spine_log$8 == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
        (php_processes + (signed long int)php_process)->php_state = 0;
      }
    }

    else
    {
      spine_log("ERROR: SS[%i] Script Server did not start properly return message was: '%s'", php_process, result_string);
      if(php_process == 999)
        (php_processes + (signed long int)i)->php_state = 1;

      else
        (php_processes + (signed long int)php_process)->php_state = 1;
    }
  }
  free((void *)result_string);
  return 1;
}

// php_readpipe
// file php.c line 151
extern char * php_readpipe(signed int php_process)
{
  struct anonymous$8 fds;
  struct timeval timeout;
  double begin_time = (double)0;
  double end_time = (double)0;
  char *result_string;
  signed int i;
  char *cp;
  char *bptr;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)1024);
  result_string = (char *)return_value_malloc$1;
  if(result_string == ((char *)NULL))
    die("ERROR: Fatal malloc error: php.c php_readpipe!");

  result_string[(signed long int)0] = (char)0;
  begin_time=get_time_as_double();
  timeout.tv_sec = (signed long int)set.script_timeout;
  timeout.tv_usec = (signed long int)0;
  signed int return_value_select$2;
  signed int *return_value___errno_location$3;
  double return_value_floor$4;
  double return_value_rint$5;
  double return_value_rint$6;
  do
  {

  retry:
    ;
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$8) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->__fds_bits[(signed long int)0]) : "memory");
    (&fds)->__fds_bits[(signed long int)((php_processes + (signed long int)php_process)->php_read_fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)((php_processes + (signed long int)php_process)->php_read_fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << (php_processes + (signed long int)php_process)->php_read_fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    return_value_select$2=select((php_processes + (signed long int)php_process)->php_read_fd + 1, &fds, (struct anonymous$8 *)(void *)0, (struct anonymous$8 *)(void *)0, &timeout);
    if(!(return_value_select$2 == -1))
    {
      if(return_value_select$2 == 0)
        goto __CPROVER_DUMP_L12;

      goto __CPROVER_DUMP_L13;
    }

    return_value___errno_location$3=__errno_location();
    if(!(*return_value___errno_location$3 == 9))
    {
      if(*return_value___errno_location$3 == 4)
        goto __CPROVER_DUMP_L5;

      if(*return_value___errno_location$3 == 22)
        goto __CPROVER_DUMP_L8;

      if(*return_value___errno_location$3 == 12)
        goto __CPROVER_DUMP_L9;

      goto __CPROVER_DUMP_L10;
    }

    spine_log("ERROR: SS[%i] An invalid file descriptor was given in one of the sets.", php_process);
    goto __CPROVER_DUMP_L11;

  __CPROVER_DUMP_L5:
    ;
    usleep((unsigned int)2000);
    end_time=get_time_as_double();
    return_value_floor$4=floor((double)set.script_timeout - (end_time - begin_time));
    return_value_rint$5=rint(return_value_floor$4);
    timeout.tv_sec = (signed long int)return_value_rint$5;
    return_value_rint$6=rint((((double)set.script_timeout - (end_time - begin_time)) - (double)timeout.tv_sec) * (double)1000000);
    timeout.tv_usec = (signed long int)return_value_rint$6;
    if(!(end_time + -begin_time < (double)set.script_timeout))
      break;

  }
  while((_Bool)1);
  spine_log("WARNING: SS[%i] The Script Server script timed out while processing EINTR's.", php_process);
  goto __CPROVER_DUMP_L11;

__CPROVER_DUMP_L8:
  ;
  spine_log("ERROR: SS[%i] N is negative or the value contained within timeout is invalid.", php_process);
  goto __CPROVER_DUMP_L11;

__CPROVER_DUMP_L9:
  ;
  spine_log("ERROR: SS[%i] Select was unable to allocate memory for internal tables.", php_process);
  goto __CPROVER_DUMP_L11;

__CPROVER_DUMP_L10:
  ;
  spine_log("ERROR: SS[%i] Unknown fatal select() error", php_process);
  goto __CPROVER_DUMP_L11;

__CPROVER_DUMP_L11:
  ;
  result_string[(signed long int)0] = (char)85;
  result_string[(signed long int)1] = (char)0;
  php_close(php_process);
  php_init(php_process);
  goto __CPROVER_DUMP_L21;

__CPROVER_DUMP_L12:
  ;
  spine_log("WARNING: SS[%i] The PHP Script Server did not respond in time and will therefore be restarted", php_process);
  result_string[(signed long int)0] = (char)85;
  result_string[(signed long int)1] = (char)0;
  php_close(php_process);
  php_init(php_process);
  goto __CPROVER_DUMP_L21;

__CPROVER_DUMP_L13:
  ;
  if(!((fds.__fds_bits[(signed long int)((php_processes + (signed long int)php_process)->php_read_fd / 8)] & (signed long int)(1UL << (php_processes + (signed long int)php_process)->php_read_fd % 8)) == 0l))
  {
    bptr = result_string;
    while((_Bool)1)
    {
      signed long int return_value_read$7;
      return_value_read$7=read((php_processes + (signed long int)php_process)->php_read_fd, (void *)bptr, (unsigned long int)((signed long int)1024 - (bptr - result_string)));
      i = (signed int)return_value_read$7;
      if(!(i >= 1))
      {
        result_string[(signed long int)0] = (char)85;
        result_string[(signed long int)1] = (char)0;
        break;
      }

      bptr = bptr + (signed long int)i;
      *bptr = (char)0;
      cp=strstr(result_string, "\n");
      if(!(cp == ((char *)NULL)))
        break;

      if(bptr >= result_string + 1024l)
      {
        spine_log("ERROR: SS[%i] The Script Server result was longer than the acceptable range", php_process);
        result_string[(signed long int)0] = (char)85;
        result_string[(signed long int)1] = (char)0;
      }

    }
  }

  else
  {
    spine_log("ERROR: SS[%i] The FD was not set as expected", php_process);
    result_string[(signed long int)0] = (char)85;
    result_string[(signed long int)1] = (char)0;
  }
  (php_processes + (signed long int)php_process)->php_state = 0;

__CPROVER_DUMP_L21:
  ;
  return result_string;
}

// ping_host
// file ping.h line 137
extern signed int ping_host(struct host_struct *host, struct ping_results *ping)
{
  signed int ping_result;
  signed int snmp_result;
  ping_result = 0;
  snmp_result = 0;
  _Bool tmp_if_expr$3;
  if(host->availability_method == 1)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = host->availability_method == 3 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = host->availability_method == 4 ? (_Bool)1 : (_Bool)0;
  signed int return_value_spine_log$1;
  if(tmp_if_expr$4)
  {
    if(host->ping_method == 1)
    {
      if(set.icmp_avail == 0)
      {
        if(set.log_level >= 5)
        {
          return_value_spine_log$1=spine_log("Host[%i] DEBUG Falling back to UDP Ping Due to SetUID Issues", host->id);
          if(!(return_value_spine_log$1 == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
        host->ping_method = 2;
      }

    }

    char *return_value_strstr$2;
    return_value_strstr$2=strstr(host->hostname, "localhost");
    if(return_value_strstr$2 == ((char *)NULL))
    {
      if(host->ping_method == 1)
        ping_result=ping_icmp(host, ping);

      else
        if(host->ping_method == 2)
          ping_result=ping_udp(host, ping);

        else
          if(host->ping_method == 3)
            ping_result=ping_tcp(host, ping);

    }

    else
    {
      snprintf(ping->ping_status, (unsigned long int)50, "0.000");
      snprintf(ping->ping_response, (unsigned long int)256, "PING: Host does not require ping");
      ping_result = 3;
    }
  }

  _Bool tmp_if_expr$5;
  if(host->availability_method == 2)
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = host->availability_method == 5 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$6;
  if(tmp_if_expr$5)
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = host->availability_method == 6 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$7;
  if(tmp_if_expr$6)
    tmp_if_expr$7 = (_Bool)1;

  else
    tmp_if_expr$7 = host->availability_method == 1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$8;
  if(tmp_if_expr$7)
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = (host->availability_method == 4 ? (ping_result != 3 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$8)
    snmp_result=ping_snmp(host, ping);

  unsigned long int return_value_strlen$9;
  unsigned long int return_value_strlen$10;
  switch(host->availability_method)
  {
    case 1:
    {
      return_value_strlen$9=strlen(host->snmp_community);
      if(return_value_strlen$9 == 0ul)
      {
        if(!(host->snmp_version >= 3))
        {
          if(ping_result == 3)
            return 3;

          else
            return 1;
        }

      }

      if(ping_result == 3 && snmp_result == 3)
        return 3;

      else
        return 1;
    }
    case 4:
    {
      return_value_strlen$10=strlen(host->snmp_community);
      if(return_value_strlen$10 == 0ul)
      {
        if(!(host->snmp_version >= 3))
        {
          if(ping_result == 3)
            return 3;

          else
            return 1;
        }

      }

      if(snmp_result == 3)
        return 3;

      if(ping_result == 3)
        return 3;

      else
        return 1;
    }
    case 2:

    case 6:

    case 5:
      if(snmp_result == 3)
        return 3;

      else
        return 1;
    case 3:
      if(ping_result == 3)
        return 3;

      else
        return 1;
    case 0:
      return 3;
    default:
      return 1;
  }
}

// ping_icmp
// file ping.c line 235
extern signed int ping_icmp(struct host_struct *host, struct ping_results *ping)
{
  signed int icmp_socket;
  double begin_time;
  double end_time;
  double total_time;
  double host_timeout;
  double one_thousand = 1000.00;
  struct timeval timeout;
  struct sockaddr_in recvname;
  struct sockaddr_in fromname;
  char socket_reply[1024l];
  signed int retry_count;
  char *cacti_msg = "cacti-monitoring-system\0";
  signed int packet_len;
  unsigned int fromlen;
  signed long int return_code;
  struct anonymous$8 socket_fds;
  struct icmp *icmp;
  struct ip *ip;
  struct icmp *pkt;
  unsigned char *packet;
  char *new_hostname;
  signed int return_value_spine_log$1;
  if(set.log_level >= 5)
  {
    return_value_spine_log$1=spine_log("Host[%i] DEBUG: Entering ICMP Ping", host->id);
    if(!(return_value_spine_log$1 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  new_hostname=remove_tcp_udp_from_hostname(host->hostname);
  retry_count = 0;
  while((_Bool)1)
  {
    signed int return_value_hasCaps$2;
    return_value_hasCaps$2=hasCaps();
    if(!(return_value_hasCaps$2 == 1))
    {
      thread_mutex_lock(2);
      seteuid((unsigned int)0);
    }

    icmp_socket=socket(2, 3, 1);
    if(icmp_socket == -1)
    {
      usleep((unsigned int)500000);
      retry_count = retry_count + 1;
      if(retry_count >= 5)
      {
        snprintf(ping->ping_response, (unsigned long int)256, "ICMP: Ping unable to create ICMP Socket");
        snprintf(ping->ping_status, (unsigned long int)50, "down");
        free((void *)new_hostname);
        signed int return_value_hasCaps$4;
        return_value_hasCaps$4=hasCaps();
        if(!(return_value_hasCaps$4 == 1))
        {
          unsigned int return_value_getuid$3;
          return_value_getuid$3=getuid();
          seteuid(return_value_getuid$3);
          thread_mutex_unlock(2);
        }

        return 1;
        break;
      }

    }

    else
      break;
  }
  signed int return_value_hasCaps$6;
  return_value_hasCaps$6=hasCaps();
  if(!(return_value_hasCaps$6 == 1))
  {
    unsigned int return_value_getuid$5;
    return_value_getuid$5=getuid();
    seteuid(return_value_getuid$5);
    thread_mutex_unlock(2);
  }

  host_timeout = (double)host->ping_timeout;
  unsigned long int return_value_strlen$7;
  return_value_strlen$7=strlen(cacti_msg);
  packet_len = (signed int)((unsigned long int)8 + return_value_strlen$7);
  void *return_value_malloc$8;
  return_value_malloc$8=malloc((unsigned long int)packet_len);
  packet = (unsigned char *)return_value_malloc$8;
  if(packet == ((unsigned char *)NULL))
    die("ERROR: Fatal malloc error: ping.c ping_icmp!");

  memset((void *)packet, 0, (unsigned long int)packet_len);
  memset((void *)&fromname, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  memset((void *)&recvname, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  icmp = (struct icmp *)packet;
  icmp->icmp_type = (unsigned char)8;
  icmp->icmp_code = (unsigned char)0;
  signed int return_value_getpid$9;
  return_value_getpid$9=getpid();
  icmp->icmp_hun.ih_idseq.icd_id = (unsigned short int)(return_value_getpid$9 & 0xFFFF);
  thread_mutex_lock(3);
  static unsigned int seq = (unsigned int)0;
  unsigned int tmp_post$10 = seq;
  seq = seq + 1u;
  icmp->icmp_hun.ih_idseq.icd_seq = (unsigned short int)tmp_post$10;
  thread_mutex_unlock(3);
  icmp->icmp_cksum = (unsigned short int)0;
  unsigned long int return_value_strlen$11;
  return_value_strlen$11=strlen(cacti_msg);
  memcpy((void *)(packet + (signed long int)8), (const void *)cacti_msg, return_value_strlen$11);
  icmp->icmp_cksum=get_checksum((void *)packet, packet_len);
  unsigned long int return_value_strlen$27;
  return_value_strlen$27=strlen(host->hostname);
  signed int return_value_select$12;
  signed int return_value_spine_log$13;
  signed int return_value_spine_log$15;
  signed int return_value_spine_log$19;
  if(!(icmp_socket == -1) && !(return_value_strlen$27 == 0ul))
  {
    snprintf(ping->ping_status, (unsigned long int)50, "down");
    snprintf(ping->ping_response, (unsigned long int)256, "default");
    signed int return_value_init_sockaddr$23;
    return_value_init_sockaddr$23=init_sockaddr(&fromname, new_hostname, (unsigned short int)7);
    if(!(return_value_init_sockaddr$23 == 0))
    {
      retry_count = 0;
      total_time = (double)0;
      begin_time = (double)0;
      do
      {
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$8) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&socket_fds)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      (&socket_fds)->__fds_bits[(signed long int)(icmp_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&socket_fds)->__fds_bits[(signed long int)(icmp_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << icmp_socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      while((_Bool)1)
      {
        if(!(host->ping_retries >= retry_count))
        {
          snprintf(ping->ping_response, (unsigned long int)256, "ICMP: Ping timed out");
          snprintf(ping->ping_status, (unsigned long int)50, "down");
          free((void *)new_hostname);
          free((void *)packet);
          close(icmp_socket);
          return 1;
        }

        if(IEEE_FLOAT_EQUAL(total_time, 0.000000))
        {
          timeout.tv_sec = (signed long int)0;
          timeout.tv_usec = (signed long int)(host->ping_timeout * 1000);
          setsockopt(icmp_socket, 1, 20, (const void *)(char *)&timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
          setsockopt(icmp_socket, 1, 21, (const void *)(char *)&timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
          begin_time=get_time_as_double();
        }

        else
          timeout.tv_usec = (signed long int)(((double)host->ping_timeout - total_time) * (double)1000);
        return_code=sendto(icmp_socket, (const void *)packet, (unsigned long int)packet_len, 0, (struct sockaddr *)&fromname, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
        fromlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        do
        {

        keep_listening:
          ;
          return_value_select$12=select(1024, &socket_fds, (struct anonymous$8 *)(void *)0, (struct anonymous$8 *)(void *)0, &timeout);
          return_code = (signed long int)return_value_select$12;
          end_time=get_time_as_double();
          total_time = (end_time - begin_time) * one_thousand;
          if(!(total_time < host_timeout))
            goto __CPROVER_DUMP_L37;

          return_code=recvfrom(icmp_socket, (void *)socket_reply, (unsigned long int)1024, 256, (struct sockaddr *)&recvname, &fromlen);
          if(!(return_code >= 0l))
          {
            signed int *return_value___errno_location$14;
            return_value___errno_location$14=__errno_location();
            if(*return_value___errno_location$14 == 4)
            {
              if(set.log_level >= 5)
              {
                return_value_spine_log$13=spine_log("Host[%i] DEBUG: Received EINTR", host->id);
                if(!(return_value_spine_log$13 == 0))
                  (_Bool)1;

                else
                  (_Bool)0;
              }

              else
                (_Bool)0;
              goto keep_listening;
            }

            break;
          }

          ip = (struct ip *)socket_reply;
          pkt = (struct icmp *)(socket_reply + (signed long int)((signed int)ip->ip_hl << 2));
          if(fromname.sin_addr.s_addr == recvname.sin_addr.s_addr)
          {
            if((signed int)pkt->icmp_type == 0)
            {
              if(set.log_level >= 5)
              {
                return_value_spine_log$15=spine_log("Host[%i] DEBUG: ICMP Host Alive, Try Count:%i, Time:%.4f ms", host->id, retry_count + 1, total_time);
                if(!(return_value_spine_log$15 == 0))
                  (_Bool)1;

                else
                  (_Bool)0;
              }

              else
                (_Bool)0;
              snprintf(ping->ping_response, (unsigned long int)256, "ICMP: Host is Alive");
              snprintf(ping->ping_status, (unsigned long int)50, "%.5f", total_time);
              free((void *)new_hostname);
              free((void *)packet);
              signed int return_value_hasCaps$16;
              return_value_hasCaps$16=hasCaps();
              if(!(return_value_hasCaps$16 == 1))
              {
                thread_mutex_lock(2);
                seteuid((unsigned int)0);
              }

              close(icmp_socket);
              signed int return_value_hasCaps$18;
              return_value_hasCaps$18=hasCaps();
              if(!(return_value_hasCaps$18 == 1))
              {
                unsigned int return_value_getuid$17;
                return_value_getuid$17=getuid();
                seteuid(return_value_getuid$17);
                thread_mutex_unlock(2);
              }

              return 3;
            }

            else
            {
              if(total_time > host_timeout)
              {
                retry_count = retry_count + 1;
                total_time = (double)0;
              }

              goto __CPROVER_DUMP_L43;
            }
            break;
          }

        }
        while((_Bool)1);
        goto __CPROVER_DUMP_L42;

      __CPROVER_DUMP_L37:
        ;
        if(set.log_level >= 5)
        {
          return_value_spine_log$19=spine_log("Host[%i] DEBUG: Exceeded Host Timeout, Retrying", host->id);
          if(!(return_value_spine_log$19 == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;

      __CPROVER_DUMP_L42:
        ;
        total_time = (double)0;
        retry_count = retry_count + 1;
        usleep((unsigned int)1000);

      __CPROVER_DUMP_L43:
        ;
      }
    }

    else
    {
      snprintf(ping->ping_response, (unsigned long int)256, "ICMP: Destination hostname invalid");
      snprintf(ping->ping_status, (unsigned long int)50, "down");
      free((void *)new_hostname);
      free((void *)packet);
      signed int return_value_hasCaps$20;
      return_value_hasCaps$20=hasCaps();
      if(!(return_value_hasCaps$20 == 1))
      {
        thread_mutex_lock(2);
        seteuid((unsigned int)0);
      }

      close(icmp_socket);
      signed int return_value_hasCaps$22;
      return_value_hasCaps$22=hasCaps();
      if(!(return_value_hasCaps$22 == 1))
      {
        unsigned int return_value_getuid$21;
        return_value_getuid$21=getuid();
        seteuid(return_value_getuid$21);
        thread_mutex_unlock(2);
      }

      return 1;
    }
  }

  else
  {
    snprintf(ping->ping_response, (unsigned long int)256, "ICMP: Destination address not specified");
    snprintf(ping->ping_status, (unsigned long int)50, "down");
    free((void *)new_hostname);
    free((void *)packet);
    if(!(icmp_socket == -1))
    {
      signed int return_value_hasCaps$24;
      return_value_hasCaps$24=hasCaps();
      if(!(return_value_hasCaps$24 == 1))
      {
        thread_mutex_lock(2);
        seteuid((unsigned int)0);
      }

      close(icmp_socket);
      signed int return_value_hasCaps$26;
      return_value_hasCaps$26=hasCaps();
      if(!(return_value_hasCaps$26 == 1))
      {
        unsigned int return_value_getuid$25;
        return_value_getuid$25=getuid();
        seteuid(return_value_getuid$25);
        thread_mutex_unlock(2);
      }

    }

    return 1;
  }
}

// ping_snmp
// file ping.c line 156
extern signed int ping_snmp(struct host_struct *host, struct ping_results *ping)
{
  char *poll_result;
  char *oid;
  signed int num_oids_checked = 0;
  double begin_time;
  double end_time;
  double total_time;
  double one_thousand = 1000.00;
  signed int return_value_spine_log$1;
  if(set.log_level >= 5)
  {
    return_value_spine_log$1=spine_log("Host[%i] DEBUG: Entering SNMP Ping", host->id);
    if(!(return_value_spine_log$1 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  _Bool tmp_if_expr$5;
  const char *return_value_snmp_api_errstring$2;
  signed int return_value_spine_log$3;
  if(!(host->snmp_session == NULL))
  {
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(host->snmp_community);
    if(!(return_value_strlen$4 == 0ul))
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = host->snmp_version == 3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
    {
      if(host->availability_method == 6)
        oid=strdup(".1.3");

      else
        if(host->availability_method == 5)
          oid=strdup(".1.3.6.1.2.1.1.1.0");

        else
          oid=strdup(".1.3.6.1.2.1.1.3.0");
      if(oid == ((char *)NULL))
        die("ERROR: malloc(): strdup() oid ping.c failed");

      begin_time=get_time_as_double();
      if(host->availability_method == 6)
        poll_result=snmp_getnext(host, oid);

      else
        poll_result=snmp_get(host, oid);
      end_time=get_time_as_double();
      free((void *)oid);
      total_time = (end_time - begin_time) * one_thousand;
      if(host->snmp_status == -58)
      {
        snprintf(ping->snmp_response, (unsigned long int)256, "Host responded to SNMP");
        snprintf(ping->snmp_status, (unsigned long int)50, "%.5f", total_time);
        free((void *)poll_result);
        return 3;
      }

      else
        if(!(host->snmp_status == 0))
        {
          if(set.log_level >= 3)
          {
            return_value_snmp_api_errstring$2=snmp_api_errstring(host->snmp_status);
            return_value_spine_log$3=spine_log("Host[%i] SNMP Ping Error: %s", host->id, return_value_snmp_api_errstring$2);
            if(!(return_value_spine_log$3 == 0))
              (_Bool)1;

            else
              (_Bool)0;
          }

          else
            (_Bool)0;
          snprintf(ping->snmp_response, (unsigned long int)256, "Host did not respond to SNMP");
          free((void *)poll_result);
          return 1;
        }

        else
        {
          snprintf(ping->snmp_response, (unsigned long int)256, "Host responded to SNMP");
          snprintf(ping->snmp_status, (unsigned long int)50, "%.5f", total_time);
          free((void *)poll_result);
          return 3;
        }
    }

    else
    {
      snprintf(ping->snmp_status, (unsigned long int)50, "0.00");
      snprintf(ping->snmp_response, (unsigned long int)256, "Host does not require SNMP");
      return 3;
    }
  }

  else
  {
    snprintf(ping->snmp_status, (unsigned long int)50, "0.00");
    snprintf(ping->snmp_response, (unsigned long int)256, "Invalid SNMP Session");
    return 1;
  }
}

// ping_tcp
// file ping.c line 670
extern signed int ping_tcp(struct host_struct *host, struct ping_results *ping)
{
  double begin_time;
  double end_time;
  double total_time;
  double host_timeout;
  double one_thousand = 1000.00;
  struct timeval timeout;
  signed int tcp_socket;
  struct sockaddr_in servername;
  signed int retry_count;
  signed int return_code;
  char *new_hostname;
  signed int return_value_spine_log$1;
  if(set.log_level >= 5)
  {
    return_value_spine_log$1=spine_log("Host[%i] DEBUG: Entering TCP Ping", host->id);
    if(!(return_value_spine_log$1 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  new_hostname=remove_tcp_udp_from_hostname(host->hostname);
  host_timeout = (double)host->ping_timeout;
  if(host->ping_timeout >= 1000)
  {
    double return_value_floor$2;
    return_value_floor$2=floor(host_timeout / (double)1000);
    double return_value_rint$3;
    return_value_rint$3=rint(return_value_floor$2);
    timeout.tv_sec = (signed long int)return_value_rint$3;
    timeout.tv_usec = timeout.tv_sec * (signed long int)1000000 - (signed long int)(host->ping_timeout * 1000);
  }

  else
  {
    timeout.tv_sec = (signed long int)0;
    timeout.tv_usec = (signed long int)(host->ping_timeout * 1000);
  }
  tcp_socket=socket(2, 1, 6);
  unsigned long int return_value_strlen$8;
  return_value_strlen$8=strlen(host->hostname);
  _Bool tmp_if_expr$6;
  signed int *return_value___errno_location$5;
  signed int return_value_spine_log$4;
  if(!(tcp_socket == -1) && !(return_value_strlen$8 == 0ul))
  {
    snprintf(ping->ping_status, (unsigned long int)50, "down");
    snprintf(ping->ping_response, (unsigned long int)256, "default");
    setsockopt(tcp_socket, 1, 20, (const void *)(char *)&timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
    setsockopt(tcp_socket, 1, 21, (const void *)(char *)&timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
    signed int return_value_init_sockaddr$7;
    return_value_init_sockaddr$7=init_sockaddr(&servername, new_hostname, (unsigned short int)host->ping_port);
    if(!(return_value_init_sockaddr$7 == 0))
    {
      retry_count = 0;
      while((_Bool)1)
      {
        begin_time=get_time_as_double();
        return_code=connect(tcp_socket, (struct sockaddr *)&servername, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
        end_time=get_time_as_double();
        total_time = (end_time - begin_time) * one_thousand;
        if(return_code == -1)
        {
          return_value___errno_location$5=__errno_location();
          tmp_if_expr$6 = *return_value___errno_location$5 == 111 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$6 = (_Bool)0;
        if(return_code == 0 || tmp_if_expr$6)
        {
          if(set.log_level >= 5)
          {
            return_value_spine_log$4=spine_log("Host[%i] DEBUG: TCP Host Alive, Try Count:%i, Time:%.4f ms", host->id, retry_count + 1, total_time);
            if(!(return_value_spine_log$4 == 0))
              (_Bool)1;

            else
              (_Bool)0;
          }

          else
            (_Bool)0;
          snprintf(ping->ping_response, (unsigned long int)256, "TCP: Host is Alive");
          snprintf(ping->ping_status, (unsigned long int)50, "%.5f", total_time);
          free((void *)new_hostname);
          close(tcp_socket);
          return 3;
        }

        else
          if(!(host->ping_retries >= retry_count))
          {
            snprintf(ping->ping_status, (unsigned long int)50, "down");
            snprintf(ping->ping_response, (unsigned long int)256, "TCP: Cannot connect to host");
            free((void *)new_hostname);
            close(tcp_socket);
            return 1;
          }

          else
            retry_count = retry_count + 1;
      }
    }

    else
    {
      snprintf(ping->ping_response, (unsigned long int)256, "TCP: Destination hostname invalid");
      snprintf(ping->ping_status, (unsigned long int)50, "down");
      free((void *)new_hostname);
      close(tcp_socket);
      return 1;
    }
  }

  else
  {
    snprintf(ping->ping_response, (unsigned long int)256, "TCP: Destination address invalid or unable to create socket");
    snprintf(ping->ping_status, (unsigned long int)50, "down");
    free((void *)new_hostname);
    if(!(tcp_socket == -1))
      close(tcp_socket);

    return 1;
  }
}

// ping_udp
// file ping.c line 512
extern signed int ping_udp(struct host_struct *host, struct ping_results *ping)
{
  double begin_time;
  double end_time;
  double total_time;
  double host_timeout;
  double one_thousand = 1000.00;
  struct timeval timeout;
  signed int udp_socket;
  struct sockaddr_in servername;
  char socket_reply[1024l];
  signed int retry_count;
  char request[1024l];
  signed int request_len;
  signed int return_code;
  struct anonymous$8 socket_fds;
  char *new_hostname;
  signed int return_value_spine_log$1;
  if(set.log_level >= 5)
  {
    return_value_spine_log$1=spine_log("Host[%i] DEBUG: Entering UDP Ping", host->id);
    if(!(return_value_spine_log$1 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  total_time = (double)0;
  new_hostname=remove_tcp_udp_from_hostname(host->hostname);
  host_timeout = (double)host->ping_timeout;
  udp_socket=socket(2, 2, 17);
  unsigned long int return_value_strlen$14;
  return_value_strlen$14=strlen(host->hostname);
  signed int *return_value___errno_location$8;
  _Bool tmp_if_expr$10;
  signed int *return_value___errno_location$9;
  signed int return_value_spine_log$7;
  signed int *return_value___errno_location$11;
  signed int return_value_spine_log$12;
  if(!(udp_socket == -1) && !(return_value_strlen$14 == 0ul))
  {
    snprintf(ping->ping_status, (unsigned long int)50, "down");
    snprintf(ping->ping_response, (unsigned long int)256, "default");
    setsockopt(udp_socket, 1, 20, (const void *)(char *)&timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
    setsockopt(udp_socket, 1, 21, (const void *)(char *)&timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
    signed int return_value_init_sockaddr$13;
    return_value_init_sockaddr$13=init_sockaddr(&servername, new_hostname, (unsigned short int)host->ping_port);
    if(!(return_value_init_sockaddr$13 == 0))
    {
      signed int return_value_connect$2;
      return_value_connect$2=connect(udp_socket, (struct sockaddr *)&servername, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(!(return_value_connect$2 >= 0))
      {
        snprintf(ping->ping_status, (unsigned long int)50, "down");
        snprintf(ping->ping_response, (unsigned long int)256, "UDP: Cannot connect to host");
        free((void *)new_hostname);
        close(udp_socket);
        return 1;
      }

      snprintf(request, (unsigned long int)1024, "cacti-monitoring-system");
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(request);
      request_len = (signed int)return_value_strlen$3;
      retry_count = 0;
      do
      {
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$8) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&socket_fds)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      (&socket_fds)->__fds_bits[(signed long int)(udp_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&socket_fds)->__fds_bits[(signed long int)(udp_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << udp_socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      while((_Bool)1)
      {
        if(!(host->ping_retries >= retry_count))
        {
          snprintf(ping->ping_response, (unsigned long int)256, "UDP: Ping timed out");
          snprintf(ping->ping_status, (unsigned long int)50, "down");
          free((void *)new_hostname);
          close(udp_socket);
          return 1;
        }

        begin_time=get_time_as_double();
        if(host->ping_timeout >= 1000)
        {
          double return_value_floor$4;
          return_value_floor$4=floor(host_timeout / (double)1000);
          double return_value_rint$5;
          return_value_rint$5=rint(return_value_floor$4);
          timeout.tv_sec = (signed long int)return_value_rint$5;
          timeout.tv_usec = timeout.tv_sec * (signed long int)1000000 - (signed long int)(host->ping_timeout * 1000);
        }

        else
        {
          timeout.tv_sec = (signed long int)0;
          timeout.tv_usec = (signed long int)(host->ping_timeout * 1000);
        }
        send(udp_socket, (const void *)request, (unsigned long int)request_len, 0);
        do
        {

        wait_more:
          ;
          return_code=select(1024, &socket_fds, (struct anonymous$8 *)(void *)0, (struct anonymous$8 *)(void *)0, &timeout);
          end_time=get_time_as_double();
          total_time = (end_time - begin_time) * one_thousand;
          if(return_code >= 1)
          {
            if(!((socket_fds.__fds_bits[(signed long int)(udp_socket / 8)] & (signed long int)(1UL << udp_socket % 8)) == 0l))
            {
              signed long int return_value_read$6;
              return_value_read$6=read(udp_socket, (void *)socket_reply, (unsigned long int)1024);
              return_code = (signed int)return_value_read$6;
              if(return_code == -1)
              {
                return_value___errno_location$8=__errno_location();
                if(*return_value___errno_location$8 == 104)
                  tmp_if_expr$10 = (_Bool)1;

                else
                {
                  return_value___errno_location$9=__errno_location();
                  tmp_if_expr$10 = *return_value___errno_location$9 == 111 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$10)
                {
                  if(set.log_level >= 5)
                  {
                    return_value_spine_log$7=spine_log("Host[%i] DEBUG: UDP Host Alive, Try Count:%i, Time:%.4f ms", host->id, retry_count + 1, total_time);
                    if(!(return_value_spine_log$7 == 0))
                      (_Bool)1;

                    else
                      (_Bool)0;
                  }

                  else
                    (_Bool)0;
                  snprintf(ping->ping_response, (unsigned long int)256, "UDP: Host is Alive");
                  snprintf(ping->ping_status, (unsigned long int)50, "%.5f", total_time);
                  free((void *)new_hostname);
                  close(udp_socket);
                  return 3;
                }

              }

            }

            goto __CPROVER_DUMP_L23;
          }

          if(!(return_code == -1))
            goto __CPROVER_DUMP_L23;

          return_value___errno_location$11=__errno_location();
          if(!(*return_value___errno_location$11 == 4))
            break;

        }
        while((_Bool)1);
        snprintf(ping->ping_response, (unsigned long int)256, "UDP: Host is Down");
        snprintf(ping->ping_status, (unsigned long int)50, "%.5f", total_time);
        free((void *)new_hostname);
        close(udp_socket);
        return 1;

      __CPROVER_DUMP_L23:
        ;
        if(set.log_level >= 5)
        {
          return_value_spine_log$12=spine_log("Host[%i] DEBUG: UDP Timeout, Try Count:%i, Time:%.4f ms", host->id, retry_count + 1, total_time);
          if(!(return_value_spine_log$12 == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
        retry_count = retry_count + 1;
        usleep((unsigned int)1000);
      }
    }

    else
    {
      snprintf(ping->ping_response, (unsigned long int)256, "UDP: Destination hostname invalid");
      snprintf(ping->ping_status, (unsigned long int)50, "down");
      free((void *)new_hostname);
      close(udp_socket);
      return 1;
    }
  }

  else
  {
    snprintf(ping->ping_response, (unsigned long int)256, "UDP: Destination address invalid or unable to create socket");
    snprintf(ping->ping_status, (unsigned long int)50, "down");
    free((void *)new_hostname);
    if(!(udp_socket == -1))
      close(udp_socket);

    return 1;
  }
}

// poll_host
// file poller.c line 109
extern void poll_host(signed int host_id, signed int host_thread, signed int last_host_thread, signed int host_data_ids, char *host_time)
{
  char query1[1024l];
  char query2[1024l];
  char *query3 = (char *)(void *)0;
  char query4[1024l];
  char query5[1024l];
  char query6[1024l];
  char query8[1024l];
  char query9[1024l];
  char query10[1024l];
  char query11[1024l];
  char *query12 = (char *)(void *)0;
  char posuffix[1024l];
  char sysUptime[1024l];
  char result_string[1280l];
  signed int result_length;
  char temp_result[1024l];
  signed int num_rows;
  signed int assert_fail = 0;
  signed int reindex_err = 0;
  signed int spike_kill = 0;
  signed int rows_processed = 0;
  signed int i = 0;
  signed int j = 0;
  signed int k = 0;
  signed int num_oids = 0;
  signed int snmp_poller_items = 0;
  unsigned long int out_buffer;
  signed int php_process;
  char *poll_result = (char *)(void *)0;
  char update_sql[1024l];
  char limits[256l];
  signed int num_snmp_agents = 0;
  signed int last_snmp_version = 0;
  signed int last_snmp_port = 0;
  char last_snmp_community[50l];
  char last_snmp_username[50l];
  char last_snmp_password[50l];
  char last_snmp_auth_protocol[5l];
  char last_snmp_priv_passphrase[200l];
  char last_snmp_priv_protocol[7l];
  char last_snmp_context[65l];
  double poll_time;
  poll_time=get_time_as_double();
  signed int previous_assert_failure = 0;
  signed int last_data_query_id = 0;
  signed int perform_assert = 1;
  signed int new_buffer = 1;
  struct host_reindex_struct *reindex;
  struct host_struct *host;
  struct ping_results *ping;
  struct target_struct *poller_items;
  struct snmp_oids *snmp_oids;
  struct st_mysql mysql;
  struct st_mysql_res *result;
  char **row;
  db_connect(set.dbdb, &mysql);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct host_struct) /*1192ul*/ );
  host = (struct host_struct *)return_value_malloc$1;
  if(host == ((struct host_struct *)NULL))
    die("ERROR: Fatal malloc error: poller.c host struct!");

  memset((void *)host, 0, sizeof(struct host_struct) /*1192ul*/ );
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct ping_results) /*868ul*/ );
  ping = (struct ping_results *)return_value_malloc$2;
  if(ping == ((struct ping_results *)NULL))
    die("ERROR: Fatal malloc error: poller.c ping struct!");

  memset((void *)ping, 0, sizeof(struct ping_results) /*868ul*/ );
  void *return_value_malloc$3;
  return_value_malloc$3=malloc(sizeof(struct host_reindex_struct) /*624ul*/ );
  reindex = (struct host_reindex_struct *)return_value_malloc$3;
  if(reindex == ((struct host_reindex_struct *)NULL))
    die("ERROR: Fatal malloc error: poller.c reindex poll!");

  memset((void *)reindex, 0, sizeof(struct host_reindex_struct) /*624ul*/ );
  sysUptime[(signed long int)0] = (char)0;
  if(host_data_ids >= 1)
    snprintf(limits, (unsigned long int)256, "LIMIT %i, %i", host_data_ids * (host_thread - 1), host_data_ids);

  else
    limits[(signed long int)0] = (char)0;
  if(set.poller_id == 0)
  {
    snprintf(query1, (unsigned long int)1024, "SELECT action, hostname, snmp_community, snmp_version, snmp_username, snmp_password, rrd_name, rrd_path, arg1, arg2, arg3, local_data_id, rrd_num, snmp_port, snmp_timeout, snmp_auth_protocol, snmp_priv_passphrase, snmp_priv_protocol, snmp_context  FROM poller_item WHERE host_id=%i ORDER BY snmp_port %s", host_id, (const void *)limits);
    snprintf(query2, (unsigned long int)1024, "SELECT id, hostname, snmp_community, snmp_version, snmp_username, snmp_password, snmp_auth_protocol, snmp_priv_passphrase, snmp_priv_protocol, snmp_context, snmp_port, snmp_timeout, max_oids, availability_method, ping_method, ping_port, ping_timeout, ping_retries, status, status_event_count, status_fail_date, status_rec_date, status_last_error, min_time, max_time, cur_time, avg_time, total_polls, failed_polls, availability  FROM host WHERE id=%i", host_id);
    snprintf(query4, (unsigned long int)1024, "SELECT data_query_id, action, op, assert_value, arg1 FROM poller_reindex WHERE host_id=%i", host_id);
    snprintf(query5, (unsigned long int)1024, "SELECT action, hostname, snmp_community, snmp_version, snmp_username, snmp_password, rrd_name, rrd_path, arg1, arg2, arg3, local_data_id, rrd_num, snmp_port, snmp_timeout, snmp_auth_protocol, snmp_priv_passphrase, snmp_priv_protocol, snmp_context  FROM poller_item WHERE host_id=%i and rrd_next_step <=0 ORDER by snmp_port %s", host_id, (const void *)limits);
    snprintf(query6, (unsigned long int)1024, "UPDATE poller_item SET rrd_next_step=IF((rrd_next_step-%i)>=0, (rrd_next_step-%i), (rrd_step-%i)) WHERE host_id=%i", set.poller_interval, set.poller_interval, set.poller_interval, host_id);
    snprintf(query8, (unsigned long int)1024, "INSERT INTO poller_output (local_data_id, rrd_name, time, output) VALUES");
    snprintf(posuffix, (unsigned long int)1024, " ON DUPLICATE KEY UPDATE output=VALUES(output)");
    snprintf(query9, (unsigned long int)1024, "SELECT snmp_port, count(snmp_port) FROM poller_item WHERE host_id=%i GROUP BY snmp_port %s", host_id, (const void *)limits);
    snprintf(query10, (unsigned long int)1024, "SELECT snmp_port, count(snmp_port) FROM poller_item WHERE host_id=%i AND rrd_next_step < 0 GROUP BY snmp_port %s", host_id, (const void *)limits);
  }

  else
  {
    snprintf(query1, (unsigned long int)1024, "SELECT action, hostname, snmp_community, snmp_version, snmp_username, snmp_password, rrd_name, rrd_path, arg1, arg2, arg3, local_data_id, rrd_num, snmp_port, snmp_timeout, snmp_auth_protocol, snmp_priv_passphrase, snmp_priv_protocol, snmp_context  FROM poller_item WHERE host_id=%i AND poller_id=%i ORDER BY snmp_port %s", host_id, set.poller_id, (const void *)limits);
    snprintf(query2, (unsigned long int)1024, "SELECT id, hostname, snmp_community, snmp_version, snmp_username, snmp_password, snmp_auth_protocol, snmp_priv_passphrase, snmp_priv_protocol, snmp_context, snmp_port, snmp_timeout, max_oids, availability_method, ping_method, ping_port, ping_timeout, ping_retries, status, status_event_count, status_fail_date, status_rec_date, status_last_error, min_time, max_time, cur_time, avg_time, total_polls, failed_polls, availability  FROM host WHERE id=%i", host_id);
    snprintf(query4, (unsigned long int)1024, "SELECT data_query_id, action, op, assert_value, arg1 FROM poller_reindex WHERE host_id=%i", host_id);
    snprintf(query5, (unsigned long int)1024, "SELECT action, hostname, snmp_community, snmp_version, snmp_username, snmp_password, rrd_name, rrd_path, arg1, arg2, arg3, local_data_id, rrd_num, snmp_port, snmp_timeout, snmp_auth_protocol, snmp_priv_passphrase, snmp_priv_protocol, snmp_context  FROM poller_item WHERE host_id=%i AND rrd_next_step <=0 AND poller_id=%i ORDER by snmp_port %s", host_id, set.poller_id, (const void *)limits);
    snprintf(query6, (unsigned long int)1024, "UPDATE poller_item SET rrd_next_step=IF((rrd_next_step-%i)>=0, (rrd_next_step-%i), (rrd_step-%i)) WHERE host_id=%i AND poller_id=%i", set.poller_interval, set.poller_interval, set.poller_interval, host_id, set.poller_id);
    snprintf(query8, (unsigned long int)1024, "INSERT INTO poller_output (local_data_id, rrd_name, time, output) VALUES");
    snprintf(posuffix, (unsigned long int)1024, " ON DUPLICATE KEY UPDATE output=VALUES(output)");
    snprintf(query9, (unsigned long int)1024, "SELECT snmp_port, count(snmp_port) FROM poller_item WHERE host_id=%i AND poller_id=%i GROUP BY snmp_port %s", host_id, set.poller_id, (const void *)limits);
    snprintf(query10, (unsigned long int)1024, "SELECT snmp_port, count(snmp_port) FROM poller_item WHERE host_id=%i AND rrd_next_step < 0 AND poller_id=%i GROUP BY snmp_port %s", host_id, set.poller_id, (const void *)limits);
  }
  snprintf(query11, (unsigned long int)1024, "INSERT INTO poller_output_boost (local_data_id, rrd_name, time, output) VALUES");
  snprintf(ping->ping_status, (unsigned long int)50, "down");
  snprintf(ping->ping_response, (unsigned long int)256, "Ping not performed due to setting.");
  snprintf(ping->snmp_status, (unsigned long int)50, "down");
  snprintf(ping->snmp_response, (unsigned long int)256, "SNMP not performed due to setting or ping result");
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$8;
  unsigned long int return_value_strlen$7;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$13;
  unsigned long int return_value_strlen$12;
  _Bool tmp_if_expr$14;
  signed int return_value_spine_log$10;
  if(!(host_id == 0))
  {
    result=db_query(&mysql, query2);
    if(!(result == ((struct st_mysql_res *)NULL)))
    {
      unsigned long long int return_value_mysql_num_rows$4;
      return_value_mysql_num_rows$4=mysql_num_rows(result);
      num_rows = (signed int)return_value_mysql_num_rows$4;
      if(!(num_rows == 1))
      {
        spine_log("Host[%i] TH[%i] ERROR: Multiple Hosts with Host ID", host_id, host_thread);
        mysql_free_result(result);
        mysql_close(&mysql);
        mysql_thread_end();
        goto __CPROVER_DUMP_L358;
      }

      row=mysql_fetch_row(result);
      if(!(row == ((char **)NULL)))
      {
        host->id = 0;
        host->hostname[(signed long int)0] = (char)0;
        host->snmp_session = (void *)0;
        host->snmp_community[(signed long int)0] = (char)0;
        host->snmp_version = 1;
        host->snmp_username[(signed long int)0] = (char)0;
        host->snmp_password[(signed long int)0] = (char)0;
        host->snmp_auth_protocol[(signed long int)0] = (char)0;
        host->snmp_priv_passphrase[(signed long int)0] = (char)0;
        host->snmp_priv_protocol[(signed long int)0] = (char)0;
        host->snmp_context[(signed long int)0] = (char)0;
        host->snmp_port = 161;
        host->snmp_timeout = 500;
        host->snmp_retries = set.snmp_retries;
        host->max_oids = 10;
        host->availability_method = 0;
        host->ping_method = 0;
        host->ping_port = 23;
        host->ping_timeout = 500;
        host->ping_retries = 2;
        host->status = 3;
        host->status_event_count = 0;
        host->status_fail_date[(signed long int)0] = (char)0;
        host->status_rec_date[(signed long int)0] = (char)0;
        host->status_last_error[(signed long int)0] = (char)0;
        host->min_time = (double)0;
        host->max_time = (double)0;
        host->cur_time = (double)0;
        host->avg_time = (double)0;
        host->total_polls = 0;
        host->failed_polls = 0;
        host->availability = (double)100;
        host->ignore_host = 0;
        if(!(*row == ((char *)NULL)))
          host->id=atoi(row[(signed long int)0]);

        if(!(row[1l] == ((char *)NULL)))
          strncopy(host->hostname, row[(signed long int)1], sizeof(char [250l]) /*250ul*/ );

        if(!(row[2l] == ((char *)NULL)))
          strncopy(host->snmp_community, row[(signed long int)2], sizeof(char [100l]) /*100ul*/ );

        if(!(row[3l] == ((char *)NULL)))
          host->snmp_version=atoi(row[(signed long int)3]);

        if(!(row[4l] == ((char *)NULL)))
          strncopy(host->snmp_username, row[(signed long int)4], sizeof(char [50l]) /*50ul*/ );

        if(!(row[5l] == ((char *)NULL)))
          strncopy(host->snmp_password, row[(signed long int)5], sizeof(char [50l]) /*50ul*/ );

        if(!(row[6l] == ((char *)NULL)))
          strncopy(host->snmp_auth_protocol, row[(signed long int)6], sizeof(char [5l]) /*5ul*/ );

        if(!(row[7l] == ((char *)NULL)))
          strncopy(host->snmp_priv_passphrase, row[(signed long int)7], sizeof(char [200l]) /*200ul*/ );

        if(!(row[8l] == ((char *)NULL)))
          strncopy(host->snmp_priv_protocol, row[(signed long int)8], sizeof(char [7l]) /*7ul*/ );

        if(!(row[9l] == ((char *)NULL)))
          strncopy(host->snmp_context, row[(signed long int)9], sizeof(char [65l]) /*65ul*/ );

        if(!(row[10l] == ((char *)NULL)))
          host->snmp_port=atoi(row[(signed long int)10]);

        if(!(row[11l] == ((char *)NULL)))
          host->snmp_timeout=atoi(row[(signed long int)11]);

        if(!(row[12l] == ((char *)NULL)))
          host->max_oids=atoi(row[(signed long int)12]);

        if(!(row[13l] == ((char *)NULL)))
          host->availability_method=atoi(row[(signed long int)13]);

        if(!(row[14l] == ((char *)NULL)))
          host->ping_method=atoi(row[(signed long int)14]);

        if(!(row[15l] == ((char *)NULL)))
          host->ping_port=atoi(row[(signed long int)15]);

        if(!(row[16l] == ((char *)NULL)))
          host->ping_timeout=atoi(row[(signed long int)16]);

        if(!(row[17l] == ((char *)NULL)))
          host->ping_retries=atoi(row[(signed long int)17]);

        if(!(row[18l] == ((char *)NULL)))
          host->status=atoi(row[(signed long int)18]);

        if(!(row[19l] == ((char *)NULL)))
          host->status_event_count=atoi(row[(signed long int)19]);

        if(!(row[20l] == ((char *)NULL)))
          strncopy(host->status_fail_date, row[(signed long int)20], sizeof(char [40l]) /*40ul*/ );

        if(!(row[21l] == ((char *)NULL)))
          strncopy(host->status_rec_date, row[(signed long int)21], sizeof(char [40l]) /*40ul*/ );

        if(!(row[22l] == ((char *)NULL)))
          strncopy(host->status_last_error, row[(signed long int)22], sizeof(char [256l]) /*256ul*/ );

        if(!(row[23l] == ((char *)NULL)))
          host->min_time=atof(row[(signed long int)23]);

        if(!(row[24l] == ((char *)NULL)))
          host->max_time=atof(row[(signed long int)24]);

        if(!(row[25l] == ((char *)NULL)))
          host->cur_time=atof(row[(signed long int)25]);

        if(!(row[26l] == ((char *)NULL)))
          host->avg_time=atof(row[(signed long int)26]);

        if(!(row[27l] == ((char *)NULL)))
          host->total_polls=atoi(row[(signed long int)27]);

        if(!(row[28l] == ((char *)NULL)))
          host->failed_polls=atoi(row[(signed long int)28]);

        if(!(row[29l] == ((char *)NULL)))
          host->availability=atof(row[(signed long int)29]);

        if(host->max_oids == 0)
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = host->max_oids > 100 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
        {
          spine_log("Host[%i] TH[%i] WARNING: Max OIDS is out of range with value of '%i'.  Resetting to default of 5", host_id, host_thread, host->max_oids);
          host->max_oids = 5;
        }

        mysql_free_result(result);
        if(host->snmp_version >= 1)
          tmp_if_expr$6 = host->snmp_version <= 2 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6 = (_Bool)0;
        if(tmp_if_expr$6)
        {
          return_value_strlen$7=strlen(host->snmp_community);
          tmp_if_expr$8 = return_value_strlen$7 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$8 = (_Bool)0;
        if(tmp_if_expr$8)
          tmp_if_expr$9 = (_Bool)1;

        else
          tmp_if_expr$9 = host->snmp_version == 3 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$9)
          host->snmp_session=snmp_host_init(host->id, host->hostname, host->snmp_version, host->snmp_community, host->snmp_username, host->snmp_password, host->snmp_auth_protocol, host->snmp_priv_passphrase, host->snmp_priv_protocol, host->snmp_context, host->snmp_port, host->snmp_timeout);

        else
          host->snmp_session = (void *)0;
        if(host->availability_method == 2)
        {
          return_value_strlen$12=strlen(host->snmp_community);
          tmp_if_expr$13 = return_value_strlen$12 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$13 = (_Bool)0;
        if(tmp_if_expr$13)
          tmp_if_expr$14 = host->snmp_version < 3 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$14 = (_Bool)0;
        if(tmp_if_expr$14)
        {
          host->ignore_host = 0;
          update_host_status(3, host, ping, host->availability_method);
          if(set.log_level >= 3)
          {
            return_value_spine_log$10=spine_log("Host[%i] TH[%i] No host availability check possible for '%s'", host->id, host_thread, (const void *)host->hostname);
            if(!(return_value_spine_log$10 == 0))
              (_Bool)1;

            else
              (_Bool)0;
          }

          else
            (_Bool)0;
        }

        else
        {
          signed int return_value_ping_host$11;
          return_value_ping_host$11=ping_host(host, ping);
          if(return_value_ping_host$11 == 3)
          {
            host->ignore_host = 0;
            if(host_thread == 1)
              update_host_status(3, host, ping, host->availability_method);

          }

          else
          {
            host->ignore_host = 1;
            if(host_thread == 1)
              update_host_status(1, host, ping, host->availability_method);

          }
        }
        if(host_thread == 1)
        {
          snprintf(update_sql, (unsigned long int)1024, "UPDATE host SET status='%i', status_event_count='%i', status_fail_date='%s', status_rec_date='%s', status_last_error='%s', min_time='%f', max_time='%f', cur_time='%f', avg_time='%f', total_polls='%i', failed_polls='%i', availability='%.4f' WHERE id='%i'", host->status, host->status_event_count, (const void *)host->status_fail_date, (const void *)host->status_rec_date, (const void *)host->status_last_error, host->min_time, host->max_time, host->cur_time, host->avg_time, host->total_polls, host->failed_polls, host->availability, host->id);
          db_insert(&mysql, update_sql);
        }

      }

      else
      {
        spine_log("Host[%i] TH[%i] ERROR: MySQL Returned a Null Host Result", host->id, host_thread);
        num_rows = 0;
        host->ignore_host = 1;
      }
    }

    else
    {
      num_rows = 0;
      host->ignore_host = 1;
    }
  }

  else
  {
    host->id = 0;
    host->max_oids = 1;
    host->snmp_session = (void *)0;
    host->ignore_host = 0;
  }
  signed int return_value_spine_log$16;
  signed int return_value_spine_log$18;
  signed int return_value_spine_log$19;
  signed int return_value_spine_log$21;
  char *return_value_exec_poll$23;
  signed int return_value_spine_log$24;
  char *return_value_php_cmd$25;
  signed int return_value_spine_log$26;
  void *return_value_malloc$27;
  signed int return_value_snmp_count$28;
  signed int return_value_spine_log$29;
  void *return_value_malloc$30;
  char *return_value_exec_poll$31;
  signed int return_value_char_count$32;
  signed int return_value_spine_log$33;
  void *return_value_malloc$34;
  _Bool tmp_if_expr$50;
  _Bool tmp_if_expr$52;
  signed int return_value_strcasecmp$51;
  signed int return_value_strcmp$47;
  _Bool tmp_if_expr$49;
  signed int return_value_strcmp$48;
  signed int return_value_spine_log$36;
  signed int return_value_strcmp$43;
  _Bool tmp_if_expr$46;
  signed long long int return_value_strtoll$44;
  signed long long int return_value_strtoll$45;
  signed int return_value_spine_log$37;
  signed int return_value_strcmp$42;
  signed long long int return_value_strtoll$39;
  signed long long int return_value_strtoll$40;
  signed int return_value_spine_log$38;
  _Bool tmp_if_expr$58;
  signed int return_value_strcmp$57;
  _Bool tmp_if_expr$60;
  signed int return_value_strcmp$59;
  signed int return_value_strcmp$54;
  _Bool tmp_if_expr$56;
  signed int return_value_strcmp$55;
  signed int return_value_spine_log$53;
  signed int return_value_spine_log$61;
  if(host->ignore_host == 0)
  {
    if(!(host_id == 0))
    {
      result=db_query(&mysql, query4);
      if(!(result == ((struct st_mysql_res *)NULL)))
      {
        unsigned long long int return_value_mysql_num_rows$15;
        return_value_mysql_num_rows$15=mysql_num_rows(result);
        num_rows = (signed int)return_value_mysql_num_rows$15;
        if(num_rows >= 1)
        {
          if(set.log_level >= 5)
          {
            return_value_spine_log$16=spine_log("Host[%i] TH[%i] RECACHE: Processing %i items in the auto reindex cache for '%s'", host->id, host_thread, num_rows, (const void *)host->hostname);
            if(!(return_value_spine_log$16 == 0))
              (_Bool)1;

            else
              (_Bool)0;
          }

          else
            (_Bool)0;
          do
          {
            row=mysql_fetch_row(result);
            if(row == ((char **)NULL))
              break;

            assert_fail = 0;
            reindex_err = 0;
            reindex->data_query_id = 0;
            reindex->action = -1;
            reindex->op[(signed long int)0] = (char)0;
            reindex->assert_value[(signed long int)0] = (char)0;
            reindex->arg1[(signed long int)0] = (char)0;
            if(!(*row == ((char *)NULL)))
              reindex->data_query_id=atoi(row[(signed long int)0]);

            if(!(row[1l] == ((char *)NULL)))
              reindex->action=atoi(row[(signed long int)1]);

            if(!(row[2l] == ((char *)NULL)))
              snprintf(reindex->op, sizeof(char [4l]) /*4ul*/ , "%s", row[(signed long int)2]);

            if(!(row[3l] == ((char *)NULL)))
              db_escape(&mysql, reindex->assert_value, row[(signed long int)3]);

            if(!(row[4l] == ((char *)NULL)))
              snprintf(reindex->arg1, sizeof(char [512l]) /*512ul*/ , "%s", row[(signed long int)4]);

            if(last_data_query_id == reindex->data_query_id && previous_assert_failure == 0)
              perform_assert = 1;

            else
              if(!(last_data_query_id == reindex->data_query_id))
              {
                last_data_query_id = reindex->data_query_id;
                perform_assert = 1;
                previous_assert_failure = 0;
              }

              else
                perform_assert = 0;
            if(!(perform_assert == 0))
            {
              switch(reindex->action)
              {
                case 0:
                {
                  if(host->snmp_session == NULL)
                    reindex_err = 1;

                  if(reindex_err == 0)
                  {
                    char *return_value_strstr$22;
                    return_value_strstr$22=strstr(reindex->arg1, ".1.3.6.1.2.1.1.3.0");
                    if(!(return_value_strstr$22 == ((char *)NULL)))
                    {
                      unsigned long int return_value_strlen$20;
                      return_value_strlen$20=strlen(sysUptime);
                      if(return_value_strlen$20 >= 1ul)
                      {
                        void *return_value_malloc$17;
                        return_value_malloc$17=malloc((unsigned long int)1024);
                        poll_result = (char *)return_value_malloc$17;
                        if(poll_result == ((char *)NULL))
                          die("ERROR: Fatal malloc error: poller.c poll_result");

                        poll_result[(signed long int)0] = (char)0;
                        snprintf(poll_result, (unsigned long int)1024, "%s", (const void *)sysUptime);
                        if(set.log_level >= 3)
                        {
                          return_value_spine_log$18=spine_log("Host[%i] TH[%i] Recache DataQuery[%i] OID: %s, output: %s", host->id, host_thread, reindex->data_query_id, (const void *)reindex->arg1, poll_result);
                          if(!(return_value_spine_log$18 == 0))
                            (_Bool)1;

                          else
                            (_Bool)0;
                        }

                        else
                          (_Bool)0;
                      }

                      else
                      {
                        poll_result=snmp_get(host, reindex->arg1);
                        snprintf(sysUptime, (unsigned long int)1024, "%s", poll_result);
                        if(set.log_level >= 3)
                        {
                          return_value_spine_log$19=spine_log("Host[%i] TH[%i] Recache DataQuery[%i] OID: %s, output: %s", host->id, host_thread, reindex->data_query_id, (const void *)reindex->arg1, poll_result);
                          if(!(return_value_spine_log$19 == 0))
                            (_Bool)1;

                          else
                            (_Bool)0;
                        }

                        else
                          (_Bool)0;
                      }
                    }

                    else
                    {
                      poll_result=snmp_get(host, reindex->arg1);
                      if(set.log_level >= 3)
                      {
                        return_value_spine_log$21=spine_log("Host[%i] TH[%i] Recache DataQuery[%i] OID: %s, output: %s", host->id, host_thread, reindex->data_query_id, (const void *)reindex->arg1, poll_result);
                        if(!(return_value_spine_log$21 == 0))
                          (_Bool)1;

                        else
                          (_Bool)0;
                      }

                      else
                        (_Bool)0;
                    }
                  }

                  else
                    spine_log("WARNING: Host[%i] TH[%i] DataQuery[%i] Reindex Check FAILED: No SNMP Session.  If not an SNMP host, don't use Uptime Goes Backwards!", host->id, host_thread, reindex->data_query_id);
                  break;
                }
                case 1:
                {
                  return_value_exec_poll$23=exec_poll(host, reindex->arg1);
                  poll_result=trim(return_value_exec_poll$23);
                  if(set.log_level >= 3)
                  {
                    return_value_spine_log$24=spine_log("Host[%i] TH[%i] Recache DataQuery[%i] CMD: %s, output: %s", host->id, host_thread, reindex->data_query_id, (const void *)reindex->arg1, poll_result);
                    if(!(return_value_spine_log$24 == 0))
                      (_Bool)1;

                    else
                      (_Bool)0;
                  }

                  else
                    (_Bool)0;
                  break;
                }
                case 2:
                {
                  php_process=php_get_process();
                  return_value_php_cmd$25=php_cmd(reindex->arg1, php_process);
                  poll_result=trim(return_value_php_cmd$25);
                  if(set.log_level >= 3)
                  {
                    return_value_spine_log$26=spine_log("Host[%i] TH[%i] Recache DataQuery[%i] SERVER: %s, output: %s", host->id, host_thread, reindex->data_query_id, (const void *)reindex->arg1, poll_result);
                    if(!(return_value_spine_log$26 == 0))
                      (_Bool)1;

                    else
                      (_Bool)0;
                  }

                  else
                    (_Bool)0;
                  break;
                }
                case 10:
                {
                  return_value_malloc$27=malloc((unsigned long int)1024);
                  poll_result = (char *)return_value_malloc$27;
                  if(poll_result == ((char *)NULL))
                    die("ERROR: Fatal malloc error: poller.c poll_result");

                  poll_result[(signed long int)0] = (char)0;
                  return_value_snmp_count$28=snmp_count(host, reindex->arg1);
                  snprintf(poll_result, (unsigned long int)1024, "%d", return_value_snmp_count$28);
                  if(set.log_level >= 3)
                  {
                    return_value_spine_log$29=spine_log("Host[%i] TH[%i] Recache DataQuery[%i]: OID_COUNT: %s, output: %s", host->id, host_thread, reindex->data_query_id, (const void *)reindex->arg1, poll_result);
                    if(!(return_value_spine_log$29 == 0))
                      (_Bool)1;

                    else
                      (_Bool)0;
                  }

                  else
                    (_Bool)0;
                  break;
                }
                case 11:
                {
                  return_value_malloc$30=malloc((unsigned long int)1024);
                  poll_result = (char *)return_value_malloc$30;
                  if(poll_result == ((char *)NULL))
                    die("ERROR: Fatal malloc error: poller.c poll_result");

                  poll_result[(signed long int)0] = (char)0;
                  return_value_exec_poll$31=exec_poll(host, reindex->arg1);
                  return_value_char_count$32=char_count(return_value_exec_poll$31, 10);
                  snprintf(poll_result, (unsigned long int)1024, "%d", return_value_char_count$32);
                  if(set.log_level >= 3)
                  {
                    return_value_spine_log$33=spine_log("Host[%i] TH[%i] Recache DataQuery[%i] CMD Count: %s, output: %s", host->id, host_thread, reindex->data_query_id, (const void *)reindex->arg1, poll_result);
                    if(!(return_value_spine_log$33 == 0))
                      (_Bool)1;

                    else
                      (_Bool)0;
                  }

                  else
                    (_Bool)0;
                  break;
                }
                case 12:
                {
                  return_value_malloc$34=malloc((unsigned long int)1024);
                  poll_result = (char *)return_value_malloc$34;
                  if(poll_result == ((char *)NULL))
                    die("ERROR: Fatal malloc error: poller.c poll_result");

                  poll_result[(signed long int)0] = (char)0;
                  spine_log("Host[%i] TH[%i] Recache DataQuery[%i] *SKIPPING* Script Server Count: %s,  (arg_num_indexes required)", host->id, host_thread, reindex->data_query_id, (const void *)reindex->arg1);
                  break;
                }
                default:
                  spine_log("Host[%i] TH[%i] ERROR: Unknown Assert Action!", host->id, host_thread);
              }
              if(reindex_err == 0)
              {
                void *return_value_malloc$35;
                return_value_malloc$35=malloc((unsigned long int)1024);
                query3 = (char *)return_value_malloc$35;
                if(query3 == ((char *)NULL))
                  die("ERROR: Fatal malloc error: poller.c reindex insert!");

                query3[(signed long int)0] = (char)0;
                if((signed int)*poll_result == 85)
                  tmp_if_expr$50 = (signed int)poll_result[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$50 = (_Bool)0;
                if(tmp_if_expr$50)
                  tmp_if_expr$52 = (_Bool)1;

                else
                {
                  return_value_strcasecmp$51=strcasecmp(poll_result, "No Such Instance");
                  tmp_if_expr$52 = return_value_strcasecmp$51 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$52)
                  assert_fail = 0;

                else
                {
                  return_value_strcmp$47=strcmp(reindex->op, "=");
                  if(return_value_strcmp$47 == 0)
                  {
                    return_value_strcmp$48=strcmp(reindex->assert_value, poll_result);
                    tmp_if_expr$49 = return_value_strcmp$48 != 0 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr$49 = (_Bool)0;
                  if(tmp_if_expr$49)
                  {
                    if(set.log_level >= 4)
                    {
                      return_value_spine_log$36=spine_log("Host[%i] TH[%i] ASSERT: '%s' .eq. '%s' failed. Recaching host '%s', data query #%i", host->id, host_thread, (const void *)reindex->assert_value, poll_result, (const void *)host->hostname, reindex->data_query_id);
                      if(!(return_value_spine_log$36 == 0))
                        (_Bool)1;

                      else
                        (_Bool)0;
                    }

                    else
                      (_Bool)0;
                    if(host_thread == 1)
                    {
                      snprintf(query3, (unsigned long int)1024, "REPLACE INTO poller_command (poller_id, time, action,command) values (0, NOW(), %i, '%i:%i')", 1, host->id, reindex->data_query_id);
                      db_insert(&mysql, query3);
                    }

                    assert_fail = 1;
                    previous_assert_failure = 1;
                  }

                  else
                  {
                    return_value_strcmp$43=strcmp(reindex->op, ">");
                    if(return_value_strcmp$43 == 0)
                    {
                      return_value_strtoll$44=strtoll(reindex->assert_value, (char **)(void *)0, 10);
                      return_value_strtoll$45=strtoll(poll_result, (char **)(void *)0, 10);
                      tmp_if_expr$46 = return_value_strtoll$44 < return_value_strtoll$45 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$46 = (_Bool)0;
                    if(tmp_if_expr$46)
                    {
                      if(set.log_level >= 4)
                      {
                        return_value_spine_log$37=spine_log("Host[%i] TH[%i] ASSERT: '%s' .gt. '%s' failed. Recaching host '%s', data query #%i", host->id, host_thread, (const void *)reindex->assert_value, poll_result, (const void *)host->hostname, reindex->data_query_id);
                        if(!(return_value_spine_log$37 == 0))
                          (_Bool)1;

                        else
                          (_Bool)0;
                      }

                      else
                        (_Bool)0;
                      if(host_thread == 1)
                      {
                        snprintf(query3, (unsigned long int)1024, "REPLACE INTO poller_command (poller_id, time, action, command) values (0, NOW(), %i, '%i:%i')", 1, host->id, reindex->data_query_id);
                        db_insert(&mysql, query3);
                      }

                      assert_fail = 1;
                      previous_assert_failure = 1;
                    }

                    else
                    {
                      return_value_strcmp$42=strcmp(reindex->assert_value, "0");
                      if(!(return_value_strcmp$42 == 0))
                      {
                        signed int return_value_strcmp$41;
                        return_value_strcmp$41=strcmp(reindex->op, "<");
                        if(return_value_strcmp$41 == 0)
                        {
                          return_value_strtoll$39=strtoll(reindex->assert_value, (char **)(void *)0, 10);
                          return_value_strtoll$40=strtoll(poll_result, (char **)(void *)0, 10);
                          if(!(return_value_strtoll$40 >= return_value_strtoll$39))
                          {
                            if(set.log_level >= 4)
                            {
                              return_value_spine_log$38=spine_log("Host[%i] TH[%i] ASSERT: '%s' .lt. '%s' failed. Recaching host '%s', data query #%i", host->id, host_thread, (const void *)reindex->assert_value, poll_result, (const void *)host->hostname, reindex->data_query_id);
                              if(!(return_value_spine_log$38 == 0))
                                (_Bool)1;

                              else
                                (_Bool)0;
                            }

                            else
                              (_Bool)0;
                            if(host_thread == 1)
                            {
                              snprintf(query3, (unsigned long int)1024, "REPLACE INTO poller_command (poller_id, time, action, command) values (0, NOW(), %i, '%i:%i')", 1, host->id, reindex->data_query_id);
                              db_insert(&mysql, query3);
                            }

                            assert_fail = 1;
                            previous_assert_failure = 1;
                          }

                        }

                      }

                    }
                  }
                }
                if(!(assert_fail == 0))
                  tmp_if_expr$58 = (_Bool)1;

                else
                {
                  return_value_strcmp$57=strcmp(reindex->op, ">");
                  tmp_if_expr$58 = !(return_value_strcmp$57 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$58)
                  tmp_if_expr$60 = (_Bool)1;

                else
                {
                  return_value_strcmp$59=strcmp(reindex->op, "<");
                  tmp_if_expr$60 = !(return_value_strcmp$59 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$60)
                {
                  if(host_thread == 1)
                  {
                    snprintf(query3, (unsigned long int)1024, "UPDATE poller_reindex SET assert_value='%s' WHERE host_id='%i' AND data_query_id='%i' and arg1='%s'", poll_result, host_id, reindex->data_query_id, (const void *)reindex->arg1);
                    db_insert(&mysql, query3);
                  }

                  if(!(assert_fail == 0))
                  {
                    return_value_strcmp$54=strcmp(reindex->op, "<");
                    if(return_value_strcmp$54 == 0)
                      tmp_if_expr$56 = (_Bool)1;

                    else
                    {
                      return_value_strcmp$55=strcmp(reindex->arg1, ".1.3.6.1.2.1.1.3.0");
                      tmp_if_expr$56 = !(return_value_strcmp$55 != 0) ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr$56)
                    {
                      spike_kill = 1;
                      if(set.log_level >= 3)
                      {
                        return_value_spine_log$53=spine_log("Host[%i] TH[%i] NOTICE: Spike Kill in Effect for '%s'", host_id, host_thread, (const void *)host->hostname);
                        if(!(return_value_spine_log$53 == 0))
                          (_Bool)1;

                        else
                          (_Bool)0;
                      }

                      else
                        (_Bool)0;
                    }

                  }

                }

                free((void *)query3);
                free((void *)poll_result);
              }

            }

          }
          while((_Bool)1);
        }

        else
          if(set.log_level >= 4)
          {
            return_value_spine_log$61=spine_log("Host[%i] TH[%i] Host has no information for recache.", host->id, host_thread);
            if(!(return_value_spine_log$61 == 0))
              (_Bool)1;

            else
              (_Bool)0;
          }

          else
            (_Bool)0;
        mysql_free_result(result);
      }

      else
        spine_log("Host[%i] TH[%i] ERROR: Recache Query Returned Null Result!", host->id, host_thread);
      if(!(host->snmp_session == NULL))
      {
        snmp_host_cleanup(host->snmp_session);
        host->snmp_session = (void *)0;
      }

    }

  }

  num_rows = 0;
  if(set.poller_interval == 0)
  {
    result=db_query(&mysql, query9);
    if(!(result == ((struct st_mysql_res *)NULL)))
    {
      unsigned long long int return_value_mysql_num_rows$62;
      return_value_mysql_num_rows$62=mysql_num_rows(result);
      num_snmp_agents = (signed int)return_value_mysql_num_rows$62;
      mysql_free_result(result);
      result=db_query(&mysql, query1);
      if(!(result == ((struct st_mysql_res *)NULL)))
      {
        unsigned long long int return_value_mysql_num_rows$63;
        return_value_mysql_num_rows$63=mysql_num_rows(result);
        num_rows = (signed int)return_value_mysql_num_rows$63;
      }

      else
        spine_log("Host[%i] TH[%i] ERROR: Unable to Retrieve Rows due to Null Result!", host->id, host_thread);
    }

    else
      spine_log("Host[%i] TH[%i] ERROR: Agent Count Query Returned Null Result!", host->id, host_thread);
  }

  else
  {
    result=db_query(&mysql, query10);
    if(!(result == ((struct st_mysql_res *)NULL)))
    {
      unsigned long long int return_value_mysql_num_rows$64;
      return_value_mysql_num_rows$64=mysql_num_rows(result);
      num_snmp_agents = (signed int)return_value_mysql_num_rows$64;
      mysql_free_result(result);
      result=db_query(&mysql, query5);
      if(!(result == ((struct st_mysql_res *)NULL)))
      {
        unsigned long long int return_value_mysql_num_rows$65;
        return_value_mysql_num_rows$65=mysql_num_rows(result);
        num_rows = (signed int)return_value_mysql_num_rows$65;
      }

      else
        spine_log("Host[%i] TH[%i] ERROR: Unable to Retrieve Rows due to Null Result!", host->id, host_thread);
    }

    else
      spine_log("Host[%i] TH[%i] ERROR: Agent Count Query Returned Null Result!", host->id, host_thread);
  }
  signed int return_value_spine_log$68;
  _Bool tmp_if_expr$82;
  _Bool tmp_if_expr$85;
  _Bool tmp_if_expr$84;
  signed int return_value_strcmp$83;
  _Bool tmp_if_expr$98;
  _Bool tmp_if_expr$87;
  signed int return_value_strcmp$86;
  _Bool tmp_if_expr$89;
  signed int return_value_strcmp$88;
  _Bool tmp_if_expr$91;
  signed int return_value_strcmp$90;
  _Bool tmp_if_expr$93;
  signed int return_value_strcmp$92;
  _Bool tmp_if_expr$95;
  signed int return_value_strcmp$94;
  _Bool tmp_if_expr$97;
  signed int return_value_strcmp$96;
  _Bool tmp_if_expr$80;
  signed int return_value_is_numeric$77;
  _Bool tmp_if_expr$79;
  signed int return_value_is_multipart_output$78;
  signed int return_value_is_hexadecimal$76;
  signed int return_value_strcasecmp$73;
  _Bool tmp_if_expr$75;
  signed int return_value_strcasecmp$74;
  signed int return_value_spine_log$81;
  _Bool tmp_if_expr$110;
  signed int return_value_is_numeric$107;
  _Bool tmp_if_expr$109;
  signed int return_value_is_multipart_output$108;
  signed int return_value_is_hexadecimal$106;
  signed int return_value_strcasecmp$103;
  _Bool tmp_if_expr$105;
  signed int return_value_strcasecmp$104;
  signed int return_value_spine_log$111;
  char *return_value_strstr$112;
  _Bool tmp_if_expr$122;
  signed int return_value_is_numeric$118;
  _Bool tmp_if_expr$121;
  char *return_value_trim$119;
  signed int return_value_is_multipart_output$120;
  signed int return_value_is_hexadecimal$117;
  signed int return_value_spine_log$123;
  char *return_value_strstr$124;
  _Bool tmp_if_expr$134;
  signed int return_value_is_numeric$130;
  _Bool tmp_if_expr$133;
  char *return_value_trim$131;
  signed int return_value_is_multipart_output$132;
  signed int return_value_is_hexadecimal$129;
  signed int return_value_spine_log$135;
  signed int return_value_strcasecmp$136;
  _Bool tmp_if_expr$148;
  signed int return_value_is_numeric$145;
  _Bool tmp_if_expr$147;
  signed int return_value_is_multipart_output$146;
  signed int return_value_is_hexadecimal$144;
  signed int return_value_strcasecmp$141;
  _Bool tmp_if_expr$143;
  signed int return_value_strcasecmp$142;
  signed int return_value_spine_log$149;
  char *return_value_strstr$150;
  if(num_rows >= 1)
  {
    void *return_value_calloc$66;
    return_value_calloc$66=calloc((unsigned long int)num_rows, sizeof(struct target_struct) /*3372ul*/ );
    poller_items = (struct target_struct *)return_value_calloc$66;
    i = 0;
    do
    {
      row=mysql_fetch_row(result);
      if(row == ((char **)NULL))
        break;

      (poller_items + (signed long int)i)->target_id = 0;
      (poller_items + (signed long int)i)->action = -1;
      (poller_items + (signed long int)i)->hostname[(signed long int)0] = (char)0;
      (poller_items + (signed long int)i)->snmp_community[(signed long int)0] = (char)0;
      (poller_items + (signed long int)i)->snmp_version = 1;
      (poller_items + (signed long int)i)->snmp_username[(signed long int)0] = (char)0;
      (poller_items + (signed long int)i)->snmp_password[(signed long int)0] = (char)0;
      (poller_items + (signed long int)i)->snmp_auth_protocol[(signed long int)0] = (char)0;
      (poller_items + (signed long int)i)->snmp_priv_passphrase[(signed long int)0] = (char)0;
      (poller_items + (signed long int)i)->snmp_priv_protocol[(signed long int)0] = (char)0;
      (poller_items + (signed long int)i)->snmp_context[(signed long int)0] = (char)0;
      (poller_items + (signed long int)i)->snmp_port = 161;
      (poller_items + (signed long int)i)->snmp_timeout = 500;
      (poller_items + (signed long int)i)->rrd_name[(signed long int)0] = (char)0;
      (poller_items + (signed long int)i)->rrd_path[(signed long int)0] = (char)0;
      (poller_items + (signed long int)i)->arg1[(signed long int)0] = (char)0;
      (poller_items + (signed long int)i)->arg2[(signed long int)0] = (char)0;
      (poller_items + (signed long int)i)->arg3[(signed long int)0] = (char)0;
      (poller_items + (signed long int)i)->local_data_id = 0;
      (poller_items + (signed long int)i)->rrd_num = 0;
      if(!(*row == ((char *)NULL)))
        (poller_items + (signed long int)i)->action=atoi(row[(signed long int)0]);

      if(!(row[1l] == ((char *)NULL)))
        snprintf((poller_items + (signed long int)i)->hostname, sizeof(char [250l]) /*250ul*/ , "%s", row[(signed long int)1]);

      if(!(row[2l] == ((char *)NULL)))
        snprintf((poller_items + (signed long int)i)->snmp_community, sizeof(char [100l]) /*100ul*/ , "%s", row[(signed long int)2]);

      if(!(row[3l] == ((char *)NULL)))
        (poller_items + (signed long int)i)->snmp_version=atoi(row[(signed long int)3]);

      if(!(row[4l] == ((char *)NULL)))
        snprintf((poller_items + (signed long int)i)->snmp_username, sizeof(char [50l]) /*50ul*/ , "%s", row[(signed long int)4]);

      if(!(row[5l] == ((char *)NULL)))
        snprintf((poller_items + (signed long int)i)->snmp_password, sizeof(char [50l]) /*50ul*/ , "%s", row[(signed long int)5]);

      if(!(row[6l] == ((char *)NULL)))
        snprintf((poller_items + (signed long int)i)->rrd_name, sizeof(char [30l]) /*30ul*/ , "%s", row[(signed long int)6]);

      if(!(row[7l] == ((char *)NULL)))
        snprintf((poller_items + (signed long int)i)->rrd_path, sizeof(char [255l]) /*255ul*/ , "%s", row[(signed long int)7]);

      if(!(row[8l] == ((char *)NULL)))
        snprintf((poller_items + (signed long int)i)->arg1, sizeof(char [512l]) /*512ul*/ , "%s", row[(signed long int)8]);

      if(!(row[9l] == ((char *)NULL)))
        snprintf((poller_items + (signed long int)i)->arg2, sizeof(char [255l]) /*255ul*/ , "%s", row[(signed long int)9]);

      if(!(row[10l] == ((char *)NULL)))
        snprintf((poller_items + (signed long int)i)->arg3, sizeof(char [255l]) /*255ul*/ , "%s", row[(signed long int)10]);

      if(!(row[11l] == ((char *)NULL)))
        (poller_items + (signed long int)i)->local_data_id=atoi(row[(signed long int)11]);

      if(!(row[12l] == ((char *)NULL)))
        (poller_items + (signed long int)i)->rrd_num=atoi(row[(signed long int)12]);

      if(!(row[13l] == ((char *)NULL)))
        (poller_items + (signed long int)i)->snmp_port=atoi(row[(signed long int)13]);

      if(!(row[14l] == ((char *)NULL)))
        (poller_items + (signed long int)i)->snmp_timeout=atoi(row[(signed long int)14]);

      if(!(row[15l] == ((char *)NULL)))
        snprintf((poller_items + (signed long int)i)->snmp_auth_protocol, sizeof(char [5l]) /*5ul*/ , "%s", row[(signed long int)15]);

      if(!(row[16l] == ((char *)NULL)))
        snprintf((poller_items + (signed long int)i)->snmp_priv_passphrase, sizeof(char [200l]) /*200ul*/ , "%s", row[(signed long int)16]);

      if(!(row[17l] == ((char *)NULL)))
        snprintf((poller_items + (signed long int)i)->snmp_priv_protocol, sizeof(char [7l]) /*7ul*/ , "%s", row[(signed long int)17]);

      if(!(row[18l] == ((char *)NULL)))
        snprintf((poller_items + (signed long int)i)->snmp_context, sizeof(char [65l]) /*65ul*/ , "%s", row[(signed long int)18]);

      (poller_items + (signed long int)i)->result[(signed long int)0] = (char)85;
      (poller_items + (signed long int)i)->result[(signed long int)1] = (char)0;
      if((poller_items + (signed long int)i)->action == 0)
        snmp_poller_items = snmp_poller_items + 1;

      i = i + 1;
    }
    while((_Bool)1);
    mysql_free_result(result);
    void *return_value_calloc$67;
    return_value_calloc$67=calloc((unsigned long int)host->max_oids, sizeof(struct snmp_oids) /*1540ul*/ );
    snmp_oids = (struct snmp_oids *)return_value_calloc$67;
    memset((void *)snmp_oids, 0, sizeof(struct snmp_oids) /*1540ul*/  * (unsigned long int)host->max_oids);
    if(set.log_level >= 3)
    {
      return_value_spine_log$68=spine_log("Host[%i] TH[%i] NOTE: There are '%i' Polling Items for this Host", host_id, host_thread, num_rows);
      if(!(return_value_spine_log$68 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
    i = 0;
    k = 0;
    for( ; !(i >= num_rows); rows_processed = rows_processed + 1)
    {
      if(!(host->ignore_host == 0))
        break;

      switch((poller_items + (signed long int)i)->action)
      {
        case 0:
        {
          if(k == 0)
          {
            last_snmp_port = (poller_items + (signed long int)i)->snmp_port;
            last_snmp_version = (poller_items + (signed long int)i)->snmp_version;
            strncopy(last_snmp_community, (poller_items + (signed long int)i)->snmp_community, sizeof(char [50l]) /*50ul*/ );
            strncopy(last_snmp_username, (poller_items + (signed long int)i)->snmp_username, sizeof(char [50l]) /*50ul*/ );
            strncopy(last_snmp_password, (poller_items + (signed long int)i)->snmp_password, sizeof(char [50l]) /*50ul*/ );
            strncopy(last_snmp_auth_protocol, (poller_items + (signed long int)i)->snmp_auth_protocol, sizeof(char [5l]) /*5ul*/ );
            strncopy(last_snmp_priv_passphrase, (poller_items + (signed long int)i)->snmp_priv_passphrase, sizeof(char [200l]) /*200ul*/ );
            strncopy(last_snmp_priv_protocol, (poller_items + (signed long int)i)->snmp_priv_protocol, sizeof(char [7l]) /*7ul*/ );
            strncopy(last_snmp_context, (poller_items + (signed long int)i)->snmp_context, sizeof(char [65l]) /*65ul*/ );
            host->snmp_session=snmp_host_init(host->id, (poller_items + (signed long int)i)->hostname, (poller_items + (signed long int)i)->snmp_version, (poller_items + (signed long int)i)->snmp_community, (poller_items + (signed long int)i)->snmp_username, (poller_items + (signed long int)i)->snmp_password, (poller_items + (signed long int)i)->snmp_auth_protocol, (poller_items + (signed long int)i)->snmp_priv_passphrase, (poller_items + (signed long int)i)->snmp_priv_protocol, (poller_items + (signed long int)i)->snmp_context, (poller_items + (signed long int)i)->snmp_port, (poller_items + (signed long int)i)->snmp_timeout);
            k = k + 1;
          }

          if(host->snmp_session == NULL)
          {
            host->ignore_host = 1;
            break;
          }

          if(!(last_snmp_port == (poller_items + (signed long int)i)->snmp_port))
            tmp_if_expr$82 = (_Bool)1;

          else
            tmp_if_expr$82 = last_snmp_version != (poller_items + (signed long int)i)->snmp_version ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$82)
            tmp_if_expr$85 = (_Bool)1;

          else
          {
            if(!((poller_items + (signed long int)i)->snmp_version >= 3))
            {
              return_value_strcmp$83=strcmp(last_snmp_community, (poller_items + (signed long int)i)->snmp_community);
              tmp_if_expr$84 = !(return_value_strcmp$83 == 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$84 = (_Bool)0;
            tmp_if_expr$85 = tmp_if_expr$84 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$85)
            tmp_if_expr$98 = (_Bool)1;

          else
          {
            if((poller_items + (signed long int)i)->snmp_version >= 3)
            {
              return_value_strcmp$86=strcmp(last_snmp_username, (poller_items + (signed long int)i)->snmp_username);
              tmp_if_expr$87 = !(return_value_strcmp$86 == 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$87 = (_Bool)0;
            if(tmp_if_expr$87)
              tmp_if_expr$89 = (_Bool)1;

            else
            {
              return_value_strcmp$88=strcmp(last_snmp_password, (poller_items + (signed long int)i)->snmp_password);
              tmp_if_expr$89 = !(return_value_strcmp$88 == 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$89)
              tmp_if_expr$91 = (_Bool)1;

            else
            {
              return_value_strcmp$90=strcmp(last_snmp_auth_protocol, (poller_items + (signed long int)i)->snmp_auth_protocol);
              tmp_if_expr$91 = !(return_value_strcmp$90 == 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$91)
              tmp_if_expr$93 = (_Bool)1;

            else
            {
              return_value_strcmp$92=strcmp(last_snmp_priv_passphrase, (poller_items + (signed long int)i)->snmp_priv_passphrase);
              tmp_if_expr$93 = !(return_value_strcmp$92 == 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$93)
              tmp_if_expr$95 = (_Bool)1;

            else
            {
              return_value_strcmp$94=strcmp(last_snmp_priv_protocol, (poller_items + (signed long int)i)->snmp_priv_protocol);
              tmp_if_expr$95 = !(return_value_strcmp$94 == 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$95)
              tmp_if_expr$97 = (_Bool)1;

            else
            {
              return_value_strcmp$96=strcmp(last_snmp_context, (poller_items + (signed long int)i)->snmp_context);
              tmp_if_expr$97 = !(return_value_strcmp$96 == 0) ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr$98 = tmp_if_expr$97 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$98)
          {
            if(num_oids >= 1)
            {
              snmp_get_multi(host, snmp_oids, num_oids);
              j = 0;
              for( ; !(j >= num_oids); j = j + 1)
              {
                if(!(host->ignore_host == 0))
                {
                  spine_log("Host[%i] TH[%i] DS[%i] WARNING: SNMP timeout detected [%i ms], ignoring host '%s'", host_id, host_thread, (poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->local_data_id, host->snmp_timeout, (const void *)host->hostname);
                  (snmp_oids + (signed long int)j)->result[(signed long int)0] = (char)85;
                  (snmp_oids + (signed long int)j)->result[(signed long int)1] = (char)0;
                }

                else
                {
                  if((signed int)(snmp_oids + (signed long int)j)->result[0l] == 85)
                    tmp_if_expr$80 = (signed int)(snmp_oids + (signed long int)j)->result[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$80 = (_Bool)0;
                  if(!tmp_if_expr$80)
                  {
                    return_value_is_numeric$77=is_numeric((snmp_oids + (signed long int)j)->result);
                    if(!(return_value_is_numeric$77 == 0))
                      tmp_if_expr$79 = (_Bool)1;

                    else
                    {
                      return_value_is_multipart_output$78=is_multipart_output((snmp_oids + (signed long int)j)->result);
                      tmp_if_expr$79 = return_value_is_multipart_output$78 != 0 ? (_Bool)1 : (_Bool)0;
                    }
                    if(!tmp_if_expr$79)
                    {
                      return_value_is_hexadecimal$76=is_hexadecimal((snmp_oids + (signed long int)j)->result, (const signed short int)1);
                      if(!(return_value_is_hexadecimal$76 == 0))
                      {
                        unsigned long long int return_value_hex2dec$69;
                        return_value_hex2dec$69=hex2dec((snmp_oids + (signed long int)j)->result);
                        snprintf((snmp_oids + (signed long int)j)->result, (unsigned long int)1024, "%lld", return_value_hex2dec$69);
                      }

                      else
                      {
                        return_value_strcasecmp$73=strcasecmp((snmp_oids + (signed long int)j)->result, "U");
                        if(return_value_strcasecmp$73 == 0)
                          tmp_if_expr$75 = (_Bool)1;

                        else
                        {
                          return_value_strcasecmp$74=strcasecmp((snmp_oids + (signed long int)j)->result, "Nan");
                          tmp_if_expr$75 = return_value_strcasecmp$74 == 0 ? (_Bool)1 : (_Bool)0;
                        }
                        if(!tmp_if_expr$75)
                        {
                          char *return_value_trim$70;
                          return_value_trim$70=trim((snmp_oids + (signed long int)j)->result);
                          char *return_value_strip_alpha$71;
                          return_value_strip_alpha$71=strip_alpha(return_value_trim$70);
                          snprintf(temp_result, (unsigned long int)1024, "%s", return_value_strip_alpha$71);
                          snprintf((snmp_oids + (signed long int)j)->result, (unsigned long int)1024, "%s", (const void *)temp_result);
                          signed int return_value_validate_result$72;
                          return_value_validate_result$72=validate_result((snmp_oids + (signed long int)j)->result);
                          if(return_value_validate_result$72 == 0)
                          {
                            (snmp_oids + (signed long int)j)->result[(signed long int)0] = (char)85;
                            (snmp_oids + (signed long int)j)->result[(signed long int)1] = (char)0;
                          }

                        }

                      }
                    }

                  }

                }
                snprintf((poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->result, (unsigned long int)1024, "%s", (const void *)(snmp_oids + (signed long int)j)->result);
                if(set.log_level >= 3)
                {
                  return_value_spine_log$81=spine_log("Host[%i] TH[%i] DS[%i] SNMP: v%i: %s, dsname: %s, oid: %s, value: %s", host_id, host_thread, (poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->local_data_id, host->snmp_version, (const void *)host->hostname, (const void *)(poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->rrd_name, (const void *)(poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->arg1, (const void *)(poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->result);
                  if(!(return_value_spine_log$81 == 0))
                    (_Bool)1;

                  else
                    (_Bool)0;
                }

                else
                  (_Bool)0;
              }
              num_oids = 0;
              memset((void *)snmp_oids, 0, sizeof(struct snmp_oids) /*1540ul*/  * (unsigned long int)host->max_oids);
            }

            snmp_host_cleanup(host->snmp_session);
            host->snmp_session=snmp_host_init(host->id, (poller_items + (signed long int)i)->hostname, (poller_items + (signed long int)i)->snmp_version, (poller_items + (signed long int)i)->snmp_community, (poller_items + (signed long int)i)->snmp_username, (poller_items + (signed long int)i)->snmp_password, (poller_items + (signed long int)i)->snmp_auth_protocol, (poller_items + (signed long int)i)->snmp_priv_passphrase, (poller_items + (signed long int)i)->snmp_priv_protocol, (poller_items + (signed long int)i)->snmp_context, (poller_items + (signed long int)i)->snmp_port, (poller_items + (signed long int)i)->snmp_timeout);
            last_snmp_port = (poller_items + (signed long int)i)->snmp_port;
            last_snmp_version = (poller_items + (signed long int)i)->snmp_version;
            strncopy(last_snmp_community, (poller_items + (signed long int)i)->snmp_community, sizeof(char [50l]) /*50ul*/ );
            strncopy(last_snmp_username, (poller_items + (signed long int)i)->snmp_username, sizeof(char [50l]) /*50ul*/ );
            strncopy(last_snmp_password, (poller_items + (signed long int)i)->snmp_password, sizeof(char [50l]) /*50ul*/ );
            strncopy(last_snmp_auth_protocol, (poller_items + (signed long int)i)->snmp_auth_protocol, sizeof(char [5l]) /*5ul*/ );
            strncopy(last_snmp_priv_passphrase, (poller_items + (signed long int)i)->snmp_priv_passphrase, sizeof(char [200l]) /*200ul*/ );
            strncopy(last_snmp_priv_protocol, (poller_items + (signed long int)i)->snmp_priv_protocol, sizeof(char [7l]) /*7ul*/ );
            strncopy(last_snmp_context, (poller_items + (signed long int)i)->snmp_context, sizeof(char [65l]) /*65ul*/ );
          }

          if(num_oids >= host->max_oids)
          {
            snmp_get_multi(host, snmp_oids, num_oids);
            j = 0;
            for( ; !(j >= num_oids); j = j + 1)
            {
              if(!(host->ignore_host == 0))
              {
                spine_log("Host[%i] TH[%i] DS[%i] WARNING: SNMP timeout detected [%i ms], ignoring host '%s'", host_id, host_thread, (poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->local_data_id, host->snmp_timeout, (const void *)host->hostname);
                (snmp_oids + (signed long int)j)->result[(signed long int)0] = (char)85;
                (snmp_oids + (signed long int)j)->result[(signed long int)1] = (char)0;
              }

              else
              {
                if((signed int)(snmp_oids + (signed long int)j)->result[0l] == 85)
                  tmp_if_expr$110 = (signed int)(snmp_oids + (signed long int)j)->result[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$110 = (_Bool)0;
                if(!tmp_if_expr$110)
                {
                  return_value_is_numeric$107=is_numeric((snmp_oids + (signed long int)j)->result);
                  if(!(return_value_is_numeric$107 == 0))
                    tmp_if_expr$109 = (_Bool)1;

                  else
                  {
                    return_value_is_multipart_output$108=is_multipart_output((snmp_oids + (signed long int)j)->result);
                    tmp_if_expr$109 = return_value_is_multipart_output$108 != 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(!tmp_if_expr$109)
                  {
                    return_value_is_hexadecimal$106=is_hexadecimal((snmp_oids + (signed long int)j)->result, (const signed short int)1);
                    if(!(return_value_is_hexadecimal$106 == 0))
                    {
                      unsigned long long int return_value_hex2dec$99;
                      return_value_hex2dec$99=hex2dec((snmp_oids + (signed long int)j)->result);
                      snprintf((snmp_oids + (signed long int)j)->result, (unsigned long int)1024, "%lld", return_value_hex2dec$99);
                    }

                    else
                    {
                      return_value_strcasecmp$103=strcasecmp((snmp_oids + (signed long int)j)->result, "U");
                      if(return_value_strcasecmp$103 == 0)
                        tmp_if_expr$105 = (_Bool)1;

                      else
                      {
                        return_value_strcasecmp$104=strcasecmp((snmp_oids + (signed long int)j)->result, "Nan");
                        tmp_if_expr$105 = return_value_strcasecmp$104 == 0 ? (_Bool)1 : (_Bool)0;
                      }
                      if(!tmp_if_expr$105)
                      {
                        char *return_value_trim$100;
                        return_value_trim$100=trim((snmp_oids + (signed long int)j)->result);
                        char *return_value_strip_alpha$101;
                        return_value_strip_alpha$101=strip_alpha(return_value_trim$100);
                        snprintf(temp_result, (unsigned long int)1024, "%s", return_value_strip_alpha$101);
                        snprintf((snmp_oids + (signed long int)j)->result, (unsigned long int)1024, "%s", (const void *)temp_result);
                        signed int return_value_validate_result$102;
                        return_value_validate_result$102=validate_result((snmp_oids + (signed long int)j)->result);
                        if(return_value_validate_result$102 == 0)
                        {
                          (snmp_oids + (signed long int)j)->result[(signed long int)0] = (char)85;
                          (snmp_oids + (signed long int)j)->result[(signed long int)1] = (char)0;
                        }

                      }

                    }
                  }

                }

              }
              snprintf((poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->result, (unsigned long int)1024, "%s", (const void *)(snmp_oids + (signed long int)j)->result);
              if(set.log_level >= 3)
              {
                return_value_spine_log$111=spine_log("Host[%i] TH[%i] DS[%i] SNMP: v%i: %s, dsname: %s, oid: %s, value: %s", host_id, host_thread, (poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->local_data_id, host->snmp_version, (const void *)host->hostname, (const void *)(poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->rrd_name, (const void *)(poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->arg1, (const void *)(poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->result);
                if(!(return_value_spine_log$111 == 0))
                  (_Bool)1;

                else
                  (_Bool)0;
              }

              else
                (_Bool)0;
              if(!(spike_kill == 0))
              {
                return_value_strstr$112=strstr((poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->result, ":");
                if(return_value_strstr$112 == ((char *)NULL))
                {
                  (poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->result[(signed long int)0] = (char)85;
                  (poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->result[(signed long int)1] = (char)0;
                }

              }

            }
            num_oids = 0;
            memset((void *)snmp_oids, 0, sizeof(struct snmp_oids) /*1540ul*/  * (unsigned long int)host->max_oids);
          }

          snprintf((snmp_oids + (signed long int)num_oids)->oid, sizeof(char [512l]) /*512ul*/ , "%s", (const void *)(poller_items + (signed long int)i)->arg1);
          (snmp_oids + (signed long int)num_oids)->array_position = i;
          num_oids = num_oids + 1;
          break;
        }
        case 1:
        {
          poll_result=exec_poll(host, (poller_items + (signed long int)i)->arg1);
          if((signed int)*poll_result == 85)
            tmp_if_expr$122 = (signed int)poll_result[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$122 = (_Bool)0;
          if(tmp_if_expr$122)
          {
            (poller_items + (signed long int)i)->result[(signed long int)0] = (char)85;
            (poller_items + (signed long int)i)->result[(signed long int)1] = (char)0;
          }

          else
          {
            return_value_is_numeric$118=is_numeric(poll_result);
            if(!(return_value_is_numeric$118 == 0))
              tmp_if_expr$121 = (_Bool)1;

            else
            {
              return_value_trim$119=trim(poll_result);
              return_value_is_multipart_output$120=is_multipart_output(return_value_trim$119);
              tmp_if_expr$121 = return_value_is_multipart_output$120 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$121)
              snprintf((poller_items + (signed long int)i)->result, (unsigned long int)1024, "%s", poll_result);

            else
            {
              return_value_is_hexadecimal$117=is_hexadecimal((snmp_oids + (signed long int)j)->result, (const signed short int)1);
              if(!(return_value_is_hexadecimal$117 == 0))
              {
                unsigned long long int return_value_hex2dec$113;
                return_value_hex2dec$113=hex2dec(poll_result);
                snprintf((poller_items + (signed long int)i)->result, (unsigned long int)1024, "%lld", return_value_hex2dec$113);
              }

              else
              {
                char *return_value_trim$114;
                return_value_trim$114=trim(poll_result);
                char *return_value_strip_alpha$115;
                return_value_strip_alpha$115=strip_alpha(return_value_trim$114);
                snprintf(temp_result, (unsigned long int)1024, "%s", return_value_strip_alpha$115);
                snprintf((poller_items + (signed long int)i)->result, (unsigned long int)1024, "%s", (const void *)temp_result);
                signed int return_value_validate_result$116;
                return_value_validate_result$116=validate_result((poller_items + (signed long int)i)->result);
                if(return_value_validate_result$116 == 0)
                {
                  (poller_items + (signed long int)i)->result[(signed long int)0] = (char)85;
                  (poller_items + (signed long int)i)->result[(signed long int)1] = (char)0;
                }

              }
            }
          }
          if(!(poll_result == ((char *)NULL)))
            free((void *)poll_result);

          if(set.log_level >= 3)
          {
            return_value_spine_log$123=spine_log("Host[%i] TH[%i] DS[%i] SCRIPT: %s, output: %s", host_id, host_thread, (poller_items + (signed long int)i)->local_data_id, (const void *)(poller_items + (signed long int)i)->arg1, (const void *)(poller_items + (signed long int)i)->result);
            if(!(return_value_spine_log$123 == 0))
              (_Bool)1;

            else
              (_Bool)0;
          }

          else
            (_Bool)0;
          if(!(spike_kill == 0))
          {
            return_value_strstr$124=strstr((poller_items + (signed long int)i)->result, ":");
            if(return_value_strstr$124 == ((char *)NULL))
            {
              (poller_items + (signed long int)i)->result[(signed long int)0] = (char)85;
              (poller_items + (signed long int)i)->result[(signed long int)1] = (char)0;
            }

          }

          break;
        }
        case 2:
        {
          php_process=php_get_process();
          poll_result=php_cmd((poller_items + (signed long int)i)->arg1, php_process);
          if((signed int)*poll_result == 85)
            tmp_if_expr$134 = (signed int)poll_result[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$134 = (_Bool)0;
          if(tmp_if_expr$134)
          {
            (poller_items + (signed long int)i)->result[(signed long int)0] = (char)85;
            (poller_items + (signed long int)i)->result[(signed long int)1] = (char)0;
          }

          else
          {
            return_value_is_numeric$130=is_numeric(poll_result);
            if(!(return_value_is_numeric$130 == 0))
              tmp_if_expr$133 = (_Bool)1;

            else
            {
              return_value_trim$131=trim(poll_result);
              return_value_is_multipart_output$132=is_multipart_output(return_value_trim$131);
              tmp_if_expr$133 = return_value_is_multipart_output$132 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$133)
              snprintf((poller_items + (signed long int)i)->result, (unsigned long int)1024, "%s", poll_result);

            else
            {
              return_value_is_hexadecimal$129=is_hexadecimal((snmp_oids + (signed long int)j)->result, (const signed short int)1);
              if(!(return_value_is_hexadecimal$129 == 0))
              {
                unsigned long long int return_value_hex2dec$125;
                return_value_hex2dec$125=hex2dec(poll_result);
                snprintf((poller_items + (signed long int)i)->result, (unsigned long int)1024, "%lld", return_value_hex2dec$125);
              }

              else
              {
                char *return_value_trim$126;
                return_value_trim$126=trim(poll_result);
                char *return_value_strip_alpha$127;
                return_value_strip_alpha$127=strip_alpha(return_value_trim$126);
                snprintf(temp_result, (unsigned long int)1024, "%s", return_value_strip_alpha$127);
                snprintf((poller_items + (signed long int)i)->result, (unsigned long int)1024, "%s", (const void *)temp_result);
                signed int return_value_validate_result$128;
                return_value_validate_result$128=validate_result((poller_items + (signed long int)i)->result);
                if(return_value_validate_result$128 == 0)
                {
                  (poller_items + (signed long int)i)->result[(signed long int)0] = (char)85;
                  (poller_items + (signed long int)i)->result[(signed long int)1] = (char)0;
                }

              }
            }
          }
          if(!(poll_result == ((char *)NULL)))
            free((void *)poll_result);

          if(set.log_level >= 3)
          {
            return_value_spine_log$135=spine_log("Host[%i] TH[%i] DS[%i] SS[%i] SERVER: %s, output: %s", host_id, host_thread, (poller_items + (signed long int)i)->local_data_id, php_process, (const void *)(poller_items + (signed long int)i)->arg1, (const void *)(poller_items + (signed long int)i)->result);
            if(!(return_value_spine_log$135 == 0))
              (_Bool)1;

            else
              (_Bool)0;
          }

          else
            (_Bool)0;
          if(!(spike_kill == 0))
          {
            return_value_strcasecmp$136=strcasecmp((poller_items + (signed long int)i)->result, ":");
            if(!(return_value_strcasecmp$136 == 0))
            {
              (poller_items + (signed long int)i)->result[(signed long int)0] = (char)85;
              (poller_items + (signed long int)i)->result[(signed long int)1] = (char)0;
            }

          }

          break;
        }
        default:
          spine_log("Host[%i] TH[%i] DS[%i] ERROR: Unknown Poller Action: %s", host_id, host_thread, (poller_items + (signed long int)i)->local_data_id, (const void *)(poller_items + (signed long int)i)->arg1);
      }
      i = i + 1;
    }
    if(num_oids >= 1)
    {
      snmp_get_multi(host, snmp_oids, num_oids);
      j = 0;
      for( ; !(j >= num_oids); j = j + 1)
      {
        if(!(host->ignore_host == 0))
        {
          spine_log("Host[%i] TH[%i] DS[%i] WARNING: SNMP timeout detected [%i ms], ignoring host '%s'", host_id, host_thread, (poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->local_data_id, host->snmp_timeout, (const void *)host->hostname);
          (snmp_oids + (signed long int)j)->result[(signed long int)0] = (char)85;
          (snmp_oids + (signed long int)j)->result[(signed long int)1] = (char)0;
        }

        else
        {
          if((signed int)(snmp_oids + (signed long int)j)->result[0l] == 85)
            tmp_if_expr$148 = (signed int)(snmp_oids + (signed long int)j)->result[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$148 = (_Bool)0;
          if(!tmp_if_expr$148)
          {
            return_value_is_numeric$145=is_numeric((snmp_oids + (signed long int)j)->result);
            if(!(return_value_is_numeric$145 == 0))
              tmp_if_expr$147 = (_Bool)1;

            else
            {
              return_value_is_multipart_output$146=is_multipart_output((snmp_oids + (signed long int)j)->result);
              tmp_if_expr$147 = return_value_is_multipart_output$146 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(!tmp_if_expr$147)
            {
              return_value_is_hexadecimal$144=is_hexadecimal((snmp_oids + (signed long int)j)->result, (const signed short int)1);
              if(!(return_value_is_hexadecimal$144 == 0))
              {
                unsigned long long int return_value_hex2dec$137;
                return_value_hex2dec$137=hex2dec((snmp_oids + (signed long int)j)->result);
                snprintf((snmp_oids + (signed long int)j)->result, (unsigned long int)1024, "%lld", return_value_hex2dec$137);
              }

              else
              {
                return_value_strcasecmp$141=strcasecmp((snmp_oids + (signed long int)j)->result, "U");
                if(return_value_strcasecmp$141 == 0)
                  tmp_if_expr$143 = (_Bool)1;

                else
                {
                  return_value_strcasecmp$142=strcasecmp((snmp_oids + (signed long int)j)->result, "Nan");
                  tmp_if_expr$143 = return_value_strcasecmp$142 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(!tmp_if_expr$143)
                {
                  char *return_value_trim$138;
                  return_value_trim$138=trim((snmp_oids + (signed long int)j)->result);
                  char *return_value_strip_alpha$139;
                  return_value_strip_alpha$139=strip_alpha(return_value_trim$138);
                  snprintf(temp_result, (unsigned long int)1024, "%s", return_value_strip_alpha$139);
                  snprintf((snmp_oids + (signed long int)j)->result, (unsigned long int)1024, "%s", (const void *)temp_result);
                  signed int return_value_validate_result$140;
                  return_value_validate_result$140=validate_result((snmp_oids + (signed long int)j)->result);
                  if(return_value_validate_result$140 == 0)
                  {
                    (snmp_oids + (signed long int)j)->result[(signed long int)0] = (char)85;
                    (snmp_oids + (signed long int)j)->result[(signed long int)1] = (char)0;
                  }

                }

              }
            }

          }

        }
        snprintf((poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->result, (unsigned long int)1024, "%s", (const void *)(snmp_oids + (signed long int)j)->result);
        if(set.log_level >= 3)
        {
          return_value_spine_log$149=spine_log("Host[%i] TH[%i] DS[%i] SNMP: v%i: %s, dsname: %s, oid: %s, value: %s", host_id, host_thread, (poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->local_data_id, host->snmp_version, (const void *)host->hostname, (const void *)(poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->rrd_name, (const void *)(poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->arg1, (const void *)(poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->result);
          if(!(return_value_spine_log$149 == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
        if(!(spike_kill == 0))
        {
          return_value_strstr$150=strstr((poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->result, ":");
          if(return_value_strstr$150 == ((char *)NULL))
          {
            (poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->result[(signed long int)0] = (char)85;
            (poller_items + (signed long int)(snmp_oids + (signed long int)j)->array_position)->result[(signed long int)1] = (char)0;
          }

        }

      }
    }

    void *return_value_malloc$151;
    return_value_malloc$151=malloc((unsigned long int)(65536 + 1024));
    query3 = (char *)return_value_malloc$151;
    if(query3 == ((char *)NULL))
      die("ERROR: Fatal malloc error: poller.c query3 output buffer!");

    query3[(signed long int)0] = (char)0;
    unsigned long int return_value_strlen$152;
    return_value_strlen$152=strlen(query8);
    strncat(query3, query8, return_value_strlen$152);
    out_buffer=strlen(query3);
    if(!(set.boost_redirect == 0))
    {
      void *return_value_malloc$153;
      return_value_malloc$153=malloc((unsigned long int)(65536 + 1024));
      query12 = (char *)return_value_malloc$153;
      if(query12 == ((char *)NULL))
        die("ERROR: Fatal malloc error: poller.c query12 boost output buffer!");

      query12[(signed long int)0] = (char)0;
      unsigned long int return_value_strlen$154;
      return_value_strlen$154=strlen(query11);
      strncat(query12, query11, return_value_strlen$154);
    }

    i = 0;
    while(!(i >= rows_processed))
    {
      snprintf(result_string, (unsigned long int)(1024 + 256), " (%i,'%s','%s','%s')", (poller_items + (signed long int)i)->local_data_id, (const void *)(poller_items + (signed long int)i)->rrd_name, host_time, (const void *)(poller_items + (signed long int)i)->result);
      unsigned long int return_value_strlen$155;
      return_value_strlen$155=strlen(result_string);
      result_length = (signed int)return_value_strlen$155;
      if(out_buffer + (unsigned long int)result_length >= 65536ul)
      {
        unsigned long int return_value_strlen$156;
        return_value_strlen$156=strlen(posuffix);
        strncat(query3, posuffix, return_value_strlen$156);
        db_insert(&mysql, query3);
        query3[(signed long int)0] = (char)0;
        unsigned long int return_value_strlen$157;
        return_value_strlen$157=strlen(query8);
        strncat(query3, query8, return_value_strlen$157);
        if(!(set.boost_redirect == 0))
        {
          unsigned long int return_value_strlen$158;
          return_value_strlen$158=strlen(posuffix);
          strncat(query12, posuffix, return_value_strlen$158);
          db_insert(&mysql, query12);
          query12[(signed long int)0] = (char)0;
          unsigned long int return_value_strlen$159;
          return_value_strlen$159=strlen(query11);
          strncat(query12, query11, return_value_strlen$159);
        }

        out_buffer=strlen(query3);
        new_buffer = 1;
      }

      if(!(new_buffer == 0))
        result_string[(signed long int)0] = (char)32;

      else
        result_string[(signed long int)0] = (char)44;
      unsigned long int return_value_strlen$160;
      return_value_strlen$160=strlen(result_string);
      strncat(query3, result_string, return_value_strlen$160);
      if(!(set.boost_redirect == 0))
      {
        unsigned long int return_value_strlen$161;
        return_value_strlen$161=strlen(result_string);
        strncat(query12, result_string, return_value_strlen$161);
      }

      unsigned long int return_value_strlen$162;
      return_value_strlen$162=strlen(result_string);
      out_buffer = out_buffer + return_value_strlen$162;
      new_buffer = 0;
      i = i + 1;
    }
    unsigned long int return_value_strlen$165;
    return_value_strlen$165=strlen(query8);
    if(!(return_value_strlen$165 >= out_buffer))
    {
      unsigned long int return_value_strlen$163;
      return_value_strlen$163=strlen(posuffix);
      strncat(query3, posuffix, return_value_strlen$163);
      db_insert(&mysql, query3);
      if(!(set.boost_redirect == 0))
      {
        unsigned long int return_value_strlen$164;
        return_value_strlen$164=strlen(posuffix);
        strncat(query12, posuffix, return_value_strlen$164);
        db_insert(&mysql, query12);
      }

    }

    if(!(host->snmp_session == NULL))
      snmp_host_cleanup(host->snmp_session);

    free((void *)query3);
    if(!(set.boost_redirect == 0))
      free((void *)query12);

    free((void *)poller_items);
    free((void *)snmp_oids);
  }

  else
    mysql_free_result(result);
  free((void *)host);
  free((void *)reindex);
  free((void *)ping);
  if(host_thread == last_host_thread)
    db_query(&mysql, query6);

  double return_value_get_time_as_double$166;
  return_value_get_time_as_double$166=get_time_as_double();
  poll_time = return_value_get_time_as_double$166 - poll_time;
  signed int return_value_spine_log$167;
  if(set.log_level >= 3)
  {
    return_value_spine_log$167=spine_log("Host[%i] TH[%i] Total Time: %5.2g Seconds", host_id, host_thread, poll_time);
    if(!(return_value_spine_log$167 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  mysql_close(&mysql);
  mysql_thread_end();
  signed int return_value_spine_log$168;
  if(set.log_level >= 5)
  {
    return_value_spine_log$168=spine_log("Host[%i] TH[%i] DEBUG: HOST COMPLETE: About to Exit Host Polling Thread Function", host_id, host_thread);
    if(!(return_value_spine_log$168 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;

__CPROVER_DUMP_L358:
  ;
}

// printable_action
// file keywords.c line 184
extern const char * printable_action(signed int token)
{
  const char *return_value_find_keyword_by_value$1;
  return_value_find_keyword_by_value$1=find_keyword_by_value(actions, token, "-unknown-");
  return return_value_find_keyword_by_value$1;
}

// printable_log_level
// file keywords.c line 168
extern const char * printable_log_level(signed int token)
{
  const char *return_value_find_keyword_by_value$1;
  return_value_find_keyword_by_value$1=find_keyword_by_value(log_level, token, "-unknown-");
  return return_value_find_keyword_by_value$1;
}

// printable_logdest
// file keywords.h line 37
extern const char * printable_logdest(signed int token)
{
  const char *return_value_find_keyword_by_value$1;
  return_value_find_keyword_by_value$1=find_keyword_by_value(logdest, token, "-unknown-");
  return return_value_find_keyword_by_value$1;
}

// read_config_options
// file util.h line 35
extern void read_config_options(void)
{
  struct st_mysql mysql;
  struct st_mysql_res *result;
  signed int num_rows;
  char web_root[1024l];
  char sqlbuf[256l];
  char *sqlp = sqlbuf;
  const char *res;
  db_connect(set.dbdb, &mysql);
  set.dbversion = 0;
  res=getglobalvariable(&mysql, "version");
  if(!(res == ((const char *)NULL)))
    set.dbversion=atoi(res);

  res=getsetting(&mysql, "log_verbosity");
  if(!(res == ((const char *)NULL)))
  {
    signed int n;
    n=atoi(res);
    if(!(n == 0))
      set.log_level = n;

  }

  res=getsetting(&mysql, "path_webroot");
  if(!(res == ((const char *)NULL)))
  {
    snprintf(set.path_php_server, (unsigned long int)256, "%s/script_server.php", res);
    snprintf(web_root, (unsigned long int)1024, "%s", res);
  }

  res=getsetting(&mysql, "path_cactilog");
  if(!(res == ((const char *)NULL)))
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(res);
    if(!(return_value_strlen$2 == 0ul))
      snprintf(set.path_logfile, (unsigned long int)256, "%s", res);

    else
    {
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(web_root);
      if(!(return_value_strlen$1 == 0ul))
        snprintf(set.path_logfile, (unsigned long int)256, "%s/log/cacti.log", (const void *)web_root);

      else
        set.path_logfile[(signed long int)0] = (char)0;
    }
  }

  else
    snprintf(set.path_logfile, (unsigned long int)256, "%s/log/cacti.log", (const void *)web_root);
  signed int return_value_spine_log$3;
  if(set.log_level >= 5)
  {
    return_value_spine_log$3=spine_log("DEBUG: The path_php_server variable is %s", (const void *)set.path_php_server);
    if(!(return_value_spine_log$3 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  signed int return_value_spine_log$4;
  if(set.log_level >= 5)
  {
    return_value_spine_log$4=spine_log("DEBUG: The path_cactilog variable is %s", (const void *)set.path_logfile);
    if(!(return_value_spine_log$4 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  res=getsetting(&mysql, "log_destination");
  if(!(res == ((const char *)NULL)))
    set.log_destination=parse_logdest(res, 1);

  else
    set.log_destination = 1;
  const char *return_value_printable_logdest$5;
  signed int return_value_spine_log$6;
  if(set.log_level >= 5)
  {
    return_value_printable_logdest$5=printable_logdest(set.log_destination);
    return_value_spine_log$6=spine_log("DEBUG: The log_destination variable is %i (%s)", set.log_destination, return_value_printable_logdest$5);
    if(!(return_value_spine_log$6 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  set.logfile_processed = 1;
  res=getsetting(&mysql, "path_php_binary");
  if(!(res == ((const char *)NULL)))
    strncopy(set.path_php, res, sizeof(char [256l]) /*256ul*/ );

  signed int return_value_spine_log$7;
  if(set.log_level >= 5)
  {
    return_value_spine_log$7=spine_log("DEBUG: The path_php variable is %s", (const void *)set.path_php);
    if(!(return_value_spine_log$7 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  res=getsetting(&mysql, "availability_method");
  if(!(res == ((const char *)NULL)))
    set.availability_method=atoi(res);

  signed int return_value_spine_log$8;
  if(set.log_level >= 5)
  {
    return_value_spine_log$8=spine_log("DEBUG: The availability_method variable is %i", set.availability_method);
    if(!(return_value_spine_log$8 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  res=getsetting(&mysql, "ping_recovery_count");
  if(!(res == ((const char *)NULL)))
    set.ping_recovery_count=atoi(res);

  signed int return_value_spine_log$9;
  if(set.log_level >= 5)
  {
    return_value_spine_log$9=spine_log("DEBUG: The ping_recovery_count variable is %i", set.ping_recovery_count);
    if(!(return_value_spine_log$9 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  res=getsetting(&mysql, "ping_failure_count");
  if(!(res == ((const char *)NULL)))
    set.ping_failure_count=atoi(res);

  signed int return_value_spine_log$10;
  if(set.log_level >= 5)
  {
    return_value_spine_log$10=spine_log("DEBUG: The ping_failure_count variable is %i", set.ping_failure_count);
    if(!(return_value_spine_log$10 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  res=getsetting(&mysql, "ping_method");
  if(!(res == ((const char *)NULL)))
    set.ping_method=atoi(res);

  signed int return_value_spine_log$11;
  if(set.log_level >= 5)
  {
    return_value_spine_log$11=spine_log("DEBUG: The ping_method variable is %i", set.ping_method);
    if(!(return_value_spine_log$11 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  res=getsetting(&mysql, "ping_retries");
  if(!(res == ((const char *)NULL)))
    set.ping_retries=atoi(res);

  signed int return_value_spine_log$12;
  if(set.log_level >= 5)
  {
    return_value_spine_log$12=spine_log("DEBUG: The ping_retries variable is %i", set.ping_retries);
    if(!(return_value_spine_log$12 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  res=getsetting(&mysql, "ping_timeout");
  if(!(res == ((const char *)NULL)))
    set.ping_timeout=atoi(res);

  signed int return_value_spine_log$13;
  if(set.log_level >= 5)
  {
    return_value_spine_log$13=spine_log("DEBUG: The ping_timeout variable is %i", set.ping_timeout);
    if(!(return_value_spine_log$13 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  res=getsetting(&mysql, "snmp_retries");
  if(!(res == ((const char *)NULL)))
    set.snmp_retries=atoi(res);

  signed int return_value_spine_log$14;
  if(set.log_level >= 5)
  {
    return_value_spine_log$14=spine_log("DEBUG: The snmp_retries variable is %i", set.snmp_retries);
    if(!(return_value_spine_log$14 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  set.log_perror=getboolsetting(&mysql, "log_perror", 0);
  signed int return_value_spine_log$15;
  if(set.log_level >= 5)
  {
    return_value_spine_log$15=spine_log("DEBUG: The log_perror variable is %i", set.log_perror);
    if(!(return_value_spine_log$15 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  set.log_pwarn=getboolsetting(&mysql, "log_pwarn", 0);
  signed int return_value_spine_log$16;
  if(set.log_level >= 5)
  {
    return_value_spine_log$16=spine_log("DEBUG: The log_pwarn variable is %i", set.log_pwarn);
    if(!(return_value_spine_log$16 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  set.boost_redirect=getboolsetting(&mysql, "boost_redirect", 0);
  signed int return_value_spine_log$17;
  if(set.log_level >= 5)
  {
    return_value_spine_log$17=spine_log("DEBUG: The boost_redirect variable is %i", set.boost_redirect);
    if(!(return_value_spine_log$17 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  set.log_pstats=getboolsetting(&mysql, "log_pstats", 0);
  signed int return_value_spine_log$18;
  if(set.log_level >= 5)
  {
    return_value_spine_log$18=spine_log("DEBUG: The log_pstats variable is %i", set.log_pstats);
    if(!(return_value_spine_log$18 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  res=getsetting(&mysql, "max_threads");
  if(!(res == ((const char *)NULL)))
  {
    set.threads=atoi(res);
    if(set.threads >= 101)
      set.threads = 100;

  }

  signed int return_value_spine_log$19;
  if(set.log_level >= 5)
  {
    return_value_spine_log$19=spine_log("DEBUG: The threads variable is %i", set.threads);
    if(!(return_value_spine_log$19 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  res=getsetting(&mysql, "poller_interval");
  if(!(res == ((const char *)NULL)))
    set.poller_interval=atoi(res);

  else
    set.poller_interval = 0;
  signed int return_value_spine_log$20;
  signed int return_value_spine_log$21;
  if(set.poller_interval == 0)
  {
    if(set.log_level >= 5)
    {
      return_value_spine_log$20=spine_log("DEBUG: The polling interval is the system default");
      if(!(return_value_spine_log$20 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
  }

  else
    if(set.log_level >= 5)
    {
      return_value_spine_log$21=spine_log("DEBUG: The polling interval is %i seconds", set.poller_interval);
      if(!(return_value_spine_log$21 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
  res=getsetting(&mysql, "concurrent_processes");
  if(!(res == ((const char *)NULL)))
    set.num_parent_processes=atoi(res);

  else
    set.num_parent_processes = 1;
  signed int return_value_spine_log$22;
  if(set.log_level >= 5)
  {
    return_value_spine_log$22=spine_log("DEBUG: The number of concurrent processes is %i", set.num_parent_processes);
    if(!(return_value_spine_log$22 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  res=getsetting(&mysql, "script_timeout");
  if(!(res == ((const char *)NULL)))
  {
    set.script_timeout=atoi(res);
    if(!(set.script_timeout >= 5))
      set.script_timeout = 5;

  }

  else
    set.script_timeout = 25;
  signed int return_value_spine_log$23;
  if(set.log_level >= 5)
  {
    return_value_spine_log$23=spine_log("DEBUG: The script timeout is %i", set.script_timeout);
    if(!(return_value_spine_log$23 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  res=getsetting(&mysql, "php_servers");
  if(!(res == ((const char *)NULL)))
  {
    set.php_servers=atoi(res);
    if(set.php_servers >= 11)
      set.php_servers = 10;

    if(!(set.php_servers >= 1))
      set.php_servers = 1;

  }

  else
    set.php_servers = 2;
  signed int return_value_spine_log$24;
  if(set.log_level >= 5)
  {
    return_value_spine_log$24=spine_log("DEBUG: The number of php script servers to run is %i", set.php_servers);
    if(!(return_value_spine_log$24 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  set.php_required = 0;
  unsigned long int return_value_strlen$39;
  return_value_strlen$39=strlen(set.host_id_list);
  signed int return_value_spine_log$31;
  signed int return_value_spine_log$38;
  if(return_value_strlen$39 == 0ul)
  {
    sqlp = sqlbuf;
    signed int return_value_sprintf$25;
    return_value_sprintf$25=sprintf(sqlp, "SELECT action FROM poller_item");
    sqlp = sqlp + (signed long int)return_value_sprintf$25;
    signed int return_value_sprintf$26;
    return_value_sprintf$26=sprintf(sqlp, " WHERE action=%d", 2);
    sqlp = sqlp + (signed long int)return_value_sprintf$26;
    signed int return_value_append_hostrange$27;
    return_value_append_hostrange$27=append_hostrange(sqlp, "host_id");
    sqlp = sqlp + (signed long int)return_value_append_hostrange$27;
    if(!(set.poller_id_exists == 0))
    {
      signed int return_value_sprintf$28;
      return_value_sprintf$28=sprintf(sqlp, " AND poller_id=%i", set.poller_id);
      sqlp = sqlp + (signed long int)return_value_sprintf$28;
    }

    signed int return_value_sprintf$29;
    return_value_sprintf$29=sprintf(sqlp, " LIMIT 1");
    sqlp = sqlp + (signed long int)return_value_sprintf$29;
    result=db_query(&mysql, sqlbuf);
    unsigned long long int return_value_mysql_num_rows$30;
    return_value_mysql_num_rows$30=mysql_num_rows(result);
    num_rows = (signed int)return_value_mysql_num_rows$30;
    if(num_rows >= 1)
      set.php_required = 1;

    if(set.log_level >= 5)
    {
      return_value_spine_log$31=spine_log("DEBUG: StartHost='%i', EndHost='%i', TotalPHPScripts='%i'", set.start_host_id, set.end_host_id, num_rows);
      if(!(return_value_spine_log$31 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
  }

  else
  {
    sqlp = sqlbuf;
    signed int return_value_sprintf$32;
    return_value_sprintf$32=sprintf(sqlp, "SELECT action FROM poller_item");
    sqlp = sqlp + (signed long int)return_value_sprintf$32;
    signed int return_value_sprintf$33;
    return_value_sprintf$33=sprintf(sqlp, " WHERE action=%d", 2);
    sqlp = sqlp + (signed long int)return_value_sprintf$33;
    signed int return_value_sprintf$34;
    return_value_sprintf$34=sprintf(sqlp, " AND host_id IN(%s)", (const void *)set.host_id_list);
    sqlp = sqlp + (signed long int)return_value_sprintf$34;
    if(!(set.poller_id_exists == 0))
    {
      signed int return_value_sprintf$35;
      return_value_sprintf$35=sprintf(sqlp, " AND poller_id=%i", set.poller_id);
      sqlp = sqlp + (signed long int)return_value_sprintf$35;
    }

    signed int return_value_sprintf$36;
    return_value_sprintf$36=sprintf(sqlp, " LIMIT 1");
    sqlp = sqlp + (signed long int)return_value_sprintf$36;
    result=db_query(&mysql, sqlbuf);
    unsigned long long int return_value_mysql_num_rows$37;
    return_value_mysql_num_rows$37=mysql_num_rows(result);
    num_rows = (signed int)return_value_mysql_num_rows$37;
    if(num_rows >= 1)
      set.php_required = 1;

    if(set.log_level >= 5)
    {
      return_value_spine_log$38=spine_log("DEBUG: Host List to be polled='%s', TotalPHPScripts='%i'", (const void *)set.host_id_list, num_rows);
      if(!(return_value_spine_log$38 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
  }
  signed int return_value_spine_log$40;
  if(set.log_level >= 5)
  {
    return_value_spine_log$40=spine_log("DEBUG: The PHP Script Server is %sRequired", set.php_required != 0 ? "" : "Not ");
    if(!(return_value_spine_log$40 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  res=getsetting(&mysql, "max_get_size");
  if(!(res == ((const char *)NULL)))
  {
    set.snmp_max_get_size=atoi(res);
    if(set.snmp_max_get_size >= 129)
      set.snmp_max_get_size = 128;

  }

  else
    set.snmp_max_get_size = 25;
  signed int return_value_spine_log$41;
  if(set.log_level >= 5)
  {
    return_value_spine_log$41=spine_log("DEBUG: The Maximum SNMP OID Get Size is %i", set.snmp_max_get_size);
    if(!(return_value_spine_log$41 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  mysql_free_result(result);
  db_disconnect(&mysql);
}

// read_spine_config
// file util.h line 36
extern signed int read_spine_config(char *file)
{
  struct _IO_FILE *fp;
  char buff[1024l];
  char *buffer;
  char p1[1024l];
  char p2[1024l];
  fp=fopen(file, "rb");
  signed int return_value_feof$1;
  signed int return_value_strcasecmp$10;
  signed int return_value_strcasecmp$9;
  signed int return_value_strcasecmp$8;
  signed int return_value_strcasecmp$7;
  signed int return_value_atoi$2;
  signed int return_value_strcasecmp$6;
  signed int return_value_strcasecmp$5;
  signed int return_value_atoi$3;
  signed int return_value_strcasecmp$4;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    if(set.log_level == 5)
    {
      if(set.stderr_notty == 0)
        fprintf(stderr, "ERROR: Could not open config file [%s]\n", file);

    }

    return -1;
  }

  else
  {
    if(set.stdout_notty == 0)
      fprintf(stdout, "SPINE: Using spine config file [%s]\n", file);

    do
    {
      return_value_feof$1=feof(fp);
      if(!(return_value_feof$1 == 0))
        break;

      buffer=fgets(buff, 1024, fp);
      signed int return_value_feof$12;
      return_value_feof$12=feof(fp);
      if(return_value_feof$12 == 0)
      {
        if(!((signed int)buff[0l] == 35))
        {
          if(!((signed int)buff[0l] == 32))
          {
            if(!((signed int)buff[0l] == 10))
            {
              sscanf(buff, "%15s %255s", (const void *)p1, (const void *)p2);
              signed int return_value_strcasecmp$11;
              return_value_strcasecmp$11=strcasecmp(p1, "DB_Host");
              if(return_value_strcasecmp$11 == 0)
                strncopy(set.dbhost, p2, sizeof(char [256l]) /*256ul*/ );

              else
              {
                return_value_strcasecmp$10=strcasecmp(p1, "DB_Database");
                if(return_value_strcasecmp$10 == 0)
                  strncopy(set.dbdb, p2, sizeof(char [256l]) /*256ul*/ );

                else
                {
                  return_value_strcasecmp$9=strcasecmp(p1, "DB_User");
                  if(return_value_strcasecmp$9 == 0)
                    strncopy(set.dbuser, p2, sizeof(char [256l]) /*256ul*/ );

                  else
                  {
                    return_value_strcasecmp$8=strcasecmp(p1, "DB_Pass");
                    if(return_value_strcasecmp$8 == 0)
                      strncopy(set.dbpass, p2, sizeof(char [256l]) /*256ul*/ );

                    else
                    {
                      return_value_strcasecmp$7=strcasecmp(p1, "DB_Port");
                      if(return_value_strcasecmp$7 == 0)
                      {
                        return_value_atoi$2=atoi(p2);
                        set.dbport = (unsigned int)return_value_atoi$2;
                      }

                      else
                      {
                        return_value_strcasecmp$6=strcasecmp(p1, "Poller");
                        if(return_value_strcasecmp$6 == 0)
                          set.poller_id=atoi(p2);

                        else
                        {
                          return_value_strcasecmp$5=strcasecmp(p1, "DB_PreG");
                          if(return_value_strcasecmp$5 == 0)
                          {
                            return_value_atoi$3=atoi(p2);
                            set.pre087g = (unsigned int)return_value_atoi$3;
                          }

                          else
                          {
                            return_value_strcasecmp$4=strcasecmp(p1, "SNMP_Clientaddr");
                            if(return_value_strcasecmp$4 == 0)
                              strncopy(set.snmp_clientaddr, p2, sizeof(char [256l]) /*256ul*/ );

                            else
                              if(set.stderr_notty == 0)
                                fprintf(stderr, "WARNING: Unrecongized directive: %s=%s in %s\n", (const void *)p1, (const void *)p2, file);

                          }
                        }
                      }
                    }
                  }
                }
              }
              p1[0l] = (char)0;
              p2[0l] = (char)0;
            }

          }

        }

      }

    }
    while((_Bool)1);
    unsigned long int return_value_strlen$13;
    return_value_strlen$13=strlen(set.dbpass);
    if(return_value_strlen$13 == 0ul)
      set.dbpass[0l] = (char)0;

    return 0;
  }
}

// remove_tcp_udp_from_hostname
// file ping.c line 925
extern char * remove_tcp_udp_from_hostname(char *hostname)
{
  char *cleaned_hostname;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(hostname);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(return_value_strlen$1 + (unsigned long int)1);
  cleaned_hostname = (char *)return_value_malloc$2;
  if(cleaned_hostname == ((char *)NULL))
    die("ERROR: Fatal malloc error: ping.c remove_tcp_udp_from_hostname");

  signed int return_value_strncasecmp$5;
  return_value_strncasecmp$5=strncasecmp(hostname, "TCP:", (unsigned long int)4);
  _Bool tmp_if_expr$7;
  signed int return_value_strncasecmp$6;
  if(return_value_strncasecmp$5 == 0)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_strncasecmp$6=strncasecmp(hostname, "UDP:", (unsigned long int)4);
    tmp_if_expr$7 = !(return_value_strncasecmp$6 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$7)
  {
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(hostname);
    memcpy((void *)cleaned_hostname, (const void *)(hostname + (signed long int)4), return_value_strlen$3 - (unsigned long int)4);
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(hostname);
    cleaned_hostname[(signed long int)(return_value_strlen$4 - (unsigned long int)4)] = (char)0;
  }

  else
    strcpy(cleaned_hostname, hostname);
  return cleaned_hostname;
}

// reverse
// file util.c line 1096
extern char * reverse(char *str)
{
  signed int end;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  end = (signed int)(return_value_strlen$1 - (unsigned long int)1);
  signed int start = 0;
  for( ; !(start >= end); end = end - 1)
  {
    str[(signed long int)start] = str[(signed long int)start] ^ str[(signed long int)end];
    str[(signed long int)end] = str[(signed long int)end] ^ str[(signed long int)start];
    str[(signed long int)start] = str[(signed long int)start] ^ str[(signed long int)end];
    start = start + 1;
  }
  return str;
}

// rtrim
// file util.c line 1054
extern char * rtrim(char *str)
{
  char *end;
  char *rtrim$$1$$trim = " \"'\\\t\n\r";
  char *tmp_post$2;
  if(str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    end = str + (signed long int)return_value_strlen$1;
    do
    {
      tmp_post$2 = end;
      end = end - 1l;
      if(str >= tmp_post$2)
        break;

      char *return_value_strchr$3;
      return_value_strchr$3=strchr(rtrim$$1$$trim, (signed int)*end);
      if(return_value_strchr$3 == ((char *)NULL))
        return str;

      *end = (char)0;
    }
    while((_Bool)1);
    return str;
  }
}

// set_option
// file util.h line 48
extern void set_option(const char *option, const char *value)
{
  opttable[(signed long int)nopts].opt = option;
  signed int tmp_post$1 = nopts;
  nopts = nopts + 1;
  opttable[(signed long int)tmp_post$1].val = value;
}

// snmp_count
// file snmp.c line 485
extern signed int snmp_count(struct host_struct *current_host, char *snmp_oid)
{
  struct snmp_pdu *pdu = (struct snmp_pdu *)(void *)0;
  struct snmp_pdu *response = (struct snmp_pdu *)(void *)0;
  struct variable_list *vars = (struct variable_list *)(void *)0;
  unsigned long int anOID_len = (unsigned long int)128;
  unsigned long int rootlen = (unsigned long int)128;
  unsigned long int anOID[128l];
  unsigned long int root[128l];
  signed int status;
  signed int ok = 1;
  signed int error_occurred = 0;
  signed int count = 0;
  char temp_result[1024l];
  status = 99;
  signed int return_value_spine_log$1;
  if(set.log_level >= 5)
  {
    return_value_spine_log$1=spine_log("NOTE: walk starts at OID %s", snmp_oid);
    if(!(return_value_spine_log$1 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  _Bool tmp_if_expr$4;
  signed int return_value_memcmp$3;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  if(!(current_host->snmp_session == NULL))
  {
    rootlen = (unsigned long int)128;
    unsigned long int *return_value_snmp_parse_oid$2;
    return_value_snmp_parse_oid$2=snmp_parse_oid(snmp_oid, root, &rootlen);
    if(return_value_snmp_parse_oid$2 == ((unsigned long int *)NULL))
    {
      spine_log("Host[%i] ERROR: SNMP Count Problems parsing SNMP OID %s", current_host->id, snmp_oid);
      return count;
    }

    memmove((void *)anOID, (const void *)root, rootlen * sizeof(unsigned long int) /*8ul*/ );
    anOID_len = rootlen;
    while(error_occurred == 0 && !(ok == 0))
    {
      pdu=snmp_pdu_create((signed int)(unsigned char)0x80 | (signed int)(unsigned char)0x20 | 0x1);
      snmp_add_null_var(pdu, anOID, anOID_len);
      status=snmp_sess_synch_response(current_host->snmp_session, pdu, &response);
      current_host->snmp_status = status;
      if(status == 0)
      {
        if(response->errstat == 0l)
        {
          vars = response->variables;
          for( ; !(vars == ((struct variable_list *)NULL)); vars = vars->next_variable)
          {
            if(!(vars->name_length >= rootlen))
              tmp_if_expr$4 = (_Bool)1;

            else
            {
              return_value_memcmp$3=memcmp((const void *)root, (const void *)vars->name, rootlen * sizeof(unsigned long int) /*8ul*/ );
              tmp_if_expr$4 = return_value_memcmp$3 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$4)
              ok = 0;

            else
            {
              count = count + 1;
              if(!((signed int)vars->type == 130))
                tmp_if_expr$6 = (signed int)vars->type != ((signed int)(unsigned char)0x80 | (signed int)(unsigned char)0x00 | 0x0) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$6 = (_Bool)0;
              if(tmp_if_expr$6)
                tmp_if_expr$7 = (signed int)vars->type != ((signed int)(unsigned char)0x80 | (signed int)(unsigned char)0x00 | 0x1) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$7 = (_Bool)0;
              if(tmp_if_expr$7)
              {
                signed int return_value_snmp_oid_compare$5;
                return_value_snmp_oid_compare$5=snmp_oid_compare(anOID, anOID_len, vars->name, vars->name_length);
                if(return_value_snmp_oid_compare$5 >= 0)
                {
                  spine_log("ERROR: OID not increasing");
                  ok = 0;
                  error_occurred = 1;
                }

                memmove((void *)(char *)anOID, (const void *)(char *)vars->name, vars->name_length * sizeof(unsigned long int) /*8ul*/ );
                anOID_len = vars->name_length;
              }

              else
                ok = 0;
            }
          }
        }

        else
          spine_log("ERROR: An internal Net-Snmp error condition detected in Cacti snmp_count");
      }

      else
        if(status == 2)
        {
          spine_log("ERROR: Timeout detected in Cacti snmp_count");
          ok = 0;
          error_occurred = 1;
        }

        else
        {
          spine_log("ERROR: An internal Net-Snmp error condition detected in Cacti snmp_count (STAT_ERROR)");
          ok = 0;
          error_occurred = 1;
        }
      if(!(response == ((struct snmp_pdu *)NULL)))
        snmp_free_pdu(response);

    }
  }

  else
    status = 99;
  if(!(status == 0))
    current_host->ignore_host = 1;

  return count;
}

// snmp_get
// file snmp.c line 313
extern char * snmp_get(struct host_struct *current_host, char *snmp_oid)
{
  struct snmp_pdu *pdu = (struct snmp_pdu *)(void *)0;
  struct snmp_pdu *response = (struct snmp_pdu *)(void *)0;
  struct variable_list *vars = (struct variable_list *)(void *)0;
  unsigned long int anOID_len = (unsigned long int)128;
  unsigned long int anOID[128l];
  signed int status;
  char *result_string;
  char temp_result[1024l];
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)1024);
  result_string = (char *)return_value_malloc$1;
  if(result_string == ((char *)NULL))
    die("ERROR: Fatal malloc error: snmp.c snmp_get!");

  result_string[(signed long int)0] = (char)0;
  status = 99;
  if(!(current_host->snmp_session == NULL))
  {
    anOID_len = (unsigned long int)128;
    pdu=snmp_pdu_create((signed int)(unsigned char)0x80 | (signed int)(unsigned char)0x20 | 0x0);
    unsigned long int *return_value_snmp_parse_oid$2;
    return_value_snmp_parse_oid$2=snmp_parse_oid(snmp_oid, anOID, &anOID_len);
    if(return_value_snmp_parse_oid$2 == ((unsigned long int *)NULL))
    {
      spine_log("Host[%i] ERROR: SNMP Get Problems parsing SNMP OID %s", current_host->id, snmp_oid);
      result_string[(signed long int)0] = (char)85;
      result_string[(signed long int)1] = (char)0;
      return result_string;
    }

    else
      snmp_add_null_var(pdu, anOID, anOID_len);
    status=snmp_sess_synch_response(current_host->snmp_session, pdu, &response);
    current_host->snmp_status = status;
    if(status == 0)
    {
      if(response == ((struct snmp_pdu *)NULL))
      {
        spine_log("ERROR: An internal Net-Snmp error condition detected in Cacti snmp_get");
        result_string[(signed long int)0] = (char)85;
        result_string[(signed long int)1] = (char)0;
        status = 1;
      }

      else
        if(response->errstat == 0l)
        {
          vars = response->variables;
          snmp_snprint_value(temp_result, (unsigned long int)1024, vars->name, vars->name_length, vars);
          char *return_value_trim$3;
          return_value_trim$3=trim(temp_result);
          snprintf(result_string, (unsigned long int)1024, "%s", return_value_trim$3);
        }

    }

    if(!(response == ((struct snmp_pdu *)NULL)))
    {
      snmp_free_pdu(response);
      response = (struct snmp_pdu *)(void *)0;
    }

  }

  else
    status = 99;
  if(!(status == 0))
  {
    current_host->ignore_host = 1;
    result_string[(signed long int)0] = (char)85;
    result_string[(signed long int)1] = (char)0;
  }

  return result_string;
}

// snmp_get_multi
// file snmp.c line 618
extern void snmp_get_multi(struct host_struct *current_host, struct snmp_oids *snmp_oids, signed int num_oids)
{
  struct snmp_pdu *pdu = (struct snmp_pdu *)(void *)0;
  struct snmp_pdu *response = (struct snmp_pdu *)(void *)0;
  struct variable_list *vars = (struct variable_list *)(void *)0;
  signed int status;
  signed int i;
  signed int array_count;
  signed int index_count;
  char temp_result[1024l];
  /* snmp_get_multi::1::tag-nameStruct */
struct nameStruct
{
  // name
  unsigned long int name[128l];
  // name_len
  unsigned long int name_len;
};

/* */
  ;
  struct nameStruct *name;
  struct nameStruct *namep;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)num_oids, sizeof(struct nameStruct) /*1032ul*/ );
  name = (struct nameStruct *)return_value_calloc$1;
  namep = name;
  pdu=snmp_pdu_create((signed int)(unsigned char)0x80 | (signed int)(unsigned char)0x20 | 0x0);
  i = 0;
  for( ; !(i >= num_oids); i = i + 1)
  {
    namep->name_len = (unsigned long int)128;
    unsigned long int *return_value_snmp_parse_oid$2;
    return_value_snmp_parse_oid$2=snmp_parse_oid((snmp_oids + (signed long int)i)->oid, namep->name, &namep->name_len);
    if(return_value_snmp_parse_oid$2 == ((unsigned long int *)NULL))
    {
      spine_log("Host[%i] ERROR: Problems parsing Multi SNMP OID! (oid: %s), Set MAX_OIDS to 1 for this host to isolate bad OID", current_host->id, (const void *)(snmp_oids + (signed long int)i)->oid);
      (snmp_oids + (signed long int)i)->result[(signed long int)0] = (char)85;
      (snmp_oids + (signed long int)i)->result[(signed long int)1] = (char)0;
    }

    else
      snmp_add_null_var(pdu, namep->name, namep->name_len);
    namep = namep + 1l;
  }
  status = 99;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  do
  {

  retry:
    ;
    status=snmp_sess_synch_response(current_host->snmp_session, pdu, &response);
    current_host->snmp_status = status;
    if(!(status == 0))
      goto __CPROVER_DUMP_L23;

    if(response == ((struct snmp_pdu *)NULL))
    {
      spine_log("ERROR: An internal Net-Snmp error condition detected in Cacti snmp_get_multi");
      status = 1;
      goto __CPROVER_DUMP_L23;
    }

    if(response->errstat == 0l)
    {
      vars = response->variables;
      i = 0;
      for( ; !(vars == ((struct variable_list *)NULL)) && !(i >= num_oids); i = i + 1)
      {
        if((signed int)(snmp_oids + (signed long int)i)->result[0l] == 85)
          tmp_if_expr$4 = (signed int)(snmp_oids + (signed long int)i)->result[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
        {
          snmp_snprint_value(temp_result, (unsigned long int)1024, vars->name, vars->name_length, vars);
          char *return_value_trim$3;
          return_value_trim$3=trim(temp_result);
          snprintf((snmp_oids + (signed long int)i)->result, (unsigned long int)1024, "%s", return_value_trim$3);
          vars = vars->next_variable;
        }

      }
      goto __CPROVER_DUMP_L23;
    }

    if(response->errindex == 0l)
      goto __CPROVER_DUMP_L22;

    index_count = 1;
    array_count = 0;
    while(!(array_count >= num_oids))
    {
      if((signed int)(snmp_oids + (signed long int)array_count)->result[0l] == 85)
        tmp_if_expr$5 = (signed int)(snmp_oids + (signed long int)array_count)->result[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        array_count = array_count + 1;

      else
      {
        if((signed long int)index_count == response->errindex)
        {
          (snmp_oids + (signed long int)array_count)->result[(signed long int)0] = (char)85;
          (snmp_oids + (signed long int)array_count)->result[(signed long int)1] = (char)0;
          break;
        }

        array_count = array_count + 1;
        index_count = index_count + 1;
      }
    }
    pdu=snmp_fix_pdu(response, (signed int)(unsigned char)0x80 | (signed int)(unsigned char)0x20 | 0x0);
    snmp_free_pdu(response);
    response = (struct snmp_pdu *)(void *)0;
    if(pdu == ((struct snmp_pdu *)NULL))
      break;

  }
  while((_Bool)1);
  status = 0;
  goto __CPROVER_DUMP_L23;

__CPROVER_DUMP_L22:
  ;
  status = 99;

__CPROVER_DUMP_L23:
  ;
  if(!(status == 0))
  {
    current_host->ignore_host = 1;
    i = 0;
    for( ; !(i >= num_oids); i = i + 1)
    {
      (snmp_oids + (signed long int)i)->result[(signed long int)0] = (char)85;
      (snmp_oids + (signed long int)i)->result[(signed long int)1] = (char)0;
    }
  }

  if(!(response == ((struct snmp_pdu *)NULL)))
    snmp_free_pdu(response);

}

// snmp_getnext
// file snmp.c line 397
extern char * snmp_getnext(struct host_struct *current_host, char *snmp_oid)
{
  struct snmp_pdu *pdu = (struct snmp_pdu *)(void *)0;
  struct snmp_pdu *response = (struct snmp_pdu *)(void *)0;
  struct variable_list *vars = (struct variable_list *)(void *)0;
  unsigned long int anOID_len = (unsigned long int)128;
  unsigned long int anOID[128l];
  signed int status;
  char *result_string;
  char temp_result[1024l];
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)1024);
  result_string = (char *)return_value_malloc$1;
  if(result_string == ((char *)NULL))
    die("ERROR: Fatal malloc error: snmp.c snmp_get!");

  result_string[(signed long int)0] = (char)0;
  status = 99;
  if(!(current_host->snmp_session == NULL))
  {
    anOID_len = (unsigned long int)128;
    pdu=snmp_pdu_create((signed int)(unsigned char)0x80 | (signed int)(unsigned char)0x20 | 0x1);
    unsigned long int *return_value_snmp_parse_oid$2;
    return_value_snmp_parse_oid$2=snmp_parse_oid(snmp_oid, anOID, &anOID_len);
    if(return_value_snmp_parse_oid$2 == ((unsigned long int *)NULL))
    {
      spine_log("Host[%i] ERROR: SNMP Getnext Problems parsing SNMP OID %s", current_host->id, snmp_oid);
      result_string[(signed long int)0] = (char)85;
      result_string[(signed long int)1] = (char)0;
      return result_string;
    }

    else
      snmp_add_null_var(pdu, anOID, anOID_len);
    status=snmp_sess_synch_response(current_host->snmp_session, pdu, &response);
    current_host->snmp_status = status;
    if(status == 0)
    {
      if(response == ((struct snmp_pdu *)NULL))
      {
        spine_log("ERROR: An internal Net-Snmp error condition detected in Cacti snmp_get");
        result_string[(signed long int)0] = (char)85;
        result_string[(signed long int)1] = (char)0;
        status = 1;
      }

      else
        if(response->errstat == 0l)
        {
          vars = response->variables;
          if(!(vars == ((struct variable_list *)NULL)))
          {
            snmp_snprint_value(temp_result, (unsigned long int)1024, vars->name, vars->name_length, vars);
            char *return_value_trim$3;
            return_value_trim$3=trim(temp_result);
            snprintf(result_string, (unsigned long int)1024, "%s", return_value_trim$3);
          }

          else
          {
            result_string[(signed long int)0] = (char)85;
            result_string[(signed long int)1] = (char)0;
            status = 1;
          }
        }

    }

    if(!(response == ((struct snmp_pdu *)NULL)))
    {
      snmp_free_pdu(response);
      response = (struct snmp_pdu *)(void *)0;
    }

  }

  else
    status = 99;
  if(!(status == 0))
  {
    current_host->ignore_host = 1;
    result_string[(signed long int)0] = (char)85;
    result_string[(signed long int)1] = (char)0;
  }

  return result_string;
}

// snmp_host_cleanup
// file snmp.c line 297
extern void snmp_host_cleanup(void *snmp_session)
{
  if(!(snmp_session == NULL))
    snmp_sess_close(snmp_session);

}

// snmp_host_init
// file snmp.c line 122
extern void * snmp_host_init(signed int host_id, char *hostname, signed int snmp_version, char *snmp_community, char *snmp_username, char *snmp_password, char *snmp_auth_protocol, char *snmp_priv_passphrase, char *snmp_priv_protocol, char *snmp_context, signed int snmp_port, signed int snmp_timeout)
{
  void *sessp = (void *)0;
  struct snmp_session session;
  char hostnameport[1024l];
  snmp_sess_init(&session);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(set.snmp_clientaddr);
  if(return_value_strlen$1 >= 1ul)
    session.localname=strdup(set.snmp_clientaddr);

  netsnmp_ds_set_boolean(0, 32, 1);
  netsnmp_ds_set_boolean(0, 35, 1);
  netsnmp_ds_set_boolean(0, 29, 1);
  netsnmp_ds_set_boolean(0, 13, 1);
  netsnmp_ds_set_boolean(0, 28, 1);
  netsnmp_ds_set_boolean(0, 21, 1);
  netsnmp_ds_set_boolean(0, 18, 1);
  session.securityEngineID = ((unsigned char *)NULL);
  session.securityEngineIDLen = (unsigned long int)0;
  session.securityName = ((char *)NULL);
  session.securityNameLen = (unsigned long int)0;
  session.contextEngineID = ((unsigned char *)NULL);
  session.contextEngineIDLen = (unsigned long int)0;
  session.contextName = ((char *)NULL);
  session.contextNameLen = (unsigned long int)0;
  if(snmp_version == 2)
  {
    session.version = (signed long int)1;
    session.securityModel = 2;
  }

  else
    if(snmp_version == 1)
    {
      session.version = (signed long int)0;
      session.securityModel = 1;
    }

    else
      if(snmp_version == 3)
      {
        session.version = (signed long int)3;
        session.securityModel = 3;
      }

      else
      {
        spine_log("Host[%i] ERROR: SNMP Version Error for Host '%s'", host_id, hostname);
        return NULL;
      }
  snprintf(hostnameport, (unsigned long int)1024, "%s:%i", hostname, snmp_port);
  session.peername = hostnameport;
  session.retries = 3;
  session.remote_port = (unsigned short int)snmp_port;
  session.timeout = (signed long int)(snmp_timeout * 1000);
  unsigned long int return_value_strlen$2;
  _Bool tmp_if_expr$11;
  unsigned long int return_value_strlen$10;
  if(snmp_version == 1 || snmp_version == 2)
  {
    session.community = (unsigned char *)snmp_community;
    session.community_len=strlen(snmp_community);
  }

  else
  {
    session.securityName = snmp_username;
    session.securityNameLen=strlen(session.securityName);
    if(!(snmp_context == ((char *)NULL)))
    {
      return_value_strlen$2=strlen(snmp_context);
      if(!(return_value_strlen$2 == 0ul))
      {
        session.contextName = snmp_context;
        session.contextNameLen=strlen(session.contextName);
      }

    }

    session.securityAuthKeyLen = (unsigned long int)32;
    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(snmp_auth_protocol, "MD5");
    if(return_value_strcmp$3 == 0)
    {
      session.securityAuthProto=snmp_duplicate_objid(usmHMACMD5AuthProtocol, (unsigned long int)10);
      session.securityAuthProtoLen = (unsigned long int)10;
    }

    else
    {
      session.securityAuthProto=snmp_duplicate_objid(usmHMACSHA1AuthProtocol, (unsigned long int)10);
      session.securityAuthProtoLen = (unsigned long int)10;
    }
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(snmp_password);
    signed int return_value_generate_Ku$5;
    return_value_generate_Ku$5=generate_Ku(session.securityAuthProto, (unsigned int)session.securityAuthProtoLen, (unsigned char *)snmp_password, return_value_strlen$4, session.securityAuthKey, &session.securityAuthKeyLen);
    if(!(return_value_generate_Ku$5 == 0))
      spine_log("SNMP: Error generating SNMPv3 Ku from authentication pass phrase.");

    signed int return_value_strcmp$9;
    return_value_strcmp$9=strcmp(snmp_priv_protocol, "[None]");
    if(return_value_strcmp$9 == 0)
      tmp_if_expr$11 = (_Bool)1;

    else
    {
      return_value_strlen$10=strlen(snmp_priv_passphrase);
      tmp_if_expr$11 = return_value_strlen$10 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$11)
    {
      session.securityPrivProto=snmp_duplicate_objid(usmNoPrivProtocol, sizeof(unsigned long int [10l]) /*80ul*/  / sizeof(unsigned long int) /*8ul*/ );
      session.securityPrivProtoLen = sizeof(unsigned long int [10l]) /*80ul*/  / sizeof(unsigned long int) /*8ul*/ ;
      session.securityPrivKeyLen = (unsigned long int)32;
      session.securityLevel = 2;
    }

    else
    {
      signed int return_value_strcmp$6;
      return_value_strcmp$6=strcmp(snmp_priv_protocol, "DES");
      if(return_value_strcmp$6 == 0)
      {
        session.securityPrivProto=snmp_duplicate_objid(usmDESPrivProtocol, (unsigned long int)10);
        session.securityPrivProtoLen = (unsigned long int)10;
        session.securityPrivKeyLen = (unsigned long int)32;
        session.securityLevel = 3;
      }

      else
      {
        session.securityPrivProto=snmp_duplicate_objid(usmAESPrivProtocol, (unsigned long int)10);
        session.securityPrivProtoLen = (unsigned long int)10;
        session.securityPrivKeyLen = (unsigned long int)32;
        session.securityLevel = 3;
      }
      unsigned long int return_value_strlen$7;
      return_value_strlen$7=strlen(snmp_priv_passphrase);
      signed int return_value_generate_Ku$8;
      return_value_generate_Ku$8=generate_Ku(session.securityAuthProto, (unsigned int)session.securityAuthProtoLen, (unsigned char *)snmp_priv_passphrase, return_value_strlen$7, session.securityPrivKey, &session.securityPrivKeyLen);
      if(!(return_value_generate_Ku$8 == 0))
        spine_log("SNMP: Error generating SNMPv3 Ku from privacy pass phrase.");

    }
  }
  thread_mutex_lock(0);
  sessp=snmp_sess_open(&session);
  thread_mutex_unlock(0);
  signed int return_value_spine_log$12;
  if(sessp == NULL)
  {
    if(set.log_level >= 3)
    {
      return_value_spine_log$12=spine_log("ERROR: Problem initializing SNMP session '%s'", hostname);
      if(!(return_value_spine_log$12 == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
  }

  return sessp;
}

// snmp_snprint_value
// file snmp.c line 592
extern void snmp_snprint_value(char *obuf, unsigned long int buf_len, const unsigned long int *objid, unsigned long int objidlen, struct variable_list *variable)
{
  unsigned char *buf = (unsigned char *)(void *)0;
  unsigned long int out_len = (unsigned long int)0;
  if(buf_len >= 1ul)
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc(buf_len, (unsigned long int)1);
    buf = (unsigned char *)return_value_calloc$1;
    if(!(buf == ((unsigned char *)NULL)))
    {
      sprint_realloc_by_type(&buf, &buf_len, &out_len, 1, variable, (struct enum_list *)(void *)0, (const char *)(void *)0, (const char *)(void *)0);
      snprintf(obuf, buf_len, "%s", buf);
    }

    else
    {
      obuf[(signed long int)0] = (char)85;
      obuf[(signed long int)1] = (char)0;
    }
    free((void *)buf);
  }

  else
  {
    obuf[(signed long int)0] = (char)85;
    obuf[(signed long int)1] = (char)0;
  }
}

// snmp_spine_close
// file snmp.c line 108
void snmp_spine_close(void)
{
  snmp_shutdown("spine");
}

// snmp_spine_init
// file snmp.h line 34
extern void snmp_spine_init(void)
{
  netsnmp_ds_set_boolean(0, 8, 1);
  netsnmp_ds_set_boolean(0, 32, 1);
  netsnmp_ds_set_boolean(0, 35, 1);
  netsnmp_ds_set_boolean(0, 29, 1);
  netsnmp_ds_set_boolean(0, 13, 1);
  netsnmp_ds_set_boolean(0, 28, 1);
  netsnmp_ds_set_boolean(0, 21, 1);
  netsnmp_ds_set_boolean(0, 18, 1);
  signed int return_value_spine_log$1;
  if(set.log_level >= 5)
  {
    return_value_spine_log$1=spine_log("DEBUG: Issues with SNMP Header Version information, assuming old version of Net-SNMP.");
    if(!(return_value_spine_log$1 == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }

  else
    (_Bool)0;
  init_snmp("spine");
}

// spine_log
// file util.h line 40
extern signed int spine_log(const char *format, ...)
{
  void **args;
  struct _IO_FILE *log_file = (struct _IO_FILE *)(void *)0;
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  signed long int nowbin;
  struct tm now_time;
  struct tm *now_ptr;
  char logprefix[256l];
  char ulogmessage[4096l];
  char flogmessage[4096l];
  args = (void **)&format;
  vsprintf(ulogmessage, format, args);
  args = ((void **)NULL);
  fp = stdout;
  if(set.log_destination == 4)
  {
    char *return_value_trim$1;
    return_value_trim$1=trim(ulogmessage);
    puts(return_value_trim$1);
    return 1;
  }

  char *return_value_strstr$2;
  return_value_strstr$2=strstr(ulogmessage, "\n");
  if(return_value_strstr$2 == ((char *)NULL))
    strncat(ulogmessage, "\n", (unsigned long int)1);

  snprintf(logprefix, (unsigned long int)256, "SPINE: Poller[%i] ", set.poller_id);
  nowbin=time(&nowbin);
  localtime_r(&nowbin, &now_time);
  now_ptr = &now_time;
  unsigned long int return_value_strftime$3;
  return_value_strftime$3=strftime(flogmessage, (unsigned long int)50, "%m/%d/%Y %I:%M:%S %p - ", now_ptr);
  if(return_value_strftime$3 == 0ul)
  {
    fp = stderr;
    if(!(fp == stderr) || set.stderr_notty == 0)
    {
      if(!(fp == stdout) || set.stdout_notty == 0)
        fprintf(fp, "ERROR: Could not get string from strftime()\n");

    }

  }

  strncat(flogmessage, logprefix, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
  strncat(flogmessage, ulogmessage, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
  unsigned long int return_value_strlen$5;
  if(!(set.log_level == 1) && (set.log_destination == 1 || set.log_destination == 2))
  {
    return_value_strlen$5=strlen(set.path_logfile);
    if(!(return_value_strlen$5 == 0ul))
    {
      if(!(set.logfile_processed == 0))
      {
        signed int return_value_file_exists$4;
        return_value_file_exists$4=file_exists(set.path_logfile);
        if(return_value_file_exists$4 == 0)
          log_file=fopen(set.path_logfile, "w");

        else
          log_file=fopen(set.path_logfile, "a");
        static signed int log_error = 0;
        if(!(log_file == ((struct _IO_FILE *)NULL)))
        {
          fputs(flogmessage, log_file);
          fclose(log_file);
        }

        else
          if(log_error == 0)
          {
            printf("ERROR: Spine Log File Could Not Be Opened/Created\n");
            log_error = 1;
          }

      }

    }

  }

  _Bool tmp_if_expr$8;
  char *return_value_strstr$7;
  if(set.log_destination == 2 || set.log_destination == 3)
  {
    thread_mutex_lock(5);
    openlog("Cacti", 0x08 | 0x01, 5 << 3);
    char *return_value_strstr$6;
    return_value_strstr$6=strstr(flogmessage, "ERROR");
    if(!(return_value_strstr$6 == ((char *)NULL)))
      tmp_if_expr$8 = (_Bool)1;

    else
    {
      return_value_strstr$7=strstr(flogmessage, "FATAL");
      tmp_if_expr$8 = return_value_strstr$7 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$8)
    {
      if(!(set.log_perror == 0))
        syslog(2, "%s\n", (const void *)flogmessage);

    }

    char *return_value_strstr$9;
    return_value_strstr$9=strstr(flogmessage, "WARNING");
    if(!(return_value_strstr$9 == ((char *)NULL)))
    {
      if(!(set.log_pwarn == 0))
        syslog(4, "%s\n", (const void *)flogmessage);

    }

    char *return_value_strstr$10;
    return_value_strstr$10=strstr(flogmessage, "STATS");
    if(!(return_value_strstr$10 == ((char *)NULL)))
    {
      if(!(set.log_pstats == 0))
        syslog(5, "%s\n", (const void *)flogmessage);

    }

    closelog();
    thread_mutex_unlock(5);
  }

  _Bool tmp_if_expr$13;
  char *return_value_strstr$12;
  _Bool tmp_if_expr$15;
  char *return_value_strstr$14;
  if(set.log_level >= 1)
  {
    char *return_value_strstr$11;
    return_value_strstr$11=strstr(flogmessage, "ERROR");
    if(!(return_value_strstr$11 == ((char *)NULL)))
      tmp_if_expr$13 = (_Bool)1;

    else
    {
      return_value_strstr$12=strstr(flogmessage, "WARNING");
      tmp_if_expr$13 = return_value_strstr$12 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$13)
      tmp_if_expr$15 = (_Bool)1;

    else
    {
      return_value_strstr$14=strstr(flogmessage, "FATAL");
      tmp_if_expr$15 = return_value_strstr$14 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$15)
      fp = stderr;

    if(!(fp == stderr) || set.stderr_notty == 0)
    {
      if(!(fp == stdout) || set.stdout_notty == 0)
        fprintf(fp, "%s", (const void *)flogmessage);

    }

  }

  return 1;
}

// spine_signal_handler
// file error.c line 46
static void spine_signal_handler(signed int spine_signal)
{
  signal(spine_signal, (void (*)(signed int))0);
  set.exit_code = spine_signal;
  switch(spine_signal)
  {
    case 2:
    {
      die("FATAL: Spine Interrupted by Console Operator");
      break;
    }
    case 11:
    {
      die("FATAL: Spine Encountered a Segmentation Fault");
      break;
    }
    case 7:
    {
      die("FATAL: Spine Encountered a Bus Error");
      break;
    }
    case 8:
    {
      die("FATAL: Spine Encountered a Floating Point Exception");
      break;
    }
    case 3:
    {
      die("FATAL: Spine Encountered a Keyboard Quit Command");
      break;
    }
    case 13:
    {
      die("FATAL: Spine Encountered a Broken Pipe");
      break;
    }
    default:
      die("FATAL: Spine Encountered An Unhandled Exception Signal Number: '%d'", spine_signal);
  }
}

// strip_alpha
// file util.c line 894
extern char * strip_alpha(char *string)
{
  signed int i;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(string);
  i = (signed int)return_value_strlen$1;
  while(i >= 0)
  {
    const unsigned short int **return_value___ctype_b_loc$2;
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if(!((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)string[(signed long int)i]]) == 0))
      break;

    else
      string[(signed long int)i] = (char)0;
    i = i - 1;
  }
  return string;
}

// strncopy
// file util.c line 972
extern char * strncopy(char *dst, const char *src, unsigned long int obuf)
{
  /* assertion dst != 0 */
  assert(dst != ((char *)NULL));
  /* assertion src != 0 */
  assert(src != ((const char *)NULL));
  unsigned long int len;
  len=strlen(src);
  if(len == 0ul)
    dst[(signed long int)0] = (char)0;

  else
    if(!(len >= obuf))
    {
      strncpy(dst, src, len);
      dst[(signed long int)len] = (char)0;
    }

    else
    {
      obuf = obuf - 1ul;
      strncpy(dst, src, obuf);
      dst[(signed long int)obuf] = (char)0;
    }
  return dst;
}

// thread_mutex_lock
// file locks.h line 35
extern void thread_mutex_lock(signed int mutex)
{
  union anonymous$9 *return_value_get_lock$1;
  return_value_get_lock$1=get_lock(mutex);
  pthread_mutex_lock(return_value_get_lock$1);
}

// thread_mutex_trylock
// file locks.h line 37
extern signed int thread_mutex_trylock(signed int mutex)
{
  union anonymous$9 *return_value_get_lock$1;
  return_value_get_lock$1=get_lock(mutex);
  signed int return_value_pthread_mutex_trylock$2;
  return_value_pthread_mutex_trylock$2=pthread_mutex_trylock(return_value_get_lock$1);
  return return_value_pthread_mutex_trylock$2;
}

// thread_mutex_unlock
// file locks.h line 36
extern void thread_mutex_unlock(signed int mutex)
{
  union anonymous$9 *return_value_get_lock$1;
  return_value_get_lock$1=get_lock(mutex);
  pthread_mutex_unlock(return_value_get_lock$1);
}

// trim
// file util.c line 1044
extern char * trim(char *str)
{
  char *return_value_rtrim$1;
  return_value_rtrim$1=rtrim(str);
  char *return_value_ltrim$2;
  return_value_ltrim$2=ltrim(return_value_rtrim$1);
  return return_value_ltrim$2;
}

// uninstall_spine_signal_handler
// file error.h line 35
extern void uninstall_spine_signal_handler(void)
{
  signed int i;
  struct sigaction action;
  void (*ohandler)(signed int);
  i = 0;
  for( ; !(spine_fatal_signals[(signed long int)i] == 0); i = i + 1)
  {
    sigaction(spine_fatal_signals[(signed long int)i], (struct sigaction *)(void *)0, &action);
    if(action.__sigaction_handler.sa_handler == spine_signal_handler)
    {
      action.__sigaction_handler.sa_handler = (void (*)(signed int))0;
      sigaction(spine_fatal_signals[(signed long int)i], &action, (struct sigaction *)(void *)0);
    }

  }
  i = 0;
  for( ; !(spine_fatal_signals[(signed long int)i] == 0); i = i + 1)
  {
    ohandler=signal(spine_fatal_signals[(signed long int)i], (void (*)(signed int))0);
    if(!(ohandler == spine_signal_handler))
      signal(spine_fatal_signals[(signed long int)i], ohandler);

  }
}

// update_host_status
// file ping.h line 143
extern void update_host_status(signed int status, struct host_struct *host, struct ping_results *ping, signed int availability_method)
{
  signed int issue_log_message = 0;
  double ping_time;
  double hundred_percent = 100.00;
  char current_date[40l];
  signed long int nowbin;
  struct tm now_time;
  struct tm *now_ptr;
  signed long int return_value_time$1;
  return_value_time$1=time(&nowbin);
  if(return_value_time$1 == -1l)
    die("ERROR: Could not get time of day from time()");

  localtime_r(&nowbin, &now_time);
  now_ptr = &now_time;
  strftime(current_date, (unsigned long int)40, "%Y-%m-%d %H:%M", now_ptr);
  unsigned long int return_value_strlen$2;
  _Bool tmp_if_expr$3;
  unsigned long int return_value_strlen$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$10;
  if(status == 1)
  {
    host->failed_polls = host->failed_polls + 1;
    host->total_polls = host->total_polls + 1;
    host->availability = (hundred_percent * (double)(host->total_polls - host->failed_polls)) / (double)host->total_polls;
    switch(availability_method)
    {
      case 4:

      case 1:
      {
        return_value_strlen$2=strlen(host->snmp_community);
        if(return_value_strlen$2 == 0ul)
          tmp_if_expr$3 = host->snmp_version < 3 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          snprintf(host->status_last_error, (unsigned long int)256, "%s", (const void *)ping->ping_response);

        else
          snprintf(host->status_last_error, (unsigned long int)256, "%s, %s", (const void *)ping->snmp_response, (const void *)ping->ping_response);
        break;
      }
      case 2:
      {
        return_value_strlen$4=strlen(host->snmp_community);
        if(return_value_strlen$4 == 0ul)
          tmp_if_expr$5 = host->snmp_version < 3 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        if(tmp_if_expr$5)
          snprintf(host->status_last_error, (unsigned long int)256, "%s", (const void *)"Device does not require SNMP");

        else
          snprintf(host->status_last_error, (unsigned long int)256, "%s", (const void *)ping->snmp_response);
        break;
      }
      default:
        snprintf(host->status_last_error, (unsigned long int)256, "%s", (const void *)ping->ping_response);
    }
    if(host->status == 3)
    {
      host->status_event_count = host->status_event_count + 1;
      if(host->status_event_count >= set.ping_failure_count)
      {
        host->status = 1;
        issue_log_message = 1;
        if(set.ping_failure_count == 1)
          snprintf(host->status_fail_date, (unsigned long int)40, "%s", (const void *)current_date);

      }

      else
        if(host->status_event_count == 1)
          snprintf(host->status_fail_date, (unsigned long int)40, "%s", (const void *)current_date);

    }

    else
      if(host->status == 2)
      {
        host->status_event_count = 1;
        host->status = 1;
      }

      else
        if(host->status == 0)
        {
          host->status = 1;
          host->status_event_count = 0;
        }

        else
          host->status_event_count = host->status_event_count + 1;
  }

  else
  {
    host->total_polls = host->total_polls + 1;
    host->availability = (hundred_percent * (double)(host->total_polls - host->failed_polls)) / (double)host->total_polls;
    if(availability_method == 1)
    {
      unsigned long int return_value_strlen$8;
      return_value_strlen$8=strlen(host->snmp_community);
      if(return_value_strlen$8 == 0ul)
        ping_time=atof(ping->ping_status);

      else
      {
        double return_value_atof$6;
        return_value_atof$6=atof(ping->snmp_status);
        double return_value_atof$7;
        return_value_atof$7=atof(ping->ping_status);
        ping_time = (return_value_atof$6 + return_value_atof$7) / (double)2;
      }
    }

    else
      if(availability_method == 2)
      {
        unsigned long int return_value_strlen$9;
        return_value_strlen$9=strlen(host->snmp_community);
        if(return_value_strlen$9 == 0ul)
          ping_time = 0.000;

        else
          ping_time=atof(ping->snmp_status);
      }

      else
        if(availability_method == 0)
          ping_time = 0.000;

        else
          ping_time=atof(ping->ping_status);
    host->cur_time = ping_time;
    if(ping_time > host->max_time)
      host->max_time = ping_time;

    if(ping_time < host->min_time)
      host->min_time = ping_time;

    host->avg_time = ((double)((host->total_polls - 1) - host->failed_polls) * host->avg_time + ping_time) / (double)(host->total_polls - host->failed_polls);
    if(host->status == 1)
      tmp_if_expr$10 = (_Bool)1;

    else
      tmp_if_expr$10 = host->status == 2 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$10)
    {
      if(host->status == 1)
      {
        host->status = 2;
        host->status_event_count = 1;
      }

      else
        host->status_event_count = host->status_event_count + 1;
      if(host->status_event_count >= set.ping_recovery_count)
      {
        host->status = 3;
        issue_log_message = 1;
        if(set.ping_recovery_count == 1)
          snprintf(host->status_rec_date, (unsigned long int)40, "%s", (const void *)current_date);

        host->status_event_count = 0;
      }

      else
        if(host->status_event_count == 1)
          snprintf(host->status_rec_date, (unsigned long int)40, "%s", (const void *)current_date);

    }

    else
    {
      host->status = 3;
      host->status_event_count = 0;
    }
  }
  _Bool tmp_if_expr$26;
  signed int return_value_spine_log$11;
  signed int return_value_spine_log$12;
  signed int return_value_spine_log$13;
  signed int return_value_spine_log$14;
  _Bool tmp_if_expr$18;
  signed int return_value_spine_log$15;
  signed int return_value_spine_log$16;
  signed int return_value_spine_log$19;
  signed int return_value_spine_log$20;
  signed int return_value_spine_log$21;
  signed int return_value_spine_log$22;
  signed int return_value_spine_log$23;
  signed int return_value_spine_log$24;
  signed int return_value_spine_log$25;
  if(set.log_level >= 4)
  {
    if(host->status == 3)
      tmp_if_expr$26 = (_Bool)1;

    else
      tmp_if_expr$26 = host->status == 2 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$26)
    {
      if(availability_method == 1)
      {
        if(set.log_level >= 4)
        {
          return_value_spine_log$11=spine_log("Host[%i] PING Result: %s", host->id, (const void *)ping->ping_response);
          if(!(return_value_spine_log$11 == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
        if(set.log_level >= 4)
        {
          return_value_spine_log$12=spine_log("Host[%i] SNMP Result: %s", host->id, (const void *)ping->snmp_response);
          if(!(return_value_spine_log$12 == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
      }

      else
        if(availability_method == 4)
        {
          if(set.log_level >= 4)
          {
            return_value_spine_log$13=spine_log("Host[%i] PING Result: %s", host->id, (const void *)ping->ping_response);
            if(!(return_value_spine_log$13 == 0))
              (_Bool)1;

            else
              (_Bool)0;
          }

          else
            (_Bool)0;
          if(set.log_level >= 4)
          {
            return_value_spine_log$14=spine_log("Host[%i] SNMP Result: %s", host->id, (const void *)ping->snmp_response);
            if(!(return_value_spine_log$14 == 0))
              (_Bool)1;

            else
              (_Bool)0;
          }

          else
            (_Bool)0;
        }

        else
          if(availability_method == 2)
          {
            unsigned long int return_value_strlen$17;
            return_value_strlen$17=strlen(host->snmp_community);
            if(return_value_strlen$17 == 0ul)
              tmp_if_expr$18 = host->snmp_version < 3 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$18 = (_Bool)0;
            if(tmp_if_expr$18)
            {
              if(set.log_level >= 4)
              {
                return_value_spine_log$15=spine_log("Host[%i] SNMP Result: Device does not require SNMP", host->id);
                if(!(return_value_spine_log$15 == 0))
                  (_Bool)1;

                else
                  (_Bool)0;
              }

              else
                (_Bool)0;
            }

            else
              if(set.log_level >= 4)
              {
                return_value_spine_log$16=spine_log("Host[%i] SNMP Result: %s", host->id, (const void *)ping->snmp_response);
                if(!(return_value_spine_log$16 == 0))
                  (_Bool)1;

                else
                  (_Bool)0;
              }

              else
                (_Bool)0;
          }

          else
            if(availability_method == 0)
            {
              if(set.log_level >= 4)
              {
                return_value_spine_log$19=spine_log("Host[%i] No Host Availability Method Selected", host->id);
                if(!(return_value_spine_log$19 == 0))
                  (_Bool)1;

                else
                  (_Bool)0;
              }

              else
                (_Bool)0;
            }

            else
              if(set.log_level >= 4)
              {
                return_value_spine_log$20=spine_log("Host[%i] PING: Result %s", host->id, (const void *)ping->ping_response);
                if(!(return_value_spine_log$20 == 0))
                  (_Bool)1;

                else
                  (_Bool)0;
              }

              else
                (_Bool)0;
    }

    else
      if(availability_method == 1)
      {
        if(set.log_level >= 4)
        {
          return_value_spine_log$21=spine_log("Host[%i] PING Result: %s", host->id, (const void *)ping->ping_response);
          if(!(return_value_spine_log$21 == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
        if(set.log_level >= 4)
        {
          return_value_spine_log$22=spine_log("Host[%i] SNMP Result: %s", host->id, (const void *)ping->snmp_response);
          if(!(return_value_spine_log$22 == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
      }

      else
        if(availability_method == 2)
        {
          if(set.log_level >= 4)
          {
            return_value_spine_log$23=spine_log("Host[%i] SNMP Result: %s", host->id, (const void *)ping->snmp_response);
            if(!(return_value_spine_log$23 == 0))
              (_Bool)1;

            else
              (_Bool)0;
          }

          else
            (_Bool)0;
        }

        else
          if(availability_method == 0)
          {
            if(set.log_level >= 4)
            {
              return_value_spine_log$24=spine_log("Host[%i] No Host Availability Method Selected", host->id);
              if(!(return_value_spine_log$24 == 0))
                (_Bool)1;

              else
                (_Bool)0;
            }

            else
              (_Bool)0;
          }

          else
            if(set.log_level >= 4)
            {
              return_value_spine_log$25=spine_log("Host[%i] PING Result: %s", host->id, (const void *)ping->ping_response);
              if(!(return_value_spine_log$25 == 0))
                (_Bool)1;

              else
                (_Bool)0;
            }

            else
              (_Bool)0;
  }

  if(!(issue_log_message == 0))
  {
    if(host->status == 1)
      spine_log("Host[%i] Hostname[%s] ERROR: HOST EVENT: Host is DOWN Message: %s", host->id, (const void *)host->hostname, (const void *)host->status_last_error);

    else
      spine_log("Host[%i] Hostname[%s] NOTICE: HOST EVENT: Host Returned from DOWN State", host->id, (const void *)host->hostname);
  }

}

// validate_result
// file poller.c line 1322
extern signed int validate_result(char *result)
{
  if(!(result == ((char *)NULL)))
  {
    signed int return_value_is_numeric$3;
    return_value_is_numeric$3=is_numeric(result);
    if(!(return_value_is_numeric$3 == 0))
      return 1;

    else
    {
      char *return_value_trim$1;
      return_value_trim$1=trim(result);
      signed int return_value_is_multipart_output$2;
      return_value_is_multipart_output$2=is_multipart_output(return_value_trim$1);
      if(!(return_value_is_multipart_output$2 == 0))
        return 1;

      else
        return 0;
    }
  }

  return 0;
}

