// #anon_enum$A_OPEN=0$A_CLOSE=1$A_DATA=2
// file spdsend.h line 52
enum anonymous$2 { A_OPEN=0, A_CLOSE=1, A_DATA=2 };

// #anon_enum$FALSE=0$TRUE=1
// file spdsend.h line 39
enum anonymous$0 { FALSE=0, TRUE=1 };

// #anon_enum$OK=0$ERROR=1
// file spdsend.h line 43
enum anonymous$7 { OK=0, ERROR=1 };

// #anon_enum$OK_CODE=0$ER_CODE=1
// file spdsend.h line 54
enum anonymous$3 { OK_CODE=0, ER_CODE=1 };

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$5;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$6;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$1;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$4;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous$4, unsigned int *);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$4, unsigned int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_connection
// file spdsend.h line 69
extern enum anonymous$7 close_connection(signed int s, signed int id);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous$4, unsigned int);
// connect_server
// file server.c line 434
static signed int connect_server();
// daemonize
// file server.c line 378
static void daemonize();
// do_close_connection
// file server.c line 138
static enum anonymous$7 do_close_connection(signed int id);
// do_open_connection
// file server.c line 106
static signed int do_open_connection(const char *host, signed int port);
// do_send_data
// file server.c line 148
static enum anonymous$7 do_send_data(signed int id, signed int from, signed int to, enum anonymous$7 (*forwarder)(signed int, signed int, enum anonymous$0));
// do_send_data::forwarder$object
//
enum anonymous$7 forwarder$object(signed int, signed int, enum anonymous$0);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// forward_data
// file spdsend.h line 50
extern enum anonymous$7 forward_data(signed int from, signed int to, enum anonymous$0 closep);
// forward_ssip_answer
// file server.c line 211
static enum anonymous$7 forward_ssip_answer(signed int from, signed int to, enum anonymous$0 _closep);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// get_connection
// file server.c line 73
static signed int get_connection(signed int id);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getline
// file /usr/include/stdio.h line 678
extern signed long int getline(char ** restrict , unsigned long int *, struct _IO_FILE *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// init_connections
// file server.c line 398
static void init_connections();
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// login_name
// file server.c line 321
static const char * login_name();
// main::1::1::function$object
//
enum anonymous$7 function$object(signed int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// new_connection
// file server.c line 89
static signed int new_connection(signed int s);
// open_connection
// file spdsend.h line 68
extern enum anonymous$7 open_connection(signed int s, const char *host, signed int port);
// open_server
// file spdsend.h line 64
extern signed int open_server();
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_close
// file server.c line 268
static void process_close(signed int s);
// process_data
// file server.c line 277
static void process_data(signed int s);
// process_open
// file server.c line 234
static void process_open(signed int s);
// process_request
// file server.c line 289
static void process_request(signed int s);
// process_request_thread
// file server.c line 309
static void * process_request_thread(void *s);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous *, const union anonymous$6 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_data
// file spdsend.h line 49
extern signed int read_data(signed int s, void *buffer, unsigned long int max_size);
// read_id
// file server.c line 203
static signed int read_id(signed int s);
// read_reply
// file client.c line 61
static signed int read_reply(signed int s);
// report
// file server.c line 184
static enum anonymous$7 report(signed int s, enum anonymous$3 code);
// report_error
// file server.c line 198
static enum anonymous$7 report_error(signed int s);
// report_ok
// file server.c line 189
static enum anonymous$7 report_ok(signed int s, signed int id);
// send_command
// file spdsend.h line 70
extern enum anonymous$7 send_command(signed int s, signed int id);
// send_header
// file client.c line 34
static enum anonymous$7 send_header(signed int s, enum anonymous$2 action, signed int id);
// send_open_header
// file client.c line 47
static enum anonymous$7 send_open_header(signed int s, const char *host, signed int port);
// serve
// file server.c line 334
static void serve();
// server_socket_name
// file server.c line 326
static const char * server_socket_name();
// set_connection
// file server.c line 78
static void set_connection(signed int id, signed int s);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// start_server
// file server.c line 413
static void start_server();
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// string_to_number
// file spdsend.c line 87
static signed long int string_to_number(const char *string, signed long int low_limit, signed long int high_limit);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// system_error
// file server.c line 60
static void system_error(const char *message);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file spdsend.c line 78
static void usage(const char * const message);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_data
// file spdsend.h line 48
extern enum anonymous$7 write_data(signed int s, const void *buffer, unsigned long int size);

union anonymous$5
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$6
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$1
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$4
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in6_addr
{
  // __in6_u
  union anonymous$5 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};


// CONNECTION_ID_MAX
// file common.c line 35
const signed long int CONNECTION_ID_MAX = (const signed long int)1000;
// CONNECTION_ID_MIN
// file common.c line 34
const signed long int CONNECTION_ID_MIN = (const signed long int)1;
// EXIT_ERROR
// file common.c line 38
const signed int EXIT_ERROR = 1;
// EXIT_OK
// file common.c line 37
const signed int EXIT_OK = 0;
// SPDSEND_VERSION
// file spdsend.c line 35
const char * const SPDSEND_VERSION = "0.0.0";
// connections
// file server.c line 68
signed int *connections;
// connections_mutex
// file server.c line 70
union anonymous connections_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;

// close_connection
// file spdsend.h line 69
extern enum anonymous$7 close_connection(signed int s, signed int id)
{
  enum anonymous$7 return_value_send_header$1;
  return_value_send_header$1=send_header(s, (enum anonymous$2)A_CLOSE, id);
  if((signed int)return_value_send_header$1 == ERROR)
    return (enum anonymous$7)ERROR;

  else
  {
    signed int return_value_read_reply$2;
    return_value_read_reply$2=read_reply(s);
    return (enum anonymous$7)(return_value_read_reply$2 == OK ? OK : ERROR);
  }
}

// connect_server
// file server.c line 434
static signed int connect_server()
{
  struct sockaddr_un name;
  signed int sock;
  sock=socket(1, 1, 0);
  signed int name_size;
  name.sun_family = (unsigned short int)1;
  const char *return_value_server_socket_name$1;
  return_value_server_socket_name$1=server_socket_name();
  strncpy(name.sun_path, return_value_server_socket_name$1, sizeof(char [108l]) /*108ul*/ );
  name.sun_path[(signed long int)(sizeof(char [108l]) /*108ul*/  - (unsigned long int)1)] = (char)0;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(name.sun_path);
  name_size = (signed int)(2ul + return_value_strlen$2 + (unsigned long int)1);
  signed int return_value_connect$3;
  return_value_connect$3=connect(sock, (struct sockaddr *)&name, (unsigned int)name_size);
  if(!(return_value_connect$3 >= 0))
    return -1;

  else
    return sock;
}

// daemonize
// file server.c line 378
static void daemonize()
{
  signed int ret = 0;
  signed int return_value_fork$1;
  return_value_fork$1=fork();
  if(!(return_value_fork$1 == 0))
    exit(0);

  setsid();
  signal(1, (void (*)(signed int))1);
  signed int return_value_fork$2;
  return_value_fork$2=fork();
  if(!(return_value_fork$2 == 0))
    exit(0);

  ret=chdir("/");
  if(!(ret == 0))
    fputs("server.c:daemonize: could not chdir", stderr);

  exit(1);
  umask((unsigned int)0);
  signed int i = 0;
  for( ; !(i >= 4); i = i + 1)
    close(i);
}

// do_close_connection
// file server.c line 138
static enum anonymous$7 do_close_connection(signed int id)
{
  signed int c;
  c=get_connection(id);
  if(c == -1)
    return (enum anonymous$7)ERROR;

  else
  {
    close(c);
    set_connection(id, -1);
    return (enum anonymous$7)OK;
  }
}

// do_open_connection
// file server.c line 106
static signed int do_open_connection(const char *host, signed int port)
{
  signed int sock;
  sock=socket(2, 1, 0);
  struct sockaddr_in name;
  name.sin_family = (unsigned short int)2;
  name.sin_port=htons((unsigned short int)port);
  struct hostent *hostinfo;
  hostinfo=gethostbyname(host);
  if(hostinfo == ((struct hostent *)NULL))
    return -1;

  else
  {
    name.sin_addr = *((struct in_addr *)hostinfo->h_addr_list[(signed long int)0]);
    signed int return_value_connect$1;
    return_value_connect$1=connect(sock, (struct sockaddr *)&name, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_connect$1 >= 0))
      return -1;

    else
    {
      signed int arg = 1;
      setsockopt(sock, 6, 1, (const void *)&arg, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int id;
      id=new_connection(sock);
      if(id == -1)
        close(sock);

      return id;
    }
  }
}

// do_send_data
// file server.c line 148
static enum anonymous$7 do_send_data(signed int id, signed int from, signed int to, enum anonymous$7 (*forwarder)(signed int, signed int, enum anonymous$0))
{
  signed int sock;
  sock=get_connection(id);
  if(sock == -1)
    return (enum anonymous$7)ERROR;

  else
  {
    if(from == -1)
      from = sock;

    else
      if(to == -1)
        to = sock;

    enum anonymous$7 result;
    result=forwarder(from, to, (enum anonymous$0)FALSE);
    if(!((signed int)result == OK))
      do_close_connection(id);

    return result;
  }
}

// forward_data
// file spdsend.h line 50
extern enum anonymous$7 forward_data(signed int from, signed int to, enum anonymous$0 closep)
{
  const unsigned long int buffer_size = (const unsigned long int)4096;
  const signed long int buffer_size$array_size0 = (signed long int)buffer_size;
  char buffer[buffer_size$array_size0];
  signed long int n;
  do
  {
    n=read(from, (void *)buffer, buffer_size);
    if(!(n >= 1l))
      break;

    enum anonymous$7 return_value_write_data$1;
    return_value_write_data$1=write_data(to, (const void *)buffer, (unsigned long int)n);
    if((signed int)return_value_write_data$1 == ERROR)
      return (enum anonymous$7)ERROR;

  }
  while((_Bool)1);
  if(!(closep == /*enum*/FALSE))
    shutdown(to, 1);

  return (enum anonymous$7)(n == (signed long int)-1 ? ERROR : OK);
}

// forward_ssip_answer
// file server.c line 211
static enum anonymous$7 forward_ssip_answer(signed int from, signed int to, enum anonymous$0 _closep)
{
  signed int result = OK;
  struct _IO_FILE *f;
  f=fdopen(from, "r");
  unsigned long int line_size = (unsigned long int)256;
  char *line;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(line_size);
  line = (char *)return_value_malloc$1;
  if(line == ((char *)NULL))
    system_error("memory allocation");

  _Bool tmp_if_expr$4;
  enum anonymous$7 return_value_write_data$3;
  while((_Bool)1)
  {
    signed int n;
    signed long int return_value_getline$2;
    return_value_getline$2=getline(&line, &line_size, f);
    n = (signed int)return_value_getline$2;
    if(!(n >= 0))
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_write_data$3=write_data(to, (const void *)line, (unsigned long int)n);
      tmp_if_expr$4 = (signed int)return_value_write_data$3 == ERROR ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      result = ERROR;
      break;
    }

    if(n >= 4)
    {
      if((signed int)line[3l] == 32)
        break;

    }

  }
  free((void *)line);
  return (enum anonymous$7)result;
}

// get_connection
// file server.c line 73
static signed int get_connection(signed int id)
{
  return connections[(signed long int)id];
}

// init_connections
// file server.c line 398
static void init_connections()
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)CONNECTION_ID_MAX * sizeof(signed int) /*4ul*/ );
  connections = (signed int *)return_value_malloc$1;
  if(connections == ((signed int *)NULL))
    system_error("memory allocation");

  signed int i = (signed int)CONNECTION_ID_MIN;
  for( ; !((signed long int)i >= CONNECTION_ID_MAX); i = i + 1)
    connections[(signed long int)i] = -1;
  pthread_mutex_init(&connections_mutex, (const union anonymous$6 *)(void *)0);
}

// login_name
// file server.c line 321
static const char * login_name()
{
  unsigned int return_value_getuid$1;
  return_value_getuid$1=getuid();
  struct passwd *return_value_getpwuid$2;
  return_value_getpwuid$2=getpwuid(return_value_getuid$1);
  return return_value_getpwuid$2->pw_name;
}

// main
// file spdsend.c line 98
signed int main(signed int argc, char **argv)
{
  if(!(argc >= 2))
    usage("Invalid number of arguments");

  const char * const action = argv[(signed long int)1];
  enum anonymous$7 (*function)(signed int, signed int);
  signed int conn_id;
  char *host;
  signed int port;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(action, "--version");
  if(return_value_strcmp$1 == 0)
  {
    printf("spdsend %s\n", SPDSEND_VERSION);
    exit(EXIT_OK);
  }

  signed int action_is_open;
  signed int return_value_strcmp$2;
  return_value_strcmp$2=strcmp(action, "--open");
  action_is_open = (const signed int)(return_value_strcmp$2 == 0);
  signed int return_value_strcmp$5;
  if(!(action_is_open == 0))
  {
    if(!(argc == 4))
      usage("Invalid number of arguments");

    host = argv[(signed long int)2];
    signed long int return_value_string_to_number$3;
    return_value_string_to_number$3=string_to_number(argv[(signed long int)3], (signed long int)0, (signed long int)65535);
    port = (signed int)return_value_string_to_number$3;
  }

  else
  {
    if(!(argc == 3))
      usage("Invalid number of arguments");

    signed long int return_value_string_to_number$4;
    return_value_string_to_number$4=string_to_number(argv[(signed long int)2], CONNECTION_ID_MIN, CONNECTION_ID_MAX);
    conn_id = (signed int)return_value_string_to_number$4;
    signed int return_value_strcmp$6;
    return_value_strcmp$6=strcmp(action, "--close");
    if(return_value_strcmp$6 == 0)
      function = close_connection;

    else
    {
      return_value_strcmp$5=strcmp(action, "--send");
      if(return_value_strcmp$5 == 0)
        function = send_command;

      else
        usage("Invalid option");
    }
  }
  signed int server;
  server=open_server();
  signed int tmp_if_expr$8;
  enum anonymous$7 return_value_open_connection$7;
  enum anonymous$7 return_value;
  if(server == -1)
    return EXIT_ERROR;

  else
  {
    signed int result;
    if(!(action_is_open == 0))
    {
      return_value_open_connection$7=open_connection(server, host, port);
      tmp_if_expr$8 = (signed int)return_value_open_connection$7;
    }

    else
    {
      return_value=function(server, conn_id);
      tmp_if_expr$8 = (signed int)return_value;
    }
    result = tmp_if_expr$8;
    return result == OK ? EXIT_OK : EXIT_ERROR;
  }
}

// new_connection
// file server.c line 89
static signed int new_connection(signed int s)
{
  pthread_mutex_lock(&connections_mutex);
  signed int id = (signed int)CONNECTION_ID_MIN;
  _Bool tmp_if_expr$1;
  do
  {
    if(!((signed long int)id >= CONNECTION_ID_MAX))
      tmp_if_expr$1 = connections[(signed long int)id] != -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    id = id + 1;
  }
  while((_Bool)1);
  if((signed long int)id >= CONNECTION_ID_MAX)
    return -1;

  else
  {
    connections[(signed long int)id] = s;
    pthread_mutex_unlock(&connections_mutex);
    return id;
  }
}

// open_connection
// file spdsend.h line 68
extern enum anonymous$7 open_connection(signed int s, const char *host, signed int port)
{
  enum anonymous$7 return_value_send_open_header$1;
  return_value_send_open_header$1=send_open_header(s, host, port);
  if((signed int)return_value_send_open_header$1 == ERROR)
    return (enum anonymous$7)ERROR;

  else
  {
    signed int id;
    id=read_reply(s);
    if(id == -1)
      return (enum anonymous$7)ERROR;

    else
    {
      printf("%d\n", id);
      return (enum anonymous$7)OK;
    }
  }
}

// open_server
// file spdsend.h line 64
extern signed int open_server()
{
  signed int s;
  s=connect_server();
  if(s == -1)
  {
    start_server();
    s=connect_server();
  }

  if(s == -1)
    return -1;

  else
    return s;
}

// process_close
// file server.c line 268
static void process_close(signed int s)
{
  signed int id;
  id=read_id(s);
  _Bool tmp_if_expr$2;
  enum anonymous$7 return_value_do_close_connection$1;
  if(!(id == -1))
  {
    return_value_do_close_connection$1=do_close_connection(id);
    tmp_if_expr$2 = (signed int)return_value_do_close_connection$1 == OK ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    report_ok(s, id);

  else
    report_error(s);
}

// process_data
// file server.c line 277
static void process_data(signed int s)
{
  signed int id;
  id=read_id(s);
  if(!(id == -1))
    report_ok(s, id);

  else
    report_error(s);
  enum anonymous$7 return_value_do_send_data$1;
  return_value_do_send_data$1=do_send_data(id, s, -1, forward_data);
  if((signed int)return_value_do_send_data$1 == OK)
    do_send_data(id, -1, s, forward_ssip_answer);

}

// process_open
// file server.c line 234
static void process_open(signed int s)
{
  signed int id;
  signed int port;
  signed int hostlen;
  signed int return_value_read_data$1;
  return_value_read_data$1=read_data(s, (void *)&port, sizeof(signed int) /*4ul*/ );
  if(!((unsigned long int)return_value_read_data$1 == sizeof(signed int) /*4ul*/ ))
    report_error(s);

  else
  {
    signed int return_value_read_data$2;
    return_value_read_data$2=read_data(s, (void *)&hostlen, sizeof(signed int) /*4ul*/ );
    if(!((unsigned long int)return_value_read_data$2 == sizeof(signed int) /*4ul*/ ))
      report_error(s);

    else
    {
      char *host;
      void *return_value_malloc$3;
      return_value_malloc$3=malloc((unsigned long int)(hostlen + 1));
      host = (char *)return_value_malloc$3;
      if(host == ((char *)NULL))
        system_error("memory allocation");

      signed int return_value_read_data$4;
      return_value_read_data$4=read_data(s, (void *)host, (unsigned long int)hostlen);
      if(!(return_value_read_data$4 == hostlen))
      {
        free((void *)host);
        report_error(s);
      }

      else
      {
        host[(signed long int)hostlen] = (char)0;
        id=do_open_connection(host, port);
        free((void *)host);
        if(id == -1)
          report_error(s);

        else
          report_ok(s, id);
      }
    }
  }
}

// process_request
// file server.c line 289
static void process_request(signed int s)
{
  enum anonymous$2 action;
  signed int return_value_read_data$1;
  return_value_read_data$1=read_data(s, (void *)&action, sizeof(enum anonymous$2) /*4ul*/ );
  if(!(return_value_read_data$1 == -1))
  {
    if((signed int)action == A_OPEN)
      process_open(s);

    else
      if((signed int)action == A_CLOSE)
        process_close(s);

      else
        if((signed int)action == A_DATA)
          process_data(s);

        else
          report_error(s);
    close(s);
  }

}

// process_request_thread
// file server.c line 309
static void * process_request_thread(void *s)
{
  signed int s_deref = *((signed int *)s);
  free(s);
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  pthread_detach(return_value_pthread_self$1);
  process_request(s_deref);
  return (void *)0;
}

// read_data
// file spdsend.h line 49
extern signed int read_data(signed int s, void *buffer, unsigned long int max_size)
{
  unsigned long int nread = (unsigned long int)0;
  unsigned long int n;
  while(!(nread >= max_size))
  {
    signed long int return_value_read$1;
    return_value_read$1=read(s, buffer, max_size);
    n = (unsigned long int)return_value_read$1;
    if(n == 0ul)
      break;

    nread = nread + n;
    buffer = buffer + (signed long int)n;
    max_size = max_size - n;
  }
  return (signed int)nread;
}

// read_id
// file server.c line 203
static signed int read_id(signed int s)
{
  signed int id;
  signed int return_value_read_data$1;
  return_value_read_data$1=read_data(s, (void *)&id, sizeof(signed int) /*4ul*/ );
  if(return_value_read_data$1 == ERROR)
    return -1;

  else
    return id;
}

// read_reply
// file client.c line 61
static signed int read_reply(signed int s)
{
  enum anonymous$3 result;
  signed int id;
  signed int return_value_read_data$1;
  return_value_read_data$1=read_data(s, (void *)&result, sizeof(enum anonymous$3) /*4ul*/ );
  if(!((unsigned long int)return_value_read_data$1 == sizeof(enum anonymous$3) /*4ul*/ ))
    return -1;

  else
    if(!((signed int)result == OK_CODE))
      return -1;

    else
    {
      signed int return_value_read_data$2;
      return_value_read_data$2=read_data(s, (void *)&id, sizeof(signed int) /*4ul*/ );
      if(!((unsigned long int)return_value_read_data$2 == sizeof(signed int) /*4ul*/ ))
        return -1;

      else
        return id;
    }
}

// report
// file server.c line 184
static enum anonymous$7 report(signed int s, enum anonymous$3 code)
{
  enum anonymous$7 return_value_write_data$1;
  return_value_write_data$1=write_data(s, (const void *)&code, sizeof(enum anonymous$3) /*4ul*/ );
  return return_value_write_data$1;
}

// report_error
// file server.c line 198
static enum anonymous$7 report_error(signed int s)
{
  enum anonymous$7 return_value_report$1;
  return_value_report$1=report(s, (enum anonymous$3)ER_CODE);
  return return_value_report$1;
}

// report_ok
// file server.c line 189
static enum anonymous$7 report_ok(signed int s, signed int id)
{
  enum anonymous$7 return_value_report$1;
  return_value_report$1=report(s, (enum anonymous$3)OK_CODE);
  _Bool tmp_if_expr$3;
  enum anonymous$7 return_value_write_data$2;
  if((signed int)return_value_report$1 == OK)
  {
    return_value_write_data$2=write_data(s, (const void *)&id, sizeof(signed int) /*4ul*/ );
    tmp_if_expr$3 = (signed int)return_value_write_data$2 == OK ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
    return (enum anonymous$7)OK;

  else
    return (enum anonymous$7)ERROR;
}

// send_command
// file spdsend.h line 70
extern enum anonymous$7 send_command(signed int s, signed int id)
{
  enum anonymous$7 return_value_send_header$1;
  return_value_send_header$1=send_header(s, (enum anonymous$2)A_DATA, id);
  _Bool tmp_if_expr$5;
  enum anonymous$7 return_value_forward_data$4;
  if((signed int)return_value_send_header$1 == ERROR)
    return (enum anonymous$7)ERROR;

  else
  {
    signed int return_value_read_reply$2;
    return_value_read_reply$2=read_reply(s);
    if(return_value_read_reply$2 == -1)
      return (enum anonymous$7)ERROR;

    else
    {
      enum anonymous$7 return_value_forward_data$3;
      return_value_forward_data$3=forward_data(0, s, (enum anonymous$0)TRUE);
      if((signed int)return_value_forward_data$3 == OK)
      {
        return_value_forward_data$4=forward_data(s, 1, (enum anonymous$0)FALSE);
        tmp_if_expr$5 = (signed int)return_value_forward_data$4 == OK ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        return (enum anonymous$7)OK;

      else
        return (enum anonymous$7)ERROR;
    }
  }
}

// send_header
// file client.c line 34
static enum anonymous$7 send_header(signed int s, enum anonymous$2 action, signed int id)
{
  enum anonymous$7 return_value_write_data$1;
  return_value_write_data$1=write_data(s, (const void *)&action, sizeof(enum anonymous$2) /*4ul*/ );
  _Bool tmp_if_expr$3;
  enum anonymous$7 return_value_write_data$2;
  if((signed int)return_value_write_data$1 == OK)
  {
    return_value_write_data$2=write_data(s, (const void *)&id, sizeof(signed int) /*4ul*/ );
    tmp_if_expr$3 = (signed int)return_value_write_data$2 == OK ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
    return (enum anonymous$7)OK;

  else
    return (enum anonymous$7)ERROR;
}

// send_open_header
// file client.c line 47
static enum anonymous$7 send_open_header(signed int s, const char *host, signed int port)
{
  signed int hostlen;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(host);
  hostlen = (signed int)return_value_strlen$1;
  enum anonymous$2 action = (enum anonymous$2)A_OPEN;
  enum anonymous$7 return_value_write_data$2;
  return_value_write_data$2=write_data(s, (const void *)&action, sizeof(enum anonymous$2) /*4ul*/ );
  _Bool tmp_if_expr$4;
  enum anonymous$7 return_value_write_data$3;
  if((signed int)return_value_write_data$2 == OK)
  {
    return_value_write_data$3=write_data(s, (const void *)&port, sizeof(signed int) /*4ul*/ );
    tmp_if_expr$4 = (signed int)return_value_write_data$3 == OK ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$4 = (_Bool)0;
  _Bool tmp_if_expr$6;
  enum anonymous$7 return_value_write_data$5;
  if(tmp_if_expr$4)
  {
    return_value_write_data$5=write_data(s, (const void *)&hostlen, sizeof(signed int) /*4ul*/ );
    tmp_if_expr$6 = (signed int)return_value_write_data$5 == OK ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  _Bool tmp_if_expr$8;
  enum anonymous$7 return_value_write_data$7;
  if(tmp_if_expr$6)
  {
    return_value_write_data$7=write_data(s, (const void *)host, (unsigned long int)hostlen);
    tmp_if_expr$8 = (signed int)return_value_write_data$7 == OK ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$8 = (_Bool)0;
  if(tmp_if_expr$8)
    return (enum anonymous$7)OK;

  else
    return (enum anonymous$7)ERROR;
}

// serve
// file server.c line 334
static void serve()
{
  struct sockaddr_un name;
  signed int sock;
  unsigned long int size;
  const char *filename;
  filename=server_socket_name();
  sock=socket(1, 1, 0);
  if(!(sock >= 0))
    system_error("socket creation");

  name.sun_family = (unsigned short int)1;
  strncpy(name.sun_path, filename, sizeof(char [108l]) /*108ul*/ );
  name.sun_path[(signed long int)(sizeof(char [108l]) /*108ul*/  - (unsigned long int)1)] = (char)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(name.sun_path);
  size = 2ul + return_value_strlen$1 + (unsigned long int)1;
  signed int return_value_bind$2;
  return_value_bind$2=bind(sock, (struct sockaddr *)&name, (unsigned int)size);
  if(!(return_value_bind$2 >= 0))
    system_error("bind");

  signed int return_value_listen$3;
  return_value_listen$3=listen(sock, 100);
  if(!(return_value_listen$3 >= 0))
    system_error("listen");

  while((_Bool)1)
  {
    struct sockaddr_un client_address;
    unsigned int client_address_len = (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ ;
    signed int *s;
    void *return_value_malloc$4;
    return_value_malloc$4=malloc(sizeof(signed int) /*4ul*/ );
    s = (signed int *)return_value_malloc$4;
    if(s == ((signed int *)NULL))
      system_error("memory allocation");

    *s=accept(sock, (struct sockaddr *)&client_address, &client_address_len);
    if(!(*s >= 0))
      break;

    unsigned long int tid;
    pthread_create(&tid, (const union pthread_attr_t *)(void *)0, process_request_thread, (void *)s);
  }
}

// server_socket_name
// file server.c line 326
static const char * server_socket_name()
{
  char *name;
  const char *return_value_login_name$1;
  return_value_login_name$1=login_name();
  signed int return_value_asprintf$2;
  return_value_asprintf$2=asprintf(&name, "/tmp/spdsend-server.%s", return_value_login_name$1);
  if(!(return_value_asprintf$2 >= 0))
    system_error("memory allocation");

  return name;
}

// set_connection
// file server.c line 78
static void set_connection(signed int id, signed int s)
{
  pthread_mutex_lock(&connections_mutex);
  connections[(signed long int)id] = s;
  pthread_mutex_unlock(&connections_mutex);
}

// start_server
// file server.c line 413
static void start_server()
{
  const char *socket_name;
  socket_name=server_socket_name();
  unlink(socket_name);
  signed int pid;
  pid=fork();
  if(pid == -1)
    system_error("fork");

  if(pid == 0)
  {
    daemonize();
    init_connections();
    serve();
    unlink(socket_name);
    exit(0);
  }

  else
    sleep((unsigned int)1);
}

// string_to_number
// file spdsend.c line 87
static signed long int string_to_number(const char *string, signed long int low_limit, signed long int high_limit)
{
  char *tailptr;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  signed long int number;
  number=strtol(string, &tailptr, 0);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  _Bool tmp_if_expr$3;
  if(!(*return_value___errno_location$2 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = *tailptr != 0 ? (_Bool)1 : (_Bool)0;
  if(!(number >= low_limit) || !(high_limit >= number) || tmp_if_expr$3)
    usage("Invalid parameter");

  return number;
}

// system_error
// file server.c line 60
static void system_error(const char *message)
{
  perror(message);
  exit(1);
}

// usage
// file spdsend.c line 78
static void usage(const char * const message)
{
  if(!(message == ((const char *)NULL)))
    fprintf(stderr, "spdsend: %s\n", message);

  fprintf(stderr, "usage: spdsend { --open SERVER PORT | --close ID | --send ID }\n");
  exit(EXIT_ERROR);
}

// write_data
// file spdsend.h line 48
extern enum anonymous$7 write_data(signed int s, const void *buffer, unsigned long int size)
{
  signed int written;
  for( ; size >= 1ul; buffer = buffer + (signed long int)written)
  {
    signed long int return_value_write$1;
    return_value_write$1=write(s, buffer, size);
    written = (signed int)return_value_write$1;
    if(!(written >= 0))
      return (enum anonymous$7)ERROR;

    size = size - (unsigned long int)written;
  }
  return (enum anonymous$7)OK;
}

