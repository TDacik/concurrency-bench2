// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_10;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_8;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_1;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#}_SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#_'__cancel_jmp_buf'||ARR4{*{V}_V_}_*{V}_V__'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous_3;

// tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous_2;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_18;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_4;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_7;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_6;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_12;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_5;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_9;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_13;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_0;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_11;

// tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous_17;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_15;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_16;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_14;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__MHASH_INSTANCE
// file /usr/include/mutils/mtypes.h line 39
struct __MHASH_INSTANCE;

// tag-__hashid
// file /usr/include/mutils/mglobal.h line 33
enum __hashid { MHASH_CRC32=0, MHASH_MD5=1, MHASH_SHA1=2, MHASH_HAVAL256=3, MHASH_RIPEMD160=5, MHASH_TIGER192=7, MHASH_GOST=8, MHASH_CRC32B=9, MHASH_HAVAL224=10, MHASH_HAVAL192=11, MHASH_HAVAL160=12, MHASH_HAVAL128=13, MHASH_TIGER128=14, MHASH_TIGER160=15, MHASH_MD4=16, MHASH_SHA256=17, MHASH_ADLER32=18, MHASH_SHA224=19, MHASH_SHA512=20, MHASH_SHA384=21, MHASH_WHIRLPOOL=22, MHASH_RIPEMD128=23, MHASH_RIPEMD256=24, MHASH_RIPEMD320=25, MHASH_SNEFRU128=26, MHASH_SNEFRU256=27, MHASH_MD2=28, MHASH_AR=64, MHASH_BOOGNISH=65, MHASH_CELLHASH=66, MHASH_FFT_HASH_I=67, MHASH_FFT_HASH_II=68, MHASH_NHASH=69, MHASH_PANAMA=70, MHASH_SMASH=71, MHASH_SUBHASH=72 };

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-destination
// file dest.h line 25
struct destination;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous_3 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous_3 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous_3 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// __xpg_basename
// file /usr/include/libgen.h line 34
extern char * __xpg_basename(char *);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// addHashAlgorithm
// file mbuffer.c line 1520
static void addHashAlgorithm(const char *name);
// argcheck
// file mbuffer.c line 1504
static signed int argcheck(const char *opt, const char **argv, signed int *c, signed int argc);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bzero
// file /usr/include/string.h line 458
extern void bzero(void *, unsigned long int);
// calcint
// file mbuffer.c line 1440
static unsigned long long int calcint(const char **argv, signed int c, unsigned long long int def);
// calcval
// file mbuffer.c line 1599
static const char * calcval(const char *arg, unsigned long long int *res);
// cancelAll
// file mbuffer.c line 292
static void cancelAll(void);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// createNetworkOutput
// file network.c line 198
struct destination * createNetworkOutput(const char *addr);
// dup
// file /usr/include/unistd.h line 531
extern signed int dup(signed int);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// enforceSpeedLimit
// file mbuffer.c line 488
static signed long long int enforceSpeedLimit(unsigned long long int limit, signed long long int num, struct timespec *last);
// errormsg
// file log.c line 151
void errormsg(const char *msg, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fatal
// file log.c line 176
void fatal(const char *msg, ...);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fscanf
// file /usr/include/stdio.h line 425
extern signed int fscanf(struct _IO_FILE *, const char *, ...);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// fsync
// file /usr/include/unistd.h line 956
extern signed int fsync(signed int);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// hashThread
// file mbuffer.c line 949
static void * hashThread(void *arg);
// infomsg
// file log.c line 113
void infomsg(const char *msg, ...);
// initDefaults
// file mbuffer.c line 1660
static void initDefaults();
// initNetworkInput
// file network.c line 93
void initNetworkInput(const char *addr);
// inputThread
// file mbuffer.c line 673
static void * inputThread(void *ignored);
// inputThread::1::1::1::1::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// kb2str
// file mbuffer.c line 219
static signed int kb2str(char *s, double v);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// logdebug
// file log.c line 94
void logdebug(const char *msg, ...);
// logwrite
// file log.c line 50
void logwrite(char *buf, unsigned long int b);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// madvise
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 94
extern signed int madvise(void *, unsigned long int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// mhash
// file /usr/include/mutils/mhash.h line 73
_Bool mhash(struct __MHASH_INSTANCE *, const void *, unsigned int);
// mhash_count
// file /usr/include/mutils/mhash.h line 56
unsigned int mhash_count(void);
// mhash_deinit
// file /usr/include/mutils/mhash.h line 79
void mhash_deinit(struct __MHASH_INSTANCE *, void *);
// mhash_get_block_size
// file /usr/include/mutils/mhash.h line 57
unsigned int mhash_get_block_size(enum __hashid);
// mhash_get_hash_name_static
// file /usr/include/mutils/mhash.h line 61
const unsigned char * mhash_get_hash_name_static(enum __hashid);
// mhash_init
// file /usr/include/mutils/mhash.h line 65
struct __MHASH_INSTANCE * mhash_init(enum __hashid);
// mkstemp
// file /usr/include/stdlib.h line 619
extern signed int mkstemp(char *);
// mlock
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 103
extern signed int mlock(const void *, unsigned long int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// mt_usleep
// file mbuffer.c line 333
static signed int mt_usleep(unsigned long int sleep_usecs);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openDestinationFiles
// file mbuffer.c line 1556
static void openDestinationFiles(struct destination *d);
// outputThread
// file mbuffer.c line 1150
static void * outputThread(void *arg);
// outputThread::1::2::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// outputThread::1::3::1::1::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// printmsg
// file log.c line 197
void printmsg(const char *msg, ...);
// promptInteractive
// file mbuffer.c line 531
static signed int promptInteractive(unsigned int at, unsigned int num);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_16 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_16 *, const union anonymous_15 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_16 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_16 *, union anonymous_14 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_14 *, const union anonymous_15 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_14 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_14 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous *, struct anonymous *);
// raise
// file /usr/include/signal.h line 139
extern signed int raise(signed int);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// releaseLock
// file mbuffer.c line 665
static void releaseLock(void *l);
// requestInputVolume
// file mbuffer.c line 585
static signed int requestInputVolume(unsigned int at, unsigned int num);
// requestOutputVolume
// file mbuffer.c line 1012
static signed int requestOutputVolume(signed int out, const char *outfile);
// rint
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 279
extern double rint(double);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_1 *, struct anonymous_1 *, struct anonymous_1 *, struct timeval *);
// sem_getvalue
// file /usr/include/semaphore.h line 72
extern signed int sem_getvalue(union anonymous_17 *, signed int *);
// sem_init
// file /usr/include/semaphore.h line 36
extern signed int sem_init(union anonymous_17 *, signed int, unsigned int);
// sem_post
// file /usr/include/semaphore.h line 69
extern signed int sem_post(union anonymous_17 *);
// sem_wait
// file /usr/include/semaphore.h line 54
extern signed int sem_wait(union anonymous_17 *);
// senderThread
// file mbuffer.c line 866
static void * senderThread(void *arg);
// setTCPBufferSize
// file network.c line 61
static void setTCPBufferSize(signed int sock, unsigned int buffer);
// seteuid
// file /usr/include/unistd.h line 710
extern signed int seteuid(unsigned int);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// sigHandler
// file mbuffer.c line 307
static void sigHandler(signed int signr);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// statusThread
// file mbuffer.c line 375
static void statusThread(void);
// strcasecmp
// file /usr/include/strings.h line 116
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// summary
// file mbuffer.c line 245
static void summary(unsigned long long int numb, signed int numthreads);
// syncSenders
// file mbuffer.c line 791
static inline signed int syncSenders(char *b, signed int s);
// syncSenders::1::2::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// terminateOutputThread
// file mbuffer.c line 1117
static void terminateOutputThread(struct destination *d, signed int status);
// terminateSender
// file mbuffer.c line 838
static inline void terminateSender(signed int fd, struct destination *d, signed int ret);
// timediff
// file mbuffer.c line 476
static inline signed long long int timediff(struct timespec * restrict t1, struct timespec * restrict t2);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file mbuffer.c line 1367
static void usage(void);
// valloc
// file /usr/include/stdlib.h line 498
extern void * valloc(unsigned long int);
// version
// file mbuffer.c line 1352
static void version(void);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// warningmsg
// file log.c line 131
void warningmsg(const char *msg, ...);
// watchdogThread
// file mbuffer.c line 351
static void * watchdogThread(void *ignored);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_10
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_8
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_1
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_2
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous_3
{
  // __cancel_jmp_buf
  struct anonymous_2 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous_18
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_4
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_7
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_6
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_5
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_9
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_11
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_4 _kill;
  // _timer
  struct anonymous_5 _timer;
  // _rt
  struct anonymous_6 _rt;
  // _sigchld
  struct anonymous_7 _sigchld;
  // _sigfault
  struct anonymous_8 _sigfault;
  // _sigpoll
  struct anonymous_9 _sigpoll;
  // _sigsys
  struct anonymous_10 _sigsys;
};

struct anonymous_12
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_11 _sifields;
};

union anonymous_13
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_12 *, void *);
};

union anonymous_0
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_17
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

union anonymous_15
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_16
{
  // __data
  struct anonymous_18 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_14
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __MHASH_INSTANCE
{
  // hmac_key_size
  unsigned int hmac_key_size;
  // hmac_block
  unsigned int hmac_block;
  // hmac_key
  unsigned char *hmac_key;
  // state
  unsigned char *state;
  // state_size
  unsigned int state_size;
  // algorithm_given
  enum __hashid algorithm_given;
  // hash_func
  void (*hash_func)(void *, const void *, signed int);
  // final_func
  void (*final_func)(void *);
  // deinit_func
  void (*deinit_func)(void *, unsigned char *);
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct destination
{
  // next
  struct destination *next;
  // arg
  const char *arg;
  // name
  const char *name;
  // port
  const char *port;
  // result
  const char *result;
  // fd
  signed int fd;
  // mode
  signed int mode;
  // thread
  unsigned long int thread;
};

struct in6_addr
{
  // __in6_u
  union anonymous_0 __in6_u;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_13 __sigaction_handler;
  // sa_mask
  struct anonymous sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};


// ActSenders
// file mbuffer.c line 209
static volatile signed int ActSenders = 0;
// AddrFam
// file network.c line 55
signed int AddrFam = 0;
// AutoloadCmd
// file mbuffer.c line 157
static const char *AutoloadCmd = ((const char *)NULL);
// AutoloadTime
// file mbuffer.c line 159
static unsigned int AutoloadTime = (unsigned int)0;
// Autoloader
// file mbuffer.c line 205
static signed int Autoloader = 0;
// Blocksize
// file mbuffer.c line 148
static unsigned long long int Blocksize = (unsigned long long int)10240;
// Buf2Dev
// file mbuffer.c line 195
static union anonymous_17 Buf2Dev;
// Buffer
// file mbuffer.c line 155
static char **Buffer;
// ClockSrc
// file mbuffer.c line 172
static signed int ClockSrc = 0;
// Dest
// file mbuffer.c line 207
static struct destination *Dest = ((struct destination *)NULL);
// Dev2Buf
// file mbuffer.c line 195
static union anonymous_17 Dev2Buf;
// Direct
// file mbuffer.c line 163
static signed int Direct = 0;
// Done
// file mbuffer.c line 145
static volatile signed int Done = 0;
// EmptyCount
// file mbuffer.c line 142
static volatile signed int EmptyCount = 0;
// ErrorOccurred
// file log.c line 40
signed int ErrorOccurred = 0;
// ErrorsFatal
// file log.c line 40
signed int ErrorsFatal = 0;
// Finish
// file mbuffer.c line 166
static signed long int Finish = (signed long int)-1;
// FullCount
// file mbuffer.c line 143
static volatile signed int FullCount = 0;
// Hashers
// file mbuffer.c line 163
static signed int Hashers = 0;
// HighMut
// file mbuffer.c line 203
static union anonymous_14 HighMut = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// In
// file mbuffer.c line 129
signed int In = -1;
// Infile
// file mbuffer.c line 157
static const char *Infile = ((const char *)NULL);
// Log
// file log.c line 40
signed int Log = 2;
// LowMut
// file mbuffer.c line 202
static union anonymous_14 LowMut = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// MainOutOK
// file mbuffer.c line 146
static volatile signed int MainOutOK = 1;
// MaxReadSpeed
// file mbuffer.c line 149
static unsigned long long int MaxReadSpeed = (unsigned long long int)0;
// MaxWriteSpeed
// file mbuffer.c line 149
static unsigned long long int MaxWriteSpeed = (unsigned long long int)0;
// Memlock
// file mbuffer.c line 161
static signed int Memlock = 0;
// Memmap
// file mbuffer.c line 162
static signed int Memmap = 0;
// NumP
// file mbuffer.c line 148
static unsigned long long int NumP = (unsigned long long int)0;
// NumSenders
// file mbuffer.c line 144
static volatile signed int NumSenders = -1;
// NumVolumes
// file mbuffer.c line 165
static signed long int NumVolumes = (signed long int)1;
// Numblocks
// file mbuffer.c line 167
static signed long int Numblocks = (signed long int)512;
// Numin
// file mbuffer.c line 151
static volatile unsigned long long int Numin = (volatile unsigned long long int)0;
// Numout
// file mbuffer.c line 151
static volatile unsigned long long int Numout = (volatile unsigned long long int)0;
// OptSync
// file mbuffer.c line 137
static signed long int OptSync = (signed long int)0;
// OutVolsize
// file mbuffer.c line 149
static unsigned long long int OutVolsize = (unsigned long long int)0;
// Outsize
// file mbuffer.c line 139
static unsigned long int Outsize = (unsigned long int)10240;
// Pause
// file mbuffer.c line 139
static unsigned long int Pause = (unsigned long int)0;
// PercHigh
// file mbuffer.c line 198
static union anonymous_16 PercHigh = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// PercLow
// file mbuffer.c line 197
static union anonymous_16 PercLow = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// PgSz
// file mbuffer.c line 148
static unsigned long long int PgSz = (unsigned long long int)0;
// Prefix
// file mbuffer.c line 127
char *Prefix;
// PrefixLen
// file mbuffer.c line 131
unsigned long int PrefixLen = (unsigned long int)0;
// Quiet
// file mbuffer.c line 162
static signed int Quiet = 0;
// Reader
// file mbuffer.c line 134
static unsigned long int Reader;
// Rest
// file mbuffer.c line 151
static volatile unsigned long long int Rest = (volatile unsigned long long int)0;
// SendAt
// file mbuffer.c line 208
static char * volatile SendAt = ((char *)NULL);
// SendCond
// file mbuffer.c line 199
static union anonymous_16 SendCond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// SendMut
// file mbuffer.c line 204
static union anonymous_14 SendMut = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// SendSize
// file mbuffer.c line 209
static volatile signed int SendSize = 0;
// SetOutsize
// file mbuffer.c line 163
static signed int SetOutsize = 0;
// StartRead
// file mbuffer.c line 153
static double StartRead = (double)1;
// StartWrite
// file mbuffer.c line 153
static double StartWrite = (double)0;
// Starttime
// file mbuffer.c line 206
static struct timeval Starttime;
// Status
// file mbuffer.c line 162
static signed int Status = 1;
// StatusLog
// file mbuffer.c line 162
static signed int StatusLog = 1;
// TCPBufSize
// file network.c line 53
signed int TCPBufSize = 1 << 20;
// TermMut
// file mbuffer.c line 201
static union anonymous_14 TermMut = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// TermQ
// file mbuffer.c line 161
static signed int TermQ[2l];
// Terminal
// file mbuffer.c line 205
static signed int Terminal = 1;
// Terminate
// file mbuffer.c line 141
static volatile signed int Terminate = 0;
// TickTime
// file mbuffer.c line 169
static signed long long int TickTime = (signed long long int)0;
// Timeout
// file mbuffer.c line 139
static unsigned long int Timeout = (unsigned long int)0;
// Tmp
// file mbuffer.c line 136
static signed long int Tmp = (signed long int)-1;
// Tmpfile
// file mbuffer.c line 155
static char *Tmpfile = ((char *)NULL);
// Totalmem
// file mbuffer.c line 148
static unsigned long long int Totalmem = (unsigned long long int)0;
// Verbose
// file log.c line 40
signed int Verbose = 3;
// Watchdog
// file mbuffer.c line 134
static unsigned long int Watchdog;
// WatchdogRaised
// file mbuffer.c line 129
signed int WatchdogRaised = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;

// addHashAlgorithm
// file mbuffer.c line 1520
static void addHashAlgorithm(const char *name)
{
  const char *algoname = "";
  signed int algo = 0;
  signed int numalgo;
  unsigned int return_value_mhash_count_1;
  return_value_mhash_count_1=mhash_count();
  numalgo = (signed int)return_value_mhash_count_1;
  signed int return_value_strcasecmp_3;
  while(numalgo >= algo)
  {
    const unsigned char *return_value_mhash_get_hash_name_static_2;
    return_value_mhash_get_hash_name_static_2=mhash_get_hash_name_static((enum __hashid)algo);
    algoname = (const char *)return_value_mhash_get_hash_name_static_2;
    if(!(algoname == ((const char *)NULL)))
    {
      return_value_strcasecmp_3=strcasecmp(algoname, name);
      if(return_value_strcasecmp_3 == 0)
        break;

    }

    algo = algo + 1;
  }
  signed int return_value_strcasecmp_5;
  return_value_strcasecmp_5=strcasecmp(algoname, name);
  if(return_value_strcasecmp_5 == 0)
  {
    struct destination *dest;
    void *return_value_malloc_4;
    return_value_malloc_4=malloc(sizeof(struct destination) /*56ul*/ );
    dest = (struct destination *)return_value_malloc_4;
    bzero((void *)dest, sizeof(struct destination) /*56ul*/ );
    dest->name = algoname;
    dest->fd = algo;
    if(!(Dest == ((struct destination *)NULL)))
    {
      dest->next = Dest->next;
      Dest->next = dest;
    }

    else
    {
      Dest = dest;
      dest->next = ((struct destination *)NULL);
    }
    if(Verbose >= 5)
      logdebug("enabled hash algorithm %s\n", name);

    NumSenders = NumSenders + 1;
    Hashers = Hashers + 1;
  }

  else
    fatal("invalid or unsupported hash function %s\n", name);
}

// argcheck
// file mbuffer.c line 1504
static signed int argcheck(const char *opt, const char **argv, signed int *c, signed int argc)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(opt);
  signed int return_value_strncmp_2;
  return_value_strncmp_2=strncmp(opt, argv[(signed long int)*c], return_value_strlen_1);
  if(!(return_value_strncmp_2 == 0))
    return 1;

  else
  {
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(argv[(signed long int)*c]);
    if(return_value_strlen_3 >= 3ul)
      argv[(signed long int)*c] = argv[(signed long int)*c] + (signed long int)2;

    else
    {
      *c = *c + 1;
      if(*c == argc)
        fatal("missing argument to option %s\n", opt);

    }
    return 0;
  }
}

// calcint
// file mbuffer.c line 1440
static unsigned long long int calcint(const char **argv, signed int c, unsigned long long int def)
{
  char ch;
  double d = (double)def;
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(argv[(signed long int)c], "%lf%c", &d, &ch);
  if(!(return_value_sscanf_1 == 2))
  {
    if(return_value_sscanf_1 == 1)
      goto __CPROVER_DUMP_L14;

    if(return_value_sscanf_1 == 0)
      goto __CPROVER_DUMP_L18;

    /* assertion 0 */
    assert(0 != 0);
  }

  else
  {
    if(d <= 0.000000)
      fatal("invalid argument - must be > 0\n");

    switch((signed int)ch)
    {
      case 107:

      case 75:
      {
        d = d * 1024.0;
        return (unsigned long long int)d;
      }
      case 109:

      case 77:
      {
        d = d * 1024.0 * 1024.0;
        return (unsigned long long int)d;
      }
      case 103:

      case 71:
      {
        d = d * 1024.0 * 1024.0 * 1024.0;
        return (unsigned long long int)d;
      }
      case 116:

      case 84:
      {
        d = d * 1024.0 * 1024.0 * 1024.0 * 1024.0;
        return (unsigned long long int)d;
      }
      case 37:
      {
        if(d <= 0.000000 || d >= 90.000000)
          fatal("invalid value for percentage (must be 0..90)\n");

        return (unsigned long long int)d;
      }
      case 98:

      case 66:
      {
        if(d < 128.000000)
          fatal("invalid value for number of bytes\n");

        return (unsigned long long int)d;
      }
      default:
      {
        if((signed int)argv[(signed long int)c][-2l] == 45)
          fatal("unrecognized size character \"%c\" for option \"%s\"\n", ch, &argv[(signed long int)c][(signed long int)-2]);

        else
          fatal("unrecognized size character \"%c\" for option \"%s\"\n", ch, argv[(signed long int)(c - 1)]);
        return (unsigned long long int)d;
      }
    }

  __CPROVER_DUMP_L14:
    ;
    if(d <= 0.000000)
      fatal("invalid argument - must be > 0\n");

    if(d <= 100.000000)
    {
      if((signed int)argv[(signed long int)c][-2l] == 45)
        fatal("invalid low value for option \"%s\" - missing suffix?\n", &argv[(signed long int)c][(signed long int)-2]);

      else
        fatal("invalid low value for option \"%s\" - missing suffix?\n", argv[(signed long int)(c - 1)]);
    }

    return (unsigned long long int)d;
  }

__CPROVER_DUMP_L18:
  ;
  errormsg("unrecognized argument \"%s\" for option \"%s\"\n", argv[(signed long int)c], argv[(signed long int)(c - 1)]);
  return (unsigned long long int)d;
}

// calcval
// file mbuffer.c line 1599
static const char * calcval(const char *arg, unsigned long long int *res)
{
  char ch;
  double d;
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(arg, "%lf%c", &d, &ch);
  if(!(return_value_sscanf_1 == 2))
  {
    if(return_value_sscanf_1 == 1)
      goto __CPROVER_DUMP_L12;

    if(return_value_sscanf_1 == 0)
      goto __CPROVER_DUMP_L15;

    /* assertion 0 */
    assert(0 != 0);
  }

  else
  {
    if(d <= 0.000000)
      return "negative value out of range";

    switch((signed int)ch)
    {
      case 107:

      case 75:
      {
        d = d * 1024.0;
        *res = (unsigned long long int)d;
        return ((const char *)NULL);
      }
      case 109:

      case 77:
      {
        d = d * 1024.0 * 1024.0;
        *res = (unsigned long long int)d;
        return ((const char *)NULL);
      }
      case 103:

      case 71:
      {
        d = d * 1024.0 * 1024.0 * 1024.0;
        *res = (unsigned long long int)d;
        return ((const char *)NULL);
      }
      case 116:

      case 84:
      {
        d = d * 1024.0 * 1024.0 * 1024.0 * 1024.0;
        *res = (unsigned long long int)d;
        return ((const char *)NULL);
      }
      case 37:
      {
        if(d <= 0.000000 || d >= 90.000000)
          return "invalid value for percentage (must be 0..90)";

        *res = (unsigned long long int)d;
        return ((const char *)NULL);
      }
      case 98:

      case 66:
      {
        if(d < 128.000000)
          return "invalid value for number of bytes";

        *res = (unsigned long long int)d;
        return ((const char *)NULL);
      }
      default:
        return "invalid dimension";
    }

  __CPROVER_DUMP_L12:
    ;
    if(d <= 0.000000)
      return "value out of range";

    if(d <= 100.000000)
      return "value out of range";

    *res = (unsigned long long int)d;
    return ((const char *)NULL);
  }

__CPROVER_DUMP_L15:
  ;
  return "unrecognized argument";
}

// cancelAll
// file mbuffer.c line 292
static void cancelAll(void)
{
  struct destination *d = Dest;
  do
  {
    pthread_cancel(d->thread);
    if(d->result == ((const char *)NULL))
      d->result = "canceled";

    d = d->next;
  }
  while(!(d == ((struct destination *)NULL)));
  if(!(Status == 0))
    pthread_cancel(Reader);

}

// createNetworkOutput
// file network.c line 198
struct destination * createNetworkOutput(const char *addr)
{
  char *host;
  char *port;
  struct addrinfo hint;
  struct addrinfo *ret = ((struct addrinfo *)NULL);
  struct addrinfo *x;
  signed int err;
  signed int fd = -1;
  struct destination *d;
  /* assertion addr */
  assert(addr != ((const char *)NULL));
  host=strdup(addr);
  /* assertion host */
  assert(host != ((char *)NULL));
  port=strrchr(host, 58);
  if(port == ((char *)NULL))
    fatal("syntax error - target must be given in the form <host>:<port>\n");

  char *tmp_post_1 = port;
  port = port + 1l;
  *tmp_post_1 = (char)0;
  bzero((void *)&hint, sizeof(struct addrinfo) /*48ul*/ );
  hint.ai_family = AddrFam;
  hint.ai_protocol = 6;
  hint.ai_socktype = 1;
  hint.ai_flags = 0x0020;
  if(Verbose >= 5)
    logdebug("getting address info for %s\n", addr);

  err=getaddrinfo(host, port, &hint, &ret);
  const char *return_value_gai_strerror_2;
  if(!(err == 0))
  {
    return_value_gai_strerror_2=gai_strerror(err);
    fatal("unable to resolve address information for '%s': %s\n", addr, return_value_gai_strerror_2);
  }

  x = ret;
  for( ; !(x == ((struct addrinfo *)NULL)); x = x->ai_next)
  {
    fd=socket(x->ai_family, 1, 0);
    if(fd == -1)
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      errormsg("unable to create socket: %s\n", return_value_strerror_4);
      goto __CPROVER_DUMP_L8;
    }

    signed int return_value_connect_5;
    return_value_connect_5=connect(fd, x->ai_addr, x->ai_addrlen);
    if(return_value_connect_5 == 0)
    {
      if(Verbose >= 5)
        logdebug("successfully connected to %s\n", addr);

      break;
    }

    close(fd);
    fd = -1;
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    char *return_value_strerror_7;
    return_value_strerror_7=strerror(*return_value___errno_location_6);
    warningmsg("error connecting to %s: %s\n", addr, return_value_strerror_7);

  __CPROVER_DUMP_L8:
    ;
  }
  if(x == ((struct addrinfo *)NULL) || fd == -1)
    errormsg("unable to connect to %s\n", addr);

  freeaddrinfo(ret);
  if(!(fd == -1))
    setTCPBufferSize(fd, (unsigned int)7);

  void *return_value_malloc_8;
  return_value_malloc_8=malloc(sizeof(struct destination) /*56ul*/ );
  d = (struct destination *)return_value_malloc_8;
  d->arg = addr;
  d->name = host;
  d->port = port;
  d->fd = fd;
  bzero((void *)&d->thread, sizeof(unsigned long int) /*8ul*/ );
  d->result = ((const char *)NULL);
  d->next = ((struct destination *)NULL);
  return d;
}

// enforceSpeedLimit
// file mbuffer.c line 488
static signed long long int enforceSpeedLimit(unsigned long long int limit, signed long long int num, struct timespec *last)
{
  struct timespec now;
  signed long long int tdiff;
  double dt;
  signed long int self;
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  self = (signed long int)return_value_pthread_self_1;
  num = num + (signed long long int)Blocksize;
  if(!(num >= 0l))
  {
    if(Verbose >= 5)
      logdebug("enforceSpeedLimit(%lld,%lld): thread %ld\n", limit, num, self);

    return num;
  }

  else
  {
    clock_gettime(ClockSrc, &now);
    tdiff=timediff(&now, last);
    dt = (double)tdiff * 1E-6;
    if((double)num / dt > (double)limit)
    {
      double req = (double)num / (double)limit - dt;
      signed long long int w = (signed long long int)(req * 1E6);
      if(w >= TickTime)
      {
        signed long long int slept;
        signed long long int ret;
        mt_usleep((unsigned long int)w);
        clock_gettime(ClockSrc, last);
        slept=timediff(last, &now);
        ret = -((signed long long int)((double)limit * (double)(slept - w) * 1E-6));
        if(Verbose >= 5)
          logdebug("thread %ld: slept for %lld usec (planned for %lld), ret = %lld\n", self, slept, w, ret);

        return ret;
      }

      else
      {
        if(Verbose >= 5)
          logdebug("thread %ld: request for sleeping %lld usec delayed\n", self, w);

        return num;
      }
    }

    if(Verbose >= 5)
      logdebug("thread %ld: %lld/%g (%g) <= %g\n", self, num, dt, (double)num / dt, (double)limit);

    return num;
  }
}

// errormsg
// file log.c line 151
void errormsg(const char *msg, ...)
{
  ErrorOccurred = 1;
  if(Verbose >= 2)
  {
    void **val;
    char buf[256l];
    char *b = buf + (signed long int)PrefixLen;
    unsigned long int s;
    val = (void **)&msg;
    memcpy((void *)buf, (const void *)Prefix, PrefixLen);
    memcpy((void *)b, (const void *)"error: ", (unsigned long int)7);
    b = b + (signed long int)7;
    signed int return_value_vsnprintf_1;
    return_value_vsnprintf_1=vsnprintf(b, sizeof(char [256l]) /*256ul*/  - (unsigned long int)(b - buf), msg, val);
    b = b + (signed long int)return_value_vsnprintf_1;
    s = (unsigned long int)(b - buf);
    /* assertion s < sizeof(buf) */
    assert(s < sizeof(char [256l]) /*256ul*/ );
    logwrite(buf, s);
    val = ((void **)NULL);
  }

  if(!(ErrorsFatal == 0))
  {
    close(Log);
    exit(1);
  }

}

// fatal
// file log.c line 176
void fatal(const char *msg, ...)
{
  if(Verbose >= 1)
  {
    void **val;
    char buf[256l];
    char *b = buf + (signed long int)PrefixLen;
    unsigned long int s;
    val = (void **)&msg;
    memcpy((void *)buf, (const void *)Prefix, PrefixLen);
    memcpy((void *)b, (const void *)"fatal: ", (unsigned long int)7);
    b = b + (signed long int)7;
    signed int return_value_vsnprintf_1;
    return_value_vsnprintf_1=vsnprintf(b, sizeof(char [256l]) /*256ul*/  - (unsigned long int)(b - buf), msg, val);
    b = b + (signed long int)return_value_vsnprintf_1;
    s = (unsigned long int)(b - buf);
    /* assertion s < sizeof(buf) */
    assert(s < sizeof(char [256l]) /*256ul*/ );
    logwrite(buf, s);
    val = ((void **)NULL);
  }

  exit(1);
}

// hashThread
// file mbuffer.c line 949
static void * hashThread(void *arg)
{
  struct destination *dest = (struct destination *)arg;
  signed int algo = dest->fd;
  struct __MHASH_INSTANCE *ctxt;
  ctxt=mhash_init((enum __hashid)algo);
  /* assertion ctxt != ((MHASH) 0x0) */
  assert(ctxt != (struct __MHASH_INSTANCE *)0x0);
  if(Verbose >= 5)
    logdebug("hashThread(): starting...\n");

  signed int return_value_sprintf_5;
  char *tmp_post_6;
  do
  {
    signed int size;
    syncSenders(((char *)NULL), 0);
    size = SendSize;
    if(size == 0)
    {
      unsigned long int ds;
      unsigned char hashvalue[128l];
      char *msg;
      char *m;
      const char *an;
      signed int i;
      void *return_value_malloc_1;
      return_value_malloc_1=malloc((unsigned long int)300);
      msg = (char *)return_value_malloc_1;
      m = msg;
      if(Verbose >= 5)
        logdebug("hashThread(): done.\n");

      mhash_deinit(ctxt, (void *)hashvalue);
      const unsigned char *return_value_mhash_get_hash_name_static_2;
      return_value_mhash_get_hash_name_static_2=mhash_get_hash_name_static((enum __hashid)algo);
      an = (const char *)return_value_mhash_get_hash_name_static_2;
      unsigned int return_value_mhash_get_block_size_3;
      return_value_mhash_get_block_size_3=mhash_get_block_size((enum __hashid)algo);
      ds = (unsigned long int)return_value_mhash_get_block_size_3;
      /* assertion sizeof(hashvalue) >= ds */
      assert(sizeof(unsigned char [128l]) /*128ul*/  >= ds);
      signed int return_value_sprintf_4;
      return_value_sprintf_4=sprintf(m, "%s hash: ", an);
      m = m + (signed long int)return_value_sprintf_4;
      i = 0;
      for( ; !((unsigned long int)i >= ds); i = i + 1)
      {
        return_value_sprintf_5=sprintf(m, "%02x", (unsigned int)hashvalue[(signed long int)i]);
        m = m + (signed long int)return_value_sprintf_5;
      }
      tmp_post_6 = m;
      m = m + 1l;
      *tmp_post_6 = (char)10;
      *m = (char)0;
      dest->result = msg;
      pthread_exit((void *)msg);
      return NULL;
    }

    if(!(Terminate == 0))
    {
      syncSenders(((char *)NULL), -1);
      infomsg("hashThread(): terminating early upon request...\n");
      pthread_exit((void *)0);
    }

    if(Verbose >= 6)
      logdebug("hashThread(): hashing %d@0x%p\n", size, (void *)SendAt);

    mhash(ctxt, (const void *)SendAt, (unsigned int)size);
  }
  while((_Bool)1);
}

// infomsg
// file log.c line 113
void infomsg(const char *msg, ...)
{
  if(Verbose >= 4)
  {
    void **val;
    char buf[256l];
    char *b = buf + (signed long int)PrefixLen;
    unsigned long int s;
    val = (void **)&msg;
    memcpy((void *)buf, (const void *)Prefix, PrefixLen);
    signed int return_value_vsnprintf_1;
    return_value_vsnprintf_1=vsnprintf(b, sizeof(char [256l]) /*256ul*/  - (unsigned long int)(b - buf), msg, val);
    b = b + (signed long int)return_value_vsnprintf_1;
    s = (unsigned long int)(b - buf);
    /* assertion s < sizeof(buf) */
    assert(s < sizeof(char [256l]) /*256ul*/ );
    logwrite(buf, s);
    val = ((void **)NULL);
  }

}

// initDefaults
// file mbuffer.c line 1660
static void initDefaults()
{
  char dfname[4097l];
  char line[256l];
  const char *home;
  home=getenv("HOME");
  unsigned long int l;
  signed int df;
  struct _IO_FILE *dfstr;
  struct stat st;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  signed int return_value_feof_8;
  _Bool tmp_if_expr_10;
  signed int *return_value___errno_location_9;
  signed int return_value_strcasecmp_69;
  _Bool tmp_if_expr_12;
  signed int *return_value___errno_location_11;
  signed int return_value_strcasecmp_68;
  _Bool tmp_if_expr_15;
  signed int *return_value___errno_location_14;
  signed int return_value_strcasecmp_67;
  signed int return_value_strcasecmp_66;
  signed int return_value_strcasecmp_65;
  _Bool tmp_if_expr_19;
  signed int *return_value___errno_location_18;
  signed int return_value_strcasecmp_64;
  _Bool tmp_if_expr_27;
  signed int return_value_strcasecmp_26;
  _Bool tmp_if_expr_29;
  signed int return_value_strcmp_28;
  signed int return_value_strcasecmp_20;
  _Bool tmp_if_expr_22;
  signed int return_value_strcasecmp_21;
  _Bool tmp_if_expr_24;
  signed int return_value_strcmp_23;
  signed int return_value_strcasecmp_63;
  _Bool tmp_if_expr_37;
  signed int return_value_strcasecmp_36;
  _Bool tmp_if_expr_39;
  signed int return_value_strcmp_38;
  signed int return_value_strcasecmp_30;
  _Bool tmp_if_expr_32;
  signed int return_value_strcasecmp_31;
  _Bool tmp_if_expr_34;
  signed int return_value_strcmp_33;
  signed int return_value_strcasecmp_62;
  _Bool tmp_if_expr_47;
  signed int return_value_strcasecmp_46;
  _Bool tmp_if_expr_49;
  signed int return_value_strcmp_48;
  signed int return_value_strcasecmp_40;
  _Bool tmp_if_expr_42;
  signed int return_value_strcasecmp_41;
  _Bool tmp_if_expr_44;
  signed int return_value_strcmp_43;
  signed int return_value_strcasecmp_61;
  _Bool tmp_if_expr_58;
  signed int return_value_strcasecmp_57;
  _Bool tmp_if_expr_60;
  signed int return_value_strcmp_59;
  signed int return_value_strcasecmp_51;
  _Bool tmp_if_expr_53;
  signed int return_value_strcasecmp_52;
  _Bool tmp_if_expr_55;
  signed int return_value_strcmp_54;
  signed int return_value_strcasecmp_74;
  signed int return_value_strcasecmp_73;
  signed int return_value_strcasecmp_72;
  signed int return_value_strcasecmp_71;
  if(home == ((const char *)NULL))
    warningmsg("HOME environment variable not set - unable to find defaults file\n");

  else
  {
    strncpy(dfname, home, sizeof(char [4097l]) /*4097ul*/  - (unsigned long int)1);
    dfname[(signed long int)(sizeof(char [4097l]) /*4097ul*/  - (unsigned long int)1)] = (char)0;
    l=strlen(dfname);
    if(12ul + l >= 4097ul)
      warningmsg("path to defaults file breaks PATH_MAX\n");

    else
    {
      strcat(dfname, "/.mbuffer.rc");
      df=open(dfname, 00);
      if(df == -1)
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        if(*return_value___errno_location_3 == 2)
          infomsg("no defaults file ~/.mbuffer.rc\n");

        else
        {
          return_value___errno_location_1=__errno_location();
          return_value_strerror_2=strerror(*return_value___errno_location_1);
          warningmsg("error opening defaults file %s: %s\n", (const void *)dfname, return_value_strerror_2);
        }
        goto __CPROVER_DUMP_L101;
      }

      signed int return_value_fstat_6;
      return_value_fstat_6=fstat(df, &st);
      if(return_value_fstat_6 == -1)
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        char *return_value_strerror_5;
        return_value_strerror_5=strerror(*return_value___errno_location_4);
        warningmsg("unable to stat defaults file %s: %s\n", (const void *)dfname, return_value_strerror_5);
        close(df);
        goto __CPROVER_DUMP_L101;
      }

      unsigned int return_value_getuid_7;
      return_value_getuid_7=getuid();
      if(!(return_value_getuid_7 == st.st_uid))
      {
        warningmsg("ignoring defaults file from different user\n");
        close(df);
      }

      else
      {
        infomsg("reading defaults file %s\n", (const void *)dfname);
        dfstr=fdopen(df, "r");
        /* assertion dfstr */
        assert(dfstr != ((struct _IO_FILE *)NULL));
        do
        {
          return_value_feof_8=feof(dfstr);
          if(!(return_value_feof_8 == 0))
            break;

          char key[64l];
          char valuestr[64l];
          fscanf(dfstr, "%255[^\n]\n", (const void *)line);
          char *pound;
          pound=strchr(line, 35);
          unsigned long long int value;
          signed int a;
          if(!(pound == ((char *)NULL)))
            *pound = (char)0;

          a=sscanf(line, "%63[A-Za-z]%*[ \t=:]%63[0-9a-zA-Z]", (const void *)key, (const void *)valuestr);
          if(!(a == 2))
            warningmsg("unable to parse line '%s' in .mbuffer.rc; %d arguments\n", (const void *)line, a);

          else
          {
            if(Verbose >= 5)
              logdebug("parsing key/value pair %s=%s\n", (const void *)key, (const void *)valuestr);

            signed int return_value_strcasecmp_70;
            return_value_strcasecmp_70=strcasecmp(key, "numblocks");
            if(return_value_strcasecmp_70 == 0)
            {
              signed long int nb;
              nb=strtol(valuestr, ((char ** restrict )NULL), 0);
              if(nb == 0l)
              {
                return_value___errno_location_9=__errno_location();
                tmp_if_expr_10 = *return_value___errno_location_9 == 22 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_10 = (_Bool)0;
              if(tmp_if_expr_10)
                warningmsg("invalid argument for %s: \"%s\"\n", (const void *)key, (const void *)valuestr);

              else
              {
                Numblocks = nb;
                if(Verbose >= 5)
                  logdebug("Numblocks = %llu\n", Numblocks);

              }
            }

            else
            {
              return_value_strcasecmp_69=strcasecmp(key, "pause");
              if(return_value_strcasecmp_69 == 0)
              {
                signed long int p;
                p=strtol(valuestr, ((char ** restrict )NULL), 0);
                if(p == 0l)
                {
                  return_value___errno_location_11=__errno_location();
                  tmp_if_expr_12 = *return_value___errno_location_11 == 22 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_12 = (_Bool)0;
                if(tmp_if_expr_12)
                  warningmsg("invalid argument for %s: \"%s\"\n", (const void *)key, (const void *)valuestr);

                else
                {
                  Pause = (unsigned long int)p;
                  if(Verbose >= 5)
                    logdebug("Pause = %d\n", Pause);

                }
              }

              else
              {
                return_value_strcasecmp_68=strcasecmp(key, "autoloadtime");
                if(return_value_strcasecmp_68 == 0)
                {
                  signed long int at;
                  signed long int return_value_strtol_13;
                  return_value_strtol_13=strtol(valuestr, ((char ** restrict )NULL), 0);
                  at = return_value_strtol_13 - (signed long int)1;
                  if(at == 0l)
                  {
                    return_value___errno_location_14=__errno_location();
                    tmp_if_expr_15 = *return_value___errno_location_14 == 22 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_15 = (_Bool)0;
                  if(tmp_if_expr_15)
                    warningmsg("invalid argument for %s: \"%s\"\n", (const void *)key, (const void *)valuestr);

                  else
                  {
                    AutoloadTime = (unsigned int)at;
                    if(Verbose >= 5)
                      logdebug("Autoloader time = %d\n", AutoloadTime);

                  }
                }

                else
                {
                  return_value_strcasecmp_67=strcasecmp(key, "startread");
                  if(return_value_strcasecmp_67 == 0)
                  {
                    double sr = (double)0;
                    signed int return_value_sscanf_16;
                    return_value_sscanf_16=sscanf(valuestr, "%lf", &sr);
                    if(return_value_sscanf_16 == 1)
                      sr = sr / (double)100;

                    if(sr <= 1.000000 && sr > 0.000000)
                    {
                      StartRead = sr;
                      if(Verbose >= 5)
                        logdebug("StartRead = %1.2lf\n", StartRead);

                    }

                  }

                  else
                  {
                    return_value_strcasecmp_66=strcasecmp(key, "startwrite");
                    if(return_value_strcasecmp_66 == 0)
                    {
                      double sw = (double)0;
                      signed int return_value_sscanf_17;
                      return_value_sscanf_17=sscanf(valuestr, "%lf", &sw);
                      if(return_value_sscanf_17 == 1)
                        sw = sw / (double)100;

                      if(sw <= 1.000000 && sw > 0.000000)
                      {
                        StartWrite = sw;
                        if(Verbose >= 5)
                          logdebug("StartWrite = %1.2lf\n", StartWrite);

                      }

                    }

                    else
                    {
                      return_value_strcasecmp_65=strcasecmp(key, "timeout");
                      if(return_value_strcasecmp_65 == 0)
                      {
                        signed long int t;
                        t=strtol(valuestr, ((char ** restrict )NULL), 0);
                        if(t == 0l)
                        {
                          return_value___errno_location_18=__errno_location();
                          tmp_if_expr_19 = *return_value___errno_location_18 == 22 ? (_Bool)1 : (_Bool)0;
                        }

                        else
                          tmp_if_expr_19 = (_Bool)0;
                        if(!(t >= 0l) || tmp_if_expr_19)
                          warningmsg("invalid argument for %s: \"%s\"\n", (const void *)key, (const void *)valuestr);

                        else
                        {
                          Timeout = (unsigned long int)t;
                          if(Verbose >= 5)
                            logdebug("Timeout = %lu\n", Timeout);

                        }
                      }

                      else
                      {
                        return_value_strcasecmp_64=strcasecmp(key, "showstatus");
                        if(return_value_strcasecmp_64 == 0)
                        {
                          signed int return_value_strcasecmp_25;
                          return_value_strcasecmp_25=strcasecmp(valuestr, "yes");
                          if(return_value_strcasecmp_25 == 0)
                            tmp_if_expr_27 = (_Bool)1;

                          else
                          {
                            return_value_strcasecmp_26=strcasecmp(valuestr, "on");
                            tmp_if_expr_27 = return_value_strcasecmp_26 == 0 ? (_Bool)1 : (_Bool)0;
                          }
                          if(tmp_if_expr_27)
                            tmp_if_expr_29 = (_Bool)1;

                          else
                          {
                            return_value_strcmp_28=strcmp(valuestr, "1");
                            tmp_if_expr_29 = return_value_strcmp_28 == 0 ? (_Bool)1 : (_Bool)0;
                          }
                          if(tmp_if_expr_29)
                          {
                            Quiet = 0;
                            if(Verbose >= 5)
                              logdebug("showstatus = yes\n");

                          }

                          else
                          {
                            return_value_strcasecmp_20=strcasecmp(valuestr, "no");
                            if(return_value_strcasecmp_20 == 0)
                              tmp_if_expr_22 = (_Bool)1;

                            else
                            {
                              return_value_strcasecmp_21=strcasecmp(valuestr, "off");
                              tmp_if_expr_22 = return_value_strcasecmp_21 == 0 ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr_22)
                              tmp_if_expr_24 = (_Bool)1;

                            else
                            {
                              return_value_strcmp_23=strcmp(valuestr, "0");
                              tmp_if_expr_24 = return_value_strcmp_23 == 0 ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr_24)
                            {
                              Quiet = 1;
                              if(Verbose >= 5)
                                logdebug("showstatus = no\n");

                            }

                            else
                              warningmsg("invalid argument for %s: \"%s\"\n", (const void *)key, (const void *)valuestr);
                          }
                          continue;
                        }

                        else
                        {
                          return_value_strcasecmp_63=strcasecmp(key, "logstatus");
                          if(return_value_strcasecmp_63 == 0)
                          {
                            signed int return_value_strcasecmp_35;
                            return_value_strcasecmp_35=strcasecmp(valuestr, "yes");
                            if(return_value_strcasecmp_35 == 0)
                              tmp_if_expr_37 = (_Bool)1;

                            else
                            {
                              return_value_strcasecmp_36=strcasecmp(valuestr, "on");
                              tmp_if_expr_37 = return_value_strcasecmp_36 == 0 ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr_37)
                              tmp_if_expr_39 = (_Bool)1;

                            else
                            {
                              return_value_strcmp_38=strcmp(valuestr, "1");
                              tmp_if_expr_39 = return_value_strcmp_38 == 0 ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr_39)
                            {
                              StatusLog = 1;
                              if(Verbose >= 5)
                                logdebug("logstatus = yes\n");

                            }

                            else
                            {
                              return_value_strcasecmp_30=strcasecmp(valuestr, "no");
                              if(return_value_strcasecmp_30 == 0)
                                tmp_if_expr_32 = (_Bool)1;

                              else
                              {
                                return_value_strcasecmp_31=strcasecmp(valuestr, "off");
                                tmp_if_expr_32 = return_value_strcasecmp_31 == 0 ? (_Bool)1 : (_Bool)0;
                              }
                              if(tmp_if_expr_32)
                                tmp_if_expr_34 = (_Bool)1;

                              else
                              {
                                return_value_strcmp_33=strcmp(valuestr, "0");
                                tmp_if_expr_34 = return_value_strcmp_33 == 0 ? (_Bool)1 : (_Bool)0;
                              }
                              if(tmp_if_expr_34)
                              {
                                StatusLog = 0;
                                if(Verbose >= 5)
                                  logdebug("logstatus = no\n");

                              }

                              else
                                warningmsg("invalid argument for %s: \"%s\"\n", (const void *)key, (const void *)valuestr);
                            }
                            continue;
                          }

                          else
                          {
                            return_value_strcasecmp_62=strcasecmp(key, "memlock");
                            if(return_value_strcasecmp_62 == 0)
                            {
                              signed int return_value_strcasecmp_45;
                              return_value_strcasecmp_45=strcasecmp(valuestr, "yes");
                              if(return_value_strcasecmp_45 == 0)
                                tmp_if_expr_47 = (_Bool)1;

                              else
                              {
                                return_value_strcasecmp_46=strcasecmp(valuestr, "on");
                                tmp_if_expr_47 = return_value_strcasecmp_46 == 0 ? (_Bool)1 : (_Bool)0;
                              }
                              if(tmp_if_expr_47)
                                tmp_if_expr_49 = (_Bool)1;

                              else
                              {
                                return_value_strcmp_48=strcmp(valuestr, "1");
                                tmp_if_expr_49 = return_value_strcmp_48 == 0 ? (_Bool)1 : (_Bool)0;
                              }
                              if(tmp_if_expr_49)
                              {
                                Memlock = 1;
                                if(Verbose >= 5)
                                  logdebug("Memlock = %lu\n", Memlock);

                              }

                              else
                              {
                                return_value_strcasecmp_40=strcasecmp(valuestr, "no");
                                if(return_value_strcasecmp_40 == 0)
                                  tmp_if_expr_42 = (_Bool)1;

                                else
                                {
                                  return_value_strcasecmp_41=strcasecmp(valuestr, "off");
                                  tmp_if_expr_42 = return_value_strcasecmp_41 == 0 ? (_Bool)1 : (_Bool)0;
                                }
                                if(tmp_if_expr_42)
                                  tmp_if_expr_44 = (_Bool)1;

                                else
                                {
                                  return_value_strcmp_43=strcmp(valuestr, "0");
                                  tmp_if_expr_44 = return_value_strcmp_43 == 0 ? (_Bool)1 : (_Bool)0;
                                }
                                if(tmp_if_expr_44)
                                {
                                  Memlock = 0;
                                  if(Verbose >= 5)
                                    logdebug("Memlock = %lu\n", Memlock);

                                }

                                else
                                  warningmsg("invalid argument for %s: \"%s\"\n", (const void *)key, (const void *)valuestr);
                              }
                              continue;
                            }

                            else
                            {
                              return_value_strcasecmp_61=strcasecmp(key, "printpid");
                              if(return_value_strcasecmp_61 == 0)
                              {
                                signed int return_value_strcasecmp_56;
                                return_value_strcasecmp_56=strcasecmp(valuestr, "yes");
                                if(return_value_strcasecmp_56 == 0)
                                  tmp_if_expr_58 = (_Bool)1;

                                else
                                {
                                  return_value_strcasecmp_57=strcasecmp(valuestr, "on");
                                  tmp_if_expr_58 = return_value_strcasecmp_57 == 0 ? (_Bool)1 : (_Bool)0;
                                }
                                if(tmp_if_expr_58)
                                  tmp_if_expr_60 = (_Bool)1;

                                else
                                {
                                  return_value_strcmp_59=strcmp(valuestr, "1");
                                  tmp_if_expr_60 = return_value_strcmp_59 == 0 ? (_Bool)1 : (_Bool)0;
                                }
                                if(tmp_if_expr_60)
                                {
                                  signed int return_value_getpid_50;
                                  return_value_getpid_50=getpid();
                                  printmsg("PID is %d\n", return_value_getpid_50);
                                }

                                else
                                {
                                  return_value_strcasecmp_51=strcasecmp(valuestr, "no");
                                  if(return_value_strcasecmp_51 == 0)
                                    tmp_if_expr_53 = (_Bool)1;

                                  else
                                  {
                                    return_value_strcasecmp_52=strcasecmp(valuestr, "off");
                                    tmp_if_expr_53 = return_value_strcasecmp_52 == 0 ? (_Bool)1 : (_Bool)0;
                                  }
                                  if(tmp_if_expr_53)
                                    tmp_if_expr_55 = (_Bool)1;

                                  else
                                  {
                                    return_value_strcmp_54=strcmp(valuestr, "0");
                                    tmp_if_expr_55 = return_value_strcmp_54 == 0 ? (_Bool)1 : (_Bool)0;
                                  }
                                  if(!tmp_if_expr_55)
                                    warningmsg("invalid argument for %s: \"%s\"\n", (const void *)key, (const void *)valuestr);

                                }
                                continue;
                              }

                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            const char *argerror;
            argerror=calcval(valuestr, &value);
            if(!(argerror == ((const char *)NULL)))
              warningmsg("ignoring key/value pair from defaults file (%s = %s): %s\n", (const void *)key, (const void *)valuestr, argerror);

            else
            {
              signed int return_value_strcasecmp_75;
              return_value_strcasecmp_75=strcasecmp(key, "blocksize");
              if(return_value_strcasecmp_75 == 0)
                Blocksize = value;

              else
              {
                return_value_strcasecmp_74=strcasecmp(key, "maxwritespeed");
                if(return_value_strcasecmp_74 == 0)
                  MaxWriteSpeed = value;

                else
                {
                  return_value_strcasecmp_73=strcasecmp(key, "maxreadspeed");
                  if(return_value_strcasecmp_73 == 0)
                    MaxReadSpeed = value;

                  else
                  {
                    return_value_strcasecmp_72=strcasecmp(key, "Totalmem");
                    if(return_value_strcasecmp_72 == 0)
                    {
                      if(!(value >= 100ul))
                      {
                        Totalmem = ((unsigned long long int)NumP * PgSz * value) / (unsigned long int)100;
                        if(Verbose >= 5)
                          logdebug("Totalmem = %lluk\n", Totalmem >> 10);

                      }

                    }

                    else
                    {
                      return_value_strcasecmp_71=strcasecmp(key, "tcpbuffer");
                      if(return_value_strcasecmp_71 == 0)
                        TCPBufSize = (signed int)value;

                      else
                      {
                        warningmsg("unknown key: %s\n", (const void *)key);
                        continue;
                      }
                    }
                  }
                }
              }
              infomsg("setting %s to %lld\n", (const void *)key, value);
            }
          }
        }
        while((_Bool)1);
        fclose(dfstr);
        close(df);
      }
    }
  }

__CPROVER_DUMP_L101:
  ;
}

// initNetworkInput
// file network.c line 93
void initNetworkInput(const char *addr)
{
  char *host;
  char *port;
  struct addrinfo hint;
  struct addrinfo *pinfo = ((struct addrinfo *)NULL);
  struct addrinfo *x;
  struct addrinfo *cinfo = ((struct addrinfo *)NULL);
  signed int err;
  signed int sock = -1;
  signed int l;
  if(Verbose >= 5)
    logdebug("initNetworkInput(\"%s\")\n", addr);

  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(addr);
  l = (signed int)(return_value_strlen_1 + (unsigned long int)1);
  void *return_value___builtin_alloca_2;
  return_value___builtin_alloca_2=__builtin_alloca((unsigned long int)l);
  host = (char *)return_value___builtin_alloca_2;
  memcpy((void *)host, (const void *)addr, (unsigned long int)l);
  port=strrchr(host, 58);
  const char *return_value_gai_strerror_3;
  if(port == ((char *)NULL))
  {
    port = host;
    host = ((char *)NULL);
  }

  else
    if(port == host)
    {
      port = host + (signed long int)1;
      host = ((char *)NULL);
    }

    else
    {
      *port = (char)0;
      port = port + 1l;
      bzero((void *)&hint, sizeof(struct addrinfo) /*48ul*/ );
      hint.ai_family = AddrFam;
      hint.ai_protocol = 6;
      hint.ai_socktype = 1;
      hint.ai_flags = 0x0020 | 0x0008;
      err=getaddrinfo(host, ((const char *)NULL), &hint, &cinfo);
      if(!(err == 0))
      {
        return_value_gai_strerror_3=gai_strerror(err);
        fatal("unable to resolve address information for expected host '%s': %s\n", host, return_value_gai_strerror_3);
      }

    }
  bzero((void *)&hint, sizeof(struct addrinfo) /*48ul*/ );
  hint.ai_family = AddrFam;
  hint.ai_protocol = 6;
  hint.ai_socktype = 1;
  hint.ai_flags = 0x0001 | 0x0020;
  err=getaddrinfo(((const char *)NULL), port, &hint, &pinfo);
  const char *return_value_gai_strerror_4;
  if(!(err == 0))
  {
    return_value_gai_strerror_4=gai_strerror(err);
    fatal("unable to get address information for port/service '%s': %s\n", port, return_value_gai_strerror_4);
  }

  /* assertion pinfo */
  assert(pinfo != ((struct addrinfo *)NULL));
  x = pinfo;
  signed int *return_value___errno_location_7;
  char *return_value_strerror_8;
  for( ; !(x == ((struct addrinfo *)NULL)); x = x->ai_next)
  {
    signed int reuse_addr = 1;
    if(Verbose >= 5)
      logdebug("creating socket for address familiy %d\n", x->ai_family);

    sock=socket(x->ai_family, 1, 0);
    if(sock == -1)
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      char *return_value_strerror_6;
      return_value_strerror_6=strerror(*return_value___errno_location_5);
      warningmsg("unable to create socket for input: %s\n", return_value_strerror_6);
      goto __CPROVER_DUMP_L13;
    }

    signed int return_value_setsockopt_9;
    return_value_setsockopt_9=setsockopt(sock, 1, 2, (const void *)&reuse_addr, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(return_value_setsockopt_9 == -1)
    {
      return_value___errno_location_7=__errno_location();
      return_value_strerror_8=strerror(*return_value___errno_location_7);
      warningmsg("cannot set socket to reuse address: %s\n", return_value_strerror_8);
    }

    signed int return_value_bind_10;
    return_value_bind_10=bind(sock, x->ai_addr, x->ai_addrlen);
    if(return_value_bind_10 == 0)
    {
      if(Verbose >= 5)
        logdebug("successfully bound socket - address length %d\n", x->ai_addrlen);

      break;
    }

    signed int *return_value___errno_location_11;
    return_value___errno_location_11=__errno_location();
    char *return_value_strerror_12;
    return_value_strerror_12=strerror(*return_value___errno_location_11);
    warningmsg("could not bind to socket for network input: %s\n", return_value_strerror_12);
    close(sock);

  __CPROVER_DUMP_L13:
    ;
  }
  if(x == ((struct addrinfo *)NULL))
    fatal("Unable to initialize network input.\n");

  infomsg("listening on socket...\n");
  signed int return_value_listen_15;
  return_value_listen_15=listen(sock, 0);
  signed int *return_value___errno_location_13;
  char *return_value_strerror_14;
  if(!(return_value_listen_15 >= 0))
  {
    return_value___errno_location_13=__errno_location();
    return_value_strerror_14=strerror(*return_value___errno_location_13);
    fatal("could not listen on socket for network input: %s\n", return_value_strerror_14);
  }

  signed int *return_value___errno_location_16;
  char *return_value_strerror_17;
  signed int *return_value___errno_location_21;
  char *return_value_strerror_22;
  do
  {
    char chost[1025l];
    char serv[32l];
    struct sockaddr_in6 caddr;
    struct addrinfo *c;
    unsigned int len = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
    signed int initNetworkInput__1__5__1__err;
    if(Verbose >= 5)
      logdebug("waiting for incoming connection\n");

    In=accept(sock, (struct sockaddr *)&caddr, &len);
    if(!(In >= 0))
    {
      return_value___errno_location_16=__errno_location();
      return_value_strerror_17=strerror(*return_value___errno_location_16);
      fatal("Unable to accept connection for network input: %s\n", return_value_strerror_17);
    }

    initNetworkInput__1__5__1__err=getnameinfo((struct sockaddr *)&caddr, len, chost, (unsigned int)sizeof(char [1025l]) /*1025ul*/ , serv, (unsigned int)sizeof(char [32l]) /*32ul*/ , 1 | 2 | 4);
    if(!(initNetworkInput__1__5__1__err == 0))
    {
      const char *return_value_gai_strerror_18;
      return_value_gai_strerror_18=gai_strerror(initNetworkInput__1__5__1__err);
      fatal("unable to get name information for hostname of incoming connection: %s\n", return_value_gai_strerror_18);
    }

    infomsg("incoming connection from %s:%s\n", (const void *)chost, (const void *)serv);
    if(host == ((char *)NULL))
      break;

    c = cinfo;
    for( ; !(c == ((struct addrinfo *)NULL)); c = c->ai_next)
    {
      char xhost[1025l];
      signed int return_value_getnameinfo_20;
      return_value_getnameinfo_20=getnameinfo((struct sockaddr *)c->ai_addr, c->ai_addrlen, xhost, (unsigned int)sizeof(char [1025l]) /*1025ul*/ , ((char *)NULL), (unsigned int)0, 1 | 4);
      if(return_value_getnameinfo_20 == 0)
      {
        if(Verbose >= 5)
          logdebug("checking against host '%s'\n", (const void *)xhost);

        signed int return_value_strcmp_19;
        return_value_strcmp_19=strcmp(xhost, chost);
        if(return_value_strcmp_19 == 0)
          break;

      }

    }
    if(!(c == ((struct addrinfo *)NULL)))
      break;

    warningmsg("rejected connection from %s\n", (const void *)chost);
    signed int return_value_close_23;
    return_value_close_23=close(In);
    if(return_value_close_23 == -1)
    {
      return_value___errno_location_21=__errno_location();
      return_value_strerror_22=strerror(*return_value___errno_location_21);
      warningmsg("error closing rejected input: %s\n", return_value_strerror_22);
    }

  }
  while((_Bool)1);
  freeaddrinfo(pinfo);
  if(!(cinfo == ((struct addrinfo *)NULL)))
    freeaddrinfo(cinfo);

  if(Verbose >= 5)
    logdebug("input connection accepted\n");

  setTCPBufferSize(In, (unsigned int)8);
  close(sock);
}

// inputThread
// file mbuffer.c line 673
static void * inputThread(void *ignored)
{
  signed int fill = 0;
  unsigned long long int num;
  signed int at = 0;
  signed long long int xfer = (signed long long int)0;
  const double startread = StartRead;
  const double startwrite = StartWrite;
  struct timespec last;
  signed int maxfd;
  signed int tmp_if_expr_1;
  if(!(In >= TermQ[0l]))
    tmp_if_expr_1 = TermQ[(signed long int)0] + 1;

  else
    tmp_if_expr_1 = In + 1;
  maxfd = tmp_if_expr_1;
  if(!(Status == 0))
    /* assertion TermQ[0] != -1 */
    assert(TermQ[(signed long int)0] != -1);

  clock_gettime(ClockSrc, &last);
  /* assertion ignored == 0 */
  assert(ignored == NULL);
  unsigned long int return_value_pthread_self_2;
  return_value_pthread_self_2=pthread_self();
  infomsg("inputThread: starting with threadid %ld...\n", (signed long int)return_value_pthread_self_2);
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  _Bool tmp_if_expr_7;
  signed int *return_value___errno_location_6;
  _Bool tmp_if_expr_13;
  signed int *return_value___errno_location_12;
  signed int *return_value___errno_location_10;
  char *return_value_strerror_11;
  do
  {
    signed int err;
    if(startread < 1.000000)
    {
      err=pthread_mutex_lock(&LowMut);
      /* assertion err == 0 */
      assert(err == 0);
      err=sem_getvalue(&Buf2Dev, &fill);
      /* assertion err == 0 */
      assert(err == 0);
      if((signed long int)fill == Numblocks + -1l)
      {
        if(Verbose >= 5)
          logdebug("inputThread: buffer full, waiting for it to drain.\n");

        do
        {
          struct anonymous_3 __cancel_buf;
          void (*__cancel_routine)(void *) = releaseLock;
          void *__cancel_arg = (void *)&LowMut;
          signed int __not_first_call;
          __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
          if(!((signed long int)__not_first_call == 0l))
          {
            __cancel_routine(__cancel_arg);
            __pthread_unwind_next(&__cancel_buf);
          }

          __pthread_register_cancel(&__cancel_buf);
          do
          {
            err=pthread_cond_wait(&PercLow, &LowMut);
            /* assertion err == 0 */
            assert(err == 0);

          __CPROVER_DUMP_L8:
            ;
          }
          while((_Bool)0);
          __pthread_unregister_cancel(&__cancel_buf);
        }
        while((_Bool)0);
        FullCount = FullCount + 1;
        if(Verbose >= 5)
          logdebug("inputThread: low watermark reached, continuing...\n");

      }

      err=pthread_mutex_unlock(&LowMut);
      /* assertion err == 0 */
      assert(err == 0);
    }

    if(!(Terminate == 0))
    {
      if(Verbose >= 5)
        logdebug("inputThread: terminating early upon request...\n");

      signed int return_value_close_5;
      return_value_close_5=close(In);
      if(return_value_close_5 == -1)
      {
        return_value___errno_location_3=__errno_location();
        return_value_strerror_4=strerror(*return_value___errno_location_3);
        errormsg("error closing input: %s\n", return_value_strerror_4);
      }

      if(!(Status == 0))
        pthread_exit((void *)1);

      return (void *)1;
    }

    err=sem_wait(&Dev2Buf);
    /* assertion err == 0 */
    assert(err == 0);
    num = (unsigned long long int)0;
    do
    {
      signed int in;
      if(!(Status == 0))
      {
        struct anonymous_1 readfds;
        do
        {
          signed int __d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_1) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readfds)->fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        (&readfds)->fds_bits[(signed long int)(TermQ[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->fds_bits[(signed long int)(TermQ[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << TermQ[(signed long int)0] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        (&readfds)->fds_bits[(signed long int)(In / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->fds_bits[(signed long int)(In / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << In % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        err=select(maxfd, &readfds, ((struct anonymous_1 *)NULL), ((struct anonymous_1 *)NULL), ((struct timeval *)NULL));
        if(Verbose >= 6)
          logdebug("inputThread: select(%d, {%d,%d}, 0, 0, 0) = %d\n", maxfd, In, TermQ[(signed long int)0], err);

        if(err >= 1)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value___errno_location_6=__errno_location();
          tmp_if_expr_7 = *return_value___errno_location_6 == 9 ? (_Bool)1 : (_Bool)0;
        }
        /* assertion (err > 0) || ((*__errno_location ()) == 9) */
        assert(tmp_if_expr_7);
        if(!((readfds.fds_bits[(signed long int)(TermQ[0l] / 8)] & (signed long int)(1UL << TermQ[0l] % 8)) == 0l))
          return (void *)-1;

        /* assertion ((((&readfds)->fds_bits)[((In) / (8 * (int) sizeof (__fd_mask)))] & ((__fd_mask) (1UL << ((In) % (8 * (int) sizeof (__fd_mask)))))) != 0) */
        assert(((&readfds)->fds_bits[(signed long int)(In / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & (signed long int)(1UL << In % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0);
      }

      signed long int return_value_read_8;
      return_value_read_8=read(In, (void *)(Buffer[(signed long int)at] + (signed long int)num), Blocksize - num);
      in = (signed int)return_value_read_8;
      if(Verbose >= 6)
        logdebug("inputThread: read(In, Buffer[%d] + %llu, %llu) = %d\n", at, num, Blocksize - num, in);

      if(in >= 1)
        num = num + (unsigned long long int)in;

      else
        if(in == 0 && !(NumVolumes == 1l) && (!(Autoloader == 0) || !(Terminal == 0)))
        {
          signed int return_value_requestInputVolume_9;
          return_value_requestInputVolume_9=requestInputVolume((unsigned int)at, (unsigned int)num);
          if(return_value_requestInputVolume_9 == 0)
            return NULL;

        }

        else
        {
          if(in == -1)
          {
            return_value___errno_location_12=__errno_location();
            tmp_if_expr_13 = *return_value___errno_location_12 == 5 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_13 = (_Bool)0;
          if(!(NumVolumes == 1l) && (!(Autoloader == 0) || !(Terminal == 0)) && tmp_if_expr_13)
            requestInputVolume((unsigned int)at, (unsigned int)num);

          else
            if(!(in >= 1))
            {
              if(Terminate == 0 && in == -1)
              {
                return_value___errno_location_10=__errno_location();
                return_value_strerror_11=strerror(*return_value___errno_location_10);
                errormsg("inputThread: error reading at offset 0x%llx: %s\n", Numin * Blocksize, return_value_strerror_11);
              }

              Rest = num;
              Finish = (signed long int)at;
              if(Verbose >= 5)
                logdebug("inputThread: last block has %llu bytes\n", num);

              err=pthread_mutex_lock(&HighMut);
              /* assertion err == 0 */
              assert(err == 0);
              err=sem_post(&Buf2Dev);
              /* assertion err == 0 */
              assert(err == 0);
              err=pthread_cond_signal(&PercHigh);
              /* assertion err == 0 */
              assert(err == 0);
              err=pthread_mutex_unlock(&HighMut);
              /* assertion err == 0 */
              assert(err == 0);
              infomsg("inputThread: exiting...\n");
              if(!(Status == 0))
                pthread_exit((void *)in);

              return (void *)in;
            }

        }
    }
    while(!(num >= Blocksize));
    if(!(MaxReadSpeed == 0ull))
      xfer=enforceSpeedLimit(MaxReadSpeed, xfer, &last);

    err=sem_post(&Buf2Dev);
    /* assertion err == 0 */
    assert(err == 0);
    if(startwrite > 0.000000)
    {
      err=pthread_mutex_lock(&HighMut);
      /* assertion err == 0 */
      assert(err == 0);
      err=sem_getvalue(&Buf2Dev, &fill);
      /* assertion err == 0 */
      assert(err == 0);
      if((double)fill / (double)Numblocks + 2.220446e-16 >= startwrite)
      {
        err=pthread_cond_signal(&PercHigh);
        /* assertion err == 0 */
        assert(err == 0);
      }

      err=pthread_mutex_unlock(&HighMut);
      /* assertion err == 0 */
      assert(err == 0);
    }

    at = at + 1;
    if((signed long int)at == Numblocks)
      at = 0;

    Numin = Numin + 1ull;
  }
  while((_Bool)1);
}

// kb2str
// file mbuffer.c line 219
static signed int kb2str(char *s, double v)
{
  const char *dim = "KMGT";
  const char *f;
  while(v > 10000.0)
  {
    v = v / 1024.0;
    dim = dim + 1l;
    if((signed int)*dim == 0)
    {
      v = v * 1024.0 * 1024.0 * 1024.0 * 1024.0;
      break;
    }

  }
  if(v < 0.000000)
    f = " ??? ";

  else
    if(v < 100.000000)
      f = "%4.1f %ci";

    else
      if(v < 10000.000000)
      {
        v=rint(v);
        f = "%4.0f %ci";
      }

      else
        f = "%5.lg ";
  signed int return_value_sprintf_1;
  return_value_sprintf_1=sprintf(s, f, v, *dim);
  return return_value_sprintf_1;
}

// logdebug
// file log.c line 94
void logdebug(const char *msg, ...)
{
  void **val;
  char buf[256l];
  unsigned long int b = PrefixLen;
  val = (void **)&msg;
  memcpy((void *)buf, (const void *)Prefix, b);
  signed int return_value_vsnprintf_1;
  return_value_vsnprintf_1=vsnprintf(buf + (signed long int)b, sizeof(char [256l]) /*256ul*/  - b, msg, val);
  b = b + (unsigned long int)return_value_vsnprintf_1;
  /* assertion b < sizeof(buf) */
  assert(b < sizeof(char [256l]) /*256ul*/ );
  logwrite(buf, b);
  val = ((void **)NULL);
}

// logwrite
// file log.c line 50
void logwrite(char *buf, unsigned long int b)
{
  write(Log, (const void *)buf, b);
}

// main
// file mbuffer.c line 1841
signed int main(signed int argc, const char **argv)
{
  signed int optMset = 0;
  signed int optSset = 0;
  signed int optBset = 0;
  signed int optMode = 0200;
  signed int numOut = 0;
  signed int numstdout = 0;
  signed int numthreads = 0;
  signed long int mxnrsem;
  signed int c;
  signed int fl;
  signed int err;
  struct anonymous signalSet;
  struct stat st;
  unsigned short int netPortIn = (unsigned short int)0;
  unsigned short int netPortOut = (unsigned short int)0;
  char *argv0;
  argv0=strdup(argv[(signed long int)0]);
  char *progname;
  char null;
  const char *outfile = ((const char *)NULL);
  struct sigaction sig;
  struct destination *main__1__dest = ((struct destination *)NULL);
  progname=__xpg_basename(argv0);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(progname);
  PrefixLen = return_value_strlen_1 + (unsigned long int)2;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(PrefixLen);
  Prefix = (char *)return_value_malloc_2;
  strcpy(Prefix, progname);
  Prefix[(signed long int)(PrefixLen - (unsigned long int)2)] = (char)58;
  Prefix[(signed long int)(PrefixLen - (unsigned long int)1)] = (char)32;
  c = 1;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_3;
  for( ; !(c >= argc); c = c + 1)
  {
    const char *arg = argv[(signed long int)c];
    if((signed int)*arg == 45)
    {
      if((signed int)arg[1l] == 118)
      {
        signed long int verb;
        if(!(arg[2l] == 0))
          verb=strtol(arg + (signed long int)2, ((char ** restrict )NULL), 0);

        else
        {
          c = c + 1;
          verb=strtol(argv[(signed long int)c], ((char ** restrict )NULL), 0);
        }
        if(verb == 0l)
        {
          return_value___errno_location_3=__errno_location();
          tmp_if_expr_4 = *return_value___errno_location_3 == 22 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
          errormsg("invalid argument to option -v: \"%s\"\n", argv[(signed long int)c]);

        else
          Verbose = (signed int)verb;
        if(Verbose >= 5)
          logdebug("Verbose = %d\n", Verbose);

      }

    }

  }
  signed long int return_value_sysconf_5;
  return_value_sysconf_5=sysconf(2);
  TickTime = (signed long int)1000000 / return_value_sysconf_5;
  signed long int return_value_sysconf_6;
  return_value_sysconf_6=sysconf(30);
  PgSz = (unsigned long long int)return_value_sysconf_6;
  /* assertion PgSz > 0 */
  assert(PgSz > (unsigned long int)0);
  signed long int return_value_sysconf_7;
  return_value_sysconf_7=sysconf(86);
  NumP = (unsigned long long int)return_value_sysconf_7;
  /* assertion NumP > 0 */
  assert(NumP > (unsigned long int)0);
  Blocksize = PgSz;
  if(Verbose >= 5)
    logdebug("total # of phys pages: %li (pagesize %li)\n", NumP, PgSz);

  Numblocks = (signed long int)(NumP / (unsigned long int)50);
  signed long int return_value_sysconf_8;
  return_value_sysconf_8=sysconf(149);
  if(return_value_sysconf_8 >= 1l)
    ClockSrc = 1;

  initDefaults();
  if(Verbose >= 5)
    logdebug("default buffer set to %d blocks of %lld bytes\n", Numblocks, Blocksize);

  c = 1;
  signed int return_value_strcmp_79;
  signed int return_value_strcmp_78;
  signed int return_value_argcheck_77;
  signed int return_value_argcheck_76;
  _Bool tmp_if_expr_10;
  signed int *return_value___errno_location_9;
  signed int return_value_strcmp_75;
  signed int return_value_argcheck_74;
  signed int return_value_argcheck_73;
  signed int return_value_argcheck_72;
  _Bool tmp_if_expr_13;
  signed int *return_value___errno_location_12;
  signed int return_value_argcheck_71;
  signed int return_value_argcheck_70;
  signed int return_value_argcheck_69;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_15;
  signed int *return_value___errno_location_14;
  signed int return_value_argcheck_68;
  signed int return_value_argcheck_67;
  signed int tmp_post_19;
  signed int return_value_strcmp_66;
  signed int return_value_strcmp_65;
  signed int return_value_strcmp_64;
  signed int return_value_argcheck_63;
  signed int return_value_argcheck_62;
  signed int return_value_argcheck_61;
  signed int return_value_strcmp_60;
  signed int return_value_argcheck_59;
  signed int return_value_strcmp_58;
  signed int return_value_strcmp_57;
  signed int return_value_strcmp_56;
  signed int return_value_strcmp_55;
  signed int return_value_strcmp_54;
  signed int return_value_argcheck_53;
  _Bool tmp_if_expr_27;
  signed int *return_value___errno_location_26;
  signed int return_value_argcheck_52;
  signed int return_value_argcheck_51;
  signed int return_value_argcheck_50;
  signed int return_value_strcmp_49;
  signed int return_value_argcheck_48;
  signed int return_value_strcmp_47;
  signed int return_value_strcmp_44;
  _Bool tmp_if_expr_46;
  signed int return_value_strcmp_45;
  signed int return_value_strcmp_41;
  _Bool tmp_if_expr_43;
  signed int return_value_strcmp_42;
  signed int return_value_strcmp_38;
  _Bool tmp_if_expr_40;
  signed int return_value_strcmp_39;
  signed int return_value_strcmp_37;
  signed int return_value_strcmp_36;
  signed int return_value_argcheck_35;
  for( ; !(c >= argc); c = c + 1)
  {
    signed int return_value_argcheck_80;
    return_value_argcheck_80=argcheck("-s", argv, &c, argc);
    if(return_value_argcheck_80 == 0)
    {
      Outsize=calcint(argv, c, Blocksize);
      Blocksize = Outsize;
      optSset = 1;
      if(Verbose >= 5)
        logdebug("Blocksize = %llu\n", Blocksize);

      if(!(Blocksize >= 100ul))
        fatal("cannot set blocksize as percentage of total physical memory\n");

    }

    else
    {
      return_value_strcmp_79=strcmp("--append", argv[(signed long int)c]);
      if(return_value_strcmp_79 == 0)
      {
        optMode = optMode | 02000;
        if(Verbose >= 5)
          logdebug("append to next file\n");

      }

      else
      {
        return_value_strcmp_78=strcmp("--truncate", argv[(signed long int)c]);
        if(return_value_strcmp_78 == 0)
        {
          optMode = optMode | 01000;
          if(Verbose >= 5)
            logdebug("truncate next file\n");

        }

        else
        {
          return_value_argcheck_77=argcheck("-m", argv, &c, argc);
          if(return_value_argcheck_77 == 0)
          {
            Totalmem=calcint(argv, c, Totalmem);
            optMset = 1;
            if(!(Totalmem >= 100ul))
              Totalmem = ((unsigned long long int)NumP * PgSz * Totalmem) / (unsigned long int)100;

            if(Verbose >= 5)
              logdebug("Totalmem = %lluk\n", Totalmem >> 10);

          }

          else
          {
            return_value_argcheck_76=argcheck("-b", argv, &c, argc);
            if(return_value_argcheck_76 == 0)
            {
              signed long int nb;
              nb=strtol(argv[(signed long int)c], ((char ** restrict )NULL), 0);
              if(nb == 0l)
              {
                return_value___errno_location_9=__errno_location();
                tmp_if_expr_10 = *return_value___errno_location_9 == 22 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_10 = (_Bool)0;
              if(tmp_if_expr_10)
                errormsg("invalid argument to option -b: \"%s\"\n", argv[(signed long int)c]);

              else
              {
                Numblocks = nb;
                optBset = 1;
              }
              if(Verbose >= 5)
                logdebug("Numblocks = %llu\n", Numblocks);

            }

            else
            {
              return_value_strcmp_75=strcmp("--tcpbuffer", argv[(signed long int)c]);
              if(return_value_strcmp_75 == 0)
              {
                c = c + 1;
                unsigned long long int return_value_calcint_11;
                return_value_calcint_11=calcint(argv, c, (unsigned long long int)TCPBufSize);
                TCPBufSize = (signed int)return_value_calcint_11;
                if(Verbose >= 5)
                  logdebug("TCPBufSize = %lu\n", TCPBufSize);

              }

              else
              {
                return_value_argcheck_74=argcheck("-d", argv, &c, argc);
                if(return_value_argcheck_74 == 0)
                {
                  SetOutsize = 1;
                  if(Verbose >= 5)
                    logdebug("setting output size according to the blocksize of the device\n");

                }

                else
                {
                  return_value_argcheck_73=argcheck("-v", argv, &c, argc);
                  if(!(return_value_argcheck_73 == 0))
                  {
                    return_value_argcheck_72=argcheck("-u", argv, &c, argc);
                    if(return_value_argcheck_72 == 0)
                    {
                      signed long int p;
                      p=strtol(argv[(signed long int)c], ((char ** restrict )NULL), 0);
                      if(p == 0l)
                      {
                        return_value___errno_location_12=__errno_location();
                        tmp_if_expr_13 = *return_value___errno_location_12 == 22 ? (_Bool)1 : (_Bool)0;
                      }

                      else
                        tmp_if_expr_13 = (_Bool)0;
                      if(tmp_if_expr_13)
                        errormsg("invalid argument to option -u: \"%s\"\n", argv[(signed long int)c]);

                      else
                        Pause = (unsigned long int)p;
                      if(Verbose >= 5)
                        logdebug("Pause = %d\n", Pause);

                    }

                    else
                    {
                      return_value_argcheck_71=argcheck("-r", argv, &c, argc);
                      if(return_value_argcheck_71 == 0)
                      {
                        MaxReadSpeed=calcint(argv, c, (unsigned long long int)0);
                        if(Verbose >= 5)
                          logdebug("MaxReadSpeed = %lld\n", MaxReadSpeed);

                      }

                      else
                      {
                        return_value_argcheck_70=argcheck("-R", argv, &c, argc);
                        if(return_value_argcheck_70 == 0)
                        {
                          MaxWriteSpeed=calcint(argv, c, (unsigned long long int)0);
                          if(Verbose >= 5)
                            logdebug("MaxWriteSpeed = %lld\n", MaxWriteSpeed);

                        }

                        else
                        {
                          return_value_argcheck_69=argcheck("-n", argv, &c, argc);
                          if(return_value_argcheck_69 == 0)
                          {
                            signed long int nv;
                            nv=strtol(argv[(signed long int)c], ((char ** restrict )NULL), 0);
                            if(!(nv >= 0l))
                              tmp_if_expr_16 = (_Bool)1;

                            else
                            {
                              if(nv == 0l)
                              {
                                return_value___errno_location_14=__errno_location();
                                tmp_if_expr_15 = *return_value___errno_location_14 == 22 ? (_Bool)1 : (_Bool)0;
                              }

                              else
                                tmp_if_expr_15 = (_Bool)0;
                              tmp_if_expr_16 = tmp_if_expr_15 ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr_16)
                              fatal("invalid argument to option -n: \"%s\"\n", argv[(signed long int)c]);

                            else
                              NumVolumes = nv;
                            if(!(NumVolumes >= 0l))
                              fatal("argument for number of volumes must be > 0\n");

                            if(Verbose >= 5)
                              logdebug("NumVolumes = %d\n", NumVolumes);

                          }

                          else
                          {
                            return_value_argcheck_68=argcheck("-i", argv, &c, argc);
                            if(return_value_argcheck_68 == 0)
                            {
                              signed int return_value_strcmp_17;
                              return_value_strcmp_17=strcmp(argv[(signed long int)c], "-");
                              if(!(return_value_strcmp_17 == 0))
                              {
                                Infile = argv[(signed long int)c];
                                if(Verbose >= 5)
                                  logdebug("Infile = %s\n", Infile);

                              }

                              else
                              {
                                Infile = ((const char *)NULL);
                                if(Verbose >= 5)
                                  logdebug("Infile is stdin\n");

                              }
                            }

                            else
                            {
                              return_value_argcheck_67=argcheck("-o", argv, &c, argc);
                              if(return_value_argcheck_67 == 0)
                              {
                                struct destination *dest;
                                void *return_value_malloc_18;
                                return_value_malloc_18=malloc(sizeof(struct destination) /*56ul*/ );
                                dest = (struct destination *)return_value_malloc_18;
                                signed int return_value_strcmp_20;
                                return_value_strcmp_20=strcmp(argv[(signed long int)c], "-");
                                if(!(return_value_strcmp_20 == 0))
                                {
                                  if(Verbose >= 5)
                                    logdebug("output file: %s\n", argv[(signed long int)c]);

                                  dest->arg = argv[(signed long int)c];
                                  dest->name = argv[(signed long int)c];
                                  dest->fd = -1;
                                  dest->mode = (signed int)((signed long int)(0100 | 01 | optMode | Direct | 0) | OptSync);
                                }

                                else
                                {
                                  tmp_post_19 = numstdout;
                                  numstdout = numstdout + 1;
                                  if(!(tmp_post_19 == 0))
                                    fatal("cannot output multiple times to stdout\n");

                                  if(Verbose >= 5)
                                    logdebug("output to stdout\n", argv[(signed long int)c]);

                                  dest->fd=dup(1);
                                  err=dup2(2, 1);
                                  /* assertion err != -1 */
                                  assert(err != -1);
                                  dest->arg = "<stdout>";
                                  dest->name = "<stdout>";
                                  dest->mode = 0;
                                }
                                optMode = 0200;
                                dest->port = ((const char *)NULL);
                                dest->result = ((const char *)NULL);
                                bzero((void *)&dest->thread, sizeof(unsigned long int) /*8ul*/ );
                                dest->next = Dest;
                                Dest = dest;
                                if(outfile == ((const char *)NULL))
                                  outfile = argv[(signed long int)c];

                                numOut = numOut + 1;
                                NumSenders = NumSenders + 1;
                              }

                              else
                              {
                                return_value_strcmp_66=strcmp("-0", argv[(signed long int)c]);
                                if(return_value_strcmp_66 == 0)
                                  AddrFam = 0;

                                else
                                {
                                  return_value_strcmp_65=strcmp("-4", argv[(signed long int)c]);
                                  if(return_value_strcmp_65 == 0)
                                    AddrFam = 2;

                                  else
                                  {
                                    return_value_strcmp_64=strcmp("-6", argv[(signed long int)c]);
                                    if(return_value_strcmp_64 == 0)
                                      AddrFam = 10;

                                    else
                                    {
                                      return_value_argcheck_63=argcheck("-I", argv, &c, argc);
                                      if(return_value_argcheck_63 == 0)
                                        initNetworkInput(argv[(signed long int)c]);

                                      else
                                      {
                                        return_value_argcheck_62=argcheck("-O", argv, &c, argc);
                                        if(return_value_argcheck_62 == 0)
                                        {
                                          struct destination *main__1__2__1__19__d;
                                          main__1__2__1__19__d=createNetworkOutput(argv[(signed long int)c]);
                                          if(main__1__2__1__19__d->fd == -1)
                                            free((void *)main__1__2__1__19__d);

                                          else
                                          {
                                            main__1__2__1__19__d->next = Dest;
                                            Dest = main__1__2__1__19__d;
                                            NumSenders = NumSenders + 1;
                                          }
                                          numOut = numOut + 1;
                                        }

                                        else
                                        {
                                          return_value_argcheck_61=argcheck("-T", argv, &c, argc);
                                          if(return_value_argcheck_61 == 0)
                                          {
                                            unsigned long int return_value_strlen_21;
                                            return_value_strlen_21=strlen(argv[(signed long int)c]);
                                            void *return_value_malloc_22;
                                            return_value_malloc_22=malloc(return_value_strlen_21 + (unsigned long int)1);
                                            Tmpfile = (char *)return_value_malloc_22;
                                            if(Tmpfile == ((char *)NULL))
                                              fatal("out of memory\n");

                                            strcpy(Tmpfile, argv[(signed long int)c]);
                                            Memmap = 1;
                                            if(Verbose >= 5)
                                              logdebug("Tmpfile = %s\n", Tmpfile);

                                          }

                                          else
                                          {
                                            return_value_strcmp_60=strcmp("-t", argv[(signed long int)c]);
                                            if(return_value_strcmp_60 == 0)
                                            {
                                              Memmap = 1;
                                              if(Verbose >= 5)
                                                logdebug("Memmap = 1\n");

                                            }

                                            else
                                            {
                                              return_value_argcheck_59=argcheck("-l", argv, &c, argc);
                                              if(return_value_argcheck_59 == 0)
                                              {
                                                Log=open(argv[(signed long int)c], 01 | 02000 | 01000 | 0100 | 0, 0666);
                                                if(Log == -1)
                                                {
                                                  Log = 2;
                                                  signed int *return_value___errno_location_23;
                                                  return_value___errno_location_23=__errno_location();
                                                  char *return_value_strerror_24;
                                                  return_value_strerror_24=strerror(*return_value___errno_location_23);
                                                  errormsg("error opening log file: %s\n", return_value_strerror_24);
                                                }

                                                if(Verbose >= 5)
                                                  logdebug("logFile set to %s\n", argv[(signed long int)c]);

                                              }

                                              else
                                              {
                                                return_value_strcmp_58=strcmp("-f", argv[(signed long int)c]);
                                                if(return_value_strcmp_58 == 0)
                                                {
                                                  optMode = optMode & ~0200;
                                                  if(Verbose >= 5)
                                                    logdebug("overwrite = 1\n");

                                                }

                                                else
                                                {
                                                  return_value_strcmp_57=strcmp("-q", argv[(signed long int)c]);
                                                  if(return_value_strcmp_57 == 0)
                                                  {
                                                    if(Verbose >= 5)
                                                      logdebug("disabling display of status\n");

                                                    Quiet = 1;
                                                  }

                                                  else
                                                  {
                                                    return_value_strcmp_56=strcmp("-Q", argv[(signed long int)c]);
                                                    if(return_value_strcmp_56 == 0)
                                                    {
                                                      if(Verbose >= 5)
                                                        logdebug("disabling logging of status\n");

                                                      StatusLog = 0;
                                                    }

                                                    else
                                                    {
                                                      return_value_strcmp_55=strcmp("-c", argv[(signed long int)c]);
                                                      if(return_value_strcmp_55 == 0)
                                                      {
                                                        if(Verbose >= 5)
                                                          logdebug("enabling full synchronous I/O\n");

                                                        OptSync = (signed long int)04010000;
                                                      }

                                                      else
                                                      {
                                                        return_value_strcmp_54=strcmp("-e", argv[(signed long int)c]);
                                                        if(return_value_strcmp_54 == 0)
                                                        {
                                                          if(Verbose >= 5)
                                                            logdebug("will terminate on any kind of error\n");

                                                          ErrorsFatal = 1;
                                                        }

                                                        else
                                                        {
                                                          return_value_argcheck_53=argcheck("-a", argv, &c, argc);
                                                          if(return_value_argcheck_53 == 0)
                                                          {
                                                            signed long int at;
                                                            signed long int return_value_strtol_25;
                                                            return_value_strtol_25=strtol(argv[(signed long int)c], ((char ** restrict )NULL), 0);
                                                            at = return_value_strtol_25 - (signed long int)1;
                                                            if(at == 0l)
                                                            {
                                                              return_value___errno_location_26=__errno_location();
                                                              tmp_if_expr_27 = *return_value___errno_location_26 == 22 ? (_Bool)1 : (_Bool)0;
                                                            }

                                                            else
                                                              tmp_if_expr_27 = (_Bool)0;
                                                            if(tmp_if_expr_27)
                                                              errormsg("invalid argument to option -a: \"%s\"\n", argv[(signed long int)c]);

                                                            else
                                                            {
                                                              Autoloader = 1;
                                                              AutoloadTime = (unsigned int)at;
                                                            }
                                                            if(Verbose >= 5)
                                                              logdebug("Autoloader time = %d\n", AutoloadTime);

                                                          }

                                                          else
                                                          {
                                                            return_value_argcheck_52=argcheck("-A", argv, &c, argc);
                                                            if(return_value_argcheck_52 == 0)
                                                            {
                                                              Autoloader = 1;
                                                              AutoloadCmd = argv[(signed long int)c];
                                                              if(Verbose >= 5)
                                                                logdebug("Autoloader command = \"%s\"\n", AutoloadCmd);

                                                            }

                                                            else
                                                            {
                                                              return_value_argcheck_51=argcheck("-P", argv, &c, argc);
                                                              if(return_value_argcheck_51 == 0)
                                                              {
                                                                signed int return_value_sscanf_28;
                                                                return_value_sscanf_28=sscanf(argv[(signed long int)c], "%lf", &StartWrite);
                                                                if(!(return_value_sscanf_28 == 1))
                                                                  StartWrite = (double)0;

                                                                StartWrite = StartWrite / (double)100;
                                                                if(StartWrite <= 0.000000 || StartWrite > 1.000000)
                                                                  fatal("error in argument -P: must be bigger than 0 and less or equal 100\n");

                                                                if(Verbose >= 5)
                                                                  logdebug("StartWrite = %1.2lf\n", StartWrite);

                                                              }

                                                              else
                                                              {
                                                                return_value_argcheck_50=argcheck("-p", argv, &c, argc);
                                                                if(return_value_argcheck_50 == 0)
                                                                {
                                                                  signed int return_value_sscanf_29;
                                                                  return_value_sscanf_29=sscanf(argv[(signed long int)c], "%lf", &StartRead);
                                                                  if(return_value_sscanf_29 == 1)
                                                                    StartRead = StartRead / (double)100;

                                                                  else
                                                                    StartRead = 1.0;
                                                                  if(StartRead < 0.000000 || StartRead >= 1.000000)
                                                                    fatal("error in argument -p: must be bigger or equal to 0 and less than 100\n");

                                                                  if(Verbose >= 5)
                                                                    logdebug("StartRead = %1.2lf\n", StartRead);

                                                                }

                                                                else
                                                                {
                                                                  return_value_strcmp_49=strcmp("-L", argv[(signed long int)c]);
                                                                  if(return_value_strcmp_49 == 0)
                                                                  {
                                                                    Memlock = 1;
                                                                    if(Verbose >= 5)
                                                                      logdebug("memory locking enabled\n");

                                                                  }

                                                                  else
                                                                  {
                                                                    return_value_argcheck_48=argcheck("-W", argv, &c, argc);
                                                                    if(return_value_argcheck_48 == 0)
                                                                    {
                                                                      signed long int return_value_strtol_30;
                                                                      return_value_strtol_30=strtol(argv[(signed long int)c], ((char ** restrict )NULL), 0);
                                                                      Timeout = (unsigned long int)return_value_strtol_30;
                                                                      if(!(Timeout >= 1ul))
                                                                        fatal("invalid argument to option -W\n");

                                                                      if((unsigned long int)AutoloadTime >= Timeout)
                                                                        fatal("timeout must be bigger than autoload time\n");

                                                                    }

                                                                    else
                                                                    {
                                                                      return_value_strcmp_47=strcmp("--direct", argv[(signed long int)c]);
                                                                      if(return_value_strcmp_47 == 0)
                                                                      {
                                                                        if(Verbose >= 5)
                                                                          logdebug("using O_DIRECT to open file descriptors\n");

                                                                        Direct = 040000;
                                                                      }

                                                                      else
                                                                      {
                                                                        return_value_strcmp_44=strcmp("--help", argv[(signed long int)c]);
                                                                        if(return_value_strcmp_44 == 0)
                                                                          tmp_if_expr_46 = (_Bool)1;

                                                                        else
                                                                        {
                                                                          return_value_strcmp_45=strcmp("-h", argv[(signed long int)c]);
                                                                          tmp_if_expr_46 = !(return_value_strcmp_45 != 0) ? (_Bool)1 : (_Bool)0;
                                                                        }
                                                                        if(tmp_if_expr_46)
                                                                          usage();

                                                                        else
                                                                        {
                                                                          return_value_strcmp_41=strcmp("--version", argv[(signed long int)c]);
                                                                          if(return_value_strcmp_41 == 0)
                                                                            tmp_if_expr_43 = (_Bool)1;

                                                                          else
                                                                          {
                                                                            return_value_strcmp_42=strcmp("-V", argv[(signed long int)c]);
                                                                            tmp_if_expr_43 = !(return_value_strcmp_42 != 0) ? (_Bool)1 : (_Bool)0;
                                                                          }
                                                                          if(tmp_if_expr_43)
                                                                            version();

                                                                          else
                                                                          {
                                                                            return_value_strcmp_38=strcmp("--md5", argv[(signed long int)c]);
                                                                            if(return_value_strcmp_38 == 0)
                                                                              tmp_if_expr_40 = (_Bool)1;

                                                                            else
                                                                            {
                                                                              return_value_strcmp_39=strcmp("-H", argv[(signed long int)c]);
                                                                              tmp_if_expr_40 = !(return_value_strcmp_39 != 0) ? (_Bool)1 : (_Bool)0;
                                                                            }
                                                                            if(tmp_if_expr_40)
                                                                              addHashAlgorithm("MD5");

                                                                            else
                                                                            {
                                                                              return_value_strcmp_37=strcmp("--hash", argv[(signed long int)c]);
                                                                              if(return_value_strcmp_37 == 0)
                                                                              {
                                                                                c = c + 1;
                                                                                if(c == argc)
                                                                                  fatal("missing argument to option --hash\n");

                                                                                signed int return_value_strcmp_33;
                                                                                return_value_strcmp_33=strcmp(argv[(signed long int)c], "list");
                                                                                if(return_value_strcmp_33 == 0)
                                                                                {
                                                                                  fprintf(stderr, "valid hash functions are:\n");
                                                                                  signed int algo;
                                                                                  unsigned int return_value_mhash_count_31;
                                                                                  return_value_mhash_count_31=mhash_count();
                                                                                  algo = (signed int)return_value_mhash_count_31;
                                                                                  while(algo >= 0)
                                                                                  {
                                                                                    const char *algoname;
                                                                                    const unsigned char *return_value_mhash_get_hash_name_static_32;
                                                                                    return_value_mhash_get_hash_name_static_32=mhash_get_hash_name_static((enum __hashid)algo);
                                                                                    algoname = (const char *)return_value_mhash_get_hash_name_static_32;
                                                                                    if(!(algoname == ((const char *)NULL)))
                                                                                      fprintf(stderr, "\t%s\n", algoname);

                                                                                    algo = algo - 1;
                                                                                  }
                                                                                  exit(0);
                                                                                }

                                                                                addHashAlgorithm(argv[(signed long int)c]);
                                                                              }

                                                                              else
                                                                              {
                                                                                return_value_strcmp_36=strcmp("--pid", argv[(signed long int)c]);
                                                                                if(return_value_strcmp_36 == 0)
                                                                                {
                                                                                  signed int return_value_getpid_34;
                                                                                  return_value_getpid_34=getpid();
                                                                                  printmsg("PID is %d\n", return_value_getpid_34);
                                                                                }

                                                                                else
                                                                                {
                                                                                  return_value_argcheck_35=argcheck("-D", argv, &c, argc);
                                                                                  if(return_value_argcheck_35 == 0)
                                                                                  {
                                                                                    OutVolsize=calcint(argv, c, (unsigned long long int)0);
                                                                                    if(Verbose >= 5)
                                                                                      logdebug("OutVolsize = %llu\n", OutVolsize);

                                                                                  }

                                                                                  else
                                                                                    fatal("unknown option \"%s\"\n", argv[(signed long int)c]);
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }

                }
              }
            }
          }
        }
      }
    }
  }
  if((unsigned long int)AutoloadTime >= Timeout && !(AutoloadTime == 0u) && !(Timeout == 0ul))
    fatal("autoload time must be smaller than watchdog timeout\n");

  if(!((optBset & optMset & optSset) == 0))
  {
    if(!(Blocksize * (unsigned long int)Numblocks == Totalmem))
      fatal("inconsistent options: blocksize * number of blocks != totalsize!\n");

  }

  else
    if(!((optMset & optSset & (signed int)(optBset == 0)) == 0) || !((optMset & (signed int)(optBset == 0) & (signed int)(optSset == 0)) == 0))
    {
      if(Blocksize >= Totalmem)
        fatal("total memory must be larger than block size\n");

      Numblocks = (signed long int)(Totalmem / Blocksize);
      infomsg("Numblocks = %llu, Blocksize = %llu, Totalmem = %llu\n", (unsigned long long int)Numblocks, (unsigned long long int)Blocksize, (unsigned long long int)Totalmem);
    }

    else
      if(!((optBset & optMset & (signed int)(optSset == 0)) == 0))
      {
        if(Blocksize == 0ul)
          fatal("blocksize must be greater than 0\n");

        if(Blocksize >= Totalmem)
          fatal("total memory must be larger than block size\n");

        Blocksize = Totalmem / (unsigned long int)Numblocks;
        infomsg("blocksize = %llu\n", (unsigned long long int)Blocksize);
      }

  if(StartRead < 1.000000 && StartWrite > 0.000000)
    fatal("setting both low watermark and high watermark doesn't make any sense...\n");

  if(NumSenders + -Hashers >= 1 && (!(Autoloader == 0) || !(OutVolsize == 0ull)))
    fatal("multi-volume support is unsupported with multiple outputs\n");

  if(!(Autoloader == 0))
  {
    if(Infile == ((const char *)NULL) && outfile == ((const char *)NULL))
      fatal("Setting autoloader time or command without using a device doesn't make any sense!\n");

    if(!(Infile == ((const char *)NULL)) && !(outfile == ((const char *)NULL)))
      fatal("Which one is your autoloader? Input or output? Replace input or output with a pipe.\n");

  }

  if(!(Infile == ((const char *)NULL)) && !(netPortIn == 0))
    fatal("Setting both network input port and input file doesn't make sense!\n");

  if(!(outfile == ((const char *)NULL)) && !(netPortOut == 0))
    fatal("Setting both network output and output file doesn't make sense!\n");

  if(Infile == ((const char *)NULL) && !(NumVolumes == 1l))
    fatal("multi-volume support for input needs an explicitly specified input device (option -i)\n");

  if(outfile == ((const char *)NULL) && !(OutVolsize == 0ull))
    fatal("Setting OutVolsize without an output device doesn't make sense!\n");

  if(!(OutVolsize == 0ul) && !(OutVolsize >= Blocksize))
    fatal("If non-zero, OutVolsize must be at least as large as the buffer blocksize (%llu)!\n", Blocksize);

  mxnrsem=sysconf(33);
  if(mxnrsem == -1l)
  {
    mxnrsem = 0x7fffffffffffffffL;
    warningmsg("unable to determine maximum value of semaphores\n");
  }

  if(!(Numblocks >= 5l))
    fatal("Minimum block count is 5.\n");

  if(!(mxnrsem >= Numblocks))
    fatal("cannot allocate more than %d blocks.\nThis is a system-dependent limit, depending on the maximum semaphore value.\nPlease choose a bigger block size.\n", mxnrsem);

  if(Blocksize * (unsigned long int)Numblocks >= 9223372036854775808ul)
    fatal("Cannot address so much memory (%lld*%d=%lld>%lld).\n", Blocksize, Numblocks, Blocksize * (unsigned long int)(signed long long int)Numblocks, (signed long long int)0x7fffffffffffffffL);

  void *return_value_valloc_81;
  return_value_valloc_81=valloc((unsigned long int)Numblocks * sizeof(char *) /*8ul*/ );
  Buffer = (char **)return_value_valloc_81;
  signed int *return_value___errno_location_82;
  char *return_value_strerror_83;
  if(Buffer == ((char **)NULL))
  {
    return_value___errno_location_82=__errno_location();
    return_value_strerror_83=strerror(*return_value___errno_location_82);
    fatal("Could not allocate enough memory (%d requested): %s\n", (unsigned long int)Numblocks * sizeof(char *) /*8ul*/ , return_value_strerror_83);
  }

  char *tmp_if_expr_86;
  char *return_value_getenv_85;
  signed int *return_value___errno_location_91;
  char *return_value_strerror_92;
  signed int *return_value___errno_location_95;
  char *return_value_strerror_96;
  signed int *return_value___errno_location_98;
  char *return_value_strerror_99;
  signed int *return_value___errno_location_101;
  char *return_value_strerror_102;
  signed int *return_value___errno_location_105;
  char *return_value_strerror_106;
  signed int *return_value___errno_location_108;
  char *return_value_strerror_109;
  signed int *return_value___errno_location_110;
  char *return_value_strerror_111;
  if(!(Memmap == 0))
  {
    infomsg("mapping temporary file to memory with %llu blocks with %llu byte (%llu kB total)...\n", (unsigned long long int)Numblocks, (unsigned long long int)Blocksize, (unsigned long long int)((unsigned long int)Numblocks * Blocksize >> 10));
    if(Tmpfile == ((char *)NULL))
    {
      char tmplname[15l] = { 'm', 'b', 'u', 'f', 'f', 'e', 'r', '-', 'X', 'X', 'X', 'X', 'X', 'X', 0 };
      char *tmpdir;
      char *return_value_getenv_84;
      return_value_getenv_84=getenv("TMPDIR");
      if(!(return_value_getenv_84 == ((char *)NULL)))
      {
        return_value_getenv_85=getenv("TMPDIR");
        tmp_if_expr_86 = return_value_getenv_85;
      }

      else
        tmp_if_expr_86 = "/var/tmp";
      tmpdir = tmp_if_expr_86;
      signed long int tmpdir_array_size0;
      unsigned long int return_value_strlen_87;
      return_value_strlen_87=strlen(tmpdir);
      tmpdir_array_size0 = (signed long int)(sizeof(char [15l]) /*15ul*/  + return_value_strlen_87 + (unsigned long int)1);
      char tfilename[tmpdir_array_size0];
      strcpy(tfilename, tmpdir);
      strcat(tfilename, "/");
      strcat(tfilename, tmplname);
      signed int return_value_mkstemp_88;
      return_value_mkstemp_88=mkstemp(tfilename);
      Tmp = (signed long int)return_value_mkstemp_88;
      unsigned long int return_value_strlen_89;
      return_value_strlen_89=strlen(tfilename);
      void *return_value_malloc_90;
      return_value_malloc_90=malloc(return_value_strlen_89);
      Tmpfile = (char *)return_value_malloc_90;
      if(Tmpfile == ((char *)NULL))
      {
        return_value___errno_location_91=__errno_location();
        return_value_strerror_92=strerror(*return_value___errno_location_91);
        fatal("out of memory: %s\n", return_value_strerror_92);
      }

      strcpy(Tmpfile, tfilename);
      infomsg("tmpfile is %s\n", Tmpfile);
    }

    else
    {
      unsigned int mode = (unsigned int)(02 | 0);
      signed int return_value_strncmp_93;
      return_value_strncmp_93=strncmp(Tmpfile, "/dev/", (unsigned long int)5);
      if(!(return_value_strncmp_93 == 0))
        mode = mode | (unsigned int)(0100 | 0200);

      signed int return_value_open_94;
      return_value_open_94=open(Tmpfile, (signed int)mode, 0600);
      Tmp = (signed long int)return_value_open_94;
    }
    if(Tmp == -1l)
    {
      return_value___errno_location_95=__errno_location();
      return_value_strerror_96=strerror(*return_value___errno_location_95);
      fatal("could not create temporary file (%s): %s\n", Tmpfile, return_value_strerror_96);
    }

    signed int return_value_strncmp_97;
    return_value_strncmp_97=strncmp(Tmpfile, "/dev/", (unsigned long int)5);
    if(!(return_value_strncmp_97 == 0))
      unlink(Tmpfile);

    signed long int return_value_lseek_100;
    return_value_lseek_100=lseek((signed int)Tmp, (signed long int)((unsigned long int)Numblocks * Blocksize - sizeof(signed int) /*4ul*/ ), 0);
    if(return_value_lseek_100 == -1l)
    {
      return_value___errno_location_98=__errno_location();
      return_value_strerror_99=strerror(*return_value___errno_location_98);
      fatal("could not resize temporary file: %s\n", return_value_strerror_99);
    }

    signed long int return_value_write_103;
    return_value_write_103=write((signed int)Tmp, (const void *)&c, sizeof(signed int) /*4ul*/ );
    if(return_value_write_103 == -1l)
    {
      return_value___errno_location_101=__errno_location();
      return_value_strerror_102=strerror(*return_value___errno_location_101);
      fatal("could not resize temporary file: %s\n", return_value_strerror_102);
    }

    void *return_value_mmap_104;
    return_value_mmap_104=mmap(NULL, Blocksize * (unsigned long int)Numblocks, 0x1 | 0x2, 0x01, (signed int)Tmp, (signed long int)0);
    Buffer[(signed long int)0] = (char *)return_value_mmap_104;
    if((char *)-1 == *Buffer)
    {
      return_value___errno_location_105=__errno_location();
      return_value_strerror_106=strerror(*return_value___errno_location_105);
      fatal("could not map buffer-file to memory: %s\n", return_value_strerror_106);
    }

    if(Verbose >= 5)
      logdebug("temporary file mapped to address %p\n", Buffer[(signed long int)0]);

  }

  else
  {
    infomsg("allocating memory for %d blocks with %llu byte (%llu kB total)...\n", Numblocks, (unsigned long long int)Blocksize, (unsigned long long int)((unsigned long int)Numblocks * Blocksize >> 10));
    void *return_value_valloc_107;
    return_value_valloc_107=valloc(Blocksize * (unsigned long int)Numblocks);
    Buffer[(signed long int)0] = (char *)return_value_valloc_107;
    if(*Buffer == ((char *)NULL))
    {
      return_value___errno_location_108=__errno_location();
      return_value_strerror_109=strerror(*return_value___errno_location_108);
      fatal("Could not allocate enough memory (%lld requested): %s\n", (unsigned long long int)Blocksize * (unsigned long int)Numblocks, return_value_strerror_109);
    }

    signed int return_value_madvise_112;
    return_value_madvise_112=madvise((void *)Buffer[(signed long int)0], Blocksize * (unsigned long int)Numblocks, 10);
    if(return_value_madvise_112 == -1)
    {
      return_value___errno_location_110=__errno_location();
      return_value_strerror_111=strerror(*return_value___errno_location_110);
      warningmsg("unable to advise memory handling of buffer: %s\n", return_value_strerror_111);
    }

  }
  c = 1;
  for( ; !((signed long int)c >= Numblocks); c = c + 1)
  {
    Buffer[(signed long int)c] = Buffer[(signed long int)0] + (signed long int)(Blocksize * (unsigned long int)c);
    *Buffer[(signed long int)c] = (char)0;
  }
  signed int return_value_mlock_115;
  _Bool tmp_if_expr_117;
  signed int return_value_mlock_116;
  signed int *return_value___errno_location_113;
  char *return_value_strerror_114;
  if(!(Memlock == 0))
  {
    unsigned int uid;
    uid=geteuid();
    signed int return_value_seteuid_118;
    return_value_seteuid_118=seteuid((unsigned int)0);
    if(!(return_value_seteuid_118 == 0))
      warningmsg("could not change to uid 0 to lock memory (is mbuffer setuid root?)\n");

    else
    {
      return_value_mlock_115=mlock((const void *)(char *)Buffer, (unsigned long int)Numblocks * sizeof(char *) /*8ul*/ );
      if(!(return_value_mlock_115 == 0))
        tmp_if_expr_117 = (_Bool)1;

      else
      {
        return_value_mlock_116=mlock((const void *)Buffer[(signed long int)0], Blocksize * (unsigned long int)Numblocks);
        tmp_if_expr_117 = 0 != return_value_mlock_116 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_117)
      {
        return_value___errno_location_113=__errno_location();
        return_value_strerror_114=strerror(*return_value___errno_location_113);
        warningmsg("could not lock buffer in memory: %s\n", return_value_strerror_114);
      }

      else
        infomsg("memory locked successfully\n");
    }
    err=seteuid(uid);
    /* assertion err == 0 */
    assert(err == 0);
  }

  if(Verbose >= 5)
    logdebug("creating semaphores...\n");

  signed int return_value_sem_init_121;
  return_value_sem_init_121=sem_init(&Buf2Dev, 0, (unsigned int)0);
  signed int *return_value___errno_location_119;
  char *return_value_strerror_120;
  if(!(return_value_sem_init_121 == 0))
  {
    return_value___errno_location_119=__errno_location();
    return_value_strerror_120=strerror(*return_value___errno_location_119);
    fatal("Error creating semaphore Buf2Dev: %s\n", return_value_strerror_120);
  }

  signed int return_value_sem_init_124;
  return_value_sem_init_124=sem_init(&Dev2Buf, 0, (unsigned int)Numblocks);
  signed int *return_value___errno_location_122;
  char *return_value_strerror_123;
  if(!(return_value_sem_init_124 == 0))
  {
    return_value___errno_location_122=__errno_location();
    return_value_strerror_123=strerror(*return_value___errno_location_122);
    fatal("Error creating semaphore Dev2Buf: %s\n", return_value_strerror_123);
  }

  if(Verbose >= 5)
    logdebug("opening input...\n");

  signed int *return_value___errno_location_126;
  char *return_value_strerror_127;
  if(!(Infile == ((const char *)NULL)))
  {
    signed int flags = 00 | 0 | Direct;
    In=open(Infile, flags);
    if(In == -1)
    {
      signed int *return_value___errno_location_125;
      return_value___errno_location_125=__errno_location();
      if(*return_value___errno_location_125 == 22)
      {
        flags = flags & ~0;
        In=open(Infile, flags);
      }

      if(In == -1)
      {
        return_value___errno_location_126=__errno_location();
        return_value_strerror_127=strerror(*return_value___errno_location_126);
        fatal("could not open input file: %s\n", return_value_strerror_127);
      }

    }

  }

  else
    if(In == -1)
      In = 0;

  if(numOut == 0)
  {
    struct destination *d;
    void *return_value_malloc_128;
    return_value_malloc_128=malloc(sizeof(struct destination) /*56ul*/ );
    d = (struct destination *)return_value_malloc_128;
    d->fd=dup(1);
    err=dup2(2, 1);
    /* assertion err != -1 */
    assert(err != -1);
    d->name = "<stdout>";
    d->arg = "<stdout>";
    d->port = ((const char *)NULL);
    d->result = ((const char *)NULL);
    bzero((void *)&d->thread, sizeof(unsigned long int) /*8ul*/ );
    d->next = Dest;
    Dest = d;
    NumSenders = NumSenders + 1;
  }

  openDestinationFiles(Dest);
  if(NumSenders == -1)
    fatal("no output left - nothing to do\n");

  if(Verbose >= 5)
    logdebug("checking if we have a controlling terminal...\n");

  sig.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  sigemptyset(&sig.sa_mask);
  sig.sa_flags = 0;
  err=sigaction(21, &sig, ((struct sigaction *)NULL));
  /* assertion err == 0 */
  assert(err == 0);
  fl=fcntl(2, 3);
  err=fcntl(2, 4, fl | 04000);
  /* assertion err == 0 */
  assert(err == 0);
  signed long int return_value_read_130;
  return_value_read_130=read(2, (void *)&c, (unsigned long int)1);
  signed int *return_value___errno_location_129;
  if(return_value_read_130 == -1l)
  {
    return_value___errno_location_129=__errno_location();
    if(!(*return_value___errno_location_129 == 11))
    {
      signed int tty;
      tty=open("/dev/tty", 02);
      if(tty == -1)
      {
        Terminal = 0;
        if(Autoloader == 0 && !(outfile == ((const char *)NULL)))
          warningmsg("No controlling terminal and no autoloader command specified.\n");

      }

      else
      {
        Terminal = 1;
        err=dup2(tty, 2);
        /* assertion err != -1 */
        assert(err != -1);
      }
    }

  }

  err=fcntl(2, 4, fl);
  /* assertion err == 0 */
  assert(err == 0);
  signed int *return_value___errno_location_133;
  char *return_value_strerror_134;
  if(Terminal == 1 && !(NumVolumes == 1l))
  {
    struct termios tset;
    signed int return_value_tcgetattr_136;
    return_value_tcgetattr_136=tcgetattr(2, &tset);
    if(return_value_tcgetattr_136 == -1)
    {
      signed int *return_value___errno_location_131;
      return_value___errno_location_131=__errno_location();
      char *return_value_strerror_132;
      return_value_strerror_132=strerror(*return_value___errno_location_131);
      warningmsg("unable to get terminal attributes: %s\n", return_value_strerror_132);
    }

    else
    {
      tset.c_lflag = tset.c_lflag & (unsigned int)(~0000002 & ~0000010);
      tset.c_cc[(signed long int)5] = (unsigned char)0;
      tset.c_cc[(signed long int)6] = (unsigned char)1;
      signed int return_value_tcsetattr_135;
      return_value_tcsetattr_135=tcsetattr(2, 0, &tset);
      if(return_value_tcsetattr_135 == -1)
      {
        return_value___errno_location_133=__errno_location();
        return_value_strerror_134=strerror(*return_value___errno_location_133);
        warningmsg("unable to set terminal attributes: %s\n", return_value_strerror_134);
      }

    }
  }

  if(Verbose >= 5)
    logdebug("registering signals...\n");

  sig.__sigaction_handler.sa_handler = sigHandler;
  err=sigemptyset(&sig.sa_mask);
  /* assertion err == 0 */
  assert(err == 0);
  err=sigaddset(&sig.sa_mask, 2);
  /* assertion err == 0 */
  assert(err == 0);
  sig.sa_flags = 0x10000000;
  signed int return_value_sigaction_139;
  return_value_sigaction_139=sigaction(2, &sig, ((struct sigaction *)NULL));
  signed int *return_value___errno_location_137;
  char *return_value_strerror_138;
  if(!(return_value_sigaction_139 == 0))
  {
    return_value___errno_location_137=__errno_location();
    return_value_strerror_138=strerror(*return_value___errno_location_137);
    warningmsg("error registering new SIGINT handler: %s\n", return_value_strerror_138);
  }

  err=sigemptyset(&sig.sa_mask);
  /* assertion err == 0 */
  assert(err == 0);
  err=sigaddset(&sig.sa_mask, 1);
  /* assertion err == 0 */
  assert(err == 0);
  signed int return_value_sigaction_142;
  return_value_sigaction_142=sigaction(1, &sig, ((struct sigaction *)NULL));
  signed int *return_value___errno_location_140;
  char *return_value_strerror_141;
  if(!(return_value_sigaction_142 == 0))
  {
    return_value___errno_location_140=__errno_location();
    return_value_strerror_141=strerror(*return_value___errno_location_140);
    warningmsg("error registering new SIGHUP handler: %s\n", return_value_strerror_141);
  }

  if(Verbose >= 5)
    logdebug("starting threads...\n");

  gettimeofday(&Starttime, ((struct timezone *)NULL));
  err=sigfillset(&signalSet);
  /* assertion 0 == err */
  assert(0 == err);
  pthread_sigmask(0, &signalSet, (struct anonymous *)(void *)0);
  main__1__dest = Dest;
  for( ; main__1__dest->fd == -1; main__1__dest = main__1__dest->next)
  {
    main__1__dest->name = ((const char *)NULL);
    if(Verbose >= 5)
      logdebug("skipping destination %s\n", main__1__dest->arg);

    /* assertion dest->next */
    assert(main__1__dest->next != ((struct destination *)NULL));
  }
  if(Verbose >= 5)
    logdebug("checking output device...\n");

  signed int return_value_fstat_145;
  return_value_fstat_145=fstat(main__1__dest->fd, &st);
  signed int *return_value___errno_location_143;
  char *return_value_strerror_144;
  if(return_value_fstat_145 == -1)
  {
    return_value___errno_location_143=__errno_location();
    return_value_strerror_144=strerror(*return_value___errno_location_143);
    errormsg("could not stat output: %s\n", return_value_strerror_144);
  }

  else
    if((61440u & st.st_mode) == 8192u || (61440u & st.st_mode) == 24576u)
    {
      infomsg("blocksize is %d bytes on output device\n", st.st_blksize);
      if(!(Blocksize % (unsigned long int)st.st_blksize == 0ul))
      {
        warningmsg("Blocksize should be a multiple of the blocksize of the output device!\nThis can cause problems with some device/OS combinations...\nBlocksize on output device is %d (transfer block size is %lld)\n", st.st_blksize, Blocksize);
        if(!(SetOutsize == 0))
          fatal("unable to set output blocksize\n");

      }

      else
        if(!(SetOutsize == 0))
        {
          infomsg("setting output blocksize to %d\n", st.st_blksize);
          Outsize = (unsigned long int)st.st_blksize;
        }

    }

    else
      infomsg("no device on output stream\n");
  if(Verbose >= 5)
    logdebug("checking input device...\n");

  signed int return_value_fstat_148;
  return_value_fstat_148=fstat(In, &st);
  signed int *return_value___errno_location_146;
  char *return_value_strerror_147;
  if(return_value_fstat_148 == -1)
  {
    return_value___errno_location_146=__errno_location();
    return_value_strerror_147=strerror(*return_value___errno_location_146);
    warningmsg("could not stat input: %s\n", return_value_strerror_147);
  }

  else
    if((61440u & st.st_mode) == 8192u || (61440u & st.st_mode) == 24576u)
    {
      infomsg("blocksize is %d bytes on input device\n", st.st_blksize);
      if(!(Blocksize % (unsigned long int)st.st_blksize == 0ul))
        warningmsg("Blocksize should be a multiple of the blocksize of the input device!\nUse option -s to adjust transfer block size if you get an out-of-memory error on input.\nBlocksize on input device is %d (transfer block size is %lld)\n", st.st_blksize, Blocksize);

    }

    else
      infomsg("no device on input stream\n");
  if(!(Quiet == 0) && (StatusLog == 0 || !(Verbose >= 4)))
    Status = 0;

  signed int *return_value___errno_location_149;
  char *return_value_strerror_150;
  if(!(Status == 0))
  {
    signed int return_value_pipe_151;
    return_value_pipe_151=pipe(TermQ);
    if(return_value_pipe_151 == -1)
    {
      return_value___errno_location_149=__errno_location();
      return_value_strerror_150=strerror(*return_value___errno_location_149);
      fatal("could not create termination pipe: %s\n", return_value_strerror_150);
    }

  }

  else
  {
    TermQ[(signed long int)0] = -1;
    TermQ[(signed long int)1] = -1;
  }
  err=pthread_create(&main__1__dest->thread, ((const union pthread_attr_t *)NULL), outputThread, (void *)main__1__dest);
  /* assertion 0 == err */
  assert(0 == err);
  if(!(Timeout == 0ul))
  {
    err=pthread_create(&Watchdog, ((const union pthread_attr_t *)NULL), watchdogThread, (void *)0);
    /* assertion 0 == err */
    assert(0 == err);
  }

  signed int *return_value___errno_location_152;
  char *return_value_strerror_153;
  if(!(Status == 0))
  {
    err=pthread_create(&Reader, ((const union pthread_attr_t *)NULL), inputThread, NULL);
    /* assertion 0 == err */
    assert(0 == err);
    pthread_sigmask(1, &signalSet, (struct anonymous *)(void *)0);
    statusThread();
    err=pthread_join(Reader, ((void **)NULL));
    if(!(err == 0))
    {
      return_value___errno_location_152=__errno_location();
      return_value_strerror_153=strerror(*return_value___errno_location_152);
      errormsg("error joining reader: %s\n", return_value_strerror_153);
    }

  }

  else
  {
    pthread_sigmask(1, &signalSet, (struct anonymous *)(void *)0);
    inputThread(NULL);
    if(Verbose >= 5)
      logdebug("waiting for output to finish...\n");

    if(!(TermQ[0l] == -1))
    {
      signed long int return_value_read_154;
      return_value_read_154=read(TermQ[(signed long int)0], (void *)&null, (unsigned long int)1);
      err = (signed int)return_value_read_154;
      /* assertion err == 1 */
      assert(err == 1);
    }

  }
  signed int *return_value___errno_location_155;
  char *return_value_strerror_156;
  if(!(Dest == ((struct destination *)NULL)))
  {
    struct destination *main__1__27__d = Dest;
    signed int ret;
    infomsg("waiting for senders...\n");
    if(!(Terminate == 0))
      cancelAll();

    while((_Bool)1)
    {
      if(!(main__1__27__d->name == ((const char *)NULL)))
      {
        void *status;
        if(!(main__1__27__d->arg == ((const char *)NULL)))
        {
          if(Verbose >= 5)
            logdebug("joining sender for %s\n", main__1__27__d->arg);

        }

        else
          if(Verbose >= 5)
            logdebug("joining hasher for %s\n", main__1__27__d->name);

        ret=pthread_join(main__1__27__d->thread, &status);
        if(!(ret == 0))
        {
          return_value___errno_location_155=__errno_location();
          return_value_strerror_156=strerror(*return_value___errno_location_155);
          errormsg("error joining %s: %s\n", main__1__27__d->arg, main__1__27__d->name, return_value_strerror_156);
        }

        if(status == NULL)
          numthreads = numthreads + 1;

      }

      main__1__27__d = main__1__27__d->next;
      if(main__1__27__d == ((struct destination *)NULL))
        break;

    }
  }

  if(!(Log == 2) || !(Status == 0))
    summary(Numout * Blocksize + Rest, numthreads);

  if(!(Memmap == 0))
  {
    signed int main__1__28__ret;
    main__1__28__ret=munmap((void *)Buffer[(signed long int)0], Blocksize * (unsigned long int)Numblocks);
    /* assertion ret == 0 */
    assert(main__1__28__ret == 0);
  }

  if(!(Tmp == -1l))
    close((signed int)Tmp);

  unsigned long int return_value_strlen_158;
  if(!(Dest == ((struct destination *)NULL)))
  {
    struct destination *main__1__29__d = Dest;
    do
    {
      struct destination *n = main__1__29__d->next;
      if(!(main__1__29__d->result == ((const char *)NULL)))
      {
        if(!(main__1__29__d->arg == ((const char *)NULL)))
          warningmsg("error during output to %s: %s\n", main__1__29__d->arg, main__1__29__d->result);

        else
        {
          unsigned long int return_value_strlen_157;
          return_value_strlen_157=strlen(main__1__29__d->result);
          write(2, (const void *)main__1__29__d->result, return_value_strlen_157);
          if(!(Log == 2))
          {
            return_value_strlen_158=strlen(main__1__29__d->result);
            write(Log, (const void *)main__1__29__d->result, return_value_strlen_158);
          }

        }
      }

      free((void *)main__1__29__d);
      main__1__29__d = n;
    }
    while(!(main__1__29__d == ((struct destination *)NULL)));
  }

  if(!(ErrorOccurred == 0))
    exit(1);

  exit(0);
}

// mt_usleep
// file mbuffer.c line 333
static signed int mt_usleep(unsigned long int sleep_usecs)
{
  struct timespec tv;
  tv.tv_sec = (signed long int)(sleep_usecs / (unsigned long int)1000000);
  tv.tv_nsec = (signed long int)((sleep_usecs % (unsigned long int)1000000) * (unsigned long int)1000);
  signed int *return_value___errno_location_1;
  do
  {
    signed int return_value_nanosleep_2;
    return_value_nanosleep_2=nanosleep(&tv, &tv);
    if(return_value_nanosleep_2 == 0)
      return 0;

    return_value___errno_location_1=__errno_location();
  }
  while(*return_value___errno_location_1 == 4);
  return -1;
}

// openDestinationFiles
// file mbuffer.c line 1556
static void openDestinationFiles(struct destination *d)
{
  unsigned int errs = (unsigned int)ErrorOccurred;
  signed int *return_value___errno_location_2;
  signed int *return_value___errno_location_3;
  for( ; !(d == ((struct destination *)NULL)); d = d->next)
  {
    if(d->fd == -1)
    {
      signed int return_value_strncmp_1;
      return_value_strncmp_1=strncmp(d->arg, "/dev/", (unsigned long int)5);
      if(return_value_strncmp_1 == 0)
        d->mode = d->mode & ~0200;

      d->fd=open(d->arg, d->mode, 0666);
      if(d->fd == -1)
      {
        return_value___errno_location_2=__errno_location();
        if(*return_value___errno_location_2 == 22)
        {
          d->mode = d->mode & ~0;
          d->fd=open(d->arg, d->mode, 0666);
        }

      }

      if(d->fd == -1)
      {
        return_value___errno_location_3=__errno_location();
        if(*return_value___errno_location_3 == 22)
        {
          d->mode = d->mode & ~01000;
          d->fd=open(d->arg, d->mode, 0666);
        }

      }

      if(d->fd == -1)
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        d->result=strerror(*return_value___errno_location_4);
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        char *return_value_strerror_6;
        return_value_strerror_6=strerror(*return_value___errno_location_5);
        errormsg("unable to open output %s: %s\n", d->arg, return_value_strerror_6);
      }

      else
        if(Verbose >= 5)
          logdebug("successfully opened destination file %s with fd %d\n", d->arg, d->fd);

    }

    if(d->fd == -1)
    {
      d->name = ((const char *)NULL);
      NumSenders = NumSenders - 1;
    }

  }
  if(!((unsigned int)ErrorOccurred == errs))
    fatal("unable to open all outputs\n");

}

// outputThread
// file mbuffer.c line 1150
static void * outputThread(void *arg)
{
  struct destination *dest = (struct destination *)arg;
  unsigned int at = (unsigned int)0;
  signed int fill = 0;
  signed int haderror = 0;
  signed int out;
  signed int multipleSenders;
  const double startwrite = StartWrite;
  const double startread = StartRead;
  unsigned long long int blocksize = Blocksize;
  signed long long int xfer = (signed long long int)0;
  struct timespec last;
  /* assertion NumSenders >= 0 */
  assert(NumSenders >= 0);
  if(!(dest->next == ((struct destination *)NULL)))
  {
    signed int ret;
    struct destination *d = dest->next;
    if(Verbose >= 5)
      logdebug("NumSenders = %d\n", NumSenders);

    ActSenders = NumSenders + 1;
    ret=pthread_mutex_init(&SendMut, ((const union anonymous_15 *)NULL));
    /* assertion ret == 0 */
    assert(ret == 0);
    ret=pthread_cond_init(&SendCond, ((const union anonymous_15 *)NULL));
    /* assertion ret == 0 */
    assert(ret == 0);
    while((_Bool)1)
    {
      if(d->arg == ((const char *)NULL))
      {
        if(Verbose >= 5)
          logdebug("creating hash thread with algorithm %s\n", d->name);

        ret=pthread_create(&d->thread, ((const union pthread_attr_t *)NULL), hashThread, (void *)d);
        /* assertion ret == 0 */
        assert(ret == 0);
      }

      else
        if(!(d->fd == -1))
        {
          if(Verbose >= 5)
            logdebug("creating sender for %s\n", d->arg);

          ret=pthread_create(&d->thread, ((const union pthread_attr_t *)NULL), senderThread, (void *)d);
          /* assertion ret == 0 */
          assert(ret == 0);
        }

        else
        {
          if(Verbose >= 5)
            logdebug("outputThread: ignoring destination %s\n", d->arg);

          d->name = ((const char *)NULL);
        }
      d = d->next;
      if(d == ((struct destination *)NULL))
        break;

    }
  }

  multipleSenders = (signed int)(NumSenders > 0);
  dest->result = ((const char *)NULL);
  out = dest->fd;
  if(startwrite > 0.000000)
  {
    signed int err;
    err=pthread_mutex_lock(&HighMut);
    /* assertion err == 0 */
    assert(err == 0);
    if(Verbose >= 5)
      logdebug("outputThread: delaying start until buffer reaches high watermark\n");

    do
    {
      struct anonymous_3 __cancel_buf;
      void (*__cancel_routine)(void *) = releaseLock;
      void *__cancel_arg = (void *)&HighMut;
      signed int __not_first_call;
      __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
      if(!((signed long int)__not_first_call == 0l))
      {
        __cancel_routine(__cancel_arg);
        __pthread_unwind_next(&__cancel_buf);
      }

      __pthread_register_cancel(&__cancel_buf);
      do
      {
        err=pthread_cond_wait(&PercHigh, &HighMut);
        /* assertion err == 0 */
        assert(err == 0);

      __CPROVER_DUMP_L13:
        ;
      }
      while((_Bool)0);
      __pthread_unregister_cancel(&__cancel_buf);
    }
    while((_Bool)0);
    if(Verbose >= 5)
      logdebug("outputThread: high watermark reached, starting...\n");

    err=pthread_mutex_unlock(&HighMut);
    /* assertion err == 0 */
    assert(err == 0);
  }

  else
    infomsg("outputThread: starting output on %s...\n", dest->arg);
  clock_gettime(ClockSrc, &last);
  _Bool tmp_if_expr_6;
  signed int *return_value___errno_location_3;
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_4;
  do
  {
    unsigned long long int rest = blocksize;
    signed int outputThread__1__3__1__err;
    if(startwrite > 0.000000 && !(fill >= 1))
    {
      /* assertion fill == 0 */
      assert(fill == 0);
      outputThread__1__3__1__err=pthread_mutex_lock(&HighMut);
      /* assertion err == 0 */
      assert(outputThread__1__3__1__err == 0);
      outputThread__1__3__1__err=sem_getvalue(&Buf2Dev, &fill);
      /* assertion err == 0 */
      assert(outputThread__1__3__1__err == 0);
      if(fill == 0)
      {
        if(Verbose >= 5)
          logdebug("outputThread: buffer empty, waiting for it to fill\n");

        do
        {
          struct anonymous_3 outputThread__1__3__1__1__1__1____cancel_buf;
          void (*outputThread__1__3__1__1__1__1____cancel_routine)(void *) = releaseLock;
          void *outputThread__1__3__1__1__1__1____cancel_arg = (void *)&HighMut;
          signed int outputThread__1__3__1__1__1__1____not_first_call;
          outputThread__1__3__1__1__1__1____not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)outputThread__1__3__1__1__1__1____cancel_buf.__cancel_jmp_buf, 0);
          if(!((signed long int)outputThread__1__3__1__1__1__1____not_first_call == 0l))
          {
            outputThread__1__3__1__1__1__1____cancel_routine(outputThread__1__3__1__1__1__1____cancel_arg);
            __pthread_unwind_next(&outputThread__1__3__1__1__1__1____cancel_buf);
          }

          __pthread_register_cancel(&outputThread__1__3__1__1__1__1____cancel_buf);
          do
          {
            outputThread__1__3__1__err=pthread_cond_wait(&PercHigh, &HighMut);
            /* assertion err == 0 */
            assert(outputThread__1__3__1__err == 0);

          __CPROVER_DUMP_L22:
            ;
          }
          while((_Bool)0);
          __pthread_unregister_cancel(&outputThread__1__3__1__1__1__1____cancel_buf);
        }
        while((_Bool)0);
        EmptyCount = EmptyCount + 1;
        if(Verbose >= 5)
          logdebug("outputThread: high watermark reached, continuing...\n");

        clock_gettime(ClockSrc, &last);
      }

      outputThread__1__3__1__err=pthread_mutex_unlock(&HighMut);
      /* assertion err == 0 */
      assert(outputThread__1__3__1__err == 0);
    }

    else
      fill = fill - 1;
    outputThread__1__3__1__err=sem_wait(&Buf2Dev);
    /* assertion err == 0 */
    assert(outputThread__1__3__1__err == 0);
    if(!(Terminate == 0))
    {
      infomsg("outputThread: terminating upon termination request...\n");
      dest->result = "canceled";
      terminateOutputThread(dest, 1);
    }

    if(Finish == (signed long int)at)
    {
      outputThread__1__3__1__err=sem_getvalue(&Buf2Dev, &fill);
      /* assertion err == 0 */
      assert(outputThread__1__3__1__err == 0);
      if(fill == 0 && Rest == 0ul)
      {
        if(!(multipleSenders == 0))
          syncSenders((char *)0xdeadbeef, 0);

        infomsg("outputThread: finished - exiting...\n");
        terminateOutputThread(dest, haderror);
      }

      else
      {
        rest = Rest;
        blocksize = rest;
        if(Verbose >= 5)
          logdebug("outputThread: last block has %llu bytes\n", (unsigned long long int)Rest);

      }
    }

    if(!(multipleSenders == 0))
      syncSenders(Buffer[(signed long int)at], (signed int)blocksize);

    if(Numout % (OutVolsize / Blocksize) == 0ul && Numout >= 1ul && !(OutVolsize == 0ul))
    {
      mt_usleep((unsigned long int)500000);
      out=requestOutputVolume(out, dest->name);
      if(out == -1)
      {
        haderror = 1;
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        dest->result=strerror(*return_value___errno_location_1);
      }

    }

    do
    {
      unsigned long long int n = rest > Outsize ? Outsize : rest;
      signed int num;
      if(!(haderror == 0))
      {
        if(NumSenders == 0)
          Terminate = 1;

        num = (signed int)rest;
      }

      else
      {
        signed long int return_value_write_2;
        return_value_write_2=write(out, (const void *)((Buffer[(signed long int)at] + (signed long int)blocksize) - (signed long int)rest), n);
        num = (signed int)return_value_write_2;
        if(Verbose >= 6)
          logdebug("outputThread: writing %lld@0x%p: ret = %d\n", n, (Buffer[(signed long int)at] + (signed long int)blocksize) - (signed long int)rest, num);

      }
      if(!(Autoloader == 0) || !(Terminal == 0))
      {
        if(num == -1)
        {
          return_value___errno_location_3=__errno_location();
          if(*return_value___errno_location_3 == 12)
            tmp_if_expr_5 = (_Bool)1;

          else
          {
            return_value___errno_location_4=__errno_location();
            tmp_if_expr_5 = *return_value___errno_location_4 == 28 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_6 = (_Bool)0;
        if(num == 0 || tmp_if_expr_6)
        {
          out=requestOutputVolume(out, dest->name);
          if(out == -1)
            haderror = 1;

          continue;
        }

      }

      else
        if(num == -1)
        {
          signed int *return_value___errno_location_7;
          return_value___errno_location_7=__errno_location();
          dest->result=strerror(*return_value___errno_location_7);
          signed int *return_value___errno_location_8;
          return_value___errno_location_8=__errno_location();
          char *return_value_strerror_9;
          return_value_strerror_9=strerror(*return_value___errno_location_8);
          errormsg("outputThread: error writing to %s at offset 0x%llx: %s\n", dest->arg, ((unsigned long int)(signed long long int)Blocksize * Numout + blocksize) - rest, return_value_strerror_9);
          MainOutOK = 0;
          if(NumSenders == 0)
          {
            if(Verbose >= 5)
              logdebug("outputThread: terminating...\n");

            Terminate = 1;
            outputThread__1__3__1__err=sem_post(&Dev2Buf);
            /* assertion err == 0 */
            assert(outputThread__1__3__1__err == 0);
            terminateOutputThread(dest, 1);
          }

          if(Verbose >= 5)
            logdebug("outputThread: %d senders remaining - continuing...\n", NumSenders);

          haderror = 1;
        }

      rest = rest - (unsigned long long int)num;
    }
    while(rest >= 1ul);
    if(multipleSenders == 0)
    {
      outputThread__1__3__1__err=sem_post(&Dev2Buf);
      /* assertion err == 0 */
      assert(outputThread__1__3__1__err == 0);
    }

    if(!(MaxWriteSpeed == 0ull))
      xfer=enforceSpeedLimit(MaxWriteSpeed, xfer, &last);

    if(!(Pause == 0ul))
      mt_usleep(Pause);

    if(Finish == (signed long int)at)
    {
      outputThread__1__3__1__err=sem_getvalue(&Buf2Dev, &fill);
      /* assertion err == 0 */
      assert(outputThread__1__3__1__err == 0);
      if(fill == 0)
      {
        if(!(multipleSenders == 0))
          syncSenders((char *)0xdeadbeef, 0);

        terminateOutputThread(dest, 0);
        return NULL;
      }

    }

    at = at + 1u;
    if(Numblocks == (signed long int)at)
      at = (unsigned int)0;

    if(startread < 1.000000)
    {
      outputThread__1__3__1__err=pthread_mutex_lock(&LowMut);
      /* assertion err == 0 */
      assert(outputThread__1__3__1__err == 0);
      outputThread__1__3__1__err=sem_getvalue(&Buf2Dev, &fill);
      /* assertion err == 0 */
      assert(outputThread__1__3__1__err == 0);
      if((double)fill / (double)Numblocks < startread)
      {
        outputThread__1__3__1__err=pthread_cond_signal(&PercLow);
        /* assertion err == 0 */
        assert(outputThread__1__3__1__err == 0);
      }

      outputThread__1__3__1__err=pthread_mutex_unlock(&LowMut);
      /* assertion err == 0 */
      assert(outputThread__1__3__1__err == 0);
    }

    Numout = Numout + 1ull;
  }
  while((_Bool)1);
}

// printmsg
// file log.c line 197
void printmsg(const char *msg, ...)
{
  void **val;
  char buf[256l];
  char *b = buf + (signed long int)PrefixLen;
  unsigned long int s;
  val = (void **)&msg;
  memcpy((void *)buf, (const void *)Prefix, PrefixLen);
  signed int return_value_vsnprintf_1;
  return_value_vsnprintf_1=vsnprintf(b, sizeof(char [256l]) /*256ul*/  - (unsigned long int)(b - buf), msg, val);
  b = b + (signed long int)return_value_vsnprintf_1;
  s = (unsigned long int)(b - buf);
  /* assertion s < sizeof(buf) */
  assert(s < sizeof(char [256l]) /*256ul*/ );
  logwrite(buf, s);
  val = ((void **)NULL);
}

// promptInteractive
// file mbuffer.c line 531
static signed int promptInteractive(unsigned int at, unsigned int num)
{
  signed int err;
  err=pthread_mutex_lock(&TermMut);
  /* assertion 0 == err */
  assert(0 == err);
  signed long int return_value_write_3;
  static const char prompt[70l] = { '\n', 'C', 'o', 'n', 't', 'i', 'n', 'u', 'e', ' ', 'w', 'i', 't', 'h', ' ', 'n', 'e', 'x', 't', ' ', 'v', 'o', 'l', 'u', 'm', 'e', '?', ' ', 'P', 'r', 'e', 's', 's', ' ', '\'', 'y', '\'', ' ', 't', 'o', ' ', 'c', 'o', 'n', 't', 'i', 'n', 'u', 'e', ' ', 'o', 'r', ' ', '\'', 'n', '\'', ' ', 't', 'o', ' ', 'f', 'i', 'n', 'i', 's', 'h', '.', '.', '.', 0 };
  return_value_write_3=write(2, (const void *)prompt, sizeof(const char [70l]) /*70ul*/ );
  if(return_value_write_3 == -1l)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    errormsg("error accessing controlling terminal for manual volume change request: %s\nConsider using autoload option, when running mbuffer without terminal.\n", return_value_strerror_2);
    Terminate = 1;
    pthread_exit((void *)-1);
  }

  signed int *return_value___errno_location_6;
  do
  {
    char c = (char)0;
    signed long int return_value_read_7;
    return_value_read_7=read(2, (void *)&c, (unsigned long int)1);
    if(return_value_read_7 == -1l)
    {
      return_value___errno_location_6=__errno_location();
      if(!(*return_value___errno_location_6 == 4))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        char *return_value_strerror_5;
        return_value_strerror_5=strerror(*return_value___errno_location_4);
        errormsg("error accessing controlling terminal for manual volume change request: %s\nConsider using autoload option, when running mbuffer without terminal.\n", return_value_strerror_5);
        Terminate = 1;
        pthread_exit((void *)-1);
      }

    }

    if(Verbose >= 5)
      logdebug("prompt input %c\n", c);

    switch((signed int)c)
    {
      case 110:

      case 78:
      {
        Rest = (volatile unsigned long long int)num;
        static const char donemsg[51l] = { '\n', 'n', 'o', ' ', '-', ' ', 'i', 'n', 'p', 'u', 't', ' ', 'd', 'o', 'n', 'e', ',', ' ', 'w', 'a', 'i', 't', 'i', 'n', 'g', ' ', 'f', 'o', 'r', ' ', 'o', 'u', 't', 'p', 'u', 't', ' ', 't', 'o', ' ', 'f', 'i', 'n', 'i', 's', 'h', '.', '.', '.', '\n', 0 };
        write(2, (const void *)donemsg, sizeof(const char [51l]) /*51ul*/ );
        err=pthread_mutex_lock(&HighMut);
        /* assertion err == 0 */
        assert(err == 0);
        err=sem_post(&Buf2Dev);
        /* assertion err == 0 */
        assert(err == 0);
        err=pthread_cond_signal(&PercHigh);
        /* assertion err == 0 */
        assert(err == 0);
        err=pthread_mutex_unlock(&HighMut);
        /* assertion err == 0 */
        assert(err == 0);
        err=pthread_mutex_unlock(&TermMut);
        /* assertion 0 == err */
        assert(0 == err);
        Finish = (signed long int)at;
        if(!(Status == 0))
          pthread_exit(NULL);

        return 0;
      }
      case 121:

      case 89:
      {
        static const char contmsg[39l] = { '\n', 'y', 'e', 's', ' ', '-', ' ', 'c', 'o', 'n', 't', 'i', 'n', 'u', 'i', 'n', 'g', ' ', 'w', 'i', 't', 'h', ' ', 'n', 'e', 'x', 't', ' ', 'v', 'o', 'l', 'u', 'm', 'e', '.', '.', '.', '\n', 0 };
        write(2, (const void *)contmsg, sizeof(const char [39l]) /*39ul*/ );
        err=pthread_mutex_unlock(&TermMut);
        /* assertion 0 == err */
        assert(0 == err);
        return 1;
      }
      default:
        ;
    }
  }
  while((_Bool)1);
}

// releaseLock
// file mbuffer.c line 665
static void releaseLock(void *l)
{
  signed int err;
  err=pthread_mutex_unlock((union anonymous_14 *)l);
  /* assertion err == 0 */
  assert(err == 0);
}

// requestInputVolume
// file mbuffer.c line 585
static signed int requestInputVolume(unsigned int at, unsigned int num)
{
  const char *cmd;
  struct timeval now;
  double diff;
  unsigned int min;
  unsigned int hr;
  signed long int hr_array_size0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(Infile);
  hr_array_size0 = (signed long int)((unsigned long int)15 + return_value_strlen_1);
  char cmd_buf[hr_array_size0];
  if(Verbose >= 5)
    logdebug("requesting new volume for input\n");

  gettimeofday(&now, ((struct timezone *)NULL));
  static struct timeval volstart = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
  if(!(volstart.tv_sec == 0l))
    diff = (double)(now.tv_sec - volstart.tv_sec) + (double)(now.tv_usec - volstart.tv_usec) * 1E-6;

  else
    diff = (double)(now.tv_sec - Starttime.tv_sec) + (double)(now.tv_usec - Starttime.tv_usec) * 1E-6;
  if(diff > 3600.000000)
  {
    hr = (unsigned int)(diff / (double)3600);
    diff = diff - (double)(hr * (unsigned int)3600);
    min = (unsigned int)(diff / (double)60);
    diff = diff - (double)(min * (unsigned int)60);
    infomsg("time for reading volume: %u:%02u:%02f\n", hr, min, diff);
  }

  else
    if(diff > 60.000000)
    {
      min = (unsigned int)(diff / (double)60);
      diff = diff - (double)(min * (unsigned int)60);
      infomsg("time for reading volume: %02u:%02f\n", min, diff);
    }

    else
      infomsg("time for reading volume: %02fsec.\n", diff);
  signed int return_value_close_4;
  return_value_close_4=close(In);
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  if(return_value_close_4 == -1)
  {
    return_value___errno_location_2=__errno_location();
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    errormsg("error closing input: %s\n", return_value_strerror_3);
  }

  signed int *return_value___errno_location_8;
  signed int *return_value___errno_location_9;
  char *return_value_strerror_10;
  while((_Bool)1)
  {
    if(!(Infile == ((const char *)NULL)) && !(Autoloader == 0))
    {
      signed int ret;
      if(!(AutoloadCmd == ((const char *)NULL)))
        cmd = AutoloadCmd;

      else
      {
        snprintf(cmd_buf, (unsigned long int)hr_array_size0, "mt -f %s offline", Infile);
        cmd = cmd_buf;
      }
      infomsg("requesting new input volume with command '%s'\n", cmd);
      ret=system(cmd);
      if(ret >= 1)
      {
        warningmsg("error running \"%s\" to change volume in autoloader: exitcode %d\n", cmd, ret);
        Terminate = 1;
        pthread_exit((void *)0);
      }

      else
        if(!(ret >= 0))
        {
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          char *return_value_strerror_6;
          return_value_strerror_6=strerror(*return_value___errno_location_5);
          errormsg("error starting \"%s\" to change volume in autoloader: %s\n", cmd, return_value_strerror_6);
          Terminate = 1;
          pthread_exit((void *)-1);
        }

      if(!(AutoloadTime == 0u))
      {
        infomsg("waiting for drive to get ready...\n");
        sleep(AutoloadTime);
      }

    }

    else
    {
      signed int return_value_promptInteractive_7;
      return_value_promptInteractive_7=promptInteractive(at, num);
      if(return_value_promptInteractive_7 == 0)
        return 0;

    }
    In=open(Infile, 00 | 0 | Direct);
    if(In == -1)
    {
      return_value___errno_location_8=__errno_location();
      if(*return_value___errno_location_8 == 22)
        In=open(Infile, 00 | Direct);

    }

    if(In == -1)
    {
      return_value___errno_location_9=__errno_location();
      return_value_strerror_10=strerror(*return_value___errno_location_9);
      errormsg("could not reopen input: %s\n", return_value_strerror_10);
    }

    if(!(In == -1))
      break;

  }
  gettimeofday(&volstart, ((struct timezone *)NULL));
  diff = (double)(volstart.tv_sec - now.tv_sec) + (double)(volstart.tv_usec - now.tv_usec) * 1E-6;
  infomsg("tape-change took %fsec. - continuing with next volume\n", diff);
  NumVolumes = NumVolumes - 1l;
  if(Autoloader == 0 && !(Terminal == 0))
  {
    char msg[21l] = { '\n', 'O', 'K', ' ', '-', ' ', 'c', 'o', 'n', 't', 'i', 'n', 'u', 'i', 'n', 'g', '.', '.', '.', '\n', 0 };
    write(2, (const void *)msg, sizeof(char [21l]) /*21ul*/ );
  }

  return 1;
}

// requestOutputVolume
// file mbuffer.c line 1012
static signed int requestOutputVolume(signed int out, const char *outfile)
{
  struct timeval now;
  double diff;
  unsigned int min;
  unsigned int hr;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  signed int *return_value___errno_location_12;
  signed int *return_value___errno_location_15;
  char *return_value_strerror_16;
  if(outfile == ((const char *)NULL))
  {
    errormsg("End of volume, but not end of input:\nOutput file must be given (option -o) for multi-volume support!\n");
    return -1;
  }

  else
  {
    infomsg("end of volume - last block on volume: %lld\n", Numout);
    gettimeofday(&now, ((struct timezone *)NULL));
    static struct timeval volstart = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
    if(!(volstart.tv_sec == 0l))
      diff = (double)(now.tv_sec - volstart.tv_sec) + (double)(now.tv_usec - volstart.tv_usec) * 1E-6;

    else
      diff = (double)(now.tv_sec - Starttime.tv_sec) + (double)(now.tv_usec - Starttime.tv_usec) * 1E-6;
    if(diff > 3600.000000)
    {
      hr = (unsigned int)(diff / (double)3600);
      diff = diff - (double)(hr * (unsigned int)3600);
      min = (unsigned int)(diff / (double)60);
      diff = diff - (double)(min * (unsigned int)60);
      infomsg("time for writing volume: %u:%02u:%02f\n", hr, min, diff);
    }

    else
      if(diff > 60.000000)
      {
        min = (unsigned int)(diff / (double)60);
        diff = diff - (double)(min * (unsigned int)60);
        infomsg("time for writing volume: %02u:%02f\n", min, diff);
      }

      else
        infomsg("time for writing volume: %02fsec.\n", diff);
    signed int return_value_close_3;
    return_value_close_3=close(out);
    if(return_value_close_3 == -1)
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      errormsg("error closing output %s: %s\n", outfile, return_value_strerror_2);
    }

    do
    {
      unsigned int mode;
      if(!(Autoloader == 0))
      {
        const char default_cmd[17l] = { 'm', 't', ' ', '-', 'f', ' ', '%', 's', ' ', 'o', 'f', 'f', 'l', 'i', 'n', 'e', 0 };
        signed long int default_cmd_array_size0;
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(outfile);
        default_cmd_array_size0 = (signed long int)(sizeof(const char [17l]) /*17ul*/  + return_value_strlen_4);
        char cmd_buf[default_cmd_array_size0];
        const char *cmd = AutoloadCmd;
        signed int err;
        if(cmd == ((const char *)NULL))
        {
          snprintf(cmd_buf, (unsigned long int)default_cmd_array_size0, default_cmd, Infile);
          cmd = cmd_buf;
        }

        infomsg("requesting new output volume with command '%s'\n", cmd);
        err=system(cmd);
        if(err >= 1)
        {
          errormsg("error running \"%s\" to change volume in autoloader - exitcode %d\n", cmd, err);
          Autoloader = 0;
          return -1;
        }

        else
          if(!(err >= 0))
          {
            signed int *return_value___errno_location_5;
            return_value___errno_location_5=__errno_location();
            char *return_value_strerror_6;
            return_value_strerror_6=strerror(*return_value___errno_location_5);
            errormsg("error starting \"%s\" to change volume in autoloader: %s\n", cmd, return_value_strerror_6);
            Autoloader = 0;
            return -1;
          }

        if(!(AutoloadTime == 0u))
        {
          infomsg("waiting for drive to get ready...\n");
          sleep(AutoloadTime);
        }

      }

      else
      {
        signed int requestOutputVolume__1__4__2__err;
        char c = (char)0;
        char msg[64l] = { '\n', 'v', 'o', 'l', 'u', 'm', 'e', ' ', 'f', 'u', 'l', 'l', ' ', '-', ' ', 'i', 'n', 's', 'e', 'r', 't', ' ', 'n', 'e', 'w', ' ', 'm', 'e', 'd', 'i', 'a', ' ', 'a', 'n', 'd', ' ', 'p', 'r', 'e', 's', 's', ' ', 'r', 'e', 't', 'u', 'r', 'n', ' ', 'w', 'h', 'e', 'n', ' ', 'r', 'e', 'a', 'd', 'y', '.', '.', '.', '\n', 0 };
        if(Terminal == 0)
        {
          errormsg("End of volume, but not end of input.\nSpecify an autoload command, if you are working without terminal.\n");
          return -1;
        }

        requestOutputVolume__1__4__2__err=pthread_mutex_lock(&TermMut);
        /* assertion 0 == err */
        assert(0 == requestOutputVolume__1__4__2__err);
        signed long int return_value_write_9;
        return_value_write_9=write(2, (const void *)msg, sizeof(char [64l]) /*64ul*/ );
        if(return_value_write_9 == -1l)
        {
          signed int *return_value___errno_location_7;
          return_value___errno_location_7=__errno_location();
          char *return_value_strerror_8;
          return_value_strerror_8=strerror(*return_value___errno_location_7);
          errormsg("error accessing controlling terminal for manual volume change request: %s\nConsider using autoload option, when running mbuffer without terminal.\n", return_value_strerror_8);
          return -1;
        }

        do
        {
          signed long int return_value_read_13;
          return_value_read_13=read(2, (void *)&c, (unsigned long int)1);
          if(return_value_read_13 == -1l)
          {
            return_value___errno_location_12=__errno_location();
            if(!(*return_value___errno_location_12 == 4))
            {
              signed int *return_value___errno_location_10;
              return_value___errno_location_10=__errno_location();
              char *return_value_strerror_11;
              return_value_strerror_11=strerror(*return_value___errno_location_10);
              errormsg("error accessing controlling terminal for manual volume change request: %s\nConsider using autoload option, when running mbuffer without terminal.\n", return_value_strerror_11);
              return -1;
            }

          }

        }
        while(!((signed int)c == 10));
        requestOutputVolume__1__4__2__err=pthread_mutex_unlock(&TermMut);
        /* assertion 0 == err */
        assert(0 == requestOutputVolume__1__4__2__err);
      }
      mode = (unsigned int)((signed long int)(01 | 01000) | OptSync | (signed long int)0 | (signed long int)Direct);
      signed int return_value_strncmp_14;
      return_value_strncmp_14=strncmp(outfile, "/dev/", (unsigned long int)5);
      if(!(return_value_strncmp_14 == 0))
        mode = mode | (unsigned int)0100;

      out=open(outfile, (signed int)mode, 0666);
      if(out == -1)
      {
        return_value___errno_location_15=__errno_location();
        return_value_strerror_16=strerror(*return_value___errno_location_15);
        errormsg("error reopening output file: %s\n", return_value_strerror_16);
      }

    }
    while(out == -1);
    gettimeofday(&volstart, ((struct timezone *)NULL));
    diff = (double)(volstart.tv_sec - now.tv_sec) + (double)(volstart.tv_usec - now.tv_usec) * 1E-6;
    infomsg("tape-change took %fsec. - continuing with next volume\n", diff);
    if(Autoloader == 0 && !(Terminal == 0))
    {
      char requestOutputVolume__1__5__msg[21l] = { '\n', 'O', 'K', ' ', '-', ' ', 'c', 'o', 'n', 't', 'i', 'n', 'u', 'i', 'n', 'g', '.', '.', '.', '\n', 0 };
      write(2, (const void *)requestOutputVolume__1__5__msg, sizeof(char [21l]) /*21ul*/ );
    }

    return out;
  }
}

// senderThread
// file mbuffer.c line 866
static void * senderThread(void *arg)
{
  unsigned long long int outsize = Blocksize;
  struct destination *dest = (struct destination *)arg;
  signed int out = dest->fd;
  struct stat st;
  if(Verbose >= 5)
    logdebug("sender(%s): checking output device...\n", dest->arg);

  signed int return_value_fstat_4;
  return_value_fstat_4=fstat(out, &st);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(return_value_fstat_4 == -1)
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    warningmsg("could not stat output %s: %s\n", dest->arg, return_value_strerror_2);
  }

  else
    if((61440u & st.st_mode) == 8192u || (61440u & st.st_mode) == 24576u)
    {
      infomsg("blocksize is %d bytes on output device\n", st.st_blksize);
      if(!(Blocksize % (unsigned long int)st.st_blksize == 0ul) || !(Blocksize >= (unsigned long int)st.st_blksize))
      {
        warningmsg("Blocksize should be a multiple of the blocksize of the output device!\nThis can cause problems with some device/OS combinations...\nBlocksize on output device %s is %d (transfer block size is %lld)\n", dest->arg, st.st_blksize, Blocksize);
        if(!(SetOutsize == 0))
        {
          errormsg("unable to set output blocksize\n");
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          dest->result=strerror(*return_value___errno_location_3);
          terminateSender(out, dest, 1);
        }

      }

      else
        if(!(SetOutsize == 0))
        {
          infomsg("setting output blocksize to %d\n", st.st_blksize);
          outsize = (unsigned long long int)st.st_blksize;
        }

    }

    else
      infomsg("no device on output stream %s\n", dest->arg);
  if(Verbose >= 5)
    logdebug("sender(%s): starting...\n", dest->arg);

  do
  {
    signed int size;
    signed int num = 0;
    syncSenders(((char *)NULL), 0);
    size = SendSize;
    if(size == 0)
    {
      if(Verbose >= 5)
        logdebug("senderThread(\"%s\"): done.\n", dest->arg);

      terminateSender(out, dest, 0);
      return NULL;
    }

    if(!(Terminate == 0))
    {
      infomsg("senderThread(\"%s\"): terminating early upon request...\n", dest->arg);
      dest->result = "canceled";
      terminateSender(out, dest, 1);
    }

    do
    {
      unsigned long long int rest = (unsigned long long int)(size - num);
      signed int ret;
      /* assertion size >= num */
      assert(size >= num);
      char *baddr = SendAt + (signed long int)num;
      signed long int return_value_write_5;
      return_value_write_5=write(out, (const void *)baddr, rest > outsize ? outsize : rest);
      ret = (signed int)return_value_write_5;
      if(Verbose >= 6)
        logdebug("sender(%s): writing %llu@0x%p: ret = %d\n", dest->arg, rest, (void *)baddr, ret);

      if(ret == -1)
      {
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        char *return_value_strerror_7;
        return_value_strerror_7=strerror(*return_value___errno_location_6);
        errormsg("error writing to %s: %s\n", dest->arg, return_value_strerror_7);
        signed int *return_value___errno_location_8;
        return_value___errno_location_8=__errno_location();
        dest->result=strerror(*return_value___errno_location_8);
        terminateSender(out, dest, 1);
      }

      num = num + ret;
    }
    while(!(num == size));
  }
  while((_Bool)1);
}

// setTCPBufferSize
// file network.c line 61
static void setTCPBufferSize(signed int sock, unsigned int buffer)
{
  signed int err;
  signed int osize;
  signed int size;
  unsigned int bsize = (unsigned int)sizeof(signed int) /*4ul*/ ;
  /* assertion buffer == 8 || buffer == 7 */
  assert(buffer == (unsigned int)8 || buffer == (unsigned int)7);
  err=getsockopt(sock, 1, (signed int)buffer, (void *)&osize, &bsize);
  /* assertion (err == 0) && (bsize == sizeof(osize)) */
  assert(err == 0 && (unsigned long int)bsize == sizeof(signed int) /*4ul*/ );
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  if(!(osize >= TCPBufSize))
  {
    size = TCPBufSize;
    do
    {
      err=setsockopt(sock, 1, (signed int)buffer, (void *)&size, (unsigned int)sizeof(signed int) /*4ul*/ );
      size = size >> 1;
      if(err == -1)
      {
        return_value___errno_location_1=__errno_location();
        tmp_if_expr_2 = *return_value___errno_location_1 == 12 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
    }
    while(!(osize >= size) && tmp_if_expr_2);
    if(err == -1)
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      warningmsg("unable to set socket buffer size: %s\n", return_value_strerror_4);
      goto __CPROVER_DUMP_L8;
    }

  }

  bsize = (unsigned int)sizeof(signed int) /*4ul*/ ;
  err=getsockopt(sock, 1, (signed int)buffer, (void *)&size, &bsize);
  /* assertion err != -1 */
  assert(err != -1);
  if(buffer == 8u)
    infomsg("set TCP receive buffer size to %d\n", size);

  else
    infomsg("set TCP send buffer size to %d\n", size);

__CPROVER_DUMP_L8:
  ;
}

// sigHandler
// file mbuffer.c line 307
static void sigHandler(signed int signr)
{
  if(signr == 1 || signr == 2)
  {
    ErrorOccurred = 1;
    Terminate = 1;
    close(In);
    if(!(TermQ[1l] == -1))
      write(TermQ[(signed long int)1], (const void *)"0", (unsigned long int)1);

    if(StartWrite > 0.000000)
      pthread_cond_signal(&PercHigh);

    if(StartRead < 1.000000)
      pthread_cond_signal(&PercLow);

    goto __CPROVER_DUMP_L6;
  }

  raise(6);

__CPROVER_DUMP_L6:
  ;
}

// statusThread
// file mbuffer.c line 375
static void statusThread(void)
{
  struct timeval last;
  struct timeval now;
  double in = (double)0;
  double out = (double)0;
  double total;
  double diff;
  double fill;
  unsigned long long int lin = (unsigned long long int)0;
  unsigned long long int lout = (unsigned long long int)0;
  signed int unwritten = 1;
  struct anonymous_1 readfds;
  struct timeval timeout = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)200000 };
  signed int maxfd = 0;
  last = Starttime;
  if(!(TermQ[0l] == -1))
    maxfd = TermQ[(signed long int)0] + 1;

  signed int *return_value___errno_location_2;
  while(Terminate == 0 && Finish == -1l && Numin == 0ul)
  {
    timeout.tv_sec = (signed long int)0;
    timeout.tv_usec = (signed long int)200000;
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_1) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readfds)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    if(!(TermQ[0l] == -1))
      (&readfds)->fds_bits[(signed long int)(TermQ[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->fds_bits[(signed long int)(TermQ[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << TermQ[(signed long int)0] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

    signed int return_value_select_1;
    return_value_select_1=select(maxfd, &readfds, ((struct anonymous_1 *)NULL), ((struct anonymous_1 *)NULL), &timeout);
    if(!(return_value_select_1 == 0))
    {
      if(return_value_select_1 == 1)
        goto __CPROVER_DUMP_L5;

      if(return_value_select_1 == -1)
        goto __CPROVER_DUMP_L6;

    }

    else
    {
      continue;

    __CPROVER_DUMP_L5:
      ;
      goto __CPROVER_DUMP_L8;

    __CPROVER_DUMP_L6:
      ;
      return_value___errno_location_2=__errno_location();
      if(*return_value___errno_location_2 == 4)
        goto __CPROVER_DUMP_L8;

    }
    abort();

  __CPROVER_DUMP_L8:
    ;
  }
  signed int *return_value___errno_location_3;
  signed int return_value_sprintf_8;
  signed int return_value_sprintf_9;
  while(Done == 0)
  {
    signed int err;
    signed int numsender;
    signed long int nw = (signed long int)0;
    char buf[256l];
    char *b = buf;
    timeout.tv_sec = (signed long int)0;
    timeout.tv_usec = (signed long int)500000;
    do
    {
      signed int statusThread__1__2__1____d0;
      signed int statusThread__1__2__1____d1;
      asm("cld; rep; stosq" : "=c"(statusThread__1__2__1____d0), "=D"(statusThread__1__2__1____d1) : "a"(0), "0"(sizeof(struct anonymous_1) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readfds)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    if(!(TermQ[0l] == -1))
      (&readfds)->fds_bits[(signed long int)(TermQ[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->fds_bits[(signed long int)(TermQ[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << TermQ[(signed long int)0] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

    err=select(maxfd, &readfds, ((struct anonymous_1 *)NULL), ((struct anonymous_1 *)NULL), &timeout);
    if(!(err == 0))
    {
      if(err == 1)
        goto __CPROVER_DUMP_L14;

      if(err == -1)
        goto __CPROVER_DUMP_L15;

    }

    else
    {
      goto __CPROVER_DUMP_L17;

    __CPROVER_DUMP_L14:
      ;
      goto __CPROVER_DUMP_L24;

    __CPROVER_DUMP_L15:
      ;
      return_value___errno_location_3=__errno_location();
      if(*return_value___errno_location_3 == 4)
        goto __CPROVER_DUMP_L17;

    }
    abort();

  __CPROVER_DUMP_L17:
    ;
    gettimeofday(&now, ((struct timezone *)NULL));
    diff = (double)(now.tv_sec - last.tv_sec) + (double)(now.tv_usec - last.tv_usec) / (double)1000000;
    err=pthread_mutex_lock(&TermMut);
    /* assertion 0 == err */
    assert(0 == err);
    err=sem_getvalue(&Buf2Dev, &unwritten);
    /* assertion 0 == err */
    assert(0 == err);
    fill = ((double)unwritten / (double)Numblocks) * 100.0;
    in = (double)((Numin - lin) * Blocksize >> 10);
    in = in / diff;
    out = (double)((Numout - lout) * Blocksize >> 10);
    out = out / diff;
    lin = Numin;
    lout = Numout;
    last = now;
    total = (double)(Numout * Blocksize >> 10);
    fill = fill < 0.0 ? 0.0 : fill;
    signed int return_value_sprintf_4;
    return_value_sprintf_4=sprintf(b, "\rin @ ");
    b = b + (signed long int)return_value_sprintf_4;
    signed int return_value_kb2str_5;
    return_value_kb2str_5=kb2str(b, in);
    b = b + (signed long int)return_value_kb2str_5;
    numsender = (NumSenders + MainOutOK) - Hashers;
    signed int return_value_sprintf_6;
    return_value_sprintf_6=sprintf(b, "B/s, out @ ");
    b = b + (signed long int)return_value_sprintf_6;
    signed int return_value_kb2str_7;
    return_value_kb2str_7=kb2str(b, out * (double)numsender);
    b = b + (signed long int)return_value_kb2str_7;
    if(!(numsender == 1))
    {
      return_value_sprintf_8=sprintf(b, "B/s, %d x ", numsender);
      b = b + (signed long int)return_value_sprintf_8;
    }

    else
    {
      return_value_sprintf_9=sprintf(b, "B/s, ");
      b = b + (signed long int)return_value_sprintf_9;
    }
    signed int return_value_kb2str_10;
    return_value_kb2str_10=kb2str(b, total);
    b = b + (signed long int)return_value_kb2str_10;
    signed int return_value_sprintf_11;
    return_value_sprintf_11=sprintf(b, "B total, buffer %3.0f%% full", fill);
    b = b + (signed long int)return_value_sprintf_11;
    if(Quiet == 0)
    {
      unsigned long int return_value_strlen_12;
      return_value_strlen_12=strlen(buf);
      nw=write(2, (const void *)buf, return_value_strlen_12);
    }

    if(!(Log == 2) && !(StatusLog == 0))
      infomsg("%s\n", buf + (signed long int)1);

    err=pthread_mutex_unlock(&TermMut);
    /* assertion 0 == err */
    assert(0 == err);
    if(nw == -1l)
      break;

  }

__CPROVER_DUMP_L24:
  ;
}

// summary
// file mbuffer.c line 245
static void summary(unsigned long long int numb, signed int numthreads)
{
  signed int h;
  signed int m;
  double secs;
  double av;
  char buf[256l];
  char *msg = buf;
  struct timeval now;
  gettimeofday(&now, ((struct timezone *)NULL));
  char *tmp_post_1;
  if(!(Status == 0))
  {
    tmp_post_1 = msg;
    msg = msg + 1l;
    *tmp_post_1 = (char)10;
  }

  if(Terminate == 1 && numthreads == 0)
    numthreads = 1;

  secs = ((double)(now.tv_sec - Starttime.tv_sec) + (double)now.tv_usec / (double)1000000) - (double)Starttime.tv_usec / (double)1000000;
  /* assertion secs > 0 */
  assert(secs > (double)0);
  numb = numb >> 10;
  av = ((double)numb / secs) * (double)numthreads;
  h = (signed int)secs / 3600;
  m = (signed int)(secs - (double)(h * 3600)) / 60;
  secs = secs - (double)(m * 60 + h * 3600);
  signed int return_value_sprintf_2;
  signed int return_value_sprintf_3;
  if(numthreads >= 2)
  {
    return_value_sprintf_2=sprintf(msg, "summary: %dx ", numthreads);
    msg = msg + (signed long int)return_value_sprintf_2;
  }

  else
  {
    return_value_sprintf_3=sprintf(msg, "summary: ");
    msg = msg + (signed long int)return_value_sprintf_3;
  }
  signed int return_value_kb2str_4;
  return_value_kb2str_4=kb2str(msg, (double)numb);
  msg = msg + (signed long int)return_value_kb2str_4;
  signed int return_value_sprintf_5;
  return_value_sprintf_5=sprintf(msg, "Byte in ");
  msg = msg + (signed long int)return_value_sprintf_5;
  signed int return_value_sprintf_6;
  signed int return_value_sprintf_7;
  signed int return_value_sprintf_8;
  if(h >= 1)
  {
    return_value_sprintf_6=sprintf(msg, "%dh %02dmin %04.1fsec - average of ", h, m, secs);
    msg = msg + (signed long int)return_value_sprintf_6;
  }

  else
    if(m >= 1)
    {
      return_value_sprintf_7=sprintf(msg, "%2dmin %04.1fsec - average of ", m, secs);
      msg = msg + (signed long int)return_value_sprintf_7;
    }

    else
    {
      return_value_sprintf_8=sprintf(msg, "%4.1fsec - average of ", secs);
      msg = msg + (signed long int)return_value_sprintf_8;
    }
  signed int return_value_kb2str_9;
  return_value_kb2str_9=kb2str(msg, av);
  msg = msg + (signed long int)return_value_kb2str_9;
  signed int return_value_sprintf_10;
  return_value_sprintf_10=sprintf(msg, "B/s");
  msg = msg + (signed long int)return_value_sprintf_10;
  signed int return_value_sprintf_11;
  if(!(EmptyCount == 0))
  {
    return_value_sprintf_11=sprintf(msg, ", %dx empty", EmptyCount);
    msg = msg + (signed long int)return_value_sprintf_11;
  }

  signed int return_value_sprintf_12;
  if(!(FullCount == 0))
  {
    return_value_sprintf_12=sprintf(msg, ", %dx full", FullCount);
    msg = msg + (signed long int)return_value_sprintf_12;
  }

  char *tmp_post_13 = msg;
  msg = msg + 1l;
  *tmp_post_13 = (char)10;
  *msg = (char)0;
  if(!(Log == 2))
    write(Log, (const void *)buf, (unsigned long int)(msg - buf));

  if(!(Status == 0))
    write(2, (const void *)buf, (unsigned long int)(msg - buf));

}

// syncSenders
// file mbuffer.c line 791
static inline signed int syncSenders(char *b, signed int s)
{
  signed int err;
  err=pthread_mutex_lock(&SendMut);
  /* assertion err == 0 */
  assert(err == 0);
  static volatile signed int size = 0;
  static char * volatile buf = ((char *)NULL);
  if(!(b == ((char *)NULL)))
  {
    buf = b;
    size = s;
  }

  if(!(s >= 0))
    NumSenders = NumSenders - 1;

  ActSenders = ActSenders - 1;
  if(!(ActSenders == 0))
  {
    if(Verbose >= 6)
      logdebug("syncSenders(%p,%d): ActSenders = %d\n", b, s, ActSenders);

    do
    {
      struct anonymous_3 __cancel_buf;
      void (*__cancel_routine)(void *) = releaseLock;
      void *__cancel_arg = (void *)&SendMut;
      signed int __not_first_call;
      __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
      if(!((signed long int)__not_first_call == 0l))
      {
        __cancel_routine(__cancel_arg);
        __pthread_unwind_next(&__cancel_buf);
      }

      __pthread_register_cancel(&__cancel_buf);
      do
      {
        err=pthread_cond_wait(&SendCond, &SendMut);
        /* assertion err == 0 */
        assert(err == 0);

      __CPROVER_DUMP_L6:
        ;
      }
      while((_Bool)0);
      __pthread_unregister_cancel(&__cancel_buf);
      __cancel_routine(__cancel_arg);
    }
    while((_Bool)0);
    if(Verbose >= 6)
      logdebug("syncSenders(): continue\n");

    return 0;
  }

  else
  {
    ActSenders = NumSenders + 1;
    /* assertion (buf != 0) || Terminate */
    assert(buf != ((char *)NULL) || Terminate != 0);
    SendAt = buf;
    SendSize = size;
    buf = ((char *)NULL);
    static volatile signed int skipped = 0;
    if(!(skipped == 0))
    {
      err=sem_post(&Dev2Buf);
      /* assertion err == 0 */
      assert(err == 0);
    }

    else
      skipped = 1;
    err=pthread_mutex_unlock(&SendMut);
    /* assertion err == 0 */
    assert(err == 0);
    if(Verbose >= 6)
      logdebug("syncSenders(): send %d@%p, BROADCAST\n", SendSize, SendAt);

    err=pthread_cond_broadcast(&SendCond);
    /* assertion err == 0 */
    assert(err == 0);
    return 1;
  }
}

// terminateOutputThread
// file mbuffer.c line 1117
static void terminateOutputThread(struct destination *d, signed int status)
{
  signed int err;
  infomsg("outputThread: syncing %s...\n", d->arg);
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  do
  {
    err=fsync(d->fd);
    if(!(err == 0))
    {
      return_value___errno_location_1=__errno_location();
      tmp_if_expr_2 = *return_value___errno_location_1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  _Bool tmp_if_expr_7;
  signed int *return_value___errno_location_6;
  if(!(err == 0))
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    if(*return_value___errno_location_5 == 22)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value___errno_location_6=__errno_location();
      tmp_if_expr_7 = *return_value___errno_location_6 == 56 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      infomsg("syncing unsupported on %s: omitted.\n", d->arg);

    else
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      warningmsg("unable to sync %s: %s\n", d->arg, return_value_strerror_4);
    }
  }

  infomsg("outputThread: finished - exiting...\n");
  signed int return_value_close_10;
  return_value_close_10=close(d->fd);
  signed int *return_value___errno_location_8;
  char *return_value_strerror_9;
  if(return_value_close_10 == -1)
  {
    return_value___errno_location_8=__errno_location();
    return_value_strerror_9=strerror(*return_value___errno_location_8);
    errormsg("error closing %s: %s\n", d->arg, return_value_strerror_9);
  }

  signed int *return_value___errno_location_12;
  char *return_value_strerror_13;
  if(!(TermQ[1l] == -1))
  {
    signed long int return_value_write_11;
    return_value_write_11=write(TermQ[(signed long int)1], (const void *)"0", (unsigned long int)1);
    err = (signed int)return_value_write_11;
    if(err == -1)
    {
      return_value___errno_location_12=__errno_location();
      return_value_strerror_13=strerror(*return_value___errno_location_12);
      errormsg("error writing to termination queue: %s\n", return_value_strerror_13);
    }

  }

  if(!(status == 0))
  {
    sem_post(&Dev2Buf);
    pthread_cond_broadcast(&SendCond);
  }

  Done = 1;
  pthread_exit((void *)status);
}

// terminateSender
// file mbuffer.c line 838
static inline void terminateSender(signed int fd, struct destination *d, signed int ret)
{
  if(Verbose >= 5)
    logdebug("terminating operation on %s\n", d->arg);

  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_7;
  signed int *return_value___errno_location_6;
  signed int *return_value___errno_location_8;
  char *return_value_strerror_9;
  if(!(fd == -1))
  {
    signed int err;
    infomsg("syncing %s...\n", d->arg);
    do
    {
      err=fsync(fd);
      if(!(err == 0))
      {
        return_value___errno_location_1=__errno_location();
        tmp_if_expr_2 = *return_value___errno_location_1 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
    }
    while(tmp_if_expr_2);
    if(!(err == 0))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      if(*return_value___errno_location_5 == 22)
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value___errno_location_6=__errno_location();
        tmp_if_expr_7 = *return_value___errno_location_6 == 56 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
        infomsg("syncing unsupported on %s: omitted.\n", d->arg);

      else
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        char *return_value_strerror_4;
        return_value_strerror_4=strerror(*return_value___errno_location_3);
        warningmsg("unable to sync %s: %s\n", d->arg, return_value_strerror_4);
      }
    }

    signed int return_value_close_10;
    return_value_close_10=close(fd);
    if(return_value_close_10 == -1)
    {
      return_value___errno_location_8=__errno_location();
      return_value_strerror_9=strerror(*return_value___errno_location_8);
      errormsg("error closing file %s: %s\n", d->arg, return_value_strerror_9);
    }

  }

  if(!(ret == 0))
  {
    ret=syncSenders(((char *)NULL), -1);
    if(Verbose >= 5)
      logdebug("terminateSender(%s): sendSender(0,-1) = %d\n", d->arg, ret);

  }

  pthread_exit((void *)ret);
}

// timediff
// file mbuffer.c line 476
static inline signed long long int timediff(struct timespec * restrict t1, struct timespec * restrict t2)
{
  signed long long int tdiff = (t1->tv_sec - t2->tv_sec) * (signed long int)1000000;
  tdiff = tdiff + (t1->tv_nsec - t2->tv_nsec) / (signed long int)1000;
  if(!(tdiff >= 0l))
    tdiff = (signed long long int)0;

  return tdiff;
}

// usage
// file mbuffer.c line 1367
static void usage(void)
{
  const char *dim = "bkMGTP";
  unsigned long long int m = (unsigned long int)Numblocks * Blocksize;
  for( ; m >= 10000ul; dim = dim + 1l)
    m = m >> 10;
  fprintf(stderr, "usage: mbuffer [Options]\nOptions:\n-b <num>   : use <num> blocks for buffer (default: %ld)\n-s <size>  : use blocks of <size> bytes for processing (default: %llu)\n-m <size>  : memory <size> of buffer in b,k,M,G,%% (default: 2%% = %llu%c)\n-L         : lock buffer in memory (unusable with file-based buffers)\n-d         : use blocksize of device for output\n-D <size>  : assumed output device size (default: infinite/auto-detect)\n-P <num>   : start writing after buffer has been filled more than <num>%%\n-p <num>   : start reading after buffer has been filled less than <num>%%\n-i <file>  : use <file> for input\n-o <file>  : use <file> for output (this option can be passed MULTIPLE times)\n--append   : append to output file (must be passed before -o)\n--truncate : truncate next file (must be passed before -o)\n-I <h>:<p> : use network port <port> as input, allow only host <h> to connect\n-I <p>     : use network port <port> as input\n-O <h>:<p> : output data to host <h> and port <p> (MUTLIPLE outputs supported)\n-n <num>   : <num> volumes for input, '0' to prompt interactively\n-t         : use memory-mapped temporary file (for huge buffer)\n-T <file>  : as -t but uses <file> as buffer\n-l <file>  : use <file> for logging messages\n-u <num>   : pause <num> milliseconds after each write\n-r <rate>  : limit read rate to <rate> B/s, where <rate> can be given in b,k,M,G\n-R <rate>  : same as -r for writing; use either one, if your tape is too fast\n-f         : overwrite existing files\n-a <time>  : autoloader which needs <time> seconds to reload\n-A <cmd>   : issue command <cmd> to request new volume\n-v <level> : set verbose level to <level> (valid values are 0..6)\n-q         : quiet - do not display the status on stderr\n-Q         : quiet - do not log the status\n-c         : write with synchronous data integrity support\n-e         : stop processing on any kind of error\n--direct   : open input and output with O_DIRECT\n-H\n--md5      : generate md5 hash of transferred data\n--hash <a> : use algorithm <a>, if <a> is 'list' possible algorithms are listed\n--pid      : print PID of this instance\n-W <time>  : set watchdog timeout to <time> seconds\n-4         : force use of IPv4\n-6         : force use of IPv6\n-0         : use IPv4 or IPv6\n--tcpbuffer: size for TCP buffer\n-V\n--version  : print version information\nUnsupported buffer options: -t -Z -B\n", Numblocks, Blocksize, m, *dim);
  exit(0);
}

// version
// file mbuffer.c line 1352
static void version(void)
{
  fprintf(stderr, "mbuffer version 20150412\nCopyright 2001-2014 - T. Maier-Komor\nLicense: GPLv3 - see the LICENSE file\nThis program comes with ABSOLUTELY NO WARRANTY!!!\nDonations via PayPal to thomas@maier-komor.de are welcome and support this work!\n\n");
  exit(0);
}

// warningmsg
// file log.c line 131
void warningmsg(const char *msg, ...)
{
  if(Verbose >= 3)
  {
    void **val;
    char buf[256l];
    char *b = buf + (signed long int)PrefixLen;
    unsigned long int s;
    val = (void **)&msg;
    memcpy((void *)buf, (const void *)Prefix, PrefixLen);
    memcpy((void *)b, (const void *)"warning: ", (unsigned long int)9);
    b = b + (signed long int)9;
    signed int return_value_vsnprintf_1;
    return_value_vsnprintf_1=vsnprintf(b, sizeof(char [256l]) /*256ul*/  - (unsigned long int)(b - buf), msg, val);
    b = b + (signed long int)return_value_vsnprintf_1;
    s = (unsigned long int)(b - buf);
    /* assertion s < sizeof(buf) */
    assert(s < sizeof(char [256l]) /*256ul*/ );
    logwrite(buf, s);
    val = ((void **)NULL);
  }

}

// watchdogThread
// file mbuffer.c line 351
static void * watchdogThread(void *ignored)
{
  unsigned long int ni = Numin;
  unsigned long int no = Numout;
  do
  {
    sleep((unsigned int)Timeout);
    if(Finish == -1l && ni == Numin)
    {
      errormsg("watchdog timeout: input stalled; sending SIGINT\n");
      WatchdogRaised = 1;
      signed int return_value_getpid_1;
      return_value_getpid_1=getpid();
      kill(return_value_getpid_1, 2);
    }

    if(no == Numout)
    {
      errormsg("watchdog timeout: output stalled; sending SIGINT\n");
      WatchdogRaised = 1;
      signed int return_value_getpid_2;
      return_value_getpid_2=getpid();
      kill(return_value_getpid_2, 2);
    }

    ni = Numin;
    no = Numout;
  }
  while((_Bool)1);
  return NULL;
}

