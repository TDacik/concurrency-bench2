// #anon_enum_G_LOG_FLAG_RECURSION=1_G_LOG_FLAG_FATAL=2_G_LOG_LEVEL_ERROR=4_G_LOG_LEVEL_CRITICAL=8_G_LOG_LEVEL_WARNING=16_G_LOG_LEVEL_MESSAGE=32_G_LOG_LEVEL_INFO=64_G_LOG_LEVEL_DEBUG=128_G_LOG_LEVEL_MASK=-4
// file /usr/include/glib-2.0/glib/gmessages.h line 51
enum anonymous { G_LOG_FLAG_RECURSION=1, G_LOG_FLAG_FATAL=2, G_LOG_LEVEL_ERROR=4, G_LOG_LEVEL_CRITICAL=8, G_LOG_LEVEL_WARNING=16, G_LOG_LEVEL_MESSAGE=32, G_LOG_LEVEL_INFO=64, G_LOG_LEVEL_DEBUG=128, G_LOG_LEVEL_MASK=-4 };

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_14;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_12;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_2;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_4;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_8;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_11;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_10;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_16;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_9;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_13;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_17;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_0;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_15;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_6;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_5;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_7;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_3;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_1;

// tag-_GAsyncQueue
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 36
struct _GAsyncQueue;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GMutex
// file /usr/include/glib-2.0/glib/gthread.h line 51
union _GMutex;

// tag-_GString
// file /usr/include/glib-2.0/glib/gstring.h line 39
struct _GString;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-bginfo_struct
// file xnbd_tester.c line 53
struct bginfo_struct;

// tag-cachestat
// file xnbd_cachestat.c line 33
struct cachestat;

// tag-cmsghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 242
struct cmsghdr;

// tag-crequest
// file xnbd_tester.c line 36
struct crequest;

// tag-custom_log_handler_params
// file common.h line 85
struct custom_log_handler_params;

// tag-disk_image
// file xnbd.h line 90
struct disk_image;

// tag-disk_stack
// file xnbd.h line 103
struct disk_stack;

// tag-disk_stack_io
// file xnbd.h line 110
struct disk_stack_io;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-mmap_partial
// file xnbd.h line 208
struct mmap_partial;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-nbd_negotiate_pdu_new_0
// file nbd.c line 321
struct nbd_negotiate_pdu_new_0;

// tag-nbd_negotiate_pdu_new_1
// file nbd.c line 327
struct nbd_negotiate_pdu_new_1;

// tag-nbd_negotiate_pdu_new_2
// file nbd.c line 334
struct nbd_negotiate_pdu_new_2;

// tag-nbd_negotiate_pdu_old
// file nbd.c line 525
struct nbd_negotiate_pdu_old;

// tag-nbd_reply
// file lib/nbd.h line 53
struct nbd_reply;

// tag-nbd_request
// file nbd.h line 45
struct nbd_request;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-parameters
// file xnbd_tester.c line 193
struct parameters;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-proxy_priv
// file xnbd_proxy.h line 37
struct proxy_priv;

// tag-proxy_session
// file xnbd_proxy.c line 37
struct proxy_session;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 309
union pthread_attr_t;

// tag-remote_read_request
// file xnbd_proxy.h line 29
struct remote_read_request;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-xnbd_cmd_type
// file xnbd.h line 124
enum xnbd_cmd_type { xnbd_cmd_unknown=-1, xnbd_cmd_target=0, xnbd_cmd_cow_target=1, xnbd_cmd_proxy=2, xnbd_cmd_help=3, xnbd_cmd_version=4 };

// tag-xnbd_info
// file xnbd.h line 135
struct xnbd_info;

// tag-xnbd_proxy
// file xnbd_proxy.h line 75
struct xnbd_proxy;

// tag-xnbd_proxy_cmd_type
// file xnbd_proxy.h line 109
enum xnbd_proxy_cmd_type { XNBD_PROXY_CMD_UNKNOWN=0, XNBD_PROXY_CMD_QUERY_STATUS=1, XNBD_PROXY_CMD_REGISTER_FD=2, XNBD_PROXY_CMD_REGISTER_FORWARDER_FD=3, XNBD_PROXY_CMD_REGISTER_SHARED_BUFFER_FD=4, XNBD_PROXY_CMD_DETECT_SWITCH=5 };

// tag-xnbd_proxy_query
// file xnbd_proxy.h line 119
struct xnbd_proxy_query;

// tag-xnbd_session
// file xnbd.h line 175
struct xnbd_session;

// tag-xnbd_tester_rwmode
// file xnbd_tester.c line 187
enum xnbd_tester_rwmode { TESTRDONLY=1, TESTWRONLY=2, TESTRDWR=3 };

#ifndef NULL
#define NULL ((void*)0)
#endif

// __bswap_64
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 109
static inline unsigned long int __bswap_64(unsigned long int __bsx);
// __bswap_64_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 109
static inline unsigned long int __bswap_64_link1(unsigned long int __bsx_link1);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous_1, unsigned int *);
// add_read_block_to_tail
// file xnbd_proxy_forwarder.c line 56
void add_read_block_to_tail(struct proxy_priv *priv, unsigned long int i);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bgctl_thread_create
// file xnbd_tester.c line 135
void bgctl_thread_create(signed long int disksize, const char *bgctlpath);
// bgctl_thread_main
// file xnbd_tester.c line 70
void * bgctl_thread_main(void *data);
// bgctl_wait_shutdown
// file xnbd_tester.c line 166
void bgctl_wait_shutdown(void);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous_1, unsigned int);
// bitmap_alloc
// file bitmap.c line 43
unsigned long int * bitmap_alloc(unsigned long int bits);
// bitmap_close_file
// file lib/bitmap.h line 37
void bitmap_close_file(unsigned long int *bitmap, unsigned long int bitmaplen);
// bitmap_create
// file bitmap.c line 147
unsigned long int * bitmap_create(char *bitmapfile, unsigned long int bits, signed int *cbitmapfd, unsigned long int *cbitmaplen);
// bitmap_on
// file lib/bitmap.h line 40
void bitmap_on(unsigned long int *bitmap_array, unsigned long int block_index);
// bitmap_open_file
// file lib/bitmap.h line 36
unsigned long int * bitmap_open_file(const char *bitmapfile, unsigned long int bits, unsigned long int *bitmaplen, signed int readonly, signed int zeroclear);
// bitmap_size
// file bitmap.c line 37
unsigned long int bitmap_size(unsigned long int bits);
// bitmap_test
// file lib/bitmap.h line 39
signed int bitmap_test(unsigned long int *bitmap_array, unsigned long int block_index);
// block_all_signals
// file xnbd_proxy.c line 51
void block_all_signals(void);
// cachestat_cache_bgcopy
// file xnbd_cachestat.c line 254
inline void cachestat_cache_bgcopy(void);
// cachestat_cache_odread
// file xnbd_cachestat.c line 252
inline void cachestat_cache_odread(void);
// cachestat_cache_odwrite
// file xnbd_cachestat.c line 253
inline void cachestat_cache_odwrite(void);
// cachestat_dump
// file xnbd_cachestat.c line 48
void cachestat_dump(char *path);
// cachestat_dump_loop
// file xnbd_cachestat.c line 84
void cachestat_dump_loop(char *path, unsigned int interval);
// cachestat_hit
// file xnbd_cachestat.c line 258
inline void cachestat_hit(void);
// cachestat_initialize
// file xnbd_cachestat.c line 259
signed int cachestat_initialize(const char *path, unsigned long int nblocks);
// cachestat_miss
// file xnbd_cachestat.c line 257
inline void cachestat_miss(void);
// cachestat_read_block
// file xnbd_cachestat.c line 255
inline void cachestat_read_block(void);
// cachestat_shutdown
// file xnbd_cachestat.c line 260
signed int cachestat_shutdown(void);
// cachestat_write_block
// file xnbd_cachestat.c line 256
inline void cachestat_write_block(void);
// calc_block_index
// file lib/io.h line 49
void calc_block_index(const unsigned int blocksize, const signed long int iofrom, const unsigned long int iolen, unsigned long int *index_start, unsigned long int *index_end);
// check_consistency_by_partial_mmap
// file xnbd_tester.c line 411
signed int check_consistency_by_partial_mmap(char *srcdisk, signed int tgtdiskfd, struct crequest *req);
// check_consistency_by_partial_mmap_for_cowdisk
// file xnbd_tester.c line 330
signed int check_consistency_by_partial_mmap_for_cowdisk(char *srcdisk, signed int tgtdiskfd, struct crequest *req);
// check_disksize
// file xnbd_common.c line 160
void check_disksize(char *diskpath, signed long int disksize, _Bool force_cblock);
// check_done
// file net.c line 489
void check_done(signed int ret, signed int errcode);
// check_fin
// file net.c line 517
signed int check_fin(signed int ret, signed int errcode, unsigned long int len);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// compress_iovec_and_send
// file xnbd_target_cow_lzo.c line 737
void compress_iovec_and_send(signed int csock, struct iovec *iov, signed int count);
// compress_iovec_and_send_advanced
// file xnbd_target_cow_lzo.c line 729
void compress_iovec_and_send_advanced(signed int csock, struct iovec *iov, const unsigned int count, signed int lzo_enabled);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous_1, unsigned int);
// create_disk_stack
// file xnbd_target_cow_lzo.c line 170
struct disk_stack * create_disk_stack(char *diskpath);
// create_disk_stack_io
// file xnbd_target_cow_lzo.c line 401
static struct disk_stack_io * create_disk_stack_io(struct disk_stack *ds);
// custom_log_handler
// file common.c line 83
void custom_log_handler(const char *log_domain, enum anonymous log_level, const char *message, void *data);
// destroy_disk_stack
// file xnbd_target_cow_lzo.c line 255
void destroy_disk_stack(struct disk_stack *ds);
// disk_stack_add_image
// file xnbd_target_cow_lzo.c line 279
void disk_stack_add_image(struct disk_stack *ds, char *diskpath, signed int newfile);
// disk_stack_mmap
// file xnbd.h line 120
struct disk_stack_io * disk_stack_mmap(struct disk_stack *ds, signed long int iofrom, unsigned long int iolen, signed int reading);
// dump_buffer
// file io.c line 104
void dump_buffer(const char *buff, unsigned long int bufflen);
// dump_buffer_all
// file lib/io.h line 42
void dump_buffer_all(const char *buff, unsigned long int bufflen);
// dump_buffer_main
// file io.c line 70
static void dump_buffer_main(const char *buff, unsigned long int bufflen, signed int all);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fill_random
// file xnbd_tester.c line 27
static void fill_random(char *buff, unsigned long int len);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fork_or_abort
// file lib/io.h line 45
signed int fork_or_abort(void);
// forwarder_rx_thread_main
// file xnbd_proxy.h line 135
void * forwarder_rx_thread_main(void *arg);
// forwarder_rx_thread_mainloop
// file xnbd_proxy_forwarder.c line 295
signed int forwarder_rx_thread_mainloop(struct xnbd_proxy *proxy);
// forwarder_tx_thread_main
// file xnbd_proxy.h line 136
void * forwarder_tx_thread_main(void *arg);
// free_disk_stack_io
// file xnbd.h line 121
void free_disk_stack_io(struct disk_stack_io *io);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 219
extern signed int fstat(signed int, struct stat *);
// ftruncate
// file /usr/include/unistd.h line 1019
extern signed int ftruncate(signed int, signed long int);
// g_assertion_message_expr
// file /usr/include/glib-2.0/glib/gtestutils.h line 302
extern void g_assertion_message_expr(const char *, const char *, signed int, const char *, const char *);
// g_async_queue_length
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 88
extern signed int g_async_queue_length(struct _GAsyncQueue *);
// g_async_queue_new
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 39
extern struct _GAsyncQueue * g_async_queue_new(void);
// g_async_queue_pop
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 74
extern void * g_async_queue_pop(struct _GAsyncQueue *);
// g_async_queue_push
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 58
extern void g_async_queue_push(struct _GAsyncQueue *, void *);
// g_async_queue_push_sorted
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 64
extern void g_async_queue_push_sorted(struct _GAsyncQueue *, void *, signed int (*)(const void *, const void *, void *), void *);
// g_async_queue_push_unshift
// file xnbd_proxy.c line 529
static void g_async_queue_push_unshift(struct _GAsyncQueue *queue, void *data);
// g_async_queue_try_pop
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 78
extern void * g_async_queue_try_pop(struct _GAsyncQueue *);
// g_async_queue_unref
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 49
extern void g_async_queue_unref(struct _GAsyncQueue *);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_list_append
// file /usr/include/glib-2.0/glib/glist.h line 59
extern struct _GList * g_list_append(struct _GList *, void *);
// g_list_first
// file /usr/include/glib-2.0/glib/glist.h line 128
extern struct _GList * g_list_first(struct _GList *);
// g_list_length
// file /usr/include/glib-2.0/glib/glist.h line 130
extern unsigned int g_list_length(struct _GList *);
// g_list_remove
// file /usr/include/glib-2.0/glib/glist.h line 85
extern struct _GList * g_list_remove(struct _GList *, const void *);
// g_log
// file /usr/include/glib-2.0/glib/gmessages.h line 101
extern void g_log(const char *, enum anonymous, const char *, ...);
// g_malloc
// file /usr/include/glib-2.0/glib/gmem.h line 78
extern void * g_malloc(unsigned long int);
// g_malloc0
// file /usr/include/glib-2.0/glib/gmem.h line 80
extern void * g_malloc0(unsigned long int);
// g_malloc0_n
// file /usr/include/glib-2.0/glib/gmem.h line 96
extern void * g_malloc0_n(unsigned long int, unsigned long int);
// g_mutex_clear
// file /usr/include/glib-2.0/glib/gthread.h line 166
extern void g_mutex_clear(union _GMutex *);
// g_mutex_init
// file /usr/include/glib-2.0/glib/gthread.h line 164
extern void g_mutex_init(union _GMutex *);
// g_mutex_lock
// file /usr/include/glib-2.0/glib/gthread.h line 168
extern void g_mutex_lock(union _GMutex *);
// g_mutex_unlock
// file /usr/include/glib-2.0/glib/gthread.h line 172
extern void g_mutex_unlock(union _GMutex *);
// g_slice_alloc0
// file /usr/include/glib-2.0/glib/gslice.h line 34
extern void * g_slice_alloc0(unsigned long int);
// g_slice_free1
// file /usr/include/glib-2.0/glib/gslice.h line 39
extern void g_slice_free1(unsigned long int, void *);
// g_strdup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 216
extern char * g_strdup(const char *);
// g_strdup_printf
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 218
extern char * g_strdup_printf(const char *, ...);
// g_string_append
// file /usr/include/glib-2.0/glib/gstring.h line 80
extern struct _GString * g_string_append(struct _GString *, const char *);
// g_string_append_printf
// file /usr/include/glib-2.0/glib/gstring.h line 149
extern void g_string_append_printf(struct _GString *, const char *, ...);
// g_string_free
// file /usr/include/glib-2.0/glib/gstring.h line 56
extern char * g_string_free(struct _GString *, signed int);
// g_string_new
// file /usr/include/glib-2.0/glib/gstring.h line 49
extern struct _GString * g_string_new(const char *);
// g_strlcpy
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 117
extern unsigned long int g_strlcpy(char *, const char *, unsigned long int);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_disk_nblocks
// file xnbd_common.c line 183
unsigned long int get_disk_nblocks(signed long int disksize);
// get_disksize
// file lib/io.h line 47
signed long int get_disksize(signed int fd);
// get_disksize_of_path
// file lib/io.h line 48
signed long int get_disksize_of_path(const char *path);
// get_event_connecter
// file io.c line 344
void get_event_connecter(signed int *notifier, signed int *listener);
// get_io_range_index
// file xnbd.h line 237
void get_io_range_index(signed long int iofrom, unsigned long int iolen, unsigned long int *index_start, unsigned long int *index_end);
// get_line
// file io.c line 200
char * get_line(signed int fd);
// get_log_fd
// file xnbd_common.c line 201
signed int get_log_fd(const char *path);
// get_nameinfo_string
// file net.c line 29
static char * get_nameinfo_string(struct addrinfo *ai);
// get_session_from_read_fd
// file xnbd_proxy.c line 411
struct proxy_session * get_session_from_read_fd(struct _GList *list_head, signed int fd);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpagesize
// file /usr/include/unistd.h line 978
extern signed int getpagesize(void);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getppid
// file /usr/include/unistd.h line 631
extern signed int getppid(void);
// gnu_dev_major
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 27
extern unsigned int gnu_dev_major(unsigned long long int);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// io_all
// file io.c line 26
static void io_all(signed int fd, void *buf, unsigned long int len, signed int read_ops);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// lseek
// file /usr/include/unistd.h line 337
extern signed long int lseek(signed int, signed long int, signed int);
// main_loop
// file xnbd_proxy.c line 534
signed int main_loop(struct xnbd_proxy *proxy, signed int unix_listen_fd, signed int master_fd);
// make_pipe
// file lib/io.h line 61
void make_pipe(signed int *write_fd, signed int *read_fd);
// make_sockpair
// file lib/io.h line 62
void make_sockpair(signed int *fd0, signed int *fd1);
// mem_usage_add
// file xnbd_proxy.c line 112
static void mem_usage_add(struct xnbd_proxy *proxy, struct proxy_priv *priv);
// mem_usage_del
// file xnbd_proxy.c line 170
static void mem_usage_del(struct xnbd_proxy *proxy, struct proxy_priv *priv);
// mem_usage_wait
// file xnbd_proxy.c line 134
static void mem_usage_wait(struct xnbd_proxy *proxy);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 61
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// mmap_iorange
// file xnbd_common.c line 107
void * mmap_iorange(const signed long int disksize, const _Bool readonly, const signed int fd, const signed long int iofrom, const unsigned long int iolen, char **mmaped_buf, unsigned long int *mmaped_len, signed long int *mmaped_offset);
// mmap_partial_map
// file xnbd.h line 216
struct mmap_partial * mmap_partial_map(signed int fd, signed long int iofrom, const unsigned long int iolen_in, signed int readonly);
// mmap_partial_unmap
// file xnbd.h line 217
void mmap_partial_unmap(struct mmap_partial *mpinfo);
// msync
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 89
extern signed int msync(void *, unsigned long int, signed int);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// munmap_or_abort
// file lib/io.h line 65
void munmap_or_abort(void *addr, unsigned long int len);
// nbd_client_recv_header
// file lib/nbd.h line 104
signed int nbd_client_recv_header(signed int remotefd);
// nbd_client_recv_read_reply
// file lib/nbd.h line 103
signed int nbd_client_recv_read_reply(signed int remotefd, char *buf, unsigned long int len);
// nbd_client_recv_read_reply_iov
// file nbd.c line 171
signed int nbd_client_recv_read_reply_iov(signed int remotefd, struct iovec *iov, unsigned int count);
// nbd_client_send_disc_request
// file lib/nbd.h line 101
void nbd_client_send_disc_request(signed int remotefd);
// nbd_client_send_read_request
// file lib/nbd.h line 100
signed int nbd_client_send_read_request(signed int remotefd, signed long int iofrom, unsigned long int len);
// nbd_client_send_request_header
// file lib/nbd.h line 99
signed int nbd_client_send_request_header(signed int remotefd, unsigned int iotype, signed long int iofrom, unsigned long int len, unsigned long int handle);
// nbd_get_iotype_string
// file lib/nbd.h line 72
const char * nbd_get_iotype_string(unsigned int iotype);
// nbd_negotiate_with_client
// file nbd.c line 573
signed int nbd_negotiate_with_client(signed int sockfd, signed long int exportsize);
// nbd_negotiate_with_client_common
// file nbd.c line 535
static signed int nbd_negotiate_with_client_common(signed int sockfd, signed long int exportsize, signed int readonly);
// nbd_negotiate_with_client_new_phase_0
// file nbd.c line 363
char * nbd_negotiate_with_client_new_phase_0(signed int sockfd);
// nbd_negotiate_with_client_new_phase_1
// file nbd.c line 415
signed int nbd_negotiate_with_client_new_phase_1(signed int sockfd, signed long int exportsize, signed int readonly);
// nbd_negotiate_with_client_readonly
// file nbd.c line 568
signed int nbd_negotiate_with_client_readonly(signed int sockfd, signed long int exportsize);
// nbd_negotiate_with_server
// file lib/nbd.h line 81
signed long int nbd_negotiate_with_server(signed int sockfd);
// nbd_negotiate_with_server2
// file lib/nbd.h line 82
signed int nbd_negotiate_with_server2(signed int sockfd, signed long int *exportsize, unsigned int *exportflags);
// nbd_negotiate_with_server_new
// file lib/nbd.h line 83
signed int nbd_negotiate_with_server_new(signed int sockfd, signed long int *exportsize, unsigned int *exportflags, unsigned long int namesize, const char *target_name);
// nbd_reply_dump
// file nbd.c line 55
void nbd_reply_dump(struct nbd_reply *reply);
// nbd_request_dump
// file nbd.c line 45
void nbd_request_dump(struct nbd_request *request);
// nbd_server_recv_request
// file lib/nbd.h line 97
signed int nbd_server_recv_request(signed int clientfd, signed long int disksize, unsigned int *iotype_arg, signed long int *iofrom_arg, unsigned long int *iolen_arg, struct nbd_reply *reply);
// net_accept
// file net.c line 157
signed int net_accept(signed int lsock);
// net_connect
// file lib/net.h line 55
signed int net_connect(const char *hostname, const char *service, signed int socktype, signed int proto);
// net_create_server_sockets
// file net.c line 79
unsigned int net_create_server_sockets(struct addrinfo *ai_head, signed int *fds, unsigned long int nfds);
// net_getaddrinfo
// file net.c line 57
struct addrinfo * net_getaddrinfo(char *host, signed int port, signed int ai_family, signed int socktype, signed int proto);
// net_iov_all
// file net.c line 331
static signed int net_iov_all(signed int fd, struct iovec *iov, signed int count, signed int reading);
// net_readv_all
// file net.c line 456
signed int net_readv_all(signed int fd, struct iovec *iov, signed int count);
// net_readv_all_or_abort
// file lib/net.h line 70
void net_readv_all_or_abort(signed int fd, struct iovec *iov, unsigned int count);
// net_readv_all_or_error
// file net.h line 71
signed int net_readv_all_or_error(signed int fd, struct iovec *iov, unsigned int count);
// net_recv_all
// file net.c line 472
signed long int net_recv_all(signed int sockfd, void *buff, unsigned long int bufflen);
// net_recv_all_or_abort
// file lib/net.h line 61
void net_recv_all_or_abort(signed int sockfd, void *buff, unsigned long int bufflen);
// net_recv_all_or_error
// file lib/net.h line 62
signed int net_recv_all_or_error(signed int sockfd, void *buff, unsigned long int bufflen);
// net_send_all
// file net.h line 64
signed long int net_send_all(signed int sockfd, const void *buff, unsigned long int bufflen);
// net_send_all_or_abort
// file lib/net.h line 65
void net_send_all_or_abort(signed int sockfd, const void *buff, unsigned long int bufflen);
// net_send_all_or_error
// file lib/net.h line 66
signed int net_send_all_or_error(signed int sockfd, const void *buff, unsigned long int bufflen);
// net_set_bindv6only
// file net.c line 216
signed int net_set_bindv6only(signed int sockfd);
// net_set_keepalive
// file net.c line 228
signed int net_set_keepalive(signed int sockfd);
// net_set_nodelay
// file net.c line 204
signed int net_set_nodelay(signed int sockfd);
// net_set_reuseaddr
// file net.c line 192
signed int net_set_reuseaddr(signed int sockfd);
// net_writev_all
// file net.c line 450
signed int net_writev_all(signed int fd, struct iovec *iov, signed int count);
// net_writev_all_or_abort
// file lib/net.h line 68
void net_writev_all_or_abort(signed int fd, struct iovec *iov, unsigned int count);
// net_writev_all_or_error
// file lib/net.h line 69
signed int net_writev_all_or_error(signed int fd, struct iovec *iov, unsigned int count);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// poll_data_and_event
// file io.c line 317
signed int poll_data_and_event(signed int datafd, signed int event_listener_fd);
// poll_request_arrival
// file xnbd_common.c line 155
signed int poll_request_arrival(struct xnbd_session *ses);
// prctl
// file /usr/include/x86_64-linux-gnu/sys/prctl.h line 27
extern signed int prctl(signed int, ...);
// prepare_read_priv
// file xnbd_proxy_forwarder.c line 82
void prepare_read_priv(struct xnbd_proxy *proxy, struct proxy_priv *priv);
// prepare_write_priv
// file xnbd_proxy_forwarder.c line 113
void prepare_write_priv(struct xnbd_proxy *proxy, struct proxy_priv *priv);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// proxy_initialize
// file xnbd_proxy.c line 355
void proxy_initialize(struct xnbd_info *xnbd, struct xnbd_proxy *proxy);
// proxy_initialize_forwarder
// file xnbd_proxy.c line 324
void proxy_initialize_forwarder(struct xnbd_proxy *proxy, signed int remotefd);
// proxy_priv_dump
// file xnbd_proxy.h line 139
void proxy_priv_dump(struct proxy_priv *priv);
// proxy_shutdown
// file xnbd_proxy.c line 388
void proxy_shutdown(struct xnbd_proxy *proxy);
// proxy_shutdown_forwarder
// file xnbd_proxy.c line 331
void proxy_shutdown_forwarder(struct xnbd_proxy *proxy);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_5 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_5 *, const union anonymous_6 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_5 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_5 *, union anonymous_7 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_create_or_abort
// file lib/io.h line 44
unsigned long int pthread_create_or_abort(void * (*start_routine)(void *), void *arg);
// pthread_create_or_abort::start_routine_object
//
void * start_routine_object(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_7 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_7 *, const union anonymous_6 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_7 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_7 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_2 *, struct anonymous_2 *);
// put_line
// file io.c line 250
signed int put_line(signed int fd, const char *msg);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_all
// file io.c line 59
void read_all(signed int fd, void *buf, unsigned long int len);
// readv
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 39
extern signed long int readv(signed int, struct iovec *, signed int);
// receiver_thread_main
// file xnbd_tester.c line 286
void * receiver_thread_main(void *data);
// recv_reply_header
// file xnbd_tester.c line 262
void recv_reply_header(signed int remotefd, unsigned long int expected_index);
// recv_request
// file xnbd_proxy.c line 189
signed int recv_request(struct proxy_session *ps);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// rx_thread_main
// file xnbd_proxy.c line 424
void * rx_thread_main(void *arg);
// sender_thread_main
// file xnbd_tester.c line 202
void * sender_thread_main(void *data);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// set_process_name
// file lib/common.h line 95
void set_process_name(const char *name);
// set_sigactions
// file xnbd_tester.c line 586
static void set_sigactions();
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// show_help_and_exit
// file xnbd_tester.c line 604
void show_help_and_exit(const char *msg);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous_2 *);
// sigmask_all
// file io.c line 270
void sigmask_all(void);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strnlen
// file /usr/include/string.h line 405
extern unsigned long int strnlen(const char *, unsigned long int);
// syscall
// file /usr/include/unistd.h line 1058
extern signed long int syscall(signed long int, ...);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// syslog_level
// file common.c line 46
signed int syslog_level(signed int glib_log_level);
// target_mode_main_cow
// file xnbd_target_cow_lzo.c line 748
signed int target_mode_main_cow(struct xnbd_session *ses);
// test_direct_mode
// file xnbd_tester.c line 483
signed int test_direct_mode(char *srcdisk, char *tgtdisk, signed int remotefd, signed int cowmode, enum xnbd_tester_rwmode rwmode, const char *bgctlpath);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tx_thread_main
// file xnbd_proxy.c line 448
void * tx_thread_main(void *arg);
// unix_connect
// file lib/net.h line 80
signed int unix_connect(const char *path);
// unix_recv_fd
// file lib/net.h line 82
signed int unix_recv_fd(signed int socket);
// unix_send_fd
// file lib/net.h line 81
signed int unix_send_fd(signed int socket, signed int fd);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unshift_func
// file xnbd_proxy.c line 522
static signed int unshift_func(const void *a, const void *b, void *user_data);
// update_block_with_found
// file xnbd_target_cow_lzo.c line 320
static void update_block_with_found(struct disk_stack *ds, struct disk_stack_io *io, unsigned long int index, unsigned long int start_index);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// wait_until_readable
// file lib/io.h line 60
signed int wait_until_readable(signed int fd, signed int unblock_fd);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_all
// file lib/io.h line 40
void write_all(signed int fd, const void *buf, unsigned long int len);
// writev
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 50
extern signed long int writev(signed int, struct iovec *, signed int);
// xnbd_cow_target_close_disk
// file xnbd.h line 251
void xnbd_cow_target_close_disk(struct disk_stack *ds, signed int delete_cow);
// xnbd_cow_target_open_disk
// file xnbd.h line 250
struct disk_stack * xnbd_cow_target_open_disk(char *diskpath, signed int newfile, signed int cowid);
// xnbd_cow_target_session_server
// file xnbd_target_cow_lzo.c line 857
signed int xnbd_cow_target_session_server(struct xnbd_session *ses);
// xnbd_proxy_control_cache_block
// file xnbd_proxy.h line 141
void xnbd_proxy_control_cache_block(signed int ctl_fd, unsigned long int index, unsigned long int nblocks);
// xnbd_proxy_session_server
// file xnbd_proxy.c line 885
signed int xnbd_proxy_session_server(struct xnbd_session *ses);
// xnbd_proxy_start
// file xnbd_proxy.c line 771
void xnbd_proxy_start(struct xnbd_info *xnbd);
// xnbd_proxy_stop
// file xnbd_proxy.c line 754
void xnbd_proxy_stop(struct xnbd_info *xnbd);

struct anonymous_14
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_12
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_2
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_4
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_8
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_11
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_10
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_9
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_13
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_15
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_8 _kill;
  // _timer
  struct anonymous_9 _timer;
  // _rt
  struct anonymous_10 _rt;
  // _sigchld
  struct anonymous_11 _sigchld;
  // _sigfault
  struct anonymous_12 _sigfault;
  // _sigpoll
  struct anonymous_13 _sigpoll;
  // _sigsys
  struct anonymous_14 _sigsys;
};

struct anonymous_16
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_15 _sifields;
};

union anonymous_17
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_16 *, void *);
};

union anonymous_0
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_6
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_5
{
  // __data
  struct anonymous_4 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_7
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous_3
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_1
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

union _GMutex
{
  // p
  void *p;
  // i
  unsigned int i[2l];
};

struct _GString
{
  // str
  char *str;
  // len
  unsigned long int len;
  // allocated_len
  unsigned long int allocated_len;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct bginfo_struct
{
  // disksize
  signed long int disksize;
  // lock
  union anonymous_7 lock;
  // init_done
  union anonymous_5 init_done;
  // tid
  unsigned long int tid;
  // ctlpath
  const char *ctlpath;
  // count
  signed int count;
};

struct cachestat
{
  // nblocks
  unsigned long int nblocks;
  // cache_odread
  unsigned long int cache_odread;
  // cache_odwrite
  unsigned long int cache_odwrite;
  // cache_bgcopy
  unsigned long int cache_bgcopy;
  // io_blocks
  unsigned long int io_blocks;
  // read_blocks
  unsigned long int read_blocks;
  // written_blocks
  unsigned long int written_blocks;
  // cache_hit
  unsigned long int cache_hit;
  // cache_miss
  unsigned long int cache_miss;
};

struct cmsghdr
{
  // cmsg_len
  unsigned long int cmsg_len;
  // cmsg_level
  signed int cmsg_level;
  // cmsg_type
  signed int cmsg_type;
  // __cmsg_data
  unsigned char __cmsg_data[0l];
};

struct crequest
{
  // iotype
  unsigned int iotype;
  // iofrom
  signed long int iofrom;
  // iolen
  unsigned long int iolen;
  // write_buff
  char *write_buff;
  // index
  unsigned int index;
};

struct custom_log_handler_params
{
  // use_syslog
  signed int use_syslog;
  // use_fd
  signed int use_fd;
  // fd
  signed int fd;
};

struct disk_image
{
  // path
  char *path;
  // diskfd
  signed int diskfd;
  // bmpath
  char *bmpath;
  // bm
  unsigned long int *bm;
  // bmlen
  unsigned long int bmlen;
};

struct disk_stack
{
  // nlayers
  signed int nlayers;
  // image
  struct disk_image *image[10l];
  // disksize
  signed long int disksize;
};

struct disk_stack_io
{
  // ds
  struct disk_stack *ds;
  // bufs
  char *bufs[10l];
  // buflen
  unsigned long int buflen;
  // iov
  struct iovec *iov;
  // iov_size
  unsigned int iov_size;
};

struct in6_addr
{
  // __in6_u
  union anonymous_0 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct mmap_partial
{
  // iobuf
  void *iobuf;
  // buf
  void *buf;
  // len
  unsigned long int len;
  // offset
  signed long int offset;
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct nbd_negotiate_pdu_new_0
{
  // passwd
  unsigned long int passwd;
  // magic
  unsigned long int magic;
  // flag16
  unsigned short int flag16;
} __attribute__ ((__packed__));

struct nbd_negotiate_pdu_new_1
{
  // reserved
  unsigned int reserved;
  // opt_magic
  unsigned long int opt_magic;
  // opt
  unsigned int opt;
  // namesize
  unsigned int namesize;
} __attribute__ ((__packed__));

struct nbd_negotiate_pdu_new_2
{
  // size
  unsigned long int size;
  // flags
  unsigned short int flags;
  // padding
  char padding[124l];
} __attribute__ ((__packed__));

struct nbd_negotiate_pdu_old
{
  // passwd
  unsigned long int passwd;
  // magic
  unsigned long int magic;
  // size
  unsigned long int size;
  // flags
  unsigned int flags;
  // padding
  char padding[124l];
} __attribute__ ((__packed__));

struct nbd_reply
{
  // magic
  unsigned int magic;
  // error
  unsigned int error;
  // handle
  unsigned long int handle;
};

struct nbd_request
{
  // magic
  unsigned int magic;
  // type
  unsigned int type;
  // handle
  unsigned long int handle;
  // from
  unsigned long int from;
  // len
  unsigned int len;
} __attribute__ ((__packed__));

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct parameters
{
  // nreq
  unsigned int nreq;
  // rwmode
  enum xnbd_tester_rwmode rwmode;
  // disksize
  signed long int disksize;
  // remotefd
  signed int remotefd;
  // tgtdiskfd
  signed int tgtdiskfd;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

struct remote_read_request
{
  // bindex_iofrom
  signed long int bindex_iofrom;
  // bindex_iolen
  unsigned long int bindex_iolen;
};

struct proxy_priv
{
  // clientfd
  signed int clientfd;
  // iotype
  unsigned int iotype;
  // nreq
  signed int nreq;
  // req
  struct remote_read_request req[32l];
  // iofrom
  signed long int iofrom;
  // iolen
  unsigned long int iolen;
  // block_index_start
  unsigned long int block_index_start;
  // block_index_end
  unsigned long int block_index_end;
  // reply
  struct nbd_reply reply;
  // write_buff
  char *write_buff;
  // read_buff
  char *read_buff;
  // tx_queue
  struct _GAsyncQueue *tx_queue;
  // need_exit
  signed int need_exit;
  // need_retry
  signed int need_retry;
  // prepare_done
  signed int prepare_done;
  // seqnum
  unsigned long int seqnum;
};

struct proxy_session
{
  // nbd_fd
  signed int nbd_fd;
  // wrk_fd
  signed int wrk_fd;
  // tx_queue
  struct _GAsyncQueue *tx_queue;
  // proxy
  struct xnbd_proxy *proxy;
  // tid_tx
  unsigned long int tid_tx;
  // tid_rx
  unsigned long int tid_rx;
  // pipe_write_fd
  signed int pipe_write_fd;
  // pipe_read_fd
  signed int pipe_read_fd;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_17 __sigaction_handler;
  // sa_mask
  struct anonymous_2 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct xnbd_info
{
  // cmd
  enum xnbd_cmd_type cmd;
  // disksize
  signed long int disksize;
  // nblocks
  unsigned long int nblocks;
  // readonly
  signed int readonly;
  // sessions
  struct _GList *sessions;
  // target_diskpath
  char *target_diskpath;
  // target_diskfd
  signed int target_diskfd;
  // cow_diskpath
  char *cow_diskpath;
  // cow_ds
  struct disk_stack *cow_ds;
  // proxy_pid
  signed int proxy_pid;
  // proxy_sockpair_proxy_fd
  signed int proxy_sockpair_proxy_fd;
  // proxy_sockpair_master_fd
  signed int proxy_sockpair_master_fd;
  // proxy_diskpath
  char *proxy_diskpath;
  // proxy_bmpath
  char *proxy_bmpath;
  // proxy_rhost
  char *proxy_rhost;
  // proxy_rport
  char *proxy_rport;
  // proxy_unixpath
  char *proxy_unixpath;
  // proxy_target_exportname
  char *proxy_target_exportname;
  // proxy_clear_bitmap
  _Bool proxy_clear_bitmap;
  // proxy_max_buf_size
  unsigned long int proxy_max_buf_size;
  // proxy_max_que_size
  unsigned long int proxy_max_que_size;
};

struct xnbd_proxy
{
  // tid_fwd_tx
  unsigned long int tid_fwd_tx;
  // tid_fwd_rx
  unsigned long int tid_fwd_rx;
  // fwd_tx_queue
  struct _GAsyncQueue *fwd_tx_queue;
  // fwd_rx_queue
  struct _GAsyncQueue *fwd_rx_queue;
  // fwd_retry_queue
  struct _GAsyncQueue *fwd_retry_queue;
  // xnbd
  struct xnbd_info *xnbd;
  // remotefd
  signed int remotefd;
  // cachefd
  signed int cachefd;
  // cbitmap
  unsigned long int *cbitmap;
  // cbitmaplen
  unsigned long int cbitmaplen;
  // shared_buff
  char *shared_buff;
  // curr_use_mutex
  union _GMutex curr_use_mutex;
  // cur_use_buf
  unsigned long int cur_use_buf;
  // cur_use_que
  unsigned long int cur_use_que;
};

struct xnbd_proxy_query
{
  // disksize
  signed long int disksize;
  // diskpath
  char diskpath[4096l];
  // bmpath
  char bmpath[4096l];
  // master_pid
  signed int master_pid;
  // rhost
  char rhost[4096l];
  // rport
  char rport[4096l];
  // max_use_buf
  unsigned long int max_use_buf;
  // max_use_que
  unsigned long int max_use_que;
  // cur_use_buf
  unsigned long int cur_use_buf;
  // cur_use_que
  unsigned long int cur_use_que;
};

struct xnbd_session
{
  // clientfd
  signed int clientfd;
  // xnbd
  struct xnbd_info *xnbd;
  // pipe_worker_fd
  signed int pipe_worker_fd;
  // pipe_master_fd
  signed int pipe_master_fd;
  // pid
  signed int pid;
  // notifying
  signed int notifying;
};


// CBLOCKSIZE
// file xnbd_common.c line 28
const unsigned int CBLOCKSIZE = (const unsigned int)4096;
// CoWID
// file xnbd_tester.c line 328
static signed int CoWID = 0;
// NBD_NEGOTIATE_MAGIC_NEW
// file nbd.c line 315
const unsigned long int NBD_NEGOTIATE_MAGIC_NEW = (const unsigned long int)0x49484156454F5054LL;
// NBD_NEGOTIATE_MAGIC_OLD
// file nbd.c line 314
const unsigned long int NBD_NEGOTIATE_MAGIC_OLD = (const unsigned long int)0x0000420281861253LL;
// NBD_OPT_EXPORT_NAME
// file nbd.c line 316
const unsigned int NBD_OPT_EXPORT_NAME = (const unsigned int)1;
// NBD_PASSWD
// file nbd.c line 312
const unsigned long int NBD_PASSWD = (const unsigned long int)0x4e42444d41474943LL;
// PAGESIZE
// file xnbd_common.c line 29
unsigned int PAGESIZE = (unsigned int)4096;
// XNBD_PORT
// file xnbd_common.c line 31
const signed int XNBD_PORT = 8520;
// bginfo_data
// file xnbd_tester.c line 61
struct bginfo_struct bginfo_data;
// check_pendings
// file xnbd_tester.c line 185
struct _GAsyncQueue *check_pendings;
// conn_list
// file xnbd_proxy.c line 409
struct _GList *conn_list = (struct _GList *)(void *)0;
// eofmarker
// file xnbd_tester.c line 48
struct crequest eofmarker = { .iotype=0u, .iofrom=0l, .iolen=0ul, .write_buff=(char *)(void *)0, .index=0u };
// fwd_counter
// file xnbd_proxy_forwarder.c line 219
static unsigned long int fwd_counter = (unsigned long int)0;
// longopts
// file xnbd_tester.c line 597
static struct option longopts[4l] = { { .name="bgctlpath", .has_arg=1, .flag=(signed int *)(void *)0, .val=66 },
    { .name="rwmode", .has_arg=1, .flag=(signed int *)(void *)0, .val=109 },
    { .name="cow", .has_arg=1, .flag=(signed int *)(void *)0, .val=99 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
// myhandle
// file nbd.c line 93
static const unsigned long int myhandle = 18446744073709551615UL;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// priv_stop_forwarder
// file xnbd_proxy.c line 29
struct proxy_priv priv_stop_forwarder = { .clientfd=0, .iotype=(unsigned int)6, .nreq=0, .req={ { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul },
    { .bindex_iofrom=0l, .bindex_iolen=0ul } },
    .iofrom=0l,
    .iolen=0ul, .block_index_start=0ul, .block_index_end=0ul,
    .reply={ .magic=0u, .error=0u, .handle=0ul }, .write_buff=(char *)(void *)0,
    .read_buff=(char *)(void *)0, .tx_queue=((struct _GAsyncQueue *)NULL),
    .need_exit=0,
    .need_retry=0, .prepare_done=0, .seqnum=0ul };
// receiving_failed
// file xnbd_proxy_forwarder.c line 294
static signed int receiving_failed = 0;
// reply_pendings
// file xnbd_tester.c line 184
struct _GAsyncQueue *reply_pendings;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;

// __bswap_64
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 109
static inline unsigned long int __bswap_64(unsigned long int __bsx)
{
  signed long long int return_value___builtin_bswap64_1;
  return_value___builtin_bswap64_1=__builtin_bswap64((signed long long int)__bsx);
  return (unsigned long int)return_value___builtin_bswap64_1;
}

// __bswap_64_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 109
static inline unsigned long int __bswap_64_link1(unsigned long int __bsx_link1)
{
  signed long long int return_value___builtin_bswap64_1_link1;
  return_value___builtin_bswap64_1_link1=__builtin_bswap64((signed long long int)__bsx_link1);
  return (unsigned long int)return_value___builtin_bswap64_1_link1;
}

// add_read_block_to_tail
// file xnbd_proxy_forwarder.c line 56
void add_read_block_to_tail(struct proxy_priv *priv, unsigned long int i)
{
  signed int cur_nreq = priv->nreq;
  if(cur_nreq >= 1)
  {
    struct remote_read_request *last_req = &priv->req[(signed long int)(cur_nreq - 1)];
    if(i == last_req->bindex_iolen + (unsigned long int)last_req->bindex_iofrom)
    {
      last_req->bindex_iolen = last_req->bindex_iolen + (unsigned long int)1;
      goto __CPROVER_DUMP_L6;
    }

  }

  priv->req[(signed long int)cur_nreq].bindex_iofrom = (signed long int)i;
  priv->req[(signed long int)cur_nreq].bindex_iolen = (unsigned long int)1;
  priv->nreq = priv->nreq + 1;
  if(priv->nreq == 32)
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bug, MAXNBLOCK is too small", return_value_pthread_self_1, (const void *)"add_read_block_to_tail");

  __CPROVER_DUMP_L4:
    ;
    goto __CPROVER_DUMP_L4;
  }


__CPROVER_DUMP_L6:
  ;
}

// bgctl_thread_create
// file xnbd_tester.c line 135
void bgctl_thread_create(signed long int disksize, const char *bgctlpath)
{
  struct bginfo_struct *bginfo = &bginfo_data;
  memset((void *)bginfo, 0, sizeof(struct bginfo_struct) /*120ul*/ );
  pthread_mutex_init(&bginfo->lock, (const union anonymous_6 *)(void *)0);
  pthread_cond_init(&bginfo->init_done, (const union anonymous_6 *)(void *)0);
  bginfo->disksize = disksize;
  bginfo->ctlpath = bgctlpath;
  if(!(bginfo->ctlpath == ((const char *)NULL)))
  {
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "bgctl is on");
    pthread_mutex_lock(&bginfo->lock);
    bginfo->tid=pthread_create_or_abort(bgctl_thread_main, (void *)bginfo);
    pthread_cond_wait(&bginfo->init_done, &bginfo->lock);
    pthread_mutex_unlock(&bginfo->lock);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "bgthread creation done");
  }

}

// bgctl_thread_main
// file xnbd_tester.c line 70
void * bgctl_thread_main(void *data)
{
  struct bginfo_struct *bginfo = (struct bginfo_struct *)data;
  signed int bgctlfd = 0;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "try open %s", bginfo->ctlpath);
    bgctlfd=unix_connect(bginfo->ctlpath);
    if(!(bgctlfd >= 0))
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "open bgctl %s, %m", bginfo->ctlpath);
      while((_Bool)0);
      sleep((unsigned int)1);
    }

    else
      break;
  }
  while((_Bool)1);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "open %s done", bginfo->ctlpath);
  while((_Bool)0);
  signed int ctl_fd;
  signed int proxy_fd;
  make_sockpair(&ctl_fd, &proxy_fd);
  enum xnbd_proxy_cmd_type cmd = (enum xnbd_proxy_cmd_type)XNBD_PROXY_CMD_REGISTER_FD;
  net_send_all_or_abort(bgctlfd, (const void *)&cmd, sizeof(enum xnbd_proxy_cmd_type) /*4ul*/ );
  unix_send_fd(bgctlfd, proxy_fd);
  close(proxy_fd);
  pthread_mutex_lock(&bginfo->lock);
  pthread_cond_signal(&bginfo->init_done);
  pthread_mutex_unlock(&bginfo->lock);
  do
  {
    signed long int nblocks = bginfo->disksize / (signed long int)CBLOCKSIZE;
    unsigned long int index;
    signed long int return_value_random_1;
    return_value_random_1=random();
    index = (unsigned long int)((1.0L * (long double)nblocks * (long double)return_value_random_1) / (long double)2147483647);
    xnbd_proxy_control_cache_block(ctl_fd, index, (unsigned long int)1);
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "%d bgctl index %lu (iofrom %ju)\n", bginfo->count, index, (signed long int)index * (signed long int)CBLOCKSIZE);
    while((_Bool)0);
    bginfo->count = bginfo->count + 1;
    if(bginfo->count >= 1001)
      break;

  }
  while((_Bool)1);
  nbd_client_send_disc_request(ctl_fd);
  close(ctl_fd);
  char buf[1l];
  net_recv_all_or_abort(bgctlfd, (void *)buf, (unsigned long int)1);
  close(bgctlfd);
  g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "bgthread bye");
  return (void *)0;
}

// bgctl_wait_shutdown
// file xnbd_tester.c line 166
void bgctl_wait_shutdown(void)
{
  struct bginfo_struct *bginfo = &bginfo_data;
  if(!(bginfo->ctlpath == ((const char *)NULL)))
  {
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "wait bgctl");
    pthread_join(bginfo->tid, (void **)(void *)0);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "wait done, count %d done", bginfo->count);
    pthread_mutex_destroy(&bginfo->lock);
    pthread_cond_destroy(&bginfo->init_done);
    memset((void *)bginfo, 0, sizeof(struct bginfo_struct) /*120ul*/ );
  }

}

// bitmap_alloc
// file bitmap.c line 43
unsigned long int * bitmap_alloc(unsigned long int bits)
{
  unsigned long int *bitmap_array;
  unsigned long int narrays = ((bits + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ );
  void *return_value_g_malloc0_n_1;
  return_value_g_malloc0_n_1=g_malloc0_n(narrays, sizeof(unsigned long int) /*8ul*/ );
  bitmap_array = (unsigned long int *)return_value_g_malloc0_n_1;
  return bitmap_array;
}

// bitmap_close_file
// file lib/bitmap.h line 37
void bitmap_close_file(unsigned long int *bitmap, unsigned long int bitmaplen)
{

__CPROVER_DUMP_L1:
  ;
  signed int ret;
  ret=msync((void *)bitmap, bitmaplen, 4);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) msync bitmap failed", return_value_pthread_self_1, (const void *)"bitmap_close_file");

  __CPROVER_DUMP_L3:
    ;
    goto __CPROVER_DUMP_L3;
  }

  munmap_or_abort((void *)bitmap, bitmaplen);
}

// bitmap_create
// file bitmap.c line 147
unsigned long int * bitmap_create(char *bitmapfile, unsigned long int bits, signed int *cbitmapfd, unsigned long int *cbitmaplen)
{
  signed int fd;
  signed int bitmap_create__1__ret;
  void *buf = (void *)0;
  unsigned long int narrays = ((bits + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ );
  unsigned long int buflen = sizeof(unsigned long int) /*8ul*/  * narrays;
  fd=open(bitmapfile, 02 | 0100 | 01000000, 0400 | 0200);
  if(!(fd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open bitmapfile", return_value_pthread_self_1, (const void *)"bitmap_create");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  signed long int ret;
  ret=lseek(fd, (signed long int)buflen - (signed long int)1, 0);
  if(!(ret >= 0l))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) lseek", return_value_pthread_self_2, (const void *)"bitmap_create");

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

  ret=write(fd, (const void *)"\0", (unsigned long int)1);
  if(!(ret >= 0l))
  {
    unsigned long int return_value_pthread_self_3;
    return_value_pthread_self_3=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) write", return_value_pthread_self_3, (const void *)"bitmap_create");

  __CPROVER_DUMP_L8:
    ;
    goto __CPROVER_DUMP_L8;
  }

  buf=mmap((void *)0, buflen, 0x1 | 0x2, 0x01, fd, (signed long int)0);
  if(buf == (void *)-1)
  {
    unsigned long int return_value_pthread_self_4;
    return_value_pthread_self_4=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bitmap mapping failed", return_value_pthread_self_4, (const void *)"bitmap_create");

  __CPROVER_DUMP_L11:
    ;
    goto __CPROVER_DUMP_L11;
  }

  memset(buf, 0, buflen);
  bitmap_create__1__ret=msync(buf, buflen, 4);
  if(!(bitmap_create__1__ret >= 0))
  {
    unsigned long int return_value_pthread_self_5;
    return_value_pthread_self_5=pthread_self();
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    char *return_value_strerror_7;
    return_value_strerror_7=strerror(*return_value___errno_location_6);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bitmap msync failed, %s", return_value_pthread_self_5, (const void *)"bitmap_create", return_value_strerror_7);

  __CPROVER_DUMP_L14:
    ;
    goto __CPROVER_DUMP_L14;
  }

  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "bitmap %s, %lu arrays of %zu bytes, %lu nbits", bitmapfile, narrays, sizeof(unsigned long int) /*8ul*/ , bits);
  while((_Bool)0);
  *cbitmapfd = fd;
  *cbitmaplen = buflen;
  return (unsigned long int *)buf;
}

// bitmap_on
// file lib/bitmap.h line 40
void bitmap_on(unsigned long int *bitmap_array, unsigned long int block_index)
{
  unsigned long int bitmap_index = block_index / (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8);
  unsigned long int *bitmap = &bitmap_array[(signed long int)bitmap_index];
  *bitmap = *bitmap | 1UL << block_index % (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8);
}

// bitmap_open_file
// file lib/bitmap.h line 36
unsigned long int * bitmap_open_file(const char *bitmapfile, unsigned long int bits, unsigned long int *bitmaplen, signed int readonly, signed int zeroclear)
{
  void *buf = (void *)0;
  unsigned long int narrays = ((bits + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ );
  unsigned long int buflen = sizeof(unsigned long int) /*8ul*/  * narrays;
  signed int mmap_flag = readonly != 0 ? 0x1 : 0x2;
  signed int open_flag = readonly != 0 ? 00 : 02 | 0100;
  struct stat st;
  signed int ret;
  ret=stat(bitmapfile, &st);
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 2)
      open_flag = open_flag | 01000000;

    else
    {
      unsigned long int return_value_pthread_self_1;
      return_value_pthread_self_1=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) stat %s, %m", return_value_pthread_self_1, (const void *)"bitmap_open_file", bitmapfile);

    __CPROVER_DUMP_L2:
      ;
      goto __CPROVER_DUMP_L2;
    }
  }

  else
  {
    unsigned int return_value_geteuid_3;
    return_value_geteuid_3=geteuid();
    if(st.st_uid == return_value_geteuid_3)
      open_flag = open_flag | 01000000;

  }
  signed int fd;
  fd=open(bitmapfile, open_flag, 0400 | 0200);
  if(!(fd >= 0))
  {
    unsigned long int return_value_pthread_self_4;
    return_value_pthread_self_4=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bitmap open %s, %m", return_value_pthread_self_4, (const void *)"bitmap_open_file", bitmapfile);

  __CPROVER_DUMP_L8:
    ;
    goto __CPROVER_DUMP_L8;
  }

  if(!(readonly == 0))
  {
    unsigned long int size;
    signed long int return_value_get_disksize_5;
    return_value_get_disksize_5=get_disksize(fd);
    size = (unsigned long int)return_value_get_disksize_5;
    if(!(size == buflen))
    {
      unsigned long int return_value_pthread_self_6;
      return_value_pthread_self_6=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bitmap size mismatch, %ju %zu", return_value_pthread_self_6, (const void *)"bitmap_open_file", size, buflen);

    __CPROVER_DUMP_L11:
      ;
      goto __CPROVER_DUMP_L11;
    }

  }

  else
  {
    unsigned long int previous_size;
    signed long int return_value_get_disksize_7;
    return_value_get_disksize_7=get_disksize(fd);
    previous_size = (const unsigned long int)return_value_get_disksize_7;
    if(previous_size == 0ul)
      zeroclear = 1;

    if(!(previous_size == buflen))
    {
      if(!(zeroclear == 0))
      {
        signed int bitmap_open_file__1__2__3__2__1__ret;
        bitmap_open_file__1__2__3__2__1__ret=ftruncate(fd, (signed long int)buflen);
        if(!(bitmap_open_file__1__2__3__2__1__ret >= 0))
        {
          unsigned long int return_value_pthread_self_8;
          return_value_pthread_self_8=pthread_self();
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) ftruncate %m", return_value_pthread_self_8, (const void *)"bitmap_open_file");

        __CPROVER_DUMP_L16:
          ;
          goto __CPROVER_DUMP_L16;
        }

      }

      else
      {
        unsigned long int return_value_pthread_self_9;
        return_value_pthread_self_9=pthread_self();
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) Denying to re-use existing bitmap file of different size with no --clear-bitmap given.", return_value_pthread_self_9, (const void *)"bitmap_open_file");

      __CPROVER_DUMP_L19:
        ;
        goto __CPROVER_DUMP_L19;
      }
    }

  }
  buf=mmap((void *)0, buflen, mmap_flag, 0x01, fd, (signed long int)0);
  if(buf == (void *)-1)
  {
    unsigned long int return_value_pthread_self_10;
    return_value_pthread_self_10=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bitmap mapping failed", return_value_pthread_self_10, (const void *)"bitmap_open_file");

  __CPROVER_DUMP_L23:
    ;
    goto __CPROVER_DUMP_L23;
  }

  close(fd);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "bitmap file %s (%zu bytes = %lu arrays of %zu bytes), %lu nbits", bitmapfile, buflen, narrays, sizeof(unsigned long int) /*8ul*/ , bits);
  while((_Bool)0);
  if(readonly == 0)
  {
    if(!(zeroclear == 0))
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "bitmap file %s zero-cleared", bitmapfile);
      while((_Bool)0);
      memset(buf, 0, buflen);
    }

    else
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "re-using previous state from bitmap file %s", bitmapfile);
      while((_Bool)0);
    signed int bitmap_open_file__1__4__ret;
    bitmap_open_file__1__4__ret=msync(buf, buflen, 4);
    if(!(bitmap_open_file__1__4__ret >= 0))
    {
      unsigned long int return_value_pthread_self_11;
      return_value_pthread_self_11=pthread_self();
      signed int *return_value___errno_location_12;
      return_value___errno_location_12=__errno_location();
      char *return_value_strerror_13;
      return_value_strerror_13=strerror(*return_value___errno_location_12);
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bitmap msync failed, %s", return_value_pthread_self_11, (const void *)"bitmap_open_file", return_value_strerror_13);

    __CPROVER_DUMP_L30:
      ;
      goto __CPROVER_DUMP_L30;
    }

  }

  *bitmaplen = buflen;
  return (unsigned long int *)buf;
}

// bitmap_size
// file bitmap.c line 37
unsigned long int bitmap_size(unsigned long int bits)
{
  unsigned long int narrays = ((bits + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ );
  return sizeof(unsigned long int) /*8ul*/  * narrays;
}

// bitmap_test
// file lib/bitmap.h line 39
signed int bitmap_test(unsigned long int *bitmap_array, unsigned long int block_index)
{
  unsigned long int bitmap_index = block_index / (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8);
  unsigned long int *bitmap = &bitmap_array[(signed long int)bitmap_index];
  unsigned long int val = *bitmap & 1UL << block_index % (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8);
  if(val >= 1ul)
    return 1;

  else
    return 0;
}

// block_all_signals
// file xnbd_proxy.c line 51
void block_all_signals(void)
{
  struct anonymous_2 sig;
  signed int ret;
  ret=sigfillset(&sig);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) sigfillset", return_value_pthread_self_1, (const void *)"block_all_signals");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  ret=pthread_sigmask(2, &sig, (struct anonymous_2 *)(void *)0);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) sigmask", return_value_pthread_self_2, (const void *)"block_all_signals");

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

}

// cachestat_cache_bgcopy
// file xnbd_cachestat.c line 254
inline void cachestat_cache_bgcopy(void)
{
  ;
}

// cachestat_cache_odread
// file xnbd_cachestat.c line 252
inline void cachestat_cache_odread(void)
{
  ;
}

// cachestat_cache_odwrite
// file xnbd_cachestat.c line 253
inline void cachestat_cache_odwrite(void)
{
  ;
}

// cachestat_dump
// file xnbd_cachestat.c line 48
void cachestat_dump(char *path)
{
  signed int fd;
  char *buf;
  fd=open(path, 00);
  if(!(fd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open cachestat file %s, %s", return_value_pthread_self_1, (const void *)"cachestat_dump", path, return_value_strerror_3);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  void *return_value_mmap_4;
  return_value_mmap_4=mmap((void *)0, (unsigned long int)PAGESIZE, 0x1, 0x01, fd, (signed long int)0);
  buf = (char *)return_value_mmap_4;
  if(buf == (char *)-1)
  {
    unsigned long int return_value_pthread_self_5;
    return_value_pthread_self_5=pthread_self();
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    char *return_value_strerror_7;
    return_value_strerror_7=strerror(*return_value___errno_location_6);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) disk mapping failed, %s", return_value_pthread_self_5, (const void *)"cachestat_dump", return_value_strerror_7);

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

  struct cachestat *st = (struct cachestat *)buf;
  printf("nblocks %lu\n", st->nblocks);
  printf("cached_by_ondemand_read %lu\n", st->cache_odread);
  printf("cached_by_ondemand_write %lu\n", st->cache_odwrite);
  printf("cached_by_bgcopy %lu\n", st->cache_bgcopy);
  printf("io_blocks %lu\n", st->io_blocks);
  printf("read_blocks %lu\n", st->read_blocks);
  printf("written_blocks  %lu\n", st->written_blocks);
  printf("cache_hit %lu\n", st->cache_hit);
  printf("cache_miss %lu\n", st->cache_miss);
  printf("cache_hit_ratio %lf\n", (100.0 * (double)st->cache_hit) / (double)(st->cache_hit + st->cache_miss));
  printf("transferred blocks %lu\n", st->cache_miss + st->cache_bgcopy);
  munmap_or_abort((void *)buf, (unsigned long int)PAGESIZE);
  close(fd);
}

// cachestat_dump_loop
// file xnbd_cachestat.c line 84
void cachestat_dump_loop(char *path, unsigned int interval)
{
  signed int fd;
  char *buf;
  fd=open(path, 00);
  if(!(fd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open cachestat file %s, %s", return_value_pthread_self_1, (const void *)"cachestat_dump_loop", path, return_value_strerror_3);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  void *return_value_mmap_4;
  return_value_mmap_4=mmap((void *)0, (unsigned long int)PAGESIZE, 0x1, 0x01, fd, (signed long int)0);
  buf = (char *)return_value_mmap_4;
  if(buf == (char *)-1)
  {
    unsigned long int return_value_pthread_self_5;
    return_value_pthread_self_5=pthread_self();
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    char *return_value_strerror_7;
    return_value_strerror_7=strerror(*return_value___errno_location_6);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) disk mapping failed, %s", return_value_pthread_self_5, (const void *)"cachestat_dump_loop", return_value_strerror_7);

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

  struct cachestat *st = (struct cachestat *)buf;
  printf("#time nblocks ");
  printf("cached_by_ondemand_read ");
  printf("cached_by_ondemand_write ");
  printf("cached_by_bgcopy ");
  printf("cached_ratio  ");
  printf("io_blocks ");
  printf("read_blocks ");
  printf("written_blocks  ");
  printf("io_blocks_per_sec  ");
  printf("cache_hit ");
  printf("cache_miss ");
  printf("cache_hit_ratio ");
  printf("cache_hit_ratio_total  ");
  printf("transferred_blocks ");
  printf("transferred_blocks_per_sec\n");
  unsigned long int io_blocks_prev = (unsigned long int)0;
  unsigned long int cache_hit_prev = (unsigned long int)0;
  unsigned long int cache_miss_prev = (unsigned long int)0;
  unsigned long int transferred_blocks_prev = (unsigned long int)0;
  do
  {
    signed long int now;
    now=time((signed long int *)(void *)0);
    printf("%lu ", now);
    printf("%lu ", st->nblocks);
    printf("%lu ", st->cache_odread);
    printf("%lu ", st->cache_odwrite);
    printf("%lu ", st->cache_bgcopy);
    printf("%lf  ", ((double)(st->cache_odread + st->cache_odwrite + st->cache_bgcopy) * 100.0) / (double)st->nblocks);
    printf("%lu ", st->io_blocks);
    printf("%lu ", st->read_blocks);
    printf("%lu ", st->written_blocks);
    printf("%lf  ", (1.0 * (double)(st->io_blocks - io_blocks_prev)) / (double)interval);
    printf("%lu ", st->cache_hit);
    printf("%lu ", st->cache_miss);
    unsigned long int cache_hit_diff = st->cache_hit - cache_hit_prev;
    unsigned long int cache_miss_diff = st->cache_miss - cache_miss_prev;
    printf("%lf ", (100.0 * (double)cache_hit_diff) / (double)(cache_hit_diff + cache_miss_diff));
    printf("%lf  ", (100.0 * (double)st->cache_hit) / (double)(st->cache_hit + st->cache_miss));
    unsigned long int transferred_blocks = st->cache_miss + st->cache_bgcopy;
    double transferred_blocks_per_sec = (1.0 * (double)(transferred_blocks - transferred_blocks_prev)) / (double)interval;
    printf("%lu ", transferred_blocks);
    printf("%lf\n", transferred_blocks_per_sec);
    io_blocks_prev = st->io_blocks;
    cache_hit_prev = st->cache_hit;
    cache_miss_prev = st->cache_miss;
    transferred_blocks_prev = transferred_blocks;
    fflush(stdout);
    sleep(interval);
  }
  while((_Bool)1);
  munmap_or_abort((void *)buf, (unsigned long int)PAGESIZE);
  close(fd);
}

// cachestat_hit
// file xnbd_cachestat.c line 258
inline void cachestat_hit(void)
{
  ;
}

// cachestat_initialize
// file xnbd_cachestat.c line 259
signed int cachestat_initialize(const char *path, unsigned long int nblocks)
{
  return 0;
}

// cachestat_miss
// file xnbd_cachestat.c line 257
inline void cachestat_miss(void)
{
  ;
}

// cachestat_read_block
// file xnbd_cachestat.c line 255
inline void cachestat_read_block(void)
{
  ;
}

// cachestat_shutdown
// file xnbd_cachestat.c line 260
signed int cachestat_shutdown(void)
{
  return 0;
}

// cachestat_write_block
// file xnbd_cachestat.c line 256
inline void cachestat_write_block(void)
{
  ;
}

// calc_block_index
// file lib/io.h line 49
void calc_block_index(const unsigned int blocksize, const signed long int iofrom, const unsigned long int iolen, unsigned long int *index_start, unsigned long int *index_end)
{
  unsigned long int block_index_start = (unsigned long int)(iofrom / (signed long int)blocksize);
  unsigned long int block_index_end;
  if((iolen + (unsigned long int)iofrom) % (unsigned long int)blocksize == 0ul)
    block_index_end = ((unsigned long int)iofrom + iolen) / (unsigned long int)blocksize - (unsigned long int)1;

  else
    block_index_end = ((unsigned long int)iofrom + iolen) / (unsigned long int)blocksize;
  *index_start = block_index_start;
  *index_end = block_index_end;
}

// check_consistency_by_partial_mmap
// file xnbd_tester.c line 411
signed int check_consistency_by_partial_mmap(char *srcdisk, signed int tgtdiskfd, struct crequest *req)
{
  signed int result = 0;
  signed int srcdiskfd;
  srcdiskfd=open(srcdisk, 00);
  if(!(srcdiskfd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open srcdisk %s", return_value_pthread_self_1, (const void *)"check_consistency_by_partial_mmap", srcdisk);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  struct mmap_partial *srcmp;
  srcmp=mmap_partial_map(srcdiskfd, req->iofrom, req->iolen, 1);
  struct mmap_partial *tgtmp;
  tgtmp=mmap_partial_map(tgtdiskfd, req->iofrom, req->iolen, 0);
  char *srciobuf = (char *)srcmp->iobuf;
  char *tgtiobuf = (char *)tgtmp->iobuf;
  signed int ret;
  ret=memcmp((const void *)srciobuf, (const void *)tgtiobuf, req->iolen);
  if(!(ret == 0))
  {
    const char *return_value_nbd_get_iotype_string_2;
    return_value_nbd_get_iotype_string_2=nbd_get_iotype_string(req->iotype);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "mismatch index %d iotype %s iofrom %ju iolen %zu", req->index, return_value_nbd_get_iotype_string_2, req->iofrom, req->iolen);
    unsigned long int block_index_start;
    unsigned long int block_index_end;
    get_io_range_index(req->iofrom, req->iolen, &block_index_start, &block_index_end);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "iofrom %ju (%ju KB), block_index_start %lu offset_in_start_block %ju", req->iofrom, req->iofrom / (signed long int)1024, block_index_start, req->iofrom % (signed long int)CBLOCKSIZE);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "ioend %ju (%ju KB), block_index_end %lu offset_in_end_block %ju", (unsigned long int)req->iofrom + req->iolen, ((unsigned long int)req->iofrom + req->iolen) / (unsigned long int)1024, block_index_end, ((unsigned long int)req->iofrom + req->iolen) % (unsigned long int)CBLOCKSIZE);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "srcbuf ...");
    dump_buffer_all(srciobuf, req->iolen);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "tgtbuf ...");
    dump_buffer_all(tgtiobuf, req->iolen);
    if(req->iotype == 1u)
    {
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "req->write_buff");
      dump_buffer_all(req->write_buff, req->iolen);
    }

    signed int found = 0;
    unsigned int j = (unsigned int)0;
    for( ; !((unsigned long int)j >= req->iolen); j = j + 1u)
    {
      char x0 = srciobuf[(signed long int)j];
      char x1 = tgtiobuf[(signed long int)j];
      if(!(x0 == x1))
      {
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "mismatch at %d byte, %c %c", j, x0, x1);
        found = 1;
        break;
      }

    }
    if(found == 0)
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "not mismatched !?");

    result = -1;
  }

  mmap_partial_unmap(srcmp);
  mmap_partial_unmap(tgtmp);
  close(srcdiskfd);
  return result;
}

// check_consistency_by_partial_mmap_for_cowdisk
// file xnbd_tester.c line 330
signed int check_consistency_by_partial_mmap_for_cowdisk(char *srcdisk, signed int tgtdiskfd, struct crequest *req)
{
  signed int result = 0;
  struct disk_stack *ds;
  ds=xnbd_cow_target_open_disk(srcdisk, 0, CoWID);
  struct disk_stack_io *io;
  io=disk_stack_mmap(ds, req->iofrom, req->iolen, 1);
  struct mmap_partial *tgtmp;
  tgtmp=mmap_partial_map(tgtdiskfd, req->iofrom, req->iolen, 0);
  char *tgtiobuf = (char *)tgtmp->iobuf;
  unsigned long int offset = (unsigned long int)0;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= (unsigned long int)io->iov_size); i = i + 1ul)
  {
    signed int ret;
    ret=memcmp((io->iov + (signed long int)i)->iov_base, (const void *)(tgtiobuf + (signed long int)offset), (io->iov + (signed long int)i)->iov_len);
    if(!(ret == 0))
    {
      unsigned long int return_value_pthread_self_1;
      return_value_pthread_self_1=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) mismatch", return_value_pthread_self_1, (const void *)"check_consistency_by_partial_mmap_for_cowdisk");

    __CPROVER_DUMP_L3:
      ;
      goto __CPROVER_DUMP_L3;
    }

    offset = offset + (io->iov + (signed long int)i)->iov_len;
  }
  if(!(req->iolen == offset))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) io size mismatch", return_value_pthread_self_2, (const void *)"check_consistency_by_partial_mmap_for_cowdisk");

  __CPROVER_DUMP_L7:
    ;
    goto __CPROVER_DUMP_L7;
  }

  free_disk_stack_io(io);
  xnbd_cow_target_close_disk(ds, 0);
  mmap_partial_unmap(tgtmp);
  return result;
}

// check_disksize
// file xnbd_common.c line 160
void check_disksize(char *diskpath, signed long int disksize, _Bool force_cblock)
{
  signed int pgsize;
  pgsize=getpagesize();
  if(!(disksize % 1024l == 0l))
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "disksize %jd is not a multiple of 1024 (nbd's default block size)", disksize);
    while((_Bool)0);

  if(!(disksize % (signed long int)pgsize == 0l))
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "disksize %jd is not a multiple of a page size (%d)", disksize, pgsize);
    while((_Bool)0);

  if(!(disksize % (signed long int)CBLOCKSIZE == 0l))
  {
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "disksize %jd is not a multiple of %d (xnbd's cache block size)", disksize, CBLOCKSIZE);
    while((_Bool)0);
    if(!(force_cblock == (_Bool)0))
      exit(1);

  }

  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "disk %s size %ju B (%ju MB)", diskpath, disksize, (disksize / (signed long int)1024) / (signed long int)1024);
  while((_Bool)0);
}

// check_done
// file net.c line 489
void check_done(signed int ret, signed int errcode)
{
  if(ret == -1)
  {
    if(errcode == 32 || errcode == 104)
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "got RST. abort");
      while((_Bool)0);
      exit(0);
    }

    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "unknown err");
    while((_Bool)0);
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(errcode);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) xmit: %s (%d)", return_value_pthread_self_1, (const void *)"check_done", return_value_strerror_2, errcode);

  __CPROVER_DUMP_L4:
    ;
    goto __CPROVER_DUMP_L4;
  }

  else
    if(ret >= 0)
      goto __CPROVER_DUMP_L8;

  unsigned long int return_value_pthread_self_3;
  return_value_pthread_self_3=pthread_self();
  g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) not reached", return_value_pthread_self_3, (const void *)"check_done");

__CPROVER_DUMP_L7:
  ;
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L8:
  ;
}

// check_fin
// file net.c line 517
signed int check_fin(signed int ret, signed int errcode, unsigned long int len)
{
  if(ret == -1)
  {
    if(errcode == 32 || errcode == 104)
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "got RST. abort");
      while((_Bool)0);
      exit(0);
    }

    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(errcode);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) xmit: %s (%d)", return_value_pthread_self_1, (const void *)"check_fin", return_value_strerror_2, errcode);

  __CPROVER_DUMP_L3:
    ;
    goto __CPROVER_DUMP_L3;
  }

  else
    if(ret == 0)
    {
      if(len >= 1ul)
        return 1;

      else
      {
        unsigned long int return_value_pthread_self_3;
        return_value_pthread_self_3=pthread_self();
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) len must be larger than 0", return_value_pthread_self_3, (const void *)"check_fin");

      __CPROVER_DUMP_L6:
        ;
        goto __CPROVER_DUMP_L6;
      }
    }

    else
      if(ret >= 1)
      {
        if(!(ret >= (signed int)len))
          return 1;

        else
          if(ret == (signed int)len)
            return 0;

          else
          {
            unsigned long int return_value_pthread_self_4;
            return_value_pthread_self_4=pthread_self();
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) len mismatch", return_value_pthread_self_4, (const void *)"check_fin");

          __CPROVER_DUMP_L11:
            ;
            goto __CPROVER_DUMP_L11;
          }
      }

  unsigned long int return_value_pthread_self_5;
  return_value_pthread_self_5=pthread_self();
  g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) not reached", return_value_pthread_self_5, (const void *)"check_fin");

__CPROVER_DUMP_L13:
  ;
  goto __CPROVER_DUMP_L13;
  return -1;
}

// compress_iovec_and_send
// file xnbd_target_cow_lzo.c line 737
void compress_iovec_and_send(signed int csock, struct iovec *iov, signed int count)
{
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) lzo support was not compiled", return_value_pthread_self_1, (const void *)"compress_iovec_and_send");

__CPROVER_DUMP_L2:
  ;
  goto __CPROVER_DUMP_L2;
}

// compress_iovec_and_send_advanced
// file xnbd_target_cow_lzo.c line 729
void compress_iovec_and_send_advanced(signed int csock, struct iovec *iov, const unsigned int count, signed int lzo_enabled)
{
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) compression support was not compiled", return_value_pthread_self_1, (const void *)"compress_iovec_and_send_advanced");

__CPROVER_DUMP_L2:
  ;
  goto __CPROVER_DUMP_L2;
}

// create_disk_stack
// file xnbd_target_cow_lzo.c line 170
struct disk_stack * create_disk_stack(char *diskpath)
{
  signed int diskfd;
  signed long int disksize;
  diskfd=open(diskpath, 00);
  if(!(diskfd >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 75)
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "enable large file support!");
      while((_Bool)0);

    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open, %s", return_value_pthread_self_2, (const void *)"create_disk_stack", return_value_strerror_4);

  __CPROVER_DUMP_L3:
    ;
    goto __CPROVER_DUMP_L3;
  }

  disksize=get_disksize(diskfd);
  check_disksize(diskpath, disksize, (_Bool)1);
  struct disk_stack *ds;
  void *return_value_g_malloc0_5;
  return_value_g_malloc0_5=g_malloc0(sizeof(struct disk_stack) /*96ul*/ );
  ds = (struct disk_stack *)return_value_g_malloc0_5;
  ds->nlayers = 1;
  ds->disksize = disksize;
  struct disk_image *di;
  void *return_value_g_malloc0_6;
  return_value_g_malloc0_6=g_malloc0(sizeof(struct disk_image) /*40ul*/ );
  di = (struct disk_image *)return_value_g_malloc0_6;
  di->diskfd = diskfd;
  di->path=g_strdup(diskpath);
  unsigned long int nblocks;
  nblocks=get_disk_nblocks(ds->disksize);
  do
  {
    signed long int suffix;
    suffix=random();
    di->bmpath=g_strdup_printf("/dev/shm/xnbd-server-cow-base-%lx.bm", suffix);
    signed int fd;
    fd=open(di->bmpath, 02 | 0100 | 0200, 0600);
    if(!(fd >= 0))
    {
      g_free((void *)di->bmpath);
      continue;
    }

    else
    {
      close(fd);
      break;
    }
  }
  while((_Bool)1);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "create new base bitmap %s", di->bmpath);
  while((_Bool)0);
  unsigned long int tmp_bmlen;
  unsigned long int *tmp_bm;
  tmp_bm=bitmap_open_file(di->bmpath, nblocks, &tmp_bmlen, 0, 1);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "bitmap file %s filled by 1", di->bmpath);
  while((_Bool)0);
  memset((void *)tmp_bm, 0xff, tmp_bmlen);
  bitmap_close_file(tmp_bm, tmp_bmlen);
  di->bm=bitmap_open_file(di->bmpath, nblocks, &di->bmlen, 1, 0);
  unlink(di->bmpath);
  ds->image[(signed long int)0] = di;
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "disk_stack[0] %s %s", di->path, di->bmpath);
  while((_Bool)0);
  return ds;
}

// create_disk_stack_io
// file xnbd_target_cow_lzo.c line 401
static struct disk_stack_io * create_disk_stack_io(struct disk_stack *ds)
{
  struct disk_stack_io *io;
  void *return_value_g_malloc0_1;
  return_value_g_malloc0_1=g_malloc0(sizeof(struct disk_stack_io) /*112ul*/ );
  io = (struct disk_stack_io *)return_value_g_malloc0_1;
  io->ds = ds;
  return io;
}

// custom_log_handler
// file common.c line 83
void custom_log_handler(const char *log_domain, enum anonymous log_level, const char *message, void *data)
{
  struct custom_log_handler_params *params = (struct custom_log_handler_params *)data;
  struct _GString *gstring;
  gstring=g_string_new((const char *)(void *)0);
  char *header;
  header=getenv("LOG_HEADER");
  if(!(header == ((char *)NULL)))
    g_string_append(gstring, header);

  char name[20l];
  signed int ret;
  ret=prctl(16, (unsigned long int)name);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) PR_GET_NAME, %m", return_value_pthread_self_1, (const void *)"custom_log_handler");

  __CPROVER_DUMP_L3:
    ;
    goto __CPROVER_DUMP_L3;
  }

  g_string_append(gstring, name);
  g_string_append(gstring, "(");
  signed int pid;
  pid=getpid();
  signed int tid;
  signed long int return_value_syscall_2;
  return_value_syscall_2=syscall((signed long int)186);
  tid = (signed int)return_value_syscall_2;
  if(pid == tid)
    g_string_append_printf(gstring, "%d", pid);

  else
    g_string_append_printf(gstring, "%d.%d", pid, tid);
  g_string_append(gstring, ") ");
  if(!(log_domain == ((const char *)NULL)))
  {
    g_string_append(gstring, log_domain);
    g_string_append(gstring, ">");
  }

  switch((signed int)log_level & G_LOG_LEVEL_MASK)
  {
    case G_LOG_LEVEL_ERROR:
    {
      g_string_append(gstring, "ERR");
      break;
    }
    case G_LOG_LEVEL_CRITICAL:
    {
      g_string_append(gstring, "CRIT");
      break;
    }
    case G_LOG_LEVEL_WARNING:
    {
      g_string_append(gstring, "WARN");
      break;
    }
    case G_LOG_LEVEL_MESSAGE:
    {
      g_string_append(gstring, "msg");
      break;
    }
    case G_LOG_LEVEL_INFO:
    {
      g_string_append(gstring, "info");
      break;
    }
    case G_LOG_LEVEL_DEBUG:
    {
      g_string_append(gstring, "dbg");
      break;
    }
    default:
      g_string_append(gstring, "log");
  }
  if(!((G_LOG_FLAG_RECURSION & (signed int)log_level) == 0))
    g_string_append(gstring, " (recursed)");

  g_string_append(gstring, ": ");
  if(!(message == ((const char *)NULL)))
    g_string_append(gstring, message);

  else
    g_string_append(gstring, "(NULL) message");
  signed int is_fatal = (signed int)(((signed int)log_level & G_LOG_FLAG_FATAL) != 0);
  if(!(is_fatal == 0))
    g_string_append(gstring, "\naborting...\n");

  else
    g_string_append(gstring, "\n");
  signed int return_value_syslog_level_3;
  if(!(params == ((struct custom_log_handler_params *)NULL)))
  {
    if(!(params->use_syslog == 0))
    {
      return_value_syslog_level_3=syslog_level((signed int)log_level);
      syslog(return_value_syslog_level_3, "%s", gstring->str);
    }

    if(!(params->use_fd == 0))
    {
      do
        if(params->fd == -1)
          g_assertion_message_expr((char *)0, "common.c", 188, (const char *)"custom_log_handler", "params->fd != -1");

      while((_Bool)0);
      write(params->fd, (const void *)gstring->str, gstring->len);
    }

  }

  else
    write(2, (const void *)gstring->str, gstring->len);
  g_string_free(gstring, (signed int)!(0 != 0));
}

// destroy_disk_stack
// file xnbd_target_cow_lzo.c line 255
void destroy_disk_stack(struct disk_stack *ds)
{
  signed int i = 0;
  for( ; !(i >= ds->nlayers); i = i + 1)
  {
    struct disk_image *di = ds->image[(signed long int)i];
    close(di->diskfd);
    if(!(di->bm == ((unsigned long int *)NULL)))
    {
      signed int ret;
      ret=msync((void *)di->bm, di->bmlen, 4);
      if(!(ret >= 0))
      {
        unsigned long int return_value_pthread_self_1;
        return_value_pthread_self_1=pthread_self();
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) msync", return_value_pthread_self_1, (const void *)"destroy_disk_stack");

      __CPROVER_DUMP_L3:
        ;
        goto __CPROVER_DUMP_L3;
      }

      munmap_or_abort((void *)di->bm, di->bmlen);
    }

    g_free((void *)di->path);
    g_free((void *)di->bmpath);
    g_free((void *)di);
  }
  g_free((void *)ds);
}

// disk_stack_add_image
// file xnbd_target_cow_lzo.c line 279
void disk_stack_add_image(struct disk_stack *ds, char *diskpath, signed int newfile)
{
  signed int diskfd;
  signed long int disksize;
  if(ds->nlayers == 10)
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) no space", return_value_pthread_self_1, (const void *)"disk_stack_add_image");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  diskfd=open(diskpath, 02 | 0100, 0644);
  if(!(diskfd >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 75)
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "enable large file support!");
      while((_Bool)0);

    unsigned long int return_value_pthread_self_3;
    return_value_pthread_self_3=pthread_self();
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open, %s", return_value_pthread_self_3, (const void *)"disk_stack_add_image", return_value_strerror_5);

  __CPROVER_DUMP_L6:
    ;
    goto __CPROVER_DUMP_L6;
  }

  disksize=get_disksize(diskfd);
  if(!(disksize == ds->disksize))
  {
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "ftruncate %s (%ju -> %ju)", diskpath, disksize, ds->disksize);
    while((_Bool)0);
    signed int ret;
    ret=ftruncate(diskfd, ds->disksize);
    if(!(ret >= 0))
    {
      unsigned long int return_value_pthread_self_6;
      return_value_pthread_self_6=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) ftruncate", return_value_pthread_self_6, (const void *)"disk_stack_add_image");

    __CPROVER_DUMP_L10:
      ;
      goto __CPROVER_DUMP_L10;
    }

  }

  struct disk_image *di;
  void *return_value_g_malloc0_7;
  return_value_g_malloc0_7=g_malloc0(sizeof(struct disk_image) /*40ul*/ );
  di = (struct disk_image *)return_value_g_malloc0_7;
  di->diskfd = diskfd;
  di->path=g_strdup(diskpath);
  di->bmpath=g_strdup_printf("%s.bm", diskpath);
  unsigned long int return_value_get_disk_nblocks_8;
  unsigned long int return_value_get_disk_nblocks_9;
  if(!(newfile == 0))
  {
    return_value_get_disk_nblocks_8=get_disk_nblocks(ds->disksize);
    di->bm=bitmap_open_file(di->bmpath, return_value_get_disk_nblocks_8, &di->bmlen, 0, 1);
  }

  else
  {
    return_value_get_disk_nblocks_9=get_disk_nblocks(ds->disksize);
    di->bm=bitmap_open_file(di->bmpath, return_value_get_disk_nblocks_9, &di->bmlen, 1, 0);
  }
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "disk_stack[%d] %s %s", ds->nlayers, di->path, di->bmpath);
  while((_Bool)0);
  ds->image[(signed long int)ds->nlayers] = di;
  ds->nlayers = ds->nlayers + 1;
}

// disk_stack_mmap
// file xnbd.h line 120
struct disk_stack_io * disk_stack_mmap(struct disk_stack *ds, signed long int iofrom, unsigned long int iolen, signed int reading)
{
  unsigned long int index_start;
  unsigned long int index_end;
  get_io_range_index(iofrom, iolen, &index_start, &index_end);

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;
  signed long int mapping_start = (signed long int)index_start * (signed long int)CBLOCKSIZE;
  unsigned long int mapping_length = ((index_end - index_start) + (unsigned long int)1) * (unsigned long int)CBLOCKSIZE;

__CPROVER_DUMP_L3:
  ;
  struct disk_stack_io *io;
  io=create_disk_stack_io(ds);
  signed int disk_stack_mmap__1__4__i = 0;
  for( ; !(disk_stack_mmap__1__4__i >= ds->nlayers); disk_stack_mmap__1__4__i = disk_stack_mmap__1__4__i + 1)
  {
    struct disk_image *disk_stack_mmap__1__4__1__di = ds->image[(signed long int)disk_stack_mmap__1__4__i];
    signed int flags = 0x1;
    if(disk_stack_mmap__1__4__i == ds->nlayers + -1)
      flags = flags | 0x2;

    void *return_value_mmap_1;
    return_value_mmap_1=mmap((void *)0, mapping_length, flags, 0x01, disk_stack_mmap__1__4__1__di->diskfd, mapping_start);
    io->bufs[(signed long int)disk_stack_mmap__1__4__i] = (char *)return_value_mmap_1;
    if(io->bufs[(signed long int)disk_stack_mmap__1__4__i] == (char *)-1)
    {
      unsigned long int return_value_pthread_self_2;
      return_value_pthread_self_2=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) mmap, %m", return_value_pthread_self_2, (const void *)"disk_stack_mmap");

    __CPROVER_DUMP_L7:
      ;
      goto __CPROVER_DUMP_L7;
    }

    io->buflen = mapping_length;

  __CPROVER_DUMP_L9:
    ;
  }
  struct iovec *iov = (struct iovec *)(void *)0;
  unsigned int iov_size = (unsigned int)0;
  signed int return_value_bitmap_test_7;
  signed int return_value_bitmap_test_8;
  if(!(reading == 0))
  {
    do
      if(1ul + index_end + -index_start >= 4294967296ul)
        g_assertion_message_expr((char *)0, "xnbd_target_cow_lzo.c", 464, (const char *)"disk_stack_mmap", "(index_end - index_start + 1) <= UINT32_MAX");

    while((_Bool)0);
    iov_size = (unsigned int)((index_end - index_start) + (unsigned long int)1);
    void *return_value_g_malloc0_n_3;
    return_value_g_malloc0_n_3=g_malloc0_n((unsigned long int)iov_size, sizeof(struct iovec) /*16ul*/ );
    iov = (struct iovec *)return_value_g_malloc0_n_3;
    unsigned long int disk_stack_mmap__1__5__2__index = index_start;
    for( ; index_end >= disk_stack_mmap__1__5__2__index; disk_stack_mmap__1__5__2__index = disk_stack_mmap__1__5__2__index + 1ul)
    {
      unsigned long int disk_stack_mmap__1__5__2__1__iofrom_inbuf = (unsigned long int)0;
      unsigned long int iolen_inbuf = (unsigned long int)0;
      disk_stack_mmap__1__5__2__1__iofrom_inbuf = (unsigned long int)((signed long int)disk_stack_mmap__1__5__2__index * (signed long int)CBLOCKSIZE - mapping_start);
      iolen_inbuf = (unsigned long int)CBLOCKSIZE;
      if(index_start == index_end)
      {
        disk_stack_mmap__1__5__2__1__iofrom_inbuf = (unsigned long int)(iofrom - mapping_start);
        iolen_inbuf = iolen;
      }

      else
        if(disk_stack_mmap__1__5__2__index == index_start)
        {
          disk_stack_mmap__1__5__2__1__iofrom_inbuf = (unsigned long int)(iofrom - mapping_start);
          iolen_inbuf = (unsigned long int)CBLOCKSIZE - disk_stack_mmap__1__5__2__1__iofrom_inbuf;
        }

        else
          if(disk_stack_mmap__1__5__2__index == index_end)
          {
            disk_stack_mmap__1__5__2__1__iofrom_inbuf = (unsigned long int)((signed long int)disk_stack_mmap__1__5__2__index * (signed long int)CBLOCKSIZE - mapping_start);
            iolen_inbuf = (unsigned long int)(((unsigned long int)iofrom + iolen) - disk_stack_mmap__1__5__2__index * (unsigned long int)CBLOCKSIZE);
          }


    __CPROVER_DUMP_L17:
      ;
      signed int found = 0;
      signed int disk_stack_mmap__1__5__2__1__4__i = ds->nlayers - 1;
      for( ; disk_stack_mmap__1__5__2__1__4__i >= 0; disk_stack_mmap__1__5__2__1__4__i = disk_stack_mmap__1__5__2__1__4__i - 1)
      {
        struct disk_image *di = ds->image[(signed long int)disk_stack_mmap__1__5__2__1__4__i];
        signed int return_value_bitmap_test_4;
        return_value_bitmap_test_4=bitmap_test(di->bm, disk_stack_mmap__1__5__2__index);
        if(!(return_value_bitmap_test_4 == 0))
        {

        __CPROVER_DUMP_L19:
          ;
          (iov + (signed long int)(disk_stack_mmap__1__5__2__index - index_start))->iov_base = (void *)(io->bufs[(signed long int)disk_stack_mmap__1__5__2__1__4__i] + (signed long int)disk_stack_mmap__1__5__2__1__iofrom_inbuf);
          (iov + (signed long int)(disk_stack_mmap__1__5__2__index - index_start))->iov_len = iolen_inbuf;
          found = 1;
          break;
        }

      }
      if(found == 0)
      {
        unsigned long int return_value_pthread_self_5;
        return_value_pthread_self_5=pthread_self();
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bug", return_value_pthread_self_5, (const void *)"disk_stack_mmap");

      __CPROVER_DUMP_L23:
        ;
        goto __CPROVER_DUMP_L23;
      }

    }
  }

  else
  {
    iov_size = (unsigned int)1;
    void *return_value_g_malloc0_6;
    return_value_g_malloc0_6=g_malloc0(sizeof(struct iovec) /*16ul*/ );
    iov = (struct iovec *)return_value_g_malloc0_6;
    unsigned long int iofrom_inbuf = (unsigned long int)(iofrom - mapping_start);
    (iov + (signed long int)0)->iov_base = (void *)(io->bufs[(signed long int)(ds->nlayers - 1)] + (signed long int)iofrom_inbuf);
    (iov + (signed long int)0)->iov_len = iolen;
    signed int get_start_block = 0;
    signed int get_end_block = 0;
    if(!(iofrom % (signed long int)CBLOCKSIZE == 0l))
    {
      return_value_bitmap_test_7=bitmap_test(ds->image[(signed long int)(ds->nlayers - 1)]->bm, index_start);
      if(return_value_bitmap_test_7 == 0)
        get_start_block = 1;

    }

    if(!((iolen + (unsigned long int)iofrom) % (unsigned long int)CBLOCKSIZE == 0ul))
    {
      if(get_start_block == 0 && index_end == index_start || !(index_start >= index_end))
      {
        return_value_bitmap_test_8=bitmap_test(ds->image[(signed long int)(ds->nlayers - 1)]->bm, index_end);
        if(return_value_bitmap_test_8 == 0)
          get_end_block = 1;

      }

    }

    if(!(get_start_block == 0))
      update_block_with_found(ds, io, index_start, index_start);

    if(!(get_end_block == 0))
      update_block_with_found(ds, io, index_end, index_start);

    unsigned long int index = index_start;
    for( ; index_end >= index; index = index + 1ul)
      bitmap_on(ds->image[(signed long int)(ds->nlayers - 1)]->bm, index);
  }
  unsigned int i = (unsigned int)0;
  for( ; !(i >= iov_size); i = i + 1u)

    __CPROVER_DUMP_L36:
      ;
  io->iov = iov;
  io->iov_size = iov_size;
  return io;
}

// dump_buffer
// file io.c line 104
void dump_buffer(const char *buff, unsigned long int bufflen)
{
  dump_buffer_main(buff, bufflen, 0);
}

// dump_buffer_all
// file lib/io.h line 42
void dump_buffer_all(const char *buff, unsigned long int bufflen)
{
  dump_buffer_main(buff, bufflen, 1);
}

// dump_buffer_main
// file io.c line 70
static void dump_buffer_main(const char *buff, unsigned long int bufflen, signed int all)
{
  unsigned int i;
  if(all == 0 && bufflen >= 129ul)
  {
    i = (unsigned int)0;
    for( ; !(i >= 128u); i = i + 1u)
    {
      if(i % 24u == 0u)
        printf("   ");

      printf("%02x ", (unsigned char)buff[(signed long int)i]);
      if(i % 4u == 3u)
        printf("| ");

      if(i % 24u == 23u)
        printf("\n");

    }
    printf("... (%zu byte)\n", bufflen);
  }

  else
  {
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= bufflen); i = i + 1u)
    {
      if(i % 24u == 0u)
        printf("%4d|| ", i);

      printf("%02x ", (unsigned char)buff[(signed long int)i]);
      if(i % 4u == 3u)
        printf("| ");

      if(i % 24u == 23u)
        printf("\n");

    }
    printf("\n");
  }
}

// fill_random
// file xnbd_tester.c line 27
static void fill_random(char *buff, unsigned long int len)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= len); i = i + 1ul)
  {
    signed long int rvalue;
    rvalue=random();
    buff[(signed long int)i] = (char)rvalue;
  }
}

// fork_or_abort
// file lib/io.h line 45
signed int fork_or_abort(void)
{
  signed int pid;
  pid=fork();
  if(!(pid >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) fork() %m", return_value_pthread_self_1, (const void *)"fork_or_abort");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  return pid;
}

// forwarder_rx_thread_main
// file xnbd_proxy.h line 135
void * forwarder_rx_thread_main(void *arg)
{
  struct xnbd_proxy *proxy = (struct xnbd_proxy *)arg;
  set_process_name("proxy_fwd_rx");
  receiving_failed = 0;
  block_all_signals();
  do
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "create forwarder_rx thread %lu", return_value_pthread_self_1);
  }
  while((_Bool)0);
  do
  {
    signed int ret;
    ret=forwarder_rx_thread_mainloop(proxy);
    if(!(ret >= 0))
      break;

  }
  while((_Bool)1);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "bye forwarder_rx thread");
  while((_Bool)0);
  return (void *)0;
}

// forwarder_rx_thread_mainloop
// file xnbd_proxy_forwarder.c line 295
signed int forwarder_rx_thread_mainloop(struct xnbd_proxy *proxy)
{
  struct xnbd_info *xnbd = proxy->xnbd;
  struct proxy_priv *priv;
  signed int ret;

__CPROVER_DUMP_L1:
  ;
  void *return_value_g_async_queue_pop_1;
  return_value_g_async_queue_pop_1=g_async_queue_pop(proxy->fwd_rx_queue);
  priv = (struct proxy_priv *)return_value_g_async_queue_pop_1;

__CPROVER_DUMP_L2:
  ;
  proxy_priv_dump(priv);
  char *mmaped_buf;
  unsigned long int mmaped_len;
  signed long int mmaped_offset;
  char *iobuf;
  void *return_value_mmap_iorange_2;
  if(priv == &priv_stop_forwarder)
    return -1;

  else
    if(priv->need_exit == 0)
    {
      mmaped_buf = (char *)(void *)0;
      mmaped_len = (unsigned long int)0;
      mmaped_offset = (signed long int)0;
      iobuf = (char *)(void *)0;
      return_value_mmap_iorange_2=mmap_iorange(xnbd->disksize, (const _Bool)0, proxy->cachefd, priv->iofrom, priv->iolen, &mmaped_buf, &mmaped_len, &mmaped_offset);
      iobuf = (char *)return_value_mmap_iorange_2;

    __CPROVER_DUMP_L4:
      ;

    __CPROVER_DUMP_L5:
      ;
      signed int i = 0;
      for( ; !(i >= priv->nreq); i = i + 1)
      {

      __CPROVER_DUMP_L7:
        ;
        signed long int block_iofrom = priv->req[(signed long int)i].bindex_iofrom * (signed long int)CBLOCKSIZE;
        unsigned long int block_iolen = priv->req[(signed long int)i].bindex_iolen * (unsigned long int)CBLOCKSIZE;
        char *iobuf_partial = (char *)(void *)0;
        iobuf_partial = mmaped_buf + (block_iofrom - mmaped_offset);

      __CPROVER_DUMP_L8:
        ;
        ret=nbd_client_recv_read_reply(proxy->remotefd, iobuf_partial, block_iolen);
        if(!(ret >= 0))
        {
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "forwarder: receiving a read reply failed, seqnum %lu", priv->seqnum);
          while((_Bool)0);
          receiving_failed = 1;
          break;
        }

      }
      if(!(receiving_failed == 0))
        priv->need_retry = 1;

      if(priv->need_retry == 0)
      {
        if(priv->iotype == 0u)
          memcpy((void *)priv->read_buff, (const void *)iobuf, priv->iolen);

        else
          if(priv->iotype == 1u)
            memcpy((void *)iobuf, (const void *)priv->write_buff, priv->iolen);

      }

      munmap_or_abort((void *)mmaped_buf, mmaped_len);
      if(priv->need_retry == 0)
        goto got_stop_session;

      g_async_queue_push(proxy->fwd_retry_queue, (void *)priv);
      return 0;
    }

    else
    {
      do

        got_stop_session:
          ;
      while((_Bool)0);
      g_async_queue_push(priv->tx_queue, (void *)priv);

    __CPROVER_DUMP_L16:
      ;
      return 0;
    }
}

// forwarder_tx_thread_main
// file xnbd_proxy.h line 136
void * forwarder_tx_thread_main(void *arg)
{
  struct xnbd_proxy *proxy = (struct xnbd_proxy *)arg;
  signed int sending_failed = 0;
  set_process_name("proxy_fwd_tx");
  block_all_signals();
  do
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "create forwarder_tx thread %lu", return_value_pthread_self_1);
  }
  while((_Bool)0);
  _Bool tmp_if_expr_3;
  do
  {
    struct proxy_priv *priv;
    void *return_value_g_async_queue_pop_2;
    return_value_g_async_queue_pop_2=g_async_queue_pop(proxy->fwd_tx_queue);
    priv = (struct proxy_priv *)return_value_g_async_queue_pop_2;

  __CPROVER_DUMP_L3:
    ;
    if(priv == &priv_stop_forwarder)
    {
      g_async_queue_push(proxy->fwd_rx_queue, (void *)priv);
      break;
    }

    if(!(priv->need_exit == 0))
      g_async_queue_push(proxy->fwd_rx_queue, (void *)priv);

    else
    {
      if(priv->prepare_done == 0)
      {
        if(priv->iotype == 1u)
          prepare_write_priv(proxy, priv);

        else
        {
          if(priv->iotype == 0u)
            tmp_if_expr_3 = (_Bool)1;

          else
            tmp_if_expr_3 = priv->iotype == (unsigned int)3 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_3)
            prepare_read_priv(proxy, priv);

        }
        priv->seqnum = fwd_counter;
        fwd_counter = fwd_counter + (unsigned long int)1;
        priv->prepare_done = 1;
      }

      signed int i = 0;
      for( ; !(i >= priv->nreq); i = i + 1)
      {
        signed long int iofrom = (signed long int)priv->req[(signed long int)i].bindex_iofrom * (signed long int)CBLOCKSIZE;
        unsigned long int length = priv->req[(signed long int)i].bindex_iolen * (unsigned long int)CBLOCKSIZE;
        signed int ret;
        ret=nbd_client_send_read_request(proxy->remotefd, iofrom, length);
        if(!(ret >= 0))
        {
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "sending read request failed, seqnum %lu", priv->seqnum);
          while((_Bool)0);
          sending_failed = 1;
          break;
        }

      }
      if(!(sending_failed == 0))
        priv->need_retry = 1;

      g_async_queue_push(proxy->fwd_rx_queue, (void *)priv);
    }
  }
  while((_Bool)1);
  do
  {

  out_of_loop:
    ;
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "bye forwarder_tx thread");
  }
  while((_Bool)0);
  return (void *)0;
}

// free_disk_stack_io
// file xnbd.h line 121
void free_disk_stack_io(struct disk_stack_io *io)
{
  signed int i = 0;
  for( ; !(i >= io->ds->nlayers); i = i + 1)
    munmap_or_abort((void *)io->bufs[(signed long int)i], io->buflen);
  g_free((void *)io->iov);
  g_free((void *)io);
}

// g_async_queue_push_unshift
// file xnbd_proxy.c line 529
static void g_async_queue_push_unshift(struct _GAsyncQueue *queue, void *data)
{
  g_async_queue_push_sorted(queue, data, unshift_func, (void *)0);
}

// get_disk_nblocks
// file xnbd_common.c line 183
unsigned long int get_disk_nblocks(signed long int disksize)
{
  if(!(disksize % (signed long int)CBLOCKSIZE == 0l))
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "disksize is not a multiple of CBLOCKSIZE");
    while((_Bool)0);

  signed long int nblocks64 = disksize / (signed long int)CBLOCKSIZE + (signed long int)(disksize % (signed long int)CBLOCKSIZE != 0l ? 1U : 0U);
  return (unsigned long int)nblocks64;
}

// get_disksize
// file lib/io.h line 47
signed long int get_disksize(signed int fd)
{
  struct stat st;
  signed long int disksize = (signed long int)0;
  signed int ret;
  ret=fstat(fd, &st);
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 75)
    {
      unsigned long int return_value_pthread_self_1;
      return_value_pthread_self_1=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) enable 64bit offset support", return_value_pthread_self_1, (const void *)"get_disksize");

    __CPROVER_DUMP_L2:
      ;
      goto __CPROVER_DUMP_L2;
    }

  }

  signed long int return_value_lseek_5;
  if((61440u & st.st_mode) == 32768u)
  {
    disksize = st.st_size;
    return disksize;
  }

  else
    if((61440u & st.st_mode) == 24576u)
    {
      disksize=lseek(fd, (signed long int)0, 2);
      if(!(disksize >= 0l))
      {
        unsigned long int return_value_pthread_self_3;
        return_value_pthread_self_3=pthread_self();
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) lseek failed: %d", return_value_pthread_self_3, (const void *)"get_disksize", *return_value___errno_location_4);

      __CPROVER_DUMP_L7:
        ;
        goto __CPROVER_DUMP_L7;
      }

      return disksize;
    }

    else
      if((61440u & st.st_mode) == 8192u)
      {
        unsigned int return_value_gnu_dev_major_6;
        return_value_gnu_dev_major_6=gnu_dev_major(st.st_rdev);
        if(return_value_gnu_dev_major_6 == 259u)
        {
          return_value_lseek_5=lseek(fd, (signed long int)0, 2);
          return return_value_lseek_5;
        }

      }

      else
      {
        unsigned long int return_value_pthread_self_7;
        return_value_pthread_self_7=pthread_self();
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) file type %d not supported", return_value_pthread_self_7, (const void *)"get_disksize", st.st_mode);

      __CPROVER_DUMP_L12:
        ;
        goto __CPROVER_DUMP_L12;
      }
  unsigned long int return_value_pthread_self_8;
  return_value_pthread_self_8=pthread_self();
  g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) failed to detect disk size", return_value_pthread_self_8, (const void *)"get_disksize");

__CPROVER_DUMP_L14:
  ;
  goto __CPROVER_DUMP_L14;
  return (signed long int)0;
}

// get_disksize_of_path
// file lib/io.h line 48
signed long int get_disksize_of_path(const char *path)
{
  signed int fd;
  fd=open(path, 00);
  if(!(fd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) disk open, %s", return_value_pthread_self_1, (const void *)"get_disksize_of_path", path);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  signed long int disksize;
  disksize=get_disksize(fd);
  close(fd);
  return disksize;
}

// get_event_connecter
// file io.c line 344
void get_event_connecter(signed int *notifier, signed int *listener)
{
  make_pipe(notifier, listener);
}

// get_io_range_index
// file xnbd.h line 237
void get_io_range_index(signed long int iofrom, unsigned long int iolen, unsigned long int *index_start, unsigned long int *index_end)
{
  calc_block_index(CBLOCKSIZE, iofrom, iolen, index_start, index_end);
}

// get_line
// file io.c line 200
char * get_line(signed int fd)
{
  signed int found_eol = 0;
  char *line;
  void *return_value_g_malloc0_1;
  return_value_g_malloc0_1=g_malloc0((unsigned long int)100);
  line = (char *)return_value_g_malloc0_1;

__CPROVER_DUMP_L1:
  ;
  signed int i = 0;
  for( ; !(i >= 100); i = i + 1)
  {
    char ch = (char)48;
    signed int ret;
    signed long int return_value_read_2;
    return_value_read_2=read(fd, (void *)&ch, (unsigned long int)1);
    ret = (signed int)return_value_read_2;
    if(ret == 0)
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "get_line: peer closed");
      while((_Bool)0);
      goto err_eof;
    }

    else
      if(ret == -1)
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(*return_value___errno_location_4 == 104)
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "get_line: peer closed (%m)");
          while((_Bool)0);

        else
          do
          {
            signed int *return_value___errno_location_3;
            return_value___errno_location_3=__errno_location();
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "get_line: err %d (%m)", *return_value___errno_location_3);
          }
          while((_Bool)0);
        goto err_eof;
      }


  __CPROVER_DUMP_L8:
    ;
    if((signed int)ch == 10)
    {
      found_eol = 1;
      break;
    }

    line[(signed long int)i] = ch;
  }
  if(found_eol == 0)
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "no eol found before MAX_LINE(%d)", 100);
    while((_Bool)0);

  else
  {

  __CPROVER_DUMP_L12:
    ;
    return line;
  }

err_eof:

  err:
    ;
  g_free((void *)line);
  return (char *)(void *)0;
}

// get_log_fd
// file xnbd_common.c line 201
signed int get_log_fd(const char *path)
{
  signed int fd;
  fd=open(path, 01 | 0100 | 02000, 0400 | 0200);
  if(!(fd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open %s, %m", return_value_pthread_self_1, (const void *)"get_log_fd", path);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  return fd;
}

// get_nameinfo_string
// file net.c line 29
static char * get_nameinfo_string(struct addrinfo *ai)
{
  signed int ret;
  char hbuf[1025l];
  char sbuf[32l];
  ret=getnameinfo(ai->ai_addr, ai->ai_addrlen, hbuf, (unsigned int)sizeof(char [1025l]) /*1025ul*/ , sbuf, (unsigned int)sizeof(char [32l]) /*32ul*/ , 1 | 2);
  if(!(ret == 0))
    do
    {
      const char *return_value_gai_strerror_1;
      return_value_gai_strerror_1=gai_strerror(ret);
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "getnameinfo failed, %s", return_value_gai_strerror_1);
    }
    while((_Bool)0);

  const char *type = "unknown_ai_socktype";
  if(ai->ai_protocol == 6)
    type = "TCP";

  else
    if(ai->ai_protocol == 17)
      type = "UDP";

    else
      if(ai->ai_protocol == 132)
        type = "SCTP";

      else
        if(ai->ai_protocol == 33)
          type = "DCCP";

  char *return_value_g_strdup_printf_2;
  char *return_value_g_strdup_printf_3;
  if(ai->ai_family == 2)
  {
    return_value_g_strdup_printf_2=g_strdup_printf("%s:%s,%s", (const void *)hbuf, (const void *)sbuf, type);
    return return_value_g_strdup_printf_2;
  }

  else
  {
    return_value_g_strdup_printf_3=g_strdup_printf("[%s]:%s,%s", (const void *)hbuf, (const void *)sbuf, type);
    return return_value_g_strdup_printf_3;
  }
}

// get_session_from_read_fd
// file xnbd_proxy.c line 411
struct proxy_session * get_session_from_read_fd(struct _GList *list_head, signed int fd)
{
  struct _GList *list;
  list=g_list_first(list_head);
  struct _GList *tmp_if_expr_1;
  for( ; !(list == ((struct _GList *)NULL)); list = tmp_if_expr_1)
  {
    struct proxy_session *ps = (struct proxy_session *)list->data;
    if(ps->pipe_read_fd == fd)
      return ps;

    if(!(list == ((struct _GList *)NULL)))
      tmp_if_expr_1 = ((struct _GList *)list)->next;

    else
      tmp_if_expr_1 = (struct _GList *)(void *)0;
  }
  return (struct proxy_session *)(void *)0;
}

// io_all
// file io.c line 26
static void io_all(signed int fd, void *buf, unsigned long int len, signed int read_ops)
{
  signed int next_len = (signed int)len;
  char *next_buf = (char *)buf;
  const char *mode = read_ops != 0 ? "read" : "write";
  unsigned long int total = (unsigned long int)0;
  signed long int return_value_read_1;
  signed long int return_value_write_2;
  do
  {
    signed int ret = 0;
    if(!(read_ops == 0))
    {
      return_value_read_1=read(fd, (void *)next_buf, (unsigned long int)next_len);
      ret = (signed int)return_value_read_1;
    }

    else
    {
      return_value_write_2=write(fd, (const void *)next_buf, (unsigned long int)next_len);
      ret = (signed int)return_value_write_2;
    }
    if(ret == 0)
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "%s() returned 0 (fd %d)", mode, fd);

    if(ret == -1)
    {
      unsigned long int return_value_pthread_self_3;
      return_value_pthread_self_3=pthread_self();
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) %s error %s (%d) (fd %d)", return_value_pthread_self_3, (const void *)"io_all", mode, return_value_strerror_5, *return_value___errno_location_6, fd);

    __CPROVER_DUMP_L6:
      ;
      goto __CPROVER_DUMP_L6;
    }

    total = total + (unsigned long int)ret;
    next_len = next_len - ret;
    next_buf = next_buf + (signed long int)ret;
    if(total == len)
      break;

  }
  while((_Bool)1);
}

// main
// file xnbd_tester.c line 622
signed int main(signed int argc, char **argv)
{
  enum xnbd_tester_rwmode rwmode = (enum xnbd_tester_rwmode)TESTRDONLY;
  signed int cowmode = 0;
  char *bgctlpath = (char *)(void *)0;
  signed int return_value_atoi_1;
  do
  {
    signed int c;
    signed int index = 0;
    c=getopt_long(argc, argv, "tphB:cm:", longopts, &index);
    if(c == -1)
      break;

    switch(c)
    {
      case 109:
      {
        return_value_atoi_1=atoi(optarg);
        rwmode = (enum xnbd_tester_rwmode)return_value_atoi_1;
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "rw mode (%d)", rwmode);
        while((_Bool)0);
        break;
      }
      case 99:
      {
        cowmode = 1;
        CoWID=atoi(optarg);
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "copy-on-write enabled, cowid %d", CoWID);
        while((_Bool)0);
        break;
      }
      case 66:
      {
        bgctlpath = optarg;
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "enable background copy with %s", optarg);
        while((_Bool)0);
      }
    }
  }
  while((_Bool)1);
  if(!(argc + -optind == 4))
    show_help_and_exit("argument error");

  char *remotehost = argv[(signed long int)optind];
  char *remoteport = argv[(signed long int)(optind + 1)];
  char *srcpath = argv[(signed long int)(optind + 2)];
  char *dstpath = argv[(signed long int)(optind + 3)];
  set_sigactions();
  g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "srcdisk %s dstdisk %s", srcpath, dstpath);
  do
  {
    signed int remotefd;
    remotefd=net_connect(remotehost, remoteport, 1, 6);
    signed int ret;
    ret=test_direct_mode(srcpath, dstpath, remotefd, cowmode, rwmode, bgctlpath);
    if(!(ret >= 0))
      return 1;

    nbd_client_send_disc_request(remotefd);
    close(remotefd);
  }
  while((_Bool)1);
  return 0;
}

// main_loop
// file xnbd_proxy.c line 534
signed int main_loop(struct xnbd_proxy *proxy, signed int unix_listen_fd, signed int master_fd)
{
  signed int ret;
  signed long int ret_array_size0;
  unsigned int return_value_g_list_length_1;
  return_value_g_list_length_1=g_list_length(conn_list);
  ret_array_size0 = (signed long int)((unsigned int)2 + return_value_g_list_length_1);
  struct pollfd eventfds[ret_array_size0];
  unsigned long int neventfds = (unsigned long int)0;
  eventfds[(signed long int)neventfds].fd = unix_listen_fd;
  eventfds[(signed long int)neventfds].events = (signed short int)(0x040 | 0x2000);
  neventfds = neventfds + (unsigned long int)1;
  eventfds[(signed long int)neventfds].fd = master_fd;
  eventfds[(signed long int)neventfds].events = (signed short int)(0x040 | 0x2000);
  neventfds = neventfds + (unsigned long int)1;
  struct _GList *list;
  list=g_list_first(conn_list);
  struct _GList *tmp_if_expr_2;
  for( ; !(list == ((struct _GList *)NULL)); list = tmp_if_expr_2)
  {
    struct proxy_session *main_loop__1__1__1__ps = (struct proxy_session *)list->data;
    eventfds[(signed long int)neventfds].fd = main_loop__1__1__1__ps->pipe_read_fd;
    eventfds[(signed long int)neventfds].events = (signed short int)(0x040 | 0x2000);
    neventfds = neventfds + (unsigned long int)1;
    if(!(list == ((struct _GList *)NULL)))
      tmp_if_expr_2 = ((struct _GList *)list)->next;

    else
      tmp_if_expr_2 = (struct _GList *)(void *)0;
  }
  signed int nready;
  nready=poll(eventfds, neventfds, -1);
  if(nready == -1)
  {
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    if(*return_value___errno_location_7 == 4)
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "polling signal cached");
      while((_Bool)0);
      return -1;
    }

    else
    {
      unsigned long int return_value_pthread_self_3;
      return_value_pthread_self_3=pthread_self();
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) polling, %s, (%d)", return_value_pthread_self_3, (const void *)"main_loop", return_value_strerror_5, *return_value___errno_location_6);

    __CPROVER_DUMP_L7:
      ;
      goto __CPROVER_DUMP_L7;
    }
  }

  if(!((8256 & (signed int)eventfds[0l].revents) == 0))
  {
    struct sockaddr_un cliaddr;
    unsigned int cliaddr_len = (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ ;
    signed int wrk_fd;
    wrk_fd=accept(eventfds[(signed long int)0].fd, &cliaddr, &cliaddr_len);
    if(!(wrk_fd >= 0))
    {
      unsigned long int return_value_pthread_self_8;
      return_value_pthread_self_8=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) accept %m", return_value_pthread_self_8, (const void *)"main_loop");

    __CPROVER_DUMP_L11:
      ;
      goto __CPROVER_DUMP_L11;
    }

    signed int close_wrk_fd = 1;
    enum xnbd_proxy_cmd_type cmd;
    ret=net_recv_all_or_error(wrk_fd, (void *)&cmd, sizeof(enum xnbd_proxy_cmd_type) /*4ul*/ );
    if(!(ret >= 0))
      cmd = (enum xnbd_proxy_cmd_type)XNBD_PROXY_CMD_UNKNOWN;

    switch((signed int)cmd)
    {
      case XNBD_PROXY_CMD_QUERY_STATUS:
      {
        struct xnbd_proxy_query query;
        memset((void *)&query, 0, sizeof(struct xnbd_proxy_query) /*16432ul*/ );
        query.disksize = proxy->xnbd->disksize;
        g_strlcpy(query.diskpath, proxy->xnbd->proxy_diskpath, sizeof(char [4096l]) /*4096ul*/ );
        g_strlcpy(query.bmpath, proxy->xnbd->proxy_bmpath, sizeof(char [4096l]) /*4096ul*/ );
        g_strlcpy(query.rhost, proxy->xnbd->proxy_rhost, sizeof(char [4096l]) /*4096ul*/ );
        g_strlcpy(query.rport, proxy->xnbd->proxy_rport, sizeof(char [4096l]) /*4096ul*/ );
        query.master_pid=getppid();
        query.max_use_buf = proxy->xnbd->proxy_max_buf_size;
        query.cur_use_buf = proxy->cur_use_buf;
        query.max_use_que = proxy->xnbd->proxy_max_que_size;
        query.cur_use_que = proxy->cur_use_que;
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "send current status (wrk_fd %d)", wrk_fd);
        while((_Bool)0);
        net_send_all_or_error(wrk_fd, (const void *)&query, sizeof(struct xnbd_proxy_query) /*16432ul*/ );
        break;
      }
      case XNBD_PROXY_CMD_REGISTER_FD:
      {
        signed int nbd_fd;
        nbd_fd=unix_recv_fd(wrk_fd);
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "create proxy_session (nbd_fd %d wrk_fd %d)", nbd_fd, wrk_fd);
        while((_Bool)0);
        struct proxy_session *main_loop__1__3__2__2__ps;
        void *return_value_g_malloc0_9;
        return_value_g_malloc0_9=g_malloc0(sizeof(struct proxy_session) /*48ul*/ );
        main_loop__1__3__2__2__ps = (struct proxy_session *)return_value_g_malloc0_9;
        main_loop__1__3__2__2__ps->nbd_fd = nbd_fd;
        main_loop__1__3__2__2__ps->wrk_fd = wrk_fd;
        main_loop__1__3__2__2__ps->tx_queue=g_async_queue_new();
        main_loop__1__3__2__2__ps->proxy = proxy;
        main_loop__1__3__2__2__ps->tid_tx=pthread_create_or_abort(tx_thread_main, (void *)main_loop__1__3__2__2__ps);
        main_loop__1__3__2__2__ps->tid_rx=pthread_create_or_abort(rx_thread_main, (void *)main_loop__1__3__2__2__ps);
        make_pipe(&main_loop__1__3__2__2__ps->pipe_write_fd, &main_loop__1__3__2__2__ps->pipe_read_fd);
        conn_list=g_list_append(conn_list, (void *)main_loop__1__3__2__2__ps);
        close_wrk_fd = 0;
        break;
      }
      case XNBD_PROXY_CMD_REGISTER_FORWARDER_FD:
      {
        signed int fwd_fd;
        fwd_fd=unix_recv_fd(wrk_fd);
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "register forwarder fd (nbd_fd %d wrk_fd %d)", fwd_fd, wrk_fd);
        while((_Bool)0);
        proxy_shutdown_forwarder(proxy);
        nbd_client_send_disc_request(proxy->remotefd);
        close(proxy->remotefd);
        do
        {
          struct proxy_priv *priv;
          void *return_value_g_async_queue_try_pop_10;
          return_value_g_async_queue_try_pop_10=g_async_queue_try_pop(proxy->fwd_retry_queue);
          priv = (struct proxy_priv *)return_value_g_async_queue_try_pop_10;
          if(priv == ((struct proxy_priv *)NULL))
            break;

          priv->need_retry = 0;
          g_async_queue_push_unshift(proxy->fwd_tx_queue, (void *)priv);
        }
        while((_Bool)1);
        proxy_initialize_forwarder(proxy, fwd_fd);
        break;
      }
      case XNBD_PROXY_CMD_REGISTER_SHARED_BUFFER_FD:
      {
        if(!(proxy->shared_buff == ((char *)NULL)))
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "shared_buff was already assigned; do nothing");
          while((_Bool)0);

        else
        {
          signed int buf_fd;
          buf_fd=unix_recv_fd(wrk_fd);
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "register shared buffer fd (buf_fd %d wrk_fd %d)", buf_fd, wrk_fd);
          while((_Bool)0);
          void *return_value_mmap_11;
          return_value_mmap_11=mmap((void *)0, (unsigned long int)(CBLOCKSIZE * (unsigned int)1000), 0x1, 0x01, buf_fd, (signed long int)0);
          proxy->shared_buff = (char *)return_value_mmap_11;
          if(proxy->shared_buff == (char *)-1)
          {
            unsigned long int return_value_pthread_self_12;
            return_value_pthread_self_12=pthread_self();
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) mmap, %m", return_value_pthread_self_12, (const void *)"main_loop");

          __CPROVER_DUMP_L28:
            ;
            goto __CPROVER_DUMP_L28;
          }

          close(buf_fd);
        }
        break;
      }
      case XNBD_PROXY_CMD_DETECT_SWITCH:
      {
        close_wrk_fd = 0;
        break;
      }
      case XNBD_PROXY_CMD_UNKNOWN:

      default:
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "unknown proxy cmd %d (wrk_fd %d)", cmd, wrk_fd);
        while((_Bool)0);
    }
    if(!(close_wrk_fd == 0))
      close(wrk_fd);

  }

  _Bool tmp_if_expr_13;
  if(!((8256 & (signed int)eventfds[1l].revents) == 0))
  {
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "mainloop exit is requested");
    while((_Bool)0);
    unsigned int remaining_sessions;
    remaining_sessions=g_list_length(conn_list);
    if(remaining_sessions >= 1u)
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "terminate %u xnbd-bgctl session(s)", remaining_sessions);
      while((_Bool)0);

    if(!(proxy->cur_use_buf == 0ul))
      tmp_if_expr_13 = (_Bool)1;

    else
      tmp_if_expr_13 = proxy->cur_use_que != (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_13)
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "terminate pending requests");
      while((_Bool)0);

    return -1;
  }

  else
  {
    unsigned long int i = (unsigned long int)2;
    for( ; !(i >= neventfds); i = i + 1ul)
      if(!((8256 & (signed int)eventfds[(signed long int)i].revents) == 0))
      {
        signed int pipe_read_fd = eventfds[(signed long int)i].fd;
        struct proxy_session *ps;
        ps=get_session_from_read_fd(conn_list, pipe_read_fd);
        do
          if(ps == ((struct proxy_session *)NULL))
            g_assertion_message_expr((char *)0, "xnbd_proxy.c", 715, (const char *)"main_loop", "ps");

        while((_Bool)0);
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "cleanup proxy_session (nbd_fd %d wrk_fd %d)", ps->nbd_fd, ps->wrk_fd);
        while((_Bool)0);
        pthread_join(ps->tid_rx, (void **)(void *)0);
        pthread_join(ps->tid_tx, (void **)(void *)0);
        do
        {
          signed int return_value_g_async_queue_length_14;
          return_value_g_async_queue_length_14=g_async_queue_length(ps->tx_queue);
          if(!(return_value_g_async_queue_length_14 == 0))
            g_assertion_message_expr((char *)0, "xnbd_proxy.c", 730, (const char *)"main_loop", "g_async_queue_length(ps->tx_queue) == 0");

        }
        while((_Bool)0);
        g_async_queue_unref(ps->tx_queue);
        close(ps->pipe_read_fd);
        close(ps->pipe_write_fd);
        close(ps->nbd_fd);
        signed long int return_value_write_15;
        return_value_write_15=write(ps->wrk_fd, (const void *)"", (unsigned long int)1);
        ret = (signed int)return_value_write_15;
        if(!(ret >= 0))
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "notifying the worker process failed: %m");
          while((_Bool)0);

        close(ps->wrk_fd);
        conn_list=g_list_remove(conn_list, (const void *)ps);
        g_free((void *)ps);
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "cleanup proxy_session done");
        while((_Bool)0);
      }

    return 0;
  }
}

// make_pipe
// file lib/io.h line 61
void make_pipe(signed int *write_fd, signed int *read_fd)
{
  signed int pipefds[2l];
  signed int ret;
  ret=pipe(pipefds);
  if(ret == -1)
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) pipe, %m", return_value_pthread_self_1, (const void *)"make_pipe");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  *write_fd = pipefds[(signed long int)1];
  *read_fd = pipefds[(signed long int)0];
}

// make_sockpair
// file lib/io.h line 62
void make_sockpair(signed int *fd0, signed int *fd1)
{
  signed int sockfds[2l];
  signed int ret;
  ret=socketpair(1, 1, 0, sockfds);
  if(ret == -1)
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) socketpair, %m", return_value_pthread_self_1, (const void *)"make_sockpair");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  *fd0 = sockfds[(signed long int)0];
  *fd1 = sockfds[(signed long int)1];
}

// mem_usage_add
// file xnbd_proxy.c line 112
static void mem_usage_add(struct xnbd_proxy *proxy, struct proxy_priv *priv)
{
  _Bool tmp_if_expr_1;
  do
  {
    if(!(priv->write_buff == ((char *)NULL)))
      tmp_if_expr_1 = priv->read_buff != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      g_assertion_message_expr((char *)0, "xnbd_proxy.c", 115, (const char *)"mem_usage_add", "(priv->write_buff != NULL && priv->read_buff != NULL) == false");

  }
  while((_Bool)0);
  g_mutex_lock(&proxy->curr_use_mutex);
  _Bool tmp_if_expr_2;
  if(!(proxy->xnbd->proxy_max_buf_size == 0ul))
  {
    proxy->cur_use_buf = proxy->cur_use_buf + sizeof(struct proxy_priv) /*624ul*/ ;
    if(!(priv->write_buff == ((char *)NULL)))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = priv->read_buff != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      proxy->cur_use_buf = proxy->cur_use_buf + priv->iolen;

  }

  if(!(proxy->xnbd->proxy_max_que_size == 0ul))
    proxy->cur_use_que = proxy->cur_use_que + (unsigned long int)1;

  g_mutex_unlock(&proxy->curr_use_mutex);
}

// mem_usage_del
// file xnbd_proxy.c line 170
static void mem_usage_del(struct xnbd_proxy *proxy, struct proxy_priv *priv)
{
  g_mutex_lock(&proxy->curr_use_mutex);
  _Bool tmp_if_expr_1;
  if(!(proxy->xnbd->proxy_max_buf_size == 0ul))
  {
    proxy->cur_use_buf = proxy->cur_use_buf - sizeof(struct proxy_priv) /*624ul*/ ;
    if(!(priv->write_buff == ((char *)NULL)))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = priv->read_buff != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      proxy->cur_use_buf = proxy->cur_use_buf - priv->iolen;

  }

  if(!(proxy->xnbd->proxy_max_que_size == 0ul))
    proxy->cur_use_que = proxy->cur_use_que - (unsigned long int)1;

  g_mutex_unlock(&proxy->curr_use_mutex);
}

// mem_usage_wait
// file xnbd_proxy.c line 134
static void mem_usage_wait(struct xnbd_proxy *proxy)
{
  do
  {
    _Bool mem_is_full = (_Bool)0;
    _Bool queue_is_full = (_Bool)0;
    g_mutex_lock(&proxy->curr_use_mutex);
    if(!(proxy->xnbd->proxy_max_buf_size == 0ul))
    {
      if(!(proxy->xnbd->proxy_max_buf_size >= proxy->cur_use_buf))
        mem_is_full = (_Bool)1;

    }

    if(!(proxy->xnbd->proxy_max_que_size == 0ul))
    {
      if(!(proxy->xnbd->proxy_max_que_size >= proxy->cur_use_que))
        queue_is_full = (_Bool)1;

    }

    g_mutex_unlock(&proxy->curr_use_mutex);
    if(mem_is_full == (_Bool)0 && queue_is_full == (_Bool)0)
      break;

    if(!(mem_is_full == (_Bool)0))

      __CPROVER_DUMP_L5:
        ;

    if(!(queue_is_full == (_Bool)0))

      __CPROVER_DUMP_L7:
        ;

    usleep((unsigned int)(200 * 1000));
  }
  while((_Bool)1);
}

// mmap_iorange
// file xnbd_common.c line 107
void * mmap_iorange(const signed long int disksize, const _Bool readonly, const signed int fd, const signed long int iofrom, const unsigned long int iolen, char **mmaped_buf, unsigned long int *mmaped_len, signed long int *mmaped_offset)
{
  unsigned long int index_start;
  unsigned long int index_end;
  char *buf;
  get_io_range_index(iofrom, iolen, &index_start, &index_end);
  signed long int mapping_start = (signed long int)index_start * (signed long int)CBLOCKSIZE;
  unsigned long int mapping_length = ((index_end - index_start) + (unsigned long int)1) * (unsigned long int)CBLOCKSIZE;
  if(!(disksize >= mapping_start + (signed long int)mapping_length))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) exceed disksize", return_value_pthread_self_1, (const void *)"mmap_iorange");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  void *return_value_mmap_2;
  void *return_value_mmap_3;
  if(!(readonly == (_Bool)0))
  {
    return_value_mmap_2=mmap((void *)0, mapping_length, 0x1, 0x01, fd, mapping_start);
    buf = (char *)return_value_mmap_2;
  }

  else
  {
    return_value_mmap_3=mmap((void *)0, mapping_length, 0x1 | 0x2, 0x01, fd, mapping_start);
    buf = (char *)return_value_mmap_3;
  }
  if(buf == (char *)-1)
  {
    unsigned long int return_value_pthread_self_4;
    return_value_pthread_self_4=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) disk mapping failed (iofrom %ju iolen %zu), %m", return_value_pthread_self_4, (const void *)"mmap_iorange", iofrom, iolen);

  __CPROVER_DUMP_L7:
    ;
    goto __CPROVER_DUMP_L7;
  }

  *mmaped_buf = buf;
  *mmaped_len = mapping_length;
  *mmaped_offset = mapping_start;
  char *iobuf = buf + (iofrom - mapping_start);
  return (void *)iobuf;
}

// mmap_partial_map
// file xnbd.h line 216
struct mmap_partial * mmap_partial_map(signed int fd, signed long int iofrom, const unsigned long int iolen_in, signed int readonly)
{
  const signed long int iolen = (const signed long int)iolen_in;
  unsigned long int mmap_length;
  signed long int iofrom_fraction = iofrom % (signed long int)PAGESIZE;
  signed long int mmap_offset = iofrom - iofrom_fraction;
  signed long int ioend_fraction = (iofrom + iolen) % (signed long int)PAGESIZE;
  if(!(ioend_fraction == 0l))
    mmap_length = (unsigned long int)((((iofrom + iolen) - ioend_fraction) + (signed long int)PAGESIZE) - mmap_offset);

  else
    mmap_length = (unsigned long int)((iofrom + iolen) - mmap_offset);
  unsigned long int inds;
  unsigned long int inde;
  calc_block_index(PAGESIZE, iofrom, iolen_in, &inds, &inde);
  if(!((signed long int)PAGESIZE * (signed long int)inds == mmap_offset))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) check failed 0: %ju, %ju", return_value_pthread_self_1, (const void *)"mmap_partial_map", (signed long int)inds * (signed long int)PAGESIZE, mmap_offset);

  __CPROVER_DUMP_L4:
    ;
    goto __CPROVER_DUMP_L4;
  }

  unsigned long int mmap_len2 = ((inde - inds) + (unsigned long int)1) * (unsigned long int)(unsigned int)PAGESIZE;
  if(!(mmap_len2 == mmap_length))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) check failed 1: %zu, %zu", return_value_pthread_self_2, (const void *)"mmap_partial_map", mmap_len2, mmap_length);

  __CPROVER_DUMP_L7:
    ;
    goto __CPROVER_DUMP_L7;
  }

  char *buf = (char *)(void *)0;
  void *return_value_mmap_3;
  void *return_value_mmap_4;
  if(!(readonly == 0))
  {
    return_value_mmap_3=mmap((void *)0, mmap_length, 0x1, 0x01, fd, mmap_offset);
    buf = (char *)return_value_mmap_3;
  }

  else
  {
    return_value_mmap_4=mmap((void *)0, mmap_length, 0x1 | 0x2, 0x01, fd, mmap_offset);
    buf = (char *)return_value_mmap_4;
  }
  if(buf == (char *)-1)
  {
    unsigned long int return_value_pthread_self_5;
    return_value_pthread_self_5=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) disk mapping failed (iofrom %ju iolen %zu), %m", return_value_pthread_self_5, (const void *)"mmap_partial_map", iofrom, iolen);

  __CPROVER_DUMP_L12:
    ;
    goto __CPROVER_DUMP_L12;
  }

  struct mmap_partial *mpinfo;
  void *return_value_g_malloc_6;
  return_value_g_malloc_6=g_malloc(sizeof(struct mmap_partial) /*32ul*/ );
  mpinfo = (struct mmap_partial *)return_value_g_malloc_6;
  mpinfo->buf = (void *)buf;
  mpinfo->len = mmap_length;
  mpinfo->offset = mmap_offset;
  mpinfo->iobuf = (void *)(buf + iofrom_fraction);
  return mpinfo;
}

// mmap_partial_unmap
// file xnbd.h line 217
void mmap_partial_unmap(struct mmap_partial *mpinfo)
{
  munmap_or_abort(mpinfo->buf, mpinfo->len);
  g_free((void *)mpinfo);
}

// munmap_or_abort
// file lib/io.h line 65
void munmap_or_abort(void *addr, unsigned long int len)
{
  signed int ret;
  ret=munmap(addr, len);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) munmap %m", return_value_pthread_self_1, (const void *)"munmap_or_abort");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

}

// nbd_client_recv_header
// file lib/nbd.h line 104
signed int nbd_client_recv_header(signed int remotefd)
{
  struct nbd_reply reply;

__CPROVER_DUMP_L1:
  ;
  memset((void *)&reply, 0, sizeof(struct nbd_reply) /*16ul*/ );
  signed int ret;
  ret=net_recv_all_or_error(remotefd, (void *)&reply, sizeof(struct nbd_reply) /*16ul*/ );
  if(!(ret >= 0))
  {
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "proxy error: redirect tcp down");
    while((_Bool)0);
    return -32;
  }

  else
  {
    unsigned int return_value_ntohl_2;
    return_value_ntohl_2=ntohl(reply.magic);
    if(!(return_value_ntohl_2 == 1732535960u))
    {
      do
      {
        unsigned int return_value_ntohl_1;
        return_value_ntohl_1=ntohl(reply.magic);
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "proxy error: unknown reply magic, %x %x", reply.magic, return_value_ntohl_1);
      }
      while((_Bool)0);
      return -32;
    }

    else
    {
      unsigned long int return_value___bswap_64_4;
      return_value___bswap_64_4=__bswap_64_link1(myhandle);
      if(!(reply.handle == return_value___bswap_64_4))
      {
        do
        {
          unsigned long int return_value___bswap_64_3;
          return_value___bswap_64_3=__bswap_64_link1(myhandle);
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "proxy error: unknown reply handle, %ju %ju", reply.handle, return_value___bswap_64_3);
        }
        while((_Bool)0);
        return -32;
      }

      else
      {
        unsigned int error;
        error=ntohl(reply.error);
        if(!(error == 0u))
        {
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "proxy error: remote internal, reply state %d", error);
          while((_Bool)0);
          return (signed int)-error;
        }

        else
          return 0;
      }
    }
  }
}

// nbd_client_recv_read_reply
// file lib/nbd.h line 103
signed int nbd_client_recv_read_reply(signed int remotefd, char *buf, unsigned long int len)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(buf == ((char *)NULL))
      g_assertion_message_expr((char *)0, "nbd.c", 195, (const char *)"nbd_client_recv_read_reply", "buf");

  while((_Bool)0);
  do
    if(len >= 4294967296ul)
      g_assertion_message_expr((char *)0, "nbd.c", 196, (const char *)"nbd_client_recv_read_reply", "len <= UINT32_MAX");

  while((_Bool)0);
  struct iovec iov[1l];
  iov[(signed long int)0].iov_base = (void *)buf;
  iov[(signed long int)0].iov_len = len;
  signed int return_value_nbd_client_recv_read_reply_iov_1;
  return_value_nbd_client_recv_read_reply_iov_1=nbd_client_recv_read_reply_iov(remotefd, iov, (unsigned int)1);
  return return_value_nbd_client_recv_read_reply_iov_1;
}

// nbd_client_recv_read_reply_iov
// file nbd.c line 171
signed int nbd_client_recv_read_reply_iov(signed int remotefd, struct iovec *iov, unsigned int count)
{
  signed int ret;
  ret=nbd_client_recv_header(remotefd);
  if(!(ret >= 0))
  {
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "recv header");
    while((_Bool)0);
    return -32;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    ret=net_readv_all_or_error(remotefd, iov, count);
    if(!(ret >= 0))
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "recv data");
      while((_Bool)0);
      return -32;
    }

    else
      return 0;
  }
}

// nbd_client_send_disc_request
// file lib/nbd.h line 101
void nbd_client_send_disc_request(signed int remotefd)
{
  struct nbd_request request;
  signed int ret;
  memset((void *)&request, 0, sizeof(struct nbd_request) /*28ul*/ );
  request.magic=htonl((unsigned int)0x25609513);
  request.type=htonl((unsigned int)2);
  signed long int return_value_net_send_all_1;
  return_value_net_send_all_1=net_send_all(remotefd, (const void *)&request, sizeof(struct nbd_request) /*28ul*/ );
  ret = (signed int)return_value_net_send_all_1;
  if(!((signed long int)ret >= (signed long int)sizeof(struct nbd_request) /*28l*/ ))
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "sending NBD_DISC failed");
    while((_Bool)0);

}

// nbd_client_send_read_request
// file lib/nbd.h line 100
signed int nbd_client_send_read_request(signed int remotefd, signed long int iofrom, unsigned long int len)
{

__CPROVER_DUMP_L1:
  ;
  signed int return_value_nbd_client_send_request_header_1;
  return_value_nbd_client_send_request_header_1=nbd_client_send_request_header(remotefd, (unsigned int)0, iofrom, len, myhandle);
  return return_value_nbd_client_send_request_header_1;
}

// nbd_client_send_request_header
// file lib/nbd.h line 99
signed int nbd_client_send_request_header(signed int remotefd, unsigned int iotype, signed long int iofrom, unsigned long int len, unsigned long int handle)
{
  do
    if(len >= 4294967296ul)
      g_assertion_message_expr((char *)0, "nbd.c", 66, (const char *)"nbd_client_send_request_header", "len <= UINT32_MAX");

  while((_Bool)0);
  do
    if(len + (unsigned long int)iofrom >= 9223372036854775808ul)
      g_assertion_message_expr((char *)0, "nbd.c", 67, (const char *)"nbd_client_send_request_header", "iofrom + len <= OFF_MAX");

  while((_Bool)0);
  do
    if(!(iofrom >= 0l))
      g_assertion_message_expr((char *)0, "nbd.c", 68, (const char *)"nbd_client_send_request_header", "iofrom >= 0");

  while((_Bool)0);

__CPROVER_DUMP_L10:
  ;
  struct nbd_request request;
  memset((void *)&request, 0, sizeof(struct nbd_request) /*28ul*/ );
  request.magic=htonl((unsigned int)0x25609513);
  request.type=htonl(iotype);
  request.from=__bswap_64_link1((unsigned long int)iofrom);
  request.len=htonl((unsigned int)len);
  request.handle=__bswap_64_link1(handle);
  signed long int ret;
  ret=net_send_all(remotefd, (const void *)&request, sizeof(struct nbd_request) /*28ul*/ );
  if(!(ret >= (signed long int)sizeof(struct nbd_request) /*28l*/ ))
  {
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "sending a nbd client header failed");
    while((_Bool)0);
    return -1;
  }

  else
    return 0;
}

// nbd_get_iotype_string
// file lib/nbd.h line 72
const char * nbd_get_iotype_string(unsigned int iotype)
{
  const char *nbd_iotype_string_table[7l] = { "NBD_CMD_READ", "NBD_CMD_WRITE", "NBD_CMD_DISC", "NBD_CMD_BGCOPY", "NBD_CMD_READ_COMPRESS", "NBD_CMD_READ_COMPRESS_LZO", "NBD_CMD_UNDEFINED" };
  if((unsigned long int)iotype >= 7ul)
    return "NBD_CMD_UNDEFINED";

  else
    return nbd_iotype_string_table[(signed long int)iotype];
}

// nbd_negotiate_with_client
// file nbd.c line 573
signed int nbd_negotiate_with_client(signed int sockfd, signed long int exportsize)
{
  signed int return_value_nbd_negotiate_with_client_common_1;
  return_value_nbd_negotiate_with_client_common_1=nbd_negotiate_with_client_common(sockfd, exportsize, 0);
  return return_value_nbd_negotiate_with_client_common_1;
}

// nbd_negotiate_with_client_common
// file nbd.c line 535
static signed int nbd_negotiate_with_client_common(signed int sockfd, signed long int exportsize, signed int readonly)
{
  do
    if(!(exportsize >= 0l))
      g_assertion_message_expr((char *)0, "nbd.c", 537, (const char *)"nbd_negotiate_with_client_common", "exportsize >= 0");

  while((_Bool)0);
  signed int ret;
  struct nbd_negotiate_pdu_old pdu;
  memset((void *)&pdu, 0, sizeof(struct nbd_negotiate_pdu_old) /*152ul*/ );
  unsigned int flags = (unsigned int)(1 << 0);
  if(!(readonly == 0))
  {
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "nbd_negotiate: readonly");
    while((_Bool)0);
    flags = flags | (unsigned int)(1 << 1);
  }

  pdu.passwd=__bswap_64_link1(NBD_PASSWD);
  pdu.magic=__bswap_64_link1(NBD_NEGOTIATE_MAGIC_OLD);
  pdu.size=__bswap_64_link1((unsigned long int)exportsize);
  pdu.flags=htonl(flags);
  ret=net_send_all_or_error(sockfd, (const void *)&pdu, sizeof(struct nbd_negotiate_pdu_old) /*152ul*/ );
  if(ret >= 0)
  {

  __CPROVER_DUMP_L6:
    ;
    return 0;
  }

  else
  {
    do
    {

    err_out:
      ;
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "negotiation failed");
    }
    while((_Bool)0);
    return -1;
  }
}

// nbd_negotiate_with_client_new_phase_0
// file nbd.c line 363
char * nbd_negotiate_with_client_new_phase_0(signed int sockfd)
{
  signed int ret;
  struct nbd_negotiate_pdu_new_0 pdu0;
  memset((void *)&pdu0, 0, sizeof(struct nbd_negotiate_pdu_new_0) /*18ul*/ );
  pdu0.passwd=__bswap_64_link1(NBD_PASSWD);
  pdu0.magic=__bswap_64_link1(NBD_NEGOTIATE_MAGIC_NEW);
  pdu0.flag16 = (unsigned short int)0;
  ret=net_send_all_or_error(sockfd, (const void *)&pdu0, sizeof(struct nbd_negotiate_pdu_new_0) /*18ul*/ );
  _Bool tmp_if_expr_3;
  unsigned int return_value_ntohl_2;
  if(ret >= 0)
  {
    struct nbd_negotiate_pdu_new_1 pdu1;
    ret=net_recv_all_or_error(sockfd, (void *)&pdu1, sizeof(struct nbd_negotiate_pdu_new_1) /*20ul*/ );
    unsigned long int return_value___bswap_64_1;
    return_value___bswap_64_1=__bswap_64_link1(pdu1.opt_magic);
    if(!(return_value___bswap_64_1 == NBD_NEGOTIATE_MAGIC_NEW))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_ntohl_2=ntohl(pdu1.opt);
      tmp_if_expr_3 = return_value_ntohl_2 != NBD_OPT_EXPORT_NAME ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "header mismatch");
      while((_Bool)0);

    else
    {
      unsigned int namesize;
      namesize=ntohl(pdu1.namesize);
      if(namesize >= 257u)
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "namesize error");
        while((_Bool)0);

      else
      {
        char *target_name;
        void *return_value_g_malloc0_4;
        return_value_g_malloc0_4=g_malloc0((unsigned long int)(namesize + (unsigned int)1));
        target_name = (char *)return_value_g_malloc0_4;
        ret=net_recv_all_or_error(sockfd, (void *)target_name, (unsigned long int)namesize);
        if(ret >= 0)
        {
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "requested target_name %s", target_name);
          while((_Bool)0);
          return target_name;
        }

      }
    }
  }


err_out:
  ;
  return (char *)(void *)0;
}

// nbd_negotiate_with_client_new_phase_1
// file nbd.c line 415
signed int nbd_negotiate_with_client_new_phase_1(signed int sockfd, signed long int exportsize, signed int readonly)
{
  do
    if(!(exportsize >= 0l))
      g_assertion_message_expr((char *)0, "nbd.c", 417, (const char *)"nbd_negotiate_with_client_new_phase_1", "exportsize >= 0");

  while((_Bool)0);
  signed int ret;
  struct nbd_negotiate_pdu_new_2 pdu2;
  memset((void *)&pdu2, 0, sizeof(struct nbd_negotiate_pdu_new_2) /*134ul*/ );
  unsigned int flags = (unsigned int)(1 << 0);
  if(!(readonly == 0))
  {
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "nbd_negotiate: readonly");
    while((_Bool)0);
    flags = flags | (unsigned int)(1 << 1);
  }

  pdu2.size=__bswap_64_link1((unsigned long int)exportsize);
  unsigned int return_value_htonl_1;
  return_value_htonl_1=htonl(flags);
  pdu2.flags = (unsigned short int)return_value_htonl_1;
  ret=net_send_all_or_error(sockfd, (const void *)&pdu2, sizeof(struct nbd_negotiate_pdu_new_2) /*134ul*/ );
  if(ret >= 0)
  {

  __CPROVER_DUMP_L6:
    ;
    return 0;
  }

  else
  {
    do
    {

    err_out:
      ;
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "negotiation failed");
    }
    while((_Bool)0);
    return -1;
  }
}

// nbd_negotiate_with_client_readonly
// file nbd.c line 568
signed int nbd_negotiate_with_client_readonly(signed int sockfd, signed long int exportsize)
{
  signed int return_value_nbd_negotiate_with_client_common_1;
  return_value_nbd_negotiate_with_client_common_1=nbd_negotiate_with_client_common(sockfd, exportsize, 1);
  return return_value_nbd_negotiate_with_client_common_1;
}

// nbd_negotiate_with_server
// file lib/nbd.h line 81
signed long int nbd_negotiate_with_server(signed int sockfd)
{
  signed long int size;
  signed int ret;
  ret=nbd_negotiate_with_server2(sockfd, &size, (unsigned int *)(void *)0);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) negotiate with server", return_value_pthread_self_1, (const void *)"nbd_negotiate_with_server");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  return size;
}

// nbd_negotiate_with_server2
// file lib/nbd.h line 82
signed int nbd_negotiate_with_server2(signed int sockfd, signed long int *exportsize, unsigned int *exportflags)
{
  struct nbd_negotiate_pdu_old pdu;
  const unsigned long int passwd_plus_magic_len = sizeof(unsigned long int) /*8ul*/  + sizeof(unsigned long int) /*8ul*/ ;
  signed int ret;
  ret=net_recv_all_or_error(sockfd, (void *)&pdu, passwd_plus_magic_len);
  if(!(ret >= 0))
  {
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "receiving negotiate header failed");
    while((_Bool)0);
    return -1;
  }

  else
  {
    unsigned long int return_value___bswap_64_1;
    return_value___bswap_64_1=__bswap_64_link1(pdu.passwd);
    if(!(return_value___bswap_64_1 == NBD_PASSWD))
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "password mismatch");
      while((_Bool)0);
      return -1;
    }

    else
    {
      unsigned long int return_value___bswap_64_2;
      return_value___bswap_64_2=__bswap_64_link1(pdu.magic);
      if(return_value___bswap_64_2 == NBD_NEGOTIATE_MAGIC_NEW)
      {
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "plain server expected, wrapped server found");
        while((_Bool)0);
        return -1;
      }

      else
      {
        ret=net_recv_all_or_error(sockfd, (void *)((char *)&pdu + (signed long int)passwd_plus_magic_len), sizeof(struct nbd_negotiate_pdu_old) /*152ul*/  - passwd_plus_magic_len);
        if(!(ret >= 0))
        {
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "receiving negotiate header failed");
          while((_Bool)0);
          return -1;
        }

        else
        {
          unsigned long int return_value___bswap_64_3;
          return_value___bswap_64_3=__bswap_64_link1(pdu.magic);
          if(!(return_value___bswap_64_3 == NBD_NEGOTIATE_MAGIC_OLD))
          {
            do
              g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "negotiate magic mismatch");
            while((_Bool)0);
            return -1;
          }

          else
          {
            unsigned long int size;
            size=__bswap_64_link1(pdu.size);
            unsigned int flags;
            flags=ntohl(pdu.flags);
            do
              g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "remote size: %ju bytes (%ju MBytes)", size, (size / (unsigned long int)1024) / (unsigned long int)1024);
            while((_Bool)0);
            if(size >= 9223372036854775808ul)
            {
              do
                g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "remote size exceeds a local off_t(%zd bytes) value", sizeof(signed long int) /*8ul*/ );
              while((_Bool)0);
              return -1;
            }

            else
            {
              *exportsize = (signed long int)size;
              if(!(exportflags == ((unsigned int *)NULL)))
                *exportflags = flags;

              return 0;
            }
          }
        }
      }
    }
  }
}

// nbd_negotiate_with_server_new
// file lib/nbd.h line 83
signed int nbd_negotiate_with_server_new(signed int sockfd, signed long int *exportsize, unsigned int *exportflags, unsigned long int namesize, const char *target_name)
{
  signed int ret;
  struct nbd_negotiate_pdu_new_0 pdu0;
  ret=net_recv_all_or_error(sockfd, (void *)&pdu0, sizeof(struct nbd_negotiate_pdu_new_0) /*18ul*/ );
  if(ret >= 0)
  {
    unsigned long int return_value___bswap_64_1;
    return_value___bswap_64_1=__bswap_64_link1(pdu0.passwd);
    if(!(return_value___bswap_64_1 == NBD_PASSWD))
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "password mismatch");
      while((_Bool)0);
      goto err_out;
    }

    unsigned long int return_value___bswap_64_2;
    return_value___bswap_64_2=__bswap_64_link1(pdu0.magic);
    if(return_value___bswap_64_2 == NBD_NEGOTIATE_MAGIC_OLD)
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "wrapped server expected, plain server found");
      while((_Bool)0);
      goto err_out;
    }

    unsigned long int return_value___bswap_64_3;
    return_value___bswap_64_3=__bswap_64_link1(pdu0.magic);
    if(!(return_value___bswap_64_3 == NBD_NEGOTIATE_MAGIC_NEW))
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "negotiate magic mismatch");
      while((_Bool)0);
      goto err_out;
    }

    struct nbd_negotiate_pdu_new_1 pdu1;
    pdu1.reserved = (unsigned int)0;
    pdu1.opt_magic=__bswap_64_link1(NBD_NEGOTIATE_MAGIC_NEW);
    pdu1.opt=htonl(NBD_OPT_EXPORT_NAME);
    pdu1.namesize=htonl((unsigned int)namesize);
    ret=net_send_all_or_error(sockfd, (const void *)&pdu1, sizeof(struct nbd_negotiate_pdu_new_1) /*20ul*/ );
    if(!(ret >= 0))
      goto err_out;

    ret=net_send_all_or_error(sockfd, (const void *)target_name, namesize);
    if(!(ret >= 0))
      goto err_out;

    struct nbd_negotiate_pdu_new_2 pdu2;
    ret=net_recv_all_or_error(sockfd, (void *)&pdu2, sizeof(struct nbd_negotiate_pdu_new_2) /*134ul*/ );
    if(!(ret >= 0))
      goto err_out;

    unsigned long int size;
    size=__bswap_64_link1(pdu2.size);
    unsigned int flags;
    flags=ntohl((unsigned int)pdu2.flags);
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "remote size: %ju bytes (%ju MBytes)", size, (size / (unsigned long int)1024) / (unsigned long int)1024);
    while((_Bool)0);
    if(size >= 9223372036854775808ul)
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "remote size exceeds a local off_t(%zd bytes) value", sizeof(signed long int) /*8ul*/ );
      while((_Bool)0);
      return -1;
    }

    *exportsize = (signed long int)size;
    if(!(exportflags == ((unsigned int *)NULL)))
      *exportflags = flags;

    return 0;
  }

  else
  {

  err_out:
    ;
    return -1;
  }
}

// nbd_reply_dump
// file nbd.c line 55
void nbd_reply_dump(struct nbd_reply *reply)
{
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "nbd_reply %p", reply);
  while((_Bool)0);
  do
  {
    unsigned int return_value_ntohl_1;
    return_value_ntohl_1=ntohl(reply->magic);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, " reply.magic  %x %x", reply->magic, return_value_ntohl_1);
  }
  while((_Bool)0);
  do
  {
    unsigned int return_value_ntohl_2;
    return_value_ntohl_2=ntohl(reply->magic);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, " reply.error  %u %u", reply->error, return_value_ntohl_2);
  }
  while((_Bool)0);
  do
  {
    unsigned long int return_value___bswap_64_3;
    return_value___bswap_64_3=__bswap_64_link1(reply->handle);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, " reply.handle %ju %ju", reply->handle, return_value___bswap_64_3);
  }
  while((_Bool)0);
}

// nbd_request_dump
// file nbd.c line 45
void nbd_request_dump(struct nbd_request *request)
{
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "nbd_request %p", request);
  while((_Bool)0);
  do
  {
    unsigned int return_value_ntohl_1;
    return_value_ntohl_1=ntohl(request->magic);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, " request.magic  %x %x", request->magic, return_value_ntohl_1);
  }
  while((_Bool)0);
  do
  {
    unsigned int return_value_ntohl_2;
    return_value_ntohl_2=ntohl(request->type);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, " request.type  %u %u", request->type, return_value_ntohl_2);
  }
  while((_Bool)0);
  do
  {
    unsigned long int return_value___bswap_64_3;
    return_value___bswap_64_3=__bswap_64_link1(request->from);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, " request.from  %ju %ju", request->from, return_value___bswap_64_3);
  }
  while((_Bool)0);
  do
  {
    unsigned int return_value_ntohl_4;
    return_value_ntohl_4=ntohl(request->len);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, " request.len  %u %u", request->len, return_value_ntohl_4);
  }
  while((_Bool)0);
  do
  {
    unsigned long int return_value___bswap_64_5;
    return_value___bswap_64_5=__bswap_64_link1(request->handle);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, " request.handle %ju %ju", request->handle, return_value___bswap_64_5);
  }
  while((_Bool)0);
}

// nbd_server_recv_request
// file lib/nbd.h line 97
signed int nbd_server_recv_request(signed int clientfd, signed long int disksize, unsigned int *iotype_arg, signed long int *iofrom_arg, unsigned long int *iolen_arg, struct nbd_reply *reply)
{
  struct nbd_request request;
  unsigned int magic = (unsigned int)0;
  unsigned int iotype = (unsigned int)0;
  unsigned long int iofrom = (unsigned long int)0;
  unsigned int iolen = (unsigned int)0;
  signed int ret;
  memset((void *)&request, 0, sizeof(struct nbd_request) /*28ul*/ );
  ret=net_recv_all_or_error(clientfd, (void *)&request, sizeof(struct nbd_request) /*28ul*/ );
  if(!(ret >= 0))
  {
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "recv_request: peer closed or error");
    while((_Bool)0);
    return -3;
  }

  else
  {
    magic=ntohl(request.magic);
    iotype=ntohl(request.type);
    iofrom=__bswap_64_link1(request.from);
    iolen=ntohl(request.len);
    if(iotype == 2u)
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "recv_request: disconnect request");
      while((_Bool)0);
      return -3;
    }

    else
      if(!(magic == 627086611u))
      {
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "recv_request: magic mismatch, %u %u", magic, 0x25609513);
        while((_Bool)0);
        nbd_request_dump(&request);
        dump_buffer((char *)&request, sizeof(struct nbd_request) /*28ul*/ );
        return -2;
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        reply->handle = request.handle;
        if(!((unsigned long int)disksize >= iofrom + (unsigned long int)iolen))
        {
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "error offset exceeds the end of disk, offset %ju (iofrom %ju + iolen %u) disksize %jd", iofrom + (unsigned long int)iolen, iofrom, iolen, disksize);
          while((_Bool)0);
          reply->error=htonl((unsigned int)22);
          return -1;
        }

        else
        {
          *iotype_arg = iotype;
          *iofrom_arg = (signed long int)iofrom;
          *iolen_arg = (unsigned long int)iolen;
          return 0;
        }
      }
  }
}

// net_accept
// file net.c line 157
signed int net_accept(signed int lsock)
{
  signed int csock;
  struct sockaddr_storage ss;
  unsigned int len = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  char host[1025l];
  char port[32l];
  signed int ret;
  memset((void *)&ss, 0, sizeof(struct sockaddr_storage) /*128ul*/ );
  csock=accept(lsock, (struct sockaddr *)&ss, &len);
  if(!(csock >= 0))
  {
    do
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "accept failed, fd %d, %s (%d)", csock, return_value_strerror_2, *return_value___errno_location_3);
    }
    while((_Bool)0);
    return -1;
  }

  else
  {
    ret=getnameinfo((struct sockaddr *)&ss, len, host, (unsigned int)sizeof(char [1025l]) /*1025ul*/ , port, (unsigned int)sizeof(char [32l]) /*32ul*/ , 1 | 2);
    if(!(ret == 0))
      do
      {
        const char *return_value_gai_strerror_4;
        return_value_gai_strerror_4=gai_strerror(ret);
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "getnameinfo failed, %s", return_value_gai_strerror_4);
      }
      while((_Bool)0);

    if((signed int)ss.ss_family == 2)
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "connected from %s:%s", (const void *)host, (const void *)port);
      while((_Bool)0);

    else
      if((signed int)ss.ss_family == 10)
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "connected from [%s]:%s", (const void *)host, (const void *)port);
        while((_Bool)0);

      else
        if((signed int)ss.ss_family == 1)
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "connected (unix)");
          while((_Bool)0);

        else
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "connected (unknown pf)");
          while((_Bool)0);
    return csock;
  }
}

// net_connect
// file lib/net.h line 55
signed int net_connect(const char *hostname, const char *service, signed int socktype, signed int proto)
{
  struct addrinfo hints;
  struct addrinfo *ai_head;
  signed int sockfd;
  signed int found = 0;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_socktype = socktype;
  hints.ai_protocol = proto;
  signed int ret;
  ret=getaddrinfo(hostname, service, &hints, &ai_head);
  if(!(ret == 0))
  {
    do
    {
      const char *return_value_gai_strerror_1;
      return_value_gai_strerror_1=gai_strerror(ret);
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "getaddrinfo failed, %s %s: %s", hostname, service, return_value_gai_strerror_1);
    }
    while((_Bool)0);
    return -1;
  }

  else
  {
    struct addrinfo *ai = ai_head;
    for( ; !(ai == ((struct addrinfo *)NULL)); ai = ai->ai_next)
    {
      char *nameinfo;
      nameinfo=get_nameinfo_string(ai);

    __CPROVER_DUMP_L4:
      ;
      sockfd=socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
      if(!(sockfd >= 0))
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "socket() failed, %m");
        while((_Bool)0);

      else
      {
        if(proto == 6)
        {
          net_set_nodelay(sockfd);
          net_set_keepalive(sockfd);
        }

        ret=connect(sockfd, ai->ai_addr, ai->ai_addrlen);
        if(!(ret >= 0))
        {

        __CPROVER_DUMP_L8:
          ;
          close(sockfd);
        }

        else
        {
          found = 1;
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "connected to %s", nameinfo);
          while((_Bool)0);
        }
      }

    cleanup:
      ;
      g_free((void *)nameinfo);
      if(!(found == 0))
        break;

    }
    freeaddrinfo(ai_head);
    if(!(found == 0))
      return sockfd;

    else
    {

    __CPROVER_DUMP_L13:
      ;
      return -1;
    }
  }
}

// net_create_server_sockets
// file net.c line 79
unsigned int net_create_server_sockets(struct addrinfo *ai_head, signed int *fds, unsigned long int nfds)
{
  struct addrinfo *ai;
  unsigned long int index = (unsigned long int)0;
  ai = ai_head;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  for( ; !(ai == ((struct addrinfo *)NULL)); ai = ai->ai_next)
  {
    if(index >= nfds)
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "skip other addresses");
      while((_Bool)0);
      break;
    }

    char *name;
    name=get_nameinfo_string(ai);
    signed int reuseaddr = 0;
    signed int tcpnodelay = 0;
    signed int sockfd;
    sockfd=socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
    if(!(sockfd >= 0))
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "socket(%s) failed, %m", name);
      while((_Bool)0);
      g_free((void *)name);
    }

    else
    {
      net_set_reuseaddr(sockfd);
      reuseaddr = 1;
      if(ai->ai_socktype == 1)
      {
        if(ai->ai_protocol == 6)
        {
          net_set_nodelay(sockfd);
          tcpnodelay = 1;
        }

      }

      if(ai->ai_family == 10)
        net_set_bindv6only(sockfd);

      if(sockfd >= 1024)
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "select/poll() may fail because sockfd (%d) >= FD_SETSIZE.", sockfd);
        while((_Bool)0);

      signed int ret;
      ret=bind(sockfd, ai->ai_addr, ai->ai_addrlen);
      if(!(ret >= 0))
      {
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "bind(%s) failed, %m", name);

      __CPROVER_DUMP_L11:
        ;
        goto __CPROVER_DUMP_L11;
      }

      if(ai->ai_socktype == 1)
        tmp_if_expr_1 = ai->ai_protocol == 6 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        if(ai->ai_socktype == 6)
          tmp_if_expr_2 = ai->ai_protocol == 33 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
      {
        ret=listen(sockfd, 128);
        if(!(ret >= 0))
        {
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "listen(%s) failed, %m", name);

        __CPROVER_DUMP_L20:
          ;
          goto __CPROVER_DUMP_L20;
        }

      }

      struct _GString *gs;
      gs=g_string_new((const char *)(void *)0);
      g_string_append_printf(gs, "server %s,fd=%d", name, sockfd);
      if(!(reuseaddr == 0))
        g_string_append(gs, ",reuseaddr");

      if(!(tcpnodelay == 0))
        g_string_append(gs, ",nodelay");

      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "%s", gs->str);
      while((_Bool)0);
      g_string_free(gs, (signed int)!(0 != 0));
      fds[(signed long int)index] = sockfd;
      index = index + 1ul;
      g_free((void *)name);
    }
  }
  if(index == 0ul)
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "no server sockets created");
    while((_Bool)0);

  return (unsigned int)index;
}

// net_getaddrinfo
// file net.c line 57
struct addrinfo * net_getaddrinfo(char *host, signed int port, signed int ai_family, signed int socktype, signed int proto)
{
  signed int ret;
  struct addrinfo hints;
  struct addrinfo *ai_head;
  char portstr[32l];
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = ai_family;
  hints.ai_socktype = socktype;
  hints.ai_flags = 0x0001;
  hints.ai_protocol = proto;
  snprintf(portstr, sizeof(char [32l]) /*32ul*/ , "%d", port);
  ret=getaddrinfo(host, portstr, &hints, &ai_head);
  if(!(ret == 0))
  {
    const char *return_value_gai_strerror_1;
    return_value_gai_strerror_1=gai_strerror(ret);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "getaddrinfo() failed %s: %s", (const void *)portstr, return_value_gai_strerror_1);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  return ai_head;
}

// net_iov_all
// file net.c line 331
static signed int net_iov_all(signed int fd, struct iovec *iov, signed int count, signed int reading)
{
  signed int next_count = count;
  struct iovec *next_iov = iov;
  const char *mode = reading != 0 ? "readv" : "writev";
  signed long int total = (signed long int)0;
  signed int *return_value___errno_location_4;
  do
  {
    signed long int sent = (signed long int)0;
    signed int expected = 0;
    signed int do_next = 0;

  __CPROVER_DUMP_L2:
    ;
    if(!(reading == 0))
      sent=readv(fd, next_iov, next_count);

    else
      sent=writev(fd, next_iov, next_count);
    if(sent == 0l)
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "%s() returned 0 (fd %d)", mode, fd);
      while((_Bool)0);
      return (signed int)total;
    }

    if(sent == -1l)
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      if(*return_value___errno_location_5 == 104)
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "received TCP_RST (fd %d)", fd);
        while((_Bool)0);

      else
      {
        return_value___errno_location_4=__errno_location();
        if(*return_value___errno_location_4 == 32)
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "raised EPIPE (fd %d)", fd);
          while((_Bool)0);

        else
          do
          {
            signed int *return_value___errno_location_1;
            return_value___errno_location_1=__errno_location();
            char *return_value_strerror_2;
            return_value_strerror_2=strerror(*return_value___errno_location_1);
            signed int *return_value___errno_location_3;
            return_value___errno_location_3=__errno_location();
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "%s error %s (%d) (fd %d)", mode, return_value_strerror_2, *return_value___errno_location_3, fd);
          }
          while((_Bool)0);
      }
      return -1;
    }

    total = total + sent;
    signed int i = 0;
    for( ; !(i >= next_count); i = i + 1)
    {
      expected = expected + (signed int)(next_iov + (signed long int)i)->iov_len;
      if(!(sent >= (signed long int)expected))
      {

      __CPROVER_DUMP_L14:
        ;
        signed int rest_in_block = (signed int)((signed long int)expected - sent);
        signed int sent_in_block = (signed int)((next_iov + (signed long int)i)->iov_len - (unsigned long int)rest_in_block);
        (next_iov + (signed long int)i)->iov_base = (void *)((char *)(next_iov + (signed long int)i)->iov_base + (signed long int)sent_in_block);
        (next_iov + (signed long int)i)->iov_len = (unsigned long int)rest_in_block;
        next_iov = &next_iov[(signed long int)i];
        next_count = next_count - i;
        do_next = 1;
        break;
      }

    }
    if(do_next == 0)
      break;

  }
  while((_Bool)1);

__CPROVER_DUMP_L17:
  ;
  return (signed int)total;
}

// net_readv_all
// file net.c line 456
signed int net_readv_all(signed int fd, struct iovec *iov, signed int count)
{

__CPROVER_DUMP_L1:
  ;
  signed int return_value_net_iov_all_1;
  return_value_net_iov_all_1=net_iov_all(fd, iov, count, 1);
  return return_value_net_iov_all_1;
}

// net_readv_all_or_abort
// file lib/net.h line 70
void net_readv_all_or_abort(signed int fd, struct iovec *iov, unsigned int count)
{
  unsigned long int bufflen = (unsigned long int)0;
  unsigned int i = (unsigned int)0;
  for( ; !(i >= count); i = i + 1u)
    bufflen = bufflen + (iov + (signed long int)i)->iov_len;
  signed int ret;
  ret=net_readv_all(fd, iov, (signed int)count);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  signed int return_value_check_fin_3;
  return_value_check_fin_3=check_fin(ret, *return_value___errno_location_2, bufflen);
  if(!(return_value_check_fin_3 == 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) sockfd (%d) closed", return_value_pthread_self_1, (const void *)"net_readv_all_or_abort", fd);

  __CPROVER_DUMP_L4:
    ;
    goto __CPROVER_DUMP_L4;
  }

}

// net_readv_all_or_error
// file net.h line 71
signed int net_readv_all_or_error(signed int fd, struct iovec *iov, unsigned int count)
{
  unsigned long int bufflen = (unsigned long int)0;
  unsigned int i = (unsigned int)0;
  for( ; !(i >= count); i = i + 1u)
    bufflen = bufflen + (iov + (signed long int)i)->iov_len;
  signed int ret;
  ret=net_readv_all(fd, iov, (signed int)count);
  if(!(ret == (signed int)bufflen))
    return -1;

  else
    return ret;
}

// net_recv_all
// file net.c line 472
signed long int net_recv_all(signed int sockfd, void *buff, unsigned long int bufflen)
{
  struct iovec iov[1l];
  iov[(signed long int)0].iov_base = buff;
  iov[(signed long int)0].iov_len = bufflen;
  signed int return_value_net_iov_all_1;
  return_value_net_iov_all_1=net_iov_all(sockfd, iov, 1, 1);
  return (signed long int)return_value_net_iov_all_1;
}

// net_recv_all_or_abort
// file lib/net.h line 61
void net_recv_all_or_abort(signed int sockfd, void *buff, unsigned long int bufflen)
{
  signed int ret;
  signed long int return_value_net_recv_all_1;
  return_value_net_recv_all_1=net_recv_all(sockfd, buff, bufflen);
  ret = (signed int)return_value_net_recv_all_1;
  signed int *return_value___errno_location_3;
  return_value___errno_location_3=__errno_location();
  signed int return_value_check_fin_4;
  return_value_check_fin_4=check_fin(ret, *return_value___errno_location_3, bufflen);
  if(!(return_value_check_fin_4 == 0))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) sockfd (%d) closed", return_value_pthread_self_2, (const void *)"net_recv_all_or_abort", sockfd);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

}

// net_recv_all_or_error
// file lib/net.h line 62
signed int net_recv_all_or_error(signed int sockfd, void *buff, unsigned long int bufflen)
{
  signed int ret;
  signed long int return_value_net_recv_all_1;
  return_value_net_recv_all_1=net_recv_all(sockfd, buff, bufflen);
  ret = (signed int)return_value_net_recv_all_1;
  if(!(ret == (signed int)bufflen))
    return -1;

  else
    return ret;
}

// net_send_all
// file net.h line 64
signed long int net_send_all(signed int sockfd, const void *buff, unsigned long int bufflen)
{
  struct iovec iov[1l];
  iov[(signed long int)0].iov_base = (void *)buff;
  iov[(signed long int)0].iov_len = bufflen;
  signed int return_value_net_iov_all_1;
  return_value_net_iov_all_1=net_iov_all(sockfd, iov, 1, 0);
  return (signed long int)return_value_net_iov_all_1;
}

// net_send_all_or_abort
// file lib/net.h line 65
void net_send_all_or_abort(signed int sockfd, const void *buff, unsigned long int bufflen)
{
  signed int ret;
  signed long int return_value_net_send_all_1;
  return_value_net_send_all_1=net_send_all(sockfd, buff, bufflen);
  ret = (signed int)return_value_net_send_all_1;
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  check_done(ret, *return_value___errno_location_2);
}

// net_send_all_or_error
// file lib/net.h line 66
signed int net_send_all_or_error(signed int sockfd, const void *buff, unsigned long int bufflen)
{
  signed int ret;
  signed long int return_value_net_send_all_1;
  return_value_net_send_all_1=net_send_all(sockfd, buff, bufflen);
  ret = (signed int)return_value_net_send_all_1;
  if(!(ret == (signed int)bufflen))
    return -1;

  else
    return ret;
}

// net_set_bindv6only
// file net.c line 216
signed int net_set_bindv6only(signed int sockfd)
{
  const signed int val = 1;
  signed int ret;
  ret=setsockopt(sockfd, 41, 26, (const void *)&val, (unsigned int)sizeof(const signed int) /*4ul*/ );
  if(!(ret >= 0))
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "setsockopt IPV6_V6ONLY failed");
    while((_Bool)0);

  return ret;
}

// net_set_keepalive
// file net.c line 228
signed int net_set_keepalive(signed int sockfd)
{
  const signed int val = 1;
  signed int ret;
  ret=setsockopt(sockfd, 1, 9, (const void *)&val, (unsigned int)sizeof(const signed int) /*4ul*/ );
  if(!(ret >= 0))
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "setsockopt SO_KEEPALIVE failed");
    while((_Bool)0);

  return ret;
}

// net_set_nodelay
// file net.c line 204
signed int net_set_nodelay(signed int sockfd)
{
  const signed int val = 1;
  signed int ret;
  ret=setsockopt(sockfd, 6, 1, (const void *)&val, (unsigned int)sizeof(const signed int) /*4ul*/ );
  if(!(ret >= 0))
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "setsockopt TCP_NODELAY failed");
    while((_Bool)0);

  return ret;
}

// net_set_reuseaddr
// file net.c line 192
signed int net_set_reuseaddr(signed int sockfd)
{
  const signed int val = 1;
  signed int ret;
  ret=setsockopt(sockfd, 1, 2, (const void *)&val, (unsigned int)sizeof(const signed int) /*4ul*/ );
  if(!(ret >= 0))
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "setsockopt SO_REUSEADDR failed");
    while((_Bool)0);

  return ret;
}

// net_writev_all
// file net.c line 450
signed int net_writev_all(signed int fd, struct iovec *iov, signed int count)
{

__CPROVER_DUMP_L1:
  ;
  signed int return_value_net_iov_all_1;
  return_value_net_iov_all_1=net_iov_all(fd, iov, count, 0);
  return return_value_net_iov_all_1;
}

// net_writev_all_or_abort
// file lib/net.h line 68
void net_writev_all_or_abort(signed int fd, struct iovec *iov, unsigned int count)
{
  signed int ret;
  ret=net_writev_all(fd, iov, (signed int)count);
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  check_done(ret, *return_value___errno_location_1);
}

// net_writev_all_or_error
// file lib/net.h line 69
signed int net_writev_all_or_error(signed int fd, struct iovec *iov, unsigned int count)
{
  unsigned long int bufflen = (unsigned long int)0;
  unsigned int i = (unsigned int)0;
  for( ; !(i >= count); i = i + 1u)
    bufflen = bufflen + (iov + (signed long int)i)->iov_len;
  signed int ret;
  ret=net_writev_all(fd, iov, (signed int)count);
  if(!(ret == (signed int)bufflen))
    return -1;

  else
    return ret;
}

// poll_data_and_event
// file io.c line 317
signed int poll_data_and_event(signed int datafd, signed int event_listener_fd)
{
  signed int return_value_wait_until_readable_1;
  return_value_wait_until_readable_1=wait_until_readable(datafd, event_listener_fd);
  return return_value_wait_until_readable_1;
}

// poll_request_arrival
// file xnbd_common.c line 155
signed int poll_request_arrival(struct xnbd_session *ses)
{
  signed int return_value_wait_until_readable_1;
  return_value_wait_until_readable_1=wait_until_readable(ses->clientfd, ses->pipe_worker_fd);
  return return_value_wait_until_readable_1;
}

// prepare_read_priv
// file xnbd_proxy_forwarder.c line 82
void prepare_read_priv(struct xnbd_proxy *proxy, struct proxy_priv *priv)
{
  unsigned long int block_index_start = priv->block_index_start;
  unsigned long int block_index_end = priv->block_index_end;
  unsigned long int i = block_index_start;
  for( ; block_index_end >= i; i = i + 1ul)
  {
    cachestat_read_block();
    signed int return_value_bitmap_test_1;
    return_value_bitmap_test_1=bitmap_test(proxy->cbitmap, i);
    if(return_value_bitmap_test_1 == 0)
    {
      bitmap_on(proxy->cbitmap, i);
      cachestat_miss();
      cachestat_cache_odread();
      add_read_block_to_tail(priv, i);
    }

    else
      cachestat_hit();
  }
}

// prepare_write_priv
// file xnbd_proxy_forwarder.c line 113
void prepare_write_priv(struct xnbd_proxy *proxy, struct proxy_priv *priv)
{
  unsigned long int block_index_start = priv->block_index_start;
  unsigned long int block_index_end = priv->block_index_end;
  signed long int iofrom = priv->iofrom;
  unsigned long int iolen = priv->iolen;
  signed int get_start_block = 0;
  signed int get_end_block = 0;
  signed int return_value_bitmap_test_1;
  if(!(iofrom % (signed long int)CBLOCKSIZE == 0l))
  {
    return_value_bitmap_test_1=bitmap_test(proxy->cbitmap, block_index_start);
    if(return_value_bitmap_test_1 == 0)
      get_start_block = 1;

  }

  signed int return_value_bitmap_test_2;
  if(!((iolen + (unsigned long int)iofrom) % (unsigned long int)CBLOCKSIZE == 0ul))
  {
    if(get_start_block == 0 && block_index_end == block_index_start || !(block_index_start >= block_index_end))
    {
      return_value_bitmap_test_2=bitmap_test(proxy->cbitmap, block_index_end);
      if(return_value_bitmap_test_2 == 0)
        get_end_block = 1;

    }

  }

  unsigned long int i = block_index_start;
  for( ; block_index_end >= i; i = i + 1ul)
  {
    cachestat_write_block();
    signed int return_value_bitmap_test_3;
    return_value_bitmap_test_3=bitmap_test(proxy->cbitmap, i);
    if(return_value_bitmap_test_3 == 0)
    {
      bitmap_on(proxy->cbitmap, i);
      cachestat_cache_odwrite();
    }

  }
  if(!(get_start_block == 0))
  {
    do
      if(1 + priv->nreq >= 33)
        g_assertion_message_expr((char *)0, "xnbd_proxy_forwarder.c", 168, (const char *)"prepare_write_priv", "priv->nreq + 1 <= MAXNBLOCK");

    while((_Bool)0);
    signed int cur_nreq = priv->nreq;
    priv->req[(signed long int)cur_nreq].bindex_iofrom = (signed long int)block_index_start;
    priv->req[(signed long int)cur_nreq].bindex_iolen = (unsigned long int)1;
    priv->nreq = priv->nreq + 1;
    cachestat_miss();
  }

  else
    cachestat_hit();
  if(!(get_end_block == 0))
  {
    do
      if(1 + priv->nreq >= 33)
        g_assertion_message_expr((char *)0, "xnbd_proxy_forwarder.c", 181, (const char *)"prepare_write_priv", "priv->nreq + 1 <= MAXNBLOCK");

    while((_Bool)0);
    signed int prepare_write_priv__1__4__cur_nreq = priv->nreq;
    priv->req[(signed long int)prepare_write_priv__1__4__cur_nreq].bindex_iofrom = (signed long int)block_index_end;
    priv->req[(signed long int)prepare_write_priv__1__4__cur_nreq].bindex_iolen = (unsigned long int)1;
    priv->nreq = priv->nreq + 1;
    cachestat_miss();
  }

  else
    cachestat_hit();
}

// proxy_initialize
// file xnbd_proxy.c line 355
void proxy_initialize(struct xnbd_info *xnbd, struct xnbd_proxy *proxy)
{
  proxy->xnbd = xnbd;
  proxy->fwd_tx_queue=g_async_queue_new();
  proxy->fwd_rx_queue=g_async_queue_new();
  proxy->fwd_retry_queue=g_async_queue_new();
  proxy->cbitmap=bitmap_open_file(xnbd->proxy_bmpath, xnbd->nblocks, &proxy->cbitmaplen, 0, xnbd->proxy_clear_bitmap != (_Bool)0 ? 1 : 0);
  signed int cachefd;
  cachefd=open(xnbd->proxy_diskpath, 02 | 0100 | 01000000, 0400 | 0200);
  if(!(cachefd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) open", return_value_pthread_self_1, (const void *)"proxy_initialize");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  signed long int size;
  size=get_disksize(cachefd);
  if(!(size == xnbd->disksize))
  {
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "cache disk size (%ju) != target disk size (%ju)", size, xnbd->disksize);
    while((_Bool)0);
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "now ftruncate() it");
    while((_Bool)0);
    signed int ret;
    ret=ftruncate(cachefd, xnbd->disksize);
    if(!(ret >= 0))
    {
      unsigned long int return_value_pthread_self_2;
      return_value_pthread_self_2=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) ftruncate", return_value_pthread_self_2, (const void *)"proxy_initialize");

    __CPROVER_DUMP_L7:
      ;
      goto __CPROVER_DUMP_L7;
    }

  }

  proxy->cachefd = cachefd;
  g_mutex_init(&proxy->curr_use_mutex);
  proxy->cur_use_buf = (unsigned long int)0;
  proxy->cur_use_que = (unsigned long int)0;
}

// proxy_initialize_forwarder
// file xnbd_proxy.c line 324
void proxy_initialize_forwarder(struct xnbd_proxy *proxy, signed int remotefd)
{
  proxy->remotefd = remotefd;
  proxy->tid_fwd_rx=pthread_create_or_abort(forwarder_rx_thread_main, (void *)proxy);
  proxy->tid_fwd_tx=pthread_create_or_abort(forwarder_tx_thread_main, (void *)proxy);
}

// proxy_priv_dump
// file xnbd_proxy.h line 139
void proxy_priv_dump(struct proxy_priv *priv)
{

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;

__CPROVER_DUMP_L3:
  ;

__CPROVER_DUMP_L4:
  ;

__CPROVER_DUMP_L5:
  ;

__CPROVER_DUMP_L6:
  ;

__CPROVER_DUMP_L7:
  ;

__CPROVER_DUMP_L8:
  ;
  signed int i = 0;
  for( ; !(i >= priv->nreq); i = i + 1)
  {

  __CPROVER_DUMP_L10:
    ;

  __CPROVER_DUMP_L11:
    ;
  }

__CPROVER_DUMP_L13:
  ;

__CPROVER_DUMP_L14:
  ;

__CPROVER_DUMP_L15:
  ;

__CPROVER_DUMP_L16:
  ;

__CPROVER_DUMP_L17:
  ;

__CPROVER_DUMP_L18:
  ;

__CPROVER_DUMP_L19:
  ;
}

// proxy_shutdown
// file xnbd_proxy.c line 388
void proxy_shutdown(struct xnbd_proxy *proxy)
{
  g_mutex_clear(&proxy->curr_use_mutex);
  _Bool tmp_if_expr_1;
  if(!(proxy->cur_use_buf == 0ul))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = proxy->cur_use_que != (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "cur_use_buf %zu cur_use_que %zu", proxy->cur_use_buf, proxy->cur_use_que);
    while((_Bool)0);

  g_async_queue_unref(proxy->fwd_retry_queue);
  g_async_queue_unref(proxy->fwd_tx_queue);
  g_async_queue_unref(proxy->fwd_rx_queue);
  if(!(proxy->shared_buff == ((char *)NULL)))
    munmap_or_abort((void *)proxy->shared_buff, (unsigned long int)(CBLOCKSIZE * (unsigned int)1000));

  close(proxy->cachefd);
  bitmap_close_file(proxy->cbitmap, proxy->cbitmaplen);
}

// proxy_shutdown_forwarder
// file xnbd_proxy.c line 331
void proxy_shutdown_forwarder(struct xnbd_proxy *proxy)
{
  g_async_queue_push(proxy->fwd_tx_queue, (void *)&priv_stop_forwarder);
  pthread_join(proxy->tid_fwd_tx, (void **)(void *)0);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "forwarder_tx exited");
  while((_Bool)0);
  pthread_join(proxy->tid_fwd_rx, (void **)(void *)0);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "forwarder_rx exited");
  while((_Bool)0);
}

// pthread_create_or_abort
// file lib/io.h line 44
unsigned long int pthread_create_or_abort(void * (*start_routine)(void *), void *arg)
{
  unsigned long int tid;
  signed int ret;
  ret=pthread_create(&tid, (const union pthread_attr_t *)(void *)0, start_routine, arg);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) create thread", return_value_pthread_self_1, (const void *)"pthread_create_or_abort");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  return tid;
}

// put_line
// file io.c line 250
signed int put_line(signed int fd, const char *msg)
{
  char line[100l];
  unsigned long int return_value_strnlen_1;
  return_value_strnlen_1=strnlen(msg, (unsigned long int)(100 - 2));
  if(return_value_strnlen_1 == 98ul)
  {
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "too large msg for a line");
    while((_Bool)0);
    return -1;
  }

  else
  {
    sprintf(line, "%s\n", msg);

  __CPROVER_DUMP_L3:
    ;
    signed int ret;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(line);
    ret=net_send_all_or_error(fd, (const void *)line, return_value_strlen_2);
    if(!(ret >= 0))
      return -1;

    else
      return 0;
  }
}

// read_all
// file io.c line 59
void read_all(signed int fd, void *buf, unsigned long int len)
{
  io_all(fd, buf, len, 1);
}

// receiver_thread_main
// file xnbd_tester.c line 286
void * receiver_thread_main(void *data)
{
  struct parameters *params = (struct parameters *)data;
  do
  {
    struct crequest *req;
    void *return_value_g_async_queue_pop_1;
    return_value_g_async_queue_pop_1=g_async_queue_pop(reply_pendings);
    req = (struct crequest *)return_value_g_async_queue_pop_1;
    if(req == &eofmarker)
      break;

    recv_reply_header(params->remotefd, (unsigned long int)req->index);

  __CPROVER_DUMP_L3:
    ;
    struct mmap_partial *tgtmp;
    tgtmp=mmap_partial_map(params->tgtdiskfd, req->iofrom, req->iolen, 0);
    if(req->iotype == 1u)
    {
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "index %d req %p write done", req->index, req);
      memcpy(tgtmp->iobuf, (const void *)req->write_buff, req->iolen);
    }

    else
      if(req->iotype == 0u)
      {
        net_recv_all_or_abort(params->remotefd, tgtmp->iobuf, req->iolen);
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "index %d req %p read done", req->index, req);
      }

      else
      {
        unsigned long int return_value_pthread_self_2;
        return_value_pthread_self_2=pthread_self();
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bug", return_value_pthread_self_2, (const void *)"receiver_thread_main");

      __CPROVER_DUMP_L6:
        ;
        goto __CPROVER_DUMP_L6;
      }
    mmap_partial_unmap(tgtmp);
    g_async_queue_push(check_pendings, (void *)req);
  }
  while((_Bool)1);
  g_async_queue_push(check_pendings, (void *)&eofmarker);
  g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "io finished");
  return (void *)0;
}

// recv_reply_header
// file xnbd_tester.c line 262
void recv_reply_header(signed int remotefd, unsigned long int expected_index)
{
  struct nbd_reply reply;
  memset((void *)&reply, 0, sizeof(struct nbd_reply) /*16ul*/ );
  net_recv_all_or_abort(remotefd, (void *)&reply, sizeof(struct nbd_reply) /*16ul*/ );
  unsigned int return_value_ntohl_3;
  return_value_ntohl_3=ntohl(reply.magic);
  if(!(return_value_ntohl_3 == 1732535960u))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    unsigned int return_value_ntohl_2;
    return_value_ntohl_2=ntohl(reply.magic);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) unknown reply magic, %x %x", return_value_pthread_self_1, (const void *)"recv_reply_header", reply.magic, return_value_ntohl_2);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  unsigned int error;
  error=ntohl(reply.error);
  if(!(error == 0u))
  {
    unsigned long int return_value_pthread_self_4;
    return_value_pthread_self_4=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) reply state error %d", return_value_pthread_self_4, (const void *)"recv_reply_header", error);

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

  unsigned long int reply_index;
  reply_index=__bswap_64(reply.handle);

__CPROVER_DUMP_L7:
  ;
  if(!(reply_index == expected_index))
  {
    unsigned long int return_value_pthread_self_5;
    return_value_pthread_self_5=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) wrong reply ordering, reply_index %ju (%jx) expected_index %ju", return_value_pthread_self_5, (const void *)"recv_reply_header", reply_index, reply_index, expected_index);

  __CPROVER_DUMP_L9:
    ;
    goto __CPROVER_DUMP_L9;
  }

}

// recv_request
// file xnbd_proxy.c line 189
signed int recv_request(struct proxy_session *ps)
{
  struct xnbd_proxy *proxy = ps->proxy;
  signed int nbd_client_fd = ps->nbd_fd;
  struct proxy_priv *priv;
  void *return_value_g_slice_alloc0_1;
  return_value_g_slice_alloc0_1=g_slice_alloc0(sizeof(struct proxy_priv) /*624ul*/ );
  priv = (struct proxy_priv *)return_value_g_slice_alloc0_1;
  unsigned int iotype = (unsigned int)0;
  signed long int iofrom = (signed long int)0;
  unsigned long int iolen = (unsigned long int)0;
  signed int ret = 0;
  priv->nreq = 0;
  priv->clientfd = nbd_client_fd;
  priv->tx_queue = ps->tx_queue;
  priv->reply.magic=htonl((unsigned int)0x67446698);
  priv->reply.error = (unsigned int)0;
  ret=wait_until_readable(nbd_client_fd, ps->wrk_fd);
  unsigned long int block_index_start;
  unsigned long int block_index_end;
  if(ret >= 0)
  {
    ret=nbd_server_recv_request(nbd_client_fd, proxy->xnbd->disksize, &iotype, &iofrom, &iolen, &priv->reply);
    if(ret == -1)
      goto err_handle;

    else
      if(ret == -2)
      {
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "client bug: invalid header");
        while((_Bool)0);
        goto err_handle;
      }

      else
        if(ret == -3)
          goto err_handle;


  __CPROVER_DUMP_L4:
    ;
    if(!(proxy->xnbd->readonly == 0))
    {
      if(iotype == 1u)
      {
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "NBD_CMD_WRITE to a readonly server. disconnect.");
        while((_Bool)0);
        goto err_handle;
      }

    }

    get_io_range_index(iofrom, iolen, &block_index_start, &block_index_end);

  __CPROVER_DUMP_L7:
    ;

  __CPROVER_DUMP_L8:
    ;
    priv->iotype = iotype;
    priv->iofrom = iofrom;
    priv->iolen = iolen;
    priv->block_index_start = block_index_start;
    priv->block_index_end = block_index_end;
    if(iotype == 1u)
    {
      void *return_value_g_malloc_2;
      return_value_g_malloc_2=g_malloc(iolen);
      priv->write_buff = (char *)return_value_g_malloc_2;
      ret=net_recv_all_or_error(priv->clientfd, (void *)priv->write_buff, priv->iolen);
      if(!(ret >= 0))
      {
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "recv write data");
        while((_Bool)0);
        goto err_handle;
      }

    }

    else
      if(iotype == 0u)
      {
        void *return_value_g_malloc_3;
        return_value_g_malloc_3=g_malloc(iolen);
        priv->read_buff = (char *)return_value_g_malloc_3;
      }

      else
        if(!(iotype == 3u))
        {
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "client bug: unknown iotype");
          while((_Bool)0);
          goto err_handle;
        }

    mem_usage_wait(proxy);
    mem_usage_add(proxy, priv);
    g_async_queue_push(proxy->fwd_tx_queue, (void *)priv);
    return 0;
  }

  else
  {
    do
    {

    err_handle:
      ;
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "start terminating session (nbd_fd %d wrk_fd %d)", ps->nbd_fd, ps->wrk_fd);
    }
    while((_Bool)0);
    priv->need_exit = 1;
    priv->iotype = (unsigned int)6;
    mem_usage_add(proxy, priv);
    g_async_queue_push(proxy->fwd_tx_queue, (void *)priv);
    return -1;
  }
}

// rx_thread_main
// file xnbd_proxy.c line 424
void * rx_thread_main(void *arg)
{
  struct proxy_session *ps = (struct proxy_session *)arg;
  set_process_name("proxy_rx");
  block_all_signals();
  do
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "rx_thread %lu starts", return_value_pthread_self_1);
  }
  while((_Bool)0);
  do
  {
    signed int ret;
    ret=recv_request(ps);
    if(!(ret >= 0))
      break;

  }
  while((_Bool)1);
  do
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "rx_thread %lu exits", return_value_pthread_self_2);
  }
  while((_Bool)0);
  return (void *)0;
}

// sender_thread_main
// file xnbd_tester.c line 202
void * sender_thread_main(void *data)
{
  struct parameters *params = (struct parameters *)data;
  unsigned int index = (unsigned int)0;
  signed long int return_value_random_2;
  signed long int tmp_if_expr_6;
  for( ; !(index >= params->nreq); index = index + 1u)
  {
    struct crequest *req;
    void *return_value_g_malloc0_1;
    return_value_g_malloc0_1=g_malloc0(sizeof(struct crequest) /*40ul*/ );
    req = (struct crequest *)return_value_g_malloc0_1;

  __CPROVER_DUMP_L2:
    ;
    if((signed int)params->rwmode == TESTRDWR)
    {
      return_value_random_2=random();
      if(!(return_value_random_2 % 2l == 0l))
        req->iotype = (unsigned int)0;

      else
        req->iotype = (unsigned int)1;
    }

    else
      if((signed int)params->rwmode == TESTRDONLY)
        req->iotype = (unsigned int)0;

      else
        if((signed int)params->rwmode == TESTWRONLY)
          req->iotype = (unsigned int)1;

        else
        {
          unsigned long int return_value_pthread_self_3;
          return_value_pthread_self_3=pthread_self();
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) unknown rwmode", return_value_pthread_self_3, (const void *)"sender_thread_main");

        __CPROVER_DUMP_L8:
          ;
          goto __CPROVER_DUMP_L8;
        }
    signed long int return_value_random_4;
    return_value_random_4=random();
    req->iofrom = (signed long int)((1.0L * (long double)params->disksize * (long double)return_value_random_4) / (long double)2147483647);
    unsigned long int tmp_iolen;
    signed long int return_value_random_5;
    return_value_random_5=random();
    tmp_iolen = (unsigned long int)((long double)1 + (10000.0L * (long double)return_value_random_5) / (long double)2147483647);
    if(!((signed long int)tmp_iolen >= params->disksize + -req->iofrom))
      tmp_if_expr_6 = (signed long int)tmp_iolen;

    else
      tmp_if_expr_6 = params->disksize - req->iofrom;
    req->iolen = (unsigned long int)tmp_if_expr_6;
    const char *return_value_nbd_get_iotype_string_7;
    return_value_nbd_get_iotype_string_7=nbd_get_iotype_string(req->iotype);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "index %d req %p iotype %s iofrom %ju iolen %zu", index, req, return_value_nbd_get_iotype_string_7, req->iofrom, req->iolen);
    do
      if(!((unsigned long int)params->disksize >= req->iolen + (unsigned long int)req->iofrom))
        g_assertion_message_expr((char *)0, "xnbd_tester.c", 237, (const char *)"sender_thread_main", "req->iofrom + req->iolen <= (unsigned long)params->disksize");

    while((_Bool)0);
    nbd_client_send_request_header(params->remotefd, req->iotype, req->iofrom, req->iolen, (unsigned long int)index);
    if(req->iotype == 1u)
    {
      void *return_value_g_malloc_8;
      return_value_g_malloc_8=g_malloc(req->iolen);
      req->write_buff = (char *)return_value_g_malloc_8;
      fill_random(req->write_buff, req->iolen);
      net_send_all_or_abort(params->remotefd, (const void *)req->write_buff, req->iolen);
    }

    req->index = index;
    g_async_queue_push(reply_pendings, (void *)req);
    signed long int return_value_random_9;
    return_value_random_9=random();
    poll((struct pollfd *)(void *)0, (unsigned long int)0, (signed int)((10.0L * (long double)return_value_random_9) / (long double)2147483647));
  }
  g_async_queue_push(reply_pendings, (void *)&eofmarker);
  g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "%d requests were sent", params->nreq);
  return (void *)0;
}

// set_process_name
// file lib/common.h line 95
void set_process_name(const char *name)
{
  char comm[16l];
  strncpy(comm, name, sizeof(char [16l]) /*16ul*/ );
  signed int ret;
  ret=prctl(15, (unsigned long int)comm, 0l, 0l, 0l);
  if(!(ret >= 0))
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "set_name %m");
    while((_Bool)0);

}

// set_sigactions
// file xnbd_tester.c line 586
static void set_sigactions()
{
  struct sigaction act;
  memset((void *)&act, 0, sizeof(struct sigaction) /*152ul*/ );
  act.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  sigaction(13, &act, (struct sigaction *)(void *)0);
}

// show_help_and_exit
// file xnbd_tester.c line 604
void show_help_and_exit(const char *msg)
{
  if(!(msg == ((const char *)NULL)))
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "%s\n", msg);
    while((_Bool)0);

  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "make xnbd-server xnbd-tester");
  while((_Bool)0);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "For target mode");
  while((_Bool)0);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "  ./xnbd-server --target --lport 8992 disk1G.img");
  while((_Bool)0);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "  ./xnbd-tester --rwmode 1 localhost 8992 disk1G.img /tmp/tmp.img");
  while((_Bool)0);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, " ");
  while((_Bool)0);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "For proxy mode");
  while((_Bool)0);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "  ./xnbd-server --target --lport 8992 disk1G.img");
  while((_Bool)0);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "  ./xnbd-server --proxy --lport 8521 localhost 8992 /tmp/disk.cache /tmp/disk.cache.bitmap /tmp/xnbd-bg.ctl");
  while((_Bool)0);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "  ./xnbd-tester --rwmode 1 --bgctlpath /tmp/xnbd-bg.ctl localhost 8521 /tmp/disk.cache /tmp/tmp.img");
  while((_Bool)0);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, " ");
  while((_Bool)0);
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) See source code for detail.", return_value_pthread_self_1, (const void *)"show_help_and_exit");

__CPROVER_DUMP_L13:
  ;
  goto __CPROVER_DUMP_L13;
}

// sigmask_all
// file io.c line 270
void sigmask_all(void)
{
  struct anonymous_2 sig;
  signed int ret;
  ret=sigfillset(&sig);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) sigfillset", return_value_pthread_self_1, (const void *)"sigmask_all");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  ret=pthread_sigmask(2, &sig, (struct anonymous_2 *)(void *)0);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) sigmask", return_value_pthread_self_2, (const void *)"sigmask_all");

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

}

// syslog_level
// file common.c line 46
signed int syslog_level(signed int glib_log_level)
{
  signed int level = 6;
  switch(glib_log_level & G_LOG_LEVEL_MASK)
  {
    case G_LOG_LEVEL_CRITICAL:
    {
      level = 2;
      break;
    }
    case G_LOG_LEVEL_ERROR:
    {
      level = 3;
      break;
    }
    case G_LOG_LEVEL_WARNING:
    {
      level = 4;
      break;
    }
    case G_LOG_LEVEL_MESSAGE:
    {
      level = 5;
      break;
    }
    case G_LOG_LEVEL_INFO:
    {
      level = 6;
      break;
    }
    case G_LOG_LEVEL_DEBUG:
    {
      level = 7;
      break;
    }
    default:
      level = 2;
  }
  return level | 3 << 3;
}

// target_mode_main_cow
// file xnbd_target_cow_lzo.c line 748
signed int target_mode_main_cow(struct xnbd_session *ses)
{
  struct xnbd_info *xnbd = ses->xnbd;
  struct nbd_reply reply;
  signed int csock = ses->clientfd;
  unsigned int iotype = (unsigned int)0;
  signed long int iofrom = (signed long int)0;
  unsigned long int iolen = (unsigned long int)0;
  signed int ret;
  memset((void *)&reply, 0, sizeof(struct nbd_reply) /*16ul*/ );
  reply.magic=htonl((unsigned int)0x67446698);
  reply.error = (unsigned int)0;
  ret=poll_request_arrival(ses);
  unsigned long int return_value_pthread_self_3;
  if(!(ret >= 0))
    return -1;

  else
  {
    ret=nbd_server_recv_request(csock, xnbd->disksize, &iotype, &iofrom, &iolen, &reply);
    if(ret == -1)
    {
      net_send_all_or_abort(csock, (const void *)&reply, sizeof(struct nbd_reply) /*16ul*/ );
      return 0;
    }

    else
      if(ret == -2)
      {
        unsigned long int return_value_pthread_self_1;
        return_value_pthread_self_1=pthread_self();
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) client bug: invalid header", return_value_pthread_self_1, (const void *)"target_mode_main_cow");

      __CPROVER_DUMP_L4:
        ;
        goto __CPROVER_DUMP_L4;
      }

      else
        if(ret == -3)
          return ret;

    signed int compression_enabled = 0;
    signed int compression_lzo = 0;
    if(iotype == 4u || iotype == 5u)
    {

    __CPROVER_DUMP_L7:
      ;
      compression_enabled = 1;
      if(iotype == 5u)
        compression_lzo = 1;


    __CPROVER_DUMP_L8:
      ;
      iotype = (unsigned int)0;
    }

    if(!(xnbd->readonly == 0))
    {
      if(iotype == 1u)
      {
        unsigned long int return_value_pthread_self_2;
        return_value_pthread_self_2=pthread_self();
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) NBD_CMD_WRITE to a readonly disk. disconnect.", return_value_pthread_self_2, (const void *)"target_mode_main_cow");

      __CPROVER_DUMP_L12:
        ;
        goto __CPROVER_DUMP_L12;
      }

    }


  __CPROVER_DUMP_L13:
    ;
    struct disk_stack_io *io;
    io=disk_stack_mmap(xnbd->cow_ds, iofrom, iolen, (signed int)(iotype == (unsigned int)0));
    switch(iotype)
    {
      case (unsigned int)1:
      {

      __CPROVER_DUMP_L14:
        ;
        net_readv_all_or_abort(csock, io->iov, io->iov_size);
        net_send_all_or_abort(csock, (const void *)&reply, sizeof(struct nbd_reply) /*16ul*/ );
        break;
      }
      case (unsigned int)0:
      {

      __CPROVER_DUMP_L15:
        ;
        net_send_all_or_abort(csock, (const void *)&reply, sizeof(struct nbd_reply) /*16ul*/ );
        if(!(compression_enabled == 0))
          compress_iovec_and_send_advanced(csock, io->iov, io->iov_size, compression_lzo);

        else
          net_writev_all_or_abort(csock, io->iov, io->iov_size);
        break;
      }
      default:
      {
        return_value_pthread_self_3=pthread_self();
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) unknown command %u", return_value_pthread_self_3, (const void *)"target_mode_main_cow", iotype);

      __CPROVER_DUMP_L19:
        ;
        goto __CPROVER_DUMP_L19;
      }
    }
    free_disk_stack_io(io);
    return 0;
  }
}

// test_direct_mode
// file xnbd_tester.c line 483
signed int test_direct_mode(char *srcdisk, char *tgtdisk, signed int remotefd, signed int cowmode, enum xnbd_tester_rwmode rwmode, const char *bgctlpath)
{
  signed int result = 0;
  signed long int now;
  now=time((signed long int *)(void *)0);
  srandom((unsigned int)now);
  reply_pendings=g_async_queue_new();
  check_pendings=g_async_queue_new();
  signed long int disksize;
  disksize=nbd_negotiate_with_server(remotefd);
  g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "remote disk size %ju", disksize);
  sleep((unsigned int)3);
  signed long int return_value_get_disksize_of_path_2;
  return_value_get_disksize_of_path_2=get_disksize_of_path(srcdisk);
  if(!(disksize == return_value_get_disksize_of_path_2))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) %s size not match to %ju", return_value_pthread_self_1, (const void *)"test_direct_mode", srcdisk, disksize);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  signed int tgtdiskfd;
  tgtdiskfd=open(tgtdisk, 02 | 0100 | 01000, 0400 | 0200);
  if(!(tgtdiskfd >= 0))
  {
    unsigned long int return_value_pthread_self_3;
    return_value_pthread_self_3=pthread_self();
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) tgt disk open %s", return_value_pthread_self_3, (const void *)"test_direct_mode", return_value_strerror_5);

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

  signed int ret;
  ret=ftruncate(tgtdiskfd, disksize);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_6;
    return_value_pthread_self_6=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) ftruncate %m", return_value_pthread_self_6, (const void *)"test_direct_mode");

  __CPROVER_DUMP_L8:
    ;
    goto __CPROVER_DUMP_L8;
  }

  unsigned long int testcount = (unsigned long int)0;
  struct parameters params = { .nreq=(unsigned int)1000, .rwmode=rwmode, .disksize=disksize,
    .remotefd=remotefd, .tgtdiskfd=tgtdiskfd };
  signed int loop_per_session = 0;
  for( ; !(loop_per_session >= 100); loop_per_session = loop_per_session + 1)
  {
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "io start");
    bgctl_thread_create(disksize, bgctlpath);
    signed int aaa;
    signed long int return_value_random_7;
    return_value_random_7=random();
    aaa = (signed int)((1000.0L * (long double)return_value_random_7) / (long double)2147483647);
    poll((struct pollfd *)(void *)0, (unsigned long int)0, aaa);
    unsigned long int tid_sender;
    tid_sender=pthread_create_or_abort(sender_thread_main, (void *)&params);
    unsigned long int tid_receiver;
    tid_receiver=pthread_create_or_abort(receiver_thread_main, (void *)&params);
    pthread_join(tid_sender, (void **)(void *)0);
    pthread_join(tid_receiver, (void **)(void *)0);
    bgctl_wait_shutdown();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "sender and receiver finished");
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "checking start ...");
    do
    {
      struct crequest *req;
      void *return_value_g_async_queue_pop_8;
      return_value_g_async_queue_pop_8=g_async_queue_pop(check_pendings);
      req = (struct crequest *)return_value_g_async_queue_pop_8;
      if(req == &eofmarker)
        break;

      if(!(cowmode == 0))
        result=check_consistency_by_partial_mmap_for_cowdisk(srcdisk, tgtdiskfd, req);

      else
        result=check_consistency_by_partial_mmap(srcdisk, tgtdiskfd, req);
      if(!(result >= 0))
        goto err_out;

      if(req->iotype == 1u)
        g_free((void *)req->write_buff);

      g_free((void *)req);
    }
    while((_Bool)1);
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "checking done");
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "## test %ju done", testcount);
    sleep((unsigned int)1);
    testcount = testcount + (unsigned long int)1;
  }

err_out:
  ;
  g_async_queue_unref(reply_pendings);
  g_async_queue_unref(check_pendings);
  close(tgtdiskfd);
  return result;
}

// tx_thread_main
// file xnbd_proxy.c line 448
void * tx_thread_main(void *arg)
{
  struct proxy_session *ps = (struct proxy_session *)arg;
  signed int need_exit = 0;
  signed int need_skip = 0;
  set_process_name("proxy_tx");
  block_all_signals();
  do
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "tx_thread %lu starts", return_value_pthread_self_1);
  }
  while((_Bool)0);
  do
  {
    struct proxy_priv *priv;
    void *return_value_g_async_queue_pop_2;
    return_value_g_async_queue_pop_2=g_async_queue_pop(ps->tx_queue);
    priv = (struct proxy_priv *)return_value_g_async_queue_pop_2;
    proxy_priv_dump(priv);
    if(!(priv->need_exit == 0))
      need_exit = 1;

    else
      if(need_skip == 0)
      {
        struct iovec iov[2l];
        unsigned int iov_size = (unsigned int)0;
        iov[(signed long int)iov_size].iov_base = (void *)&priv->reply;
        iov[(signed long int)iov_size].iov_len = sizeof(struct nbd_reply) /*16ul*/ ;
        iov_size = iov_size + (unsigned int)1;
        if(priv->iotype == 0u)
        {
          iov[(signed long int)iov_size].iov_base = (void *)priv->read_buff;
          iov[(signed long int)iov_size].iov_len = priv->iolen;
          iov_size = iov_size + (unsigned int)1;
        }

        signed int ret;
        ret=net_writev_all_or_error(priv->clientfd, iov, iov_size);
        if(!(ret >= 0))
        {
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "clientfd %d is dead", priv->clientfd);
          while((_Bool)0);
          need_skip = 1;
        }

      }

    if(!(priv->read_buff == ((char *)NULL)))
      g_free((void *)priv->read_buff);

    if(!(priv->write_buff == ((char *)NULL)))
      g_free((void *)priv->write_buff);

    mem_usage_del(ps->proxy, priv);
    do
      g_slice_free1(sizeof(struct proxy_priv) /*624ul*/ , (void *)priv);
    while((_Bool)0);
    if(!(need_exit == 0))
      break;

  }
  while((_Bool)1);
  net_send_all_or_abort(ps->pipe_write_fd, (const void *)"", (unsigned long int)1);
  do
  {
    unsigned long int return_value_pthread_self_3;
    return_value_pthread_self_3=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "tx_thread %lu exits", return_value_pthread_self_3);
  }
  while((_Bool)0);
  return (void *)0;
}

// unix_connect
// file lib/net.h line 80
signed int unix_connect(const char *path)
{
  signed int fd;
  fd=socket(1, 1, 0);
  if(!(fd >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) socket %m", return_value_pthread_self_1, (const void *)"unix_connect");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  struct sockaddr_un cliaddr;
  cliaddr.sun_family = (unsigned short int)1;
  g_strlcpy(cliaddr.sun_path, path, sizeof(char [108l]) /*108ul*/ );
  signed int ret;
  ret=connect(fd, (struct sockaddr *)&cliaddr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) connect %m", return_value_pthread_self_2, (const void *)"unix_connect");

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

  return fd;
}

// unix_recv_fd
// file lib/net.h line 82
signed int unix_recv_fd(signed int socket)
{
  struct msghdr msg;
  memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
  signed int fd;
  char buf[1l];
  struct iovec iov[1l];
  iov[(signed long int)0].iov_base = (void *)buf;
  iov[(signed long int)0].iov_len = sizeof(char [1l]) /*1ul*/ ;
  msg.msg_iov = iov;
  msg.msg_iovlen = (unsigned long int)1;
  char data_buf[24l];
  msg.msg_control = (void *)data_buf;
  msg.msg_controllen = sizeof(char [24l]) /*24ul*/ ;
  signed int ret;
  signed long int return_value_recvmsg_1;
  return_value_recvmsg_1=recvmsg(socket, &msg, 0);
  ret = (signed int)return_value_recvmsg_1;
  if(ret == -1)
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) recv_fd, %m", return_value_pthread_self_2, (const void *)"unix_recv_fd");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  else
    if(ret == 0)
    {
      unsigned long int return_value_pthread_self_3;
      return_value_pthread_self_3=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) recv_fd, peer closed", return_value_pthread_self_3, (const void *)"unix_recv_fd");

    __CPROVER_DUMP_L5:
      ;
      goto __CPROVER_DUMP_L5;
    }

  struct cmsghdr *cmsg;
  struct cmsghdr *tmp_if_expr_4;
  if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
    tmp_if_expr_4 = (struct cmsghdr *)(&msg)->msg_control;

  else
    tmp_if_expr_4 = (struct cmsghdr *)0;
  cmsg = tmp_if_expr_4;
  if(cmsg == ((struct cmsghdr *)NULL))
  {
    unsigned long int return_value_pthread_self_5;
    return_value_pthread_self_5=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) no cmsghdr", return_value_pthread_self_5, (const void *)"unix_recv_fd");

  __CPROVER_DUMP_L10:
    ;
    goto __CPROVER_DUMP_L10;
  }

  _Bool tmp_if_expr_7;
  if(cmsg->cmsg_len == sizeof(signed int) * 5 /*20ul*/ )
    tmp_if_expr_7 = cmsg->cmsg_level == 1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_7 = (_Bool)0;
  _Bool tmp_if_expr_8;
  if(tmp_if_expr_7)
    tmp_if_expr_8 = cmsg->cmsg_type == 1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_8 = (_Bool)0;
  if(tmp_if_expr_8)
  {
    signed int *fdptr = (signed int *)cmsg->__cmsg_data;
    fd = *fdptr;
  }

  else
  {
    unsigned long int return_value_pthread_self_6;
    return_value_pthread_self_6=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) no descriptor", return_value_pthread_self_6, (const void *)"unix_recv_fd");

  __CPROVER_DUMP_L17:
    ;
    goto __CPROVER_DUMP_L17;
  }
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "fd %d received", fd);
  while((_Bool)0);
  return fd;
}

// unix_send_fd
// file lib/net.h line 81
signed int unix_send_fd(signed int socket, signed int fd)
{
  struct msghdr msg;
  memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
  struct iovec iov[1l];
  iov[(signed long int)0].iov_base = (void *)(char *)"";
  iov[(signed long int)0].iov_len = (unsigned long int)1;
  msg.msg_iov = iov;
  msg.msg_iovlen = (unsigned long int)1;
  char data_buf[24l];
  msg.msg_control = (void *)data_buf;
  msg.msg_controllen = sizeof(char [24l]) /*24ul*/ ;
  struct cmsghdr *cmsg;
  struct cmsghdr *tmp_if_expr_1;
  if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
    tmp_if_expr_1 = (struct cmsghdr *)(&msg)->msg_control;

  else
    tmp_if_expr_1 = (struct cmsghdr *)0;
  cmsg = tmp_if_expr_1;
  cmsg->cmsg_level = 1;
  cmsg->cmsg_type = 1;
  cmsg->cmsg_len = ((sizeof(struct cmsghdr) /*16ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1)) + sizeof(signed int) /*4ul*/ ;
  signed int *fdptr = (signed int *)cmsg->__cmsg_data;
  *fdptr = fd;
  msg.msg_controllen = cmsg->cmsg_len;
  signed int ret;
  signed long int return_value_sendmsg_2;
  return_value_sendmsg_2=sendmsg(socket, &msg, 0);
  ret = (signed int)return_value_sendmsg_2;
  if(ret == -1)
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "send_fd, %m");
    while((_Bool)0);

  else
    if(ret == 0)
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "send_fd, peer closed");
      while((_Bool)0);

  return ret;
}

// unshift_func
// file xnbd_proxy.c line 522
static signed int unshift_func(const void *a, const void *b, void *user_data)
{
  return -1;
}

// update_block_with_found
// file xnbd_target_cow_lzo.c line 320
static void update_block_with_found(struct disk_stack *ds, struct disk_stack_io *io, unsigned long int index, unsigned long int start_index)
{
  signed int found = 0;
  signed int i = ds->nlayers - 1;
  for( ; i >= 0; i = i - 1)
  {
    struct disk_image *di = ds->image[(signed long int)i];
    signed int return_value_bitmap_test_1;
    return_value_bitmap_test_1=bitmap_test(di->bm, index);
    if(!(return_value_bitmap_test_1 == 0))
    {

    __CPROVER_DUMP_L2:
      ;
      char *dstptr = io->bufs[(signed long int)(ds->nlayers - 1)] + (signed long int)((unsigned long int)CBLOCKSIZE * (index - start_index));
      char *srcptr = io->bufs[(signed long int)i] + (signed long int)((unsigned long int)CBLOCKSIZE * (index - start_index));
      memcpy((void *)dstptr, (const void *)srcptr, (unsigned long int)CBLOCKSIZE);
      found = 1;
      break;
    }

  }
  if(found == 0)
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) bug", return_value_pthread_self_2, (const void *)"update_block_with_found");

  __CPROVER_DUMP_L6:
    ;
    goto __CPROVER_DUMP_L6;
  }

}

// wait_until_readable
// file lib/io.h line 60
signed int wait_until_readable(signed int fd, signed int unblock_fd)
{
  struct pollfd eventfds[2l];

__CPROVER_DUMP_L1:
  ;
  eventfds[(signed long int)0].fd = fd;
  eventfds[(signed long int)0].events = (signed short int)(0x040 | 0x2000);
  eventfds[(signed long int)1].fd = unblock_fd;
  eventfds[(signed long int)1].events = (signed short int)(0x040 | 0x2000);
  signed int nready;
  nready=poll(eventfds, (unsigned long int)2, -1);
  if(nready == -1)
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    if(*return_value___errno_location_5 == 4)
    {
      do
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "polling signal cached");
      while((_Bool)0);
      return -1;
    }

    else
    {
      unsigned long int return_value_pthread_self_1;
      return_value_pthread_self_1=pthread_self();
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) polling, %s, (%d)", return_value_pthread_self_1, (const void *)"wait_until_readable", return_value_strerror_3, *return_value___errno_location_4);

    __CPROVER_DUMP_L5:
      ;
      goto __CPROVER_DUMP_L5;
    }
  }

  if(!((8256 & (signed int)eventfds[1l].revents) == 0))
  {
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "notified");
    while((_Bool)0);
    return -1;
  }

  else
    if(!((8256 & (signed int)eventfds[0l].revents) == 0))
      return 0;

    else
    {
      unsigned long int return_value_pthread_self_6;
      return_value_pthread_self_6=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) unknown ppoll events", return_value_pthread_self_6, (const void *)"wait_until_readable");

    __CPROVER_DUMP_L11:
      ;
      goto __CPROVER_DUMP_L11;
    }
}

// write_all
// file lib/io.h line 40
void write_all(signed int fd, const void *buf, unsigned long int len)
{
  io_all(fd, (void *)buf, len, 0);
}

// xnbd_cow_target_close_disk
// file xnbd.h line 251
void xnbd_cow_target_close_disk(struct disk_stack *ds, signed int delete_cow)
{
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "close cow disk");
  while((_Bool)0);
  do
    if(ds == ((struct disk_stack *)NULL))
      g_assertion_message_expr((char *)0, "xnbd_target_cow_lzo.c", 382, (const char *)"xnbd_cow_target_close_disk", "ds");

  while((_Bool)0);
  if(!(delete_cow == 0))
  {
    struct disk_image *di_cow = ds->image[(signed long int)(ds->nlayers - 1)];
    signed int ret;
    ret=unlink(di_cow->path);
    if(!(ret >= 0))
    {
      unsigned long int return_value_pthread_self_1;
      return_value_pthread_self_1=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) unlink %m", return_value_pthread_self_1, (const void *)"xnbd_cow_target_close_disk");

    __CPROVER_DUMP_L6:
      ;
      goto __CPROVER_DUMP_L6;
    }

    ret=unlink(di_cow->bmpath);
    if(!(ret >= 0))
    {
      unsigned long int return_value_pthread_self_2;
      return_value_pthread_self_2=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) unlink %m", return_value_pthread_self_2, (const void *)"xnbd_cow_target_close_disk");

    __CPROVER_DUMP_L9:
      ;
      goto __CPROVER_DUMP_L9;
    }

  }

  destroy_disk_stack(ds);
}

// xnbd_cow_target_open_disk
// file xnbd.h line 250
struct disk_stack * xnbd_cow_target_open_disk(char *diskpath, signed int newfile, signed int cowid)
{
  struct disk_stack *ds;
  ds=create_disk_stack(diskpath);
  char *cowpath;
  if(!(newfile == 0))
    do
    {
      cowpath=g_strdup_printf("%s.cow%d.layer%d", diskpath, cowid, ds->nlayers - 1);
      signed int fd;
      fd=open(cowpath, 02 | 0100 | 0200, 0600);
      if(!(fd >= 0))
      {
        cowid = cowid + 1;
        g_free((void *)cowpath);
        continue;
      }

      else
      {
        close(fd);
        break;
      }
    }
    while((_Bool)1);

  else
    cowpath=g_strdup_printf("%s.cow%d.layer%d", diskpath, cowid, ds->nlayers - 1);
  disk_stack_add_image(ds, cowpath, newfile);
  g_free((void *)cowpath);
  return ds;
}

// xnbd_cow_target_session_server
// file xnbd_target_cow_lzo.c line 857
signed int xnbd_cow_target_session_server(struct xnbd_session *ses)
{
  set_process_name("cow_wrk");
  do
  {
    signed int ret = 0;
    ret=target_mode_main_cow(ses);
    if(!(ret >= 0))
      return ret;

  }
  while((_Bool)1);
  return 0;
}

// xnbd_proxy_control_cache_block
// file xnbd_proxy.h line 141
void xnbd_proxy_control_cache_block(signed int ctl_fd, unsigned long int index, unsigned long int nblocks)
{
  signed long int iofrom = (signed long int)index * (signed long int)CBLOCKSIZE;
  unsigned long int iolen = nblocks * (unsigned long int)CBLOCKSIZE;
  signed int ret;
  ret=nbd_client_send_request_header(ctl_fd, (unsigned int)3, iofrom, iolen, 18446744073709551615UL);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) send_read_request, %m", return_value_pthread_self_1, (const void *)"xnbd_proxy_control_cache_block");

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  ret=nbd_client_recv_header(ctl_fd);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) recv header, %m", return_value_pthread_self_2, (const void *)"xnbd_proxy_control_cache_block");

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

}

// xnbd_proxy_session_server
// file xnbd_proxy.c line 885
signed int xnbd_proxy_session_server(struct xnbd_session *ses)
{
  struct xnbd_info *xnbd = ses->xnbd;
  set_process_name("proxy_wrk");
  signed int unix_fd;
  unix_fd=unix_connect(xnbd->proxy_unixpath);
  enum xnbd_proxy_cmd_type cmd = (enum xnbd_proxy_cmd_type)XNBD_PROXY_CMD_REGISTER_FD;
  net_send_all_or_abort(unix_fd, (const void *)&cmd, sizeof(enum xnbd_proxy_cmd_type) /*4ul*/ );
  unix_send_fd(unix_fd, ses->clientfd);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "proxy worker: send fd %d via unix_fd %d", ses->clientfd, unix_fd);
  while((_Bool)0);
  signed int ret;
  struct pollfd eventfds[2l];
  unsigned long int neventfds = (unsigned long int)0;
  eventfds[(signed long int)neventfds].fd = unix_fd;
  eventfds[(signed long int)neventfds].events = (signed short int)(0x040 | 0x2000);
  neventfds = neventfds + (unsigned long int)1;
  eventfds[(signed long int)neventfds].fd = ses->pipe_worker_fd;
  eventfds[(signed long int)neventfds].events = (signed short int)(0x040 | 0x2000);
  neventfds = neventfds + (unsigned long int)1;
  block_all_signals();
  do
  {
    signed int nready;
    nready=poll(eventfds, neventfds, -1);
    if(nready == -1)
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      if(*return_value___errno_location_6 == 4)
      {
        unsigned long int return_value_pthread_self_1;
        return_value_pthread_self_1=pthread_self();
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) proxy worker: catch an unexpected signal", return_value_pthread_self_1, (const void *)"xnbd_proxy_session_server");

      __CPROVER_DUMP_L4:
        ;
        goto __CPROVER_DUMP_L4;
      }

      else
      {
        unsigned long int return_value_pthread_self_2;
        return_value_pthread_self_2=pthread_self();
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        char *return_value_strerror_4;
        return_value_strerror_4=strerror(*return_value___errno_location_3);
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) polling, %s, (%d)", return_value_pthread_self_2, (const void *)"xnbd_proxy_session_server", return_value_strerror_4, *return_value___errno_location_5);

      __CPROVER_DUMP_L6:
        ;
        goto __CPROVER_DUMP_L6;
      }
    }

    if(!((8256 & (signed int)eventfds[0l].revents) == 0))
    {
      char buf[1l];
      ret=net_recv_all_or_error(eventfds[(signed long int)0].fd, (void *)buf, (unsigned long int)1);
      if(!(ret >= 0))
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "proxy worker: detect the incorrect termination of xnbd_proxy");
        while((_Bool)0);

      else
        do
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "proxy worker: detect the session exited");
        while((_Bool)0);
      break;
    }

    else
      if(!((8256 & (signed int)eventfds[1l].revents) == 0))
      {
        char xnbd_proxy_session_server__1__2__1__3__buf[1l];
        ret=net_recv_all_or_error(eventfds[(signed long int)1].fd, (void *)xnbd_proxy_session_server__1__2__1__3__buf, (unsigned long int)1);
        if(!(ret >= 0))
        {
          unsigned long int return_value_pthread_self_7;
          return_value_pthread_self_7=pthread_self();
          g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) proxy worker: the master server was incorrectly terminated?", return_value_pthread_self_7, (const void *)"xnbd_proxy_session_server");

        __CPROVER_DUMP_L14:
          ;
          goto __CPROVER_DUMP_L14;
        }

        else
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "proxy worker: be requested session termination");
          while((_Bool)0);
        ret=net_send_all_or_error(unix_fd, (const void *)"", (unsigned long int)1);
        if(!(ret >= 0))
          do
            g_log((char *)0, (enum anonymous)G_LOG_LEVEL_WARNING, "proxy worker: sending session termination request failed");
          while((_Bool)0);

      }

      else
      {
        unsigned long int return_value_pthread_self_8;
        return_value_pthread_self_8=pthread_self();
        g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) not reached", return_value_pthread_self_8, (const void *)"xnbd_proxy_session_server");

      __CPROVER_DUMP_L20:
        ;
        goto __CPROVER_DUMP_L20;
      }
  }
  while((_Bool)1);
  return 0;
}

// xnbd_proxy_start
// file xnbd_proxy.c line 771
void xnbd_proxy_start(struct xnbd_info *xnbd)
{
  signed int ret;

__CPROVER_DUMP_L1:
  ;
  char *tmp_if_expr_1;
  do
  {
    if(!(xnbd->proxy_target_exportname == ((char *)NULL)))
      tmp_if_expr_1 = xnbd->proxy_target_exportname;

    else
      tmp_if_expr_1 = "";
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "proxymode mode %s %s (%s%s) cache %s cachebitmap %s", xnbd->proxy_rhost, xnbd->proxy_rport, xnbd->proxy_target_exportname != ((char *)NULL) ? "xnbd-wrapper:" : "xnbd-server", tmp_if_expr_1, xnbd->proxy_diskpath, xnbd->proxy_bmpath);
  }
  while((_Bool)0);
  signed int remotefd;
  remotefd=net_connect(xnbd->proxy_rhost, xnbd->proxy_rport, 1, 6);
  if(!(remotefd >= 0))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) connecting %s:%s failed", return_value_pthread_self_2, (const void *)"xnbd_proxy_start", xnbd->proxy_rhost, xnbd->proxy_rport);

  __CPROVER_DUMP_L6:
    ;
    goto __CPROVER_DUMP_L6;
  }

  unsigned long int return_value_strlen_3;
  if(!(xnbd->proxy_target_exportname == ((char *)NULL)))
  {
    return_value_strlen_3=strlen(xnbd->proxy_target_exportname);
    ret=nbd_negotiate_with_server_new(remotefd, &xnbd->disksize, (unsigned int *)(void *)0, return_value_strlen_3, xnbd->proxy_target_exportname);
  }

  else
    ret=nbd_negotiate_with_server2(remotefd, &xnbd->disksize, (unsigned int *)(void *)0);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_4;
    return_value_pthread_self_4=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) negotiation with %s:%s failed", return_value_pthread_self_4, (const void *)"xnbd_proxy_start", xnbd->proxy_rhost, xnbd->proxy_rport);

  __CPROVER_DUMP_L11:
    ;
    goto __CPROVER_DUMP_L11;
  }

  xnbd->nblocks=get_disk_nblocks(xnbd->disksize);
  make_sockpair(&xnbd->proxy_sockpair_master_fd, &xnbd->proxy_sockpair_proxy_fd);
  signed int pid;
  pid=fork_or_abort();
  if(pid == 0)
  {
    set_process_name("proxy_main");
    close(xnbd->proxy_sockpair_master_fd);
    block_all_signals();
    struct xnbd_proxy *proxy;
    void *return_value_g_malloc0_5;
    return_value_g_malloc0_5=g_malloc0(sizeof(struct xnbd_proxy) /*104ul*/ );
    proxy = (struct xnbd_proxy *)return_value_g_malloc0_5;
    proxy_initialize(xnbd, proxy);
    proxy_initialize_forwarder(proxy, remotefd);
    signed int unix_listen_fd;
    unix_listen_fd=socket(1, 1, 0);
    if(!(unix_listen_fd >= 0))
    {
      unsigned long int return_value_pthread_self_6;
      return_value_pthread_self_6=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) socket %m", return_value_pthread_self_6, (const void *)"xnbd_proxy_start");

    __CPROVER_DUMP_L14:
      ;
      goto __CPROVER_DUMP_L14;
    }

    struct sockaddr_un srvaddr;
    srvaddr.sun_family = (unsigned short int)1;
    g_strlcpy(srvaddr.sun_path, xnbd->proxy_unixpath, sizeof(char [108l]) /*108ul*/ );
    ret=bind(unix_listen_fd, &srvaddr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
    if(!(ret >= 0))
    {
      unsigned long int return_value_pthread_self_7;
      return_value_pthread_self_7=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) binding to %s: %m", return_value_pthread_self_7, (const void *)"xnbd_proxy_start", xnbd->proxy_unixpath);

    __CPROVER_DUMP_L17:
      ;
      goto __CPROVER_DUMP_L17;
    }

    ret=listen(unix_listen_fd, 10);
    if(!(ret >= 0))
    {
      unsigned long int return_value_pthread_self_8;
      return_value_pthread_self_8=pthread_self();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) listening to %s: %m", return_value_pthread_self_8, (const void *)"xnbd_proxy_start", xnbd->proxy_unixpath);

    __CPROVER_DUMP_L20:
      ;
      goto __CPROVER_DUMP_L20;
    }

    do
    {
      signed int return_value_getpid_9;
      return_value_getpid_9=getpid();
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "xnbd_proxy (pid %d) remote %s:%s, cache %s (%s), ctl %s", return_value_getpid_9, xnbd->proxy_rhost, xnbd->proxy_rport, xnbd->proxy_diskpath, xnbd->proxy_bmpath, xnbd->proxy_unixpath);
    }
    while((_Bool)0);
    net_send_all_or_abort(xnbd->proxy_sockpair_proxy_fd, (const void *)"", (unsigned long int)1);
    shutdown(xnbd->proxy_sockpair_proxy_fd, 1);
    do
    {
      ret=main_loop(proxy, unix_listen_fd, xnbd->proxy_sockpair_proxy_fd);
      if(!(ret >= 0))
        break;

    }
    while((_Bool)1);
    proxy_shutdown_forwarder(proxy);
    proxy_shutdown(proxy);
    nbd_client_send_disc_request(proxy->remotefd);
    close(proxy->remotefd);
    g_free((void *)proxy);
    close(unix_listen_fd);
    unlink(xnbd->proxy_unixpath);
    do
      g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "xnbd_proxy successfully exits");
    while((_Bool)0);
    exit(0);
  }

  xnbd->proxy_pid = pid;
  close(xnbd->proxy_sockpair_proxy_fd);
  close(remotefd);
  char buf[1l];
  net_recv_all_or_abort(xnbd->proxy_sockpair_master_fd, (void *)buf, (unsigned long int)1);
  shutdown(xnbd->proxy_sockpair_master_fd, 0);
  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "xnbd_proxy gets ready");
  while((_Bool)0);
}

// xnbd_proxy_stop
// file xnbd_proxy.c line 754
void xnbd_proxy_stop(struct xnbd_info *xnbd)
{
  do
  {
    unsigned int return_value_g_list_length_1;
    return_value_g_list_length_1=g_list_length(xnbd->sessions);
    if(!(return_value_g_list_length_1 == 0u))
      g_assertion_message_expr((char *)0, "xnbd_proxy.c", 756, (const char *)"xnbd_proxy_stop", "g_list_length(xnbd->sessions) == 0");

  }
  while((_Bool)0);
  write_all(xnbd->proxy_sockpair_master_fd, (const void *)"", (unsigned long int)1);
  close(xnbd->proxy_sockpair_master_fd);
  signed int ret;
  ret=waitpid(xnbd->proxy_pid, (signed int *)(void *)0, 0);
  if(!(ret >= 0))
  {
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_ERROR, "(tid:0x%lx) (%-12s) waitpid %d, %m", return_value_pthread_self_2, (const void *)"xnbd_proxy_stop", xnbd->proxy_pid);

  __CPROVER_DUMP_L5:
    ;
    goto __CPROVER_DUMP_L5;
  }

  do
    g_log((char *)0, (enum anonymous)G_LOG_LEVEL_MESSAGE, "xnbd_proxy (pid %d) exited", xnbd->proxy_pid);
  while((_Bool)0);
}

